This paper introduces the concept of certified computation, where an algorithm not only generates a result "r" for a given input "x," but also provides a proof that "r" is a correct result for "x." This can significantly increase the trustworthiness of the result, as long as the axioms and inference rules used in the proof are trusted. The paper presents and analyzes two examples of certifying algorithms.

The authors have developed denotational proof languages (DPLs) as a unified platform for certified computation. DPLs seamlessly integrate computation and deduction, offer strong soundness guarantees, and provide versatile mechanisms for constructing proofs and proof-search methods. Many well-known algorithms have been implemented as certifiers using DPLs, including sorting algorithms, compiler optimizations, the Hindley-Milner W algorithm, Prolog engines, and more.

Fully verifying software systems through deductive proofs can be a daunting task. The challenge lies in mechanically proving that a complex piece of software will consistently produce the correct output for any given input. Despite the difficulties, formal proofs are an effective method for increasing reliability and could still be useful even when it's impractical to completely prove a system's correctness.

The algorithm outlined in the paper implicitly relies on two theorems. To explicitly prove the algorithm's correctness, the connection between the algorithm and these theorems must be made explicit. For static verification, strong induction on "b" can be used to demonstrate that for any given "a" and "b," "euclid(a, b)" produces "gcd(a, b)."

Athena, a higher-order strict functional programming language, is well-suited for certified computation due to its features such as freely passing around higher-order proof continuations. However, it is noted that other programming languages, such as Java, could also be integrated with the abstract syntax and semantics of DPL proofs in a conservative manner.

Users of DPLs have the flexibility to introduce arbitrary axioms, rules, and decision procedures and can decide where to anchor the proofs on an individual basis depending on the application's context. This approach can reduce the trusted computing base noticeably. Additionally, the paper discusses the tradeoff between its approach and static program verification, highlighting the advantages of each.

The paper advocates for certified computation, in which program results are derived deductively rather than being generated by arbitrary processes. The authors illustrate this approach with examples and demonstrate its feasibility through the development of DPLs, a class of languages that facilitate the formulation of algorithms as theorem provers. The theoretical foundations of DPLs have been extensively investigated, and an efficient implementation of Athena has been built to express many interesting algorithms as theorem provers.