In our research on test and verification of avionics controllers, our workgroup has detected various faults, errors, and anomalies. The next logical step is to categorize these encountered faults. Drawing from commonly used fault models in semiconductor fault diagnostics, we have applied these models and methods to develop a comprehensive strategy for identifying faults in distributed embedded systems within their respective environments. The methods, techniques, and tools described in this paper are based on prior investigations, which have been thoroughly documented.

When conducting system integration testing, network monitors are typically utilized to capture a portion of the data exchange between communicating controllers; for example, AFDX monitors and ARINC 429 monitors can record specific types of data packages. However, certain communications, such as the data exchange between redundant fault-tolerant controllers, may not be observable.

The fault tree created in the third step illustrates potential error hypotheses, along with the necessary boundary conditions for a hypothetical error to cause the observed failure at the interface between the system under test (SUT) and the testing environment. The fault classification for each component aligns with the fault models introduced in the relevant literature, and the fault tree construction technique outlined in the same source. In the diagnostic procedure, we exclude the possibility of an external intruder, as we are dealing with a closed system with well-known components.

If the hypothesis holds, an additional test stimulating v0 can be conducted. If it passes, it implies that v1 was not lost within the SUT. In our case, the hypothesis is confirmed by the SUT implementation, thus an additional test can be expected to flag the sensors as failed. If this occurs, we have proven that sensor state changes of sd5,6 are not lost within the SDCU. Since the SUT implementation aligns with the expected messages, a signal deletion error can be ruled out.

We conduct a test where sd5 remains continuously in the alarm state, while the state of sd6 toggles between standby and alarm. In a properly functioning SUT, an output compalarm=1 should occur only if sd6 is in the alarm state. The test log demonstrates that no compartment alarm for comp2 is triggered, as only sensor sd5 is in the alarm state, while sensor sd6 remains in the standby state, which is the anticipated behavior.

With the exception of the potential stuck-at-0 fault, all fault hypotheses can be eliminated through additional tests. Considering the internal structure of the SDCU, the global input variables sensorsdsalarm[] become visible in the processmessages() method. An additional unit test of this method uncovers the presence of a stuck-at-0 fault within this method.

Our experience indicates that it is feasible to pinpoint any type of fault by following the presented procedures and refinements. While the strategy for fault detection we have outlined is widely accepted for semiconductor error diagnostics, it is currently not prevalent in the realm of distributed embedded systems. Through the close integration of these procedures with the tool chain, we introduce a reliable and efficient testing approach. The tool chain, comprising the rt-tester, its user interface (rttui), and the interval analyzer, can be supplemented by tools like ReliaSoft's Fault Tree Analysis software for comprehensive fault tree analysis.