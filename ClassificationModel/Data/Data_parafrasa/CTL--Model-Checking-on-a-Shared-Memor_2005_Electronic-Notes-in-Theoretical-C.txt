This paper introduces a parallel algorithm for CTL* model checking on a virtual shared-memory high-performance parallel machine architecture. The algorithm, which is based on automata-driven and game-theoretic approaches, demonstrates parallel execution using dynamic load balancing to allocate work among processors. The effectiveness and practicality of the algorithm are demonstrated through performance graphs.

To examine the feasibility and challenges of parallelizing model checking for shared-memory multiprocessor computers, we investigated the parallelization of explicit-state on-the-fly model checking for both safety and liveness properties. Our research led to the development of a parallel model checker for CTL*, and we observed its practicality and effective speedup using shared-memory architecture. The performance of the parallel algorithm was evaluated theoretically and experimentally across various prototypical models, including correctness properties of the parallel model checker itself.

In this work, we build upon our prior research on parallel reachability analysis to present a parallel model checking algorithm for CTL* that leverages the dynamic load balancing technique from the parallel reachability analysis algorithm discussed previously. We also provide an overview of the parallel reachability analysis algorithm and then delve into the description of the serial automata-driven game-theoretic algorithm for CTL* and its parallelization in subsequent sections.

Our parallel reachability analysis algorithm is executed on n processes, with each process running on a dedicated physical processor. All processes share a single store for storing visited states, while each process has its unbounded private stack and a shared stack with a bounded capacity for storing unexpanded states. Additionally, a process can add states only to its private and shared stacks, but can steal a state from the shared stack of another process when its own stacks are empty.

Furthermore, the paper also discusses accepting runs, finite branches in runs, and the acceptance conditions of different types of alternating automata, providing insights into the performance of the parallel algorithm and its scalability with an increase in the number of processors.


Overall, the implementation of the parallel algorithm demonstrates excellent performance, as evidenced by its ability to complete the reachability analysis of a 100 million state graph in approximately 4 minutes on a single process and around twenty seconds on sixteen processes. Additionally, experimental results suggest that the algorithm's behavior remains favorable when the idle overhead is modified to reflect waiting times for accessing the shared stack.