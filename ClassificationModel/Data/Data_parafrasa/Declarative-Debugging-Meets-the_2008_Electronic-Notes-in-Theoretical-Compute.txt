The fundamental concept behind declarative debugging involves constructing a computation tree, also known as an evaluation dependency tree, that represents the computations performed by a faulty program. The structure of the computation tree is dependent on the nature of the errors that need to be diagnosed. Each node in the computation tree corresponds to the result of a computation step in the program and is linked to nodes representing the subcomputations that were carried out to produce the result.

When a program yields unexpected or incorrect results, its computation tree contains one or more erroneous nodes, whose outcomes do not align with the intended semantics of the program. Some of these erroneous nodes are the products of other faulty computations, while others represent genuine programming errors. These erroneous nodes can be recognized by the absence of erroneous children, indicating that their represented computation steps produce incorrect results from correct inputs.

This paper introduces a modification to the standard program transformation approach to address the limitations outlined above. The modification involves transforming functions in the IO monad in a specific manner, leveraging the fact that elements of the IO type are abstract and cannot be directly inspected by user-defined functions. By defining suitable adaptors for the primitive IO functions, it becomes possible to overcome these limitations. Most of these adaptor functions can be derived mechanically from the semantic model of the IO type, with predefined implementations necessary only for a few distinguished primitives. Notably, no additional non-standard primitives are required for their definition.

The subsequent sections of the paper are organized as follows: the next section provides a brief overview of the standard program transformation approach for identifying incorrect answers in functional and functional logic programming languages. The third section discusses monadic IO and the challenges it presents for the program transformation approach. Section 4 introduces the modified program transformation that integrates effectively with monadic IO, followed by sections presenting related work and a conclusion.

The debugger employs computation trees with basic facts at their nodes, each node being associated with a program rule used at the corresponding computation step. By pointing out the program rule connected to a buggy node as an incorrect program rule, the debugger assists in identifying faulty computations. The children of a node correspond to the subcomputations carried out while evaluating the guard and right-hand side of the program rule. Soundness and completeness results ensure that, given an incorrect answer, the debugger detects an incorrect program rule.

Various strategies have been proposed for creating and navigating computation trees. A well-established approach utilized in logic programming involves using meta-interpreters to re-execute the goal during the debugging phase, making the computation tree unnecessary. However, this solution is not applicable to languages such as Haskell or Curry, as they lack built-in meta-instructions. It has been observed that declarative logic languages are particularly suitable for these strategies due to the complexity of computation trees necessary for detecting missing answers and the occurrence of wrong and missing answers simultaneously.

In cases of missing answers, retention of the computation trees is unnecessary, given that the goal is to diagnose only incorrect answers. The error case corresponding to an exception condition where no answer is computed does not require the preservation of computation trees.

Overall, the paper proposes a modification to the program transformation approach that aligns well with monadic IO and effectively addresses the challenges associated with identifying incorrect program rules. The use of computation trees by the debugger assists in pinpointing faulty computations, contributing to a more effective debugging process.