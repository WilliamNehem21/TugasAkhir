The Maude system is an implementation of rewriting logic, which, along with various methodologies and tools, facilitates the design and analysis of systems. Currently, there are two approaches to modeling assembly languages. One approach involves the creation of a simplified RISC assembly language for verifying microprocessor elements, while the other approach focuses on modeling a limited subset of the x86 assembly language for detecting malware behavior. Both approaches prioritize verification issues over defining the language semantics. The language semantics definitions depend on the memory system specification at both the structural and functional levels. Our work complements previous research by proposing memory models for imperative and object-oriented languages, using rewriting logic for formal language definitions.

The K framework is a rewrite-based framework that allows for the definition of operational semantics of programming languages. It demonstrates its versatility by handling real languages such as C, Scheme, and Verilog. Our current work utilizes the K framework to define the assembly language, leveraging a subset of the language of interest. The K implementation, known as K-Maude, is built on top of the Maude system, providing access to the integrated technologies and tools offered by Maude.

The paper is organized as follows: Section 2 provides an overview of some concepts of the K framework as the assembly language is formally defined. Section 3 describes a modular system with a focus on main memory modeling and two possible instances. Section 4 presents the implementation and benchmarking specific details, while Section 5 contains the conclusions.

We offer practical insights into the K framework as we define the Simplified Scalar RISC (SSRISC) assembly language. We present a subset of instructions, including arithmetic-logic, branch and jump, load and store, and special error instructions, using specialized notation provided by K.

We also implement the semantics for a number of SSRISC instructions, covering arithmetic-logic, branch and jump, load and store, and program error-handling instructions. For instance, we define rules for addition instructions involving both integer and floating point operands, as well as rules for branch, jump, and break instructions.

Furthermore, we detail the execution of instructions that manipulate symbolic data addresses, outlining the transformation of instructions into integer register updates and introducing the concept of a communication module to facilitate easy extensions to the definition.

The SSRISC definition allows for underspecifying the memory content by using symbolic values for stored data, a feature that extends the specific built-in operations to handle symbolic values, which is utilized for abstract execution of programs for estimating timing bounds.

In addition, we discuss the implementation of the SSRISC assembly language in the context of programming language definitions in the K framework, emphasizing the communication module that allows for easy extension of the definition.

The paper also discusses implementing the MIPS-based assembly language of the SimpleScalar toolset, detailing the implementation of various instructions and memory modeling.

Lastly, we highlight the use of the SSRISC language definition as a basis for defining abstractions for timing analysis of embedded programs, specifically using non-labeled memory representation to contain useful information about actual instruction and data placement.