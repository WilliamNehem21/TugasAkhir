Constraints on the meta-variables and their instantiations lead to interdependencies among goals sharing these meta-variables. For example, if two goals, j and j', both contain a meta-variable mv, the instantiation of mv for goal j may render goal j' unprovable. In this situation, default backtracking in a proof planner like multi would remove goal j', although the actual problem lies in the selection of an appropriate instantiation for mv. Thus, part of the subplan for goal j needs to be revisited to introduce a new subplan instantiating mv differently. This meta-reasoning pattern is indicative of the need to reason about failures in mathematics and aligns with common techniques used in the field.

The complexity of knowledge engineering for proof planning has limited the success of tackling mathematical domains and problems using proof planning. Nonetheless, there is compelling evidence for the necessity of meta-reasoning about failures in mathematics, as demonstrated by meta-reasoning patterns that draw upon common mathematical techniques. For instance, the failure reasoning in the proof planner clam exploits failures to guide the introduction of case-splits, even in a different mathematical domain involving proving theorems by mathematical induction.

The meta-reasoning patterns offer heuristics for addressing failures that arise alongside partially successful steps in the proof planning process. These patterns not only help navigate around failures, but also play a crucial role in constructing a solution proof plan.

The flexible control in the proof planner multi enables failure reasoning and the subsequent modifications to the proof plan. Unlike a pre-defined systematic backtracking approach, strategic control rules, which encode heuristics declaratively, can analyze failures and dynamically guide refinements and modifications of the proof plan when failures occur. Furthermore, the meta-reasoning patterns are generally applicable, as evidenced by experiments, and can be leveraged to exploit the flexible control in multi.

In multi, failure reasoning is conducted by declarative and separate control rules, which are not specific to any particular method, and test for specific situations that may arise during the proof planning process, independent of the strategy or method that caused the situation. This is in contrast to critics, which are bound to failing preconditions of a specific method and include a patch of the failure implemented as a special procedure. The patch of a failure in multi is carried out by methods and strategies suggested by the control rules, rather than through specialized procedures.

Control reasoning in elaborate blackboard systems, such as the unblocking of desirable steps in multi, is akin to reasoning on the failure in these systems, which can suggest the invocation of knowledge sources to unblock desired knowledge sources.