The rest of this paper is organized as follows: In Section 2, we provide a brief review of previous work on concurrency and lock verification. Section 3 introduces the annotation language and methodology of the Verifying C Compiler (VCC) developed at Microsoft, which is used to annotate and verify our lock implementation. In Section 4, we present the reader-writer lock implementation, including its invariants and the specifications of its various functions. Finally, in Section 5, we present our conclusions.

Bornat et al. introduced an ownership scheme that permits shared readonly state. They provided a (manual) proof of a reader-writer lock implementation based on axiomatically defined semaphores in concurrent separation logic. However, their lock implementation is somewhat simpler and less efficient than ours, as it is based on semaphores and may also block when releasing a shared lock. There are also modeling issues related to the dynamic creation and initialization of locks.

The Verifying C Compiler (VCC) is a concurrency verifier for Concurrent C being developed at Microsoft Research in Redmond, USA and at the European Microsoft Innovation Center (EMIC) in Aachen, Germany. While VCC is not specifically designed for our lock example, it targets a wide range of programs and algorithms and is being used as a proof tool in the Verisoft XT project to specify and verify industrial software, including the Microsoft hypervisor Hyper-V.

In this section, we provide an overview of the annotation constructs available in VCC and the underlying formal model. We pay particular attention to concurrency in the context of our verification target and illustrate the methodology with small examples. For a more comprehensive introduction to the tool and methodology, we refer the reader to previous work, with a focus on concurrency.

The current version of VCC implements and enforces a Spec#-style object and ownership model, which has been shown to be more elegant and efficient than the low-level memory model supported in earlier versions. This model ensures that objects of the same type with different addresses do not overlap in memory. Each object is associated with metadata, including the owner, the objects it owns, its closedness, and its reference count. These fields control how objects can be accessed and when object invariants need to be assumed to hold.

Invariants can be annotated on objects of aggregate type (e.g., structures), ensuring that they hold for all closed objects and are checked when closing an object. Two-state invariants are used to restrict possible interference from other threads.

VCC supports call-by-reference specification parameters marked with the "out" keyword in function declarations and calls, which can help to reduce the burden on the prover.

Additionally, two-state invariants are needed to ensure that the lock stays initialized and that the protected object and the self claim do not change. These invariants require the use of "old(initialized)" instead of "initialized" on the left side of the implication to ensure they are fulfilled during the activation of the initialized state.

The "acquireshared()" function passes out a claim parameter for read access, which needs to be fresh, valid, wrapped, and unreferenced. This claim can be used in read accesses and volatile write accesses on the protected object. The "releaseshared()" function takes back the unreferenced claim and destroys it once it has been used.