Ensuring the accuracy of computer systems is an important area of research. While there are several instances where the correctness of individual computer components has been successfully established, the formal verification of an entire industrial-scale system is now at the forefront. Moore, the leader of the CLI project, has initiated the grand challenge of achieving pervasive verification of whole computer systems.

This study focuses on the issue of operating system microkernel correctness. A microkernel provides minimal operating system services and only the necessary mechanisms to implement such services. These mechanisms include process and memory management, address spaces, low-level IPC, and I/O, typically implemented as primitives - microkernel routines that provide functionality to upper layers. As every operating system service relies on these primitives, their correctness is of utmost importance.

This paper discusses the correctness concerns of primitives within an academic operating system microkernel and describes the successful application of the system software verification methodology developed in the Verisoft project to primitives implemented in C with inline assembler. It outlines the correctness criteria of microkernel primitives and explains what it means for a primitive to fulfill these correctness criteria, along with a general idea of how such theorems are proven. A case study elaborates on specific details of specifications and proofs within this context.

The microkernel in question implements the Communicating Virtual Machines (CVM) model, which defines parallel execution of concurrent user processes interacting with a kernel. The microkernel is divided into two logical parts: the abstract kernel, which provides an interface to a user or an operating system and can be implemented in a high-level programming language, and the lower layers, which implement the desired functionality. The low-level functionality's implementation includes assembler portions due to the inability of ordinary C variables to access processor registers and user processes.

The correctness of the primitives, implemented in the C0 programming language with inline assembler parts, and the CVM model semantics and correctness criteria are sketched. The memory of physical and virtual machines is conceptually organized in pages of P machine words.

The paper discusses the simulation relation, called the B-relation, specifying the parallel execution of user processes on one physical machine, and the formal specification of the linking operator, which relates the concrete kernel to the CVM model.

The verification environment for this work is based on the Isabelle/HOL theorem prover, with all the concepts and semantics formalized in Isabelle by colleagues in the Verisoft project. The source code of the primitives is translated by a tool into C0 small step semantics in Isabelle.

To prove theorems about the code, the paper describes creating separate lemmas of the same form but discussing the code in different semantics. These lemmas are proved by applying C0 and inline assembler semantics, with a focus on constructing a consistent C0 machine after the assembler part execution.

An example application of this approach is provided to demonstrate the establishment of the correctness of the "copy" primitive, which is intended to copy a specified number of words between processes, with the correctness justified by theorems specific to this primitive.

The paper concludes with the specification of the primitive and its implications on the user processes, concrete kernel, and underlying physical machine. It discusses the preconditions that must be satisfied for the result of the "copy" primitive to be well-defined and outlines the step-by-step changes to the physical memory.