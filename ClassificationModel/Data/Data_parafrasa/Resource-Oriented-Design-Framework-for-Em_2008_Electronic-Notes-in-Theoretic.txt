To achieve compatibility between hardware and software descriptions, codesign offers a framework for designing embedded systems that integrates both hardware and software without discrimination [3,8]. This approach partitions the system design into detailed hardware and software designs for implementation purposes. However, the implementation of codesigned software models is often hindered by issues related to the interaction between hardware and software, such as communication timing. Additionally, the behavior of embedded software generated from a codesigned system may deviate from the behavior of the original software model due to resource limitations which restrict the software's access to resources. Therefore, it is crucial to capture and analyze the behavior of embedded software that is constrained not only by communication timing but also by resource limitations.

Embedded system models can be categorized into structural and behavioral models. While software developers typically focus on the dynamic behavior of structural elements during system operation, addressing how to define hardware attributes such as time and resource constraints within the embedded system model remains a relatively unexplored area. Resources in computer systems encompass both physical and logical elements that are necessary for the processing of data by application software. Some embedded software requires physical resources such as power, bandwidth, CPU, memory, and I/O devices, while others necessitate logical elements like data structures, semaphores, message queues, and network data packets accessed via operating systems.

ROM defines software behavior in accordance with hardware constraints, presenting it as a property of the resource model. This software behavior can be validated against hardware constraints, with the resource model originating from hardware engineers who utilize hardware timing verification techniques to validate timing properties. Subsequently, the hardware model can be abstracted to provide hardware constraints to software engineers, who in turn construct their software behavior model based on the software-oriented hardware behavior model and verify it against the hardware model.

In resource-oriented models, there are three embedded system component models—software behavior model, software-oriented hardware model, and resource model—and two embedded system models—resource-independent model and resource-oriented model. Illustrating each property of resource-oriented models, we provide an example of a signal and gate control system.

In Example 6.3, the functionality of a gate control system is captured in the specification of ACSR. The gate initiates its closing operation when it detects an open state and receives a signal tick from a timer. If the green signal is on and the others are off, it proceeds with its actual closing operation by transmitting a signal "go" to the signal control software ('go, 1).closing).

The design discussed here aims to model a resource while explicitly defining the behavior of a hardware component. This approach focuses on capturing the exclusive use of a resource in the specification of ACSR. Meanwhile, resource-oriented design not only captures the exclusive use of a resource but also the specific impact of resource behavior on software behavior.