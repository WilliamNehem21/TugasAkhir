In addition to model checking, Hugo also offers support for animation and the generation of Java code from UML state machine models, using a similar implementation structure. Our goal is to ensure the correctness of the generated code in accordance with the properties validated from the Promela model. The current version is somewhat limited due to the requirement for guards and statements to be expressed in the respective host languages (Promela or Java), and because the model checker lacks some of the constructs supported by code generation. The structure of this paper comprises Section 2 introducing relevant UML notations, Section 3 explaining the translation of state machines to Promela, and Section 4 describing the verification of collaborations. Section 5 provides details on incorrect scenarios and the implementation of state machines in the system.

Each state of a state machine is represented by an individual Promela process. Two additional processes are dedicated to dispatching events stored in the event queue and handling transitions for each state machine. Communication among processes associated with a single state machine takes place via unbuffered channels, while the event queue is modeled as a buffered channel.

A state machine maintains an array of its states and two queues of pending ordinary and completion events. The event queue's length is set to a constant eventqueuecapacity, which can be increased if Spin reports a channel overflow. When a synchronous call event occurs, the sending machine includes its ID with the event and waits for notification from the receiving machine via channel chanscdone, indicating that the call event has been processed. The array sm holds the data for all state machines in the model.

As different state machines communicate exclusively through message passing, their internal operations cannot interfere with each other. Taking advantage of this observation, internal operations are executed atomically, guarded by a global semaphore (see the macros entermutex and exitmutex in the code fragment below). The semaphore is released after the execution of an rtc step and whenever events are generated during the execution of actions, resulting in a significant reduction in the number of states that Spin needs to generate.

A completion event is raised when a state completes all its internal activities. For example, a simple state completes its internal activity when both its entry action and its activity (if present) have terminated. A non-concurrent composite state completes when its active substate is a final state, and its activity has terminated. Finally, a concurrent composite state completes when all its regions have completed, and its activity has terminated.

To achieve a clear translation structure that can be easily justified by inspection, and to adapt to changes in state machine semantics for the forthcoming version 2.0 of UML, a programming approach to implementing operational semantics should make it easier to support the full range of UML constructs. Although Hugo does not presently support choice states, it is evident how they can be implemented, whereas they pose non-trivial problems for encodings based on static pre-computation.

The format of extended hierarchical automata has been widely used to define the semantics of statechart variants, and Latella, Majzik, and Massink have provided a semantics for a behavioral subset of UML state machines implemented in Promela. However, their approach does not directly support the verification of collaborations, and we have not been able to compare their model checker with Hugo because it appears to be no longer available. Additionally, their paper does not include activities, entry and exit actions, completion events and transitions, history states, and context. Furthermore, transition effects may only generate new events, limiting it to a single state machine.