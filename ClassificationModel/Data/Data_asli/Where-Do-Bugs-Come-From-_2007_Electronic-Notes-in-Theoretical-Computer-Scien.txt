the analysis of bug databases reveals that some software components are far more failure-prone than others. yet it is hard to find properties that are universally shared by failure-prone components. we have mined the eclipse bug and version databases to map failures to eclipse components. the resulting data set lists the defect density of all eclipse components, and may thus help to find features that predict how defect-prone a component will be.



so far, we found the best predictor for defect density to be the problem domain. this is inspired by a simple observation: some problem domains are more failure-prone than others. for instance, when working on the eclipse code base, we find working on compiler internals to be much more difficult and error-prone than, say, building user interfaces. this observation holds regardless of developer, programming language, or the complexity of the resulting code.



in general, software defects related to the usage of other components come to be by violating the constraints of these components. as an example, consider the internal data structures of a compiler, in particular the abstract syntax tree. this internal representation of the program has an enormous number of constraints, reflecting the syntactic and semantic properties of the programming language.



how to we determine implicit constraints? we must analyze the components for valid usages as well as their users for normal usages. we must find appropriate abstractions to tell valid from invalid usage, or normal from abnormal usage. we must find appropriate measures to tell which constraints are easy to violate, and which ones are not. and we must see whether such measures actually predict the defect-proneness of a module.



