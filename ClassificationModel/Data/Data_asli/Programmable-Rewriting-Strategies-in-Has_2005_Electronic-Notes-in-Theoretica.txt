related forms of programmable strategies permeate computer science. for instance, evaluation strategies without any traversal control are useful on their own in rewriting[7,4]. in theorem proving, one uses a sort of strategies as proof tactics and tacticals. in parallel functional programming, one uses a sort of strategies to synthesise parallel programs.



type genericm m= forall a. data a=> a-> m a-corresponds to tp m type generict= forall a. data a=> a-> a-transformations type genericq r= forall a. data a=> a-> r-queries



we used the combinator gmapt:: generict-> generict, which is the nonmonadic variation on alltp. the type of stop_tdtp says that this combinator takes a polymorphic function and returns one. we use the type aliases for readability; we could as well inline the forall types. as an exercise in versatility, we have reconstructed a more specifically typed scheme stop_tdtp. the original scheme involved the opaque type tp m, where m could be instantiated later to any instance of monadplus. the reconstructed scheme fixes the monad for the argument type to maybe, which allows us to guarantee success of the composed strategy(cf. the non-monadic result type generict).



attribute grammars strategies and attribute grammars are complementary in that the former are more operational, whereas the latter are more declarative. also, the former emphasise traversal, whereas the latter emphasise attribute dependencies. research on a possible marriage of strategies and attribute grammars promises interesting insights. alike strategies, attribute grammars are conveniently embedded into haskell.



xml& xpath next to language processing on the basis of syntaxes, strategies are thought to be useful for xml document processing. functional combinator libraries for xml processing do exist, but they lack the typing strength of functional strategies. it should be possible to use strategies as a means to provide the illusion of an xpath-like language for controlling fully typed xml transformations.



