we are interested in models of reversibility suited to functional programming languages. functional languages are interesting in a reversible setting for two reasons. first, they are easier to reason and prove properties about, which is a boon if we want to understand the logic behind reversible programming. second, they are not stateful by definition, which eases reversing programs. it is fair to say that existing reversible functional programming languages[20,34] still lack various desirable constructs familiar from the irreversible setting.



irreversible functional programming languages like haskell naturally take semantics in categories. the objects interpret types, and the morphisms interpret functions. functional languages are by definition not stateful, and their categorical semantics only models pure functions. however, sometimes it is useful to have non-functional side-effects, such as exceptions, input/output, or indeed even state. irreversible functional languages can handle this elegantly using monads or more generally arrows.



this paper aims to inform design principles of sound reversible programming languages. the main contribution is to match desirable programming concepts to precise category theoretic constructions. as such, it is written from a theoretical perspective. to make examples more concrete for readers with a more practical background, we adopt the syntax of a typed first-order reversible functional programming language with type classes. we begin with preliminaries on reversible base categories(in section 2).



this is analogous to how variable assignment works in the reversible programming language janus: since destructive updating is not permitted, state is updated by means of built-in reversible update operators, e.g., updating a variable by adding a constant or the contents of another variable to it, etc.



a similar approach to invertibility using arrows is given by bidirectional arrows. however, while the goal of inverse arrows is to add effects to already invertible languages, bidirectional arrows arise as a means to add invertibility to an otherwise uninvertible language. as such, bidirectional arrows have different concerns than inverse arrows, and notably do not guarantee invertibility in the general case.



