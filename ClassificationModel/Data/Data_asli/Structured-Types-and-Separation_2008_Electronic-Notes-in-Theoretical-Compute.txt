normalisation is motivated by the observation that padding fields are ignored when reading structured values from their byte representation. also, there may exist more than one byte representation for a value in c, even for primitive types. it provides us with a means to quantify over and compare c types.



additional rules can be given that allow one to dive inside a singleton heap assertion for a structured type value. this may be needed in extracting points-to information to aid in discharging guard proof obligations or side-conditions of some of the rules such as thm. 6.4 and is useful in allowing the granularity of an assertion to be changed.



compared to our earlier in-place list reversal example, the proof script was about the same structure and size, 67 lines. in our experience, lifts and heap-updates can be reduced as above for type-safe c, freeing the user from this level of detail. however, a completeness result is not possible in this shallow treatment.



