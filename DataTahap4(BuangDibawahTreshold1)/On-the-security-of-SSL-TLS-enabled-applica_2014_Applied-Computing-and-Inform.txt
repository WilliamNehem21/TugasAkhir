Abstract SSL/TLS (Secure Socket Layer/Transport Layer Security)-enabled web applications aim to provide public key certificate based authentication, secure session key establishment, and symmetric key based traffic confidentiality. A large number of electronic commerce applications, such as stock trading, banking, shopping, and gaming rely on the security strength of the SSL/TLS pro- tocol. In recent times, a potential threat, known as main-in-the-middle (MITM) attack, has been exploited by attackers of SSL/TLS-enabled web applications, particularly when naive users want to connect to an SSL/TLS-enabled web ser- ver. In this paper, we discuss about the MITM threat to SSL/TLS-enabled web applications. We review the existing space of solutions to counter the MITM attack on SSL/TLS-enabled applications, and then, we provide an effective solution which can resist the MITM attack on SSL/TLS-enabled applications. The proposed solution uses a soft-token based approach for user authentication on top of the SSL/TLS’s security features. We show that the proposed solution is secure, efficient and user friendly in comparison to other similar approaches.

Informally, not all SSL/TLS-enabled applications require client’s authentica- tion as long as the server gets paid off for the client’s service. This optional client’s authentication in SSL/TLS-enabled application opens up a potential security loophole to attackers (Oppliger and Gajek, 2005) who could try to convince a na- ive client with a fake server certificate and if he succeeds, he would be able to cap- ture all sensitive data from the client. This type of attack usually takes the SSL/ TLS-enabled communication into some vulnerable state by tampering the security indicators and making the user believing that the connection is established with the legitimate server, but the client is actually connected to the attacker’s server. For example, suppose the attacker produces a fake server certificate in place of the legitimate server certificate and the client accepts the fake certificate without checking the correctness of the certificate. After that, when the client wants to con- nect to the same legitimate server (for which the client has already accepted the fake certificate), the client will be routed to the attacker’s server. This type of at- tack is known as MITM attacks on SSL/TLS-enabled application. Recently, SSL Stripping attacks (Marlinspike, 2009), (Shin and Lopes, 2011), (Zhao et al., 2012) also pose a serious threat to defeat SSL/TLS protection to web application. In SSL stripping attack, the user believes that an SSL/TLS connection has been

We discuss the existing solutions to counter the MITM attacks on SSL/TLS-en- abled applications. As most of the solutions consider the client authentication as an important factor, we discuss the solution space for password, graphical user interface, and token-based approaches for user authentication. We then present an efficient solution using soft-token based client’s authentication that can resist SSL/ TLS-enabled application from MITM attacks. We analyze the proposed solution for its security feature on top of the SSL/TLS protocol security, and provide its efficiency in comparison to other approaches.

The remainder of the paper is organized as follows. Section 2 reviews the SSL/TLS protocol, discusses MITM attacks on SSL/TLS-enabled application, and outlines existing solutions for MITM threats on SSL/TLS-enabled transactions. Section 3 presents the proposed solution for securing SSL/TLS-enabled application from MITM attacks. Section 4 analyzes the proposed solution and compares the pro- posed solution with related approaches. We conclude the paper in Section 5.

An MITM attack is a form of active attack in which the attacker intercepts and selectively modifies intercepted data in order to impersonate a legitimate party involved in client and server communication. Based on intended services and busi- ness perspectives, several SSL/TLS-enabled web applications do not employ client authentication as a requirement, instead the web applications enable SSL/TLS in server authentication mode. The reason behind this is justified by saying that the server delivers services as long as the client pays the required amount to the server (e.g., online shopping facilitated by Amazon, eBay), so the client authentication is not required for such scenarios. Therefore, it is client’s responsibility to check whether s/he is talking to the correct server or not. In SSL/TLS protocol, on re- ceipt of the communicating server’s certificate, the client may get a warning if any of the following occurs: (i) the Root Certifying Authority (CA) is not recog- nized (or trusted) by the client; (ii) the certificate is invalid/expired; and (iii) the common name (CN) of the certificate does not match with the Domain Name Server. In such cases, the client should check for a possible reason and drop the connection if not convinced with the warning message window. It is observed that

most of the time the client does not pay attention to such an important warning, and accepts the exception and stores the server’s certificate in its specified location. Once the client stores a fake certificate in its memory, the damage has been done, as s/he is going to talk to a fake server though the connection is protected by SSL/ TLS protocol. This type of situation opens up a door to MITM attacker (Burk- hold, 2002) on SSL/TLS-enabled application. Another potential scenario is the stripping attacks (Marlinspike, 2009; Shin and Lopes, 2011; Zhao et al., 2012) on SSL-enabled web applications. SSL stripping attacks assume that an attacker is present in the middle of the victim and the server.

In (Li and Wu, 2003), authors proposed a tamper resistant TrustBar in the browser to visualize the certificate information. In Ye and Smith, 2002, a concept of synchronized random boundaries has been proposed so as to distinguish be- tween the authentic parts of the browser’s GUI and the rendered content received by the server. Another approach that needs fewer changes at the browser is the use of dynamic security skin (Dhamija and Tygar, 2005), where the browser has a per- sonalized area which needs to be customized by the user according to his/her will. It is believed that the attacker cannot spoof the personalized area without knowing the exact specification of the area. We now discuss some approaches for user authentication on top of the SSL/TLS protocol security strengths in order to mit- igate the MITM attacks on SSL/TLS-enabled web applications.

Password-based user authentication is widely used in many real-world applica- tions. Saito et al. (2008) proposed a protocol for binding the SSL/TLS session with the client using the user’s password. Saito et al’s protocol binds HTTP authenti- cation over SSL/TLS in server authentication mode. As HTTP authentication does not encrypt its channel and client does not authenticate the server, binding

the client’s authentication over SSL/TLS in the server authentication mode can make the communication secure. The interesting feature of their protocol is that it binds user authentication without modifying the SSL/TLS, HTTP and HTTPS protocols. The protocol works as follows. Client and server first establish an SSL/ TLS connection in the server authentication mode. After that the server authenti- cates the user by using HTTP authentication in arbitrary time. However, the ser- ver can control timing to obtain user’s password. This is a convenient feature than the fixed timing of authentication in SSL/TLS Handshake. In order to meet these goals, Saito et al’s protocol works with the following steps:

The symbols CN, MAC, Km, Ke and h(.) indicate Common Name in the server certificate, Message Authentication Codes, MAC key, Encryption key and hash function, respectively. Messages A1–A5 represent the SSL/TLS handshake proto- col. With the Handshake protocol, the client and server establish a master secret key by which they can derive MAC key (Km) and encryption key (Ke). The mes- sages B1 and B2 involve user authentication steps using HTTP and encryption key Ke. The messages C1 and C2 involve user’s password. The server locally com- putes h(CN, cert, h(user_id, password, Km)) and compares it with the one received in C1, while the client computes h(user_id, password, h(CN, cert, Km)) and com- pares it with the one received in C2. If they validate the received content success- fully, then they believe that the communication is mutually authenticated. With the step (iii), the protocol Saito et al., 2008 can bind the client’s authentication using the user’s password which can avoid the MITM attack on SSL/TLS session in the server authentication mode.

sequence of clicks on an image. There are other variants which work in similar ways (e.g., clicks on an image or draw a secret picture). Instead of using only textual password, graphical password can employ bidirectional authentication, where the server provides its authenticity to the user by displaying user’s graphical password, which was chosen by the user at the time of his/her registration. Upon confirmation, the user authenticates to the server using a kind of challenge- response mechanism. Although, the GUI-based approach provides some resistance to MITM attacks, the mechanism cannot survive once the adversary captures user’s graphical password.

OTP manual (e.g. Scratch card): A piece of paper or card containing OTP. The OTP must be securely printed and mailed to the customer. Using the OTP the user can login to the system and after that the OTP has no value. In other words, the adversary cannot do anything by knowing the OTP once it is used, as the user is going to use a different OTP for the next time.

OTP synchronous (e.g. Hardware/Software token): The time-synchronized OTP is same as SecurID, a hardware/software token, where each user is given a personalized token that generates an OTP every 30 or 60 s. The token’s clock must be synchronized with the clock of the server.

OTP asynchronous: In this case, the authentication server generates a ran- dom challenge and sends it to the user. The user enters the challenge into his/her token, which in turn, generates a result based on the challenge and some seed/secret value stored in the token’s memory (which is known to the authentication server). Then the user sends the result back to the authen- tication server. Here, the challenge is valid for a short time decided by the server, and only the authentication server needs to keep track of the validity period. The advantage of the OTP asynchronous is that the clock of the user’s token and the authentication server does not require to be synchronized.

Token-based user authentication employs two-factor authentication mechanism. User enters his/her PIN and the token generates a 6-digit or 8-digit random code, which the user enters into the authentication server used for intended application. The authentication server computes the code on its own and checks whether user’s code matches with its code or not. Both the user and the server should be in the same clock drift in order to accept user’s token generated code. RSA SecurID (RSA SecurID, 2010) is a standard reference for token-based two-factor authen- tication, which has got enormous acceptance in industry and Government sectors. One can also integrate token-based user authentication to SSL–VPN enabled application for strong authentication purpose. Since the token generated code is random in nature, the MITM cannot use it for the next run by retransmitting it to the server, which will be discarded by the server. Some implementations of the SSL/TLS session-aware user authentication have been proposed in Oppliger et al. (2006, 2008) that provide the following two ways:

Hardware-token based implementation: This approach employs impersonal tokens (that is, tokens which are not user specific) with token specific secret keys. These impersonal tokens are used for user authentication to the ACE server (RSA SecurID, 2010). The token has a small display on which the user enters his/her PIN and generates the code. The code is then used to authenticate the user. Although the approach provides security against MITM, employing such token-based implementation increases complexity and also requires extra cost.

The SSL (ver. 3.0)/TLS (ver. 1.0 or later) protocol provides server authentication, session key establishment and data confidentiality security services. In addition to these security services, the proposed protocol provides additional security measure for user authentication code checking using pattern matrix. The pattern matrix was selected by the user at the time of registration process and stored it securely at the server. When the user wants to connect to the server s/he has to select the appropriate patter code from the displayed pattern matrix on the legitimate server. Without knowing the pattern matrix chosen by the user, the attacker

In SSL/TLS server authentication mode, the client receives the server certificate through the server_hello message. Upon seeing the server’s certificate, the client can check its validity (by checking the issuer, subject, validity period, trust chain, purpose of the certificate) whether s/he is interacting with the correct server or not. However, the correctness checking of the server certificate by a naive user is a bot- tleneck. Moreover, if the client (i.e., browser) accepts (or stores somehow) a fake certificate of the (attacker) server then the user’s password will get leaked to the attacker, because the user will enter his/her password after establishing the SSL/ TLS connection to the attacker server in believing that s/he is talking to the correct server. Below we show that how the proposed protocol can counter this threat by authenticating the client on server stored client’s information.

Many SSL/TLS-enabled applications do not employ public key certificate based client authentication. The reason behind is that the client’s authentication is not required for such applications. Other possible reasons are: (i) employing public key certificate for client’s authentication increases computational cost; (ii) client is required to buy certificate from a trusted authority; (iii) mobility issues for client certificate that is, if the client wants to access the server from different places across several machines or browsers, then the client has to carry its certificate in a device. Now if the server imposes client’s authentication as a mandatory require- ment then instead of using certificate based client authentication one can use a soft-token based approach. The proposed solution is based on soft-token for client authentication on server stored client’s information, which can avoid the MITM attack on SSL/TLS-enabled applications, as explained below.

Suppose that an attacker attempts to mount an MITM attack by impersonating a user who wants to access a server enabled with the SSL/TLS protocol. We as- sume that the attacker establishes the SSL/TLS session with user and another SSL/TLS session with the server who hosted the SSL/TLS-enabled application. In the scenario between user and attacker, the attacker presents a false token to the user and asks for the UID and AC. Then, the attacker forwards the UID to the server so as to spoof the user. In this situation, the server will abort the session, as the server can identify that the AC given by the user does not belong to the same SSL/TLS session as the server sees a different hash of SSL/TLS messages. Further- more, the user is not revealing her/his credentials at any stage. Therefore, the at- tacker cannot get user’s pattern code PC in order to impersonate the user. The scenario is depicted in the Fig. 4 (K1 and K2 are SSL/TLS session keys), where the attacker will not be able to succeed in gaining anything, as two different values

of ACs for the two different sessions are being executed by the attacker while inter- acting with the user and the server. Even though the attacker submits a fake server certificate to the client and if the client accepts it, the attacker cannot gain any- thing from the client as the attacker does not have any knowledge of the user’s AC stored in the server. Therefore, MITM attacks cannot work in the proposed solution.

The session key of the proposed protocol is generated by pre-master secret key, client and server’s random numbers, and other session specific parameters. If an adversary intercepts messages from the current or previous run of the protocol and tries to replay any messages in a new run of the protocol to get access of the server, then the adversary will not be succeeded because the server will discard the request as the messages will not pass the freshness property. The usage of ran- dom numbers of client and server in the session helps in resisting the replay attack. Therefore, the proposed protocol is not vulnerable to replay attack.

In the conventional password-based user authentication protocol, attacker at- tempts to guess user’s password by intercepting messages between the user and the server. Once the attacker guesses the user’s password correctly, he will then impersonate the user for gaining access to the server. In the proposed protocol, the user password is not communicated to the server. Instead, the user generates an authentication code AC using the patter matrix chosen by the user at the time of registration to the server. This avoids password guessing attacks in the pro- posed protocol. In other words, the proposed protocol prevents the password guessing attack.

The proposed solution is also usable. The user is required to input the AC and then s/he will be able to see the PC chosen at the time of registration. The ap- proach does not require registered user to carry any device/token while s/he is roaming from one place to another place. Only thing s/he requires to remember at the time of connecting to the server is her/his patter code PC, which is similar to remembering a password.

We have discussed about the MITM threat to SSL/TLS-enabled web applications. We reviewed the existing approaches for user authentication and proposed a soft-token based user authentication. By enabling the proposed solution in SSL/ TLS-enabled web application, the MITM attacks can be avoided. The proposed solution requires a trusted display (controlled by the legitimate server) on the browser to render the compressed value of the hash of SSL/TLS handshake mes- sages. The proposed solution is computationally efficient and provides additional security on top of the SSL/TLS protocol’s security strength.

