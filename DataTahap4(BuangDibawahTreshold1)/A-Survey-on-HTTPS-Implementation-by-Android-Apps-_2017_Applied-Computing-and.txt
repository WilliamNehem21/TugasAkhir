Abstract As more and more sensitive data is transferred from mobile applications across unse- cured channels, it seems imperative that transport layer encryption should be used in any non- trivial instance. Yet, research indicates that many Android developers do not use HTTPS or violate rules which protect user data from man-in-the-middle attacks. This paper seeks to find a root cause of the disparities between theoretical HTTPS usage and in-the-wild implementation of the protocol by looking into Android applications, online resources, and papers published by HTTPS and Android security researchers. From these resources, we extract a set of barrier categories that exist in the path of proper TLS use. These barriers not only include improper developer practices, but also server misconfiguration, lacking documentation, flaws in libraries, the fundamentally complex TLS PKI system, and a lack of consumer understanding of the importance of HTTPS. Following this discussion, we compile a set of potential solutions and patches to better secure Android HTTPS and the TLS/SSL protocol in general. We conclude our survey with gaps in current understanding of the environment and suggestions for further research.

In the lowest level, SSL functions in the following way depicted in Fig. 2. The client sends an HTTPS request to the server with its SSL version number and supported ciphers. The server responds with its SSL version number and ciphers as well as its certificate. This server certificate has been signed by a trusted certificate authority (CA) which has verified the servers authenticity. The client will compare the certificate’s public key to its local key store and the field values to expected values. If the certificate passes, and the certificate has not been revoked by a CA (as determined by a query to a CA’s certifi- cate revocation list (CRL)), the handshake continues. The cipher suite is chosen from the algorithms which the client and server have in common. An example cipher suite could use ECDHE for key exchange, RSA for certificates, AES128-

Assuming that the device had the proper certificates installed, this code in lst. 1 would be operational. The URLConnection API takes care of hostname verification and certificate management. Besides the URLConnection API, other libraries and middleware have been developed for application designers which manage these components. More customization is available in the Java Secure Socket Extension (JSSE) which comes packaged with Java [32]. Other common libraries include OpenSSL [11] and GnuTLS [33]: C-based frameworks for SSL/TLS implementation. Higher-level wrap- per implementations of these SSL/TLS libraries include cURL

As seen in Listing 2, messages are hidden from users and the application continues as though it has a secure connec- tion[24,8]. Again, overriding errors thrown by the system defeats its purpose and mimics the insecure manner in which users click through SSL errors in the browser. However, unlike in desktop browsers, this case comes with the repercussion of never presenting the user with options for their own security.

which users received when accessing Facebook were forged. These false certificates were invalid and should have been cast away, but users still followed them or the application which accessed the website did not throw an error, thus falling victim to a man-in-the-middle attack. As Moxie Marlinspike has shown with his tool sslsniff [42], automated MITM attacks are simple to carry out. The susceptibility of the physical layer of mobile communication to eavesdroppers only raises this risk. Android HTTPS development is in a bind. While devel- opers want to have a secure system for their users, several fac- tors within and without their control complicate proper implementation of end-to-end encrypted communication. Why aren’t Android developers using HTTPS? Why do exist- ing SSL implementations remain insecure? In the next section, we will analyze factors which have been identified in the cur- rent Android development process and SSL/TLS ecosystem which keep HTTPS from reaching the ideal security that it is often claimed to be.

In this section, we will look into the issues which compromise the security of SSL/TLS implementations, in particular, on Android-based devices. First, we will look at the primary causes of SSL insecurities with current Android HTTPS imple- mentations. Even though the only guidance afforded to devel- opers hoping to secure their applications are a few weakly enforced frameworks in the Android system, security must be built by manually integrating custom security features into the project while retaining a functional and cohesive form. This process can be ad hoc, prone to error, repetitive, and inex- act [43]. As shown in the previous section, vulnerabilities and holes are rampant and actively exploited. The first step in patching these flaws is determining their origin. There exist issues rooted in the mobile app development paradigm, server configuration, Android documentation, SSL/TLS libraries, the SSL/TLS protocol, and application consumers. Extensive research has gone into determining the root cause of each of these factors. This section will investigate each of these causes further.

Among the papers reviewed, the most commonly reported flaws in HTTPS configuration were due developer negligence. One such problem is debug code being left in production appli- cations. this problem isn’t new and it has been listed in the Common Weakness Enumeration [44]. Leftover code and snip- pets that bypass standard procedures to make the an app oper- ational in development have a widespread effect on application security [8]. Ironically, leftover debug code can violate the pro- tections which the system it models is supposed to afford. HTTPS is not immune to development glitches where the author of a program either leaves vulnerable code or places an intentional override in their application, especially on Android. This could come in the form of a situation where, in order for an application to populate and display data for the developer, the certificate validation must be set up to allow a stream of data from a mock server. This allows for the author to assure the other components of the application are properly functioning, but leaves the HTTPS connection vul-

nerable unless the certificate checking is turned back on. This happens with unfortunate frequency since there are simple mechanisms which we will later discuss to prevent uninten- tional remnant debug code from emerging in production appli- cations. Developers want top level security, but also desire their product to function properly in development [24]. This creates an issue with a complex setup like SSL/TLS. As explained earlier, the most crucial part of an HTTPS commu- nication paradigm is the existence of valid certificates and rec- ognized certificate authorities. When running both the server and the application, developers may build their server with self-signed certificates for development and forget to change the application’s validation process when they do get the proper CA-signed certificate or bypass this for alternative rea- sons [39,45]. Running an application without SSL/TLS protec- tion while debugging is obviously harmless, but once these apps are open to the general public, there is extreme risk of data theft. Beyond inspecting the code itself, speaking to devel- opers about their mistakes and security bugs yields a more thorough look into the cause of these developer-based flaws. A study conducted by Fahl et al. [24] showed a few trends among the developers surveyed.

Developers make mistakes. Upon contacting the devel- opers at fault, many took the advice and fixed their mis- takes. Others, however, refused to admit that the flaw was an issue [39]. These mistakes are understandable. Android is a complex system and public-key cryptogra- phy is not a easily grasped even with high-level libraries. The startling rejection and denial made by developers in this survey may be a result of embarrassment at incor- rectly implementing code. However, for applications made by developers both willing and unwilling to admit fault for SSL misconfiguration, it seems apparent that there was a failing in code coverage in the development process.

[14] found that while many of the participants in their experiment had a general knowledge and awareness of software security, there were gaps between this knowl- edge and the actual practices and behaviors that their participants reported. Despite general knowledge of security, they were not able to give concrete examples of their personal security practices. In the same study, Xie et al. noted that there was a prevalence of the ‘‘it’s not my responsibility” attitude. The developers often relied on other people, processes, or technology to han- dle the security side of the application. When these soft- ware authors are so busy with the pure functionality and viability of their product and the approaching deadlines, it is obvious that the security hat looks much better on another member of the team. Unfortunately, code review and quality assurance only go so far, especially when looking at an application retrospectively. In an ideal situation, security is considered in every step of the development process from the design through the deployment. As evidenced by this report, this is not the case in many development environments.

order to solve errors. One such website is Stack Over- flow [46]. Typically, errors solved are caused when the developer who has posed the question has incorrectly written a chunk of code. In these situations, Stack Over- flow operates in an important, positive way. However, in

the case of SSL errors, the most trivial way to stop the errors without configuring the server is to stop the appli- cation from throwing the errors. Figs. 3 and 4 show an example of an Android SSL certificate expiration over- ride. While most respondents explain that these solu-

tions should not be used in production environments before giving a sample override, some answers, such as the one shown in Fig. 4, do not provide that context. This answer has received negative feedback most likely for this reason. However, given almost 10,000 views, this solution has almost certainly ended up in a developer’s production application. Thoughtful answers are often mixed with less security-oriented responses on these websites, allowing harmful programming paradigms to develop online.For instance, a developer may ask for a way to get past the UntrustedCertificate error in Apache’s HttpClient and the answer may be to use a custom SSLSocketFactory to trust all hosts [47]. Of course, those who answered the question or other com- munity members may stress how this should not run in production, but the solution is still presented in a fash- ion that a desperate developer can quickly find a work-around. Websites such as Stack Overflow don’t encourage app designers to customize their SSL/TLS implementation to use self-signed certificates and accept all hosts in production, but they do show developers how to use them in testing [39]. Stackoverflow cannot be blamed nor can the open-door style of development which Android possesses. The fault in these situations are the developers who either forget to remove the work-around code or just ignore the warnings on using accept-all policies in production applications.

line approaches, proper security can be an unfortunate sacri- fice when a client’s main focus is functionality and design [14]. Besides a missing understanding of HTTPS standards, these external constraints potentially hold the most sway over the correctness of a developer’s solution. Developers are faced with pressure, deadlines, an imperfect support system, and the complexities of public key infrastructure and Android. Mis- takes and misconfigurations are bound to arise in this system. When user data must rely on this stressed authorship, there are serious implications. While applications created by these devel- opers are the breaking-point in this system, there are several more causes both for developer mistakes and general insecuri- ties in Android SSL connections.

oper works on a psychological level is not a feasible solution and remains out of the purview of this paper. Those seeking to make developers more astute at securing their SSL imple- mentations must focus on support tools and resources. In this section, using ideas from other platforms and contexts, we will discuss a few of the ideas and subject areas which have seen solutions proposed.

Tendulkar et al. also suggest removing the ability for develop- ers to override SSLErrorHandler [8]. This prevents developers from hiding SSL error messages from the end user, forcing them to fix their code rather than obfuscate incorrect imple- mentations. Coupled with disabling of SSL checks when the DEBUGGABLE flag is triggered, half of SSL vulnerabilities could be prevented [8]. This does, however, restrict the pro- grammatic capability of developers and would make debug- ging much more challenging. Instead, warnings or errors could better announce the danger of leaving certificate check- ing out of the application.

Applications submitted to the Android market could be required to undergo scrutiny by MalloDroid [24] or the auto- mated fuzzing framework noted in recent work by Malek et al. [74]. Fuzzing, also talked about in other SSL testing research [37], would test the number of accepted certificates from ran- domly generated data in a way like Frankencerts [60]. Applica- tions with AllowAllHostnameVerifier [57] would be flagged. Another solution proposed by Enck et al. suggests Kirin [75] as a service within individual devices which would check appli- cations for dangerous permissions and malicious code. This could be refitted into a service which also verifies that applica- tions downloaded properly use HTTPS, flagging applications that use unsafe certificate verification methods or custom root stores. This device-based solution would not only protect a

phone from the Android Market, but also apps in open- source repositories like F-Droid [76]. This solution would not prevent developers from writing non-HTTPS code, but would stop these applications from reaching production mar- kets. Difficulties of implementing this include the setup and oversight required by market operators and the added restric- tions placed on applications which may not deal in sensitive data.

Developer misuse of SSL can be mitigated can also be miti- gated through better documentation and clearer APIs. Cases of unclear APIs are specific and should be continually analyzed and reported by the community. Consistent error reporting by APIs can aid in a better understanding of how developers should solve for SSL instead of against it [37]. Code analysis techniques and intelligent suggestions could be adopted by IDEs to check SSL implementations in real-time [58]. Further- more, Android platform maintainers with the help of the development and security communities need to create a more comprehensive and educational source of information on cor- rect implementations of HTTPS in both testing and produc- tion systems. One small example is that the Android ‘‘Preparing to Release” checklist should include information about removing debug code in applications and ensuring the application does not accept self-signed certificates [65]. Improving documentation is as close to improving the devel- oper paradigm as is possible. Updating documentation is not a trivial task and may take years to update across the entire ecosystem. However, new tools which aid in the development of SSL session creation should be sure not only to explain how to successful connection, but also the importance of prop- erly approaching the debugging vs production certificate man- agement situation.

In order to secure SSL implementations on every platform, SSL libraries and middleware with flaws in their validation and revocation checks mentioned in the previous section need to be patched. Design refactoring of current libraries should focus on hiding low-level code. A system similar to HTTPS Everywhere should be used in Android communication APIs [63,24]. As libraries are more and more utilized, their code needs to be scrutinized and brought into a state of security that is both forward-looking and all-encompassing. Large compa- nies which handle critical data should be contributing efforts toward the improvement of open-source SSL libraries and pro- tocols. Changes to libraries may roll out slowly across the SSL/ TLS ecosystem, but they would become the cornerstone of safe Android web development.

In a more specific sense, large mobile applications made by Facebook, Amazon, and Google have the ability to verify their own certificates in mobile applications and detect MITM attacks [41]. Certain companies which can spare the bandwidth and application space should look into origin bound certs (OBCs) [41] and the use of HSTS [15]. These fixes are more of a server-side change than anything, but their use can secure popular mobile applications. Depending on the success of these systems, APIs for third-party apps which hook into com- pany servers could also require clients to have certificates. This may prove challenging in scenarios where the application is closed source. However, even black box approaches [51] are able to identify certain patterns in SSL traffic that indicate unsafe SSL usage. The technology industry seems to under- stand the importance of SSL, but implementations of the strongest and arguably the most complex security measures in reality are rarely ideal.

Beyond issues with developers, the TLS protocol needs to revised to allow for further progress in technological security. IETF RFC 2818, Section 3.1 [61], which deals with HTTP over TLS, needs to be revised to be more strict on validation guide- lines. The protocol must require hostname and certificate val- idation and the community must adopt the strongest standard possible and implement it correctly. From there, applications which deal with user data can be built. The IETF [78] gives the following recommendations to certificate authorities and client developers:

which use it. The main limitation remains what direction would be the most sustainable solution moving forward, gar- nering both industry and academic support. While these increases in strictness will make the line drawn between secure and insecure architectures clear, it may pose an issue to devel- opers and users who are looking for performance and avail- ability over security. Suggestions for a warning escalation system may alleviate the pressure on developers and system administrators, much innovation and discussion remains before a proper certificate architecture that solves for both security and usability can be put in place.

Gaining user pressure on developers seems to be possible at this point to in only a few ways. If platform developers were to implement an effective non-HTTPS warning system in Android, the hands of developers would be pushed [24]. This would not alert all users, but it would alert those who are secu- rity conscious. Going further and preventing users from going to sites with misconfigured SSL/TLS forces developers to fix their authentication issues though it may inconvenience a user [72]. Less frequent and more accurate warnings may stop the end user from ignoring the errors since a user will obviously click through messages if they are bombarded with them [40]. The end user is most familiar with SSL when it gives them an error. These interactions need to be more meaningful and human-understandable. As with any security education, plac- ing proper importance on SSL/TLS will require concrete examples and explanations about why sites with broken certifi- cates should be avoided almost completely.

studied on such a scale. Another area of SSL ecosystem research which is not clear is the effect of implementing HSTS and OBCs on a modern cellular or wireless network. Finally, there is little research in the field of an Android implementa- tion of the DANE protocol and similar tools. Determining the effectiveness of these tools on the Android platform or as an extension in an Android browser is an important tool in deciding how to better secure HTTPS on Android and make it the standard protocol of the platform.

closed-source applications. Implementations of traffic finger- printing and analysis have been conducted [51,52], which give great insights to the way that various Internet services handle SSL overall. As mentioned in the work of Georgiev et al. [37], several open source libraries could benefit from a reworded API and stronger documentation. Another project which could originate from this survey would be an effort to present clear method names and contributions to these open source libraries. This would require strong collaboration with security experts in the community and further research into psycholog- ical implications of programming syntax. One of the more specific solutions for Android which could come from work existing on a desktop scale would be the implementation of CDNSEC [82], a Firefox add-on that demonstrates the DANE protocol, as an Android service. While this would serve a very specific purpose based deeply in the work of Liang et al. [15] and not so much on the SSL comprehension for developers, it would be the first step toward adoption of DANE and in extension, forward-thinking SSL security, on multiple plat- forms. Furthermore, the development of Convergence [71], a CA-free certificate validation system on the Android platform would allow for the promising protocol to expand and test the implications of the overhead on mobile phones.

A less technical research project could be conducted in a similar manner to that of Xie et al.’s survey of developers [14], but focus on asking developers what their major chal- lenges were in implementing HTTPS. Following the survey, the experimenters could look into the applications made by these developers to see how the SSL was implemented. Conclu- sions drawn from this would go into refining documentation, educational materials, and SSL libraries. Furthermore, devel- opers could be presented with a situation which requires an HTTP call in their chosen language. The experimenters would then record the comprehension of the developer, whether or not web resources were used, and how well this implementa- tion would withstand a MITM attack.

The development of a sustainable Internet-scanning service for security researchers would allow for further research into the shortcomings that still exist within the HTTPS protocol in its current form. This tool would be available to researchers, commercial entities, and security organizations in order to find holes to patch. The outcome would be much like the work of Durumeric et al. following Heartbleed [50], extensive notifica- tion of vulnerable entities with the hopes that these systems would be patched quickly. Further solutions will certainly arise for the Android platform as research into new protocols, lan- guages, and programming paradigms continues.

end-to-end transport security, listed the areas in SSL which need improvement, and presented the current proposals of solutions to these areas. It is clear that Android developers remain unable to properly use the protocol in their applica- tions due to reasons within and without their reach. Even in si- tuations where the implementation is syntactically correct, there can be flaws along the chain of communication or in the CAs which back up the trust web of SSL. User-facing applications, SSL libraries, protocols, and infrastructure have limitations which must be further investigated. Most notably, the areas of education and support tools for developers require research and resolution. Evaluation of the solutions presented by the papers was brought together in this survey and including them into the next set of TLS/X.509 protocols and versions of SSL libraries will ensure user data integrity and security in a mobile environment that continues to see growth in the amount of confidential data transmitted. From these solutions, developers will benefit and this will trickle down to end users.

