Most of the patter search algorithms in literature are mostly string based and do not concentrate on finding sequential patterns with constraints in a given database. Also in query languages such as SQL or MySQL, the select clause does not allow the use of the non-aggregate functions as part of query compilation. The objective of this work is to propose a pattern mining algorithm which may be embedded into SQL or MySQL Query languages so that we can search for presence of sequential pattern in the database. The algorithm makes use of sliding sequential patterns with three look-ahead elements in the event of any mismatch.

In this paper the idea is to first perform preprocessing of the sequential pattern before the search process. Instead of searching for a string based pattern, we perform search for a sequence of tuple or record values with user defined constraints. The elements of pattern considered are numerical type.

Most of the algorithms designed in literature are string based and are not developed by considering sequential patterns with constraints. An attempt is made in this work towards this direction by considering a time series database. We search for a sequential pattern of interest in a given database with each pattern element imposed with a user defined constraint.

The algorithm developed may be embedded in to any existing query languages so that the use of non aggregate functions is possible which makes the complexity of the query get reduced in terms of query processing and also the time efficiency. Section III, IV describes the proposed algorithm with a working example. The objective of this algorithm is to make the pattern shift by a length more than the pattern length as compared to the existing algorithms. The efficiency can be seen from the moves made by the pattern itself.

In [1] Wang and Kobayashi propose a pattern search algorithm for network security applications that computes a function called next before the start of the search process. The value defined by next is used in the event of a mismatch between the pattern and the text. In [8] the authors design a pattern search algorithm using two sliding windows. In [6] algorithm uses the concept of implications to find the relation between the pattern elements and is designed to find the sequence pattern in a given database. In [9] algorithm designed performs the two way pattern search using sliding patterns. The algorithm in [10] uses three sliding windows.

In the preprocessing phase failure functions are first computed. In case of any mismatch in the search process the algorithm uses three attribute values of the input present immediately after the aligned sliding pattern. These attribute values are called look ahead elements.

This phase consists of searching for the sequence pattern over a specific attribute or column in given database. Initially the pattern is aligned with left end and right end of the input database. Algorithm scans concurrently from both sides of database to find the presence of user defined sequence pattern. Initially, algorithm starts by searching for presence of the sequence pattern from left end of the database.

While searching from left if a mismatch occurs, the sequence pattern window is shifted rightward by a shift value defined by the left shift failure function. The algorithm now performs the search process by scanning from the rightmost end of the database moving towards left and if a mismatch occurs; shift-right failure function is used to shift the pattern towards left. Algorithm terminates when the pattern is found or the left and right indices over cross each other.

Step1: At start the sequential pattern is aligned with left and right ends of the input database. To reduce the number of comparisons made, only the terminal elements of sequence pattern are compared. If the dead end elements match with pattern elements then we compare other pattern elements.

Step2: When a mismatch occurs from left end of the database while searching from the left, algorithm uses shift-left function to shift the sequence pattern making use of three attribute values of the input database which immediately appear after the aligned left sliding pattern. Similarly, shift value is computed using right failure function if a mismatch occurs from right end of database. This process continues until first occurrence of sequence pattern is found in the input database from either side or until both indices of sliding patterns over cross each other. The detailed algorithm for the same is given below in fig 2.

First iteration: The search process begins by comparing pattern element at index=0 to the element of the inputdB at index=0. As there is a mismatch and also as all other cases violate, So left_shift failure function computes shift value as length(pattern)+ 3 = 7. The algorithm shifts sequence pattern to the right by 7 units. At the end of first iteration the algorithm makes the pattern indices from 0 to 3 aligned to indices of inputdB from 8 to 12.

Second iteration: Now the sequence pattern aligned at right end of the input database is considered for search process, pattern element at index 0 is compared with the database element at index 10. Since there is a mismatch, the immediate three attribute values to the left of the input database at indices 7, 8, 9 are considered to compute shift value using right_shift failure function. We stop the search process as there is a mismatch and start the search process from left end.

A sequential pattern mining algorithm with the pattern elements consisting of the user defined constraints is presented in this work. Failure functions are designed to handle the case of mismatch. The process of concurrent searching from the both ends of the database makes algorithm more efficient for the worst case situation when required sequence pattern is even at the end of the input. The reduction in the number comparisons done is visible from the best case move where algorithm shifts the pattern by a shift value greater than length of pattern when compared to algorithm used in [6].

