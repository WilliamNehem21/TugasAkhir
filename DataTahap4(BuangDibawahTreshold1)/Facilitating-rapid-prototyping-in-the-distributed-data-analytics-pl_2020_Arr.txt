Starting with MUC, the major difference is that this system exclu- sively targets cloud-only updates, while active-code replacement also addresses a potentially very large number of client devices. In MUC, each update leads to forking a new process that is executed concurrently. These processes are synchronized to ensure consistency. In contrast, in OODIDA, assignments are executed concurrently. Yet, as there is no continual processing, our problem is simplified. We thus replace code at any point but only execute it the next time it is called, which is after a batch of results has arrived. There is no need to concurrently execute an old version of the code as it would taint the state a computation if we combined results that were arrived at with non-identical code.

procedure than updating custom code for data analytics. In addition, Polus operates in a multi-threading environment instead of the highly concurrent message-passing environment of OODIDA. This is a funda- mental difference, which means that the approach of Polus could not be easily replicated in OODIDA. In essence, we spawn a separate process that uses custom code. In order to replicate the approach of Polus, we would need to update the existing process, which would make sand- boxing much more difficult. In our case, a spawned process handler that crashes due to illegal custom code, which should not happen to begin with, cannot take down the entire system. Instead, this process is terminated and the custom code discarded.

In addition to plans for future work on the OODIDA platform in general, we also have concrete ambitions for active-code replacement. The feature, as described, works as intended. Yet, we did point out some limitations and workarounds. The guiding idea is that the execution of custom code should be safe. One way of achieving this is by placing re- strictions on the provided code, such as only allowing certain return types. As of now, we only allow numerical values or lists of numerical values. This is sufficient for a very large number of data analytics tasks. Yet, in order to make active-code replacement more useful, we should extend the set of allowed return types. Related is the problem that we exclude certain Python libraries from being called. A further investiga- tion is needed in order to determine if a more fine-grained approach would make sense.

A major limitation of the current iteration of active-code replacement in OODIDA is that the user is not allowed to deploy additional libraries. However, as this is a potentially very useful feature, we would like to explore the possibility of creating sandboxed environments on the client, perhaps a solution based on lightweight containers via Docker [16]. This also refers back to an earlier note (cf. Sect. 3.7) on the current difficulties of reproducing deployments with custom code [17]. In fact, the idea of deploying a custom lightweight container to the client, which contains a custom sandboxed environment, seems promising. While this would arguably make custom deployments take more time, it would still be incomparably faster than the standard workflow for updating the client installation, as that is a decision the user cannot take by themselves and may take days or weeks, depending on organizational processes.

prototyping, largely achieved by automated deployment of the client installation. In reality, however, organizational bureaucracy and the demands of industry best-practices slow down this process a lot. In contrast, with the help of the active-code replacement feature, we pro- vide a safe and easy-to-use alternative that sidesteps such hurdles. Of course, we had to make some concessions by placing limitations on user- defined custom-code modules. Nonetheless, active-code replacement is eminently useful in practice as it enables data analysts working with OODIDA to pursue a highly interactive workflow, given how quickly custom code can be deployed on the system.

This research was financially supported by the project Onboard/ Offboard Distributed Data Analytics (OODIDA) in the funding program FFI: Strategic Vehicle Research and Innovation (DNR 2016–04260), which is administered by VINNOVA, the Swedish Government Agency for Innovation Systems. It took place in the Fraunhofer Cluster of Excellence “Cognitive Internet Technologies.” Ramin Yahyapour (Uni- versity of Go€ttingen) provided insightful comments during a poster presentation.

