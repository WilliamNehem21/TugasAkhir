This takes place, when capturing system requirements by properties in a logic language, for the expected behaviours and structure of a correct system design. While requirements are supposed to be independent from a particular system design, properties are expressed in terms of a formal model (i.e. an abstracted representation in a specification language with formal semantics) of the system under design and in fact constrain the system’s design. Properties derivation can be based on a language of property patterns, where each pattern has been assigned semantics in a logic language. Every single requirement is covered by properties that can be derived through property patterns associated with the specific patterns of the requirement’s specification and by associating the re- quirement’s concepts to events of the system’s formal model. This en- sures that all requirements have a consistent interpretation with respect to the system’s formal model. If the properties are not satisfied by the model, then a modified design (and model) has to be pursued or certain requirements that are not satisfied have to be refined.

The rest of the article is structured as follows. The next section dis- cusses the problems of ambiguity and underspecification in natural lan- guage requirements. Section 3 presents the recent advances on the ontology-based modeling of system requirements, their specification by means of appropriate pattern languages and the supported semantic analyses. Section 4 discusses the problem of requirement formalisation through the derivation of formal properties. This problem is related to the problem of system design and for this reason we also present the two main paradigms of model-based and component-based system design. Both design paradigms are relevant to the description of the four related tools in Section 5. Finally, Section 6 explains the limitations and the important challenges for applying a requirements formalisation/valida- tion approach to industrial-scale projects. The last section concludes the paper and discusses some more future research prospects.

attributes in a system context (e.g. function invokes function, system performs function). Fig. 1 depicts the domain-independent ontology that we used in [9]. These relationships characterise every concept instance of the domain-specific ontologies in the requirements and provide information for building the formal model of the system [18] and for deriving verifiable properties [9,19–21]. They also set a semantic analysis framework, which is used to detect missing information and potential inconsistencies.

Any omission detected by the mentioned analyses enacts a need of refining one or more requirements. The refinement of a set of re- quirements [25] consists of: (i) identifying what cannot be guaranteed or effected and (ii) augmenting or replacing them until they are fully veri- fiable. This can be ensured only after having derived formal properties that are really verifiable.

Example 1. This illustrative example was inspired from [26], where it was first used to demonstrate space system engineering methods for on-board software design. It refers to a generic first-in-first-out queue (FIFO), whose functionality is given in Fig. 2 as SysML natural language

The “concurrent readers/writers” and “element types” requirements refer to the FIFO queue interface, whereas the “implementation lan- guage” requirement to an expectation, which by definition cannot be rendered verifiable. All requirements, apart from the “implementation language” were manually imported in our requirements ontology using a boilerplate syntax similar to the one in [9]. Fig. 3 demonstrates how the P15 prefix and M10 main boilerplates were combined for specifying the “Writer capability” requirement.

The process followed to input requirements into the ontology is shown in Fig. 4. First, the boilerplates to be used from the list of existing boilerplates are selected and their placeholders are presented according to the attributes of their syntax. Each placeholder is then filled in using either a (sub-)class of the boilerplate attributes or an instance of that (sub-)class (Fig. 3).

All requirements with a (sub-)class as an attribute are noted as having missing information. Complete requirements (i.e., with instances in each placeholder) are analyzed by applying the mentioned analyses that provide warnings in a table (e.g. which attribute has not been instanti- ated by any requirement, conflicting requirements etc). Warnings prompt to edit, refine or add additional requirements and then to repeat the se- mantic analysis in the updated requirements. In this example, the results of missing information analysis prompted us to define the “full” and “empty” FIFO states.

Semantic analysis is based on the ontological representation of the boilerplate attribute values in Fig. 5 (relationships comply with the domain-independent ontology of Fig. 1). Note that this representation refers to concepts that do not exist in the boilerplate representation of the requirement in Fig. 3 (e.g. function_001, function_002, func- tion_003, flow_001). The reason is that the following two specifica- tion patterns are utilized.

First, in the main boilerplate, we refer to two different systems (i.e. the writer and the FIFO). This specification style, due to the used boilerplate, entails the invocation of two different functions; it is there- fore represented with the invokes relationship between the push function (in main), and a new function, say function_001. For the sake of understandability, we name function_001 as add, to express that

upon a push by the writer, the FIFO shall add an element to the queue. The second specification pattern concerns with referring to a state as precondition specified in the prefix. This style, due to the prefix boiler- plate, entails a representation according to Fig. 1, which assumes an

Due to the container, relationships of function_001 (including invokes) are applied to the container (function_003). We call function_002 as check NOT FULL, and function_003 as check NOT FULL and add. Fig. 5 eventually reflects the semantics: the writer performs a push, which invokes FIFO to check that state is not FULL and add element to the queue.

together with those provided by our ontology architecture. Any variation of this process is feasible if all completeness checks precede the rest of semantic analysis. Completeness checks may even take place concur- rently and interleave with the specification of requirements. From the discussion on the ontological representation of the requirement in Fig. 3, we see that completeness depends on (i) the relationships of boilerplate attributes (domain-independent ontology) and (ii) the boilerplates syn- tax and all concepts that are not explicitly referred as attribute values, but are inferred from them.

(EPS) of a spacecraft system for generating, storing, conditioning and provision of electric power to all satellite units. EPS is decomposed into subunits (Fig. 6), whose requirements have been expressed using our boilerplate syntax (and attributes in Fig. 1) as shown in Table 1. The main subunits are:

All requirements based on the M10 boilerplate (EPS-07, EPS-08, EPS- 17 and EPS-18) resemble the requirement of Fig. 3, where the main clause refers to two different system attributes of the boilerplate. Similarly to Example 1, the main clause representation includes (EPS-17 require- ment in Fig. 7) the invokes relationship between the function referred in the boilerplate and an additional function (shown as func- tion_001), which (the analysis warns that) should be instantiated and specified in another requirement. We call function_001 as process, in order to denote that ground control is expected to process telemetries upon receiving them.

Requirements that refer to a state in the prefix clause (EPS-10 to EPS- 13), similarly to the requirement of Fig. 3, introduce a precondition to a function occurrence. This semantics requires two additional functions, as in Fig. 8, since there is no direct relationship in our domain-independent ontology (Fig. 1) between any state and function attributes:

the different system attributes (AOCS or ground control and PCDU TMTC) in prefix and main, but it is based solely on the use of the function attribute in prefix. As shown in Fig. 9, the AOCS and ground control perform a forwards function, which invokes a process function performed by PCDU TMTC.

Finally, we highlight the role of a class of requirements, found in requirements documents, which cannot be expressed ontologically with the concepts of a domain-independent ontology. Instead, such re- quirements complement the domain-specific ontologies. Specifically, EPS-01 to EPS-06 are related to the design of the specified system and if they are not handled properly, they will cause warnings for detected noise or opacity.

Even if we can guarantee absence of semantic omissions in re- quirements specification, this does not mean that requirements are valid for an acceptable system design. They could be unsatisfiable or not realizable! The conjunctions and prepositions in prefix/suffix patterns cannot be evaluated over a declarative-style specification, such as that created by instantiating boilerplates using domain ontologies. We need the model of a system design, in a language with formally-defined opera- tional semantics. Then, from the various combinations of prefix, main and suffix clauses we derive formal properties referring to events and state variables of the model that correspond to the attribute values of the re- quirements. In component-based formalisms such as BIP [27] and the SLIM language (a subset of the Architecture Analysis & Design Language - AADL extended with behavioural models) of the COMPASS toolset [28], properties are specified in terms of atomic propositions that refer to specific components and their ports. Moreover, in SLIM, properties may also refer to error variables and states of error models [29,30].

which capture recurring problems in requirements formalisation. Pat- terns are used as a data input mechanism to specify properties; they are expressed based on a structured English grammar and they have formal semantics in logic languages. Each boilerplate is associated with a set of property patterns [9, 10], such that every possible requirement specifi- cation is covered by adequate properties. This is a prerequisite, for a logically consistent interpretation of requirements with respect to the model of system design.

where beg(M), occ(e1), obs(s1) are mapped to events (component ports) corresponding to the occurrence of the main specification (beg(M)), the occurrence of e1 and the observation of s1 in execution traces of the model of system design. P2.1 is a safety property, whereas P2.2 is a liveness property; for both, a formal semantics has been defined

in [32], where the author points out that a sufficiently high level of precision must be retained. The author examines the “simple” require- ment “When you pick up the phone, you get a dialtone” and provides four possible interpretations in Linear-time Temporal Logic (LTL) [33] with different levels of precision. It is eventually shown that for one who is not experienced in using temporal logic, it is unlikely to produce a precise formalisation of this requirement. Moreover, even when such a precise formalisation is achieved, it is impossible to recognize the initial speci- fication, where the property comes from.

A widely used repository of patterns for functional properties is re- ported in [31]. The semantics of these patterns [34] is defined in Computation Tree Logic (CTL) [35] and in other logic languages. Ac- cording to this approach, every property is specified using a scope (optional) and a property pattern. The scope (six different patterns) se- lects the subset of the model state-space, where the property is expected to hold; for the rest of the state-space, the property is undefined. The property pattern defines an expected occurrence of a given event/state (four different patterns) or the relative order of multiple events/states (four patterns) during system execution.

For extra-functional properties, the authors of [36,37] were based on the repository of [31], to introduce patterns for real-time specifications, while in [38] the authors organized them in a unified framework and introduced some additional patterns, which complete this repository. A different set of patterns for timing properties has been also proposed in [39]. Finally, in [40] the author has presented a repository of patterns for probabilistic properties, which have been used for real-world re- quirements focused on reliability, availability, performance, safety, se- curity, and performability.

However, for verifying extra-functional properties we need a model of the system’s design in a formal language with suitable semantics (e.g. timed automata for real-time properties, stochastic semantics for prob- abilistic properties). With respect to this, for the BIP language it is worth to mention:

From the preceding discussion, derivation of formal properties from system requirements is tightly intertwined with the system design, i.e. the problem of defining the architecture, the modules, the interfaces and the data in a system model. A widespread approach is the component-based design, in which system design takes place by integrating blocks of functionality called components that are coordinated so as to fulfill the system requirements.

(properties derivation). Due to the creative nature of this process, its obvious dependencies on two types of models and the form of the system design process (top-down vs. bottom-up design), human involvement cannot be vanished and therefore it can be only partially automated. In next section, we survey some noteworthy proposals of tool-support in recent bibliography.

In [11], the authors presented a tool called DODT that was developed in the frame of the CESAR project [10]. DODT allows for projectional editing and typing of requirements based on a boilerplate syntax (Re- quirements Specification Language - RSL), an attribute ontology and a domain-specific ontology. The ontology-based validation checks in [22] have been implemented, which allow detecting contradictions by pair- wise comparison of requirements, nouns that are not defined in the ontology and so on. Finally, a language of property patterns with formal semantics is supported. Although DODT does not implement an exact association of boilerplates with property patterns, in [10] the authors provide suggestions for patterns that could be suitable for capturing a given requirement.

The EARS-CTRL tool [58] was introduced to ensure by construction well-formedness of requirements written using the Easy Approach to Requirements Syntax (EARS) [13,14] templates. The tool checks whether a controller can be synthesized from a set of requirements. If a controller cannot be synthesized, it is possible that conflicting requirements exist. EARS-CTRL allows for projectional requirements’ editing, based on a glossary defined for the domain of controller synthesis. Requirements are analyzed as LTL formulas. The analysis effectiveness depends on user-defined semantic information (e.g. simple predicates) for the given glossary. Finally, model synthesis is limited to a fragment of LTL that involves the universal path quantifier, the next-step operator and the weak until temporal operator [59].

4.1. While editing requirements, the user interacts with underlying on- tologies by querying them and accessing their class instances for matching terms. In this way, the vocabulary of boilerplate attributes is restricted to terms that are identifiable within domain-specific ontologies and ontologies specific to the system under design. The boilerplate at- tributes relationships in Fig. 1 play a key-role in semantic analysis and property derivation, where each boilerplate has been associated with predefined property patterns that can formally capture it. For property enforcement, the user can choose among the available architecture pat- terns and parameterize them by selecting components from the incre- mentally built BIP model of the system. Then, the absence of deadlocks in the resulting BIP model has to be checked, which is proposed to take place using the D-Finder tool [60]. For the properties that cannot be enforced using the existing architecture patterns, the user will have to use external tools, such as the nuXmv model checker [61].

AADL model (e.g. subcomponents and port connections). The formal semantics of the system properties relies on the behavioural semantics of the SLIM language, whereas the logic used to define most of them is a variant of Metric Temporal Logic (MTL) [62]. While the taxonomy of formal properties is comparatively limited in expressiveness, it completely eliminates the need to choose a pattern and invent an instantiation. The formal properties can be analyzed for consistency among different abstraction levels of the system model or can be used as assumptions/guarantees of components for contract-based design. For the latter intent, COMPASS requires to further specify a contract refine- ment, which links a contract to the contracts of subcomponents. This al- lows to perform various analyses, such as the consistency or entailment for any subset of contract properties, to check whether the contract re- finements are correct, as well as to tighten a contract such that the refinement still holds.

formalise all system requirements that need to be validated. To a large extent, the expressiveness depends on the set of connective words sup- ported by the syntax of the pattern language and their meaning. A restricted set of connectives limits the language expressiveness, whereas a more extensive set of connectives may render impossible to completely avoid ambiguity in syntax and semantics. For enhanced expressiveness, it may be even necessary to assign multiple meanings to a connective word, which will have to be distinguished by the word’s position within the sentence. In any case, the syntax of pattern languages will have to be designed with extensibility in mind.

The effort needed to apply any of the reviewed processes/tools in an industrial project and their scalability potential raise important chal- lenges. Most of them have been applied to proof-of-concept case studies based on subsets of real requirements e.g. from space systems, but none has been applied to the complete set of requirements of a real industrial project. For such a project scale, the challenges to be addressed include:

We surveyed the recent advances in formalisation and early valida- tion of system requirements. A series of related industrial research pro- jects has delivered valuable experience on pattern languages for various types of requirements and on the derivation of formal properties. Requirement specification can be based on domain ontologies, which are used to identify missing information and eliminate inconsistencies and cases of underspecification. The properties derivation depends on a formal model of the system, which may be incrementally built through a component-based design process. We reviewed two related design par- adigms and we discussed the problem of formalising requirements within their context. Finally, we reviewed tools that were recently introduced, in order to address the mentioned problems.

The presentation of these developments allowed us to comment on their strengths and weaknesses. It was also evident that important limi- tations still have to be addressed, as well as open challenges associated with applying such an approach in industrial-scale projects. Apart from these prospects, open problems for future work exist on: (i) raising the level of automation for the formalisation and validation of requirements. and (ii) extending the applicability to more types of extra-fuctional re- quirements/properties.

Murugesan A, Heimdahl MPE, Whalen MW, Rayadurgam S, Komp J, Duan L, Kim B- G, Sokolsky O, Lee I. From requirements to code: model based development of a medical cyber physical system. In: Software engineering in health care. Cham: Springer; 2017. p. 96–112.

