Proper scheduling of air assets can be the difference between life and death for a patient. While poor scheduling can be incredibly problematic during hospital transfers, it can be potentially catastrophic in the case of a disaster. These issues are amplified in the case of an air emergency medical service (EMS) system where populations are dispersed, and resources are limited. There are exact methodologies existing for scheduling missions, although actual calculation times can be quite significant given a large enough problem space. For this research, known coordinates of air and health facilities were used in conjunction with a formulated integer linear programming model. This was the programmed through Gurobi so that performance could be compared against custom algo- rithmic solutions. Two methods were developed, one based on neighbourhood search and the other on Tabu search. While both were able to achieve results quite close to the Gurobi solution, the Tabu search outperformed the former algorithm. Additionally, it was able to do so in a greatly decreased time, with Gurobi being unable to resolve to optimal in larger examples. Parallel variations were also developed with the compute unified device architecture (CUDA), though did not improve the timing given the smaller sample size.

Disasters can strike at any time and in these scenarios, it can be devastating if there is not an efficient emergency medical service (EMS) system. While this can be problematic in a city-based environment, it is catastrophic when considering a larger air ambulance system. These vehicles travel over much longer distances, through regions with very dispersed populations. While patient transfers may occur between populous areas, this is not guaranteed during a disaster. Additionally, many air ambulances have a rather small contingency [1] which must cover all missions within a certain time frame to be effective. It is critical to accurately schedule vehicles in such a way that these potentially vast distances can be managed, and patient lives can be secured.

This work is a continuation of prior research which sought to opti- mize the staging and positioning of air assets [2]. Therefore, despite it being an independent methodology, it is also part of a greater problem directed towards air ambulance management. This is not necessarily new, as there have been several exact methodologies suggested previ- ously [3]. Though solving for optimal is not always unreasonable, since scheduling is NP-hard, it becomes much more time consuming with an increase in the solution space. The issue with this is compounded in a critical system like EMS where time can mean the difference between life and death. Near-optimal metaheuristics provide an effective alternative

This paper is arranged as follows. Section 2 describes the related work with a description of past techniques and solutions. Section 3 outlines the modelling of the problem, emphasizing constraints and the objective. Section 4 displays the algorithmic solutions, describing the neighbour- hood and tabu search, as well as the initialization technique. Sections 5 and 6 respectively show the results and conclude the paper.

Another research presented by Repoussis et al. formulated a mixed integer linear programming model for the scheduling and routing of large casualty disasters [7]. They sought to use a minimized amount of re- sources while also being able to achieve a reduced response time. Their solution was developed as a hybrid multi-start local search, involving an exact construction heuristic followed by an optimization by iterated Tabu search. Initialization utilized a greedy technique for assignments and then the problem in its reduced state was optimized. A high-quality upper bound was achieved and these were inputted into the Tabu search, repeating until the stopping condition was met.

Scheduling of air ambulances follows predetermined positions, where ambulances are already placed at bases. Time is also a factor as sched- uling relies on patients arriving at certain periods. This may be due to urgency from an incident or transfers for more specialized care. While there are potentially many bases in an EMS system, this scheduling problem only deals with the subset of bases that have vehicles assigned to them. In general, unless otherwise specified, the scheduling problem treats the terms vehicles and bases as synonymous.

Due to the constraints, there is no guarantee that a randomized initialization will be able to generate a valid solution. Since vehicles must fly under a certain period and within a particular limit there is an increased difficulty in discovering a starting state. Therefore, Algorithm 1 was developed to find an initialized organization for optimization. To

clarify, the algorithm is not designed to find a near-optimal solution, only to determine the existence of any solution. Essentially, the method will attempt to assign missions to bases and upon failure will perform swaps. This will improve the current result and may increase the chances of finding a valid permutation. If after so many attempts, it does not find a solution it will report an error.

The addition of parallelism to this algorithm was simplistic, as race conditions were only an issue for CurrentMin. CUDA operates through concurrent thread organization, so the loops at lines 7 and 44 could instead be replaced with their own threads. The continues are also replaced as each thread controls its own base. This allowed the MinIndex to be checked simultaneously for each base. A mutex check was per- formed at line 32 to add to CurrentMin along with the thread ID. At line 40, if the thread ID matched the CurrentMin, then it updated it with its solution. If there was currently no updated solution, a thread would be allocated to performing the swaps.

Algorithm 2 accepts either the initialized or the partially complete data from Algorithm 1. The goal of the algorithm is to find an organi- zation of missions and bases which minimizes the total travel time. As already discussed, the design of the previous algorithm was not to find an optimal solution, only a valid one. Conversely, Algorithm 2 was formu- lated to be performed through multiple instances to minimize the total time to near optimal. Though the initialization method uses this algo- rithm, it only performs a single iteration to attempt a new result. To ensure that Algorithm 2 has a diverse set of possibilities, the loops at lines 6 and 7 may be exchanged with random index permutation vectors.

The algorithm functions by moving missions to new bases, essentially having another vehicle take responsibility for that mission. It will only end once no further improvement is found. If utilizing a set of permu- tation vectors, this means no better result is found in the current per- mutation and provides the opportunity for another iteration. A similar set of constraints from the previous algorithm are used and updates are performed to the Solution matrix. There are four sets of loops with line 6 allowing for looping through the bases and line 7 for looping through the respective missions assigned to a base. The loops at lines 9 and 17 perform a similar function, though they are the corresponding positions being move to.

Like the previous algorithm, this one can be made easily parallel by the removal of the loop at line 9. This allows every base to be simulta- neously checked and for the CurrentMin to be updated with the best result quicker. The outer loop at line 6 could have instead been replaced, though this would have given a different value than the original, making accurate comparison difficult. Either design can be run multiple times and so long as an index ordering is done the solution may be improved.

This algorithm functions as a modification of Algorithm 2, with a near identical design. The primary differences are the variables included at lines 5 and 6. The TabuList prevents recently explored neighbourhoods from being explored again. There is a chance that the algorithm may become locked into a local minimum, preventing optimum exploration of the space. Therefore, the TabuList helps to prevent this, keeping certain regions restricted for several iterations based on the TabuCounter.

Eight datasets were employed for testing the algorithms, all being based on known coordinates of air and health facilities. The Numba li- brary [17] was applied to speed up the programs through the JIT compiler. All programs, including Gurobi scripts, were tested with a system containing 128 GBs of RAM with a 24 core Intel Core i9-7920X X-series processor. CUDA versions made use of a GeForce GTX 1080 Ti graphics card as well as the prior technologies mentioned.

