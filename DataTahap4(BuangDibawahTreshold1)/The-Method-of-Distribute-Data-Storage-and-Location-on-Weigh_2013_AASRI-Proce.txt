Focusing on the existing location technology limited the performance of the algorithm, distributed data location strategies DLPSL based on weights of jump table is presented to solve the efficiency problem. Weights are added to nodes of jump table, so that the high rate of location of the storage node priority is found to short the search path, and improve the storage and location efficiency. System analysis shows that, the node's insertion, deleting, and location on DLPSL are more efficient than single-linked list storage structure and skip graphic. Its time complexity is 0(log n), and space complexity is 0(n).

The purpose of storing information is to access and utilize. In a distributed storage system, there are many problems, for example, existence of large amount of data and how to quickly and accurately find out the dispersed data. Usually, there are three classic index mechanism categories as following [1]: a typical representative, like extendable HASH (EH) and linear HASH (LH) and Collision chain HASH (CBH) and Controlled search multiple direction HASH (CSMH),is the index mechanism based on hash function of random data organizing; another typical index mechanism is the index mechanism of orderly organization of the data based on the query tree, such as ,B-tree, B+ tree, AVL tree, T tree, T * tree, T-tail tree, etc.; the third typical representative is a hybrid index mechanism Hybrid-HT proposed by Chanho Ryu [2],and it is a mixed mechanism combined the characteristics of hash tables with query tree. Binary search tree will produce degraded tree, although AVL search tree can ensure good performance at the same time increase the difficulty to achieve the system [3]. The jump table get a better average time complexity by randomness, and you can get a good computing performance by using jump table in dynaset and dictionary.

which has higher efficiency in inserting, deleting and searching, and the function of the jump diagram is similar to the jump table and the binary search tree. Hammurabi Mendes et al [6] studied the consistency of jump figure, and used synchronous lock primitives for synchronous operation to improve search efficiency in the P2P distributed environment. Ying Jun et al [7] proposed a large-scale search algorithm to solve the hand-held device calculation processing data weaker problem. John Risson et al [8] proposed search model under P2P, the index mechanism of the model is based on keyword search, which can be used for information recovery and data management.

Jump table is a data structure of probability, invented by William Pugh in the 1990,its list bases on the parallel link list, and the operation efficiency has significant improvement related to binary search tree (For most of operation ,the average time needs O (log n))[9]. It is almost a binary tree data structure, and its implementation is simpler than balanced tree [10, 11]. It is an extension of the linked list, and the difference between jump table and the linked list is that there are pluralities of forward pointers to achieve rapid retrieval in each node (Node) of the jump table. These pointers form multi-level pointer

The advantage of jump table is that it can skip some nodes and reduce the number of keys comparison in the retrieval process. For example, when you retrieve a jump table with two pointers, you will traverse along the first primary pointer until you find a better node value than search key, and then go back to the secondary pointer. During the retrieval process, it will start from the highest level pointer and skip as many records as needed to shorten the stride. Whether it is successful or unsuccessful, the retrieval process will skip some node value comparison; in the jump table with multi-level pointers, retrieval process will skip much more node value comparison.

 Initialization. DLPSL node is comprised of storage index value (SID), Data information (Data), storage node ID(CID), weights (priority) and the pointer field. All storage index value is often between -  and + , and the index value which is the basis to find the specified user data by the server which is defined as a 32 bit binary number. Data information is used to store the data of the relevant information, and set the initial value to NULL. Storage node ID is the storage ID of the corresponding file fragmentation, generally has multiple ID addresses. When you initialize the nodes, all of the weights are set to 0. The level of each node is generated by the random function, and then adjusts dynamically the weights according to the rate of searching; the layer in which the node located will dynamically change on the basis of the size of weights.

 Node Locating. When a customer access the stored data, according to the client SID which returned by the system, it uses DLPSL strategies to search on meta directory storage table. After searching SID number, corresponding CID will be return to the server end, then take out the corresponding data segment according to the CID, finally the server end will return the data fragment back to the client. Positioning node must be top-priority before deleting and inserting node, the lines in bold shows the path of query node 63 in the following figure 3.

 Node Inserting. The main step to complete insert operation is: firstly, locate insert position of node, secondly create new nodes and finally modify the change pointer value. The insert operation will be used while updating nodes and its time efficiency mainly depends on the localization algorithm efficiency.

 Node Deleting. Node deleting is similar to its inserting. The first is to locate the nodes that needed to delete, and then to judge whether it will find the node. If it could find the node, then modify relevant pointer value and delete node. If the node is not found, then return to failure of deleting node. The time efficiency of Node delete also depends on the localization algorithm efficiency.

 Weights Updating. When the storage node is inquired by once, its weight value will add 1.When updating by DLPSL, it judges the weights of first layer nodes whether their weights are more than or equal to 5, if node right value is greater than 5, the node series will increase 1 and the node weight be set to zero. By this way, combined with the property that series high node in jump table can be preferential to identify, it can guarantee that the node of high rate of positioning would be quickly found out, thus reduces search time.

The complexity of search, insert and deleting operation are O(n+MaxLevel) while there are n elements in the jump table. In the worst cases, there are only one MaxLevel- level chain element and all the remaining elements are all in level 0 chain. If i>0, the time complexity is O(MaxLevel) in i-level chain while it is O(n) in 0-level chain. The average complexity of each operations of the jump table (search, insert and delete) is O(logn), the proof is as follows:

Space complexity, namely all elements could be MaxLevel-level in the worst case and each element needs MaxLevel+1 pointers. For this reason, the n elements need to be stored and meanwhile chain pointer need to be stored also (space needed is O(n * MaxLevel)). Usually, only n*p elements in 1-level chain, n*p2 elements in 2-level chain and n*pi in i-level chain. So the

The first layer n, the second n/2, the third layer n/22,â€¦, until n/2log n=1. So, the total space requirement is: S = n + n/2 + n/22 + ... + n/2log n < n (1 + 1/2 + 1/22 + ... + 1/2) =2n.

