Outsourcing data and computation services to public cloud providers de-mands security mechanisms that can enforce strict data confidenti- ality and in-tegrity regulations. This is particularly important for ap- plications and orga-nizations that prosess sensitive data. Two orthogonal approaches for securing data processing activities are actively being touted as potential game changers: Homomorphic Encryption (HE) and hardware based TEEs.

HE promises computation on encrypted values without revealing their con-tent. Research in the area increased after 2009, when Craig Gentry [1], in his doctoral thesis, described the first technique for achieving FHE nearly 30 years after the idea was conceived [2]. FHE enables outsourcing of many types of computations that previously had to be kept in-house due to confidentiality constraints, including health-data processing, financial processing, and genome research.

Multithread-ing (SMT) [7]. Hardware technology that reveals secrets internally thus cannot be relied on to provide highly assured confiden- tiality in public cloud settings. There are some ways to counter this, such as using oblivious primitives like Oblivious RAM (ORAM) [8], which obscures access patterns to prevent infor-mation leakage through side-channels. Oblivious methods do, however, incur significant per- formance overhead to computation.

within the stated security context, and propose a hybrid approach that combines the confidentiality strengths of FHE with the integrity strengths of TEEs. We do so using the memory-safe programming lan- guage Rust [9]. Using Rust miti-gates large classes of dangerous and common security-related bugs, including memory corruption errors, buffer overflows, uninitialized memory, data races, dereferenced pointers to unallocated memory (e.g., null-pointer dereferencing), and

that uses FHE both outside and within SGX. By comparing the relative performance difference, we demonstrate that a hybrid approach is feasible in terms of per-formance while retaining more robust security and safety guarantees than using either FHE or SGX separately. To our knowledge, our approach is the first work that combines a TEE with FHE to cover integrity weaknesses of FHE.

Although malleable encryption schemes are secure under standard Indistin-guishability under Chosen-Plaintext Attack (IND-CPA), they are not secure un-der Indistinguishability under Adaptive Chosen- Ciphertext Attack (IND-CCA2) [13], as opposed to non-malleable cryp- tosystems [14]. Furthermore, it has been shown that some encryption schemes that are IND-CPA become insecure when they encrypt their own decryption key [15], often referred to as circular security. As.

Several known methods exist for an adversary to physically attack hard-ware components to extract information. This includes power- monitoring (or power-tweaking) attacks such as Plundervolt [22], acoustic cryptanalysis attacks [23], electromagnetic attacks, and optical attacks. Software-based side-channel attacks range from page-fault based attacks [3], cache-based attacks [4], and interface-based attacks [5], all targeting confidentiality.

The TEE manufacturer must also be trusted to provide sound soft- ware and development tools. In the case of Intel SGX, various software systems and a Software Development Kit (SDK) are provided, in addition to the on-chip hardware mechanisms. As of February 2021, the Intel SGX Linux SDK consists of around 360 000 Source Lines of Code (SLoC).

The TFHE-rs library combines HE with code executing inside a TEE to provide both confidentiality and integrity. By processing ciphertexts within a TEE, an adversary cannot modify nor even read the ciphertext, eliminating the issue of malleability and thus providing stronger secu- rity. For our TEE we use Intel SGX and for homomorphic operations we use the Fast Fully Homomorphic Encryption over the Torus (TFHE) scheme, first described by Chillotti et al. [24].

TFHE is a symmetric lattice-based FHE scheme that works by represent-ing polynomials with coefficients over T, the set of real numbers modulo 1, or R/Z. Chillotti et al. [24] also provide an accom- panying library implemen-tation [25], which we will refer to as TFHE-c in this paper. A key benefit of the TFHE-c library is that it is designed to compute on bits. In contrast, other schemes like Homomorphic Encryption Arithmetic of Approximate Num-bers (HEAAN) (also called Cheon-Kim-Kim-Song (CKKS)) [26] and Brakerski- Gentry-Vaikun tanathan (BGV) [27], work with approximate numbers as the plaintext space is within the complex numbers.

The TFHE source code has some structures where a field is a pointer to values within a dynamically-allocated array that a different field in the same structure also references, i.e. self-referential structures. When one moves a value in memory, the referenced value in the self-referential structure is invalidated. This makes them inherently dangerous and thus disallowed by the type system in Rust. As a solution, we chose to remove these fields and access the values directly, at the loss of some readability.

All data structures that might need to be transmitted are serializable and deserializable, using the Rust package Serde.3 Serde designs seri- alization and deserialization so that any data structure that implements one of two traits can be serialized or deserialized to one of the tens of different serialization for-mats supported. This is unlike the TFHE li- brary, where serialization of data can only be done through specific functions for reading and writing files and streams. These functions are somewhat limited and do not allow the developer to specify the serial- ization format. In TFHE-rs, a macro allows deriving the implementation automatically, such as (line 3 highlights derive macro):

Finally, we also performed the benchmark of the TFHE library with all their optimizations included. We use their spqlios FFT processor with the FMA instruction set extensions and achieved an execution time of 14.771 ms. This number is similar to their findings, but should not be compared directly to ours as it implements several more optimizations.

under conditions that make it challenging to solve. Thus, it is good to use as proof that a par-ticular system can solve problems in the domain of SMPC. The problem has several solutions, with techniques ranging from oblivious transfer methods [31], private set intersections with HE [32] to FHE.

We start by producing the binary decomposition of the two values. We use two 32-bit signed integers for this purpose. For each of the values, we decompose them into bytes in big-endian order, then decompose those into the individual bits. We use big-endian as we implemented the circuits we use to work on big-endian values. Then each bit is individually encrypted with our TFHE implementation. This results in two pairs of 32 ciphertexts representing the encryption of the two values. In a multi-key setup, the two parties perform these actions separately after completing a key-exchange protocol. Note that our implementation of the TFHE scheme does not support multi-key setups as we based it on an implementation that also did not support it. However, supporting it would only necessitate adding a key combina- tion step that scales linearly with the number of parties.

Next, we evaluate and compare the performance of TFHE-rs with and with-out the use of SGX. We repeat each experiment 25 times, timing only the relevant sections. Running with 80-bit security, TFHE-rs with SGX finished with an arithmetic mean of 90.504 s and a standard de- viation of 0.602 86 s while the FHE-only version finished in 116.08 s and a standard deviation of 2.3548 s. These results indicate that TFHE-rs is approximately 28% faster with SGX.

There is known overhead associated with SGX memory encryption and pag-ing. However, we explain the performance improvement be- tween the two ver-sions of TFHE-rs by how an SGX enclave handles memory. For this, we profiled our non SGX program using the 128-bit security parameter set, which is the one that uses most memory, with the memory profiler for Linux.8 The observed memory usage over time is

Drucker and Gueron [35] state that most secure cloud database so- lutions tend to provide confidentiality and integrity of data by using either a TEE or HE. They show that combining a TEE and using HE is feasible and does not need to rely on the TEE for confidentiality pur- poses. They compare their work to CryptDB [36] and MrCrypt [37], which both use Partially Homomorphic En-cryption (PHE), but lack integrity security for both code and data. Drucker and Gueron combine the PHE scheme Paillier [38] and SGX, where SGX pro-vides integrity of code and data (in addition to some confidentiality guarantees, side-channel attacks aside). The Paillier cryptosystem ensures data is private and provides confidentiality, even within the enclave. The combination allows the system to place less trust in Intel, as the Paillier cryptosystem guarantees confidentiality for the encrypted data while allowing some computations. In their experiments, they only experience

problems re-lated to side-channel attacks and cloud hosted computa- tions. Chen et al. [41] propose a software framework that detects side-channel attacks by a privileged attacker, such as a malicious or virus-infected OS. Some types of side-channel attacks that exploit access-pattern information leakage can be protected against using techniques such as ORAM [8]. ORAM can be seen as a compiler that transforms memory accesses of a program into a program where the distribu-tion of memory accesses differs (is independent) from the original program while preserving the semantics of the program. Path ORAM [42] improves upon reg-ular ORAM and has a low space over- head and in some cases, asymptotically improved performance compared to earlier work. Circuit ORAM [43] further improves the techniques and gives an implementation with a complexity near the theoretical lower-bound.

ZeroTrace [44] is an example of oblivious primitives in action. Se- curity is strengthened against access-pattern side-channel attacks in SGX using a block-level memory controller to hide access patterns. Both Path ORAM and Circuit ORAM are implemented and gave in some situations only a logarithmic over-head in bandwidth costs between enclave code and ORAM servers. ZeroTrace mitigates considerable weaknesses in SGX as it protects against shared resource and page-fault related attacks by converting programs into oblivious represen-tations. Another example of oblivious memory primitives in SGX is Oblix [45], an oblivious search index. The authors introduce something they call doubly-oblivious tech- niques, as it ensures that accesses to external servers as well as the

We evaluated the performance characteristics of TFHE-rs with and without an SGX enclave and found that the performance overhead is negligible. The evaluation showed that using TFHE-rs with SGX is 3% faster than a version of TFHE-rs without SGX. This result is not in line with what we conjectured, which was that TFHE-rs with SGX should be slower. Based on our experience, we conjecture that specific memory management implementations particularly affects performance. The

the dlmalloc allocator used by the Fortanix Rust EDP in the SGX setup. As such, a system with a similar setup to ours should emphasize low memory usage and experiment with different allocators to ensure that they stay within the memory limits imposed by SGX. However, the measured stan-dard deviation does account for most of the performance difference, and the benchmarks themselves take long enough for this discrepancy to be due to envi-ronmental factors in our experimental setup (i.e., due to system load). Overall, this is a positive result, as our hybrid solution is both more secure and faster.

