ORIGINAL ARTICLE
A Survey on HTTPS Implementation by AndroidApps: Issues and Countermeasures
Xuetao Wei*, Michael Wolf
University of Cincinnati, United StatesReceived 5 July 2016; revised 5 October 2016; accepted 31 October 2016Available online 11 November 2016
KEYWORDSHTTPS;Android;Mobile security;TLS/SSL;Mobile developmentAbstractAs more and more sensitive data is transferred from mobile applications across unse-cured channels, it seems imperative that transport layer encryption should be used in any non-trivial instance. Yet, research indicates that many Android developers do not use HTTPS or violaterules which protect user data from man-in-the-middle attacks. This paper seeks to ﬁnd a root causeof the disparities between theoretical HTTPS usage and in-the-wild implementation of the protocolby looking into Android applications, online resources, and papers published by HTTPS andAndroid security researchers. From these resources, we extract a set of barrier categories that existin the path of proper TLS use. These barriers not only include improper developer practices, butalso server misconﬁguration, lacking documentation, ﬂaws in libraries, the fundamentally complexTLS PKI system, and a lack of consumer understanding of the importance of HTTPS. Followingthis discussion, we compile a set of potential solutions and patches to better secure Android HTTPSand the TLS/SSL protocol in general. We conclude our survey with gaps in current understandingof the environment and suggestions for further research.
/C2112016 The Authors. Production and hosting by Elsevier B.V. on behalf of King Saud University. This isan open access article under the CC BY-NC-ND license ( http://creativecommons.org/licenses/by-nc-nd/4.0/ ).
Contents1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1022. Overview of Android HTTPS and current ﬁndings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1033. In-depth cause analysis of HTTPS misuse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1063.1. Developer misuse of HTTPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
*Corresponding author.E-mail address:weix2@ucmail.uc.edu(X. Wei).Peer review under responsibility of King Saud University.
Production and hosting by ElsevierApplied Computing and Informatics (2017) 13, 101–117
Saudi Computer Society, King Saud University
Applied Computing and Informatics
(http://computer.org.sa)www.ksu.edu.sawww.sciencedirect.com
http://dx.doi.org/10.1016/j.aci.2016.10.0012210-8327/C2112016 The Authors. Production and hosting by Elsevier B.V. on behalf of King Saud University.This is an open access article under the CC BY-NC-ND license ( http://creativecommons.org/licenses/by-nc-nd/4.0/ ).3.2. Server misconﬁgurations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1083.3. Lacking documentation on HTTPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1093.4. Flaws in SSL/TLS libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1093.5. Issues in the HTTPS protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1103.6. Need for consumer awareness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1114. Proposed solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1114.1. Link SSL to DEBUGGABLE ﬂag in the Android manifest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1124.2. Remove SSLErrorHandler. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1124.3. Android market and client side application validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1124.4. Use SSL pinning. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1124.5. Improve documentation and API clarity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1124.6. Begin persistent Internet-wide SSL vulnerability scanning. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1134.7. Patch and increase oversight on SSL libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1134.8. Large mobile applications should use stronger HTTPS protections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1134.9. Revise the TLS protocol suite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1134.10. Increase consumer awareness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145. Discussion and future work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145.1. Gaps in research. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1145.2. Moving forward . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1146. Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1151. IntroductionThe Android mobile platform was introduced in 2007 by Goo-gle and the Open Handset Alliance. Due to its open nature andsupport from both Google and third-party developers, it hasbecome the most widespread mobile operating system as of2014[1]. The ease of entry to Android development hasallowed the platform to expand to its current size; however,this free-for-all environment exacerbates issues in applicationsecurity and user privacy. The security of Android is the bur-den which individual developers must bear and the standardsfor security are not always clear. Developers writing applica-tions for Android must consider how their code will assureuser safety while simultaneously calculating for minimal mem-ory usage, battery life, and weak processing power. Their appsmust comply to security protocols, launch as their own UID,sign their code, and minimize permissions [2]. Needless to say, lost in the innumerable tasks of application creation anddeployment, security errors are undeniably frequent. In thissurvey, the primary focus will be on the insecure developmentof Internet-connected non-browser Android applications andthe implementation of HTTPS, potential remedies, and sugges-tions for further research. The increased shift of consumer elec-tronics to the mobile realm and the development of a widerange of applications that has followed has meant a steadyincrease in the amount of personal, critical and conﬁdentialinformation that ﬂows in and out of mobile devices [3,4]. These handhelds use channels such as public WiFi which, even withmodern protections, can be vulnerable[5]. Packets can be easily sniffed and manipulated when sent in plaintext HTTPmessages over these networks[6]. There are many mechanismswhich satisfy the goal of protecting packets, but the SSL andTLS protocol built into HTTPS has become the de facto suite,though it may not deserve the unchecked faith it receives [7]. Thus TLS and its implementations will be the system investi-gated as we continue. While web browsers are generally ableto implement HTTPS connections securely since they are man-aged by enormous teams of engineers or contributors, Androidapplications do not have this sort of oversight. The widespreadand mostly unsupervised creation of Android applications hasallowed for security loopholes to appear in programs whichuse HTTPS calls[8]. According to the Bureau of Labor Statis-tics, software jobs in the US are set to grow by 30% by 2022[9]. It is essential that both new and experienced developersare able to properly tackle loopholes in Android security.The Android platform has several encryption and securitysuites. It hosts a large Java encryption library and well-respected and versatile third-party implementations such asBouncy Castle[10]and OpenSSL[11]. There are several differ-ent methods of implementing HTTPS built directly into theplatform. These methods frequently require no custom codeto function securely. In addition, the Android developmenttraining website hosts several walkthroughs on HTTPS [12]. Despite the need for transport-layer encryption and the readyavailability of encryption mechanisms, many Android applica-tions simply do not implement HTTPS when they should ortheir code alters the HTTPS implementation in a way thatmakes the application vulnerable. In these cases, user dataare susceptible to Man in the Middle attacks. As shown inFig. 1, MitM attacks allow for a malicious actor (E) to eaves-drop, intercept and insert itself into a conversation betweentwo legitimate users (A and B). This has become one of themost pressing threats to wireless and cellular communications.More unfortunately, there is frequently no warning to theuser that these vulnerable connections are not secured bySSL/TLS. Issues remain in SSL libraries, the TLS and X.509certiﬁcate validation protocol, and server-side conﬁgurations.As will be discussed in later sections, cleaning up the SSL uni-verse to protect user data requires the cooperation of moreparties than just Android application developers. It is impera-tive that proper encryption is used in all applications whichprocess user data over the Internet. This paper will analyzewhy developers do not (or are unable to) implement secureHTTPS connections and present an idea for a solution to the102 X. Wei, M. Wolfgap between theoretical security and implemented HTTPSsecurity in Android. We will look at the state of the artresearch in ﬁelds beyond the mobile realm to detect trends insecurity and ascertain ways to harden the HTTPS environmenton Android. The remainder of this paper is organized in thefollowing way. Section2contains a summary of HTTPS, itsproper usage on the Android platform, and the major relevantﬁndings contributed by security researchers. Section 3provides a deeper interpretation and grouping of these results includinga listing and discussion of causes of HTTPS misuse. Section 4 provides a listing of potential solutions which have been sug-gested by security researchers. Section5.1gives the observedgaps in current Android HTTPS research. Section 5.2contains concrete suggestions for future research which fulﬁll the someof the solutions suggested in Section3or bridge holes in cur-rent understanding noted in Section5.1. The paper is con-cluded in Section6.2. Overview of Android HTTPS and current ﬁndingsCryptography is difﬁcult to implement even with modern soft-ware[13]. In order to create resistant keys, complex algorithmsand programming mechanisms are needed. Hundreds of algo-rithms are used for different steps in the encryption process [2]. Adding to this, developers aren’t always taught security bestpractices[14]. As computers increasingly grow in their process-ing capacity, so will the encryption systems grow in intricacy tomaintain their defenses against brute force and man-in-the-middle (MITM) attacks. Internet systems have developedgreater complexity with the inﬂux of users, web stakeholders,and non-traditional server methodologies [15]. In order to secure user data and the integrity of Internet-connected appli-cations, developers must be able to properly implementencryption technologies[4,16,17]. SSL/TLS is one such crypto-graphic system which requires a layer of abstraction in order tobe usable to developers. SSL was developed to provide an end-to-end encrypted data channel for servers and clients on wire-less systems. Given that wireless technology is prone on thephysical level to eavesdropping attacks based on RF broadcastinterception, this cryptographic protocol is vital for the securetransfer of any data to and from cell phones [18]. The corner- stone of SSL is the ability of the client to conﬁrm without adoubt that the server contacted is the correct one. From heredata can then be transferred with trust. To establish this stateof trust, a complicated, mixed public-private key exchangetakes place. This requires an extensive handshake and veriﬁca-tion process to avoid sending the encryption key to any inter-ceptors on the network who have latched on to the chain ofcommunication.In the lowest level, SSL functions in the following waydepicted inFig. 2. The client sends an HTTPS request to theserver with its SSL version number and supported ciphers.The server responds with its SSL version number and ciphersas well as its certiﬁcate. This server certiﬁcate has been signedby a trusted certiﬁcate authority (CA) which has veriﬁed theservers authenticity. The client will compare the certiﬁcate’spublic key to its local key store and the ﬁeld values to expectedvalues. If the certiﬁcate passes, and the certiﬁcate has not beenrevoked by a CA (as determined by a query to a CA’s certiﬁ-cate revocation list (CRL)), the handshake continues. Thecipher suite is chosen from the algorithms which the clientand server have in common. An example cipher suite coulduse ECDHE for key exchange, RSA for certiﬁcates, AES128-
Figure 2A simple TLS handshake.
Figure 1A classic Man In the Middle attack with theconversation between Alice (A) and Bob (B) being interceptedby Eve (E).Survey on HTTPS implementation by Android apps 103GCM for message encryption, and SHA256 for message integ-rity checking. A pre-master secret is encrypted with server’spublic key using a cipher suite which is in common betweenthe two machines and transmitted to the server. If the clienthas been asked to verify itself with a certiﬁcate, this will beincluded with the secret and transmitted to the server. If theauthenticity is conﬁrmed, each machine uses the pre-mastersecret to generate the master – a session ID that functions asthe symmetric key for the SSL communication. Once the hand-shake has been completed and each device informs the otherthat all further communication will be encrypted with the ses-sion ID, the client encrypts its messages using the symmetrickey and sends the data to the server. Once all data is sent,the connection is terminated[19,20]. Digital certiﬁcates, thecore of the SSL system, are based on the X.509 protocol[21]. This protocol along with the Online Certiﬁcate StatusProtocol (OCSP)[22]establish how certiﬁcates are to be devel-oped, validated, and revoked[23]. The major components ofcertiﬁcate checking are issuer veriﬁcation, hostname validationand revocation checking. Each of these steps assures that theserver in question is still trusted by a certiﬁcate authority.Within the certiﬁcate validation process, issues have arisenwith servers signing their own certiﬁcates and certiﬁcates usingwildcard hostnames (for example,*.google.com). These dis-crepancies are easily spotted and ﬂagged by properly imple-mented SSL clients or humans. However, in situations wherethe functionality of X.509 has been compromised by customcode, such as removed revocation checks, these invalid certiﬁ-cates can be accepted – rendering the SSL process useless [24]. Without proper validation checks, any rogue access point canbreak into the chain of communication, send a random certiﬁ-cate to the user, and forward the packets to the original server,decrypting and reading all data ﬂowing between the ends.Much in the way that higher-level programming languagesobscure memory management to make the developers jobmore straightforward, so do many encryption suites try tomake encryption and decryption a standard, human-understandable process. The papers and communicationswhich become the foundation of SSL, TLS, and the manyimprovements, revisions, and decisions on these topics, comefrom the Internet Engineering Task Force (IETF) [25]. These technical documents cannot be directly utilized by most devel-opers. Thus, libraries and encryption suites take the technicaldocumentation and develop a platform for applications touse. Libraries like OpenSSL[11]handle the TLS handshakefor developers, leading to a more uniform and secure set ofHTTPS connections. While these libraries have come underscrutiny due to security ﬂaws[26,27], their role is vital in theInternet and they have existed for years. OpenSSL, foundedin 1998, is used by servers which comprise 66% of the web ser-vers[28]. SSL/TLS libraries are the ‘physical’ implementationof the IETF protocols. However, this code is not necessarily‘in the wild’. In this paper, we will use the term ‘in the wild’to refer instead to consumer-facing applications. As librariesrely on protocols for guidance, consumer-facing implementa-tions rely on libraries and, in effect, protocols, for guidance.For this paper, the primary ‘wild’ code investigated will beon the Android platform. The movement of cryptography toabstraction is especially important in Android which has aheavy focus on third-party development and ease-of-development. In the standard Android implementation ofHTTPS, there are three parts in the creation of a secure con-nection with SSL/TLS. These three parts, setup, socket gener-ation, and the certiﬁcate management, reﬂect the typical TLShandshake protocol[29]. The following is a possible SSLimplementation. Setup involves customizing the HTTP packetheaders. This can be done through HttpParams andClientConnectionManager to transmit the proper headersand data. Cipher suites can be manually selected, but defaultswill function for most calls. The socket is generated through aninstance of the SSLSocketFactory class. Finally, theX509TrustManager which is an entity within theSSLSocketFactory will by default authenticate credentialsand certiﬁcates. The stock Android trust manager has 134 rootcertiﬁcate authorities installed[30]. The library will attempt totrace the certiﬁcate trust chain back to one of these 134 rootCAs. Once the client and server are certiﬁed, transmissioncommences. This can be an incredibly simple and black-boxed process. For instance, according to the Android Devel-oper Training, valid HTTPS code can be written in four linesusing HttpsURLConnection, part of the URLConnectionlibrary (seeListing 1)[12,31].Assuming that the device had the proper certiﬁcatesinstalled, this code in lst. 1 would be operational. TheURLConnection API takes care of hostname veriﬁcationand certiﬁcate management. Besides the URLConnectionAPI, other libraries and middleware have been developed forapplication designers which manage these components. Morecustomization is available in the Java Secure Socket Extension(JSSE) which comes packaged with Java[32]. Other common libraries include OpenSSL[11]and GnuTLS[33]: C-based frameworks for SSL/TLS implementation. Higher-level wrap-per implementations of these SSL/TLS libraries include cURL[34]and Apache HttpClient[35]. Furthermore, certain indus-
tries have their own middleware such as Amazons FlexiblePayment Service[36]which help abstract the HTTPS connec-tion code away from the developer. While libraries are anattempt to make SSL/TLS implementation default, they canalso leave the applications vulnerable. Since application secu-rity is completely tied to the libraries it uses, ﬂaws in thelibraries are in extension ﬂaws in the applications which usethem. Giorgiev et al.[37]found that SSL certiﬁcate validationis completely broken in many critical software applicationsand libraries. In one example, Chase Mobile Banking overridesX509TrustManager and doesn’t check the server’s certiﬁcatethus violating the most important aspect of HTTPS. Further-more, Tendulkar et al.[8]found that during the investigationof 26 open-source applications, 10 were using SSL incorrectly.This is perhaps due to misreading library documentation oroverriding important features of the suites. Even large-scaleenterprises misuse HTTPS or don’t fully secure their connec-tions[24]. A vulnerability note released by CERT identiﬁesapplications by Fandango and Credit Karma which fail to val-idate SSL certiﬁcates[38]. The issues within Android are morecomplex than a lack of experience with application construc-tion, they derive from issues in libraries, protocols, server con-ﬁgurations, and user comprehension of SSL and TLS. Fahlet al.[24]developed a tool called MalloDroid which targetsapplication vulnerabilities dealing with MITM attacks. Mallo-Droid analyzed the API calls which applications made,checked the validity of certiﬁcates, and identiﬁed cases of cus-tom HTTPS implementation. Of the applications tested, 8%were vulnerable. The main issues discovered in this investiga-tion were symptoms of unnecessary customizations placed104 X. Wei, M. Wolfover default SSL code. The use of customized code over SSLdefaults is almost always detrimental[39]. Tendulkar et al.[8]found that 1613 out of 1742 implementations of SSL withcustom code did not require anything beyond the defaults.In fact, in most cases, adding the single character ‘s’ wouldhave allowed the application to securely use HTTPS. The pri-mary customizations at fault were trust managers which acceptall certiﬁcates, trust all hostnames, and ignore SSL errors[24,8]. Trust managers exist to validate certiﬁcates. When thecertiﬁcate checking is turned off, security is compromised.Using user-deﬁned trust managers that accept all certiﬁcatesor self-signed certiﬁcates has been shown to be an issue inthe Android community. It places user data in a vulnerableposition and compromises the original intention of both SSLlibraries and the SSL/TLS protocol. Unfortunately, trustingall hostnames is even simpler than implementing a customtrust manager. Using the org.apache.http.conn.ssl.AllowAllHostnameVeriﬁer, developers are able to bypass checking theserver for a certiﬁed hostname. Several applications investi-gated with MalloDroid contained custom classes whichallowed all hostnames in the SSL connection [24]. This imple- mentation subverts the fundamental trust process of SSL/TLS.Many mobile applications have been found to simply ignorethe errors thrown by Android or a corresponding librarywhich could not validate the HTTPS certiﬁcate.As seen inListing 2, messages are hidden from users andthe application continues as though it has a secure connec-tion[24,8]. Again, overriding errors thrown by the systemdefeats its purpose and mimics the insecure manner in whichusers click through SSL errors in the browser. However, unlikein desktop browsers, this case comes with the repercussion ofnever presenting the user with options for their own security.One ﬁnal issue that doesn’t revolve around the customizationof default SSL code is that developers sometimes use hybridHTTP/HTTPS or don’t use SSL/TLS at all. Fahl et al. [24] found an instant messenger application which sent login cre-dentials over non-encrypted channels vulnerable to a replayattack. Other hybrid systems were vulnerable to strippingattacks or leaking data through broken SSL channels. Brow-sers and applications using Android’s WebView to connectto a server are particularly vulnerable in these cases. Theseinstances warrant attention from both developers and serverarchitects. Beyond application-level ﬂaws, there are wide-spread server misconﬁgurations which lead to a large numberof false positive SSL errors[40]. These false-positives take upuser attention and lead to an unsafe dismissal of SSL errorvalidity by developers and users. Certiﬁcate management isoften a difﬁcult and paperwork-intensive process for serveroperations teams. In addition, content delivery networks(CDNs), and more speciﬁcally CNAME routing, have compli-cated the certiﬁcate issuance and validation process. Since theCDN model is based off surrogate servers handling web trafﬁcload from the customer’s server, using HTTPS properly, anintimate client-server model, requires less-than-ideal work-arounds to maintain non-repudiation and trust. During theinvestigation of 20 CDN providers and 10,721 websites byLiang et al.[15], 15% raised invalid certiﬁcate errors. All 5CDNs investigated had insecure HTTPS or HTTP communi-cation on the back-end. Due to many Android applicationsreliance on servers which use CDNs, this issue needs to beresolved in order for efforts of client-side validation and errorreporting to be accurate and attune to SSL errors. Each ofthese vulnerabilities identiﬁed are not just issues waiting tobe exploited. Huang et al.[41]showed that 2% of certiﬁcates//===
Listing 1Example of a standard Android HTTPS call.
Listing 2Overridden SSLSocketFactory found in the wild.Survey on HTTPS implementation by Android apps 105which users received when accessing Facebook were forged.These false certiﬁcates were invalid and should have been castaway, but users still followed them or the application whichaccessed the website did not throw an error, thus falling victimto a man-in-the-middle attack. As Moxie Marlinspike hasshown with his tool sslsniff[42], automated MITM attacksare simple to carry out. The susceptibility of the physical layerof mobile communication to eavesdroppers only raises thisrisk. Android HTTPS development is in a bind. While devel-opers want to have a secure system for their users, several fac-tors within and without their control complicate properimplementation of end-to-end encrypted communication.Why aren’t Android developers using HTTPS? Why do exist-ing SSL implementations remain insecure? In the next section,we will analyze factors which have been identiﬁed in the cur-rent Android development process and SSL/TLS ecosystemwhich keep HTTPS from reaching the ideal security that it isoften claimed to be.3. In-depth cause analysis of HTTPS misuseIn this section, we will look into the issues which compromisethe security of SSL/TLS implementations, in particular, onAndroid-based devices. First, we will look at the primarycauses of SSL insecurities with current Android HTTPS imple-mentations. Even though the only guidance afforded to devel-opers hoping to secure their applications are a few weaklyenforced frameworks in the Android system, security mustbe built by manually integrating custom security features intothe project while retaining a functional and cohesive form.This process can be ad hoc, prone to error, repetitive, and inex-act[43]. As shown in the previous section, vulnerabilities andholes are rampant and actively exploited. The ﬁrst step inpatching these ﬂaws is determining their origin. There existissues rooted in the mobile app development paradigm, serverconﬁguration, Android documentation, SSL/TLS libraries, theSSL/TLS protocol, and application consumers. Extensiveresearch has gone into determining the root cause of each ofthese factors. This section will investigate each of these causesfurther.3.1. Developer misuse of HTTPSAmong the papers reviewed, the most commonly reportedﬂaws in HTTPS conﬁguration were due developer negligence.One such problem is debug code being left in production appli-cations. this problem isn’t new and it has been listed in theCommon Weakness Enumeration[44]. Leftover code and snip-pets that bypass standard procedures to make the an app oper-ational in development have a widespread effect on applicationsecurity[8]. Ironically, leftover debug code can violate the pro-tections which the system it models is supposed to afford.HTTPS is not immune to development glitches where theauthor of a program either leaves vulnerable code or placesan intentional override in their application, especially onAndroid. This could come in the form of a situation where,in order for an application to populate and display data forthe developer, the certiﬁcate validation must be set up to allowa stream of data from a mock server. This allows for theauthor to assure the other components of the application areproperly functioning, but leaves the HTTPS connection vul-nerable unless the certiﬁcate checking is turned back on. Thishappens with unfortunate frequency since there are simplemechanisms which we will later discuss to prevent uninten-tional remnant debug code from emerging in production appli-cations. Developers want top level security, but also desiretheir product to function properly in development [24]. This creates an issue with a complex setup like SSL/TLS. Asexplained earlier, the most crucial part of an HTTPS commu-nication paradigm is the existence of valid certiﬁcates and rec-ognized certiﬁcate authorities. When running both the serverand the application, developers may build their server withself-signed certiﬁcates for development and forget to changethe application’s validation process when they do get theproper CA-signed certiﬁcate or bypass this for alternative rea-sons[39,45]. Running an application without SSL/TLS protec-tion while debugging is obviously harmless, but once theseapps are open to the general public, there is extreme risk ofdata theft. Beyond inspecting the code itself, speaking to devel-opers about their mistakes and security bugs yields a morethorough look into the cause of these developer-based ﬂaws.A study conducted by Fahl et al.[24]showed a few trendsamong the developers surveyed.(i) Developers make mistakes. Upon contacting the devel-opers at fault, many took the advice and ﬁxed their mis-takes. Others, however, refused to admit that the ﬂawwas an issue[39]. These mistakes are understandable.Android is a complex system and public-key cryptogra-phy is not a easily grasped even with high-level libraries.The startling rejection and denial made by developers inthis survey may be a result of embarrassment at incor-rectly implementing code. However, for applicationsmade by developers both willing and unwilling to admitfault for SSL misconﬁguration, it seems apparent thatthere was a failing in code coverage in the developmentprocess.(ii) Another explanation may be apathy or simple ignoranceon the topic of SSL/TLS security. A paper by Xie et al.[14]found that while many of the participants in theirexperiment had a general knowledge and awareness ofsoftware security, there were gaps between this knowl-edge and the actual practices and behaviors that theirparticipants reported. Despite general knowledge ofsecurity, they were not able to give concrete examplesof their personal security practices. In the same study,Xie et al. noted that there was a prevalence of the ‘‘it’snot my responsibility”attitude. The developers oftenrelied on other people, processes, or technology to han-dle the security side of the application. When these soft-ware authors are so busy with the pure functionality andviability of their product and the approaching deadlines,it is obvious that the security hat looks much better onanother member of the team. Unfortunately, codereview and quality assurance only go so far, especiallywhen looking at an application retrospectively. In anideal situation, security is considered in every step ofthe development process from the design through thedeployment. As evidenced by this report, this is notthe case in many development environments.(iii) Online forums and user-to-user resources may not be the
cause of developer misuse of SSL, but they allow devel-opers to discover ways to bypass security measures in106 X. Wei, M. Wolforder to solve errors. One such website is Stack Over-ﬂow[46]. Typically, errors solved are caused when thedeveloper who has posed the question has incorrectlywritten a chunk of code. In these situations, Stack Over-ﬂow operates in an important, positive way. However, inthe case of SSL errors, the most trivial way to stop theerrors without conﬁguring the server is to stop the appli-cation from throwing the errors.Figs. 3 and 4show an example of an Android SSL certiﬁcate expiration over-ride. While most respondents explain that these solu-
Figure 3An example question seeking an SSL override on StackExchange.
Figure 4An unsafe suggestion for resolving the question on StackExchange.Survey on HTTPS implementation by Android apps 107tions should not be used in production environmentsbefore giving a sample override, some answers, such asthe one shown inFig. 4, do not provide that context.This answer has received negative feedback most likelyfor this reason. However, given almost 10,000 views, thissolution has almost certainly ended up in a developer’sproduction application. Thoughtful answers are oftenmixed with less security-oriented responses on thesewebsites, allowing harmful programming paradigms todevelop online.For instance, a developer may ask for away to get past the UntrustedCertiﬁcate error inApache’s HttpClient and the answer may be to use acustom SSLSocketFactory to trust all hosts [47].O f course, those who answered the question or other com-munity members may stress how this should not run inproduction, but the solution is still presented in a fash-ion that a desperate developer can quickly ﬁnd awork-around. Websites such as Stack Overﬂow don’tencourage app designers to customize their SSL/TLSimplementation to use self-signed certiﬁcates and acceptall hosts in production, but they do show developershow to use them in testing[39]. Stackoverﬂow cannotbe blamed nor can the open-door style of developmentwhich Android possesses. The fault in these situationsare the developers who either forget to remove thework-around code or just ignore the warnings on usingaccept-all policies in production applications.Despite the many ﬂaws which can be found in Androiddevelopment and production applications, there is no solid evi-dence that Android developers are more clumsy with SSL thanothers in a similar situation. Investigations of iOS applicationshas shown that the two platforms have a comparable numberof SSL/TLS vulnerabilities[39]. The so-called walled gardenapproach doesn’t seem to ﬁx issues in developer misuse ofHTTPS. While it may make sense to correlate a lack of devel-oper knowledge with an incorrect SSL connection, it would beincorrect to say that the Android-speciﬁc development para-digm causes these errors. If anything can be found to be lack-ing, it is a lack of oversight on mobile applications. Another,more social, factor may contribute to these developer mistakesand in turn effect the security of HTTPS calls. Xie et al. [14] show that there are issues in developer environments (teammembers, support staff, managers, etc.) that can cause themto make mistakes. One such issue is misplaced trust in process.This involves believing that software security is only retrospec-tive or investigated in the code review stages. Secondly, there isthe feeling that a software engineer doesn’t need to knowabout vulnerabilities if they aren’t speciﬁcally working onthem. This would be like designing a backend without payingany attention to the frontend. Software isn’t contextual, andall components in the ﬁnal project need to be designed, devel-oped, and reviewed at every step in the process. Each memberof a team should be aware of what the others are doing inorder to create the most accurate and uniﬁed product. Finally,and most recognizably to developers, is the existence of exter-nal constraints which effect workﬂow and programming pro-cess on a human level. These include deadlines, client desires,government policy, and any sort of conﬁning elements thatwould stop the developer from creating the product in theway he or she imagines. When the budget tightens or a dead-line approaches, proper security can be an unfortunate sacri-ﬁce when a client’s main focus is functionality and design[14]. Besides a missing understanding of HTTPS standards,these external constraints potentially hold the most sway overthe correctness of a developer’s solution. Developers are facedwith pressure, deadlines, an imperfect support system, and thecomplexities of public key infrastructure and Android. Mis-takes and misconﬁgurations are bound to arise in this system.When user data must rely on this stressed authorship, there areserious implications. While applications created by these devel-opers are the breaking-point in this system, there are severalmore causes both for developer mistakes and general insecuri-ties in Android SSL connections.3.2. Server misconﬁgurationsOn the opposite end of the TLS system is the HTTPS server.Setting up an Apache HTTPS server is not difﬁcult [48].I n addition, security for these servers can be conﬁgured to bemuch higher with ease[49]. Despite this, only 45% of theTop 1 Million websites support HTTPS[50]. Furthermore, the systems which do operate on HTTPS can have ﬂaws whichcan completely compromise the security of SSL. Korczynskiet al.[51]discovered that even in a relatively small set of Inter-net services, certain elements of the TLS protocol were beingignored or misused. These heavily trafﬁcked websites receivesigniﬁcant amounts of trafﬁc and ﬁnancial transactions, mak-ing it imperative for stronger end-to-end implementations ofTLS. SSL server probing[52,53]has shown an upward trendin positive TLS implementation and healthy cipher use, how-ever the growing reliance on encrypted data ﬂows has madetight adherence to protocols on the server-side fundamentalto effective security throughout the full Internet domain. A fre-quent mistake made by HTTPS servers is the use of self-signedcertiﬁcates. Self-signed certiﬁcates, certiﬁcates which have noauthority to back up their validity, work well in testing situa-tions, but when a server needs accept requests from the publicInternet, these false certiﬁcates are unsafe. In these cases, asigned certiﬁcate from a certiﬁcate authority must be acquiredor purchased. These servers will treat Android trafﬁc the sameway as any trafﬁc and cause the pitfalls for mobile trafﬁc justas they do for desktop clients. Indeed, the most frequent issuewith server conﬁguration is the mishandling of certiﬁcateinstallation[40]. Certiﬁcate management isn’t an automatedprocess. After applying for a certiﬁcate from a certiﬁcateauthority, that certiﬁcate is sent by email to the companywhich sent in the request. This certiﬁcate must then be manu-ally installed in order for clients to believe that the server is infact correct. When certiﬁcates expire following their two orthree year lifespan, a smooth transition to a new certiﬁcatemust be carried out in order to assure maximum uptime. Vra-tonjic et al.[54]found that among many other violations,82.4% of servers investigated used expired or otherwise invalidcertiﬁcates. Again, in the days following the Heartbleed bug,
only 10% of vulnerable servers replaced their potentially com-promised certiﬁcates. Of this 10%, another 14% reused thesame private key which may have leaked[50,55]. These cases demonstrate the difﬁculty that system operators have withhealthy use of certiﬁcates. Indeed, the prevalence of theseincorrectly implemented certiﬁcates has a direct effect ondevelopers and the services that rely on secure Internet connec-108 X. Wei, M. Wolftions. If developers can’t connect to a server outside their con-trol due to an SSL error, the only course of action would be tolower the validation parameters on their application. Bothends of the SSL connection need to maintain the highest levelof security. In order to reach adoption by developers on allplatforms, the system must display a reasonable level of consis-tent functionality. Certiﬁcate management is a tricky and com-plicated aspect of SSL which needs further research, tools, andperspectives to be introduced before it can reach a realisticallyreliable state. New technologies in the burgeoning operationsworld make certiﬁcate management even trickier. ContentDelivery Networks (CDNs) are distributed server farms whichspread out the load on large, public websites. The servers ofthe CDN act as surrogates for the main web server, steppingin the middle of a direct client-server relationship. Thismiddle-man server must be trusted by the server, but any cur-rent method of doing this violates the SSL protocol [15]. Inno- vative methodologies must be contributed to the X.509protocol and the certiﬁcate authority industry to meet the chal-lenge of scaling websites and an ever-increasing pool of vitalwebsites that require certiﬁcates to be properly installed. Untilservers are properly secured, the security of all client applica-tions will suffer. Developers will be wary of using the protocoland the default Internet connection methodology on Androidwill not be HTTPS until it is as easy to implement as cleartextHTTP.3.3. Lacking documentation on HTTPSBeyond the physical limitations of an SSL connection, one ofthe problems which developers face is a lack of proper docu-mentation and a foundation in the importance of applicationsecurity. There is very little research of interactive support todevelopers for secure software development[14]. This informa- tion is critical to expose developers to correct methodologiesand point them in the way of secure Internet connection cre-ation. While the Android platform prides itself on ease ofuse, it can be surprisingly confusing. For instance, manualanalysis of ﬁnancial applications with vulnerabilities in theirinter-app communication yielded the conclusion that severalﬂaws were caused due to developer confusion over Android’scomplexities[56]. The authors stated that they believe thatthese errors, made by security-conscious developers, areindicative of the fact that Android’s Intent system is confusingand tricky to use securely. This subject, completely separatefrom SSL/TLS in terms of purpose and architecture, hasshown that Android is at its core a complex system that is dif-ﬁcult to comprehend from a front-end developer standpoint.Existing documentation and tutorials are not reaching theiraudiences effectively. Approaching the issue of ‘complexity’isn’t an endeavor that can happen with a single update. How-ever, in order to further the security and proper developmentpractices of Android applications, the maintainers of the oper-ating system must work toward abstracting the complexities orputting out better documentation. Further research must gointo the psychology behind technical documentation compre-hension, particularly for Android. One such example of inad-equate training is also the most critical. The Android developertraining on SSL/TLS is sorely lacking in proper examples andimplementation. The training on security is near the bottom ofthe screen and listed below trainings on user interface and per-formance[12]. There is a minimal explanation of the protocolor public key cryptography in general. A lack of solid docu-mentation in popular SSL/TLS libraries also presents an issue[37]. The OpenSSL library documentation[11]is a meaty web- page that can be rather intimidating. It may be that the quickcode snippets of StackOverﬂow are much more appealing. Inseveral prominent libraries, there are examples of generallyconfusing APIs. This will be discussed in the next subsection.In order to fulﬁll their role in the implementation of SSL,libraries must create documentation for developers who arenot cryptography experts. Major security-breaching methodslike AllowAllHostnameVeriﬁer should be documented asbeing for testing purposes only[57]. Finally, there are generalbarriers in coding that need to be broken down in order toallow developers to properly build secure programming princi-ples into their products. Research by Ko et al. [58]has presented ﬁndings on the elements of programming environ-ments which prevent problem solving. The primary takeawayfrom this study is that there is a minimal error reporting infras-tructure in many major IDEs and programming languagecompilers. There are invisible rules that seem to exist withoutmuch documentation and differences in programming inter-faces interfere with the natural ﬂow of problem solving. Notonly do libraries need to be more informative, but applicationdevelopment tools should be smart enough to identify securityﬂaws or inform developers of best practices. A solid documen-tation source would be responsive to user confusion and effec-tive in communicating the most simple, but secure solution.3.4. Flaws in SSL/TLS librariesThe ideal Android HTTPS library would enable developers touse SSL correctly without coding effort and prevent them frombreaking certiﬁcate validation through customization [39]. This would be a model where socket generation and adminis-tration of certiﬁcation authorities are the only responsibilitiesassigned to programmer. It would bridge the gap between con-trol facilities needed to establish HTTPS connections, makingit unnecessary to involve programmers in the development ofevery essential interface in the already complex HTTPS envi-ronment[29]. Furthermore, the API should allow certainrelaxed certiﬁcate validation when the application is being test-ing. Dozens of libraries and SSL/TLS abstraction frameworksexist to make HTTPS easier to use. Despite the goal of makingthe system more approachable, Cairns et al. and others haveshown that major SSL/TLS libraries remain too complicatedand low-level[17,59]. Fahl et al. claim that there is no solidlibrary which provides easy SSL usage[39]. Indeed, it seemsthat frustration with APIs is the guiding factor behind devel-opers resorting to StackOverﬂow to ﬁnd work-arounds. Geor-giev et al. conducted an investigation into critical applicationswhich were compromised due to these ﬂawed or poorly-writtenlibraries[37]. The cURL library is one such confusing library.For example, Amazons Flexible Payments Service PHP libraryattempts to enable hostname veriﬁcation by setting cURLsCURLOPT_SSL_VERIFYHOST parameter to true. Unfortu-nately, this is the wrong boolean to turn on hostname veriﬁca-
tion and thus the middleware and all applications using it arecompromised. PayPals Payment library makes the same mis-take. Not only cURL, but GnuTLS has a misleading gnutls_certiﬁcate_verify_peers2 which leaves the Lynx text-basedSurvey on HTTPS implementation by Android apps 109web browser vulnerable. Poorly worded APIs defeat the goalof libraries to make SSL easier to correctly implement. Com-bined with poor documentation, these libraries can be detri-mental to a healthy public key infrastructure. Otherproblems were pointed out in the study by Georgiev et al. Val-idation was lacking and documentation was so scarce thatusers were led to misuse the suite. Error handling was differentfor each library. This sort of miscommunication between sys-tems has lead developers to frequently use the incorrect SSL/TLS libraries for their speciﬁc problem. For instance, pythonlibraries urllib2 and httplib which do not support certiﬁcatechecking, were used in applications hooking into PayPal andTwitter. The disconnect between end users and libraries canbe bridged with better communication, documentation, andstandards across libraries. Not only are SSL/TLS APIs foundto be often confusing, but some contain their own program-matic holes. Apache Axis, which is used by big-name applica-tions from PayPal and Amazon, implements Apache’sHTTPClient. Axis uses the standard SSLSocketFactory, butomits hostname veriﬁcation. Using the independent nature ofvarious SSL libraries to compare reactions to certiﬁcates, Bru-baker et al. found several holes in major open source librariesand browsers[60]. While efforts in ﬁnding ﬂaws have encour-aged library developers to patch their software, more oversightneeds to go into these libraries which provide the backbone(and reputation) of the HTTPS ecosystem. Making APIs easiergoes hand-in-hand with documentation clariﬁcation and devel-oper education on security[17]. As technology progresses andmore of the Internet supports HTTPS connections, librarieswill be forced to become more user friendly and standard.Issues like Heartbleed, which allowed attackers to sniff pro-tected memory from approximately 25–50% of Alexa top 1million HTTPS sites, while frightening, will encourage morescrutinizing eyes to fall on open source SSL libraries and theinfrastructure which supports it[50]. Security researchers havecalled for more development on these critical open-source pro-jects in order to protect the entirety of the HTTPS infrastruc-ture. Android developers rely on these libraries and they mustbe ﬁrmly in place for developers to use.3.5. Issues in the HTTPS protocolBelow the lowest-level SSL libraries, the TLS/x.509 protocolsare set. Even in this foundation of the HTTPS world, thereare ﬂaws. As Fahl et al. express, the SSL/TLS protocol isn’tforceful enough[24]. Validation checks are not a central partof the SSL/TLS and X.509 standards[22,61]. Recommenda- tions are given in these IETF papers, but the actual implemen-tation is left to the application developer. IETF RFC 2818,Section3.1states that if the client has external informationas to the expected identity of the server, the hostname checkmay be omitted. Both OpenSSL and cURL have issues withthe proper implementation of certiﬁcate validation. Thisleniency in the protocol shifts focus away from a vital partof SSL security. While understandable for developing applica-tions with a limited budget, this guiding document of HTTPSmust be more deﬁnite on the vital subject of hostname veriﬁca-tion especially in production applications. Beyond its weakenforcement of certiﬁcate validation, there are several issueswith the TLS protocol that leave it vulnerable. A couple issuesmentioned in a study by Bhargavan et al.[59]are that the pro- tocol allows cipher suites which have been ruled unsafe andallows reused identities on resumption of sessions which canpotentially break through the process of the TLS handshakeby bypassing it. As security researchers continue to look intothe TLS protocol and its shortcomings, more hardening mech-anisms will be determined. Server-side policies have been pre-sented by the IETF to curb the use of HTTP instead of HTTPSsuch as HTTP Strict Transport Security (HSTS) [62]. Described inFig. 5, they allow for a server to always redirecttrafﬁc to HTTPS through the use of an additional header. Thiseffectively counteracts Moxie Marlinspike’s SSLSniff [42]. Consumers must manually override occurrences of failedHSTS in their browser. However, these ﬁxes are not as effec-tive as client-side HTTPS Everywhere[63]which similarly forces the server to provide the HTTPS version of the service.Unfortunately, no such implementation of HTTPS Every-where for communication libraries exists at the time this paperwas written. The promise of client certiﬁcation validity can
Figure 5Overview of the role of HSTS[64].110 X. Wei, M. Wolfdouble the prevention efforts of man-in-the-middle attacks. AsHTTPS becomes more of a universal standard, it is clear thatcommunication libraries must offer an HTTPS-only stylemethod to protect user data from plaintext servers and HTTPSstripping attacks. Another critical protocol in SSL security,X.509[65], is extremely general and ﬂexible. It has too manycomplexity related security features of which few are used.Parsing X.509 certiﬁcates isn’t simple[66]. Indeed, it also bearsthe pressure of new technologies for which it has no solution.The X.509 Protocol leaves no room for CDNs which havebecome ubiquitous on the Internet[15]. Like the TLS protocol,the X.509 certiﬁcate protocol needs an update which narrowsdown its reach, provides rigidity and standard security mecha-nisms, and is able to adapt to changes in the make-up of Inter-net routing infrastructure. In the current SSL environment,system operators and developers are effected by the corruptionof certiﬁcate authorities. As shown in the work of Amann et al.[67]and Bates et al.[68], the entire CA system is convoluted,unreliable, and overﬂowing with too many CAs [7]. When web certiﬁcates rely on the authenticity of a CA’s web of trust,this web should be as small as possible. Several high proﬁlecases of rogue certiﬁcate issuance in recent years [69,70]have raised questions about the security of these trusted servers[54]. Nearly every major CA has had a large leak of some sort.Certiﬁcate authorities can be socially engineered into surren-dering certs to malicious actors. Their systems can be compro-mised or incorrectly conﬁgured and the system of CAs is liableto fall into capitalistic tendencies which may not be conducivefor healthy certiﬁcate validation. Alternatives have been pre-sented such as Convergence[71]which would replace certiﬁ-cate authorities with notaries which would ping destinationservers to verify the validity of the desired path. Further dis-cussion of the future validation methodologies for SSL isbeyond the purview of this paper. While the CA infrastructurehas dire consequences for SSL security, it isn’t necessarilyapplicable to developer misuse of SSL. Along with the riskymanual installation process which server administrators mustcarry out, the primary ﬂaw in the current CA system whicheffects developers is the process of simply getting a certiﬁcate.Nearly all certiﬁcate authorities require a fee to receive a cer-tiﬁcate[40]. This is not conducive to the widespread acceptanceof HTTPS. Again, as noted by Zhang et al. following the fall-out of Heartbleed[55], a majority of system administratorsfailed to revoke the certiﬁcates which had been reissued. Thisleaves these vulnerable certiﬁcates out in the wild to be usedagainst hosts. The certiﬁcate authority industry needs to adoptstandards which aid the easy, free access to certiﬁcates and asimple installation process. The security community mustwork with system operators to build a more intuitive revoca-tion process. In the best case scenario, the introduction of asimpler method of certiﬁcate deployment and reset wouldsecure the systems of critical Internet applications. Complica-tions and vulnerabilities at the protocol level drip down tothe designs of libraries and applications. In order to assuredevelopers properly use SSL, the system must be no-more dif-ﬁcult to implement than a standard HTTP call.3.6. Need for consumer awarenessFinally, among all of the guilty parties of HTTPS vulnerabili-ties, the most under-noted one is the end user. As the work ofFelt et al. has shown with regards to web browsers, users fre-quently disregard warnings about SSL/TLS [72]. This issue is just as pressing on the Android platform. Another paper byFelt[73]explores Android user attention when shown mes-sages on application permissions. Granting applications per-missions is a critical responsibility which users must bear inorder to protect their privacy and security. Unfortunately,when 308 users were interviewed, only 17% of participantspaid attention to permissions during installation and only3% of respondents correctly answered all three permissioncomprehension questions. What this means is that the popu-lace views their applications as black boxes. Few users are crit-ical of their applications enough to even read the warnings.This is worrisome since the pace of change is set by consumers.Unless end-users desire security, it will not be implemented in awidespread manner. When investigating user comprehensionof HTTPS on Android, the numbers are equally bleak. Anonline survey by Fahl et al. shows that half of the 700 usersquestioned could not determine if they were using HTTP orHTTPS[24]. Many of the participants failed to read the entirewarning message. Participants were mostly college-aged andincluded students majoring in IT-related and non-IT-relatedﬁelds. Results showed that even this age-and-major groupdidn’t have a sufﬁcient understanding of data security. Despitethe difﬁculty which comes with informing users of the risks ofinsecure TLS connections, it seems imperative that no groupcan push developers to properly implement HTTPS more thantheir end users. One subset of the lack of user comprehension isthat Android does not offer any default warning for SSLerrors. This forces developers to provide one for themselvesif they wish to inform users about failed certiﬁcate validations[39]. Furthermore, error reporting in libraries and browsers isbroken[60]. In a study by Brubaker et al. found that during aninvestigation of major browsers, many only reported one erroreven if there were more. It can be presumed that Androidapplications which have much less oversight than these brow-sers have even worse error reporting. Furthermore, the mes-sages produced by libraries aren’t always human readableand the application frequently does little to clarify the message.This leads to an uninformed end-user who clicks throughwarnings that seem unimportant. One notable mistake whichhinders the reputability of SSL errors is the high number offalse ﬂags. A study conducted by Akhawe et al. [40]
found that when analyzing SSL errors on a mass-scale that 1.54% werefalse warnings due to misreading the messages from the SSLAPI. In order for SSL to secure Internet communications,the end-user must remain vigilant of the state of their connec-tion’s integrity and the state of their application’s security.Developers must work to insure that users are informed andable to check the security of the application itself. In the nextsection, we will present a list of solutions proposed byresearchers and industry leaders and their ideas on combatingbroken SSL channels.4. Proposed solutionsSeveral solutions to ﬂaws in Android HTTPS security havebeen proposed in the aforementioned papers, the IETF, andsecurity community as a whole, but a more extensive overhaulis needed to bring this burgeoning platform into the traditionallevel IND-CPA compliance[13]. Changing the way a devel-Survey on HTTPS implementation by Android apps 111oper works on a psychological level is not a feasible solutionand remains out of the purview of this paper. Those seekingto make developers more astute at securing their SSL imple-mentations must focus on support tools and resources. In thissection, using ideas from other platforms and contexts, we willdiscuss a few of the ideas and subject areas which have seensolutions proposed.4.1. Link SSL to DEBUGGABLE ﬂag in the Android manifestBased on research by Fahl et al.[24]and Georgiev et al.[37], Tendulkar et al.[8]suggest changes in the Android manifest toincrease secure development practices. A single link betweenthe DEBUGGABLE ﬂag in the Android manifest and SSL/TLS veriﬁcation would allow developers to build their appsusing mock certiﬁcates while still eventually forcing them tomake their SSL/TLS connections functional in production.Certiﬁcate checks would have to be intact if debugging wasoff, but the app could accept self-signed certiﬁcates if it wason. Applications submitted to the Market with the DEBUG-GABLE ﬂag would be rejected. This solution would directlycounteract many of the issues with developers forgetting theirdebug code in their applications. This is a simple solution thatshould be implemented in the Android manifest. It is the mostdirect and effective solution to allow Android developers towrite safe SSL communications enumerated in this paper.While it may require some coordination between the AndroidMarket maintainers and developers who already have theirapplications live, the change would create a sensible workﬂowfor all developers to follow.4.2. Remove SSLErrorHandlerTendulkar et al. also suggest removing the ability for develop-ers to override SSLErrorHandler[8]. This prevents developersfrom hiding SSL error messages from the end user, forcingthem to ﬁx their code rather than obfuscate incorrect imple-mentations. Coupled with disabling of SSL checks when theDEBUGGABLE ﬂag is triggered, half of SSL vulnerabilitiescould be prevented[8]. This does, however, restrict the pro-grammatic capability of developers and would make debug-ging much more challenging. Instead, warnings or errorscould better announce the danger of leaving certiﬁcate check-ing out of the application.4.3. Android market and client side application validationApplications submitted to the Android market could berequired to undergo scrutiny by MalloDroid [24]or the auto- mated fuzzing framework noted in recent work by Malek et al.[74]. Fuzzing, also talked about in other SSL testing research[37], would test the number of accepted certiﬁcates from ran-domly generated data in a way like Frankencerts [60]. Applica- tions with AllowAllHostnameVeriﬁer[57]would be ﬂagged.Another solution proposed by Enck et al. suggests Kirin [75] as a service within individual devices which would check appli-cations for dangerous permissions and malicious code. Thiscould be reﬁtted into a service which also veriﬁes that applica-tions downloaded properly use HTTPS, ﬂagging applicationsthat use unsafe certiﬁcate veriﬁcation methods or custom rootstores. This device-based solution would not only protect aphone from the Android Market, but also apps in open-source repositories like F-Droid[76]. This solution wouldnot prevent developers from writing non-HTTPS code, butwould stop these applications from reaching production mar-kets. Difﬁculties of implementing this include the setup andoversight required by market operators and the added restric-tions placed on applications which may not deal in sensitivedata.4.4. Use SSL pinningAnother solution suggested by many researchers is theincreased use of SSL Pinning. A pinning strategy using Truston First Use (TOFU) retrieves the certiﬁcate from a websitewhen it is ﬁrst accessed. Every further connection comparesthe cached cert to the one which has been sent. This tacticis already used with success in SSH as Key Continuity Man-agement. The user must trust the server on the ﬁrst access,but all future sessions are more secure. The technology ofHTTPS Strict Transport Security with pinning (HSTS) [77] forces all clients which wish to connect to a server to doso by HTTPS. Any situations where there is a mismatch willforce a new session to be held to renegotiate certiﬁcates. Thismay be a hefty burden on bandwidth and may break servicesalready in place. However, this technology would preventattacks from rogue CAs, SSL stripping, session hijacking,and developers who do not use secure HTTP from connect-ing to secure servers. Coupled with other SSL protocolimprovements, pinning could round out HTTPS, formingan effective foundation for Android applications that devel-opers can rely on. SSL pinning relies on the validity of aninitial connection and may become burdensome on the enduser, leading to further manual overrides and apathy towardweb security.4.5. Improve documentation and API clarityDeveloper misuse of SSL can be mitigated can also be miti-gated through better documentation and clearer APIs. Casesof unclear APIs are speciﬁc and should be continually analyzedand reported by the community. Consistent error reporting byAPIs can aid in a better understanding of how developersshould solve for SSL instead of against it[37]. Code analysis techniques and intelligent suggestions could be adopted byIDEs to check SSL implementations in real-time [58]. Further- more, Android platform maintainers with the help of thedevelopment and security communities need to create a morecomprehensive and educational source of information on cor-rect implementations of HTTPS in both testing and produc-tion systems. One small example is that the Android‘‘Preparing to Release”
checklist should include informationabout removing debug code in applications and ensuring theapplication does not accept self-signed certiﬁcates [65]. Improving documentation is as close to improving the devel-oper paradigm as is possible. Updating documentation is nota trivial task and may take years to update across the entireecosystem. However, new tools which aid in the developmentof SSL session creation should be sure not only to explainhow to successful connection, but also the importance of prop-erly approaching the debugging vs production certiﬁcate man-agement situation.112 X. Wei, M. Wolf4.6. Begin persistent Internet-wide SSL vulnerability scanningResearch conducted by the EFF, Durumeric et al. [50], Zhang et al.[55], Levillain et al.[52], and others following Heartbleedhave shown that widespread scanning of the Internet for holesin the security of SSL are possible. These scans identify exactlyhow safe some hosts and servers are and potentially whereattacks are originating from. As shown in the work of Duru-meric et al. has presented, these scans also allow for research-ers to notify server operators whose systems may be vulnerableto attack. This type of notiﬁcation has proven effective inimproving the safety of the Internet. A movement towardInternet-wide vulnerability scanning has positive implicationsfor patching the security of the HTTPS. As new paradigmsfor SSL analysis are developed[51], the capacity for SSLadherence analysis becomes greater. Yet, the growing numberof network ﬂows across the internet will make tracing individ-ual applications and versions more challenging. Any observa-tory must accurately and transparently identify applicationsthat may be at risk and be able to notify the developers atonce.4.7. Patch and increase oversight on SSL librariesIn order to secure SSL implementations on every platform,SSL libraries and middleware with ﬂaws in their validationand revocation checks mentioned in the previous section needto be patched. Design refactoring of current libraries shouldfocus on hiding low-level code. A system similar to HTTPSEverywhere should be used in Android communication APIs[63,24]. As libraries are more and more utilized, their codeneeds to be scrutinized and brought into a state of security thatis both forward-looking and all-encompassing. Large compa-nies which handle critical data should be contributing effortstoward the improvement of open-source SSL libraries and pro-tocols. Changes to libraries may roll out slowly across the SSL/TLS ecosystem, but they would become the cornerstone of safeAndroid web development.4.8. Large mobile applications should use stronger HTTPSprotectionsIn a more speciﬁc sense, large mobile applications made byFacebook, Amazon, and Google have the ability to verify theirown certiﬁcates in mobile applications and detect MITMattacks[41]. Certain companies which can spare the bandwidthand application space should look into origin bound certs(OBCs)[41]and the use of HSTS[15]. These ﬁxes are moreof a server-side change than anything, but their use can securepopular mobile applications. Depending on the success ofthese systems, APIs for third-party apps which hook into com-pany servers could also require clients to have certiﬁcates. Thismay prove challenging in scenarios where the application isclosed source. However, even black box approaches [51]are able to identify certain patterns in SSL trafﬁc that indicateunsafe SSL usage. The technology industry seems to under-stand the importance of SSL, but implementations of thestrongest and arguably the most complex security measuresin reality are rarely ideal.4.9. Revise the TLS protocol suiteBeyond issues with developers, the TLS protocol needs torevised to allow for further progress in technological security.IETF RFC 2818, Section3.1 [61], which deals with HTTP overTLS, needs to be revised to be more strict on validation guide-lines. The protocol must require hostname and certiﬁcate val-idation and the community must adopt the strongest standardpossible and implement it correctly. From there, applicationswhich deal with user data can be built. The IETF [78]gives the following recommendations to certiﬁcate authorities andclient developers:/C15Move away from including and checking strings that looklike domain names in the subjects Common Name./C15Move toward including and checking DNS domain namesvia the subject AlternativeName extension designed for thatpurpose: dNSName./C15Move toward including and checking even more speciﬁcsubjectAlternativeName extensions where appropriate forusing the protocol (e.g., uniformResourceIdentiﬁer andthe otherName form SRVName)./C15Move away from the issuance of so-called wildcard certiﬁ-cates (e.g., a certiﬁcate containing an identiﬁer for ‘‘ *.exam ple.com”).Furthermore, the X.509 needs revision[21]. In order to make way for CDNs, several amendments have been sug-gested, such as DNS-Based Authentication of Named Entities(DANE)[79,15]. In order to defend the protocol from resump-tion attacks, the suggestion made by Bhargavan et al. [59]is to create a new channel binding that would serve as a unique ses-sion hash. Master secrets thus beneﬁt from this nonce. Also,secure resumption indicator which forces connections to checkprevious sessions is recommended. Stricter name constraintscan deﬁne exactly who is receiving a certiﬁcate and make socialengineering more difﬁcult. However, certiﬁcate transparency
(CT) represents a more promising proposal. It compiles a listof all existing certiﬁcates on the Internet. This allows for thepublic to view and investigate fraudulent certs issued in prepa-ration for MITM attacks. This protocol, of course, relies oninterested parties, like the EFF’s SSL observatory to pay atten-tion[66]. This could also help CAs determine the validity ofcert requests. Combining CT and pinning would greatlyincrease security[67]. The openness of these systems will bothspread awareness of SSL security, but hopefully spur furthereducational materials and human-friendly implementations.One other addendum to the protocol would establish a systemthat rather than allowing certiﬁcates to expire and throw afatal error immediately, have certs warn the administratorfor a week before throwing the error and more relaxed warn-ings[40]. CAs can use more speciﬁc revocation lists– somefor normal expirations and some for blacklists [40]. These two solutions would stop a large number of false positivewarnings which undermine the social comprehension of SSL.Finally, Android speciﬁcally could beneﬁt from implementinga device-wide web security policy[80]which would guide itsspeciﬁc implementations of SSL to a strong standard. TheTLS/X.509 protocol can beneﬁt from dozens of new additionsand speciﬁcations which will meet the needs of the applicationsSurvey on HTTPS implementation by Android apps 113which use it. The main limitation remains what directionwould be the most sustainable solution moving forward, gar-nering both industry and academic support. While theseincreases in strictness will make the line drawn between secureand insecure architectures clear, it may pose an issue to devel-opers and users who are looking for performance and avail-ability over security. Suggestions for a warning escalationsystem may alleviate the pressure on developers and systemadministrators, much innovation and discussion remainsbefore a proper certiﬁcate architecture that solves for bothsecurity and usability can be put in place.4.10. Increase consumer awarenessGaining user pressure on developers seems to be possible atthis point to in only a few ways. If platform developers wereto implement an effective non-HTTPS warning system inAndroid, the hands of developers would be pushed [24]. This would not alert all users, but it would alert those who are secu-rity conscious. Going further and preventing users from goingto sites with misconﬁgured SSL/TLS forces developers to ﬁxtheir authentication issues though it may inconvenience a user[72]. Less frequent and more accurate warnings may stop theend user from ignoring the errors since a user will obviouslyclick through messages if they are bombarded with them[40]. The end user is most familiar with SSL when it gives theman error. These interactions need to be more meaningful andhuman-understandable. As with any security education, plac-ing proper importance on SSL/TLS will require concreteexamples and explanations about why sites with broken certiﬁ-cates should be avoided almost completely.5. Discussion and future work5.1. Gaps in researchThis survey contains data from a wide range of academicpapers and recent events; however, the topic of Android devel-oper misuse of HTTPS is not solved. There are no interviewswhich answer the ‘why’ question or truly get into the develop-ers’ heads. Why don’t developers ﬁx the holes in their codenoted in the work by Fahl et al.[39]? Why do developers useHTTP when using HTTPS may require only changing theURL in the call? The answers to these questions are currentlyconjectures. While steps are made to implement the solutionsabove, a deeper look into the psychological and potentiallysociological underpinnings of SSL implementation is needed.Research into developer understanding of SSL documentationis lacking. While it is clear that their knowledge of cryptogra-phy may not be strong[17], there has been no research into thespeciﬁc tools which developers need to create a secure HTTPSconnection. There have been no tools, as of this writing, whichcheck the security of HTTPS calls as they are written in anIDE. Much of existing research revolves around static codeanalysis of applications. Codebases that are not publicly avail-able have generally not been included. Research is still wantingin how strongly closed source Android apps follow the TLSprotocol and how these implementations compare to thoseseen in open source repositories. While the prevalence ofMITM attacks in the wild has been investigated, the preva-lence of MITM attacks against Android phones has not beenstudied on such a scale. Another area of SSL ecosystemresearch which is not clear is the effect of implementing HSTSand OBCs on a modern cellular or wireless network. Finally,there is little research in the ﬁeld of an Android implementa-tion of the DANE protocol and similar tools. Determiningthe effectiveness of these tools on the Android platform oras an extension in an Android browser is an important toolin deciding how to better secure HTTPS on Android and makeit the standard protocol of the platform.5.2. Moving forwardThe previous sections opens up several ideas for next steps inresearch to prevent Android developer misuse of HTTPS. Inthis section, we will present some recommendations for futurework. A productive solution to the issue of misinformationand SSL ignorance would be the creation of an online resourcewhich exists as a single, accurate reference for the growingnumber of Android developers seeking to implement HTTPSin their applications. This solution would work with existingparties such as Android Developer Training and Stack Over-ﬂow to present credible and understandable information. Aproject in this ﬁeld would include a primer on public keyinfrastructure, the proper usage of HTTPS, current attackson SSL, a presentation of the most popular ways of imple-menting TLS on Android, and directions on how to acquirea server certiﬁcate. The presentation would be easy to readand include links to resources for further study and morespeciﬁc problem solutions. A plugin to an IDE which wouldprovide real-time feedback on the legitimacy of HTTPS callscould be developed in order to point out mistakes to develop-ers. Similar to warnings which arise when using C’s vulnerablestrcpy, this plugin could then be tested for effectiveness atproperly informing developers of their mistakes and the properway to implement SSL. This plugin would need to returnhuman readable and speciﬁc errors. An experimental plugin,emphaSSL[45]has been developed pursuant of this idea.The review of 75 open-source applications showed that 40%of the applications had signiﬁcant violations of TLS protocol.This is concerning given the popularity of some of these appli-cations and the sensitive data they transmit. Further researchis needed to determine how effective feedback within theIDE is for developers and how to best present security sugges-tions during the product creation lifecycle. Fahl et al. [24]men- tion the implementation of their service MalloDroid as part ofthe Android Market or as a web application. In order to bringthe beneﬁts of Mallodroid to end users, an experimental ser-vice based off Mallodroid could be developed which woulddetect applications with vulnerable SSL connections and ﬂagthe program operator. This would ﬁt into a model of anAndroid Market app or an end user device. This experimentwould present either of these models with static code checkingat its core and predict success rates. Furthermore, the work ofYao et al.[81]could be used by market administrators and net-work watchdogs to identify insecure trafﬁc and identify theapplications and speciﬁc software versions which are vulnera-ble. Individual ﬂows could be analyzed for weak ciphers,expired and self-signed certiﬁcates, as well as completelyplain-text packets. This would give greater oversight on exist-ing network trafﬁc at a more practical and automated levelthan static code analysis and would open up oversight to114 X. Wei, M. Wolfclosed-source applications. Implementations of trafﬁc ﬁnger-printing and analysis have been conducted[51,52], which give great insights to the way that various Internet services handleSSL overall. As mentioned in the work of Georgiev et al. [37], several open source libraries could beneﬁt from a rewordedAPI and stronger documentation. Another project whichcould originate from this survey would be an effort to presentclear method names and contributions to these open sourcelibraries. This would require strong collaboration with securityexperts in the community and further research into psycholog-ical implications of programming syntax. One of the morespeciﬁc solutions for Android which could come from workexisting on a desktop scale would be the implementation ofCDNSEC[82], a Firefox add-on that demonstrates the DANEprotocol, as an Android service. While this would serve a veryspeciﬁc purpose based deeply in the work of Liang et al. [15] and not so much on the SSL comprehension for developers,it would be the ﬁrst step toward adoption of DANE and inextension, forward-thinking SSL security, on multiple plat-forms. Furthermore, the development of Convergence [71],a CA-free certiﬁcate validation system on the Android platformwould allow for the promising protocol to expand and test theimplications of the overhead on mobile phones.A less technical research project could be conducted in asimilar manner to that of Xie et al.’s survey of developers[14], but focus on asking developers what their major chal-lenges were in implementing HTTPS. Following the survey,the experimenters could look into the applications made bythese developers to see how the SSL was implemented. Conclu-sions drawn from this would go into reﬁning documentation,educational materials, and SSL libraries. Furthermore, devel-opers could be presented with a situation which requires anHTTP call in their chosen language. The experimenters wouldthen record the comprehension of the developer, whether ornot web resources were used, and how well this implementa-tion would withstand a MITM attack.Again, a device-wide security policy could be proposed ordiscussed in further research which would encourage Androiddevelopers to adopt a standard set of security procedures andset a benchmark for SSL usage. This exists in diverse for-mats, but the presentation of a uniﬁed system would fulﬁllthe call issued by Jeff Hodges and Andy Steingruebl for aweb security policy framework[80], but with a particularlymobile lean.The development of a sustainable Internet-scanning servicefor security researchers would allow for further research intothe shortcomings that still exist within the HTTPS protocolin its current form. This tool would be available to researchers,commercial entities, and security organizations in order to ﬁndholes to patch. The outcome would be much like the work ofDurumeric et al. following Heartbleed[50], extensive notiﬁca-tion of vulnerable entities with the hopes that these systemswould be patched quickly. Further solutions will certainly arisefor the Android platform as research into new protocols, lan-guages, and programming paradigms continues.6. ConclusionThis paper has compiled current research on vulnerableHTTPS implementations and lacking protocols. We lookedat the current shortcomings in the real-world application ofend-to-end transport security, listed the areas in SSL whichneed improvement, and presented the current proposals ofsolutions to these areas. It is clear that Android developersremain unable to properly use the protocol in their applica-tions due to reasons within and without their reach. Even in si-tuations where the implementation is syntactically correct,there can be ﬂaws along the chain of communication or inthe CAs which back up the trust web of SSL. User-facingapplications, SSL libraries, protocols, and infrastructure havelimitations which must be further investigated. Most notably,the areas of education and support tools for developersrequire research and resolution. Evaluation of the solutionspresented by the papers was brought together in this surveyand including them into the next set of TLS/X.509 protocolsand versions of SSL libraries will ensure user data integrityand security in a mobile environment that continues to seegrowth in the amount of conﬁdential data transmitted. Fromthese solutions, developers will beneﬁt and this will trickledown to end users.References
[1] IDC, Worldwide smartphone market grows 28.6% year overyear in the ﬁrst quarter of 2014, according to idc, Tech. rep.,IDC, 2014. <http://www.idc.com/getdoc.jsp?containerId=prUS24823414>.[2]
J. Burns, Mobile application security on android, in: Black HatUSA, 2009
.[3] H. Wilcox, Press release: Juniper research forecasts total mobilepayments to grow nearly ten fold by 2013, Tech. rep., JuniperResearch, 2008. <http://www.juniperresearch.com/viewpressrelease.php?pr=106>.[4] P. Ruggiero, J. Foote, Cyber threats to mobile phones, Tech.rep., 2011. <https://www.us-cert.gov/sites/default/ﬁles/publications/cyber_threats-to_mobile_phones.pdf >. [5]
H. Hwang, G. Jung, K. Sohn, S. Park, A study on mitm (man inthe middle) vulnerability in wireless network using 802.1x andeap, in: IEEE ICISS, 2008
.[6] T. King, Packet snifﬁng in a switched environment, SANSReading Room. <https://www.sans.org/reading-room/white-papers/networkdevs/packet-snifﬁng-switched-environment-244 >. [7] Revisiting ssl: a large scale study of the internet’s most trustedprotocol, Tech. rep., 2012.[8] V. Tendulkar, Mitigating android application ssl vulnerabilitiesusing conﬁguration policies, North Carolina State University,2013.http://repository.lib.ncsu.edu/ir/bitstream/1840.16/8840/1/etd.pdf.[9] BLS, Occupational outlook: Computer programmer, Tech. rep.,US BLS, 2012. <http://stats.bls.gov/ooh/computer-and-information-technology/computer-programmers.htm >. [10] The Legion of Bouncy Castle, The Legion of Bouncy Castle.<http://bouncycastle.org>.[11] OpenSSL Project, OpenSSL. <http://www.openssl.org/>. [12] Security with HTTPS and SSL, android Developer Training.<https://developer.android.com/training/articles/security-ssl.html>.[13]
M. Egele, D. Brumley, Y. Fratantonio, C. Kruegel, An empiricalstudy of cryptographic misuse in android applications, in: ACMCCS, 2013
.[14]
J. Xie, H.R. Lipford, B. Chu, Why do programmers makesecurity errors?, in: IEEE VL/HCC, 2011
[15]J. Liang, J. Jiang, H. Duan, K. Li, Kang, T. Wan, J. Wu, Whenhttps meets cdn: a case of authentication in delegated service, in:IEEE S &P, 2014
.Survey on HTTPS implementation by Android apps 115[16]M. Egele, D. Brumley, Y. Fratantonio, C. Kruegel, An empiricalstudy of cryptographic misuse in android applications, in: ACMCCS, 2013
.[17]
K. Cairns, G. Steel, Developer-resistant cryptography, in: W3C/IAB STRINT, 2014
.[18] Y. Zou, X. Wang, L. Hanzo, A survey on wireless security:Technical challenges, recent advances and future trends, CoRRabs/1505.07919. <http://arxiv.org/abs/1505.07919>. [19] Microsoft, SSL/TLS in Detail. <http://technet.microsoft.com/en-us/library/cc785811.aspx>.[20] The transport layer security (tls) protocol, rFC 5246.<http://tools.ietf.org/html/rfc5246>.[21] Internet x.509 public key infrastructure certiﬁcate and certiﬁcaterevocation list (crl) proﬁle, rFC 5280. < http://tools.ietf.org/ html/rfc5280>.[22] X.509 internet public key infrastructure online certiﬁcate statusprotocol – ocsp, rFC 6960. <http://tools.ietf.org/html/rfc6960>.[23] Microsoft, How Certiﬁcates Work. < http://technet.microsoft.com/en-us/library/cc776447%28v=WS.10%29.aspx >. [24]
S. Fahl, M. Harbach, T. Muders, L. Baumga ¨rtner, B. Freisleben, M. Smith, Why eve and mallory love android: ananalysis of android ssl (in)security, in: ACM CCS, 2012
. [25] The internet engineering task force. < http://www.ietf.org/>. [26] Heartbleed bug. <http://heartbleed.com/>. [27] Debian security advisory 1571. <http://heartbleed.com/>. [28] Netcraft, April 2014 web server survey, Tech. rep., Netcraft,2014. <http://news.netcraft.com/archives/2014/04/02/april-2014-web-server-survey.html>.[29]
I. Buitron-Damaso, G. Morales-Luna, Https connections overandroid, in: IEEE CCE, 2011
.[30] Trusted roots. <http://www.setupmobile.se/wp-content/uploads/2011/11/trusted_roots_ICS.txt>. [31] Android, URLConnection. <https://developer.android.com/reference/java/net/URLConnection.html >. [32] Oracle, JSSE. <http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html>. [33] GnuTLS, GnuTLS. <http://gnutls.org/>. [34] Haxx, cURL. <http://curl.haxx.se/>. [35] Apache, HTTPClient – SSL Guide. < https://hc.apache.org/ httpclient-3.x/sslguide.html>.[36] Amazon, Amazon Flexible Payment Service.<https://payments.amazon.com/developer >. [37]
R. Anubhai, D. Boneh, M. Georgiev, S. Iyengar, S. Jana, V.Shmatikov, The most dangerous code in the world: validating sslcertiﬁcates in non-browser software, in: ACM CCS, 2012
. [38] Vulnerability note vu#582497: Multiple android applicationsfail to properly validate ssl certiﬁcates. < http://www.kb.cert. org/vuls/id/582497>.[39]
S. Fahl, M. Harbach, H. Perl, M. Koetter, M. Smith,Rethinking ssl development in an appiﬁed world, in: ACMCCS, 2013
.[40]
D. Akhawe, B. Amann, M. Vallentin, R. Sommer, Here’s mycert, so trust me, maybe?: understanding tls errors on the web,in: WWW, 2013
.[41]
L.S. Huang, A. Rice, E. Ellingsen, C. Jackson, Analyzing forgedssl certiﬁcates in the wild, in: IEEE S&P, 2014
. [42] Moxie Marlinspike, SSLSniff. < http://www.thoughtcrime.org/software/sslsniff/>.[43]
M. Ongtang, S. McLaughlin, W. Enck, P. McDaniel,Semantically rich application-centric security in android, in:ACSAC, 2009
.[44] Cwe-489: Leftover debug code. < http://cwe.mitre.org/data/index.html>.[45]
X. Wei, M. Wolf, L. Geo, K.H. Lee, M. Huang, N. Niu,emphassl: towards emphasis as a mechanism to harden networksecurity in android apps, in: IEEE GLOBECOM, 2016
.[46] Stack overﬂow. <http://stackoverﬂow.com/>. [47] Stack overﬂow: Ssl – untrusted certiﬁcate error. < http:// stackoverﬂow.com/questions/2642777/trusting-all-certiﬁcates-using-httpclient-over-https>.[48] Setting up Apache HTTP Server with SSL support on Ubuntu/Debian. <http://softwareinabottle.wordpress.com/2011/12/18/setting-up-apache-http-server-with-ssl-support-on-ubuntudebian/>.[49] Apache, SSL/TLS Strong Encryption: How-To. < http://httpd. apache.org/docs/2.4/ssl/ssl_howto.html>. [50]Z. Durumeric, J. Kasten, D. Adrian, J.A. Halderman, M.Bailey, The matter of heartbleed, in: ACM IMC, 2014
. [51]
M. Korczynski, A. Duda, Markov chain ﬁngerprinting toclassify encrypted trafﬁc, in: IEEE INFOCOM, 2014
. [52]
O. Levillain, A. Ebalard, B. Morin, H. Debar, One year of sslinternet measurement, in: ACM ACSAC, 2012
. [53]
H. Lee, T. Malkin, E. Nahum, Cryptographic strength of ssl/tlsservers: current and recent practice, in: ACM IMC, 2007
. [54]
N. Vratonjic, J. Freudiger, V. Bindschaedler, J. Hubaux, Theinconvenient truth about web certiﬁcates, in: WEIS, 2011
. [55]
L. Zhang, D. Choffnes, D. Levin, T. Dumitras, A. Mislove, A.Schulman, C. Wilson, Analysis of ssl certiﬁcate reissues andrevocations in the wake of heartbleed, in: ACM IMC, 2014
. [56]
E. Chin, A. Felt, K. Greenwood, D. Wagner, Analyzing inter-application communication in android, in: ACM MobiSys, 2011
. [57] Apache, AllowAllHostnameVeriﬁer. < http://developer. android.com/reference/org/apache/http/conn/ssl/AllowAllHostnameVeriﬁer.html>.[58]
A.J. Ko, B.A. Myers, H.H. Aung, Six learning barriers in end-user programming systems, in: IEEE VL/HCC, 2004
. [59]
K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Pironti, P.Strub, Triple handshakes and cookie cutters: breaking and ﬁxingauthentication over tls, in: IEEE S&P, 2014
. [60]
C. Brubaker, S. Jana, B. Ray, S. Khurshid, V. Shmatikov, Usingfrankencerts for automated adversarial testing of certiﬁcatevalidation in ssl/tls implementations, in: IEEE S&P, 2014
. [61] Http over tls, rFC 2818. <http://tools.ietf.org/html/rfc2818>. [62] Http strict transport security (hsts), rFC 6797. < http://tools. ietf.org/html/rfc6797>.[63] EFF, HTTPS Everywhere. < https://www.eff.org/https-everywhere>.[64] Http strict transport security hsts. < http://scratchingsecurity.blogspot.com/2013/06/http-strict-transport-security-hsts.html>.[65] Android, Preparing for Release. < http://developer. android.com/tools/publishing/preparing.html >. [66] An observatory for the ssliverse. < https://www.eff.org/ﬁles/DefconSSLiverse.pdf>.[67] Using frankencerts for automated adversarial testing of certiﬁcatevalidation in ssl/tls implementations, in: ACSAC, 2013.[68]
A. Bates, J. Pletcher, T. Nichols, B. Hollembaek, K.R.B. Butler,Forced perspectives, in: ACM IMC, 2014
. [69] P. Hallam-Baker, Comodo ssl afﬁliate the recent ra compromise,Comodo Blog. <https://blogs.comodo.com/uncategorized/the-recent-ra-compromise/>.[70] Microsoft security advisory 2607712. < https://technet. microsoft.com/en-us/library/security/2607712.aspx >. [71] Convergence. <http://convergence.io/>. [72]
A. Felt, R. Reeder, H. Almuhimedi, S. Consolvo, Experimentingat scale with google chrome’s ssl warning, in: ACM CHI, 2014
. [73]
A. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, D. Wagner,Android permissions: user attention, comprehension andbehavior, in: ACM SOUPS, 2012
.[74] S. Malek, N. Esfahani, T. Kacem, R. Mahmood, N. Mirzaei, A.Stavrou, Packet snifﬁng in a switched environment (2012).<http://mason.gmu.edu/nesfaha2/Publications/SERE2012.pdf>.116 X. Wei, M. Wolf[75]W. Enck, M. Ongtang, P. McDaniel, On lightweight mobilephone application certiﬁcation, in: ACM CCS, 2009
. [76] F-Droid, F-Droid. <https://f-droid.org/>. [77] Certiﬁcate pinning extension for hsts, updated http://tools.ietf.org/html/rfc6797. <http://www.ietf.org/mail-archive/web/websec/current/pdfnSTRd9kYcY.pdf>. [78] Representation and veriﬁcation of domain-based applicationservice identity within internet public key infrastructure usingx.509 (pkix) certiﬁcates in the context of transport layer security(tls), rFC 6125. <http://tools.ietf.org/pdf/rfc6125.pdf>.[79] The dns-based authentication of named entities (dane) transportlayer security (tls) protocol: Tlsa, rFC 6698. < http://tools.ietf. org/html/rfc6698>.[80] The need for a coherent web security policy framework, 2010.<http://www.w2spconf.com/2010/papers/p11.pdf >. [81]
Y. Hongyi, R. Gyan, A. Tongaonkar, L. Yong, M. ZhuoqingMorley, Samples: self adaptive mining of persistent lexicalsnippets for classifying mobile application trafﬁc, in: ACMMobiCom, 2015
.[82] GitHub, DANE4CDN. <https://github.com/cdnsec/dane4cdn>.Survey on HTTPS implementation by Android apps 117