A survey on the formalisation of system requirements and their validation
Konstantinos Mokos, Panagiotis Katsaros*
School of Informatics, Aristotle University of Thessaloniki, 54124 Thessaloniki, Greece
ARTICLE INFO
Keywords:Requirement speciﬁcationRequirement formalisationSemantic analysisModel-based designComponent-based designFormal veriﬁcationABSTRACT
System requirements deﬁne conditions and capabilities to be met by a system under design. They are a partialdeﬁnition in natural language, with inevitable ambiguities. Formalisation concerns with the transformation ofrequirements into a speciﬁcation with unique interpretation, for resolving ambiguities, underspeci ﬁed references and for assessing whether requirements are consistent, correct (i.e. valid for an acceptable solution) and attain-able. Formalisation and validation of system requirements provides early evidence of adequate speci ﬁcation, for reducing the validation tests and high-cost corrective measures in the later system development phases. Thisarticle has the following contributions. First, we characterise the speci ﬁcation problem based on an ontology for some domain. Thus, requirements represent a particular system among many possible ones, and their speci ﬁcation takes the form of mapping their concepts to a semantic model of the system. Second, we analyse the state-of-the-art of pattern-based speciﬁcation languages, which are used to avoid ambiguity. We then discuss the semanticanalyses (missing requirements, inconsistencies etc.) supported in such a framework. Third, we survey relatedresearch on the derivation of formal properties from requirements, i.e. veri ﬁable speciﬁcations that constrain the system’s structure and behaviour. Possibleﬂaws in requirements may render the derived properties unsatis ﬁable or not realizable. Finally, this article discusses the important challenges for the current requirements analysistools, towards being adopted in industrial-scale projects.
1. IntroductionRequirements engineering is of vital importance in systems engi-neering. It consists of the elicitation, speci ﬁcation and management of requirements, with the aim to deliver a system that meets the stake-holders’needs.System requirementsspecify how the system will meet the higher-levelstakeholder requirements (also called early requirements). These re-quirements are a partial speciﬁcation of a system solution to a designproblem that is not restricted to a speciﬁc design. Since requirements are usually written using a controlled natural language (i.e. restricted insyntax and/or lexical terms), they are inevitably ambiguous. This un-dermines our ability to guarantee essential qualities, such as the absenceof underspeciﬁed references to system entities and inconsistencies, aswell as that the speciﬁcation is valid for an acceptable solution (correct)and attainable. Possibleﬂaws in system requirements imply iteratedcostly cycles of validation testing and corrections to the system ’s design, during the later phases of system development.Therefore, the potential to properly validateandreﬁnethe system requirements, early in the development cycle, and to apply this toindustrial-scale projects is a challenge that has not yet been adequatelyaddressed in the current state of practice. Validation is associated withthe problem of transforming requirements into a formal speci ﬁcation amenable to veriﬁcation (requirements formalisation). This implies that all detected ambiguities and underspeciﬁed references have been resolved, while a mapping to a precisely deﬁned semantic model of the system hasbeen speciﬁed. We therefore assume that speciﬁcation takes place with reference to adomain model, i.e. an ontology with precisely deﬁned logical relationships and facts about the concepts mentioned in the re-quirements of a system’s domain. Potential ambiguities can be elimi-nated if using a language ofrequirement patternswith well-deﬁned semantics. Then, various semantic analyses can be supported, likedetecting cases of missing requirements, checking the absence of con-tradictory speciﬁcations, discovering terms to be replaced with moreconcrete subclasses of a concept and so on. However, even after havingapplied these analyses, there is not yet any guarantee for the absence ofspeciﬁcationﬂaws; though they improve the system requirements at thesemantic level, they cannot render them veriﬁable. This may be happen only if the system requirements are satisﬁable and realizable, something that can be decided after they have been transformed into a formal
* Corresponding author.E-mail addresses:kmokos@csd.auth.gr(K. Mokos),katsaros@csd.auth.gr(P. Katsaros).
Contents lists available atScienceDirect
Array
journal homepage:www.elsevier.com/journals/array/2590-0056/open-access-journal
https://doi.org/10.1016/j.array.2020.100030Received 1 January 2020; Received in revised form 7 May 2020; Accepted 9 May 2020Available online 28 May 20202590-0056/©2020 The Authors. Published by Elsevier Inc. This is an open access article under the CC BY license ( http://creativecommons.org/licenses/by/4.0/ ).Array 7 (2020) 100030speciﬁcation.This takes place, when capturing system requirements by propertiesin a logic language, for the expected behaviours and structure of a correctsystem design. While requirements are supposed to be independent froma particular system design, properties are expressed in terms of a formal model(i.e. an abstracted representation in a speci ﬁcation language with formal semantics) of the system under design and in fact constrain thesystem’s design. Properties derivation can be based on a language ofproperty patterns, where each pattern has been assigned semantics in alogic language. Every single requirement is covered by properties thatcan be derived through property patterns associated with the speci ﬁc patterns of the requirement’s speciﬁcation and by associating the re- quirement’s concepts to events of the system ’s formal model. This en- sures that all requirements have a consistent interpretation with respectto the system’s formal model. If the properties are not satis ﬁed by the model, then a modiﬁed design (and model) has to be pursued or certainrequirements that are not satisﬁed have to be reﬁned. This article covers all mentioned challenges of formalisation andvalidation of system requirements, reviews the latest state-of-the-art anddiscusses the existing pattern languages, the available tools and theirlimitations with respect to the potential of applying them in industrial-scale projects.The rest of the article is structured as follows. The next section dis-cusses the problems of ambiguity and underspeci ﬁcation in natural lan- guage requirements. Section3presents the recent advances on theontology-based modeling of system requirements, their speci ﬁcation by means of appropriate pattern languages and the supported semanticanalyses. Section4discusses the problem of requirement formalisationthrough the derivation of formal properties. This problem is related to theproblem of system design and for this reason we also present the twomain paradigms of model-based and component-based system design.Both design paradigms are relevant to the description of the four relatedtools in Section5. Finally, Section6explains the limitations and the important challenges for applying a requirements formalisation/valida-tion approach to industrial-scale projects. The last section concludes thepaper and discusses some more future research prospects.2. Ambiguity and underspeciﬁcation in natural languagerequirementsAmbiguityin a natural language requirement stems from the possi-bility of interpreting it in different ways. The problem may be attributedto the syntax (e.g. ambiguous grouping of connectives) or its semantics,i.e. when there are multiple readings for a word or a vague adjunct [ 1], but it may be also due to neglecting some contextual information of aword. Ambiguous requirements with many interpretations allow inter-facing code, usually written by different engineers, to operate underdiverse assumptions [2]. The problem is exacerbated if the author is notavailable for clariﬁcations, when the requirements are interpreted, dur-ing the system’
s implementation. This is a particularly hard problem,since there are various kinds of meaning [ 3] encoded in the lexical or grammatical structure of sentences. For system requirements, we focuson a sentence-meaning that is exhausted by the propositional content ofsentences, which is truth-conditionally explicable (i.e. the truth of theproposition depends on something outside the language that is used [ 4]). Also, a requirement may be impossible to be interpreted, when somerequired details are missing. In [5], this problem is referred asincom- pletenessof individual requirements and it is associated with likelyincomplete and/or incorrect design of the system architecture, due toadopting potentially incorrect guesses or assumptions. As expected,incomplete requirements are not veriﬁable and they can imply serious safety issues in systems design. For example [ 6], when the verb“send”is used, two arguments are expected, the “sender”and the“recipient”. If the “recipient”is omitted, it is not possible to know whether there are one ormore recipients. Thus, for every predicate (verb, noun, adjective, prep-osition), all obligatory arguments have to be speci ﬁed. A promisingapproach to address the incompleteness of individual requirements [ 5]i s to adopt adequate notions of completeness, for every single type ofrequirement (functional, inreface, extra-fuctional etc.).Underspeciﬁcationsrefer to using words that denote an entire class ofobjects, without a modiﬁer specifying a concrete instance of the class[7,8]. Every such word is compatible with multiple possible semanticinterpretations, thus leading to ambiguity, whose implications have beenalready discussed.Industrial-scale projects are mostly based on guidelines for the way ofexpressing system requirements, i.e. they introduce a style in languageuse, for clarity. In a space system project, we encountered the followingguideline:“A requirement will contain the word shall. Equivalent expressionsare allowed in exceptional cases: is required to, has to etc ”. Certain words that violate veriﬁability (e.g.“is not allowed”,“is required to be not”,“must not”) may be excluded.However, these guidelines do not help to eliminate the mentionedsources of vagueness, which are inherent in all natural languagespeciﬁcations.3. Semantic modeling of requirements and pattern-basedspeciﬁcationNatural language requirements can be formalised only through apartial loss of expressiveness. To eliminate the ambiguity of free-formsyntax, a natural-like artiﬁcial language is usually used [9–14], which allows combining speciﬁcation patterns (boilerplates) through a strictly deﬁned syntax (context-free grammar) based on connectives with precisesemantics. Boilerplates consist ofattributesandﬁxed syntax elementssuch as:〈system〉shall<function>where“shall”is aﬁxed element, while〈system〉and<function>are attributes of placeholders for user input. Boilerplates usually consist of atmost three clauses: (i) thepreﬁx, for specifying a stimulation or a con-dition, (ii) themainand (iii) thesufﬁx, for specifying various constraints. Connectives are used in the boilerplate syntax to introduce additionalentities in a speciﬁcation, or for determining time, order/sequence,consequence, comparison and various types of conjunctions (coordi-nating, correlative, subordinating).To avoid vague semantics, due to many word readings, boilerplates are instantiated to speciﬁcationsby mapping attributes to class instances froman ontology with all concepts (and relationships) needed for writing re-quirements of a system [11,12,15–17]. Multiple ontologies are used (a requirement can refer to diversesystem domains) that must comply with a domain-independent ontologywith all relationships between classes of
Fig. 1.Boilerplate attributes deﬁnition relationships in [9].K. Mokos, P. Katsaros Array 7 (2020) 100030
2attributes in a system context (e.g. functioninvokesfunction, systemperformsfunction).Fig. 1depicts the domain-independent ontology that we used in [9]. These relationships characterise everyconcept instance of the domain-speciﬁc ontologies in the requirements and provide information for building the formal model of the system [ 18] and for deriving veriﬁable properties [9,19–21]. They also set asemantic analysisframework, which is used to detect missing information andpotential inconsistencies.In [10,12,22], the following semantic analyses are proposed:/C15Missing information.Requirements that are incomplete or still missing.In the former case, some references to concept instances are missingfor one or more boilerplate attributes. In the latter case, we focus onboilerplate attributes that have been instantiated, but they have notyet been speciﬁed in any other requirement. /C15Conﬂicting requirements.Similar requirements in terms of boilerplatesthat assign to the same attributes, for the same subject, differentconcept instances or use contradicting words or different quantities./C15Underspeciﬁcations.Requirements that assign attributes, which can bereplaced with instances of more concrete subclasses./C15Noise.Requirements with terms not deﬁned in domain ontologies./C15Opacity.Requirements which assign irrelevant instances of conceptsto their attributes./C15Redundancy.Requirements with the same boilerplates and quantitiesthat assign semantically equivalent concepts to their attributes.These ontology-based analyses can be implemented using SPARQLqueries [23] and SPIN inference rules [24]. Any omission detected by the mentioned analyses enacts a need ofreﬁning one or more requirements. The re ﬁnement of a set of re- quirements [25] consists of: (i) identifying what cannot be guaranteed oreffected and (ii) augmenting or replacing them until they are fully veri-ﬁable. This can be ensured only after having derived formal propertiesthat are really veriﬁable.Example 1.This illustrative example was inspired from [26], where it
wasﬁrst used to demonstrate space system engineering methods foron-board software design. It refers to a generic ﬁrst-in-ﬁrst-out queue (FIFO), whose functionality is given in Fig. 2as SysML natural languagerequirements linked with“reﬁne”relations (directed arrows, where thetarget reﬁnes the source).The“concurrent readers/writers”and“element types”requirements refer to the FIFO queue interface, whereas the “implementation lan- guage”requirement to an expectation, which by de ﬁnition cannot be rendered veriﬁable. All requirements, apart from the “implementation language”were manually imported in our requirements ontology using aboilerplate syntax similar to the one in [ 9].Fig. 3demonstrates how the P15 preﬁx and M10 main boilerplates were combined for specifying the“Writer capability”requirement.The process followed to input requirements into the ontology isshown inFig. 4. First, the boilerplates to be used from the list of existingboilerplates are selected and their placeholders are presented accordingto the attributes of their syntax. Each placeholder is then ﬁlled in using either a (sub-)class of the boilerplate attributes or an instance of that(sub-)class (Fig. 3).All requirements with a (sub-)class as an attribute are noted as havingmissing information. Complete requirements (i.e., with instances in eachplaceholder) are analyzed by applying the mentioned analyses thatprovide warnings in a table (e.g. which attribute has not been instanti-ated by any requirement, conﬂicting requirements etc). Warnings promptto edit, reﬁne or add additional requirements and then to repeat the se-mantic analysis in the updated requirements. In this example, the resultsof missing information analysis prompted us to de ﬁne the“full”and “empty”FIFO states.Semantic analysis is based on the ontological representation of theboilerplate attribute values inFig. 5(relationships comply with the domain-independent ontology ofFig. 1). Note that this representation refers to concepts that do not exist in the boilerplate representation of therequirement inFig. 3(e.g.function_001, function_002, func-tion_003, ﬂow_001). The reason is that the following two speci ﬁca- tion patterns are utilized.First, in the main boilerplate, we refer to two different systems (i.e.thewriterand theFIFO). This speciﬁcation style, due to the used boilerplate, entails the invocation of two different functions; it is there-fore represented with theinvokesrelationship between thepush function (in main), and a new function, say function_001. For the sake of understandability, we namefunction_001asadd, to express that
Fig. 2.FIFO requirements.K. Mokos, P. Katsaros Array 7 (2020) 100030
3upon apushby thewriter, theFIFOshall add an element to the queue.The second speciﬁcation pattern concerns with referring to a state asprecondition speciﬁed in the preﬁx. This style, due to the preﬁx boiler- plate, entails a representation according to Fig. 1, which assumes anadditionalﬂow thatsetsthe state (and thenotstate) and two addi- tional functions:/C15function_002to check the state deﬁned in the preﬁx boilerplate, /C15function_003that acts as container, which contains the latter andthefunction_001thatFIFOperforms, as was previously mentioned.Due to the container, relationships offunction_001(including invokes) are applied to the container (function_003). We call function_002ascheck NOT FULL, andfunction_003ascheck NOT FULL and add.Fig. 5eventually reﬂects the semantics: thewriter performs apush, whichinvokes FIFOto check that state is notFULL and add element to the queue.The described speciﬁcation patterns can be applied by integratingappropriate SPARQL rules, in order to infer the additional functions andrelationships. Alternatively, two or more separate requirements shouldbe speciﬁed to deﬁne what each system performs and how their functionsare invoked.△The process ofFig. 4integrates the semantic analyses of [ 10,12,22] together with those provided by our ontology architecture. Any variationof this process is feasible if all completeness checks precede the rest ofsemantic analysis. Completeness checks may even take place concur-rently and interleave with the speciﬁcation of requirements. From the discussion on the ontological representation of the requirement in Fig. 3, we see that completeness depends on (i) the relationships of boilerplateattributes (domain-independent ontology) and (ii) the boilerplates syn-tax and all concepts that are not explicitly referred as attribute values, butare inferred from them.Example 2.This example refers to the Electrical Power Subsystem
Fig. 3.Requirement boilerplate instantiation for the Writer capability requirement.
Fig. 4.Requirement speciﬁcation process steps.
Fig. 5.Ontological representation of the Writer capability requirement.K. Mokos, P. Katsaros Array 7 (2020) 100030
4(EPS) of a spacecraft system for generating, storing, conditioning andprovision of electric power to all satellite units. EPS is decomposed intosubunits (Fig. 6), whose requirements have been expressed using ourboilerplate syntax (and attributes inFig. 1) as shown inTable 1. The main subunits are:/C15Power Conditioning and Distribution Unit (PCDU): receives theelectric power from the solar array and/or battery and distributes it tothe satellite subsystems through the Latching Current Limiter (LCL)./C15Battery: stores electric power provided by the solar array during Sunvisibility and powers the satellite subsystems during eclipse phases. Itis charged/discharged by the Battery Charge/Discharge Regulator(BCDR)./C15Main Error Ampliﬁer (MEA): stabilizes power to the default voltage./C15Solar Array: delivers power to the satellite subsystems through thePCDU. It supplies the satellite during Sun exposure and in parallelcharges the battery after the eclipse phases./C15PCDU Telemetry&Telecommand (TMTC): controls PCDU withcommands external to the subsystem, e.g. power on/off, (dis-)charging from Attitude&Orbit Control System (AOCS) and groundcontrol.All requirements based on the M10 boilerplate (EPS-07, EPS-08, EPS-17 and EPS-18) resemble the requirement of Fig. 3, where the main clause refers to two differentsystemattributes of the boilerplate. Similarlyto Example 1, the main clause representation includes (EPS-17 require-ment inFig. 7) theinvokesrelationship between the function referredin the boilerplate and an additional function (shown as func- tion_001), which (the analysis warns that) should be instantiated andspeciﬁed in another requirement. We callfunction_001asprocess, in order to denote that ground control is expected to process telemetriesupon receiving them.Requirements that refer to a state in the pre ﬁx clause (EPS-10 to EPS- 13), similarly to the requirement ofFig. 3, introduce a precondition to a function occurrence. This semantics requires two additional functions, asinFig. 8, since there is no direct relationship in our domain-independentontology (Fig. 1) between any state and function attributes:/C15a function (function_001) to check the state in the preﬁx clause, /C15a function (function_002) to act as a container of the latter and thefunction that is speciﬁed in the main clause.If the state attribute in preﬁx refers to an item, that item is related tothe new functions with theaffectsrelationship.EPS-15 and EPS-16 use a different combination of pre ﬁx/main boil- erplates that shows the need for aninvokesrelationship between function attributes. In this case, such a representation is not attributed to
the different system attributes (AOCS or ground control and PCDUTMTC) in preﬁx and main, but it is based solely on the use of the functionattribute in preﬁx. As shown inFig. 9, the AOCS and ground controlperformaforwardsfunction, whichinvokesaprocessfunction performed by PCDU TMTC.These speciﬁcation cases show the role of preﬁx boilerplate in the invokesrelationship deﬁnition of the requirement’s ontological representation:/C15when the preﬁx introduces a state attribute as precondition of main,additional functions andﬂows are needed apart from those that areexplicitly mentioned in the requirement;
Fig. 6.Electric Power System decomposition.Table 1Power subsystem requirements.
ID RequirementEPS-01 M16: <System: EPS>shall contain a <System: PCDU>. EPS-02 M16: <System: EPS>shall contain a <System: Solar Array>. EPS-03 M16: <System: EPS>shall contain a <System: Battery>. EPS-04 M16: <System: PCDU >shall contain a <System: MEA>. EPS-05 M16: <System: MEA>shall contain a <System: BCDR>. EPS-06 M12: <System: EPS>shall have < StateSet: operational modes> with values: <State: On>, <State: Off>. EPS-07 M10: <System: EPS>shall < Function: transmit> <Item: bus voltage>to < System: platform> EPS-08 M10: <System: EPS>shall < Function: transmit> <Item: bus voltage>to < System: payload> EPS-09 M7: <System: EPS>shall < Function: start-up>, S2: after < Flow: launcher separates>. EPS-10 P11: If < Item: bus voltage >is <State: undervoltage>, M7: <System: PCDU>shall < Function: power down certainLCLs>,S6: sequentially.EPS-11 P11: If < Item: bus voltage >is <State: overvoltage>, M7: <System: MEA>shall < Function: reset> <Item: bus voltage>to < State: 50 V/C60.5 V>. EPS-12 P11: If < Item: battery voltage >is <State: below 45V>, M7: <System: BCDR>shall < Function: charge> <Item: battery voltage>to < State: 50V/C60.5 V
>. EPS-13 P11: If < Item: battery voltage >is <State: over 55V>, M7: <System: BCDR>shall < Function: discharge> <Item: battery voltage>to < State: 50V/C60.5 V>. EPS-14 M7: <System: EPS>shall < Function: transmit> <Item: operational, health and performance telemetries of all units >. EPS-15 P12: If < System: AOCS ><Function: forwards><Item: EPS related telecommands>,M7: <System: PCDU TMTC>shall < Function: process><Item: EPS related telecommands>. EPS-16 P12: If < System: ground control ><Function: forwards> <Item: EPS related telecommands>, M7: <System: PCDU TMTC>shall < Function: process> <Item: EPS related telecommands>. EPS-17 M10: <System: PCDU TMTC >shall < Function: transmit> <Item: telemetries>to < System: ground control>. EPS-18 M10: <System: PCDU TMTC >shall < Function: transmit> <Item: telemetries>to < System: AOCS>.
Fig. 7.Ontological representation of the EPS-17 requirement.K. Mokos, P. Katsaros Array 7 (2020) 100030
5/C15when the preﬁx introduces a function attribute as precondition ofmain, aninvokesrelationship is generated without additionaldeﬁnitions.Finally, we highlight the role of a class of requirements, found inrequirements documents, which cannot be expressed ontologically withthe concepts of a domain-independent ontology. Instead, such re-quirements complement the domain-speci ﬁc ontologies. Speciﬁcally, EPS-01 to EPS-06 are related to the design of the speci ﬁed system and if they are not handled properly, they will cause warnings for detectednoise or opacity.As noted, all speciﬁcation patterns can be applied by integratingSPARQL rules. Upon semantic analysis, newly created concepts aremarked as missing information, until they are further speci ﬁed in other requirements.△4. Formal properties derivation and veriﬁcationEven if we can guarantee absence of semantic omissions in re-quirements speciﬁcation, this does not mean that requirements are validfor an acceptable system design. They could be unsatis ﬁable or not realizable! The conjunctions and prepositions in pre ﬁx/sufﬁx patterns cannot be evaluated over a declarative-style speci ﬁcation, such as that created by instantiating boilerplates using domain ontologies. We needthe model of a system design, in a language with formally-deﬁned opera- tional semantics. Then, from the various combinations of pre ﬁx, main and sufﬁx clauses we derive formal properties referring to events and statevariables of the model that correspond to the attribute values of the re-quirements. Incomponent-basedformalisms such as BIP [27] and the SLIM language (a subset of the Architecture Analysis&Design Language - AADL extended with behavioural models) of the COMPASS toolset [ 28], properties are speciﬁed in terms of atomic propositions that refer tospeciﬁc components and their ports. Moreover, in SLIM, properties mayalso refer to error variables and states of error models [ 29,30]. Derivation of properties can be based on property patterns that areparameterizable, formalism-independent speci ﬁcation abstractions,which capture recurring problems in requirements formalisation. Pat-terns are used as a data input mechanism to specify properties; they areexpressed based on a structured English grammar and they have formalsemantics in logic languages. Each boilerplate is associated with a set ofproperty patterns [9,10], such that every possible requirement speci ﬁ- cation is covered by adequate properties. This is a prerequisite, for alogically consistent interpretation of requirements with respect to themodel of system design.Example 3.An example of a properties derivation proposal that weintroduced in[9]is the following. Let us consider the preﬁx boilerplate: P2: if<Flow: e1>and<State: s1>When P2 is used in a requirement speciﬁcation, two properties are derived that are expressed through the following property patterns from[31].P2.1: globally, occ (e1)^obs (s1) precedesbeg(M) P2.2: globally,beg(M)responds to occ (e1)^obs (s1). wherebeg(M),occ(e1),obs(s1)are mapped to events (componentports) corresponding to the occurrence of the main speci ﬁcation (beg(M)), the occurrence ofe1and the observation ofs1in execution traces of the model of system design. P2.1 is a safety property, whereasP2.2 is a liveness property; for both, a formal semantics has been de ﬁned in temporal logic languages.△The complexity of the properties formalisation problem is discussedin [32], where the author points out that a suf ﬁciently high level of precision must be retained. The author examines the “simple”require- ment“When you pick up the phone, you get a dialtone ”and provides four possible interpretations in Linear-time Temporal Logic (LTL) [ 33] with different levels of precision. It is eventually shown that for one who is notexperienced in using temporal logic, it is unlikely to produce a preciseformalisation of this requirement. Moreover, even when such a preciseformalisation is achieved, it is impossible to recognize the initial speci-ﬁcation, where the property comes from.A widely used repository of patterns for functional properties is re-ported in [31]. The semantics of these patterns [ 34]i sd eﬁned in Computation Tree Logic (CTL) [35] and in other logic languages. Ac-
cording to this approach, every property is speci ﬁed using a scope (optional) and a property pattern. The scope (six different patterns) se-lects the subset of the model state-space, where the property is expectedto hold; for the rest of the state-space, the property is unde ﬁned. The property pattern deﬁnes an expected occurrence of a given event/state(four different patterns) or the relative order of multiple events/states(four patterns) during system execution.For extra-functional properties, the authors of [ 36,37] were based on the repository of [31], to introduce patterns for real-time speciﬁcations, while in [38] the authors organized them in a uniﬁed framework and introduced some additional patterns, which complete this repository. Adifferent set of patterns for timing properties has been also proposed in[39]. Finally, in [40] the author has presented a repository of patterns forprobabilistic properties, which have been used for real-world re-quirements focused on reliability, availability, performance, safety, se-curity, and performability.However, for verifying extra-functional properties we need a model ofthe system’s design in a formal language with suitable semantics (e.g.timed automata for real-time properties, stochastic semantics for prob-abilistic properties). With respect to this, for the BIP language it is worthto mention:/C15the BIP extension in [41] for specifying probabilistic aspects and astochastic semantics for the parallel composition of BIP components;/C15the RT-BIP extension for modeling timing constraints as a timed au-tomaton and for computing schedules meeting these constraints [ 42].COMPASS implements a different approach and supports variousanalyses. Instead of extending the SLIM language semantics, the toolutilizes model extensions, such as error models and fault injections,which enable it to automatically inject faults into the nominal model. The
Fig. 8.Ontological representation of the EPS-12 requirement.
Fig. 9.Ontological representation of the EPS-15 and EPS-16 requirement.K. Mokos, P. Katsaros Array 7 (2020) 100030
6extended model is translated into a symbolic model amenable to formalveriﬁcation and to a Markov chain for probabilistic analyses. A combi-nation of backend tools supports a multitide of analyses [ 43], including properties veriﬁcation, functional correctness, fault management,dependability and performability analyses.4.1. Model-based and component-based system designFrom the preceding discussion, derivation of formal properties fromsystem requirements is tightly intertwined with the system design, i.e. the problem of deﬁning the architecture, the modules, the interfaces and thedata in a system model. A widespread approach is the component-baseddesign, in which system design takes place by integrating blocks offunctionality called components that are coordinated so as to ful ﬁll the system requirements.Two different perspectives of model-based and component-basedsystem design exist, the so-called top-downandbottom-up design approaches.In top-down design [44–47], we have a top-down system decompo-sition into components through which we mainly focus on allocatingrequirements to components, such that higher-level requirements areestablished. Each component is seen as an open system, with inputsprovided by other components in the system or the external world andsome outputs. All other components and the exterior world is referred toas the component’senvironment. Components are designed for a partic-ular context and cannot constrain their environment. Requirements areformalised ascontracts[48] consisting ofassumptionsfor the environment andguaranteesprovided by the component. In [49], a pattern-based contract speciﬁcation approach was introduced. When allocating re-quirements to a component [50], we must ensure that the assumptionsfor the component’s environment (assertions on its input or invariants)can be fulﬁlled. An overly weak assumption on the environment can leadto overly strong (inconsistent) guarantees. Additional assumptions maybe needed to weaken the existing requirements. The RATSY tool forproperty simulation can be used to improve the precision of additionalassumptions [51]. In overall, at each step, a design decision has to bemade towardsﬁnding an appropriate component (and contract)decomposition through which all higher-level requirements can be met.For this purpose, a formalreﬁnement relationwas proposed in [52]. In bottom-up design [9,53], at each step, a formalarchitecture pattern [54] is applied to a set of components of the system model in BIP. Ar-chitectures are reusable BIP models that characterise the interactionsbetween a set of component types. In essence, they are operatorsrestricting component behaviour for enforcing
one or more properties. To apply them, certain properties are assumed for their operands, which canbe veriﬁed locally by inspecting the components to which they areapplied. If an assumed property is not satisﬁed, the component behaviour has to be reﬁned. A related theory [55] provides a framework for ar- chitecture composition that guarantees preservation of propertiesestablished in a previous design step. In overall, this is an incremental designapproach that aims to avoid a posteriori veri ﬁcation as much as possible (correctness-by-construction). The design philosophy lies on thefact that when specifying system requirements, a signi ﬁcant part of the speciﬁcation comes from adapting requirements (and design solutions)found in previous projects. Architecture patterns provide the means toformally capture common solutions to recurring design problems in anabstract and reusable form. They drive the choice of component coor-dination, decomposition into components and behaviour transformation,but to be able to enforce a worthwhile set of properties we need a suf-ﬁciently developed library of architecture patterns. This incurs anon-negligible investment cost. In a related research work [ 56], the au- thors open prospects for deﬁning architecture patterns, which enforcequantitative properties.In overall, formalisation of system requirements is a two-stage processof interpreting them (i) based on a semantic model of the system domain(speciﬁcation), and (ii) with respect to a model of the system ’s design(properties derivation). Due to the creative nature of this process, itsobvious dependencies on two types of models and the form of the systemdesign process (top-down vs. bottom-up design), human involvementcannot be vanished and therefore it can be only partially automated. Innext section, we survey some noteworthy proposals of tool-support inrecent bibliography.5. ToolsAt least three tools have been presented in related bibliography, buttheir availability beyond the projects in which they were developed isunclear. A fourth tool is available as part of the COMPASS toolset [ 28], which facilitates formal speciﬁcation of requirements in the context ofAADL models [57].In [11], the authors presented a tool called DODT that was developedin the frame of the CESAR project [ 10]. DODT allows for projectional editing and typing of requirements based on a boilerplate syntax (Re-quirements Speciﬁcation Language - RSL), an attribute ontology and adomain-speciﬁc ontology. The ontology-based validation checks in [ 22] have been implemented, which allow detecting contradictions by pair-wise comparison of requirements, nouns that are not de ﬁned in the ontology and so on. Finally, a language of property patterns with formalsemantics is supported. Although DODT does not implement an exactassociation of boilerplates with property patterns, in [ 10] the authors provide suggestions for patterns that could be suitable for capturing agiven requirement.The EARS-CTRL tool [58] was introduced to ensure by constructionwell-formedness of requirements written using the Easy Approach toRequirements Syntax (EARS) [13,14] templates. The tool checks whethera controller can be synthesized from a set of requirements. If a controllercannot be synthesized, it is possible that con ﬂicting requirements exist. EARS-CTRL allows for projectional requirements ’editing, based on a glossary deﬁned for the domain of controller synthesis. Requirements areanalyzed as LTL formulas. The analysis effectiveness depends onuser-deﬁned semantic information (e.g. simple predicates) for the givenglossary. Finally, model synthesis is limited to a fragment of LTL thatinvolves the universal path quantiﬁer, the next-step operator and the weak until temporal operator [59].The RERD tool [9] supports the requirements speciﬁcation and properties derivation based on boilerplates and property patterns, as wellas the incremental construction of systems for discharging the derivedproperties through the bottom-up design approach described in Section4.1. While editing requirements, the user interacts with underlying on-tologies by querying them and accessing their class instances formatching terms. In this way, the vocabulary of boilerplate attributes isrestricted to terms that are identiﬁable within domain-speciﬁc ontologies and ontologies speciﬁc to the system under design. The boilerplate at-tributes relationships inFig. 1play a key-role in semantic analysis andproperty derivation, where each boilerplate has been associated withpredeﬁned property patterns that can formally capture it. For propertyenforcement, the user can choose among the available architecture pat-terns and parameterize them by selecting components from the incre-mentally built BIP model of the system. Then, the absence of deadlocks inthe resulting BIP model has to be checked, which is proposed to takeplace using the D-Finder tool [60]. For the properties that cannot beenforced using the existing architecture patterns, the user will have to useexternal tools, such as the nuXmv model checker [ 61]. Regarding the COMPASS-based approach, in [ 57], the authors pre- sented a different approach, according to which formal properties are notinstantiated from patterns by replacing their placeholders with states/-events associated with boilerplate-speciﬁed attributes, but through assigning values toattributes of the system model. More speciﬁcally, a set of properties was introduced, which allow to associate values to speci ﬁc AADL model elements. A taxonomy of formal properties was thendeﬁned, with each of them being expressed by the values associated tothe corresponding AADL properties or else using certain structures in theK. Mokos, P. Katsaros Array 7 (2020) 100030
7AADL model (e.g. subcomponents and port connections). The formalsemantics of the system properties relies on the behavioural semantics ofthe SLIM language, whereas the logic used to de ﬁne most of them is a variant of Metric Temporal Logic (MTL) [ 62]. While the taxonomy of formal properties is comparatively limited in expressiveness, itcompletely eliminates the need to choose a pattern and invent aninstantiation. The formal properties can be analyzed for consistencyamong differentabstraction levelsof the system model or can be used asassumptions/guarantees of components for contract-based design. Forthe latter intent, COMPASS requires to further specify a contract reﬁne- ment, which links a contract to the contracts of subcomponents. This al-lows to perform various analyses, such as the consistency or entailmentfor any subset of contract properties, to check whether the contract re-ﬁnements are correct, as well as to tighten a contract such that thereﬁnement still holds.6. Limitations and challenges for industrial-scale projectsEffectiveness of ontology-based and pattern-based requirementspeciﬁcation depends on: (i) the quality of the domain-speci ﬁc ontol- ogies, and (ii) the expressiveness of pattern languages and their potentialto eliminate ambiguity.Regarding the former matter, for the design of proper domain-speci ﬁc ontologies we need to involve requirement engineers, ontology engineersand domain experts, who are in charge of the system design. Such aprocess requires gathering knowledge from previous projects (e.g.requirement speciﬁcation documents, architecture design documents),identifying the important concepts that are not speci ﬁc to these projects and then classifying them into abstract categories (identi ﬁable func- tionality, exchanged information between systems etc.). Categories mustthen be assigned to boilerplate attributes from a conceptual model, suchas the one inFig. 1, and their interrelationships must be ontologicallydeﬁned. It is also required to capture tacit knowledge for the designproblem, which is necessary to infer e.g. that certain events or dataranges that respect the boilerplate attributes model syntactically are notrelevant semantically. Such knowledge may come for example from lawsof physics or other system engineering aspects. From the ontology en-gineering perspective, it is necessary to adopt adequate qualitative(cohesion, adaptability etc.) and quantitative (coupling, computationalefﬁciency etc.) criteria, which help to uncover errors and inef ﬁciencies regarding the modeling complexity and size of the ontologies. A completetreatment of this problem is given in [ 63]. An additional challenge is how to organise the collaboration/responsibility of the different depart-ments/stakeholders that may be involved in various ontologies, which inlarge system projects may include, for example, domain ontologiescommon for multiple stakeholders.Expressiveness of pattern languages is important for being able toformalise all system requirements that need to be validated. To a largeextent, the expressiveness depends on the set of connective words sup-ported by the syntax of the pattern language and their meaning. Arestricted set of connectives limits the language expressiveness, whereasa more extensive set of connectives may render impossible to completelyavoid ambiguity in syntax and semantics. For enhanced expressiveness, itmay be even necessary to assign multiple meanings to a connective word,which will have to be distinguished by the word ’s position within the sentence. In any case, the syntax of pattern languages will have to bedesigned with extensibility in mind.The effort needed to apply any of the reviewed processes/tools in anindustrial project and their scalability potential raise important chal-lenges. Most of them have been applied to proof-of-concept case studiesbased on subsets of real requirements e.g. from space systems, but nonehas been applied to the complete set of requirements of a real industrialproject. For such a project scale, the challenges to be addressed include:(i) to document the relationship between the ontology-based require-ment speciﬁcations and the requirement baselines, as well as the ontol-
ogies lifecycle within a project and across projects, (ii) to improveusability through increasing the technology readiness level of the tools,especially when some properties cannot be veri ﬁed and it is necessary to identify the relevant sub-model for the correction.7. Conclusions and future research prospectsWe surveyed the recent advances in formalisation and early valida-tion of system requirements. A series of related industrial research pro-jects has delivered valuable experience on pattern languages for varioustypes of requirements and on the derivation of formal properties.Requirement speciﬁcation can be based on domain ontologies, which areused to identify missing information and eliminate inconsistencies andcases of underspeciﬁcation. The properties derivation depends on aformal model of the system, which may be incrementally built through acomponent-based design process. We reviewed two related design par-adigms and we discussed the problem of formalising requirements withintheir context. Finally, we reviewed tools that were recently introduced, inorder to address the mentioned problems.The presentation of these developments allowed us to comment ontheir strengths and weaknesses. It was also evident that important limi-tations still have to be addressed, as well as open challenges associatedwith applying such an approach in industrial-scale projects. Apart fromthese prospects, open problems for future work exist on: (i) raising thelevel of automation for the formalisation and validation of requirements.and (ii) extending the applicability to more types of extra-fuctional re-quirements/properties.References[1]Berry DM. Ambiguity in natural language requirements documents. In: Paech B,Martell C, editors. Innovations for requirement analysis. From stakeholders ’needs to formal designs. Springer; 2008. p. 1 –7. [2]Berry DM, Kamsties E. Ambiguity in requirements speci ﬁcation. Boston, MA: Springer US; 2004. p. 7–44. [3]Lyons J. Linguistic semantics: an introduction. Cambridge University Press; 1995 . [4]Lyons J. Semantics, 1&vol. 2. Cambridge: Cambridge University Press; 1977 . [5]Firesmith D. Are your requirements complete? J Object Technol 2005;4:27 –44. [6]Geierhos M, B€aumer FS. How to complete customer requirements. In: naturallanguage processing and information systems. Cham: Springer; 2016. p. 37 –47. [7]Geierhos M, B~a¤umer FS. In: Guesswork? Resolving vagueness in user-generatedsoftware requirements. 1 ed. Cambridge Scholars Publishing; 2017. p. 65 –108. [8]Fabbrini F, Fusani M, Gnesi S, Lami G. An automatic quality evaluation for naturallanguage requirements. In: Proc. Of the 7th int. Workshop on RE. Foundation forSoftware Quality (REFSQ 2001); 2001 . [9]Stachtiari E, Mavridou A, Katsaros P, Bliudze S, Sifakis J. Early validation of systemrequirements and design through correctness-by-construction. J Syst Software2018;145:52–78.[10]Rajan A, Wahl T. CESAR-cost-efﬁcient methods and processes for safety-relevant embedded systems. Springer; 2013 . [11]Farfeleder S, Moser T, Krall A, Stålhane T, Omoronyia I, Zojer H. Ontology-drivenguidance for requirements elicitation. In: The semanic web: research andapplications. Berlin, Heidelberg: Springer Berlin Heidelberg; 2011. p. 212 –26. [12]Mahmud N, Seceleanu C, Ljungkrantz O. Resa : an ontology-based requirementspeciﬁcation language tailored to automotive systems. In: 10th IEEE int. Symp. Onindustrial embedded systems; 2015. p. 1 –10. [13]Mavin A, Wilkinson P, Harwood A, Novak M. Easy approach to requirements syntax(ears). In: Proc. Of 17th IEEE int. Requirements engineering conf. IEEE ComputerSociety; 2009. p. 317–22. [14]Mavin A, Wilkinson P. Big ears (the return of “easy approach to requirements engineering”). In: Proc. Of 2010 18th IEEE int. Requirements engineering conf.IEEE Computer Society; 2010. p. 277 –82. [15]Lin J, Fox MS, Bilgic T. A requirement ontology for engineering design. Concurr Eng
1996;4:279–91.[16]Stalhane T, Omoronyia I, Reicenbach F. Ontology-guided requirements and safetyanalysis. 2010.[17]Hennig C, Viehl A, K€ampgen B, Eisenmann H. Ontology-based design of spacesystems. In: The semantic web –ISWC 2016. Cham: Springer; 2016. p. 308 –24. [18]Wagner DA, Bennett MB, Karban R, Rouquette N, Jenkins S, Ingham M. An ontologyfor state analysis: formalizing the mapping to sysml. In: 2012 IEEE aerospace conf.IEEE; 2012. p. 1–16.[19]Yan R, Cheng C-H, Chai Y. Formal consistency checking over speci ﬁcations in natural languages. In: Proc. Of the 2015 design. Automation &Test in Europe Conf. &Exhibition, DATE’15; 2015. p. 1677–82. [20]B€oschen M, Bogusch R, Fraga A, Rudat C. Bridging the gap between naturallanguage requirements and formal speci ﬁcations. In: Joint proc. Of REFSQ-2016 workshops of 22nd int. Conf. On requirements engineering. Foundation forSoftware Quality (REFSQ 2016); 2016 .K. Mokos, P. Katsaros Array 7 (2020) 100030
8[21]Mahmud N, Seceleanu C, Ljungkrantz O. Speci ﬁcation and semantic analysis of embedded systems requirements: from description logic to temporal logic. In:Software engineering and formal methods. Cham: Springer; 2017. p. 332 –48. [22]Kaiya H, Saeki M. Ontology based requirements analysis: lightweight semanticprocessing approach. In: Proc. Of the 5th int. Conf. On quality software, QSIC ’05. IEEE Computer Society; 2005. p. 223 –30. [23] SPARQL query language for RDF - W3C recommendation. 2008. https://www .w3.org/TR/rdf-sparql-query/ . [Accessed 31 December 2019]. [24] SPARQL inferencing notation (SPIN). 2019. http://spinrdf.org. [Accessed 31 December 2019].[25]Zave P, Jackson M. Four dark corners of requirements engineering. ACM TransSoftware Eng Methodol 1997;6:1 –30. [26]Cordet astrium (astrium, SciSys), cordet TAS (TAS, UPD, P &P SW) and ESA; with contribution by intecs, GMVand soft-wcare, de ﬁnition of A reference on board software architecture basic constituents, technical report TEC-SWE/09-248/AJ ESAESTEC. 2009.[27]Basu A, Bensalem B, Bozga M, Combaz J, Jaber M, Nguyen T-H, Sifakis J. Rigorouscomponent-based system design using the bip framework. IEEE Software 2011;28:41–8.[28]Bozzano M, Bruintjes H, Cimatti A, Katoen J-P, Noll T, Tonetta S. Compass 3.0. In:Tools and algorithms for the construction and analysis of systems (TACAS). Cham:Springer; 2019. p. 379–85. [29]Mokos K, Katsaros P, Bassiliades N, Vassiliadis V, Perrotin M. Towardscompositional safety analysis via semantic representation of component failurebehaviour. In: Proc. Of 8th joint conf. On knowledge-based software engineering.IOS Press; 2008. p. 405–14. [30]Mokos K, Meditskos G, Katsaros P, Bassiliades N, Vasiliades V. Ontology-basedmodel driven engineering for safety veri ﬁcation. In: 36th EUROMICRO conf. On software engineering and advanced applications (SEAA 2010). IEEE ComputerSociety; 2010. p. 47–54. [31]Dwyer MB, Avrunin GS, Corbett JC. Patterns in property speci ﬁcations forﬁnite- state veriﬁcation. In: Proc. Of the 21st int. Conf. On software engineering, ICSE ’99. ACM; 1999. p. 411–20.[32]Holzmann GJ. Formalizing requirements is hard. Cham: Springer; 2019. p. 51 –6. [33]Pnueli A. The temporal logic of programs. In: Proc. Of the 18th annual symp. onfoundations of computer science, SFCS ’77. IEEE Computer Society; 1977. p. 46 –57.
[34] Temporal speciﬁcation patterns. 2019.http://patterns.projects.cs.ksu.edu/ . [Accessed 31 December 2019].[35]Clarke EM, Emerson EA. Design and synthesis of synchronization skeletons usingbranching time temporal logic. In: Kozen D, editor. Logics of programs. Berlin,Heidelberg: Springer Berlin Heidelberg; 1982. p. 52 –71. [36]Konrad S, Cheng BHC. Real-time speci ﬁcation patterns. In: Proc. Of the 27th int. Conf. On software engineering. ICSE ’05, ACM; 2005. p. 372–81. [37]Abid N, Dal Zilio S, Le Botlan D. Real-time speci ﬁcation patterns and tools. In: Stoelinga M, Pinger R, editors. Formal methods for industrial critical systems.Springer Berlin Heidelberg; 2012. p. 1 –15. [38]Expressing and organizing real-time speci ﬁcation patterns via temporal logics. J Syst Software 2009;82:183 –96. [39]Reinkemeier P, Stierand I, Rehkop P, Henkler S. A pattern-based requirementspeciﬁcation language: mapping automotive speci ﬁc timing requirements. In: Software engineering 2011 ^a
€“workshopband. Bonn: Gesellschaft f ~A¼r Informatik e.V.; 2011. p. 99–108.[40]Grunske L. Speciﬁcation patterns for probabilistic quality properties. In: Proc. Ofthe 30th int. Conf. On software engineering. ICSE ’08, ACM; 2008. p. 31–40. [41]Nouri A, Bensalem S, Bozga M, Delahaye B, Jegourel C, Legay A. Statistical modelchecking qos properties of systems with sbip. Int J Software Tool Technol Tran2015;17:171–85.[42]Abdelatif T, Combaz J, Sifakis J. Rigorous implementation of real-time systemsfrom theory to application. Math Struct Comput Sci 2013;23:882 –914.[43]Bozzano M, Cimatti A, Katoen J-P, Katsaros P, Mokos K, Nguyen VY, Noll T,Postma B, Roveri M. Spacecraft early design validation using formal methods.Reliab Eng Syst Saf 2014;132:20 –35. [44]Murugesan A, Whalen MW, Rayadurgam S, Heimdahl MP. Compositionalveriﬁcation of a medical device system. ACM SIGAda - Ada Lett 2013;33:51 –64. [45]Murugesan A, Heimdahl MPE, Whalen MW, Rayadurgam S, Komp J, Duan L, Kim B-G, Sokolsky O, Lee I. From requirements to code: model based development of amedical cyber physical system. In: Software engineering in health care. Cham:Springer; 2017. p. 96–112. [46]Whalen MW, Gacek A, Cofer D, Murugesan A, Heimdahl MPE, Rayadurgam S. Your“what”is my“how”: iteration and hierarchy in system design. IEEE Software 2013;30:54–60.[47]Bozzano M, Cimatti A, Fernandes Pires A, Jones D, Kimberly G, Petri T, Robinson R,Tonetta S. Formal design and safety analysis of air6110 wheel brake system. In:Proc. 27th int. Conf. Computer aided veri ﬁcation, Part I, LNCS 9206; 2015. p. 518–35.[48]Benveniste A, Caillaud B, Nickovic D, Passerone R, Raclet J-B, Reinkemeier P,Sangiovanni-Vincentelli A, Damm W, Henzinger T, Larsen KG. Contracts for systemsdesign: theory, research report RR-8759, inria rennes bretagne atlantique. INRIA;2015.[49]Damm W, Hungar H, Josko B, Peikenkamp T, Stierand I. Using contract-basedcomponent speciﬁcations for virtual integration testing and architecture design. In:2011 design. Automation Test in Europe; 2011. p. 1 –6. [50]Ingham MD, Day J, Donahue K, Kadesch A, Kennedy A, Khan MO, Post E,Standley S. A model-based approach to engineering behavior of complex aerospacesystems. In: Infotech@Aerospace 2012, garden grove, California, USA, june 19-21,2012; 2012.[51]Bloem R, Cimatti A, Greimel K, Hofferek G, K €onighofer R, Roveri M, Schuppan V, Seeber R. Ratsy–a new requirements analysis tool with synthesis. In: Computeraided veriﬁcation. Springer Berlin Heidelberg; 2010. p. 425 –9. [52]Cimatti A, Dorigatti M, Tonetta S. Ocra: a tool for checking the re ﬁnement of temporal contracts. In: 2013 28th IEEE/ACM int. Conf. On automated softwareengineering (ASE); 2013. p. 702 –5. [53]Sifakis J. Rigorous system design. Foundations and Trends in Electronic DesignAutomation 2013;6:293 –362. [54]Mavridou A, Stachtiari E, Bliudze S, Ivanov A, Katsaros P, Sifakis J. Architecture-based design: a satellite on-board software case study. In: Formal aspects ofcomponent software. Cham: Springer; 2017. p. 260 –79. [55]Attie P, Baranov E, Bliudze S, Jaber M, Sifakis J. A general framework forarchitecture composability. Formal Aspect Comput 2016;28:207 –31. [56]Paraponiari P, Rahonis G. On weighted con ﬁguration logics. In: Formal aspects of component software. Cham: Springer; 2017. p. 98 –116. [57]Bos V, Bruintjes H, Tonetta S. Catalogue of system and software properties. In:Computer safety, reliability, and security. Cham: Springer; 2016. p. 88 –101. [58]Lúcio L, Rahman S, Cheng C, Mavin A. Just formal enough? automated analysis ofEARS requirements. NFM 2017 2017:427 –34. NASA formal methods - 9th int. Symp.[59]Cheng C, Hamza Y, Ruess H. Structural synthesis for GXW speci ﬁcations. In: 28th int. Conf. Computer aided veriﬁcation; 2016. p. 95–117. [60]Bensalem S, Griesmayer A, Legay A, Nguyen T-H, Sifakis J, Yan R. D-Finder 2:towards efﬁcient correctness of incremental design. In: Proc. Of third int. Conf. OnNASA formal methods. Springer; 2011. p. 453 –8. [61]Cavada R, Cimatti A, Dorigatti M, Griggio A, Mariotti A, Micheli A, Mover S,Roveri M, Tonetta S. The nuXmv symbolic model checker. In: Computer aidedveriﬁcation, LNCS 8559. Springer; 2014. p. 334 –42. [62]Koymans R. Specifying real-time properties with metric temporal logic. R Time Syst1990;2:255–99.[63]Vrandecic D. Ontology evaluation. Ph.D. thesis. Karlsruhe Institute of Technology;2010.K. Mokos, P. Katsaros Array 7 (2020) 100030
9