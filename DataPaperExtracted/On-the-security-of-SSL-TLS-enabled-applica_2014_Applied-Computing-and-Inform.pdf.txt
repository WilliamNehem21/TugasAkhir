ORIGINAL ARTICLE
On the security of SSL/TLS-enabledapplications
Manik Lal Das *, Navkar Samdaria
DA-IICT, Gandhinagar, IndiaReceived 20 August 2012; revised 31 January 2014; accepted 11 February 2014
Available online 26 February 2014
KEYWORDSSecure Socket Layer;Transport LayerSecurity;Authentication;Public key certiﬁcate;Man-in-the-middleattacks;One-time padAbstract SSL/TLS (Secure Socket Layer/Transport Layer Security)-enabledweb applications aim to provide public key certiﬁcate based authentication,secure session key establishment, and symmetric key based trafﬁc conﬁdentiality.A large number of electronic commerce applications, such as stock trading,banking, shopping, and gaming rely on the security strength of the SSL/TLS pro-tocol. In recent times, a potential threat, known as main-in-the-middle (MITM)attack, has been exploited by attackers of SSL/TLS-enabled web applications,particularly when naive users want to connect to an SSL/TLS-enabled web ser-ver. In this paper, we discuss about the MITM threat to SSL/TLS-enabled webapplications. We review the existing space of solutions to counter the MITMattack on SSL/TLS-enabled applications, and then, we provide an effectivesolution which can resist the MITM attack on SSL/TLS-enabled applications.The proposed solution uses a soft-token based approach for user authenticationon top of the SSL/TLS’s security features. We show that the proposed solution issecure, efﬁcient and user friendly in comparison to other similar approaches.
ª2014 King Saud University. Production and hosting by Elsevier B.V. All rights reserved.
*Corresponding author. Tel.: +91 79 30510617.E-mail addresses:maniklal_das@daiict.ac.in(M.L. Das),navkar.samdaria@gmail.com(N. Samdaria). Peer review under responsibility of King Saud University.
Production and hosting by ElsevierApplied Computing and Informatics (2014) 10, 68–81
King Saud University
Applied Computing and Informatics
www.ksu.edu.sawww.sciencedirect.com
2210-8327ª2014 King Saud University. Production and hosting by Elsevier B.V. All rights reserved.http://dx.doi.org/10.1016/j.aci.2014.02.0011. Introduction
Secure Socket Layer/Transport Layer Security (SSL/TLS) ( Dierks and Rescorla, 2008) protocol is typically integrated into application for protecting data sentvia HTTP between clients and servers, which is also known as HTTP over TLS(HTTPS). In an SSL/TLS-enabled application, client ﬁrst sends a hello messageto the server then the server, upon conﬁrming negotiated parameters, sends theserver’s hello message along with server’s digital certiﬁcate to the client. The ser-ver’s digital certiﬁcate provides information about the server’s public key, certiﬁ-cate validity period, owner and issuer information. Once the client authenticatesthe server using the server’s certiﬁcate, the client and the server establish sessionkeys, which are symmetric keys used to encrypt and decrypt information ex-changed during the SSL/TLS session and to verify message integrity. As a result,the SSL/TLS-enabled application aims to provide digital certiﬁcate-based serverauthentication, public key based key exchange, and session key based data conﬁ-dentiality using a standard symmetric key encryption (e.g., AES) algorithm. Inaddition, message integrity is checked using message authentication codes ( Fig. 1).
The SSL/TLS protocol is composed of four subprotocols – Handshake,Change- CipherSpec,Record, andAlertsubprotocols (Dierks and Rescorla, 2008). The Handshake subprotocol allows the client to authenticate the communicating ser-ver using server’s public key certiﬁcate (we note that the client authentication isan optional security support the protocol offers that can also be achieved usingthe client’s certiﬁcate), key exchange between the client and server using publickey algorithm followed by keying material generation, and data conﬁdentialityfor trafﬁc security using symmetric key encryption algorithm. The working prin-ciple of the Handshake protocol is as follows. A client, who wants to connect
Figure. 1Certiﬁcate warning at the client on SSL/TLS-enabled application.On the security of SSL/TLS-enabled applications 69to an SSL/TLS-enabled web application, is required to communicate to the servera list of ciphers and algorithms (known as cipher suites) that the client can sup-port. Upon receiving the client’s request, the server selects a suitable cipher andrequired algorithms from the client’s cipher suites. If the server does not agreeto a common cipher suite from the list given by the client, then both the clientand the server are required to negotiate further toward an agreeable cipher suite.Once the server selects a suitable cipher suite from the client’s list, the server sendsits public key certiﬁcate along with the selected cipher suite to the client. The clientnow veriﬁes the server’s certiﬁcate and if the certiﬁcate is found valid then the ser-ver is authenticated. We note that the client’s authentication can also be checkedby the server, but it is an optional step. If the server wants to check for client’sauthentication then the server asks for the client’s certiﬁcate. Once the serverauthentication is conﬁrmed, the client and the server establish a master secretkey using a key exchange algorithm based on RSA, Difﬁe-Hellman, or Fortezza.With this master key, both the client and the server generate key material (e.g.,encryption key, MAC key) using a pseudo-random function (PRF) and otherephemeral parameters while using the SSL protocol, and for TLS protocol, itapplies the HMAC and PRF to generate the key material. The Handshake subpro-tocol ends with the client’s and server’s message authentication codes of all previ-ously exchanged messages, to protect the Handshake from message tampering.The Record subprotocol secures application data using the keys (MAC keysand encryption keys) computed in the Handshake subprotocol. Basically, the Re-cord subprotocol is responsible for protecting the application data in the currentsession. The Alert subprotocol is invoked when any error or warning occurs whilerunning the other subprotocols.
Informally, not all SSL/TLS-enabled applications require client’s authentica-tion as long as the server gets paid off for the client’s service. This optional client’sauthentication in SSL/TLS-enabled application opens up a potential securityloophole to attackers (Oppliger and Gajek, 2005) who could try to convince a na-ive client with a fake server certiﬁcate and if he succeeds, he would be able to cap-ture all sensitive data from the client. This type of attack usually takes the SSL/TLS-enabled communication into some vulnerable state by tampering the securityindicators and making the user believing that the connection is established withthe legitimate server, but the client is actually connected to the attacker’s server.For example, suppose the attacker produces a fake server certiﬁcate in place ofthe legitimate server certiﬁcate and the client accepts the fake certiﬁcate withoutchecking the correctness of the certiﬁcate. After that, when the client wants to con-nect to the same legitimate server (for which the client has already accepted thefake certiﬁcate), the client will be routed to the attacker’s server. This type of at-tack is known as MITM attacks on SSL/TLS-enabled application. Recently, SSLStripping attacks (Marlinspike, 2009), (Shin and Lopes, 2011), (Zhao et al., 2012) also pose a serious threat to defeat SSL/TLS protection to web application. In SSLstripping attack, the user believes that an SSL/TLS connection has been70 M.L. Das, N. Samdariaestablished with the target server, while the attacker has the ability to view theuser’s trafﬁc in clear-text. The attacker suppresses the SSL/TLS peer negotiationmessages and provides the user with a ‘‘stripped’’ version of the requested website,provoking the user to communicate to the server through an insecure channel.
1.1. Our contributions
We discuss the existing solutions to counter the MITM attacks on SSL/TLS-en-abled applications. As most of the solutions consider the client authenticationas an important factor, we discuss the solution space for password, graphical userinterface, and token-based approaches for user authentication. We then present anefﬁcient solution using soft-token based client’s authentication that can resist SSL/TLS-enabled application from MITM attacks. We analyze the proposed solutionfor its security feature on top of the SSL/TLS protocol security, and provide itsefﬁciency in comparison to other approaches.
1.2. Organization of the paper
The remainder of the paper is organized as follows. Section 2reviews the SSL/TLS protocol, discusses MITM attacks on SSL/TLS-enabled application, and outlinesexisting solutions for MITM threats on SSL/TLS-enabled transactions. Section 3 presents the proposed solution for securing SSL/TLS-enabled application fromMITM attacks. Section4analyzes the proposed solution and compares the pro-posed solution with related approaches. We conclude the paper in Section 5.
2. MITM Attacks on SSL/TLS-enabled Applications
An MITM attack is a form of active attack in which the attacker intercepts andselectively modiﬁes intercepted data in order to impersonate a legitimate partyinvolved in client and server communication. Based on intended services and busi-ness perspectives, several SSL/TLS-enabled web applications do not employ clientauthentication as a requirement, instead the web applications enable SSL/TLS inserver authentication mode. The reason behind this is justiﬁed by saying that theserver delivers services as long as the client pays the required amount to the server(e.g., online shopping facilitated by Amazon, eBay), so the client authentication isnot required for such scenarios. Therefore, it is client’s responsibility to checkwhether s/he is talking to the correct server or not. In SSL/TLS protocol, on re-ceipt of the communicating server’s certiﬁcate, the client may get a warning ifany of the following occurs: (i) the Root Certifying Authority (CA) is not recog-nized (or trusted) by the client; (ii) the certiﬁcate is invalid/expired; and (iii) thecommon name (CN) of the certiﬁcate does not match with the Domain NameServer. In such cases, the client should check for a possible reason and drop theconnection if not convinced with the warning message window. It is observed thatOn the security of SSL/TLS-enabled applications 71most of the time the client does not pay attention to such an important warning,and accepts the exception and stores the server’s certiﬁcate in its speciﬁed location.Once the client stores a fake certiﬁcate in its memory, the damage has been done,as s/he is going to talk to a fake server though the connection is protected by SSL/TLS protocol. This type of situation opens up a door to MITM attacker ( Burk- hold, 2002) on SSL/TLS-enabled application. Another potential scenario is thestripping attacks (Marlinspike, 2009; Shin and Lopes, 2011; Zhao et al., 2012 ) on SSL-enabled web applications. SSL stripping attacks assume that an attackeris present in the middle of the victim and the server.
Many websites provide a secure connection between the client and the server byusing HTTPS for protecting user credentials, conﬁdential information such aslogin form, password change, money transaction and so on. Although the serverresponse comes over HTTPS, the attacker changes all <a href = ‘‘https:// ...’’> to <a href = ‘‘http://...’’> before the victim receives the target web page. Thevictim believes that s/he sends the credentials over a secure connection (HTTPS)to the server, but the attacker gets the information by stripping off the connectionby HTTP in place of HTTPS. It is also important for the attacker to keep a list ofall HTTP substitutions that he has made so that he can send the HTTPS requestback to the communicating server. Finally, the MITM attacker spoofs the client toa vulnerable state and steals useful parameters from the client. Although modernbrowsers support many indicators (e.g., padlock) to provide information regard-ing the connection, a naive client generally ignores such indications and falls intothe trap. In some cases, the attacker is able to manipulate these indicators leavingno clue to the user.
In (Li and Wu, 2003), authors proposed a tamper resistant TrustBar in thebrowser to visualize the certiﬁcate information. InYe and Smith, 2002, a concept of synchronized random boundaries has been proposed so as to distinguish be-tween the authentic parts of the browser’s GUI and the rendered content receivedby the server. Another approach that needs fewer changes at the browser is the useof dynamic security skin (Dhamija and Tygar, 2005), where the browser has a per-sonalized area which needs to be customized by the user according to his/her will.It is believed that the attacker cannot spoof the personalized area without knowingthe exact speciﬁcation of the area. We now discuss some approaches for userauthentication on top of the SSL/TLS protocol security strengths in order to mit-igate the MITM attacks on SSL/TLS-enabled web applications.
2.1. Password-based approach
Password-based user authentication is widely used in many real-world applica-tions.Saito et al. (2008)proposed a protocol for binding the SSL/TLS session withthe client using the user’s password. Saito et al’s protocol binds HTTP authenti-cation over SSL/TLS in server authentication mode. As HTTP authenticationdoes not encrypt its channel and client does not authenticate the server, binding72 M.L. Das, N. Samdariathe client’s authentication over SSL/TLS in the server authentication mode canmake the communication secure. The interesting feature of their protocol is thatit binds user authentication without modifying the SSL/TLS, HTTP and HTTPSprotocols. The protocol works as follows. Client and server ﬁrst establish an SSL/TLS connection in the server authentication mode. After that the server authenti-cates the user by using HTTP authentication in arbitrary time. However, the ser-ver can control timing to obtain user’s password. This is a convenient feature thanthe ﬁxed timing of authentication in SSL/TLS Handshake. In order to meet thesegoals, Saito et al’s protocol works with the following steps:
(i) Establishing SSL/TLS Handshake in server authentication mode.
(A1) ClientﬁServer: client_hello.
(A2) ServerﬁClient: server_hello, server’s public key certiﬁcate (cert).(A3) ClientﬁServer: {pre-master-secret}
cert.(A4) ClientﬁServer:fMAC
KmofðA1–A3ÞgKe.(A5) ServerﬁClient:fMAC
KmofðA1–A4ÞgKe.(ii) HTTP user authentication over the SSL/TLS channel.
(B1) ClientﬁServer:fRequest for some pagegKe.
(B2) ServerﬁClient:fRequest for user authenticationgKe. (iii) Exchanging and verifying user credentials for binding authentication.
(C1) ClientﬁServer:fuser id;hðCN;cert;hðuser id;password;K mÞÞgKe.
(C2) ServerﬁClient:fCN;hðuser id;password;hðCN;cert;K mÞÞ;Requested pageg
Ke.
The symbolsCN, MAC,K m,Keandh(.) indicate Common Name in the servercertiﬁcate, Message Authentication Codes, MAC key, Encryption key and hashfunction, respectively. Messages A1–A5 represent the SSL/TLS handshake proto-col. With the Handshake protocol, the client and server establish a master secretkey by which they can derive MAC key (K
m) and encryption key (K e). The mes- sages B1 and B2 involve user authentication steps using HTTP and encryptionkeyK
e. The messages C1 and C2 involve user’s password. The server locally com-putesh(CN,cert,h(user_id, password,K
m)) and compares it with the one receivedin C1, while the client computesh(user_id, password,h(CN,cert,K
m)) and com- pares it with the one received in C2. If they validate the received content success-fully, then they believe that the communication is mutually authenticated. Withthe step (iii), the protocolSaito et al., 2008can bind the client’s authenticationusing the user’s password which can avoid the MITM attack on SSL/TLS sessionin the server authentication mode.
2.2. GUI-based approach
Authentication mechanisms such as PassFaces (PassFaces, 2009) and PASSpicture (Exum, 2007) use the natural ability of humans to recognize images. With thePASSpicture based approach normal textual password is being replaced with aOn the security of SSL/TLS-enabled applications 73sequence of clicks on an image. There are other variants which work in similarways (e.g., clicks on an image or draw a secret picture). Instead of using onlytextual password, graphical password can employ bidirectional authentication,where the server provides its authenticity to the user by displaying user’s graphicalpassword, which was chosen by the user at the time of his/her registration. Uponconﬁrmation, the user authenticates to the server using a kind of challenge-response mechanism. Although, the GUI-based approach provides someresistance to MITM attacks, the mechanism cannot survive once the adversarycaptures user’s graphical password.
2.3. One-Time-Password approach
There are many One-Time-Password (OTP) (Rubin, 1996) mechanisms, such as OTP manual, OTP automatic, OTP synchronous, and OTP asynchronous. Thesemechanisms are brieﬂy explained as follows.
– OTP manual (e.g. Scratch card): A piece of paper or card containing OTP.The OTP must be securely printed and mailed to the customer. Using theOTP the user can login to the system and after that the OTP has no value.In other words, the adversary cannot do anything by knowing the OTP onceit is used, as the user is going to use a different OTP for the next time.– OTP automatic (e.g. SMS): Instead of scratching the OTP from a card, theOTP is sent to the registered user’s mobile phone/PDA via Short MessageService (SMS). Many banking applications use this concept to protect theirapplications from phishing.– OTP synchronous (e.g. Hardware/Software token): The time-synchronizedOTP is same as SecurID, a hardware/software token, where each user isgiven a personalized token that generates an OTP every 30 or 60 s. Thetoken’s clock must be synchronized with the clock of the server.– OTP asynchronous: In this case, the authentication server generates a ran-dom challenge and sends it to the user. The user enters the challenge intohis/her token, which in turn, generates a result based on the challenge andsome seed/secret value stored in the token’s memory (which is known tothe authentication server). Then the user sends the result back to the authen-tication server. Here, the challenge is valid for a short time decided by theserver, and only the authentication server needs to keep track of the validityperiod. The advantage of the OTP asynchronous is that the clock of theuser’s token and the authentication server does not require to besynchronized.
We note that the OTP manual-based user authentication would make user com-fortable for frequent server access. The OTP automatic is secure in comparison tothe OTP manual, but a third party (e.g., mobile service provider) dependency74 M.L. Das, N. Samdariawould be a bottleneck in this mechanism. The token-based OTP for user authen-tication is a secure mechanism, but synchronization is again a bottleneck.
2.4. Token-based approach
Token-based user authentication employs two-factor authentication mechanism.User enters his/her PIN and the token generates a 6-digit or 8-digit random code,which the user enters into the authentication server used for intended application.The authentication server computes the code on its own and checks whether user’scode matches with its code or not. Both the user and the server should be in thesame clock drift in order to accept user’s token generated code. RSA SecurID(RSA SecurID, 2010) is a standard reference for token-based two-factor authen-tication, which has got enormous acceptance in industry and Government sectors.One can also integrate token-based user authentication to SSL–VPN enabledapplication for strong authentication purpose. Since the token generated code israndom in nature, the MITM cannot use it for the next run by retransmitting itto the server, which will be discarded by the server. Some implementations ofthe SSL/TLS session-aware user authentication have been proposed in Oppliger et al. (2006, 2008)that provide the following two ways:
– Hardware-token based implementation: This approach employs impersonaltokens (that is, tokens which are not user speciﬁc) with token speciﬁc secretkeys. These impersonal tokens are used for user authentication to the ACEserver (RSA SecurID, 2010). The token has a small display on which theuser enters his/her PIN and generates the code. The code is then used toauthenticate the user. Although the approach provides security againstMITM, employing such token-based implementation increases complexityand also requires extra cost.– Soft-token based implementation: In this approach, the concept of hard-ware-token is converted to soft-token by emulating its functionality in soft-ware. Soft-token based solution is less expensive than the hardware-tokenbased solution, but it suffers from additional security risks such as keyloggerattacks and visual spooﬁng.
3. The proposed protocol
We present a soft-token based solution to mitigate the MITM threat on SSL/TLS-enabled web applications. The participating entities of our protocol are as follows:
– User/client, who wants to access SSL/TLS-enabled applications.– Server that hosts the SSL/TLS-enabled application.On the security of SSL/TLS-enabled applications 75Before accessing the application, user/client requires to register with the serversecurely. Upon successful registration, user shares its identity ( UID), password (PWD) and a pattern code (PC) with the server. The pattern code is an additionalsecurity measure that is added to our proposed solution. The pattern code is ashape or a sequence of matrix elementA(i,j) of a pattern matrix (Kumar and Raghavan, 2008). Each cell of the pattern matrix is an image that represents acharacter. During the registration process, the user is provided a randomly gener-ated pattern matrix and is asked to choose some sequence of positions by typingthe characters present in the pattern matrix, which then becomes the user’s patterncode,PC. TheFig. 2shows the user’sPC, which is captured in the shaded region(we note that the sequence of user’sPCis superscribed with numbers 1 to 7 in theshaded region), that is,PCinFig. 2is B{#(S7&. The protocol works as follows.When the user/client wants to access to the server, the client and server establishan SSL/TLS session keyKusing the SSL/TLS handshake protocol. After that, theserver generates a soft-token containingPC,UID, and an authentication code,AC, whereAC=MAC(PC;h(all previous SSL/TLS messages)) and MAC(.) is a message authentication code. The soft-token provides user the visual charac-ter-by-character feedback ofPConce the user inputs toAC. The browser will also have a small display where the compressed hash value of all the previous SSL/TLSmessages will be displayed. This area can be customized by the user, therebyavoiding any visual spooﬁng attack. The user generates ACusing the hash value displayed on the browser and her/his pattern codePC. Then, the user submitsUID andACto the server. After receivingAC, the server also calculatesACusing the hash value andPCcorresponding to theUID. If the computedACis same as the receivedACthen the client is authenticated by the server. The user can stop input-ting toACif s/he does not see the pattern code corresponding to the chosen pat-tern at the time of registration. The process of inputting to ACand displayingPC is shown inFig. 3
. Each character ofACis coupled with the SSL/TLS session sothat the adversary is unable to use the same message in a different SSL/TLSsession. The protocol is given below:
Figure. 2Pattern matrix and pattern code.76 M.L. Das, N. Samdaria(A1) CﬁS: client_hello.(A2) SﬁC: server_hello, server public key certiﬁcate (cert).(A3) CﬁS: {pre-master-secret}
cert.(A4) CﬁS: MAC
Kmof A1–A3.(A5) SﬁC: MAC
Kmof A1–A4.(A6) CﬁS:fRequest for some informationg
Ke.(A7) SﬁC:fRequest for user authentication using token g
Ke. (A8) CﬁS:fuser
id;ACgKe.(A9) SﬁC:fRequested informationg
Ke.
Messages A8 and A9 occur as many times as the server sends challenge to theclient.
4. Analysis
4.1. Security analysis
The SSL (ver. 3.0)/TLS (ver. 1.0 or later) protocol provides server authentication,session key establishment and data conﬁdentiality security services. In addition tothese security services, the proposed protocol provides additional security measurefor user authentication code checking using pattern matrix. The pattern matrixwas selected by the user at the time of registration process and stored it securelyat the server. When the user wants to connect to the server s/he has to selectthe appropriate patter code from the displayed pattern matrix on the legitimateserver. Without knowing the pattern matrix chosen by the user, the attackerFigure. 3Pattern matrix and authentication code.On the security of SSL/TLS-enabled applications 77cannot provide the correct patter matrix to the user/client, which eliminates theMITM attacks on SSL/TLS-enabled applications.4.1.1. Server authentication
In SSL/TLS server authentication mode, the client receives the server certiﬁcatethrough theserver_hellomessage. Upon seeing the server’s certiﬁcate, the clientcan check its validity (by checking the issuer, subject, validity period, trust chain,purpose of the certiﬁcate) whether s/he is interacting with the correct server or not.However, the correctness checking of the server certiﬁcate by a naive user is a bot-tleneck. Moreover, if the client (i.e., browser) accepts (or stores somehow) a fakecertiﬁcate of the (attacker) server then the user’s password will get leaked to theattacker, because the user will enter his/her password after establishing the SSL/TLS connection to the attacker server in believing that s/he is talking to the correctserver. Below we show that how the proposed protocol can counter this threat byauthenticating the client on server stored client’s information.4.1.2. Client authentication
Many SSL/TLS-enabled applications do not employ public key certiﬁcate basedclient authentication. The reason behind is that the client’s authentication is notrequired for such applications. Other possible reasons are: (i) employing publickey certiﬁcate for client’s authentication increases computational cost; (ii) clientis required to buy certiﬁcate from a trusted authority; (iii) mobility issues for clientcertiﬁcate that is, if the client wants to access the server from different placesacross several machines or browsers, then the client has to carry its certiﬁcate ina device. Now if the server imposes client’s authentication as a mandatory require-ment then instead of using certiﬁcate based client authentication one can use asoft-token based approach. The proposed solution is based on soft-token for clientauthentication on server stored client’s information, which can avoid the MITMattack on SSL/TLS-enabled applications, as explained below.
Suppose that an attacker attempts to mount an MITM attack by impersonatinga user who wants to access a server enabled with the SSL/TLS protocol. We as-sume that the attacker establishes the SSL/TLS session with user and anotherSSL/TLS session with the server who hosted the SSL/TLS-enabled application.In the scenario between user and attacker, the attacker presents a false token tothe user and asks for theUIDandAC. Then, the attacker forwards theUIDto the server so as to spoof the user. In this situation, the server will abort the session,as the server can identify that theACgiven by the user does not belong to the sameSSL/TLS session as the server sees a different hash of SSL/TLS messages. Further-more, the user is not revealing her/his credentials at any stage. Therefore, the at-tacker cannot get user’s pattern codePCin order to impersonate the user. Thescenario is depicted in theFig. 4(K1andK2are SSL/TLS session keys), wherethe attacker will not be able to succeed in gaining anything, as two different values78 M.L. Das, N. SamdariaofACs for the two different sessions are being executed by the attacker while inter-acting with the user and the server. Even though the attacker submits a fake servercertiﬁcate to the client and if the client accepts it, the attacker cannot gain any-thing from the client as the attacker does not have any knowledge of the user’sACstored in the server. Therefore, MITM attacks cannot work in the proposedsolution.4.1.3. Replay attack
The session key of the proposed protocol is generated by pre-master secret key,client and server’s random numbers, and other session speciﬁc parameters. If anadversary intercepts messages from the current or previous run of the protocoland tries to replay any messages in a new run of the protocol to get access ofthe server, then the adversary will not be succeeded because the server will discardthe request as the messages will not pass the freshness property. The usage of ran-dom numbers of client and server in the session helps in resisting the replay attack.Therefore, the proposed protocol is not vulnerable to replay attack.4.1.4. Password guessing attack
In the conventional password-based user authentication protocol, attacker at-tempts to guess user’s password by intercepting messages between the user andthe server. Once the attacker guesses the user’s password correctly, he will thenimpersonate the user for gaining access to the server. In the proposed protocol,the user password is not communicated to the server. Instead, the user generatesan authentication codeACusing the patter matrix chosen by the user at the timeof registration to the server. This avoids password guessing attacks in the pro-posed protocol. In other words, the proposed protocol prevents the passwordguessing attack.Figure. 4Safeguard against MITM attacks on SSL/TLS-enabled application.On the security of SSL/TLS-enabled applications 794.2. Performance
We give a comparison of all approaches that we have discussed in the paper inTable 1. From the table we can see that the proposed soft-token based approachprovides optimal solution in terms of security and efﬁciency.
The proposed solution is also usable. The user is required to input the ACand then s/he will be able to see thePCchosen at the time of registration. The ap-proach does not require registered user to carry any device/token while s/he isroaming from one place to another place. Only thing s/he requires to rememberat the time of connecting to the server is her/his patter code PC, which is similar to remembering a password.
5. Conclusions
We have discussed about the MITM threat to SSL/TLS-enabled web applications.We reviewed the existing approaches for user authentication and proposed asoft-token based user authentication. By enabling the proposed solution in SSL/TLS-enabled web application, the MITM attacks can be avoided. The proposedsolution requires a trusted display (controlled by the legitimate server) on thebrowser to render the compressed value of the hash of SSL/TLS handshake mes-sages. The proposed solution is computationally efﬁcient and provides additionalsecurity on top of the SSL/TLS protocol’s security strength.
References
Burkholder, P., 2002. SSL Man-in-the-Middle Attacks. SANS Institute Information Security.
Dhamija, R., Tygar, J.D., 2005. The battle against phishing: dynamic security skins. In: Proc. of the Symposiumon Usable Privacy and Security. ACM Press, pp. 77–88
.
Dierks T., Rescorla E., 2008. Transport Layer Security Protocol. Network Working Group, RFC 5246. Availablefrom: <http://tools.ietf.org/html/rfc5246>.
Exum, T., 2007. Graphical passwords. In: Communication Security. < http://www.infosecwriters.com/textre- sources/pdf/GraphicalPasswordsTExum.pdf > (Retrieved December 2013).
Kumar, T.R., Raghavan, S.V., 2008. PassPattern System (PPS): a pattern-based user authentication scheme. In:Proc. of the International IFIP-TC6 Networking Conference on AdHoc and Sensor Networks, WirelessNetworks, Next Generation Internet. ACM Press, pp. 162–169
.
Li, T.Y., Wu, Y., 2003. Trust on web browser: attack vs. defense. In: Proc. of International Conference onApplied Cryptography and Network Security (ACNS), LNCS 2846, pp. 241–253.
Marlinspike, M., 2009. New Tricks for Defeating SSL in Practice. In BlackHat.Table 1Comparison of different approaches.Approach Resistance to MITM attack Computational cost User FriendlinessPassword-based Yes Low YesGUI-based No High YesOne-Time-Password based Yes High NoHard-token based Yes High NoProposed Soft-token based Yes Low Yes80 M.L. Das, N. SamdariaOppliger, R., Gajek, S., 2005. Effective Protection against Phishing and Web spooﬁng. Communications andMultimedia Security, pp.32–41.
Oppliger, R., Hauser, R., Basin, D., 2006. SSL/TLS session-aware user authentication – or how to effectivelythwart the man-in-the-middle. Comput. Commun. 29 (12), 2238–2246
.
Oppliger, R., Hauser, R., Basin, D., 2008. SSL/TLS session-aware user authentication revisited. Comput. Secur.27 (3–4), 64–70
.
PassFaces, 2009. <http://www.passfaces.com/enterprise/products/web access.htm > (Retrieved June 2009).
RSA SecurID: Securing Your Future with Two-factor Authentication. < http://www.rsa.com/> (Retrieved January 2010).
Rubin, A.D., 1996. Independent one-time passwords. In: The USENIX Association of Computing Systems, vol.9, pp.15–27.
Saito, T., Sekiguchi, K., Hatsugai, R., 2008. Authentication binding between TLS and HTTP. In: Proc. of theInternational Conference on Network-Based Information Systems, LNCS 5186, pp. 252–262.
Shin, D., Lopes, R. 2011. An empirical study of visual security cues to prevent the SSL stripping attack. In: Proc.of the Computer Security Applications Conference (ACSAC 2011), ACM, pp. 287–296.
Ye, Z.E., Smith., S. 2002. Trusted paths for browsers. In: Proc. of the USENIX Security Symposium, pp. 263–279.
Zhao, S., Wang, D., Zhao, S., Yang, W., Ma, C., 2012. Cookie-Proxy: a scheme to prevent SSLStrip attack. In:Proc. of the International Conference on Information and Communications Security (ICICS’12), LNCS 7618,pp. 365–372.On the security of SSL/TLS-enabled applications 81