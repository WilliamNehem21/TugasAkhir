 AASRI Procedia   4  ( 2013 )  313 – 318 
2212-6716 © 2013 The Authors. Published by Elsevier B.V.
Selection and/or peer review under responsibility of American Applied Science Research Institute
doi: 10.1016/j.aasri.2013.10.046 ScienceDirect
bA
Abst
Most
with 
the n
whic
datab
 
© 20
Sele
 
Keyw
1. In
In
searc
cons
M
patte
We 
defin
The 
func
time
algo
The 
 
* 
E
 Cons t
Van
      aDepart m
Associate Profess
 cProfessor & H e
tract 
t of the patter s
constraints in a
non-aggregate f
ch may be emb e
base. The algor i
013 The Auth
ection and/or p
words :  sequence p
ntroduction 
n this paper t h
ching for a s t
straints. The e l
Most of the a l
erns with con s
search for a 
ned constrain t
algorithm d e
ctions is possi b
e efficiency. S
rithm is to m a
efficiency ca n
Corresponding a
E-mail address:  ra2013 A A
traint B a
D
ngipuram R
ment of Informati o
or , Department o
ead, Department 
search algorith m
a given databa s
functions as p a
edded into SQ L
ithm makes us e
ors. Publishe d
peer review u n
pattern;look ahe a
he idea is to fi r
tring based p a
lements of pa t
lgorithms des i
straints. An at t
sequential pa t
t.  
eveloped may 
ble which ma k
Section III, I V
ake the patter n
n be seen fro m
author. Tel.: +97 0
adhakrishna_v@ vASRI Con f
ased Se q
Databas e
Radhakris h
on Technology, V
of Computer Sci e
of Computer Sci e
ms in literatur e
se. Also in que r
art of query co m
L or MySQL Q
e of sliding seq u
d by Elsevier B
nder responsi b
ad; time series;se q
rst perform pre
attern, we per
ttern consider e
igned in liter a
tempt is mad e
ttern of inter e
be embedde d
kes the comp l
V describes t h
n shift by a le n
m the moves m
00684242 
vnrvjiet.in  ference on I n
quential P
es - A t w
hnaa*,Chin t
VNR Vignana Jy o
ence and Engine e
ence and Engine e
 
e are mostly st r
ry languages su
mpilation. The 
Query languag e
uential pattern s
B.V. 
bility of Ame r
quence tuple 
eprocessing o f
form search f
ed are numeri c
ature are stri n
e in this wor k
est in a give n
d in to any e
lexity of the q
he proposed a
ngth more tha n
made by the p antelligent S
Pattern M
wo Wa y A
takindi Sri n
othi Institute of E n
ering, Kakatiya I n
ering, S. R Engin e
 
 
     
ring based and 
ch as SQL or M
objective of t h
es so that we c a
s with three loo k
rican Applied 
f the sequenti a
for a sequenc e
cal type.  
ng based and 
towards this d
n database wi t
existing query 
query get red u
algorithm wi t
n the pattern l
attern itself. ystems an d
Mining i
Approa c
nivasb,Dr.C
ngineering and Te
nstitute of Techn o
eering College, H
do not conce n
MySQL, the sel
his work is to p
an search for p r
k-ahead eleme n
Science Res e
al pattern befo
e of tuple or r
are not deve l
direction by c o
th each patte r
languages s o
uced in terms o
th a working 
length as co mpd Control 
in Time 
ch 
C.V.Guru R
Technology, Hyder
ology and Scienc e
Hasanparthy, Wa r
ntrate on findin g
ect clause doe s
propose a patte
resence of seq u
nts in the event 
earch Institute 
 
ore the search 
record values
loped by con s
onsidering a t i
rn element i m
o that the us e
of query proc e
example. Th e
mpared to the eSeries 
Raoc 
rabad, INDIA  
e, Warangal, IND
rangal, INDIA 
g sequential p a
s not allow the u
ern mining alg o
uential pattern 
of any mismat c
process. Inst e
 with user d e
sidering sequ e
ime series dat a
mposed with a
e of non agg r
essing and al s
e objective o f
existing algori tDIA 
 
atterns 
use of 
orithm 
in the 
ch.  
ead of 
efined 
ential 
abase. 
a user 
regate 
so the 
f this 
thms. 
Available online at www.sciencedirect.com
© 2013 The Authors. Published by Elsevier B.V.
Selection and/or peer review under responsibility of American Applied Science Research InstituteOpen access under CC BY -NC-ND  license.
Open access under CC BY -NC-ND  license.314   Vangipuram Radhakrishna et al.  /  AASRI Procedia   4  ( 2013 )  313 – 318 
2. Related Works In [1] Wang and Kobayashi propose a pattern search algor ithm for network security applications that computes a function called next before the start of the search process.  The value defined by next is used in the event of a mismatch between the pattern and the text. In [8] the author s design a pattern search algorithm using two sliding windows. In [6] algorithm uses the concept of implications to find the relation between the pattern elements and is designed to find the sequence pattern in a given database. In [9] algorithm designed performs the two way pattern search using sliding patterns. The algorithm in [10] uses three sliding windows.  3. Proposed Work The algorithm consists of two steps.   a) Pre-process sequence pattern with constraints. b) Search for sequence pattern in the given database.   3.1 Preprocessing phase  
3.1.1 Left Shift failure function  
1                                ;    pattern[length (pattern) -1]=L 1  2                                ;    pattern[length (pattern) -1]pattern[length (pattern) -2]=L
2L1  length (pattern) -index            ;     pattern[index]pattern [index+1] pattern [index+2] =L
1L2L3  left_shift [L
1, L2, L3] = minimum                   length (pattern) +1               ;    pattern [0] pattern [1] =L 2L3                                                          length (pattern) +2                  ;    pattern [0] =L
3                         length (pattern) +3               ;     else                                                                                    
(1)    3.1.2 Right Shift failure function 
                                                     length (pattern) +2                ;   pattern [length (pattern) -1] = L 1                                      length (pattern) +1                ;   pattern [length (pattern) -1] pattern [length (patt ern) -2] = L
2L1                                                                       index +3                                  ;   pattern [ind ex] pattern [index+1] pattern [index+2] = L
1L2L3  Right_shift [L
1, L2, L3] = minimum               1                                                ;    pattern [0] pattern [1] =L 2L3                                                                                                                          2                                                ;    pattern [0] =L
3                                                                                                             length (pattern) +3                       ; else                                                                                      (2) 
  In the preprocessing phase failure functions are first computed. In case of any mismatch in the search process the algorithm uses three attribute values of the input present  immediately after the aligned sliding pattern. These attribute values are called look ahead elements.     315  Vangipuram Radhakrishna et al.  /  AASRI Procedia   4  ( 2013 )  313 – 318 
The algorithm for the preprocessing of the sequence pattern is given in fig 1 below.  
 
 
  Fig. 1. Algorithm for computing shift-left and shift-right failure functions 
3.2. Search  for Sequence Pattern in the Database  This phase consists of searching for the sequence pattern over a specific attribute or column in given database. Initially the pattern is aligned with left end and right end of the input database. Algorithm scans concurrently from both sides of database to find the presence of user define d sequence pattern. Initially, algorithm starts by searching for presence of the sequence pattern from left end of the database.  While searching from left if a mismatch occurs, the sequence pattern window is shifted rightward by a shift value defined by the left shift failure function. The algorithm now performs the search process by scanning from the rightmost end of the database moving towards left and if a mismatch occurs; shift-right failure function is used to shift the pattern towards left. Algorithm terminates when the pattern is found or the left and right indices over cross each other.   
   Step1:  At start the sequential pattern is aligned with left a nd right ends of the input database. To reduce the number of comparisons made, only the terminal elements of sequence pattern are compared. If the dead end elements match with pattern elements then we compare other pattern elements.  In an event of any mismatch, the algorithm moves to step2 otherwise the searching continues till the sequential pattern of interest is found. On success it reports the index position of the sequence pattern.  
     Step2:
 When a mismatch occurs from left end of the database while searching from the left, algorithm uses shift-left function to shift the sequence pattern making us e of three attribute values of the input database which immediately appear after the aligned left sliding pattern . Similarly, shift value is computed using right failure function if a mismatch occurs from right end of database. This process continues until first occurrence of sequence pattern is found in the input database from either side or until both indices of sliding patterns over cross each other. The detailed algorithm for the same is given below in fig 2.          
 Begin algorithm  left_shift     
 length (pattern) +3; right_shift   
 length (pattern) +3; 
for each pattern element Pattern [index] from i  0 to length (pattern) -3 do  
       Compute Next [index] as Next [index]   length (pattern) –index; 
                                                 next [index]   index+2 
end for          If (pattern [length (pattern) -1] = =L
1) then                          {left_shift
 1; right_shift  length (pattern) +2} else If (pattern [length (pattern) -1] pattern [length (pattern) -2] = =L
2L3) then                          {left_shift
2; right_shift length (pattern) +1} else If (pattern [index] pattern [index+1] pattern [index+2] = = L
1L2L3) then                         {left_shift
 next[i]; right_shift next[i]} else if (pattern [0] pattern [1] = =L
2L3) then                        {left_shift
m+1; right_shift 1} else if (pattern [0] ==L
3) {left_shift length (pattern) +2; right_shift 2} end  if  end of algorith
m 316   Vangipuram Radhakrishna et al.  /  AASRI Procedia   4  ( 2013 )  313 – 318 
  
             
    Fig. 2. Searching Algorithm 
4. Working Example  
                                              where      P
1 = tuple.value <   tuple.previous.value                                                        P
2 = tuple.value <   tuple.previous.value ^ 40 < tuple.value < 50                                                        P
3 = tuple.value >   tuple.previous.value ^ tuple.value < 52                                                        P
4 = tuple.value >   tuple.previous.value.                                            and the operator ‘^’ indicates logical AND operation.            P1 P2 P3 P4 Left 0;                             //  index used from left Right
n-m;                     //   index used from right found
false;                  //    initial value while (Left < = Right) do         leftindex  
length(pattern)-1;         rightindex
 length(pattern)-1;         if (Pattern [0] ==inputdB [Left])    while (leftindex > 0) do             if (Pattern[leftindex] ==inputdB [Left])                  leftindex
leftindex-1;             else                 break;     end while if (Pattern [0] ==inputdB[Right])      while(rightindex>0) do              if (P[rightindex] ==T[rightindex+Right])                   rightindex
rightindex-1;              else                  break;       end while if (leftindex = = 0) {sequence retrieved left end at: Left} ; exit from outer loop; if(rightindex = = 0) {sequence retrieved at right end at: Right};  exit from outer loop; Left
 Left + shiftL (text substring (Left+m, Left+m+3)); Right
Right-shiftR (text substring (Right-3, Right)); if (Left > Right) {search is failure} exit from outer loop; 317  Vangipuram Radhakrishna et al.  /  AASRI Procedia   4  ( 2013 )  313 – 318 
Think of a scenario as in [8] where we are interested to find trends in the temperature for four consecutive days, i.e every possible instance where a sequence pattern co nsists of two immediate falls followed by two immediate hikes and the drops are such that the temperature to lie between 40
oc and 50oc.  Also the first increase does not let the temperature move beyond 52
oc.Here, we need to retrieve the sequence of Quintuple (A, B, C, D, E) with B.value < A.value, C.value < B.value, 40 <C.value<50, C.value<D.value, D.value<52, D.value<E.value holding well. The optimal set of constraints called as pattern elements are thus derived as shown above. The working of the algorithm is as explained below  
First iteration:  The search process begins by comparing pattern elem ent at index=0 to the element of the inputdB at index=0. As there is a  mismatch and also as all other  cases violate, So left_shift failure function computes shift value as length(pattern)+ 3 = 7. The algorithm shifts sequence pattern to the right by 7 units. At the end of first iteration the algorithm makes the pattern indices from 0 to  3 aligned to indices of inputdB from 8 to 12. 
 Second iteration: Now the 
sequence pattern aligned at right end of the input database is considered for search process, pattern element at index 0 is compared with the database element at index 10. Since there is a mismatch, the immediate three attribute values to the left of the input da tabase at indices 7, 8, 9 are considered to compute shift value using right_shift failure function. We stop the search process as there is a mismatch and start the search process from left end. 
 Third iteration: T
he elements of the sequence pattern from indices 0 to 3 are compared with the input database attribute values from indices 8 to 11 and it is a success. So stop and output the sequential pattern.    
10 40 70 80 65 4253 48 46 49 6075 80 60 
                                      P0     P 1      P 2     P 3                                                                           from left end first iteration                                                       
                                                             from right end second iteration                                          P 0    P 1    P 2     P 3  
                                                          from left end third iteration                              P 0    P 1     P 2    P 3          [Best case Move] 
Fig. 3. Working Example  
5. Conclusion A sequential pattern mining algorithm with the pattern elements consisting of the user defined constraints is presented in this work. Failure functions are designed to handle the case of mismatch. The process of concurrent searching from the both ends of the database makes algorithm more efficient for the worst case situation when required sequence pattern is even at the end of the input. The reduction in the number comparisons done is visible from the best case move where algorithm shifts the patter n by a shift value greater than length of pattern when compared to algorithm used in [6].     318   Vangipuram Radhakrishna et al.  /  AASRI Procedia   4  ( 2013 )  313 – 318 
References 
 
[1]     Knuth, D.E., J.H. Morris and V.R. Pratt. Fast  pattern matching in strings. SIAM Journal of Computing. 6(2).1977, 323-350. [2]     Boyer, R. S. AND Moore, J. S. A fast string  searching algorithm. Communications of the ACM. 20(10).1977, 762–772. [3]     R. Nigel Horspool.  Practical fast searching in strings. Software Practice and Experience. John Wiley and Sons. (10) 1980, 501-506. [4]     T.BERRY AND S.RAVINDRAN A Fast String Matc hing Algorithm and Experimental Results, Proceedings of Prague Stringology              Club, workshop’99 [5]     Handbook of Exact String Matching Algorithms. [6]     Expressing and Optimizing Sequence Queries in Database Systems. http://www.cs.ucla.edu/~zaniolo/papers/todsjune04.pdf [7]     Wang, Y. and H. Kobayashi. High performance pa ttern matching algorithm for network security.6 (10). 2006, 83-87. [8]     Mjad Hudaib, Rola Al-Khalid, Dima Suleiman, Mariam Itriq and Aseel Al-Anani. A Fast Pattern Matching Algorithm Using Two            Sliding Windows, Journal of computer science. 4(5) 2008, 393-401. [9]     V.Radhakrishna, B.Phaneendra, V.Sangeeth Kuma r. A Two Way Pattern Matching Algorithm Using Sliding Patterns. In the   Proceedings of 3
rd IEEE International Conference on Advanced Computer Theory and Engineering. (2) 2010, 666-670. [10]   V.Radhakrishna, C.Srinivas, Dr.C.V.Guru Rao. High Performance Pattern Search algorithm using three sliding windows. IJCET  3(2) 2012, 543-552. Journal Impact Factor: 3.9580 calculated by GISI.   