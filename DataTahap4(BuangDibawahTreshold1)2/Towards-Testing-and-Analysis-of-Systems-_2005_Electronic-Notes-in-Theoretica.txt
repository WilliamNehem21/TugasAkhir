Object serialization facilitates the flattening of structured objects into byte streams and is therefore important for all component-based applications that strongly rely on data-exchange among compo- nents. Unfortunately, implementing and controlling the serialization mechanisms may expose the software to subtle faults. This paper paves the way towards testing and analysis techniques specifi- cally tailored to the assessment of software that uses serialization. In particular, we introduce a tax- onomy of abstractions and terms to semantically characterize and classify the main data-exchange cases, which serialization can be involved with. The resulting conceptual framework provides a means to forecast how erroneous implementations of serialization would look like in different cases, thus enabling the focusing of testing and analysis techniques to address serialization-related faults.

Unfortunately, changing the default behavior of serialization exposes the software to subtle faults. Consider for example the case in which two com- ponents exchange an object and this involves serialization. Subtle faults and failures may show up if the receiving component assumes that the object structure is as defined in the sender component, but instead the structure was modified during serialization. The first part of this paper reports a number of sample cases of software faults that can be accounted to the use of serialization. However, to the best of our knowledge, in the current research and industrial practice there is lack of testing and analysis techniques that address correct- ness of the software in presence of serialization. This motivates our research

As a first milestone towards this goal, the main contribution of this paper is the definition of a conceptual framework for reasoning about serialization. We introduce a taxonomy of abstractions and terms to semantically characterize and classify the main data-exchange cases, which serialization can be involved with. We draw the link between the identified semantic cases and the linguistic support for serialization. Our conceptual framework provides a means to forecast how erroneous implementations of serialization would look like in different cases. This enables focusing of testing and analysis techniques to address serialization-related faults. As preliminary evaluation of our research, we sketch how the defined conceptual framework may facilitate the adaptation of the ideas of traditional data-flow testing [6,5] for verifying serialization. We illustrate the framework and the examples referring to Java, but we believe that the ideas can be easily ported to other programming language.

Part of the work presented in this paper relates to the concepts presented by Fuggetta, Picco and Vigna in [2]. Referring to mobile code systems, these authors distinguish mobility mechanisms for three elements of a program: code, execution state and data space. In particular, data mobility involves transfer of structured data across computing environments and is often prac- tically accomplished by means of serialization [10]. Our taxonomy of data- exchange cases can be regarded to as an extension of the data mobility cases presented in [2].

The paper is organized as follows. Section 2 illustrates some sample soft- ware faults that can be accounted to the use of serialization. Section 3 pro- poses a conceptual framework for reasoning on testing and analysis techniques for serialization. Section 4 exemplifies how our framework may support the definition of dataflow-based testing of serialization related faults. Section 5 summarizes the contributions of this paper and sketches the future agenda of our research.

void readObject(Object) of the class ObjectInputStream. By default, when an object is serialized, its whole object graph is serialized, i.e., all di- rectly and indirectly referenced objects are recursively serialized as well. The default behavior of serialization can be altered by marking object references as transient, thus interrupting the recursion in the a branch of the object graph, or redefining the methods readObject and writeObject for specific classes of objects. Serialization can be the source of subtle faults in a software system. Referring to Java, this section provides examples of faults that can be accounted to serialization in specific cases.

The state of a complex object is often composed of other objects. For instance the state of a Person object might include an Address object containing in- formation like street, city, zip code and so forth. By default in Java the serial- ization of a Person object would imply the serialization of the corresponding Address object. In general, the serialization of an object o is performed by recursively serializing all objects referenced in o.

Static attributes address the definition of properties that are shared among all objects of a class. In Java the values of the static attributes are not serialized by default. Thus, when an object is resumed from a stream, its static attributes are inherited from the new runtime context. This however may be a potential source of faults if all possible bindings are not considered. For example, let us consider a class WebPage that contains a static attribute style, which references an object of class PageStyle storing style attributes for all pages in a given context:

When a WebPage object is serialized, the contained static reference is ig- nored. When the object is deserialized, style is set to the PageStyle object in the new environment. However, if the attribute is undefined in the new environment, the attribute style of a deserialized WebPage object will inherit the default reference value, i.e., a null reference. This can produce undesired effects (e.g., a NullPointerException) if the value of style is not checked before use.

Replication of the code from constructors is often the case in practice for customizing the deserialization process in presence of static attributes. However, for complex programs, it can be difficult to correctly choose which constructor and which parts must be replicated. This generates a new source of potential faults.

In component based applications, it is likely that different components may refer to different versions of the same class, for instance because platforms have been updated at the different moments. It is possible that a component receives a serialized object that does not match the held version of the class. Deserialization would fail in this case.

ject state variables, the metadata and the serialVersionUID of the class. This latter is a static attribute assigned to classes at compile-time. It represents the class version as a long integer number. Conversion can be accomplished during the serialization process in two ways:

The existence of a cycle in the transitive closure of the references of a given object could, in principle, cause the same object to be serialized multiple times in the same stream. To avoid this situation, the default serialization maintains memory of already serialized objects and inserts only a token into the stream when the same object occurs again. Tokens are such that they uniquely identify the objects. This mechanism prevents infinite recursion, but also hinders the serialization of a new copy of an already serialized version, which sometimes can be the desired behavior.

After establishing the communication, the client sends to the server two ob- jects of the class Counter. (Although not explicitly shown, the class Counter is supposed to provide the functionality of a simple counter that is initialized to zero on construction and can be incremented of a unit with the method Inc.) The client initializes a counter, serializes it and sends it to the server through the TCP socket. The operation is repeated twice and the counter is incremented in between. The server receives the objects and prints their values on the screen. In the showed example, the communication results in a failure: the server prints the number 0 twice, instead of printing 0 and 1 as expected. The reason for such faulty behavior is that the Counter object is not serialized the second time that the client writes it into the stream. In- stead, a token that refers to the previous copy of the counter is inserted into the stream.

Rebinding occurs when an object graph is excluded from the data-exchange with the semantics that the corresponding reference will be relinked in the target environment to an object of the same type. Rebinding is possible in two different ways, depending on the identity of the relinked objects. Rebinding to the original object occurs when the original subgraph is relinked through a link that spans across the target and the original envi- ronments. Conversely, rebinding to a different object occurs when the actual relinked objects are different from the original object graph. For example, rebinding to the original object is used in Java-RMI ([8]) when a remotely accessible object is passed as parameter to a remote method (i.e., a method of a remote component), resulting in the object remaining local and only a remote reference being passed to the remote component: the object graph is not transferred, while instead as a result of the invocation, it is relinked from within the remote component. Rebinding to a different object happens for example in the case of a software agent that migrates across the network and links to resources in the reached hosts, after having detached the correspond- ing resources in the original host.

The definition of testing techniques addressing serialization is not straight- forward since both semantics of current operation and semantics of the seri- alization must be taken into account. To support testing of serialization, we developed a reasoning framework based on our knowledge on the possible data exchange strategies that may occur with serialization. We do not claim this framework to be complete or exhaustive, but we investigated its usefulness by showing that it allows to tune and extend dataflow testing for systems that use serialization.

We are currently working to refine and complete our conceptual framework for reasoning on serialization. In particular, we are currently investigating the connection between the data-exchange cases classified in the framework and the implementation support provided in Java for serialization. We are also conducting further research on testing and analysis techniques that can be defined based on our conceptual framework. We are refining the specialized dataflow testing approach that we preliminarily described in this paper. We are finally investigating assertion-based run time verification [7,11]. This lat- ter could exploit our conceptual framework as a base for the definition of specialized assertions to address serialization.

