Software components are now widely used in the development of systems. However, incompatibilities between their behavioural interfaces may make their composition impossible. The objective of software adaptation is to compensate such incompatibilities building as automatically as possible corrective connec- tors or components. Constructing component-based systems from scratch is difficult, in particular when components cannot be used directly since they have to be adjusted with respect to their mates. Incremental construction methods are therefore essential because they make it possible to build systems step by step and therefore to master the complexity of their adaptation. In this paper, we propose an incremental approach to build component-based systems which relies on the generation of adaptors to overcome behavioural in- compatibilities. The adaptation stage can be automated being given an abstract mapping formalising the properties of the system to be adapted.

Software components are now widely used in the development of systems, including embedded systems, Web services and distributed applications. The main challenges of Component-Based Software Engineering are composition, adaptation and verifi- cation of component applications. Software adaptation [16,7] aims at generating as automatically as possible component adaptors. Their role is to compensate incom- patibilities appearing in a system constituted of communicating entities. It is now

Building a software system from scratch is a difficult task even if one of the promises of the component-based approach is to make the reuse of existing software entities easier. Moreover, composing components is a task which must take also into account adaptation of incompatible components. We propose an approach to build incrementally component-based systems, and where the generation of adaptors is fully automated if the software architect gives an abstract description of the properties of the system to be adapted, i.e., an adaptation mapping.

The rest of the paper is organized as follows. Section 2 presents the formal model of components, and the architectural style we rely on. Section 3 focuses on adaptation, and presents mechanisms to check if adaptation is needed, to compute adaptors, and to assess them. In Section 4, our approach for incremental construc- tion involving components and adaptors is presented. We describe how the system is updated as automatically as possible when one component is added or removed. Section 5 illustrates our incremental approach on several case studies. We end in Section 6 with concluding remarks.

Various definitions of behavioural mismatch have been proposed in the field of software adaptation and Software Architecture analysis. We build on the most commonly accepted one, namely deadlock-freedom. Intuitively, a system made up of several identified components is deadlock-free, and therefore does not need any adaptation, if its synchronous product has no deadlock.

In practice, behavioural mismatch can be computed (i) encoding the set of LTSs in the EXP.OPEN input format [11], (ii) computing the product, and (iii) checking the absence of deadlocks on the resulting automaton. Note that to distinguish final states and real deadlocks within EXP.OPEN LTSs, we first add specific loop transitions labelled with accept over final states. Point (i) has been encoded in ADAPTOR, a prototype tool under development dedicated to the adaptation of software components. Points (ii) and (iii) are computed automatically calling CADP

In this section, we follow the adaptor generation process proposed in [8]. To check if a system made up of several components presents behavioural mismatch, the synchronous product [3] of their LTS behavioural interfaces is computed and then the absence of deadlocks is checked on it. The protocol of an adaptor is given by an LTS which, put into a non-deadlock-free system yields a deadlock-free one. For this to work, the adaptor has to preempt all the component communications. Therefore, prior to the adaptation process, component message names may have to be renamed prefixing them by the component name, e.g., c:message!.

Once a new adaptor is generated, we propose different means to assess the new system and make the architect sure that this system still contains all the expected services. Being given a set of components and their adaptors, the synchronous product is computed. Then, we propose several techniques to assess the adapted system.

The addition of a component does not always need protocol adaptation, e.g., when adding the first component or when the test of mismatch does not detect a deadlock. However, our approach associates an automatically generated no-op adaptor to every component as in [15]. Such an adaptor basically reproduces from an external point of view the same behaviour as its component, and then routes

Step (iv)(b) takes into account two slightly different cases, since an erroneous system can be worked out either proposing a new mapping instead of the former one and then replacing the last adaptor, or keeping the last adaptor and proposing an additional mapping to build another adaptor to be connected on top of the previous one. We will illustrate such a situation in Section 5.2. Last, mappings have to be kept while building the system since in case of suppression, they may be modified and their corresponding adaptors updated.

Our first example is a simplified version of the component-based Video-on-Demand (VOD) system described in [6]. We consider a client-server system formed by two kinds of components, one server component, called VOD, and one or more clients of VOD. The server VOD offers services to watch movies. If a client has not registered before, he can only preview movies. If a client has registered, he can view movies. In case of registered clients, the movie can be played directly or recorded (i.e., the movie is first stored and played later on). Our objective, here, is to use adaptors to take into account the differences between registered and unregistered clients. The behavioural interfaces of VOD and its clients are the following:

Let us suppose that an unregistered client is added, C1. It has the same be- havioural interface as Client (shown above), i.e., C1 = Client. In this situation, VOD and C1 are incompatible since they use different action names (e.g., search and menu actions do not match). Thus, the architect provides the following mapping that is used to generate A C1, i.e., the adaptor for C1:

In this section, we consider a component-based system simulating the classical din- ing philosophers problem instantiated to the case of two philosophers and two forks. In order to eat, each philosopher needs both forks. In our model, we consider three kinds of components: Fork, Phil1 and Phil2. The behavioural interface of Fork is the following:

Phil1 and Phil2 have different behavioural interfaces (they are given below). In the classical formulation of this problem, philosophers share the same behaviour which may cause a deadlock when they both interact to access the two forks. In this example we have simplified the classical formulation by isolating only the behaviour of each philosopher that may cause a deadlock, when both of them are present. The behavioural specifications of Phil1 and Phil2 are the following:

different names can be inserted into the system, the two philosophers have also a mismatching interaction protocol. The system deadlocks whenever, e.g., Phil1 asks for and obtains the access to the first fork and then, Phil2 asks for and obtains the access to the second fork. At this stage, both philosophers are blocked waiting for their complementary fork that will never be assigned to them.

The addition of the two Fork components F1 = f1:Fork and F2 = f2:Fork is done analogously to what we have done in Section 5.1 for the addition of the VOD server. The no-op adaptors of F1 and F2 are A F1 and A F2, respectively.

is stated that the system (A F1 | A F2 | A Phil1 | phil1:Phil1) has no service Analogously to what we have done in Section 5.1, the adaptor is assessed and it lost (wrt. the services provided by F1 and F2). Thus, Phil1 and its adaptor are

Now, Phil2 has to be added. The addition of Phil2 is carried out analogously to the addition of Phil1 hence giving a mapping M2 and generating an adaptor A Phil2 connected to Phil2, A F1 and A F2. This example points out an interesting application scenario of our approach. When the architect performs the deadlock

Last, we consider a component-based Hi-Fi system formed by four components: HF, TR, PDA1 and PDA2. HF controls an Hi-Fi station which can be asked to (i) play mp3 files, i.e., read?, (ii) stop reading, i.e., halt?, (iii) stop reading temporarily, i.e., pause? and (iv) resume a temporary stop, i.e., resume?. Its behavioural interface is defined as follows:

PDA1 is a PDA which can, among other possible actions, ask the music system to (i) play a chosen mp3 file, i.e., play!, (ii) stop playing, i.e., stop!, (iii) stop the player temporarily, i.e., pause! and (iv) resume a temporary stop, i.e., resume!. Its behavioural interface is:

To the best of our knowledge, the closer works to ours are dedicated to incremen- tal protocol enhancement. In [14] it is shown how to compose component wrappers to augment connector behaviour. In [15], the authors have revisited [14] providing approach automation. In [15], the starting point is a centralized adaptor that is always generated. Conversely to this, we try to solve mismatches by only producing local adaptors and we produce a centralized one only when it is unavoidable (e.g., Dining Philosophers problem).

