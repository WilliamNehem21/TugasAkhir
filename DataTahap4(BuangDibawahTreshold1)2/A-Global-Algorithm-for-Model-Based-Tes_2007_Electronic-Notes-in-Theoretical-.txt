Model-based testing has been proposed as a technique to automatically verify that a system conforms to its specification. A popular approach is to use a model-checker to produce a set of test cases by formulating the test generation problem as a reachability problem. To guide the selection of test cases, a coverage criterion is often used. A coverage criterion can be seen as a set of items to be covered, called coverage items. We propose an on-the-fly algorithm that generates a test suite that covers all feasible coverage items. The algorithm returns a set of traces that includes a path fulfilling each item, without including redundant paths. The reachability algorithm explores a state only if it might increase the total coverage. The decision is global in the sense that it does not only regard each individual local search branch in isolation, but the total coverage in all branches together. For simpler coverage criteria as location of edge coverage, this implies that each model state is never explored twice.

according to a test specification, and the responses of the system are checked to conform to its specification. To reduce the costs of this process, the execution of software testing is often automated, whereas the production of test suites are mostly done by hand. Techniques to automatically generate test suites, or to combine generation and execution, are emerging and getting more mature [31,9,28,19].

used in this paper, and review techniques for test case generation based on reach- ability analysis. In Section 3 we describe a reachability analysis algorithm for test case generation. In Section 4 we present a novel algorithm for test case generation that uses global information about the generated state-space to determine termi- nation and pruning. In Section 5 we describe the results of experiments comparing the different techniques. The paper ends with conclusions in Section 6.

In [19], Hong et al show how several flow-based coverage criteria can be expressed in temporal logic and how the test case generation problem can be solved by model- checking. Hong and Ural [17] continue this work and study how coverage items can subsume each other, and propose a solution to the problem. These works use an existing CTL model-checker to solve the test case generation problem, whereas we propose a specialized algorithm for test case generation.

Our work is also related to directed model-checking techniques, where state- space exploration is guided by the property to be checked. In [8], the authors use a bitstate hashing based iterated search refinement method to guide a model-checker to generate test cases. This method can be seen as a meta algorithm using an existing model-checker iteratively. Thus the actual model-checking algorithms is not refined for test case generation.

We will present ideas and algorithms for test case generation applicable to several automata based models, such as finite state machines, extended finite state machines (EFSM) as, e.g., SDL [20], or timed automata [1]. Throughout this paper, we shall present our results using the model of communicating EFSMs.

We will focus the presentation on generating test suites with a certain coverage in a CEFSM. Coverage criteria are often used by testing engineers to specify how thorough a test suite should test a system under test. Examples of coverage criteria used in model-based testing include structural criteria such as location or edge coverage, data-flow properties such as definition-use pair coverage, and semantic coverage on, e.g., states of an EFSM or the time regions of a timed automata [28,30]. A coverage criterion typically consists of a list of items to be covered or reached. We shall call those items coverage items, and use C to denote a set of coverage items, C0 the initial C, and |C| to denote the size of C.

The rows marked Train e 6 (0) show performance for the train gate model with the edge coverage criterion on the instances of the train automaton. There are six coverage items to be covered, with zero partial coverage items. The global algorithm generates 1645 states which is the size of the model. The local algorithm generates 3353 or 7375 states without and with resets, respectively.

For the rows Train du 12 (5) the definition-use criterion has been used. There are 12 different coverage criteria and five partial coverage items. The size of the generated state space of the global algorithm increases (due to the partial coverage items) modestly to 1717 (+4.3% compared with the actual size of the model state space). For the local algorithm this increase is from 3357 states to 27129 (or 114697 when resets are used). We note that the global algorithm performs substantially better than the local algorithms. In fact, it generates only 6% (or 2%) of the states used by the local algorithm(s). The gain in execution time is similar.

In this paper, we have studied algorithms and ideas for test suite generation ap- plicable to automata models with semantics defined as a (finite) transition system. We have reviewed algorithms derived from ordinary reachability analysis algorithm, similar to those used in many model-checking and planning tools. Such algorithms can be used to generate test suites that follow a given coverage criterion and are optimal in e.g, the total number of model transitions the test suite will exercise. We have further elaborated these algorithms by adopting existing abstraction and pruning techniques often used in model-checking algorithms.

All algorithms presented in this paper have been implemented in our test case generation tool Uppaal coCer. To compare and evaluate the algorithms, we have performed a number of experiments on a set of models previously described in the literature. In particular, the evaluation gives experimental evidence that the suggested global algorithm uses substantially less memory and time than local al- gorithms, and outputs test suites that are not far from optimal. In this respect,

