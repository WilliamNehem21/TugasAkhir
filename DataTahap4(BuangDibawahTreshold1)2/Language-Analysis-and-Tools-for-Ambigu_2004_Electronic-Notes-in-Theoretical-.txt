Automatically generated lexers and parsers for programming languages have a long history. Al- though they are well-suited for many languages, many widely-used generators, among them Flex and Bison, fail to handle input stream ambiguities that arise in embedded languages, in legacy languages, and in programming by voice. We have developed Blender, a combined lexer and parser generator that enables designers to describe many classes of embedded languages and to handle ambiguities in spoken input and in legacy languages. We have enhanced the incremental lexing and parsing algorithms in our Harmonia framework to analyze lexical, syntactic and semantic ambigu- ities. The combination of better language description and enhanced analysis provides a powerful platform on which to build the next generation of language analysis tools.

The methods described in this paper handle four kinds of input streams, three of which are ambiguous; our solutions are summarized in Section 3. Combinations of these ambiguities arise in different forms of embedded lan- guages. The handling of this fifth kind of input stream is presented in Sec- tions 4 to 7. Some of these ambiguities have also been addressed in related work, which is summarized in Section 8.

Multiple spellings; single lexical type. Programming by voice introduces potential ambiguities into programming that do not occur when programs are typed. If the user speaks a homophone which corresponds to multiple lexemes (for example, i and eye), and all the lexemes are of the same lexical type (the token IDENTIFIER), using one or the other homophone may change the meaning of the program. Multiple spellings of a single lexical type might also be used to model voice recognition errors or lexical misspellings of typed lexemes (e.g. the identifier counter occurring instead as conter).

to their structural and semantic properties. High-level transformation opera- tions can be created and maintained in the program representation. Harmonia furnishes the XEmacs [25] and Eclipse [4] programming editors with interac- tive, on-line services to be used by the end user during program composition, editing and navigation.

Support for each user language is provided by a plug-in module consisting of a lexical description, syntax description and semantic analysis definition. The framework maintains a versioned, annotated parse tree that retains all edits made by the user (or other tools) and all analyses that have ever been executed [21]. When the user makes a keyboard-based edit, the editor finds the lexemes (i.e., the terminal nodes of the tree) that have been modified and updates their text, temporarily invalidating the tree because the changes are unanalyzed. If the input was spoken, the words from the voice recognizer are turned into a new unanalyzed terminal node and added to the appropriate location in the parse tree. These changes make up the most recently edited version (a.k.a the last edited version). This version of the tree and the pre- edited version are used by an incremental lexer and parser to analyze and reconcile the changes in the tree.

Unambiguous lexing and parsing is the normal state of our analysis framework. Programming languages have mostly straightforward language descriptions, only incorporating bounded ambiguities when described using GLR. Thus, the typical process of the lexer and parser is as follows. The incremental parser identifies the location of the edited node in the last edited parse tree and invokes the incremental lexer. The incremental lexer looks at a previously computed lookback value (stored in each token) to identify how many tokens back in the input stream to start lexing due to the change in this token. 5 The characters of the starting token are fed to the Flex-based lexical analyzer one at a time until a regular expression is matched. The action associated with the regular expression creates a single, unambiguous token, which is returned to the parser to use as its lookahead symbol. In response to the parser asking for tokens, lexing continues until the next token would be a token that is already in the edited version of the syntax tree. (The details of the parser incrementality are not essential to this discussion and are omitted for brevity. Notice that additional information must be stored in each tree node to support incrementality).

A similar mechanism could be used for automated semantic error recovery. Identifiers can easily be misspelled by a user when typing on a keyboard. Compilers have long supported substituting similarly spelled (or phonetically similar) words for the incorrect identifier. In an incremental setting, where the

If the alternate spellings for a spoken word (as described above) have differ- ing lexical types (such as 4/for/fore), they are returned to the parser as individual tokens grouped in the same AmbigNode container described above. When the lexer/parser interface sees an AmbigNode, it forks the parser and lexer instance, and assigns one token to each lexer instance. The state of each lexer instance must be reset to the lexical state encountered after lexing its assigned alternative, since each spelling variant may traverse a different path through the lexer automaton. 6 Once each token is re-lexed, it is returned to its associated parser to be used as its lookahead token and shifted into the parse tree.

Using Blender, the outer and inner languages that constitute an embedded language can be specified by two completely independent language definitions, for example, one for PHP and another for XHTML, which are composed to produce the final language analysis tool. Embedded language descriptions may be arbitrarily nested and mutually recursive. It is the job of the language description writer to provide appropriate boundary descriptions.

One technique for identifying boundaries is to use a special program editor that understands the boundary tokens that divide the two languages (e.g., PHP embedded in XHTML) and enforces a high-level document/subdocument editing structure. The boundary tokens are fixed, and once inserted, can not be edited or removed without removing the entire subdocument. The two languages can then be analyzed independently.

Another technique is to use regular expression matching (or a simple lexer) to identify the boundary tokens in the document and use them as an indication to switch analysis services to or from the inner language. These services are usually limited to lexically based ones, such as syntax highlighting or imprecise indentation. More complex services based on syntax analysis cannot easily be used, since the regular expressions are not powerful enough to determine the boundary tokens accurately.

Lexical descriptions are written in a variant of the format used by Flex. The header contains a set of token declarations which are used to name the tokens that will be returned by the actions in this description. At the beginning of a rule is a regular expression (optionally preceded by a lexical condition state) that when matched creates a token of the desired type(s) and returns it to the parser.

Grammar descriptions are written in a variant of the Bison format. Each grammar consists of a header containing precedence and associativity decla- rations, followed by a set of grammar productions. To support descriptional modularity, one or more %import-token declarations are written to specify which lexical descriptions to load (of which one is specified as the default) in order to find tokens to use in this grammar. In addition to importing to- kens, a grammar may import nonterminals from another grammar using the

In Blender, boundary tokens for an inner language are specified with the outer language, so that the outer analyzer can detect the boundaries. The data for the inner language is written in a different specification, named comment- lang, which is imported into the Java grammar. In this simple case, the embedding is lexical. Comment boundary tokens are described by regular expressions that detect the tokens /* and */. They are placed in the main Java lexical description (the one that describes keywords, identifiers and literals).

A Flex rule consists of a regular expression followed by an optionally- braced C compound statement. The regular expression is denoted by the regexp root nonterminal from the regexp grammar. The symbol WSPC de- notes a white-space character. The compound statement is denoted by the compound stmt from the C grammar.

When a Blender language description incorporates grammars for more than one language, the grammars are merged. 9 Each grammar symbol is tagged with its language name to ensure its uniqueness. Parser generation proceeds normally as for a GLR parser generator (i.e. LALR(1) with GLR conflict resolution).

Next, if each parser has its own private lexer instance, and each lexer instance is in a different lexical state when reading the input stream, then the input streams may diverge at their token boundaries, with some streams producing fewer tokens, some producing more. This may cause each parser to be at a different position in the input stream than the others, which is a departure from the traditional GLR parsing algorithm in which all parsers are kept in sync shifting the same lookahead token during each major iteration. Unless we are careful, this could have serious repercussions on the ability of parsers to merge, as well as performance implications if one parser were forced to repeat the work of another.

We introduce a new data structure, a map from a lookahead token to the parsers with that lookahead. The map is initialized to empty in GLR- PARSE(), and is filled with each parser in the active-parsers list after each looka- head has been lexed in PARSE-NEXT-SYMBOL(). Any new parsers created during DO-REDUCTIONS() are added to the map. In DO-REDUCTIONS(), when a parser

In principle, both incrementality and the extensions described in this paper could be added to scannerless GLR parsers. However, as always, the devil is in the details. In an incremental setting, parse tree nodes have significant size because they contain data to maintain incremental state. If the number of nodes increases, even by a linear factor, performance can be affected. More significantly, incremental performance is based on the fact that the potentially changed region of the tree can be both determined and limited prior to parsing by the set of changed tokens reported from the lexer. For example, only a trivial amount of reparsing is needed if the spelling of an identifier changes, since the change does not cross a node boundary. Although we have not done a detailed analysis, our intuition is that without a lexer, the potentially changed regions that would end up being re-analyzed for each change would be considerably larger.

New techniques being developed in our research group for batch GLR parser error recovery do not yet take into account the ambiguities discussed in this paper. Extension of the work above to incorporate batch error recovery is ongoing. (Incremental error recovery is change-based and is more easily ex- tended.)

