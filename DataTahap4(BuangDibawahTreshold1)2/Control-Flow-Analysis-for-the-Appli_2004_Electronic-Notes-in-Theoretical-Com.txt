Accordingly to the intuitive semantics, in the first example A1, fst(x) at run- time evaluates to a name (n2). The second example A2 shows a process that creates a new name (n2), signs it with a private key pri(n1) and sends it. Another process receives it, checks the signature and uses n2. Note that for A2 to work, the term check(sign(n2, pri(n1)), pub(n1)) should evaluate to ok and removesign(sign(n2, pri(n1))) should evaluate to n2.

Although we decided not to use General-Subst, we cannot simply discard it. While we do not want to introduce new variables (via General-Subst applied left-to-right), we should permit the elimination of variables and the applica- tion of substitution processes to adjacent processes (via General-Subst applied right-to-left). To this purpose, we introduce the following reduction relation.

There is no rule for 0 since it cannot do any action. Moreover, we note that a conditional is executed only when the terms are ground and otherwise it behaves as 0. Inputs and outputs also behave as 0 unless the subject is a name (or is reduced via >> to a name).

In this section we show the correctness the CFA of Section 4 with respect to the formal semantics of Section 3 by proving a subject reduction result. Most proofs are by structural induction or rule induction, and are quite straightfor- ward. In the case, we simply sketch the proof.

In this scenario, two participants (A and B) share a long term symmetric key with a trusted server (S): the key KAS is known only to A and S, while the key KBS is known only to B and S. The participant A generates a new key KAB and wants to share it with B. To perform it in a secure way, A sends the new key to S, encrypting it with the key that shares with the server. The server S simply decrypts it and encrypts it again, this time using KBS; then it sends it to B. Principal B receives the key from the server and an encrypted term M from A: now the continuation B' can decrypt the key from the server and then decrypt M .

