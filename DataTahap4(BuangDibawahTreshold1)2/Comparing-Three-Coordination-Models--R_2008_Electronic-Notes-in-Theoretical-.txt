comparing coordination models. In this paper, we compare and contrast three co- ordination models: Reo [4], Actors-Roles-Coordinators (ARC) [20], and Reflective Russian Dolls (RRD) [17]. These three models cover a wide spectrum of communi- cation mechanisms and coordination strategies and serve as a good sample set for our study. Other models to consider in future comparison studies include: Linda

[13] and its mobile extension, Lime [19], Klaim[18] and its stochastic extension [11]. Reo is a channel-based exogenous coordination model for component composi- tion. In Reo, complex connectors are compositionally built out of simpler ones. The simplest connectors are channels with well-defined behaviors. These connectors are

nectors, and the coordination and communication patterns which they impose on the components, but not on the components which are the coordinatees. Composi- tional semantics of Reo circuits can be given by Timed Data Streams (TDS) [8] and by constraint automata [9]. Constraint automata can also be used for analyzing and model checking Reo systems.

ARC uses the separation of concern principle to partition coordination into two disjoint categories, i.e., intra-role and inter-role coordination, and uses roles and coordinators, respectively, to abstract these behaviors. The coordinatees in the ARC model are actors, entities that interact by asynchronous message exchange. Coordination is through message time-space manipulations which are transparent to the coordinatees. Reasoning in the ARC system is based on message dispatches in time (when) and space (to whom).

The remainder of the paper is organized as follows. In Section 2, we spell out the features to be compared and contrasted. Section 3 describes the three models and compares them according to the listed features. Section 4 describes representations in the three models of a simple coordination task. In Section 5 we make a step towards a common semantic foundation for the three models. Conclusions and future work are discussed in Section 6.

Semantic model. How is the semantics of components and/or coordinators specified? An operational semantics could be given as a state transition system, such as automata or rewrite systems. Denotational semantics might be expressed in terms of observable events, traces/streams, or signals.

Reo is an exogenous coordination language based on a calculus of channel composi- tion. A channel is an abstract communication medium with exactly two ends and a constraint that relates the flow of data at its ends. A channel represents a primitive interaction (protocol), explicitly represented as a binary constraint. There are two types of channel ends, source-end where data enters into the channel, and sink-end where data leaves the channel. A channel can have two sources, two sinks, or a source and a sink. The channel relation can be defined by users which allows an open-ended set of different channel types, each with its own policy for synchroniza-

Computation model. Reo is a channel based language. Channels may be ei- ther synchronous or asynchronous. A channel is called synchronous if the pairs of operations on its two ends can only succeed atomically; otherwise it is called asyn- chronous. There is no shared global memory. Both ARC and RRD are based on the actor model of computation [1,16,2] with the coordinated objects being actors and the coordinators being meta-actors. Actors encapsulate their state and thread of control and communicate by asynchronous message passing. Meta-actors control the communication semantics of their base level actors.

Control. Coordination is imposed by a Reo circuit on connected components by determining when data can be accepted on input ports and when it can be taken from output ports, blocking components attempting write or read until the operation is available. The decision to connect to a port is made by the coordinatee, but once connected the coordinatee has no control over how the data is routed.

In the ARC model, role meta-actors intercept and control the delivery of base level messages. Formally, each base level action generates events that must be handled by the appropriate role before further base-level computation can take place. Role and coordinator meta-actors also communicate by events. The base- level actors have no active role in the coordination. However, roles are aware of the higher level coordinator and participate actively in their coordination. A novel aspect is that individual actors in a role are transparent to the coordinator layer. In the RRD model, coordination is exogenous at all levels. At each level, lower-level objects execute as if there were no coordination layer.

The coordinatees have been replaced by message queue attributes representing their interfaces: up-a corresponds to the output queue of the assembler, a, dn-a corre- sponds to its input queue. Similarly for other up/dn attributes. In addition the co- ordinator exposes interfaces in-a for input to the assembler, and out-x for replies to external actors. A PBRD policy state consists of a queue of messages,pending, and a wheel actor queue, wQ. There are rules that unconditionally read messages from the input in-a and up interface queues and place them in pending (tagged with the interface name). There are five rewrite rules for the policy, FactoryPolicy.

Each of the models is clearly highly expressive. The Reo model is more mature, with several formal semantics and tools for analysis. Reo is closer to being a program- ming model, while RRD focuses on more abstract specifications. The ARC model

is aimed at coordination of resource usage and QoS goals while RRD has focused on logical communication constraints, as has much of the Reo work. All three models provide for user definable coordination behavior, but in different ways: channel be- havior (Reo), coordinator events (ARC), coordinator rewrite rules (RRD). Although channels and messages seem very different operationally, denotationally they have similar semantics.

There are a number of topics for future work. Preliminary work indicates that Reo specifications as CA can be used as a policy language for PBRD and that ARC can be embedded fairly naturally into RRD. These mappings need to be worked out in detail. The full generality of rewriting logic and RRD make it difficult to give simple mappings from RRD to Reo or ARC. Logics for specification and reasoning about coordination are of great interest. Do the logics developed for Reo work more generally? Are new logics needed to express end-to-end properties emerging from coordination? An important topic is developing methods to combine coordination rules for different concerns: communication constraints, timing, resource usage, etc., and to assure safe composition.

