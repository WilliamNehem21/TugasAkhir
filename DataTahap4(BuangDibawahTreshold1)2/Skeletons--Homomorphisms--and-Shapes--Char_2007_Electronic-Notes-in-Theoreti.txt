In this paper we develop a framework, based on strand spaces, for reasoning about cryptographic protocols and characterizing their executions. We define skeletons, homomorphisms, and shapes. Skeletons model partial information about regular (honest) behavior in an execution of a cryptographic protocol. A homo- morphism between skeletons is an information-preserving map. Much protocol analysis may be regarded as an exploration of the properties of the category of skeletons and homomorphisms. A set of skeletons can characterize all runs of the protocol; the smallest such set is the set of shapes. This approach is a foundation for mechanizing protocol analysis.

Instead of checking each security property individually, we characterize all pro- tocol executions compatible with the initial assumptions. The resulting charac- terization is a set of protocol runs that is representative of all possible protocol runs. These representatives are the minimal, essentially different executions of the protocol. Some advantages of this approach are:

In this paper, we will present a framework, based on strand spaces, for analyzing protocols and characterizing their executions. While a generalized notion of our characterizations can capture both authentication and secrecy properties, we focus here on a simpler notion that captures authentication properties exclusively. We will discuss the applicability to secrecy elsewhere. In practice, any algorithm for constructing characterizations must reason about both secrecy and authentication. As motivation for this framework, consider a protocol analyst presented with some initial assumptions about a protocol run. Often this is the experience of a single participant and some secrecy and freshness assumptions. The analyst can then repeatedly apply inference rules such as the authentication tests [4] in order

At any point in the analysis, the analyst possesses partial information about the structure of possible protocol runs. We will represent this partial information in structures we will call skeletons. We will also define a notion of homomorphism between skeletons; homomorphisms are information-preserving maps. Thus, much of protocol analysis can be expressed in terms of skeletons and homomorphisms between them.

We discuss the actual algorithms used to construct these characterizations in [2]. In the present paper, we define the underlying framework for the algorithms. Given a set of initial assumptions (an initial skeleton), we will define how a set of protocol runs can characterize all possible runs. Furthermore, we will show that there is a minimum such characterization: the set of shapes. They are the minimal, essentially different executions possible for the protocol.

In the ensuing discussion we will use the term regular strand to refer to a run of some role of the protocol. Likewise we will use regular node to refer to a send or receive event occuring on a regular strand. We also use regular behavior to refer to all regular nodes in a particular run of the protocol as well as their causal ordering. We will also use the notation term(n) to refer to the message sent or received on node n.

Terms in A are freely built from atoms using concatenation and encryption. The concatenation of t0 and t1 is written t0, t1. Encryption takes a term t and an atomic key K, and yields a term written as {|t|}K . Instead of general substitutions, we use Replacements for simplicity. Replacements have only atoms in their range:

We saw that the ISO reject protocol has two shapes, one corresponding to the intended run and another corresponding to the attack. The Needham-Schoeder- Lowe [7,6] protocol has only one shape, corresponding to the intended run. This holds for NSL whether we take the point of view of a responder B, asking what global behavior must have occurred if B has had a local run of the protocol, or whether we start from a local run of an originator A. In either case, the other party must have had a matching run. A, however, can never be sure that the last message it sends was received by B, as A is no longer expecting to receive any further messages. Uniqueness of shape is perhaps not surprising for as strong a protocol as Needham-Schroeder-Lowe.

Due to the existence of an infinite set of homomorphisms realizing any preskeleton A, it is useful to find a small subset of those that characterizes all the runs. The notion of characterization is catered to an intuitive understanding of what it means for a protocol run to be an extension of another protocol run. Here we capture one notion of extension that we have, in our experience, found to be the most natural and useful.

Clearly the set of all realizing homomorphisms for A is a characterization for A. However, we seek a characterization as small as possible: a minimal characteriza- tion, under some criterion of size (number of nodes, total size of messages... etc). We will show later that there is a single characterization that is a unique minimum for all these definitions of size simultaneously.

In cases where the set of shapes is finite, the shapes for a preskeleton A form a succint representation of all protocol runs compatible with A. In most protocols we have studied, we have found experimentally that any starting preskeleton yields a finite set of shapes. However, it would be useful to identify a subclass of protocols for which this is guaranteed. We expect that a subclass of protocols similar to those defined in [1] and [8] has this property.

tree of preskeletons with the shapes at the leaves. These shapes are annotated with secrecy information. The algorithm reasons about secrecy by trying to construct a shape that discloses a value. Further analysis of the properties of this algorithm will be the subject of future work.

