semantics where each concurrently enabled transition must be considered sep- arately in any given state. Several techniques exist to address aspects of the state explosion problem. Symmetry and partial order reduction exploit struc- ture and concurrency to reduce the number of states in the reachable state space that must be explored to complete the model checking problem [3][6]. Bit state hashing (supertrace) and hash compaction reduce the cost of storage states in the reachable state space [7][13]. All of these techniques enable the verification of larger problems, but in the end, are restricted to the number of states that can be stored on a single workstation. If the model checking algorithm exhausts resources on the workstation it is running on before com- pletion of the verification problem, then the problem must be altered in some way to reduce the size of its reachable state space until it can fit into the available resources.

This paper presents an empirical study of the seminal static partition al- gorithm showing the level of load imbalance, regardless of the chosen static partition, that exists between the processes on different supercomputing plat- forms. The imbalance results in high idle times in several processors, as well as extremely large search queues. The high idle times indicate that many pro- cessors are not contributing to state enumeration, and the large search queues lead to premature termination by exhausting memory resources. Furthermore, the imbalance in the partition slows down error discovery since states leading to errors can be buried deep in the search queues. The paper further presents a load balancing algorithm based on generalized dimensional exchange(GDE) to mitigate idle time at the expense of additional communication overhead. Load balancing the state partition algorithm improves speedup in distributed model checking despite the increased communication. In addition, it reduces

A major part of the testing is performed using the models located at the model database in [1]. These models have been selected because they provide a large, controllable, interesting and diverse set for testing. The selected models are not representative of all types of problems, but they effectively capture our general observations in studying the several problems.

This section will first analyze the static partition algorithm and present the problems encountered when using it. After the analysis, we discuss two ex- isting techniques to solve these problems. Our results indicate that these techniques are not very effective on the models and benchmarks used by us.

A technique to improve performance of distributed model checking is the use of state caching to reduce the number of messages and hash lookups. Previous work regarding state caching, to improve performance has been presented in [11][4]. Our analysis indicates the presence of duplicate states in the same message or in different messages being sent to other processors. This is due to the fact that many states in the state space of the model can be reached by different paths and from different states. To avoid this, a block of memory is allocated on each processor to function as a direct mapped state cache. Only states not present in the cache are forwarded to their owning processors.

algorithm. A clear example of a model containing an inconspicuous error is the queens8 problem. The queens8 problem involves placing 8 queens on a chess board in such a manner that no queen is threatening any other queen. The error state is successfully placing all the queens in the described manner. The static partition algorithm performs well compared to the serial algorithm, but the GDE load balanced algorithm outperforms both algorithms. Even in other models we can see that the load balanced algorithm outperforms the static partition algorithm by a significant factor with the worst case scenario of performing only slightly better than the static partition algorithm.

Using load balancing techniques such as GDE, we have successfully bal- anced the queues on all processors and reduced the time to verify models in our benchmark suite. Due to the non-deterministic nature of the GDE load balancing algorithm, we have also changed the search order to the degree where error states in our models can be discovered earlier and by exploring a fewer number of states. Using the GDE load balancing algorithm we have also shown that maximum queue sizes have been decreased by an order of magnitude compared to the maximum queue sizes obtained in the static par- tition algorithm for the models and benchmark suite used by us. We have also shown that the communication overhead does not counteract the usefulness of GDE load balancing when using a state cache.

Future work in this research area would involve creating load balancing schemes that are completely independent of any user input regarding the fre- quency of load balancing. Processors should be capable of avoiding situations where there is no useful work to do. A more detailed study of the GDE scheme with respect to the amount of load balancing done between a pair of proces- sors is also important. Other dynamic load balancing schemes also provide an interesting field of further research too.

