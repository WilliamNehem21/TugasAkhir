Object-oriented programming languages offer a significant means to create software in a modular way. The mechanisms of inheritance and encapsulation allow program modules to provide sufficient information for others to make use of them, meanwhile hiding implementation details. This characteristic is excellent for code reuse and management, but it also calls for new formal approaches to reasoning about and verifying these OO programs.

The remainder of this paper is organized as follows. Next section sets up the syntax of the C++ -like language used throughout this paper, and its semantics of class inheritance and method overriding in a syntactical way. Then the separation logic for this language is introduced, with the storage model expressing the program states, the assertion language and its semantics, and the verification rules. After that our approach of forcing behavioral subtyping is brought out, followed by an example to illustrate this model for multiple inheritance verification, and the last section summarizes the paper with related and future works.

To keep the formalism simple, we leave out other C++ features that are of less interest. Since separation logic is mainly about the aliases and mutation of pointers to heap, all the variables in this core are assumed to be pointers. Arithmetic expressions and some other language constructs are also omitted. These features are to be added to our concern step by step in our future works towards practical implementation of this system.

At last are some conventions for the remainder of the paper. To traverse the class names, we use C and D with proper subscripts. For class fields and methods, f and m are used respectively. For general variables x (and sometimes y) is used. And for any tuple a, we denote a.i as the i-th component of a.

to promote dynamic polymorphism. However, it can also cause ambiguity when we refer to some fields of an object. For this issue we take the former inheritance class C : C1,..., Cn and an object x typed C to describe the following cases:

As is introduced, separation logic is about the reasoning of aliases and shared muta- ble objects. Because both such aliases and sharing occur on the heap, it is necessary to include the heap in our storage model, which is different from classical Hoare logic where variables are accessed based on the stack. Meanwhile stack is still needed in our model, since the heap can be modeled as a mapping from an address to a value, in which the address should be accessed via the stack. Our storage model, given as follows, is based on the standard model for separation logic.

The auxiliary variables compose a significant part of the program state. Though they are not a real part of the storage, they can be useful as assistance to describe program states and specifications. Hence they are also involved in the storage model. These variables do not have fixed types and are supposed to capture any appropriate value from both the stack and the heap.

Note that our model of heap is slightly different from the classical separation logic, where heap is modeled as a mapping from locations (a subset of integers or values) to values, i.e. Heap =df Loc ~ Value+. The reason for us to diverge from

containing the field (but not the type of the field itself). This design is to facilitate multiple inheritance, since a class may inherit many fields with the same name from its ancestor classes, which form a lattice in lieu of a chain; hence both the name of the field and the actual class containing it are needed when accessing that field. The values mapped to by f are undefined for such pairs not contained in this object.

It is worth noting here that we do not have the assertion emp in standard separation logic to express empty heap. Instead, the assertion x = null is used to express that no part of the heap is allocated for the variable x and thus it points to a reserved area null. This assertion not only depicts empty heap but also specifies the variable owning no corresponding allocated heap, which is more accurate without the presence of dangling pointers.

The two rules of assignment take use of auxiliary variable X instead of the tradi- tional assignment rule using substitution in assertions. The auxiliary variable in- troduced can be eliminated later in a proof. Note that an assignment also changes the heap location that a variable points to.

This rule first ensures that this method is defined in the right class C. After that the method body is checked to agree with the specification {P} s {Q[x/ret]}. Then the specification is added to the statical environment to support potential method invocation, which is depicted in the following rule.

{PC} s {QC}, namely, a proof of the latter with the only premise of the former, then the latter is defined as compatible with the former. The aim of behavioral subtyping is to ensure that each overriding method C.m(x) has a specification com- patible with its counterpart in the superclass, D.m(x).

Ideally Task and Display are disjoint because they share no similarity. However, a computer terminal, whose class is denoted Terminal, can act both as a task node and a monitor device. Thus the best way is to make Terminal inherit both Task and Display. In the following example we omit the definition of Switch, Line and other indifferent methods in our view for the space limit. For more detailed background of these examples, the bibliography is recommended.

This paper brings out an extension of the separation logic for the reasoning of object-oriented programs with multiple inheritance. It has condensed the syntax of C++ to a core and set up a storage model for it based on the canonical separation logic. The verification rules are proposed according to this model, and behavioral subtyping is considered for the sake of runtime type decision. Finally an example is utilized to illustrate this whole approach.

for the verification of object-oriented programs. Another former attempt to intro- duce separation logic into the field of OO verification belongs to Parkinson [11]. In that work he found good means (abstract predicate family) to depict methods spec- ifications and to rebuild the logic for Java program reasoning. We intend to follow his route to construct another extension of separation logic for a more general case of class inheritance. In our case the chains of inheritance might have intersections, which are different from single inheritance in both syntax and semantics.

Another important future work is to give an implementation of this extension of separation logic. Before this more features of C++ must be added to the language, such as stack variables for basic data types, arithmetic operations and access con- trol. Then the model and the rules should be combined to some (semi-) automatic reasoners for implementation.

