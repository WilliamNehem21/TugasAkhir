While these models and tools are useful for teaching and learn- ing programming, there is continuous need to create more tools for supporting novices, targeting specific programming constructs. Studies have shown that practice improves programming ability [17]. We also know that constructs such as nested loops are often difficult to comprehend for novices [3,18]; hence, the problem addressed in this paper is the synthesis of nested loop exercises. The synthesised exercises can be manually solved with pen and paper as a practical support for novice programmers. To do this, we have designed a context-free grammar (CFG) for the formalisa- tion of specific syntactic patterns for nested loop exercises. We have also designed algorithms that makes use of the CFG rules in rendering valid nested loop exercises. These rules and the resulting exercises are targeted for Python programming language, as this is one of the most used languages in introductory programming around the world today [19].

The remainder of this paper is organised as follows. Section 2 pre- sents background information and Section 3 discusses related Works. Section 4 presents grammar design for the synthesis of nested loops and Section 5 explains the algorithms for loop synthe- sis. Section 6 describes the implementation and results, and Sec- tion 7 presents evaluation. Section 8 presents the conclusion and future work.

In this section, we discuss the difficulties faced by novices in learning how to write computer programs. We starting with gen- eral difficulties to specific ones around the comprehension of nested loop structures. We further discussed the importance of loops and highlighted the motivation behind this work.

Students often struggle with the practical understanding of loops in introductory programming modules [3,18]. They find it difficult to understand the process of program iteration [26]. Some of the difficulties with loops faced by novice programmers include: misconception of loop construct and loop execution, and difficul- ties in solving problems with the use of a loop constructs [3]. When loops are nested, it becomes more difficult for novice programmers to understand [26].

This work is motivated by these challenges and needs in learning programming. We have devised a formal technique (based on a CFG) for synthesising exercises of nested loop problems that novice programmers can use as practical problems. In the next section, we present research works that are related to this study.

Context-free grammars (or CFGs) are a class of formal lan- guages that can be used to, formally, specify Context-free Lan- guages (CFLs). The formal definition of CFGs is presented in Section 4.1. We have used CFGs as a medium of expressing the rules for formulating new problems in nested loops, for the fol- lowing reasons:

Formal Languages and Automata Theory (FLAT) is a well known aspect of Theoretical Computer Science. This aspect has also been known to have many mathematical or computational the- ories with little or no real life applications. However, adopting an aspect of FLAT (CFGs) in this work shows that FLAT can find new applications in topics like procedural content generation, and computer science education.

The syntactic definitions of programming language recognisers and parsers are done with CFGs. This is preferred over Regular Languages (or RLs) because it handles more complex structures such as the language of balanced parenthesis. The use of CFGs in parsing programming languages is not new, and like any other formal language, they can be used for both recognition and gen- eration tasks [35]. The application of CFGs for recognition can be found in compiler constructions, and its applications in gen- eration can be found in Ade-Ibijola [1].

Artefacts Gulwani [36] synthesised a range of objects with inter- face models and algorithmic methods for repetitive drawings and mathematical concepts (such as algebraic identities, bit vector algorithms, compass based geom- etry constructions, etc.). Ade-Ibijola [37] proposed an algorithm for the automatic generation of hypothetical social network graphs that were graphically rendered using the Microsoft Automatic Graph Layout API. This algorithm produced random hypothetical names as ver- tices, and random directed edges connections between them. Sunbeom and Hakjoo [38] developed a tool for the generation of different patterns of characters through synthesis of pattern program. The algorithm synthesised the desired program through the integra- tion of enumerative search, constraint response, and program exploration. Another work by Ade-Ibijola

Some of the terms used in this section include: symbol, alphabet, string, and context-free grammar (or CFG). We define these terms as follows. A symbol is an item or single token; an alphabet is a finite set of symbols; strings consist of a concatenation of zero or more symbols (when it is zero, its called an empty string, represented as k), and grammar (G) is a formal way of representing rules describing the syntax of a language [45].

able initialisation (this is done with a function presented in Algo- rithm 1). Rules 5 and 6 describe statement blocks. In Rule 5, variables are initialised first, and these variables are used in arith- metic expressions or as an alternative, logical expressions are gen- erated with Boolean variable initialised in Rule 4. Rule 6 allows for an optional statement block to be generated. This is later used in building nested loop programs that may or may not have statement blocks in specific parts of the source code. Rule 7 enumerates the types of loops covered, and this is passed to Rule 8 for the synthesis of an actual loop instance using the function GetLoopStatement (), defined in Algorithm 2. To maintain the structure of a nested loop, the newline and tab characters are combined in Rule 9 to man- age indentation of code.

At this stage, a question that comes to mind is: what if we want more than two sub-loops? Or, what if we want to define these rules such that it allows infinitely many sub-loops to be derivable from the start symbol? Hence, it becomes compelling to define the sub- loops recursively. Rules for this is presented in Section 4.4.

In this section, we present an algorithm (Algorithm 1) for the generation of loop types defined earlier in Rule 7. Algorithm 2 describes the GetLoopStatement() function used to perform the operation defined in Production 8. This algorithm takes five parameters described on Line 1 and returns a loop statement. One Line 2, a syntactic end of line character in python is initialised, and the loop string is set to null on Line 3. The switch statement that begins on Line 4 allows for a selection of loop type. Loops

Algorithm 3 traces the steps of derivation of the grammar, G. This algorithm takes the number of loops to be derived as a param- eter and returns a list of these loops. At each step, it attempts to replace all nonterminals in the grammar rules with terminal pro- ductions or symbols. Line 10 adds the final string derived from G to a list of nested loop strings. This list is returned on Line 13.

Here we present the implementation details of these algorithms and showcase the results from these implementation. We imple- mented all the rules and algorithms with Python. This program was tested severally, and 120,000 iterations of valid nested loop programs that were synthesised from this program can be viewed at: https://tinyurl.com/nestedloops2021.

The survey included 210 university undergraduates, both first- year students (87.7%) and returning or old students (13.3%). The sample population consists of male and female students of Com- puter Science and other relevant courses who are taking the intro- ductory programming course for the first time and those who have previously taken it. This audience is appropriate for the study since the goal of the research is to aid novices in overcoming challenges in program comprehension.

It tested student perceptions of the use of looping statements in programming. 76.2% believed that it is difficult to use looping statements in programming, 11.9% found it easy to use and 11.9% were indifferent. This suggests that the majority of novice

The findings show that a large proportion of the students involved in this survey are at the early stage of learning programming including those who are currently doing the course and those who did it before. Computer Programming courses have been shown to be difficult for the majority of students to learn, particu- larly the use of loops, suggesting that students need the support of learning aids. This result compare well with the reports of [3,26] which indicated that students struggle to understand nested loops at early stage of programming. The synthesised nested loop exer- cises were correctly formulated and are solvable with pen and

paper, indicating that the tool was well-designed to achieve the purpose of the study. By practicing the generated exercises, novice programmers can learn more about the use of loop statements in programs, making it easier for them to improve their programming skills in Python. This finding agrees with the suggestion of [17] that practice improves programming ability.

