These practical problems provide the context of our theoretical work. This work can be broken down into two steps. In the first step, semantic and algorithmic machinery needs to be developed for verifying in a partial view global properties expressed using predicate and function symbols that the partial view may have no knowledge of. In the second step, semantic and algorithmic machinery needs to be developed to enable reasoning over multiple viewpoints. Although global property verification is done at each partial view, various forms of communication between some of the partial views should provide the means for a more integrated global check of system properties. In this paper we undertake the first step only; the second step will be tackled in future work.

[2], this three-valued semantics is decomposed into two semantics whose con- sensus (the union of the Smyth powerdomain) recovers the original semantics. This consensus, together with a translation of formulas into negation normal form,is used to reduce our three-valued semantics to two standard semantics of first-order logic. Thus, three-valued model checking of global properties in a partial model can be reduced to two-valued model checking of standard models of first-order logic.

In Section 2, we define partial models that have only limited access to a global signature. Section 3 uses these models to interpret global terms and formulas. This is done from first principles by applying the Smyth power- domain to the set of semantic elements (for terms) and to the discrete set of ordinary truth values {T, F} (for formulas). A refinement preorder of par- tial models is proposed in Section 4 and proved to be sound, provided that the set of semantic elements remains the same. In Section 5, we decompose our semantics into two semantics whose consensus (the union of the Smyth powerdomain) recovers the original semantics. Section 6 uses this consensus, together with a translation of formulas into negation normal form, to reduce our three-valued semantics to two standard semantics of first-order logic. In Section 7,we describe related work and Section 8 concludes.

One partial view can be a refinement of another partial view. Intuitively,this means that the refining view encodes more precise knowledge of a software system without contradicting the knowledge of the refined view. We say that a semantics of partial views is sound with respect to refinement if it supports this property of the refinement relation. In Definition 4.1 we formalize the idea that the refining view encodes more precise knowledge of the software system in question. In Proposition 4.5 below we show that the refining view does not contradict the knowledge of the refined view if the domains of se- mantic elements of the two views are the same and, thus, establish that our semantics is sound with respect to the refinement relation under the specified circumstances.

In [2], G. Bruns and P. Godefroid develop a three-valued version of model- checking models of computation tree logic (CTL). The models are similar to conventional Kripke structures,except that state propositions can take on val- ues T, F,or U. They have a notion of refinement and show that their temporal logic semantics is sound and complete with respect to this refinement. With each three-valued model they associate two Kripke structures, an optimistic and a pessimistic one, allowing them to implement their three-valued model- checking problem as two two-valued model-checking problems for CTL (over Kripke structures). In [3], this work is being extended to generalized model checking (GMC), improving the precision (and increasing the complexity) of their initial semantics,and implementing GMC via (finite-state) automata on infinite words. 12

(= overspecification) of multiple specification components and their interac- tion through the checking of invariants. Second,one can refute properties (= underspecification) by computing a counterexample to an assert statement. Since the full language (first-order relational logic with a transitive closure operator) is undecidable, both modes run in a user-specified scope, the max- imal size of primitive types. This approach is partial in that the inability of generating a counterexample within a given scope means that the status of inconsistency and property refutation is unknown (respectively).

S. Guerra [10] develops a framework for specifications of software artifacts, where such specifications have defaults and allow for exceptions stemming from the reuse or evolution of system demands. This framework is cast in the machinery of institutions [9]. Specifications are written in linear-time temporal logic [26] and a non-monotonic semantics for this logic is defined based on default institutions. A distance between interpretation morphisms induces a preferential preorder between models that is used to define that semantics. The signature is split into observable actions (where the distance enforces consistency across models) and attributes (where the distance checks for consistency across models).

