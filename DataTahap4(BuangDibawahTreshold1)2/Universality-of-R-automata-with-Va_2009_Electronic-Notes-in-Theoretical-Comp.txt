R-automata are finite state machines extended with counters which can be incremented or reset to zero along the transitions. The universality question asks whether there is a constant D such that all words are accepted by some run along which no counter exceeds D. It has been shown in [2] that this question is decidable. In this paper, we add one more operation to R-automata, namely the operation which can copy the value of a counter into another one. The result of this paper is a reduction of the universality problem for R-automata with value copying to universality of R-automata, thus rendering the problem decidable. The reduction replaces copy operations by non-deterministic resets together with a mechanism ensuring that the number of such replacements is bounded between each two resets of a value.

Finite state machines usually serve as word acceptors, where the accepting condition is expressed in terms of the last reached state. For the acceptance of a word, it does not matter what has happened along the run, as long as we end up in an accepting state. One can also introduce a notion of the cost into finite automata by setting a price on each transition. The cost of a run is then the sum of the costs of the transitions. The cost of a word is the minimum of the costs of all accepting runs for this word. One way of bringing this concept into the automata model is to introduce counters which accumulate the cost along the runs.

Questions asked for these automata are concerned with the existence of bounds on the costs (i.e., counter values). The limitedness problem is to decide whether there is a bound such that all accepted words are accepted by a run along which no counter exceeds this bound. The universality problem is a special case of the limitedness problem, i.e., the question whether there is a bound such that all words are accepted by a run along which no counter exceeds this bound. This problem has been shown decidable for R-automata in [2] using the factorization forest theorem [12]. Here we show the decidability of the universality problem for R-automata with value copying by reducing it to the universality problem of R-automata (without copying).

The main idea of the reduction is to replace the copy instructions by resetting and swapping the counter values. We reset the counter into which a value should be copied and then we non-deterministically choose whether we swap the values of the involved counters. This allows us to choose in which of these two counters we keep the value accumulated so far. There is a mechanism which ensures that the number of such resets along the lifetime of each value, i.e., from the beginning (a reset) of a value until its end (the next reset or overwrite by a copy), is bounded by the number of the counters. By this, we can decrease the cost of each word only by a constant ratio.

Related work. Different proofs of the decidability of the limitedness problem for distance automata are reported in [7,11,13]. The last of these results [13] is based on the factorization forest theorem [12,5].Distance automata were extended in [8,9] with additional counters which can be reset following a hierarchical discipline resem- bling parity acceptance conditions. R-automata form a superclass of this extension. Universality of a similar type of automata for tree languages is studied in [4]. B- automata [3] contain counters which can be incremented and reset in the same way as in R-automata, but they accept infinite words such that the counters are bounded along an infinite accepting computation. The main result is that B-automata can be complemented.

ing RC-automaton. Observe that the LTS contains infinitely many states, but the counter values do not influence the computations, since they are not tested any- where. In fact, for any RC-automaton A, A) is bisimilar to A considered as a finite automaton (without counters and effects).

In order to avoid unnecessary technical complications in the main part of the proof, we restrict ourselves to RC-automata with at most one copy operation in each effect. We show how to extend the proof to the general model at the end of this section. We reduce the universality problem for (restricted) RC-automata to the universality problem of R-automata, for which it has been shown that this problem is decidable [2].

Intuitively, the choice of a counter in the copy instruction tells that the value in this counter will be destroyed by a reset or overwritten by a copy instruction later than in the counter which was not chosen. The structure of the copies is captured by the parent pointers in the following sense. If the counter i points to the counter j then i contains an immediate copy of j (but possibly modified by increments) and its value will be destroyed earlier than the value in j. The automaton ends in the error sink if it witnesses a violation of some of these implicit claims, i.e., the value in the counter i is destroyed earlier than the value in the counter j.

First, we formalize the concept of the evolution of a value and define the corre- sponding runs. Then we show existence of corresponding accepting runs. Later on we use the fact that the parent pointers along the simulating traces have a special structure to show the correctness of the simulation.

The basic step (i.e., the prefix length is 0) is trivial. For the induction step, let us assume that there is a simulation of the prefix of length k satisfying the induction hypothesis. To simulate the k + 1-st transition, we follow the expectancy rule.

