The specification language Csp-Casl allows one to model processes as well as data of distributed systems within one framework. In our paper, we describe how a combination of the existing tools Hets and Csp- Prover can solve the challenges that Csp-Casl raises on integrated theorem proving for processes and data. For building this new tool, the automated generation of theorems and their proofs in Isabelle/HOL plays a fundamental role. A case study of industrial strength demonstrates that our approach scales up to complex problems.

Here, we develop theorem proving support for Csp-Casl and show that our approach scales up to practically relevant systems such as the EP2 standard. Csp- Casl comes with a simple, but powerful notion of refinement. Csp-Casl refinement can be decomposed into first a refinement step on data only and then a refinement step on processes. Data refinement is well understood in the Casl context and has good tool support already. Thus, we focus here on process refinement. The basic idea is to re-use existing tools for the languages Casl and Csp, namely for Casl the tool Hets [13] and for Csp the tool Csp-Prover [8,9,10,11], both of which are based on the theorem prover Isabelle/HOL [19]. This re-use is possible thanks to the definition of the Csp-Casl semantics in a two step approach: First, the data specified in Casl is translated into an alphabet of communications, which, in the second step, is used within the processes, where the standard Csp semantics are applied.

Our paper is organised as follows: Section 2 introduces the Csp-Casl semantics along with a case study from the EP2 system. Section 3 describes the existing tools which we make use of. The overall architecture of Csp-Casl-Prover is presented in Section 4. First we discuss how to build an alphabet to be used as a parameter for

Theorem 2.1 allows the decomposition of a Csp-Casl refinement (Sp, P ) ~D (Sp',P') into (1) a Casl refinement step from Sp to Sp' and (2) a Csp-Casl re- finement step from (Sp',P ) ~D (Sp',P'), where the data part remains constant, namely Sp'. For (1), the tool Hets already offers tool support. Thus, we con- centrate here on (2). Concrete: we provide an automatic translation of Csp-Casl refinement over constant data parts into the input language of Csp-Prover.

can be discharged by various theorem provers, such as Isabelle/HOL or SPASS. Hets is written in the functional programming language Haskell [6]. The Hets code base defines a rich type system which captures mathematical notions such as logics, comorphisms, Casl specifications, theories, etc. Hets makes use of monadic programming in order to simulate states within Haskell.

Aim of the alphabet construction is to create an alphabet of communications (the new type Alphabet) in Isabelle/HOL as set out in Section 2.2. We then use this type within Csp-Prover to form the type Alphabet proc of Csp processes over the alphabet of communications.

