Slicing is a program analysis technique which can be used for reducing the size of the model and avoid state explosion in model checking. In this work a static slicing technique is proposed for reducing Rebeca models with respect to a property. For applying the slicing techniques, the Rebeca dependence graph (RDG) is introduced. As the static slicing usually produces large slices, two other slicing-based reduction techniques, step-wise slicing and bounded slicing, are proposed as simple novel ideas. Step-wise slicing first generates slices overapproximating the behavior of the original model and then refines it, and bounded slicing is based on the semantics of non-deterministic assignments in Rebeca. We also propose a static slicing algorithm for deadlock detection (in absence of any particular property). The applicability of these techniques is checked by applying them to several case studies which are included in this paper. Similar techniques can be applied on the other actor-based languages.

Model checking [4] is a formal verification technique for verifying concurrent systems against a number of specifications and can be used for developing more reliable systems. The main problem of model checking is the state space explosion problem and many techniques are developed to overcome this problem. These techniques include: abstract interpretation [5], data abstraction [9], predicate abstraction [12], slicing [31], partial order [23] and symmetry reductions [15].

For slicing Rebeca models a dependency graph should be constructed first. For this purpose we introduced a special dependency graph based on Rebeca semantics. This graph is less complicated than existing dependency graphs, due to the asyn- chronous nature of communication, atomic execution of message servers, absence of shared variables and absence of procedure calls (hence there is no need for inter- ference or summary edges discussed in [19]). In addition, although Rebeca is an object-based language, we should not deal with complexities of dependence graphs designed for object-oriented languages, as features like inheritance and polymor- phism are not included in the language. In the case of component-based models the corresponding subgraph of each component can be saved and reused when a component appears in another model.

For computing the slice from the resulted graph, four different algorithms are presented in this paper. The first one is the traditional reachability algorithm which is used for static slicing. The second algorithm is based on a simple novel idea and is used when we want to check a model against deadlock (unlike regular slicing algorithms there is no need to specify a property here). The idea is eliminating the statements that have no effect on any other statements.

In the third slicing algorithm, step-wise slicing, an overapproximation of the original model is computed and then based on the verification result, the reduced model is refined if needed. This algorithm starts by including the property variables in the model. Variables which have a direct effect on the value of the property variables, are also included in the model. These variables take a value using a non- deterministic assignment, in the reduced model. The other variables are eliminated from the model. Then, the reduced model is verified and if a spurious counter- example is found, the model is refined by including more variables in it.

Although the reduced model overapproximates the behavior of the original model, but the possibility of finding a spurious counter-example is reduced. The reason is that the variables are eliminated heuristically by the user (and not as an adhoc manner). However in the case of finding a spurious counter-example the model should be refined by adding more variables to it.

Automatic processing: The static slicing process is completely automatic and does not involve the user in the reduction process, comparing to the compositional verification approach in which the user should make a decision in selecting a num- ber of components. Bounded slicing is applied automatically on a Rebeca model which uses non-deterministic assignment for assigning value to some variables. However the user can specify more variables (with non-deterministic values) for the bounded slicing algorithm to get a smaller slice. Step-wise slicing is not fully automatic in this work because the refinement process needs user interaction. But it can be improved to a fully automatic process and it is one of the future works.

Property preservation: Static slicing is characterized by strong property preservation. This means that satisfaction and violation of a property in the original model can be directly concluded from the reduced model. In contrast, compositional verification overapproximates the model and the violation of the property in the reduced model does not necessarily implies the violation of the property in the original model. Both of the step-wise slicing and bounded slicing techniques overapproximate the model, however when bounded slicing is used, the possibility of finding spurious counter-examples is reduced.

This paper is structured as follows. The next section presents an overview of the related works. Section 3 briefly introduced the Rebeca language and program slicing technique. In Section 4 the Rebeca dependence graph is presented and in Section 5 different slicing algorithms are discussed. Section 6 explains the result of applying the slicing techniques to two case studies and the last section concludes the work.

Static slicing has been used as a reduction technique in [1,6,21,13,2,24] for model checking purposes. In [7] an evaluation of using this technique for model reduction is presented. The result of [7] shows that slicing concurrent object-oriented source code provides significant reductions that are orthogonal to a number of other reduction techniques, and that slicing should always be applied due to its automation and low computational costs.

An approach named abstract slicing is presented in [14] which is based on ab- stract interpretation. Abstract slicing extends static slicing with predicates and constraints by using the program model as an abstract state graph, which is ob- tained by applying predicate abstraction to a program. For controlling the state space explosion problem, the abstract slicing is formulated in terms of symbolic model checking. In this abstraction technique, it can be determined under which conditions one statement might affect another. But for verification we may need to find out whether some condition might hold at all or not.

One of the ideas presented recently is incremental slicing [30]. It starts with a small, minimal part of the specification and successively adds further parts until either the property under interest holds on the slice or a real counterexample is found. This technique is applied to CSP-OZ [10]. The step-wise slicing technique presented in this paper uses the idea of overapproximating the behavior of the model and then refining it. However because of the different nature of the languages the way of applying the idea is different. In addition, in [30] the technique is applied to a simple automaton (comparing to our work in which the technique is applied to the dependency graph), therefore further comparison between these two techniques is not possible.

In [11,20] a technique is proposed for slicing synchronous reactive systems by introducing a new notion of slicing. In [11], this technique is applied to Argos language which is based on finite state machines. In [20] the Esterel language is considered which has a rich set of control constructs. The concentration of [20] is on modeling these constructs by defining new dependencies. The main difference of our work and this technique is the actor-based and asynchronous nature of Rebeca language.

Rebeca [27] is an actor-based language for modeling concurrent and distributed systems as a set of reactive objects which communicate via asynchronous message passing. A Rebeca model consists of a set of reactive classes. Each reactive class contains a set of state variables and a set of message servers in which the body of the message servers is executed atomically. In a Rebeca model there is a set of rebecs (reactive objects) which are concurrently executed. Rebecs are encapsulated reactive objects, with no shared variables. Each rebec is instantiated from a reactive class and has a single thread of execution which is triggered by reading messages from an unbounded queue. Each message specifies a unique method to be invoked when the message is serviced. When a message is read from the queue, its method is invoked and the message is deleted from the queue. Each rebec has an initial message server, and in the initial state the queue of the rebec is empty and its statement to be executed is the first statement of the initial message server.

In [26], components encapsulate tightly coupled reactive objects which may have synchronous communication. The behavior of each component is like a reactive object and in the simplest case each reactive object is a component itself. In this pa- per we abstract from the internal synchronous communication as this is not natural behavior for actors.

In this example there exists a sender which sends a number of messages to a receiver. According to the non-deterministically chosen value of variable y, the sent message may be a new message or the previous message. After sending the last message this scenario starts over again. On the receiver side, after receiving the last message the value of a boolean variable named b is set to true. A possible property for this example is G(F(b == true)) which checks whether the last message is finally received by the receiver. The property is an LTL (Linear Temporal Logic) formula in which G denotes globally and F denotes Finally.

In general, slicing [31] is an analysis technique which is widely used in debugging, testing, maintenance and program comprehension. Program slicing, is first intro- duced as a decomposition technique that extracts statements relevant to a particular computation, from a program. A program slice consists of the parts of a program that potentially affect the values computed at some point of interest (referred to as a slicing criterion). In general, it is undecidable if a slice is minimal [31] and one of the attempts of slicing algorithms is to make the computed slice more precise.

For slicing programs without procedures, a reachability algorithm is performed on the program dependence graph (PDG) [16]. The PDG mainly consists of nodes which represent the statements of a program and two types of dependence edges: Control dependence edge that exists between two statement nodes if one node con- trols the execution of the other node. Data dependence edge that exists between two statement nodes if assigning value to a variable at one statement might reach the usage of the same variable at another statement.

In slicing programs with procedures, a two phase reachability algorithm is per- formed on the system dependence graph (SDG) [25]. The system dependence graph is a collection of procedure dependence graphs, one for each procedure. A procedure dependence graph contains nodes representing the procedure statements and con- trol and data dependence edges. In addition, it contains an entry node representing entry to the procedure and a set of formal-in and formal-out nodes for modeling parameter passing. In each call site there is a call node and a set of actual-in and actual-out nodes. A call edge connects a procedure call site node to the entry node of the related procedure. Parameter-in edges and parameter-out edges connect the formal-in and formal-out nodes to the actual-in and actual-out nodes, respectively.

When slicing is used in model checking for model reduction purposes, the definition of a slice slightly differs from the original definition which is used in software testing, debugging and maintenance. The reason is that in model checking the slicing is applied with respect to a property instead of a particular computation in a certain location of the program. Therefore the slice should be computed with respect to all of the points in which the involved variables in the property are taking a value.

Message passing: putting a message in a queue is represented through an activation node. In addition an activation edge is used for connecting the activation node to the entry node of the related message server. The parame- ters of the messages is modeled using formal-in and actual-in nodes as well as parameter-in edges.

For each component in the model, the related subgraph can be extracted from the RDG for further reuse. This can be done by selecting the reactive classes entry nodes related to the component and finding all of the nodes reachable from them. When finding reachable nodes, all of the edges are followed, except activation and parameter-in edges going to other reactive classes.

In this section we describe slicing-based techniques which can be used for model reduction. As mentioned in the previous section, the intra-rebec data dependency edges are not transitive and precise slices can be computed by considering realizable paths. The purpose of the algorithms, presented in this section, is showing the main ideas of the slicing techniques, therefore for simplicity, we do not discuss the computation of realizable paths in these algorithms, in this paper.

The main purpose of proposing this technique is the gap exists between the tradi- tional static slicing method and step-wise slicing. The weakness of static slicing is that it usually generates a large slice and its advantage is that it preserves the prop- erty strongly. One the other hand step-wise slicing generates small slices (at least at the first stages of the algorithm) but it overapproximates the model. Additionally, it may take several rounds for getting a result, especially in large models.

In the bounded slicing technique we used the idea of non-deterministic assign- ments in Rebeca. However this technique can be applied to any other language supporting non-determinism. A non-deterministic assignment statement is not data dependent to any other statement so there is no data dependence edge, intra-rebec dependence edge or parameter-in edge that could be followed by the slicing algo- rithm. Thus, the algorithm is bounded by these assignments.

The proposed techniques were applied to a number of case studies. This section presents the results of reducing these case studies. The model checking is performed using Modere [17] on a computer with a 1.80 GHz CPU and 2038 MB of RAM.

Leader election problem (LE): A node should be selected as a leader in a ring of n nodes. It is supposed that each node knows the nodes next to it only. The leader is selected through the messages sent among the nodes.

In this paper we use slicing-based techniques for reducing the Rebeca models. A dependence graph named Rebeca dependence graph (RDG) is introduced for mod- eling the asynchronous nature of Rebeca. Three slicing-based techniques are used to compute the slices and each of them had a different reachability algorithm for computing the slice. In addition, a technique is proposed which reduces models that should be checked against deadlock.

In future work, we planned to find the main characteristics of the models which are best reduced by applying each of these techniques. Also, further investiga- tion is ongoing to find more specializing techniques for Rebeca. Integrating these techniques with Rebeca verifier tool set is one of the other future works.

