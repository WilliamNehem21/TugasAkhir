In this paper, we present a SAT-based approach for bounded model checking of Timed Constraint Automata. We present an embedding of bounded model checking into propositional logic with linear arithmetic, which overcomes the state explosion problem to deal with large systems by defining a product that is linear in the size of the system. To further improve model checking performance, we show how to embed our approach into an extension of counterexample guided abstraction refinement with Craig interpolants.

Component-based software engineering amounts to constructing large systems by composing individual components. The correctness and safety of these concurrent systems depend on actions that happen at the right time, i.e., before or after a certain deadline, or within a certain time interval. As components are often available as black boxes only, timed coordination has to be done by the time-aware component connectors. Timed Constraint Automata [4] (TCA) have been originally defined as a semantical model for the coordination language Reo [3]. They offer a powerful stand-alone coordination mechanism for implementing coordinating connectors in networks of timed components exchanging data through multiple channels.

omnipresent state explosion problem [9] already present in finite state model check- ing, current model checking techniques for real-time systems are still limited in the number of concurrent quantitative temporal observations (measured by clocks). A particularly dramatic cause of the state explosion problem is the exponential blow-up obtained by forming the cross product for parallel composition of TCA. To avoid this, we define a linear-size parallel composition for the logical representation of TCA. Typically, only a reduced part of the full parallel composition has to be expanded from our representation during satisfiability checking (SAT solving).

Very sophisticated and well-optimised techniques (e.g., [17]) guide high-end SAT solvers to explore only a comparably narrow fragment around the part of the state space relevant for the particular safety property. We build upon this development by choosing a linear arithmetic/propositional encoding, a philosophy that has suc- cessfully proven its great potential in finite state systems [8]. With this basis, we exploit the particularities of transition systems induced by TCA using abstraction refinement to deal with the challenges of infinite states.

Abstraction refinement [9,12] is a promising direction of research to overcome the challenges of the state explosion problem and infinite state model checking, while preserving correctness of verification results. Abstraction techniques over- approximate system behaviour by removing constraints that are considered irrele- vant for verifying a particular specification. If the abstract system is safe (no error state is reachable) then, by conservative over-approximation, so is the original.

We have extended the CA editor in the Eclipse Coordination Tools [10] to support generation and editing of TCA (including various syntactical checks, e.g. well-formedness of clock constraints). Within this platform, we have implemented the translation of TCA to propositional formulas with linear arithmetic constraints (front end), as described in this paper. Further, we have implemented the generation of input files for the MathSAT solver (back end), allowing us to analyse the under- lying TCA in detail. Having split the formula generation in two parts, it is very easy to switch to another solver, by just exchanging the back end. This implementation is scheduled to be part of the next release of the Eclipse Coordination Tools.

In the next section, we discuss some related work. After introducing TCA and bounded model checking (BMC) in Section 3, we present a faithful representation of TCA in propositional logic with linear arithmetic for BMC in Section 4, and give some soundness results. In Section 5, we introduce a uniform abstraction, extend the algebraic perspective on soundness from Section 4 to correspondence results about abstraction, and briefly recall how to exploit spurious counterexamples for refining abstractions. Section 6 concludes the paper and discusses some future work.

Jhala and McMillan [13] present an abstraction refinement approach for predi- cate abstraction. Using interpolants, they generate refinements which take into ac- count specific characteristics of the property. A limitation, however, is the fact that their approach relies on an appropriate choice of predicates for predicate abstrac- tion. Our approach can be considered as a quick (hence, scalable) approximation of predicate abstraction, where predicate discovery is evident by exploiting the nature of TCA.

The abstraction refinement framework presented by Clarke et al. [9] works with Kripke structures originating from finite state programs. In contrast, our approach deals with the challenges of infinite state model checking, as introduced by the notion of real-time clocks. Further, we directly use a formula representation which is tailored for SAT-based bounded model checking.

The representation of other constraints is straightforward, by using conjunctions (and negations, in case of data constraints) of the aforementioned representations. The inter-step representation is needed for correct representation of delayed transitions in ST , cf. Section 3.2: the invariant of the target location s' is evaluated

The restriction to convex clock constraints does not reduce the expressiveness of our model (cf. Section 3.1), but on the contrary significantly simplifies the rep- resentation formulas, since clock constraints need to be checked at the beginning and at the end of a time delay only, rather than at all intermediate points (cf. (7)). We further simplify verification by defining a product representation which is linear in the number of automata (12). In this way, we also avoid the exponential state space blow-up when forming the cross product.

In this section, we show how to adapt the abstraction technique of abstraction by merging omission (MO) [14] to our representation. MO is a simple and fast but nevertheless powerful abstraction technique specifically tailored to work on logical formulas. The removal of constraints considered irrelevant to the particular safety property yields an over-approximation.

This result is already captured by Lemma 5.2. Here, we have proven an even stronger correctness result, by showing the existence of a homomorphism between concrete and abstract sets of runs. For a detailed discussion and proof, we again refer to the extended version of this paper, available at www.cwi.nl/~kemper.

In this paper, we have presented a SAT-based approach for bounded model checking of TCA. We have defined an embedding of bounded model checking for systems of TCA into propositional logic with linear arithmetic, and introduced a uniform logic- based abstraction for clocks, locations, port names and data values. This logical representation directly benefits from state-of-the-art SAT solving techniques, and allows a linear-size representation of parallel composition. We expect the structural relationships underlying the abstraction to provide the basis for a framework to generalise our work to other scenarios.

We believe our framework provides means to better understand the functioning of TCA, Reo coordinators and Reo networks [3] (for which TCA serve as formal model). To further improve this, we plan to integrate a back translation from formulas to TCA into the Eclipse Coordination Tools, such that e.g. the result of abstraction can be viewed as a TCA in the editor. Our framework further facilitates verification of these connectors, for example whether an implementation meets its specification. We intend to use the framework within a testing environment of Reo networks, which will enables us to perform black and white box testing, for example check the feasibility of a certain interaction behaviour.

