An embedded system being intrinsically critical, it is essential to insure that it is tolerant to processor failures. This can even motivate its distribution itself. In such a case, at the very least, the loss of one computing site must not lead to the loss of the whole application. We are interested in formal methods to model systems with guarantees on their fault-tolerance. Among the various existing formal methods, we investigate the use of discrete controller synthesis (DCS). The advantages of using DCS are the correctness of the resulting system and the easy modifiability of the controller (thanks to automatic tools), i.e., the possibility to study and test several fault-tolerance objectives or failure hypotheses on the same system model, without the need to re-design the system. Specifically, our objective is:

The technical context of our work is the synchronous approach 2 for the design of reactive systems [4]. This choice is motivated by the existence of a corpus of available results (laguages, compilers, formal tools) and technologies, which already have an industrial impact. Our method is compatible with synchronous models, and this influences some of our choices in the LTSs and composition, as well as in already existing DCS, applied as such [17].

We assume the following failure hypothesis : only the processors can fail, with a fail-silent model. That is, a processor is either active and works fine, or faulty and does not produce any output. To tolerate such faults, we are going to make use of the intrinsic hardware redundancy offered by the dis- tributed architecture: i.e., we do not wish to add extra processors but to use only the existing ones. Our goal is to apply error treatment techniques, such that whenever a processor will fail, the tasks that were active on it will be dynamically restarted on some other non faulty processor. The new state of the system reached after such an error treatment is degraded in the sense that less processors are now available, but the functionality is maintained since all the tasks are still being executed.

In our approach, P is specified as a LTS, and D is an objective to be sat- isfied by the controlled system, typically making a subset of states invariant in the controlled system, or keeping it always reachable. The controller C ob- tained with DCS is a constraint restricting the transitions of P, i.e., inhibiting those that would jeopardize the objective. The key point is that the set of inputs I is partitioned into two subsets, Ic and Iu, respectively the set of con- trollable and uncontrollable inputs. The principle of DCS is that the controller C can only constrain those transitions of P for which the guard contains at least one controllable signal, i.e., in Ic.

an invariance constraint, because the latter might compromise the former by removing paths and breaking reachability. On the contrary, considering reach- ability after invariance does not jeopardize the invariance, as it will not result in paths going out of the invariant set. Optimization should be considered last, as a choice among correct solutions; even after reachability, it will keep only some paths, which should always satisfy it.

The real-time aspect of such systems comes from the time costs of the periodic tasks. The time cost of each task is measured thanks to a WCET analysis. Then, each task being periodic, we consider that, when executing on a pro- cessor, it uses some CPU load, computed by dividing its WCET by its period. Enforcing real-time constraints amounts thus to assigning to each processor a CPU load maximal bound, which should never be overtaken.

resource. Also, related to the weights and particularly costs in power and load, individual tasks weights are to be additive: on a given processor, the global load is the sum of that of all the active tasks. Each processor i has a quantitative bound bi, specifying its maximum power capacity.

The model consists of the composition of all LTSs as above. In the example, we have three of them, one for each of the processors P1, P2, and P3, for which capacity bounds bi w.r.t. power consumption are, respectively, 5, 3, and 6.

result in a total failure of the system, with no possibility at all to ensure the fault-tolerance of the system. No one expects a system to tolerate a failure of all the processors it is made of. Therefore, we need to specify the way the failures do occur in the patterns that we consider.

Providing such an environement model is up to the designer. His choice will depend on his knowledge of the system and the related failure assump- tions. For instance, if it is unlikely for two failures to occur simultaneously, he will remove from the automaton 4(a) the three transitions from B to Fi,j. Alternatively, if he wants to consider malicious attacks, he will keep them.

Implicitly, each state has an additional self-loop labeled with the comple- ment guard w.r.t. all its other outgoing transitions. For instance, state Ij has a self-loop labeled with rj , which enables the LTS to remain inside Ij until the occurrence of the signal rj.

The fault-tolerance policy is specified declaratively by a set of properties and objectives. The fault-tolerance specificity of these properties is twofold. On the one hand, they are meant to be considered upon models as described above, where all faults, recoveries or failures behaviors are represented. On the other hand, they characterize failed states (e.g., consistent placement constraints characterize states where the system is not viable), as well as the tolerance, meaning the notion of fulfilling functionality whatever the faults.

Property 1 is contradicted whenever a task T j is active on processor Pi (i.e., in state Aj) while Pi is in Erri. The synthesis objective is to make it invariantly true. If the system, as modeled by the designer, is such that in each state there exists a transition to a safe state (i.e., one where Property 1 holds), then the synthesis will succeed and the controlled system will allways be able to react to a processor failure by moving to a safe state. Otherwise the synthesis will fail, indicating to the designer that her/his system cannot be made fault-tolerant.

taking this transition means that a later processor failure, specified in the environment model, will not be tolerated without bounding problems. Here, the DCS computes the most permissive controller such that all failures are guaranteed to be tolerated without bounding problems. A terminating task can then release another waiting task.

as the environment model says, the remaining processors with the smallest capacity are still able to host all the active tasks. This constraint can also block the system in the ready states, because the path is not clear and wide enough for execution. Here, as well as for the previous objective, the environ- ment model can have a determining influence: if it excludes pathological fault patterns, then a solution can be found.

We first considered simple tasks, and consistent execution objectives, and then extended our objectives with functionality fulfillment and optimization. Our method is limited by the technological state of the existing DCS tools, basically the same limitations as with model checking tools. Given the current trend in this domain (symbolic state space exploration, abstract interpreta- tion, widening operators ... ), we believe that future improvements in DCS

We have shown how to model a real-time distributed system, its heteroge- neous architecture, and its environment in order to produce automatically a controller enforcing fault-tolerance. It reacts to the occurrences of failures by migrating tasks according to the fault-tolerance policy. For this, we have applied DCS to LTS models of the whole system, with objectives regarding consistent execution, functionality fulfillment, and optimizations.

example, an image processing coder/decoder sub-system in a system-on- chip, can be embedded into different devices, e.g., a home DVD player, where power supply is not at all an issue, or a cell phone or cam-recorder, where power is indeed crucial; reusing the same model submitted to differ- ent synthesis objectives opens perspectives in further applications of these techniques, in the framework of platform-based design.

