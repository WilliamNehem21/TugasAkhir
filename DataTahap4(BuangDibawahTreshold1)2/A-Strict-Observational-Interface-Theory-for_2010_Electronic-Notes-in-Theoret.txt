Service oriented computing is an accepted architectural style for developing large, distributed software systems. A particular promise of such architectures is service orchestration, i.e. the ability to combine existing services to create more complex functionality, thereby yielding new services. In this paper, we discuss application-level protocol compliance checking of service orchestrations and service protocols using the semantic domain of modal input/output automata (MIOs). Based on a practical example, we motivate and introduce new notions of refinement and compatibility, and prove that they constitute a valid interface theory. With this domain-specific interface theory, we provide a framework for application-level analysis of service orchestrations, thus complementing existing work on compatibility analysis. Our theory is tool- supported through the MIO Workbench, a verification tool for modal input/output automata.

With the advent of Service-Oriented Architectures (SOAs), the enterprise software landscape has been transformed from interactions of proprietary, closed components to an open and standardised communication between individual, self-describing components called services. Of particular importance in this context is the compo- sition of individual services to form a new service, which has come to be known as service orchestration. Using techniques from the model-driven community, service- based systems can be modelled in UML or other user-friendly, graphical or non- graphical languages and later be transformed to platform-specific models and code.

Correctly implementing a given protocol in a service orchestration is not an easy task. Our aim, therefore, is supporting developers in this task by providing application-level protocol breach analysis. This type of analysis focusses exclusively on protocol actions, which corresponds to the layer of abstraction the developer is interested in. It explicitly does not cover lower-level implementation issues such as race conditions.

Thirdly, the analysis of service protocols and orchestrations should have some tangible result for the developer. An important point of service-oriented architec- tures is the ability to switch between different services with a minimum amount of effort. Therefore, the analysis should give us the assurance that if an orchestra- tion works with a certain protocol, it can work with any service implementation which corresponds to the same protocol. This property has come to be known as independent implementability.

The remaining sections are organised as follows. In Section 2, we recall the fundamental notion of interface theories and their most important properties, and moreover, modal I/O automata which serve as the formal basis of our approach. Then, in Section 3, we recapitulate the standard definition of weak modal refine- ment which is shown to be insufficient for our needs. As a remedy, we define a

We first try to analyse this service orchestration with existing interface theories for modal I/O automata. The closest to our own definitions of refinement and compatibility for MIOs are weak refinement and compatibility, complemented by the notion of hiding. We shall introduce these now, before moving on to the discussion of our interface theory.

The initial problem indicated above (s.complete? not being possible after e.cancel? ) is not detected by our refinement notion, which allows us to focus on finding protocol breaches. This problem can be dealt with using other analysis techniques such as interface theories building on weak refinement [2].

We now adapt weak modal refinement to satisfy our needs, i.e. we only want to consider relevant actions during refinement of MIOs. The basic idea for our refinement is to skip leading actions unrelated to the protocol under investigation. First, the refining MIOs may have more actions than the refined one, and second, in both directions in the definition we focus on the external actions of the more abstract MIO since these actions are the relevant ones.

Considering again the example of compatibility between the orchestration and the student protocol, strict-observational I/O compatibility treats e.cancel? and t.assessThesis! differently, as both actions are not defined in the student proto- col. e.cancel? is only relevant as a prefix to s.abort!, while t.assessThesis! is not considered at all. We therefore get a positive compatibility result between ThesisManagement and Student as expected.

We have implemented strict-observational refinement, compatibility, and com- position in the MIO Workbench [2], an Eclipse-based verification tool which includes an editor for MIOs and is able to depict relations and problematic paths directly on the graphical MIO representation. The workbench also implements the standard notions of refinement and compatibility (strong, weak, and may-weak refinement as well as strong, weak, and friendly environment compatibility, cf. [2,19]), which allows a direct comparison between the individual interface theories. The MIO workbench is available for download from http://www.miowb.net/.

There is also an extensive body of knowledge on semantics and analysis of Web service orchestrations based on industry standards like BPEL; [31] provides a decent overview. However, to the best of our knowledge, no approach so far has considered early application-level verification as a precursor to existing approaches. Instead, the focus lies on analysis of specific aspects of service orchestrations. Both [22] and

[26] analyse BPEL compositions through transformations to petri-nets. Their com- position analysis assumes a friendly environment in the sense of [4], but is not geared towards application-level analysis of service orchestrations. Fu et al. [13] present a translation of a composition of BPEL processes to Promela, the input language of the SPIN model checker [16]. However, due to the interaction semantics of the translation, application-level verification is not feasible. Two further approaches that are closer to ours use calculi to specify the underlying labelled transition sys- tems: [3] explicitly focusses on strong notions of compliance and compatibility. For calculi-based model-checking approaches like [10], the same reasoning as for the ap- proach of [13] applies: application-level verification is prohibited by the composition semantics of the language.

