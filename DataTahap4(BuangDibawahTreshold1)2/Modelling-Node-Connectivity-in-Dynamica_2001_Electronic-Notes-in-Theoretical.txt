Of course, di erent nodes of a network may use di erent forms of connec- tivity. The rst form of connectivity represents an idealized situation that seldom takes place in practice for all nodes of a wide-area dynamically evolv- ing network. Here are a couple of realistic, but simpli ed, scenarios where users experiment with the remaining two forms of connectivity.

Untethered mode is the usual form of connectivity for a mobile user that, from time to time, enters di erent areas where connectivity is constrained. For instance, the user may connect to computers that are within a rewall, so that the communication among such computers is available, but connection to the rest of the net is disabled. This limitation, however, could not concern all computers; typically, there might be some of them that are allowed to access the whole net and represent the gateway to the external world.

The rest of the paper is organized as follows (due to lack of space, all technical details have been omitted). Section 2 informally presents the lan- guage Klaim, while Section 3 introduces the extensions for managing clusters. Section 4, by means of a simple example, illustrates how to use the new fea- tures to model node connectivity. Finally, Section 5 presents a sketch of the translation of the extended language into Klaim and the extensions to the implementation.

Klaim (Kernel Language for Agent Interaction and Mobility, [5]) is an exper- imental programming language speci cally designed to program distributed systems composed of several components interacting through multiple tuple spaces and mobile code. It is inspired by the coordination language Linda [8], hence it relies on the concept of tuple space. A tuple space is a multiset of tuples; these are containers of information items (called elds). Klaim distinguishes between actual elds (i.e. expressions, processes, localities, con- stants, identi ers) and formal  elds (i.e. variables). Syntactically, a formal

(\foo"; \bar"; !P rice) is a tuple with three elds. The rst two elds are string values while the third one is a formal eld. Similarly, (out(\hello")@l; \foo") is a tuple whose rst eld is a process. Tuples are anonymous and content- addressable; pattern-matching is used to select tuples in a tuple space:

In Linda there is only one global shared tuple space; Klaim extends Linda by handling multiple distributed tuple spaces. Tuple spaces are placed on nodes that are part of a net. Each node contains a single tuple space and processes in execution; a node can be accessed through its address. There are two kinds of addresses:

Sites have an absolute meaning and can be thought as IP addresses, while localities have a relative meaning depending on the node where they are in- terpreted and can be thought as aliases for network resources. Localities are associated to sites through allocation environments, represented as partial functions. Each node has its own environment that, in particular, associates self to the site of the node.

  in(t)@l: evaluates tuple t and looks for a matching tuple t0 in the tuple space located at l. Whenever the matching tuple t0 is found, it is removed from the tuple space. The corresponding values of t0 are then assigned to the formal elds of t and the operation terminates. If no matching tuple is found, the operation is suspended until one is available.

Klaim processes can be built from basic operations by using standard op- erators borrowed from process algebras [9], such, e.g., action pre xing and parallel composition. Timeouts can also be used for avoiding that processes block due to network latency bandwidth or, when retrieving information, to absence of matching tuples.

sure (i.e. the process together with the environment of the node where the evaluation is taking place). The di erence between operation out(P )@l and eval(P )@l is that out adds the closure of P to the tuple space located at l, while eval sends P , not its closure, for execution at l. Therefore, if node s1 performs an out of P to node s2, when P is executed at s2 , self will actually refer to s1 . This means that static scoping is used for binding localities. On the contrary, if s1 spawns P at s2 with eval, no closure is sent: P will refer to s2 when using self and dynamic scoping is used for binding localities.

Operations over clusters modify the topology of networks and can be per- formed only by superprocesses (these are denoted by P). Superprocesses can- not migrate and cannot be used as tuple eld. They are installed at a node when the network is initially con gured or when the node is dynamically cre- ated by using newloc(u; P), which creates a new node with superprocess P. The superprocess of a node can be thought of as an abstraction of that part of a network operating system that lies at the node, while standard Klaim processes are the user programs that can call for execution of system calls. In addition to the standard Klaim operations, superprocesses can also per- form operations newc, add and rm acting over clusters. More speci cally, newc(w):P creates a new, empty cluster that can be referred to via the vari- able w. add(c):P adds the node where it is running to the cluster c, whilst, conversely, rm(c):P removes the node from c. Hence, node mobility is mod- elled in terms of the ability of nodes in entering to and exiting from clusters.

  Tethered Mode: There is only one cluster and all nodes belong to it. More- over, a node cannot be removed from the cluster, hence there are no super- processes in the nodes. The standard Klaim model ts in this picture.

A software engineer works in isolation. Sometimes, he dials up and gets reconnected to a virtual community server in order to download updates and perform a query in the virtual community. After that, he goes o -line. Later, he reconnects to the virtual community and the results of the search will be dispatched. Moreover, he can establish a communication with one of the other community users. When he has acquired enough information he logs o . Finally, when he nishes his work, he logs on and uploads the artifacts.

Let us now consider a possible speci cation in Klaim that also exploits clusters and operations over them. In the net that models the scenario there is only one cluster, called virtualc, corresponding to the virtual community. In the cluster, there is a node for the server, called S, and one node for each user in the community. A node is on-line when it belongs to the cluster and, conversely, it is o -line when it is removed from the cluster. We just consider superprocesses and Klaim processes running at the engineer's node. We assume that, initially, the engineer's node is outside the cluster.

As regards the implementation, clusters can be smoothly accommodated in the existing Klaim implementation 1 , without making use of the translation sketched above. Indeed, a Klaim net is implemented through a server where nodes must register by using their site. The server allows nodes to communi- cate both directly or indirectly (i.e. messages pass through the server) and it can be considered as a cluster. Hence, extending the implementation consists in having more than one server in the same net and in allowing a node to register in more than one server. Currently, the extended implementation is in progress.

The paradigm that is closer to ours is the Ambient calculus [4]. However, the aim of clusters and their features are quite di erent from ambients' ones. Clusters represent communication capabilities, rather than real physical en- vironments (indeed clusters are more similar to channels). Hence, di erently from ambients, clusters can overlap so that, e.g., shared nodes can act as gate- ways between di erent clusters. Moreover, clusters cannot move and cannot be nested (in the sense that a cluster cannot occur inside another one), while

Another related paradigm is Lime [11]. In Lime, each mobile agent has its own tuple space and all the agents running over an host share the transient tuple space formed by the union of the tuple spaces of each agent. Lime hosts can resemble our clusters, however, in Klaim, clusters can overlap and nodes' tuple spaces are always distinct, thus can be explicitly addressed.

[2] Bettini, L., R. De Nicola, G. Ferrari and R. Pugliese, Interactive Mobile Agents in X-Klaim, in: P. Ciancarini and R. Tolksdorf, editors, Proc. of the 7th Int. IEEE Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises (WETICE) (1998), pp. 110{115.

