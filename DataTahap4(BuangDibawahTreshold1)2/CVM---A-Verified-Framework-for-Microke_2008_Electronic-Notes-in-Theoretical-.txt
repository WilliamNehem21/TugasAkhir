At first sight, this appears to be a mission impossible because of the sheer size of operating system implementations. For example, the Linux 2.6.0 kernel released in late 2003 has nearly 6 million lines of code. Yet, the idea of having a small and reliable kernel is not new and has led to the development of so-called 2nd generation microkernels like L4 [16]. Microkernels offer elementary, but sufficient functionality, and can therefore be of relatively small size. For instance by using them as a trusted platform, we can run two operating systems on top of it, one small and reliable for critical applications, and a conventional one for all other tasks [24].

We use devices in two ways in CVM. First, the page fault handler described in Sect. 5.3 uses a hard disk as swap device. Second, we offer a range of typical devices accessible by user processes through special kernel calls. Currently, we support models for five different device types: (i) a hard disk, e.g. used as the swap device for memory virtualization [11], (ii) a timer, which can be used for scheduling

In order to realize memory virtualization, the VAMP runs in two modes: user mode and system mode. In user mode, all addresses are virtual and have to be translated first before accessing memory [7]. However, in system mode, we deal with physical addresses that can be used without translation. In our scenario, the microkernel runs in system mode while the user processes run in user mode.

The transition function depends on the special purpose register mode, where mode = 0 denotes system mode and mode = 1 denotes user mode. For system mode, the transition function is simply defined by the instruction to which cphys.dpc points (see [5,17]). In user mode, memory accesses are subject to address transla- tion: they either cause a page fault or are redirected to the translated physical address pma(cphys, va) for a given virtual address va. For details on VAMP address translation see [8].

tions, the abstract kernel only declares (i.e. the CVM primitives), and we have to add functions that are not visible in the abstract kernel (i.e. cvmdispatch). Ad- ditionally, we have to add some extra global variables not needed in the abstract kernel.

a mapping of addresses to content: sm : N - Z. Besides the architecturally de- fined physical memory address pma(cphys, va), we define a (software) swap memory address function sma(cphys, va) maintained by the page fault handler, which maps virtual addresses to addresses in cdevs(1).sm.

First, the abstract kernel has to be simulated by the concrete kernel. Second, the concrete kernel is a C0 program and cannot be executed directly on the hardware. Thus, we depend on compiler correctness, i.e. a simulation relation between C0 machines and physical machines.

The concrete kernel is written in C0 with inline assembler portions, while on the actual hardware, the translated object-code is executed. Hence, we have to define in a formal way, what correct translation of C0 means. Since our work is part of the Verisoft project, we are using the Verisoft simple non-optimizing C0 Compiler and the consistency relation it provides. Nevertheless, approaches like translation validation [25] are also feasible and have been successfully applied in other projects [19].

Future work includes the verification of further CVM primitives, especially those dealing with devices. In particular, accessing devices in block mode, i.e. reading and writing big chunks with one kernel call, yields major challenges like handling interrupts that might occur during such accesses.

The new Hypervisor project in Verisoft XT deals with even more open research problems. Here, a multi-threaded virtualization layer, the hypervisor, runs multi- threaded on a multi-processor architecture with a weak memory model and is com- piled using a highly optimizing compiler. Due to the major differences in design and complexity of this task, it seems unrealistic to expect anything of CVM to be reused but the experience and knowledge gained by the people involved in this work.

