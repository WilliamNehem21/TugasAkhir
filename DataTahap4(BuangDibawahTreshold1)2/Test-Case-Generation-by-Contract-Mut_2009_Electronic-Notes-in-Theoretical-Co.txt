Based on C#, Microsoft has built the Spec# [5] system. Spec# extends C# with preconditions, postconditions, invariants, and a notion of ownership. In combina- tion with Boogie, a verification condition generator that uses Common Intermediate Language (CIL, part of [14]) code as input, and Z3 [12] as SMT-solver, capable of producing error models, a framework for automatically verifying code has been pub- lished. From contracts and implementation code, Spec#/Boogie is able to generate

counter-examples when, e.g., a postcondition can not be proved. (Due to the work- ings of Boogie the reported example may be spurious.) One obvious advantage of having a counter-example is that it can be shown to the developer, so he/she un- derstands why the contract can be broken. This approach has been pursued by the author of [7] and resulted in a tool that enables counter-example execution.

and works similar to an event based system (e.g., Event-B [20]) where each action (function) has a guard and an update statement. Within model programs, the up- date statement (i.e. the post-condition of the event) is the method body, whereas the guard is built by a slight abuse of the notion of a precondition. (Strictly speak- ing, a violation of a precondition does not forbid calling the method.) Using these guards and the postconditions in the method body, SpecExplorer does a state-space exploration to discover the transition system. Note that these model programs lack a contract-like-specified postcondition.

This paper is organized as follows. In Section 2 we repeat the most important definitions of the underlying theory and present a formula for mutation-based test case generation. In Section 3 we introduce Spec# and Boogie and show how to link the refinement check of Boogie with the test-case generation formula presented before. Next, we discuss the proposed methodology, give an example in Section 4 and evaluate difficulties arising in more complex environments in Section 5. Before concluding, we present related research.

We adopt the notion of [1,2] in that a test case is an abstraction of the system specification. Within fault-based testing, one tries to cover anticipated faults, hence we are searching for test cases that can distinguish between the correct and an incorrect specification. We adopt the standard notion that faults are results of errors (bugs), while a failure is a wrong behavior caused by a fault.

In order to generate faulty specifications from the correct one, we rely on muta- tion operations, similar to the work presented in [18]. The underlying assumption is that the developer will create an almost correct implementation and that errors will be minor deviations from the correct specification. Thus, by slightly mutating the correct specification and calculating test cases to distinguish the two versions, we cover most of the errors.

Boogie is a static program verifier that relies on the SMT-solver Z3 [12] in order to discharge the proof obligations. Boogie defines its own input language (Boogie), so different front-end systems can use Boogie for automated reasoning.  Spec# is an extension to C# and adds features for contract based program verification. Internally, Spec# relies on Boogie.

Boogie reports several counter-examples when more than one pre/postcondition does not hold. This might be, e.g., due to non-deterministic behavior of Cm that potentially violates several conditions, or in the case both, pre- and postcondition, were mutated. Adding mutated pre- and postconditions at the same time, however, is not recommended, as a mutated precondition may hide contract violations of the postcondition.

From the counter-example we now have observed the input values, and the return value of the mutated method. We still lack the expected return value according to the specification. Unfortunately, we can not observe this value directly from the error-model provided. This is because the postcondition is checked within following statement:

One of the main features of Spec# is that it is able to work with all data types offered by C#. This includes reference types, value types, as well as generic types. Spec# also comes with annotations for some parts of the .NET core library. Because Microsoft seems serious about bringing contracts to the every-day-developer, it is reasonable to expect even better contract coverage of core-libraries in future. Taking all this together makes Spec# a promising target for automated test case generation. However, the same reasons also make test case generation a complex task, which is also reflected to some part within the reported counter-example.

At different times within the computation process, these functions will return different values. This is reflected by different heap generations in the counter- example: $Heap means the initial generation that is followed by $Heap@0. (The successorship is encoded elsewhere in the counter-example.)

Besides these object-creation issues, there are more fundamental ones. For test- case generation we rely on the solving capabilities of Z3: If the solver can not prove a given verification condition, even if it is true, we will try and create a test case. However, given that we start from a proved specification and also have control over the mutation operations being performed, this case seems controllable.

testing, as, e.g., proposed in [21] can be used to generate test cases from pre- and postconditions. This work has been integrated into the latest version of the Eiffel [17] development environment. Goal is to provide the developer immediate feedback if an implementation does not adhere to the given contract. Failing test cases are stored and re-run during the next compilation cycles. Since we can modify our approach to fit the PEX methodology, we could also use random testing in order to generate discriminating test inputs. Because random testing only guarantees to find specific cases with a certain probability we did not further evaluate this combination.

