Some cryptographic protocols are vulnerable to replay attacks, a type of weakness that was a focus of attention in the Burroughs-Abadi-Needham logic. Newer, more operational approaches to protocol analysis have not concentrated on this type of attack. This paper fills the gap for the strand space theory.

In this paper we fill this gap in the strand space literature. We show how to specify the behavior of a key server so that recent keys remain un- compromised, whereas older keys may have been compromised. The famil- iar Needham-Schroeder private key protocol [13] is vulnerable in this model, whereas the Yahalom protocol [1] is not. The main technical point is to pro- vide a definition of recency. Our candidate is convenient because the strand space method already has a powerful way to prove that an event is recent, namely the incoming and outgoing authentication tests [5,7].

A supplementary purpose of this paper is to illustrate the power of the authentication tests. They provide simple and straightforward explanations of protocol correctness. We linger over several examples to illustrate the pat- terns of usage for the authentication tests. These patterns of usage are quite stereotyped, although there are several ingredients to be combined effectively.

perhaps a penetrator will cryptanalyze the conversation to recover K. In this case, the penetrator can start a session by resending the same unit {|A , K|}KB , later returning {|1+ Nb|}K. Then B will have been had. The assumption that K is good should expire when it is no longer recently generated.

Terms and Subterms  A is the set of messages that can be sent between principals. Its elements, called terms, are freely generated from two disjoint sets, T (texts such as nonces or names) and K (keys), by concatenation and encryption. The concatenation of terms g and h is denoted g , h, and the encryption of h using key K is denoted {|h|}K. (See Appendix A.3.)

The height of a strand in a bundle is the number of nodes on the strand that are in the bundle. Authentication theorems assert that if some regular strand has at least a given height in a bundle, meaning that the principal must have engaged in at least that many steps of its run, then another regular strand must have a certain height in the bundle. They often assume that certain values are uniquely originating in the nodes of that bundle.

The Penetrator  While regular principals are represented only by what they say and hear, the behavior of the penetrator is represented more explic- itly. The values he deduces are treated as if they had been said publicly. A penetrator strand represents an atomic deduction, and more complex actions use several penetrator strands. We partition penetrator strands according

to the operations they exemplify. E-strands encrypt when given a key and a plaintext; D-strands decrypt when given a decryption key and matching ciphertext; C-strands and S-strands concatenate and separate terms, respec- tively; M-strands emit known atomic texts or guesses; and K-strands emit keys from a set of known keys. The set of initially known keys, that may be emitted in K-strands, is called KP. (See Definition A.8.)

This key compromise attack is perhaps less obvious than the NSSK attack, since there is no suspicious neck in the protocol definition. However, the underlying problem is the same: B cannot verify the recency of the session key K. And the cause of the problem is the same, namely that the protocol relies on an unsolicited test rather than an incoming or outgoing test.

Our core idea is that regular strands provide a way to measure recency. Im- plementors always ensure that a protocol run will time out long before crypt- analysis could have succeeded, a matter of hours at least in the case of any usable cryptosystem. 1 Thus, a principal engaged in a strand knows that an event is recent, if it happened after an earlier event on the same strand.

