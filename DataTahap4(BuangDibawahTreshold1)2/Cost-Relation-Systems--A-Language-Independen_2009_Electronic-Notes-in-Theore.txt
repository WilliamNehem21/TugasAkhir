A first objective of this paper is to characterize the notion of CRSs and motivate its use as a common target language for cost analysis. The intuitive idea is that CRSs abstract away the particular language features and are simply an instrumen- tation of the abstracted version of the program which allows approximating its cost. Also, we characterize the notion of a CRS being correct. To do this, we need to define an evaluation mechanism for CRSs. We will see that CRSs can be formally defined independently of the programming language in which the input programs to cost analysis are written. Therefore, CRSs can be considered a lingua franca in the sense that they can be used as the target for cost analysis of any language. Hence, we argue that progress in the study of CRSs is of interest to cost analysis of any programming language.

The second objective of the paper is to present the features and challenges that CRSs bring about. As CRSs resemble Recurrence Relation Systems (RRSs) in many aspects, it has been typically assumed that the output of cost analysis are simply RRSs. We clarify the differences between CRSs and RRSs and point out the limitations of existing computer algebra systems (CAS) to handle them. Finally, the usefulness of CRSs is discussed by describing its applications in the context of performance debugging and code certification. The main contributions of this paper are:

use of different resources of interest. For instance, the Java bytecode cost analyzer of [2] can be used for observing, among other things, the number of execution steps performed, the amount of heap allocated during execution, and the number of calls to certain relevant methods. In particular, a cost model which counts the number of execution steps can be defined as Mninst(l) = 1 for any l. The cost model Mheap, which counts the number of bytes allocated on the heap has been defined in [4], where the cost model returns zero for all bytecode instructions which do not allocate memory in the heap and returns the corresponding number of bytes for those instructions which actually allocate heap space.

at approximating Cost (t, M) s.t. t corresponds to the execution which starts from s0, but without constructing t, i.e., they allow approximating the cost of a program for some input data without having to actually run the program for such data and thus avoiding such overhead. Cost analysis, and within it CRSs, fall into the second approach.

In deterministic languages, given an initial state s0, there is a unique STS which corresponds to the execution. However, in languages where a non-deterministic choice is possible, an initial state may lead to several possible STSs. This, in fact, is the case for most realistic programming languages, as they provide con- structs for random number generation and/or access to environment variables such as date/time. In order to accommodate for truly non-deterministic programming languages, from now on we consider that given an initial state s0 there is a set of different executions, with their corresponding STSs, which can be built from s0. We will refer to the set of all possible STSs for s0 as Executions(s0). In deterministic executions, Executions(s0) is a singleton.

sources we are accumulating; they are also used to represent the bounds of CRSs. As CRSs can be used to capture any complexity class, cost expressions must cover poly- nomial, logarithmic and exponential expressions and we must be able to bound its solution (by using functions max and min). We now present a language-independent definition of the notion of CRS.

(possibly infinite) possible evaluations of a call, trying to obtain a solution (or an upper bound for it) in this way is impractical. Besides, it can difficult to glean immediate information about the cost of a program by looking at its associated CRS, especially when there are multiple relations involved. As a result, CRSs have rather limited applicability unless closed form (i.e., non-recursive) solutions or bounds for them are obtained.

An important point to note is that the actual cost of executing the program for a given goal is necessarily a solution of the CRS. In principle, this makes CRSs valid tools for computing upper and lower bounds of the cost. We start by recalling the definition of upper bound of relations.

Performance Debugging and Validation. This is a direct application of cost anal- ysis, where the analyzer tries to verify or falsify assertions about the efficiency of the program which are written by the programmer. The role of CRSs is essential in order to infer the performance, either as an exact solution or upper bound.

