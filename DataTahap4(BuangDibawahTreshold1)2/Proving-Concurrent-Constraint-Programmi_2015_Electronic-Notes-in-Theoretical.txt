The connection between logic and CCP processes (and constraint systems) has been studied since its inception: in [22] a closure operator semantics is given to deterministic CCP programs that was later related to the logic of constraints in [19]. In [4] a calculus for proving properties of CCP programs is defined where properties are expressed in an enriched logic of the constraint system. The works in [20,5] relate operational steps of CCP and lcc with derivations in ILL. We can also mention the works in [13,4] that give logical semantics to timed CCP languages and provide calculi to verify temporal properties of programs. The reader may find a survey of all these developments in [18].

interpret lcc processes using pure linear logic. Hence, the encoding is more natural and direct, and we can use all the rich and already stablished meta-theory developed for linear logic to help in drawing conclusions about CCP systems. Moreover, we study different notions of observables not considered in [16] (see Definition 4.6). Particularly, we show that there are lcc computations that cannot be mimicked by the standard encoding of processes as ILLF formulas. Then, by introducing delays in the encoding, we recover the one-to-one correspondence between ILLF derivations and lcc computations. We also study the behavior of non-deterministic processes with blind and guarded choices not present in [16].

The store in CCP grows monotonically, this means that agents are only allowed to add new information but it is not possible to delete constraints from the store. In order to have a better resource control, the Linear CCP (lcc) language was proposed in [5], where constraints are seen as formulas in a fragment of intuitionistic linear logic (ILL) [8]. More precisely, the linear constraint system is redefined as follows.

The formula on the right is the head p of a process definition. Thus it has to be focused (since it will come from a focused implication formula on the left), it is positive and atomic. Hence the proof must end immediately with the initial axiom IR.

The next lemma clarifies better the above cases when formulas on the right are focused. In particular, we show how is the shape of the derivations in a proof involving banged guards and goals: such formulas are derivable by other guards and non-logical axioms only. Actually, we may state a stronger result: there is no proof of banged guards and goals if a process definition is chosen to be focused on.

Observe that the last derivation in Example 4.4 does not produce any observable store (see Definition 2.3). Hence a good question is whether it is possible to restrict the behavior of ask agents to avoid interleaved executions when we are interested in observing a given constraint, i.e., when the system exhibits an output. Fortunately, the answer is positive as shown below.

As we know, once the guard c in ask c then P is entailed, the operational se- mantics dictates that P is enabled for execution (rule RA). The semantics, however, does not enforce the immediate execution of P . Next definition gives an alternative semantics to ask agents in order to force the execution of P avoiding interleaved derivations as the ones in Example 4.4.

evolves into ask dJ then PJ not producing any constraint. Then either P will remain blocked and hence it will not be used for producing c, or dJ will be produced by some other process R and P will reduce to PJ. But in this last case, R does not depend on P , and it can be executed before. Hence the nested asks can be executed at once.	2

Remark 4.10 Observe that Theorem 4.8 gives a canonical trace to lcc success- ful computations via focusing. In this case, the guards of nested ask agents are evaluated at once to decide whether the process continues blocked or not. On the other hand, Theorem 4.9 shows that traces of a derivation in logic have a one-to-one correspondence with traces of a computation in a lcc program.

Observe that, this way, we capture well the behavior of choosing one process from the choices we have. At the same time, forcing formulas to be positive in the BC case implies that the chosen process will not block on the positive phase. On the other hand, Pi being a negative formula in the case GC, assures that the choice will be triggered only if the guard is already in the context. Hence, we continue having a neat logical control corresponding to the operational semantics and Theorem 4.9 is also valid for indeterminate CCP.

