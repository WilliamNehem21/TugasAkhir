Nevertheless, the choice of the right model checker has been a question since the beginning of the project; comparative studies on various model check- ers in the application domain are quite rare, and, thus, the decision had to be based on anecdotal case studies. Despite the success of the project, we have been wondering whether other choices would have been better. Especially, the choice between symbolic and explicit model checking is quite unclear, with only limited comparative arguments; among others, it has been argued that symbolic model checking performs better for synchronous systems with hardware-like characteristics and explicit model checking is better for asyn- chronous systems with a number of communicating processes. Many reports have pointed out, however, that a direct comparison of the two techniques is very difficult, if not impossible [1,7,16]. Some experiments report that a symbolic model checker performs better even for asynchronous systems [7], contradicting some of the arguments.

Furthermore, a system can have both synchronous and asynchronous as- pects depending on which part we are interested in and how we interpret the system behavior. For example, the FGS system consists of two FGSs, an ac- tive FGS and a passive FGS for back-up, running in parallel. The system is an asynchronous system when we consider its two communicating processes running in parallel; it can be interpreted as a synchronous system, with the complex mode logic complex enough to challenge the capability of the model checking technique, when we focus only on the mode logic of one-side FGS.

The remainder of this paper is organized as follows: Section 2 discusses existing related work focusing on the comparison of symbolic and explicit model checking techniques. Section 3 introduces our motivation with a brief description of the existing work related to model checking Flight Guidance Systems. Section 4 describes our direct and modular translations to the SPIN model with their performance data. We conclude with a discussion about the implication of the result in Section 5.

Eisner and Peled examined another well-known argument that symbolic model checking is better for hardware systems and explicit model checking is better for software systems in verifying the software of a disk controller using the symbolic model checker RULEBASE and the explicit model checker SPIN [7]. Their result shows that RULEBASE is able to model check a 2- process system with 10150 states, while SPIN spaces out after checking 108 states with 2G of memory. This result is not favorable to the argument that explicit model checking performs better for software verification, especially for communicating processes.

macros. Note that RSML-e provides macro and function constructs to improve the readability of specifications. In the FGS specifications, macros are exten- sively used as an alternative representation of synchronous events which, in the end, provide a concise way to specify system properties in temporal logic 2 . Since macros encapsulate complex mode logic, the use of macros in tempo- ral logic specification tremendously simplifies logic expression, which plays a crucial role in enhancing the usability of model checking.

From the experience, it becomes clear that symbolic model checking can be very powerful and also usable, but only up to a certain point. The technique is based on exhaustive state-space search and does not provide alternative options when it reaches its limitation. On the other hand, explicit model checking usually provides more flexibility in dealing with a large state-space, sometimes trading off exhaustiveness for efficiency. Our hope is that the flex- ibility of explicit model checking may be able to provide us a certain level of verification capability even for larger systems that symbolic model checking is not capable of handling. We set up two goals of the investigation to realize (or nullify) our hope; the first is to check the possibility of using the explicit model checker SPIN for verifying FGSs, and the second is to come up with a systematic approach of translating RSML-e to the input language of SPIN to support full automation and better usability, if the first goal turns out to be achievable.

We start from a translation of the RSML-e model of one-sided FGSs with invariants to the input language of SPIN, Promela. Our intuitive hypothe- sis is that SPIN must be able to handle the synchronous one-sided FGSs in order to be scaled to the two-sided asynchronous FGSs. Our first attempt of a direct translation turns out to be too inefficient for model checking. To achieve better performance, we adopt modularization and encapsulation by utilizing the SPIN message passing mechanism and by modifying macros to cope with the structural change. The result of the change is quite promising; it

Input variables and message channels are declared as global variables in Promela, since those are to be accessed by both the FGS model and the en- vironment model. FGS state variables as well as their corresponding history variables are translated into local variables in the FGS process, and their tran- sition relation is translated with the Promela if statement. User defined enu- meration types are translated to the Promela mtype. Macros are declared as C-style macros in Promela; SPIN performs pre-processing for C-style macros, and, thus, does not introduce additional variables for macros.

Though the basic translation is straightforward, there exist a couple of Promela-specific issues: First, the environment of the system must be explic- itly specified. This means that we have to model the possible values for all 13 input variables in a non-deterministic way to simulate the random inputs from the open environment. Second, in order to model the FGS with only one side, we also have to explicitly model the possible inputs from the other FGS with constraints. Luckily, the modeling of the pure non-deterministic input is relatively simple for boolean or enumeration variables, since the Promela

Nevertheless, Promela does not support imposing invariants on the model itself, and, thus, imposing constraints on the non-deterministic input values from the other side FGS can be quite tricky. One way is to restrict the non-deterministic value assignment with the constraints and check that the constraints are actually satisfied by the model using the assertion statement or the LTL verifier. For example, the following is an assumption to be satisfied in the input values from the other side FGS and the way it is imposed in NuSMV as an invariant.

Verification is performed on a 800 MHz Linux machine with 768 M of memory. We set the memory limitation to 600 M in SPIN. With the hash-compact option with compression, the verification process terminates using up 625M of actual memory after 24 minutes. The maximum search depth was set at 1,000,000 and yet, SPIN reported the search depth as being too small. The situation is similar or worse with other SPIN verification options. The result

The major source of the state-space explosion of the directly translated version of the FGS is the large number of global variables, mainly the input variables and their history variables, in addition to the large number of local state variables in the FGS process. Especially, global variables are expensive in SPIN verification since SPIN needs to keep track of all their values in the state transition graph. To optimize the performance, we look into mechanical ways to minimize the number of variables, both global and local variables. Note that one of our goals in this investigation is to support a usable verification process in practice, and, thus, any modification of the original model for the purpose of optimization needs to be systematic so that it can be automated in future work.

One possible way of dealing with such a usage of macros is to pre-process all the macros by replacing all the references to a macro in the specification with their value expression. The macros, however, are specified by practitioners in a way to match their languages used for communicating with pilots, and many of the properties (98 out of 298) to be verified are specified in terms of marcro names. Therefore, we do not want to change them if it is not really necessary 4 .

Our experiment reveals that SPIN performs poorer than NuSMV on the one-sided synchronous FGS model than NuSMV, but scales better to asyn- chronous two-sided FGSs once we manage to handle the one-sided FGS. Nev- ertheless, we do not intend to put an emphasis on the performance differences because of two major reasons; (1) the result of using SPIN can be unsound because of the use of the bit-state hashing option, and (2) the performance can be highly dependent on the level of optimization performed by the modeler. We believe that our initial optimization approach is just a starting point, and far better optimization is possible as we gain better knowledge on the model checker. We also do not rule out the possibility of using NuSMV for the two-sided FGSs by using aggressive optimization and/or abstraction in the future.

