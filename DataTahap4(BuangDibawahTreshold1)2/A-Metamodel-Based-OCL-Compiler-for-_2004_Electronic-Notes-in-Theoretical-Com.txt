After a discussion of related work and a number of preliminary issues in Sections 2 and 3, the general architecture of the OCL compiler is introduced in Section 4. Section 5 discusses the alignment of OCL to UML and MOF. The code generation is presented in Section 6. We conclude by summarizing the results of our work and give a short outlook about our future work in section 7.

Based on version 1.3 of the OCL specification, our group has already devel- oped the Dresden OCL Toolkit [4,5,3,13]. It features a modularly structured OCL compiler that provides a set of interfaces for easy enhancement and in- tegration into different software engineering environments. With the toolkit it is possible to process preconditions, postconditions, and invariants on UML models. Code generators have been developed for Java and the Structured Query Language (SQL) and the usage of the toolkit within several projects, partly in conjunction with partners in industry, has led to extensive tests and eventually to a solid foundation for OCL support. In our current work, we use artifacts from this earlier toolset, e.g. an OCL Basis Library.

[10] describes the USE tool, which can evaluate OCL expressions over UML models. It provides functionality to describe models on a textual basis and associated OCL expressions and to create instances, so-called snapshots, of them. The OCL expressions are evaluated based on these snapshots. Basically, these models can also be metamodels and therefore can be subject to OCL expression evaluation. Differences between the OCL expression evaluation in

[10] and our tool concern the used metamodels and the kind of OCL expression evaluation. Whereas USE is based on a small core of the UML and a precursor of the OCL metamodel, our tool is based on proposed and accepted standards of the Object Management Group (OMG). Furthermore, in contrast to our toolkit, USE does not generate code for the evaluation of OCL expressions but uses interpretation.

This section discusses some preliminary issues concerning terms and technolo- gies used throughout this paper. The discussion is centered around the MOF metadata architecture, which is introduced first. Terms like XML Metadata Interchange (XMI) and Java Metadata Interface (JMI) are explained subse- quently.

MOF meta-metamodel. This meta-metamodel, or MOF model, is object- oriented and includes an essential set of modeling constructs aligned with a specific subset of UML object modeling constructs. The MOF model on its part is self-describing, i.e., it is formally defined using its own metamodelling constructs.

OCL is defined by a metamodel with dependencies to elements of the UML metamodel and allows to write OCL expressions for UML models, which reside on layer M1. Since metamodels on M2 layer are instances of the MOF model but OCL is rather designed to write expressions for models on M1 layer, the specification of WFRs by OCL would not be possible without having an adapted OCL metamodel for MOF. Section 5 describes how to adapt the original OCL metamodel in order to be used for the specification of WFRs on M2 layer.

The MOF metadata architecture provides the foundation for the defini- tion of XMI, which describes a standard for the exchange of models among software engineering tools. XMI comprises DTD 4 and document production rules. The DTD production rules are used to describe the generation of DTDs from metamodels (M2) whereas the document production rules describe the generation of XML documents from actual models (M1). The XML documents containing the UML metamodel and MOF model for example are provided by

XMI enables the exchange of data between tools. For tools to share data located in a common repository, JMI and the MOF-IDL mapping provide the technology to generate interfaces from arbitrary metamodels (M2) which are then used to access according instances (M1) or to perform necessary operations on them. Whereas JMI describes the production of Java interfaces and is not part of the OMG standards, the MOF-IDL mapping is part of the MOF specification and describes the production of CORBA-IDL interfaces.

ICommon is a set of JMI interfaces that enable access to instances of the OCL metamodel in a transparent way, independent of MOF or UML. They abstract common concepts of IMofOcl and IUmlOcl. Details about the com- mon interface and its relations to UML and MOF are described in section 5.1.

To realize this architecture, we had to make a decision on what MOF repository to use for our toolset. After an evaluation and comparison of several MOF repository implementations we decided to use the NetBeans Metadata Repository [6]. This product is part of the NetBeans Integrated Development Environment, but can be used as a standalone tool as well.

This section discusses the alignment of OCL to MOF and UML. After a dis- cussion of the differences between MOF and UML core, we introduce an ab- stract interface that allows to access instances of the OCL metamodel inde- pendently of the UML-specific or MOF-specific metamodels. We then present an adapter-based solution for the mapping between MOF and OCL datatypes. Finally, we show how the WFRs of OCL can be decoupled from the internal structure of the UML.

There is a similar concept in MOF, but it is not modeled by a separate class. There is for example an Association between EnumLiteralExp in the OCL metamodel and EnumerationLiteral in the UML metamodel. MOF knows the concept of enumerations as well, but there is no separate class for enumeration literals. Rather, enumeration literals are stated by

Whereas the metaclasses of MOF and UML core are generally quite similar, the associations between them are very different. Since the WFRs of the OCL metamodel and the rules for the abstract syntax mapping navigate along such internal associations of the UML metamodel, they cannot be directly applied to MOF. Therefore, Section 5.3 introduces additional operations in the MOF/UML abstraction layer that encapsulate internal navigations through the UML metamodel.

3. Common-OCL is the central element of the abstraction. It can be accessed through the ICommon interfaces, which are generated from this package re- spectively from the contained classes by the MOF repository. Common-OCL comprises CommonModel on the one hand and the Expressions and Types packages on the other hand. The package CommonModel provides abstrac- tions for the UML metaclasses that are used by the Expressions and Types packages of the OCL metamodel. The latter do not exclusively exist within Common-OCL but also within the individual OCL metamodels aligned to MOF and UML, which are contained within MOF-OCL and UML-OCL. Classes from the individual OCL metamodels inherit from the according abstract classes in Common-OCL and have relations to respective classes of the MOF or UML metamodel. The reader should be aware that instances of the OCL metamodel are either instances of MOF-OCL or UML-OCL.

The package UML-OCL contains the OCL metamodel defined in [1]. It has dependencies on the UML metamodel due to association and generalization relationships. The packages UML and UML-OCL serve as the basis for generating IUmlOcl. These interfaces are accessed, for example, by a code generator for OCL expressions in UML models.

association between Classifier and Operation in the UML metamodel 6 , CollectionType in UML-OCL inherits from UML::Core::Classifier. In CommonModel, there is no association between Classifier and Operation, because an according association would not model the reuse of the already ex- isting association in UML properly. Instead, the operations are made accessible by defining the additional operation lookupOperation() for Classifier.

MOF defines its own datatype schema, providing metaclasses for constructing primitive types, structured types, collection types, and enumeration types. With the exception of primitive types like Integer and String, all types are user- defined. In contrast to the datatypes defined in the OCL Standard Library, the MOF datatypes cannot have any operations, because they do not inherit from MOF::Model::Class. Consider, for example, a metamodel containing a class A that has an attribute x of type Integer. To represent a simple OCL constraint like

While it was necessary for primitive types to introduce an adapter (AdPrimitive), this is not the case for CollectionType and TupleType. In- stead, the according classes from MOF-OCL::Types are used directly. They inherit from their counterparts in Common-OCL as well as from AdDataType. For mapping of collection and structure types, the types of the elements or fields need to be mapped as well. This is done by using the previously defined operation toOclType().

As already mentioned in Section 5.1.1, EnumerationType needs special treatment, because the OCL metamodel expects enumeration literals to be modeled by a separate class whereas MOF models literals as the multivalued attribute labels in EnumerationType. The mapping is realized by introduc- ing two adapter classes, namely AdEnumeration and AdEnumerationLiteral. The following constraint describes the relation between an EnumerationType and the associated adapters:

The well-formedness rules of the OCL metamodel navigate along internal as- sociations of the UML metamodel and access attributes defined in UML meta- classes. Due to these dependencies with UML, the WFRs cannot be applied directly to MOF-OCL or Common-OCL.To decouple the WFRs from the in- ternal structure of the UML metamodel, we introduce additional operations for the CommonModel classes. Note, that this kind of decoupling is useful to ease the alignment with UML 2.0 as well. As long as there are only changes in the UML metamodel, but not in OCL, the WFRs do not need an update. Only the helper operations have to be aligned, because they essentially give a complete definition of the interface between OCL and UML.

The definitions are different, because in the first case self.type means a navigation from UML::Core::Attribute to UML::Core::Classifier but in the second case from MOF::Model::Attribute to MOF::Model::Classifier. As described in the previous chapter, the type of the attribute is mapped to the according OCL type by the toOclType() operation.

The generated code uses the method ifThenElse(), which is defined in OclBoolean. This method has the return type OclRoot, the common superin- terface of all classes in the OCL Basis Library. Thus, it is necessary to insert a type cast into the code, which yields the proper type of the IfExp. The op- eration getId() results in the identifier for the IfExp that has been created before by createId().

We can already present a prototype of the metamodel-based OCL com- piler that comprises the MOF repository implementation and the presented code generator by which we can demonstrate the code generation for selected WFRs. At the moment, a parser module is under development based on the current proposal for the OCL specification. We are investigating, to which ex- tent a parser can be generated automatically from the provided specification. For concepts to be applied in practice, efficient tool support is essential.

