The paper is organized as follows: In Section 2 we present the new version of rule Val and discuss how it differs from its predecessors. In Section 3, which is the heart of paper, we describe the new method of invariant generation. In Section 4 we describe a new computation of data mapping that the new invariants generation entails. We conclude in Section 5.

Other approaches [8,11] considered translation validation of less restricted lan- guages than considered in [9], allowing, for example, nested loops. They also consid- ered a more extensive set of optimizations. However, the methods proposed there were restricted to structure preserving optimizations, and could not directly deal with more aggressive optimizations that involve code motion or loop reordering transformations.

Tvoc-sp computes invariants by fixed-point computations depending on reach- ing definitions. For this code, Tvoc-sp cannot establish valid verification conditions since it cannot generate the invariant N3 = 500 at location 5. The invariant com- putation presented in the next section can trivially detect this invariant.

Invariant generation is the most challenging task in the application of Val. In this section we describe a new invariant generation method, that operates on IR programs in SSA form. Since the data-flow based method currently implemented in Tvoc is purely syntactic, and the new method is also semantic, we believe it to be both more efficient and to generate more information than the data-flow based method.

Finally, whether x is or is not a loop header, gen(x) holds after block x is executed. Therefore, out(x, G) is a conjunction of in(x, G) with gen(x). Since we assume that in(x, G) is sound, the soundness of out(x, G) follows.	 It thus follows from Theorem 3.1 that for every initial location i of the cfg

succeeds in determining this, our method, that does not propagate information it- eratively, cannot. Similarly, in the code in (b), ai = bi is invariant in all cutpoints where ai and bi are defined. While the value numbering algorithm of [1] succeeds in determining this, our method, being unable to proceed around loops, cannot.

Our technique may also be useful in proving properties of microcode. E.g., [2] describes a tool for proving backward compatibility of microcode. The microcode there is assumed not to contain loops. Our technique may allow for extending the work to microcode programs with loops. (In fact, our technique orignated with the work on the project reported on in [2].) In addition, we expect the techniques to be applicable to property verification of microcode programs.

L. Zuck, A. Pnueli, B. Goldberg, C. Barrett, Y. Fang, and Y. Hu. Translation and run-time validation of loop transformations. Journal on Formal Methods in System Design, 27(3), 11 2005. Preliminary version appeared in Proceedings of the Run-Time Result Verification Workshop, Electronic Notes in Theoretical Computer Science (ENTCS), 2002, 70(4).

