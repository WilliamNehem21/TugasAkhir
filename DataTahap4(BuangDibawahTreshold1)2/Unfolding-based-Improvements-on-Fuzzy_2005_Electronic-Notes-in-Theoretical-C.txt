Unfolding is a semantics-preserving program transformation technique that consists in the ex- pansion of subexpressions of a program using their own definitions. In this paper we define two unfolding-based transformation rules that extend the classical definition of the unfolding rule (for pure logic programs) to a fuzzy logic setting. We use a fuzzy variant of Prolog where each program clause can be interpreted under a different (fuzzy) logic. We adapt the concept of a computation rule, a mapping that selects the subexpression of a goal involved in a computation step, and we prove the independence of the computation rule. We also define a basic transformation system and we demonstrate its strong correctness, that is, original and transformed programs compute the same fuzzy computed answers. Finally, we prove that our transformation rules always produce an improvement in the efficiency of the residual program, by reducing the length of successful Fuzzy SLD-derivations.

Logic Programming [12] has been widely used for problem solving and know- ledge representation in the past. Nevertheless, traditional logic programming languages do not incorporate techniques or constructs in order to treat explic- itly uncertainty and approximated reasoning. Fuzzy Logic provides a mathe- matical background for modeling uncertainty and/or vagueness. Fuzzy logic relays on the concept of fuzzy set, the theory of fuzzy connectives (t-norms, t-conorms, etc.) and the extension of two-values classical predicate logic to a logic where formulas can be evaluated in the range of the [0, 1] real interval (see [22] or [13] for a comprehensive introduction of this subject). Fuzzy sets

Fuzzy Logic Programming is an interesting and still growing research area that agglutinates the efforts to introduce Fuzzy Logic into Logic Program- ming. During the last decades, several fuzzy logic programming systems have been developed, where the classical inference mechanism of SLD-Resolution is replaced with a fuzzy variant which is able to handle partial truth and to reason with uncertainty. Most of these systems implement the fuzzy resolu- tion principle introduced by Lee in [10], such as the Prolog-Elf system [4], Fril Prolog system [2] and the F-Prolog language [11].

On the other hand, there is also no agreement about which fuzzy logic must be used when fuzzifying Prolog. Most systems use min-max logic (for mod- eling the conjunction and disjunction operations) but other systems just use Lukasiewicz logic [7]. Other approaches are parametric with respect the inter- pretation of the fuzzy connectives, letting them unspecified to obtain a more general framework [21]. Recently, it has been appeared in [20] a theoretical model for fuzzy logic programming which deals with many values implications. Finally, in [19] we find an extremely flexible scheme where, apart from intro- ducing negation and dealing with interval-valued fuzzy sets [8], each clause on a given program may be interpreted with a different logic. In this paper, we

The outline of this paper is as follows. In the next section, we summarize an extension of the fuzzy Prolog dialect described in [21]. In the new extension, that we call f-Prolog, each program clause can be interpreted under a different logic. Section 3 presents the operational semantics of our language. Moreover, in Section 4, we also adapt the concept of a computation rule and we prove a result which is the fuzzy counterpart of the independence of the computation rule theorem demonstrated in [12]. In Section 5 we define two unfolding- based transformation rules for a labeled mark variant of f-Prolog whereas in Section 6 we prove its main theoretical/practical properties. Finally, we show our conclusions in Section 7.

rule can be applied to obtain [[et1]](q, [[et2]](r1,... , rn)), the truth degree of the goal G. We need a mechanism in order to remenber that a program rule was applied in former steps, since it is necessary to distinguish when to apply [[et1]] or [et2]]. In [21] a context grammar was introduced to solve this problem. This

As for the classical SLD-Resolution calculus, we assume the existence of a fixed selection function, also called fuzzy computation rule, deciding, for a given goal, which is the selected lf-expression to be exploited in the next fuzzy SLD-Resolution step. For instance, when building the f-derivation shown in Example 3.3, we have used a computation rule similar to the left to right selection rule of Prolog but delaying the application of the [[et1]] and [[et2]] resolution rules until all atoms have been resolved. Given a fuzzy compu- tation rule R, we say that a fuzzy SLD-derivation is via R if the selected lf-expression in every step is obtained by the application of the mapping R to the corresponding goal in that step. In the following section, we stablish in our fuzzy setting the independence of the computation rule proved in [12] for the pure logic programming case.

extension of unfolding, by considering the complete set of fuzzy SLD-resolution rules in Definition 3.1 (when performing symbolic computation steps) in order to generate all alternative clauses. However, a deeper look at Definition 3.1, reveals us that only rules 1 and 2 reproduce the essence of classical logic programming by exploiting atoms and generating unifiers and, in this sense, they are more appropriate to be used during the unfolding process to simulate the original definition. On the other hand, rules 3 and 4 neither reduce atoms nor produce unifiers, but simply perform numerical manipulations to produce truth degrees (what, in some way, reflects the fuzzy component of this enriched context). Therefore, rules 3 and 4 should be more appropriately used for defining other kind of transformations (as we will see in Definition 5.3).

In this paper we adopt this new point of view and in the next two sections, we define a set of program transformations based on (fuzzy variants of) the classical unfolding operation for pure logic programs defined in [17]. We also prove their strong correctness, i.e., they are sound and complete w.r.t. the semantics of fuzzy computed answers obtained by fuzzy SLD-resolution.

of including marks and real numbers in the body of lf-Prolog clauses (which intuitively have the same structure of any initial, intermediate or final goal appearing in fuzzy SLD-derivations). This implies that any f-Prolog program is also a lf-Prolog program, although the contrary is not always true (i.e., the set of f-Prolog programs is a proper subclass of the set of lf-Prolog programs). Apart from this simple fact (which, on the other hand, is mandatory to define the fuzzy SLD-resolution principle) both languages share the same operational semantics.

the T-Norm replacement of kind 3 has never been considered in the literature, neither implicitly nor explicitly (although it was proposed as future work in [5]), and its application is able to transform a non unit program clause into a fact (i.e., a clause with empty body). Observe that no other transformation has this capability, which indirectly imply that, in the best case, although programs to be transformed by this transformation must necessarily belong to the lf-Prolog superclass, once transformed by T-Norm replacement of kind 3, they may recover the f-Prolog syntax.

derivation for G in P' that we plan to simulate by constructing a new deriva- tion D in P. The construction of D is done by induction on the length of D', n. Since the case base, i.e. n = 0, is trivial, we proceed with the general case when

Now, and similarly to the previous theorem, we are going to simulate D in P' by constructing a new derivation D' using the clauses of P' and fol- lowing an schema perfectly analogous to the one used in Theorem 6.2, but inverting now the use of terms P and P' (and related ones). The construc- tion of D' is done by induction on the length of D, n. Since the case base,

After an inspection of the main proposals for the inclusion of fuzzy logic into a logic programming setting, we have selected an extension of the language described in [21], that we call lf-Prolog, since we think it is the best suited to deal with the problems that may arise in the transformation process of logic programs. It is remarkable that lf-Prolog is provided with a labeled mark language. Inspired in [19], we have extended this language in order to be able to code different fuzzy logics inside the same program, which greatly enhances the expressive power of the former language. Also, as an auxiliary result, we have established the independence of the Fuzzy Computation Rule for lf-Prolog programs and goals (Theorem 4.4).

