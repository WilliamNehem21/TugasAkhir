Operation calls The call op(v; y. c) passes a parameter value v (e.g. the memory location to be read) to the operation op, and after op performs the effect, its result value (e.g. the contents of the memory location) is bound to y and the evaluation of c, called a continuation, resumes. However, note that encompassing handlers may override this behaviour.

This handler works as follows: whenever read is called, we ignore its unit parameter and capture its continuation in a function k that expects the resulting string and resumes the evaluation when applied. Next, instead of calling read, we evaluate the computation in the handling clause: we resume the continuation k, but instead of reading the string from interactive input, we yield the constant string s. The handler implicitly continues to handle the continuation, so any read in the handled computation again yields s. If the handled computation calls any operation other than read, the call escapes the handler, but the handler again wraps itself around the continuation so that it may handle any further read calls. For example, evaluating

When a computation returns a value x, there will be no further printouts, so we can return the given accumulator acc in addition to x. But if print is called, we resume the continuation by yielding it the expected unit result. Since the continuation is further handled into a function, we need to pass k () the new accumulator, which is acc extended with s. To obtain the collected output of a computation c, we apply the resulting function to the empty accumulator as:

Exception handlers are, of course, a special instance of handlers. We represent exceptions with an operation raise that takes an exception argument (e.g. error message) and yields nothing to the continuation (for more details on how this can be enforced, see Example 4.1).

Then, with backtrack handle pythagorean (m, n) finds (5, 12, 13) for (m, n)= (4, 15) but fails for (m, n) = (7, 10). The exact triple found depends on the implementa- tion of the handler. If, instead, we first tried yielding false, the resulting triple for (m, n)= (4, 15) would be (9, 12, 15). To get a list of all possible triples, we can use the handler pickAll from Section 2.3.1, but extended with a clause that handles fail with an empty list.

We represent state with operations set for setting the state contents, and get for reading them. For simplicity, we assume a single memory location that holds an integer. So, set takes an integer, stores it, and returns a unit result, while get takes a unit parameter, reads the stored integer, and returns it.

We can use handlers to temporarily alter the stored value or to log all updates. But we can also use them to implement stateful behaviour even if we do not assume a built-in one. Like in Section 2.1.3, we use a parameter-passing handler to pass

To make the intuition about the behaviour of computations concrete, we now give an operational semantics. The idea behind it is that operation calls do not perform actual effects (e.g. printing to an output device), but behave as signals that prop- agate outwards until they reach a handler with a matching clause. For simplicity, any operation call that escapes all handlers will be treated as a terminating com- putation, i.e. one that does not further reduce. We can assume that actual effectful behaviour is simulated by an outermost handler, or consider one of the approaches listed in Section 6.5.

Call-by-push-value [12] is an evolved version of the fine-grain call-by-value approach. Though the latter was used in this tutorial as it is closer to the more familiar call- by-value, a significant part of the recent work on algebraic effects uses the former. To compare given operational semantics and effect system to ones done in a call-by- push-value setting, see [10], while for denotational semantics and reasoning, see [22].

The list of examples in Section 2 is by no means exhaustive. For more involved ex- amples that include multi-threading, delimited continuations, selection functionals, text processing, resource management, efficient backtracking, or logic programming, see [5,10,6,25]. A number of implementations of handlers has also sprung up, either as independent languages [3,14], or as libraries in existing languages [10,6,25]. More recently, a multicore [2] branch of OCaml [1] has started adopting handlers as a way of implementing concurrency primitives.

