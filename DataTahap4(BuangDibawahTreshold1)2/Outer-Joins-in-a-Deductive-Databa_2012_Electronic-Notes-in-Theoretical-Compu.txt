Outer joins are extended relational algebra operations intended to deal with unknown information represented with null values. This work shows an approach to embed both null values and outer join operations in the deductive database system DES (Datalog Educational System), which uses Datalog as a query language. This system also supports SQL, where views and queries are compiled to Datalog programs. So, as SQL statements are ultimately solved by a Datalog engine, it became a need to integrate null-related operations into Datalog in order to support a wider set of SQL. Since DES implements a top-down-driven bottom-up stratified fixpoint computation based on tabling for solving Datalog queries, we show how to compute outer joins in such a context by means of source-to-source transformations applied to Datalog programs.

Deductive database systems include a form of the Datalog language, which has become the de-facto standard deductive database query language. There have been many versions of this language (pure Datalog, Datalog with negation, un- interpreted function symbols, disjunctive heads, constraints, . . . [20]), and sev- eral deductive systems have emerged along time, mostly born from academic efforts. See, among others, DLV [17], XSB [26], bddbddb [16], LDL++ [2],

Organization of this paper is as follows: Section 2 introduces DES and its query languages: Datalog and SQL. Section 3 describes the tabling-based solving that DES implements which is used to compute outer joins. Section 4 introduces null values, their representation, how they are handled, and the outer join operations allowed in the system from a user viewpoint. Section 5 shows how it is possible to solve outer joins via program transformations and including native support for nulls. As well, points to drive the proposed program transformation technique to other systems are also given in Section

DES implements Datalog with stratified negation as described in [30] with safety checks [30,31]. Stratified negation broadly means that negation is not involved in a recursive computation path, although it can use recursive rules. The system can compute a query Q in the context of a program that is re- stricted to the dependency graph (which shows the computation dependen- cies among predicates) built for Q so that a stratification can be found. This means that, even when a program could be actually non-stratifiable, a query

SQL DQL statements are translated into and executed as Datalog pro- grams (basics can be found in [30]), and relational metadata for DDL state- ments are kept. Submitting a DQL query amounts to 1) parse it, 2) compile to a Datalog program including the relation answer/N with as many argu- ments as expected from the SQL statement, 3) assert this program, and 4) submit the Datalog query answer(X), where X are N fresh variables. After its execution, this Datalog program is removed. On the contrary, if a DDL statement defining a view is submitted, its translated program and metadata do persist. A DML statement including either a WHERE condition for filter- ing or a SELECT data source is translated into a Datalog query and program, so that results obtained from executing this query are used to modify base relations, depending on the statement (DELETE, UPDATE, or INSERT).

[11] in the sense that, in addition, it deals with negation, undefined (although incomplete) information, nulls and aggregates, also providing a more efficient tabling mechanism (however, this system does not pretend to be competitive with current implementations but a system capable of showing the nice as- pects of the more powerful form of logic we can find in Datalog systems w.r.t. relational database systems).

For non-stratifiable programs (cf. next subsection), it is also possible to infer both a positive and a negative fact for a given call. Then, an undefined fact replaces the contradictory information. The implementation simply re- moves the contradictory facts and informs about the undefinedness. However, the current algorithm for determining undefinedness is incomplete as this fea- ture is only kept for teaching purposes on rather small examples (for instance, XSB includes a complete implementation of the well-founded semantics which deals with undefined facts).

Unknownness has been handled in relational databases long time ago because its ubiquitous presence in real-world applications. Despite its claimed dan- gers due to unclean semantics (see, e.g., the discussion in [10]), null values to represent unknowns have been widely used. Including nulls in a Datalog system conducts to also provide built-ins to handle them, as outer join opera- tions. DES includes the common outer join operations in relational databases, providing the very same semantics for outer join operators ranging over null values, which are described next.

