Handling infinite objects is a typical feature of lazy (functional) languages. Although reductions in Maude [5,6] are basically innermost (or eager), Maude is able to exhibit a similar behavior by using strategy annotations [18]. Maude strategy annotations are lists of non-negative integers associated to function symbols which specify the ordering in which the arguments are (eventually) evaluated in function calls: when considering a function call f (t1,... , tk), only the arguments whose indices are present as positive integers in the local

Nevertheless, the absence of some indices in the local strategies can also jeopardize the ability of such strategies to compute normal forms. For in- stance, the evaluation of the expression s(0) + s(0) w.r.t. Example 1.1 using Maude 3 yields the following:

In [8], we have introduced two new commands (norm and eval) to make techniques i and ii available for the execution of Maude programs. In this paper we show how we have brought on-demand strategies into Maude. Be- fore entering into details, we show how negative indices can improve Maude strategy annotations.

As we show below, on-demand strategy annotations can solve this problem. In fact, the use of the strategy (-1 0) for symbol s, declaring its first argument as evaluable only on-demand, permits to recover the desired behavior while keeping termination of the program (see Examples 4.1 and 4.2 below).

In this paper, we furnish Maude with the ability of dealing with on-demand strategy annotations. The reflective capabilities of Maude are the key for build- ing such language extensions, which turn out to be very simple to use thanks to the infrastructure provided by Full Maude. Full Maude is an extension of Maude written in Maude itself, that endows Maude with notation for object- oriented modules and with a powerful and extensible module algebra [5]. Its design, and the level of abstraction at which it is given, make of it an ex- cellent metalevel tool to test and experiment with features and capabilities not present in (Core) Maude [9,10,5]. We make use of the extensibility and flexibility of Full Maude to permit the use of both red (the usual evaluation command of Maude) and norm (introduced in [8]) with Maude programs using on-demand strategy annotations.

that is, we try to reduce one of the subterms in positions with (consumed or present) negative indices. All consumed indices (positive and negative) are kept associated to each symbol in the term using an extra strategy list, so that demanded positions can be searched. See [1] for a formal description of the procedure and for details about why the memory list is necessary compared to other frameworks for negative annotations as OBJ3 [15] and CafeOBJ [20,21]. In this paper, we do not consider AC symbols or rules with non-linear left-hand side. Furthermore, strategy annotations are explicitly prohibited for AC symbols (see [13,14]) and the completeness of evaluation with strategy annotations is only guaranteed for linear left-hand sides and constructor-based

All these functionalities are very useful for metaprogramming, and in par- ticular when building formal tools. Moreover, Full Maude provides a powerful setting in which additional facilities are available, making the addition of new commands or the redefinition of previous ones, as in this paper, simpler. The specification of Full Maude and its execution environment can then be used as the infrastructure on which building new features.

As for other commands in Full Maude, we may define the actions to take when the new commands are used by defining its corresponding meta-function. For instance, a red command is executed by appropriately calling the met- alevel metaReduce function. In order to furnish Maude with on-demand eval- uation we provide a new metalevel operation metaReduceOnDemand which ex- tends the reflective and metalevel capabilities of Maude, as explained in Sec- tion 3. The operation metaReduceOnDemand takes arguments of sorts Module,

OpDeclSet and Term, and returns a term of sort ResultPair. Its arguments represent, respectively, the module on which the reduction takes place, the operation declarations in such a module, and the term to be reduced. The result returned is as the one given by metaReduce (see Section 3). Note that (Core) Maude cannot handle negative annotations, and therefore, the function takes a valid module, i.e. a module without negative annotations, and the set of operation declarations with any kind of annotation. The redefined com- mand red must then select between metaReduce and metaReduceOnDemand depending on whether negative annotations are present or not.

When an index 0 is found, the function procStrat attempts to match the term against the left-hand sides of the rules using the metalevel function metaApply. 4 If there is a match, then the rule is applied. If no match is ob- tained, then we determine if any demanded position exists using the function procStratOD, which performs a matching algorithm to detect which positions under negative annotations are actually demanded by some rule (see [1] for details). If a demanded position exists, then the evaluation of such a position is started, and then we will retry the matching against the left-hand sides of the rules after the evaluation is completed. If no demanded position exists, the current index 0 is removed from the strategy list and the rest of the strategy list is considered.

When the function procStratOD is executed, i.e. when a demanded posi- tion is being searched, the computational model of [1] specifies that the search order defined by the position order in the strategy must be followed, i.e. if (-1 -2 0) is the strategy for symbol . , then any demanded subterm un- der the first argument would be selected first, despite any demanded subterm under the second argument (see [1] for details).

Once implemented the function metaReduceOnDemand, we need to rede- fine parts of Full Maude so that the command red can be able to execute metaReduce or metaReduceOnDemand. There is no need to define a new com- mand and extend Full Maude to accept that command, as it was done for norm and eval commands in [8]. We just need to modify the way the red command is processed.

In the current version of Maude, input/output is accomplished by the pre- defined LOOP-MODE module, which provides a generic read-eval-print loop. In the case of Full Maude, the persistent state of the loop is given by a single object of class Database which maintains the database of the system. This object has an attribute db, to keep the actual database in which all the mod- ules being entered are stored (a set of records), an attribute default, to keep the identifier of the current module by default, and attributes input and output to simplify the communication of the read-eval-print loop given by the LOOP-MODE module with the database. Using the notation for classes in object-oriented modules we can declare such a class as follows:

The module DATABASE-HANDLING defines the behavior of the database upon new entries. The behavior associated to commands is managed by rules de- scribing transitions which call the function procCommand. For example, the rule defining what to do when the red command is received is as follows.

When a red command is entered, the parsing of the input returns a term of the form red_.[T], where T is a variable of sort T representing a bubble. The result of the parsing is placed in the input attribute of the database object. The function procCommand specifies what to do when the term red_.[T] is received, with MN and DB variables with values the name of the current default module and the state of the database, respectively. In the original case of the command red, procCommand calls the function procRed with the appro- priate arguments, namely the name of the default module, the flatten module itself, the bubble representing the argument of the command, the variables in the default module, and the database. Note that depending on whether the default module is a built-in or not, and whether it is compiled or not, procCommand will do different things, so that the arguments for procRed are obtained. In the redefinition for command red, procCommand calls a new function procReduceOnDemand which redefines procRed.

As explained along the paper, our goal is to provide appropriate normal forms to programs with strategy annotations. However, the redefinition of command red is not able to provide the normal form 0 . 1 for the program in Example 1.2, since the annotation 2 is missing in the strategy list for symbol . (see the output of the red command in Example 4.1). However, as it was explained in Section 1, this concrete problem is solved using either a layered normalization, or a transformation. In this section, we redefine the command norm of [8] to perform a layered normalization of the output given by the on-demand evaluation previously presented.

guages such as Maude. We make use of the extensibility and flexibility of Full Maude to permit the use of both red (the usual evaluation com- mand of Maude) and norm (introduced in [8]) with Maude programs us- ing on-demand strategy annotations. The full specification is available at http://www.dsic.upv.es/users/elp/toolsMaude.

These features have been integrated into Full Maude, making them avail- able inside its programming environment. The high level at which the spec- ification (implementation) of Full Maude is given makes this approach par- ticularly attractive when compared to conventional implementations (see e.g. [3]). The flexibility and extensibility that Full Maude affords has made the extension quite simple and in a very short time.

