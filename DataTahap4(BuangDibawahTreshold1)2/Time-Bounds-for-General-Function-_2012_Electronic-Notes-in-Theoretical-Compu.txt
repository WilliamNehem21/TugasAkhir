We design a program logic of explicit time resource bounds for HAL. Programs verified in our logic are guaranteed to satisfy all invariants given in assert statements and are verified against an explicit bound on the number of function calls they make before safely halting. We hope this kind of logic will be applicable to real-time systems, where one is interested in concrete bounds rather than simple termination. We are unaware of any other logic of resource bounds for languages containing either function pointers or the kind of contravariant circularity present in HAL.

We can handle programs that exhibit nontrivial use of function pointers including mutually recursive function groups and higher-order functions. Each recursive group is verified as a whole and combined into proofs of whole-program termination, which makes the logic compositional. Higher-order functions are verified independently of the context in which they will be used and we are able to apply such functions to themselves without trouble (e.g., map of map). Our semantic model demonstrates how step indexing can be applied to logics of resource bounds in a compact manner. Contributions. We design a language containing function pointers and seman-

l. Second, l must be a function pointer to some code with termination measure t, function precondition Pl, and function postcondition Ql. Third, the termination measure t must be defined on the current store and evaluate to some n. That is,

starting from the current store, the function l will make no more then n function calls before returning. Fourth, the function precondition Pl must hold when applied to some a. Finally, the function postcondition Ql, when applied to the same a, must imply the postcondition Q in all stores (i.e., in particular, in the store after the function call is completed). The metavariable a is chosen to relate the function

H- and V-rules. Now that we have finished our semantic definitions, we are prepared to prove the rules of the Hoare logic as lemmas. The proofs are straight- forward for all of the rules aside from Hcall, which itself is not arduous [7].

Limitations. Our program logic is somehow simultaneously too weak and too strong. It is too weak in that the upper bound need not be tight, and we make no claims on the lower bound. Our logic is too strong in that the burden of constructing an explicit termination measure may be onerous for someone only concerned with termination. It would be better if one could provide a well-founded relation for each function, hiding the explicit bounds and termination measures under existentials.

Predicates in syntax. Semantic assertions are often used in program analysis settings such as BoogiePL [5]. Semantic assertions are one example of a larger class of bookkeeping instructions that embed formulas into program syntax, such as the makelock instruction used in concurrent C minor [8].

We have presented a simple language with embedded semantic assertions and func- tion pointers, together with a logic of the total correctness of time resource bounds. Our logic is able to reason about terminating function pointers in a very general way, including polymorphic mutually-recursive function groups. We have proved our logic sound with respect to an operational semantics using step-indexing, thus demonstrating that step-indexed models are useful for modeling resource logics.

