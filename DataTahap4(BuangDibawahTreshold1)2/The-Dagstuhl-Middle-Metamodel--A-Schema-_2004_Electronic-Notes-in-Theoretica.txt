The Dagstuhl Middle Metamodel (DMM) is an extensible schema for static models of software. It is a middle-level metamodel since it captures program level entities and their relationships, rather than a full abstract syntax graph (lower level), or architectural abstractions (higher level). DMM can be used to represent models extracted from software written in most common object-oriented and procedural languages. This paper presents the main features of DMM.

There have been several practical uses of DMM. For example, Moise and Wong [9] used it in an industrial reverse engineering case study. There is also a tool on the web [10] that will take any C++ source code and convert it into DMM using GXL syntax. Several projects are also building schemas that extend or connect with DMM (e.g. [11]).

DMM does not represent programs completely; i.e. it does not store the abstract syntax tree. Nor does it represent very high-level architectural ele- ments like pipes, filters, clients, servers, etc. Other types of metamodels can be used for these low-level and high-level models, respectively. DMM is intended to be used for middle-level models. There is nothing in DMM, however, that precludes extensions which address high-level or lower-level concerns.

Some users of DMM may elect to simplify their models by omitting all but the most essential SourceObjects. Rather than storing one or more SourceObjects for every single ModelObject (e.g. specifying where in a file each variable, method, invocation etc. is located), one could just store the SourceObjects corresponding to top-level ModelObjects (i.e. just the Classes). If this option is chosen, then tools using such models will not be able to pinpoint the exact location in files of lower-level ModelObjects without further searching; such searching can, however, be done easily in near real time.

An interesting issue that arose when storing source code information was how, in the SourcePart class, to store pointers to the start and end of blocks of source code text. One strategy is to use character offsets from the beginning of a file. This makes seeking to a particular character easy in some program- ming languages. The choice that was instead made is to use line number plus character offset in the line. This has the advantage that no confusion arises when the size of lines in a file change due to the different line-ending conventions (i.e. CR vs. CR/LF).

To achieve this multi-language transparency, DMM generalizes several con- cepts. For example, the notions of routine, function and subroutine are all treated the same. Also, a Method is very much the same as a Routine except that it has a relationship to a class. Similarly, a Class is a Struc- turedType that has a few other features, such as methods. Although various programming languages have minor semantic differences regarding how they implement these ideas, DMM abstracts these differences away.

Some people have proposed even abstracting away the differences between Method and Routine, as well as between StructuredType and Class. If this were done, true structured types would be represented as classes that happen not to have any methods. This simplification has not been made in the current DMM version. A reason for keeping all four classes is that we believe it helps people to understand DMM better.

more specialized. The domain of a sub-relationship is the same as or a sub- classes of the domain of a higher-level relationship. The same is true of ranges. Models using DMM do not have to represent information about each rela- tionship shown. Also, if a model wants to model accesses, it could use either

A metamodel needs to be robust as opposed to fragile. Robustness means the widest possible variety of tools can use it without the need for inconsistent variants. We hope that robustness was increased by the fact that the devel- opers of several metamodels got together and worked out a metamodel that could be used by all the groups. The fact that several projects have used DMM with little change, is initial evidence for its robustness.

It will be important to continue to examine other metamodels to improve DMM to the point where it achieves widespread acceptance. Examples of metamodels that have been widely studied include Columbus [13] and the UML metamodel [14]. Unlike DMM, Columbus is explicitly for C++. The UML metamodel overlaps DMM in places; however, it is designed for forward

