Abstract algebra has a solid mathematical underpinning and simultane- ously provides a perspicuous notation that allows for simple symbol pushing instead of tedious model-theoretic reasoning. There have been several exam- ples of abstract algebra as an efficient reasoning tool. One of the earliest such abstract algebras is Kleene algebra with tests, which was employed by Kozen for proving transformation rules of loops [4]. Recently, McIver, Cohen and Morgan used probabilistic Kleene algebra for protocol verification [5] and Solin and von Wright used refinement algebras for program reasoning in a total-correctness environment [14,15,12,11].

In this paper, we present an abstract algebra for reasoning about prob- abilistic programs. It lifts the concrete-algebraic approach to probabilistic programs of Meinicke and Hayes [8] to a more abstract level, in the same way that Solin and von Wright [14,15,12] lift the concrete-algebraic approach to non-probabilistic programs of Back and von Wright [2]. The lifting not only provides a more perspicuous notation, but also allows for results proved in the algebra to be reused over different models for which the axiomatisation is sound. It also paves a more treadable way for automation.

choice operator in our algebra. This decision reflects an important observation: many non-trivial transformation rules for probabilistic systems, such as the data refinement rules we derive in Sect. 6, may in fact be specified and verified without having to reason directly about probabilistic choices. We consider the elegance and simplicity of the framework to be a virtue. By not including a probabilistic choice operator we do not unnecessarily restrict its generality.

We do introduce guards and assertions into the refinement algebra. Guards form a Boolean subalgebra of the carrier set and can be used when modeling for example the predicates of conditionals and loops. Since Boolean algebra is again a very well-known structure, this does not endanger the simplicity of the abstraction. Assertions, which can also be used to model predicates but behave differently from guards when the predicate does not hold, are defined in terms of guards. Moreover, we define operators that determine whether a program is enabled, has certain failure (will abort with probability one) or does not have certain failure, respectively. The last-mentioned operators are similar to the domain operator of relational algebra and thus familiar to several with a background in computer science or discrete mathematics.

To show the elegance of the abstract-algebraic method, we apply the alge- bra to reasoning about action systems. Action systems can be used for model- ing parallel or distributed systems in which concurrent behaviour is modeled by interleaving atomic actions [1]. Probabilistic action systems extend action systems to account also for probabilistic behaviour, in that the actions are allowed to be probabilistic programs [10]. Employing the enabledness and the certain-failure operator we show how to prove data refinement rules of probabilistic action systems in the refinement algebra.

Let us look a bit closer at some of the axioms. Most of those not pertaining to the strong iteration operator should be familiar from Kleene algebra: in fact one of the Kleene algebra axioms is absent and three have been modified. The annihilation axiom, xT = T, is absent so that we can model non-termination.

As noted by Meinicke and Hayes [8], these properties do not hold for pro- grams which exhibit branching behaviour, and so right-distributivity is suit- ably weakened to right sub-distributivity (axiom (8)), and the unfolding and induction axioms are replaced by axioms (11) and (13). A similar generali- sation is also made in probabilistic Kleene algebra [5] and the monodic tree Kleene algebra [13]. Axiom (11) may be derived from the others, but is in- cluded for clarity. 5

Although the primary focus of this paper is performing total correctness reasoning, we do not exclude discussions of the weak-iteration operator, since it can be applied when it is reasonable to assume that an iteration is termi- nating (see [5,8]). In Sect. 6 we show how weak iteration, via the new axiom (13), plays an important role in the derivation of a data refinement rule for probabilistic action systems.

for any y and z in the carrier set. As mentioned in the previous section, conjunctivity is not satisfied by all probabilistic programs, hence it is not an axiom of pDRA. It is, however, satisfied by a large subset of these: the programs which do not include probabilistic choices. When it is reasonable to take conjuctivity as an assumption, many useful transformation rules which would otherwise not hold, may be verified. Also, we say that an element x is continuous if the condition

We now introduce guards and assertions into the algebra. Guards are to be seen as statements that check if a predicate holds and skip if the predicate holds, otherwise behave like magic. Guards must be introduced slightly differ- ently than in [14,15], since not every element is conjunctive but we still want guards to satisfy conjunctivity. Hence, an element g of the carrier set that

The failure operator satisfies the following properties that we will use later on. The first property says that a program can be refined by statement that checks that the program fails and then aborts (remember that the failure is checked by a guard, and thus a miracle happens if the program fails). The second property says that any program composed of any number of statements is refined by a program that checks if the first statement fails.

This section comprises an application of our algebra to data refinement of action systems. Action systems can be used for reasoning about parallel or distributed systems in which concurrent behaviour is modeled by interleaving atomic actions [1]. Probabilistic action systems extend action systems to account also for probabilistic behaviour, in that the actions are allowed to be probabilistic programs [10]. An action system

is an iteration of a set of actions x1, ..., xn that terminates when none of the actions are enabled, that is to say, the iteration continues as long as any action is enabled. In the abstract algebra, we encode an action system as a strong iteration of a demonic choice between n actions and we express the termination condition with the aid of the enabledness operator [12,2,8]:

In this paper we showed that abstract-algebraic reasoning also works well when probabilistic programs are concerned. We proposed a probabilistic refinement algebra facilitating total correctness and including a strong iteration operator, as well as operators for enabledness and certain failure. As an application, probabilistic action systems were cast in the abstract algebra and three data refinement rules were established.

This research could be taken further in several directions. One direction would be to introduce angelic choice into the algebra and another direction would be to consider probabilistic choice abstractly. It should also be interesting to apply the algebra to more elaborate case studies.

This short appendix is written for those who are already somewhat familiar with the theory of expectation transformers. It provides an expectation- transformer interpretation of the concepts involved in the probabilistic refinement algebra. This appendix can unfortunately not be completely self-contained and self-explanatory, but we refer the interested reader to the comprehensive book by McIver and Morgan [6]. We use a slight variation

