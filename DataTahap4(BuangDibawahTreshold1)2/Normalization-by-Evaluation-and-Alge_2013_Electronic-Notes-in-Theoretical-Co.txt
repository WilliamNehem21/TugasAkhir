Notice how we are describing computational effects with an algebraic signature: inp is a binary operation, and out0, out1 are unary operations. A crucial observation is that the same normalization algorithm works if we begin with a different algebraic signature of computational effects. Many other effects have been described in an algebraic way, including non-determinism, probability, memory access [36,35,26] and logic programming [43]. Our framework is a general one for all these examples.

We describe simple effects involved in computation using algebraic signatures [36]. For example, we can describe the effects involved in input/output of bits over a fixed communication channel with a binary operation inp and unary operations out0, out1. The algebraic expression inp[M, N ] describes a computation that first reads a bit from the channel and then proceeds as the computation M if it is 0, or as N if it is 1. The expression out0[M ] describes a computation that outputs a bit 0 to the channel and then proceeds as M .

In this paper we have considered a restricted language with just enough features to demonstrate our contributions. While language features such as recursion and sum types are very important, they can be dealt with by using standard techniques from the literature. We briefly summarize the main ideas.

The semantic analysis based on presheaf categories has been extended to explain nbe with sum types for pure languages without computational effects [2,6]. Filin- ski [13] and Lindley [21] have discussed nbe for effectful languages with sums from a more pragmatic perspective. The languages they consider type case expressions as computations rather than as values, which allows them to use the residualizing monad to treat pattern-matching on atomic values.

We have investigated normalization by evaluation for a language with higher types and computational effects. The effects are specified by an algebraic signature, so our algorithm works for any notion of computation that can be expressed this way. A key contribution of our work is our clear and modular semantic analysis of normalization by evaluation. At the heart of our analysis is the residualizing monad.

