sty i and a type T which may contain x1,... , xn, y1,... , ym. In the case where the declared function proofName is not recursive, we may also use the keyword prfn and give no metric. Please see [4,5] for some examples of proofs formed in ATS/LF.

representation of typing judgments, but instead the context of the metalanguage is utilized. Such higher-order representations of the typing judgment, as often used in Twelf [10], benefit from inheriting substitution on typings from the metalan- guage, and so do not need a typing substitution lemma. On the other hand, the use of explicit contexts allows for a first-order representation of typing derivations. This, along with the separation between statics and dynamics, allows us to prove metatheorems directly, using total recursive functions, while still taking advantage of HOAS for object syntax. The inconvenience of having to prove substitution on typing derivations is minor, and not pervasive as issues involving binders in the syntax are. In fact, we do not ever need to make use of substitution on typing

When we prove this lemma in ATS/LF, the higher-order encoding buys us quite a bit over a first-order encoding. Because of HOAS, we do not have to think about freshness of variables nor do we have to explicitly prove that the substitution com- mutes with the lambda binding when handling the lambda case. Lemma 4.9 is encoded in ATS/LF as a total function, which we omit for brevity:

Strong normalization for System F has previously been formalized by Altenkirch [2] using the Lego system. His formalization uses the de Bruijn encoding for both terms and types, and because of this, is significantly longer and more complicated than our proof. Even though our formalization contains full proof terms, rather than tactic-based scripts, it is shorter by about a factor of two.

