Tom and ApiGen are two complementary tools which simplify the definition and the manipulation of abstract datatypes. Tom is an extension of Java which adds pattern matching facilities indepen- dently of the used data-structure. ApiGen is a generator of abstract syntax tree implementations which interacts naturally with Tom. In this paper, we show how Eclipse can be extended to support the development of Tom programs. By integrating a Tom editor, an automatic build process, and an error management mechanism, we demonstrate the integration of an algebraic programming environment in Eclipse. Hence, our work contributes to the promotion of formal methods and Eclipse to the educational, algebraic, and industrial communities.

In this paper, we present an Eclipse plug-in for Tom [13] and ApiGen [5]. Tom is an extension of Java (and C) which adds pattern matching facilities to these languages [15,16,12,10]. This is particularly well-suited when describing various transformations of structured entities like, for example, trees/terms and XML documents. From an implementation point of view, it is a compiler which accepts different native languages (C or Java) and whose compilation process consists in translating the matching constructs into a given underlying native language. Its design follows our experiences on the efficient compilation of rule-based systems [9].

As mentioned previously, an important feature of Tom is to support list matching, also known as associative matching with neutral element (inspired by the ASF+SDF Meta-Environment [3]). Let us consider the associative operator conc used for building list of naturals (NatList). In Tom, an asso- ciative operator is a variadic operator and each sub-term could be either of sort element or list (respectively Nat or NatList in our case). To illustrate the expressivity of associative matching, let us define a sorting algorithm:

uments. Indeed, an XML document can be parsed and represented by a tree-based data-structure like Document Object Model (Dom), promoted by the W3C. Dom is a platform independent interface that allows to dynami- cally access and update the content, structure, and style of XML documents. Tom provides a mapping mechanism (the signature definition) that enables us to see a Dom tree as an algebraic term, on which pattern matching can be performed. In addition to the standard prefix notation, Tom supports a specific XML-like notation which makes pattern definitions very natural for XML users. As an example, comparing two XML nodes (Person) according to values of their attributes (Age in this example) could be described as follows:

When using the XML notation, the pattern <Person>...</Person> matches an XML document only when this document is rooted by a Person node. In our example, the notation Age=a1 means that we are only interested in a node which contains the attribute Age. For these nodes, the value of the attribute (a string) is stored in the fresh variable a1. The previous pattern matches when given two XML documents t1 and t2, these documents are rooted by Person and have an attribute Age. In this case, the value of their attribute Age are stored respectively in a1 and a2. Thus, we say that t1 is smaller than t2 when a1 is smaller than a2 (using the compareTo method provided by the String library of Java). In all other cases, the two documents t1 and t2 are not comparable and the integer 0 is returned.

With this XML notation, it becomes possible to retrieve information stored in subterms. The following pattern matches an XML document when it con- tains a sub-node rooted by Name. In this case, the content of the Name node (a string) is stored the variable name.

Object-oriented languages are not good at analyzing and transforming XML, as one can observe when manipulating XML documents. This is be- cause such trees usually contain data but no methods. The Dom library helps the programmer but make transformations still tedious to express. The ex- perience showed us that Tom performs well in this area, mainly because the notion of pattern matching naturally extends to the processing of XML data. Ideally, one would hope for a fusion which unifies concepts found in different paradigms. Our proposal is a first answer to this problem. As an example, the Dom library offers a way to obtain all nodes with a specific name. This can be specified in Tom, but it is more tedious. The collection of all nodes with a particular attribute is more easy in Tom and very tedious using the Dom library.

ELAN [9], a strong core compiler for the language has been developed [13]. This compiler, called JTom, is written in Java and Tom itself, using ApiGen for abstract datatype definitions. In parallel, a dynamic debugger, able to track pattern matching and rewrite step expressions has been implemented. This tool allows to set conditional break-points and visualize variables instan- tiated by pattern matching.

Recently, the Tom compiler has been adapted to be integrated into the Eclipse platform. The development of the Tom plug-in, thanks to Eclipse framework simplicity, led to the emergence of a complete integrated algebraic environment dedicated to Tom. This work share some common features with the ASF+SDF Meta-Environment [1,4].

There was definitely a need for a more friendly environment to promote the language and also make our development easier. The Eclipse platform answers to these problems by providing an integrated environment which con- tains both editors, compilers, and builders. Furthermore, Eclipse is able to provide a complete specialized editor for Tom, offering syntax coloring, key- word completion, and error reporting in a uniform environment.

To each Tom file is associated a specific editor, whose design is inspired by the Java editor. On the implementation side, some behavior is inherited from the classes included in the JDT. In particular, this gives Java coloring, indentation, and function template completion for free. The specific part consists in adding Tom functionality to complete the inherited one:

a last feature allows to display the signature of an algebraic constructor. By double-clicking on a Tom constructor, an info-pop gives its algebraic signa- ture (domain, co-domain, and field-names). This considerably improves the development process and participates to reduce the number of ill-formed term errors.

The last point is interesting because it illustrates the smooth integration of Tom and ApiGen: algebraic constructors are used in Tom programs, whereas their signature is defined at the ApiGen level (in *.adt files). By parameter- izing the Tom editor with signature definitions, the editor is able to retrieve and display pertinent information.

By developing such a plug-in, we have identified several opportunities for improvement in both the Tom project as well as in Eclipse. In addition to the design of the source code synchronization mechanism, we had to adapt our tools to allow them to share a common Java virtual machine. Thus, it appeared essential to remove all static objects as well as to banish all calls to System.exit(), since it immediately terminates the execution of the Eclipse environment.

In the previous section we showed how a pleasant and easy-to-use development environment can be provided for an extension of Java. Moreover, we also showed how the Eclipse framework can be turned into a platform dedicated to refactoring and debugging of algebraic based languages. The presented Tom plug-in makes the build process automatic, compilation errors are reported in the editor and located, with explanatory messages. In our opinion, this contributes to reduce the time spent in debugging and thus to speed-up the development process.

Providing such an environment is with no doubt interesting for the de- velopment of formal methods, because it will help students to learn and use algebraic specification languages. The facilities offered by such an environ- ment allow to focus on the underlying concepts of such a language instead of the syntactic idiosyncrasies of the language. By quickly identifying syntax and type errors, the IDE contributes to focus on higher level concepts rather than technical problems.

This work shows how Eclipse can be used to develop new environments for languages or extensions, using the open architecture of the IDE framework. We have shown how this framework can be used to integrate different tools, formerly considered as independent tools, involving a complex build process into a programmer friendly environment. The introduction of other tools allows to unify these tools in a common platform. We show that the poten- tial of Eclipse environment can be also easily extended to promote such new languages by providing a uniform framework with features usually found in professional used IDE only.

authentication between an initiator and a responder) has been described and verified using Tom [7]. In both cases, the interaction between Java and Tom was very fruitful: Tom was used to specify the transition system, whereas the expressive power of Java was used to specify how the search space has to be explored. Finally, the use of Eclipse made this fusion of paradigms so natural that Tom appears to be mature enough to be promoted in a teaching or an industrial environment.

The Tom plug-in has been recently used by the CRIL Technology Group. The main theoretical objective of this research project is to specify and per- form transformations of timed automata. From an implementation point of view, most of the data-structure are represented by XML documents. Thus, the need of a powerful and integrated XML transformation tool was essential. A first prototype has been implemented in Java using Eclipse and the Dom library to describe the various transformations. In a second version of the implementation, it was decided to use Tom to describe the transformations. It is worth to say that the existence of the Tom-Eclipse plug-in was essential: without such a plug-in it would have been much more difficult to convince this group to use higher-level programming concepts to implement its tools. The result are quite impressive up-to now, the Eclipse plug-in described in this paper has enabled them to implement complex algorithms, they could never have implemented using Dom. The Tom plug-in also helped them to improve the maintenance of their system and reduce the size of the project by a factor 3 (from 1,200 lines of Java to 400 lines of Tom).

Several systems have been developed in order to integrate pattern matching and transformation facilities into imperative languages. For instance App [14] and Prop [11] are two extensions of C++: the first one is a preprocessor which adds a match construct to the language, whereas the second one is a multi- paradigm extension of C++, including pattern matching constructs. Finally, Pizza [15] is a Java extension that supports parametric polymorphism, first- class functions, class cases and pattern matching. All these approaches are interesting and powerful but less generic than Tom since they strongly depend on the underlying language.

In spirit, Prop and Pizza are very close to Tom: they add pattern matching facilities to a classical imperative language, but the method of achieving this is completely different. Indeed, they are more intrusive than Tom since they really extend C++ and Java with several new pattern matching constructions. The non-intrusive approach of Tom allows us to be more reactive to any modification of the underlying language (Tom is already ready for Java 1.5 for example) and also simplifies its integration into programming environments

As far as we know, several extensions of Java have already been integrated into Eclipse. Let us mention the JavaCC and the Jack [6] plug-ins for instance. JavaCC is a parser generator for Java, whereas Jack is a tool for static verifi- cation of Java applets, using JML annotations. However, to the best of our knowledge, these tools are not fully integrated into Eclipse, as they do not provide any good support to retrieve and display programming errors in the Eclipse editor.

At last, it should be interesting to port all these efforts to the C language by the intermediate of the CDT tools. This port will benefit from the use of conventions and generic functionality imposed by the platform. So, this task should consists in refactoring and adapting the editor and the integration of compilers.

