Inverse computation of an n-ary function f is, given an output v, the calculation of the possible input v1,..., vn of f such that f (v1,..., vn) = v. Two approaches for inverse computation are distinguished [1]: inverse interpreters [4,1] that performs inverse computation, and inversion compilers [18,28,9,25,24,7,19,20,2] that performs program inversion.

3 To simplify discussions, we omit describing special rules in the form of InvF (F (x1,..., xn))	x1,..., xn [25,24] because they are meaningless for inverse computation in dealing with functional programs on call- by-value interpretation. The special rules are necessary only for inverse computation of normalizing com- putation in term rewriting.

In Section 5, we first show a sufficient condition of constructor TRSs from which the inversion compiler generates (innermost-)convergent DCTRSs. Next, we de- scribe an implementation of the modified completion procedure, and the experi- ments for the unraveled TRSs of DCTRSs obtained by the inversion compiler [24] from injective functions shown by Kawabe et al. [9]. Finally, we illustrate an infor- mal translation of the non-overlapping TRSs obtained by the procedure back into functional programs.

t1    sk   tk  R   are called patterns (in R). We denote the set of patterns in R by Pat(R). It follows from the definition of U that Pat(R) = Pat(U(R)) up to variable renaming. Patterns represents structures of data by means of matching. Especially, in innermost reductions, patterns matches normal forms only.

In this section, we apply the modified and simplified completion procedures to DCTRSs generated by the partial inversion compiler [25], that is, we apply the procedures as a post-processor of U( nv( )) to the unraveled TRSs. First, we briefly introduce the feature of inverse systems for injective functions. Then, we show the results of experiments by an implementation of the framework.

InvRev(z) U4(InvRev(z), z). For this reason, we restrict ourselves to injective functions whose inverse TRSs are terminating. In [22], a sufficient condition has been shown for the full inversion compiler in [24] to generate convergent inverse DCTRSs from injective TRSs. The condition is also effective for the partial inversion compiler Inv [25].

Note that if the DCTRS nv(R) is OP-SN then the TRS U( nv(R)) is ter- minating [14]. Theorem 5.2 (i) shows that if nv(R) is OP-SN, then nv(R) has innermost-confluence that is necessary for successful runs of the simplified comple- tion procedure. Note that nv(R) is confluent if R is convergent [25]. When R does not satisfy the condition in Theorem 5.2 (ii), we directly check the termination of U( nv(R)). In other words, when R satisfies the condition in Theorem 5.2 (ii), we are free of the termination check of U( nv(R)) that is less efficient than the check of satisfying the condition.

In this subsection, we report the results of applying implementations of the modified and simplified completion procedures to 10 of 15 examples shown in [9]. 5 These 15 examples are introduced for the experiments of the inversion compiler LRinv [9,10] where LRinv succeeds in inverting all of them. Those examples are written in the scheme script Gauche. The inverse TRSs of the scripts snoc, snocrev and reverse correspond to the TRSs U( nv(R1)), R3 and U( nv(R4)), respectively. The constructor TRSs corresponding to the 5 scripts (reverse and so on) are not injective and the inverse TRSs obtained from them are not terminating. For this reason, we excluded those non-terminating examples from our experiments. For some examples, there exists no appropriate LPO to guarantee termination of the

In this paper, we have shown that completion procedures are useful in generating (innermost-)convergent inverse TRSs of injective TRSs. The completion procedures can be also used for checking whether or not a (innermost-)convergent constructor TRS is injective. This is because if a given convergent constructor TRS is not injec- tive, then the procedures never succeeds for the TRS. It is known to be undecidable

in general whether or not a function is injective [5]. In [17], however, it is shown that injectivity of linear treeless functions is decidable. On the other hand, some of the examples we mentioned in the experiments are non-linear or non-treeless while the method in this paper is not decidable.

where   and  are special function symbols not in the original signature. In this system, the term InvSnoc([a, b, c],  ) has a unique normal form  [a, b], c . As described in Section 1, however, it is difficult to translate the convergent TRS into a functional program because the system contains special symbols  and  , and overlapping rules. On the other hand, the modified completion procedure in this paper unexpectedly succeeded for all the experiments where the DCTRSs are confluent, and the resulting systems of the procedure are often non-overlapping. Moreover, for the DCTRSs that are not confluent but innermost-confluent, we pro- posed the simplified completion procedure but it is not yet known whether or not the transformation in [30] is applicable.

The inversion compiler LRinv, the closest one to the method in this paper, has been proposed for injective functions written in a functional language [9,7,10]. This compiler translates source programs into programs in a grammar language, and then inverts the grammar programs into inverse grammar programs. To eliminate nondeterminism in the inverse programs, their compiler applies LR parsing to the inverse programs. The classes for which LR parsing and the completion procedure work successfully are not well known, which makes it difficult to compare LRinv and our method. However, LRinv succeeds in generating inverse functions from the 5 scripts (reverse and so on) that we excluded from the experiments, where the main functions call non-injective functions such as the accumulator Rev. From this fact, LRinv seems to be stronger than the method in this paper but there must be plenty of room on improving the principle of inversion used in the partial inversion complier in [25]. As future work, we plan to extend the partial inversion compiler

