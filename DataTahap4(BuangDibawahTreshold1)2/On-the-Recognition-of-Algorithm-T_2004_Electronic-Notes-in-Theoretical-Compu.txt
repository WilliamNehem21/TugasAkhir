Hardware-software codesign: if we recognize in the source program a piece of code for which we have a hardware implementation (e.g. as a coprocessor or an Intellectual Property) we can remove the code and replace it by an activation of the hardware.

The aim of this paper is to propose a method in order to perform some algorithm template recognition and to find out how the instantiation is per- formed. This important issue have never been tackled before in the framework of algorithm recognition. This preliminary work is based on the framework presented in [3]. As in most algorithm recognition methods, the first step is

for all dependences in the SARE. If the domains are bounded, a schedule exists iff the given SARE has no dependence cycle. The scheduling problem for parametrically bounded SAREs is undecidable [14]. However, the existence of affine schedules for SAREs is decidable [7]. Note that in general, these schedules have a parametric latency. We only consider in this paper SAREs with a schedule.

Consider two scheduled SAREs S and S', with S a template. Suppose that we are given a bijection between the output variables of the two SAREs and a mapping between input variables. These pairings must have the property that corresponding variables have the same domain.

and template outputs, finding out the substitutions for the variables. We will show that this procedure is correct and complete. However, it may take a parametric number of steps to terminate. The next section proposes to address this termination problem by the construction of an automaton.

The matching procedure unfolds the recurrences defined by the SARE, thus may take a parametric number of steps. The idea of this semi-algorithm, following the approach of [4], is to implement the procedure with an automaton and analyze the automaton, without executing it, in order to construct the set of unifiers. The automaton, a Memory State Automaton (MSA) is described below.

(v) can be applied, because reachability sets were already computed. One can notice that the MSA has the same transitions than the matching procedure, with the same context in firing relations. So it computes the same set of unifiers, which is correct (see correction proof in section 4). This justifies steps (vii) and (viii).

