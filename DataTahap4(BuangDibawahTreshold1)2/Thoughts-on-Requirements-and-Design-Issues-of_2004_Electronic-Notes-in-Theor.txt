The gradual development of proof assistants contrasts with the more hap- hazard history of theorem prover user interfaces. A look at the literature of the 1990s reveals several projects which seem to have had little impact. In some cases, the projects produced systems that never advanced beyond rather small groups of users. It is interesting to see that among the more popular survivors are several systems based on (X)Emacs, i.e. ProofGeneral and the user interfaces for PVS and IMPS [29].

Most theorem provers have been developed in functional programming lan- guages from the ML and Lisp families. Compared to other languages such as C++, Java or Basic, these functional languages are lacking in graphical user interface (GUI) toolkits and in some cases provide only poor support for light-weight concurrent processes. These problems have lead to several projects that connect functional languages with frameworks that have better GUI facilities, see for example sml tk [20] and recent OCaml [30] bindings for TK and GTK+. Still, the resulting development environments are more cumbersome than the direct use of a modern commercial GUI builder tool.

For the reasons mentioned above, only few academic institutions have the necessary resources to build and maintain completely custom UIs. Even these institutions would benefit from more reuse by freeing up developer time. This suggests that it is in the interest of the academic theorem proving community to devise reusable UI components and UIs.

An interactive proof is started by posing a logical formula (the main/ initial goal ) that is to be proven. This is followed by a number of proof steps. In each step, the user analyses the proof state and then issues some proof command. This is carried out by the prover and leads to the next proof state.

Below is a sample use case for a hypothetical proof assistant system. It deals with the addition of a new logical constant to an existing theory. This is a task that typically arises during the iterative development of a theory when one notices at some point that it would be useful to introduce a further constant. The formulation is based on a use-case template by Larman [18].

4 a. The system displays appropriate messages in case of illegal or failed proof commands, a successful completion of a proof by proving all sub- goals, warnings during proof step execution, proof step cancellation and abortion of proofs. In case of failed commands, the system should also provide feedback.

used as the basis of further development. In case of functional programming languages, these categories will be implemented as types. In this context, it is instructive to note that the code of modern theorem prover systems is organised around structures that group together types and their associated operations. This is analogous to the organisation of object-oriented program- ming languages around classes.

Auto completion could be used whenever it is necessary to name objects such as theories, theorems, proof commands, etc. Completion should be intelligent in the sense that it takes object types and context into account. An advanced implementation could perhaps even consider the likelihood of different possible completions.

Hiding of irrelevant information decreases the amount of effort in finding information and making decisions. For example, menus should offer only possible choices. When searching for theorems in a library, it should be possible to do so without being distracted by the proofs of these theorems.

Sorting items according to the likelihood of their usefulness is another way of decreasing effort. For example, the user interface could keep track of how often certain menu items are used. Rarely-used menu-items can then be hidden and only made visible on explicit demand.

K. Eastaughffe [11] has identified further HCI design principles for theorem prover support. In particular she suggests complementary views of proof con- structions, ease of undo operations, flexibility in the way users can articulate commands to a prover, and support for concurrent proof constructions.

Graphical User Interfaces (GUIs) have transformed the use of computers and contribute significantly to their popularity. They are kind to novices and non-experts as they make it unnecessary to learn command languages. GUIs are based on the direct manipulation metaphor: objects are represented by graphical elements such that a manipulation of the graphical representation induces a corresponding operation on the represented object. A particular strength of GUIs is the manipulation of complex objects. For example, visual editors have made command line text editors obsolete. The latter are typically only used in emergency situations.

In our view, this controversy suggests that the UI should offer a choice between text-based and graphical interaction whenever there is no clear-cut advantage to use either. This applies, for example, to selections which are often faster by keyboard, at least for expert users. Providing such a choice also caters for individual preferences.

Customisation should be possible at different levels such as project level, theory level and proof level. Settings on a more specific level should override setting on more general levels, i.e. setting the visibility of brackets in the context of a particular proof should override the setting of this parameter on the theory level.

Using a standard web browser for reading theories is attractive because of reuse possibilities, hyperlinking and the widespread familiarity of users with this interface. MathML promises to simplify the rendering of mathematical formulas. Representing theories as XML documents would allow simple cus- tomisation of the presentation via XSLT or via a transformation to HTML combined with the use of CSS style sheets.

For efficiency reasons, it is usually advisable that the UI performs basic validation of user inputs. It also makes sense for the UI to be aware of the textual commands that might be entered by users. This could help with graphical support as outlined in the HCI design section. On the other hand, parsing of formulas is a complex, logic-dependent task. It seems best if these are passed directly from the UI to the proof assistant. Having a parser in the proof assistant also supports the batch-processing of theory files.

provide typically only a small number of interfaces over which data encoded as XML documents is exchanged. The validity of XML messages with respect to pre-defined rules is not ensured by the framework. Instead, validity can be checked explicitly by the receiver of a message. This results in very loosely coupled, easily extensible and lightweight architectures.

XML processing and web service standards are supported by implemen- tations for different platforms and programming languages while at the same time being completely platform and programming language independent. A downside is that XML messaging is generally slower than the exchange of data via remote procedure calls or remote method invocations. Despite this performance drawback, XML messaging appears a promising choice for com- munication between generic UIs and proof assistant backends.

