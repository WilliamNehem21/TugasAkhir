In this paper we describe our framework and experiments for proving and certi- fying resource consumption of programs written in a subset of Java bytecode using program logics and automated theorem provers. Our initial motivation was to obtain certificates of memory consumption for low-level programs annotated with memory consumption on the level of methods. The annotations can be directly generated from the results of a static analysis for inferring heap space consump- tion of programs written in a high-level functional language called Camelot [17,13]. With the current state of the art in automated theorem proving this seems to be an easy way of obtaining the certificates in comparison with compiling into a typed assembly language and then generating the proofs from typing derivations.

This paper is organised as follows. First, we will outline the language, the program logic and our axiomatisation in Sect. 2. Then, in Sect. 3, we will describe our verification condition generator and demonstrate a successful application to reasoning about running time in Sect. 4. In Sect. 5 we will discuss the problems arising when reasoning about programs with heap aliasing and suggest possible solutions to the difficulties. Sect. 6 concludes.

In the syntax we use v for values, a for variables or values, top for test operators (comparisons), bop for binary operators (addition, etc.), t for base types and e for expressions. Note that class and field definitions are omitted from the syntax as their definition is completely standard.

We have based our program logic on the original program logic for Grail [1]. How- ever, we could not use it verbatim since it uses higher-order logic as the language of assertions. The main change in our logic is replacing the explicit environment in the assertions of the original logic by substitutions in our logic.

In the translation to obligations we delete the sorts for heaps, locations and integers. For the sorts for fields and classes we use the standard translation from sorted to unsorted logics using predicates for sorts. Some non-theorems 6 in the sorted logic can become theorems when the sorts are deleted. However, Bouillaguet

The example has one method and two functions, which results into three verifi- cation conditions. For an illustration of a verification condition we show the proof obligation for the loop method. At first our generator computes a specification of loop using the rules of the program logic (we omit space consumption and some trivially eliminated quantifiers from the specification).

The obligations are proved by Simplify in a fraction of a second. It seems likely that this example would extend to other cases where recursion pattern matches the definition of the predicate, such as proving running time of a search in a binary tree of bounded height. We have successfully applied our technique to other simple examples, such as multiplying integers using only addition.

in h and h'. In our case of obligation for putf predicate we can use the array-like select-store axioms for putf and getf to describe relationship of the two versions of getf. To capture the reach predicates we will use the axiom for effects of putf on reachability. The verification condition transformed this way 9 is provable by both Simplify and Harvey. Although we have not tested the approach on other verification conditions, we believe we could handle more complex obligations by eliminating all existentially quantified explicit heaps using a similar approach we have used for eliminating h and h'.

A similar approach to ours was used in [3] to prove memory consumption of simple programs with no recursive data structures involved. As opposed to our technique, they have used ghost variables to describe memory usage in a Hoare-like program logic for bytecode [5]. Their work does not discuss treatment of programs involving recursive data structures and aliasing at all.

There are several other alternatives to our approach. Nguyen, David, Qin and Chin [22] apply separation logic to prove size and shape properties using a cus- tom decision procedure based on folding and unfolding of recursive predicates, de- signed similarly to our well-founded predicates. By the usage of folding/unfolding in separation logic they neatly avoid the necessity of proving frame conditions using induction.

To handle shape analysis using logical tools [16] employs first-order theorem provers in combination with heuristics for instantiation of an induction scheme. Similar work of Lahiri and Qadeer [15] uses a decision procedure and several fixed instantiations of an induction scheme to prove shape properties of possibly cyclic data structures. We improve on their work by considering resources, their induction scheme is expressible using our well-founded predicates and the induction scheme for natural numbers. Interesting results in shape analysis were obtained by using limited, but decidable logics [28,21]. It is still an open question how to combine such logic with resources. It was suggested to us that Kuncak and Rinard [14] combine

Bouillaguet, C., V. Kuncak, T. Wies, K. Zee and M. Rinard, Using first-order theorem provers in the Jahob data structure verification system, in: B. Cook and A. Podelski, editors, Proceedings of the 8th International Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI 2007, Nice, January 14-16), Lecture Notes in Computer Science 4349 (2007).

Nguyen, H. H., C. David, S. Qin and W.-N. Chin, Automated verification of shape and size properties via separation logic, in: B. Cook and A. Podelski, editors, Proceedings of the 8th International Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI 2007, Nice, January 14-16), Lecture Notes in Computer Science 4349 (2007).

