The contribution of this paper is to show how data refinement in Z can be automatically verified using the Alloy Analyzer. The soundness and joint completeness of the simulation rules for Z have already been established: here we translate them to Alloy. We then show how data types expressed in Z can also be translated to Alloy, before presenting the assertions necessary for the Alloy Analyzer to identify the retrieve relation and hence verify refinement. We present a simple example in which the Alloy Analyzer successfully identifies the retrieve relation between two data types thereby verifying simulation and hence refinement. We conclude the paper with a discussion of the suitability of the Alloy Analyzer for such a task.

In the development of critical systems, standards dictate that it is necessary to design, construct and formally analyse abstract models of the system [10]. Developers must then verify that the final implementation is consistent with (or satisfies the properties captured by) these more abstract specifications. Refinement is a technique that is used for verifying such a consistency. The precise notion of refinement and the means for determining whether or not one model is refined by another depends on the choice of specification language and semantic model.

The main contribution of this paper is to show how data refinement in Z can be automatically verified using the Alloy Analyzer [8], a SAT-based verification tool. Moreover, in the process of this verification the Alloy Analyzer identifies the associated retrieve relation: typically the most difficult part of verifying refinement is not the application of the simulation rules but the identification of the correct retrieve relation. A further contribution of this paper is to define a notion of refinement within the Alloy language [8].

The Z notation is a state-based specification language that relies heavily on mathematical constructs such as set theory, logic and relational calculus. In addition, it employs a construct called the schema for structuring the math- ematics when modelling systems. The schema incorporates a declaration of variables and a predicate constraining those variables.

There are a variety of ways of capturing data types in Z [5]. Since the purpose of this paper is to show how data types expressed in Z might be automatically analysed using the Alloy Analyzer, we adopt the schema repre- sentation since this is closest to our Alloy representation. For further clarity, we consider only simple data types, those in which operations neither give outputs nor receive inputs.

Like the forwards simulation rules, the backwards simulation rules for ver- ifying data refinement within the blocking, or behavioural, context are very similar to those for verifying refinement in the non-blocking context. Again they differ only in the correctness rule which, as with the forwards simulation rules, is strengthened. The correctness condition for backwards simulation within the blocking context concerns all concrete states not only those that correspond only to abstract states that lie within the domain of the operation. This strengthening is captured by the removal of the domain subtraction in rule (Bb 3).

As observed above, sets of simulation rules can be used to verify refinement, since one data type is refined by another precisely when the first simulates the second. In this section we define Alloy versions of the simulation rules before presenting the Alloy check for automatically verifying refinement. See the Appendix and [8] for necessary notation.

In this section we identify the assertions necessary for enabling the Alloy Analyzer to identify the retrieve relation between the state spaces of a pair of data types. The actual data types under consideration must be uniquely captured. As illustrated in Section 5, in order to do this, the developer will need to extend the types Op, AState and CState to respectively include the names of all operations on the data types, all the states in the abstract state space, and all the states in the concrete state space.

where x is the number of operations on the data types, y is the size of the ab- stract state space and z is the size of the concrete state space. This means that for forwards simulation one SpecificFwdsPair, one FwdsPair, one DataTypeA and one DataTypeC would be considered. We can consider individual pairs but we must always consider the entire state space of each data type.

In this section we demonstrate the techniques discussed in the previous sec- tions. We present a pair of simple data types in Z. We translate them to Alloy and use the Alloy Analyzer to automatically identify the retrieve relation re- lating their state space and hence to verify refinement. We adopt the semantic model corresponding to data refinement within the blocking context.

Let data types A and C be defined as follows. They each have two operations Op1 and Op2. Initially data type A offers a non-deterministic choice between these operations and data type C nondeterministically will either deadlock or offer a non-deterministic choice between Op1 and Op2. Both data types will deadlock after any operation occurs.

Similarly, set difference is represented by the - operator: given an element pair of type BkwdsPair, the set containing those elements of the concrete state space that lie outside the domain of concrete operation n is described as follows pair.concrete.state - (pair.concrete.trans[n]).CState.

