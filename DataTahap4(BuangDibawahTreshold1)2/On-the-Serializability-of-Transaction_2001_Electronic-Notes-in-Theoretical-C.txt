JavaSpaces also supports transactions: multiple coordination operations can be grouped into a bundle that acts as a single atomic operation. In this paper we adopt serializability as a criterion to evaluate the correctness of the JavaSpaces transaction semantics: we prove that serializability is satis ed only if we restrict to output, input, and read operations. On the other hand, in the presence of either test for absence or event noti cation, serializability is not satis ed; we propose an alternative semantics and we prove that it supports serializability.

The JavaSpaces speci cations adopts the following lock mechanism for trans- actions: \When read, an entry is added to the set of entries read by the pro- vided transaction. Such an entry may be read in any other transaction to which the entry is visible, but cannot be taken". This policy in necessary in order to ensure serializability of transactions as described by the following example. Consider the con guration

Con gurations are the parallel composition of available data, programs, and active transactions. Available data are modelled by terms haiX , where a de- notes the datum and X the set of active transaction from which the datum has been read (it is usually omitted when empty); this information is necessary to implement the transaction policy described above. Programs are represented by terms C containing the coordination primitives.

A transaction is started by a create operation and it is possibly terminated by a commitment operation, performed by all the involved processes. When performed within a transaction, a read operation may test for presence either a datum produced under that transaction or a datum in the external envi- ronment. As discussed above, when a datum is read within a transaction it cannot be consumed by processes outside that transaction. A take operation behaves in a similar way, and the selected datum is withdrawn from the datas- pace. A datum written within a transaction will not be visible to processes outside the transaction until the transaction commits; before commitment, this datum can be consumed by a process inside the transaction; in that case, the object will never become externally visible.

because the datum should not be previously read within active transactions. Axiom (2) models the read operation (in this case the subscript set of trans- action names does not play any role). Axiom (3) indicates that the e ect of the execution of a write(a) operation is the production of the datum hai; (the subscript set of transaction names is initially empty).

Each active transaction is identi ed by a unique name; we model this naming mechanism by associating to each transaction a fresh name (i.e. a new name which has not been previously used in the agent). For the sake of simplicity, we do not formally model any mechanism to ensure the global freshness of names, however, standard mechanisms can be exploited which allow for the propagation of locally-fresh names.

In the following we need the following notation: txn(X: ) = txn(X: ) = txn(X: ) = X to denote the transaction names occurring in a transition label and actxn(P ) = fx  j 9C ; Q s.t. x fQg or x : C fQg is a subterm of P g to denote the set of the transactions active in a con guration.

the transaction; nally, the transaction commits. This computation is clearly non-serializable because the unique way to perform the test for absence and the output operation outside the transaction is to execute them after the take(a) but before the take(b) operations inside the transaction. This kind of problem is solved in JavaSpaces by avoiding the consumption of data taken within a transaction: these data are simply locked and they are removed only when the transaction commits. Locked data can be neither read nor consumed, and disallow the execution of operations testing the absence of data of that kind. We now discuss a further problem concerning serializability in the pres- ence of test for absence operations which is not addressed in the JavaSpaces

Axiom (30) introduces the new label ~a denoting the execution of a write(a) operation. Axioms (40) and (50) are the adaptations of the corresponding rules to the new syntax; in particular, (50) updates the set of data removed from the environment by input operations inside the transaction. Axiom (70) intro- duces the new label X:A  (the notation  j aj denotes the multiset union of all the singletons faj g).

A transition labelled with :a, representing a test for absence of a, can be performed only if the environment does not contain any hai and also no hai have been previously consumed inside an active transaction (see rule (18)). Moreover, when a test for absence is performed inside a transaction, the sub- script set T of data tested for absence must be updated (see rule (19)). Ac- cording to rule (20) a transaction can commit only if the data it introduces in the shared repository are not currently tested for absence inside other active transactions; moreover, the side condition Data(Q) = ; ensures that all the data available in the environment when a transaction commits are taken into account by the rule (70) (which introduces transaction commitment). Rule

The new program notify(a; C ):P can register its interest in the future in- coming arrivals of the data of kind a, and then receive communication of each occurrence of this event. When this event occurs, a new instance of the program C is activated as reaction to the event. This behaviour can be modelled by introducing a new term on(a; C ), which is a listener that spawns an instance of program C every time a new object hai is introduced in the dataspace. Formally we extend the con gurations as follows:

According to the JavaSpaces speci cation \a notify ... applies to write operations that are committed to the entire space. A notify performed under a ... transaction additionally provides noti cation of writes performed under that transaction." Following this approach a listener inside a transaction has

