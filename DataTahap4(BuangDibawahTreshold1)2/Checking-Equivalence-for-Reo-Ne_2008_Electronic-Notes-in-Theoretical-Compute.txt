Reo is a channel-based exogenous coordination language [1]. It was invented to provide the glue code for describing how component instances communicate with each other and how they are coordinated. Since then it has been used to model many different complex systems. The Reo point of view is that a system consists of component instances which execute at different locations and communicate through connectors. The main idea is to define a small set of simple channels and their behavior. More complex connectors then can be constructed through composition of these simple channels. During design

straint automata in section 2. Section 3 explains how the compositional ap- proach to generate a constraint automaton from a given Reo circuit can work symbolically. Then section 4 explains the main features of our implementation and section 5 reports on our experimental results.

Due to the fact that in constraint automata there is no way to distinguish between incoming and outgoing ports we have to use two different operations to mimic the merge semantics of Reo nodes. On the automata level we first provide the product automata operator for joining a source node with another node (no matter what type). Then we use a merger automaton to simulate the merger behavior of multiple joined sink channel ends. This merger automaton can be regarded as a new primitive connector in the Reo circuit plugged before the old node which just performs a non-deterministic choice on its source ports and forwards the chosen data to the old node. Its semantics can be represented by a constraint automaton with only one state and self-loop transitions for every incoming channel-end.

give a constraint automaton describing the desired behavior. Then compar- ing its behavior with the behavior of the constructed Reo circuit shows if the Reo circuit is a correct implementation. This is sometimes called a homoge- neous approach to verification (model checking). There is a strong connection between this problem and the bisimilarity of constraint automata. An algo- rithm computing the bisimulation relation therefore can be of great help when treating larger Reo circuits. We start with some notations which are needed to introduce bisimulation for constraint automata.

To obtain compact BDD-representations of constraint automata the vari- able ordering must be chosen carefully. A detailed description of our heuristics to determine a good variable ordering goes beyond the scope of this paper. We just mention that our heuristics attempt to put variables representing constraints close to variables representing states having transitions relying on those constraints.

