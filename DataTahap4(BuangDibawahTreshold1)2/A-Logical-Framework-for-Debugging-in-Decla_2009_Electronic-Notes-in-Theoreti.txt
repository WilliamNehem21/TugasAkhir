Debugging tools are a practical need for diagnosing the causes of erroneous computa- tions. Declarative programming paradigms involving complex operational details, such as constraint solving and lazy evaluation, do not fit well to traditional de- bugging techniques relying on the inspection of low-level computation traces. As a solution to this problem, declarative diagnosis uses Computation Trees (shortly, CTs) in place of traces. CTs are built a posteriori to represent the structure of a computation whose top level outcome is regarded as an error symptom by the user.

Each node in a CT represents the computation of some observable result, depending on the results of its children nodes. Declarative diagnosis explores a CT looking for a so-called buggy node which computes an incorrect result from children whose results are correct; such a node must point to an incorrect program fragment. The search for a buggy node can be implemented with the help of an external oracle (usually the user with some semiautomatic support) who has a reliable declarative knowledge of the expected program semantics, the so-called intended interpretation.

The rest of the paper is organized as follows: Section 2 motivates our approach by presenting a debugging example which is used as illustration along the rest of the paper. Section 3 recalls the CFLP (D) scheme from [14] to the extent needed for understanding the theoretical results in this paper. Section 4 presents a correct method for the declarative diagnosis of wrong computed answers in any soundly im- plemented CFLP (D)-system. Section 5 describes the debugging tool DDT . Section

[11] or T OY [15], or formal goal solving calculi including recent proposals such as the CDNC(D) calculus [22], which is sound and complete w.r.t. the declarative semantics discussed in the next subsection, and behaves as a faithful formal model for actual computations in the T OY system.

For instance, the computed answer shown in Example 2.1 is wrong w.r.t. the in- tended model for the program assumed in that example, for the reasons already discussed in Section 2. As illustrated by this example, computed answers typi- cally include constraints on the variables occurring in the initial goal. However, goal solving systems for CFLP (D) programs also maintain internal information on constraints related to variables used in intermediate computation steps, but not occurring in the initial goal. Such information is relevant for declarative debug- ging purposes. Therefore, in the rest of this section we will assume that computed answers S include also constraints related to intermediate variables.

In addition to CDNC(D), other formal goal solving calculi known for CFLP (D) are also CPPC(D)-sound. Moreover, it is also reasonable to assume CPPC(D)- soundness for implemented goal solving systems such as Curry [11] and T OY [15] whose computation model is based on constrained lazy narrowing. Moreover, any CPPC(D)-sound goal solving system is semantically sound in the sense of item 2 in Definition 3.3:

Proof. For each of the inference rules EX, ARf , and FAf , we prove that an arbitrary model I |=D P such that the premises of the rule are valid in I, also verifies that the conclusion of the rule is valid in I. Similar proofs for the other inference rules in CFLP (D) can be found in [14].

The previous theorem does not yet provide a practical method for finding an erroneous program rule. As explained in the Introduction, a declarative diagnosis method is expected to find the erroneous program rule by inspecting a CT . We propose to use abbreviated CPPC(D) proof trees as CTs. Since DFP is the only inference rule in the CPPC(D) calculus that depends on the program, abbreviated

A node in an APPT (D) is called a buggy node iff the c-statement at the node is not valid in the intended interpretation I, while all the c-statements at the children nodes are valid in I. Our last theorem guarantees that declarative diagnosis with APPT (D)s used as CTs leads to the correct detection of program errors. A proof is given in the Appendix.

We have presented a logical and semantic framework for the declarative diagnosis of wrong computed answers in CFLP (D), a generic scheme for constraint functional logic programming over a given constraint domain D. The diagnosis technique re- presents the computation which has produced a wrong computed answer by means of an abridged proof tree whose inspection leads to the discovery of some erro- neous program rule responsible for the wrong answer. The logical correctness of the method can be formally proved thanks to the connection between abbreviated proof trees and program semantics.

