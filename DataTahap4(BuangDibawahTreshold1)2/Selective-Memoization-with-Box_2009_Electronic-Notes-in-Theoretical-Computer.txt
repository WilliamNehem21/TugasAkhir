However, we cannot assign a new value to the same box. Furthermore, the encap- sulation of a value v by a box signals that v should be explored to reveal its control and data dependences. Particularly, in practice, memoized functions involve a box type in their domains.

Our paper is organized as follows: after this introduction we present a system SM of selective memoization with box types in section 2. The auxiliary system S, which keeps the selectivity mechanism but without effects (storages), is developed in section 3, where we also prove that it is type safe. In section 4 the type safeness of SM is proved by means of a faithful translation to S. A translation of S to PCF is provided in section 5 proving indirectly the soundness of the original effectful evaluation semantics of SM with respect to the purely functional semantics of PCF. Finally in section 6 we provide some closing remarks and future work.

where box t is the constructor of box typed terms; and mfunl(f.a.e) defines a memoized, usually recursive, function with name f , in this case the metavariable l belongs to a set L of label locations disjoint from ordinary variables and resources. The dot notation on abstractions, case analysis and function declarations denotes

Variable contexts correspond to the validity context of [11] whereas resource context correspond to truth contexts. We use a third context for labels to keep exact track of the labels occurring in a term or expression. With aid of this context we will statically ensure that location labels of different functions in a same program will be different.

Terms. The same terms as for SM except for the memoized functions declaration where now there is no label associated with a function. That is, we use terms of the form mfun(f.a.e) instead of mfunl(f.a.e). This class of term is called named function.

Inductive step: assume that there are n + 1 inference rules from e1[f, a := v1, v2] up to e. The proof proceeds by a case analysis on the top rule and is illustrated for the case of rule (Eletbox). In this case we have e' = let box(t, x.e1), e = e1[x :=

We have now fulfilled our main goal. However, although system S does not have explicit effects, from a strict point of view, this system is still not pure, for it keeps the distinction between types and expressions as well as the selectivity feature. To solve this problem we provide a translation of S to the purely functional language PCF.

The framework MFL of selective memoization makes explicit the performance effects of memoization by capturing control and data dependences between the input and the result of a memoized function. Moreover it yields programs whose running times can be analyzed by standard techniques and has been implemented as an SML library. An essential feature of the system is the use of a modal type to reveal dependences. In this paper we have presented a framework SM, similar to the one developed in [2], with the following improvements from the theoretical point of view: instead of the bang modality, which in our opinion, was an ad-hoc choice for the implementation of the original system, we use the box type corresponding to the necessitation modality deeply discussed in [11] from the logical point of view. We provide our system with a static semantics which keeps exact track of the location labels occurring in a term or expression. Hence, we statically ensure the uniqueness of the label assignment for memoized functions. Type safeness for SM is proven by its translation to an effect-free system which is later translated

Memoization becomes more complicated when the language includes composite value types like records, in that case the data dependencies should be as fine-grained as possible, as discussed in [4]. Therefore, it is interesting to pursuit the modeling of such dependencies in our framework. Last, but not least, and regarding the inclu- sion of recursive types, we recall that memoization is most effective when applied to the kind of programs used in dynamic programming, which usually are neither sim- ple iterative nor primitive-recursive, but course-of-value recursive. This fact leads us to investigate an extension with inductive types modeling the latter principle, motivated by our previous work in [7].

