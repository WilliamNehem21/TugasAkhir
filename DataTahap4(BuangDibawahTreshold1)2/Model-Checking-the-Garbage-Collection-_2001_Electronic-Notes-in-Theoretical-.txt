There is extensive previous work on the application of model checking to the source code of railway interlocking software [25,33,10,11,18,17]. While technically a railway interlocking is a piece of software, the semantics of railway interlocking languages are extremely simple, to the extent that Sheeran and St almarck term interlockings hardware-like systems [35]. In this paper, we apply model checking to software written in the general purpose language C. Godefroid [22,23] describes VeriSoft, a tool for model checking concurrent software written in C or C++, and the successful veri cation of a 2500 line concurrent C program is noted. The focus of [22,23] is the search algorithm, which performs a variety of explicit state space exploration. Stoller [36] takes an approach similar to that of [22,23] for Java programs. In this paper, we do not modify the model checking algorithm. Rather, we use c2edl to translate C code into the input language of our model checker, and use the existing

Demartini, Iosif and Sisto [15] describe the application of the SPIN model checker to Java multithreading applications. They describe the process of translating Java source code into PROMELA, the input language of SPIN. Their goal, like that of this paper, is to verify source code, using automatic abstraction techniques to get a simpli ed model. They demonstrate their technique on toy examples. Havelund and Pressburger [26] take an approach similar to [15] in the rst generation of their tool Java PathFinder, but support more of the language, and note results for Java programs of up to 2000 lines of code. In both [15] and [26], the translation is complicated by the need to model the concurrency primitives of Java, while the method used by c2edl is free of those concerns. On the other hand, the translations of [15,26] are in some ways simpler than that of c2edl, because the PROMELA language allows them to retain much more of the structure of the original program than

Visser, Havelund, Brat and Park present the second generation of Java PathFinder in [37]. While the rst generation translates Java source code into PROMELA, the second generation is a full-blown custom-made model checker for Java. In contrast, we have not developed a new model checking algorithm, but used modeling techniques to allow the application of an existing one.

 nite state models from Java source code. They perform user-guided abstrac- tions based on reducing the cardinality of data sets, and provide a language for specifying additional abstractions. They translate Java to an interme- diate language which is then translated to one of a number model checking languages. They demonstrate their method on a toy example, a threaded pipeline consisting of 60 lines of Java code. In contrast, c2edl is completely automatic, and we present results for a non-trivial application.

Esparza, Hansel, Rossmanith and Schwoon [20] describe model checking algorithms for pushdown automata. They take, as we do, the radical approach of abstracting away all variable values. However, they are not limited to a nite stack. In contrast, c2edl produces a nite state model for RuleBase. They give impressive results for randomly generated ow graphs (skeleton programs) of up to 20,000 lines.

The work described in this paper was performed using RuleBase [6]. RuleBase was originally based on a version of SMV [32]. After eight years of develop- ment [4,8,3,9,7,5,6,21], the original SMV code is a small part of the whole. Nevertheless, the garbage collection mechanism of SMV remains.

Of course, an interesting C program will typically be more complicated than function getmax(). Extending the translation to other kinds of branch- ing and loop statements is straightforward. However, the translation process should also be able to deal with complex data types, pointers, and function calls, including recursive function calls. All of these could be dealt with by mimicking a compiler, or by starting the translation from assembly or machine code 2 . However, such a solution would be purely theoretical, since the state explosion problem would make it impossible to model check all but the most trivial programs. In the next section, we describe the solution used by c2edl.

Using a model built by c2edl, the usage of the garbage collection mechanism was checked for SMV version r2.4.4, and for RuleBase, which uses the same mechanism. C2edl was invoked in a mode in which bit vectors are used instead of integers (see Appendix A), with the stack limited to a depth of 5.

RuleBase itself was checked as well. In particular, a function called reduc- tion(), which was being debugged at the time, was checked. The generated model consisted of 2630 lines of code (that is, the value of the program counter ranged from 0 to 2629). Out of 352 formulas checked, 47 failed. Of those,	39

with the use of the garbage collection mechanism. The used of c2edl allowed these problems to be found statically using RuleBase, before the usual regres- sion testing of a new version had begun. While problems with the use of the garbage collection mechanism are usually very painful to debug, the use of c2edl and RuleBase allowed them to be found and xed easily. Instead of an unexpected result or a mysterious segmentation violation, which is the indica- tion of a test gone wrong, the counter-examples generated pointed precisely to the source line (as indicated by the program counter) exhibiting the problem.

release bdd() on line 12 releases the value which was saved inside of function f() on line 0. However, Formula 4 will ag a second call to function f() as a violation, because it does not "see" a call to release bdd() for signal p (the call on line 12 releases signal a) between the two assignments to variable p from two separate calls to the function. These and other false negatives can be avoided by adherence to certain coding conventions.

probably do not completely express the correct use of the garbage collection mechanism of SMV. The second problem is more serious. Since we have limited the depth of our stack, we will not nd errors which occur for only deeper levels of nested calls. This is a fundamental problem of the model of software as we have described it. The problem of false positives means that our method cannot be used for the veri cation of software. However, false positives are not a barrier to the use of the technique in the falsi cation of software. It is in the practical light of falsi cation, then, that this work should be viewed.

My original model of the garbage collection mechanism of SMV was much more complicated than that described in this paper. Thank you to Ilan Beer, who pointed out that the mechanism and its correct use could be expressed solely as a function of the program counter. Thank you to Shoham Ben- David, Avigail Orni, and Yaron Wolfsthal for their time reviewing and for helpful comments.

