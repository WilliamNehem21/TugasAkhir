An interesting possibility created by this approach is a novel scheme for validating optimizer implemen- tations. An optimizer can be instrumented to generate a trace of its transformations in terms of the transformation primitives. Conformance of the trace with the optimizer can be checked through simulation. If soundness conditions of the underlying primitives are satisfied by the trace then it preserves semantics.

The rest of the paper is organized as follows: Section 2 introduces the specifica- tion mechanism. Section 3 describes the verification technique and introduces TTL. Section 4 proposes a validation scheme. Section 5 describes how proof obligations can be automatically generated from the specifications of optimizations in PVS. Section 6 reviews related work. Section 7 concludes the paper and proposes future directions.

We now specify control flow analyses for identifying loops. A program point p dominates a program point q if along all backward paths from q, p is reachable. This property is defined as the predicate Dom. Let xs be a set of program points of prog. A program point p dominates xs if it dominates each member of xs. This is defined as the predicate DomS. The set xs is a strongly connected component if for every pair of program points in it there is a (non-empty) directed path whose intermediate program points also belong to xs. This is defined as the predicate Scc. A set of program points xs is a Loop if it is a strongly connected component, there is a program point in xs which dominates it, and the predecessors of other program points of xs are also in xs. The program point in a loop which dominates it is called its Header.

The function RE is a transformation primitive which takes a program and re- places expressions at the given program points by a given variable. Here, it trans- forms program prog3 by replacing invariant occurrences of e at invoccurs by the variable t. This accomplishes loop invariant code motion.

Consider two states i and j of M such that i is a predecessor of j. We want to add a new state k as a predecessor of j and a successor of i. The new state k is distinct from the states of M. We add an edge from i to k and an edge from k to

In the second transformation, an assignment ASSIGN(t, e) is inserted along all incoming edges of the loop header except the looping edge. Within the loop, neither the variable t nor any of the variable operands of the expression e are assigned. Hence t has the same value as e along all incoming paths to a program point in invoccurs. Therefore, the occurrence of e at such a program point can be replaced by t while preserving semantics of prog3.

We now prove soundness of the last transformation RE in LICM which is applied on prog3. It replaces the occurrences of the loop invariant expression e at the program points invoccurs within the loop xs with the variable t. We have to show that SoundRE(prog3, invoccurs, t) holds.

The validation scheme consists of two parts: (1) The input program is abstracted and its transformed version is derived by simulating the trace on it. If the abstrac- tion of the optimized program matches this abstraction then the trace is faithful to the optimization performed. Two abstractions match each other iff their control flow graphs are isomorphic and contents at corresponding program points are same, modulo a globally consistent renaming of variables. (2) It is checked whether the soundness conditions of the transformation primitives used in the trace are met on the respective abstractions. This establishes whether the trace preserves semantics. If both these checks succeed then the optimizer preserves semantics of the input program.

PVS parses and typechecks the specifications. It annotates the parse tree with typing information and keeps it in Common Lisp Object System (CLOS) format in PVS ILisp. PVS ILisp process runs as a subprocess of Emacs Lisp interpreter [2]. We probe the CLOS objects through Emacs interpreter using pvs-send-and-wait com- mand. We identify the transformation primitives and the context in which they are used by walking the annotated parse tree of the specification. We then generate a PVS theory containing the soundness proof obligations for each of the transforma- tion primitives used with the appropriate context. These proof obligations need to be discharged in order to prove that the optimization specification is sound. We are trying to develop high-level proof strategies so that these proof obligations can be discharged easily.

The Verifix project [4,6] addresses the issue of construction of correct compilers. They distinguish between correctness of specifications and their implementations. They also consider the correctness when the machine resources are finite. In [3], the concept of program checking with certificates is introduced and applied to opti- mizing compiler back-ends. The compiler generates a trace of its search for optimal target code as a certificate of correctness.

Based on our approach of identifying transformation primitives and their sound- ness conditions, we suggest a novel validation scheme: An optimizer can be instru- mented to generate a trace of its transformations in terms of the transformation primitives. Conformance of the trace with the optimizer can be checked through simulation. If soundness conditions of the underlying primitives are satisfied by the trace then it preserves semantics.

We are developing TTL inference rules for several kinds of transformations. As part of future work, we would like to apply them for proving soundness of control flow optimizations that may change program structures significantly like loop unrolling, loop fusion, etc. Our framework needs to be extended for handling optimizations like constant propagation which are based on non-bit vector analyses.

