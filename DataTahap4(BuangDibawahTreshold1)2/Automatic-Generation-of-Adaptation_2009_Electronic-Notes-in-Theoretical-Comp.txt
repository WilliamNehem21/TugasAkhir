issue: the adaptation of components/services 4 with mismatches at signature and behavior levels [4]. Interface Description Languages (like CORBA and WSDL for components and services, respectively) allow the composition of software written in different languages but, even though IDLs help solve the language barrier, they do not address behavioral incompatibilities. This paper focuses on the adaptation of both signature and behavior inconsistencies.

Brogi, Bracciali, Canal and Pimentel [6,7] developed a formal methodology aimed at automatically deriving adapters from the interfaces (including the behav- ioral description) of the services. This methodology is based on the initial agreement between the parts involved about an abstract adaptation contract. This contract contains a mapping between the operations of the services in such a way that, when the adapter applies these correspondences, all the services cooperate properly and they end up in a final state. However, no insight was given about how this contract is constructed and it is assumed to be handmade. This is an error-prone task which obliges the designer to have a full understanding of all the service details. In this work we introduce an approach which addresses this issue.

The rest of the paper is organised as follows. In section 2 we introduce the sub- set of abstract BPEL used to describe service interfaces. We introduce a simplified example of a file exchange system in section 3 which will be used throughout the paper to illustrate the contract generation process. The notation for abstract con- tracts used throughout the concepts and ideas applied in the development of the proposal are described in section 4. Thereafter, in section 5, we explore the different parts of our approach and further details of the process. In section 6 we reference some related work and, finally, in section 7, we present future extensions and some conclusions.

We propose a subset of abstract BPEL [1] as the language to represent the service behaviors. This subset of abstract BPEL contains enough information to extract a behavioral interface that can be represented by Finite State Machines (FSMs). FSMs will allow us to graphically represent the behaviors in a more concise manner than BPEL and to define the operational semantics of the extracted model.

<while> and <forEach>. Because of the critical role played by the condition of these activities we model them as <pick> or <if> activities depending on whether the decision is made locally or on reception of a particular message. The branches of these activities are allowed to be loops, therefore we distinguish between pick- loops and if-loops.

We now introduce a case study that we will use throughout the paper to illustrate our approach. It consists of a file exchange system composed of a client and a server, but these were built in different contexts so they have mismatches in their signature and behavior. We provide the abstract BPEL code of the server 6 in Listing 1. As far as we focus on the adaptation between two parties, our BPEL code assumes that every message is received/sent from/to the other party instead of using partnerLinks and portTypes to define the particular source or destination.

Brogi et al. [6,7] introduced a simple, high-level notation for describing the corre- spondences between the transitions of two processes being adapted. This notation is used to represent the abstract adaptation contract by a set of mappings between the operations of two services (that we will refer to as left and right services). Here, we will briefly present this notation which will be used to represent the generated contracts.

The purpose of the valuation of a mapping (v) is to represent how bad a single mapping is. The higher the mapping valuation, the worse for the adaptation. A perfect mapping should have a value of 0. The function v is informally explained as:

Mapping indeterminism: Line 2 stands for the penalization of mappings which starts with receive actions in both sides. This is so because the adapter should trigger those mappings by its own responsibility, without receiving any message from the services indicating such a thing. Nonetheless, in some cases, it is possible to know without ambiguity when such mappings should be triggered.

Listing 2 contains one of the rules stated above, in particular the rule in charge of splitting the search graph when it finds conditional branches. The client and server processes are differentiated by their ?side. This rule is triggered when a contract is marked for further exploration by the A* algorithm (childrenNeeded TRUE) and the node to process is an ?ifActivity. Then it retracts the fact that the <if> must be processed and splits the search into as many graphs as conditional branches.

We have implemented our proposal in a tool called Dinapter 8 . It takes as inputs the behaviors of the services to be adapted, described using abstract BPEL. Those behaviors are internally modeled into two directed graphs that will be explored during the automatic generation of the contracts. The output is a set of adaptation contracts expressed in the notation introduced in section 4.

Let us comment on two of these examples. The two processes in e12 are able to accept or reject the communication before performing their core functionality so, as their behaviors are quite incompatible, the first contract returned by Dinapter makes them refuse to communicate and end up in a final state. Nonetheless, if we execute another iteration of the process in the example e12, it returns a valid solution. The example e02c is the one described in section 3.

Another interesting point is the relevant role played by the A* algorithm and the underlying heuristic function which, even though there is a state explosion if the problem is difficult enough, it reduces the number of explored nodes to half of the nodes generated, approximately. As we stated at the end of subsection 5.1, the number of generated search trees (T rees) is proportional to the number of explored contracts (Exp. Cons.). Any enhancement in the heuristic and the procedure for generating and merging those trees will greatly improve the efficiency of our tool.

Moser et al. [14] developed a platform (VieDAME) based on ActiveBPEL for the monitoring and service adaptation of BPEL processes. They dynamically replace services based on QoS in a non-intrusive manner using aspect oriented programming. They adapt services using Transformers but these transformers must be designed

As regards automatic generation of adaptation contract, Schmidt and Reuss- ner [19] focused on the synchronization of two components accessing, or being ac- cessed, by a third one. They introduced an algorithm based on synchronous prod- uct computation to semi-automatically solve missing message incompatibilities, but their approach fails to overcome signature mismatches and behavioral incompatibil- ities like message reordering or message splitting/merging. Autili et al. [3] proposed a methodology for the automatic synthesis of adapters considering as input behav- ioral descriptions of components and a specification of the interactions that must be enforced in the system. Then, their tool (Synthesis) generates composition code that exhibits only the specified interactions, and prunes those which lead to dead- locks. Similarly to [19], same names of messages are assumed and some behavioral mismatches cannot be solved (such as message splitting/merging). In addition, this approach relies on a high-level description of the composition goal, and therefore does not work without such specification.

Let us now mention two related works [8,15] that tackled Web Service adapta- tion. In the first one, Brogi and Popescu [8] outlined a methodology for the au- tomated generation of adapters capable of solving behavioral mismatches between BPEL processes. In their adaptation methodology they use the YAWL workflow as an intermediate language. Once the adapter workflow is generated, they use lock analysis techniques to check if a full adapter has been generated or only a partial one (some interaction scenarios cannot be resolved). They solve message reordering incompatibilities but their approach fails with signature mismatches. In addition, even if we applied our approach to BPEL services as well, we want our approach to be more general by working on abstract descriptions of services that can be ex- tracted from BPEL but also from other programming languages and platforms such as Windows Workflow Foundation [10].

Motahari Nezhad et al. [15] presented an approach for assisting the developer to adapt new versions of existing Web Services. In their approach, they use a schema matching tool called COMA++ [2] over the service WSDL signatures. Our approach has some similarities with their work (our heuristic plays a similar role as their evidences), and they introduce some interesting ideas about deadlock han- dling. However, although they are able to generate a mismatch tree that gathers all protocol mismatches, its resolution is not automatic.

Our work has been focused on contract generation between two services. Future work is to extend our approach to more expressive languages and semantics like STS [12], or SCC [5], which is focused on service orchestration and it supports explicit session and exception handling. In any case, this work shows the feasibility of the proposed approach. Regarding validation, another of our future works is to apply our tool results to other methodologies for adapter generation and to check their bisimilarity with adapters generated from hand-writen contracts.

Unlike most proposals for mapping generation [15] and schema matching [2], our approach relies only on the behaviors and the arguments of the services. However, our approach can be extended to include semantic and syntactic information to improve its heuristics. One way to achieve this could be to compare the semantics behind the operations and their arguments using Wordnet::Similarity [16].

