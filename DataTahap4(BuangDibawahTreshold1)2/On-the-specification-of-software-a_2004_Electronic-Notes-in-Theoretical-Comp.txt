The problem of adapting heterogeneous software components that present mismatching interaction behaviour is one of the crucial problems in Component-Based Software Engineering. The aim of this paper is to contribute to setting a theoretical foundation for software adaptation. A formal analysis of adaptor specifications is presented, and their usage to feature different forms of flexible adaptations is illustrated.

Component adaptation is widely recognised to be one of the crucial problems in Component-Based Software Engineering [4,7]. The possibility for applica- tion builders to easily adapt off-the-shelf software components to work prop- erly within their applications is a must for the development of a true com- ponent marketplace, and for component deployment in general [3]. Available component-oriented platforms feature Interface Description Languages (IDLs) to address software interoperability at the signature level. IDLs are a sort of

One of the distinguishing features of the methodology is the simplicity of the notation employed to express adaptor specifications. Indeed the desired adaptation is simply expressed by defining a set of (possibly non-deterministic) correspondences between the actions of the two components. While adaptor specifications have been thoroughly employed in [1] to address various exam- ples of adaptation, a formal and precise characterisation of these specifications had not been developed.

The aim of this paper is precisely to set a theoretical foundation for soft- ware adaptation. In particular, after presenting a simple motivating example to illustrate the adaptation methodology (Sect. 2), we will focus on adap- tor specifications and start by presenting their precise syntax (Sect. 3). We

The objective of software adaptation is to deploy a software component, called adaptor, capable of acting as a component-in-the-middle between P and Q and capable of supporting their successful interoperation. A concrete adaptor will be automatically generated starting from the interfaces of the components and from a specification of the adaptor itself. Such a specification simply consists of rules establishing correspondences between actions of the two components. The natural specification of the adaptor for the example at hand is:

Adaptor specifications can be employed to specify the desired adaptation be- tween two components that present mismatching interaction behaviour. Given an adaptor specification and the interfaces of the components to be adapted, the automatic procedure described in [1] derives (if possible) a concrete adap- tor by exhaustively trying to build a component which satisfies the given specification while letting the components successfully interoperate. While the ultimate result of the process of software adaptation is a concrete adaptor component (if any), in many situations it is more convenient to present such a result in the form of an adaptor specification.

The methodology for software adaptation described in [1] has been recently extended in [2] to feature forms of soft adaptation. One of the key notions introduced in [2] is the notion of sub-service. Intuitively speaking, a sub- service is a kind of surrogate of a service, which features only a limited part of such service. For instance, in the above video-on-demand service, offering a clip preview of a movie can be considered a typical sub-service of offering the whole movie.

We have seen that adaptor derivation can be described as a transformation over adaptor specifications. Soft adaptation may generate a soft adaptor that does not strictly satisfy the initial adaptor specification. Namely the derived adaptor is described by a specification which is a reduction of the initial spec- ification where some services have been possibly sub-serviced.

A number of practice-oriented studies have analysed different issues en- countered in (manually) adapting a third-party component for using it in a (possibly radically) different context (e.g., see [5,6,10]). On the other hand, while component adaptation is widely recognised to be one of the crucial prob- lems in Component-Based Software Engineering, quite a few efforts have been devoted to develop its foundational aspects.

components with mismatching behaviour interoperate. They used finite state grammars to specify interaction protocols between components, to define a relation of compatibility, and to address the task of (semi-)automatic adap- tor generation. Some significant limitations of their approach derive from the expressiveness of the notation used, such as the impossibility of representing internal choices or parallel composition of behaviour. Moreover, the asymmet- ric meaning they gave to input and output actions made it necessary the use of ex-machina arbitrators to control system evolutions. Last, but not least, adaptor specifications in [9] allowed only to express one-to-one relations be- tween actions, a severe expressiveness bound when facing non-trivial protocol adaptations as discussed in [1].

Finally, we foresee different lines for future investigations. A natural di- rection is to extend the formal treatment of adaptor specifications to consider data dependencies across different actions, which may be defined by introduc- ing action parameters in correspondence rules. Another interesting extension is to consider multi-party adaptations, rather than pair-wise adaptations. No- tice that the syntax of adaptor specifications can be naturally lifted to deal with n components, by simply interpreting the operators 0 and 00 as polyadic rather than diadic, allowing rules of the form:

The work of A. Brogi has been partly supported by MIUR Project NAPOLI. The work of C. Canal and E. Pimentel has been partly supported by the projects TIC2002-4309-C02-02 and TIC2001-2705-C03-02, respectively, funded by the Spanish Ministry of Science and Technology.

