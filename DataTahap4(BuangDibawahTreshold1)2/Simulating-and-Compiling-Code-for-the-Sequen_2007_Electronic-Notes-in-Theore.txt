The rapidly growing field of quantum computation and quantum information is still in its infancy, largely due to the lack of a substantial, practical quan- tum computing device. However, the theoretical potential of such devices is widely acknowledged. Presently, the only realistic avenue of investigation for an interested computer scientist is the use of quantum computer simulators.

Currently several quantum simulators are available, including tools for an- alyzing quantum circuits and interpreters for quantum programming lan- guages [3,12]. The work presented here is also closely related to that described in [2,12,15], which deals with the issues involved with the design of quantum programming languages. Our work develops a more complete suite of tools consisting of separate (but interacting) parts for compilation and simulation; it also allows compiled code to be stored.

The classical component has two distinct memory locations, one for programs and one for data. We have chosen to deviate slightly from the conventional Von Neumann model, where programs are treated in the same way, and in the same location, as the data they manipulate. The CPU keeps track of the current instruction in a program through the program counter, which indexes a location in the program store.

The operating cycle of the SQRAM is as follows. Program execution be- gins with the program counter, local base, and stack top all initialized to 0. An instruction is retrieved from the location given by the program counter and executed, the process is then repeated. Most instructions cause the program counter to be incremented but some (such as jumping and halting instruc- tions) have different effects for a listing of the available classical instructions). Program execution is finished once the program counter goes past the end of the program store.

The example mostly illustrates quantum instructions; the functions per- formed by classical instructions should be familiar to most readers. The only classical instruction used in this example is SAVE, which stores the result of the measurement at the top of the classical stack. Further code could condi- tionally jump based on this value to give feedback to the user.

A quantum programming language provides an elegant mixture of classical control structures and quantum operations; this is something which is very difficult, if not impossible, to implement in the standard quantum circuit model. The use of quantum programming languages fits in well with the model of computation used by our SQRAM machine (and by most quantum algorithms). This computational model is more familiar to computer scientists than the circuit model, and we expect it to greatly ease the development of new quantum algorithms.

The inability to clone an unknown quantum state has a direct effect on the behavior of statements which involve assignment; these include direct assign- ment and passing values to functions. Because it is not possible to actually copy the value many languages make use of references and hence have many variables pointing to the same qubit. Other languages may forbid the direct assignment of quantum variables.

A transformation is applied to a quantum data type using the = operator. For example, the built-in unitary transformation U could be applied to q as follows: (q = U ). There are two situations to consider here. Firstly U might be a single qubit operation which we wish to implement directly using the GATE instruction. This becomes:

In Section 4.2 we discussed the principle of universality, stating that any quan- tum operation can be broken down and implemented in terms of a small set of universal gates. Hence our SQRAM machine only provides operations corre- sponding to these universal gates and it is the job of the compiler to perform the decomposition. This decomposition is a complex process and work has been done on it by a variety of different people and research groups. We bring this work together to form a complete compilation process and provide an analysis of its efficiency.

Note that the CNOT gates are active when the control qubit is 0 , rather than the more conventional 1 . The problem then is how to generate the series of CNOT gates which rearrange the computational states in the appropriate way. A solution involving the use of Gray codes is covered by [11] and a description within the context of our compiler is provided by [18].

A discussion of the actual physics involved in building a quantum computer has been avoided in this paper and, as far as possible, in the SQRAM model. In practice there are many physical matters which would affect the behavior of a real SQRAM device. For example, when using the ion trap technique [4] it is easier to perform operations on multiple qubits if they are adjacent to each other. It would be interesting to integrate such constraints into our design.

The QPL compiler implements only a subset of QPL, the focus being on those parts which were necessary to test ideas presented in this paper. More work on the classical control structures would enable a wider range of programs to be implemented and better data structures (currently only limited support for lists is available) would allow more interesting algorithms. We also plan to extend the compiler with features for concurrency and communication.

lator. Such constructs are available in the language CQP due to Gay and Nagarajan [8], which allows the description of quantum protocols, such as quantum key distribution and quantum teleportation. We aim to incorporate support for CQP in the QPL compiler; the simulator has already had such support added.

