The combination of state exploration approach (mainly model checking) and deductive reasoning approach (theorem proving) promises to overcome the limitation and to enhance the capabilities of each. In this paper, we are interested in defining a platform for Multiway Decision Graphs (MDGs) in LCF-style theorem prover. We define a platform to represent the MDG operations: conjunction, disjunction, relational product and prune-by-subsumption as a set of inference rules. Based on this platform, the reachability analysis is implemented as a conversion that uses the MDG theory within the HOL theorem prover. Finally, we present some experimental results to show the performance of the MDG operations of our platform.

Model checking models the system as a finite-state system and automatically decides if a temporal property holds in the desired states of the system. Further- more, model checking can produce a counterexample when the property does not hold, which can be very important for the understanding of the corresponding er- ror in the implementation under verification or in the specification itself. However, model checking suffers from the states explosion problem when dealing with complex systems.

Moreover, the growing importance of model checking in hardware verification and the difficulty of producing correct software are driving a growing interest in the application of model checking to software. This leads to many challenges of scientific and practical interest in the core of model checking technology. However, the transfer of this technique was very slow due to the state explosion problem and the semantics gap between the software developers and the verification tools. Two approaches can be used to tackle these problems: developing new dedicated techniques for software. The advantage of this approach is that the difficulty of applying software model checking is addressed directly [21]. The other approach is the integration of existing tools by using high (abstract) modeling techniques. The advantage of this approach is that the reusing an existing tool and therefore the effort is oriented towards the integration part. The integration of Multiway Decision Graph (MDG) with Bandera framework [8] is a good example of this approach [18].The authors introduced a schema for translating the intermediate representation of a JAVA program using the Bandera framework to the language of the MDG model checking.

Our approach is based on embedding the Directed Formulae (DFs): an alterna- tive vision for MDGs in terms of logic and set theory [3], in LCF-style interactive theorem prover as inference rules. We define a platform to represent the MDG op- erations: conjunction, disjunction, relational product and prune-by-subsumption as a set of inference rules. Based on this platform, the reachability analysis is imple- mented as a conversion that uses the MDG theory within the HOL theorem prover. Thus, by representing the primitive MDG operations as inference rules added to the core of the theorem prover, we can model the execution of a model checker for a given property as well as raise the security of our platform. Finally, we present some experimental results to show the performance of our platform. The obtained results show that this platform offers a considerable gain in terms of automation without sacrificing CPU time and memory usage. The performance penalty is compensated by the secure and correct infrastructure offered by the HOL theorem Prover.

The paper is organized as follows: Section 2 reviews some related work to our area. Section 3 gives some preliminaries on MDG and HOL systems, respectively. Section 4 explains the inference rules of well-formedness conditions. Section 5 presents the inference rules representing the basic MDG operations. Section 6 in- troduces the reachability analysis tactic in HOL and summarizes some experimental results and statistics to show the performance of our platform. Finally, Section 7 concludes the paper and gives some future research directions.

The development of software/hardware verification methods allowing to handel many technological challenges. Both static analysis and model checking research communities are concerned with these challenges to verify properties of software and hardware systems. The main concepts used are based on transition systems, fixpoint computations, reachability analysis, etc. On the other hand, large number of verification techniques are in use as stand alone or in combination with one an- other [10]. The best advances come from a combination of techniques from different research areas and hence our research is motivated toward this direction.

[13] which is external to the theorem prover. Thus, the HOL logic is extended with these extra primitives. Empirical evidence suggests that the efficiency loss in this approach is within reasonable bounds. The approach still leaves results reliant on the soundness of the underlying BDD tools. A high assurance of soundness is obtained at the expenses of some efficiency. Therefore, the security of the theorem prover is compromised only to the extent that the BDD engine or the BDD inference rules may be unsound.

In fact, while BDDs are widely used in state exploration methods, they can only represent Boolean formulae. Our work deals with MDGs rather than BDDs, since MDGs subsume BDDs while accommodating abstract data and uninterpreted function symbols. So we can expect more level of abstraction and more compact representation. Mhamdi and Tahar [19] follow a similar approach to the BuDDy work [13]. The work builds on the MDG-HOL [16] project, but uses a tightly integrated system with the MDG primitives written in ML rather than two tools communicating as in MDG-HOL system. The syntax is partially embedded and the conditions for well-formedness must be respected by the user. In contrast, their work linked HOL and an external MDG library, while we provide a set of inference rules to represent the MDG operations. Later, these operators can be used as an infrastructure for MDG model checking. Perhaps the experience gained from the work described here will inform the design of a second generation tool integration platform supporting a spectrum from loose to tight integration of external tools.

Let J be a set of function symbol and V a set of variables. We denote the set of terms freely generated from J and V by 7 (J, V). The syntax of a Directed Formula is given by the grammar below [22]. The underline is used to differentiate between the concrete and abstract variables.

HOL provides a wide range of proof commands, rewriting tools and decision procedures. The system is user-programmable which allows proof tools to be de- veloped for specific applications; without compromising reliability [14]. The basic interface to the system is a Standard Meta Language (SML) interpreter. SML is both the implementation language of the system and the Meta Language in which proofs are written. Proofs are input to the system as calls to SML functions. The HOL system supports two main different proof methods: forward and backward proofs in a natural-deduction style calculus.

Theorems in HOL are represented by values of the ML abstract type thm. There is no way to construct a theorem except by carrying out a proof based on the primitive inference rules and axioms. HOL has many built-in inference rules and ultimately all theorems are proved in terms of the axioms and basic inferences of the calculus. By applying a set of primitive inference rules, a theorem can be created. Once a theorem is proved, it can be used in further proofs without recomputation of its own proof.

HOL also has a rudimentary library facility which enable theories to be shared. This provides a file structure and documentation format for self contained HOL de- velopments. Many basic reasoners are given as libraries such as mesonLib, bossLib, and simpLib. These libraries integrate rewriting, conversion and decision procedures to free the user from performing low-level proof.

Using HOL recursive datatypes, the MDG sort is either concrete or abstract sort. This is embedded using two constructors called Abst Sort and Conc Sort. The Abst Sort takes as argument an abstract sort name of type alpha and the Conc Sort takes a concrete sort name and its enumeration of type string as an input argument. This is declared in HOL as follows:

Similarly, constants are either of concrete or abstract sort. Individual constant can have multiple sorts depending on the enumeration of the sort, while abstract generic constant is identified by its name and its abstract sort. We use the Ind Cons and Gen Cons constructors to declare constants in HOL. Also a variable (abstract or concrete) is identified by its name and sort. In our embedding, an abstract variable is declared using Abst Var constructor and the Conc Var constructor is used to declare a concrete variable.

+ algorithms) to define an abstract state exploration in the HOL theorem prover. For this mean, the DF vocabulary and well-formedness conditions are defined in [1] based on the directed formulae syntax. Also, we provide formal definitions of the MDG basic operations as inference rules within HOL. In this Section, we describe the MDG operations in terms of inference rules. Then, we present the reachability conversion and provide some experimental results to show the performance of the MDG operations (mainly PbyS operation) and the MDG-HOL platform.

The method for computing the conjunction of two DFs is applicable when the sets of primary variables of the two DFs are disjoint. The resulting DF has pri- mary variables that are among the primary variables of the conjuncts, including all abstract variables that have primary occurrences in any of the conjuncts. The ab- stract variables having secondary occurrences in the result are among those having secondary occurrences in the conjuncts, excluding those having primary occurrences in any of the conjuncts.

As shown below, we formalized the conjunction operation of two DFs as inference rules. Axioms (R1 to R4) represent the terminal case i.e. when one of the two DFs is TRUE or FALSE. These rules form a proof system in analogy to logical rules. The horizontal line reads implies. Thus rules represent logical truths. It follows that rules with nothing above the line are axioms since they always hold.

The relational product operation (RelP) is used to compute the sets of states reachable in one transition from one set of states. It combines conjunction and existential quantification. The inference rules formalization of the RelP operation are based on the rules of the conjunction operation and hence will not be repeated again. This simplifies the formalization and shows the reusability of our work.

In fact, the conjunction operation has consumed most of the proof preparation effort. Most of the definitions and proofs are reused by the other operations such as RelP and disjunction operations. The embedding of MDG syntax and the veri- fication of MDG operations sums up to several thousand lines of HOL codes. The complexity of the proof is related mainly to the MDG structure, and the recursive definitions of MDG operations.

Here, we present a HOL formalization of the MDG reachability analysis. This formalization is based on our embedding of MDG syntax and operations in HOL. First, we will review the MDG reachability analysis [9]; followed by its definition in HOL along with a discussion on the technical challenges. Finally, we will use the MIN-MAX design as an illustrative example for our reachability analysis embedding.

Lines 1-3 initialize the algorithm by constructing the initial MDG structure. In line 4-10, the set of reachable states is computed within the while loop. The while loop terminates when the frontier set (Q) becomes empty (F). In line 6, a new MDG input is produced. In line 7, the function next state computes the next state using the RelP operation which takes as assignment the MDGs representing the set of inputs, the current state and the transition relation, respectively. The function frontier, in line 8, computes the set difference using the PbyS operation. This operation approximates the set difference between the newly reachable state in the current iteration from the reachable state in the first iteration. Finally, in line 9, the set of all reachable states so far is computed.

We show here the steps to formalize the set of reachable states of an abstract state machine in HOL. The important difference is that we are using our embedded DF operators at a higher level. At this stage, the proof expert reasons directly in terms of DF, the internal list representation that we have used in the proof of operations is completely encapsulated.

uninterpreted function symbols, the algorithm may not terminate. Thus, the MDG reachability computation is theoretically unbounded. Meanwhile, several practi- cal solutions have been proposed to solve the non-termination problem. The au- thors in [3] related the problem to the nature of the analyzed design. Furthermore, they have characterized some mathematical criteria that leads explicitly to non- termination of particular classes of designs.

The algorithm takes as an input the design parameters. In line 1, we formalize those parameters in terms of DF and then check the well-formedness of all DFs (Tr, Q, R). In line 2, we compute one reachability computational step using the Reach Step function. Finally, in line 3, we generate a fixpoint goal of Re An. The advantage of this approach is that we compute the reachable states for only one iteration and then relying on the induction power in HOL we prove the existence of a fixpoint. However, this fixpoint may not exist for some particular designs. Furthermore, the selection of n0 is based on the knowledge and the heuristic of the design since the induction is not explicitly identified as illustrated by the case of the MIN-MAX example.

We support our platform by experimental results executed on different benchmarks. We consider four cases from the MDG benchmark suites in order to measure the performance of MDG-HOL. The case studies cover two small benchmarks: MIN- MAX and Abstract Counter, one intermediate benchmark: Look-Aside Interface (LA-1) [20], and one large benchmark: Island Tunnel Controller (ITC) [24]. The performance is measured in terms of full reachability analysis for these models. Ta- bles 5 and 6 compare the number of nodes, number of functions, the memory usage, reachability analysis time (RA), and human effort generated by MDG-HOL and For- malCheck (V2.3) [6] model checking, respectively, run on a Sun enterprize server with Solaris 5.7 OS and 6.0 GB memory. The time is measured in FormalCheck by estimating the average time for the set of all properties associated with the design.

MDGs have been proposed to extend BDDs in the representation of the relations as well as sets of states, in terms of abstract sorts to denote data values and uninter- preted function symbols to denote data operations. We have MDGs as formulae in higher order logic using the Directed Formulae notations. The well-formedness con- ditions and the operations were implemented as a set of inference rules. The ideas described here are intended to establish a correct platform for securely programming new verification algorithms.

The performance results for the PbyS operation have shown that the execution time of the PbyS operation is almost linear which emphasizes the effectiveness of our embedding. The experimental results based on benchmarks, have shown that the MDG-HOL platform provided a better performance than FormalCheck in terms of time, memory usage, number of nodes, and number of functions especially when the design is growing up. On the other hand, the human efforts are huge compared to FormalCheck. Thus, a complete model checker can be implemented in HOL based on our infrastructure. Including the definition of each LMDG [22] related algorithm as a tactic in HOL. The model checker will be a complete theory in HOL, but indeed more investigation and formalism is needed to this task. In this context, our reachability conversion can be used to make calls to our defined MDG algorithms, to check wether an LMDG property is valid. Here, we are not reducing the role of the proof expert, but we provide him with an automated conversions that reduces considerably the time he spent. Also, the work can be seen as a formal proof for the MDG model checking approach; verifying a verification system using another verification system.

