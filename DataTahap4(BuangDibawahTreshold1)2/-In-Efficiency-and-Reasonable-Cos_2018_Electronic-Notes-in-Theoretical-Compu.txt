Strong strategies. For strong strategies the question is subtler. The encoding of Theorem 3.2 provides a linear simulation of TM for every strong strategy reducing weak redexes or weak head redexes before any strong one. An example of the former is strong call-by-value that is usually obtained by iterating weak call-by-value under abstractions. One of the latter is leftmost-outermost evaluation.

A degenerate but interesting case study is given by the maximal strategy. It is a perpetual strategy, i.e. it diverges whenever possible, and moreover when it terminates it takes the maximum number of steps to reach the normal form. Thus, it is as inefficient as a strategy can be, and according to the end of Sect. 3 it does not seem to be a reasonable strategy because it does not allow to simulate TM.

Useful sharing and open dialects. In open setting (weak but with open terms), reasonable implementations must avoid the substitution of neutral terms (i.e. use- lessness of the first kind) but can substitute abstractions whenever. Note indeed that in the open size exploding family (Proposition 4.2) the explosion is given by the duplication of neutral terms.

Useful sharing and strong dialects. Reasonable implementations of strong evalu- ation must also avoid useless replacements of the second kind, with an optimisation that is sometimes called substituting abstractions on-demand in [12]. Indeed, note that the key restriction for avoiding substitutions on x under abstractions in (1) at page 10 is the fact that those occurrences of x are not applied.

How to show that strong call-by-value and call-by-need are also reasonable is an active topic of research. The tools to deal with strong call-by-value have essentially been developed in [9,12], and we expect them to also adapt to strong call-by-need, whose operational semantics is finding its way into a published form just now [18]. The subterm property still holds, as well as the schema for proving that these strategies are reasonable. What is not immediate is the handling of the many technical details of implementing strong evaluation and useful sharing for call-by- value/need.

has the iterated subterm property. The iterated subterm property unfortunately allows to chain substitutions of subterms of the initial term into subterms of the initial term, leading to size explosion, that is, to an exponential gap between the number of steps and the size of the duplicated objects. The plain subterm property, instead, avoids it.

