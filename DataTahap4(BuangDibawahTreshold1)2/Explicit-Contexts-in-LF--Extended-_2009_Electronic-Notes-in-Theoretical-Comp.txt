When formalizing meta-theorems in Twelf [10], the hypothetical interpreta- tion occasionally causes difficulties. Specifically, in settings that include dependent types, theorems that involve a distinguished bound variable (such as substitution or functionality) cannot be proven directly by induction. In the next section we illustrate the difficulty that arises.

The remainder of this paper is structured as follows: In Section 2 we illustrate the problem that arises from distinguished bound variables and dependent types. In Section 3 we formalize explicit contexts in LF and give an example of their use. In Sections 4 and 5 we show how to convert derivations between implicit and explicit contexts. Throughout the paper we assume the reader is familiar with LF and with Twelf.

It is important to note that this is an illustrative example, not a motivating one. Since substitution is provided primitively in LF by function application, this theorem has a trivial non-inductive proof. Nevertheless, we prefer this example due to its simplicity. We will briefly give some motivating examples in Section 2.2.

This proof works because we are able to reverse the order in which x and y are bound. Initially, y is within the scope of x. However, when we recurse, we move y to the outside, while x is still bound by the theorem itself.

Substitution with different judgements on the left and right. It is often necessary for typing assumptions to utilize a different judgement than the primary typing judgement. This most often happens because of a need to treat variables specially. For example, many module type theories ascribe special privileges to paths (where a path is defined as a series of actions, such as projection, acting on a variable) [3,5,6]. This might be represented in LF by:

Hereditary substitution. When defining LF and similar logical frameworks, it can be convenient to adopt a canonical formulation, in which only canonical forms are well-formed. A complication arises from substitution, since substitu- tion instances of canonical forms are not necessarily canonical. To resolve this, one can define hereditary substitution, which reduces any redices resulting from substitution [12].

The explicit context method developed in this paper provides a principled, uni- form, and dependable method to overcome these difficulties. For the first two ex- amples, ad hoc workarounds are also known to exist. (As of this writing, we know of none that are published.) Also, for the narrowing example, Pientka [8] has shown that the difficulty can be circumvented by formulating the LF encoding differently.

Turning now to explicit contexts, the first important observation is that the encoding of syntax need not be changed at all. This is important because it means that explicit-context developments can co-exist with conventional implicit-context developments. Thus, the syntax of terms and types remains exactly that given above.

5 In fact, the determining factor for Twelf as to whether the language is dependently typed is whether exp is subordinate to tp [11]; that is, whether or not Twelf permits terms of type exp to appear within terms of type tp. Twelf infers the subordination relation from the signature, and either the p or pi declaration is sufficient to add the desired edge. The explicit context method would work similarly for any other formulation of dependent types that induced that edge.

The context formation judgement checks another important property as well. We need to enforce the property that each variable appearing in the context is distinct. (This is important, for example, for establishing that looking up a variable in the context returns a unique type.)

It is convenient to use this rule for typing b, since it happens to be closed. More importantly, we use it for importing assumptions from the implicit-context setting into this explicit-context setting. This is essential because we wish to be able to shift into the explicit-context method at any point in a proof, not just when the implicit context is empty. Formally this is reflected in the worlds declaration for our lemmas allowing bind blocks as well as ovar blocks.

The key result of this paper is that we can convert from implicit to explicit form. Once we have done so, we can carry out a proof using explicit contexts (Section 3.4), and then convert back to implicit form (Section 4), thereby obtaining a general result with no mention of explicit contexts.

The proof proceeds by induction on the term M (not on its typing derivation). The variable case (that is, when the second argument is ([x] [d] d)) uses ofe/var and the proffered lookup judgement. The closed case (that is, when the second argument is ([x] [d] D), where D does not depend on d) is trivial, using the ofe/closed rule. The of/app case is a simple induction invocation.

Let us return to the of-lam case of cut-of to make two final observations. Since the case makes two recursive calls, where the second operates on the result of the first, it is not possible to do this proof by induction on derivations. Instead, we do it by induction on the term itself, which is undisturbed by all the processing of typing derivations.

