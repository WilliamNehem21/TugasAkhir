that enjoys subject reduction, type uniqueness, and decidability of typing. Then we apply a clas- sical type-erasing function to RhoF, to obtain an untyped Rho-calculus `a la Curry (uRhoF). The related type inference system is isomorphic to RhoF and enjoys subject reduction. Both RhoF and uRhoF systems can be considered as minimal calculi for polymorphic rewriting-based program- ming languages. We discuss the possibility of a logic existing underneath the type systems via a

is associated with an action; once an instance of a pattern is recognized, the corresponding term is rewritten to a new one. Another advantage of rewriting- based languages (in contrast with ML or Haskell) is the ability to handle non- determinism by means of a collection of results: pattern-matching needs not to be exclusive, i.e. multiple branches can be taken simultaneously. An empty collection of results represents a matching failure, a singleton represents a

One of the most commonly used models of computation, the Lambda- calculus, uses only trivial pattern-matching. This calculus has recently been extended, initially for programming concerns, either by introducing patterns in Lambda-calculi [31,42], or by introducing matching and rewrite rules in functional languages. More concerned with extending logics, Stehr has studied a Calculus of Constructions enhanced with rewriting logic [32].

in a uniform way. Its abstraction mechanism is based on the rewrite rule formation: in a term of the form P d A, one abstracts over the pattern P . Note that the Rewriting-calculus is a generalization of the Lambda-calculus, since we get the Lambda-calculus back if every pattern P is a variable.

Finally, static analysis via a type system (inherited from the Lambda- calculus) enforces a safer programming discipline. This paper presents a Rho- calculus `a la Church (called RhoF) featuring second-order polymorphic types. Then we apply a classical erasing function to RhoF in order to obtain a corres- ponding type inference system `a la Curry (uRhoF). We discuss the possibility

Below, we propose a well-known restriction, due to Mendler [25] that would block the counterexample to the Strong Normalization (Example 3.7), and the counterexample to the Logical Consistency (Example 5.3). The consistency of the system is guaranteed by shrinking the set of typable terms. Mendler has shown that, when introducing recursive definitions in the typed Lambda- calculus, strong normalization is no longer enforced by typing if the type

