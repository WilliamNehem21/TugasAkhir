In large component-based systems, the applicability of formal verification techniques to check interaction correctness among components is becoming challenging due to the concurrency of a large number of com- ponents. In our approach, we employ parallel LTL-like model checking to handle the size of the model. We present the results of the actual application of the technique to the verification of a complex model of a real system created within the CoCoME Modelling Contest [18]. In this case study, we check the validity of the model and the correctness of the system via checking various temporal properties. We concentrate on the component-specific properties, like local deadlocks of components, and correctness of given use-case scenarios.

During the last decade, software industry has seriously started to take advantage of component-based software development as an alternative to existing software devel- opment techniques. Component-based development proposes to assemble software systems from reusable components, possibly in a hierarchical manner. This helps to significantly reduce development costs, but brings the issue of correctness of such systems, especially if components are delivered by different vendors.

work by verifying the model. In verification, we concentrate on properties of the final model like correctness of given use-case scenarios, local deadlocks of components, and response properties. Besides these we discuss how the verification helped us to check the validity of the model during modelling.

The modelling example, called Trading System, serves to handle sales in a chain of supermarkets. Its functionality includes the interaction with the cashier at the cash desk, like product scanning, price lookup, cash/card payment, and bill printing, as well as accounting the sale at the inventory, or determining whether an express cash desk is needed in the store. Furthermore, the Trading System deals with order- ing goods from wholesalers, and generating various kinds of reports. The system is an open system, designed to interact with external components representing users of the system (cashiers and managers) and a bank application.

To model behaviour of component-based systems we use the CI automata lan- guage [6,8]. The language models each component as a labelled transition system with structured labels and a hierarchy of component names. The transition label ar- ticulates which components communicate on an action, and the hierarchy of names represents the architectural structure of the component.

For property specification, we use a slightly modified version of the linear temporal logic LTL [14] which we refer to as CI-LTL. CI-LTL is designed to express properties about occurring component interaction (i.e. labels in automata), but also about possible component interaction (i.e. label enabledness).

The tool DiVinE, which we use for the verification, provides several LTL model checking algorithms. In our case study, the algorithm OWCTY is employed. This algorithm always generates the whole reachable state space of the model and its time complexity is higher than that of simple reachability if it is the case that an accepting cycle is found. However, it was chosen because of its efficiency in distributed setting [3].

Within the CoCoME Modelling Contest [15], we have created a detailed model of the Trading System in terms of component interaction using CI automata [18]. The model in a textual notation is available at [16]. The model consists of 140 primitive automata (59 in the CashDeskLine part, and 81 in the Inventory part), composed hierarchically into 34 composite automata up to 6 levels of depth. The Trading System model is complemented by several models of cashiers and managers, who interact with the system, and specify various usage profiles under which properties of the system are checked. 3 Each usage profile/scenario (all provided within the contest) corresponds to a correct behaviour of a user operating the system.

We have experimented with all usage scenarios. However, for the clarity of the presentation, we employ only one usage profile underlying the properties studied in the paper. It is the scenario describing one sale assisted by a cashier. This scenario represents the most complex usage profile described in [15], and it is connected to a large number of component-specific properties that can be checked on the behaviour of the system that is implied by the scenario. In the scenario, the cashier first starts the sale, then scans items (in a loop), finishes the sale and receives the payment. It can select cash or card payment, where the cash payment is followed by entering the received amount and returning change, and the card payment with scanning the card and entering PIN.

State space of the model. As mentioned above, the Trading System model is composed out of 140 primitive automata hierarchically assembled into 34 composite automata. Even if the size (number of states) of individual primitive automata is moderate, the size of the complete state space is immense due to the concurrency in component behaviour. An attempt to generate the complete state space on a cluster of twenty computers finished unsuccessfully with 322 millions of states demanding for 60 GB of memory in total. The computation took 13 400 seconds. Although this might seem slow, it is not surprising because the state space generation in- volves computation of the successor states. Such computation is a complex task, which needs to take into account the hierarchical composition of components and the feasible labels that can be propagated up in the hierarchy and are part of the composite automata.

Even if the complete model is unfeasibly large, for the verification of the model under the given usage scenario, the model is composed with an automaton repre- senting the user. This restricts possible behaviours and decreases the state space. The size of the model with the cashier mentioned earlier is 749 340 reachable states and 3 181 473 reachable transitions.

The CashDeskChannel (200) in the system is not allowed to accept notifications before it delivers events to all subscribers. If some of the subscribers would be constantly refusing to accept the event, it could block other components that already accepted the event and want to notify the channel. As the property is valid, this cannot happen in the system (on the SaleStartedEvent ).

The violation of the property means that the system gets into a state from which the component is no more able to perform any computation. This can happen for three reasons: (1) it gets stuck in its internal computation, (2) the environment refuses to accept its calls, or (3) the environment does not wish the component to compute anything for it any more. After a further analysis of the model we learned that the last case is true because in the usage profile, we suppose that only one sale is accomplished. Hence the system is not supposed to execute forever. This property demonstrates that one needs to be careful when interpreting the result from the local deadlock verification. More, it allows the reader to see the memory and time needed to verify a property that does not hold.

The property is a more strict version of the property 4. While the property 4 shows that the CashDeskChannel (200) always sends all copies of the SaleStartedE- vent and gets into the state where it is ready to start accepting notifications, this property shows that it may take a while before the channel gets ready. However, this is not an error in the system. It correctly reflects the nature of the channel.

In the counterexample, one of the components gets into a loop (representing a for cycle with a finite but unknown number of iterations possible) that it never exits. Hence the counterexample represents a run that is not real in the system. However, as there is no natural way to remove the run from the model for the reasons above, we modify the property in a way that it misses this run, thus forcing verification of the original property only on fair runs.

Note that although the state-space size of the model composed with property 8 is the same as that of property 9, the verification time is larger in the first case. This is due to the nature of the verification algorithm, as mentioned in Section 3.3.

Characteristics of the model. As the number of components in the Trading Sys- tem is quite large, and our modelling language expresses component concurrency through interleaving, the model suffers from state space explosion. More, the size of the reachable state space does not grow evenly during the hierarchical composition of components, but it changes dramatically. The reason for the irregular changes of the state space is that a composite automaton does not need to be larger than the automata it is composed of. We have observed cases, where the number of reachable states has been dramatically reduced by the composition. This is due to the parametrized operator that can delimit possible behaviour in the composition. This fact can complicate the estimation of the number of states for a given model.

Local deadlocks and component-blocking properties. Interesting observa- tions were made in verifying the local deadlocks and their more strict form, the component-blocking properties. We have verified many pairs of such properties and have found a strong relation between the two kinds. Mostly, it was either the case

that both properties were satisfied, or none of them was. The reasons are similar to those explained after property 5, that is, the environment does not wish the components to compute anything any more. We have, though, found a few cases, when the local deadlock property holds, but the blocking property does not, and we have presented one of them. Note that both kinds of properties take advantage of the enabledness E operator without which they could not have been formulated.

In this paper, we give a practical application of the presented CI-LTL verifica- tion technique to a large component-based system using a parallel model checking tool DiVinE. We briefly introduce our modelling language as well as the temporal logic CI-LTL, a modification of the action based LTL. We have verified a multi- tude of properties of the Trading System. Twelve of them that are of particular interest within the component-oriented software engineering society, are presented here together with the results of the verification and their discussion. The pre- sented properties include two basic properties describing the broadcasting ability of the event-channel components, three properties concerning the possibility of a lo- cal deadlock, two properties addressing the component blocking problem, and two properties dealing with the problems caused by cycles in the model. The last three properties are different from the previous. They are used for checking the correct- ness of the use-case scenarios. Finally, we discuss how the model checking helped us in creation of the model, and we summarize the experience obtained during verifica- tion, including discussion of some of the results, and the effect of the parallelization. The study confirms that the CI automata modelling language suits well both to capture various types of interactions among individual components in component- based systems, and to formally verify interaction properties. This distinguishes our

In future, we aim at extending our verification techniques with various reduction methods to allow us to verify even larger systems. Currently, we explore the pos- sibilities of two existing reduction techniques, the partial-order reduction and the symmetry reduction. However, their application in our framework is not straight- forward, due to the nature of the temporal logic we use. We also try to find new reduction methods taking advantage of component-specific characteristics of verified systems.

