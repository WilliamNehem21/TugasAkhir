In this paper we present a new approach for the analysis of rule-based specification of system dynamics. We model system states as simple digraphs, which can be represented with boolean matrices. Rules modelling the different state changes of the system can also be represented with boolean matrices, and therefore the rewriting is expressed using boolean operations only.

simulation [8], to express and analyse refactorings or re-designs [9], or for model-to- model transformations [14]. The main advantages of graph grammars with respect to other behavioural specification techniques is that they are a visual, formal and declarative means to express transformations of different kinds of graphs. Different formalizations provide analysis techniques e.g. to study rule independence, conflu- ence or termination (partially) [4,5,11]. The most popular formalizations are based on category theory and include the single [3] and double pushout [2,4] (SPO and DPO).

Completion. In order to operate graphs of different sizes, an operation called completion adds extra rows and columns with zeros (to matrices and vectors) and rearranges rows and columns so that the identified edges and nodes of the two graphs match. In the examples, we omit such operation, but assume that matrices are completed when necessary. Later we will operate with the matrices of different productions, which means that we have to select the elements (nodes and edges) of each production which get identified to the same element in the host graph. Thus the completion has to preserve such identifications.

herent if we identify both operators and machines. Therefore, we need two different machines and two operators, one machine can consume the generated piece, while a different piece is needed for the other machine. For the case of three productions, the formula for the MID expands to M3 = (r1L1) V (r1L2)(r2L2) V (r1L3)(r2L3)(r3L3).

Note the close similarity with local confluence [4]. The problem can be easily extended to consider any finite number of derivations. Again, our objective is to characterize under which circumstances, depending on the permutation applied and on the definition of the grammar (which includes both grammar rules and the host graph), it is possible to conclude that their final states are isomorphic.

In order to calculate M0 in prop. 6.1 it is possible to follow two complementary approaches: either we start by the maximal initial digraph or by different minimal elements in the initial digraph set. In the first case the following identity may be of some help:

For the maximal initial digraph M , every element is different across productions in derivations. Let all elements (except those already known) be represented by variables in M and use a SAT solver on (4) to obtain conditions. The same can be applied to the negative intial digraph to guarantee applicability.

Through composition means that the concatenation with length greater than one must be transformed into a single production using composition. This is possible because it is coherent and compatible (see prop. 3.6). In fact it would not be necessary to transform the whole concatenation using composition, but only the parts that present a problem.

With respect to composition, note that we identify accross rules the elements through which composition is performed. This is similar to the concurrency the- orem [4]. Non-injective matches in DPO allow identifying different elements in a parallel rule, while we have to decide such identification before calculating the composition.

With respect to other similar approaches to Matrix Graph Grammars, in [15] the DPO approach was implemented using Mathematica. In that work, (simple) digraphs were represented with their boolean adjacency matrices. This is the only similarity with our work, as our goal is to develop a theory for (simple) graph rewriting based on boolean matrix algebra. Other somehow related work is the relational approaches of [7] and [10]. However, they rely on category theory for expressing the rewriting.

