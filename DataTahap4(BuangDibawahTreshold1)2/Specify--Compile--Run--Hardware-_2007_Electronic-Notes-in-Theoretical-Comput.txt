We demonstrate the application of the synthesis method by means of two exam- ples. The first is a generalized buffer from IBM, a tutorial design for which a good specification is available. The second is the arbiter for one of the AMBA buses [2], a characteristic industrial design that is not too big. Previous work on synthesis has only considered toy examples such as a simple mutual exclusion protocol, an el- evator controller, or a traffic light controller [8,16,10]. This is the first time realistic industrial examples have been tackled.

This paper is a companion paper to [4]. The current paper shows the details of the GenBuf case study, whereas [4] focuses on the AMBA example. This paper gives a detailed description of the algorithm we developed to construct a circuit from a BDD, describes some extensions that were not included in [4], and shows a major improvement in the AMBA example.

The paper continues as follows: in 2, we describe how to synthesize a circuit from specifications. In Section 3, we describe the Generalized Buffer, give its formal specification, and show the results of synthesis. In Section 4, we do the same for the AMBA AHB arbiter. We discuss lessons learned in Section 5 and present our conclusions in Section 6.

We briefly review the results presented in [16] on synthesizing GR(1) properties. We are interested in the question of realizability of PSL specifications (cf. [17]). Assume two sets of Boolean variables X and Y. Intuitively, X is the set of input variables controlled by the environment and Y is the set of system variables. Realiz- ability amounts to checking whether there exists an open controller that satisfies the specification. Such a controller is a Mealy machine that, at any step, reads values of the X variables and outputs values for the Y variables.

initial state, and (3) a formula of the form always eventually! (B) to represent the fairness condition, where B is a Boolean formula representing a set of states. (An example can be found in Section 3.3.) It should be noted that even with these restrictions, all possible (finite state) designs can be expressed as a set of properties. We reduce the realizability problem of a PSL formula to the decision of the winner in an infinite two-player game played between a system and an environment. The goal of the system is to satisfy the specification regardless of the actions of the environment. A game structure is a multi-graph whose nodes are all the truth assignments to X and Y.  A node v is connected by edges to all the nodes v'

We solve the game, attempting to decide whether the game is winning for the environment or the system. If the environment is winning the specification is unre- alizable. If the system is winning, we synthesize a winning strategy. This strategy, a BDD, is a nondeterministic representation of a working implementation. Formally, we have the following.

[12] and one based on computing cofactors. The approach of [12] yields a circuit that can generate, for a given input, any output allowed by the strategy. To this end, it uses a set of extra inputs to the combinational logic. Note that this is more general than what we need: a circuit that always yields one valid output given an input. We will see later that this generality comes at a heavy price in terms of the

Genbuf consists of a controller, a FIFO, and a multiplexer. We synthesize the controller from its specification, while assuming that the implementation of the FIFO and the multiplexer are given. FIFOs and multiplexers are standard pieces of logic and synthesizing them from specifications would make the task unnecessarily complex, especially because they involve 32-bit data buses.

Initially, the buffer we synthesized from the specification above ignored the FIFO. Instead it would wait until it could send data to a receiver before accepting data from a sender. Hence, we added the following property, which ensures that the FIFO is used.

The AHB is an on-chip communication standard that connects such devices as processor cores, cache memory, and DMA controllers. The bus allows up to 16 masters to communicate (read or write) with up to 16 clients. The bus consists of a data bus and an address bus. At any time, only one master is allowed to access each of the buses. Access to the address bus is controlled by the arbiter, which is the subject of this section.

In our initial experiments [4], we were only able to synthesize arbiters for up to four masters, for larger arbiters the synthesis algorithm ran out of memory when building the strategy. (2GB of memory were available.) After rewriting the specifi- cation, without changing its meaning, we can handle up to ten masters. The time

The automatically generated arbiter implements a round-robin arbitration scheme. This can be explained from the construction of the strategy in the synthesis algo- rithm, but it is also the simplest implementation of a fair arbiter. We have validated our specification by combining the resulting arbiter with manually written masters and clients, with which it cooperates without problems.

The effort for a manual implementation of a parameterized circuit usually does not depend strongly on the parameter. (The parameter is the number of senders in case of GenBuf and the number of masters in case of the arbiter). The same is not true for automatic synthesis: the time for synthesis and the size of the resulting circuit grow with the parameter. Unfortunately, the generated gate-level output is complicated and cannot easily be changed by hand.

Finding a small implementation for a given specification is hard. A specifica- tion corresponds to a (possibly infinite) set of open controllers that implement it. Synthesis proceeds in two steps. First, the algorithm of [16] prescribes a set of flipflops and constructs a strategy that corresponds to a finite (but typically large) set of combinational blocks that implement a correct open controller. Second, we must pick one controller with a small representation from this set. Not every small implementation that is allowed by the specification survives step one. Even if it does, it is hard to find a small circuit from among the ones allowed by the strategy in step two. We are researching methods to improve each step and we expect that we will be able to significantly reduce the size of the resulting circuits.

On the upside, the resulting PSL specification is short, readable, and easy to modify, much more so than a manual implementation in VERILOG. The synthesis algorithm was also a excellent tool to get the specifications consistent and com- plete. Although the construction of the specifications was sometimes bothersome, we doubt we would have managed to write a complete and consistent specification without the synthesis tool.

have made it applicable to realistic examples. This paper, together with its compan- ion [4], presents the first time that real-life blocks have been synthesized from their specifications. The circuits that we obtain are quite large, but the approach is still young and only a few avenues for optimization have been pursued. We attempted to generate circuits using an approach of [12]. A second attempt using cofactors yielded circuits that are an order of magnitude smaller, and optimizations to that approach yielded a significant improvement. We expect that future research will yield further large improvements, making automatic synthesis a real alternative to manual coding of some types of circuits.

