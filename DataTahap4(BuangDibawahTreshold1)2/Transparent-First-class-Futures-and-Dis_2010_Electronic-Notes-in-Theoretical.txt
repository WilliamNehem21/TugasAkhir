Futures are special kind of values that allow the synchronisation of different processes. Futures are in fact identifiers for promised results of function calls that are still awaited. When the result is necessary for the computation, the process is blocked until the result is returned. We are interested in this paper in transparent first-class futures, and their use within distributed components. We say that futures are transparent if the result is automatically and implicitly awaited upon the first access to the value; and that futures are first-class if they can be transmitted between components as usual objects. Thus, because of the difficulty to identify future objects, analysing the behaviour of components using first-class transparent futures is challenging. This paper contributes with first a static representation for futures, second a means to detect local deadlocks in a component system with first class futures, and finally extensions to interface definitions in order to avoid such deadlocks.

If communications occurring over the bindings are synchronous, then the in- terfaces can be accessed as usual objects, having methods with parameters and a return type. When components are connected asynchronously, one must find a way to create a channel for the objects returned by the components. Futures can be used as identifier of the asynchronous invocations over components. Indeed, futures provide some kind of transparent channels that correspond to the original bindings, but taken in the opposite direction: from the server to the client.

But components and futures get more related when considering static analysis. Indeed, in an asynchronous component model like the GCM, only invocations on a component create a future. Thus, the components allow the static identification of future creation points, and thus a finer static analysis.

Unfortunately, although the component model provides a good abstraction for distribution and specifies which calls are asynchronous, the flow of futures is still hard to approximate. In other words, the component abstraction tells us where futures are created but not where they can go. The dynamic and transparent nature of futures implies that each result and each parameter of an invocation may contain a future; thus the only safe assumption for parameters and results is that any object received can be a future, and every field of this object can itself be a future. This leads to a very imprecise approximation of the synchronisation in the system; this over-approximation can always be improved by static analysis (when the system is closed), or by specification, as illustrated in Section 5.

Transparent first-class futures provide a natural and efficient data-flow synchroni- sation where a result is awaited only when it is necessary. However, providing a model of programs using transparent first order futures is challenging. The contri- bution of this paper is first to give a static representation of transparent first-class futures, second to characterise how access to futures can block components indefi- nitely, third to use the previous results to identify local deadlocks, and finally extend the definition of interfaces to avoid some blocked states.

The objective of this section is to give a behavioural model for transparent first- class futures, this model is intended at the static verification of the behaviour of components. We assume that the accesses to the component interfaces and the creation point of futures are given in the functional behaviour of the component (Body). We start this section by a brief definition of the pNets model, and of its (static) graphical representation on which we build our models.

i.e. all future creations are of the form f=itf.foo(), resulting in a future stored in the variable f. We call future update the operation consisting in replacing a reference to a future by the value that has been calculated for it.

i.e. to synchronise futures. We call waitFor the primitive allowing the update of a future to be awaited (this primitive has also been named touch or get [11]). When futures are transparent, this waiting operation is automatically performed upon an access to the content of the future. We describe in this section what behavioural model can be created for this kind of futures. For the moment, we consider that futures cannot be passed between remote entities, and thus the future is necessarily accessed by the same entity that created it (at another point of the execution).

In here, if f.bar1() is executed, then f must be filled; in this case f.bar2() will be necessarily non-blocking. Otherwise, f.bar2() may or may not be blocking depending if the future f is already filled by the time the call is performed. Note that it is much simpler when futures are explicit, i.e. if futures are typed.

Proxies that are used for transmitting a future reference as the value of another future are slightly different: they need no !getValue because they simply forward the value they receive as the value for another future. Assigning a future refer- ence to another future is directly ensured at a higher-level, that is to say by the composition itself. This ensures that the behavioural model is still compositional as no name of an externally created future exist in the proxy.

In the pNets model of A, futures are forwarded to several activities; a fu- ture is sent as parameter of the method calls to E and F in call(gee(fA)) and call(hoo(fA)) resp. A proxy is created in each callee with the identifier (fA) matching the proxy of the caller, i.e. Proxy(fA). Proxy(fA) in pNets(A), after receiving the concrete value, will forward the value to both activities E and F. This is seen as an action forward(fA,val). As a remark, the update of Proxy(fA) in F is done no matter whether the component is called or not, however if the call is never performed the proxy is unreachable (its identifier is unknown).

System deadlocks if itfB.foo() is synchronous The deadlock is similar to the previous one; if foo() is synchronous, then this call blocks component B until the result is known. What it means is that a synchronous call cannot trigger a flow that goes through a composite twice. This is a common pitfall for inexperienced programmers with GCM/ProActive that we can fortunately detect in our models.

This removes some of the imprecision of the static analysis. Nevertheless, a source of ambiguity remains in open environments: a parameter (or any subfield) received in a method call may be either a future or a value due to transparency of first-class futures. This section suggests an extension to the Interface Descrip- tion Language (IDL) to improve the precision of analysis and specification, we also explain how this extension prevents the occurrence of some deadlocks.

The IDL used in the GCM specifies the interface signatures, but is insufficient to deal with transparent first-class futures. Based on the interface signature, one does not know whether method parameters are futures or not. Moreover, there is no way of controlling which parameters cannot be futures. Typing futures would solve the issue, however, we would lose all the good properties shown in Section 2.2. One way is to specify within the IDL which parameters (or fields) cannot be futures (i.e. marking them as strict value); the other parameters are allowed to be futures or not. Note that this is less restrictive than typing because some parameters can still be either a value or a future.

The difficulty is finding, statically, a proper abstraction for the parameter struc- ture. In theory, every subfield of every parameter may be a future. Therefore a static representation of arbitrary types is impractical. Here we suggest a relatively precise approximation; marking a field as strict value, recursively, means that all its subfields (known at runtime during serialisation) are strict values as well. Similarly, not marking a field implicitly means that, recursively, all its subfields (except the marked ones) may be futures.

model for futures and their behaviour (synchronisation, update). This model ex- presses the flow of future references and future values. It extends our previous works by giving behavioural models for transparent first-class futures, relying heavily on the properties proved in the ASP-calculus.

