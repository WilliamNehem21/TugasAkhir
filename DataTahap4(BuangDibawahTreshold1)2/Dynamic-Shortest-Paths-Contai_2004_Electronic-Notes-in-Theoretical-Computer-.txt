All previous approaches, however, deal with the static version of the inves- tigated problem. In this paper, we are concerned with the dynamic version of the above mentioned scenario; namely, with the case where the graph may dynamically change over time as streets may be blocked, built, or destroyed, and trains may be added or canceled. In this work, we present new algorithms that dynamically maintain geometric containers when the weight of an edge is increased or decreased (note that these cases cover also edge deletions and insertions). We also report on an experimental study with real-world railway data. Our experiments show that the new algorithms are 2-3 times faster than the naive approach of recomputing the geometric containers from scratch.

If n denotes the number of nodes, a graph (without multiple edges) can have up to n2 edges. We call a graph sparse, if the number of edges m is in O(n), and we call a graph large, if one can only afford a memory consumption in O(n). In particular for large sparse graphs, n2 space is not affordable.

Note that further nodes may be part of a target container. However, at least the nodes that can be reached by a shortest path starting with e must be in T (e). We will refer to the additional nodes as wrong nodes, since they lead us the wrong way.

Proof. Obviously, the edge (x, y) must be part of this path Pnew. Let Psy denote the sub-path of Pnew from s to v. As a sub-path of a shortest path Psy is also a shortest path. In particular, Psy is a shortest path that ends with the edge (x, y). For symmetric reasons, the first edge of a shortest x-t-path is (x, y).	 

Proof. Since wnew(x, y) < wold(x, y), the new distance dnew(s, t) must be shorter than the old distance dold(s, t). The new shortest path Pnew does con- tain the edge (x, y) in contrast to the old shortest path from s to t. Therefore

For each graph, we increase the weight of 100 random edges to a large value (i.e. the sum of all weights in the graph). This is similar to removing the edge from the graph. After every weight change, the containers are updated according to section 4.1. A second set of containers is determined from scratch to compute the quality and compare the computation time.

For the evaluation of decreasing edge weights, we start with the graph where 100 random edges have been set to a large weight. The weights are then decreased to their original values. Again, the updated containers are compared to newly computed containers.

Compute the container from scratch. The result is slightly different from recomputing all containers from scratch, because some may shrink but are not updated. However, the distances of all nodes to x and from y to all nodes are not needed in this case and their computation can be omitted.

Enlarge the container to infinity (without any further computation). If the entire graph is inside the container, it is certainly consistent. However, the quality of the containers is going down rapidly. Again, the distances of all nodes to x and from y to all nodes are not needed in this case and their computation can be omitted.

It would be interesting to find other simplifications that guarantee con- sistent containers, but realize a good compromise between optimality and running time. Furthermore, our results suggest that it should be possible to get a speed-up factor of about 2 with an (provable) optimal update strategy. Finally, it might be possible to combine edge weight increases and edge weight decreases in a single algorithm.

