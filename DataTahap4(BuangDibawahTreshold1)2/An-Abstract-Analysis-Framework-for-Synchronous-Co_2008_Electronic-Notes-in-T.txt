A pretty wide range of concurrent programming languages have been developed over the years. Coming from different programming traditions, concurrent languages differ in many respects, though all share the common aspect to expose parallelism to programmers. In order to provide language level support to pro- gramming with more than one process, a few basic concurrency primitives are often combined to provide the main language constructs, sometimes making different assumptions. In this paper, we analyze the most common primitives and related semantics for the class of synchronous concurrent programming languages, i.e., languages with a global mechanism of processes synchronization. Then, we present a generic framework for approximating the semantics of the main constructs which applies to both, declarative as well as imper- ative concurrent programming languages. We determine the conditions which ensure the correctness of the approximation, so that the resulting abstract semantics safely supports program analysis and verification.

Concurrent programming languages are programming languages that use language constructs for concurrency. Two main approaches exist to concurrency: the syn- chronous and the asynchronous models. Asynchronous models are based on the assumption that system components running in parallel proceed at different rates.

In this paper, we analyze the most common primitives and related semantics for the class of synchronous concurrent languages. Then, we present a generic frame- work for approximating the semantics of the main constructs which applies to both, declarative and imperative concurrent programming languages. We determine the conditions which ensure the correctness of the approximation so that the resulting abstract semantics safely supports accurate program analysis and verification.

In order to obtain an effective approximation of the semantics based on abstract interpretation, some sensible decisions would be made at this level which depend on the specific language and are not considered here. These decisions regard in particular how to abstract both, the domain as well as the basic actions. In the following section we discuss how the operators can be generally abstracted. The accuracy of these abstractions directly determines the amount of non real traces added to the abstract model.

In the following, we focus on the abstraction of those actions that are more critical in the sense that their execution can suspend. This includes the global choice action. As we are going to see, also the conditional operator must be handled with particular care. Actually, we are able to abstract the conditional operator without altering the notion of time of the source language only if the language being abstracted does provide an instantaneous choice operator. Below we clarify this point.

