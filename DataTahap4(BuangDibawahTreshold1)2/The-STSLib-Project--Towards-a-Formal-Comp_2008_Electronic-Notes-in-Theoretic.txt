Software engineering is still evolving in several directions. The first direction is to provide a better modularization and a separation of concerns. Examples are the numerous works around software architecture, component based program- ming and aspect oriented programming. A second preoccupation has been

Other related component references are: [12,4,16]. [12] provides a finite labelled transition model for behavioural interface of components and an au- tomatic way to check their compatibility. The originality is that they consider an optimistic hypothesis and redefine the way to compose dynamic systems. In [16], the authors propose a way to model-check Java components by ex- tracting a model of its environment. This can be seen as a variation of compo- sitional model-checking but verifying specific properties of individual compo-

Considering Java source code generation, the constructive approach of Coglio and Green [10] is relevant. In this paper, the authors show that a constructive approach, generating code from specifications, can be a valuable alternative to usual code verification. The usual way is to verify legacy code by a post-hoc method of proving certain properties, or possibly functional cor- rectness. But the combinatorial difficulty of a post-hoc approach has generally prevented the community from being able to prove full functional correctness,

As the reader may see, this product defines an STS with pairs of states and pairs of events. This synchronous product can be extended to a n-ary product and to any depth. The extension of the synchronous product of automata contains in the result the structure of the composite. Thus, we not only have states and transitions, but composite states, composite transitions, composite events and so on. This is valuable to get an exact understanding about the events and the conditions occurring in a complex system.

The STSLib API is an implementation of the STS concept with the following functionalities. It supports the definition of the dynamic and the data type part of an STS. Such an STS allows guards, emissions and receipts (n-ary, one-way, and multiple), receipt on guards and the * notation. Architecture can be built from existing components and the synchronous product can be computed. This produces a structured STS, allowing analysis of complex

Abstraction techniques such as [9,6,11] may be used in our context, but are currently only possible with a manual transformation step. Some abstractions are simple to perform on our STS either on the dynamic part or the data part, a comprehensive analysis is under study. For example, we want to check that an existing card is either owned by the proper client or by its connected till or lost. This safety property was proved by abstracting the data of the system into the card identity which is also the client id. The global product

A design of this case study has been done with LOTOS and the CADP toolbox. The LOTOS description of the processes appeared in [22]. The LO- TOS description is closest to our STS description and an automated trans- lation is even possible. However CADP bound the data types, we use really strict bounds and we cannot compute the BCG representation (the internal LOTOS representation) even with one client and one till.

Our long term objective is to provide a Java compiler which is able to translate STS, both the state machine part and the data part, and architectures into Java code. Currently we defined an experimental interpreter. There are two main parts in this: the implementation of the rendezvous we have at the specification level and the translation of the STS data part into Java. The first part was detailed in [13] and this section describes the principles of the second part. The specification process is the following: the user generates, from the STS dynamic part, a skeleton of the ADT with the signatures, then he fills the axioms part and finally a code generator produces the full Java class and its interface.

type the emitted type, ii) a guard is a boolean function of the current data type, and an action is a function of the current data type with as resulting type this current data type. In case of a receipt the guard and the action takes as additional parameters the typed receipt variables. In case of an emission, the action takes as additional parameters variables corresponding to the emitted types. In the usual terminology of ADT, guards and emitters are called observers and actions belongs to the constructor category.

Our experimental generator relies on some hypotheses but the original thing was to generate full imperative Java code from data type description. The current hypotheses are a prefixed grammar, and the lack of operator overloading. While these features do not impose technical difficulties, they will complicate the grammar. Another restriction we are able to relax is the mono- generator constraint since we have already investigated this problem in [24]. This previous work explored object-oriented class generation representing a data type with several generators. Currently our translation process preserves the axiom ordering. We have to investigate a less strict approach allowing more general left conclusion terms and a support to check axiom exclusivity (for instance using critical pairs computation).

Our library provides a CompositeSTS Java class, which defines a list of sub- components, the locations of the dynamic and data parts, the internal con- nections, with the modal operator and the external connections. From the internal connections and the modal operator, a list of synchronization vectors is computed. These vectors serve to build the locks as needed to manage the rendezvous mechanism. In addition to this, the composite defines a scope which may hide or export some ports (and the associated events) to outside. It has a similar role to the hiding operator of process algebras. A parser and a loader have been designed for the composite structure which are able to handle complex architecture descriptions. This raises the issue of defining a global context class which memorizes the component (primitive or composite) al-

One important and future task on the verification side is to define and implement abstraction techniques. The second task is to elaborate a con- crete syntax for hierarchical components and to implement a Java compiler based on our experimental interpreter. Another future perspective is to prove the translation process into Java code and the correctness of our rendezvous mechanism.

