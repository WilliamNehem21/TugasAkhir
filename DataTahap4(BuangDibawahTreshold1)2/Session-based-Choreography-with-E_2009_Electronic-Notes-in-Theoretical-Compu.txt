An emerging paradigm for programming communication is the so-called Chore- ography. This discipline focuses on the fact that an architect, when designing a distributed system, no longer describes the behaviour of each single interacting peer (end-point behaviour ) but establishes how the various inter-participant interactions happen by giving a global description (choreography) of the system. In a traditional approach, the architect would describe each communication operation, e.g. an input to be performed at one particular peer. Unfortunately, this makes it very difficult to have a global view of how the whole system being designed works. On the other hand, a global description offers a view of where and when a communication has

to happen. The architect will now decide that e.g. there will be a message from A to B and no longer think how this will be implemented at A (sending a message) or B (waiting to receive a message). Choreography can offer a vantage view of the system facilitating the design stage and leaving the implementation details to the (possibly automated) process of generating a sound end-point code, called end-point projection.

Exceptions are a mechanism widely adopted in modern programming languages (e.g. Java, C#) for dealing with exceptional system behaviours i.e. they are de- signed to handle the occurrence of some conditions interrupting the normal flow of execution of a program 3 . While the classical notion of exception is bound to the local flow of a process, in communication-centred programming exceptions are about the flow of interactions where a sudden interruption must involve all inter- acting participants. We shall call this kind of exception an interactional exception [5].

Example 2.1 (A simple Financial Protocol) This example and the following one [5] are typical scenarios in financial protocols. Consider a customer Buyer who wishes to pur- chase a product from a company Seller. Buyer starts a session with Seller who repeatedly sends quote updates about the product price. When Buyer decides to accept a particular quote, without explicitly notifying Seller, it throws an exception. At this point, Seller and Buyer move together to a new stage (exceptional stage with respect to the ordinary se- quence of actions) where they exchange information for successfully terminating the trans- action e.g. credit card details for payment and receipt. A global calculus representation of the protocol which uses the interactional exception mechanism is given:

In lines 1 and 2, Buyer invokes service chBroker and sends its identity id to Broker who, in line 3, will check whether Buyer is bad or not. If Buyer is not trusted, Broker will raise an exception which will take both Buyer and Broker to an abortion procedure in line 12. Note that in this case, Buyer and Broker are the only participants involved so far and the only ones who will move to another conversation for handling the exception.

If Buyer can be trusted, Broker invokes service chSeller and forwards to Buyer all quotes received from Seller increasing them by 10%. As before, Buyer will throw an exception whenever s/he decides to accept a quote. In this case, as the participants involved are now Buyer, Broker and Seller, the handler to be executed is the inner one where Broker will forward messages between Buyer and Seller (lines 8-11). This event will also discard the handler in line 12 which, after session initiation in line 4, has become inactive.

The predicate outerTry is necessary because the throwing of an exception can happen nested in a try-catch block which is a refinement of an outer one. Like in the financial protocol with broker, the latter needs to be discarded. Hence, we need to apply meta reduction to the outermost block.

Above, the default choreography describes a system where participant B sends two messages, one immediately after the other, without waiting for an acknowledge- ment from A. This is a common scenario in communication-centred programming that, we believe, should also be allowed. As another example, also consider the financial protocol shown in the previous sections (also without Broker) where Seller repeatedly sends a quote.

Well-threadedness is based on thread annotation of global descriptions. Threads are denoted by identifiers denoting which actions belong to the same processes. For instance, in the example above, b(s)[s, s!op(v), Q1] and !a(t)[0, Q2] denote two different threads, both running at the same location A.

Thread Projection and Coherence. In this subsection, we discuss, together with the definition of coherence, the notion of thread projection i.e. given an anno- tated global description I, how can we generate the end-point behaviour associated to each of its threads.

When we project thread 1, we must take into consideration that, after the refine- ment in line 2, such a thread is involved in another handler in the line 4 besides the outermost handler in line 5. Therefore, we must make sure that the thread projection of 1 provides a single handler ready to input with both operations op4 and op5 (lines 4 and 5). The solution is to merge the outermost handler in the fifth line with any other nested handler involving thread 1. In [4], thread merging is a partial operation between threads that allows differences in branches which do not overlap. If two end-point behaviours are mergeable, we can merge them and obtain a single process which simulates both of the two behaviours, by combining missing branches from the both. For instance, in the above example the projection of thread 1 would result into

We have introduced the notion of exception for choreography. In particular, we have extended the syntax of the global calculus [3,4] with the exception mechanism and given its formal semantics. The aim of this work was to show how exceptions can be used at choreography level and, with examples, how they can be mapped to end-points. In the global calculus, exceptions are a simple form of transferring execution to a different choreography. But, together with a sound end-point pro- jection, choreography becomes a powerful tool for designing end-point behaviour where the raising of an exception will transfer the execution of all end-points to an exception handling interaction.

Future Work. The global calculus with exceptions introduced in this work is still limited to some basic operators and only includes values in messages. One point that needs further investigation is to allow the passing of service and session channels although this problem should also be carefully studied at end-point level.

The end-point projection has only been analysed through examples but it has been revealed that it does not follow directly from the work done in [4]. However, the three conditions for guaranteeing end-point projection need to be formally defined and a theorem stating the correctness of the EPP must be proved. In particular, we need to understand how to formally define the thread projection of run-time terms such as try-catch blocks and queues.

