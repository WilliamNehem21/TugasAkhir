When modelling complex interactive systems, traditional interactor-based approaches suffer from lack of expressiveness regarding the composition of the different interactors present in the user interface model into a coherent system. In this paper we investigate an alternative approach to the composition of interactors for the specification of complex interactive systems which is based on the coordination paradigm. We layout the fundations for the work and present an illustrative example. Lines for future work are identified.

Interactive systems can be seen as a special case of the more general class of reactive systems. However, interactive systems have specificities that present new challenges when considering modelling and reasoning about them. One major aspect is the need to consider interaction with the user, and not only between components of the user interface.

Managing the coordination between the different interactors is typically achieved by the introduction of additional interactors to express the control logic for their communication. This, in turn, adds to the complexity of the models. Ideally we should be able to express the logic of the coordination between the different inter- actors in an as natural and simple way as possible. In this paper we explore the application of the coordination paradigm to model architectures of interactors. The approach is based on previous work by some of the authors (see, [5,6]).

The coordination paradigm [13,18] offers a promising way to address issues related to the development of complex systems. Since the coordination component is sep- arate from the computational one, the former views the processes comprising the latter as black boxes, whose internal implementation is hidden from the outside world. Instead, the composition of components is defined in terms of their (logical) interfaces which describe their externally observable behavior. By hiding all system computation in the components, a system can be described in terms of the observ- able behavior of its components and their interactions. As such, component-based software modelling provides a high-level abstract description of a system that allows for a clear separation of concerns between the coordination and the computational aspects.

An interactor can generate data in two directions: towards the user, and towards the application. This means that interactor behaviour is divided into two distinct parts: the external one, which contributes to the definition of the appearance, and the internal one, which consists of sending data to other interactors or application processes. Hence, an interactor is defined by a couple of functions: FI is associated with the internal behaviour (the information flow from the user towards the appli- cation side); FO is associated with the external behaviour (the information flow from the application towards the user side).

In the definition of FO, Ic represents the domain describing the output entities which it receives from the application side. Out is the type which describes the external appearance which can be generated, and If is the data type which the input part of the interactor passes to the output part for echoing. T , in both FI and FO definitions, is the time, which can be considered as a one-dimensional quantity, made up of points, where each point is associated with a value. At moment t, FO is applied to data from Ic and to an element in domain If produced by FI 

In exogenous coordination models, like [2] or [5], components are black box entities accessed by purely syntactic interfaces. The role of an interface is restricted to keeping track of port names and, possibly, of admissible types for data items flowing through them 6 . Such a notion of components interface is perfectly extensible with the notion of CNUCE interactors. So, let us define an interface as

The model provides a set of basic connectors and combinators which allow us to construct more elaborated connectors and define more complex patterns of co- ordination and interaction. In the following let us consider some of these basic connectors. For more connectors and a more formal treatment of them we refer to [5,6].

Its effect is to plug ports with the same polarity. The aggregation of output ports is done by a right join (C i > z), where C is a connector, and i and j are ports and z is a fresh name used to identify the new port. Port z receives asynchronously messages sent by either i or j. When messages are sent at the same time the combinator chooses one of them in a nondeterministic way. On the other hand, aggregation of input ports resorts to a left join (z <i C). This behaves like a broadcaster sending synchronously messages from z to both i and j. Formally, at a behavioural level, both operators effect is that of a renaming operation

activated synchronously. It should be noted that, since we are not considering timing issues at this stage, this synchronicity does not meant that the ports are activated concurrently. In the current context, what we are stating is that if one port is activated, then all the other must be activated, before the connector can engage in a new interaction.

As a final remark is important to note that this work reports on the main ideas of this approach only. The full specification of the calculi involved in the development of the examples was not demonstrated in this paper. We refer to [7] for a complete view of this approach applied to another kind of application.

As a final note, it should be point out that, when modelling complex interactive systems, the need arises to express dynamic aspects of the user interface, such as user interface components being created and destroyed, or the interconnections between components being changed in runtime. This is a complex area which we have not addressed here. A very preliminary work in this direction was presented in [8]. In that work the basic connectors are enriched with a special connector called orchestrator which is responsible for handling the mobility and the dynamism of the system. We plan to explore this aspect further, as it is one of the main drives for our research in identifying alternative modelling notations for interactive systems.

