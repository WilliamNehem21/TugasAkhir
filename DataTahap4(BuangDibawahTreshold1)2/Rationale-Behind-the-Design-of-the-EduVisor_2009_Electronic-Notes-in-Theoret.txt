The EduVisor software visualization component is a new pedagogical tool specifically developed to address some wide-spread problems in teaching object-oriented technology to novice programmers. The visualization tool is integrated in a world-class IDE, and shows the students the structure of their own creations at runtime. EduVisor is based on a solid grounding in literature and over 25 years of combined experience in teaching a CS1 course. With this component we have set the goal of helping our students progress faster through the most difficult initial stages of programming.

Over the past decades software design has often been described as a wicked or diffi- cult problem [10][11][12][2]. Dalbey and Linn [4] note that the average student does not make much progress in an introductory programming course. More recently, there are many reports corroborating this position. For instance, in the infamous McCracken Report [14] the authors noted that the average score on a programming test was only 22.89 out of 110 points for a sample of 216 students. As difficult as it is for students to acquire programming and software design skills, just as difficult is it for teachers to teach those skills.

we want them to be able to debug their programs faster. Third, we want to increase the enthusiasm of students by visualizing (and thus reducing the abstraction level) their own efforts at the push of a button. The design of the tool is based on several decades of combined CS1 teaching experience and on a thorough grounding in relevant literature.

In section 2 we describe the driving forces behind the design of EduVisor. Section 3 describes the most important runtime issues one encounters during a CS1 course, which will be used as input to the design of EduVisor. Section 4 shows a small sample of the graphical representation used in the EduVisor component based on a simple use case. Section 5 provides an overview of the resulting properties of the component. Section 6 discusses the similarities and differences between EduVisor and related work. Finally, in section 7 we present our conclusions and provide an outlook on the future development of the EduVisor component.

As so many educational institutions, the University of Antwerp has migrated from Pascal to C, later to C++ and finally to Java over the past two decades as the language of choice in our CS1 course. The switch to Java was made seven years ago. During our course we have noticed the same basic errors appear again and again, causing students to loose valuable time and generating frustration and dis- appointment.

This is caused by several issues. First, the nature of their programming efforts is very much trial and error - which is actually a well known fact [1]. Second, the students do not go through the effort of drawing out their solutions in the way we do at the whiteboard. This is not that surprising - creating the visual representations for a running program takes quite some time. Encouraging however is that, when we force them to draw their programs on a sheet of paper, most of the time they are able to pinpoint the problems themselves.

Increase their enthusiasm about object-oriented programming: The visual representation will provide an important incentive to students. As stated by Ross, it is a tacitly known fact that programmers like to see their creations in action. All artisans are intrigued by what they create, and they like to observe their work from all angles [... ]. [18]

At object instantiation, a new object gets drawn on the canvas including mem- ber variables and method areas. The object lives as long as there are references pointing to the object. At instantiation, the memory address is transported to the variable holding the address.

Failing to understand program design: the single canvas approach allows the novice programmer to see the entire structure of the program at any time during the execution. All static and dynamic structures as well as all available variables can be seen without having to switch representations. Panning and zooming capabilities help with understanding more complex structures. This unified visual presentation will help the students to see e.g. which classes (A1), methods (A2) and variables (A4) are part of their program and help them understand the deficiencies in their design. The step-wise nature of the visualization will help them understand their algorithms (A3) better.

Failing to understand the nature of objects: every single object is ex- plicitly represented on the canvas using rounded rectangles (B2). Every object contains only non-static member variables, explaining to the students the dif- ference in runtime behavior between static and non-static structures (B3). The values of these variables are always visible, which will help the student in under- standing the persistent and autonomous nature of an object (B1). Reference variables are represented in a different color than regular variables, and the value of the reference variable is the hash-code of the object. By clicking on the reference variable the corresponding object is highlighted, which will help in understanding the nature of references (B4 and B5).

Failing to understand message passing: Active objects are highlighted on the diagram. This way students see that an object is only active when a method of that object is called (C1). In addition, the values of the variables that are passed as parameters to a method are animated from the calling method to the called method, which helps in understanding the variable passing mechanism (C2). Return variables are also animated. Those return values that are not stored in a variable disappear, explaining the need to store return values (C3).

Failing to understand variables: All variables are always visible on the can- vas and presented in their own scope (class, method or block) and adorned with modifier symbols that are dynamically adjusted to reflect the variables visible to an active method. This helps in understanding scoping (D1). In addition to the variables themselves the values of these variables are also visible, help- ing students keep track of program state (D2) and helping with understanding control variables in loop and selection structures (D3).

visor. In [19], the authors state that [their] notation attempts to show most of the runtime state of the program in a single diagram. Essentially, this means displaying all relevant instances, all references to them and some of the contents of the runtime stack together. However, in their paper the presentation of program state seems to be quite different from the EduVisor presentation. The diagrams do not show the values of the variables, which is crucial in our system. For instance, the diagrams show references between objects as arrows between these objects, but there is no mention of the reference variables holding the objects. In addition, the diagrams do not show objects as environments of execution, i.e. the methods are not represented in the objects. We have found no further mention of this tool in literature.

With EduVisor we have devised a visualization component that can be integrated easily in a world-class IDE such as Netbeans. The code is currently in alpha status but is being further developed as part of the PhD project of the first author. The final intent is to include additional ITS (Intelligent Tutoring System - see Wei et al. [21]) functions such as pop quizzes and course material through XML based code- injection into the intermediate visualization code. Once the code reaches beta in the course of this year, it will be released on a public server. Our first goal now is to further develop this code base, starting with the visualization features and working our way up to the code infusion. Next we will perform experiments to research important features such as the one-canvas philosophy, the animation features and the utility of the additional pedagogical features afforded by the ITS functions.

The main goal of this paper was to present the design philosophy of our EduVisor visualization component. Based on literature and experience we have created a list of common causes of CS1 runtime problems. This list is currently being validated during course sessions and the intermediate results indicate that the list indeed represents the most common issues. The list also serves as input to the design of EduVisor. Finally, we have presented the solutions EduVisor offers to these common problems and contrasted our work with that of similar environments.

