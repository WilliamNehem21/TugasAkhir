In multiparty conversations it is quite natural that participants with essentially the same role are imple- mented by processes that follow the same pattern, differing only in the senders and receivers of commu- nication actions. In order to allow for a lighter and less rigid development of processes, we propose a translation tool which allows one to write processes in a simplified syntax, called partial syntax, where the names of senders/receivers for input/output operations are omitted. By adding the missing information, partial processes can be automatically translated in complete processes, for which an operational semantics is defined. The partial syntax, in particular, allows one to use the same process template to implement similar participants.

The translation from partial processes to complete processes is formalised in natural semantics by a set of rules. These rules implicitly define a recursive translation and type checking function, whose code is given in a ML-like language. The sound- ness and completeness of both the natural semantics rules and the corresponding algorithm can be easily proved.

Multiparty sessions arise motivated by the applications to financial protocols in the context of the development of the language Scribble [12]. The first the- oretical works on multiparty session types are [2] and [7]. The paper [2] uses a distributed calculus where each channel connects a master endpoint to one or more slave endpoints. Both processes and types in [7] share a vector of channels and each communication uses one of these channels. The process syntaxes in the present pa- per are similar to those in [1]; the main difference is that communications in [1] are asynchronous. The paper [4] takes advantage of partial syntax flexibility for dealing with self-adapting protocol participants. Bisimulation of a synchronous multiparty session calculus is studied in [9], where the calculus syntax differs from our complete syntax only for the lack of multiple receivers. We refer to [5,3,8] for comprehensive overviews of related works.

Section 2 introduces global types and partial syntax by means of examples. The whole calculus and the type system are given in Sections 3 and 4, respectively. Section 5 concludes with the natural semantics rules, mapping processes written in partial syntax to processes written in complete syntax. Lastly a translation and type checking algorithm is provided.

Multiparty session programming consists of two steps: specifying the intended communication protocols via global types, and implementing these protocols as pro- cesses. The specifications of the manager-factories protocol are given by the global type Ga. The participants are actually coded by numbers: in Ga we have M = 5, IF = 1, AF = 2, IC = 3, AC = 4.

In Ga, line 1 denotes M multicasts the same string to IF and AF. Lines 2 and 3 say both IF and AF send a natural value to M. In lines 4-8 M sends either ok or quit to all other participants. In the first case both IF and AF send to IC and AC, respectively, the number of items to deliver (lines 4-5) and the transport companies communicate delivery date to M directly (lines 6-7); in the second case there are no further communications.

Session name a establishes the session corresponding to Ga. Process M initiates a session involving five participants as fifth one by a [5](y); the first and second participants are obtained by instantiating j by 1 and 2, respectively, in F[j], the third and forth participants are obtained as two instances, for k = 3 and k = 4, of C[k]. Each participant uses a bound variable as a placeholder for the channel that will be used in the communications. Sender and receivers of the exchanged data are specified by the global type.

We now enrich this protocol introducing delegation. In the initial session a the participants are only the manager and the two factories, which also send the de- livery date to the manager, according to the new global type Ga. Actually, after receiving ok, both factories accept a new session b offered by a unique transport company. In this session, described by the global type Gb, each factory sends to the transport company not only the number of items, but also the channel used to communicate with the manager. In this way each factory delegates the transport company to send the delivery date to the manager. This delegation is transparent to the manager. The new global types Ga and Gb are then:

In the last example we add recursive-branching behaviour to the protocol with delegation. In particular we allow M repeatedly negotiates with the factories IF and AF the number of items to supply. The scenario is basically the same, the only part that changes is that, if the number of items the factories can provide is too small, the manager initiates a negotiation with the factories to increase that number. The manager starts asking the factories for a first number of items. At each step each factory answers with a new offer. The manager can accept the offer, ask for a new proposal or give up. When the manager decides to end the negotiation (accepting the last offers or giving up) he communicates his decision to the factories; in the first case, as before, the transport company is contacted.

Let |P | be the partial process obtained from the complete process P by erasing senders and receivers. If a complete process P without channels with role is typable, then the judgment which states the translation of |P | is provable. The process resulting from this translation coincides with the original P , but for erasing recursive definitions of process variables which are never called. More precisely:

