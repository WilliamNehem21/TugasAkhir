The operational semantics of a programming or speci cation language is often given in a relational style using inference rules following a small-step approach (a.k.a. structured operational semantic [36]) or big-step approach (a.k.a. nat- ural semantics [13]). In either case, algebraic ( rst-order) terms are often used to encode the language being speci ed and the rst-order theory of Horn clauses is often used to formalize and largely mechanize such semantic speci-

We must also restrict the use of implication in the bodies of de nitional clauses, otherwise cut-elimination does not hold [39]. To that end we assume that each predicate symbol p in the language is associated with it a natural number lvl(p), the level of the predicate. We then extend the notion of level to formulas and derivations. Given a formula B, its level lvl(B) is de ned as follows:

more natural that what we intend to prove is rather: \if (if B M M ) + V is provable then M + V is provable." To explore this possibility, consider intro- ducing the predicate . that serves as an operator for provability. In this case, we now need to distinguish between two logics, one meta-level logic and one object-level logic. To do so, we shall use the type o to denote meta-level logical expressions and obj to denote object-level logical expressions. The meta-logic uses the symbols 8 of type ( ! o) ! o, 9 of type ( ! o) ! o and ^ and , both of type o ! o ! o for universal and existential quanti cation at type  , for conjunction, and for implication, respectively. The object-logic

., provability of M + V directly from its Horn clause speci cation or indi- rectly via the use of this interpreter are essentially the same: (uniform) proofs in one setting map naturally to (uniform) proofs in the other setting. From a practical point of view, this distinction does not provide any proof search advantages.

 Prolog, Elf, Isabelle, and Coq, to name a few, all implement a form HOAS and many earlier papers have appeared exploiting this style of syntactic rep- resentation [24,25,26,34]. Since the earliest papers, however, there has been a tendency to consider richer -calculi as foundations for HOAS, moving away from the simply typed -calculus setting where it was rst exploited. Trying to encode a syntactic category of abstraction by placing it within a rich function spaces can cause signi cant problems (undecidable uni cation, exotic terms, etc) that might seem rather inappropriate if one is only trying to develop a simple treatment of syntax.

Thus we need to encode the object-level judgment x1;::: ; xn ` (P x1 ::: xn), where the variables on the left are all distinct and understood as bound entirely within this judgment, as an atomic formula in our meta-logic. We mention two ways to achieve this encoding. The rst introduces a \local" binders using a family of constants, say, loc of type ( ! obj) ! obj. The above expression would be something of the form

While this encoding is natural, it hides the top-level structure of P x1 ::: xn under a pre x of varying length. Uni cation and matching, which are central to the functioning of the de nition introduction rules, would not be able to directly access that top-level structure. The second alternative employs a coding technique used by McDowell [14,15]. Here, one abstraction, say for a variable l of type evs (eigenvariables), is always written over the judgment and is used to denote the list of distinct variables x1;::: ; xn. Individual variables are then accessed via the projections  of type evs ! and ^ of type evs ! evs. For example, the judgment x : a; y : b; z : c ` P xyz could be encoded as either the expression loca xlocb ylocc z:P xyz; or as

Proof outline. Applications of inference gures correspond exactly to the selection of prog clauses for backchaining over. Here, the use of and ^ ensures that object-level eigenvariables are represented by new terms at the meta-level. For this encoding to work properly, we also assume that no constants at the object-level have types involving evs.	2

We shall follow the presentation of the -calculus given in [29]. We need three primitive syntactic categories: name for channels, proc for processes, and action for actions. The output pre x is the constructor out of type name ! name ! proc ! proc and the input pre x is the constructor in of type name ! (name ! proc) ! proc: the -calculus expressions x  y:P and x(y):P are represented as (out x y P ) and (in x y:P ), respectively. We use j and

composition and summation, and of type (name ! proc) ! proc to denote restriction. The -calculus expression (x)P will be encoded as n:P , which itself is abbreviated as simply x:P . The match operator, [ = ] is of type name ! name ! proc ! proc. When  is written as a pre x, it has type proc ! proc. When is written as an action, it has type action. The symbols # and ", both of type name ! name ! action, denote the input and output actions, respectively, on a named channel with a named value.

Proof Outline. Follows almost directly from Propositions 4.1 and 5.1. The induction needs to be strengthen slightly to handle the case where the bound variable l in .l are free in the judgment, which can happen, of course, when a universally quanti ed goal is interpreted.	2

negation, h = i : name ! name ! assert ! assert for the match modal, h i : action ! assert ! assert for the possibility modal for non-binding ac- tions, and the following four modal operators used to encode the possibility of a bound actions: h# i ; h# iL ; h# iE ; h" i : name ! (name ! assert) ! assert. The rst three of these modals are used to code the \basic", \late", and \early" versions of the bounded input pre x while the forth encodes the bounded output action. Natural numbers are encoded as the type nat with constants z : nat and succ : nat ! nat. The satisfaction relation is de ned using two predicates: j= at type (evs ! proc) ! (evs ! assert) ! o as well as at the type nat ! (evs ! proc) ! (evs ! assert) ! o. This extra argu- ment is used to help stratify this de nition in the presence of negation in the assertion language. The predicate depth is of type (evs ! assert) ! nat ! o

Finally, the approach to encoding syntax and operational semantics used here is strongly motivated by proof theoretic considerations. There has been much work lately on using a more model-theoretic or categorical-theoretic approaches for such syntactic representations, see for example [4,5,10]. Com- paring those two approaches should be quite illuminating.

Catuscia Palamidessi has made a number of comments on a draft of this paper. Anonymous reviewers also made several corrections to the presentation of this paper. This work is funded in part by NSF grants CCR-9912387, CCR- 9803971, INT-9815645, and INT-9815731.

