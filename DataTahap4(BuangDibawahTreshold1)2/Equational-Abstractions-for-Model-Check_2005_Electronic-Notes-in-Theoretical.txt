An Erlang program consists of a set of modules. Each module basically contains a list of function declarations. In our example the system is defined in one module. It is initialized using the start function, which, according to the export declaration, is the only function accessible from outside the locker module. By calling the corresponding startup functions, it generates three new processes: one locker and two clients. The actual process creation is performed by the spawn builtin function which receives the module identifier and the name of the function to be invoked in the new process, together with its arguments.

A client process exhibits the complementary behavior. By issuing a re- quest, it demands access to the resource. Here, the self builtin function returns the process identifier (pid) of the client process, which is then used by the locker process as a handle to the client. After receiving the ok message it accesses the resource, and releases it afterwards.

rules of deduction which specify how to apply the above transition rules. In this way it is possible to reason about concurrent systems whose states are presented by terms and which are evolving by means of transitions. Here, the states are structured according to the signature, and the transition rules specify the local transitions in this structure whereas the deduction rules allow to reason about the overall behavior of the concurrent system given the local transformations.

Moreover we will attribute a transition label and a current evaluation envi- ronment to a process. The former is used to indicate the type of the transition which lead to the current state. The latter stores the bindings between the Erlang variables and the values assigned to them. It is modified by an assign- ment or by a pattern matching operation. Syntactic restrictions imposed on the code guarantee that every occurrence of a variable name lies within the scope of a binding operation.

live and dead processes be combined using the associative and commutative parallel composition operator  to obtain a concurrent process system. This, however, makes only sense if every process is uniquely identified by its pid. We therefore call a process system well formed if all pids which occur in the process tuples are distinct, and assume every process system to be well formed from now on.

The following rule handles one of the central concepts of Erlang: asyn- chronous sending of messages. As we shall see the message will be appended to the mailbox of the target process. Note that a process can also send a message to itself.

Process generation is formalized as follows. The spawn builtin function comes with two arguments: a function atom, and a list of arguments. The new process will call this function with these arguments, starting with the empty mailbox and the empty environment.

At first glance it might look surprising that the locker system possesses a finite state space although both the locker and the client function are recursively defined. This can be explained by the fact that only tail recursion is employed, that is, a recursive function call can occur only as the last expression in the body of the respective function. Hence such a call corresponds to a jump to the beginning of the respective function body, and thus the size of the expression which represents the control state of the computation is bounded. In fact tail recursion gives rise to an implementation technique called last

