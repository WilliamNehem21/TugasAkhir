{1,..., n}. In the following, x may consist of both structural variables as well as artificial slack variables introduced to obtain this form. For the ease of presentation, we do not consider explicit upper bounds on the variables in our notation. However, all measures introduced in the following can be easily extended to that case.

In this paper, we are focusing on dual degeneracy. An LP solution is called dual degenerate if the corresponding dual solution is (primal) degenerate. The dual solution is degenerate if one of the primal non-basic variables has a reduced cost of zero. These variables will be called dual degenerate in the following. A dual degenerate optimal LP solution implies that there might be alternative optimal solutions to this LP. More specifically, each dual degenerate variable can be pivoted into the basis without changing the objective value. Thus, multiple optimal bases are guaranteed to exist. If the variable that is pivoted out of the basis is not subject to primal degeneracy, i.e., was not at its bound before, this corresponds to a distinct primal optimal solution represented by the new basis.

The paper is structured as follows. In Sect. 2 we introduce two degeneracy measures, and then use them to computationally analyze, at the end of the root node, how many models are affected by dual degeneracy and to which extent, using a collection of public benchmark instances. Then, in Sect. 3, we evaluate how degeneracy evolves during tree search, showing that, on average, the degree of dual degeneracy stays almost constant. Finally, in Sect. 4, we evaluate how dual degeneracy affects LP solution values, and comment on the implications of our findings on the branching variable selection. In particular, we show that a high dual degeneracy often allows a significant number of branching candidates to move to an integer value while staying on the optimal face, indicating that those are poor branching candidates, and this should be taken into account by branching strategies. Conclusions are drawn in Sect. 5.

We will use two measures of dual degeneracy in the following. The first one is a classical measure in this context, and follows directly from the definition of dual degeneracy. The degeneracy rate counts the relative number of dual degenerate non- basic variables.

When considering a particular instance, we would expect an increased degeneracy rate to result in a higher number of basic variables that can be pivoted out of the basis. However, the share of non-basic dual degenerate variables would be the same (50%) if one of only two non-basic variables were dual degenerate as it would be if 500,000 out of a million non-basic variables were dual degenerate. For the same number of constraint and thus, the same basis size, however, the latter will probably allow pivoting more of the current basic variables out of the basis.

The observations we describe in the following naturally depend on the solver and, in particular, the branching rule used for the experiments. We used reliability branching (Achterberg et al. 2005), because it is a state-of-the-art rule used (in slight variations) by many solvers. Therefore, we are optimistic that the results should trans- fer both to other solvers and other common branching rules.

As test set, we use the MMMC test set which is the union of different common MIP benchmark sets. It contains all instances from MIPLIB 3 (Bixby et al. 1998), MIPLIB 2003 (Achterberg et al. 2006), and the MIPLIB 2010 benchmark set (Koch et al. 2011) as well as the Cor@l test set (http://coral.ie.lehigh.edu/data-sets/mixed- integer-instances/), which mainly contains instances that users worldwide submitted to the NEOS server (Czyzyk et al. 1998). Duplicate instances were removed, leaving us with a total of 496 instances.

All computational experiments presented in the following were performed on a compute cluster with 48 compute nodes, running only one job per node at a time. Each compute node provided two Intel Xeon Gold 5122 CPUs at 3.60 GHz with 96 GB main memory. Computing detailed degeneracy information can be time consuming; therefore, we applied a time limit of 2 days per job.

To get a first impression of how these instances are affected by dual degeneracy, we analyze the final root LP solution of SCIP in the remainder of this section. That is the LP solution after presolving, node preprocessing, the cutting plane separation loop, and potential restarts. In the next section, we will examine the amount of degeneracy inherent in the LP solutions throughout the branch-and-bound tree search.

Out of the 496 instances, 56 instances are solved at the root node before degen- eracy information is computed. Of the remaining 440 instances, only 55 instances show no dual degeneracy in the solution of the final root LP. On the other hand, 13 instances have only degenerate non-basic variables, i.e., have a degeneracy rate of 100%. These instances are pure feasibility problems with a zero objective function in the original model (6 instances), after presolving (4 instances), or after root processing (3 instances). For the majority of instances, degeneracy tends to cover either only a few or almost all variables: 158 instances have a degeneracy rate no larger than 10% while the rate is larger than 90% for 119 instances. The remaining instances distribute among the degeneracy rates from 10 to 90% with slightly fewer instances at medium ranges.

We observed degeneracy in the final root LPs of most of the regarded instances, but that alone is not enough to understand how degeneracy evolves during the tree search. In order to investigate this, we ran each instance with a node limit of 1 million, and computed the average degeneracy per depth level by first averaging over all nodes of one depth for each individual instance, and then averaging again over the instances averages for each depth level. Note that we disregard variables fixed by branching or domain propagation for the degeneracy computation and only compute the degeneracy share of the unfixed variables. The observed average degeneracy rate is almost constant during the tree search. At the root node, the average degeneracy rate is 45.8%, at depth 100, it is 45.7%. In between, it varies slightly between 44.4 and 49.4%.

We observe that many instances change their degeneracy rate during the tree search. There are roughly the same number of instances with increasing degeneracy rate at deeper levels as with decreasing degeneracy rate. The variance increases with the depth, which is reasonable as the deeper a subproblem is in the tree, the more different it is to the global problem. This explains why we observed an almost constant average.

So far, we demonstrated that dual degeneracy is very common in real-world problems. How many of the non-basic variables are affected by dual degeneracy is represented by the degeneracy rate. But being dual degenerate alone does not guarantee that a variable can indeed take different values on the optimal face. In this section, we investigate how often this happens and how this relates to the discussed degeneracy measures. In particular, we aim at answering the following two questions:

We are especially interested in the cloud intervals of integer variables. In particular, we want to identify variables that can take different values in alternative LP optima, which corresponds to a cloud interval containing more than a single point. We call such a cloud interval non-trivial. Additionally, we are interested in the case that the cloud interval contains an integer value, because this implies that there is at least one optimal solution for which that variable is integral. This might have implications for solver components, e.g., branching on such variables should typically be avoided since the dual bound will not improve for at least one child node.

As already mentioned in Sect. 2, alternative LP optima can be computed by restrict- ing the LP to the optimal face and optimizing auxiliary objective functions (Achterberg 2013). In this paper, we minimize and maximize each variable which is not yet fixed, in a similar fashion as optimization-based bound tightening (see, e.g., Zamora and Gross- mann (1999), Caprara and Locatelli (2010), Gleixner et al. (2017b)). In the worst case,

Using filtering techniques, see Gleixner et al. (2017b), the number of LPs to be solved can often be reduced. Nevertheless, it will typically be too large to use this approach in a practical application at every node of the branch-and-bound tree. From a theoretical point of view, however, this method is interesting since it determines the largest possible cloud intervals for each variable. Therefore, we will use this method for a deeper analysis of the effects of dual degeneracy in MIP models in the following. More practical methods to sample alternative LP optima are discussed by Berthold et al. (2019a).

ratios increase. The relative number of non-trivial cloud intervals increases as well. Out of the 152 instances with a degeneracy rate of 80% or higher, 81 can move all unfixed integer variable on the optimal face. Out of the same set of 152 instances, 124

We have seen that for many instances, most of the variables that remained unfixed when fixing to the optimal LP face have a non-trivial cloud interval. On the one hand, those are non-basic dual degenerate variables that can be pivoted into the basis and can then move away from their bound. On the other hand, also the basic variables can often be moved to different values. That case is of particular interest since the fractional basic variables play an important role in many algorithms within MIP solvers, in particular, for branching and cutting.

For branching, it is useful to know whether a fractional variable can be moved to an integer value, i.e., whether it has an integer value in its cloud interval. If this is the case, the branching on this variable does not not improve the dual bound for at least one child node and the variable would thus not be considered for branching by

Intuitively, a large branching candidate reduction is favorable as it allows to restrict the set of promising branching candidates. A special case in this context is a candidate reduction of 100%. This proves that no branching candidate will improve the dual bound of both child nodes.

During the branch-and-bound process, the average degree of dual degeneracy is almost constant. However, we regularly observed large changes in the grade of dual degeneracy for individual instances in deeper levels of the tree. For some instances, branching increases dual degeneracy, while for others, it is decreased. Additionally, we analyzed the effect of dual degeneracy on the uncertainty of the LP solution. Instances with high dual degeneracy measures often allow many variables to vary their value across different optimal LP solutions. Perhaps most importantly, a high dual degeneracy often leads to a large number of branching candidates obtaining integer values in alternative LP optima, which indicates that they are poor candidates for branching. Again, both effects tend to occur in extreme manifestations, but get less extreme at deeper levels of the tree.

