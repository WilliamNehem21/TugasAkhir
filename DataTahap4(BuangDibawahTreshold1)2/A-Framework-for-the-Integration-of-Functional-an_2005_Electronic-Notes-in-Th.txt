Major efforts have been spent in the past for the functional analysis of software systems, that brought nowadays to offer quite sophisticated (formal and semiformal) methodologies and tools to verify and validate the functional behaviour of a software system since the early phases of its lifecycle [1]. On the contrary, non-functional attributes (such as performance, security, etc.) have not received the same consideration. Only in the last few years the idea of integrating such type of analysis along the whole software lifecycle has been supported from new methodologies aimed at filling the gap between the software development process and its non-functional validation [2].

The rationale behind this paper is that the software evolution seems to ask for advances in two major topics of software analysis: (i) the integration of functional and non-functional analysis, and (ii) the automation in embedding the feedback resulting from analysis into the software models. The need of integration has been repeatedly claimed in the recent past, with particular focus on the software architectural level [3]. We introduce here a framework to cope with the integration issues at that level. We started from the goal of evidencing inter-relationships between functional and non-functional aspects that would not necessarily emerge from separate analysis. For example, it is intuitive that upon detecting a deadlock in a software model, a critical compo- nent may be split in two components, and this refinement may heavily affect the software performance. Viceversa, a security analysis may lead to intro- duce additional logics to components (that work as firewalls) in a subsystem, thus the behaviour of the subsystem needs to be validated again. In many cases analysis methodologies are based on a translation of the software model into a different notation to be analyzed (e.g., a formal language for functional verification, or a Petri Net for performance validation). Our intent is to place an intermediate representation (based on XML) of software models that may work as a common ground to apply functional and non-functional analysis as well as to feed back the analysis results on the software models.

[6] with the aim of making the Stochastic Process Algebra a more familiar software model notation to software engineers. Stochastic Process Algebras (SPA) permit to analyze the performance of concurrent systems which are de- scribed as collections of entities, or processes, executing atomic actions. The processes are used to describe concurrent behaviors and they synchronize in order to communicate. Temporal information is added to actions by means of continuous random variables, representing activity durations. The quanti- tative analysis of the modelled system can be performed by constructing the underlying stochastic process. In particular, when action durations are rep- resented by exponential random variables, the underlying stochastic process yields a Markov Chain.

In the Semantic Relations box the rules that link entities to entities are expressed (in XML) and allow to transfer analysis feedback from a notation to another. In fact, the model changes inferred by the analysis results in the XML Integration Core, have to be reflected in the other analysis methodologies. This is the way we conceive analysis integration.

The Integration Core purpose is twofold. It contains an easy and manageable representation of all the notations taken in input from the considered analysis approaches by means of a common language (XML). It allows the integration of the analysis in terms of the analysis results and the produced feedbacks at the software architecture level.

To reach this last aim we introduce the concept of semantic relations among the entities of the considered notations. Semantic relations are built every time it is possible to semantically relate the concepts in different notations. This means that, in general, there is not necessarily a relation between every pair of entities of two different notations; sometimes, those relations could not exist at all.

The semantic relation between two elements of two different notations strongly depends from the used approaches. This implies that the semantic relations are given by considering the approaches pairwise. We define the structure rules specifying the relations between concepts of the considered notations. Of course, when a particular software system is analyzed, these structure rules have to be instantiated on it. The rules instantiation is per- formed by a dedicated engine containing the needed logic to do so. We point out that an engine has to be built for each pair of approaches.

We devise an incremental approach to the framework implementation. The analysis approaches are considered pairwise, and for each pair we intend to introduce only the missing schemas and rules needed to integrate the approach into the framework. Therefore the Notation Schemas repository as well as the XML Rules may be extended every time two approaches have to be related.

To illustrate details on the Models and Rule Instances repositories, we use a simple example introduced in [20]. The application is made of two compo- nents: a Set and a Counter. If a User adds or removes an element to/from the Set (insert(e) and delete(e) respectively) the Set increments or decrements (inc and dec respectively) the number of stored elements into the Counter component. In the following, we refer to the Set-Counter architecture con- taining one User instance, one Set instance and one Counter instance ( 3 ).

It is also important to point out that many companies are developing mod- eling tools using the Eclipse framework. Notably UML modeling tools [23] are already available and can be readily used also in the context of our integra- tion framework. Moreover, the fact that development environments for Java and C++ have already been integrated with the Eclipse framework may be useful for bridging the gap between the models and code, for example by auto- matically generating skeleton code from the models stored in the integration core.

Our framework lays on an XML-based integration core, where software models and semantic relations between the models are represented. The aim is to provide a seamless integration of different analysis methodologies. To this regard we have sketched guidelines to allow embedding new methodolo- gies in our framework. We have also shown how such a framework can be implemented using the Eclipse platform.

Our main research direction obviously leads to embed new methodologies for analysis at architectural level in our framework. This task shall bring to enlarge the integration core in terms of software model representations as well as semantic relations. If future results in this direction will appear as promising as the ones obtained from this first setting, a long-term goal will be to extend the scope of the framework to other software lifecycle phases.

