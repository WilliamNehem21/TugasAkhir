which match the human reasoning style better than calculi developed for auto- mated reasoning (e.g. the resolution principle). However, because these calculi have been invented for proof-theoretic purposes there are still many problems inherent to interactive proof frameworks based on these calculi. Two particu- larly prominent problems with respect to interactive theorem proving are the presentation of proofs and the application of assertions

We use the recently developed CORE [2] system as a logical basis. CORE al- ready supports flexible reasoning at the assertion level in a contextual rewriting proof style. In this paper we develop a communication layer, the so called task layer, on top of the system. This layer exploits COREs strength in the appli- cation of assertions and provides an additional mechanism for the structuring of proofs. The task layer consists of a datastructure to reference subgoals, to- gether with a set of inference rules defined over this datastructure. In addition the layer provides a proof datastructure which represents the proof history.

We denote this representation as an indexed formula tree ( Ift) and observe that it represents a proof state in matrix calculi [21]. Thus, we can reuse the rules from these calculi to construct a matrix proof. In particular, it provides us with an efficient representation of variable dependencies.

In short, the CORE-calculus relies on proof states consisting of an Ift rep- resenting quantifier and substitution dependencies and a Fvift, which is a kind of working copy that is actively manipulated by replacement rule appli- cations. The calculus consist of 12 rules, including a cut rule, that transform a proof state into exactly one derived proof state. A proof state is proved if the Fvift is a propositionally trivially valid formula, such as, for instance, True+. The calculus is sound and complete for a variety of logics.

The framework provided by CORE so far is that the complete status of a proof is always represented as a single formula, which was one of the design goals. The system is augmented by the possibility to focus the reasoning pro- cess on arbitrary subformulas, without actually enforcing the decomposition of the formula, i.e. the Fvift. To this end we add the possibility to in- troduce windows on arbitrary subformulas, which are explicit representations of the focus. For instance in the example above, without windows the com- plete formula is visible, i.e. the focus of the reasoning process is on the entire

Note that we allow windows to occur below other windows. Windows below which there are no more windows are so-called active windows. The intuition of focusing is that the content of active windows are those objects that can be manipulated by rule applications. To this end the pure CORE-calculus is extended to Fvift with windows to obtain a reasoning mechanism similar to window inference [16].

Because of its strength in the application of assertions CORE is well suited for interactive proof construction. However, optimal support for focus and rule choice is still challenging. One challenge is related to rule choice since the context of a formula is currently available only as a usually long and un- structured list of replacement rules. To make things even worse, there are already dozens of replacement rules even for rather trivial problems. In par- ticular, the number of replacement rules that can be generated from a subtree

of a Fvift is exponential in the number of nodes in that tree. Although this is an effective sign of the flexibility in proof construction provided by CORE this flexibility must be controlled during automatic and semi-automatic proof construction. A further difficulty for automatic proof search is the choice of the focus. Because the focus of a proof can be changed arbitrarily it is hard to search for a proof in a systematic and goal directed way. In the following section we describe the task layer which supports the user in the structuring of the proof.

Fvifts as introduced in Sec. 2 represent all conjunctive and disjunctive sub- goals of a proof state simultaneously. However, while individual subgoals can be highlighted with the window inference mechanism the system does not support the user in systematically splitting the proof into smaller subgoals. Furthermore, a Fvift can grow significantly during a proof which makes the presentation of a proof state difficult.

It is therefore a challenge to present a proof state to the user as a set of subgoals (tasks) while maintaining the advantages that arise from the fact that a proof state is represented as a single formula. This is what is addressed by our task layer. At this layer, we use the window structure to reference parallel subgoals within an Fvift. These subgoals (tasks) structure the proof at the task layer where additional rules are provided to manipulate these subgoals. Reasoning steps at the task level are mapped into reasoning steps in the CORE system which automatically guarantees soundness.

To describe the task layer we proceed as follows. First, we give a formal definition of the task data structure. Then, we provide a set of implemented task manipulation rules. The inferences realized by these rules comprise simple decompositions of compound formulas, compound steps such as applications of assertions, and human-oriented steps such as lemma introduction.

Henceforth, when presenting tasks, we will not distinguish between a win- dow in the task and the formula it contains. For instance, instead of w1,... , wnD g in the definition above we will write Ax1,... , Axn D G. 6

Tasks describe goals that have to be achieved during a proof process. The current tasks are stored in a so-called agenda. The proof process starts with an agenda that contains only the initial task. We can refine a task on the agenda to simpler tasks by the application of task manipulation rules. The proof process terminates, when all tasks in the agenda are closed.

Task manipulation rules may vary from low-level, basic rules that perform simple logic manipulations, to complex rules and speculative rules. In the following, we shall give examples of three different kinds of task manipulation rules and their realization in CORE: (1) Simple rules to split tasks for a con- junctive goal into subtasks, or to decompose disjunctive goals (Sec. 3.2.1). (2) Complex rules to apply assertions via the replacement rules and rules, which provide a functionality similar to the Proof by Pointing approach (Sec. 3.2.2).

To apply replacement rules at the task layer we introduce the Apply-rule. The idea is that in order to apply an assertion (i.e. a formula in a support window) the user merely needs to select an assertion by clicking at it at the user interface. The system then creates a list of all replacement rules that are justified by this assertion. In case there is only a unique applicable rule it is applied automatically via the Apply-rule. In the more likely case that there is more then one rule applicable the user has to select the replacement rule that describes the appropriate application direction of the assertion. At this point heuristics will be used to narrow down the choice for the user.

The LemFW rule corresponds to the forward application of a lemma and replaces a goal formula G by another formula H. This then leads to the generation of an additional task which encodes the obligation to show that the proof step described by the replacement was actually valid. The related LemBW rule allows to insert a new lemma A into the supports of a task which can then be applied via the Apply rule.

In the Box-Line representation, a goal formula is presented below the avail- able assertions, which are displayed in a Box (see Sec. 4). We realize this presentation style in the user interface by presenting the support windows of a task on top of the goal window. This facilitates the application of assertions, which can be applied in a uniform way by making use of the Apply rule. The Box-Line presentation enables the user to apply an assertion by clicking on the corresponding support window. The replacement rules corresponding to the appropriate application direction of the assertion can then be applied with the help of the Apply rule.

rewriting steps on the content of the active window result in a local lemma that needs to be tackled afterwards. This also holds for the window inference approach of Robinson and Staples [16]. In the CORE system underlying the task layer introduced here transformations that are realized by application of replacement rules are guaranteed to be sound and hence do not introduce new subgoals.

We have introduced a task layer for the CORE system and described the impli- cations of this layer for interactive proof construction. We were able to point out how the task layer helps to structure and display CORE proofs. Further- more, by exploiting the contextual reasoning paradigm of the CORE system we were able to combine and extend existing concepts like the Proof by Pointing approach in a single interaction layer.

In this paper, we gave a bottom-up description of the task layer serving as interface to CORE. Such a bottom-up approach to enrich the logic layer by more abstract level reasoning tools is the standard approach in many proof assistants to support abstract level proof development. A drawback of the bottom-up approach, however, is that it usually causes an unnecessarily strong dependence of the abstract layer upon the logic layer. Therefore, we are actu- ally developing the task layer as independent as possible from the underlying logic layer, such that, in the ideal case, the logic layer becomes exchangeable. However, we do not propose proof assistants lacking a sound logical basis. Instead, our aim is to distinguish better between abstract level reasoning and expansion into verifiable proofs at the logic layer.

In this paper, we gave a bottom-up description of the task layer serving as interface layer to the user on top of CORE. Such a bottom-up approach to enrich the logic layer by more abstract level reasoning tools is the standard approach in many proof assistants to enable (ideally) abstract level proof development. A drawback of the bottom-up approach, however, is that it usually causes an unnecessarily strong dependence of the abstract layer upon the logic layer. Therefore, we are actually developing the task layer in a top-down approach to keep it as independent as possible from the underlying logic layer, such that, in the ideal case, the logic layer becomes exchangeable. However, we do not propose proof assistants lacking a sound logical basis. Instead, our aim is to distinguish better between abstract level reasoning and expansion into verifiable proofs at the logic layer.

J. Siekmann, D. Tsovaltzi, B. Quoc Vo, and M. Wolska. Discourse phenomena in tutorial dialogs on mathematical proofs. In In Proceedings of AI in Education (AIED 2003) Workshop on Tutorial Dialogue Systems: With a View Towards the Classroom, Sydney, Australia, 2003.

