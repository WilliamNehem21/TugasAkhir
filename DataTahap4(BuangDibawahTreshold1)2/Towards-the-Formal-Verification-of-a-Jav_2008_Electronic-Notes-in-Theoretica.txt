B. The processor is an (almost complete) implementation of a Java Virtual Machine in hardware. Thus, refinement-based verification of the Score processor begins with a formal specification of Java bytecode. Traditionally, B has been directed at the formal development of software systems. The use of B in hardware verification could provide a means of developing combined software/hardware systems, i.e. codesign.

The motivation for this paper is to demonstrate initial results from an on- going collaboration between AWE and Sandia to model and verify the Score processor using an established formal method. We choose the B Method, in particular the Event-B subset, for this purpose because it is a method with exceptional tool support which incorporates a dedicated refinement technique. We aim to prove that bytecodes are correctly implemented by microcode in- structions.

The next section gives an overview of the Event-B language and its notion of refinement. This is followed by a demonstration of our approach via an example analysis of the JVM instruction iadd . Our approach is then put into context with other formal approaches, after which we draw some conclusions. We also discuss how this work could fit in with another AWE-funded project to produce formally verified hardware. This would address the issue of proving correctness with respect to actual (clocked) hardware. It is hoped that the results presented here can be generalised to support the entire lifecycle of

An abstract Event-B specification [9] comprises a static part called the context, and a dynamic part called the machine. The machine has access to the con- text via a SEES relationship. This means that all sets, constants, and their properties defined in the context are visible to the machine. To model the dy- namic aspects, the machine contains a declaration of all of the state variables. The values of the variables are set up using the INITIALISATION clause, and values can be changed via the execution of events. Ultimately, we aim to prove properties of the specification, and these properties are made explicit using the INVARIANT clause in the machine. The tool support generates the proof obligations which must be discharged to verify that the invariant is maintained. It also has interactive and automated theorem proving capabili- ties with which to discharge the generated proof obligations.

details in favour of a more mathematical representation. Refinement is the means by which the artefacts of an implementation can be incorporated into a formal specification whilst maintaining the correct behaviour of the abstract specification. A demonstration of Event-B refinement will be given in the next section.

To illustrate our approach using Event-B, we present the arithmetic operation iadd which pops two numbers off the stack, adds them together, and then pushes the result on to the stack. This example presents the kind of analysis that would be undertaken for all arithmetic and logical bytecode operations because, in all cases, operands are popped off the stack and the result is pushed back onto the stack. In the interest of simplicity, we only consider the effect of the operation on the data path. For example, we do not model the program counter, nor do we consider how the instruction gets called. In addition, we assume the operands are put on the stack by other instructions that are not considered here.

In addition to Stack , we have defined two further sets: Bytecode and Status. At this stage, only one element of Bytecode is declared, namely iadd . Further elements can be added via context refinement when necessary. The set Status (and its two elements ACTIVE and INACTIVE ) is introduced as a conse- quence of Event-B refinement. We will see below why this set is necessary.

The variable iadd status is introduced in anticipation of refinement. This is also the reason for two events: iAddini activates the execution (but only when there are enough elements in the stack), and iAdd performs the nec- essary state update. One could imagine an event that would capture the behaviour of iadd in one step, i.e.:

without the need for a status variable. However, events with nontrivial guards and generalised substitutions such as this serve two purposes: the guard says what should hold at the beginning of an execution, and the generalised sub- stitution says what should hold at the end. A refinement that introduces new events would force us to choose between executing the existing event first (to exercise the guard at the appropriate place), or last (to position the gener- alised substitution appropriately). Since Event-B does not allow events to be split, we are forced to define (at least) two events: one with the nontrivial guard, and another with the generalised substitution. We will say more about this when we consider the refinement itself.

ing the iadd operation into 7 pseudo-microcoded instructions. This description ignores some features of the processor, but it still incorporates many of the actual implementation details. This compromise allows us to demonstrate the refinement technique involved. By proving this lower-level model is an Event-B refinement of the abstract model, we demonstrate that the low-level behaviour is faithful to the ISA specification of iadd . Although we only present one refinement here, the approach is similar for all bytecodes.

However, before we do this it is necessary to address a number of proof obliga- tions that arise in the refined model. These concern the guards of the events iAddini and iAdd. The theory underlying the B Method dictates that the guards of refined events must be at least as strong as the guards that they refine. In the case of iAddini, we have to prove:

The most substantial body of work in this area to date has been done by Panagiotis Manolios. His technique for modelling and verifying hardware motivated the investigation undertaken in this paper. The general purpose theorem proving system ACL2 [2] provides the mechanical support for his approach. Lisp is used as the modelling language, in which models of a simi- lar level of abstraction to our own are constructed. In particular, instruction set architecture (ISA) models and microarchitecture (MA) models are defined using Lisp primitives [7].

In this paper we have applied Event-B refinement to the verification of a Java processor. In particular, we have demonstrated a proof of an example bytecode with respect to its microcoded instruction implementation. We have chosen to use Event-B in this investigation because it has an off-the-shelf (and free) formal development tool with a dedicated refinement technique. Hence, our proposed approach has been tailored to make full use of the tool.

The Event-B tool is being developed with extensibility in mind. The de- cision to use Eclipse as an environment for the tool is based on its plug-in capability. For example, in addition to ProB, other tools such as a UML to B translator [11] are being built to interact directly with the Event-B tool. This

