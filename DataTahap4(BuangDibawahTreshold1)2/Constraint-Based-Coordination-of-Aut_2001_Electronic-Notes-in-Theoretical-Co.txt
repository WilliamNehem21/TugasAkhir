This paper presents an instrumentation of a constructionist bottom-up approach to coordination in multiagent systems. Coordination scenarios of autonomous agents are modelled and formalised as a contraint optimisation problem. A distributed asynchronous algorithm is presented that computes potential outcomes of coordi- nation in these scenarios. Finally, it is shown how this algorithm can be integrated into an operational coordination mechanism for a real-world domain.

In this context, the traditional design philosophy is reductionism [6]. It relies on a top-down decomposition of the global task, the assignment of sub- tasks to agents and coordination based on pre-established interaction patterns among benevolent agents. In these systems, agents have to account for interde- pendencies between their local behaviours in the light of control uncertainty: they have to find coherent sets of local behaviours despite incomplete and po- tentially inconsistent views of the overall problem-solving state. Coordination problems of these characteristics have often been formalised as distributed

However, reductionist approaches to coordination in multiagent problem solving systems often turn out to be too rigid for real-world applications [6]. Instead, a constructionist approach, based on the metaphor of societies of autonomous problem-solving agents, has become popular: agents are primar- ily interested in their local goals and interact to increase the degree of their attainment. In order that the system copes with the global task, a construc- tionist approach to coordination must be based on a mechanism that biases agent behaviour in a desired direction, i.e. somewhere between benevolence and self-interest. Elsewhere [7], we described the fundamentals of structural cooperation, an example of a coordination mechanism of this type.

In this paper, we present an algorithm for the instrumentation of struc- tural cooperation based on distributed constraint-based search and illustrate its application to a particular domain. Section 2 characterises the coordina- tion scenarios that we are interested in. In Section 3, we present a distributed constraint optimisation algorithm, that computes potential outcomes of coor- dination in these scenarios. In Section 4 we point to a real-world application of this coordination approach, before presenting our conclusions in Section 5.

We first provide a formal description of the type of multiagent domains that our coordination scenarios are based on: systems of cognitive agents that reactively develop short-term plans. Elsewhere [1], we have argued that such a stance is appropriate for a variety of real world scenarios, such as many decisions support domains. Section 2.2 gives a simplified example of one of the targeted domains.

Pareto-optimality assures that no option to improve (or at least: not to deteriorate) an agreement in the eyes of all agents is wasted. This is partic- ularly relevant for multiagent problem-solving systems, where we can assume that the local preference relations of the agents correlate positively with the desired global functionality of the system. Still, there are usually several Pareto-optimal multiplans. It is the particular coordination mechanism that establishes how to choose among them.

Once an agent updates its information models as a result of the choices implied by its agent program (see next section), relevant acquaintances are informed through messages. If an agent updates its own current individual plan (or: its own authority level), value (or: authority) messages are sent to all agents that it shares some constraints with. In case that a nogood has been detected, all agents that may be involved in it will receive nogood messages. Solution messages are targeted to all agents.

The above algorithm has been designed to compute potential outcomes of coordination in decentralised multiagent problem-solving systems. This type of systems is usually applied to domains that show an a priori distribution: the subdivision of the problem-solving system into different agents and the corresponding agent processes is rather the result of a given problem structure (spatial distribution, access restrictions etc. [7]), than a means to attack computational complexity issues. Upon this background, in this section we analyse some of the properties of the aforementioned algorithm.

The different agent processes perform parallel, asynchronous computation: nogood messages only imply the reaction of one agent (the one with the lowest authority level in the nogood), but messages informing about value changes cause simultaneous activity. The communication load is limited by selective addressing. Note that when acquaintances are informed about new nogoods, it would suffice to direct the corresponding messages just to the lowest au- thority agent involved in the nogood. Still, authority levels are changing and our policy of routing nogood messages anticipates potential future communi- cation. Furthermore, the search space is pruned on the basis of nogoods, as all multiplans that comprise a nogood are not explored.

In this section we outline how the above algorithm can be applied to a real- world problem. It is part of the instrumentation of the coordination mech- anism called structural cooperation, which as been used in the TRYSA2 proto- type (TRYS Autonomous Agents) for urban traffic management [7][4]. TRYSA2 consists of 11 autonomous knowledge-based traffic control agents, that jointly manage a road network consisting of one ring-road and seven adjacent mo- torways, provided with over 300 loop detectors, 52 Variable Message Signals (VMS), 3 traffic lights for junction control, as well as ramp metering on 7 ring-road drives.

We plan to evaluate the mechanism of structural cooperation, as well as the algorithm that instruments it, in other domains. We are particularly interested in a comparison to centralised solutions, as realised in [5] for the traffic domain. In addition we are working towards a tighter integration of the Stages 1 and 2 of our coordination algorithm in order to improve its computational complexity.

