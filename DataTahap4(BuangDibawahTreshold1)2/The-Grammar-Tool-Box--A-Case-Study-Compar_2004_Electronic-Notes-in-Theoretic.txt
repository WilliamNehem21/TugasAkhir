In the last decade the computing community has shown an increasing interest in parsing techniques that go beyond the standard approaches. There are a plethora of parser generators that extend both top-down and bottom-up approaches with backtracking and lookahead constructs. As we have noted elsewhere [11] such parsers can display surprising pathologies: in particular parser generators such as PRECC [3], PCCTS [19], ANTLR and JAVACC are really matching strings against ordered grammars in which the rule ordering is significant, and it can be hard to specify exactly what language is matched by such a parser. In any case, backtracking yields exponential parse times in worst case.

haviour but on modern hardware this need not preclude their use. Several Eiffel compilers use Earley parsers to support their relaxed use of expres- sion separators. Tools such as ASF+SDF [27] stress generality and can parse ambiguous languages with support for shared packed parse forests which effi- ciently encode all possible derivations along with sophisticated techniques for disambiguating the forest. ASF+SDF uses GLR parsing to accomplish this: as a final indicator that general techniques are entering the mainstream con- sider that even GNU Bison had recently acquired a GLR mode, although the implementation is perhaps not yet industrial strength.

specified as a detailed chain of operations on grammars and automata. Our goal is to open up the degrees of freedom in translator implementation in a structured way so that reproducible experiments can be mounted between competing techniques. Naturally, a pre-written GTB script may be used to get the effect of a conventional parser generator like YACC or RDP so GTB can replace those kinds of tools in a production environment.

GTB can handle multiple grammars simultaneously, and extract multiple grammars from a rule set by using different start symbols (a facility which is useful for some techniques that segment grammars, such as the Aycock and Horspool trie-based automaton [1]). The built-in function grammar constructs a grammar object from a particular start rule and as a side effect calculates first and follow sets. Grammar augmentation is automatically applied, if nec- essary. The following is an extract of the text generated by running GTB with the example script given above.

The generate function uses breadth first search to output either sentential forms or sentences of the grammar. We can specify leftmost, rightmost or random selection of the nonterminal in a sentential form for expansion. Of course, most interesting languages are infinite, so we can specify an upper bound on the number of outputs. The parameter of zero in the above example specifies no upper bound, so all sentential forms will be generated.

Pascal and C typify the top down and bottom up schools of language design. In the folklore at least, Pascal is thought of as being designed for LL(1) pars- ing and C for LALR parsing. In practice, Pascal is indeed reasonably close to LL(1) notwithstanding the if-then-else ambiguity and the need for lexical backtracking to distinguish between a real literal (2.3) and an integer range

For these experiments we have used the grammar for ISO-7185 Pascal extracted from the standard, the grammar for ANSI-C extracted from [14] and a grammar for IBM VS-Cobol developed in Amsterdam. The original extraction of this grammar is described at length in [16] and some interest- ing work on techniques to generate tolerant variants is described in [15]. A version of the grammar is available as a hyperlinked browsable HTML file at http://www.cs.vu.nl/grammarware/browsable/vs-cobol-ii/: we used a version prepared for ASF+SDF from which we extracted the context free rules.

The IBM VS-COBOL grammar is salutary. Our first attempt expanded all closures by creating a new left-recursive nonterminal for each closure. GTB ran out of memory when trying to create an LR(1) NFA for this grammar. Simple back substitution for head and tail recursive rules generated an NFA

We use a separate tool ebnf2bnf to perform these conversions which takes as input an (E)BNF grammar annotated with expansion operators and out- puts an (E)BNF grammar. The tool constructs a rules tree from the original grammar and then performs tree transformations under the control of the an- notations, before writing the grammar back out. An ambitious environment that supports this kind of operation has been prototyped in ASF+SDF [17]: the authors describe EBNF to BNF conversion as Yacc-ification. Our tool emphasises ease-of-use and traceability of the basic operations.

