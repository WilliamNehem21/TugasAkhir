For many software analysis tasks, however, the functional approach is too restrictive. First, specifications are often non-deterministic, thus allow one-to- many associations of elements. Determinism of programs is usually established in a refinement process. Non-determinism is even an essential feature of con- current or reactive systems. Second, functions are not entirely satisfactory for modeling the semantics of predicate transformers or of analysis formalisms like dynamic or temporal logics or the mu-calculus. It is therefore desirable to generalize from functions to relations. In fact, relations form the backbone of formal methods like B [3] or Z [18] in software development. But how to visualize relational reasoning?

The strength of our approach, however, consists not solely in the visualiza- tion of algebraic axioms by a sound and complete diagrammatic calculus, but also in intuitive and powerful derived rules for transforming and (de)composing diagrams, while preserving some interesting properties. We introduce rules that capture the typical informal diagrammatic style of rewriting theory. Our considerations in the general setting of semi-commutation, however, increases their domain of applicability to relational software development with methods like B or Z. The idea of transferring diagrammatic techniques from rewriting to software engineering is probably novel. Several examples from rewriting theory and concurrency control support the usefulnes of this approach.

The general merits of relational diagram chase in rewriting are beyond any doubt: it is the standard way of reasoning in this area. Diagrams show the essence of proofs while hiding boring technical details. Proofs by diagrams are informally rigorous in contrast to the formally rigorous proofs from logic or algebra. Our examples show that the present approach unifies both kinds

of rigor in one simple and convenient formalism. In a corresponding formal method, a proof engineer might first sketch a proof using diagrams and then incrementally refine it using our derived rules. The underlying algebraic se- mantics paves the way to a simple mechanized verification of the diagrammatic arguments. The approach is open in the sense that further diagram rules can easily be defined and verified by the user.

In this paper we try to informally motivate the main ideas behind our diagrammatic calculus and to illustrate them by examples. Theoretical re- sults about Kleene algebras and related theories can be found in the litera- ture [14,6,9]. An implementation of the calculus and an integration into a formal method is left for future work.

The remainder of this text is organized as follows: Section 2 shows how rewriting diagrams can be used for modeling meaningful properties of con- current systems and processes. Section 3 proposes an algebraic semantics for semi-commuting relational diagrams. Section 4 presents transformation and preservation laws for diagrams. Sections 5 and 6 introduce diagrammatic in- duction techniques and examples. Section 7 gives diagrams and techniques for coinduction. Section 8 and 9 further discuss the results, draw a conclusion and suggests some future work.

This turns the labeling algebra into a monoid with unit 1 and element 0 that satisfies the annihilation laws 0a =0 = a0. Some applications suggest to drop a0 = 0. When a is always non-terminating, one might want that ab = a for all b and in particular for b = 0; a conflict. See [21] for a deeper discussion.

The second rule can be obtained by exchanging solid and dashed lines. Using these rules and the splitting rule, we can derive another rule for commuting diagrams that has the same shape and in which all lines are solid. There are further derived diagram rules for combinations of commuting and semi- commuting diagrams that can be derived from the fundamental rules using the splitting rule. For the sake of brevity we present them using path expressions.

Our fourth set of derived diagram rules deals with the composition of diagrams. Again, these rules are based on isotonicity of multiplication, but now contexts are used in both antecedents. Again, there are two fundamental composition rules for semi-commuting diagrams. The first one is

The second rule can again be obtained by replacing solid and dashed lines. A corresponding rule for commuting diagrams follows immediately from those for semi-commutation and the splitting rule. Further derived rules handle again the combination of commutation and semi-commutation. They are

Our derived transformation and composition rules formalize the essence of diagram chase in rewriting theory, but generalized to the setting of semi- commutation and with an underlying abstract algebraic semantics. Diagram chase is usually far more convenient for a human than performing the de- tailed underlying algebraic manipulations (except for sectarians of idempo- tent semirings). The simple formal semantics of the present approach yields a coincidence of these opposites.

The last step in the chain of implications (and the first step in our backwards proof) uses the star induction law as a star elimination rule. The remaining step is by denesting and yields two new goals. The first goal follows im- mediately from the star unfold diagram and denesting. The second goal is one of our previous regular diagrams, which we do not analyze any further. The underlying proof in Kleene algebra can easily be recovered. The entire goal could as well be handled effectively by the decision procedure for regular expressions.

Therefore, at the present stage, the main task is the design and imple- mentation of a graphical front-end that allows the explicit manipulation of diagrams, supports user-defined transformation rules and enhances a transi- tion between algebraic and diagrammatic reasoning. A main question is proof presentation. At first sight, its seems most natural to modify diagrams succes- sively on the screen by applying transformation rules in a drag an drop style. The concrete realization of such a tool is left open.

We envision the following further work. First, our techniques should be integrated into a graphical interface that allows drag and drop diagram chase in combination with algebraic calculations. This interface should then be in- cluded into a formal method by implementing the semantics of diagrams. This novel integration of rewriting-style diagram techniques into software engineer- ing methods like B or Z might contribute to increase their comfort. Second, other variants of Kleene algebras, for instance refinement algebras [21], lazy Kleene algebras [16] and typed Kleene algebras should be considered as a se-

