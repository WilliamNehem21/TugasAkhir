Given two logical formulas A and B, a formula P is an interpolant of the pair (A, B) if P is implied by A, P implies B and P contains only symbols common to A and B. The idea of interpolant was defined by Craig in 1957 [1]. Basically, an interpolant defines an interface through which A and B interact, using only information that is shared between the two formulas. Recently, McMillan has shown that interpolants can be useful for verification, for finding inductive invariants, and for predicate abstraction [3,4,5].

This inference system only involves single constraints. In later sections, we will show how to use this inference system to determine interpolants. At that point, we will need to extend this inference system using triples instead of single constraints. We are assuming that all our constraints are simplified. After each inference,

We will try to give more motivation for the use of the substitution. The reason for the substitution is in order to share structure between c and i. The effect of our inference rules will be that inferences involving A will take place in a substitution, thereby allowing those inferences to involve i in addition to c. However, inferences involving B will not take place inside a substitution, thus we will force the inference to involve c but not i. This will ensure that, as much as possible, inferences involving A are recorded in i but not inferences involving B. Therefore, we will keep a trace of the A-inferences performed. This allows the interpolant to be formed the same way as the inferences were executed. We believe this is the interpolant which is often needed in practice. There are infinitely many interpolants for any given unsatisfiable

Note that in constraints from A, we use new the substitution variable V to share everything of c in the substitution part i, because we want to record all the actions involving A in the interpolant. However, in constraints from B, we also use V to share c with i but we relate that to an original copy of the constraint which will not be modified by the inferences. This allows us to record the actions that occur on that constraint, not the actions using that constraint.

As we stated in the previous section, we have to simplify each newly generated constraint after applying an inference rule. Given an expression or a constraint, it is well-known how to simplify it. But after an inference rule, the substitution part might not be simplified anymore, because the coefficient of the largest term may not be positive one. Here we give an inference rule called Simplify Rule to simplify the substitution part of a constraint. This will be performed eagerly when each new constraint is generated.

The next rule we will define is the Combination rule, which applies when there is a Rewriting Rule but the Triple-Rewriting Rule defined above is not applicable. This Combination rule will involve applying the substitution before the inference and then reconstructing it after the inference. So we define the following two rules, which will be used in the Combination Rule. The first is Back Substitution:

We plan on many directions for future work. We are currently extending our ideas, with the hope to give a complete method for linear constraints over integers with uninterpreted function symbols. We would also like to extend our framework to other theories. We are planning an implementation. Finally, we would like a better understanding of how our methods fits into invariant generation, predicate abstraction, and other uses of interpolants

