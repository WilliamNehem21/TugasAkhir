A reversible programming language supports deterministic forward and backward computation. This tuto- rial focuses on a high-level reversible programming language Janus. In common with other programming paradigms, reversible programming has its own programming methodology. Janus is simple, yet powerful, and its constructs can serve as a model for designing reversible languages in general.

Conventional computing models such as Turing machines and random access ma- chines (RAMs) destroy information at each computational step. The symbol written on the tape in the previous state will be overwritten by the new symbol, and the value written on the registers will be updated into the new one. At the first sight, we tend to think the destruction of information is necessary to computation. How- ever, it was shown by Landauer that any irreversible computation can be simulated by reversible computation by adding the extra storage to remember the history of computation [16]. Moreover, this garbage information can be erased by its inverse computation [2]. Thus, in theory we can simulate any irreversible computation with reversible computation provided that a given storage is infinite.

To provide a flavor of reversible programming, we show a Janus procedure for com- puting Fibonacci pairs. Given an integer n, the procedure fib computes the (n+1)-th and (n+2)-th Fibonacci number. For example, the Fibonacci pair for n =4 is (5, 8). Returning a pair of Fibonacci numbers makes the otherwise non-injective Fibonacci function injective. Variables n, x1, x2 are initially set to zero. Parameter passing is pass-by-reference.

A reversible assignment updates an integer variable or an array element. The vari- able x on the left-hand side of an assignment must not appear in the expression e on the right-hand side. Similarly, array variable x must not appear in the expression e on either side of the assignment. This, together with the reversible modify operator

procedure body in the local store of formal parameter variables. A procedure un- call invokes inverse computation of the procedure. All parameters are passed by reference. As usual, the number of parameters in a call must correspond to the number designated in the procedure declaration and the types of the actual param- eters should meet those of the formal parameters. The actual parameters must be variable names in the scope of the procedure invocation. To avoid problems with aliasing, we prohibit passing the same reference to more than a single parameter.

This is an important mechanism of reversible languages, and capturing the con- cept by switching input and output store for inverse constructs is a promising se- mantics technique. We use the same technique in defining a pop as the inverse of a push (cf. rules Push and Pop).

Each programming paradigm has its own methodology. Reversible programming also has its own techniques [30,32]. For example, Janus can implement Janus in- terpreter and the tower of this reversible self-interpreter constitutes non-standard hierarchy. Any level of self-interpreters can be both inverted and uncalled. A re- versible self-interpreter for the original Janus and a tower of reversible interpreters were reported in [32].

Several introductory articles and surveys on reversible computing have been pub- lished (e.g., [13,24,9,20,3]). The concept of reversibility has been studied by using various computation models, including reversible Turing machines [2,21], reversible cellular automata [20], reversible flowchart [31], reversible combinatory logic [6], reversible process calculi [25], reversible Boolean logic circuits [10,5], and reversible finite automata [26].

One of closely related concept to reversible programming languages is program inversion [11]. Generalized program inversion generates a semi-inversed program, in the sense that given some of the original inputs and outputs it returns the remaining inputs and outputs [23,19]. Bidirectional languages, which also have the concept of forward and backward semantics, are desined for the view updating problem [7,22].

