System on Chip (SoC) designs are fast moving towards a development environment that incorporates third party Intellectual Property (IP) cores and blocks. Due to the use of such heterogeneous IP cores, multiple communication protocols are re- quired to achieve the desired interactions, behavior, and functionality. With this diverse development environment comes not only the burden of verifying the system under development, but also the third party modules and communication protocols, to ensure the correctness and compliance of the complete system with respect to the system specification. This need is especially important for vendors looking to market and promote their products in new markets and development environments. To reduce the verification costs and redundancy of verification (verified twice: once

The paper is organized as follows. Section 2 presents an overview of related work in the field of LSCs and verification using LSCs. Section 3 gives an overview of the LSC constructs and provides an example of an LSC that is explained in detail. Section 4 presents an overview and examples of the LSC to automaton translation method. Section 5 discusses the case study and presents results of verifying Promela models against the BVCI LSC specification followed by conclusions in Section 6.

LSCs have been used to model and specify a variety of systems such as air traffic control systems [3], radio based communication systems [6], and train systems [2]. Their use in these case studies has shown their effectiveness in specifying and ver- ifying complex behaviors of a system. LSCs and PLSCs have also been used in the past to specify SoC communication protocols and formally verify aspects of the protocol on the system [5]. Additionally, they have also been used for automatic synthesis of systems as well [7].

Another aspect of LSC based verification deals with the verification of systems against the LSC specifications. Two primary methods have been proposed to per- form verification of systems against LSCs. The first deals with temporal logic. One approach converts the LSC specification to multiple small temporal logic properties that are verified on the system [5]. These individual properties are easily verified on a system but are insufficient to establish a formal relationship between the specifi- cation and implementation itself. Other approaches translate the complete chart to temporal logic, which is then used as the specification input to a model checker such as SPIN or NuSMV [13,11]. The primary limitation of these approaches is the expo- nential explosion encountered in the generated temporal logic formula (number of nested temporal operators), which severely reduces the scalability of the approach.

The second method for verifying systems against LSCs does so by converting the LSC to an automaton and using the automaton in language containment based verification techniques [12]. This method supports a greater subset of the LSC grammar and scales to much larger specification sizes. Although the verification re- sults and performance using the automaton approach for verifying systems are very promising, the research does not deal with constructs such as subcharts, hierarchi- cal charts, and Kleene stars, which are essential to the specification and verification of SoC interface and communication protocols. The work presented in this paper innovates upon previous work by extending the translation of LSCs to the complete grammar of LSCs.

Locations: The life-line of each process is marked with locations that are points where events and other constructs may be described. Locations are unique to each process and start at location L1. For each new event or construct placed on the process life-line, the location number is incremented for the respective process. For example, the address message is sent from the Initiator process at L3 and Target evaluates the cmdack == 0 post condition at L17.

Messages: Messages are a form of communication between processes in the LSC. Each message has a sender and receiver process attached to it. Messages are annotated with a message label that identifies the message. Messages can be simultaneous or asynchronous. Simultaneous messages are drawn with a solid arrow head and occur instantaneously when both the sender and receiver are ready for the communication. Asynchronous messages are drawn with an open arrow head and can be received any time after sending (we force the send event to occur before the receive event). In the example LSC, the address message is an asynchronous message and the cmdackHigh message is a synchronous message.

Conditions: Conditions are placed in the chart by drawing hexagons around the life-lines of processes evaluating the condition. The condition label describes a predicate that must be satisfied at the current location(s) of the process(es). Condi- tions spanning multiple process life-lines act as synchronizing points for the involved processes and the condition is not evaluated unless all the processes are at the re- spective condition locations. Conditions attached to a message are called bonded conditions. Conditions placed on their own location and not attached to a message in the chart are called non-bonded conditions [10]. Non-bonded conditions are eval- uated continuously until they are satisfied. In our example LSC, all conditions (the cmdack == 0 precondition and the cmdack == 0 postcondition) are non-bonded. Invariants are conditions spanning over multiple locations in the chart.

Coregions: Coregions are drawn with a dashed vertical line parallel to the life- line of a process and are used to describe behavior that can occur in any order. All messages in the dashed vertical line (address, be, clen, etc.) next to the Initiator and Target processes are in a coregion.

Additionally, we incorporate the delayed choice semantics when dealing with subcharts, hierarchical charts, and cold constructs. The delayed choice semantics allow the chart to resolve a choice by waiting for relevant input before commit- ting to a certain path in the LSC. Since we are using the chart as a specification language rather than a modeling language, delayed choice semantics help avoid non-determinism (reduce false positives). If the LSC were to be used as a model rather than a specification, delayed choice semantics would be removed to allow non-determinism in the model.

Our verification approach uses LSCs as the specification and verifies the system by detecting accepting cycles on the synchronous composition of the system automaton and the negative automaton of the LSC. The negative automaton of the LSC is the automaton that enables detection of unwanted behaviors in the system (using accept cycles recognized by the LSC automaton). The automaton is similar in nature to the never claim used in SPIN and has been shown to be an effective method of using LSCs for verification [12]. We first present an overview of the LSC to automaton translation for basic constructs as discussed in [12] and then present the translation for extended constructs that have not been explored in previous work: the Kleene star operator, subcharts, and hierarchical charts. To conserve space, we restrict our discussion to universal main charts only.

From a given cut, enabled transitions lead to successor cuts. The enabled tran- sitions correspond to the set of events that can occur from a given cut without violating the partial order induced on the events by the instances in the chart. Each unique cut of the LSC corresponds to a unique state in the automaton. The unwinding algorithm as presented in [10] provides a method to unroll the LSC and

all possible cuts of the LSC; thus, it gives the basic structure of the LSC automaton. This basic structure of the automaton is then transformed to a negative automaton using the transformation algorithm presented in [12]. It should be noted that the unwinding algorithm presented in [10] does not support Kleene stars, subcharts, and hierarchical charts. Additionally, the basic structure generated from the LSC is not as efficient as the transformed automaton presented in [12].

The general structure of the LSC automaton can be split into two parts: the prechart automaton and the main chart automaton. Additionally, a special state in the automaton is the safety state, qs: an accepting state that contains only one outgoing transition to itself labeled with true. The prechart automaton contains only non-accepting states since the prechart is responsible for the detection of the activation condition of the main chart. Additionally, the prechart states do not contain transitions to the safety state since the prechart does not detect errors or incorrect behavior. The first state of the prechart contains a special outgoing transition to itself that is labeled true to ensure that all possible instances of the charts in the system are checked for errors (corresponds to globally).

Kleene stars can be placed on messages or subcharts to indicate repetition. When a Kleene star is placed on a construct (message or subchart), the construct may be observed in the system zero or more times (finite). We first show how Kleene stars attached to messages are translated to automaton and discuss the translation of subcharts with Kleene stars in Section 4.2.

The dashed transitions in the automaton are introduced to incorporate delayed choice semantics. Such dashed transitions are introduced from every possible legal exit (last state and states corresponding to cold constructs) of a subchart to the entry points of other subcharts or higher scopes. For example, if at a legal exit of subchart A, the letter y is observed, progress is made by exiting chart A and entering chart B. Similarly, from a legal exit of chart A, progress can be made to the beginning of chart C by observing a z. The dash-dot transitions from the legal exits of B to the beginning of B are introduced to incorporate delayed choice for

A. Additionally, the dashed transitions from A to B and A to C are introduced to handle cold constructs. A similar set of transitions is introduced from C to A for cold constructs in C. These transitions can only be introduced to the successor charts of a given chart. For example, such transitions are not introduced from chart B to chart A or C since B has no successors. In the presence of multiple messages at the end of a chart, the translation is always guaranteed to have a final state, which is used as the starting point for joining successor charts.

It should be noted that in accordance with delayed choice semantics the minimal common prefix is chosen to identify the next chart that is to be executed (one message in the example, but could be more than one when complex precharts are specified). In the case of complex precharts (more than one message/condition), each legal exit of a chart leads to a new instance of prechart detection where it is possible to detect progress in the prechart of a successor chart or in the current chart itself (by observing the cold construct). For multiple successor charts, multiple prechart detections are introduced from each legal exit of a chart.

The Basic Virtual Component Interface (BVCI) protocol is part of the Virtual Component Interface (VCI) standards family that was developed to specify point to point communication protocols. We use the BVCI protocol as our specification for case analysis because of the complex nature of the specification as well as the past research that has been performed on verifying systems against the BVCI protocol [5]. We now describe our modeling and verification approach, and present results of verifying our models against the LSC specification.

We have shown how additional constructs of LSCs such as subcharts, Kleene stars, and hierarchical charts can be translated to a negative automaton. We have also presented a case study of using our translation technique to create an automaton from the BVCI protocol and perform verification of Promela models against the resulting specification, which has not been done before. Our results and experiences indicate that using the LSC language as a specification language is extremely useful for writing and developing specifications that can be used during formal verification. Additionally, their use as a modeling language further strengthens their applicability in the initial stages of the protocol development process.

Bontemps, Y., P. Heymans and H. Kugler, Applying LSCs to the specification of an air traffic control system, Proc. of the 2nd Int. Workshop on Scenarios and State Machines: Models, Algorithms and Tools (SCESM03), at the 25th Int. Conf. on Software Engineering (ICSE03), Portland, OR, USA (2003).

