We propose a benchmark to compare theorem-proving systems on their ability to express proofs of compiler correctness. In contrast to the first POPLmark, we emphasize the connection of proofs to compiler imple- mentations, and we point out that much can be done without binders or alpha-conversion. We propose specific criteria for evaluating the utility of mechanized metatheory systems; we have constructed solutions in both Coq and Twelf metatheory, and we draw conclusions about those two systems in particular.

A type system. We will assign to each live variable at each program point a list type. To guarantee safety of certain operations, we provide refinements of the list type for nonempty lists and for empty lists. In particular, the fetch-field operations demand that their list argument has nonempty list type, and the branch-if-nil

Sample program. The following list-machine program has three basic blocks. Variable v0 is initialized to nil as prescribed by the operational semantics. Block 0 initializes v1 to the list cons(nil, cons(nil, nil)) and jumps to block 1. Block 1 is a loop that, while v1 is not nil, fetches the tail of v1 and continues. The last instruction of block 1 is actually dead code (never reached). Block 2 is the loop exit, and halts.

In LF, one can compute as well on the derivation trees themselves. Suppose we write another Prolog program (set of clauses) that takes as input a derivation tree for type-checking, and produces as output a derivation tree for safe (non-stuck) execution. If this program is total (that is, terminates successfully on any input) then we have constructively proved that any well typed program is safe.

To reason about this meta-program, we use (machine-checked) %mode declara- tions to explain what are the inputs and outputs of the derivation transformer. We also use (machine-checked) %total declarations to ensure that our meta-program has covered all the cases that may arise, and that our meta-program does not infinite-loop. We give an example of such a proof in section 6, items 6 and 7.

Operational semantics. Both Twelf and Coq make it easy and natural to represent inductive definitions of the kind found in SOS. In Coq one also has the choice of representing operations over mappings (e.g., lookup and update in stores) either as relations (defined by inductive predicates) or as functions (defined by recursion and pattern-matching).

Derive an example of type-checking. Trivial to do in Twelf, by running the type system as a logic program. Not directly possible in Coq because the specification of the type system is not algorithmic: it uses universal quantification over all variables to specify environment subtyping.

%mode lub-subtype-left +P1 -P2. The modes of a logic program specify which arguments are to be considered inputs (+) and which are outputs (-). For- mally, given any ground term (i.e., containing no logic variables) P1 whose type is lub T1 T2 T3, our clauses (if they terminate) must produce outputs P2 of type subtype T1 T3 that are also ground terms.

%total P1 (lub-subtype-left P1 P2). We ask the metatheorem to check our claim that no execution of lub-subtype-left can infinite-loop: it must either fail or produce a derivation of subtype T1 T3; and we check the claim that the execution never fails (that all cases are covered). The use of P1 in two places in our %total declaration is (in some sense) mixing the thing to be proved with part of the proof: we indicate that the induction should be done over argument 1 of lub-subtype-left, not argument 2.

State soundness theorem for the type system. In Coq, the statement is just ordinary mathematics. In Twelf, this is done, as above, by writing a logical predicate that relates a derivation of type-checking to a derivation of runs-or-halts, and then making the appropriate %mode and %total claims for the Twelf system to check.

In Coq, the type-checker is defined as a function from program typing and programs to booleans. Our solution uses intermediate functions for checking envi- ronment subtyping and for type-checking instructions and blocks. These functions return option types to signal typing errors, which are propagated in a monadic style. To avoid an n2 algorithm, we represent environments and program typing as finite maps implemented by radix-2 search trees. Therefore, the typing algorithm has O(n log n) complexity.

Industrial-strength type-checker. Coq has a facility to automatically generate Caml programs from functions expressed in Coq. Automatic extraction of Caml code from the Coq functional specification of the type-checker produces code that is close to what a Caml programmer would write by hand if confined to the purely functional subset of the language.

