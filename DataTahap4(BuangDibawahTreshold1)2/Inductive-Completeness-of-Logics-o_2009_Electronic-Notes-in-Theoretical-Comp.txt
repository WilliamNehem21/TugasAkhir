The denotational semantics of a regular program can be construed as a relation, easily definable by structural induction on programs. Invoking the framework of canonical theories for (iterated) inductive definitions, we consider the first-order theory for program semantic, i.e. with the generative clauses as construction (introduction) rules, and their dual templates as deconstruction (elimination) rules.

Since this approach is strictly first-order, it is particularly accessible conceptu- ally, expositorily, and for use of automated theorem proving tools. It also meshes generically with the long-standing tradition of defining program semantics induc- tively. As soon as an inductive definition is given for a programming language, we automatically obtain the corresponding first-order inductive-definition theory, and can tackle the question of completeness of a logic for that theory.

To focus on the essentials, we consider guarded iterative programs, i.e. regular pro- grams with tests and assignments as atomic actions. This provides a clean separa- tion between the basic programming concepts. The language is generic with respect to an underlying vocabulary V , consisting of a finite set of constant-, function- and relation-identifiers, assigned positive arities when appropriate.

Generic methods for associating to a given collection of inductive (i.e. generative) definitions first-order inductive theories are well-known. The semantics of regular programs has a particularly simple form of inductive definition, using atomic pro- duction rules, i.e. natural-deduction inferences with atomic premises and conclusion, as follows.

We write Indn(Reg) for the inductive theory given by the universal closure of the formulas above. We omit the superscript n as well as Reg when in no danger of confusion. Two weaker theories are of interest. The Elementary inductive-theory, Ind0 has inductive-elimination restricted to first-order eigen-formulas. The Gen- erative Theory Gen is weaker yet, and has only the inductive-introduction rules, without inductive-elimination. Thus Gen is an inherently first-order theory, in that it does not have templates intended to approximate a second-order rule.

A point of interest is that first-order proofs of T + Ind0 obtained in the proof of Theorem 2.1 do not use the generative (data introduction) rules of the inductive theory Ind. A dual observation holds for total correctness assertions (Theorem 3.1).

Relative completeness throws in the towel not only regarding structures that are not expressive (and for which inductive completeness is unproblematic), but also for programming languages whose termination problem for finite structures is not decidable. In contrast, giving inductive definitions to the semantics of such programs is straightforward, albeit calling for auxiliary constructs (e.g. stacks). The

is more subtle. As manifested in [10], different forms of computational formulas correspond to different program constructs, and the second-order framework does not provide a silver bullet that applies to all constructs. The inductive framework studies here is therefore more appealing and generic: the programming construct in had guides directly the inductive definition, and once it does the match with a program logic is obtained.

