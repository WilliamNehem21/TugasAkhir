Informal design notations (eg ball-and-stick type diagrams) despite their easy understandability have limited utility when one needs to mathematically an- alyze designs. Design formalisms are needed in order to specify properties the designed system should satisfy as well as verify these properties on the de- signs. In addition, formal models of distributed systems may be simulated and implementation code generated from these simulate-able models. Middleware- based systems are ideal candidates for pre-implementation modeling because such highly concurrent distributed systems may hide subtle bugs that may not be captured by informal analysis.

One of the main features of middleware-based systems is that they usu- ally are highly communication-intensive distributed systems supporting a wide variety of application synchronization mechanisms. Classical architecture de- scription languages (ADLs) usually support one basic form of interaction and thus cannot naturally express the rich communication disciplines of middle- ware. Architectural Interaction Diagrams [16] (AIDs), however, provide a pa- rameterized mechanism that naturally supports a wide variety of interprocess- communication and synchronization primitives as language-supported con- structs. This frees the designer from having to simulate different IPCs by- hand: something he would have to do if she with traditional ADLs [2,5,15]. This leads to cleaner models, as there is no clutter due to communication code. Another benefit is that AIDs models have smaller state spaces, as each com- munication is now a single transition, as opposed to the multiple transitions needed when communication schemes are encoded using others.

In this paper, we illustrate the utility of our AIDs formalism with a study of the Event Heap Coordination Framework used by applications to coordinate themselves inside the i-Room [9], an experimental ubiquitous computing en- vironment at Stanford University. We demonstrate how a model of the Event Heap may be rendered using our approach and why it is more efficient than conventional modeling techniques. In order to do this, we extend our work in [16] by introducing a remote procedure call transition into the syntax of the language. As middleware systems typically include event-handling func- tionality similar to that of the Event Heap, in studying the Event Heap, we make a case for the application of our formalism to the problem of modeling different kinds of middleware systems.

A distributed system may be looked upon as a collection of multiple agents or processes interacting continuously with each other. For a formal model of distributed systems, one needs to define a) a base formalism for representing agents, b) a notion of concurrency, d) a semantics for inter-agent communica- tion and d) a concept of hierarchy. In this paper, we are concerned only with finite-state systems.

of the language. What we want however is to have a more general mecha- nism by which it would be possible for the user to define her own systems of communication and this newly created communication discipline can then be plugged seamlessly into the native semantics of the language. Buses are the means by which this goal is achieved.

The IROS, or i-Room OS, provides a rich set of facilities to applications built on top of it to share data and control. The sharing and coordination of data between applications is done through the Event Heap component of the IROS. The principal aims of the Event Heap is to make applications, that were not apriori designed to work together, interoperate in a dynamic, heterogeneous, ubiquitous environment.

Thus the Event Heap provides for anonymous communication as there is no need to explicitly rendezvous applications. As long as two applications understand the same event types they will automatically coordinate with each other. The indirect interaction mechanism of Event Heap discourages strong dependency coupling among applications leading to better interoperability and fault tolerance.

Our main aim is to define the Event Heap as a bus. As mentioned before, a bus is the abstraction of communication in AIDs. If we are able to define a bus for Event Heap we can then use this Event Heap bus as a primitive, then plug in different applications into the Event Heap framework and use the entire system for simulation and modeling. The Event Heap coordination and communication framewor will then become an atomic, native mode of com- munication like synchronous handshake is for standard state-machine based approaches.

In order to provide a definition of the Event Heap bus, we need to discharge three obligations. We have to provide a set of ports for the Event Heap and this set of ports will constitute the interface of the Event Heap. There may be any number of ports in this set signifying that the Event Heap semantics does not impose any restrictions on the components that may use it. The other two obligations are defining the data structure for the bus and providing bus rules.

Data Structures. Our obligation here is to define the data representation inside the bus as well as to define certain accessor functions that will be used by bus rules to manipulate the data structures. We start by providing some el- ementary types: PortType, EventType and TemplateType. Each of these types may be thought of as structures with fields that may be used for comparison with each other. We do not go into the details of the type structure because that is not the focus of our study. The interested reader may refer to the origi- nal (textual) specification of the Event Heap [8]. Ports are of PortType, events are of EventType, templates are of TemplateType. The structure of Porttype can disambiguate between multiple ports of the same name but belonging to different components. We also define an atomic boolean operation on types called match which takes an EventType and a TemplateType and determines if they match by a comparison of certain fields.[Again we do not consider the mechanism of how this is done] We derive the following types from the above elementary types.

Event(v), T emplate(v), Regport(v) are functions that operate on a data value of type PacketT ype and extract that part of the packet .that contains respectively the event, template and the port that the client registers to receive a particular type of event. Recall that when a client registers, it sends a template to the Event Heap and tells it to send all events that match the template to a particular port on its interface. Regport(v) returns that port at which the client wants to listen to.

An Example. We give a simple example of Event Heap clients using the Event Heap Bus. These clients can be models of any distributed application like a synchronized Powerpoint presenter or a Multibrowser client-server [11]. Let us assume that an Event Heap client is interested in a particular type of event which can be posted by any other Event Heap client of the i-Room. In order to do that, the interested client executes a remote procedure call transition by which it retrieves these specific events. A remote procedure call

The aim of this paper has been to take a representative middleware system, the Event Heap, and show how it can be defined in the AIDs framework. Other middleware systems would reasonably be expected to support the same set of features as the Event Heap and differ in implementation only. So our study makes a case for using AIDs for modeling middleware-based systems.

Future work entails incorporating AIDs into the Concurrency Workbench framework and providing designers with the power to apply sophisticated anal- ysis routines on AIDs models. We also seek to explore ways to extend AIDs by providing support for typed communication. Also, in this paper we dealt with a simplified subset of middleware, namely event coordination. Enter- prise middleware systems like .NET and COM provide other, more complex functionalities as well, and itwould be interesting to observe how AIDs would accommodate these.

