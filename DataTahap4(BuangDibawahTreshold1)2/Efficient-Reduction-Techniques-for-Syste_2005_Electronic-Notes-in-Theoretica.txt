We consider systems comprised of many copies of a few basic building blocks. Examples include collections of concurrent processes executing the same pro- gram, but also compositions of distinct kinds of homogeneous subsystems, such as the readers-writers protocol. Systems of this type are a primary source of state explosion during temporal logic model checking, characterized by the po- tential to incur a state graph much larger than the description of the system.

The techniques can be applied algorithmically. They are efficient, since they operate on the source code, which is usually small compared to a Kripke model. Finally, the proposed reductions are exact, i.e. the reduced system has the same behavior as the original one (they are bisimilar).

We assume a system of concurrent process components with an interleaving model of computation. Replicated processes are instantiations of a program template. Any number of templates is allowed; each gives rise to a fully sym- metric subsystem. Each process has its own local variables, declared in its template. All variables and statements declared outside any template are referred to as global. We thus permit compositions of distinct fully symmet- ric subsystems, which allows us to model systems like Readers-Writers (two symmetric clusters) or microprocessors with separate symmetries in channels, memory addresses, registers, etc.

High-level modeling languages allow users to specify the behavior of processes in terms of (assignments to) global and local variables. The concept of local states is implicit and must first be extracted from the program. This is, at least in theory, straightforward. A local state is given by a valuation of the local variables. Quantitatively, let m be the number of local variables declared in a program template, and let V1,... , Vm be the ranges of those variables. It

The number of local states is an important factor for the efficiency of counter abstraction. With BDD-based symbolic model checking, bits need to be explicitly allocated for every counter, whether it is relevant for program execution or not. It is therefore crucial for the performance of counter abstrac- tion to detect situations in which keeping a counter to monitor a local state is unnecessary. Such a situation might arise because some variable values in a local state are unused in the program and hence do not matter (section 3.1), or because the local state is known to be unreachable (section 3.2).

case, the local state space of a process contains a program counter, indicating the statement to be executed next. An analysis of the program allows us to estimate the way data are manipulated. We can exploit this information by only keeping track of values of variables that can possibly be used in the future.

Definition 3.1 [e.g. [16]] A variable x is live at a control point if there exists a path to a future moment 5 at which the value of x is used, and x is not assigned along the path. Otherwise, x is dead at the control point.

The formal justification for not recording dead variables is as follows. As- sume each process has a program counter PC and m other local variables v1,... , vm. The concurrent execution of the program P by the processes in an interleaved fashion defines a Kripke structure M = (S, R). Recall that

variables is a data flow analysis problem. A variety of solutions exist, of a complexity that is in practice usually low-degree polynomial in the size of the input program; see for example [16]. The result is, for each value of the pro- gram counter, a list of the variables that are live just before the corresponding line. Stepping through the program, we create a counter variable for each partial valuation of the local variables of the form (PC , x1,... , xk) such that xi is a value of local variable vi, and vi is live at the given PC . Dead variables are not expanded into possible local states.

Suppose L is a local state (i.e. a valuation of local variables) that is not reach- able by any process. In the counter-abstracted program, the corresponding counter nL is invariably zero. If the unreachability of L is known a priori, we do not have to introduce nL as a variable in the abstract program, and the translation into counters does not have to consider L.

Formally, we define the local reachability problem as follows. Given a local state L and a system of concurrent processes, determine whether there is a reachable global state in which some process is in local state L. In general, this problem is of course a model checking problem by itself. However, in order to perform counter abstraction, we do not need to know the exact set of reachable local states; any over-approximation suffices. In fact, not performing such an analysis at all is tantamount to using all (conceivable) local states

Another technique to approximate reachable local states is borrowed from compilers, which sometimes optimize program behavior by confining the num- ber of values that a local variable can have at some program point. Local states not satisfying these limits are unreachable. Examples for such tech- niques are constant propagation, constant folding, copy propagation, integer interval arithmetic and perhaps even alias analysis (depending on the expres- sive power of the programming language).6 Consider the following contrived program, which prints an input number a in some numerical base and the character with ASCII code a, denoted by chr (a).

Variables minprint and base degenerate to constants, since there is only one (dynamic) assignment to them. After replacing every occurrence by 32 or 16, resp. (constant propagation), these variables do not participate in the con- struction of local states. More interestingly, in line 4 we know after constant

efficiency, an explicit-state model checker may use a compressed notation for all zero-valued counters. Symbolically, zero-suppressed BDDs [15] may be applicable, but this technique does not capture the benefits of live variable analysis, where the counters shown to be irrelevant are non-zero. Moreover, since the set of zero-valued counters varies over time, counters for all local states must still be declared initially. The advantage of the techniques in this section is that they reduce the number of counters before even building a symbolic model; irrelevant ones are simply not present.

In modeling languages intended for describing asynchronous systems, the gran- ularity of interleaving is determined by whatever the programmer puts inside an atomic action. Such languages therefore usually support constructs that change the local state of several processes at the same time. Common ex- amples are broadcasts to all processes in a symmetric subsystem instructing them to reset their local state in order to recover from a deadlock, or to inval- idate their cache data. We call such statements synchronization constructs. We show that the straightforward way to implement them abstractly using counters can lead to complex BDDs, and describe an alternative that allows for a more efficient solution.

It changes the local state of all processes i where currently xi = true. The straightforward translation of this simple statement into one based on counters is rather involved. For all local states L with x(L)= true, counter nL must be set to zero (no process with x = true exists after t he execution of (3)). Further,

The intuition for this complexity is an artifact of counter abstraction. In an assignment like for i : xi := false, the current value of xi is overwritten and therefore normally not of further interest. With counter abstraction, however, we need to know this value since the counter for the future local state increases by the value of the counter for the current local state (L vs. L' in (5)). The solution to avoid the complexity is to disentangle steps (4) and (5) so as to

The final example illustrates the effect of serializing complex synchronous instructions when working with BDDs. A communication bridge transports data between two ports, performing some operations on them in the middle [18]. Processes read the data from the output port. When the output port is full, and no process is ready to consume the data, the system is in a deadlock- like situation. It recovers from it by instructing all processes to interrupt and be ready to unburden the output port. The message is broadcast to all processes, rather than just sent to one, since the output port would likely be full again quickly if only one data item was read from it.

In [1], the use of compiler optimization techniques similar to ours is sug- gested to reduce the number of BDD variables to represent reachable states, with different BDDs for different program points. In contrast, the goal of our work is to build a symbolic representation of the overall program, to enable symbolic model checking. This is possible since counter abstraction (which is of no concern in [1]) allows us to incorporate live variable information into the abstract state representation, by creating local state counters judiciously.

