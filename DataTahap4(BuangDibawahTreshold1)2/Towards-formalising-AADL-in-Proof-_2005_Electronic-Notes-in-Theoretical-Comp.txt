This paper presents first steps towards a formalisation of the Architecture Analysis and Design Language, mainly concentrating on a representation of its data model. For this, we contrast two approaches: one set-based (using the B modelling framework) and one in a higher-order logic (using the Isabelle proof assistant). We illustrate a transformation on a simplified part of the AADL metamodel concerning flows.

well static aspects like partitioning into packages and dynamic aspects related to active entities, communication between them and timing aspects. In fact, it reflects the growing industrial need to model and reason about complex software/hardware artifacts, as found in the avionics and automotive sector. Indeed, the authors of this contribution are partners in the federated project Topcased which comprises, among others, Airbus, and aims at creating a workbench whose main modelling language is AADL.

For the time being, we can only give a very preliminary account of our formalisation of the AADL language. Even though still incomplete, a small example in Section 4 shows where we are heading. The paper concludes in Section 5 with a discussion of related work and possible extensions.

It defines a class AObject (the very top of the AADL class hierarchy), one of its immediate subclasses, NamedElement, and a Connection class. Class AObject can contain an arbitrary number of comment attributes (as indi- cated by the negative upperBound ), NamedElement has a name attribute, apart from the comment attribute inherited from AObject. A Connection, with su- pertypes ModeMember and ReferenceElement, has three (non-inherited) at- tributes, among them two references to elements of class FeatureContext (the source and destination of the connection).

Altogether, we are left on our own to give a precise meaning to the con- structs of Ecore, based on an informal understanding of the underlying con- cepts. This translation, which we will explore for different target formalisms in Section 3, is not limited to the definition of AADL, but can be applied to any language defined in Ecore. However, AADL imposes some additional constraints that cannot be expressed in Ecore but are made precise in the accompanying standard[14].

In this section, we illustrate how an ecore description can be encoded in set theory. We use the B [1] syntax. The translation to other set based frameworks like TLA [16], or Isabelle-ZF [23] should be similar. In this section, we sketch the principles of data modeling. In section 4, we present a transformation example relying on such a representation.

Let us review the main choices: A deep embedding does not try to directly represent elements of the language as expressions of the target language (in this case: Isabelle/HOL), but rather encodes them. For example, classes could be represented by the class name, the name of the superclass and lists of their attribute types. Such an approach has been followed in the semantics of Java described in [22]. We would get a definition like

Furthermore, note that the class structure we are dealing with is not open- ended, as in a traditional object-oriented program. Rather, the class struc- ture is fixed. For example, a FlowSpec can be either a FlowSourceSpec, a FlowSinkSpec, or a FlowPathSpec. This fact would again have to be coded explicitly, while we would prefer to appeal to an induction principle.

A type s C which is the sum of the subtypes of C. For non-abstract classes, we add a further component (of type Unit) for an instance which is of class C an none of its subclasses. For a class without subtypes, we do not construct s C.

In this section, we sketch how a transformation can be considered in our framework. We first give a part of the AADL metamodel and then define a simple transformation that adds a filter to a flow. The example is only developed using the B language.

In this example, we consider a simplified part of the AADL metamodel which describes the concept of a flow. A flow can be declared in the specification of a component as a connexion between an input port and an output port. In the implementation, the flow can traverse sub-components. Three kinds of flows exist: flow paths, flow sources and flow sinks. We consider here flow paths which can be defined using the following regular expression:

The transformation must allocate new objects. They are chosen in the set of unallocated elements of their class. Objects of the same class are explicitly declared as different. For example, the following code fragment declares two new objects taken among the free instances of FlowElement and Connection.

Finally, connections between objects must be established. For this purpose, (functional or non functional) relations are updated. For example, the flow element is initialised by the flow path of the filter sub-component and by a connection linking the input port of the component to the input port of the filter.

The full code for the transformation is given above. The preconditions of the operations assert that the given filter has exactly one input port and one output port, with one flow path between them. This flow path will be inserted into the flow path fp of the given component implementation.

This specification of the transformation allows the verification of static properties such as the preservation of wellformedness properties of the model specified by invariants. The properties considered here are those directly ex- pressed by the metamodel. They could easily be extended at the B level: flow path must be well build so that the extremity of connections and of the sub- component flow paths match. Furthermore, implementation and specification of components must be compatible, which means that they have the same ports and that the origin and destination of flow paths are the same. These invariants ensure that the transformation preserve the flow-based semantics of the model. In order to go one step further, an abstract specification of the transformation should express that the specified flow is implemented by traversing the filter.

We have presented approaches of translating the Ecore language into different formalisms (set based, higher-order logic). In particular, we are interested in a representation of the AADL meta model, which permits us to specify and prove correct transformations of AADL models. It seems that the set based approach is well suited to our concerns. However, due to the power of the frameworks usually available with higher order logics proof assistants (Coq, HOL, Isabelle, PVS), a pragmatic approach would be to work on top of an embeddding of set theory in higher order logics. A major concern of our further studies will be the scalability of such embedding approaches.

An avenue that we have not further explored is the following: perceive the AADL class structure as the class structure of an object-oriented program, and transformations as appropriate methods of these classes. In order to show the correctness of transformations, prove that the methods are correct with respect to a particular specification. The proof could be carried out with tools geared towards Java [15,18,19,12] or towards OO specification mechanisms such as Object-Z or variants [24] . Even though we do not have concrete evidence, we suspect that verification of an OO program is more heavy-weighted than the approach we have chosen. We believe that the abstraction mechanismes usually available in logical frameworks are better suited.

This section gives a sample of B code. Only the text of the transforma- tion, i.e., the B operation Addfilter (section 4) has been written. The ma- chine clauses: SETS, CONCRETE CONSTANTS, DEFINITIONS, PROPERTIES,  ABSTRACT  VARIABLES,  INVARIANT and INI-

