In this paper, we discuss ProTest, an automatic test environment for B specifications. ProTest is based on ProB, a model checking and animation tools for B [16]. ProTest follows an approach similar to the one by Dick and Faivre [10] (discussed in Section 2) and generates test cases from B specifications by partition analysis of the state invariant and the operation preconditions of a specification. Our method offers some guidelines and if the implementation follows them, then the whole cycle of the testing process can be automated. We also discuss a small industrial case study to illustrate our approach and the test environment. The main results of our paper can be summarised as follows:

ProTest generates test cases by partitioning and exploring the state space. ProTest then simultaneously animates the specification and runs the im- plementation with respect to the test cases and assigns verdicts whether the implementation has passed the tests. The whole process is automatic; however, at this stage the test environment imposes some restrictions on operation arguments and results.

The organisation of the paper is as follows. Section 2 discusses the related work. Section 3 presents our approach. Section 4 discusses our implementation and in Section 5 we preset an analysis of our test environment in relation to existing work. Section 6 concludes the paper.

The work by Dick and Faivre [10] is a major contribution to the use of formal methods in software testing in which they have discussed a strategy for generating test cases from model oriented formal specifications. A VDM [14] specification has state variables and an invariant (Inv) to restrict the state variables. An operation, say OP , is specified by a pre-condition (OPpre) and a post-condition (OPpost). The approach of Dick and Faivre is to partition the

Legeard et al. [15] have developed a tool called the BZ Testing Tool (BZ- TT) for deriving test cases from Z or B specifications. Since our approach has many similarities with the BZ-TT, we present it here in some detail. So far as B specifications are concerned, they assume (i) the specification consists of a single B machine, and (ii) all sets in the B machine are transformed into finite enumerated sets. The test case generation proceeds in the following steps:

inps and s) and Post is the postcondition. inps and outs are respectively the operation input and the result. The normal form tells: provided Pre is true, the values s' and outs' are non-deterministically chosen such that Post is satisfied. Post may refer to s and outs as well as s' and outs'.

Step 5: The full state space of the B machine is explored to construct a FSM (finite state machine) whose initial node is the initial state of the B machine. Each node in the FSM represents a possible machine state and each edge is labelled by an operation instance. Of course, to explore the full state space, it is assumed that all the sets of the specification are of finite type and they are small in size. The state space search is performed by the ProB tool; more about the implementation will be discussed later. The aim here is that all the operation instances which we have generated in our partition analysis appear at least once in the FSM. However, it is not always possible since some operation instances may not be reachable.

The ProB tool is an automated consistency checker of B machines via model checking and constraint-based checking. The activity of consistency check- ing shows that the operations of a machine preserves the machine invariant. The ProB environment has been developed mainly in SICStus Prolog with a graphical user interface implemented in Tcl/Tk. ProB uses the JBTools [22] package to translate a B machine into XML form, and then the Pillow pack- age [7] is used to transform the XML files into a Prolog term representation. The ProB front end then uses this Prolog term representation. The ProB animator provides visualization of the state space that has been explored so far by the animator. Further details about ProB can be found in [16].

The model checker component of ProB tries to explore the state space of a B machine systematically and automatically. It alerts the user as soon as a problem like the invariant violation is found, and then presents the short- est trace within the states already explored that leads from the initial state to the place of error. The model checker also detects when all states for fi- nite state models have been explored, and thus can formally guarantee the absence of errors. For such exhaustive model checking, the sets of the ma- chine are restricted to small finite sets and integer variables are restricted to small numeric ranges. Under these restrictions only, ProB can traverse all the reachable states of the machine (and show the absence of errors within the restrictions). ProB can also animate a B machine. In addition, ProB supports random animation in which eligible operations are applied at random till their number reaches a certain limit given by a user.

The operation parameters of the machine and those of the implementa- tion are of basic types, and in addition the operations have a single return value of basic type. Our current implementation performs automatic ver- dict assignment under these restrictions. They keep the representation mapping between the specification and implementation namespaces sim- ple. However, in future, we intend to lift these restrictions.

The Partition Analyser: The preconditions and the machine invariants are extracted and both are converted into their DNFs. A naive theorem prover then tries to eliminate all the disjuncts from the DNF of the precondition which are either self-contradictory or which contradict the invariant. The remaining disjuncts are used to create partitions of the operation input space, and then the operation instances.

Coverage Graph Display: ProTest can display the state space coverage in the form of a graph. Nodes in this graph represent the abstract machine states and the edges are labelled with the operation instances. An edge sig- nifies state transformation through the application of the labelled operation instance.

ProTest environment at this stage can deal with Java implementations. Let us assume, we have a Java implementation which has encoded all the update and the probing operations of a B machine. In this sense, the implementa- tion has been directed by the specification. Richardson et al. [17] point out that while running a test case, examination of the test result is not the only

interesting observation; sometimes intermediate results can be examined at strategic points which they call control points. In our case, control points could be the positions before and after operation (or operation instance) in- vocations. ProTest has the capability to perform simultaneous specification animation and code execution, and at selected control points, both the spec- ification and the execution states are examined by invoking their respective probing operations. The results of the probing operations are matched by using the representation mappings, and if there is a mismatch, it is reported to the user.

B supports two types of non-determinism: bounded choice through the syn- tactic construct SELECT and unbounded choice through the construct ANY. In a SELECT construct, there are a finite number of guarded substitutions and a branch whose guard evaluates to ture is non-deterministically chosen. In an ANY construct, an element of a set is non-deterministically chosen.

Here r1,... , rk are the k non-deterministic choices made in the course of op- eration OP. Let us consider the case when ProTest is doing simultaneous animation and execution during testing with respect to a test case, and we have reached the operation OP . At this point ProTest observes what choices the implementation has made. Thereafter, ProTest will follow the choices made by the implementation. We term this approach testing on the fly. Note that the current version of the ProTest does not support this aspect.

Partition Analysis: Many other works like [10, 15] partition the input space by considering both the pre- and the postconditions of an opera- tion. The reason they cite is that usually the operation preconditions are trivial in nature, and a DNF analysis over them would hardly result in worthwhile partitions. In our case, we strengthen an operation precon- dition by lifting predicates used within the operation bodies. We have observed that our approach generate the same number of partitions as the one by Legeard et al [15]. However, partition analysis in presence of non-determinism may need some more analysis with a view to creating further partition of the input space.

Once input subdomains are derived after a DNF based analysis, the BZ- TT approach uses some (minimization/maximization) cost functions to further partition the input space and then test cases are generated. At this stage though the ProTest approach does not use cost functions, it can use them in future to create further partitions. This is just an en- hancement which can be easily integrated into the ProTest environment.

There may be operation instances generated by partition analysis which are not reachable in the course of exhaustive model checking. One pos- sible reason may be the initialization condition of the machine which does not make it possible to reach the operation instance; however, there may be a different initialization which can make this operation instance reachable. This can be found out by the constraint based checking facil- ity of ProB. ProB can even suggest an initialization condition which can make this operation instance reachable. In addition, it can be checked if application of this operation instance can lead to invariant violation.

are important differences. First, the approach to partition analysis is different though both result in similar partition sets. Second, ProTest is different in the sense that it performs simultaneous specification anima- tion and code execution to establish the correspondence. Third, ProTest performs automatic verdict assignment. In addition, we address the issue of non-determinism.

Snook and Butler [19] have developed a tool called U2B which mechan- ically translates UML specifications to B. Of course there are some re- strictions on the UML classes so that when translated they do not violate the hierarchical structure of the B machines. Our ProTest environment could be integrated with the U2B tool which would facilitate mechani- cal generation of test cases from UML specifications. Further by testing the implementation against the generated B specification, this approach would indirectly establish the correspondence between the UML specifi- cation and the implementation.

In this paper, we have presented ProTest, a testing environment for B spec- ifications. The highlights of this tool are that it performs in parallel the animation of the specification and code execution with respect to test cases, and it assigns verdicts on the test results. We have also offered a solution to handle non-determinism in the B operations. We have discussed the effi- cacy of the ProTest tool by performing a small case study from industry. We have also demonstrated how through the use of temporal model checking and constraint based checking, we can obtain a set of robust test cases.

sel_colour : COLOURS & sel_colour = lightgrey & /*Colour of slot at cursor*/ norm_colour: COLOURS & norm_colour = red &	/*Usual colour of slots */ titles	: PAGENR --> PAGENAMES &	 /* a total function	*/ titles = { 1 |-> p1, 2 |-> p2, 3 |-> p3, ...  15 |-> p15}

