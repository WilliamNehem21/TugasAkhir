This paper introduces LEMON, a generic open source C++ library providing easy-to-use and efficient implementations of graph and network algorithms and related data structures. The basic design concepts, features, and performance of LEMON are compared with similar software packages, namely BGL (Boost Graph Library) and LEDA. LEMON turned out to be a viable alternative to these widely used libraries, and our benchmarks show that it typically outperforms them in efficiency.

The goal of the library is to provide highly efficient, easy-to-use and well- cooperating software components, which help solving complex real-life optimization problems. These components include graph implementations and related data struc- tures, fundamental graph algorithms (such as graph search, shortest path, spanning tree, matching, and network flow algorithms) and various auxiliary tools (for ex- ample, flexible input-output support for graphs and associated data). Furthermore, the library provides a common high-level interface for several linear programming (LP) and mixed integer programming (MIP) [10,12] solvers.

LEMON is designed to be cross-platform and supports a wide range of operating systems and compilers. Up to now, it is tested on Linux, Windows, OSX, and AIX systems with the following compilers: GCC 3.3-4.4, Intel C++, IBM xlC, Visual C++ 2005, 2008, and 2010, MinGW. Due to the CMake [8] based build environment, LEMON integrates well with various IDEs, such as Visual Studio, CodeBlocks or Eclipse.

The rest of this paper is organized as follows. Section 2 provides an overview of the main features of LEMON compared with similar C++ graph libraries. Section 3 describes selected implementation details. Section 4 compares the performance of the discussed libraries by benchmark tests of fundamental algorithms. Section 5 outlines the main further plans for developing LEMON. Finally, the conclusions are drawn in Section 6.

Undirected graphs provide an Edge type for the undirected edges and an Arc type for the arcs. This separation makes the implementation of some algorithms simpler (e.g., planar graph algorithms) because we can distinguish the undirected edges from their directed variants. On the other hand, the Arc type of an undirected graph is convertible to the Edge type, thus the corresponding edge of an arc can always be obtained conveniently, without calling any functions. As a result, all methods and data structures that are designed for edges can be used directly with both edges and arcs. This could be quite practical in several cases. For example, a property map (see Section 2.3) that assigns data to edges can be used with both edges and arcs, but an arc map can only be used with arcs.

The adjacency list class template of BGL implements both directed and undi- rected graphs by extensive use of template specializations. As a result, directed and undirected graphs have the same interfaces but different semantics in BGL. The edges of undirected graphs are usually considered undirected, but they have di- rections in some cases, for example, in iterations. Such an inconsistency could be confusing. Moreover, this design does not make it possible to define property maps whose keys are the directed variants of the edges, although it would also be important in certain algorithms.

Various special purpose graph types are also implemented in the libraries, for example, full graphs, grid graphs or adjacency matrix graphs. Furthermore, all of the three libraries provide an optimized static data structure for directed graphs, which stores the nodes and arcs in arrays or vectors in such a way that the arcs are sorted by their source nodes. As the crucial operations of most directed graph algorithms iterate on the outgoing arcs of the nodes, they typically run faster using these static implementations.

Most graph libraries provide iterator classes for traversing through the elements of the graph data structures (i.e., the nodes and arcs). LEMON defines a special iterator interface, which does not conform to the iterator concepts of the C++ Standard Template Library (STL).

The iterators of LEMON are initialized to the first element in the traversed range by their constructors, and their validity is checked by comparing them to a special constant INVALID. Furthermore, each iterator class is convertible to the cor- responding graph element type, without having to use operator*(). This feature distinguishes LEMON iterators from the standard C++ iterators and makes their usage slightly simpler.

Note that this concept could not be applied to general iterators. For example, STL defines iterators for containers of arbitrary items. It means that the iterator type and the item type of the container could have conflicting functionality, for instance, both of them could support operator++(). Therefore, an iterator object and the referred object must be distinguished: it++ affects the iterator it, while (*it)++ affects the referred object *it.

LEMON iterator concepts, however, exploit the speciality of graphs, which can be viewed as containers of particular elements. The nodes and arcs themselves pro- vide a strongly limited set of features, which does not conflict with the functionality of iterators. Therefore, the program context always indicates whether we refer to an iterator or to a graph element, as we have already seen in the above example.

The most important operation of a map data structure is the access of its el- ements, that is, retrieving or overwriting the value assigned to a certain node or arc. In most graph libraries, time complexity of these operations is O(1). Library designers have to deal with two additional performance considerations. First, map access operations should not be virtual functions because that forbids inlining. Sec- ond, it is worthwhile to use continuous storage for maps since it usually induces faster data access due to better caching.

LEMON features only external property maps that are stored separately from the related graph data structure, but they are updated automatically on the changes of the graph (see Section 3.3). The main advantage of external maps is their great flexibility. They can be constructed and destructed freely, so their lifetimes are not bound to the lifetime of the graph. Moreover, separate storage could result in better caching properties, especially using several maps for a large graph.

External property maps are also supported in BGL by wrapping standard con- tainer data structures. They are more flexible than interior properties since their lifetimes are not bound to the associated graph. However, we have to choose between efficiency and convenience if we use these maps in conjunction with a varying graph. We can apply a map that wraps a random access container (e.g., std::vector) to ensure rapid data access, but it must be updated manually each time the graph changes. Alternatively, we can also use an external map that is based on an as-

Although these data structures are external, LEDA makes it possible to allocate additional storage space for them in the graph objects. The newly created arrays and maps can be assigned to these slots, so the memory usage can be optimized. Apart from these solutions, LEDA also provides parameterized graph data structures, whose node and edge objects can contain arbitrary additional data, just like the bundled properties in BGL.

LEMON provides highly efficient implementations of numerous algorithms re- lated to graph theory and combinatorial optimization. These algorithms include fundamental methods, such as breadth-first search (BFS), depth-first search (DFS), Dijkstra algorithm, Bellman-Ford algorithm, Kruskal algorithm, and methods for discovering various graph properties (connectivity, bipartiteness, Eulerian property, etc.), as well as complex algorithms for finding maximum flows, minimum cuts, feasible circulations, maximum matchings, minimum mean cycles, minimum cost flows, and planar embedding of a graph. BGL and LEDA feature similar varieties of algorithms but with different interfaces.

BGL implements several algorithms with visitor-based interfaces instead of us- ing special purpose graph maps. The visitor classes are the generalizations of func- tion objects: they have more entry points by defining several callback functions. A visitor-based algorithm emits different events during its execution and calls the corresponding entry functions of the associated visitor. In some cases, this tech- nique could be more convenient than the use of customized maps, because all event handler operations are implemented in the same class. For this reason, LEMON also provides visitor-based solutions but only for the basic graph search algorithms, BFS and DFS.

Another fundamental graph alteration is the hiding of nodes and arcs, which can be achieved using one of the subgraph adaptors in LEMON. These classes store filter maps that are used by the iterators to skip the currently hidden items. Therefore, subgraph adaptors are significantly less efficient than the original graph objects.

Combinatorial optimization methods are usually based on more complex graph alterations. For example, the residual network is a particularly important model for flow and matching algorithms. ResidualDigraph implements this network by adapting a directed graph along with a capacity map and a flow map.

and an out-node in a directed graph. Formally, the adaptor replaces each node v with two nodes vin and vout. Each arc (u, v) of the original graph will correspond to an arc (uout, vin). The adaptor also adds an additional bind arc (vin, vout) for each node v of the original graph. The aim of this construction is to assign costs or capacities to the nodes of the graph when using algorithms which would otherwise consider only arc costs or capacities.

Linear programming (LP) is one of the most important general methods of opera- tions research. Countless optimization problems can be formulated and solved using LP techniques. Nowadays, various efficient LP solvers are available, including both open source and commercial software. Therefore, LEMON does not implement its own solver but features wrapper classes for several LP libraries providing a common high-level interface for them.

LEMON provides a general file format for storing graphs and related node and arc maps. Such a format should be versatile, that is, it should support storing arbitrary number of maps of arbitrary value types. Furthermore, the file size and the ease of processing are also crucial to support working with huge graphs, which is a major goal of LEMON. Therefore, a flat text file format was designed instead of using structured hierarchical formats, such as GraphML [21], GXL [22] or GML [17].

The LEMON Graph Format (LGF) comprises different sections, for example, a digraph is stored in a @nodes and an @arcs section. These parts use column oriented formats, in which each column belongs to a map in the graph. The first lines of the sections associate names to these maps, which can be used to refer them. Note that this simple idea makes it possible to extend the files with new maps (columns) at any position without having to modify the processing codes.

The iteration on the outgoing arcs of a given node begins with the lookup of the corresponding NodeT item, whose first out member stores the index of the first arc. After that, each step reads the next out value from the current ArcT object to obtain the index of the next arc, or -1 if the current arc is the last one. The incoming arcs are handled in the same way using the members first in and next in. It means that the incident arcs are recorded using simply-linked lists that are actually stored in a vector.

Recall from Section 2.3 that LEMON graph maps are external, auto-updated data structures. They are implemented using arrays or std::vectors to ensure efficient data access, which is the most important design goal of maps. However, these data structures are extended when new nodes or arcs are added to the associated graph.

The graph and map types implement the Observer design pattern [15], they signal the changes of the node and arc sets. The observed events are limited to adding and removing one or several items, building the graph from scratch, and removing all items from it. The observers are inherited from the corresponding AlterationNotifier<Graph, Item>::ObserverBase class, and they have to over- ride the event handler functions.

The graph maps are designed to be exception safe. In fact, they guarantee strong exception safety [35]. If a node or arc is inserted into a graph, but an attached map cannot be extended, then each map extended earlier is rolled back to its original state.

Let us consider the checking of the Eulerian property for example. A directed graph is Eulerian if it is connected and the number of incoming and outgoing arcs are the same for each node. On the other hand, an undirected graph is Eulerian if it is connected and the number of incident edges is even for each node. Therefore, the eulerian() function is specialized for undirected graphs using UndirectedTag as follows.

with placement new when items are inserted into the graph. However, maps of POD value types are implemented with std::vectors because their constructors are cheap and do not have side effects. The values are reset when the items are removed from the graph.

All test instances were created with NETGEN [26], a popular generator for various network problems. Two different benchmark suites are considered. The first one contains sparse graphs, for which m is about n log2 n, where n and m denote the number of nodes and arcs, respectively. In the second set, there are networks

LEMON features various algorithms for the minimum cost flow problem. The two most efficient methods are the cost scaling algorithm [18,20] and the network simplex algorithm [1,12]. As LEDA also implements the cost scaling algorithm, the same method was chosen for LEMON. The efficiency of this algorithm also depends on the application of various practical heuristics, in which the libraries differ. According to these tests, LEDA was slower than LEMON by a factor between

Numerous other experiments were also made using several compilers and more algorithms applied to various generated problems and real-life networks, but they are omitted in this paper due to page limit. All comparisons showed similar rela- tions and suggested the same conclusions. The fundamental algorithms and data structures of LEMON turned out to be measurably faster than the correspond- ing implementations of the other two libraries. This achievement is clearly one of the most important benefits of LEMON. It could be a major reason for using this library.

Along with this, work will be continued on porting and thoroughly revising all the features that exist in the 0.x series of LEMON. An important group still waiting for porting is the bipartite graph concepts, implementations and bipartite graph related algorithms. This task is planned to be accomplished by the release of version 1.3.

The new language feature makes it possible to decide in compile time whether the parameter is a temporary object, thus a compilation error could be enforced in such cases. Moreover, this feature also allows a smarter handling of map references. For example, the function nodeMap() could be specialized for temporarily created parameters. This version of the function would store the passed object instead of setting a reference. This solution would support a more flexible usage without significant performance loss.

LEMON is a highly efficient, open source C++ graph template library having a clear design and convenient interface. It provides a wide range of data structures, algo- rithms and other practical components, which can be combined easily for solving problems of various types related to graphs and networks. According to exten- sive benchmark tests, essential algorithms and data structures of LEMON typically turned out to be more efficient than the corresponding tools of widely used similar libraries, namely BGL and LEDA. For these reasons, LEMON is favorable for both research and development in the area of combinatorial optimization and network design.

