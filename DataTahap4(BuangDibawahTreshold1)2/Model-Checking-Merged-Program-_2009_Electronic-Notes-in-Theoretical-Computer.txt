However, if the objective is not on-the-fly verification, but simply an analysis of a program through its runtime behavior, it is reasonable to try to collect and combine as much information as possible about it. This implies, in particular, that one should try to combine several traces in order to gain a better understanding of the underlying program. This kind of idea is pursued in a number of works for various specific purposes.

It is important to note that the technique presented here might not actually be appropriate in other contexts, such as when one wishes formal guarantees concerning the presence or absence of software defects. As it will become clear, our method depends on some assumptions and can only generate approximate models, which might elicit wrong responses from a model checker (i.e., false positives and false negatives). Nevertheless, in many situations it is better to have such an approximate understanding of a system rather than no understanding at all. Moreover, the quality of our approximations can be easily improved by adding more and longer traces.

We assume that the program traces are available and, thus, we do not provide a method for collecting them. In this respect, we just define a trace file format that our proof-of-concept tool can read. This way, we do not restrict the possible applications of our method to any particular kind of program.

establishes the formal foundations upon which the merging algorithms are defined. In Section 4, these algorithms are given. Then, in Section 5 we show how to actually perform model checking in the merged traces. Section 6, in turn, presents some illustrative experiments employing a simple economic simulation. Finally, Section 7 reflects about what was achieved and discusses what remains to be done.

sumption. So, in fact, they assume the existence of a structure similar to the one we try to create (i.e., directed graphs). Second, the quality of their approximations is given by the choice of the depth to employ when performing calculations in certain subtrees, while we give specific algorithms to create approximations and which yield different kinds of state-spaces.

With similar purposes, Lo et al. [13] investigate how to mine temporal logic formulae, Ernst [8] presents techniques to extract program invariants, and Ernst et al. [9] introduce Daikon, a system to extract such invariants. While our present work does not aim at discovering such information from traces, it will be clear that the resulting state-spaces from our algorithms can be used to such an end.

Model checking is traditionally employed as an exhaustive verification method, which demonstrates the presence or absence of some property on a formally speci- fied system. However, this also results in efficiency problems, which motivates the development of approximate model checking algorithms, in which only a part of the possible execution paths are explored, such as the work of Cho et al. [5]. Our work is similar to this approach, but whereas their approximations are derived from formal analysis of the system, ours relies on the collected traces at runtime.

This change-preserving method is of interest only if the traces to be merged present a significant amount of segments that can be eliminated. The worst case scenario, however, is even worse than that of time-preserving merging. This happens because, unlike time-preserving merger, change-preserving can connect extended states that are not temporally consecutive. Let us outline its worst case complexity. Again, define m to be the length of the largest trace and let us have m sets of extended states, each containing the extended states that appear in some particular instant. Hence, again we shall have mn extended states to consider in the worst case. Now, however, each set of extended states may connect to all sets that come after it, except the one that comes immediately after it. Therefore, the total number

Once the traces are merged, we have a state-space that can undergo model checking, using either LTL or CTL. Theoretically, there is not much more to be done. On the other hand, from a practical stand point, it is still necessary to provide an actual implementation that performs the model checking. To this end, we simply translate the state-spaces to the input language of an existing model checker, NuSMV. The translation specifies a Finite State Machine (FSM) whose states and transitions are those in our state-space, with the addition of a few new transitions to account for a technicality. Then, NuSMV can be used directly to investigate the temporal properties of the FSM.

While limiting the verification to a particular number of states might seem a crude mechanism in general model checking, in our case it is a reasonable approach, since the traces we have access to are themselves subject to such limitation. So if we want to cover all available information, it is sufficient to fix such a maximum instant as the size of the largest trace (e.g., in the above example, 200). And though it is always desirable to cover all the available information, for efficiency reasons one might need to give up part of it, thus making this kind of instant limitation useful.

Our model has the following variables of interest: inflation, economic activity and standard of living. At each simulation step, their values are updated according to some rules. The simulator simply runs the model several times, collecting traces and, in the end, producing a trace file that can be read by our trace merger.

Can depressions be eventually followed by growth? Recall that the last states in the FSM are looping, so that specifications referring to their future will be inaccurate. Hence, to specify the desired property in CTL, we must choose a maximum instant for the depressions to start, so that the future that follows remains correct. We arbitrarily chose the 50th instant. Notice also that a change- preserving trace merger would be sufficient to analyze this property. We get the following CTL proposition:

To answer these questions, we open the NuSMV file we have just generated and append them to it. Then we just run NuSMV with this input. As it turns out, only the second and the third propositions above are true. But, of course, if the simulation had being implemented in a different manner, different results could arise. Furthermore, since the state-space employed is an imperfect approximation of the actual system, it is necessary to assume that the answers given by the model

checker might be wrong. Hence, one may wonder how these answers are useful at all. To address this concern, two things must be understood. First, these uncertain answers are indeed valuable if more rigorous methods are not available, since they do reflect the behavior of the system, albeit in an incomplete manner. And, second, the technique is not supposed to assert infallible propositions, but only to suggest possible behaviors, given the available data and the suppositions concerning the simulated system. The user is expected to use such suggestions as guidelines for further scrutiny, either by providing more and longer traces to our algorithms or by employing other methods (e.g., writing specific test cases for the detected behavior, inspecting the source code).

We highlighted the merging techniques which seem most interesting to us. But they are not the only ones possible, and perhaps for different problems other man- ners may be more appropriate. For example, the change-preserving algorithm of Section 4.3 also preserves the instant that a change takes place, but maybe this is not necessary for some applications. Furthermore, we purposefully disregarded techniques in which no merging would take place and every trace would be analyzed independently, since these would not belong to the core subject of the paper.

Finally, the state-space produced by merging traces can also be useful to other things besides model checking. As an approximate representation of an underlying program, it might be interesting to apply machine learning algorithms to it, in order to extract new information about its behavior. For example, it might be the case that every time a particular state comes up, another state never appears, but we are unaware of this relation. A machine learning algorithm could, perhaps, reveal it to us.

