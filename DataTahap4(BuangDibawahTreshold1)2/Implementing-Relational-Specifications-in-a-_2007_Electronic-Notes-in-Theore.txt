For many years, relation algebra has widely been used by mathematicians and com- puter scientists as a convenient means for problem solving. Its use in Computer Science is mainly due to the fact that many datatypes and structures (like graphs, hyper-graphs, orders, lattices, Petri nets, and data bases) can be modeled via rela- tions, problems on them can be specified naturally by relation-algebraic expressions and formulae, and problem solutions can benefit from relation-algebraic reasoning and computations. A lot of examples and references to relevant literature can be found, e.g., in [17,4,6,13].

The functional logic programming language Curry [8,10] aims at integrating different declarative programming paradigms into a single programming language. It can be seen as a syntactic extension of Haskell [14] with partial data structures and a different evaluation strategy. The operational semantics of Curry is based on lazy evaluation combined with a possible instantiation of free variables. On ground terms the operational model is similar to lazy functional programming, while free variables are nondeterministically instantiated like in logic languages. Nested expressions are evaluated lazily, i.e., the leftmost outermost function call is selected for reduction in a computation step. If in a reduction step an argument value is a free variable and demanded by an argument position of the left-hand side of some rule, it is either instantiated to the demanded values nondeterministically or the function call suspends until the argument is bound by another concurrent computation. Binding free variables is called narrowing ; suspending calls on free variables is called residuation. Curry supports both strategies because which of them is right depends on the intended meaning of the called function.

Boolean formulae can be solved more efficiently using binary decision diagrams [5]. Therefore, the PAKCS [9] implementation of Curry contains a specific library CLPB that provides Constraint Logic Programming over Booleans based on BDDs. In this library, boolean constraints are represented as values of type Boolean. There are two constants, viz. the always satisfied constraint and the never satisfied constraint:

Besides these constants, the library CLPB exports a lot of functions on boolean constraints. For example, there are the following nine functions corresponding to the boolean lattice structure of Boolean, where the meaning of the function neg and the operations (.&&), (.||), (.==), and (./=) is obvious and the remaining operations denote the comparison relations on Boolean with the constant false being defined strictly smaller than the constant true:

In this section we sketch an implementation of relation algebra over finite, binary, relations in the Curry language. We will represent relations as boolean matrices. This allows to employ the higher-order features of Curry for an elegant formulation of the relation-algebraic operations, predicates, and constants. As we will also demonstrate, relational constraints can be integrated seamlessly into Curry because we can use free variables to represent unknown parts of a relation. Based on this, the nondeterministic features of Curry permit us to formulate the search for unknown relations that satisfy a given predicate in a natural way.

The functional features of Curry serve well to implement relation algebra. Relations can be easily modeled as algebraic datatype and relational operations, predicates, and constants can be defined as Curry-functions over this datatype. We only con- sider relations with finite domain and range. As already mentioned in Section 2.1, such a relation can be represented as boolean matrix. Guided by the type of ma- trices introduced in Section 3.1, we define the following type for relations:

Note that we use the type Boolean instead of Bool for the matrix elements. This allows to apply the more efficient constraint solver satisfied of Section 3.3 for solving relational problems. Furthermore, note that in our implementation a vector corresponds to a list which contains exactly one list.

In Section 2.1 we introduced one more basic combinator on relations, namely re- lational inclusion. It differs from the other constructions because it does not com- pute a new relation but yields a truth value. For the applications we have in mind, we understand relational inclusion as a boolean constraint over relations,

i.e., a function that takes two relations of the same dimension and yields a value of type Boolean. Its Curry implementation is rather straightforward by combin- ing the already used functions foldr1 and elemWise with the predefined function concat :: [[a]] -> [a] that concatenates a list of lists into a single list.

The predefined function replicate :: Int -> a -> [a] computes a list of given length that contains only the specified element. The function find is the key to many solutions of relational problems using Curry since it takes a predicate over a relation and nondeterministically computes solutions for the predicate. A gener- alization of find to predicates over more than one relation is obvious, but for the problems we will consider in this paper this simple version suffices.

Now, we present some example applications. We also report on the results of our practical experiments with the PAKCS implementation of Curry on a PowerPC G4 processor running at 1.33 GHz with 768 MB DDR SDRAM main memory. Unfortunately, the current PAKCS system is not able to use more than 256 MB of main memory which turned out to be a limitation for some examples.

In the following first example we present an application of our library that does not rely on the logic features of Curry. We implement the relational specification of a least element of a set with regard to an ordering relation. This specification is not given as a predicate but as a relation-algebraic expression.

To compute a linear extension of an ordering relation, we directly can employ the function find introduced in Section 4.2. The result is the following function that takes an ordering relation as argument and nondeterministically returns a linear extension of the given relation.

Using encapsulated search [3], the function linearExtension can be employed to enumerate all linear extensions of an ordering relation. We do not need to specify sets of linear extensions relation algebraically to compute them. The nondeterminis- tic features of Curry permit us to use a simple specification for one linear extension to compute all of them. Enumerating linear extensions is of great interest to com- puter scientists because of its relationship to sorting and scheduling problems. For example, the NP-hard problem of computing a possible scheduling for a distributed system with dependencies given as ordering relation R obviously can be solved by computing all linear extensions of R and picking a best linear extension.

If the given ordering relation represents the dependencies of tasks in a distributed system, each linear extension represents a possible scheduling expressed as relation of type Rel. To rate a scheduling with regard to some quality factor, it would be more convenient to represent it as an ordered list of tasks. The conversion is accomplished by the following function that relies on the predefined function sortBy :: (a -> a -> Bool) -> [a] -> [a] that sorts a list according to an ordering predicate. The function evaluate :: Boolean -> Bool converts between boolean constraints and values of type Bool and (xs !! n) selects the n-th element of the list xs.

Of course, with regard to efficiency, our approach to execute relational specifica- tions cannot compete with specific algorithms for the problems we have considered. It should be pointed out that our intention is not to support the implementation of highly efficient algorithms. We rather strive for automatic evaluation of rela- tional specifications with minimal programming effort and reasonable performance for small problem instances. Therefore, we compared our approach to a narrowing- based implementation, that does not rely on a constraint solver but uses the hand- coded function satisfied introduced in Section 3.2. The results of our experiments show that using a constraint solver significantly increases the performance while it preserves the declarative formulation of programs.

In this paper we have demonstrated how the functional logic programming language Curry can be used to implement relation algebra and to prototype relational speci- fications. We have used the functional features of Curry for elegantly implementing relations and the most important operations on them. Then the execution of ex- plicit specifications corresponds to the evaluation of expressions. For the execution of implicit specifications we employed a boolean constraint solver available in the PAKCS system which proved to be head and shoulders above a narrowing-based approach. Without presenting an example, it should be clear that our approach also allows the formulation of general relational algorithms (like the computation of

Using our library, relational specifications can be checked in a high-level declara- tive style with minimal programming effort. We have demonstrated that different programming paradigms can benefit from each other. Functional programming can be made more efficient using constraint solving facilities and constraint program- ming can be made more readable by abstraction mechanisms provided by functional programming languages. Especially, higher-order functions and algebraic datatypes serve well to implement constraint generation on a high level of abstraction. Func- tional logic languages allow for a seamless integration of functional constraint gen- eration and possibly nondeterministic constraint solving with instantiation of un- known values.

