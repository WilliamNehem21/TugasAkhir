This work proposes a methodology for the rigorous development of Java Card smart card applications, using the B Method. Its main feature is to abstract the particularities of Java Card and smart card aware applications from the specifier as much as possible. In the proposed approach, the specification of the aplication logic needs not be preoccupied with the specific aspects of the Java Card platform (in particular, communication between the card acceptance device and the smart card itself). Platform-specific code can then be automatically generated during the refinement and code generation process. An interesting side- effect of this approach is that the specification may be reused with any other platform of implementation.

In this paper, we propose a specialization of the B methodology that aims at improving the productivity in the development of Java Card software. Previous work [16] showed the possibility to automatically generate Java Card code from B modules. However, this work is limited to the translation of the language aspects and ignores some important aspects of the Java Card platform, such as the commu- nication between the host application and the applet running on the smart card, leaving its specification and implementation as an additional burden to the designer. The goal of the research presented in this paper is to provide B design guidelines specific for the Java Card framework which make it possible to automate part of the specification and implementation needed to build the communication protocol between the card applet and the host application.

The paper is organized as follows. The fundaments are presented in Section 2 (overviewing smart cards and Java Card) and 3 (introducing the B method). The core contribution of the paper is in Section 4, where the application of the B method- ology to design Java Card components is presented. Section 5 concludes the paper with related work and some final remarks.

A smart card is a plastic card that looks like a common magnetic-stripe card, but that has embedded in it an integrated circuit with a microprocessor and memory. This kind of card offers several advantages compared with magnetic-stripe cards [10]. The most important advantage is the security in data processing and storage pro- vided by the smart card environment composed by operating system, microprocessor and applications. In application level, personal identification numbers (PIN) and cryptographic algorithms can be used to improve the security. Other advantages are storage capacity, millions of times greater than the capacity of magnetic-stripe cards; and the remote database query independence, once every data the card needs is found in its memories or is supplied by an external application.

Many applications can benefit from the use of smart cards. Telecommunication, financial and transportation industries and the health care sector are good examples. The secure transaction mechanisms and the elements for secure user identification and data storage, besides the mobility of the cards, make them an ideal platform for these applications.

The use of this technology brings many improvements for the developer of smart card applications. The ease of programming in Java, that abstracts the low level details of the smart card system; and Java development tools (like IDEs, simulators and emulators) allow a rapid application build, test and installation, reducing the time and the cost of software production. Moreover, other benefits are the possibility of multiple applications to coexist in a same card and the ample compatibility with smart card international standards, like ISO 7816.

Card Acceptance Device (CAD) A CAD is the device localized between the host application and the smart card. It supplies power to the card and is the means of communication between the host application and the application in- side the card. A CAD can be connected to a desktop or a terminal, such as an electronic payment terminal.

The communication between these environment items is performed through a half-duplexed protocol called Application Protocol Data Unit (APDU). An APDU message has the form of a data package exchanged between the host application and the application in the card in a master-slave architecture. The host application sends commands to the card application, that, in turn, sends back a response. The command and the response APDU  are the two protocol structures used to

A Java Card applet is a class written in the Java Card subset of the Java language that inherits the javacard.framework.Applet class. This class is a blueprint that defines some variables and methods of an applet [4]. It makes, for instance, the implementation of the install and process methods obligatory. The install method creates the applet by invoking its constructor method and registers it in the Java Card Runtime Environment (JCRE), by invoking the register method. The process method receives the APDU messages of the host application, does the initial pro- cessing of these messages, and invokes a method, passing to it the APDU object as a parameter.

respect to the corresponding machine. The IMPLEMENTATIONs are then checked for compliance with the code generator for a particular language and, if it is the case, programming code may be generated. Assuming the correctness of the code generator, the generated code can be guaranteed to satisfy the stated properties of the abstract specification (the MACHINEs).

Although we concentrate our introduction to the B notation on the more abstract specification (i.e. MACHINE), similar comments apply to the remaining levels. A B module contains two main parts: a state space definition and the available op- erations. It may additionally contain auxiliary clauses in many forms (parameters, constants, assertions), but those, essentially for practical purposes (i.e. to promote modularity, reuse, etc.), and do not extend the expressive power of the notation. In the remainder, we will restrict our discussion to the core clauses of the module specification.

The specification of the state components appears in the VARIABLES and IN- VARIANT clauses. The former enumerates the state components, and the latter defines restrictions on the possible values they can take. Essentially, if V denotes the state variables of a machine, the invariant is a predicate on V . Let us denote INV such invariant predicate. All verifications carried out throughout the development process have the intention of checking that no invalid state will ever be reached as long as the operations of the machine are used as specified.

This example was extracted and simplified from the Transport machine, the main machine of our sample transport application (Section 4.2.5). In this piece of code, we can see the machine name definition in the MACHINE clause. The state variable, named balance, is typed in the INVARIANT clause and initialized in the INITIALISATION clause. An operation, named addCredit, is used to add some positive natural value to the balance variable.

Smart cards store software components that are used by client applications, also called host applications, that communicate with the card via card acceptance de- vice. Due to obvious restrictions, the code embedded in smart cards has a simple structure. In particular, Java Card imposes stringent restrictions on the Java lan- guage, e.g. excluding complex data types and multi-threading. This is one of the scenarios for which the B notation is well adapted.

The B integer variables must be restricted to the range of some Java Card integer type, that are: byte, short. The int type is not supported in all Java Card implementations, for this reason it should not be used in a B specification. We provide the specifier with (B specification and implementation of) Java Card compliant data types.

Java Card programming style includes internally validating all parameter data for each operation, and exception raising each time a non-conformance is detected. Thus, the specification developer may need to include these exceptions. For that, he must define the API Exceptions machine and include it in the refinement. The API Exceptions machine must contain all the exception names in a enumerated set (called EXCEPTIONS by convention). At the API Exceptions implementation level, these constants will be implemented by natural values and, when translated into a Java Card class, a constant declaration will be generated for each exception element of the EXCEPTIONS set.

We provide a template for the API Exceptions machine, containing a vari- able to represent the last raised exception, an operation to raise an exception (setException, used in API FF.ref) and the set EXCEPTIONS. It is the responsibil- ity of the designer to define this set in this machine, or in the refinement API FF.ref (in this case the machine API Exceptions needs not be modified).

A translation step has then to be performed to convert the interfaces of op- erations to the Java Card style. This translation step takes as input API FF.ref and generates a new B machine that we call API JC.mch. Note that here we do not strictly follow the B development process as the result of the translation is a new B abstract machine. This machine is then refined and implemented, following the rules of B, into the B implementation corresponding to the code that is to be embedded in the card. This new machine is also imported by the implementation of the API on the host side to implement the variables of API.mch, as shown in Section

The API Process.mch defines a unique operation, named process, correspond- ing to the process method that every Java Card applet needs to implement, as explained in Section 2.2. This operation processes the APDU command in order to select which operation is to be executed. It uses data from the second machine, API Conversions.mch, in order to improve readability, staying at a higher level.

The API Conversions.mch machine specifies all encoding information of the application logic into bytes, the low level data that is communicated and manipu- lated in the Java Card platform. Its minimal contents are shown below, in the case where the only converted data is the operation names. Further encoding may be needed, e.g., for enumerated types, such as a type that defines a category of users. In this case, additional sets and translation functions have to be included and can be automatically generated using classic compilation techniques.

As stated above, from the original abstract specification API.mch a B implemen- tation API Host imp.imp is derived which translates the actions specified in each operation of API.mch into data that is used by the Java Card Runtime Environment (JCRE) to create APDU commands.

