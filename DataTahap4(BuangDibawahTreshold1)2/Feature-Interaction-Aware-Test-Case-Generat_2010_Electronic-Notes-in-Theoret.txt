In addition, model-based formal analysis methods can be applied to ensure func- tional correctness, either by formal verification, e.g. model checking, or by model- based testing. Testing approaches in general are not capable of ensuring the absence of failures, i.e. proving the functional correctness. The application of systematic tests aims at finding failures in the implementation by investigating whether the system outputs differ from those predicted by the test case, i.e. for a particular use

In general, two or more features potentially interact with each other if they access at least one shared system artifact. Depending on the abstraction level, such points of interaction can be sensors/actuators, components, runnables, values, etc. used for the realization of more than one feature. According to our system specification model, we characterize feature interaction by means of shared values. Two features f1 and f2 interact if:

Hence, f1 and f2 might modify v concurrently either affecting an internal control value, or the behavior of an actuator. Again, such interactions are often introduced by design and are synchronized properly, e.g. via control flags like cls status in the sample door system. Nevertheless, such patterns must be exhaustively validated to rule out unintended behavior. If both features become activated simultaneously,

i.e. orthogonal Stateflow (sub-) automata realizing different features that change the same value, contradicting forces can be injected to an actuator. A special case arises for two distinct actuators affected by different features that have contradict- ing effects on the environment. To detect such constellations, further knowledge concerning the environment may be necessary. In the door system example, both kinds of feature interactions are present as will be examined in the following section.

Transformation into a flow graph: Test case generation algorithms, e.g. for path coverage are primarily based on test models constituting basic data/control flow graphs. Therefore, Statechart-like formalisms leading to behavioral specifica- tions in terms of hierarchical automata are to be transformed (flattened ) first to be applicable as test models [5,11]:

influence each other via f2. Therefore, a corresponding test model is to be built by composing those of f1, f2, and f3. This can be generalized by not only intersecting pairs of FI, but rather all possible combinations, which will naturally lead to the test model for the complete system integrating all features. To what extent this process shall be performed can depend on decision criteria such as the safety level of features involved, the degree of coupling, i.e. the number of shared values, etc.

