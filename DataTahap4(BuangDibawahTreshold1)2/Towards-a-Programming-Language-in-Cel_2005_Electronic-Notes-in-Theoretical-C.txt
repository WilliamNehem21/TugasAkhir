In [3], a new model of computation within the framework of Natural Computing was introduced, called Membrane Computing. It starts from the assumption that the processes taking place in the compartmental structure of a living cell can be interpreted as computations. The computational devices of this model are called P systems.

In this paper we present a family of P systems that solves a numerical NP- complete problem, namely, the Partition problem. The design of this solution is inspired in several previous works on other problems, mainly the Subset- Sum and the Knapsack problems, but also the VALIDITY and SAT. The similarities between the design introduced here and the solutions presented in [5], [6], [8] and [10] will be highlighted and some conclusions will be extracted from them.

In our case, we have chosen the class of P systems with input and with external output (special objects Y es and No will be used to implement the boolean answer). In order to obtain a significant speed-up, we will work in a cellular model using active membranes, and so we are allowed to use membrane division to obtain in polynomial time an exponential workspace. We also impose some restrictions, for instance we want the systems to be confluent (all computations with the same input lead to the same output), also every computation must be finite and, furthermore, we want that the answer is delivered in the last step of the computation, by sending to the environment a special object Y es or No.

In the case of P systems with input and with external output, the concept of computation is introduced in a similar way but with a slight variant. We consider that it is not possible to observe the internal processes inside the P system, and we can only know if the computation has halted via some distinguished objects sent out to the environment. We can formalize these ideas in the following way.

If we wanted to perform such a solution of some decision problem in a laboratory, we will find a drawback on this approach: a system constructed to solve a concrete instance is useless when trying to solve another instance. This handicap can be easily overtaken if we consider a P system with input. Then, the same system could solve different instances of the problem, provided that the corresponding input multisets are introduced in the input membrane.

We will represent the instances of the problem using tuples of the kind (n, (w1,... , wn)), where n is the size of the set A and (w1,... , wn) is the list of weights of the elements from A. We can define in a natural way an additive function w that corresponds to the data in the instance.

A. Indeed, exactly the same two schemes of rules are used for the generation stages in the Subset-Sum and the Knapsack case. Here is how these rules work: in each step (according to the index of ei), we consider an element of A and either we add it to the subset associated with the membrane, B, or we put it in the complementary subset, Bc. Note that a membrane can proceed to the checking stage only after it gets negative charge; a positively charged membrane where the object en appears will get blocked (it will be dissolved, see rules in (i)).

These rules implement the comparison mentioned above (that is, they check whether w(B)= w(Bc) holds or not). They work as a loop that erases objects a and p one by one alternatively, changing the charge of the membrane in each step. Exactly the same method can be used to compare the multiplic- ities of whatever two objects of the working alphabet, so again we find rules that might be re-used when attacking other numerical problems.

Here we find the first important difference in the design with respect to the ones for Subset-Sum and Knapsack. There counters were used, and the schemes of rules depended on the number of steps that the checking was going to last. But now this number of steps depends on the total weight of the set A, and we cannot use this information if we want an uniform design. However, there are good news: the rules used here can be used also in general, so new versions of the solutions to Subset-Sum and Knapsack using this subroutine can be given.

Before the answer is sent out, the system has to make sure that all the relevant membranes have finished their checking stages. To do this, first we wait for 2n + 1 steps and then we activate the process. This needs to be done in order to make sure that the division process is over, and thus we know that from this moment on, the membranes that finish their checking stage, and only them, will have positive charge (see the rules in (f) and (g) for the end of the checking and note that we get rid of the spare membranes via the rules in (i)).

As we said before, we need to check if all the relevant membranes have finished their checking stages. This is done using the objects g that are present in the skin and the auxiliary membrane labelled by r (see the next set of rules). There must be 2n copies of g, because each relevant membrane sends one, and there is one relevant membrane for each subset of A, that is 2n in all.

Finally, the output process is activated. The skin membrane needs to be negatively charged before the answer is sent out. Object d2 takes care of this (see the previous set of rules) and then, if the answer is affirmative, an object Y es will be sent out recovering the neutral charge for the skin. Note that the answer Y es has some priority over the negative answer, in the sense that we first check if there is any object Y es and then, if it is not the case, the answer No will be sent out. This little trick of changing the electrical charge of the skin membrane and using the auxiliary object No0 is also used in the other two designs, so hopefully this feature can be also saved for future designs.

The generation and calculation stages end in a membrane when it gets negative charge for the first time, and we have at our disposal a witness- object q that appears in the membrane exactly in that moment. If we want to perform now the comparison between the multiplicities of two objects, we need to rename all the objects in the membrane, to make sure that there does not exist overlaping, i.e. we want to avoid nondeterminism. The renaming step depends strongly on the problem, because the new objects that are needed depend on how many stages we want to perform later on.

The next set of rules is (d). When these two rules are applied iteratively, a loop is created. The charge of the membrane changes from negative to neutral and back to negative in every loop, until one of the two objects that are being used is exhausted and the loop halts.

Observe that this time the scheme of rules does not depend on n, we just compare the number of occurrences of two objects, obj1 and obj2. The names of this objects can be customized, as well as the two charges that are used. We can again recall the design of the Knapsack in [6] as an example, because two checking stages were carried out there, with different objects and different charges, but the same changing-charge-loop design.

In this case, a division process is carried out at the beginning of the process to generate one membrane for each possible truth assignment of the n variables appearing in the formula. There, the electrical charges of the membranes in each step are meaningful, because they determine whether a variable will be assigned a TRUE value or a FALSE value. This strategy is very close to the one used in our generation stage.

to check that all the clauses are satisfied, instead of comparing the multiplic- ities of two objects. However, the method that is used to control when the checking stage ends is a counter in the skin, and this is also used for the nu- merical problems. Also the answering process is very similar, the object Y es gets some priority over the object No by means of a counter and of the electric charge of the skin membrane.

Up to now, the idea of a programming language has not been deeply discussed in the Membrane Computing area, but actually it is not hard to find some similarities between different designs conceived for different purposes. The use of the changes in the polarization (used in every design within the active membrane framework), the technique of working with indexed objects and making a rotation on the indexes (already used in [2], section 7.2, and later on by many other authors), the use of renaming rules in order to inhibit the evolution of an object until a specific instant in the computation (e.g., in [5] and [6]), and, of course, the use of counters (an indexed object that increases its index up to a certain value and then transforms into something different, see again [2]), among others. It is worth mentioning two examples of applying these strategies to the design of solutions for other numerical NP-complete problems: the multidimensional Knapsack problem in [1] and the Bin Packing problem in [7].

