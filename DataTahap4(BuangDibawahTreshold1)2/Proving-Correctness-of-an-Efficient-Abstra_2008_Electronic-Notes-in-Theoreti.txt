SMV [4], Spin [8] and Uppaal [9] work on models described in their proprietary spec- ification languages. Re-modeling existing systems in these proprietary formalisms is a huge effort. For existing systems, model checking of higher level programming languages (e.g., C, C++ or Java) is the more efficient approach, but when it comes to embedded software, many problems arise when model checking C programs.

Microcontroller programs written in C usually contain direct hardware accesses or embedded assembly statements. These constructs are not handled by existing C code model checkers (see [16]). Moreover, C code is first compiled into assembly code before it is deployed to the hardware. Hence, the C code is only an intermediate representation. The compiler could introduce errors that cannot be found in the original source code. In assembly code all errors introduced during the complete development process are present. Moreover, in contrast to C code, assembly code has a clean, formal and well documented semantics. Hence, model checking of assembly code (machine code) gets into focus of research, see [1,12,13,17,20].

However, when model checking assembly code state spaces tend to be bigger and the analysis is no longer hardware independent. In order to tackle these prob- lems, we have developed [mc]square 4 , which is a discrete, (mostly) explicit state, on-the-fly, Computation Tree Logic (CTL) [4] model checker. It is capable of model checking assembly code written for certain microcontrollers (ATMEL ATmega and Infineon XC167). We did not restrict the set of supported constructs. Hence, [mc]square can handle arbitrary assembly programs for those microcontrollers, sup- porting both low-level features such as direct or indirect memory access and source- level constructs such as recursion or functions. To address the disadvantage of being hardware-dependent, we developed an extensible architecture, which is de- scribed in [18]. To deal with the state explosion problem, we implemented different abstraction techniques in [mc]square. In this paper, we will show how prioritized interrupt levels can be used to abstract away from the concrete state of the interrupt bits of a microcontroller.

a simulation relation between the concrete trace of the system and the abstracted, nondeterministic traces, thus yielding an over-approximation of the real system be- havior. However, while over-approximating the concrete behavior, it is true that for every trace in the abstract space, there is a concrete system which will exhibit this behavior. As interrupts depend on the behavior of an external environment which is not under the control of the processor, this means that all errors found in the over-approximation can in fact also be traced back to the real implementation. After that, a case study is summarized which demonstrates the effect of interrupt nondeterminism on the state space size. In the end a conclusion is drawn and some potential directions for future improvements are shown.

Motivated by the observation that usually memory is the limiting factor in the ap- plication of model checking, many approaches have been developed to combat the state explosion problem (see [4] for an overview). The abstraction technique pre- sented in this paper, Interrupt NonDeterminism, is dynamically applied at runtime. To the best of our knowledge, no comparable approach has been developed so far to control the effect of interrupts in modeling embedded systems.

Symbolic simulation is another technique that is similar to the technique applied in [mc]square. Here, symbolic values are used in place of explicit values. In our approach parts of the states used can be symbolic, but whenever the simulator or the model checker needs to access symbolic parts of a state, these parts are instantiated, and hence, become explicit. All parts of a state that are not accessed remain symbolic. In [2], a symbolic simulator is used to verify hardware systems. Whenever an X (denoted by * in our approach) is accessed and a value is needed, new symbolic variables are added and simulation has to be repeated. In our approach a dynamic refinement is conducted. There are some approaches combining explicit and symbolic executions (cf. [6,22]), but these approaches employ explicit execution and symbolic execution in parallel.

Then, the static analyzer component starts inspecting the assembly program. During this analysis, it uses information from the formula object (registers, variables and memory locations used within the atomic propositions) to preserve validity of the results. In the first step of the static analysis, a Control Flow Graph (CFG) of the assembly program is created. This CFG is inter alia used by the counterexample generator to present counterexamples or witnesses. In the end, the static analyzer adds annotations to the assembly program which are used by the simulator to reduce

During state space building [mc]square uses different abstraction techniques to minimize the size of the state space. It is important to notice that all these abstrac- tions lead to a safe over-approximation of the concrete state space, establishing a simulation relation between the concrete and the abstract states (and thus preserv- ing the validity of ACTL formulae). One of these abstraction techniques is interrupt nondeterminism, which is detailed in this paper.

Now we will show how to use the general framework to model the ATMEL AT- mega16 microcontroller. The ATMEL ATmega16 has a 16K flash memory for pro- gram code, which corresponds to the location set Q. All special purpose register of the ATMEL are embedded into the data space, which has an address length of m := 2. As we focus on interrupt handling here, we will briefly describe the inter- rupt handling of the ATMEL and identify the special purpose registers within A that are essential for the interrupt handling.

In order to reduce the effort in model checking which comes from introducing non- determinism, we will show that for the interrupts, it is safe to make all interrupt bits below the current interrupt level nondeterministic. Assuming three interrupt levels stored in the lower three bits of the interrupt register, this means we can identify all states where these bits have the values 100, 110, 101, 111, which is a reduction of a factor 4 for the interrupt handling. In the general, we gain a factor or 2n for n interrupt levels, so for the ATMEL we gain a factor of up to 220.

To show this, we look at a fixed microcontroller MC = (A, Q, Ins, env, IH, q0, v0). The interrupt handler and the environment handler are defined as sketched above, thus implementing the interrupt handling model of the ATMEL. The instruction space can hold an arbitrary program.

This case study was first described in [15]. Here, we summarize the important details and reconsider the results under the aspect of DND for interrupts. In [15] only DND for values was considered. DND for interrupts was activated in all runs.

As DND for interrupts cannot be deactivated in [mc]square because its operation is essential for the model checking of programs using interrupts, we can only show the differences obtained by DND of values. These three programs all use interrupts. Without using DND for interrupts the number of states would be considerably higher and model checking of these programs would not be possible.

We can give some comments about the size of the state space when not using DND of interrupts. When using DND for interrupts, only enabled interrupts are fired by writing only possible value combinations into the flag registers. When not using DND for interrupts, all interrupts would be fired that have an active interrupt source by writing all value combinations into the flag registers.

The plant program consists of 225 lines of assembly code and uses two interrupts and one timer. The traffic light consists of 155 lines of assembly code and uses the same number of timers and interrupts as the plant program. The window lift has 289 lines of assembly code and uses again two interrupts and one timer. As all

program use the same number of timers and interrupts, we only detail one of them. The plant program uses one timer interrupt and one external interrupt. When using DND for interrupts, at most three combinations are written to the flag reg- isters: timer interrupt occurred, external interrupt occurred, and no interrupt oc- curred. This is only done when the corresponding interrupts are enabled. When not

using DND for interrupts more combination are written. In this case all interrupts are fired that have an active interrupt source. The interrupt source for the timer used in the plant program is actually the source for two different timer interrupts.

for interrupts, it would be fired. As all value combinations are written into the flag registers, at least nine combinations would be written. These nine combination would be created in every line of the program where the sources of the interrupts are active. The sources are active in almost all parts of the program including interrupt routines (in interrupt routines, other interrupts are usually deactivated). If nonde- terminism of values is involved (e.g., input from the environment) additionally, the

In this paper delayed nondeterminism for interrupts, which is an abstraction tech- nique implemented in [mc]square, was detailed and it was proven that DND for interrupts preserves a simulation relation. This is an important result as DND for interrupts cannot be deactivated by the user because this abstraction technique is too essential for [mc]square. Without this abstraction techniques, even small pro- grams using more than one interrupt could not be model checked. As [mc]square is a CTL model checker, simulation is needed to preserve the validity of formulas. The DND of values preserves a simulation relation (see [15]) and hence, the validity of ACTL formulas is preserved. Nevertheless, DND of values can be deactivated by the user if the over-approximation is too coarse.

In the future, we want to investigate if we can establish a bisimulation relation for DND for values. The copying of values destroys the bisimulation relation. If we introduce instances of nondeterminism and copy these instances, instantiation such an instance would have an effect on all the instances and preserve the bisimulation. However, we have to observe the effects on the size of the state space and the number of different nondeterminism instances. Another thing that we want to implement is a model checking algorithm for a three-valued logic. This would make it possible to make propositions about registers used within the DND abstraction technique.

for embedded systems. [mc]square can already handle programs of interesting size. Delayed nondeterminism is an abstraction technique that helps to tackle the state explosion problem. It can be combined with other techniques implemented in [mc]- square (e.g., path reduction and dead variable reduction). This technique can also be used for model checking software for many other microcontrollers. As we have experienced with delayed nondeterminism or path reduction (cf. [19]), there are abstraction techniques which perform better when model checking assembly code. Hence, we will focus future research on domain specific abstraction techniques.

