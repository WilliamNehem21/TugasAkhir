Although the Java code of an artificial environment can be written by hand [10], the preferred way is to generate it automatically from a high-level model of its behavior [20][14]. The model can be written by hand or constructed automatically, e.g., based on the behavior of the component subject to checking [5].

In this paper, we aim at efficient detection of concurrency errors (deadlocks, race conditions) in Java components using the Java PathFinder model checker (JPF) [22]. Therefore, in our case the challenge is to decide what the behavior of the artificial environment should be in order to make it possible for JPF to find at least some concurrency errors before it runs out of available memory or reasonable time due to state explosion. Note that although state explosion is typically caused by a high number of parallel threads in the program and/or by big data domains, we focus only on the level of parallelism, since big data domains are not a problem in our case (see the end of Sect. 1 for details).

method of a component for an arbitrary finite number of times, and in parallel with other calls of all the methods (including parallel calls of the same method). It allows JPF to find all the errors, and can be easily constructed in an automated way. On the other hand, it is not possible to use such an environment in most cases, since verification with JPF is then prone to state explosion due to high number of parallel threads, even if the well-known approaches for addressing state explosion are used.

currency errors in parallel execution of two or more instances of the same method. However, for simplicity we explain the algorithm only for a set S of methods. Gen- eralization to a list is straightforward, e.g. via adding different suffixes to elements that correspond to the same method. The actual process of model construction consists of the following four steps:

Given a Java class that implements a component, the analysis is applied sepa- rately on each method. It involves (i) construction of the control-flow graph of the method in a similar way to [23], and (ii) a linear scan of Java byte code instructions in each control-flow path, which identifies all shared variable accesses in the paths. An access to a shared variable is represented by any instruction that either reads the content of a variable from the shared memory or writes to such a variable. Since the number of shared variable accesses may differ over control-flow paths, we define the number of shared variable accesses for a method as an average of the numbers for all control-flow paths. Typically, the numbers for different control-flow paths are roughly the same and thus the average is a good approximation.

To answer these questions, we have performed a number of experiments on two real-life Java components. We have used the ConcurrentHashMap class (2000 lines of code (loc) in Java) from the implementation of the java.util.concurrent package in GNU Classpath (version 0.97.1) [8] and the Daisy file system [17] (800 loc), which was used as an assignment for the challenge problem at the CAV/ISSTA 2004 event

The Daisy file system contains concurrency errors prepared by author (S. Qadeer) in advance for the purpose of evaluation of various verification tools. In case of ConcurrentHashMap, we have manually injected an error (race condition) via re- moval of calls of lock() and unlock() in the size method.

The characteristics of each experiment that we measured are total time in sec- onds and amount of memory (in MB) needed by JPF. Total time includes the time needed to construct the artificial environment (and its behavior model, i.e. time needed to perform static analysis and compute the SVA metric) and time needed by JPF to find an error.

best option with respect to efficient detection of concurrency errors would be to use ordered pairs or ordered lists with those combinations of values of the SVA metric parameters that prefer extreme sharing (i.e. EES and EEN). Again, since the SVA metric is based on a heuristic, it is not realistic to expect that the combinations EES and EEN will give the best results for all components.

Similarly, we are not aware of any concurrency-related complexity metrics for modern object-oriented programming languages (C++, Java). Although there exist several approaches to measuring the complexity of concurrent programs in Ada ([11], [19]), none of them could be used instead of our SVA metric. In particular, they either measure the control-flow complexity of concurrent programs [11] or aim at Ada-specific constructs like active rendezvous [19].

Although the technique proposed in this paper aims at components implemented in Java, it can be ported to another programming language (e.g., C or C#), provided a model checker that supports verification of multi-threaded programs written in the language is available.

