UML is a widespread language used in both industry and academia, despite the fact that its semantics is still informal and allows ambiguities. On the other hand, OhCircus is a formal specification language which unifies Z, CSP, the refinement calculus of Morgan and object-oriented theories. In this work we integrate UML class diagrams and OhCircus by written UML elements in terms of OhCircus constructs. However, instead of a simply syntactical mapping, we also propose the concept of a class model to capture associations and global constraints. Finally, we use this integration to prove the refinement of associations as attributes, a result that relates analysis to design to implementation and which is very common in industry.

Among various initiatives to make Formal Methods more accessible and used in industry, the current research direction is using a graphical and appealing language, such as UML, to encapsulate formal notations. This is usually accomplished by providing a mapping to constructions of a (often informal) language into another, a more formal one [17,21,3,14]. Thus, popular modelling languages, well-known by developers, are mapped into more powerful and formal, designed without major conceptual restrictions (although some are necessary for their practical usage).

Our approach differs on treating UML in the same semantic level of the formal language. For example, UML classes are mapped into classes in our chosen lan- guage. Other works, like those from the most important group in the area, offer a denotational semantics of UML in Z [9,7].

This works is organised as follow. In Sections 2 and 3, we describe the main elements of UML class diagrams and OhCircus specifications, respectively. In Sec- tion 4, we present our first contribution: the translation of a UML class diagram into an OhCircus specification (where we show our concept of the class model). The second contribution appears in Section 5, where we address refinement in UML diagrams using associations-as-attributes. Finally, we present our conclusion and future works in Section 6.

UML is compound of several diagrams that express static and dynamic aspects of an application. Static aspects are related to the structure of the system, being true all the time. The purpose is to describe the entities of a system and how they will always be related. On the other hand, dynamic aspects refer to the evolution of the application: the creation and destruction of objects and their connections over time; formally, the transformations in the global state (the set of objects and relations) of the system.

Class diagrams are the most common diagrams used in software development pro- jects. They model concepts from the domain of the application and the structural aspects of the system using classifiers and relationships as their building blocks. They are also named static view, representing information that never changes.

Multiplicity imposes a constraint on the number of entities of an endpoint that are related to a single element of the other. The cardinality of this set can also be expressed using ranges. For instance, consider the owns relationship, where we can relate a Person to zero or more (0..* ) instances of Account ; and for each instance of Account it must relate one or more instances of Person. The latter constraint enforces that every account must have at least one owner.

Navigability defines visibility for associations. The entity in one endpoint is seen by the opposite entity if the association between them is navigable; otherwise, that entity cannot state anything about the instances to which it is associated. Navigability is no further discussed.

Generalisations capture inheritance relations between a more general class (su- perclass) and a more specific one (subclass). In fact, all members held by the superclass are inherited by the subclass. This relationship also states that every instance of the subclass is also an instance of the superclass. It is worth noting that we are interested only in simple generalisations, where classes can have only one superclass.

In OhCircus, a class declaration is introduced with the keyword class, followed by its name and the optional clause extends. This last part enables inheritance between classes; if omitted, the class inherits from the special class object. In this example, CreditAccount extends (inherits from) Account .

The state clause indicates the schema which defines the state of a class. This schema is similar to that of Z, though its variable declarations can also contain qualifiers. If nothing is said, fields are assumed private. We can also declare them as protected or public. Despite its stated semantics, the modifiers do not constrain the access to the fields in OhCircus.

Implicitly, the CreditAccount state inherits all fields and invariants declared in the state of its superclass. Moreover, new fields and invariants can be defined. For example, the CreditAccountState introduces a new private field, credit, and states that the sum of balance and credit cannot be negative. Note that the invariant is made up of fields from the subclass and also from the superclass.

Methods are differentiated from other paragraphs by the use of private, protected, public, or logical qualifiers. The first three are directly related to the visibility of the method, again with standard meaning. The logical methods are just specific- ation artefacts, useful for the calculation of complex expressions, for instance, but not necessarily present in the implementation.

Our solution to these problems is the introduction of a class named Model, responsible for capturing all the structure of a class diagram: the sets of instances of classes, the relationships, and the global invariants. We believe that this approach offers a more abstract view of the class diagrams when compared to others ([6,15,3]), which only consider the representation of the classes, capturing associations directly through fields and ignoring global invariants. Note that the class Model is not part of the class diagram itself; it arises from our interpretation of the diagram. Thus, it is a kind of meta-class.

For mapping inheritance, one must include, in the OhCircus representation of the subclass, the extends clause followed by the name of the superclass. Moreover, an invariant in the class Model must assert the inclusion of the elements from the set of instances of the subclass into the set of instances of the superclass. In the following example, the invariant ensures that the elements of creditAccounts are also values of accounts.

links them all. Such fields are only syntactic sugar, because the consistency of the association is maintained by a relation in the class Model. However, they are neces- sary because the UML semantics allows statements about the classifiers to which a class is associated. Lastly, constraints are also established regarding multiplicity.

mix fields and associations in ones that have only fields, bringing them closer to implementation. However, the support provided by a theorem prover is a very important feature to guarantee the correctness of a demonstration, and OhCircus still lacks it. In the other hand, OhCircus has the refinement theory of Z, which has the support from Z/EVES. Thus, we chose Z to specify our model.

In this subsection, we will present the two class diagrams related to abstract and concrete models. In our mapping, each one of these class diagrams introduces a class Model in the specification. These classes will serve as the state of the specifications and their (meta-)operations will be refined.

The operations identified by the classes ModelR and ModelA change the sets of instances and associations of a diagram through the addition and removal of elements, in a similar approach to the one reported in [15]. However, since the representation of the sets does not change from one diagram to another, it is trivial to prove its refinement. So, we are interested only in the operations of addition and removal of an association pair. The steps of the proof can be seen in [1].

In this work we considered the UML formalisation using the formal specification lan- guage OhCircus. Although not exhaustive, we dealt with the most important UML static constructions. The originality of the approach, where we connect isolated ele- ments of other works, and also our contribution to support the use of associations and their representation as fields are the main points of this paper.

The second contribution of this paper is the analysis of refinement in UML. In particular, the class Model allowed exploring the same refinement theory of Z, where there is only one (global) state and operations that act over it; this gave us a direct tool support. The case study was the previously discussed representation of associations as fields, and our contribution was that the representation of fields is a refinement of the one with associations.

Related works to refinement are also important. The formal proof, using this mapping, of the validity of design patterns is an example of relevant contribution to the area of software engineering. Other refinements can be inspected, like the transformation of bidirectional associations into unidirectional ones and the inclusion or removal of a class from the model, proposing, for example, a set of transformation laws to UML models.

