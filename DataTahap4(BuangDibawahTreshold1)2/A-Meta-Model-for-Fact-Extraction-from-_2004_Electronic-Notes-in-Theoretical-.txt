Fact extraction by parsing is often the first step when analyzing a software system in a reverse engineering context. Essential to a fact extractor is the underlying meta-model, which specifies the elements and relations to be extracted. In this work we will introduce a meta-model for the Delphi programming language. The meta-model will be compared against the Dagstuhl middle model (DMM) and reasons for the development of an additional meta-model will be given. Furthermore, we will report on our first experiences with a fact extractor currently under development. We evaluate our fact extractor with two software applications that were developed in the open source community. In particular we give numbers and examples to point out the capabilities and the not yet resolved open issues of our fact extractor and we will reflect our experiences made during the case studies.

Reverse engineering and especially architecture recovery aim at extracting higher-level representations (e.g., the software architecture [6]) directly from the software system (i.e., the source code) in order to support developers in assessing, maintaining, and evolving large-scale software systems [2]. To pro- duce such architectural views current reverse engineering tools process various artifacts available for the system under study such as source code, scenario profiles, documentation, domain information and expert knowledge.

Fact extraction from source code aims at the finding pieces of information about the system (e.g., a fact is that a class is named Class-1 or that function- A calls function-B). It is a fundamental step for reverse engineering techniques and often has to be performed as a first step [4,7,8,11,13]. That means, before performing any high-level reverse engineering analysis or architecture recov- ery activities, available information in the source code has to be extracted and aggregated in a fact base or repository. Such a fact base then can be the basis for further analysis or recovery tasks.

The remainder of this position paper is structured as follows: Section 2 gives a short overview about the Delphi programming language and compares it against the well-known programming language C++. Section 3 describes our Delphi meta-model, which underlies our fact extractor. The entities and relations, which we want to extract, are presented there. The fact extractor (although still in development) is validated preliminarily with two case stud- ies in Section 4. Then Section 5 discusses related work by comparing our work against a language independent meta-model, namely the Dagstuhl mid- dle model. Section 6 presents our future work in this area. Finally, Section 7 summarizes our work and draws some conclusions.

C++ has two different types of files: implementation (.c or .cpp files) and header (.h or .hpp files) files. Header files specify interfaces and data struc- tures that can be imported by other files. In Delphi, there is only one type of file, .pas files, which contains sections for interface definition and an implementation, both only separated by special keywords.

In our case studies, we analyzed a Model Scene Editor (MSE) [12] anda SQL Parser (SQLP) [15] both are open source projects of the Delphi community. MSE is a 3D Scene Editor supporting POVray V3.1 and other formats such as VRML and DirectX. It consists of 113 files and approximately 37 KLOC. SQLP (version 0.01 alpha) is a string parser that is capable to parse SQL statements into tokens, to change these tokens and to rebuild (modified) SQL statement. It consists of 32 files containing about 7 KLOC.

Our fact extractor only recognizes calls to libraries and third party software when we have access to the source code of this software. There might be situations in which an entity in the source code depends somehow upon some other entity defined in a library (e.g., inheritance). This leads to a lack of information. For this reason, it is also possible that some information (elements and relations) could be missing, unless the source code of such a library is available.

The DMM does not fully support the Delphi programming language, which is needed for our work. In detail, DMM supports neither namespaces (units in the Delphi context) nor properties. We consider these two elements as important concepts of the Delphi language, which are supported by our underlying meta-model. Therefore we miss as well the distinction between application units and third-party library or system units.

Since the DMM is aimed to be language independent, it has to take care of elements and relations that are not needed for fact extraction from Delphi source code. The three hierarchies allow more details to be represented, but this brings an increased complexity into the meta-model. Our meta-model is targeted directly to Delphi and has to support only our needs so that we have sufficient information for our future reverse engineering tasks.

We will conduct further case studies to validate the abilities of our fact ex- tractor, and since the fact extractor is based on the introduced meta-model, this will be checked as well. And it is already planned that we apply the fact extractor in architecture recovery projects. We will use the low-level informa- tion about the software system to facilitate the recovery and documentation of the software architecture.

