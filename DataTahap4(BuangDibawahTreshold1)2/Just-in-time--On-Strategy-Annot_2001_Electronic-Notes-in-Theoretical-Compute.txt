A simple kind of strategy annotations is investigated, giving rise to a class of strate- gies, including leftmost-innermost. It is shown that under certain restrictions on annotations, an interpreter can be written which computes a normal form of a term in a bottom-up traversal. The main contribution is a correctness proof of this inter- preter. Furthermore, a default strategy annotation is provided, called just-in-time, which satis es the criteria for the interpreter. The just-in-time strategy has a better termination behaviour than innermost rewriting for many interesting examples.

A natural way of normalizing the term if (p; q; r) is to rst normalize p, and then try rule  or . This procedure avoids unnecessary reductions inside q or r. In some cases, this could even prevent non-terminating computations. If the rst argument doesn't reduce to T or F (for instance because p is an open term or because some rules are missing), the second and third argument must be normalized, and nally the last rule  is tried. The sketched procedure can be very concisely represented by the following strategy annotation for if :

We say that rule  and  need the rst argument, because they match on it. Rule  needs the second and third arguments, because it compares them. We say that the annotation is in-time because the arguments of if are evaluated before the rules which need them are tried. We say that this annotation is full because all argument positions and rules for if occur in it. Another full and in-time annotation for if would be [1; 2; 3; ; ; ], de- noting the left-most innermost strategy. We will de ne a default annotation, which evaluates all its arguments from left to right, and tries to apply a rule as soon as its needed arguments are evaluated. We call this default strategy

All mentioned strategy languages are far richer than the annotations stud- ied in our paper. Those systems advocate a separation between computations (rules) and control (strategies). By writing strategies the user can freely choose when the rules are applied. Important applications are the speci cation of pro- gram transformations. However, these strategies are not always complete, in the sense that a strategy might terminate in a term that still contains redexes. As far as we know, no analysis exists whether subclasses of these strategies are complete, which is an important issue if one is interested in nding normal forms.

Members of the OBJ-family [9,16,18] have strategy annotations that are similar to the ones discussed in our paper. In OBJ an annotation is a list of integers. Similar to us, +i denotes the normalization of the i-th argument. There are two di erences. First, instead of mentioning rules individually (our

more re ned notion allows to assign a priority in applying the rules. Avoiding repetitions of 0 (which would lead to multiple calls to the matching procedure), in OBJ the only full and in-time annotation for the three if -rules mentioned before is the strategy [1; 2; 3; 0], which corresponds to innermost rewriting. The second di erence is that OBJ allows i, denoting that argument i is only normalized on demand (i.e. if it is needed for matching with another rule). Such annotations specify lazy rewriting, which we have not studied.

The default strategy of CafeOBJ is similar to our just-in-time annotation. We cite from [16, p. 83]: For each argument, evaluate the argument before the whole term, if there is a rewrite rule that de nes the operator such that, in the place of the argument, a non-variable term appears. We added to this: \or if in the place of the argument, a non-left-linear variable occurs". This extra condition is necessary for obtaining the completeness result of our paper. It is

All normalization functions we found in the literature, e.g. [18,15,17] are presented with some memory (either by labeling or by using non-tail-recursive calls). Our correctness proof provides the extra information that the inter- preter actually follows a certain memory-less strategy, even in case of diver- gence.

We take standard de nitions from term rewriting [11,1]. We presuppose a set of variables, and function symbols (f ), each expecting a xed number of arguments, denoted by arity(f ). Terms are either variables (x) or a function symbol f applied to n terms, denoted f (t1;::: ; tn), where n is the arity of f . With head (t) we denote the topmost function symbol of t.

if p is a position in t (see [1] for a formal de nition). In that case, tj" = t and f (t1;::: ; tn)ji:p = tijp. With t[s]p we denote the term t in which tjp is replaced by s. We write p  q if p is a pre x of q (i.e. p:p0 = q for some p0 ).

A rewrite rule is a pair of terms l 7! r, where l is not a variable, and all variables occurring in r occur in l as well. A term rewrite system (TRS) is a set of rewrite rules. A substitution is a mapping from variables to terms, and with t  we denote the term t with all variables x replaced by  (x). A TRS R induces a rewrite relation on terms as follows: t !R t[r ]p if and only if tjp = l for some rule l 7! r 2 R. In this case l is called the redex and r the contractum, and the pair (l ; r ) is called a rewrite in [11]. A normal form is a term t which contains no redex. Note that a redex may have many occurrences in the same term, so in order to uniquely identify the rewrite step, we also need a position p. From the position p the redex l can be reconstructed. For this reason, it is convenient to call the pair (p; r ) a rewrite of t.

An index i is needed for a left hand side f (l1;::: ; ln), if li is not a variable, or if it is a variable which occurs in lj, for some j 6= i. Index i is needed for rule  : l 7! r if i is needed for l. A strategy annotation L is full for f , if for each i with 1  i  arity(f ), i 2 L and for each rule  : l 7! r 2 R with head (l) = f , 2 L. A strategy annotation L is in-time, if for any and i such that L = L1 L2 iL3 , i is not needed for . In a full and in-time annotation all needed positions for occur before . The distinguishing feature of the notion `needed' is as follows:

We now de ne the strategy associated to a strategy annotation. A strategy can be viewed 1 as a partial function that given a term t, yields some rewrite of t, i.e. a pair (q; s) such that tjq = l and s = r for some rule l 7! r and substitution  . In this case t !R t[s]q. Alternatively the function may yield

  Assume that t = l for some rule  : l 7! r. Then, by induction on L one can show: \if  2 L then rewr1 (t; L) is de ned". By fullness,  2 strat (t), so rewr1 (t) = rewr1 (t; strat (t)) is de ned.

  Assume that tji contains a redex. Then using the induction hypothesis, one can show with induction on L: \if i 2 L, then rewr1 (t; L) is de ned". By fullness, i 2 strat (t), so rewr1 (t) = rewr1 (t; strat (t)) is de ned.	2

immediately applicable. After reduction of T ^ T ,  and  will not be tried again. So under this annotation, norm(if (T ^ T; x; y)) = if (T; x; y), which is not normal. Similarly, [1; ; ; ; 2; 3] is not in-time, because  is non-linear in its second and third argument. Under this annotation, norm(if (x; T ^T; T )) = if (x; T; T ). This is not normal, due to the fact that  was tried too early. Finally, [ ; ; 2; 3; ] is not full, because argument position 1 is missing. Under this annotation norm(if (T ^ T; x; y)) = if (T ^ T; x; y), which is not normal.

These examples show that the conditions cannot be dropped in general. In certain cases they could be weakened. For instance in : f (x) 7! g(x), the annotation [ ] is not full, but this is harmless because  applies to any term with head symbol f . This weakening is inessential, because the behaviour of the interpreter is exactly the same as with the full strategy [ ; 1].

From this explicit de nition it is easy to guess the next rewrite that norm2 will take, given the current state (stack) S. This gives rise to the following de nition rewr2 (t; S). The result will be either ?, or a triple (q; s; T ), where (q; s) denotes the rewrite as previously, and T is the stack after replacing t[s]q.

 ned below). Then we show that in fact rewr2 is actually independent of the current state, i.e. rewr2 (t; S) = rewr2 (t; [("; strat (t))]) for all stacks S encoun- tered (Lemma 3.5). Finally, we show that rewr2 (t; [("; strat(t))]) = rewr1 (t) (Lemma 3.6).

Starting with stack [(p; L)jS] and term t, rewr2 reduces in a number of steps to (q; s; R). The proof proceeds by mimicking this reduction starting with the same stack in term t[s]q. The proof is by induction on the number of recursive calls of rewr2 (t; [(p; L)jS]) to (q; s; R).	2

We have constructed a C-implementation of the function norm, which acts as an interpreter of a given TRS annotated by some strategy. As a default, the system computes the just-in-time strategy during initialization. We rst describe this annotation, and then mention some implementation issues.

The just-in-time strategy is de ned as follows. For any function symbol f , with arity n, take the list [1;::: ; n]. Next, insert each rule  directly after the last argument position that it needs (due to matching or non-linearity). If several rules are placed between i and i + 1, the textual order of the original speci cation is maintained.

We now shortly mention some well-known implementation issues. First, a rule  : f (x) 7! g(x; x; x) with annotation [ ; 1], would copy all redexes in x three times. Therefore, in our implementation we use maximally shared terms (DAGs), in which x occurs only once. The implementation uses the ef-

Another issue is that in a rule  : f (x) 7! g(x) with annotation [1;  ], rst x is normalized by f to n, and then g(n) is called. Because g doesn't know that n is normal, it will traverse the whole n. To avoid this, all subterms which are known to be normal are marked. So g will get a marked argument, which it doesn't traverse. If the annotation would be [ ; 1], as with the just-in-time strategy, g would get x unmarked. A similar approach can be found in [18].

Finally, consider the rule  : f (x) 7! g(h(x)). In innermost rewriting,	x can be normalized, passing the result to function f . Then f calls function h and g, respectively. These functions expect normal forms as arguments. Note that the term h(x) is not actually built by f .  With the annotation [ ; 1] this is not possible. We have to build at least the term h(x), which must be passed to g before normalization. At this point we have to face some

(If the rules are non-root-overlapping, \strongly" could be dropped). This would be an important result, implicating that a rewrite implementation can make the transition from leftmost-innermost to just-in-time rewriting, without repercussions for the users. The improvement would be conservative, in the sense that all previous examples still terminate, and some more.

proof along the lines of [8,6,7], which failed. After a recent implementation of this strategy I tried a new proof of correctness. I thank Stefan Blom, Mark van den Brand, Jozef Hooman, Bas Luttik, Vincent van Oostrom and Hans Zantema for inspiring discussions and helpful hints. Finally, the referees were very helpful, by pointing out related work.

[17] M. Nakamura and K. Ogata. The evaluation strategy for head normal form with and without on-demand ags. In K. Futatsugi, editor, The 3rd Int. W. on Rewriting Logic and its Applications (WRLA2000), volume 36 of Electronic Notes in Theoretical Computer Science. Elsevier, 2001.

Let strat be in-time, let [(p; L)jS] be a well-formed stack, and assume that rewr2 (t; [(p; L)jS]) = (q; s; R), where q 6 p. We now have to prove the follow- ing: rewr2 (t; [(p; L)jS]) = rewr2 (t; S). This is by induction on tjp and within that on L. We proceed by case distinction on L.

 If q > p, then q = p:i:p0 for some i; p0 . In this case i 2 L, because p:i will not be revisited from S by the well-formedness of S. Because L is in-time, argument i is not needed by rule l 7! r, so by Lemma 2.1, t[s]qjp 6= l , for any .

