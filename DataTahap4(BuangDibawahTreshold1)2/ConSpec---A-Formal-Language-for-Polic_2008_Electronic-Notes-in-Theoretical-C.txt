The paper presents ConSpec, an automata based policy specification language. The language trades off clean semantics to language expressiveness; a formal semantics for the language is provided as security automata. ConSpec specifications can be used at different stages of the application lifecycle, rendering possible the formalization of various policy enforcement techniques.

As mobile devices become increasingly popular, the problem of secure mobile appli- cation development gains importance. Mobile devices contain personal information, which users desire to protect. They also provide access to costly functionality, such as GSM services and GPRS connections. Hiding these resources from third-party applications would largely handicap application development for mobile platforms. It seems necessary to provide controlled access to the sensitive resources through fine-grained, at times application specific, constraints on execution.

We describe first how security specifications can be enforced at the three stages of the application lifecycle: the development, installation and runtime phases. The goal is to combine static verification and monitoring so that security properties are enforced on mobile devices in the most effective way. We associate with the application a contract [4], a piece of data that describes the intended security- relevant behavior of the program. The contract simplifies tasks related to security enforcement. In this sense, our framework is similar to that of model-carrying code (MCC) introduced by Sekar et al [15]. In MCC, verification is based on a model of the program that is simplified to represent only security-relevant behavior, while we do not necessarily obtain contracts by extraction.

A framework which spans different stages of the application lifecycle and com- bines different techniques for ensuring compliance benefits from a common language for policy specification. In turn, the different aspects of the framework imposes dif- ferent restrictions on such a language. The main contribution of this paper is the language ConSpec (Contract Specification Language) which can be used for spec- ifying both user policies and application contracts. A semantics for ConSpec is provided and the formal treatment of several activities in the framework is briefly explained based on this semantics.

Development phase  We assume that the developer is aware of typical secu- rity policies and is willing to keep his application in conformance with them. From the policies he learns which actions of the application are security-relevant. Using this information he provides the application with the contract, which specifies the intended security-relevant behavior of application. At this phase, the policy lan- guage is used for expressing this contract. The compliance of the contract and the application can be checked, for instance, using static verification by a trusted third party, who then signs the application and the contract by its private key. This analysis is performed by powerful machines rather than the mobile devices, and can make use of knowledge available to the developer (e.g. program specifications, annotations derived from the source code etc). Instead of signing the application with a private key, proof-carrying code method [13] can be used to convey assurance

in program-contract compliance. The application and the contract are supplied with an easy-to-check proof of their compliance. If contract compliance can not be statically verified, then an execution monitor can be inlined in the program at this stage so that the compliance is ensured at runtime.

In our example scenario Alpha and Beta are not aware about the particular limit of SMS messages that Alice allows. But they know that the number of messages matters. Therefore, Alpha supplies the Weather application with the contract that the application sends only one message per day. However, Beta developers cannot tell in advance how many messages their application sends per day. For this reason, the contract for their application is more complex. It tells that the application will send one message to every contact from the address book that has a birthday.

Runtime At runtime, the behavior of an application may be checked against a policy by monitoring. Because of the performance overhead created by monitoring, it is preferable to use static methods described above and leave as little work to runtime as possible. But in many cases, the application of other techniques is not feasible (or not even possible due to, for example, the unavailability of the source code), and runtime monitoring is the only solution to protect a system.

ConSpec is strongly inspired by the policy specification language PSLang, which was developed by Erlingsson and Schneider [5] for runtime monitoring. PSLang poli- cies consist of a set of variable declarations, followed by a list of security relevant events, where each event is accompanied by a piece of Java-like code that specifies how the security state variables should be updated in case the event is encountered in the current state. PSLang policies make monitor inlining simple: the updates provided by the user can be almost directly inserted into the target program. How- ever, this leads for making specifications less formal. A policy text is intended to encode a security automaton: the state variables represent the automaton states and updates represent transitions. While this intuition is given, the exact way to extract the automaton from a PSLang policy is not provided. Such a task is not trivial due to the power of the programming language constructs that can be used in the updates.

while the guard selects the states, which the particular update will apply, as a subset of all states. The guards are considered from top to bottom. In case none of them is true, there is no transition for that action from the current state. If an ELSE block is present, however, the update of this block is executed in case none of the guards above it are satisfied. The guard is a side-effect free boolean expression which can mention only the set of argument values (and the return value for the case of AFTER modifier), and the security state. The update block begins with declarations of the local variables, which have the current block as their scope. A list of assignments to local variables and security state variables follow the declarations. If no assignments are present, the update block consists of the statement skip.

Monitoring  Given a program and a ConSpec policy with scope Session, the concept of monitoring can be formalized by defining the co-execution of the corresponding ConSpec automaton with the program. Such co-executions are a subset of the set of interleavings of the individual executions of the program and the automaton. Co-executions satisfy the following condition: when the execution of the program component is projected to its security relevant action executions, each before action is immediately preceded by a transition of the automaton for the same action; dually, each after action is immediately followed by a corresponding automaton transition. Therefore it is simple to show that the program component of the co-execution adheres to the given policy, as the co-execution includes an accepting trace of the automaton for the program execution.

Monitor Inlining Inlining a ConSpec policy with scope Session can be per- formed similar to inlining a PSLang policy (see [6,5] for details). A class definition is added to the target program which stores the security state variables. Then the program is rewritten so that each security relevant method call is wrapped with code compiled from the corresponding event clause(s) of the policy. Such a code segment evaluates the guards of the event clause from top to bottom and executes the updates associated with the first guard that is satisfied. If none of the guards evaluate to true, the program is terminated. The modifier of the event clause deter- mines where this segment is placed relative to the method call. The correctness of such a monitor inlining scheme can be proven by setting up a bisimulation relation between the states of the inlined program and the states of the co-execution of the original program with the ConSpec automaton (of the policy).

There exists a number of automata-based languages for security policy specification. Amongst these, ConSpec is closest to PSLang [5] which has also introduced the modifiers used in ConSpec. The language is intended solely for runtime monitoring and freely uses programming language constructs such as abstractions and functions. This enables a larger class of policies to be specified but also complicates the task of providing a formal semantics. Since the authors do not provide such a formalisation, their monitor inlining algorithm for PSLang is to be trusted on intuition as no proof of its correctness can be constructed. The Polymer language [2] has the same drawback. Polymer policies consist of Java classes which, when inlined, may trigger various actions in case of violation. For instance, it is possible to execute some recovery action as a response to the violation, after which the application is allowed to progress. Polymer policies implement edit automata [12], which extend security automata. But the correctness of the Polymer policy inlining cannot be proven either, as its semantics is not formally presented.

