This paper takes first steps towards a formalization of graph transformations in a general setting of inter- active theorem provers, which will form the basis for proofs of correctness of graph transformation systems. Whereas graph rewriting is usually performed by mapping a pattern graph into a source graph by means of a graph morphism and then carrying out operations on the image node and edge set, this article generalises the notion of pattern graph to path expressions, which are formulae in a fragment of first-order logic. We examine the correspondence with traditional graph rewriting and show that this interpretation is beneficial when formally reasoning about model transformations with the aid of proof assistants.

[7] aims at a logical characterization of graph transformations, where effective veri- fication of structural properties is not a primary concern. Usually, however, graph transformation systems are perceived as extensions of term rewriting systems, so much of the effort has gone into investigating specific properties such as conflu- ence and termination [17], which does not necessarily allow to determine whether a graph has a certain shape after transformation. These questions may be answered for graph replacement systems having a restricted structure [11], for properties ex- pressed in specialized logics such as monadic second order logic [13] or type systems [5]. There are automated approaches based on model checking [23], which however can only handle graphs with an a priori bounded number of elements. [18] presents techniques for dealing with specific structural properties such as multiplicities.

Path formulae can be understood as formulae over a fragment of first order logic (possibly including transitive closure), which are interpreted over graphs. Deter- mining whether a graph satisfies a path formula is decidable, which is indispensable for effectively applying a transformation rule to a given graph. On the downside, validity of path formulae may not be decidable, so that interactive proofs become necessary.

The paper is structured as follows: In Section 2, we informally introduce gen- eralised graph transformations. The formal model is presented in Section 3. In Section 4, we show how we can recover the traditional model of graph rewriting. We take a glimpse at how to reason about graph transformations in a proof assistant in Section 5 before concluding with an outlook on future work.

Duplication proceeds in several steps: First, we mark all nodes of the original graph with Orig nodes. We then create a duplicate node for each original, memoris- ing the relation between the original and the clone with a Cp edge. We can similarly reproduce the edges of the original graph in the copy. All that remains to be done now is to erase the auxiliary marking.

How do we formalise the marking phase, i.e. the first step of our transforma- tion? For the time being, we use a semi-formal notation that should be intuitively understandable. Precise definitions of graphs and path formulae will be presented in Section 3.1 and Section 3.2, respectively.

The action part (not shown here) expresses what we do if F is satisfied for a node n: We generate a new node, say m', having type Orig, and we create an Or-edge (m', n). We will come back to this example in Section 3.3.

expressible in traditional graph rewriting approaches. We assume to have a number of Root objects and a number of Node objects. Root objects are linked to Nodes through rn edges, Nodes are linked among themselves through nn edges. Any Node not accessible from a Root is considered as garbage.

Our purpose is not to formalize any particular approach to graph rewriting, such as the one based on category theory. Our model is set-theoretic. Roughly, graphs are composed of a finite set of nodes, a finite set of edges and a typing of the nodes.

In the following, we present a logic of path formulae, which we have found useful for expressing interesting properties (see the discussion in Section 4). However, there is no intrinsic reason to adopt precisely the language constructors we have selected, and the decidability of the logic, as well as the complexity of model checking, is greatly influenced by this choice. Similar notions can be found in [24,13,19].

With the above, other connectives and the existential quantifier Ex-form can be defined as abbreviation. Universal quantification does not use a named, but rather a positional representation of variables (de Bruijn indices, [8]). Thus, variables are not identifiers, but just numbers.

Model checking of node set and path expressions, i.e. checking that a graph gr satisfies a node set or path expression, reposes on well-known graph algorithms. Universal quantification is relativised to the node set of the graph, which is finite by well-formedness of graphs. Therefore, checking a universal formula only has to examine a finite number of elements.

The applicability condition is just given by a path formula, as outlined in the previous section. Note that this path formula may contain free variables, for example n in G(n) of Section 2, which can be understood as references to nodes in the source graph. Of course, in its coding as path formula, the free variables are numbers.

of the rule is node 0. No nodes and edges are deleted, a node numbered 1 is generated and an Or edge is added between node 1 and 0. (The syntax for update of function f at x with value y is f (x :=y ).)

For graph transformations to make sense, the references to nodes to be deleted have to be among the references to nodes in the applicability condition (thus, to the free variables of the applicability condition), whereas references to generated nodes should not occur in the applicability condition. We only generate a finite number of nodes in each transformation step, and to all of these nodes we assign a type. Similar constraints hold for deleted and generated edges. To summarise, structural well-formedness of a graph transformation is expressed by the following predicate:

having no nodes in common with the nodes of the source graph. We have adopted a deterministic solution: The nodes freshly allocated are numbered m +1 through m + k, where m is the maximal number present in the node set of graph gr and k is the cardinality of the ngen-set. All this is hidden in the definition of gt-gen-nodes. However, we only exploit the property that the fresh nodes do not occur in the original graph, and that there is a bijection b between the ngen-nodes and the fresh nodes.

path formula, and its range has to be a subset of the nodes of the graph. Most importantly, the path formula has to be satisfied in the graph when interpreting its free variables by the graph morphism in the given graph. (the is the left inverse of Some, thus the (Some x ) = x ).

{P } c {Q } to express that statement c establishes the postcondition Q provided the precondition P and some invariant well-formedness conditions W hold. W is typically the predicate struct-wf-gr that we have shown to be invariant under application of graph transformations in Section 3.6. Furthermore, the statement c usually contains annotations corresponding to loop invariants.

Suppose we want to show, for our example program, that all nodes of type Node are correctly marked, i.e. have exactly one incoming Or edge, provided that in the outset, these nodes had zero or one incoming Or edges. Let us first define nset as the set of nodes in a graph having a given node type:

Our path formulae are very expressive, which has the downside of leading, in general, to undecidable verification problems. As we want to reduce the amount of human proof effort as much as possible, we intend to address this topic in future work, by developing specialized analyses for fragments of our logic. In fact, our path formulae resemble path expressions used in shape analysis for pointer programs [24,13], other subsets have been identified in the context of description logics [12]. A detailed comparison of these approaches still has to be done.

