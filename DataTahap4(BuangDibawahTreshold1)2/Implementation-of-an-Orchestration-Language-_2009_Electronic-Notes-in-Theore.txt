The present paper addresses this problem with an implementation of the orchestration language Orc as a domain specific language in Haskell. Orc was, therefore, realized as a combinator library using the lightweight threads and the communication and synchronization primitives of the Concurrent Haskell library. With this implementation it becomes possible to create orchestrations that re-use existing Haskell code and, conversely, re-use orchestrations inside other Haskell programs.

The complexity inherent to distributed computation, entails the need for the classification of efficient, re- usable, concurrent programming patterns. The paper discusses how the calculus of recursive schemes used in the derivation of functional programs, scales up to a distributed setting. It is shown, in particular, how to parallelize the entire class of binary tree hylomorphisms.

software composition. Actually, at present, the point is not only to master the com- plexity of building and deploying a large application in time and budget, but also to manage an open-ended structure of autonomous components, possibly distributed and highly heterogeneous. The ubiquity of concurrency, in the double perspective of distribution and parallelism, entails the need for new approaches and languages for composing, at runtime, interacting software.

Implemented as a domain specific language in Haskell, Orc becomes available to a vast community of users and developers. For example, a main motivation for developing HOrc was the possibility of coupling an Orc animator to CoorInspec- tor, a tool for extracting coordination scripts (expressed in Orc) from legacy code [19]. HOrc makes possible to validate such scripts and, eventually, to transform them.

4 A small detail note: the definition of Orc includes also a special operator called 0. In HOrc, though, 0 was implemented as a primitive site. To keep the symmetry of the presentation, we will defer the introduction of 0 until the primitive sites.

Sites may return values that can be used by other site calls. We say that such values are published by the site call. Due to the need for generality, site calls have very loose semantics: sites may take arbitrary time to respond or even not at all. So each individual site call may publish zero or one value.

Common sub-expressions may be abstracted through the use of expressions, or as we prefer to call them, functions. Functions are expressions where certain parameters have been abstracted by variables. These variables are introduced in the declaration of the function in a tuple next to its name; this is followed by the expression to which calls to the function reduce.

To count the number of threads that have still to finish, we abstract the act of processing messages by a function. This function repeatedly reads one publication, forwards it, if applicable, to the calling expression and calls itself recursively to process further messages. One of the arguments of this function is an accumulator that counts the number of threads still running. Whenever it receives a Nothing it decrements the value of the accumulator passed to the recursive calls. When the accumulator reaches zero, the function terminates.

Instead, prune is composed by two steps. In the first step, f and the channel to which it publishes are initialized. prune then waits until a value is published or f terminates. In the latter case the operator terminates immediately without starting g or publishing any value. If f does publish a value, then a kill signal is sent to its thread and recursively to its child threads.

In this section we will show only two of the examples we have implemented in HOrc. For the first one we picked up the eight queens problem solution of [16] and re-written it in HOrc to show the differences between the two languages. In the second example we focus in expressing more general programming patterns. We extend the definition of hylomorphism by allowing certain parts to run in parallel. As we later show, with this abstraction it becomes trivial to implement a parallel quicksort algorithm. Among the other programming patterns we implemented in HOrc are MapReduce [7] and workflow patterns [5].

This generalises the type of binary trees, by replacing the recursive part by an additional type variable b. The values of type b will be fed to the recursive calls. These recursive calls will, in turn, replace those values with their results which will then be consumed by the catamorphism. The definition of our de-forested binary tree hylomorphism is

by introducing threads and communication primitives among them (Channels and MVars); HOrc is built on top of these primitives. Another approach is the semi- explicit parallelism provided by GpH [14]; instead of mandating a certain division of tasks, the programmer annotates the code, identifying possible division of tasks, and the runtime decides which of those divisions to follow. HOrc seems to lay in between the two approaches: it is higher level than using pure threads but the division of tasks is still fixed.

