 rst problem is addressed by languages supporting user-de nable rewriting strate- gies. This paper addresses the second problem by extending rewriting strategies with scoped dynamic rewrite rules. Dynamic rules are generated at run-time and can access variables available from their de nition context. Rules generated within a rule scope are automatically retracted at the end of that scope. The technique is illustrated by means of several program tranformations: bound variable renaming, function inlining, and dead function elimination.

The paradigm of programmable rewriting strategies solves the problem of control over the application of rules while maintaining the separation of rules and strategies. A strategy is a little program that makes a selection from the available rules and de nes the order and position in the tree for applying the rules. Thus rules remain pure, are not intertwined with the strategy, and can be reused in multiple transformations.

The usual solution to this problem is to extend the traversal over the tree (be it hand-written or generic) such that it distributes the data needed by transformation rules. For example, traversal functions in ASF+SDF [5] can be declared to have an accumulation parameter in which data can be collected. Language independent de nitions of operations such as bound vari- able renaming in Stratego [15] capture a generic tree traversal schema that takes care of distributing an environment through a tree. The disadvantage of these solutions is that the traversal strategy becomes data heavy instead of just handling control ow. That is, all traversal functions become infected with additional parameters carrying context information. Generic solutions break down when multiple environments are needed, to handle multiple name spaces, for instance.

This paper introduces the extension of rewriting strategies with scoped dy- namic rules. A dynamic rule is a normal rewrite rule that is generated at run-time and that can access information from its generation context. For example, to de ne an inliner, a rule that inlines function calls for a speci c function can be generated at the point where the function is declared, and used at call sites of the function.

Dynamic rules are rst-class. Their application is under control of a normal strategy. Thus dynamic rules can be applied as part of a global tree traversal. Rules can overrule the de nition of previously generated rules. To restrict the application of a dynamic rule to a certain part of the tree, the live range of a rule can be determined by rule scopes (Section 3). A rule temporarily overruled in a scope becomes visible again at the end of that scope. To hide rules generated in outer scopes, rules can be unde ned (Section 4). Rules from outer scopes can also be permanently overridden (Section 5).

through 5 introduce dynamic rules by means of a number of transformations on Tiger programs: bound variable renaming (Section 3), function inlining (Section 4), and dead function elimination (Section 5). Each of these examples motivates and illustrates an aspect of dynamic rules. Section 6 discusses other applications, related and future work. Section 7 concludes.

This section reviews the basics of rewriting strategies in Stratego as far as needed for this paper. See [17] for details of the operational semantics under- lying the language. In this paper Tiger, the example language in the compiler construction textbook of Appel [1], is used to illustrate the application of dynamic rules.

Rewrite rules express basic transformations on terms. A rewrite rule has the form L : l -> r, where L is the label of the rule, and the term patterns l and r are its left-hand side and right-hand side, respectively. A term pattern is either a variable, a nullary constructor C, or the application C(p1,...,pn) of an n-ary constructor C to term patterns pi. For example,

A rule L: l -> r applies to a term t when the pattern l matches t, i.e., when l has the same top-level structure as t. Applying L to t has the e ect of transforming t to the term obtained by replacing the variables in r with the subterms of t to which they correspond. Actually the basic actions un- derlying rules are rst-class operations in Stratego. The operation ?t denotes matching against the term pattern t, and !t denotes building an instantia-

Programmable rewriting strategies provide a mechanism for achieving control over the application of rewrite rules, while avoiding the introduction of new constructors or rules. A rewriting strategy is a program that transforms terms or fails at doing so. In the case of success, the result is a transformed term. In the case of failure, there is no result.

The strategy combinators just described combine strategies which apply trans- formation rules to the roots of their subject terms. In order to apply a rule at an internal site of a term (i.e., to a subterm), it is necessary to traverse the term. Stratego de nes several primitive operators which expose the direct subterms of a constructor application. These can be combined with the op- erators described above to de ne a wide variety of complete term traversals. For the purposes of this paper we restrict the discussion of traversal operators to congruence operators and the all operator.

Congruence operators provide one mechanism for term traversal in Strat- ego. If C is an n-ary constructor, then the congruence C(s1,...,sn) is the strategy that applies only to terms of the form C(t1,...,tn), and works by applying the strategies si to the terms ti. For example, the congruence Let(s1,s2) transforms terms of the form Let(t1,t2) into Let(t1',t2'), where t1' is the result of applying s1 to t1, and similarly for t2'. If the

The strategy expression rec x(s; all(x)) speci es that the parameter transformation s is rst applied to the root of the current subject term. If that succeeds, the strategy is applied recursively to all direct subterms of the term, and, thereby, to all of its subterms. This de nition of topdown captures the generic notion of a pre-order traversal over a term.

Bound variable renaming is a transformation that replaces bound variables and their corresponding occurrences by new unique names. As a result of the transformation a name is used by at most one binding. This transformation is necessary to prevent free variable capture when substituting expressions under bindings, for example when performing function inlining.

Note that the i used in the initialization of the second declaration is bound by the outer declaration, and that the i used after the inner let also refers to the outer declaration. However, the i inside the inner let refers to the inner declaration. These issues are clari ed by the renamed version on the right.

This strategy traverses an abstract syntax tree, and at each subtree tries to apply one of the rules RenameVarDec or RenameVar. The operator try is de ned as try(s) = s <+ id, i.e., it tries to apply a transformation s, but if that fails returns the original term. Only rules for constructs that are actually changed need to be provided.

But here is the catch: in rule RenameVar the intention is not to rename just any variable to any other variable, but to rename an occurrence of a bound variable to its new name generated at its binding site, i.e., in rule RenameVarDec.

This problem suggests that it should be possible to retract generated rules after the scope in which they are valid ends. This is exactly what the rule scope {| lab : s |} achieves. A rule with label lab that is generated while executing s is automatically removed at the end of the scope. Thus, any rule that was overridden by rules generated inside the scope becomes visible again after the scope. Recall that exprename was de ned as

The renamer de ned using this rule renames all variables, even if a variable name was already unique. For some applications it is useful to rename as few variables as possible, for instance, when the result should be readable by a programmer. One approach is to rename only those variables that clash with outer bindings. In our running example this approach has the following e ect:

This can be achieved by only generating a new name for variables that already exist in an outer scope. The following rule tries to apply RenameVar to the variable x. If that succeeds the variable was already declared in an outer scope. In that case a new variable is generated. Otherwise the original variable name

Note that the replacement introduces local variables to bind the actual pa- rameters to the (renamed) formal parameters. This is necessary since Tiger is an imperative language. Simply substituting the actual parameters for the formal parameters could lead to duplication of work or even to errors because of intervening assignments. Further optimizations such as constant and copy propagation can get rid of the local declarations if possible.

Strategy DeclareFun, which generates the InlineFun rules, only does so when the function declaration is deemed to be inlineable. The exact de nition of inlineable does not matter here; it could be de ned using various heuris- tics based on static or dynamic program analyses. What does matter is the fact that for non-inlineable functions no InlineFun rule is generated. If two functions with the same name exist, one shadowing the other, and the outer is inlineable while the inner is not, this could lead to replacing a call with the wrong function body. Thus, it is necessary to prevent inlining rules from outer scopes to creep trough.

However, this is not what we want, since the intention of NotDead is to change the original rule de ned in the scope of the function declaration, rather than to unde ne IsDead for local purposes. This is achieved by declaring the dynamic rules as override rules. The generation of an overriding dynamic rule only succeeds if there was a prior de nition of a dynamic rule for the same left-hand side.

In an interpreter for Tiger, dynamic rules are used to represent mappings from variables to values on the stack or heap. Variable bindings are dealt with using a scoped traversal similar to that of the renamer. Globally visible heap objects are represented by an unscoped dynamic rule that maps reference values (pointers) to values. Evaluation for individual constructs is expressed using constant folding rules.

There are many other program transformations that can bene t from the use of dynamic rules. It seems that the data- ow transformations above can be easily extended to inter-procedural transformations by generating appropri- ate rules for function calls from their function declarations. The warm fusion algorithm for deforestation [11] uses dynamically generated rewrite rules for the derivation of catamorphisms from recursive function de nitions. The im- plementation of warm fusion in Stratego [9] can be simpli ed using dynamic rules. Dynamic rules can also be used for memoization. The use/def analysis mentioned above uses a memoization scheme to incrementally recompute the analyses for an expression.

Another application area is the run-time con guration of transformation components. Options passed on the command-line can be used to generate rules used during a transformation. This can range from simple information such as optimization level to user-de ned optimization rules and instantiation of an analysis with a set of initial variables to scrutinize.

In [15] it is shown how generic traversal strategies can be used to de ne generic, language independent algorithms for language processing problems such as free variable extraction, bound variable renaming, substitution, and uni cation. These generic algorithms are parameterized with strategies for recognizing the various aspects of the object language such as representa- tion of variables, variable binding constructs, and binding positions of binding constructs. Dynamic rules are orthogonal to generic traversals and can make their implementation easier since environment threading can be delegated to dynamic rules.

Dynamic rules are most closely related to the extra-logical operators assert and retract in Prolog. The goal assert(G) adds G to the rule database. All free logic variables in G are universally quanti ed. This is similar to the variables in dynamic rules that do not occur in the context. The goal retract(G) retracts from the rule database all rules that unify with G. The dynamic rule mechanism in this paper does not provide a retract. Instead, the live range of a rule can be controlled by means of rule scope that automatically retracts rules at the end of their scope. This provides a much cleaner way to retract rules, since only those rules generated before are retracted. Rules that were declared outside the scope become visible again. This cannot be modeled using retract.

Lewis et al. [12] introduce implicit parameters in functional languages such as Haskell. Implicit parameters can be used deeply embedded in a functional de nition and can be bound at some outer level without having to pass the value explicitly through all the intermediate function calls. Hansson et al. [8] introduce dynamic variables in an imperative setting. A dynamic variable is created and initialized with an initial value. A use of a dynamic variable refers to the most recent setting of a dynamic variable with the same name. The main di erence between the approaches is the fact that the value of an implicit parameter in [12] cannot be changed, while a dynamic variable is passed by reference to the use site and can thus be updated. Such updating corresponds to the notion of overriding rules generation in this paper.

Furthermore, unlike the approaches of implicit parameters and dynamic variables, the dynamic rule scope construct in this paper is separated from both the generation and use of dynamic rules. This entails greater exibility; strategies that introduce dynamic rules can be put to di erent use by manip- ulating the range of the scope. This is illustrated for example by the various strategies for variable renaming that re ect di erent (object language) scope rules, while (re-)using the same renaming rules.

In the scheme described in this paper each dynamic rule de nes its own namespace. In order to achieve shadowing e ects in the namespaces of other rules, these rules should be unde ned. When mixing many rules this might become unattractive. Some means of declaring the namespace dependencies between rules will be useful.

It will also be interesting to investigate the interaction between various optimizations based on dynamic rules if they are combined in a single traversal. Finally, dynamic scoping may give rise to unexpected behaviour when a dynamically generated rule A itself calls a dynamic rule B, which is intended to be the A generation time instance of rule B, instead of the A call time instance of B, i.e., B could change between the generation of A and a call to A. This can often be solved by invoking B in the generation context of A. However, in

This paper presented an extension of term rewriting with the run-time gen- eration of context-dependent rewrite rules. Generated rules can be used as part of the global tree traversal, thus not increasing complexity by performing additional traversals. The extension is not limited to some speci c form of program representation such as control ow graphs, but can be applied in the transformation of arbitrary abstract syntax trees.

[3] P. Borovansky , C. Kirchner, and H. Kirchner. Controlling rewriting by rewriting. In J. Meseguer, editor, Proceedings of the First International Workshop on Rewriting Logic and its Applications, volume 4 of Electronic Notes in Theoretical Computer Science, Asilomar, Paci c Grove, CA, September 1996. Elsevier.

[6] M. Clavel and J. Meseguer.  Re ection and strategies in rewriting logic. In J. Meseguer, editor, Electronic Notes in Theoretical Computer Science, volume 4. Elsevier Science Publishers, 1996. Proceedings of the First International Workshop on Rewriting Logic and its Applications.

