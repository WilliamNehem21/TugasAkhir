We observe that followAssign(x, E ) can only be applied if the program is of the form w, x : [pre, post ]. The tactic robustFollowAssign(x, E ) above, on the other hand, may be successfully applied to specification statements that may not have x in their frame. Operationally, this results in followAssign(x, E ) failing after the first choice skip is taken, and the execution backtracking to explore the second choice of the alternation in attempting to find a successful path of continuation.

The angelic nondeterminism embedded in the choice supports a concise and general description of many robust tactics of refinement and proof. Several examples are presented in [12]. The implicit backtracking manifests itself in the following law which is valid for ArcAngel (and Angel): (t1 | t2); t3 = (t1 ; t3) | (t2 ; t3).

The Ergo theorem prover [16], which is implemented in Prolog, was extended to use Angel as a tactic language [9]. ArcAngel is incorporated in the refinement editor REFINE [14], which however does not provide facilities for theorem proving. In this paper, we present an implementation of ArcAngel in ProofPower, a flexible and extensible theorem prover based on HOL. It has an open architecture and has been successfully used on industrial-scale projects [1]. ProofPower also provides an embedding and formalisation of the Z language. This is useful in defining a semantic

We also address several issues that led to a generalisation and in parts unification of ArcAngel with its kin Angel, as well as the more specialised derivate ArcAngelC , a variant tailored for refinement in the Circus language [11]. Whereas Angel deals with proving general theorems, ArcAngel(C ) are methods for constructive refinement. A by-product of this unification is a framework that fosters the development of other derivatives of Angel, and we explain how we support their embedding.

The structure of the paper is as follows. In Section 2 we introduce the relevant preliminary material; more specifically, we give a brief account of the syntax and semantics of ArcAngel, and the ProofPower theorem prover. Section 3 discusses the fundamental design of our implementation and its relationship to the ArcAngel semantics. The following section illustrates the use of the tool through an example, and in Section 5 we draw our conclusions, address some aspects of extensions and generalisations, and identify future work.

The most basic tactic is law name(args); it assumes name, the law, to be a priori defined and to have parameters that are suitably instantiated by args. If name with arguments args is applicable, the application of the tactic succeeds and returns a new program, possibly generating proof obligations for the provisos of name. If, on the other hand, the law is not applicable, the tactic fails. An analogous construct exists to invoke a declared tactic. Its syntax is tactic name(args) where name is the name of the tactic, and args the list of arguments passed to it.

Two further unary tactics are the assertions succs t and fails t . The first ter- minates without changing the program (that is, behaving like skip) if t succeeds, and otherwise fails. The second terminates without changing the program if t fails, and otherwise fails. Both are strict with respect to abort too.

The semantics of law name(args) is a singleton list with the refinement cell containing the transformed program and possibly additional proof obligations, or otherwise an empty list if application fails. The law definition is inferred from the law environment. Similarly, tactic name(args) executes the tactic name by inferring its definition from the tactic environment.

A design objective of ProofPower was to facilitate the semantic embedding of other languages. In particular, the Z language has been embedded and formalised, producing the ProofPower-Z package and dialect. It is in essence an extension of ProofPower that provides additional syntactic constructs, parsing facilities, rules, theorems and tactics specific to transforming and proving theorems about Z expres- sions. The open architecture and flexibility of ProofPower encouraged the develop- ment of several tools that promoted its use on industrial-scale projects [4,2].

To accommodate nondeterminism, which surfaces when the application of a tactic can produce more than one possible result, we have to keep track of all possible outcomes of tactic behaviours. For example, t1 | t2 can have two possible outcomes if both tactics are applicable to the program. In order to determine which execution path leads to success and realise backtracking, if necessary, we have to keep track of both outcomes. We therefore characterise tactics as functions mapping refinement theorems to lists of refinement theorems. This characterisation closely resembles the semantic model of ArcAngel presented in Section 2.1 that modelled tactics by functions mapping refinement cells to (infinite) lists of refinement cells.

It entails the possibility of applying t once, twice, or in fact an arbitrary number of times. If t repetitively shows to be applicable, the tactic has an infinite number of potential outcomes.  Operationally, this results in an infinite list p - t (p) - t 2(p) - t 3(p) ... to be computed when EXHAUST(t ) is applied to some program

This datatype provides four constructor functions. LazyNil is used to construct empty lazy lists, LazyAtom to construct atomic (non-lazy) elements, LazyJoin to concatenate two lazy lists, and LazyDefer to explicitly defer evaluation. This list model, being a lazy variant of the join list model, was tailored to provide the flexibility and expressiveness to implement ArcAngel operators in a correct, concise, and efficient way, in particular, the tactic combinators for alternation and recursion. To support parametrised tactics and the applies to p do t operator, it is nec- essary to incorporate a special notion of environment that binds (meta)variables to

For law applications via TLaw the implementation essentially carries out the steps discussed in the previous section. It has to do a bit more work, however, to substitute meta-variables occurring free in the arguments, and move implications in the conclusion of the law theorem into the assumptions to make them provisos. For laws to be applicable, they first have to be declared using the TLawDecl function. It expects the name of the law, its formal arguments as a list of typed

The tfun argument provides the body of the recursion: a function on ArcAngel tactics. The local constant trec is introduced as a recursively-defined value which is used to determine the result of TRec. In defining trec it is vital that the recursive unfolding takes place incrementally and application of the tactic to the goal is deferred in each step. This is achieved by the function defertaceval which defers the application of one unfolding (tfun trec) to the program p.

We also provide an alternative implementation (aasolvetac atac) that eval- uates all outcomes of tactic applications to A, and selects one that discharges the goal or otherwise fails if none exists. Such a behaviour is faithful to the angelic interpretation of nondeterminism at the top level since the notion of success is clearly defined here as discharging the proof goal. This is also compatible with the mechanics of Angel which explores all possible paths of tactic executions.

For readability, the assumptions of the theorem have been omitted. Most of them carry constraints regarding the well-definedness of operator applications which were accumulated through application of the laws and monotonicity theorems. In prac- tice, we anticipate that most of these assumptions are provable automatically with- out any user intervention. The remaining assumptions encapsulate the provisos of the laws. For example, we find the following assumption encoding the first proof obligation of the law, that is, the provisos of the strPost law.

When applying ArcAngel tactics outside the subgoal package of ProofPower as above, tactic applications usually increase the number of assumptions of the gen- erated refinement theorem. In backward proofs we use the refinement theorem to simplify a refinement goal, and in this case the assumptions contribute as addi- tional subgoals of the proof and need to be discharged separately. Fortunately, ProofPower offers a lot of flexibility in implementing programming utilities and tac- tics to automate proofs, and for this purpose we have already developed a collection of specialised (ProofPower) tactics that can automatically discharge most of the well-definedness constraints encountered so far so that the only real proof effort that has to be invested is in discharging the provisos of the laws.

tion as well as decisions made in its design, and illustrated it by virtue of an example. Notably, we managed to realise a very direct translation of the ArcAngel semantics in which refinement cells in the semantic model are identified with refinement theo- rems in the implementation model. A faithful representation of partial and infinite lists was achieved through the use of lazy evaluation, and recursive ArcAngel tac- tics are directly supported through recursive ML functions on tactics. Hence, the encoding of particular tactics is mostly trivial and amenable to automation.

