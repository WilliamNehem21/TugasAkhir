Predicting the reliability of a software system at an architectural level during early design stages can help to make systems more dependable and avoid costs for fixing the implementation. Existing reliability prediction methods for component-based systems use Markov models and assume that the software architect can provide the transition probabilities between individual components. This is however not possible if the components are black boxes, only at the design stage, or not available for testing. We propose a new modelling formalism that includes parameter dependencies into software component reliability specifications. It allows the software architect to only model a system-level usage profile (i.e., parameter values and call

We present a novel approach where component developers supply component reliability specifications based on so-called stochastic regular expressions (SRE), which extend regular expressions with probabilistic attributes. An SRE describes the call propagation through a component service in dependency to input parame- ter values. Software architects can compose these parametrised specifications using tools and add their application specific system-level usage profile. A transformation tool then solves the parameter dependencies inside the component reliability speci- fications and thereby deduces the component transition probabilities based on the system-level usage profile. With our approach, the software architect does not need to estimate transition probabilities inside the architecture model making reliability predictions more accurate.

We demonstrate the applicability of our approach by modelling the reliabil- ity of the component services of a retail management system supported by tools for the Palladio Component Model (PCM) [1]. They allow software architects to compose individual component specifications by different developers. We make pre- dictions with varying system-level usage profiles and show the sensitivity of the overall system reliability to individual component failure probabilities and usage profile parameters.

elling parameter dependencies can potentially be added to any existing component- based reliability prediction approach relying on the same assumptions thereby mak- ing it more accurate and flexible. Furthermore, our approach can be used for other compositional quality attributes (e.g., performance [9]).

The paper is organised as follows. Section 2 surveys related work. Section 3 de- scribes the steps of our method and explains the involved developer roles. Section 4 defines our formalism on stochastic regular expressions and shows the transforma- tion algorithm to derive Markov model from the formalism. Section 5 demonstrates our approach in a case study, followed by a discussion of assumptions in Section 6. Section 7 concludes the paper.

The field of reliability prediction for component-based software architectures has been surveyed in [5,4,7]. The approach presented in this paper is in the class of state-based methods, which assume that the control flow between the components of a software architecture can be modelled using a Markov chain. Goseva et al. [5] state that most approaches rely on estimations of the transition probabilities be- tween components. In our approach, no estimation is necessary, as each component specifies its call propagation in dependency to its own usage profile.

One of the first approaches for architecture-based reliability modelling was pre- sented by Cheung in 1980 [3]. He emphasised the fact that a system is more reliable if the unreliable parts are rarely used. He introduced a Markov model to describe the control flow through a component-based software architecture. Cheung computes system reliability by analysing the Markov chain and incorporating the transition probabilities between different components, so that seldom used components only marginally contribute to system reliability.

Hamlet et al. [6] specify reliabilities and call propagations for each individual component. Thus, the resulting models for each component shall be reusable across different architectures and system-level usage profiles. However, the approach re- quires the software architect to execute each component against the desired usage profile, which essentially reduces the approach to testing. The dependency of tran- sition probabilities and input parameters is not made explicit in this approach.

Each software architect assembles the component specifications in the same man- ner as later the component implementations. Additionally, each software architect provides a usage profile for the complete system (i.e., having direct interaction with the user or other systems). Based on this information, a tool traverses the archi- tectural model and resolves the parameter dependencies in the component specifi- cations.

This section describes our model for component reliability specification (Sec- tion 4.1), and system modelling (Section 4.2). Afterwards it explains the necessary transformation steps to deduce a Markov model from the specification (Section 4.3), and shows how to solve the Markov model to get a reliability prediction (Section 4.4).

The algorithm creates a Markov model as a side effect while traversing the abstract syntax trees of the SREs. This Markov model contains a failure state, which is taken if an internal action fails. Therefore, the transition probability from a state representing an internal action iai to the failure state is its failure probability f p(iai).

Upon traversing an external call Ej, the algorithm creates a new usage profile for the called SRE. It first resolves the parameter dependencies on the inputs of the call defined by the function ei(Ej). Then it uses these values as new usage profile. After traversing the called SRE, the algorithm resolves parameter dependencies on the outputs of the call defined by the function eo(Ej). The parametric dependencies of these output values may refer to the return value rv of the called SRE.

The control flow of the bookSale() operation distinguishes several cases. First, an item may be rated as small goods that do not have to be declared in the inventory. A branch located in the loop body reflects this fact. If an item is small goods (which corresponds to y having value 0), there is no need for stock information update. Rather, some internal calculations ia1 are done. The probability P (y = 0) is part of the usage profile. Second, an item can be identified by a number or by a name, which results in two different types of database queries P3 and P4. Again, the usage profile determines the probabilities of both alternatives through P (z = 0).

of loop iterations, leading to more stock update operations. Only in the theoretical case that the stock update cannot fail at all, the reliability is nearly independent of the number of items. In that case, it is determined only by the potential failure of transaction setup and commit, as well as the internal calculation ia1.

Besides individual failure probabilities, the parametric dependencies of the con- trol flow also need to be given as an input to reliability prediction. The specification of the internal behaviour of components given by the component developer or deter- mined through a reverse engineering process can serve as a source of information [8]. If no specification exists and the source code is not available, it might be still possible to reconstruct the parametric dependencies by monitoring the inputs and outputs of the component by running it as a black box in a test-bed [11].

Our method abstracts from the concrete faults that may cause a failure. A ser- vice execution may alter the state of a component, such as the values of variables owned by the component, in an invalid way. The faulty component state might not immediately result in a failure, but at a later point in time. Such coherences cannot be explicitly expressed by our approach. The same is true for the probability of failure due to usage of certain resources or message loss over a certain communica- tion link. Also, failures caused by concurrency are not explicitly captured by the SREs. Our approach aggregates the distinct causes of failure into one probability value, which tends to decrease accuracy of prediction.

happened. Furthermore, we assume the failure probabilities of internal actions to be stochastically independent. Currently the failure probability values are fixed constants. They cannot be adapted to take factors like system or component state at run-time, previous service calls or the control flow of the current call into account. Such considerations are left as a topic for future work.

Our approach helps component developers by providing a language to specify component reliability. It helps software architects, who can quickly assemble com- ponent reliability specification, and parametrise them for different usage profiles without knowing the internals of the components. Similar existing component re- liability prediction approaches can adopt our method of modelling to make their prediction more accurate and more flexible. By assessing the reliability of a sys- tem design during early development stages, potentially high costs for late life-cycle fixings of a system can be avoided.

Our approach is still in an initial stage. We plan to add information about the underlying hardware resources to our model to allow to make more refined pre- dictions. Furthermore, we will add reliability models for network connections and connectors between components. Another important direction is the determination of valid failure probabilities. We plan to incorporate existing approaches for deter- mining failure probabilities into our own method and validate it on a large real-life case study.

