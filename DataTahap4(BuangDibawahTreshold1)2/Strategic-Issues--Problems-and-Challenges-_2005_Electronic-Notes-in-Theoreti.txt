Theorem proving tasks are ubiquitous in computer science, e.g., in fields like program specification, transformation and verification. Most often the given, generated or resulting proof tasks are not general ones (in the sense, that va- lidity in all models of the underlying logic specification is to be established),

The paper is primarily non-technical and high-level, focusing on relevant is- sues in (automated) ITP, that make the problem difficult. We assume some basic knowledge, terminology and notations in first-order logic. Though the presentation is essentially non-technical, to really understand, appreciate or criticize the analysis developed, especially the conclusions and interrelations, we conjecture that some familiarity with ITP in theory and practice will be necessary, since without own experience the problems in ITP are typically underestimated. For the interested reader, we give a lot of references to works in the field that may serve as a starting point for a more detailed study of various aspects and approaches in ITP. Although the links to the literature are fairly comprehensive, we do not claim any kind of completeness with this bibliography.

Before going into details let us mention a couple of papers and proceedings, that are not explicitly discussed later on, where certain issues related to proof search in TP and ITP have been discussed in some depth. One major forum for such work is the workshop on Strategies in Automated Deduction, held since 1997, cf. [90], [93], [91], [92], [22]. Another source is the workshop on the Automation of Inductive Proof, held irregularly since the beginning of the 1990s, but with at most informal proceedings (cf. e.g. [108]). Further literature includes [45,48], [49], [64], [65], [66], [68], [86,87,88,89], [104,106,110],

5 Somehow, it seems that in the automated reasoning community, the theme of (explicit) disproving of conjectures, including model building and the construction of counterexamples, has not yet received the attention it deserves (see, e.g., [200]). For a recent attempt to focus on this theme see e.g. [3].

Full first-order vs. universal fragment: Most ITP systems and approaches concentrate on universally quantified first-order formulae. Allowing exis- tential quantification (or arbitrary quantifier alternations) clearly compli- cates things considerably. Typically, existential inductive conjectures are approached by trying to constructively find witnesses and prove that they satisfy the respective inductive property, cf. eg [39,42], [20], [148], [105], [57],

tion via destructor (or selection) functions, like for lists with constructors nil , cons and destructors car , cdr (cf. e.g. [39]). Normally, the representa- tions and proofs can be easily translated from a constructor to a destructor framework and vice versa, however, from a proof-technical point of view it is advisable to stick to one of these dual frameworks.

the inductive saturation process hopefully terminates (with or without an inconsistency) in many cases. In the 1980s and later on the approach of [182], [81], [101,102] was extended, refined and generalized in various ways, cf. e.g. [192], [122,123], [72,74], [9], [83], [76,77], [62], [60]. Also, a couple of

an on-going debate about explicit vs. implicit induction and combinations thereof, in particular concerning the strengths and weaknesses of and the relationships between these approaches. But it seems clear that, regarding the essential problems in the proof search process in ITP, both approaches face essentially the same problems. For that reason we will not go into details about the latter aspects and relationships here.

Case analysis (3) is also a very challenging topic and subtask in ITP. Espe- cially, when should one initiate a case analysis, and if so, how? And according to which criteria should the generation cases be done? Furthermore, if the case analysis is not obviously complete, in the sense that all cases are covered, 9 verifying completeness involves in general again inductive reasoning, hence the full power (and difficulty) of induction. The questions of when and how to ap- ply case analysis (in ITP) are also very difficult questions where not so much literature exists (although any ITP system has heuristics for doing so), cf. e.g. [39,42], [151], [30]. A related question is how fine-grained the case distinction should be. The more special some case is, the more information is available

Let us give some comments on the current state of the art in ITP, based on some evidence from the literature and also from personal experience with ITP and different ITP systems. Of course, it is difficult to make general statements and give a comprehensive overview. We do not really claim any kind of com- pleteness here nor that there exists a consensus about these issues, but rather aim at some conclusions which ideally should trigger further discussions.

is both a powerful and efficient functional programming language and an ITP system. Its inductive theorem prover deals with the universal fragment of first-order logic. There exists an impressive collection of non-trivial exam- ples (cf. e.g. [150]). The system has a relatively high degree of automation and sophisticated strategies, heuristics and mechanisms for induction.

PVS ([190,191], [189], [70], [180] [179]): PVS provides mechanized sup- port for formal specification and verification. It is based on a powerful framework, namely classical, typed higher-order logic. Reasoning in PVS, especially ITP, is partially automated, and the system includes a modern framework for decision procedures.

VSE/INKA ([115], [183], [7], [114]): VSE/INKA is a comprehensive tool for supporting the formal software development process. Inductive proofs are one focus area of the system, with sophisticated search control strategies for certain subtasks (during induction). But the system has also substantial support for the whole development process.

QuodLibet ([229,230], [169], [168], [8], [227]): QuodLibet is the successor system of UNICOM ([82,84,83]. It is both a specification language and an ITP system for data types with partial operations. It has a flexible control, is user-oriented, but with some automation facilities. It allows lazy induction proofs and has a sophisticated concept for managing (possibly simultaneous) proof attempts.

ITP problems are at the heart of many verification and reasoning tasks in computer science. We have tried to give a thorough, though only high-level, account of induction (in the sense of ITP), both regarding the possible ap- proaches, methods, proof techniques and corresponding systems, as well as concerning the main problems in actual proofs, having in mind the goal of a high automation degree. In particular, we have worked out, isolated and discussed the crucial differences to general TP. This comparison also reveals or, better, explains, why automating inductive proofs is much harder than au- tomating general theorem proving. We hope that this analysis and discussion contributes to a better understanding of the essence of ITP, initiates further debates in the ITP community and thus contributes a bit to the further de- velopment of the field.

