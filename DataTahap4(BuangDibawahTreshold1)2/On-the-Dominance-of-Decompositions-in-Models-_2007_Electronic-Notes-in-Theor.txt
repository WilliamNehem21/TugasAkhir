Aspect-oriented approaches have commonly advocated separation of concerns. Some approaches have ap- plied this separation in a symmetric fashion, like Hyper/J, whereas some others have relied on asymmetric separation, like AspectJ. The difference in the approaches is that the different concerns play a symmetric role in the former, whereas the latter explicitly includes a conventional implementation on top of which other concerns are woven onto as aspects. The question then arises, how are the concerns of the conven- tional implementation special in the latter, and will the opportunity to use symmetric separation lead to a fundamentally different decomposition. In this paper, we discuss the dominance in decompositions in specifications and corresponding aspect-oriented implementations. As examples, we use the specification method DisCo which allows modeling of concerns in a fashion that separates the different concerns to spec- ification branches, and aspect-oriented implementations using Hyper/J and AspectJ that can be composed for DisCo specifications. As the final outcome, we propose that any aspect-oriented approach addressing the system at the level of program code necessarily has some concerns that are more dominant than some others due to the control flow of programs.

Tyranny of dominant decompositions is the term introduced to address problems related to the inability to address all concerns of a software system using the same facilities. Reported in [17], this has lead to the introduction of a paradigm where all the concerns can be treated in a similar fashion, with a practical programming-level implementation in Hyper/J [20]. Then, all concerns can be treated symmetrically, which enables the creation of systems so that both conventional modularity and cross-cutting properties are enabled using hypermodules.

In contrast to symmetric approaches to manage cross-cutting properties, asym- metric approaches have been introduced. For instance, AspectJ [18] introduces facilities for augmenting a baseline implementation with additions referred to as aspects. Then, one can advance such that an existing system, given as a conven- tional program, is taken as the starting point, and new behaviors are woven into the system with aspects. Furthermore, provided with a convention where aspects are used for certain issues, the developers can anticipate the injection of aspects, and overlook such parts of the system in the baseline implementation.

The rest of this paper is structured as follows. Section 2 introduces the specifi- cation and modeling method we use as the starting point. Furthermore, we discuss the structure of specifications that has been commonly used for separating con- cerns. Sections 3 and 4 sketch implementations for DisCo specifications using Hy- per/J and AspectJ, where symmetric and asymmetric decompositions of concerns are offered. In addition, we discuss the dominance of decompositions in described systems. Then, Section 5 finally concludes the paper.

DisCo specifications are composed in terms of layers that contain classes and ac- tions. Classes are containers of data, and actions can be understood as multi-object methods that can alter values of variables. Actions are executed in an interleaved fashion without any interference from the rest of the system and their execution is bound to be finished once it has been initiated, which makes actions atomic units of executions. The language used for composing specifications is textual. However, animation facilities have been provided to ease the analysis of specifications [16,3]. Furthermore, the relation of DisCo specifications and their denotation using UML

Layers can build on top of other layers, which is referred to as refinement in DisCo terminology. A restriction is made that actions can only alter values of variables given in the same layer, which guarantees that safety properties will be preserved by construction. To satisfy this restriction, refinements can introduce new variables and operations on them as well as augmentations to actions, provided that the new action logically implies its ancestor. In fact, one can consider that the concept of ancestors plays a key role in the DisCo approach. All classes and actions can be considered as the refinements of their ancestors in earlier layers, with the layer defining an empty system as the origin of the hierarchy. This gives an explicit structure for any DisCo specification, with the opportunity to define concerns in individual layers.

The use of layers allows modeling of systems using several levels of abstraction. For instance, when modeling a telephony exchange, it is possible to model the system using abstract concepts, such as call control, connections, and legs, which are individual connections from the exchange to a caller or callee, and charging, as well as in terms of processes used for implementing the abstract concepts. This allows each layer to focus on a certain concern the modeler wants to address separately.

Layered specifications in DisCo allow layers where individual concerns are ad- dressed. Layers are truly symmetric in the sense that the refinement relationship between layers preserves (safety) properties of all component layers, and the order in which layers are given can vary. Furthermore, refinements can only make more restrictions, which resembles the constraint-oriented design style introduced in con- nection with LOTOS [5]. Another difference to commonly used aspect-oriented approaches is that layers are complete in the sense that they only describe behav- iors in terms of the variables included in them. Then, when layers are composed, a new universe is created where the rules of behavior of all component layers are satisfied.

More recently, we have also considered aspect-oriented techniques [1]. This en- ables us to preserve the structure created with layers. Moreover, we have considered applying the same design methodology in the design of aspect-oriented systems. In the following sections, we shift the focus on composing aspect-oriented implemen- tations in a fashion that preserves the layered structure of the specification.

When composing a Hyper/J system, independent subsystems are defined in the beginning. They can be individual classes or collections of them, and they can be even tested in isolation from one another. The goal is to create all the necessary operations of the eventual implementation in isolation.

However, there is one major drawback. Before one includes the branch that defines the master control flow only declarative goals can be achieved. In other words, by combining branches that define operations that do not trigger themselves to execution, one cannot create any runnable programs. As a result, the semantics of different branches have different contribution to the development. Therefore, the branch defining the control flow can be considered as a dominant dimension in the semantic sense.

As a result of the special role of control flow, in cases where an early phase of the DisCo specification defines executions the situation is simple. The corresponding Hyper/J implementation can be given and tested in a straightforward fashion. Then, as the design advances, new features can be immediately augmented with normal routines. Furthermore, also testing by running the system is enabled. However, in cases where some later branch introduces the control, combinations where the implementation branch is missing result in declarative statements. This in particular applies to non-primitive abstractions, which often define no control as such but are conceptually important. They cannot be tested in a Hyper/J implementation independently of the rest of the system, but they can still be defined and used as intermediate systems that can be studied with reviews.

In contrast to Hyper/J, AspectJ [18] aims at the definition of systems in a fashion where a baseline implementation is given first. This baseline is given using conven- tional Java, and it will be extended with aspects that are woven into code. In other words, aspects can be taken as extensions of the baseline system, and they most nat- urally follow the control given in the baseline, although an option has been provided to override operations. In the following, we outline a mechanism for implementing the above DisCo specification using AspectJ.

The fundamental source of asymmetry in AspectJ is that there are two types of artifacts. One type is the conventional Java classes, and the other type is the aspects. The types also play a different role in the development process, which is addressed in the following.

forms a necessary element in an implementation. When considering the behaviors of the system, executions that must take place commonly introduce a dominant decomposition any case in implementations, as otherwise only declarative definitions can be given. As a result, structure-preserving implementations of the specifications, whose architecture had prescribed differences regarding the order in which certain concerns were introduced, are similar for both Hyper/J and AspectJ.

