We introduce Canonical HybridLF (CHLF), a metalogic for proving properties of deductive systems, im- plemented in Isabelle HOL. CHLF is closely related to two other metalogics. The first is the Edinburgh Logical Framework (LF) by Harper, Honsell and Plotkin. The second is the Hybrid system developed by Ambler, Crole and Momigliano which provides a Higher-Order Abstract Syntax (HOAS) based on un-typed lambda calculus.

The key innovation of CHLF is the replacement of the un-typed lambda calculus with a dependently-typed lambda calculus in the style of LF. CHLF allows signatures containing constants representing the judgements and syntax of an object logic, together with proofs of metatheorems about its judgements, to be entered using a HOAS interface. Proofs that metatheorems defined in the signature are valid are created using the M2 metalogic of Schurmann and Pfenning.

This paper is about reasoning about deductive systems such as logics, programming languages and so on. In general we refer to a typical deductive system as an object logic. One may reason about an object logic by translating it into a metalogic and then performing reasoning in the metalogic, provided that properties of the object logic are suitably reflected in the metalogic.

At the heart of Hybrid are conversion functions mapping untyped higher or- der syntax to first order syntax. Our contribution is to show that the conversion technique extends not just to a simply typed setting, but in fact to a new system, Canonical HybridLF, that is dependently typed. We can indeed dispense with well-formedness predicates. Further, the new system provides for Twelf-style rea- soning with the judgements-as-types methodology.

In section 2 we overview the Hybrid system. We point the reader to the origi- nal papers, and provide some necessary background reading. In section 3 we briefly recall the details of the Canonical LF logical framework, and then describe the main contributions of this paper, as set out in the Introduction, in detail. In section 4 we give some examples including a direct comparison of Hybrid and Canonical Hy- bridLF encodings of quantified propositional logic, and discuss an implementation of a logic for proofs in our system.

Like Hybrid, Canonical HybridLF employs the concept of abstraction, and has function predicates that determine if certain terms are valid abstractions. However there are two main differences. The first is that we now have type abstractions as well as term abstractions. The second is that Canonical HybridLF extends the general notion of abstraction from unary abstractions to k-ary abstractions. Intuitively speaking these are Isabelle functions that bind exactly k variables, are syntactic terms and have no dangling indices.

For example cterm abstr determines if an Isabelle function with one bound variable is a valid unary abstraction that returns a canonical term, while cterm abstr12 determines if a function with twelve bound variables is a valid abstraction that returns a canonical term. The other three families of functions perform the same task for abstractions representing canonical types, atomic types and lastly atomic terms. Variants for up to twelve variables suffice in practice; there are no limits on the number of variables that can be handled so we could define abstr functions that allow the analysis of functions with a greater number of bound variables. We give one example definition, of cterm abstr.

Recall the functions lambda and lbind from section 2. These functions implement the automatic conversion of HOAS expressions with named Isabelle binders v to de Bruijn form. A key contribution of the current paper is to show that the higher order pattern matching techniques used in implementing these functions in Hybrid transfer smoothly to an analogous implementation of Canonical LF, thus yielding the Canonical HybridLF system.

In canon typeof and atom typeof, the sixth parameter is the canonical term or atomic term to determine the type of, while the sixth parameter in the substitution functions is the canonical term that we are substituting for free variables. The seventh parameter in the substitution functions is a natural number, the number of the variable to substitute for. The eighth is the term into which we are substituting. We complete this section by giving some examples of the code for these functions.

Notice that some of the type constants are used to name the judgements to be proved. form is the type of formulae; nnf maps a QPL formula to one in negation normal form. Corresponding to the Hybrid inductive definition of nnf, with rules such as nnf forall, there are object constants such as nnf FORALL.

tutions, contexts, formulae and patterns. A substitution consists of pairs relating a variable number to be substituted for to the term that is to be substituted for it. Contexts consist of pairs of a free variable number and the type of the free variable. Formulae are given by a pair of contexts - the first containing universally quantified input variables, and the second containing existentially quantified output variables. We then define the datatype representing M2 proof terms (definition omitted).

A. Momigliano, S. J. Ambler, and R. L. Crole. A Comparison of Formalizations of the Meta-Theory of a Language with Variable Bindings in Isabelle. In Richard J. Boulton and Paul B. Jackson, editors, Supplemental Proceedings of the 14th International Conference on Theorem Proving in Higher Order Logics, pp 267-282, 2001.

