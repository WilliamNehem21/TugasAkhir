In this article we propose a new representation for the real numbers. This representation can be conveniently used to implement exact real number computation with a lazy programming languages. In fact the new representation permits the exploitation of hardware implementation of arithmetic functions without generating the granularity problem. Moreover we present a variation of the Karatsuba algorithm for multiplication of integers. The new algorithm performs exact real number multiplication in a lazy way and has a lower complexity than the standard algorithm.

Computation on real numbers is commonly solved, with a computer, using a subset of rationals. A real is represented using the classical floating point notation by a fixed size exponent and mantissa. The arithmetic based on this notation is intrinsically inexact. Errors are first introduced on data and then are propagated during computation. To cope with errors introduced by

This classification was first proposed by Boehm and Cartwright[3] who first realized implementations using both approaches and compared the resulting performance. Their research showed that even if real representations used in lazy implementations are more natural and elegant the resulting implemen- tation fails to be as efficient as the functional one. This is mainly caused by coerse granularity of the representation and by arithmetical algorithms used in lazy implementation that have a higher complexity order. A rappresen- tation has a coarse granularity when the finite approximations of mantissa approximated can have a number of binary digits that is is multiple of some large number (tipically 16 or 32), in a representation with coars granulariti many finite approximations of an arbitrary lengh are not allowed.

will be evaluated to n fractional digits that is typically 16n or 32n fractional bits if digits di are stored respectively as a one word or two words of memory. Instead it is clear that n fractional bits would be sufficient. Phenomena of this kind can be evidenced in many other contexts.

Another problem is evidenced using this type of representation. Algo- rithms used with lazy implementations are adapted from classical algorithms taught in grammar school. Thus complexity order is linear for addition and subtraction but quadratic for multiplication and division. This result is worse than the one obtained for implementations based on (def.1) where addition and subtraction algorithms are still linear but complexity of multiplication and division algorithms can be lowered to O(n1.59) 4 .

Second, an integer is associated to every digit of the representation. This integer, called error digit, ranging over the interval [0, b], gives an upper bound to the numbers represented by the remaining, less significative, digits. This additional information is used by arithmetical algorithms to measure approx- imation errors that influence digits.

Function norm has been introduced to lower the approximation of the first digit of the mantissa, augmenting the known accuracy. norm is unary and corresponds to identity functions: it only modifies the representation of the argument not the represented real value itself. This function reduce error e0 of the first digit x0 adding the possible carry of digit x1 to x0 by replacing x1 with the value x1mod b.

b. First digit of the sum of two reals is computed as follows. First the sum of the first error digits is computed. If ex0 + ey0 is small enough the first digit of the sum x0 + y0 is produced. Otherwise, if ex0 + ey0 is too large, that is greater than the base, function normr is applied to arguments and (alg.2) is applied again. As shown in Section 4 this algorithm does not suffer of the granularity problem.

Owing to the similarity between (def.3) and classical positional notation the arithmetical algorithms used with lazy implementations have always been derived from classical ones. Thus complexity order is linear for addition and subtraction but quadratic for multiplication and division. Instead with func-

The first implementation has been done using Scheme language[5]. Start- ing from the work of [4] the original notation has been changed and the new set of mathematical function has been developed. At first the original mul- tiplication algorithm has been used. The actual code of the implementation can be find at the URL www.dimi.uniud.it/~pietro/code.

