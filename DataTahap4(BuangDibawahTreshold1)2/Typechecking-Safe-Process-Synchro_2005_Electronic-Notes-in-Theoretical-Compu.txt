Session types describe the interactions between two parties within multi-party communications. They constitute a communication protocol in the sense that the order and type of interactions between two parties are specified. For their part, correspondence assertions provide a mechanism for synchronization. When session types and correspondence assertions are combined, they are able to describe synchronization across different communication sessions, yielding a rich language for imposing expressive interaction patterns in multi-party communications.

Increasingly in our society we are coming to depend upon processors for mon- itoring and controlling devices in almost all aspects of our lives. In many instances the behavior of these processors is governed by communication with other processors, which may be other components of the same system or may be remotely located. Examples where such communication is critical can be found in space exploration, air traffic control, medical devices, banking, and electronic commerce. It is of great importance to have high assurance that the software governing these communications and resulting decisions is correct.

The approach presented in this work applies to any situation where there is communication between multiple parties that can be factored into one-to- one communications. Session types [17,18] allow one to describe the exchange of information between two parties. They describe the information being exchanged, in which order it is exchanged, what party sends it, what party receives it, and the type of the information. However, session types alone fall short in restricting process interaction. For example, a small system involving processes Client, ATM and Bank is developed in [1,4]. It illustrates situations which cannot be captured by session types, including:

We assume given a set of names x, y, z,... We distinguish two distinct kinds of names: expression names, written a, b, c, . . . (which range over sessions and in- tegers); and channel names, written k, h, k',... We also have integer constants

assertion of the form begin L reduces these obligations by withdrawing the assertion label L from the current effect; likewise end L augments the current effect with L. Thus effects determine lower-bounds of the number of begin assertions that must be present. If the process has an empty effect, then all end assertions correspond to a matching begin assertion.

If we allow general arithmetic, which is not decidable, we can expect to define a sound semi-decision procedure: An algorithm without false positives or false negatives. If the algorithm says yes, then all information can be traced back to its sources. If the algorithm says no, the algorithm will exhibit a path showing that the data is not coming from the intended origin. If the algorithm fails to terminate, then we cannot deduce any information.

In order to keep the example simple we assume that Auctioneer can handle at most one seller at a time and that at least one buyer shall make a bid. For the same reason, we do not take into account error capture and recovery, such as when a bidder attempts to make a bid for an item which has not been placed for selling. In order to begin operating we assume that an initial seller and buyer have been placed, namely dummySeller and dummyBuyer . For this

bid: This is invoked by a buyer. Auctioneer reads in product, bid and contact information from the buyer. Then it informs the buyer manager BuyerManager that a new bidder has arrived and passes on the bidder and the other data that was input to this manager.

newBidder: selected by Auctioneer when a new bidder has arrived. Buyer- Manager reads in the bid and compares it to its current highest bid: if the former is greater than the latter then it informs the current highest bidder (i.e. currBuyer ) that it has been outbidded and recursively calls itself with the new bidder as a parameter; otherwise the new bidder is informed that her bid is too low and BuyerManager recursively calls itself with the current highest bidder as the highest bidder for the call.

This version of the bid operation places a smaller bid than the one orig- inally communicated to the auctioneer by the bidder. Unfortunately, the resulting electronic auction system is declared typable by the pure theory of session types, under the same typing assumptions as the original system. Other examples of the lack of expressiveness of the pure theory of session types are described in [1].

