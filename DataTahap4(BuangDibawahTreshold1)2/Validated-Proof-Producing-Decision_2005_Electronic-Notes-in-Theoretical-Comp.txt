A widely used technique to integrate decision procedures (DPs) with other systems is to have the DPs emit proofs of the formulas they report valid. One problem that arises is debugging the proof- producing code; it is very easy in standard programming languages to write code which produces an incorrect proof. This paper demonstrates how proof-producing DPs may be implemented in a programming language, called Rogue-Sigma-Pi (RSP), whose type system ensures that proofs are manipulated correctly. RSP combines the Rogue rewriting language and the Edinburgh Logical Framework (LF). Type-correct RSP programs are partially correct: essentially, any putative LF proof object produced by a type-correct RSP program is guaranteed to type check in LF. The paper describes a simple proof-producing combination of propositional satisfiability checking and congruence closure implemented in RSP.

The integration of congruence closure with the propositional validity checker follows the so-called eager approach, where assignments to atomic formulas are asserted to the decision procedure as they are made [3]. CC is responsible for notifying SAT immediately if the current set of asserted literals L1, L2,... , Ln is determined to be inconsistent. If such an inconsistency is detected, the current branch of the validitity check search is closed.

Assumption (Tactics): We assume we have the ability to write general pro- grams (tactics) which can manipulate H=-proofs. We use this assumption in just one case below, namely for the Deduction Theorem, whose proof is just a proof-transforming program (Section 2.8). We do not assume that we have the means to verify that tactics have properties like termination or case coverage. Hence, we do not assume that tactics always succeed.

False. We instrument CC to maintain proofs for all the intermediate facts it deduces. We would like to maintain proofs of facts like t = t', where t' is the signature representative of t. Since such facts are only valid under the assumptions given by SAT to CC, we must actually maintain slightly richer

The approach adopted here to producing proofs from CC in RVC is differ- ent from the approach followed in CVC [13, Chapter 5]. In CVC, each time a literal is asserted by SAT to a subsidiary DP like CC, the literal must be accompanied by a proof (that the literal holds). This is reasonable in proof systems with local assumptions, where the SAT solver may introduce a local assumption u that the literal holds, and provide u to CC as the proof of the literal. In the absence of local assumptions, this cannot be done directly. Rea- soning under assumptions is admissible in H=, however, due to the following elementary meta-theorem:

Using the instrumenting approach to proof production, RVC currently needs 52 lemmas to justify all the inferences it does. These lemmas have all been derived from the basic rules of H=. It is most convenient to derive lemmas using the Deduction Theorem. Since, as discussed above, the proof of the Deduction Theorem is essentially an untrusted tactic, we insist that proofs of lemmas using the Deduction Theorem be expanded out completely into proofs consisting just of primitive rules of H= and other lemmas (see Section 3.4).

check, and the soundness of RVC with respect to provability in H= has thus been statically verified. Bugs in the implementation could still cause RVC to fail to be complete. Furthermore, it can happen that due to run-time errors like pattern-matching failure, proofs could be generated with the special sym- bol Null in them. These proofs will not check. The exact statement of the guarantee provided by RSP is thus the following: any proof produced which does not contain Null is guaranteed to check.

For purposes of this paper, RSP can be thought of as an ML-like language with some additional features. The basic features RSP shares with ML are support for case analysis based on pattern-matching, and (general) recursion. RSP has pattern abstractions, which are essentially rewrite rules L -> R. These abstractions are applied (using an explicit @ operator) as functions to terms to transform them. If the pattern does not match, an application of such an abstraction evaluates to Null. Pattern abstractions can be joined with the deterministic choice operator | to perform case analysis. For example,

is a pattern abstraction transforming any expression of the form (f x x), where x is an Int (the only built-in type in RSP), to x+x. For this to be well- typed, we should have f declared to have type Int => Int => A for some type A. A need not be Int, because just as for ordinary functions, the domain and range type of a pattern abstraction need not be the same.

We come now to the crucial typing features of RSP which enable validated proof manipulation. Suppose we were implementing a proof-producing DP in ML. The natural way to represent H=-proofs would be as a datatype. That is, we would have a datatype of proofs, and we would then declare constructors corresponding to each proof rule:

The solution adopted in RSP is to refine the datatype Pf into a family of datatypes {Pf(P) | P : O}. We have a type Pf(P) for each well-formed formula P. Our intention previously was that Pf would be the datatype for all proofs. This turns out to be too crude, in the sense that we cannot restrict membership in that datatype just to proofs which prove a theorem. Our new intention is that the refined type Pf(P) will be the datatype of all proofs that prove P. It turns out that this can be conveniently enforced. Conceptually, we now have an infinite family for each constructor. For example, we have

All we need now is to have a way to define these infinite families of construc- tors. We achieve this simply by viewing each family as a function from the subscripting formulas to the appropriate constructor. For example, we view K as a function which takes in P and Q, and returns the constructor KP,Q. It suffices then to add type declarations like:

