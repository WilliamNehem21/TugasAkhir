so that the checking phase does not delete even unused objects. But another issue appears, because the rule above may execute forever without producing its output objects, even if input objects a and c are present: we have introduced divergence. In fact, after checking the presence of c, we should be able to give some kind of precedence to the second term of the choice, in order to ensure that if some object a is present, then the rule completes its job. By means of prioritised choice, it is possible to model this kind of precedence:

Again, the encoding is completely modular. Furthermore, it does not distinguish catalysts from common objects, in fact the distinction is only useful before compile- time to check the correctness of P system rules. The reason for the higher degree of priority will be clear in the next section.

First, a coin is given, then every execution of the rule eats a coin, but only a succesfull execution produces another coin: after the first failure, the loop ends. Yet, there are issues: in presence of two or more rules, the coin owned by a rule could be used by another one. Furthermore, if object a or c is absent, the process may pause in a spurious state and allow other rules to begin computing before ending execution or releasing back the catalyst c. Even if it is possible to prove that the final result does not change, this breaks the idea of atomicity for the application of a rule. Thus, channel coin must be private and the priority of every action shall be increased:

