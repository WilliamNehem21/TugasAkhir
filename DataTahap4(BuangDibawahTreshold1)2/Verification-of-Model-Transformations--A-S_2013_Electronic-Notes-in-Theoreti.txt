Within the Model-Driven Engineering paradigm, software development is based on the definition of mod- els providing different views of the system to be constructed and model transformations supporting a (semi)automatic development process. The verification of models and model transformations is crucial in order to improve the quality and the reliability of the products developed using this paradigm. In this context, the verification of a model transformation has three main components: the transformation itself, the properties of interest addressed, and the verification techniques used to establish the properties. In this paper we present an exhaustive review of the literature on the verification of model transformations analyz- ing these three components. We also take a problem-based approach exemplifying those aspects of interest that could be verified on a model transformation and show how this can be done. Finally, we conclude the need of an integrated environment for addressing the heterogeneous verification of model transformations.

The aim of this paper is to present a comprehensive review of the literature on the verification of model transformations extending the work in [2]. Particularly, we introduce the first dimension without going deeper, since there are well-known works [67,26] addressing this subject, and we extend the second and third dimensions with other aspects not addressed in [2]. We also follow a problem-based approach exemplifying by a case study those aspects of interest that could be verified on a model transformation and how they can be verified. Finally, we conclude the need of an integrated environment for addressing the heterogeneous verification of model transformations.

The remainder of the paper is structured as follows. We first detail the review process followed in Section 2. Then, in Section 3 we take a quick look at model transformations and define a running example. In Section 4 we introduce the differ- ent aspects of a transformation that must be verified, and in Section 5 we review how these aspects are verified in the literature. In Section 6 we use the running example to exemplify verification properties and discuss how they can be verified. Finally, in Section 7 we present some concluding remarks on this topic and guidelines for future work.

The inclusion criterion was based on the review of the title, abstracts and key- words of the papers found, evaluating whether they answered the initial question in some way. We considered both papers written in English and in Spanish. This initial set of papers was refined by reading their full text. Although some papers could not be considered of high quality since they were not published after a strict review process, we privileged their content in favor of answering the initial question. For space reasons we do not include here the complete literature review. An extended version of this work with a description of each paper can be found at [18].

In the MDE ecosystem everything is a model, even the code is considered as a model. In this context, a model is an abstraction of the system or its environment. Every model conforms to a metamodel, i.e. a model which introduces the syntax and semantics of certain kind of models. In the same way, a metamodel conforms to some metametamodel. A metametamodel is usually self-defined, which means that it can be specified by means of its own semantics.

This schema defines model-to-model transformations. There are also model-to- text and text-to-model transformations where the target and source models, re- spectively, are just strings not conforming to any specific metamodel. Without loss of generality we will only consider model-to-model transformations (from now just transformations, or model transformations).

However, this schema can be extended as is exhaustively studied in [26]. Leaving aside the details, the authors identify multiple variabilities on a model transforma- tion, e.g. it can be bidirectional, it can take more than one source model as input and/or produce multiple target models as output, its rule application strategy can be deterministic, non-deterministic or interactive, the source and target models could be at different abstraction levels or not (horizontal versus vertical transfor- mations), and the source and target models could conform to the same metamodel or not (endogenous versus exogenous transformations).

Beyond these aspects, there are several approaches for defining and executing model transformations, from direct-manipulation in which the transformations are usually developed in a programming language accessing an in-memory represen- tation of models (e.g. Java Metadata Interface [27]), to relational (a.k.a. declara- tive) which consists of defining transformation rules as mathematical relations be- tween source and target elements (e.g. Query/View/Transformation (QVT) Rela- tions [37]), via graph-transformation-based which consists of considering models as typed attributed labeled graphs and applying graph transformations techniques

In this section we will focus on the second dimension introduced in [2]: the properties of interest addressed by the verification of a model transformation. There are also other works [56,84] which introduce the problem of verification by defining the set of properties to be addressed. However, the contents of these proposals are mostly included in the former one. We thus present the categories of properties identified in

This category refers to the computational nature of transformations and target properties of transformation languages. As introduced in [2], a transformation spec- ification conforms to a transformation language which can possess properties on its own. In this context there are four properties of interest.

The third property, identified as a design-time property, is Typing, i.e. ensur- ing the well-formedness of the transformation specification w.r.t. its transformation language. The process of type checking may occur either at compile or run-time. Since model transformations are models, and models have metamodels (defining the transformation language), solutions to this problem are strongly related to Confor- mance and Model Typing as will be introduced in the next section.

Finally, we introduce a fourth property, not mentioned in [2], the Preservation of Execution Semantics property. This execution-time property states that the transformation execution must behave as expected according to the definition of the transformation language semantics. Related to this, and in strong contact with the Typing property, there are consistency needs between transformation rules which must also hold. For example, some languages do not allow an element of the input model to be matched more than once (redundancy problem). If this property does not hold, contradictory rules may be applied, e.g. two rules applied to the same element implying different things. Moreover, it is possible that a rule applied to an element of a hierarchy may be more restrictive than another one applied to an element in a lower level of the same hierarchy. In this case, there will be some models not matched by the second rule.

But verification interests go beyond this kind of problems. When verifying a mo- del transformation we want to consider its elements as a whole and not individually. In this sense, some authors, as in [16], use the notion of a transformation model, i.e. a model composed by the source and target metamodel, the transformation specifi- cation and the well-formedness rules. This transformation model could be implicit,

In this sense, there are properties known as Model Syntax Relations that relate metamodel elements of the source and the target metamodels trying to ensure that certain elements or structures of any input model will be transformed into other elements or structures of the output model. This problem arises when these relations cannot be inferred by just looking at the individual transformation rules, or when the transformation language does not allow expressing some relations, and another constraint language must be used. This is also known as preservation of transformation invariants or structural correspondence.

cover the entire metamodel, then this leads to some input models which cannot be transformed. From a functional point of view, syntactic completeness means that the transformation is a total function. When considered for a specific transforma- tion, determinism is also a functional property. In fact, as introduced in [16], when a transformation is total and deterministic, it is called functional.

We have seen a classification of the properties of interest addressed by the verifi- cation of a model transformation. This classification, formerly introduced in [2], identifies language-related and transformation-related properties, the first ones re- ferring to the computational nature of transformations and target properties of transformation languages, and the second ones referring to the modeling nature of transformations. We extended this classification by adding two subcategories addressing properties based on other related works.

representation of a system and the properties that must be verified, as well as a logic in that semantic domain which allows reasoning about that representation, leading from premises to conclusions. This process is usually carried out using the- orem proving software and it is usually only partially automated. Model checking also consists of using a mathematical representation of a system, and proofs consist of a systematic exhaustive exploration of the mathematical model. With the first approach there is usually a high verification cost, whilst with the second there are well-known limitations such as the state-explosion problem. On the other hand, testing relies on the construction of test strategies for a property including subse- quent execution of (either parts or all of) the system according to these strategies. Although testing is usually considered a validation strategy, it could be used for verification purposes. However, as it is well known, testing can only show the pres- ence of errors and not their absence. Finally, we can find strategies based on static

analysis, i.e. on the analysis of a model transformation that is performed without actually executing it. Static analysis typically consists on semi-decision techniques. In this sense, they are efficient but they cannot assure the overall correctness of the design. For matter of completeness we also consider the satisfaction of properties that hold by construction of the transformation, e.g. those achieved by using special transformation languages such as DSLTrans [8].

Beyond the basic conformance needs, there are usually invariants that cannot be captured by the structural rules of the modeling language. Invariants are well- formedness rules that must hold at all time for any model conforming to a meta- model. Invariants can be defined on metametamodels, metamodels and models. In the example the following invariants must hold on models:

Invariants can be expressed using a constraint language like the OCL, and as it was said in Section 4, this conformance checking is nowadays automatically ad- dressed within modeling frameworks using automated checkers. These checkers can be based on SAT solvers or model-checking, as in [3,32]. This verification is at a model level, but there are other alternatives, for example performing the verifica- tion using logical inference. In this case, we can formalize metamodels, models and

Finally, a complementary approach in [61] proposes a language for assertions based on first-order logic that describes some characteristics of a model under transformation. Then, they can derive how an assertion evolves when applying transformation rules using SWIProlog [88] as an inference system. If the assertions to be verified could be derived from the final assertion, thus they hold in the target model.

There are many alternatives for proving this property. First, we can use a formal language to state it and a proof assistant to prove it. We can also use the language for assertions and prove that this property can be derived from the final assertion. We explored these alternatives when discussed conformance and model typing.

Another option is to define a transformation contract stating the pre and post conditions of a transformation (or an individual rule), and check whether this con- tract holds. This contract could be written in OCL and then verified using an OCL checker or some other model-checker, as in [19,32]. It can also be written using a dedicated tool and then verified using some specific algorithm, as in [25,40].

As we already said in the previous section, these two properties are the hardest to prove since there are related to undecidable problems. One alternative to achieve them is to use some language which guarantees both by construction, as introduced in [8]. However, this option clearly reduces expressive power.

The preservation of the execution semantics is matter of verification during the development of a transformation engine. However, when defining a model trans- formation there are consistency needs that must be addressed. As an example, we may not want redundant rules, and indeed our example does not have redundancy. An example of a redundant rule would be one mapping attributes to columns but applicable only to persistent classes.

Only two properties are not considered within the example: Typing and Model Semantics Relations. As we said before, Typing is strongly related to Conformance and Model Typing. Also, since we are working with structural models, we do not have dynamic properties which are the main source of semantic properties. We might as well force some semantic property, but we decided to let the reader refer to [18] for more examples.

We conducted a comprehensive literature review on the verification of model trans- formations which was structured following the three dimensions presented in [2]. We extended the former review and followed a problem-based approach exemplifying those aspects of interest that could be verified on a transformation and discussing how they can be verified. For space reasons we left some details, which can be found at [18].

At this point it is clear that there exist several alternatives, not only for the specification of a transformation but also for its formal verification, which depend on those properties that must be addressed in each specific case. This problem increases when considering bidirectional, higher-order, and multi-model transformations. In this sense, there is some parallelism between MDE-built systems and traditional software systems: heterogeneous multi-logic specifications are needed, since different systems have different aspects that are best specified in different semantic domains. An example of this was introduced in the last section, where a small-size example introduces different problems, each of them best addressed by several strategies.

Related to this, the most common transformation approaches referred in the lit- erature are the relational and graph-based approaches. The point here is that those approaches closely related with traditional programming languages (direct manip- ulation, operational, etc.) introduce verification problems that are carried out by traditional code verification approaches. Moreover, both relational and graph-based

Working on this idea, we could express metamodels and transformations as so called institutions in some consistent and interdependent way, as well as transforma- tion properties in different logics (also institutions), and their translations (formally, institution (co)morphisms) into several logics with the purpose of proving transfor- mation properties. Models could be both represented as institutions or as sentences within the institution of metamodels. For example, considering our running exam- ple, we can represent models in XMI, metamodels in MOF, and transformations in QVT. These languages could be defined as institutions and there could be trans- lations from them to different logics (also specified as institutions), e.g. first-order logic, rewriting logic, modal logic, etc. If there is a conformance need specified in OCL, it could be possible to translate the different elements to rewriting logic and perform the verification as defined in [13].

To put these ideas into practice we can use the Heterogenous Tool Set (Hets, [69]) which is meant to support heterogeneous multi-logic specifications. Hets is a parsing, static analysis and proof management tool combining various such tools for individual specification languages. Nowadays the tool supports many logics (e.g. FOL, rewriting logic and modal logic) and tools (e.g. IsabelleHOL [72] and Maude [64]). Moreover, it provides proof management capabilities for monitoring the overall correctness of a heterogeneous specification whereas different parts of it are verified using, possibly different, proof systems.

Anyway, it is worth pointing out that the instantiation of this framework is not as direct as it seems. We need to formally specify firstly every MDE building block within the Theory of Institutions and secondly any possible and useful translation to those logics we need. These representations may neither be direct nor even possible within this theory.

