We describe the experience of implementing a Domain-Specific Language using transformation to a General Purpose Language. The domain of application is image processing and low-level computer vision. The transformation is accomplished using the Stratego/XT language transformation toolset. The implementa- tion presented here is contrasted with the original implementation carried out many years ago using standard compiler implementation tools of the day. We highlight some of the unexpected advantages afforded to us, as language designers and implementers, by the source-to-source transformation technique. We also present some of the practical challenges faced in the implementation and show how these issues were addressed.

This paper describes the re-implementation of a Domain-Specific Language for low- level computer vision called Apply. This work contributes a reflection on the expe- rience of using source-to-source transformation tools to implement a non-embedded Domain Specific Language. This work compares the implementation experience with that of more traditional compiler implementation techniques. Both implemen- tations were carried out by the same developer. The present Apply implementation was carried out over a period of five months and this paper distils the experience

a parser which constructed an Abstract Syntax Tree (AST). Hand-written C code implemented the analysis and generation of appropriate target code depending on the target platform. For example, the compiler could generate W2 code for the Warp processor, or C code for a uniprocessor UNIX machine.

The use of concrete syntax facilitated optimisations that would not have been feasible in the C version of the compiler. This encouraged the development of the Apply language to further enhance its expressivity without fear of sacrificing application performance. It also made it possible to compile the base language for more efficient execution on a uniprocessor machine than could have been achieved with the original design.

In the sections that follow we provide an outline of the domain of application. We introduce the Apply language and domain specific features and discuss the influence that using Stratego/XT has had on the language design. Then we discuss the implementation of the current Apply compiler and reflect on its development with reference to the original C-based implementation.

out or in out. Special features available in Apply include an abstract data type, called window which can only be used as the type of a formal parameter of a proce- dure. A window can either hold a single element of a specified primitive data-type or a two dimensional array of a specified primitive data-type with index ranges. Formal parameters of this type are declared with the syntax window of Type or window( Range,Range ) of Type border expr for scalar or subscripted instances respectively. The border expr modifier in the declaration is a succinct way of defin- ing how windows should be handled at the edges of the image. When a location of the window falls outside the image (as it would at the edges) the constant expres- sion given is substituted for the value that would otherwise have been taken for the image itself. Often this constant expression is zero.

The current implementation of Apply defines a number of new metaprogram- ming style language extensions. These extensions serve one of two purposes. Some extensions are used as hints to the compiler indicating possible optimisations. Other extensions make it easier to write the Stratego rules that will generate the code to target specific APIs. These extensions were not available in the original Apply def- inition, they have been added to the language as a direct result of the experience of using transformation techniques for the compiler implementation. Examples of these extensions include @known expressions, @apply statements, defined expres- sions and assert statements.

If the programmer knows a property of a variable but the compiler could not be expected to prove it, the programmer can assert this knowledge using the assert expr statement e.g. assert x>=2;. The compiler exploits this knowledge to op- timise code generation wherever possible. This statement could also be used to generate runtime checks, however currently this is not done.

generates assertions based on these loops. In particular the loop for row 1..100 do loop would generate the assertions row >= 1 and row <= 100. If the earlier @known example were included in the computation the Apply compiler would be

languages and the example code provided for Stratego/XT 3 was used as the basis of the Apply implementation. In particular implementing data-flow analysis, such as needed for constant propagation and unreachable code elimination, at the source code level is described in [7]. However some of the steps of transformation are unique to the Apply language and the design goals of its compiler and therefore deserve further discussion.

In the syntax of the Apply language, applied occurrences of variables of type window are indistinguishable from procedure calls. The Do Apply stage of the trans- formation uses the typing information to identify the applied occurrences of window variables and replaces them with WindowAccessScalar or WindowsAccessElement abstract syntax nodes for scalar and indexed variable respectively. The Do Apply stage also wraps the entire procedure body in the @apply language extension which represents a looping structure. The complete syntax for this extension is:

It is difficult to give an accurate measure of the relative complexity or effort involved, however to give a rough guide, and in the absence of accurate records of the time taken to program the original compiler, we compared the physical commented lines of code (LOC). We also counted non-commented code and present that as a proportion of the total. See [3] for further discussion.

9. The analysis and transformation stages for the original C implementation were smaller, however the current implementation does significantly more code manip- ulation and optimisation. The original compiler included a very simple C module for performing constant folding which handled 8 arithmetic operators computing constant values only when the arguments to the operator were themselves constant terms. By comparison constant folding in the current compiler handles 15 operators including boolean operators. This code more aggressively simplifies expressions, re- arranging them as necessary to bring constant terms together and removes operator

The reverse production format of the Stratego Syntax Definition Formalism (SDF) posed difficulties at first, as did identifying sources of ambiguities in the SDF grammar definition and correcting them. Being forced to re-specify the grammar represented a barrier to entry, but it facilitated the integration between concrete and abstract syntax. Overall productivity was greater than before, primarily due to the domain specific nature of Stratego over C.

C code generated by the old compiler with that of the current compiler. The tests were run with five combinations of CPU and C compiler. For each C compiler a range of common optimisation options were tested with the best option used for comparison for each compiler on each platform. See [3] for more details. Each measurement is the median time over 7 runs each involving 30 seconds of execution time with randomised array locations to avoid the impact of cache and paging.

We described the experience of implementing a Domain-Specific Language for im- age processing and low-level computer vision, comparing our experience of using Stratego/XT with the experience of using traditional techniques. The Stratego/XT toolset enabled easy implementation and provided opportunities to enhance the lan- guage and improve the performance of generated code. The use of concrete syntax in the transformations facilitated rapid retargeting to exploit available APIs and target environments. Our experience demonstrates that implementing a compiler by transformation to a GPL is a practical way of achieving a non-embedded DSL.

