The region calculus of Tofte and Talpin is an annotated polymorphically typed lambda calculus which makes memory allocation and deallocation explicit. It is intended as an intermediate language in a compiler for ML-like languages. The region annotations are obtained by static region and effect inference, which makes it an attractive alternative for garbage collection. Soundness of the region and effect system is crucial to guarantee safe deallocation of regions, i.e. deallocation should only take place for objects which are provable dead.

Tofte and Talpin have proved type soundness of the region calculus using rule- based co-induction. This proof is quite complicated and not very intuitive. Much of the problem lies in the low-level big-step operational semantics which involves manipulations of an explicit store and which has a co-inductive definition. In this paper, we present a small-step operational semantics for the region calculus, based on syntactic rewriting. We prove type soundness following the approach of Wright and Felleisen, leading to very simple inductive proofs.

Memory management for dynamic data structures is a problem in program- ming. While memory allocation is dictated by the problem at hand, there is considerable freedom in memory deallocation. If deallocation happens too late, the program suffers from memory bloat and space leaks, which impede performance. If deallocation happens too early, there might be dangling point- ers into deallocated memory. Dereferencing a dangling pointer is unsafe and might lead to a crash, or worse, to wrong results.

The region calculus of Tofte and Talpin [16, 15] provides an alternative method of memory management for the functional language ML. It is intended and used as an intermediate language in an ML compiler [2, 3, 14, 15, 16]. The basic idea is to split memory into regions that are allocated in a stack-like manner, directed by a construct of the language. Deallocation is instanta- neous, it just pops the topmost region from the stack. Using this method, it is possible to implement ML without garbage collection (in principle), while guaranteeing safety. In some instances, the region calculus can even prove that a pointer is semantically dead, so that the region it points to can be safely deallocated. Standard garbage collectors cannot do this.

The proof of consistency, or type soundness, for the region calculus as it is given by Tofte and Talpin [16] is a complicated proof using rule-based co- induction. The source of the complication is the co-inductive definition of consistency caused by the explicit use of a store in their big-step semantics. Recently, alternative type-soundness proofs for the region calculus have been proposed.

In contrast to the other soundness proofs [6, 1, 18], we treat the complete polymorphic region calculus. As noted by Tofte and Talpin [16], type poly- morphism does not add conceptual problems to the type soundness result, but polymorphic recursion gives rise to some subtle twists. We have included some illustrative cases in the paper.

After submission of this paper, we learned of another soundness proof by Calcagno [4]. He defines a high-level structural operational semantics and proves type soundness for it. The similarities between his big-step semantics and our small-step semantics are remarkable: the main difference is that our semantics is entirely based on syntactic rewriting, whereas his operational semantics propagates a set of live regions. Calcagno formally relates the high- level semantics to the original low-level semantics of Tofte and Talpin.

The rest of the paper is structured as follows: in Section 2 we introduce the region calculus. Section 3 presents the small-step operational semantics. Then, in Section 4, we recall the static semantics of Tofte and Talpin and provide the necessary extensions for our presentation. In Section 5, we prove syntactic type soundness. A small example is given in Section 6 and finally we conclude.

a new region, binds it to Q, evaluates e, and finally deallocates the region. Hence, the lifetime of a region corresponds with the lexical scope of Q. All memory-allocating constructs carry a region variable. It indicates the re- gion in which the allocation must be performed. Constants have a boxed representation, hence c at Q allocates memory in Q and stores the integer

We are currently working on a binding-time annotated version of the region calculus. The corresponding type soundness result amounts to the correctness of the binding-time analysis. It remains to show the other properties (for instance semantics preservation), in analogy to the results of Hatcliff and Danvy [10] for a monomorphic version of the computational metalanguage.

