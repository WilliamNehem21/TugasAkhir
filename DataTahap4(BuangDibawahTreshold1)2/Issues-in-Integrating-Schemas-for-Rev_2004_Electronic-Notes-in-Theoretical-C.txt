After adopting a standard format such as GXL to exchange graphs of artifacts for reverse engineer- ing tools, the next logical step is to define an appropriate schema for the information contained in the graphs. Various researchers have developed schemas, but in practice, it is still hard to choose an existing one. Typically, researchers end up needing to implement new schemas for the particulars of their tools or case studies. In the paper, we discuss a potential scenario for integrating schemas, with the aim of improving the interoperability among reverse engineering tools.

Some research work has been made to establish a standard schema for C/C++. Ferenc et al. explored building a standard schema for C/C++ at the abstract syntax tree level [6]. Three types of issues were analyzed in the Datrix and Columbus schemas: the lexical, the syntactic, and the semantic structure. The authors concluded that creating a standard schema for C/C++ is a complex problem, which produces many difficulties. Dean and Holt proposed a technique to combine two schemas to create a fact extractor [3].

cording to certain schemas, or due to missing elements that were of interest). Thus, we had to develop a new schema for C/C++ to be used with the Rigi reverse engineering tool. Preferably, we would rather spend more time in the analysis of the software system than in writing a fact extractor and its schema. We discuss the challenge and benefits of integrating existing schemas in Section 2. Section 4 describes in detail an example of integrating two given schemas. Section 3 describes the structuring of schemas in the reverse en- gineering domain. Section 5 presents our conclusions about this work, and

By having easier information exchange and methods to integrate data from diverse, complementary tools, users can form the best tool for the task at hand. Beyond having a common exchange format, it is necessary also to ensure that the exchanged information conforms to common, agreed semantics. The idea of integrating schemas comes naturally, but it is a significant challenge.

There are many schemas in the reverse engineering domain. Since they were developed independently, they have different structures and use differ- ent terminology for the entities, relationships, or attributes. Some of these differences identify the same thing, but are expressed in other words. Thus, we need to identify the logically common parts between these schemas. This process is called schema matching, and tries to produce a mapping between the elements of the two schemas that match semantically to each other. After this, we can view integrating the two schemas as a union of the two schemas, taking into consideration only once the elements discovered in the schema matching process.

The schema integration problem is very old, but it is still not completely solved. It has been investigated in the database field since the early 1980s [1]. Also, this problem is found in the artificial intelligence domain when integrating independently developed ontologies into a single ontology.

Jin et al. proposed a solution for transparent interoperability among re- verse engineering tools [11]. They defined a special adapter to deal with a domain ontology, which translates and filters the queries in a conceptual uni- fication, making integration possible. This is similar to creating a common intermediate language for all the reverse engineering tools. The more compre- hensive the ontology is, the more chances to obtain a good integration.

Rahm and Bernstein produced a survey of the existing approaches to au- tomatic schema matching [18]. They produced a taxonomy based on differ- ent criteria for the matches. They released an algorithm for general schema matching, called Cupid, that includes automated linguistic-based matching [14]. Cupid is based on the elements of the schema, as well as the structure of the schema.

Madhavan et al. proposed a novel approach for matching schemas [13]. The idea of this approach was to extract knowledge from past matching of schemas, and apply this knowledge to match new schemas. Schemas and mappings are added to the mapping knowledge base continually.

Two interesting classifications were presented by Jin et al. [10]. For catego- rizing the schemas, they considered the definition of schema (how the schema is defined, implicit or explicit ) and the locality of schema (where the schema is defined, internal or external ).

The subcategories contain schemas or integrated schemas as appropriate. For example, in the object-oriented subcategory, the schemas that reside here depend on what arises in practice from the existing schemas for Java, C++, etc., and the tools that deal with these languages.

This section presents an example of integrating two schemas, both intended for C/C++ elements. One of them is CPPDM developed by the University of Alberta, and the other one is DMM developed by the University of Ottawa. First, we introduce the two schemas and then we present their integration.

The aim of creating an integrated schema is to use it for integrating the data from different fact extractors. For example, if we have a software system that contains elements of C and Tcl, we might extract the facts separately for each language using the appropriate extractor, and store in two different repositories. Each repository conforms to its schema, for C and Tcl respec- tively. For data integration, we have to maintain the rules for mapping the elements from the initial schemas to the elements of the resulting schema. These rules may involve filtering data from each repository, or transforming the data as needed to conform to the new schema.

We provide an example of building attributes for the Class entity in the new schema. The attributes for the CPPDM Class entity are file, lineno, position and template. For the same entity in DMM the single attribute is isSubclassable. The set of the attributes for the Class entity in the new schema is then: file, lineno, position, template, and isSubclassable.

In this paper, we have outlined the need for integrating schemas for reverse engineering, and illustrated a process for integrating two given schemas. As future work, additional case studies are needed to apply the process for inte- grating schemas in reverse engineering. Also, we need to refine the derived transformation rules and their relationship to the data integration process. Another need is an approach for further changes of the integrated schema to enhance its reuse for a particular reverse engineering purpose.

