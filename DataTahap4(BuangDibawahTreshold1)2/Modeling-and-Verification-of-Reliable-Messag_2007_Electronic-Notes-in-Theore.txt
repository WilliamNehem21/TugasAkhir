Now we extend the core SOA metamodel of [2] to capture properties of reliable messaging between services. After enriching the domain metamodel, our long term goal is to define a corresponding UML profile to provide extensions to the UML language tailored to a specific application domain by introducing domain concepts, attributes and relations in the form of stereotypes and tagged values. However, the current paper only focuses on metamodel-level extensions for reliable messaging in the SOA metamodel.

LHS are left unchanged by the execution of the transformation, elements in LHS \ RHS are deleted while elements in RHS \ LHS are newly created by the rule. The fulfillment of the negative condition prevents the rule from being executed on the particular matching. Hereby we follow the Single Pushout Approach (SPO) approach [6] with negative application conditions [11].

A graph grammar (GG) consists of a start graph and a set of graph transforma- tion rules. A graph transition system (GTS) represents the state space generated by a graph grammar. The different states of the GG (i.e. the derived instance graphs) appear as nodes while edges denote state transition caused by the application of a graph transformation rule. An edge going from state s1 to state s2 with label r,o represents that from the graph instance s1 one can get graph instance s2 by the application of transformation rule r at match o.

In this paper, we use a compact visualization of graph transformation rules (first introduced in the Fujaba framework [8] and used in Groove [19]), when the entire rule is merged into a single pattern. Newly created elements are denoted by solid thick (green) lines (tagged as {new} in the editor) while deleted elements are depicted by dashed blue lines (tagged as {deleted}). Elements in the intersection of the LHS and the RHS are visualized normally (in black), and elements of NAC appear in thick dotted (red) lines. A negative condition is used in the current paper to prevent the rule from creating infinite number of new elements on the same matching (e.g. in the case of messaging, the same message is received only once).

The transformation rules were implemented in the Groove [19] tool, which supports the generation of the state space (i.e. a Graph Transition System - GTS) derived by a graph grammar. Using the Groove simulator, one can manually inspect the state space from a given start graph for verification purposes. While this is convenient for early tests of the GT specification, this is not very convincing in case of large state spaces. Unfortunately, the current public version of Groove (March, 2006) that we used in our experiments did not yet support the verification of CTL-like properties (reported recently in [20]).

High-level vs. low-level graph models and rules: We were able to translate (by hand) rich graph transformation rules and models (as used in [10] with inheri- tance, types, attributes, etc.) into lower level verification models (used in Groove) with relatively simple modeling tricks.

Our work conceptually follows the approach of [2] for specifying services in SOA. The authors of [3] describe the application of graph transformations in the runtime matching of behavioral Web service specifications. In [13], the conformance testing of Web services is based on graph transformations, focusing on the automated test case generation. However, none of these works discusses the aspects of reliable messaging. Our aim was to utilize the benefits of this approach by extending the metamodel and the transformation rules.

