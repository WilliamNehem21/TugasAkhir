We describe how a set-theoretic foundation for mathematics can be encoded in the new system Scunak. We then discuss an encoding of the construction of functions as functional relations in untyped set theory. Using the dependent type theory of Scunak, we can define object level application and lambda abstraction operators (in the spirit of higher-order abstract syntax) mediating between functions in the (meta-level) type theory and (object-level) functional relations. The encoding has also been exported to Automath and

Untyped set theory is often considered a foundation for mathematics because most of the usual mathematical objects of interest can be constructed as sets. For instance, certain sets can be considered pairs, and certain sets of pairs can be considered functions. In textbooks, this construction is described informally, as carrying out such a construction in standard first-order formulations of set theory is tedious. In this paper, we will describe how such a construction can be carried out in a natural, but fully formal, manner by encoding the construction in a dependent type theory. (Of course, such constructions have been formalized before in other systems [7,3,6].) The construction can be carried out using the type theories implemented in Twelf [8] or Automath [9]. However, we will show how the encoding becomes easier and arguably more natural using the system Scunak. We then export the signature

A Scunak signature can be translated into a Twelf or Automath signature. In both Twelf and Automath, one begins by declaring three basic type families cor- responding to obj, prop and pf. When translating to Twelf or Automath, any occurrences of class types are removed by Currying. So long as the Scunak sig- nature can be type-checked using the simplified typing system above (i.e., proof irrelevance is not needed), the resulting Twelf and Automath files should be well-

typed. In the signature described below, we have managed to remove all essential uses of proof irrelevance so that the corresponding Twelf and Automath files do type check. (Actually, one must explicitly add %abbrev to some Twelf abbreviations by hand, but this is a separate issue.)

Starting from the axioms of set theory described above, one can define the usual propositional connectives as well as bounded quantification. Also, one can construct pairs and define binary relations as certain sets of pairs. This provides the infras- tructure for defining functions (at the object level). We describe this infrastructure below.

A set A is a Kuratowski pair if there exist u and v such that A = {{u}, {u, v}}. To define this notion using bounded quantification, we make use of  A as a bound. One can prove that if any such u and v exist, they must inhabit  A.

is of class type class singleton. Applying the description operator the, we obtain a member of {y:B|<<x,y>>::f}. One can prove the first component of (the <{y:B|<<x,y>>::f},(funcImageSingleton A B f x)>) is in B. In the sig- nature, apProp abbreviates such a proof. Given this information, we can define an object level application as follows:

Note that in Twelf, ap is a function of six arguments instead of four. In particular, the object f is separated from the proof fp that f is a function from A to B. Likewise, the object x is separated from the proof xp that x is a member of A. Intuitively,

abbreviations. In particular, 4 of the Scunak abbreviations (the, kpair, ap, and lam) return a class type and therefore correspond to 8 abbreviations in Twelf and Automath. In Twelf, 11 abbreviations must be declared using %abbrev since there is no strict occurrence of some argument. Each of the three systems can type check the signature in less than a second.

Scunak provides a convenient way to specify a set theory and represent mathemat- ics within the set theory. Two of the reasons for the naturality of mathematics represented in Scunak are class types and the pam syntax. Class types allow one to treat arbitrary predicates (set-theoretic classes) as subtypes of the type of (un- typed) mathematical objects. The pam syntax allows one to give types and terms in a reasonably natural way.

