Our modus operandi to mechanically check a proof within Coq has nearly remained unchanged since the beginning. The proof is first written carefully on paper with as many details as possible. Then, this document is used as a guide to produce the script for the proof system. At this stage, the proof on paper and the script usually take different roads. The proof on paper is reworked, mainly shortened, so to be inserted into some technical report. The script is also modified. Good practice recommends to reorganize it in order to increase reusability and robustness.

The last source of inspiration comes from verification condition generators like Why [11]. These systems are used to prove the correctness of programs. They take as an input a program annotated with logical assertions and output a list of conditions. Proving all these conditions ensures that the annotations in the program are valid. We would like to have a similar mechanism for proofs on paper. Running the tool on a proof should generate a list of formal conditions that needs to be checked in order to ensure that what is written in the proof is correct.

The definition of the actual proof format derives directly from these con- siderations. An appropriate representation of proofs to highlight their struc- ture is known since decades. It is the natural deduction style proposed by Prawitz [21]. In the following we use some of the rules of natural deduction to illustrate how our format works. For the actual description of the format we use a mark-up language a` la XML [4].

In our format, formulae are expressed in a typed first-order logic. The syntax is directly inspired by the language to write logical assertions in Why. The language contains the usual logical connectors: conjunction and, disjunction or, implication ->, negation not. For example, the formula

Two aspects of our format for formulae are worth commenting. First, we could have chosen the Coq syntax for formulae but have decided to use a language that is independent of a particular prover. We believe that this independence is a key issue for maintaining large formal developments on the long run. Second, we have chosen a textual representation. A natural alternative would be to use MathML [5]. As a matter of fact, an earlier version of our proof format [26] did use a light version of MathML. For example, the formula

Indentation is used here for readability only. No specific layout is imposed by the format. Also the relative positions of the subgoals and the conclusion are free. Putting the conclusion first gives a goal-directed flavour to the proof. What is proved is given before explaining why it holds. Putting the conclusion last gives the more usual forward style. Most of the time a proof on paper is carried out using the forward style, but for key steps like the application of an inductive principle the conclusion may be given first. Our format easily accommodates both styles.

No limit is put on the number of assumptions and subproofs a proof can hold. Local variables are represented with the tag v. As our language is typed, the text enclosed by the tag must have the form name:type. We illustrate the

However, putting the name inside the text of the assumption is not a good idea. It gives a very limited naming schema, no extra text can be added. To get a more general one, an extra tag f is used to indicate the value of the assumption. Named assumptions should then be written as

In program verification, in order to generate the conditions one needs to use elaborate techniques such as computing the weakest preconditions. For our format, the generation is much simpler. The algorithm is illustrated here for Coq but could be easily adapted to other systems. It consists in a traversal of the tagged structure from top to bottom and from left to right. Each time a proof tag is encountered, its subproofs are first recursively processed before generating the condition associated with the tag.

first introduces assumptions. In Coq, assumptions can be named. The name given in the document can then be faithfully reflected inside Coq. The tactic Intros h1 introduces the first assumption A with the name h1. The final tac- tic Apply ok is generated so that the proof is always accepted by the prover 2 . This simple trick gives typechecking for free: any error in the initial document is automatically detected by the prover when processing the generated file. As each lemma represents a single step in the proof, tracking the origin of an error in the initial document is easy. The actual task of formally check- ing the proof consists in replacing all the applications of the axiom ok with appropriate tactics.

The third tactic simply introduces C with the name h2 in the assumption list. Note that the generator takes a special care in introducing assumptions in the proper order. The assumptions introduced last are the ones displayed next to the conclusion. In our example, the closest assumption is h2, then p1 and then h1.

In the generation, the main degree of freedom concerns the visibility of the different subproofs. In natural deduction, if a proof P has n subproofs p1, p2, ... pn, these subproofs are considered independent. For example, one cannot use the fact that the conclusion of p1 is true in the proof p2 without copying the whole proof. In a textual proof, the proof p1 is read before the proof p2. It seems then more natural to have a less restrictive policy. For this reason, the visibility rule we have implemented in our generation is that the conclusion of pi is visible inside pj for i < j and invisible outside P . A similar approach has been adopted by Richard Bornat [3] for the box style proposed by Fitch in [12].

So far we have presented our format and have shown how the conditions are generated. We still need to show how proofs on paper can be translated into our format. The idea behind our format is that this can be done mostly by just adding tags to the text of the proof. We illustrate this with a proof of an elementary property of the exponential function over integers:

A graphical interface has been developed to build proofs in our format 3 . The interface is composed of a single window. Any text can be read in this window. For example, reading the initial tag-free proof text of Section 3 gives:

Conclusions are coloured in blue and assumptions in green. In order to keep the number of colours as small as possible, we have decided to use the same colour for variables and assumptions. Like this, we have just three colours: red for names, green for what is assumed and blue for what is proved. Note also that proof tags are not visible in the picture above. This is because proofs can be nested. So colouring a proof would automatically hide the colour of its subproofs. Our solution is to colour at most one subproof at a time: the smallest subproof, if it exists, that contains the current selection. For example, if in the final coloured proof the assumption of the second subproof is selected, the whole second subproof is coloured in grey:

Finally the labels Coloured, Tagged and Coq at the bottom of the window allow the user to select the output he/she wants. So far, we have been using the coloured output. Pressing the Tagged label gives the tagged version of the text. It is the one that is saved on disk. The Coq label gives the list of the generated conditions.

There have been attempts to get a more natural language to interact with provers. The first and most impressive one by far is the Mizar project [20]. Other interesting attempts include [1,24,27,30]. Following the terminology used in [13], these systems propose a declarative style of proving, while systems like Coq offer a procedural approach. Declarative scripts usually contain lots of formulae and are then closer to proofs on paper. Unfortunately, these systems impose some strong restrictions on the way proofs should be written. In Mizar, for example, the proof has to be given with the level of detail imposed by the system. As the system has very little automation, proof scripts are often too

detailed for a human reader. A recent proposal [28] aims at relaxing this constraint. In Isar [27], some basic constructs are hard-wired. An example is the proof by case analysis, where the presentation of the different cases in the document has to follow the exact order in which the object was declared.

Other interesting approaches include attempts to accommodate both pro- cedural and declarative styles [9,16,29], extract proof texts from tactics [6], extract proof texts from proof objects [2,7,23]. Note that when provers have proof objects, it would be possible to automatically convert proof objects into our format in a very similar way as in [2,7]. The result would most probably be far too detailed. However, with some support for improving the presenta- tion while keeping the proof script consistent, this reverse engineering activity could be an effective way to get readable proofs.

In this paper we have presented a very simple and flexible format for writing formal proofs. This format is independent of a particular prover. Writing proofs is meant to be as natural as possible. With respect to the usual way of writing proofs, the author is only asked to explicitly indicate the proof structure. At each step it is then clear what the assumptions are and what the conclusion is. We have also presented a very simple user interface to help writing proofs in this format. With this interface, proofs are translated into our format by a simple colouring process.

In the introduction we have described three drawbacks of the usual loose connection between the published proof and its machine-checked version. The first drawback was that the computer proof usually only checks the final state- ment of the published proof. In our framework we get a tighter connection. Every step of the published proof has been checked and for each step there is a corresponding lemma in the formal development. The second drawback was the difficulty of maintaining proofs. To ease maintenance a good practice is to always split big proofs into smaller pieces. Our generating process enforces this practice as every lemma only covers a single step of the proof on paper. The last drawback was the difficulty of experimenting with slightly different versions of the final statement. In our case, the variations can be done directly on the published proof by changing the statement. When re-running the proof script, the lemmas that the prover fails to re-establish directly correspond to the steps that need to be fixed in the published proof.

Some more work is still needed in order to turn our experiment into a realistic approach. First, the format has to be tested intensively against large proof developments. We are planning to use it to re-engineer our formalisation of floating-point numbers [8]. Second, the conditions that are generated are rarely provable automatically by Coq. Even if full automation is not our main goal, more tactics need to be developed in order to get a reasonable ratio of conditions proved automatically. Finally, we are investigating the possibility of using directly a scientific editor such as TeXmacs [25] to write proofs. This would give us for free the usual display for mathematical expressions. With a textual representation, notations as the one for integration or the one for matrices are known to be difficult to render.

