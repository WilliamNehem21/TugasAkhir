In the context of Dolev-Yao style analysis of security protocols, we consider the capability of an intruder to dynamically choose and assign names to agents. This capability has been overlooked in all significant protocol verification frameworks based on formal methods. We identify and classify new type-flaw attacks arising from this capability.

In this paper, we introduce and discuss new intruder abilities concerning the dynamic selection of names for compromised agents and potentially even for honest agents. In contrast to the well-known type-flaw attacks, such as the one shown on the Needham-Schroeder protocol, which are based on the assumption that agent names are static, we allow the adversary to choose dynamically created terms as the name of an agent. Dynamic agent naming is typically not being considered by protocol verification frameworks and tools.

name type-flaw attack on a published protocol upon which previously no attacks were known. In the attack, using a dynamically created name, the intruder takes advantage of a type flaw to learn a shared key. This type-flaw attack would not be possible with a static name.

We distinguish between two types of chosen-name attacks. In a selected-name attack, the intruder can select arbitrary names for compromised agents only, while in an assigned-name attack the intruder may additionally assign arbitrary names to uncompromised, i.e. honest agents. Aside from the fact that assigned-name attacks are much more specialized than selected-name attacks, the two classes also have distinct targets. In selected-name attacks malicious agents choose their name to attack other agents, hence the veracity of security properties for these agents may be ignored, while in assigned-name attacks the victim may very well be the agent that is being assigned a name. Note that while the attacker may assign a name to an honest agent in order to attack another victim, in general these attacks can also be executed as selected-name attacks.

their own, but have been rather occurring as instances of other classes, such as impersonation attacks, man-in-the-middle attacks, or relay attacks. The chosen- name type-flaw attacks, however, are new and did not receive attention before. In the rest of this section we will therefore restrict ourselves to chosen-name type-flaw attacks. We will discuss existing chosen-name attacks in Section 3.

to s. In this message s interprets a as a nonce and nb as a name and responds with a newly generated key, k(b, nb), for b and nb. Agent nb can decrypt the first part of the message to learn the key k(b, nb). He then reverses the order of the two parts of the message and forwards them to b. Agent b decrypts {a, nb, k(b, nb)}k(b,s) and thinks that k(b, nb) is the freshly generated key that he should use in his session with a. He then forwards the ticket {b, na, k(b, nb)}k(nb,s) together with a newly created nonce nb' to a. The adversary intercepts this message and respond to it by encrypting the nonce nb' with the key k(b, nb) and impersonating a.

{nnbe, (nb, e)}pk(b). The conversation between the two honest agents continues and at the end of the protocol, (nb, e) and b agree on a secret value nnbe. The adversary takes the first message of this conversation and inserts it into the running session between b and eve. Agent b receives this message and confuses the name (nb, e)

This attack can be modified to impersonate b to nb and invalidate both secrecy claims of nb as follows. When (nb, e) sends out the first message of the protocol, the adversary can block the communication between the agents (nb, e) and b and inject the message {nnbe, (nb, e)}pk(b) into his run with b to learn nnbe. He then picks a nonce ne to construct the message {ne, nnbe, b}pk((nb,e)). The adversary now knows both nonces and has furthermore impersonated b to nb. The security claims of b are not invalidated though, since b does not finish the protocol.

Since the introduction of type flaws in security protocol analysis [7] various approaches have been used to detect and prevent type flaws. In [15] a tagging scheme is presented that prevents simple type flaws. Simple type flaws occur when one variable is unified with a complex term or a variable of another type.

More complex type-flaw attacks are described in [23]. These attacks emerge when tags are confused with terms or when parts of a term are confused with another term. The detection of complex type flaws is formalized in [23,24,18,19]. Research in this area focuses on the transitions from abstract message specification into concrete bit strings and vice versa.

Most formal models underlying tools for verification of security protocols can be extended to express chosen-name attacks. However, it will not necessarily be easy to extend the tools themselves. Especially tools that search through the state space of a given finite scenario will face the problem of having to choose appropriate agent names from an infinite domain.

