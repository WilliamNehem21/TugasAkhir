by proposing alternative movement capabilities. We may mention Mobile Safe Ambients (SA) [13,14], Robust Ambients (ROAM) [10], Safe Ambients with Passwords (SAP) [16], the Push and Pull Ambient Calculus (PAC) [20], Controlled Ambients (CA) [23], and the version of Boxed Ambients [2] with passwords (NBA) [3]. We shall use the term Ambient Calculus (AC) to refer to all of these variants.

The major question left open by previous work is whether pure AC with- out the open capability which dissolves ambients can be Turing complete. This question is of particular interest in view of the decision which Bugliesi, Castagna and Crafa took to dispense with ambient opening when proposing their calculus of Boxed Ambients [2,17,3,7]. They advocate communication between ambients where one is contained in the other, rather than the same- ambient communication of Mobile Ambients. A similar model of communica- tion is employed in [19].

We give an encoding of counter machines into pure MA without restriction, and without the open capability (Theorem 3.6), showing that this fragment is Turing complete. The encoding also demonstrates that both termination and the observation of weak barbs are undecidable problems. As far as we are aware, Turing completeness has not previously been shown for any pure ambient calculus without the capability to dissolve ambients (although we note that an encoding of pi-calculus into Boxed Ambients with communication is given in [2]).

Robust Ambients (ROAM) [10] is another calculus where ambients must synchronise to perform an entry. For m[ P ] to enter n[ Q ], P must name n and Q must name m, which is a symmetrical blending of subjective and objective movement. Turing completeness results for either MA or PAC will extend to ROAM (since our encodings use only a finite set of names).

We are interested in finding minimal Turing complete fragments of AC. This entails showing that smaller fragments are too weak to be Turing com- plete. Busi and Zavattaro have shown that in the fragment of MA with the open capability, but without movement capabilities or restriction, it is decid- able whether a given process has a non-terminating computation [4]. We show the same decidability property for fragments with capabilities allowing move- ment in one direction only (either entering or exiting). We also show that in certain smaller fragments (where replication is only allowed on capabilities) every computation terminates.

The paper is organised as follows. In Section 2 we recall various operators and capabilities of the Ambient Calculus, together with their associated no- tions of reduction. In Section 3 we discuss various Turing complete languages, with and without the open capability. In Section 4 we show that certain frag-

set of capabilities. When we consider languages with capability in, we shall always have capability in as well, and we shall adopt rule (SafeIn) and not rule (In). Clearly, if a language has capabilities in, in and replication on these capabilities, then the effect of rule (In) can be simulated; every ambient can be made perfectly receptive to entering processes by converting n[ P ] into n[ ! in n | P ]. Similar considerations apply to capabilities out and out.

A basic measure of the computational strength of a process language is whether Turing machines, or some other Turing-complete formalism, can be encoded in the language. Cardelli and Gordon [6] established that pure Mobile Ambients can encode Turing machines. Busi and Zavattaro [4] improved this result by showing that counter machines (CMs) can be encoded in pure MA without restriction. They also showed that the fragment of pure MA with no movement capabilities (but with restriction) can encode CMs.

It is striking that empty ambients with no movement capabilities are enough. There is an essential use of restriction to obtain the effect of mutual recursion. Nevertheless, this result shows the strength of the open capability. We wish to investigate whether we can achieve Turing completeness without open.

time they are used, as the code for either decrement or jump is left unused. We therefore parametrise our encoding by the index l of the stage we have reached in the computation. Let dec(i, l) (resp. jump(i, l)) be the number of decrements (resp. jumps) performed by instruction i during the computation of CM up to, but not including, stage l.

An instruction process [Ii]]l is triggered by the presence of sti at the top level; the instruction starts by consuming sti. The execution of [Ii]]l finishes by unleashing the sti ambient corresponding to the next instruction. Throughout the computation, at most one sti ambient is present. The encoded machine terminates if and when the ambient sta+1 appears at the top level. There are various cases depending on the nature of the instruction Ii.

An instruction process of the form [i : Inc(j)]]l creates a new register rj[ s[ ] ], which already contains the successor ambient needed to perform the increment. The new register pulls the existing rj into its core, and strips off the outer casing. The instruction then signals completion by pushing out the trigger for the next instruction. Computation is entirely deterministic. We have:

Clearly Lio is a sublanguage of Lop as defined earlier. The major difference is that Lio does not have the open capability. Also, replication is only applied to the capabilities. We shall see in Sections 4 and 5 that the computational strength of a language can depend on whether replication is applied to capa- bilities or to ambients.

Registers consist of a series of double skins s[ t[ ... ]] with z[ ] at the core. We use a double skin rather than the more obvious s[ s[ z[ ] ] ] style. This is to help with decrementing, which is done by stripping off the outermost s and then in a separate operation stripping off the t now exposed.

As the computation proceeds, inert garbage accumulates in both the in- structions and the registers. We handle this much as in the proof of Theo- rem 3.4, letting the encodings of the instructions and the registers be para- metrised with the current step in the computation.

We would like to know whether the language Lio of Subsection 3.4 is a minimal Turing-complete language. As a partial answer to this question, we shall show in this section that if we remove one of the movement capabilities (either in or out) then the resulting language is in fact terminating, i.e. every computation terminates.

and we let rd(m[ P ]) =df rnd(P cap). This is well-defined with respect to struc- tural congruence. Notice that the degree of an ambient is unchanged through- out a computation. It is unaffected by other ambients entering of whatever degree. Also, no capability can ever disappear.

Remark 4.4 If we combine replication with the open capability we can create non-terminating processes such as n[ ] | ! open n.n[ ]. Busi and Zavattaro [4] showed that termination is decidable for processes built with replication and open (see Theorem 5.2 in Section 5).

Busi and Zavattaro showed that termination is decidable in a language without restriction, and with open but no movement capabilities. They are able to allow unboxed recursion rather than merely replication. Their proof relies on the facts that any process has only finitely many names (since re- striction is absent), and that there is a finite bound on the nesting depth of ambients. These properties remain true if we add the out and push capabilities, since these cannot increase nesting depth of ambients.

processes, under which, for instance, P is below P | Q, is a well-quasi-ordering. They then use the theory of well-structured transition systems [9] to deduce that termination is decidable. We make appropriate changes to their ordering on processes to incorporate the added capabilities.	 

Matters are different when it comes to the in capability and full replication (rather than replication on capabilities, as considered in Section 4). Even such a simple process as ! n[ in n ] can have a computation with unbounded ambient nesting depth. The proof method of Theorem 5.2 is therefore not available.

Here P ' is got from P by removing the capability component of P , i.e. any in or replicated in capabilities which n[ P ] can exercise. We replace all replicated ambients after unfolding them exactly once. The replacement ![ P ] is not an

Notice that ![ P ] can engage in at most one reduction, and that DIV has no reductions. Therefore we can adapt Theorem 4.2 to show that every compu- tation in LD terminates. Furthermore, every process has a finite computation tree which can be constructed effectively. Then a process P of Lin has a non- terminating computation iff there is any occurrence of DIV in the computation tree of PD.

Secondly, only one ambient is spun off to create PD, while in Lin we allow indefinitely many. But if an unbounded number of spun-off ambients each do at least one reduction, rule (AmbDiv) would apply. If an unbounded number of spun-off ambients get entered, then each of these entries can be simulated using the single spun-off ambient of PD. (Of course this cannot in fact happen

