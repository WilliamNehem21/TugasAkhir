Code similarity is an important component of program analysis that finds application in many fields of computer science. Graph based representations of programs, such as control flow graphs and dependency graphs, are often used as a basis for deciding code similarity. Indeed, many similarity algorithms observe particular properties of these graph-based representations of programs in order to decide whether two programs are similar or not. In this work we propose a general framework for similarity analysis where the similarity of programs is expressed in terms of abstractions of their control flow graphs representation. In particular, we consider abstractions of the basic blocks of a control flow graph.

Code similarity studies if two programs are similar or if one program is similar to a portion of another program (code containment). Code similarity is an important component of program analysis that finds application in many fields of computer science, such as reverse engineering of big collections of code fragments [13,16], clone detection [2,8], identification of violations of the intellectual property of pro- grams [1,17,12], malware detection [9,10,15], software maintenance [11,19], software forensics [2,14]. In these applications, when comparing two fragments of code it is important to take into account changes due to code evolution, compiler optimiza- tion and post-compile obfuscation. These code changes give rise to fragments of code that are syntactically different while having the same intended behavior. This means that it is important to recognize modifications of the same program that are obtained though compiler optimization or code obfuscation as similar. To this end we need to abstract from syntactic changes and implementation details that do not alter the intended behavior of programs, namely that preserve to some extent the semantics of programs.

In order to consider both semantic meanings and syntactic patterns, existing tools for similarity analysis often employ mixed syntactic/symbolic and semantic representations of programs, as for example control flow graphs and dependency graphs that express the flow of control or the dependencies among program instruc- tions. Recently, in [7] the authors investigate the use of symbolic finite automata (SFA) and their abstractions for the analysis of code similarity. SFAs have been introduced in [18] as an extension of traditional finite state automata for modeling languages with a potential infinite alphabet. Transitions in a SFA are modeled as constraints interpreted in a given Boolean algebra, providing the semantic interpre- tation of constraints, and therefore the (potentially infinite) structural components of the language recognized (see [5,18]). In [7] the authors show how SFAs can be used to represent both the syntax and the semantics of programs written in an arbitrary programming language, the idea is to label transitions with syntactic la- bels representing program instructions, while their interpretation is given by the semantics of such instructions. Thus, SFAs provide the ideal formal setting in order to treat within the same model the abstraction of both the syntactic structure of programs and their intended semantics. A formal framework for the abstraction of syntactic and semantic properties of SFAs and therefore of programs represented as SFAs is presented in [7]. This formal framework turns out to be very useful in the understanding of existing similarity analysis tools, and in the development of similarity analysis tools based on semantic and syntactic properties of programs.

Structure of the paper: Section 2 recalls the basic notions used in the paper. In Section 3 we present a similarity analysis framework based on the abstract inter- pretation of the CFG. In Section 4 we present the details of our implementation and discuss the results that we have obtained. The paper ends with a discussion on future work.

CFG Extractor: We have implemented an algorithm that dynamically ex- tracts CFGs of programs from corresponding execution traces, thus studying what is effectively executed and the effects on the system. This may be useful in the analysis of malicious programs where the code may be packed, or in the analysis of code that employs code obfuscation such as opaque predicate insertion for im- peding reverse engineering. Indeed, by analyzing the execution trace of a program that contains an encrypted section it is possible to discover and comprehend the encryption/decryption engine and sometimes also the used keys.

In our implementation, we collect finite dynamic traces using a timer to end the computation after a finite amount of time in case of non-termination. Each trace is then represented as a single graph, where each instruction is contained in a node that is identified by the line number of the instruction and the execution flow is given by directed edges. If the trace passes from the same point more than once, no node is added but the existing ones are used and reconnected, because of unique node identifications. This allows us to represent loops. These graphs representing the single dynamic traces are then merged together to create a unique graph, through node identifications. At the end, the graph is commuted into a CFG by

Abstraction engine: Once the CFG has been extracted, the abstraction can be performed. In our implementation we have considered basic block abstractions that work on single instructions. The main idea is to abstract the instructions in the basic blocks using typed symbolic variables in order to be independent from variable names. This is done by consistently replacing variable names with symbolic variables inside a block. The replacement is consistent in that two occurrences of the same variable in the same block are replaced by the same variable. In addition to abstracting the variable names, also constants are abstracted. This can be expressed

sion, right hand-side, and assigns the resulting value to a target, left hand-side. We consider variables of type string and of type number (including integers, floats and booleans), while the other types are set to unknown. In our abstractions every constant is abstracted to its type: for example, "hello world" is abstracted to str (string) while 3 is abstracted to numb (number). Instead, every variable is abstracted into a symbolic name (in the following we use capital letters to denote symbolic names of variables). We assign a default value to the variables present in the right hand-side that are not previously declared or used. For example, if a basic block contains the assignment y = x but there are not previously uses of x, the ab- straction rewrites this assignment to B = def[A], where A and B are the symbolic names of variables and def[A] denotes the default value of the symbolic variable A. Moreover, we consider function composition as a single function: fun1(fun2(x),

Observe that, since the basic block abstractions that we have considered work on single instruction, we can measure the block similarity as the number of common ab- stract instructions. In this way we treat basic block as sets of instructions, thus loos- ing any information on the order in which these instructions are performed. Next, global similarity of the graphs is computed by summing up the block-similarities with respect to the maximal size of the considered graphs.

The experiments confirm that when checking for sub-graph isomorphims we can capture more similarities. Indeed, the similarity between infected program and their original version can only be captured when considering sub-graph isomorphism, while the similarity between obfuscated variants of code can also be captured when considering isomorphism over the whole abstract CFGs. At the same time sub-graph isomorpism lead to global similarity values that are in general lower than those obtained when an isomorphism between the whole graphs is found, this depends on the definition of global-similarity that considers the local similarities over the entire graphs and not only over the size of the match that has been found.

P. Cousot and R. Cousot. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In Proc. of the 4th ACM Symposium on Principles of Programming Languages (POPL 77), pages 238252. ACM Press, 1977.

M. Polino, A. Scorti, F. Maggi and S. Zanero: Jackdaw: Towards Automatic Reverse Engineering of Large Datasets of Binaries. In Proc. of the Detection of Intrusions and Malware & Vulnerability Assessment, Third International Conference, DIMVA 2015 pages 121-143, Springer LNCS 9148, 2015.

