the symbol H represents choice. The informal semantics of the selection construct is that it may perform any action Si for which the corresponding guard gi is true. If no guard is true, the whole construct acts as a skip, i.e. has no effect.

Whilst this analysis does what is claimed, the description of Sr uses an irre- versible step: v := e. We will also use such irreversible steps in our simulation of reversibility, but we give here an analysis of how purely reversible updates may be performed. Our analysis is in terms of assignment statements; a treatment of reversible updates in terms of injective functions is given by Yokoyama et al in [14].

The RVM is based on Forth [7]. Forth provides a stack based virtual machine, along with an interpreter which allows operations to be entered from a console or read from a file. A simple but extensible compiler allows new operations to be defined in terms of existing ones. An example of an interpreted interaction is:

and switches back to interpret mode. Forth is a language of commands rather than syntax, though commands may impose some restrictions on what input Forth will accept. For example  :  could print an error if the system is not in interpret mode.

Forth uses separate parameter and return stacks. The RVM adds a history stack to support reverse execution and includes reversible versions of all memory changing operations. As the above example shows, use of local variables is not obligatory, as parameters can be accessed directly from the stack. However, the RVM supports local variables and nested scopes, with stack frames held on the parameter stack.

The virtual machine consists of a nucleus and a utilities layer. The nucleus definitions are written in either Forth or in our structured version of Gnu assembler. Compilation of the nucleus generates a monolithic Gnu assembler program, which can be linked with programs written in other languages, predominantly C. The nucleus provides an interactive Forth system which has few features (no control structures or variables even) but which can extend itself by incremental compilation, due to its ability to parse the input stream and compile code.

in a structured adaptation of the GNU assembler. Glancing at the code below, the reader will notice a register exchange at the start and end of each of these operations. This is because Forth based virtual machines have separate return stack and parameter stack pointers, and the Intel platform provides only one fully featured stack pointer. By exchanging these registers, which the RVM uses as its parameter and return stack pointers, we can use the fully featured Intel stack pointer as the RVM parameter stack pointer within the body of the primitive definition.

In RVM-Forth, to use this form of choice to select between programs A, B .. C, we write <CHOICE A [] B [] .. [] C CHOICE>. As each choice is compiled it is prefixed by code that primes the history stack to conditionally switch back to forward execution and transfer control to the following choice. The condition for making the switch is that the system is not in reverse execution mode as the result

The values pushed onto the history stack by the choice prefix code are the parameter and frame stack pointers, the label of the following choice, and the address of the code fragment choice_r. This primes the return stack so that backtracking to this point will pass control to the code fragment choice_r. That code fragment must restore the parameter stack and frame pointer and re-enter forward execution at the following choice.

is reached the stack will contain 1 1. MAGIC will force backtracking to be invoked. Forward execution will start again from the next choice within the operation 1[]2 and will then return. We need a mechanism to ensure, among other things, that the return stack pointer and top return stack value are restored to the state they were in when the previous choice was made, so that the return from 1[]2 will be correctly performed. This is achieved by the following code which the meta-compiler appends to every compiled definition containing a choice construct.

Finally we need to consider what happens when backtracking returns to the first occurrence of the operation 1[]2, i.e the one which is invoked by a call from within the operation TEST1. When this occurs, the return address for TEST1 must be restored. The mechanism used is similar to the one just described, except that we must not alter the return stack pointer. That will be restored as described above. We designate TEST1 as an operation which inherits choice. The set of such words is defined recursively as the words which invoke a word which has choice, together with the words which invoke a word which inherits choice. The following code is appended to words which inherit choice:

The operation <TRY limits the scope of irrevocable reverse execution. It does not resume forward execution, but rather changes the nature of reverse execution so that forward execution can be resumed further back, e.g. at a choice with an unexplored alternative.

Where S is the postfix translation of S and E the postfix translation of E . E may alternatively be an expression representing (as a reference) a set, and ordered pair, or a string. Then we must use SET, PAIR> or STRING> in place of INT>. These variations are concerned with protecting referenced data from erasure during reverse execution by cloning it; different forms of data are cloned in different ways, and our implementation does not have a sufficient awareness of type in the above context for the correct form of cloning to be selected automatically.

3 Our type theory is based on that of J. R. Abrial, in which types are maximal sets. Our concrete repre- sentation of types, however, is built from on empty sets: INT and STRING are the empty sets of integers and strings respectively.

0 9 .. VALUE_ DIGIT ( declare set of digits ) HP! ( protect data ) Standard Forth variable declaration syntax is <expression> VALUE <name>, and in RVM-FORTH this can also be used to declare local variables. VALUE_ is used to declare a variable which is to be restored on reverse execution.

The operation PUZZLE below leaves a solution in the variables t,w,o,f,u,r, and also prints the the solution. Before coding the problem we realise f must have the value 1, and also that r, which we will calculate after guessing o, must be even. For each column in the addition we must calculate the number to write down and the carry. We perform both calculations simultaneously with the /MOD operation. For example if o has the value 9, then

We recall that when code between <RUN..RUN> executes, it generates a value on the stack, provided in this case by SOLN, which is added to the set under con- struction. Code is then reflected back (reverse execution) which prompts the code to generate another solution. This terminates when all possible choices have been exhausted.

The code between <COLLECT..TILL generates values which are added to the set of solutions. TILL provides the set under construction as an argument to the following condition test, namely CARD 2 =. If the test returns a true flag or if there are no more unexplored choices, the structure terminates. CARD removes the set from the stack and leaves is cardinality (size), so termination occurs when two solutions have been found.

FIS~ expects a flag to be on the stack. Forward execution of FIS~ has no effect, but if execution reverses back to FIS~ due to infeasibility, it switches the value of the flag and recommences forward execution. Thus if 2 3 (+) has generated a true flag, 1 will be assigned to x and the condition x 2 = will be false, causing the following guard to reverse execution. When reverse execution arrives back at FIS~ the flag is switched to false. Forward execution begins and this time 2 will be

The purpose of 1 100 .. CHOICE DROP is to ensure that the following RANPUZ operation is executed sufficiently many times to be (almost) sure of getting two different answers. In fact, given that this problem has seven solutions, we have a

RANDOM-CHOICE can be used to provide an implementation of the high level non- deterministic choice construct S1 H S2 .. H Sn . The implementation technique is to use RANDOM-CHOICE to select a value from the set 1..n and then employ this value

These expressions risk having different values if the code for the second is com- piled in such a way that two independent random values are used. RVM-FORTH does not attempt to provide any solutions, and it is up to any designer of an as- sociated high level reversible language to ensure such problems cannot arise, e.g by providing a syntax that allows at most one random choice to occur within an expression.

