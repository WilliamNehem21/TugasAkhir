Genome rearrangements are events that modify segments of genomes. A rear- rangement model M is the set of valid rearrangements that can be used to estimate the evolutionary distance. Two well known types of genome rearrangements are reversals, which revert and flip the orientation of elements in a genome, and trans- positions, which exchange the positions of two adjacent segments in a genome.

We represent a genome as a permutation of integers, where each element cor- responds to a genomic fragment shared by the genomes we are comparing. This representation assumes that there are no duplicate genes. If the orientation of the genes is known, we use a signed permutation, where each element has a sign to represent its orientation. If the orientation is unknown, the signs are omitted and we use an unsigned permutation.

The problem of Sorting Unsigned Permutations by Reversals is NP-Hard [3]. The best-known result is an algorithm with approximation factor of 1.375, given by Berman et al. [1]. On the other hand, as shown by Hannenhalli and Pevzner [6], the problem of Sorting Signed Permutations by Reversals is polynomial. The problem of Sorting (Unsigned) Permutations by Transpositions is NP-Hard [2] and the best- known result is an algorithm with approximation factor of 1.375, given by Elias and Hartman [4].

When the rearrangement model contains reversals and transpositions, we have the problems of Sorting Signed and Unsigned Permutations by Reversals and Trans- positions. The complexity of both problems are unknown. For unsigned permuta- tions, the best-known result is a 2k-approximation algorithm [14], where k is the approximation factor for cycle decomposition of breakpoints graphs. For signed permutations, Walter et al. [16] presented a 2-approximation algorithm.

Observe that the distance is O(n2) because any permutation can have at most n inversions. Besides that, the variation in the number of inversions caused by a short rearrangement can be calculated in constant time, since at most three elements are affected. As there are O(n) possible short rearrangements, the algorithms spend O(n) time to choose the best rearrangement to apply at each step. Thus, all three algorithms have time complexity O(n3).

