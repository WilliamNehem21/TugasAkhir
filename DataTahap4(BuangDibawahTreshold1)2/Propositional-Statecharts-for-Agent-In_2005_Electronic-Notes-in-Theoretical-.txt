At the turn of the millennium the field of software agent research had become one of the most active areas of R&D activity in computing [30]. Since then agents have been widely tipped as the logical next step in the evolution of computer science (e.g. [8]). Much of the intuitive appeal of the agent paradigm stems from the idea that agents could solve problems through cooperation and negotiation, as people do, therefore providing the potential for automating many of the tasks which currently still have to be performed by humans. The potential ability of agents to communicate with each other in a goal directed manner forms an integral part of this idea.

Researchers such as Greaves et al. [12] have identified three characteristics which must be shared by different agents to enable them to communicate effectively: a shared infrastructure for message passing, a common ontology, and a common agent communication language. These researchers have also noted that in all but the very simplest interactions it is necessary for each agent to have a common understanding of the set (or collection of sets) of rules underlying the interaction. A set of rules governing an interaction is commonly known as an Interaction Protocol.

UML [29] is a collection of diagrammatic notations that was introduced and standardised by Rational Software, Microsoft, and the Object Manage- ment Group during the 1990s and has become a standard method for designing object-oriented systems. Agent UML is an extension of UML which aims to apply the principles behind UML to the problem of agent oriented system design. There are a number of reasons why notations taken from Agent UML are a natural choice for the representation of interaction protocols. Their sim- ilarity to existing UML notations makes them easy to understand for agent designers, who would be familiar with UML notations already. This reduces the risk of agent designers choosing not to implement the standard protocols just because they have difficulty understanding the notation used to represent them. Another obvious advantage of UML based notations over other method- ologies is the ability to benefit from the large amount of research which has already gone into the development of UML, and its proven track record as an effective means of designing complex systems.

In conventional Software Engineering, UML has been used to provide a relatively abstract description of a system giving an overview of how it would work. In this way the UML diagram has acted as a useful reference for the programmer. The object constraint language (OCL) included in the UML framework provided a means of introducing formal constraints, however it was designed for object modelling and addressed only preconditions and post- conditions [28]. The exact details of how a system would be implemented were intentionally left out for two reasons. Firstly, the inclusion of every de- tail could compromise the clarity and simplicity of the representation, making it less useful for the programmer rather than more useful. Secondly, when initially designing a system it is not the intention to give a complete and un- ambiguous specification of it, as it would be unreasonable to expect a designer

The propositional statechart formalism presented here is based on David Harels statecharts [13]. These are based on higraphs [14], which are a modified form of Euler diagrams described in [20]. An Euler diagram is a collection of closed curves known as contours arranged on a 2D plane, which is divided into separate regions corresponding to the areas of the plane inside different col- lections of contours. A similar principle underlies Venn diagrams (described in [17]).

There are a number of reasons why we have chosen to base our graphical methodology on statecharts. Firstly, since they are part of the UML suite, they share the benefits of other methodologies derived from UML, which are described in section 1. Secondly, the inclusion of state hierarchy enables them to provide simpler, more economical representations of protocols than other graphical methodologies such as finite state machines [16]. Finally, a modified form of statecharts could provide an unambiguous representation of interaction protocols. This would facilitate consistent implementations of the protocol in

The propositional statechart formalism introduced here aims to preserve the benefits of using statecharts to represent interaction protocols while strength- ening their ability to do so unambiguously. In order to achieve this we have made a number of modifications to the statechart formalism. Firstly we have simplified the definition of statecharts by removing orthogonality. Secondly, we have introduced labelling conventions that are intended to be sufficiently intuitive to render the propositional statecharts easy to understand, yet re- strictive enough to help designers provide unambiguous representations of pro- tocols. Both of these modifications are described here in detail.

When a statechart is used to represent an interaction protocol it is pos- sible to consider each state of the interaction as a combination of the states of each agent involved in the interaction, and so decompose an interaction protocol into a series of orthogonal sub-protocols, each representing the pos- sible states of a particular agent. There are two reasons for not approaching this task using the orthogonality mechanism of standard statecharts. Firstly the agents themselves are not subsystems, it is only their sub-protocols which must combine, so we have the conceptually tricky problem of combining parts of interactions between temporally autonomous agents into a pseudo whole. Secondly in a typical interaction protocol the agent states are far from inde-

pendent, as many or all of the agents may be in the same protocol state at any particular time, or may be following a similar sub-protocol. In these cases the use of orthogonality would provide little benefit for the representation of states. Instead, one can represent each sub-protocol using a separate, and often similar, or generic, statechart. The absence of orthogonality simplifies the propositional statechart formalism. We then seek to clarify the verifica- tion and implementation of protocols by considering the properties of these simpler charts, and how they interact.

A state label is an identifier for a state. An effective state labelling system should enable the user of the statechart to refer to each state unambiguously. To achieve this goal state labels should be assigned so that if the statechart were flattened out, and the names of the superstates were appended to those of the substates, no two states would have the same label.

In their book Modeling reactive systems with statecharts [16], Harel and Politi propose the introduction of activity diagrams to give a dual hierarchy for information flow through processing activities. This perspective has not persisted because an information processing activity can also be regarded as a discrete, although possibly compound processing state, and a process as a path between such processing states in program execution. While a primitive interaction event may be the action of an agent in sending a message, a more complex interaction can be expressed as the composition of primitive actions in the way primitive programs are composed in a sufficiently rich dynamic logic. Thus we treat an event in a propositional statechart as expressed by the composition of actions by agents in certain roles, including test actions which capture and generalize the auxiliary pre- and post-conditions of statecharts. The language we have used elsewhere for expressing the events in protocols is derived from ANML [21], and allows us to extract from the interaction statechart a formal theory in the dynamic logic [15].

The work presented here is also a foundation for two other technical de- velopments. The first is work to support verification of interaction protocol properties, such as soundness and completeness [23]. The choice of labelling conventions proposed here has been motivated partly by the desire to enable a direct translation between propositional statecharts and an extended form of dynamic logic in which such logical properties can be analysed. The sec-

