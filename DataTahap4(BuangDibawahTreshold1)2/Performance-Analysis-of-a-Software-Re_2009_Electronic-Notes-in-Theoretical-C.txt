The work we present in this paper is based on an approach we have developed to model mobility and performance information at the design level. This approach consists in translating a UML2.0 model onto a process algebra, namely PEPA nets, model. Once the process algebra model generated, performance analysis of the modelled system can be carried out. In this paper, we show how to use this approach to investigate the performance of a software retrieval service.

In this paper, we show how to investigate the performance of a software retrieval service using our approach. The retrieval service, which is based on knowledge- driven agents, allows mobile users to select, retrieve and install softwares. We show that our approach allows modelling both the service architecture and the service process itself in a natural manner.

Structure of the paper: in Section 2, after a brief overview of the UML diagrams used and the PEPA nets formalism, we present the main lines of the automatic translation of a UML model into a PEPA net one. In Section 3, we present the case study of a software retrieval service. We first describe the software retrieval service, then its corresponding UML model and the generated PEPA net model. Finally, the performance analysis of the studied service is developed. Concluding remarks and the extensions of this work are discussed in Section 4.

semantics of an interaction operator is described informally in the UML2.0 super- structure specification [7]. Below we give the meaning of the operators used here: alt designates that the fragment represents a choice of behaviour. At most one of the operands will execute. The operand that executes must have a guard expression that evaluates to true at this point in the interaction. If several guards are true, one of them is selected nondeterministically for execution.

par designates that the fragment represents a parallel merge between the behaviours of the operands. The event occurrences of the different operands can be interleaved in any way as long as the ordering imposed by each operand as such is preserved. loop specifies an interaction fragment that shall be repeated some number of times. This may be indicated using a guard condition. The loop fragment is executed as long as the guard condition is true.

By default the number of tokens that are carried along an edge is one, but an input or output pin can collect several tokens of the same type. It is also possible that a pin can only accept a certain number of tokens. We write {upperBound = N } next to a pin to indicate that the maximum number of tokens that can be stored in that pin is N . If the current number of tokens at the pin is N and the pin is an input pin, then no edge leading to that pin is allowed to fire.

A PEPA net is made up of PEPA contexts, one at each place in the net. A context consists of a number of static components (possibly zero) and a number of cells (at least one). Like a memory location in an imperative program, a cell is a storage area to be filled by a datum of a particular type. In particular in a PEPA net, a cell is a storage area dedicated to storing a PEPA component of the specified type. The components which fill cells can circulate as the tokens of the net. In contrast, the static components cannot move.

As a PEPA net differentiates between two types of change of state, so we dif- ferentiate the action types associated with each of these. The set of all firings is denoted by Af . The set of all transitions is denoted by At.

Several agents take part in the software retrieval process. There are four static agents (Knowledge Engineer, Broadcaster, Alfred, Software Manager ), one per place, and four mobile agents (Integrator, Trader, Browser, Salesman) who can travel from a place to another. In the following, we briefly describe the behaviour of the different agents in the places of the system.

The user computer agents: the user has at its disposal an efficient majordomo called Alfred. This static agent is in charge of storing all possible information about the user computer. Moreover, when an agent wants to show/retrieve data to/from the user, it has to do it with the help of Alfred who will create the appropriate user interface for each case.

The software place agents: the Software Manager agent creates and provides the Browser agent with the catalogue of the available software, according to the needs expressed by Alfred on behalf of the user. The Browser agent has to travel to the user place in order to refine the catalogue of software through its interactions with the user. Once the user selects a piece of software, the Browser agent creates the Salesman agent. This new agent carries the program selected by the user to its

For more details about the software retrieval process, we refer the reader to [6]. In the following we show how to model the software retrieval service using our approach. We first present the UML model, then the generated PEPA net model.

The software retrieval service can be modelled using an IOD. The agents involved in this service are translated into object types. Each mobile agent is modelled using a token object type, whereas each static agent is modelled as a local object type to a node. Moreover, the behaviour of each object in the IOD is described using a state machine diagram. All these diagrams are described and explained in the following.

the communication between object types modelling mobile agent Integrator and static agent Broadcaster is assumed to occur in the IOD node mod- elling the broadcast place where the static agent is located. Thus token type Integrator is assumed to travel to this IOD node in order to inform object type Broadcaster about the new services provided by the GSN before return- ing to IOD node modelling the software acquisition place. This solution takes advantage of the fact that Integrator is a mobile agent and the places where it travels are all located in the GSN. This avoids the introduction of an additional token type.

Object type Browser is first woken up (awake Browser/T) by the SoftManager which will provide it with the catalogue (provide catalog/T). Bringing the cata- logue, the Browser goes to UComputer (go UComputer/r5). Once there, either the query is refined (refine query/a3) or the software is chosen (choose info/a2). In the first case, the Browser goes back to SoftPlace with a refined query to get a new catalogue. In the second case, it goes back to wake up Salesman (awake Salesman/b4).

Recently several tools have been developed to support UML2.0 features. However the new features of UML2.0, in particular IODs, are not all supported by these tools. Moreover few tools support the XMI Import/Export functions. Our approach has been implemented using the Enterprise Architect tool 2 which supports both the IOD and the XMI Import/Export functions.

In the near future, we are interested in addressing crucial issues as design consis- tency and completeness. In this context, several approaches have been proposed in the literature. However, none of them is based on the IODs which are a character- istic of UML2.0. We are also interested in investigating the translation complexity.

