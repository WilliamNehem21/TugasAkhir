Over the past few years, there has been considerable effort in developing formal models of the Java bytecode verifier. Some authors showed that the problem of bytecode verification can be formally understood and described at static time using type systems [3,4,14]. All the proposals are proved to en- joy the type soundness properties (on the bytecode fragments they consider). Also, the type inference algorithm can be turned into a correct bytecode ver- ifier, see e.g. [2,5,10].

always pass. The same holds for n18, as its only caller is the privileged n14. Nowconsider n11: one of its callers (n4) has permission Pdebit, while the other (n6) has not. Indeed, the security check at n11 is necessary. Also, note that no execution involving clyde will ever pass the check in n11: then the permission Pcanpay is always granted to both callers of n8 (n3 and n12), and the check at n8 turns out to be redundant, too.

The permissions granted at the entry of a node are those granted at the exit of all its callers. Call nodes generate granted permissions only if they are privileged; otherwise they propagate those at their entry points. A check node generates both the permissions it enforces and those granted to all of the callers that may pass the check. As an example of the GP analysis, we compute the set of permissions granted to node n16:

In this paper we developed two Control Flow Analyses for the Java byte- code. The first analysis yields a safe approximation of the set of permissions granted to bytecode at run-time, and the second one approximates the denied permissions. The analyses provide us with the basis for reducing the run- time overhead due to stack inspection. Here, we focussed on Java bytecode, however the same static techniques can be applied to deal with programming languages or systems whose security architecture provides dynamic checking of permissions through stack inspection (e.g. C] [19]).

Many authors advocated the use of static techniques to optimize the check of security properties. Walker [16] develops a notion of typed compilation schemata: types encode assertions about program security ensuring that no run-time violation of the security properties will occur. Another approach is proposed by Jensen, Le M`etayer and Thorn [8]. They formalize classes of security properties (including stack inspection) through a linear time temporal logic. Then, model checking is used to prove that local security checks enforce a given global security policy.

