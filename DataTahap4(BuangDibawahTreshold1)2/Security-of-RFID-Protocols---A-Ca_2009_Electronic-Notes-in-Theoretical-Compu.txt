Our paper is structured as follows. In Section 2 we explain our terminology and describe the HMNB protocol. In Section 3 we exhibit an authentication flaw in HMNB. In Section 4 we show an attack on untraceability. In Section 5 we show a desynchronization attack and a related untraceability attack, and in Section 6 we conclude with a comparison of our attacks to typical attacks on these properties and give an outlook on future work.

In the following, reader refers to the actual RFID reader as well as the database communicating with the reader, since this communication takes place over a secure channel. An agent can be a tag or a reader, while a role refers to the protocol steps a tag or reader is expected to carry out. A run is the execution of a role by an agent.

in this model which are not feasible in a real-world RFID system. Additionally, the feasibility of attacks does not only depend on the intruder model, but also on the circumstances under which a system is used. Therefore, for each of the attacks presented in the following sections, we explain a scenario in which it can be carried out. When describing an explicit attack scenario, we speak of one or more attackers carrying out the attack. Thus the single theoretical adversary embodies one or more real attackers.

The protocol assumes that the reader R and tag T share a secret ID, which is updated at the end of a successful protocol execution. For efficiency reasons, the reader also stores the hash of the ID in HID and the value of ID before the last update in ID'. Additionally, the tag keeps track of whether its last run ended successfully or not. For this purpose, the variable S is used. Thus the protocol is stateful.

We have found the same type of flaw in several other protocols. The protocols in [12,30,31,32] are also challenge-response-based protocols in which the response does not depend on the challenge. Therefore, these protocols contain a similar au- thentication flaw, which has hitherto gone unnoticed and is illustrated in a technical report [7].

adversary can simply query a tag to obtain h(ID). If no trusted reader is present, then there is no communication between tag and reader, thus the reader will not update ID. Therefore the adversary may use h(ID) to impersonate the tag.

The ubiquity and wireless communication capability of RFID tags facilitate and encourage their tracing through space and time. From a privacy perspective this is highly undesirable. Intuitively, a protocol provides untraceability if an adversary is not able to recognize a tag he has previously observed. For stateful protocols, such as HMNB, it follows that the adversary should not be able to observe in which state a certain tag is.

The authors of HMNB claim that their protocol provides untraceability, be- cause the tag never sends the same response twice. They provide a formal proof for untraceability using the strong privacy definition of [19] explained above. In the following, we first show that the protocol is not untraceable by providing an algo- rithm that gives the adversary a non-negligible advantage of guessing the selected tag. We then discuss the flaw in the security analysis of HMNB.

In terms of the privacy experiments, the strategy of the adversary is therefore as follows. In the learning phase, two tags Ti and Tj are selected and tag Ti is put into state S = 1. The adversary can do this by challenging Ti and terminating the protocol before sending the third message. The learning phase is formalized by Algorithm 1.

In the challenge phase, the adversary performs a man-in-the-middle attack. He obtains a challenge from the reader and sends it to the tag to obtain a response. He then replaces the nonce provided by the tag with a different value and submits the response to the reader. If the reader accepts the response, the tag was in state S = 0, hence the selected tag is Tj. If the reader rejects the response, the tag was in state S = 1, hence the selected tag is Ti. This phase is formalized by Algorithm 2.

Desynchronizing a tag from the reader also compromises untraceability of the tag. The adversary can obtain a challenge from the reader and use this challenge to obtain a response from a tag. The adversary can then test the response against the reader, which will reject the response if and only if the response came from a desynchronized tag. Therefore, the adversary will always be able to recognize a desynchronized tag.

In this paper, we have investigated the security claims of an RFID protocol [14], designed to achieve mutual authentication, strong privacy, and desynchronization resistance, while limiting the computational cost for reader and tags. We have presented a flaw in the protocol which led to attacks on tag authentication, tag untraceability, and desynchronization resistance. We have referred to other RFID protocols suffering from the same authentication flaw, but which to our knowledge have not been noticed to be flawed before. These protocols are discussed in a technical report [7].

We note that the authentication flaw in HMNB could have been found using automated verification tools, e.g. [2,5]. Although automated verification of untrace- ability is still an open problem, the flaws in the untraceability proof of HMNB and several other protocols, recently [9,23,27,28,34,38,42], indicate a need for automated verification of this notion. Similarly, the introduction of stateful RFID protocols and the resulting attacks, for instance on [20,34,38,42], call for a formal definition and verification of desynchronization resistance.

