We study abstract local reasoning for concurrent libraries. There are two main approaches: provide a specification of a library by abstracting from concrete reasoning about an implementation; or provide a direct abstract library specification, justified by refining to an implementation. Both approaches have a significant gap in their reasoning, due to a mismatch between the abstract connectivity of the abstract data structures and the concrete connectivity of the concrete heap representations. We demonstrate this gap using structural separation logic (SSL) for specifying a concurrent tree library and concurrent abstract

predicates (CAP) for reasoning about a concrete tree implementation. The gap between the abstract and concrete connectivity emerges as a mismatch between the SSL tree predicates and CAP heap predicates. This gap is closed by an interface function I which links the abstract and concrete connectivity. In the accompanying technical report, we generalise our SSL reasoning and results to arbitrary concurrent data libraries.

SSL supports reasoning about fine-grained abstract data fragments stored in abstract heaps. Abstract heaps contain cells identified by abstract addresses (e.g. address x) whose values are the disjoint data fragments. These data fragments contain context holes, also given by abstract addresses, which are place holders for the data fragments found at the appropriate abstract cells. For example, the SSL predicate ATree (t)(x) describes a tree cell with abstract address x contain- ing tree context t. We can split (abstractly allocate) this predicate to obtain the

Structural separation logic (SSL) is a general program logic for specifying structured data libraries and reasoning locally about client programs which call such libraries. Here, we give the intuition and technical details of SSL using an abstract tree library. We give the general theory of SSL in the accompanying technical report [18]. Further details, including a wide number of examples, can be found in [2].

We give our axiomatic SSL specification of a simple deleteTree(n) command. Intuitively, this command removes the entire subtree whose top node identifier cor- responds to the value of variable n, leaving the rest of the tree unchanged. We formalise this English description using assertions which describe abstract heaps.

as parameters are not present in the tree. Additionally, the appendChild(m,n) command faults if m is a descendant of n. These commands are intended to be used with any programming language. In this paper, we use the programming language of the Views framework [6] instantiated with AtomT as the set of atomic commands. We write ProgT to denote the set of programs written in this language.

To reason about our tree programs, we use the program logic of the Views framework as described in [6]. We instantiate the framework with the separation algebra of abstract tree states (Def. 2.6) as the view monoid and the tree library commands (Def. 2.1) as the atomic commands. What remains is to describe the axioms associated with the tree library commands (Def. 2.7).

The technical details of the Views framework uses a labelled transition system to describe transitions between states. Transitions are labelled either by atomic com- mands or by id which labels computation steps in which states are not changed. We extend the behaviour of the id transitions of Views by declaring the relation AxiomId for abstract allocation/deallocation. Abstract (de)allocation does not change the underlying program states and can therefore be seen as id transitions.

Concurrent Abstract Predicates With CAP, the state is modelled as a pair consisting of a thread-local state and a shared state. The shared state is divided into a set of regions, each encompassing some shared portion of the state. Each region is identified by a region identifier R and is governed by a protocol that describes how the resources of the region can be manipulated. For instance, a lock resource at location x can be specified by:

The definition of the CAP separation algebra is given in [1,6]. It provides a set of instrumented states MH consisting of a local state, a shared state and an action relation capturing the ways in which the shared state can be manipulated. The definition is parametrised by an underlying separation algebra for describing the local state. For this paper, we work with the CAP separation algebra instantiated with the standard fractional heap separation algebra.

LWit(l, n, u) Since the left pointer lock of n can only be be acquired by the thread in possession of node n, or node l (or node u if n is the first child of u and does not have a left sibling), the LWit predicate is used to track the identity of the locking thread. Recall from the definition of the Left predicate that the full witness capability [W]Rnl is held by the thread that owns node n, as described by ownsR (n, l, u, 1). We thus use the witness capabilities to determine the identity of the locking thread. The first disjunct denotes the case where the lock has been claimed by the thread in possession of node n and corresponds to the witness capability on this region (ownsR (n, l, u, 0.5)).  Analogously, the second disjunct

represents the case where the thread in possession of node l has acquired the lock, denoted by (ownsR (n, l, u, 0.5)). The third disjunct captures the case where n does not have a left sibling and the lock has been taken by the thread that owns the parent node u (ownsD (u, n, 0.5)).

In the accompanying technical report [18], we generalise this approach to translate arbitrary abstract libraries, and stipulate a set of general properties that when satisfied, will warrant sound translation of any abstract library. These properties are stated for our specific library translation in Theorem 4.9.

