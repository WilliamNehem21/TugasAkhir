provide another scenario. The agents carry data with them whose integrity and confidentiality is important to the security of the system. External nodes that execute the agent code and handle agent data should not be able to use them in a manner that will subvert their usage policy.

Flows due to codes like y = x are termed explicit flows because the the flow takes place due to the explicit transfer of a value from x to y. On the other hand, consider the code shown in Listing 1. Even though there is no direct transfer of value from x to y, once the code is executed, y would have obtained the value of x. We say that

A trickier implicit flow is shown in Listing 2. When a is true, the first if fails so c remains L, where L is the default lowest possible security class in the system. The next if succeeds and b = pc = c = L. Thus, at the end of the run, b attains the value of a, but b /= a. The same is true when a is f alse. The fundamental problem is that even though the first branch is not taken, the very fact that it is not followed contains information, which is then leaked using the next if .

Compile-time system suffer from the limitation on the kind of policies than can be enforced by it. Since the policies are bound to the code in a static manner early in the life-cycle, these systems cannot be used in application scenarios where the policy is bound, not to the application, but instead to the data. These systems also cannot enforce policies that depend on the dynamic run-time properties of the system. Pure run-time systems on the other hand are not able to handle implicit flow leaks due to their inability to analyse flows associated with unexecuted branches, as shown in Listing 2. Trishul uses a hybrid approach, as explained later on, whereby a static analysis of the Java bytecode is performed at class load time in order to evaluate and capture as much of the implicit flow as possible. Later on, when the code is executed, the actual flow of taints is traced. Trishul is thus able to make use of the dynamic run-time properties of the system to enforce wider class of policies.

Run-time information flow control systems can be implemented at several different abstract levels within a computer architecture. Implementing it at the application level, ties down the system to a specific application. Implementing it within the operating system, as in HiStar [5], allows the operating system to enforce control information flow between kernel objects, like threads, address space and devices. However, such an implementation will find it very difficult to translate application level usage policies into OS system calls due to the semantic gap between the two levels. Another aspect to be considered is that the process of tracing information flow at run-time involves having to dynamically trace access to stacks, registers, program counter and memory.

runs within Trishul, it is tainted with a security label. In order to implement this, Trishul adds hooks in order to intercept calls from the application to Java library methods that brings data into the JVM. In the complete architecture of Trishul, a pluggable policy engine module specifies which of these methods are of interest to the engine and hence need to be intercepted. Similarly, the engine also specifies which output channels are protected and which of the associated method calls need to be intercepted. A comprehensive treatment of the actual implementation of this pluggable policy engine module and the language for writing the policy engine is beyond the scope of this paper and is merely mentioned in Section 5. Instead, this paper focuses on the implementation of the core information tracing mechanism of Trishul based on version 1.1.7 of the Kaffe JVM.

(2) the execution engine which executes each bytecode instruction; and (3) the run- time data area. The runtime data area consists of a method area, heap, Java stacks, native method stacks and a program counter register. Each Java application is run inside a separate virtual machine. The method area and the heap are shared across all threads running in a JVM. Each Java stack is made up of frames, with each frame containing the state of a separate Java method invocation. In interpreter mode, Kaffe JVM uses the variables array to hold the local variable values and the operand stack to hold intermediate operation results.

In order to implement taint labels on the objects, the stack structure has to be extended. In Kaffe each stack is implemented as a set of slots. Trishul extends the struct that implements the slot in order to hold the taint information. As in

To actually determine which con- ditional CFIs influences the execu- tion of a basic block, a dataflow anal- ysis is used. Whenever there is a branch in the CFG, each outgoing path is tagged with a different value. After the dataflow analysis, the first node where all the tags are set, is the node where all execution paths merge. In the CFG, the center left

creep. Each object also has an collective object taint, which automatically includes any taint value written to any of its members. This allows a policy to quickly check if any part of an object is tainted. The policy can also set or reset this taint value.

In this section we briefly look at the performance overhead introduced by the taint propagation mechanism. This overhead can be attributed to, among other things, the analysis of the CFGs, the calculation of the context taints and the creation and maintenance of the taint properties of the objects. The experiments were conducted on an Intel Pentium M processor 1.60GHz machine with 512MB RAM, running Ubuntu 6.10 with a 2.6.17-10-generic SMP Linux kernel. Version 1.1.7 of the Kaffe JVM was used for the comparison 1 .

introduced by Trishul is 7% which reduces to a very reasonable value of 0.4% for large block sizes. This variation can be explained by the observation that when the files are read/written in smaller block sizes, the loop that performs the read/write, is executed more times and each time Trishul has to calculate the new branch taint value at each CFI instance. These expensive operations introduce more overhead. A similar result was observed for the FileReadBW benchmark test too.

Performance Optimisation - Trishul is still in the early stages of development and some of the performance numbers obtained in the previous section can probably be improved by further optimisations. Overhead incurred during the creation of the CFGs and similar static analysis performed just before execution time can be cached across application runs by storing the calculated information (like the context bitmaps) in a secure, integrity protected, manner. In a similar manner, the CFGs of trusted core Java libraries used in Kaffe and Trishul, like GNU Classpath [10], could be calculated in advance and stored securely and re-used each time they are needed. A more efficient static analysis could reduce the overhead further. For example, an analysis of the branch blocks could reveal that the objects used for context taint calculations are never written into and hence their security class never change within the branch block. This information can then be used to skip the repeated context taint calculations performed when backward branch loops are encountered.

Policy Engine - The Trishul architecture proposed here does not use a specific built-in security policy model. Rather the modular nature of the policy engine architecture allows the system to use policy engines provided by various third par- ties. In doing so, the architecture can not only support various policy expression languages but also policy semantics.

Native Methods - Java applications are able to invoke native methods directly using the JNI. Once invoked, the native methods are no longer run within the JVM and can, among other things, use registers inside the native processor and allocate mem- ory on native stacks. There is no way for the IFC system to track the information flow within these methods. In order to avoid this, Trishul assumes that only trusted native method libraries are allowed to be accessed by Java applications. As a part of the post-build process, the hash of every trusted native library is stored within the JVM. At run-time, these hashes are checked to ensure that the libraries have not been replaced with untrusted ones and only native methods provided by these libraries are allowed to be invoked.

Chandra [17] pursues a hybrid approach similar to that used by Trishul but by instrumenting the bytecode with taint propagation code. However our exception handling is more thorough and more effective at handling control flow attacks. Their work also does not consider the risks posed by native function in any great detail. Trishul treats labels as bitmaps, whereas Chandra treats them as integers. Our approach allows more flexible representation and manipulation of the labels by the policy engine. By using an external instrumentation process their system also relies of a bigger trusted computing bases for the accurate working of their system. Haldar et al. use similar instrumentation approach in order to enforce security policies [18]. However, the approach uses a much less accurate analysis of implicit flows and exceptions as well as support only a very coarse granularity for tainted objects.

In this paper we described the design and implementation of Trishul, a JVM based information flow tracing system. Trishul tackles the information flow tracing prob- lem by using a hybrid approach by performing static and dynamic analysis of the Java bytecode. Trishul is able to perform taint tracing at the granularity of Java member fields, thus providing a very flexible architecture for data-oriented policy enforcement framework.

Performance measurements using Trishul show that the system incurs limited overhead. Optimisation needed to reduce this, some of which have been outlined in the paper, form part of our future work. The information flow tracing mechanism described in this paper forms one of the core component of Trishul system archi- tecture. We are in the process of implementing the pluggable policy engine module section as well as a language for the policy engine writer to develop these policy engines.

