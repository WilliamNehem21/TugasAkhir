Currently, Java is one of the most used programming language, being adopted in many large projects, where applications reach a level of complexity for which manual testing and human inspection are not enough to guarantee quality in software development. Even when using automated unit tests, such tests rarely cover all interesting cases of code, which means that a bug could never be discovered, once the code is tested against the same set of rules over and over again. This paper addresses the problem of generating random well-typed programs in the context of Featherweight Java, a well-known object-oriented calculus, using QuickCheck, a Haskell library for property-based testing.

Nowadays, Java is one of the most popular programming languages [24]. It is a general-purpose, concurrent, strongly typed, class-based object-oriented language. Since its release in 1995 by Sun Microsystems, and currently owned by Oracle Corporation, Java has been evolving over time, adding features and programming facilities in its new versions. In a recent major release of Java, new features such as lambda expressions, method references, and functional interfaces, were added to

Considering the growth in adoption of the Java language for large projects, many applications have reached a level of complexity for which testing, code re- views, and human inspection are no longer sufficient quality-assurance guarantees. This problem increases the need for tools that employ static analysis techniques, aiming to explore all possibilities in an application, in order to guarantee the ab- sence of unexpected behaviors [6]. Normally, this task is hard to be accomplished due to computability issues considering certain problem sizes. For overcoming this situation it is possible to model formal subsets of the problem applying a certain de- gree of abstraction, using only properties of interest, facilitating the understanding of the problem and also allowing the use of automatic tools [11].

Section 3 presents the process of generating well-typed random programs in the context of FJ. Section 4 shows the results of testing type-safety properties of FJ with QuickCheck. Section 5 discusses related works. Finally, we present the final remarks in Section 6.

FJ semantics provides a purely functional view without side effects. In other words, attributes in memory are not affected by object operations [23]. Furthermore, interfaces, overloading, call to base class methods, null pointers, base types, abstract methods, statements, access control, and exceptions are not present in the language. As the language does not allow side effects, it is possible to formalize the evaluation just using the FJ syntax, without the need for auxiliary mechanisms to model the heap [23]. Next, we present the original description of FJ [14].

QuickCheck is an automated testing tool for Haskell. It defines a formal speci- fication language allowing its use to specify code under test, and to check if certain properties hold in a large number of randomly generated test cases. This library provides several test case generators for constructors of the Haskell language, but it leaves for its users the definition of generators for user-defined types. The library provides combinators which help the programmer in this process.

The process starts generating a random number n, which represents that it will be generated n methods for the given class C. A method is represented by its signature and by its body. For generating the signature, it is necessary to produce the method name, the return type, and the formal parameters (types and names). This step is performed according to the method typing rule, as follows:

end of the method name. After that, it is generated a list of random size for the formal parameters. The list of types is placed in ?3, and the non-duplicate list of names is placed in ?4. As we are generating exclusive method names for each class, the function mtype(?2, D) is always undefined. It means that the generated method is not overriding a method from the base class.

Then, the placeholder ? should be filled with a randomly generated expression, which process was explained in the last subsection. The important difference here is that the context is augmented with the variables and types of the formal parameters and with the special variable this, whose type is the class being generated. The resulting expression should be a subtype of the generated return type.

The testing tool Csmith [25] is a generator of programs for the C language, sup- porting a large number of language features, which was used to find a number of bugs in compilers such as GCC, LLVM, etc. Le et al. [18] developed a methodology that uses differential testing for C compilers. Lindig [19] created a tool for testing the C function calling convention of the GCC compiler, which randomly generates types of functions. There are also efforts on randomly generate case tests for other languages [8]. The main difference between these projects to ours is that our gen- erators were created by using a formal specification of typing rules. Furthermore, we used property-based testing for checking type-soundness proofs.

More specifically, Daniel et al. [5] generate random Java programs to test refac- toring engines in Eclipse and NetBeans. Klein et al. [15] generated random programs to test an object-oriented library. Allwood and Eisenbach [1] also used FJ as a basis to define a test suite for the mainstream programming language in question, testing how much of coverage their approach was capable to obtain. These projects are closed related to ours since they are generating code in the object-oriented context. The difference of our approach is that we generate randomly complete classes and expressions, both well-formed and well-typed by using the formal specification of typing rules in the process of generation. Another difference is that none of them used property-based testing in their approaches.

There is also an effort on automatic random test generation from the definition of a type-system. The work of Fetscher et al. [10] presents a generic method for randomly generating well-typed expressions in the context of PLT Redex [9]. The works of Lampropoulos et al. [16,17] present different ways to automatically generate random expressions by using QuickChick [7], an existing tool for property-based testing in Coq. These approaches differ to ours in the sense that the authors provide tools to generate terms automatically according to a formal specification, usually by annotating the typing rules, while in our work we focus on a specific type-system of a high-level programming language.

In this work, we presented a type-directed heuristic for constructing random pro- grams in the context of Featherweight Java and used property-based testing to verify it. The lightweight approach provided by QuickCheck allows to experiment with different semantic designs and implementations and to quickly check any changes. During the development of this work, we have changed our implementations many times, both as a result of correcting errors and streamlining the presentation. En- suring that our changes were consistent was simply a matter of re-running the test suite. Encoding the type soundness properties as Haskell functions provides a clean and concise implementation that helps not only to fix bugs but also to improve understanding the meaning of the presented semantics properties.

