In this paper we show how refactoring of object-oriented programs can be accomplished by using refactoring rules [12] and programming laws [3,4]. We present a refactoring strategy, exemplifying its application with the use of tem- plate classes. Using this strategy, we refactor a program that is representative of a number of real applications.

lational databases. We transform the original program, which initially does separate architectural concerns, into one whose architecture achieves software quality factors such as reusability and extensibility. The formal development of this case study has served to identify new refactoring rules for rool and to improve our refactoring strategy. It was initially presented in [12].

This paper is organised as follows. In Section 2, we present an overview of rool with some basic laws of commands and classes. In Section 3, we present two refactoring rules we use in the derivation we present here. After that, in Section 4, we present a strategy for program refactoring in rool that aims at structuring programs according to a layered architecture, along with a sketch of our case study. In Section 5, we discuss some related work. Finally, in Section 6, we summarise the results achieved and point some directions for future research.

A set of algebraic laws for rool has already been defined in [3,4]. Laws for commands deal with the small grain constructs, whereas laws for classes consider the medium grain constructs. Many laws of commands are similar to the laws of imperative programming presented, for example, in [18], but rool has laws that support object-oriented features such as method calls, classes, and type cast and test. These laws were proved to be sound [12] with respect to a weakest precondition semantics of rool

To apply this law from left to right, the name of the class declared in cd1 must not be referred to in the whole program. In order to apply this law from right to left, the name of the class declared in cd1 must be distinct from the name of all existing classes; the superclass that appears in the declaration cd1 is object or is declared in cds. Finally, only method redefinition is allowed for the class declared in cd1.

Presently, rool has a copy semantics rather than a reference semantics. Of course, pointers are ubiquitous in practice. We decided, however, to concen- trate initially on other aspects of object-orientation and Java like inheritance, dynamic binding, visibility, and type tests and casts. In general, the results we obtain are also valid in the presence of pointers, but they would need to be revised in the presence of sharing.

Refactoring rules are described by means of two boxes written side by side, along with where and provided clauses. We use the where clause, when necessary, to write abbreviations. The provisos for applying a refactoring rule are listed in the provided clause of the rules. The left-hand side of the rule

On the left-hand side of this rule, any call to the method m of class A is forwarded to the class B . The class A declares the attribute b of type B and initialises it with an object of B . The class B declares the attribute x of type T and attributes adsb. In the method n of B there might be occurrences of the expression self .x . On the right-hand side, the class A does not declare an attribute of type B , but the attribute x that is also declared in B . The method m of A is defined by the same parameterised command that defines the method n of B .

On the left-hand side of this rule, class B declares an attribute x , and a method m (among other methods in mtsb). On the right-hand side, we introduce class D whose method m is defined by a parameterised command with body abort, modelling the effect of a Java interface. A Java interface contains a set of signatures of abstract methods; by defining the method bodies to be abort, we give them the most abstract definition.

Programs structured in accordance with a layered architecture support en- hancements and reuse [24]. Therefore, refactoring of object-oriented programs should be conducted, whenever necessary, to obtain a final program with a layered architecture [2]. Here, we aim at a layered architecture originally designed for the integration of object-oriented programming languages with relational databases [26].

constitute the data layer. The classes that contain code for communication among subsystems compose the communication layer ; and classes that imple- ment the user interface compose the interface layer. Here we concentrate on structuring the application into the business and data layers.

Our refactoring strategy consists of three stages. Each stage involves the in- troduction of new classes, and data and algorithmic refinement of an already existing class. Data refinement typically involves the introduction of new at- tributes to restructure a class in order to improve reuse. From the first stage (Stage 1) to the last one (Stage 3), the program changes from a poorly struc- tured one to a well-structured program according to the layered architecture described previously. In practice, it might not be necessary to follow all the steps proposed here: the developer should identify in which stage of devel- opment its program is, and apply refactoring from this stage to the last one. The main reason for dividing the development in stages is the simplification of data refinement.

In the first stage, we deal with a class that is monolithic. Data and business code are mixed. The purpose of this stage is to identify basic entities in such a monolithic description, and model each entity as a separate class, with its relevant attributes and methods.

At this point, the collection class and the persistence mechanism are still interwoven. This hinders reuse and extensibility, because if the persistence mechanism is changed, part of the system must be redesigned. The business code that can be reused, when adapting the persistence mechanism, should be separated from data code. This is the purpose of this stage.

The use of an interface provides independence between the collection and the repository classes. We can change the repository class, for instance, from a class that uses a list to one that uses a tree, with minimal impact on the collection class. Only the initialiser of this class needs to change to create an object of the new implementation of the repository. We now have a program structured according to the architecture described in Section 4.

The literature related to refactoring of object-oriented programs includes work such as that of Opdyke [23], which proposes a set of seven properties that must be satisfied in order to guarantee behaviour preservation. However, there is no proof in that work that satisfying these properties preserves program se- mantics. Our approach to refactoring is based on laws. Each law establishes the restrictions that must be satisfied allowing the law application. The appli- cation of a law modifies a program leaving its behaviour unchanged, since the soundness of each law is proved [12] against a weakest precondition semantics of rool and a refinement relation defined in [8,7].

Fowler [16] suggests that before starting refactoring one should have a solid suite of tests that must be self-checking. Every change must be followed by program compilation and test. However, there are no conditions to be satisfied in order to guarantee behaviour preservation. The use of algebraic laws for refactoring, as proposed here, eliminates the need of compiling the program as the result of a law application is correct by construction, both from the syntactic and from the semantic points of view. The use of a suite of tests is optional.

Flores, Reynoso and Moore [15] use the RAISE Specification Language to formally specify the responsibilities and collaborations of patterns participants as well as the behavioural properties. They use their model to specify any object-oriented design, so that they are able to verify that a given subset of a design corresponds to a given pattern. There is no discussion about the transformation of a design into another.

Eden [14] presents a declarative language called LePUS for specifying the structural and behavioural aspects of design patterns. He recognises that relations in LePUS specifications can be mapped to different programming constructs of different programming languages, even though he argues that the set of relations used in the description of design patterns map directly to well- defined syntactic constructs in statically typed programming languages. He does not present any systematic approach for such translation. He also argues that a prototype tool for LePUS can be developed in Prolog, allowing the manipulation of formulas representing modifications in a program. However, practical results in this area are not evident yet in his published work. In our approach, we transform a particular design with the aim of obtaining a new design according to a design or architectural pattern. The transformation is accomplished by the use of rules written using metalanguage elements, such as meta-variables for representing attributes, but using a language very similar to rool, the language we use to write our programs.

This paper has illustrated how refactoring of object-oriented programs can be accomplished in a formal way by using a rule-based approach. This is based on the application of refactoring rules [12]. The proposed strategy to obtain a system with a layered architecture also involves classical data refinement [21] and algorithmic refinement.

Our general aim is formalising object-oriented design practices. We are currently working on well-established design patterns [17]. This is important for the practice of formal refactoring of object-oriented programs and also for formally justifying the validity of the design changes that aim at structuring a system according to a design pattern. In [12], we have already proposed transformations to restructure a system into one in accordance with the Fa- cade Pattern [17], by using refactoring rules. Both the Facade Pattern and the architectural pattern presented here are obtained by the application of refactoring rules.

As a future work, we plan to build a tool to mechanise the transformations of rule applications. We intend to mechanise the application of program- ming laws by using systems like Elan [5]. This will serve as the basis for the mechanised derivation of refactoring rules as well as architectural and design patterns. Once programming laws and refactoring rules are mechanised, it is possible to construct an environment to reason about program transformations with a fully-formal guarantee of semantics preservation.

