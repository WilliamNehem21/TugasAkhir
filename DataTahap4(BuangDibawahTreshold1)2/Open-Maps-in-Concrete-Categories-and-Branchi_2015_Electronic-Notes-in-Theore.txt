In our attempts to remedy this, we discovered that reinterpreting the above diagram in the context of concrete categories leads to many new insights. Firstly, it allows us to define functional bisimulations in the concrete category of prefix orders with partial orders as a base category. Secondly, the natural choice for the subcategory P of paths turns out to be the subcategory of embeddings. And thirdly, the existence of cospans of these embedding-open maps turns out to coincide with branching bisimulation when the prefix orders are the sets of runs generated by a labelled transition system. Finally, the reinterpretation comes with a flavour of syntax and semantics, in which we consider morphisms in the concrete (base) category to be implementations (observations).

tend to think of the objects of M as concrete models of behaviour and the objects of S as semantic models of behaviour. A morphism A f) B of M represents a way of implementing the behaviour of B (the specification) as a behaviour A (the implementation). On the semantic level, a morphism C g) D describes how the behaviour of C can be observed as a part of the behaviour of D.

In [1], embeddings where also called extensions, which lead us to research the possibility of using embeddings as the subcategory of path-extensions. But we were convinced of being on the right track when we discovered the similarity between the definition of P-open map and that of P-injective objects defined in [1]. In particular, the observation in that an object is an absolute retract if and only if it is an injective object in any category that has enough injective objects (see Proposition 9.10 in [1] for the original definitions) turned out to have a nice translation to the setting of open maps as well.

Note that in case of transfinite executions, this definition also relates Zeno-points and other limit behaviour, generalising the solution of [6] to a problem widespread in the study of e.g. timed and hybrid systems [18,10]. Also note, that this definition slightly differs from the one in [5] in which Zeno-choices were not explicitly taken into account yet. However, for executions of the more usual models of computations, such as labeled transition systems, they coincide.

other definitions of functional bisimulation that have been proposed in literature. It is also history preserving, hence a morphism in Pfx, and taking B = {0, 1} and A = {0} gives us a commuting square of history preserving maps. Nevertheless, no history preserving diagonal k can exist for this square. The fact that there does exists an order preserving k in this case lead us to investigate the possibility of a concrete category theoretic approach.

In the previous section, we have paved a way of defining bisimulation through cospans categorically. What is left to show, is that the embedding-open maps indeed give the notion of bisimulation that we would like to have. In order to do this, we consider prefix orders as a concrete category over the category of partial orders.

From a philosophical point of view, using a concrete category for behavioural models means that we are to distinguish implementations from observations in such a way that we assume all implementations to be observable. Interpreting the result in Theorem 3.4 along these lines, we see that X is bisimilar to Y iff any conceivable extension of X that implements additional behaviour of Y is already observable in X (although may have been implemented differently). Still, it depends on the concrete category which implementations are actually extensions, i.e. which are the embeddings that need to be preserved.

In the quest for a common approach to modeling computations and other dy- namic behaviour, the next logical step seems to be to study split faithful functors over Pfx. This may give insight in which embeddings are and are not to be taken into account. In a sense we already have studied such a split in section 5 by look- ing at the runs of labeled transition systems rather than at the transition systems themselves. But more general theory may be found here. For example, take any cat- egory of syntactic computational models M. We expect the executions of a model in this category will form a prefix order, meaning that implementations in M can be mapped to history preserving maps in Pfx and order preserving maps in Pos. From the philosophical point of view, the syntactic constructs of M are the actual

implementations and the order preserving maps of Pos would serve as observations. The definition of bisimulation for M would then come from open maps in the con- crete category of M over Pos, but the expectation that this forgetful functor splits over Pfx can be exploited when studying bisimilarity of models in M. For sure, in such a split there are less embeddings in M than there are in Pfx, therefore the notion of bisimulation can only have become weaker (there is less to preserve). This means that two models in M are bisimilar whenever they are bisimilar in Pfx. The reverse does not necessarily hold, for example because open maps in Pfx check for Zeno behaviour, while there may not be any Zeno-embeddings in M.

