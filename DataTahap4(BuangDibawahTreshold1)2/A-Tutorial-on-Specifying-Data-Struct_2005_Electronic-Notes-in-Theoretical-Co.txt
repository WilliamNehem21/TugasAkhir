reached maturity with the public release of version 2 in the summer of 2003. Since then, Maude is being used throughout the world in teaching and re- search, being specially useful for the specification and prototyping of logi- cal systems, programming languages, and computational systems in general. However, there is still a lack of common libraries that could be shared and reused.

This tutorial tries to contribute to fill this gap by providing a library of typical data structures specified in Maude. This is accomplished by updating and considerably extending the set of specifications that were available in the tutorial distributed with version 1 of Maude [4]. More specifically, we start by describing well-known versions of basic data types such as stacks, queues, and lists; we then continue with several versions of trees, including binary, general, and search trees; we do not consider only the simple versions, but also advanced ones such as AVL, 2-3-4, and red-black trees; finally, we describe an abstract version of priority queues and a more concrete one based on leftist trees.

Modules can be imported in different modes. The most important one is protecting that asserts that all the information in the imported module does not change because of the importation; more specifically, different data in the imported module are not identified in the importing module, and no new data are added to the imported sorts. When this is not the case, the importation mode can be including.

Then, the module expression LIST(Nat) denotes the instantiation of the parameterized module LIST(X :: TRIV) by means of the above view Nat. Views can also go from theories to theories, as we will see later in Section 3.4. For more information on parameterization and how it is implemented in the Maude system, the reader is referred to [7,6].

The only subtle point in a stack specification is that the top operation is partial, because it is not defined on the empty stack. In our specification, we use a subsort NeStack(X) of non-empty stacks to handle this situation. Then, push becomes a constructor of non-empty stacks, while both empty and push (the latter via subsorting) are constructors of (possibly empty) stacks; notice the ctor attribute of those operators, indicating that they are constructors. Now, the top and pop operations are defined as total with domain NeStack(X). Finally, all modules import implicitly the predefined BOOL module, and therefore we can use the sort Bool and the Boolean values true and false

-> NeList and List NeList -> NeList) but they are unnecessary in this case because of the attribute for identity. Finally, notice that operator at- tributes in overloaded operations have to coincide, even though, by reading alone the second declaration for concatenation, it may sound a bit strange to say that the empty list is an identity for an operation only defined on non-empty lists. When there are many overloaded declarations for an opera- tor, it is possible to use the operator attribute ditto to implicitly repeat the attributes without having to write all of them explicitly again.

General trees can have a variable number of children for each node. One can specify them by using an auxiliary data type of forests that behave like lists of trees. Since otherwise the parameterization and specification techniques do not differ from the ones we have already described before, we do not include the specification here and instead refer again to [10].

This example is similar in philosophy to the one for ordered lists, but more complex. We specify a subsort of (binary) search trees by using several (con- ditional) membership axioms over terms of the sort BinTree of binary trees defined in Section 3.7.

In addition to operations for insertion and deletion, we have a lookup operation that returns the contents associated to a given key, when the key appears in the tree. However, this last operation is partial, because it is not defined when the key does not appear in the tree; this error state cannot be handled by means of a subsort, because the partiality condition depends on the concrete values of the arguments. We have used a partial operator declaration by stating that the result of the lookup operator is in the kind [Y@Contents] associated to the sort Y@Contents (notice the square brackets around the sort name to denote the corresponding kind). Instead of having at the level of kinds

It is well-known that in order to have better efficiency on search trees one has to keep them balanced. One nice solution to this problem is provided by AVL trees; these are binary search trees satisfying the additional constraint in each node that the difference between the depth of both children is at most one. This constraint guarantees that the depth of the tree is always logarithmic with respect to the number of nodes, thus obtaining a logarithmic cost for the operations of search, lookup, insertion and deletion, assuming that the last two are implemented in such a way that they keep the properties of the balanced tree. As we have already anticipated in Section 3.9, it is convenient to have in each node as additional data the depth of the tree having this node

Other solutions to the problem of keeping search trees balanced are provided by 2-3 trees, which are not treated here, and 2-3-4 trees, whose specification we consider in this section. This kind of search trees generalizes binary search trees to a version of general trees of degree 4, so that a non-leaf node can have 2, 3 or 4 children. The number of values in the node depends on the number of children; for example, there are two different values (let us call N1 the smallest of the two, and N2 the greatest) in the node when it has three children. Moreover, the values in the children are well organized with respect to the values in the node; in the same example, all the values in the first child must be smaller than N1, all the values in the second child must be bigger than N1 and smaller than N2, and all the values in the third child must be bigger than N2. Furthermore, the children must have exactly the same depth, and recursively they have to satisfy the same properties. As expected, all of these properties can be stated by means of membership assertions.

Yet another solution to the problem of keeping search trees balanced are red- black search trees. These are standard binary search trees that satisfy several additional constraints that are related to a color (hence the name!) that can be associated to each node (in some presentations, to the edges). One can think of red-black trees as a binary representation of 2-3-4 search trees, and this provides helpful intuition.

As usual, the sort of leftist trees can be defined as a subsort of binary trees by means of appropriate membership assertions. In order to compare quickly the ranks of two nodes, we need to save in each node its rank (in the same way that we saved the depth in each node in AVL trees). Since we are importing binary trees, which are parameterized with respect to the theory TRIV, we first define in the module TREE-NODE the construction of pairs formed by an element and a natural number, and then instantiate the module BIN-TREE of binary trees with the parameterized view Node(T). The view is parameterized because it still keeps as a parameter, as expected, the sort of the elements with a total order on top of which we are building the leftist trees.

Concerning the proof of properties, in collaboration with Manuel Clavel we have managed to prove more complex ones, including the correctness of the sorting operations mergesort and quicksort. However, we are still finding our way with proofs of basic properties about search trees. In the future, we would like to consider more complex relationships such as those between 2-3-4 and red-black trees.

