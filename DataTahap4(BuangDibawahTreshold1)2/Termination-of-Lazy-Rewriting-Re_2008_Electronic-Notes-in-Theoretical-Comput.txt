Lazy rewriting is a proper restriction of term rewriting that dynamically restricts the reduction of certain arguments of functions in order to obtain termination. In contrast to context-sensitive rewriting, reductions at such argument positions are not completely forbidden but delayed. Based on the observation that the only existing (non-trivial) approach to prove termination of such lazy rewrite systems is flawed, we develop a modified approach for transforming lazy rewrite systems into context-sensitive ones that is sound and complete with respect to termination. First experimental results with this transformation based technique are encouraging.

In functional programming languages, evaluations are often carried out in a lazy fashion. This means that in the evaluation of an expression, the result of certain subexpressions is not computed until it is known that the particular result is actually needed. A very similar idea is used in lazy rewriting ([3]) where the reduction of certain subterms is delayed as long as possible (cf. also [1], [8], and [10]).

Termination analysis of functional programs has recently become a major subject of research in the rewriting community. Due to the similarity of lazy rewriting and the lazy evaluation strategy of functional programs, the use of lazy rewriting seems promising to find new methods for proving termination of functional programs. In particular lazy rewriting and lazy evaluation in functional programming share the idea of postponing certain evaluation steps. More precisely, arguments of functions are only evaluated if their final result is needed to compute the function.

Without an evaluation strategy the input term take(s(0),from(0)) is non-termi- nating. Yet, when using a lazy evaluation strategy it is terminating and the result is 0. The crucial difference is that in a term of the shape take( , : from( )) the from subterm may not be evaluated under lazy evaluation, because its result is not needed to evaluate any more outer function.

Therefore, lazy rewriting can only approximate lazy (Haskell) evaluations but clearly not simulate them in a one-to-one fashion. Yet, the described features of functional programs can be encoded or approximated through standard transfor- mations such that finally lazy rewriting can be used for a termination analysis (cf. e.g. [7]).

In this work we present a transformation from lazy TRSs into context-sensitive ones that is sound and complete w.r.t. termination and thus allows us to reduce the problem of deciding whether a lazy TRS is terminating or not to the same problem for context-sensitive TRSs, which has already been studied to some extent (cf. eg. [12] ). As this is the first sound and complete transformation for lazy TRSs, it enables us for the first time to investigate the use of lazy rewriting in the area of termination analysis of functional programs.

Lazy rewriting was initially introduced by [3] in a graph rewriting setting (al- though the basic underlying idea is much older, cf. e.g. [4], [15], [14]). However, for the termination analysis of functional programs it makes sense to consider term rewriting instead of graph rewriting, for the following reasons. First of all, using term rewriting instead of graph rewriting is more general and does not prohibit cer- tain evaluations a priori. Moreover, the theory of ordinary term rewriting is much further developed as compared to graph rewriting. In particular, existing methods for the termination analysis of ordinary as well as context-sensitive rewrite systems can be applied where possible. Hence, in this work we will use the notion of lazy term rewriting introduced in [11].

In Section 2 of this paper we will present basic definitions and notations of lazy rewriting. In Section 3 we introduce the transformation of [11] and give a counterexample to its soundness w.r.t. termination. We then propose a modified version of the transformation which is proved to be sound and complete w.r.t. termination. Section 4 contains a discussion of the presented approach and of some experimental results. 2

Given a labelled term t, the unlabeled term erase(t) is constructed from t by omit- ting all labels. A position p of a term t is said to be eager (resp. lazy ), if the symbol at the root of the subterm starting at position p of t has an eager (resp. lazy ) la- bel. Note that the lazy positions of a term are not the same as the non-replacing positions in context-sensitive rewriting. The reason is that in lazy rewriting ea- ger positions may occur below lazy ones whereas in context-sensitive rewriting all positions which are below a non-replacing position are non-replacing.

We start with the definition of the transformation of [11], because it provides the basic ideas for our new one. The main idea of the transformation is to explicitly mimic activation steps of lazy rewriting through special activation rules in the trans- formed system which basically exchange function symbols to make them more eager (this goes back to [13]). Activations in lazy rewriting are possible at positions which correspond to a non-variable position of the left-hand side of some rule in a partial matching. This is why in the transformation we are concerned with non-variable lazy positions of left-hand sides of rules.

Before presenting the formal definition of our new transformation (see Definition 3.8 below), which crucially relies on Definition 3.5, we want give an informal expla- nation and illustration of its essential features. In our transformation we distinguish two kinds of rules that are generated. On the one hand we have activation rules which are characterized by the fact that in these rules the left- and right-hand side differ only at exactly one position, where in the right-hand side a different function symbol as in the left-hand side is used. While having the same arity, the different function symbol in the right-hand side has exactly one more replacing position and the argument at that position is a variable (in both sides). All other rules are active rewrite rules.

our transformation (with a time limit of 10 seconds). When interpreting these results one has to keep in mind that the example TRSs considered were actually supposed to be considered context-sensitive by their authors. Thus, in many cases the changes made by our transformation were only minimal. There were only 3 sys- tems (namely Ex1 Zan97.trs, Ex9 Luc06 and Ex14 AEGL02) for which termination could be proved in the context-sensitive case but not in the lazy case. However, all these systems actually become non-terminating when considered to be lazy instead of context-sensitive. This indicates that in many practical cases the analysis of lazy termination with our approach may well be feasible and a priori not too hard. Furthermore, lazy termination analysis can greatly benefit from ongoing research in the field of context-sensitive termination.

