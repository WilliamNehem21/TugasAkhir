Interactive theorem provers have been enhanced with numerous automatic proof procedures for different application domains. However, when an auto- matic proof attempt fails, the user usually gets little information about the reasons. It may be that an additional lemma needs to be proved, that an induction hypothesis needs to be generalized, or that the formula one is try- ing to prove is not valid. In such cases an automatic tool that can refute non-theorems would be useful.

i.e. involving no more than a given number of elements. A standard SAT solver can then be used to search for a satisfying assignment, and if such an assignment is found, it can easily be transformed back into a model for the HOL formula.

As can be seen from these rules, we use Boolean variables in a unary, rather than in a binary fashion. This means that we need n variables to represent an element of a type of size n, rather than [log2 n| variables. However, exactly one of these variables must later be set to True (which keeps the search space for the SAT solver small due to unit propagation [21]), and our encoding allows for a relatively simple translation of application. To ensure that exactly one of the Boolean variables p1,..., pn is set to True, a propositional formula

Satisfiability can be tested with an off-the-shelf SAT solver. To this end trans- lations into DIMACS SAT and DIMACS CNF format [6] have been imple- mented. The translation into SAT format is trivial, whereas CNF format (supported by zChaff [14], BerkMin [7] and other state-of-the-art solvers) re- quires the Boolean formula to be in conjunctive normal form. We translate into definitional CNF [19] to avoid an exponential blowup at this stage, in- troducing auxiliary Boolean variables where necessary. A more sophisticated CNF conversion might further enhance the performance of our approach [11]. Isabelle/HOL runs on a number of different platforms, and installation should be as simple as possible. Therefore we have also implemented a naive DPLL-based [5,21] SAT solver in Isabelle. This solver is not meant to replace the external solver for serious applications, but it has proved to be efficient enough for small examples. Hence it allows users to experiment with the countermodel generation without them having to worry about the installation

of this translation, consisting of roughly 2,800 lines of code written in Stan- dard ML [13], is available in the Isabelle/HOL theorem prover. A standard SAT solver can be used to search for a satisfying assignment for the proposi- tional formula, and if such an assignment is found, it can be transformed into a model for the HOL formula. This allows for the automatic generation of finite countermodels for non-theorems in Isabelle/HOL. A similar translation has been discussed before [10]; the main contributions of this paper are its extension to higher-order logic and the seamless integration with a popular interactive theorem prover.

So far we have applied the technique only to relatively small examples. The applicability of the algorithm is limited by its non-elementary complexity. We believe that the algorithm can still be useful for practical purposes, since many formulae have small models. To substantiate this claim, and to further eval- uate the performance of our approach, we plan to carry out some larger case studies, possibly from the area of cryptographic protocol verification [16,17].

