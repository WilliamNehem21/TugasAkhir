This paper introduces the formal calculus and the idea of session types with many illustrative examples to those without background of process calculi and their typing systems. Section 2 and 3 introduce and illustrate the global formalism (a distilled version of WS-CDL). Section 4 illustrates the session types for the calculus. Finally Section 5 demonstrates its expressiveness by showing a large example inspired from a

The present work shares with many recent works in its use of types for well- structured communication-centred programming [19,3]. In particular, our work is based on the studies on session type disciplines [20,15,11,10,22,6], and extends them to both global descriptions and intra-session parallel communications. All previous work are based on end-point languages and calculi.

The formal syntax of the global calculus is given by standard BNF. Below symbols I, I',... denote terms of the global calculus, also called interactions. Terms de- scribe a course of information exchange among two ore more parties from a global viewpoint.

s, s',... range over a collection S of session channels. Session channels desig- nate communication channels freshly generated for each session. They can be implemented in various ways: in TCP, the same concept is realised by so-called connection (also called session). In web services, they are realised by sending freshly generated identity information as part of messages.

e, e',... range over expressions, given by the grammar e  ::=  x  |  v  | f (e1,... , ek) where f ranges over an appropriate set of function symbols (includ- ing standard arithmetic/boolean operators) and v, w,... range over atomic values such as natural numbers and booleans.

Interaction which can be repeated unboundedly is realised by recursion. Then the term rec X . I is the standard recursion construct, where rec X is called recur- sor, with X, the recursion variable, binding its free occurrences in I. Finally, 0 is the inaction, representing the lack of actions.

Example 3 (Syntax, 3) A session can have multiple session names for communi- cation. This is the standard practice in business protocols and other interaction- centred applications, and is essential to have multiple parallel interactions inside a single session. As an example, suppose that Buyer wants to start a session at a channel acc in which it communicates acceptance of a quote on a session name Op and, in parallel, sends its address on a session name Data. This can be expressed as:

From an engineering viewpoint, the dynamic semantics pins down a mathematical notion which designers, implementers and users can refer to when they wish to discuss about dynamic behaviour of description with rigour. For example, this would allow us to state with precision whether an implemented program conforms to the description or not. Another example usage is in monitoring, where a monitor would check the execution based on the stipulated formal dynamic semantics of a given description.

The purpose of the protocol is for Buyer to ask for a quote of a product to Seller, negotiates the price, and buys the product if its price is cheap enough. Before asking for a quote, Buyer asks CreditChecker whether Seller is credible or not. The negotiation process is done as a loop, which involves not only Buyer and Seller but also Vendor (which only interacts with Seller). When the negotiation is successful, Seller asks CreditChecker if Seller is credible, and if the answer is positive, asks RoyalMail (a shipper) to ship the good. The following illustrates the protocol step by step.

For readability reasons, we will give different threads for each participants which will then be composed in parallel. Similarly to the global case, unimportant parameters in inputs and outputs will be omitted, e.g. s D op stands for s D op(x) for some x.

Note that both processes above do not include the recursion. This is because, in the global description, their sessions are inside a recursion so that they initiate a new instance of a session each time a recursion takes place. Furthermore, the two threads above describe the same service. Thus both interactions should come from the same process. Since, however, they differ in the second action, there should be a choice operation so that both possibilities are given. This results in:

