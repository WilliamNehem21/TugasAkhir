Java is largely used to develop distributed and concurrent systems, but testing multithreaded systems cannot guarantee the quality of the software; in contrast, verification techniques give us a higher confidence about the system and, among these, model checking methods automatically establish properties of complex systems. Such techniques are usually applied to specification lan- guages, and several environments exist to verify temporal properties of concurrent specifications. In this paper we present an attempt to apply model checking techniques for verifying a subset of multithreaded Java programs. In particular, we use a tool based on the selective mu-calculus logic to check systems described through the CCS specification language.

The paper is organized as follows: in Section 2 we review the basic con- cepts of CCS and the methodology, based on selective mu-calculus, to attack the state explosion problem. In Section 3 we describe the transformation of multi-threaded Java programs into CCS specifications, while in Section 4 the usefulness of our approach in terms of the degree of the model reduction is shown through a simple synchronization problem. Finally, considerations and comparisons with related work are given in Section 5.

In this section, we briefly recall the main concepts about CCS and selective mu-calculus. CCS [32] is a specification language widely used for concurrent and distributed systems and we assume the reader to be familiar with it. The selective mu-calculus is a branching temporal logic to express behavioral properties of systems, which has been introduced by the authors et al. in [6].

The resulting CCS process is then analyzed by our CCS Reduction Tool that automatically removes all the non-relevant actions with respect to the formula to be checked. The main advantage is that our tool can be combined with, and not replace, other techniques developed to attack the state explosion problem, including partial order methods [21,36] which remove unnecessary interleaving of transitions, abstraction techniques [13] which ignore some state information, compositional reasoning [1,12,33] and methods based on heuristic searches [20,34]. In fact, once we have the CCS specification corresponding to the initial Java program, we can apply the above methods.

The operator T , defined in the remaining of this section, applies to the Java code of a program to translate it into CCS specifications. For lack of space, in this paper we only present a portion of the definition of T , in particular what is needed to understand the application of our method on the example described in Section 4. More details about the definition of T are in [22].

Method definition. Every method corresponds to a process waiting to be invoked through the action callMethodNamei. The action returnMethodN amei causes the control being returned to the method caller. Then the process goes back to the starting action so that it can be invoked again. A special case

Wait. The call to the method wait() always occurs in a synchronized block. This causes the thread being inserted in the wait-set of the object through the action inserti that will be caught by one of the WaITSET (j)i processes, de- pending on the number j (0 < j < n) of the waiting threads. Then the object lock is released through the action unlocki, so that the object i may be used again. Then WaITi waits for the action resumei from the process NOTIFY i and executes the action locki before returning the control and accepting a new invocation.

the wait-set of the object i, if any.	The actions someoneInQueuei and noneInQueuei, communicating with the someoneInQueuei and noneInQueuei actions of the WaITSET (j)i process definitions, show the state of the wait- set. If this is empty, nothing is done, whereas if the wait-set contains at least one thread, the actions resumei (caught by the WaITi process) and removei will resume and remove from the wait-set one of the waiting threads.

The results obtained with this simple example are encouraging. Obviously, this is only a starting point: further investigation will allow the validation of the results on relevant problems in software verification, and the comparison with other tools. In general, the usefulness of our tool depends both on the number of actions occurring in the formula and on the structure of the formula to be checked.

Many works can be found in the recent literature aiming to verify real pro- grams written in modern languages. As stated in [37], they can be roughly divided into two categories: custom-made model checker and source-to-source translation. An example of a custom-made model checker is described in [37], where a verification and testing environment for Java, Java PathFinder (JPF), has also been developed. The works in the second category (see, for example, [16,18,24,29]), translate software system descriptions to the input languages of verification tools. For example, in the Bandera tools [16,23] the Java source code, after some manipulation, is translated into either Promela (the input notation of Spin [28]) or SMV [31] model checker input notation. Bandera uses temporal patterns, to be instantiated to temporal logics and to specify properties, and uses program slicing and data abstraction (abstract interpre- tation) to customize models. With our methodology, we propose to add a further abstraction, which is driven by the formula being checked.

Our approach belongs to the source-to-source translation category. It consists of the translation of multithreaded Java programs into CCS specifications and of the use of a reduction algorithm, based on the selective mu-calculus logic, which allows us to face the state explosion problem and facilitates the writing of the properties. In order to use the existing model checking environment for concurrent specifications, namely CWB-NC, we use a prototype tool to implement the reduction algorithm and another tool to translate a selective formula into a mu-calculus one. This approach permits an easy detection of errors in a program, and this fact is relevant as it occurs with low probability on concurrent programs; moreover, the error detection is obtained at a lower cost, also on complex systems, compared to testing the program, because of the use of a reduced model.

