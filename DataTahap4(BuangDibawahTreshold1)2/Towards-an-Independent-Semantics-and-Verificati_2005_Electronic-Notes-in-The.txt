We present an algorithm for the translation of security protocol specifications in the HLPSL lan- guage developed in the framework of the AVISPA project to a dialect of the applied pi calculus. This algorithm provides us with two interesting scientific contributions: at first, it provides an in- dependent semantics of the HLPSL specification language and, second, makes it possible to verify protocols specified in HLPSL with the applied pi calculus-based ProVerif tool. Our technique has been implemented and tested on various security protocols. The translation can handle a large part of the protocols modelled in HLPSL.

The HLPSL language is the input language of the AVISPA tool. In more detail, the AVISPA tool takes as input an HLPSL specification, translates it to IF and analyzes the result by invoking state-of-the-art back-ends, which return attacks (if any) to the user. Since different tools are suited for solving different problems, it is relevant to integrate HLPSL with other tools for verification of security protocols. So far the available back-ends of the AVISPA tool have been based on three different technologies that cover a large share of the research arena in security protocol verification:

In this paper we propose a way to translate specifications in a subset of HLPSL to the dialect of the applied pi calculus that is supported by the ProVerif tool [6]. This makes it possible to verify secrecy, weak authentica- tion, and strong authentication properties of HLPSL specifications by invoking ProVerif on the result of the translation. It completes the number of available formalisms and technologies available for HLPSL.

HLPSL that we use. In section 3 we describe the dialect of the applied pi calculus to which the translation is performed. Section 4 describes the al- gorithm of the translation. Section 5 explains how ProVerif can be used to verify the outcome of the translation while section 6 gives some details of the implementation and the experimental results on a selection of cryptographic protocols that were modelled in HLPSL in the framework of the AVISPA project.

Protocol specifications in HLPSL are divided into roles. Some roles (the so-called basic roles) serve to describe the actions of one single agent in a run of the protocol or subprotocol. Others (composed roles) instantiate basic roles to model an entire protocol run, a session of the protocol between multiple agents, or the protocol model itself. This latter role is called the main role.

In HLPSL, both variables and constants are typed. We will use the fol- lowing types: agent, channel, public key, text, nat, bool, symmetric key, message, function, protocol id. Certain types (text and channel) may have attributes enclosed within parentheses. For example, text(fresh) rep- resents the type of freshly generated nonces and channel(dy) the type of channels that correspond to Dolev-Yao (DY) intruder model [13]. In our

A transition is defined by a label lbi, a trigger event evi, and an action acti. Each transition is triggered whenever its guard event predicate is satisfied and fires immediately. In case when a few events are satisfied, one of the transitions corresponding to them is chosen non-deterministically and executed.

In addition, the main role must have declared a constant i of the type agent that represents the intruder. It may also have a declaration of the form knowledge(i) = K, which describes the initial knowledge of the intruder. Here K is a set of HLPSL terms.

The instantiations of the composed roles in an HLPSL specification form a tree with the main role as the root. To translate the composed roles we flatten this tree by repeatedly substituting the texts of composed roles for their instantiations and actual arguments for formal arguments, and using the parallel composition operator of the pi calculus to translate parallel composi- tions of role instantiations. Besides, we rename all the constants declared in the composed roles to avoid name clashes and declare them as free constants unknown to the intruder. In addition, for each basic role instantiation we in- troduce a constant representing an identifier for this instantiation. We add a formal argument SID to each basic role and assign the instantiation identifier to this argument in each instantiation. The instantiation identifier we be used while translating strong authentication goals.

For each of the values s of the State variable, assigned to it in the HLPSL text of the role we create a process Bs acting as the role in the state s. Let T r(s) be the set of all the transitions that have the conjunction State = s on their left-hand sides and let Nk be the set of fresh variables updated by the k-th transition (i. e. the set of those variables that have the fresh attribute and are primed on the right-hand side of the transition). Then

It is worth noting that currently the semantics of HLPSL is not clearly defined. Therefore, in some cases we had to make the decision of how to interpret HLPSL constructs. In this cases we tried to follow the semantics that is implemented in the AVISPA tool.

For example, in our subset of HLPSL it is not possible to model a situation in which a role receives a private key through a channel and then decrypts a message using this private key, i. e. a role has static knowledge. This is due to the fact that the private key must be known to the role at the beginning of its execution and written in the text of the role using the inv constructor. This is compatible with the AVISPA tool, which does not support processing of such a situation at the moment.

ProVerif has not terminated on the specification of ISO3 protocol. For all the other protocols we found known attacks against flawed protocols, and proved the correctness of the correct ones. The attacks were the same as the attacks found by the AVISPA tool (using OFMC as the back-end).

Finally, we are working to identify more sophisticated protocols to assess the scalability of our approach and to use other verification engines for the applied pi calculus. A possible approach is to use the HAL model checker [16,15]. This approach is particularly convenient since HAL can handle fresh names generation in an effective way.

