The Java Card platform [8] is a platform for building multi-application smart cards. It is based on a subset of Java which omits features such as concur- rency through threads, garbage collection, and many API functions. How- ever, to support multiple applications co-existing on the same card (e.g., both a purse applet and a loyalty applet), there is a notion of an applet. Java Card applets are implemented by extending the Java Card API class

To improve upon this situation the formal design techniques group of SICS have been using fully automatic and low-cost (in terms of execution speed and memory usage) verification methods that could, potentially, be used by an on (or off) card runtime system to determine at load time whether a new applet should be permitted onto a card with pre-existing applets or not. In a first experiment, reported in [3], we analysed inter-method calls of multi-applet Java Card smart cards using model checking of Java byte code. In this paper we extend the treatment to memory allocation concerns. In case the safety of an applet cannot be proved using model checking, we as a complementary technique instrument a compiled applet with a runtime monitor to guarantee that it adheres to a safe memory allocation policy.

To provide a semantics foundation for the analysis of Java Card applets we use the abstract notion of a program graph, capturing the control flow of pro- grams with procedures/methods, and which can be efficiently computed. The behaviour of such program graphs is defined through the notion of pushdown systems, which provide a natural execution model for programs with methods (and possibly recursion), and for which completely automatic model checkers for LTL exist, e.g., Moped [7]. The details of the translation are elaborated in section 3.1, and sections 3.2, 3.3 and 3.4 describes the logic and our use of the Moped model checking tool in further detail.

We use an external static analysis tool, Soot [12], adapted to Java Card 1 , to generate call graphs which abstract from everything (such as data variables, and parameters to method calls) but the presence and order of method calls inside method bodies. The analysis tool performs a safe over-approximation (with regards to preservation of LTL safety properties) in the sense that call edges may be present in the result call graph even if the corresponding calls cannot be invoked at runtime, but the opposite does not hold. For instance, when the static analysis cannot determine which class method is invoked in a method call, typically due to subtyping, then a call edge is generated to a tar- get method in every possible class, thus increasing the nondeterminism in the generated call graph. The static analysis tool generates graphs with informa- tion about exceptional behaviours. In this work exceptional edges, and nodes, are translated into non-deterministic constructs thus effectively increasing the non-determinism in program behaviour in a conservative fashion.

As we in this case study want to observe the allocation of memory by an applet the standard method call graph generation process has been augmented to additional include information about invocations of the new and newarray Java virtual machine (byte code) instructions. An instance of the new instruc- tion will be represented in a method call graph as a call to the new (synthetic) method Events.newInst and a newarray instruction as a call to the method Events.newarrayInst.

Next define the temporal patterns (formulas) (i) m2 after m1, i.e., m2 can only be called after a call to m1; (ii) m2 through m1, i.e., m2 can only be called from m1; (iii) m2 from m1, i.e., m2 can only be called directly from m1; and

Inspecting the byte code of the applet shows that the open platform 5 per- sonalization scheme seems to be used, i.e., the code contains a call to the method visa.openplatform.OPSystem.setCardContentState. To check whether allocation occur only before personalization the first property is re- fined into the property:

To summarise the state-of-affairs: during any call to process there is a possibility that personalization takes place, and if it does, no more memory is allocated. However, there exists also the possibility that an array is allocated during an invocation of the process method but that afterwards no personal- ization takes place. This need not necessarily indicate a bug; it could be that the applet keeps a state between invocations of the process method by the runtime environment which records whether personalization has taken place, i.e., the allocation property is data dependent and these data dependencies have been abstracted away during call graph generation thus generating false positives.

A monitor can be implemented in different ways: in a runtime system if it is accessible, or as a separate thread/process, or the code of the runtime monitor can be directly inlined with the monitored application. For the Java Card platform the choice of implementation method is obvious given the lack of threads, and the lack of access to API libraries. The applet code has to be physically combined with the runtime monitor code, using the technique of code instrumentation. Any operations in the applet code that could violate the monitor has to be preceded with monitor code that checks whether the operation in question is safe. Thus for the case study we monitor calls to the

We have implemented a facility for experimenting with the automatic in- strumentation of Java Card programs using the Soot [12] tool; in fact the same tool that was used for call graph extraction. A significant advantage of using the Soot tool is that it provides a well-defined high-level abstract view of Java (Card) byte code methods. A method is guaranteed to have single entry and return program points, the runtime stack is abstracted away in favour of assignments to local variables, to be composed of a select few instructions (rather than arbitrary Java byte code instructions) partly due to the absence of stack instructions, and for implementing program transformations there is ample support for inserting new byte code instructions in the middle of a method body.

As a followup to the first experiment with runtime monitoring we decided to monitor also the weaker property of bounded memory allocation, i.e., that there is a bound on the amount of memory the applet allocates. To permit the monitoring of this property the memory control transformer was easily

