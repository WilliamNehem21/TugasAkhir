There are many programming calculi which have been designed to have a Curry- Howard correspondence with a logical proof system. In recent years such calculi have been designed to explore the computational content of Classical Logic (e.g. [2,4,6,8,11,12,14]). Different authors have chosen different sets of logical connectives to treat as primitive in their logic, and designed the syntax and reduction rules of their calculi accordingly. Implication is the most popular choice of connective, since it is well-understood that its computational behaviour is related to function abstraction and application. There are calculi which do not use implication, for example that of Wadler [14]. Calculi exist which employ conjunction, disjunction, negation, and even more esoteric connectives such as difference [1,2] and constants for truth and falsity.

This leaves the appropriate extra logical reduction rules to be defined. Each new syntax construct warrants a logical rule to specify a renaming of its introduced connector, via a cut with a capsule (see the rules exp and med, for example). Finally, for each logical connective employed, a logical rule must be defined to show how a cut between the right and left introduction of the connective may be reduced (c.f.

new cuts between their subterms and simplifying the task of cut-elimination. The principal rule is the only one which cannot be methodically derived independent of the particular connective concerned. For this reason, when investigating the representation of a particular connective, as far as reduction rules are concerned we will only concern ourselves with the principal logical rule for the connective.

To explain the second question, take for example the binary connective which has inputs A and B and always evaluates to A (ignoring B). In a sense one could see this as a unary connective, since it only makes use of one input. This gives a way of identifying those connectives of arity n which we regard as degenerate cases. The third question regards a stronger notion; that the value of a connective should, in every input state, depend on all of its inputs. As a non-example, the

We will henceforth only interest ourselves in connectives of arity 2 (and be- low). As commented, this choice is common in the literature. On a practical note, since the reader may verify that t(3) = 218, an exhaustive analysis of all possible connectives of any greater arity would be too cumbersome.

In this section, we will give the complete set of possible binary connectives, and provide an analysis of them with respect to the three questions outlined at the start of Section 5. We are interested in possible relationships between these connectives, and how these are reflected by their computational counterparts. For example, duality is a well-known concept relating binary logical connectives, and it will be seen that this relationship carries over into their computational behaviour (this is related to the results of [2,14]).

As a separate point, it should be noted that if one employs more than one logical connective in a term calculus, it will be possible to create (untypeable) cuts between their respective syntax representations to which no reduction rule applies. For example, if one were to cut the term representation of the TR rule with a mediator, there would be no sensible way to evaluate the cut. Therefore, when more than one logical connective is employed, the notion of normal form is extended; in particular it will be possible to have (untypeable) normal forms which contain cuts.

(T) and (id), which might lead us to believe its simulation capabilities in this sense are limited. However, we find this is not the case; in fact we are able to simulate the reductions associated with several other connectives, i.e. we can encode the syntax for these other connectives in such a way that reductions are preserved. When this is the case, we say we can computationally express the connective (which may or may not be expressible in a logical sense).

If we look at the iff-terms themselves, we find they provide a wealth of input and output connectors arranged in different combinations over a number of subterms. We also observe that the principal logical rule (see Definition 6.2) offers a number of interactions between these different subterms, giving scope for modelling a variety of computational behaviour, some of which may be new.

late the reductions of X . As pointed out in Section 4.3, the mechanism provided by the propagation and renaming rules is generic to any X -style term calculus; it performs the same basic task of pushing cuts through subterms and renaming con- nectors regardless of the syntax employed. To show that such rules are simulated

