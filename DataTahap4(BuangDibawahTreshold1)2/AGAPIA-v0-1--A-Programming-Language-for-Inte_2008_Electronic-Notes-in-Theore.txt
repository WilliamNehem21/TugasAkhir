A model (consisting of rv-systems), a core programming language (for developing rv-programs), several specification and analysis techniques appropriate for modeling, programming and reasoning about interac- tive computing systems have been recently introduced by Stefanescu using register machines and space-time duality, see [47]. After that, Dragoi and Stefanescu have developed structured programming techniques for rv-systems and their verification, see, e.g., [14,15,16,17,18].

guage for writing interactive programs with registers and voices (rv-programs) have been presented [47]. One of the key features of the model is the introduction of high-level temporal data structures. Actually, having high level temporal data on interaction interfaces is of crucial importance in getting a compositional model for interactive systems, a goal not always easy to achieve (recall the difficulties in get- ting a compositional semantics for data-flow networks, [4,5,6,8,29]).

In a couple of papers Dragoi and Stefanescu have developed structured pro- gramming techniques for rv-programs and for their verification, see [14,15,16,17,18]. Here, a kernel structured programming languages AGAPIA v0.1 for interactive systems is introduced and its typing system is studied. 3

A first goal of the present paper is to introduce AGAPIA v0.1 language. An example is P in Sec. 3, an AGAPIA v0.1 program implementing a termination detection protocol. Here, we briefly touch on the key features of the language, with explicit reference to P.

A second goal of the paper is to study the typing system of AGAPIA v0.1. Our particular interest is to use the results for the design of AGAPIA v0.1 compilers. While it is the programmer duty to ensure the correctness of his/her program, our type checking procedure help him/her by checking the types of the programs and

The paper is organized as follows. It starts with a brief presentation of rv- systems, including: scenarios, operations on scenarios, finite interactive systems, rv- systems and rv-programs. Then, structured rv-programs are introduced and their scenario-based operational semantics is presented. Next, the syntax of AGAPIA v0.1 is presented and an implementation of a termination detection protocol is developed. A more technical section follows, describing the typing systems for AGAPIA v0.1 programs. A few examples and final comments conclude the paper.

Voices may be implemented on top of a stream in a similar way registers are implemented on top of a Turing tape, for instance specifying their starting time and their length. Most of usual data structures have natural temporal representations. Examples include timed booleans, timed integers, timed arrays of timed integers, timed linked lists, etc.

The body of a module is its bottom-right part, including type declarations and C- like code. The exit from the module is specified by a goto statement. A statement like goto [B,3] indicates that: (i) the data of the spatial variables in the current module will be used in a next module with control state 3; (ii) the data of the temporal variables in the current module will be used for the interaction interface of a new module with interaction label B.

Notice that a global scoping rule is implicitly used here: once defined, a variable is always available. It is also possible to introduce rv-programs obeying a stronger typing discipline, where each module comes with an explicit type at each border. This option is actually used for structured programs to be introduced in the next subsection.

The rv-programs, presented in [47] (and briefly recalled in the previous subsection), resemble flowcharts and assembly languages: one freely uses goto statements, with both temporal and spatial labels. The aim of this section is to introduce struc- tured programming techniques on top of rv-programs. The resulting structured rv- programs may be described directly, from scratch. The lower level of rv-programs is used as a target language for compiling.

Given a type V , the notations V (k), V.k, V.[k],V @k, V @[k] are used to refer to its components. For instance, in the case of spatial interfaces, they refer to: V (k)- a component of a choice; V.k - a component of a tuple within a process; V.[k] - a component of an iterated tuple within a process; V @k - a component of a tuple of processes; and V @[k] - a component of an iterated tuple of processes.

Expressions, usual while programs, modules, and structured rv-programs are naturally introduced. This v0.1 version of AGAPIA has a strongly restricted for- mat: the module and the rv-programming statements are not mixed (see [37] for a new, more powerful release: AGAPIA v0.2.). The development starts with simple while programs, then modules are defined, and finally AGAPIA v0.1 programs are obtained applying structured rv-programming statements on modules. 7

The protocol is used for termination detection of a ring of processes. It can handle the case when processes may be reactivated after their local termination. To this end, it uses colored (i.e., black or white) tokens. Processes are also colored: a black color means global termination may have not occurred. Then, the algorithm works as follows:

The token is passed through the ring from one process Pi to the next when Pi has terminated. However, the color of the token may changed. If a process Pi passes a task toa process Pj with j < i, then it becomes a black process; otherwise it is a white process. A black process will pass on a black token, while a white process will pass on the token in its original color. After Pi has passed on a token, it becomes a white process.

Suppose there are m processes, denoted 0,...,m-1. Besides the input m, the program uses the spatial variables id : sInt, c : {white, black}, active : sBool and the temporal variables tm, tid : tInt, msg : tIntSet[ ]. (sInt, sBool, tInt, and tIntSet stands for spatial integers, spatial booleans, temporal integers, and temporal sets of integers, respectively.)

When a process executes the code R, whether active or passive, it checks if new jobs were assigned to it; if the answer is positive, it collects its jobs from the jobs list and stays/becomes active. When it is active, it executes some code, sends new jobs to other processes, and randomly goes to an active or passive state. If it has the token, it keeps it until it reaches termination and afterward it passes it. A white process will pass the token with the same color as it was received and a black process will pass a black token (after passing the token, the process becomes white).

For an arithmetic expression, we collect in a set the variables occurring in the expression, together with their types. The leafs of the expression should have an integer sn or tn type, otherwise the error type err is associated. The typing of the leafs is naturally extended to the full expression, collecting the types of the components and propagating their ok, war0, err status flags.

In the last 20 years, a rich and successful algebraic approach to cyclic struc- tures has been developed, see, e.g., [10,11,12,30,25,26,39,40,43], either for control or for reactive models. There are attempts to mix these two models, see, e.g., [23,24,42,41,45,44] or the last chapter of [43]. The model of rv-systems, presented in this paper, falls into this class. A difficult, but worthwhile, research topics is to extend such algebraic techniques to rv-programs.

Finally, a general topics is to develop an efficient and fully flagged compiler for AGAPIA programs. Our current approach is to translate structured rv-programs to rv-programs, then we use a running machine for rv-programs to get the program output. Currently, we have an automatic procedure for the translation (see [18]), but it is not fully implemented as we still look for the possible optimizations to improve the compiler.

