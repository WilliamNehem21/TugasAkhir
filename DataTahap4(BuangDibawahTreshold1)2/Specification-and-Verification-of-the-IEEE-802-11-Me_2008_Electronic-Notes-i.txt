To the best of our knowledge, some properties of the IEEE 802.11 standard has been proved only recently [18,12]. However, this work has three main limitations. Firstly, although the standard was formally specified, the verification followed an informal and non-mechanized approach. Secondly, as the concept of time was not modelled, only safety and liveness properties (without considering time) were taken into account. Timeliness, as needed by QoS and real-time oriented applications, has not been considered. To understand the third limitation, some explanation about the coordination functions of the protocol standard is needed.

IEEE 802.11 provides two coordination approaches, provided by the Point Co- ordination Function (PCF) and the Distributed Coordination Function (DCF), re- spectively 5 . The former uses an arbiter station to coordinate the medium access, making it possible to avoid access conflicts between different stations. The medium access control policy used by the latter, on the other hand, is distributed and it en- sures only the best-effort delivery of messages. As systems may alternate between PCF and DCF during its operation time, the protocol behavior must be analyzed considering both these functions in an integrated way. However, [18] have verified these functions in isolation. Issues related to the possible interference that one function may have in the temporal behavior of another has not been taken into account.

5 There is a version of the standard which introduces mechanisms to deal with message priorities, called IEEE 802.11e [9]. The main rules of IEEE 802.11e MAC are essentially the same, where the coordination functions, HCF and EDCF have similar meaning as PCF and DCF but operate with traffic categories.

The remainder of this paper is structured as follows. The sections 2 and 3 briefly describe the MAC layer of the IEEE 802.11 standard and UPPAAL, respec- tively. The specification and verification are presented in section 4. Then, section 5 provides our final comments and points out some possible research directions.

The IEEE 802.11 standard defines two medium access control schemes or coordina- tion functions: Point Coordination Function (PCF) and Distributed Coordination Function (DCF). The PCF is based on medium access arbitration. One of the sta- tions works as an arbiter, determining when each station of the network is allowed to send frames. The DCF is not based on a special station controlling the access to the medium. Stations trying to send frames contend for obtaining control of the medium. This might lead to colisions.

When PCF is being used to control access to the medium, the network is called to be in the Contention Free Period (CFP), since the medium arbitration avoids collisions. When DCF is being used, the network is called to be in the Contention Period. Support for PCF is optional. When a network supports PCF, both coordi- nation functions occur alternatively in time.

The DCF is the basic coordination function in IEEE 802.11 and defines a CSMA/CA (Carrier Sense Multiple Access / Collision Avoidance) access method. This method is based on medium sensing before each message is sent (Carrier Sense) and on a mechanism for avoiding (instead of detecting, as in Ethernet) collisions (Collision Avoidance). Before sending a frame, a station first verifies if the medium is free (no station is currently transmiting). If it is, the station sends the frame and waits

for an acknowledgment (ACK), confirming correct reception of the message by its destination. After having started, a station continues to transmit a frame until the whole frame is successfully sent, even if collisions might have happened. If the medium is not free, the station executes a backoff procedure. After having executed it, the station tries to send the frame again. The station repeats this process until either it receives an ACK frame or it stops after having tried a certain amount of times.

A station verifies if the medium is free or not by using a sensing mechanism in the physical layer together with a logical verification mechanism at the MAC sublayer. In the physical layer, the station senses the physical medium to detect the presence of signals indicating current transmission. In the MAC sublayer, the medium activity verification is performed by using a variable, local to each station, called NAV (Network Allocation Vector ). At each instant of time, the value of this variable indicates how long the medium will still be busy. The value of this variable is set by using information about the duration of frame transmissions sent by the stations as part of the frame headers. A station only assumes the medium to be free if the medium sensing at the physical layer indicates that there is no signal in the medium and if the NAV value is zero.

Before each frame can be sent, the sending station must sense the medium to verify that it is free for a certain period of time, known as interframe space (IFS). Three types of IFSs are defined for the DCF: the Short Interframe Space (SIFS), the DCF Interframe Space (DIFS) and the Extra Interframe Space (EIFS). The SIFS is the shortest, followed by the DIFS and EIFS, respectively. The SIFS and the DIFS have both a fixed length for a particular transmission physical medium. The EIFS has a varying length, depending on failure conditions. The IFSs are used as a mechanism to provide prioritary access to the medium. As shorter the IFS, as higher the priority for accessing the medium, since a station needs to wait a shorter time before trying to use the medium. Each IFS is used in specific situations of the protocol.

The backoff procedure works as follows. When a station starts the backoff proce- dure, it waits for the medium to become free for a DIFS period. After that, it waits for a random period of time, known as the contention window or backoff period. In order to control how long it still has to wait, each station has a local clock variable, which has its value decremented as the medium is free. If the medium becomes busy during a backoff period, the value of the clock is frozen. The clock is decremented again when the medium becomes free. This procedure is repeated until the whole backoff period has elapsed (the clock reaches zero). Before transmitting, however, the station still needs to sense the medium free for at least a DIFS period.

The PCF is defined as optional in the IEEE 802.11 standard and is built on top of DCF. As described previously, the medium access control in the PCF is based on arbitration. The station working as the bus arbiter is called the Point Coordination (PC). A station will only transmit if either it was polled by the PC or is replying to a previous transmission with an ACK.

To begin a CFP (period during which the PCF is being used), the PC waits until the medium is free for a time interval (interframe space) called PCF Interframe Space (PIFS) and sends a special frame, called beacon frame. A PIFS is longer than a SIFS and shorter than a DIFS. After having waited for a SIFS period, the PC can choose either to end the CFP, by sending a CF-End frame, or to poll some station, by sending one of the following frame types: CF-Poll, CF-Poll+Data or Data. The first frame is used by the PC to poll a station, without sending additional (application) data. The second is used when the PC polls a station and sends (application) data simultaneously. The third is used only for sending data.

A timed automaton is composed of a set of finite states, an initial state, a finite set of edges and a finite set of clocks. Constants and variables can be declared to represent channels, boolean values or numeric values. Invariant conditions can be associated to the states and three types of labels can be associated to the edges representing: guards, synchronisation functions and actions. The UPPAAL state- graph model is made up of circles that represents states, double concentric circles that represent the initial state, and arrows interconnecting the states representing automaton edges.

A system can be modelled using a timed automaton network in which each automaton models a system part. Clocks are used to specify temporal restrictions which will be associated to the states and edges of the automaton. When the automaton execution starts the clock values increase at a constant rate. Invariant conditions associated with a state restrict the permanence of the automaton on that state.

Some channels and states can be declared urgent. An edge with an urgent channel will be executed as soon as possible, regardless of any delay transitions. Similarly a state declared urgent (marked with the letter U) does not permit the evolution of the network by delay transitions.

The MAC sublayer was modeled using six automata. Two of them model the behavior of a station in the DCF. The others model the behavior of a station in the PCF, the behavior of the PC, the behavior of the carrier sense function and the behavior of the medium.

These automata contain a set of global constants and variables: a) to represent parameters that depend on the physical medium (e.g. SIFS, DIFS, PIFS), b) to in- dicate the transmission time of frames exchanged by the protocol (e.g. ACK TIME, CF END TIME, BEACON TIME), c) to model the interactions resulting from the frame starting or ending transmission between the workstations and the medium (e.g. channels iniACKm, endACKm), d) to model the interactions resulting from the frame starting or ending transmission between the medium and the workstations

The behavior of this automaton can be explained as follows. The automaton starts in the Init state and waits for another station to send a RTS frame (edge with iniRTS?) or a MPDU frame (iniMPDU?). In the first case the automaton begins to process the RTS frame (state ReceivingRTS) and at the end of this process it moves to state WaitSIFS (edge with endRTS?) where it remains for at most a SIFS period, which is guaranteed by the local<=SIFS invariant associated with the state.

In the WaitSIFS state, the station will randomly choose either to return to the initial state, i.e. RTS was not received successfully, or to answer with a CTS frame. In the latter case, the transition can only occur after a SIFS period has elapsed, which is guaranteed by both the local==SIFS guard associated with the edge and the invariant local<=SIFS associated with the state WaitSIFS. From this

transition, the automaton will synchronize with the medium through iniCTSm! starting the transmission of a CTS. The automaton remains in SendingCTS until the end of the CTS transmission, signals to the medium that this transmission has finished (endCTS!) and waits for the arrival of a MPDU frame. It remains in state WaitMPDU until the start of a MPDU transmission (iniMPDU?). After this, it makes a transition to ReceivingMPDU. In modeling the Basic DCF and DCF with RTS/CTS operations, this state is also reachable from the initial state (state Init) through the edge with the same action (iniMPDU?).

The automaton remains in ReceivingMPDU until it detects the end of the frame transmission (endMPDU?) going to state ReceivedMPDU. Then, it can randomly choose to either return to state Init, i.e. the message was corrupted, or go to state MPDUOK if the MPDU reception was successfully. In the latter case, it waits a SIFS period, as described by the invariant (local<=SIFS) and by the guard (local==SIFS). At this moment, it begins to send an ACK frame through the action iniACKm!. Then, the automaton remains in SendingACK until the end of the transmission of the ACK frame and finally returns to Init(endACKm!).

The backoff procedure can be engaged by four edges. The first is from the InitDCF state and it is engaged when the station ready to transmit detects the medium busy (nav==BUSY). The second edge is from the WaitDIFS state and is activated when the station that is waiting for a medium inactivity period elapses (DIFS) perceives that, during this period, another station has begun a transmission (busy?). The third edge is activated when the sending station does not obtain a CTS after sending a RTS frame (NoCTS state). Finally, the fourth edge (from the state NoACK) indicates that a station has not received an acknowledgment frame after transmitting the MPDU because the communication process has failed.

When the station is in backoff, it verifies whether the medium is free or busy. If the medium is busy, the automaton moves to state WaitIDLE (edge with guard nav==BUSY), where it waits for the medium to be free. Once it is free (idle? activated), the automaton goes to state WaitIFS1. In this state the station waits a DIFS period of medium inactivity. After this, the station waits the backoff random waiting period. The state WaitIFS1 can be reached directly from InitBackoff if the medium is free when the backoff has been initiated (edge with guard nav==IDLE). If the medium is busy during the period that the station is waiting the DIFS period (synchronization busy?), the automaton moves to state WaitIDLE, where it waits again for the medium to be free. If the medium continues free for the whole period (invariant local<=DIFS associated to state WaitIFS1 and guard local==DIFS of the edge that connects WaitIFS1 and ChooseBckOffValue provide it), the state ChooseBckOffValue is reached.

The state SendingRTS is reached after a write operation in the channel iniRTSm. The automaton remains in this state for the necessary time to transmit a RTS frame (invariant local <= RTS_TIME and guard local == RTS_TIME) and moves to WaitCTS. The automaton stays at most CTSTimeout time in the state WaitCTS and then leaves it because either CTSTimeout has elapsed (the case in which the automaton moves to state NoCTS and begins a backoff procedure) or a CTS frame has arrived. Exiting from this state occurs through an action with the medium

(iniCTS? and then state ReceivingCTS). The automaton stays in ReceivingCTS until the end of transmission of the CTS frame (endCTS?) and moves to state WaitSIFS. In this state, it waits the time between SIFS and begins to send the data (iniMPDUm!) reaching the state SendingMPDU. The period of time that the au- tomaton stays in state SendingMPDU depends on the size of the frame that is being transmitted and can vary between MPDU_MIN_TIME and MPDU_MAX_TIME (invariant local<=MPDU_MAX_TIME and guard local>=MPDU_MIN_TIME).

In the state SendingMPDU occurs the end of the transmission (endMPDU!) and then a movement to state WaitAck. In WaitAck, the automaton waits for an ac- knowledgment frame (iniAck?) or an occurrence of timeout (ACKTimeout). If time- out occurs, it is because the MPDU transmission has failed and the automaton has to move to NoAck and a backoff procedure should be engaged. If the MPDU transmission has been successful, an ACK frame is received ((ReceivingACK)) until it ends (endACK?). At this moment, the automaton moves to state Transmitted in- dicating that the transmission has successfully completed, and then moves to state Init.

The PC does a series of cycles in which it periodically visits the state Polling. In each of these cycle the PC can schedule or not a station and can choose or not to send data to one station. The states SendingData, WaitingAck and ReceivingAck model the sending of data by the PC to a station not scheduled. This behavior is similar to the sending of data in basic DCF mode. The PC can schedule a sta- tion in isolation or combined with data and/or acknowledgement frames. These situations are described by the states SendingCF_Poll, SendingData$CF_Poll, SendingCF_Poll$CF_Ack and SendingData$CF_Poll$CF_Ack. Depending on the case, the station can answer to the PC with data (iniMPDU?), with an acknowledge- ment frame (iniCF_Ack?) or can refuse the schedule (iniNull?). In any case, the automaton returns to state Polling.

The initial state Idle indicates that the medium sensing function has detected that the medium is free. BusingNAV and BusingPHY are states that represent when the medium is considered to be busy by virtual and physical sensing, respectively. This detection is modeled by read operations (navBusy? or phyBusy?). After de- tection, the sensing function notifies the sending station of the current medium situation (busy! and csm:=BUSY). The detection of the medium as busy by the

virtual and physical sensing is identified by the states Nav and Phy, respectively. Whichever mechanism is active, the automaton moves to state Both if the medium is detected as busy. In returning to state Idle, the automaton notifies that the medium is free (idle! and csm:=IDLE).

The automaton stays in state Init until a station starts or finishes the transmis- sion of a frame. One of the edges that connects Init to state RcvPacket is activated and the variable packetMode) registers which type of event has activated the tran- sition. Although time does not affect state RcvPacket (urgent state), interleaving among the automata can occur and collisions are represented by incrementing the variable collision. Afterwards, the automaton moves to state TransPacket and then to state NotCollision, if no collision has been registered (collision == 0) or to state Collision if a collision has occurred (collision > 0).

If the transmission is of a DFC typical frame, the automaton signals to the receiving station that the frame transmission has started or finished (from state NotCollision). This is done according to the variable packetMode. Then, the automaton moves to state EndFrame.

As regards combined frames the automaton breaks down the acknowledgment information presented in previous frames. To model this behavior, two channels are used: noAck and cfAck. Thus, if the frame belongs to the acknowledgement family (CF-Ack+CF-Poll, CF-Ack+Data, CF-Poll+CF-Ack+Data, CF-End+CF-Ack), a write operation is done in channel cfAck. If the frame is one of CF-Poll, CF- Poll+Data, Null, CF-End, Beacon or MPDU, a write operation in channel noAck occurs. The frames that are not addressed to any station in particular (the frames

We verified properties of the IEEE 802.11 MAC protocol for several different au- tomata networks. Firstly, the modes DCF and PCF were validated in isolation. Then, we verified properties in scenarios with workstations operating in either mode. As the obtained results for the modes in isolation were compatible with the ones found when they coexist in time, we have only described the latter.

The described results were obtained for a scenario with three workstations oper- ating in DCF mode, two in PCF mode and a Point Coordinator (PC) workstation. This scenario was considered sufficient, since all states are reachable, including those related to the backoff function of the DCF mode. We experienced state explosion when verifying some properties in scenarios with more components.

For verifying the properties, UPPAAL 3.4.11 was used running on a Computer Intel Celeron with 2.3 GHz CPU clock and 1GB of RAM. The longest verifying time, approximately 2 hours, was found to verify property 1. The other properties were verified in the range of 15 ms (property 3) to 21 min (property 6).

This property was verified using the formula A[]!phy.Collision. This formula is the negation of the property, i.e., it states that for all paths it is always true that no collision will occur in the physical medium (occurrence of collision is represented by the Collision state). It was checked as false.

The formula dcf1.EndBackoff-->dcf1.Transmitted represents the negation of the property, i.e., for all paths if a process in DCF mode (dcf1) terminates backoff (EndBackoff state), then it becomes eventually able to send a message (Transmitted state). This formula was checked as false. Hence, there is no guaran- tee that a station will transmit even if the backoff procedures of previous collisions have finished.

+ MAX DCF COM TIME + BEACON TIME). This is the maximum time needed for a station to send a packet of maximum size using RTS/CTS and receive an acknowledgment (see section 4.1.5 for the meanings of these constants). This is an upper limit to the value of maxPCF since its value is set to zero when the PC enters the InitPCF state. Other workstations (other than PC) do not have guaranteed access to the medium (as stated by properties 3 and 4).

We have presented a formal verification and specification of the MAC layer defined in the IEEE 802.11 protocol standard, where both of its coordination functions (DCF and PCF) were considered in an integrated way. These functions have only been considered in isolation up to now.

Finally, the IEEE 802.11 standard is also often applied to mobile systems, where workstations may move during the system operation. This may generate situations of temporary failures, where workstations cannot be seen by others. Incorporating mobility into the specification should also be part of future work.

