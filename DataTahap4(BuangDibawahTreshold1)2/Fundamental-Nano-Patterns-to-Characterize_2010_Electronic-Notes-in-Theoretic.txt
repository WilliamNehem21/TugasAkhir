We have developed a command line tool to detect nano-patterns for methods in Java bytecode class files, based on the ASM bytecode analysis toolkit [6]. Our tool reads in a class file name specified as a command line argument, and dumps out a bitstring of nano-patterns exhibited for each method in the class. The detection tool is written in Java; it is only 600 source lines of code. Our code makes extensive use of data structures and visitor code from the ASM API. The tool operates in two different ways to detect specific nano-patterns:

We envisage that it should be possible to automate the generation of ASM-based detection code for specific nano-patterns, given some kind of formal specification of the nano-pattern characteristics. A meta-language like JTL [8] may be useful here. We do not address this issue in the current research.

they are stored in library container data structures. Even with addition of generics in Java 5 source, type casts are still present in Java bytecode for retrieving objects from container data structures. Therefore this rule is an idiomatic artifact of the Java source to bytecode transformation.

Such methods take a single argument, write this value to a field of the current object and return void. The code listing below gives an outline example. One would expect to see this kind of rule for well-written programs in any object-oriented language.

Detection of high-level design patterns from low-level nano-patterns. In gen- eral, design pattern discovery is acknowledged to be difficult [14,9]. We have shown above that some combinations of low-level features are potential indica- tors for higher-level patterns. Gueheneuc et al [13] explore this concept further, although with a possibly more restrictive set of static code features.

Identification of potential bugs. Given a large and varied corpus of code, we can extract a set of high-confidence association rules. If these rules are not kept in new code, an online interactive checker can inform the developer of the rule violations [20].

The SPECjvm98 benchmark suite was originally intended to evaluate the per- formance of commercial Java virtual machine (JVM) implementations. However due to its small size and relative age, it is now only used as a target for academic research such as points-to analysis [21]. A potential replacement for SPECjvm98 is the DaCapo benchmark suite, compiled by an academic research group. The Da- Capo introductory paper [4] presents an extensive empirical study to highlight the differences between these two benchmark suites. The authors claim that DaCapo is superior to SPECjvm98 for two main reasons:

A higher proportion of methods create objects in DaCapo, and it also has many more type manipulating methods. These are clear indications of object orientation. On the other hand, there are similar amount of object field reading for both suites. Interestingly, SPECjvm98 seems to perform much more object field writing. We investigate the difference between accesses to static and instance fields, since FR and FW cover both static and instance accesses by definition. Again we found similar statistics in both suites: around 20% of reads are to static fields, and less than 10% of writes are to static fields.

One potential limitation of this study is that the nano-pattern catalogue does not presently capture all object-oriented behaviour. For instance, we do not have any measure of method overriding via virtual method calls. Also we make no distinction between accessing object fields through a this pointer and other pointers. Perhaps a richer set of nano-patterns would provide a clearer picture.

Nano-patterns can be used to indicate similarity between methods; we assert that similar methods should exhibit similar nano-patterns. The DaCapo paper [4] criti- cizes the SPECjvm98 benchmarks for being overly similar. The authors take a set of architectural metrics for each benchmark and perform a principal components analysis with four dimensions. They show that the DaCapo programs are spread around this 4-d space, whereas the SPECjvm98 programs are concentrated close together.

Analysis based on nano-patterns is entirely static. For a true comparison between the benchmark suites (especially in relation to diversity) it would be better to look at both static and dynamic behaviour. The DaCapo study focused entirely on dynamic behaviour, whereas we have only looked at static behaviour here. However we reach the same conclusions in relation to intra-suite diversity.

ison of the benchmark suites in isolation. Often these particular Java benchmarks are used to compare static analysis techniques (as opposed to runtime JVM per- formance) in which case, static object orientation and diversity become the main concern. Hence this style of empirical comparison based on nano-patterns is indeed valuable.

Clustering is a form of unsupervised learning. It is used to group data points into a variable number of clusters based upon a similarity measure, usually a distance metric. This enables a quick characterisation of data into higher level groupings. In this particular context, we aim to cluster similar methods to enable program comprehension, where method similarity is based on nano-pattern bitstrings. There are two main obstacles:

We note in passing that there has been previous work using clustering to anal- yse Java methods [19]. However our set of static method features appears to be richer than in earlier work. The application area for this analysis is mostly program comprehension.

Our future work includes extending the provisional catalogue of nano-patterns. We hope to improve its object-oriented features with support for method over- loading, overriding and super() calls. We also want to enrich our Exceptions nano-pattern to distinguish between methods that throw exceptions directly, catch exceptions, and propagate uncaught exceptions. Additional higher-level method

