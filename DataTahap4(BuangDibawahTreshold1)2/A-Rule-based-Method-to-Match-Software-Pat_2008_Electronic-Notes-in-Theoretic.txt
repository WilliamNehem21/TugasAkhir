Maintenance is recognized as the most expensive activity of the software develop- ment process. Numerous techniques and processes have been proposed to ease this task. One of the most influential proposals are design patterns [8], a collection of elegant and reusable solutions to recurring design problems. Design patterns have been quickly adopted by the object-oriented community because they ease design- ing, understanding, and re-engineering software.

However, all these proposals, at the boundary of programming languages and design models, suffer from a lack of formalism. For this reason, their application remains empirical and manually performed (which is certainly tedious and error prone).  We believe that this task should be automated or at least, be assisted.

Pattern description languages approaches like [7,6] instead introduce a (graph- ical) formal language (LePUS) which provides a much higher expressive power. Indeed LePUS is not an ad hoc collection of loosely related concepts but instead originates from an insight on a small number of basic building blocks that are ubiquitous in object-oriented design. One can easily define LePUS descriptions of common design patterns, such as Proxy, Visitor, and Composite [8]. With this approach the designer can easily redefine the descriptions of canonical patterns to look for his customizations, or define new ones from scratch, or either simply look for arbitrary compositions of other patterns at the same time.

We prefer this approach. However, LePUS is not powerful enough to express descriptions of several relevant properties, amongst all (for example) circular de- pendencies and, in general, antipatterns [5], which are essential to identify parts of a complex model which do not conform to the expected design properties. Fur- thermore the proposed prototype works only on code and not directly on UML models.

Throughout this paper, we formalize the merge of all the class diagrams of an UML model as a graph-shaped structure over a set C of classes and a set A of relations (labeled arrows) between classes. We will often call it the class diagram. For a thorough explanation of UML diagrams see [11,4].

Actually in the tool we also consider all typical method properties like visibil- ity, staticity, stereotypes, parameter passing modalities (in, out, . . . ), etc. Besides, attributes are handled with a separate set. For the sake of simplicity we will not clutter this presentation with all these details.

Example 5.1 Let us show an example of a simple pattern that can also be discov- ered by ad hoc tools. Consider the Composite Pattern pcom formalized in Exam- ple 3.2. The execution of the match of pcom against DE of Example 2.1 is

Example 5.4 Let us now see an example with an antipattern which cannot be expressed with LePUS. Consider the pattern which we formalized in Example 3.5. By executing such a pattern against DE, we are able to detect all the cycles appearing in the diagram.  Concretely, we recognize all five cycles involving the

We are currently working on a (quite technical) extension of the tool. As the information which is contained in class diagrams can be synthesized by inspecting source code, we are integrating into the matching mechanism the possibility to extract class information directly from the code. The difficult part of this is just to build a parser for the target language, then it is just a matter of visiting the parse tree.

In this paper we proposed a formal language for describing both design patterns and antipatterns. We provided a small number of basic building blocks, that are ubiquitous in object-oriented design, plus some language connectives to glue other blocks as desired, instead of giving an ad hoc collection of loosely related concepts. With this language one can easily define descriptions of common design patterns, as well as customized variations or arbitrary compositions of other patterns.

