This paper provides a tutorial-style introduction to interfaces and discusses the basic concepts and ideas. In particular, we elaborate on the automaton-based interfaces from [12] and the timed interfaces from [14]. Due space limitations, we do not treat the notion of interface refinement, but we refer the reader to [12] and [10].

The prevalent trend in software and system engineering is towards component- based design: systems are designed by combining components, some of them off-the-shelf, other application-specific. The appeal of component-based de- sign is twofold: it helps to tame complexity through decomposition, and it facilitates reuse. Components offer the unit in which complex design prob- lems can be decomposed, allowing the reduction of a single complex design problem into smaller design problems, more manageable in complexity, that can be solved in parallel by design teams. Components also provide a unit of design reuse, defining the boundaries in which functionality can be packaged, documented, and reused.

Summarizing, the composition of two interfaces yields a new interface for the composite system. The input assumptions of the new interface guarantee that the input assumptions of the composed interfaces are met; the output guarantees of the new interface combine the output guarantees of the com- posed interfaces. The compatibility and composition of interface automata will be explained later in this paper.

Interfaces as games. An interface is naturally modeled as a game between the players Output and Input. Output represents the component: the moves of Output represent the possible outputs generated by the component (output guarantees). Input represents the environment: the moves of Input represent the inputs accepted from the environment (input assumptions).

the existence of an environment for the combined interfaces that ensures that the input assumptions of both individual interfaces are satisfied. Component composition thus consists in synthesizing the most liberal input strategy in the composite system that avoid all locally incompatible states. This can be done by classical game-theoretic algorithms.

Related work. Models that can encode input assumptions, such as process algebras, usually phrase the compatibility question as a graph, whereas we treat it as a game question. In a graph model, input and output play the same role and two components are considered compatible if they cannot reach a deadlock [16,9,17] In our game-based approach, input and output play dual roles. Two components are compatible if there is some input behavior such that, for all output behaviors, no incompatibility arises. This notion captures the idea that an interface can be useful as long as it can be used in some design. In this respect, interfaces are close to types in programming languages, to trace theory [15], and to game semantics [1,2,4,5]. The reader is referred to [11] for a more elaborate comparison with related work.

Organization of the paper. This paper treats two automaton-based for- malisms for the specification and analysis of interfaces. Section 2 presents interface automata and defines well-formedness, compatibility and composi- tion for these interfaces. In Section 3, we extend interface automata with real-time, yielding timed interface automata. Again, we explore the notions of well-formedness, compatibility and composition. In particular, we explain how timed interfaces deal with time progress conditions, which are needed to ensure that time can advance in every system behavior.

Example 2.13 The interfaces B and R are clearly compatible, as the initial state (b0, r0) is so with respect to Error (B, R). Indeed, in state (b0, r1) the environment can prevent entering error states by not providing the input snd?. Hence, while the state (b0, r1) itself does not have to be avoided, its outgoing snd? action should be avoided. This is achieved automatically by removing the incompatible state (b1, r1), along with the transitions leading to it.

This section extends the interface automaton model with timing constraints, yielding timed interface automata [14]. A timed interface automaton augments an interface automaton with a set of real-valued clocks. Clocks occur in lo- cation invariants and transition guards, respectively specifying deadlines and enabling conditions on the actions of the interface. Timed interface automata are syntactically similar to timed automata [3], except that they have two kinds of invariants, one for input and one for output actions. Semantically, however, the two models differ: timed automata are interpreted as labeled transition systems, while timed interfaces are interpreted as timed games.

The order of the quantification (first over output strategies, then over input strategies) makes the game turn-based. i.e. the Output player chooses its move first and Input can use this move to determine its own move. This is due to the asymmetrical causality relation between inputs and outputs in composition, as explained in [14].

The composition of two TIAs is again obtained from their product by strengthening the input assumptions to avoid all error states. In TIAs, input strengthening means strengthening the input invariants. 8 A product of two TIAs may contain two kind of locally incompatible states: I/O-incompatible states and timing-incompatible states. A state is I/O-incompatible when one component can preform an output action that is not accepted by the other component, as in the untimed case.

The result below states that if we compose two well-formed and compatible interfaces, we get a well-formed interface. As well-formedness corresponds to the interface being useful in some environment, we see that composing two useful interfaces that can be used together, yields another useful interface. Note that this result trivially holds in the untimed case.

