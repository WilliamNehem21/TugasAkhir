This paper gives an overview of recent advances in Real-Time Maude. Real-Time Maude extends the Maude rewriting logic tool to support formal specification and analysis of object-based real-time systems. It emphasizes ease and generality of specification and supports a spectrum of analysis methods, including symbolic simulation, unbounded and time-bounded reachability analysis, and LTL model checking. Real- Time Maude can be used to specify and analyze many systems that, due to their unbounded features, such as unbounded data structures or dynamic object and message creation, cannot be modeled by current timed/hybrid automaton-based tools. We illustrate this expressiveness and generality by summarizing two

Users of formal tools face a choice between expressiveness and generality of the modeling formalism on the one hand, and the availability of decidable and complete analysis methods on the other. For real-time systems, tools based on timed and linear hybrid automata, such as Uppaal [13] and HyTech [12], have been successful in modeling and analyzing an impressive collection of systems. However, while their restrictive specification formalism ensures that interesting properties are decidable, such finite-control automata do not support well the specification of larger systems with different data types, communication models, and advanced object-oriented features.

The goal of this paper, as its title suggests, is to give an overview of recent advances in Real-Time Maude. Specific advances have been individually reported elsewhere [16,22,23,19], but no overview of the state-of-the-art exists. This paper tries to fill this gap and provide answers to questions such as: (i) what is Real-Time Maude good for?; (ii) how is it different from Uppaal and HyTech?; (iii) what logical properties can be decided?; and (iv) what applications can Real-Time Maude handle that other tools cannot handle? In particular, we emphasize expressiveness, generality, and completeness aspects, as well as challenging applications.

This latter feature is important when modeling advanced wireless sensor network algorithms. Such algorithms pose many challenges to their modeling and analysis, as explained in Section 4. In joint work with Stian Thorvaldsen, the first author recently modeled, simulated, and analyzed the sophisticated OGDC algorithm for density control in wireless sensor networks. To the best of our knowledge, our work on OGDC represents the first attempt at using a formal tool on advanced wireless sensor network algorithms. In Section 4, we show how communication in wireless sensor networks, at the level of abstraction of OGDC, can be modeled, and briefly summarize the modeling and analysis of the OGDC algorithm.

The increasing sophistication of scheduling algorithms makes it challenging, if not impossible, to model such algorithms using automaton-based formalisms. In joint work with Marco Caccamo, we have modeled and analyzed the state-of-the-art CASH scheduling algorithm [7] and a proposed improvement of this algorithm. This work is reported in [16]; here we give an overview.

We have specified (both versions) of the CASH algorithm, for all possible task sets, by allowing a job to arrive at any time and to execute for any non-zero amount of time. We have specified the algorithm in an object-oriented style, where each task server is modeled by an object of a class Server. The specifications are given in detail in [16]. In what follows, we just give a flavor for the specification.

We represent a spare capacity as a term deadline: d budget: b, where d is its relative deadline and b is its remaining budget. The cash queue of spare capacities is represented by a term [CASH: c1 ... cn ], where c1 ... cn is a queue of spare capacities. The sorts and operators for this data type are specified as follows:

A wireless sensor network consists of a set of small, cheap, and low-power sensor nodes that use wireless technology to communicate with each other [3]. Most often, it is assumed that sensor nodes communicate by broadcasting using a radio trans- mitter with an undirected antenna. Sensor nodes tend to have limited power supply (provided by a battery) that is virtually impossible to replace.

Modeling and reasoning about time-dependent behavior. For example, longevity of the network is often a crucial goal, in which case power consumption must be modeled. In addition, wireless sensor network algorithms may use timers, message transmission may be subject to message delays, and so on.

Jennifer Hou recently suggested to us the state-of-the-art optimal geographical density control (OGDC) algorithm [24] for wireless sensor networks as a challenging modeling and analysis task. OGDC has been simulated in the simulation tool ns- 2, where its performance was compared to the performance of similar algorithms. OGDC presents all the challenges (1) to (6) above.

We have modeled, simulated, and analyzed OGDC in Real-Time Maude [23]. To the best of our knowledge, our work on OGDC represents the first formal modeling and analysis effort of sophisticated wireless sensor network algorithms. We were able to do in Real-Time Maude all the analyses that the developers of OGDC per- formed using the wireless extension of ns-2 [11]. In addition, we have subjected the algorithm to time-bounded reachability analysis and temporal logic model check- ing. Such analyses normally explore all possible behaviors from a certain state, but in our case they were also relative to the sampling techniques used for simulating probabilistic behaviors.

This paper intends to give some high-level ideas on how to model wireless sensor network algorithms. The paper [22] explains in more detail how sensor network algorithms in general can be modeled and analyzed in Real-Time Maude. The report [23] describes the OGDC case study in detail.

Each sensor node can suitably be represented as an object of, say, a class called WSNode. A wireless sensor node usually does not have an explicit identifier, but can be identified by its location. In Real-Time Maude, we let object identifiers be locations by giving the subsort declaration subsort Location < Oid .

In OGDC, the network lifetime is divided into rounds. A round begins with each node entering a volunteering process where it probabilistically chooses whether or not to volunteer to be a starting node. Each node that volunteers sets its backoff timer to a small value. The node then becomes active when its backoff timer expires, and broadcasts a power-on message which contains the location of the node and a random direction (see rule startingNodePowerOn below). When a node receives a power-on message, it checks if its entire coverage area is covered by the surrounding active nodes, in which case the node becomes inactive. Otherwise, the node sets its backoff timer depending on how close the node is to the optimal position. When the backoff timer of a node expires, the node becomes active and broadcasts a power-on message. The network enters the steady state phase when each node is either active or inactive. When a round is over, the density control process starts over again.

We added to the initial state a new construction called analysis message to compute the appropriate performance metric of the state at the end of each round. Timed rewriting could then simulate the OGDC algorithm with several hundred sensor nodes and could measure all performance metrics measured by the OGDC developers using ns-2. In our simulations, we generally got a larger number of active nodes than reported in [24]. A plausible explanation is given in [23] and essentially means that, in the OGDC algorithm, more nodes will become active if transmission delays are taken into account in the simulation (as was done in our case) than if such

delays are ignored, which may have been the case in the simulations in [24]. Since transmission delays play a significant role in the definition of the OGDC algorithm, they should be taken into account in simulations. Therefore, our formal model may provide a more appropriate simulation setting for OGDC than ns-2 with the wireless extension.

The previous sections show the expressive power and generality of the Real-Time Maude formalism. The price to pay for such expressiveness is that Real-Time Maude analyses are in general incomplete 7 for dense time, because all moments in time cannot be visited. For discrete time, completeness can be achieved by exhaustively visiting all time instants. This makes breadth-first search for violation of an invari- ant a complete semi-decision procedure. Furthermore, time-bounded LTL model checking of systems in which only a finite set of states can be reached within a certain time becomes a complete decision procedure. However, visiting all discrete times typically leads to a state space explosion that renders many formal analyses unfeasible.

