Then, we investigate the rewrite relation over a particular class of term-graphs called admissible. An admissible term-graph is a term-graph whose cycles do not include defined functions. We give a sufficient (syntactic) condition which ensures that the set of admissible graphs is closed under rewriting and we show the con- fluence of admissible graph rewriting relation, even in the presence of collapsing rules.

The confluence of a rewrite relation allows one to evaluate expressions in a deterministic and efficient way by using rewrite strategies. Such strategies have been well investigated in the setting of finite and infinite orthogonal TRSs (e.g., [22,16,18]). In [1], a strategy that computes outermost needed redexes based on definitional trees has been designed in the framework of orthogonal constructor- based TRSs. We show how definitional trees can be useful to design an efficient strategy in presence of orthogonal constructor-based tGRSs. We particularly state that the resulting strategy is c-hyper-normalizing on the class of admissible graphs and develops shortest derivations.

This extended abstract is organized as follows. In the following section, we revisit the definition of term-graph rewrite systems. Section 3 introduces the class of admissible term-graphs and state the confluence property for admissible tGRSs. An efficient rewrite strategy is presented in Section 4. Concluding remarks are given

Example 2.5 Let G = n : f (m1, m2, m3).  Let H1 = m1 : h(m1)[G].  Then H1 = n : f (m1 : h(m1), m2, m3). Let H2 = n  2 m1[H1]. Then H2 = n : f (m1 : h(m1), m1, m3). Let H3 = m1   m3[H2]. Then H3 = n : f (m3, m3, m3)+m1 : h(m3).

Computing with general cyclic term-graphs is not such an easy task even in presence of orthogonal rewrite systems. In this section we introduce the class of admissible term-graphs [9] for which confluence results can be stated and efficient strategies can be designed. This class is inspired from the imperative style of programming where defined procedures and functions operate over data-structures built using particular constructors such as records, pointers etc. and where cyclic expressions such as n : fact(n), n : tail(n) or n : +(n, n) are meaningless.

Remark :  The notions of outermost node and outermost redex are well-defined in the framework of admissible graphs : if p and q are two nodes of an admissible graph labeled with defined operations and such that there exists a path from p to q (i.e., p is outer than q), then, by definition of admissible graphs, there is no path from q to p.

[1] and are defined below. Nevertheless, our definition is a bit different from the original one proposed in [1] or those used in the context of graph rewriting [3,9,10]. The main difference comes from the use of branch nodes. We actually introduce the possibility to have some sharing in the left-hand sides of the rules. For that purpose, we distinguish in the definition below between position.branch and share.branch nodes of a definitional tree. position.branch corresponds to the branch nodes in [1] whereas share.branch gives another possibility to specialize patterns according to their topological shapes.

Our strategy has been successfully extended to parallel rewriting in presence of weakly orthogonal rewrite systems [10]. Its has also been extended in order to develop needed narrowing steps [11,9]. Recently, the framework presented in this paper has been extended in order to deal with non deterministic functions in declarative (functional and logic) languages [3,2]. We are currently investigating new extensions of the presented strategy in a more general setting like term-graphs with priority [12].

