A rewrite logic semantic definitional framework for programming languages is introduced, called K, to- gether with partially automated translations of K language definitions into rewriting logic and into C. The framework is exemplified by defining SILF, a simple imperative language with functions. The translation of K definitions into rewriting logic enables the use of the various analysis tools developed for rewrite logic specifications, while the translation into C allows for very efficient interpreters. A suite of tests show the performance of interpreters compiled from K definitions.

The K language definition framework [9] is a rewrite logic based framework for specifying programming languages. It includes both a notation, the K-notation, consisting of a series of domain-specific syntactic-sugar conventions aiming at sim- plifying and enhancing readability of language definitions, and a language definition technique, the K-technique, based on a first-order representation of continuations. As part of our ongoing research, we are developing a number of tools around K to assist in defining and analyzing programming languages.

Here, we show two pieces of this work. First, we show the semantics of a simple programming language with functions defined using K. This language has standard imperative features, including a controlled jump in the form of a function return. Second, we provide some details of a translation from our notation in K to an

Here we briefly recall the K-framework [9], useful to compactly, modularly and intuitively define languages in rewrite logic. It consists of the K-notation, i.e., a series of notational conventions for matching modulo axioms, for eliding unnecessary variables, for sort inference, and for context transformers, and of the K-technique, which is a continuation-based technique to define languages algebraically. The K- framework is described in detail in [9].

Context Transformers are the most subtle aspect of the K notation, based on the observation that, in programming language definitions, it is always the case that the state of the program does not change its significant structure during the execution of the program. For example, the store will always stay at the same level in the state structure, typically at the top level. If certain state infrastructure is known to stay unchanged during the evaluation of any program, and if one is interested in certain attributes that can be unambiguously located in that state infrastructure, then we only mention those attributes as part of the context assuming that the remaining part of the context can be generated automatically (statically). Since SILF does not have threads, exceptions or other complex control sensitive language features, context transformers do not make a difference in this paper, so we do not discuss them in more detail. The reader interested in the role of context transformers in compactness and modularity of language definitions is referred to [9].

In words, this rule states that, to apply the function with identifier I to a (possibly empty) list of values, we need to replace the apply continuation item and the con- tinuation K with the continuation K' associated with the function I in the function environment, put K and environment Env on a stack, and replace Env with the global environment GEnv, which will give us access to global names while hiding names declared in the calling context. We make use of many of the conventions we discussed in this section within this rule. For instance, the values are unnamed since we do not use them at this point. Also, since the stack is an associative list, we are adding something to the head of the list by replacing the identity on the left with the item we are stacking, a tuple. The function environment is a set, so we match against the function name to get the proper tuple in the set without the need to specify the rest of the set. We need only mark those parts of the state that are changing by putting the changes under what is being changed; the parts of the state that remain the same need no further notation.

Functions. Function semantics cover three main constructs: function declaration, function invocation, and function return. We cover each below in turn. We first need to add the declared functions into the function environment. We do assume that function names are distinct and that declarations all occur at the start of the function. We add the necessary structure to the function body to bind the input values to the formal parameters, so we do not need to add this in the invocation semantics (the semantics of bind will be given shortly):

State Helper Operations. Many of the rules in the SILF semantics perform similar changes to the state. We have abstracted these changes into a number of rules which can then be used across different parts of the semantics. The operation bind creates new bindings in the environment. This operation binds a list of values

Arithmetic, Relational, and Logical Operations. All three operation types follow the same general pattern. When we encounter an addition expression, e.g., we first need to evaluate both operands. We also need to keep track of what operation we are performing. So, we will replace an expression such as E + E' with one were we evaluate E and E' and put + on the continuation to remind ourselves what we need to do with the results. Once we get back the values from evaluating the two expressions (here, expected to both be integers) on top of a +, we return their sum (using integer addition):

In this paper we introduced the K language definition framework and used it to define a simple imperative language with functions. We also showed an example of translating this definition into an interpreter in C. Based on current encouraging results, we believe this is a promising strategy for automatically deriving interpreters from definitions of language semantics.

There is much future work yet to do. We are still looking for ways to improve K as we gain more experience using it to define languages. We are also continuing work on automatically generating interpreters in rewriting logic and C from K definitions, which is currently a mix of manual and automated processes. We believe there is no reason this cannot be done in a fully automatic fashion. Along with this, we are looking for ways to more closely define both the syntax and semantics of languages, to allow for the automatic generation of language parsers and other static tools which process program text using rules we have defined in K.

Note that these operations are not short-circuit, since we evaluate both operands to and and or at once. We could make them short-circuit by instead evaluating only the first operand, and storing the second with the continuation for the operator. Based on the result of evaluating the first operand, we could then either return the proper value or evaluate the second operand to give us the value of the operation.

