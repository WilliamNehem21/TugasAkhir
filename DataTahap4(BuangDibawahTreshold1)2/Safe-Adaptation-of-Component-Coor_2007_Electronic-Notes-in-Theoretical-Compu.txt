In the domain of software engineering, the use of software components is now a well established approach. However, it raises problems about the dynamic adaptation of these components to particular users demands. Indeed, these components have been developed with the intent to have a wide range of use, and so they implement functionalities which perhaps do not match precisely enough the demands of specific users.

Therefore, we address the adaptation of the coordination between components by means of so-called Mod- erators. A Moderator is itself a coordination component managing interactions that are described and formalized using Petri nets. More precisely, we study the dynamic adaptation of the coordination rules by means of specific transformations of the Petri nets used to describe a Moderator.

Software reuse is an old and essential concern in the field of software engineering. In this search, the notions of interface and modularity have progressively emerged, leading to the current notion of software component [9,11]. Composing, assembling components is the core of software architectures. Component models are based on two key features:

assembling preexisting components. This assembly is made possible by using and maintaining invariant relationships between the assembled components. The notion of interface thus allows to abstract and encapsulate the implementation of compo- nents. The adaptation of coordination (and our approach in particular) extends this process by aiming at enabling to alter the actual behavior of a set of coordinated components, while keeping invariant the contract (the specification of the coordi- nation) that binds these components altogether. More precisely, a participant may ask the Moderator of a conversation to depart from the (preset) behavioral rules of the protocol, in order to adapt to a specific runtime context. To be safe, such an adaptation should guarantee each participant taking part to the conversation that the goal of the conversation can be reached.

In the following sections, we first describe the functionalities and the proper- ties of coordination components. Then, we define adaptations, the safety property related to these adaptations and how it can be proved. Lastly, we illustrate this adaptation approach through an e-learning case study.

Protocols are intended to ensure coordination between entities of a system. A protocol is defined as a set of rules, and it is instantiated as processes, that we call conversations, in the course of which entities follow these rules to coordinate their respective behaviors. These rules determine which participants may take part in a conversation, and how each one can or must contribute to its good processing. In other words, a conversation is a process which proceeds according to a protocol defined by the following items [10]:

The main benefit of coordination by protocols is to ensure the efficiency and the predictability of interactions among participants with regard to the achievement of some task. However, whatever the rules of a protocol, each participant must be sure that they will be respected by others participants; otherwise, there is no guarantee that the common objectives of the protocol will be reached. This can be achieved by dissociating on the one hand the interventions in a conversation that are performed by the participants, and on the other hand checking whether these interventions obey to the protocol rules, which is performed by a specific component called the Moderator of the conversation [10]. The Moderator is in charge of enforcing the protocol rules by making the participants in the physical impossibility to contravene the rules of the protocol [7]. More precisely, a Moderator:

To implement the behavioral constraints of a protocol it is proposed in [10] to model the control structure of Moderators by means of the Petri net formalism [13]. The Petri net (in short PN) of a Moderator includes communication places: input places to receive the messages sent to the Moderator by the participants, together with output places for the messages from the Moderator to the participants. The initial marking of this net corresponds to the initial state of any conversation of the protocol and its terminal (deadlocking) marking corresponds to the final state.

The basic scenario is the following: customers order goods from the web- site (which is implemented by the Moderator), and then send their payment to the website. Lastly, they acknowledge the receipt of their goods to the website. The Moderator forwards the orders and the payments that it receives to the ven- dors, and records the acknowledgments. Vendors accept orders (received from the

Moderator), send goods, and then collect payments 3. The behavior of vendors and customers is described by finite automata: a Vendor only receives messages and a Customer only sends messages. This PN includes 5 communication places (order vm, payment vm, order cm, payment cm and ack cm) that correspond to the types of messages exchanged between the Moderator and the participants.

A High Level Petri net formalism is used, in order to process data carried by tokens [17]. Notably, each message-token in a communication place includes the identity of the participant that has sent or shall receive this token. In this way, the Moderator is able to manage a dedicated thread of control for each participant and to keep track of its state with regard to the conversation.

Using the PN formalism to define the behavioral rules of a protocol allows to use techniques and tools of the PN theory to analyze behavioral properties. We do not elaborate on other aspects of Moderators (e.g. the management of data, of sessions, of threads of control, or granting roles to participants) since we are only concerned here by their behaviors.

We also assume that the IPN of a protocol is a bounded Petri net, that is there is an upper bound to the number of tokens in any marking that is reachable from the initial marking. This constraint does not prevent a component from sending any number of messages, but it entails that the Moderator can only process a finite number of these messages simultaneously. It also implies that we do not consider protocols that could coordinate simultaneously an unbounded number of components.

Firstly, we define adaptations more precisely, in this setting. Then, we consider the properties that adaptations should meet in order to keep the conversation con- sistent with respect to the initial coordination rules. Lastly, we outline how these dynamic adaptations can be managed and implemented.

The notion of safety can be related to the more general concept of conformance (i.e. substitutability with respect to simulation and stuck-freeness) in labelled tran- sition systems [15] in the following sense: an adaptation of a coordination protocol is safe if the whole adapted system (i.e. the adapted Moderator plus the partici- pants) conforms to the non-adapted system. In other words, safety appears as a special case of conformance, aiming at characterizing conformant adaptations that are local to a specfiic component, namely the Moderator.

Access document checking is performed by the ECS. To this end, the workstation of each student informs the ECS of any document access (transition T 6, or transition T 11 if the student has already received a warning). The ECS then checks whether this document belongs to the list of documents authorized for the student (transition T 5, or T 12). If the document is authorized, transition T 31 (or T 32) occurs. If it is not the case, the system informs the assistant that supervises the examination (transition T 7, or T 16).

The verification of the safety of an adaptation involves a cost insofar as a vali- dation must be run onto the PN. This validation is grounded on an exhaustive system state space exploration, and its limits, in general, are those of model check- ing. The validation of the safety of an adaptation can though benefit from works on conformance checking [15]. This can lead to constrain the PN modifications so that this analysis remains scalable according to the PN size.

