Mobility seems to be a fundamental aspect for global computing, however it gives rise to a lot of relevant security problems. We address the problem of protect- ing hosts from attacks or misbehavior of mobile processes. We propose to move process abstractions, i.e. process parameterized with respect to the operations hav- ing a local meaning, instead of processes ready-to-run or active processes (agents). Moreover, we exploit global values and types to ensure that operations having a local meaning are used only locally. Our approach is general and could be applied to every language/system for programming and coordinating network services that permits remote communications with transmission of code fragments. We illustrate our approach by using the Klaim language, where the network services are codi ed by means of tuples inside network service repositories, as, e.g., in SUN JavaSpace and IBM TSpace.

In global computing, process mobility seems to be a fundamental aspect, how- ever it gives rise to a lot of relevant security problems. For instance, mobile processes threaten host machines with theft or misuse of system resources (e.g. information, money, cpu time, disk space, bandwidth). This may degrade the performance of hosts or compromise their security and reputation. Recipro- cally, host machines threaten mobile processes with theft of resources (e.g. information) and reputation (e.g. the host may implant its own tasks into the

In this paper, we address the problem of protecting hosts from attacks or misbehavior of mobile processes. To overcome this problem, di erent so- lutions have been proposed in the literature that are based on, e.g., type systems [4,13,20,8,9], information ow analysis [12,3,14] and proof carrying code [19]. To have a ne-grain control over the behavior of mobile processes and to directly program and manage security policies, we propose to move process abstractions, i.e. process code which abstracts from local operations, instead of processes ready-to-run or active processes. To complete a migra- tion, a communication between the source and the target hosts must rst take place. Then, the target host can instantiate the received process abstraction, by de ning all potentially dangerous operations, and can wrap the resulting process within a customized environment that takes care of process execu- tion. In other words, depending on the trustness of the code received, the local operations over which the code is abstracted may be instantiated with implementations of local operations at the right security level thus avoiding undesired accesses to local resources.

The Klaim programming paradigm identi es processes as the primary units of computation, and nets, i.e. collections of nodes, as the coordinators of process activities. Each node has an address, called locality, and consists of a process component and a tuple space component. Processes are distributed over nodes and asynchronously communicate via tuple spaces. Klaim pro- cesses may perform three di erent kinds of basic operations: accessing (possi- bly remote) tuple spaces, sending (possibly remotely) processes for execution and creating new nodes. In particular, mobility can be performed in two dif- ferent ways. The (asynchronous) migration primitive eval allows a process to autonomously move to another node that has no control over the incoming mobile process. In addition, processes can be exchanged in communications by using the primitives out and in/read.  This fosters synchronous mobil-

In this paper, we introduce HotKlaim (for Higher-order typed Klaim), a variant of Klaim that does not provide the eval primitive while provides a kind of data which can embody a process, namely process abstraction. Process abstraction is useful for parameterization with respect to local operations. To express process abstractions in HotKlaim the full power of system F [10] is needed, while 2-types, similar to those in 2 [6], are used to classify global values that can freely move over the network.

In HotKlaim there are two kinds of types (and terms), global- and local- types (terms), classi ed by g and l respectively. Contexts declare the kind of type- and term-variables. L is the global-type of localities, and P is the local- type of processes. A global-type does not contain P nor free type variables declared local. A global-term, in addition, does not contain local operations o, nor free term variables declared local.

Code is the type of process code abstracted over the local type P and the local operations in O. Its de nition mimics that given in [17,18] for monadic code. When a global value of type Code has been read, it can be turned into a process by applying it to the local type P and the tuple (ojo 2 O) of local operations.

Lemma 4.1 (Basic properties) A value v 2 V cannot be of the form E[r]. For any e 2 E there is at most one E 2 EC and one r 2 R s.t. e  E[r], moreover FV(r)  FV(e).

gatherer is the mobile code for searching. Its parameters are: the locality res where the result of the search must be placed, the search key item, and an authorization key k used to check the permission to perform local operations. Since gatherer is mobile code of type MC), it is abstracted with respect to customized versions (which take a key as parameter) of the communication operations. gatherer looks for one of two alternative tuples. The rst one contains the wanted information associated to item (e.g. the price); if it is found, then the result of the search is added to the tuple space at res and the process terminates. The second tuple contains the address l of the node where the search has to be repeated; if it is found, then a tuple containing the process abstraction gatherer(res, item, k) is added to the tuple space at l for searching there.

execute is the process that acts as the guardian of nodes. It is parameter- ized with respect to its locality self, an authorization function safe that, on the basis of an authorization key, checks if code can be considered reliable (and thus may not be constrained), and an authorization function allow, on the basis of an authorization key and of a location, check if code can be allowed to perform a communication operation at that location. execute takes care of taking a process abstraction (i.e. a tuple with just one eld of type MC) from the local tuple space, specializing and instantiating the abstraction and then executing the resulting process. in' and out' are the customized versions of the communication operations with which mobile code is specialized; they make use of the two authorization functions safe and allow.

In [23,24] a process language, named D , is considered that results from the integration of the call-by-value -calculus and the -calculus, together with primitives for process distribution and remote process creation. Di er- ently from HotKlaim, communication is channel based and processes can- not explicitly refer localities (indeed, these are anonymous). D permits the transmission of process abstractions parameterized with respect to resource (i.e. channel) names.

More speci cally, in [23], a type system for D  is de ned that ensures that at any one time all the processes that intend to perform inputs at a given channel are co-located. To this aim, a value is deemed sendable whenever its exportation does not violate locality of channels. Although the type system has a di erent  avor from that of HotKlaim, sendable values and types play a role similar to our global values and types.

In [24], a ne-grain type system for D  is de ned that permits controlling the e ect of transmitted process abstractions on local resources (i.e. channels). Di erently from HotKlaim, processes are assigned ne-grain types that, like interfaces, record the resources to which processes have access together with the corresponding capabilities, and process abstractions are assigned depen- dent functional types that abstract from channel names and types. Although process abstractions have not polymorphic types as in HotKlaim, channel names may appear and be bound both in terms and in types and thus, in some sense, play the role of type variables.

In [15] a higher-order functional language, named Con ned- , is presented that supports distributed computing by allowing expressions at di erent local- ities to communicate via channels. In Con ned- , authors of code can assign regions (i.e. subsystems) to values in order to limit the part of a system where a value can freely move. Then, a type system is de ned that guarantees that each value can roam only within the corresponding region. Di erently from HotKlaim, communication is channel based, the transmissible process ab- stractions can be parameterized with respect channel names, and the types of

