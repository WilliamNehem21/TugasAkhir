In this work we present Dinapter 4 , a tool for the automatic generation of speci- fications for behavioral adapters (adapters which overcome incompatibilities at sig- nature and behavioral levels). Dinapter accepts as input the behavioral interfaces of the components written in abstract BPEL [1] and it returns adapter specifications which describe how the mismatches (in signature and behavior) can be resolved. These specifications are used by other proposals [7,11] to generate the final adapter.

In the following section (Section 2) we will present an example to illustrate how Dinapter works. In Section 3 we will explain the parameters of our tool along with several results obtained. We will comment on related work in Section 4. Finally, we will present future work and some conclusions in Section 5.

Dinapter accepts as input the behavioral description of the two components to adapt written in abstract BPEL [1] and returns a set of adapter specifications. Internally, the tool uses a combination of an A* algorithm and an expert system. The heuris- tic function used by the A* algorithm and the expert system rules represent the adaptation policy used to generate the adapter specifications.

The integration within ITACA has enhanced Dinapter by providing it with more information about the similarities between the components to adapt. A compar- ison of the semantics behind the operations to adapt is provided by another tool (Sim) which uses WordNet::Similarity [14]. The inclusion of this semantic informa- tion in Dinapter enhances the matching of name-mismatch situations, improves the adaptation of event driven conditions (PICKs) by taking into account the underly- ing semantics, and it reduces the number of search steps needed to find a correct specification.

Moser et al. [12] developed a platform (VieDAME) based on ActiveBPEL for the monitoring and service adaptation of BPEL processes. They dynamically replace services based on QoS in a non-intrusive manner using aspect oriented program- ming. They use Transformers for service adaptation but these transformers must be designed manually. Their work can be complemented by our tool by automati- cally generating these transformers.

As regards automatic generation of adaptation specification, Schmidt and Reuss- ner [15] focused on the synchronization of two components accessing, or being ac- cessed, by a third one. They introduced an algorithm based on synchronous product computation to solve missing message incompatibilities, but their approach fails to overcome signature mismatches and behavioral incompatibilities like missing mes- sages or message splitting / merging. Autili et al. [3] proposed a methodology for

the automatic synthesis of adapters considering as input behavioral descriptions of components and a specification of the interactions that must be enforced in the sys- tem. Then, their tool (Synthesis) generates composition code that exhibits only the specified interactions, and prunes those which lead to deadlocks. Similarly to [15], Synthesis does not overcome name mismatches, and some behavioral incompatibil- ities cannot be solved, such as message splitting / merging. In addition, their tool relies on a high-level description of the composition goal, and therefore does not work without such description.

Let us now mention two related works [6,13] that tackled Web services adap- tation. In the first one, Brogi and Popescu [6] outline a methodology for the au- tomated generation of adapters capable of solving behavioral mismatches between BPEL processes. In their adaptation methodology they use the YAWL workflow as an intermediate language. Once the adapter workflow is generated, they use lock analysis techniques to check if a full adapter has been generated or only a partial one (some interaction scenarios cannot be resolved). They solve message reordering incompatibilities but their approach fails with signature mismatches. In addition, even if we applied our approach to BPEL services as well, our approach is able to work with abstract descriptions of components/services that can be extracted from abstract BPEL but, due to its integration within ITACA, it also accepts other languages and platforms like Symbolic Transition Systems and Windows Workflows.

Motahari Nezhad et al. [13] presented a schema matching tool called COMA++ [2] for assisting the developer to adapt new versions of existing Web ser- vices based on the services WSDL signatures. Dinapter has some similarities with their work (the heuristic used by our tool plays a similar role to their evidences) and they introduce some interesting ideas about deadlock handling. However, although they are able to generate a mismatch tree that gather all protocol mismatches, its resolution is not automatic.

In this work, we have presented a tool for the automatic generation of adapter specifications which overcomes signature and behavioral mismatches. The gener- ated specifications successfully solve missing messages and they are able to merge and split messages depending on their arguments. There are several works in the literature [4,8,16] which use these specifications to automatically build behavioral adapters. Traditionally, these specifications were manually written and they re- quired the designer to fully understand the details of the components involved. Our tool complements this previous work by automatically generating these specifica- tions.

Dinapter tackles behavioral and syntactic mismatches using a heuristic function, so it can still be misinformed by deceptive components where the behavior, argu- ments and operation names guide the generation process to a deadlock-free, yet invalid specification. However, we are currently working on including Linear Tem- poral Logic (LTL) formulas in the expert system. In this way, Dinapter will give us the option to further refine the specifications using both customized expert system rules and LTL properties.

