This paper addresses the problem of model-based off-line selection of test cases for testing the conformance of a black-box implementation with respect to a specification, in the context of reactive systems. Efficient solutions to this problem have been proposed for LTS finite-state models, based on the ioco conformance testing theory. In this paper, the approach is extended for infinite-state specifications, modelled as automata extended with variables. When considering the selection of test cases according to test purposes (abstract

Many aspects of software can be tested to assess its correctness e.g., functionality, performance, timing, robustness, etc. Among these, the focus of this paper is on conformance testing of reactive systems. This consists in checking that a black-box implementation of a system, only known by its interactions with the environment through an interface, behaves correctly with respect to its specification. This relies on experimenting the system with test cases, with the objective of detecting some faults, or to improve the confidence one may have in the implementation.

Automatization of some parts of the testing activity, using models of software and formal methods is a way to improve the quality and cost of testing. For more than a decade, model-based testing (see e.g., [5]) advocates the use of formal models and methods to formalize this activity. The formalization relies on models of testing artifacts, relations between them including conformance, and properties they satisfy. For reactive systems, behavioral models are used for specifications, and serve both

as a basis for test generation, and as an oracle for the assignment of verdicts in test cases. Testing theories based on finite-state models such as automata (see e.g., the survey [19]), or labelled transition systems (see e.g., [25]) are now well understood, and gave rise to automatic test generation algorithms and tools like TorX [2], TGV [14], Gotcha [3] among others, have been developed and successfully used on industrial-size systems.

Some developments are still necessary to improve the automation of test gen- eration. In particular more powerful models taking into account some aspects of complex software must be considered such as data, time, etc. In this paper we fo- cus on data, and models called Input/Output Symbolic Transition Systems (ioSTS) are considered. These are automata extended with variables, with distinguished input and output actions, and corresponding to reactive programs without recur-

implementation in those of the specification, can be reused. The difficulty is in the selection of test cases. Test cases are programs with variables, directly built from the ioSTS model rather than from the enumerated ioLTS semantic model. This construction relies on syntactical transformations of the specification model, guided by an approximate analysis. The models and principles of the test selection algo- rithms are illustrated by a simple example of a lift controller. The test selection algorithms described in this paper are implemented in the STG tool [16] (see http:

Some are based on symbolic execution [4,13] and/or constraint resolution: the DART tool [11] combines symbolic execution with random testing and constraint solving, the PET tool [12] uses constraint solving to produce test cases as solu- tions to path conditions produced from a specification and a property, the Agatha tool [10] uses symbolic execution on a variation of the ioSTS model, the Gatel [23] and BZ-TT [20] tools rely on constraint solving. In [21] the authors use selection hypotheses combined with unfolding for algebraic data types and predicate resolu- tion to produce test cases. Compared to our approach, these approaches are limited to deterministic systems, and consider finite unfoldings of systems by limiting the search depth in order to cope with loops, but they may produce precise test cases. Nevertheless, these are complementary methods: test selection with test purposes using approximate analyses can be seen as a front-end used to select an abstract test case, where information on non-conformance is preserved.  Then constraint

In this section, a model of reactive systems, called ioSTS for Input/Output Sym- bolic Transition Systems, is proposed which will serve for specifications, test cases and test purposes. This model is a kind of extended automata model, inspired by I/O automata [22]. It is made of a set of variables (including one encoding control locations) which encode the state of the system, and transitions with guards, input and output actions with communication parameters and assignments of variables to expressions.

variables are standard variables defining the state of the system itself, while external variables are used to observe the state of another system (thus modified by this other system). As will be seen, this allows to use the same model for specifications and test purposes. It is assumed that guards are expressed in a theory in which satisfiability is decidable. We will come back later to the hypothesis of satisfiability of guards, which will be important during test execution.

When testing for conformance, one is interested in comparing the observable behavior, thus traces of the implementation with the ones of the specification. Ad- ditionally, one can also observe quiescences of the implementation, and check that they are allowed by the specification. A quiescence occurs when no output is fire- able: the system is blocked unless the environment provides an input. A particular case is a deadlock, i.e., when additionally no input is fireable. As quiescence is not preserved by determinization (the same trace can lead to a quiescent and a non-

test case. In some sense, this is the idea used in the TorX tool [2] for on-line test- ing for ioLTS models: the tool either non-deterministically chooses an input of the canonical tester to feed the implementation or checks that the outputs produced by the implementation does not reach Fail in the canonical tester, or stops by giving a Pass verdict. Traces of these executions form sound test cases, but exhaustiveness is in general lost when considering finite executions.

In off-line test selection, one renounces to exhaustiveness and selects test cases among all possible sound ones. The non-deterministic algorithm of [25] can then be understood as the production of a test case by an unfolding of the canonical tester. As will be seen later, one can also use test purposes to select test cases that focus on some particular behaviors. In both cases, even if exhaustiveness is lost by any finite set of test cases, one can still prove that the (inifnite) set of all test cases that could be produced is exhaustive. which guarantees that for any non-conformant implementation, there is a possibility to detect it by one test case produced by the algorithm.

The test selection algorithm proposed in this paper is based on the notion of test purpose. In practice, a test purpose attached to a test case specifies the intention of the test case. The formalization of a test purpose by an ioSTS observer allows to specify abstract behaviors one is interested to test.

Apart soundness and exhaustiveness which relate Fail verdicts to conformance, other properties related to verdicts Pass and Inconc are also of importance as they relate test cases to the selection means, namely test purposes. It can be proved that Pass verdicts are always exact: a Pass is always emitted when the current trace is accepted by the test purpose. The only verdict where the over-approximation may cause a lost in precision is Inconc. In fact, it may be the case that some traces of 7C are not anymore a prefix of an accepted trace, but is not detected as such. It will either be detected by continuation of the trace, or will loop. It is easy to see that the precision of the approximation directly influences the ability of test cases to emit Inconc verdicts accurately. For the reader familiar with structural testing, the problem of detecting Inconc verdicts is similar to the classical problem of the undecidability of the feasability of a path in structural testing, which is known to be undecidable.

of parameters values should be done by constraint solving. An input is fireable only if it is sent by the implementation under test. The tester then has to check, according to the current value of variables and the value of the input parameters, which guard is satisfiable among transitions carrying this input. As the test case is input-complete in any state with no verdict, exactly one transition is fireable.

This paper proposes an approach to the off-line selection of test cases from speci- fication models with control and data (ioSTS) using test purposes. This technique avoids the state explosion problem due to the enumeration of data values and pro- duces test cases on the form of programs. Test selection reduces to syntactical opera- tions on these models and relies on an over-approximate analysis of the co-reachable states to a target location. During execution of test cases on the implementation, constraint solving is used to choose output data values. For simplicity, the theory exposed in this paper is restricted to deterministic specifications. However, non- determnistic specifications can be taken into account with some restrictions [18].

In our perspectives of this work, more powerful models of systems with features such as time, recursion and concurrency should be considered. A similar approach has been developed for stack automata modeling recursive programs and test pur- poses specified as automata [7]. In this case, the analyses are exact, but cannot be fully used if test cases cannot observe their own stack, thus also inducing an approximation. For test generation, one problem to address in these models is par- tial observability, which, as for ioSTS, entails the identification of determinizable sub-classes corresponding to applications.

Other challenges are the combination of these techniques with coverage-based test selection. One direction should be to use the dynamic partitioning facility provided by the tool Nbac used by STG as an aid for test selection with respect to coverage criteria with a deeper semantic meaning. More generally, conformance testing appeals for more semantic based coverage criteria.

