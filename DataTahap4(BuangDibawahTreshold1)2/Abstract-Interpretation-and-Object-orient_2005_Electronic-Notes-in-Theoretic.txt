(see the electronic version with extended bibliography of [14]), the amazingly rich suite of problems and solutions that fit in the abstract interpretation setting is often dependent both on the specific programming language and on the given property to be analyzed (that might also be language dependent). Since abstract interpretation has a very semantic-based character, it is not surprising that language paradigms with strong semantic foundations, e.g. functional and logic programming, have been in the past a very fertile test bed for the development of sophisticated abstract domains and specialized fix- point algorithms. On the other hand, when looking at the contributions in the area of object-oriented programming, the picture is somehow still fragmented, and this may overshadow the great potentialities of abstract interpretation on the mainstream programming platforms where the OO paradigm is getting a leader position.

Several class analyses have been proposed in the literature, which consider different values for the ratio precision/cost. For instance, the seminal work by Palsberg and Schwartzbach, [37], presents a very precise, but also expen- sive, analysis for untyped object-oriented languages. These results have been improved by the same authors, [36], as well as by others, [4,18,15,45], which consider fast, but also imprecise, class analyses for the removal of virtual func- tion calls in C++.

Class invariants represent the basis of good software engineering of object- oriented programs, [33]. A class invariant is a property of a class valid before and after the execution of any method of the class. It can be characterized as an abstraction of the trace semantics, where just the states corresponding to the entry points and exit points of method invocations of instances of a class are retained, [30,29].

a given abstract domain is a domain that captures all the properties captured by the refined domain plus some others (specific to the refinement). On the other hand, the extension of a given base class is a class that inherits all the behaviors of the ancestor, plus some others (consider, e.g., the classical 2DPoints and 3DPoints classes, [12]).

