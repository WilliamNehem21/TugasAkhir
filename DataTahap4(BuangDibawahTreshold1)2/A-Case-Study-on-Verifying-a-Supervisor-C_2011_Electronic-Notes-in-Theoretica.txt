In this paper we present a work in progress on the formal verification of a process supervisor using the McErlang model checker. The process supervisor is an alternative implementation of the standard supervisor behaviour of Erlang/OTP. This implementation, currently employed at the company LambdaStream, was checked against several safety and liveness properties.

Writing correct concurrent software is a difficult task given the inherit non- deterministic behaviour of such systems. Concurrent declarative languages seem to be an interesting and practical choice for implementing concurrent software due to the absence of side-effects (or at least a reduced number of them). For example, the concurrent functional language Erlang [5] is being used by several companies worldwide to implement complex concurrent control systems.

The remainder of this paper is organized as follows. A brief introduction to Erlang and McErlang is provided in Section 2. The description of the process supervisor component is given in Section 3 together with a brief description of the properties we have considered. The implementation of such properties and the experimental results of checking them with McErlang is explained in Section 4. Finally, some conclusions and lines of future work are discussed in Section 5.

Fault-tolerance in Erlang is achieved by linking processes together in order to detect and possibly recover from abnormal process termination. Abnormal termination occurs if, for example, a function tries to access the tail of an empty list. Processes linked to the process that terminated abnormally are notified of the termination, and can thus take corrective action, i.e., possibly restarting the failed process. Process links are always bidirectional but the treatment of process termination notifications may differ between the two parties.

Handling a large number of processes easily turns into an unmanageable task, and therefore Erlang programmers mostly work with higher-level lan- guage components provided by libraries. The OTP (Open Telecom Platform) component library [12] is by far the most widely used library, offering several behaviours (design patterns in Erlang) that can be instantiated with con- crete callback functions. For example, OTP behaviours include, among oth- ers, generic servers (for client-server communication), finite state machines, or a supervisor component for structuring fault-tolerant systems hierarchi- cally, where a parent supervisor is responsible for supervising and managing its children (work processes).

McErlang [7] is a tool for model checking Erlang programs. The input to McErlang is the Erlang program we want to verify together with the property of interest. The fact that the program is the model facilitates the use in real-world development.

In order to use Erlang programs as models, McErlang undergoes a source- to-source transformation to prepare the program for running under the model checker. Then, the actual Erlang compiler translates the program to Erlang byte code. Finally the program runs under the McErlang run-time system, under the control of a verification algorithm, using the regular Erlang byte- code interpreter. The pure computation part of the code (i.e, code with no side effects) and memory management (including garbage collection), is carried out by the normal Erlang run time system. However, the side effect part is executed under the McErlang run-time system, which is a complete rewrite in Erlang of the basic process creating, scheduling, communication and fault-

Create the model. Use the Erlang program directly. McErlang pro- vides support for virtually the full language, full data type support, sup- port for general process communication, node semantics (inter-process communication behaves in a subtly different way from intra-process com- munication), fault detection and fault tolerance, and crucially can verify programs written using the high-level OTP Erlang component library used by most Erlang programs.

Formulate correctness properties. Write down the properties to ver- ify as either a safety monitor or a formula in linear temporal logic (LTL). A safety monitor is used to verify safety properties (something bad never happens), by keeping an internal state to check the properties at each state the program to verify reaches. Given a program and a monitor, McErlang runs them in lockstep letting the monitor analyze each new program state generated. If the property does not hold, a counterexample (an execution trace) is generated. Monitors are capable of observing both the shape of the system (e.g., which processes are alive) and significant

There is usually a mechanism to prevent a situation where a process re- peatedly terminates for the same reason, only to be immediately restarted again. This mechanism involves a maximum restart intensity. When a child reaches this restart intensity, the supervisor terminates all the child processes and then itself.

RestartStrategy. When a child process crashes/dies, if its restart strategy is child, only this child will be restarted. If its restart strategy is all, all the children will be stopped in reverse start order, and they will be restarted (including the offending one) in start order.

By reading the nos supervisor documentation we came up with many inter- esting properties to verify for its implementation. As a trivial example, we wanted to check that a child that has terminated is actually restarted by its supervisor. We also focused on properties regarding the different restart inten- sities and the shutdown strategies, checking all combinations of those options. For example, we formulated and checked a property that states that if there is any child specification with the Finally action of the restart intensity set to kill sup and this child reaches the maximum restart intensity, the supervisor applies the Shutdown strategy to its children in reverse start order and then it finishes. In the following section we describe how some of these properties were verified using McErlang.

To verify the nos supervisor described in the previous section using McErlang we follow the approach described in Sec. 2.2, i.e., we create a verifiable model, we formulate a number of correctness properties, and then we generate a set of scenarios.

Obtaining the model for this case-study is straightforward since McErlang can use the actual source code as model. In this section, we explain the only change to the source code of the nos supervisor that was needed to obtain a verifiable model. To measure the restart intensity, the nos supervisor needs to determine the number of restarts that took place within a certain time interval. As McErlang currently implements neither real-time nor discrete-time model checking algorithms we were forced to abstract away from the time interval.

As explained in section 2.2, in McErlang correctness properties can be specified either using a safety monitor, which run in parallel with the system to verify and observe its actions, or as a formula of linear temporal logic. In practice, most of the relevant nos supervisor correctness properties can be expressed as safety monitors.

It is interesting to note the way in which we formulate correctness prop- erties using safety monitors. Instead of specifying them in a temporal logic, what is done is to develop a set of simplified models of the system, and then check whether the behaviour of the real component corresponds to these mod- els. The use of the same language for regular development and for specifying safety monitors eases the adoption of this technique by the developers.

As can be seen, a predicate is a function which receives three arguments. The first is the program state, the second are the actions which triggered the state change, and the third is some private state. If any action is an action corresponding to a process dying (died action), with a Reason different than normal, this means that a child terminated abnormally.

/Erlang [2]). To create this scenarios, a test worker nos test worker has been implemented which only keeps track of its starting time. To simulate process crashes, we enable an option in the McErlang model checker which, non-deterministically, kills any process in any state. We select a subset of the running processes for termination by executing:

As can be seen, the length of the trace which leads to an error is shown, as well as the concrete scenario of the failure. In the program trace given by the debugger, we realized that the kill order was not the proposed in the specification. The debugger also allows us to manually explore the state space to analyze other paths, and help us to locate the error (under which circumstances does this error arise).

The properties of interest were extracted from the component documen- tation, and from informal discussion with the developers of the supervisor component. Most of the properties were formulated as safety monitors, writ- ten in Erlang, which observe the actions of the supervisor component as it manages a set of children, and signaling an error if the supervisor issues an incorrect command. In other words, we have defined a set of simplified mod- els, and check that the real supervisor has the same behaviour as the models (up to the abstraction level of the monitor).

Still obviously there is much room for improvement. The learning curve to be able to use McErlang effectively, and to formulate correctness properties, is currently too steep. In next release of McErlang improvements are planned regarding the usability of the tool, to provide, for example, better information on error causes, guidance in selecting appropriate verification options, and a simplified API for the formulation of correctness properties.

