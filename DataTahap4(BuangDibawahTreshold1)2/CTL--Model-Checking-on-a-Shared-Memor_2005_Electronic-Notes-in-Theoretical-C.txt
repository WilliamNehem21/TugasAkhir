In this paper we present a parallel algorithm for CTL* model checking on a virtual shared-memory high-performance parallel machine architecture. The algorithm is automata-driven and follows a games approach where one player wins if the automaton is empty while the other player wins if the automaton is nonempty. We show how this game can be played in parallel using a dynamic load balancing technique to divide the work across the processors. The practicality and effective speedup of the algorithm is illustrated by performance graphs.

We explored the parallelisation of model checking for shared-memory mul- tiprocessor computers to evaluate its feasibility and identify any inherent dif- ficulties or pitfalls when parallelising model checking for shared memory ar- chitectures. In particular, the parallelisation of explicit-state on-the-fly model checking was investigated for both safety and liveness properties and led to the development of a parallel model checker for CTL*. This research has shown the practicality and effective speedup of model checking using a shared- memory architecture. The performance of the parallel algorithm was evalu- ated via theoretical analysis and also via experimental analysis using a number of prototypical models, including correctness properties of the parallel model checker itself.

In our earlier paper, [14], we proposed a parallel algorithm for reachabil- ity analaysis on a shared-memory architecture. In this paper we present a parallel model checking algorithm for CTL* that uses the dynamic load bal- ancing technique of the parallel reachability analysis algorithm described in [14]. An overview of the parallel reachability analysis algorithm is given in the next section. This is followed by a description of the serial automata-driven game-theoretic algorithm for CTL* and its parallelisation in Sections 3 and 4.

Our parallel reachability analysis algorithm is executed on N processes where each process (thread of control) runs on one physical processor. All N pro- cesses share one store for storing visited states and each process has its own unbounded private stack and bounded shared stack for storing unexpanded states. A process can add states only to its own private and shared stacks, but when its own private and shared stacks are empty it can steal a state, i.e., remove a state from the shared stack of another process.

A run r is accepting if all its infinite paths satisfy the acceptance condi- tion. Note that we can get finite branches in the tree representing the run when either true or false is read in the transition function. In an accepting run only true can be found at the end of a finite branch. Different types of alternating automata have different acceptance conditions. In Hesitant Alter- nating Automata (HAAs) the acceptance condition is a pair of states (G, B) of which the satisfaction depends on the following restriction on the transition

The performance of the parallel algorithm is very good and scales well with an increase in the number of processors. The implementation takes approxi- mately 4 minutes to complete the reachability analysis of a 100 million state graph on one process and approximately twenty seconds on sixteen processes. Model B shows similar behaviour to the experimental results of the imple- mented algorithm if its idle overhead is changed to model a scenario where a process that wants to steal a state has to wait for only one other process to complete a single access to the shared stack before it gains access to it.

