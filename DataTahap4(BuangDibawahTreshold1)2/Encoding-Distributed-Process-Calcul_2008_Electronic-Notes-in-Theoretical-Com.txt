The most prominent similarity between the ambient calculus and LMNtal is that both feature membranes that can be nested. This suggests that any natural encod- ing from the ambient calculus to LMNtal should map ambients into LMNtal cells, and we regard this as the boundary condition in designing our encoding. Henceforth cells representing ambients are referred to as ambient cells.

Next, we define the normal form of a name tree. Intuitively, a name tree in a normal form should accord with the underlying ambient hierarchy. Let us make this more precise. First, note that an ambient hierarchy forms a tree structure that will be referred to as an ambient tree. A name tree in a normal form must have a root cell at the uppermost node of some connected subgraph of the ambient tree 3 , and a proxy cell at each of other nodes of the above connected subgraph.

Rules whose names start with proxy_ are to reestablish the normal-form con- ditions of a name tree structure when the set of names referred to in each ambient is changed by mobility primitives. proxy_enter enables two references to the same name within an ambient to be recognized within that ambient. proxy_resolve merges two serial proxies for the same name in the same ambient. proxy_insert_ middle is activated when in moves two directly connected name cells (root or proxy) to remote places not in a parent-child relation, and inserts a new proxy in between. proxy_insert_outer is activated when out exports some child proxy out of an am- bient and inverts the parent-child relationship between proxies, and creates a new proxy at the parent level. proxy_merge_outer is activated when the second parent of a proxy is created (by proxy_insert_outer) and merges the two parents.

It should be noted that name normalization and ambient operations may run concurrently. This means that in, out and open rules may be applied even when name trees are not in their normal forms. However, the three rules also preserve the above-mentioned invariants, and we can allow name tree normalization to proceed asynchronously with ambient operations.

One issue that arises in the encoding of !(open n.P ) is that the duplication of P creates new references to the free names of P . Duplication of [P ]] with free names can be expressed using aggregates. Aggregates are the only construct not yet supported in our current implementation, but the LMNtal system instead supports an nlmem (nonlinear membrane) API which does the necessary job for our purpose. nlmem.copy({P }, a, R), which is an abbreviated form of (nlmem.copy(R0, a, R),

{+R0, P }), creates two copies of the cell {+R0, P } with all its free links renamed, and connects R and the two fresh copies of R0 using a ternary atom with the name a. Furthermore, for each free link L except R0 of the original cell {+R0, P }, nlmem.copy connects the two fresh copies of L and the original L via the ternary atom a. The semantics of nlmem.copy can be given by the following rule scheme:

Acknowledgments. The author would like to thank the current and former members of the LMNtal development team who jointly built our publicly available LMNtal implementation. This work is partially supported by Grant-In-Aid for Scientific Research ((B)(2) 16300009; Priority Areas (C)(2)13324050, (B)(2)14085205 and 04560009), MEXT and JSPS.

