In this paper we show how hierarchical reasoning can be used to verify properties of complex systems. Chains of local theory extensions are used to model a case study taken from the European Train Control System (ETCS) standard, but considerably simplified. We show how testing invariants and bounded model checking (for safety properties expressed by universally quantified formulae, depending on certain parameters of the systems) can automatically be reduced to checking satisfiability of ground formulae over a base theory.

In this paper we address a case study taken from the specification of the European Train Control System (ETCS) standard (cf. [3]) but considerably simpli- fied, namely an example of a communication device responsible for a given segment of the rail track, where trains may enter and leave. We suppose that, at fixed mo- ments in time, all knowledge about the current positions of the trains is available to a controller which accordingly imposes constraints on the speed of some trains, or allows them to move freely within the allowed speed range on the track. Related problems were tackled before with methods from verification [3].

Structure of the paper. Section 2 contains the main theoretical results needed in the paper. In Section 3 we describe the case study we consider. In Section 4 we present a method for invariant and bounded model checking based on hierarchical reasoning. Section 5 contains conclusions and perspectives.

The case study we discuss here is taken from the specification of the European Train Control System (ETCS) standard [3]: we consider a radio block center (RBC), which communicates with all trains on a given track segment. Trains may enter and leave the area, given that a certain maximum number of trains on the track is not exceeded. Every train reports its position to the RBC in given time intervals and the RBC communicates to every train how far it can safely move, based on the position of the preceding train. It is then the responsibility of the trains to adjust their speed between given minimum and maximum speeds.

Model 2: Incoming and leaving trains. If we allow incoming and leaving trains, we additionally need a measure for the number of trains on the track. This is given by additional constants first and last, which at any time give the number of the first and last train on the track (again, the first train is supposed to be the train with the highest position). Furthermore, the maximum number of trains that is allowed

7 In the light of locality properties of such extensions (cf. Theorem 4.1), k will always be instantiated by values in a finite set of concrete integers, all within a given, concrete range; thus the introduction of this many-sorted multiplication does not affect decidability.

is flat and linear w.r.t. pos, so we can prove the claim by showing that every weak partial model M of T1 in which everything except pos is totally defined can be extended to a total model of T1. Locality then follows by results in [8]. To define pos at positions where it is undefined we use the density of real numbers and the fact that between two integers there are only finitely many integers:

The procedure can be repeated until pos is defined at all points between first and last. As there are finitely many positions between these two positions, the procedure terminates after a finite number of steps. We can define pos arbitrarily outside of this range. The result is a total model of T1.

In the example above we restricted attention to the problem of showing that a prop- erty of train systems (collision freeness) is an inductive invariant. Similar results can be established for bounded model checking. In this case the arguments are similar, but one needs to consider chains of extensions of length 1, 2, 3,... ,k for a bounded k, corresponding to the paths from the initial state to be analyzed. An interesting

Step 1: Use locality. We construct the set Kf [G]: There are no ground subterms with pos' at the root in Kf , and only two ground terms with pos' in G, pos'(k) and pos'(k'). This means that Kf [G] consists of two instances of Kf : one with i instantiated to k, the other instantiated to k'. E.g., the two instances of F2 are:

We present below an alternative method, somewhat similar to DPLL(T0), but which uses only branching on the literals containing terms of sort i, and thus reduces the verification problem to the problem of checking the satisfiability of a set of linear constraints over the reals. This idea, we think, may be used to simplify automated verification for a whole class of problems in which the axioms are guarded by simple, mutually disjoint and exhaustive premises expressed in a specific theory. Such examples occur very often in verification where several disjoint cases need to be taken into account.

