An important aspect of WRLA is to stimulate discussions of applications of Rewrit- ing Logic and to make the community aware of systems and tools based on Rewriting Logic. Several such systems were demonstrated as part of the workshop. In the fol- lowing we give an overview of the capabilities of the demonstrated systems. In addition, there was a competition of two mature and widely used algebraic specifi- cation environments based on rewriting, namely ASF+SDF and Maude. We present the rules of the competition, describe the benchmarks on which the system were tested and the results of the competition.

The Asf+Sdf and the Asf+Sdf Meta-Environment have been applied in a broad range of applications. The application areas can be characterized as: proto- typing of domain specific languages, software renovation, and code generation. An overview of some of the applications is given in [1].

Rewriting logic is reflective, in the sense of being able to express its own metalevel at the object level [8]. Reflection is supported efficiently in Maude endowing the lan- guage with powerful metaprogramming capabilities, including both user-definable module operations and declarative strategies to guide the deduction process. The Maude META-LEVEL provides descent functions reifying: the process of reducing a term to normal form; the process of applying a rule to a subject term; the two de- fault strategies for rewriting a term is reified by functions; the process of matching a pattern to a subject term; the process of searching for a particular pattern term; and parsing and pretty printing of a term; and key sort operations. It provides ascent functions for obtaining the metarepresentation of terms, and of modules in the module database.

The idea of organizing a rewrite competition arose from noticing various applica- tions of rewriting in different areas and by different categories of researchers, many of them manifesting a genuine and explicit interest in term rewriting. We believe that many of us can benefit from such rewrite engine competitions, provided that they are fair and explicitly state what was tested in each case. For example, users of rewrite engine can more informatively select the right rewrite engine for their their particular application. On the other hand, for rewrite engine developers, such

We hope this competition marks the beginning of a long term and fair com- parison of the performance of various rewrite engines. Specifically, we need to understand, discuss, agree, or disagree upon the relevant comparison criteria: raw speed; memory consumption/management; use of parallelism; compiler vs. inter- preter; scalability. We believe that the importance one gives to any of these criteria largely depends on the role rewriting plays in the development of their applications. Also we hope these competitions will reveal a benchmark of meaningful examples addressing all aspects of rewriting as a programming paradigm.

responding compiled code, even when no aggressive compilation optimizations are employed. Also, we do not claim that we have captured the actual strengths of the systems tested; it was actually quite difficult to devise compelling examples that fit within the intersection of the capabilities of the two systems. For example, Asf+Sdf has a great parser and was successfully applied in large program transfor- mation projects, which we were not able to test. On the other hand, Maude has AC matching, and a suite of tools (theorem prover, model checker) making it amenable for formal analysis projects, that we have not tested either.

There are two possible causes for the bad behaviour of Asf+Sdf. The first is in the way the terms are represented in the underlying ATerm-library [3]. In case of the successor notion it is very likely that given the term representation the internal hash function of the ATerm-library does not work optimally. A second cause is the restricted machine stack, it is possible to increase the size of the machine stack to solve this problem.

There are no suprises in these results. Maude uses the GNU GMP library as a backend for builtin arithmetic though it maintains the illusion of algebaically de- fined numbers via a fancy representation and matching and replacement algorithms. Almost all the cpu time goes for bignum multiplications done very efficiently by GMP.

The above is not only concise, but it can also give a very fast sorting algorithm if run on a parallel rewrite engine. Again, we tested two capabilities of the rewrite engines: with list constructors and with built-in lists. Recall that both Asf+Sdf and Maude have specialized rewriting algorithms for associative lists. With list constructors we obtained the following numbers:

List length. There are many rewrite-based programs that traverse lists and do something for each element. We have picked one of the simplest, namely one that counts the number of elements in a list. The rewrite system is trivial, so we do not give it here; we only mention that traversal of the list was from the first element to the last, and that we have used built-in associative lists in both cases:

Reversing lists. Unlike in standard functional programming where one can only access the head of a list, in rewriting programming with matching modulo assicia- tivity one can have very elegant definitions of the reverse operation on lists. We have tested the following three one-rule rewrite systems defining list reversal. For both engines we used associative lists.

In Asf+Sdf lists are directly mapped to the list representation of the ATerm library [3]. Operations on the head of these lists are extremely efficient, O(1), whereas operations, such as adding new elements, at the tail of the list are extremely expensive, O(n2) where n is the length of the list. This explains the difference in behavior between the two systems.

being constructed when they are fully reduced. In constrast, Maude explicitly does each replacement and keeps a flag to hold the reduction status of each subterm. The user can interrupt Maude at any moment with control-C and examine the current term.

Maude 2.2 supports IPv4 TCP client and server sockets. Sockets are created by sending a message to a special external object called socketManager. send and receive messages can then be sent to the newly created socket objects. Message are usually paired: a user object sends a message to an external object and waits for a

Model-Driven Development is a field in Software Engineering that, for several years, has been representing software artifacts as models in order to improve pro- ductivity, quality, and economy. Models provide a more abstract description of a software artifact than the final code of the application. Interest in this field has grown in software development companies such as the Model-Driven Architecture (MDA), supported by OMG, and the Software Factories, supported by Microsoft, ensuring a model-driven technology stock for the near future.

In this demonstration, we present the MOMENT-OCL tool, which integrates an algebraic specification of the operational semantics of part of the OCL 2.0 standard into the Eclipse Modeling Framework (EMF). EMF is a modeling environment that is plugged into the Eclipse platform and that provides a sort of implementation of the MOF. EMF enables the automatic import of software artifacts from heterogeneous data sources: UML models, relational schemas, and XML schemas. In MOMENT- OCL, OCL queries and invariants can be executed over instances of EMF models in Maude. An interesting feature of this algebraic specification of the OCL 2.0 is the use of the parameterization to reuse the OCL specification for any meta- model/model and the simulation of higher-order functions for the sake of the reuse of collection operator definitions.

Following the experience of Elan [12], the Tom [13] language was developed to provide rewrite tools for implementation of calculi, for compilation and for XML- transformations. The demonstration focussed on the former. Tom provides a lan- guage to define a syntax (a signature) embedded into Java. One can perform pattern matching with support of associative matching modulo neutral element (also known as list-matching). In addition, we can guide the application of rules with a strategy language defining term traversals (namely evaluation/rewriting strategies).

The originality of Tom lies in the combination of formal aspects with a general purpose language (such as Java). This combination leads to an agile language. At the same time, the strategy language inspired by Elan and Stratego [15] gives the opportunity to reduce the code written in the general purpose language (and thus increases the formal parts).

