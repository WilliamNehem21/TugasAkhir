w.r.t. a constraint system and non-deterministic. This work presents the tccpInterpreter system, which is the result of implementing the tccp language in Maude. Maude has been shown to be well suited for the task of prototyping the semantics of programming languages. Our tccpInterpreter parses a given program and simulates its behavior, also allowing us to reuse the Maude features to execute and analyze tccp programs.

The tccp language inherits some significant characteristics from ccp: it is parametric w.r.t. a given constraint system, non-deterministic, and the stored information grows monotonically. The underlying constraint system specifies which kind of constraints the system will be able to handle, and the relation among them. The non-deterministic behavior allows us to have more compact and precise specifications for large systems. Finally, the monotonic behavior of the store implies that information cannot be canceled, thus it is necessary to use streams to model the classical evolution of variable values.

The temporal model introduced in tccp is based on a global clock that synchronizes the execution. The agent-based model provides an intuitive way to specify reactive and embedded systems. Thanks to the new features (w.r.t. ccp), the language is able to capture typical behaviors of reactive systems such as time-outs, time-delays or watchdogs. Furthermore, since time is embedded in the semantics of the language, it is possible to naturally use the (constrained version of) Linear Temporal Logic (LTL) proposed in [5] to specify and model check properties of tccp programs [3,2,6].

To our knowledge, there is just an implementation of tccp. In [15] it was presented a prototype developed in the Mozart-Oz language. Mozart-Oz [9] is a multi-paradigm language allowing multi-threaded higher order programs to be directly executed in a distributed open system. However, the proposal is not publicly available and does not support the new features of tccp presented during the last years.

This work is organized as follows. In Section 2 we present the basic notions of the tccp language. Then, in Section 3 we partially describe how the syntax and operational semantics of tccp have been implemented in Maude. A model for a specific constraint system is shown in Section 4. Section 5 is devoted to show the functionality of the tool by using an illustrative example and, finally, in Section 6 we conclude and give some directions for future work.

executes one of the agents Ai whose condition ci is satisfied. In case no condi- tion ci is entailed, the choice agent suspends (it will be executed again in the following time instant). The conditional agent now c then A else B executes agent A if the store satisfies c, otherwise executes B. Note that due to the partial nature of the stored information, the fact that c is not satisfied does

The notion of time is modeled in the language following the idea that updates and consults to the store takes one time unit. Therefore, only the tell, choice and procedure call agents consume time. The rest of agents are considered instantaneous.

Similarly to ccp, the store in the original model of tccp behaves monotoni- cally. Thus, it is not possible to change the value of a given variable along the time. This problem can be solved by using streams. For instance, we write X = [1|Z] to denote a variable X recording the current value 1. The variable Z represents the future values of X. To ease the tasks related to streams manipulation, we use the modified computation model for tccp presented in

tccpInterpreter considers three new agents introduced in [10] to deal in a more compact way with some common behaviors regarding streams. The ask-tell(S, V ) agent consults the current value of the stream S and updates the store by instantiating the fresh variable V to such value. The update(S, V, T ) agent inserts the value of the variable V in the stream S. T represents the future values of S. Finally, the assign(S, Vf , Va) agent consults whether the value of Vf can be recovered from (any of the values stored in) the stream S; in that case, it instantiates Va to the recovered value.

Let us describe some of these semantic rules. The first rule R1 specifies the evolution of the tell agent: it reaches a skip agent in the following time instant with the given store st augmented with the constraint c. Rule R2 states that Aj is executed in the following time unit whenever st entails the condition cj. Regarding the conditional agent, R3 models the case when the

condition holds. In case that the agent A with the current store st can evolve in the agent A' and a new store st', then A' is executed in the following time instant. R7 models the evolution of the  agent: in case that A with store st is able to evolve to the agent A' with st', and also B with store st is able to evolve into the agent B' with st'', then A'||B' is executed in the following time instant with st' augmented with st''.

The tccpInterpreter system is the result of the implementation in Maude of the tccp formalism, i.e., the language operational semantics plus a specific con- straint solver. The tool takes as input the specification of a tccp program and simulates its behavior following the semantics of the language. tccpInterpreter

consists of approximately 1080 lines of code divided in six Maude modules. Each module models one or more of the entities of tccp: agents, constraints, programs, the store, the underlying constraint system, the operational seman- tics, etc. Maude allows us to implement a constraint solver for the language or to use an existing one to handle constraints. 5

Other important point in the tccp framework is the interaction with the un- derlying constraint solver. Typically, the constraint solver must be able of solving arithmetic and boolean constraints, and to perform some operations with streams. These goals can be achieved in an elegant way implementing the constraint system in Maude. Once defined the types of the expressions and the syntax of the operators needed to handle constraints, we specify the rules describing the evolution of each possible combination, thus the satisfaction relation.

Once the interpreter is loaded, we can use the Maude commands to invoke actions. For example, we can use the command red expression to parse or to identify an expression (an entity of the language). The command checks the given expression and returns the type or the sort associated to it. In other words, it tries to reduce the given expression following the specified grammar. The following example shows the output of Maude when reducing a tccp agent.

The declaration D models the process of detecting whether the door of the microwave is open at the same time that it is turned-on. This situation is controlled by the conditional agent in ln8. In case the condition holds, the process forces (with the tell agent in lt13) the microwave to be turned-off in the following time instant. Moreover, an error signal must be emitted (agent lt11). If the condition does not hold, then the system emits (via another tell agent lt15) a signal of no error that will be available in the store at the following time instant. These signals may be captured by other processes, thus it can be seen that the store allows the synchronization of processes. Finally, the procedure call agent microwave error(D,B,E) models the recursion of the system.

The recursive procedure call agent (lc16) causes the system not to end, but this is the expected behavior in the tccp execution model. Therefore, we have to deal with infinite sets of states. To make the execution finite, we can use the Maude debugging feature [4] to capture each step of the computation, or to use a ceiling of time-units in the evolution of a tccp specification.

of the command described previously. It shows the resulting store at time instant 2. In the execution graph, at time instant 0 the store is empty. At time instant 1, the store contains the information resulting by the procedure call in the first term, where the parameters of the call are instantiated. Finally, at time instant 2 the store contains the information added by the tell agents lt11 and lt13 (the constraint of the conditional agent ln8 is satisfied), and the information added by the second procedure call lc16:

We have presented how the Maude system can be used as a semantic frame- work and metalanguage to build an entire environment and mechanisms for the execution of the formal specification language tccp. Maude leads to an per- spicuous formulation in the task of specifying transition systems. It presents a rich notation supporting formal specification and implementation of concur- rent systems. In this paper, we demonstrate the feasibility and the interest of formalizing the behavior of tccp with the Maude language.

