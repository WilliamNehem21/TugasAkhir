The set of nodes (slow or fast) connected through a shared medium make up a DoRiS segment. Although many DoRiS segments can be inter-connected by switches or routers, we will restrict our specification and verification to a single DoRiS segment. At each node, a server is responsible for the transmission of hard real-time and best-effort messages. Slow nodes send only hard real-time messages and fast nodes may send both hard and best-effort messages. Each server maintains a hard queue, which stores hard real-time messages to be sent. Fast servers also maintain a soft queue, which stores outgoing best-effort messages. Although there is only a single server in each node, we define HardServ [i ] and SoftServ [i ], the two server threads

of node i dealing with the hard and soft queues, respectively. As there may be many processes executing on a node, some local priority policy has to be defined to schedule messages of different applications. However, this topic is beyond this paper scope, which is focused only on the communication aspects.

The medium access control of DoRiS is regulated by an implicit token, which rotates in the hard and soft rings (Section 2.1), according to timing and/or logical conditions built upon observed communication activities. A pure TDMA scheme is used to isolate the two rings of DoRiS . As for the soft ring scheme, the process group membership is dynamically managed using the following mechanism. Elementary messages contain a bit which, whenever set, informs all servers that the sending server will thenceforth participate of the soft ring. When the soft queue of a server

transition function on steps. In our example, the action defined by [v ' = v + 1] is true of step S . Note that for a given step S , the next-state relation from state i to state f , usually called state transition function in Finite State Machine formalism, is defined by the set of actions defined on S . As an action can be made up of several other actions, this set is also an action.

The field cons of HardState[i ] is a tuple of flags that keeps track of the elemen- tary messages received by each server. The entry cons[j ] is set to 1 whenever an elementary message sent by server j is received by server i or when server i = j sends its elementary message. When an elementary message sent by j is omitted at server i , the corresponding entry of tuple HardState[i ].cons[j ] remains null, allowing for the detection of the failure. As will be seen, the action NextTick resets all values of cons[Shared.chipCount ] to 0.

When server i is not in NoRecvSet (m), m is received normally and the various fields of HardState are updated. Message m then is appended to the msg list of incomming messages and the associated timer execTimer is set to the maximum processing time of m if it was not previously set. The entry m.id of cons is set to 1 to represent the successful reception of an elementary message and, finally, the res field is updated, according to the res set piggybacked on m.

As for SoftState, three fields are updated regarding server s whose identifier is i . If a message is not transmitted due to lack of time, the field list is kept unchanged. Otherwise, the sent message is deleted from the list by tailList . The fields token and count of SoftState[i ] also remain unchanged is no message is sent because of

In most of the TLC runs for the DoRiS specification, the execution time for some finite models was found to be reasonable, although no comparison was made with other tools. We have used a 2 Ghz Intel Core Duo processor using a java virtual machine with a 512M heap size. Three performance metrics were considered: CPU user time (U ); the total number of generated distinct states (N ); the diameter (D ) of the reachability graph. 6

The absence of deadlocks is automatically checked by TLC. On the other hand, type invariance are elementary properties to be specified. Instead of describing such basic properties, this section focus on those more related to the protocol func- tionalities. More specifically, the following relevant properties of the DoRiS protocol were verified: (i) the protocol provides communication isolation, avoiding collisions;

Although the protocol specification has given several insights to carry out its implementation, it was not possible to use the specification straightway. Indeed, DoRiS was implemented in a Linux-based real-time operating system [14] which has itself a complex architecture. However, most functions of the protocol could be translated from the specification and adapted into the operating system infrastruc- ture.

plementation of a specified protocol using an existing complex software, such an operating system, as a basic infra-structure. A more automatic way for perform- ing such a task is needed. The development of DoRiS and its described formal specification can well serve as a motivating case study for this field of research.

