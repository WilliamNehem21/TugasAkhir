We propose a structure for the model of the OCL concepts that facilitates the use of OCL over a number of different metamodels. A carefully specified set of interfaces can be defined as a bridge, which enables a common library of OCL parser, analyzer, evaluator and code generator to be used in the context of a number of different metamodels. We have implemented bridges for three different metamodels, providing OCL for Java, for KMF and for the Eclipse Modelling Framework (EMF). Our KMF implementation will be updated to use UML 2.0 when it is finalised, the architecture proposed here facilitates an easy update path. This architecture provides a clean and well-defined division between the OCL model and the metamodel to which it is attached, whilst still providing the necessary linkage.

Appendix A contains the EBNF for an LALR grammar we have used in our implementation. Our grammar is distinct from the one defined in the standard in that it is unambiguous. The most noticeable difference is the manner in which we define the rules for the OclExpression non-terminal.

These aspects make it hard for rules to be written that correctly parse the language; we have solved the problem by separately listing the variation in number and style of iterator variable definitions. This would be made simpler if an alternative separator were to be used. A possible alternative could be a semicolon; such a separator is used within iterate expressions, hence it would not be inconsistent in the iterator expressions. Without making a change along these lines the language can not include facility for multiple iterator variables

The parser generates an Abstract Syntax Tree - i.e. a model of the text ex- pression entered. This is of a form where there is a direct association between rules in the grammar and nodes in the tree. The AST is purely an abstract representation of the syntax, modelled as a tree.

Before we can interpret the meaning of the syntax, we must provide a semantic context for the expression. This context involves two parts: the UML (or other) user model over which the expression is to be interpreted; and the entry point into that model - i.e. the type of the self variable.

The model defined in the OCL standard and named, incorrectly, Abstract Syntax Model (ASM), is such a model. We feel that this model is misleadingly named; it does not contain purely Abstract Syntax information, it contains a mix of syntax nodes and semantic nodes. A semantic node is a node containing information relating to the user model and context of the expression. We suggest that an alternative name be used. As the model contains semantic information referencing the user defined context model, we refer to this as the OCL Semantic Model. (Not to be confused with a model of the semantics, which is something else not addressed in this paper.)

The classes from (ii) are distinguished in the standard by the definition that they come from various packages in the UML metamodel and they are additionally coloured white as opposed to grey. We redefine these classes to be members of a single package named bridge. They keep the same names as before, but should be considered to map to the classes form the UML model, rather than directly being classes from the UML model.

According to OCL 2.0 proposal collection and tuple types are not consid- ered to be subtypes of OclAny. This means that operations specific to OclAny cannot be applied to instances of tuple and collection types. We do not find any reason why collection and tuple types cannot be considered subtypes of OclAny and in fact we find that it be necessary that they are if we are to enable them to be type cast. For example, consider a Set of type Animal that we know to contain only objects of type Dog, we may wish to perform a cast on the Set, as shown in the following expression:

Such an expression is not currently accepted syntactically (see above) or semantically, as the OclAny operations cannot be used on collections. Con- sidering tuple and collection types as subtypes of OclAny will increase the expressiveness and the usability of OCL. If such a feature is not available in OCL, the user will have to use other syntactical constructions in order to obtain the same effect (e.g. iterate over the above collection and cast each element).

The following subsections discuss the issues relative to each of our three bridge implementations. Each of these bridge implementations provides sup- port for the Enumeration, Namespace, Operation and Property classes. The implementation of the other bridge classes is common to each of these three, and we suspect common to most bridge implementations.

KMF version 2.0 is based on the UML1.4 metamodel. KMF uses a UML 1.4 XMI file to build a model implementation; it is this implementation that we wish to use as the user model for our OCL expressions. In order to get the correct type information, irrespective of the model implementation details, the KMF bridge implementation gets all of its information from the same XMI file used to store the model information and generate the Java code which implements the model.

The most problematic bridge implementation is the one for Java. Java does not provide an explicit mechanism for creating enumerations; it does not provide typed collections classes; and its notion of a package does not match the UML package concept. The reflective capabilities of java have proved essential to forming our bridge implementation.

We identify an enumeration in one of two ways. Either by looking up the enumeration in a pre instantiated list of enumerations, or by testing if the class extends java.util.Enumeration. This is a slight misuse of the java.util.Enumeration class, but it provides a nice solution to the problem. Such enumerations are assumed to be implemented with each enumeration literal being a static member of the enumeration class and an instance of that class.

The problem with a namespace is that java packages are separately iden- tified by their full package name. Although appearing to support the notion of sub-packages, the java reflection features do not hold this sub-package rela- tionship. Hence, to lookup an owned element of a namespace by name, we first try and find a java class with the element name plus full path name of the cur- rent namespace; if that fails, we assume the name is a sub-namespace, create the appropriate sub-namespace object, and return the sub-namespace. This is not necessarily the best approach, but seems to work in most situations.

There are many CASE tools supporting drawing of UML diagrams and fea- tures like code generation and reverse engineering. However, support for OCL and transformation and mappings between models is rarely found in these tools. There are several tasks that a CASE tool should offer in order to pro- vide support for OCL. For example, syntax analysis of OCL construction and a precise mechanism for reporting syntactical errors, help in writing syntac- tically correct OCL statements. The next step could be a semantic analyser, which should report as many errors as possible in order to help the user to develop solid OCL code. If the tool offers both an interpreter and a compiler, the user has the possibility to choose the best approach in order to obtain a high quality software.

Probably the first available tool for OCL was a parser developed by the OCL authors at IBM, now maintained at Klasse Objecten. The parser uses the grammar described in [6]. Another toolset was developed at TU Dresden [4]. A part of this tool has been integrated with the open source CASE tool Argo [2]. [10] contains a description of an OCL interpreter. It is based partly on a OCL meta-model describing the abstract syntax of OCL. [8] provides also a good implementation for OCL.

Demuth B., H. Hussman, F. Finger, Modular architecture for a toolset supporting OCL. In Evans A., S. Kent, and B. Selic, UML 2000 - The Unified Modeling Language. Advancing the Standard. Third International Conference, York, UK, October 2000, Proceedings volume 1939 (2000)of LNCS, pages 440-450, Springer 2000.

