In other words, contexts are just terms with holes in them. We usually write a context C as C[.,... , .] not to get confused with ordinary terms. These holes can be filled with terms of appropriate type to give a term. We denote a

portant one. In practice other issues arise such as efficiency regarding time and/or space. Though in Part 1.1.3 we tried to summarize the theoretical issues and demonstrate the success in that regard, we never cared about the efficiency of computations. Whenever we felt a deficiency, we did not hesitate to remedy by any means.

PCF-programs are meant to output constants of the ground types bool or nat. Of course it is obvious that there are many more collection of objects over which we like to do computation. One such important case is the set of real numbers.

Traditionally we are used to computation on real numbers via floating point approximations which is satisfactory for everyday business but can prove to be extremely unreliable in special circumstances. Floating point computa- tion carries the problem of round-off errors with it, which we try to ignore in everyday life applications for a variety of reasons. In [12] this subject is ex- plored together with two interesting examples demonstrating the unreliability of floating point approach. Accordingly the idea of exact real number computa- tion has been put forward which is, as opposed to floating point computation, reliable, i.e. the output produced is guaranteed to be correct. Moreover the results can be computed effectively (e.g. as opposed to BSS approach [5]) to within any desired degree of accuracy.

The aim is to take the ground type I as the type of real numbers in the unit interval, i.e. [0, 1] and use the constants introduced in the definition for computation over them. In the above definition a ranges over intervals with

Also we have shown that wRPCF-definable functions are piecewise affine ( Definition 3.1, page 32), though our result is slightly more powerful. Of course the language we studied is really weak so it does not come as a surprise that the functions definable in that language are so limited, one witness being their piecewise affinity. The logical relations Rk we presented (Definition 3.7, page 36) by themselves do not characterize piecewise affinity. But as we discussed in Part 3.1, page 38, the whole framework could give an inspiration for further studies, specially of the following problem:

