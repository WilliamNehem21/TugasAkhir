Polarized strong categories are closely related to certain fibrations (over the op- ponent world). This provides an alternative and compelling perspective on these setting which we shall wish to exploit. This section, therefore, develops the relation- ship to fibrations and also introduces R-sized sets which we shall use as a running example to illustrate the theory.

The X-strong categories we are interested in here have much more structure: the player category is affine closed 10 with products and coproducts. This section de- scribes how this structure is defined for X-strong categories and gives the corre- sponding fibrational interpretation. Finally, the corresponding structure in R-sized sets is described.

A peculiarity of the (initial) fixed point calculus in his setting is that inductive data (i.e. fixed point data) does not in general supply material from which one can build more inductive data. This is because inductive data does not, in general, organize itself into a polarized operator.

In the initial settings it is usually the case that every object in the opponent world is actually a lifted player object. In such settings the polarized operators are completely determined by the player side. Thus, the specification of these operators in the player world is often the crucial aspect.

Each constructor increases the size of its input by 1, so they are certainly maps in the player category. The map cons above is the cotuple of these constructors, and so it too is bounded by a size increase of 1. The inverse map is non-size increasing and so is also in R-Setconst. This shows that this object is a fixed point in R-Setconst.

It is convenient, in order to bound the recursion principle to use the transfor- mation of proposition 5.1 and derive the size bounds from the fixed point form of the map. This then has to be evaluated to obtain the map we actually want. It

These matters are addressed in [20] which is still work in progress. That doc- ument describes a full programming language and type system in support of the development of a PTIME programming language called Pola [3]. It is a more com- plex system than that described here. It uses a bunched logic for the programs in the player world, has type inference, and supports both inductive and coinductive data. Coinductive data has destruction which is constant time, and thus, like the closed structure discussed in this document, is completely in the player world. The inductive data is essentially as discussed here (although a slightly more powerful recursion principle is used).

One can easily program PTIME Turing machines in this languiage: thus, it is certainly PTIME complete. If the distributive law for products over coproducts is assumed for all data, then QSAT can be programmed (following the observation of Hofmann). Thus this language is also PSPACE complete. The arguments for soundness are by structural induction: they show first that the language (with the distributive law) is PSPACE sound and second that, if one drops the distributive law (for higher-order, coinductive, and universal types), that the language is PTIME sound (PTIME completeness is not affected).

