we can fix the proposition and apply narrowing search for an unknown proof. The general search procedure will then try to construct proofs of the given proposition. One approach to develop a proof construction tool for a given higher-order for- malism is to add meta variables (or logical variables) to the abstract syntax of the proof language. These are used as place holders for unknown data. When searching for a proof, a single meta variable is created at the start, indicating that the entire proof term is initially unknown. The meta variable is then instantiated step-by-step, adding new meta variables representing unknown sub-terms. While instantiating, one keeps track of the semantics of the formalism, back-tracking whenever the cur-

There would be several advantages of the proposed way of attaining proof search from a proof checker. Instead of implementing an often intricate and tedious proof search algorithm, the proof checker, which presumably already exists, is reused. Apart from saving work, this entails that there is little potential for inconsistency. In other words, given that the narrowing search procedure is sound and complete, the same properties are inherited by the proof search. Thus the correctness of the search is in principal directly provided. Another advantage would be that meta variables are handled by the narrowing algorithm. Hence, there is no need to add meta variables to the term syntax, and functions like evaluation and comparison do not need to be aware of them. Also, since the narrowing is first-order, the search algorithm is pretty simple. In this work narrowing is used to construct higher-order proofs. To make this possible the terms are represented in a first-order abstract syntax.

The potential drawback of the approach which could overshadow all these ben- efits is of course that the resulting search procedure, although working in theory, is not efficient enough for practical use. We have investigated this by implementing a narrowing search algorithm and a proof checker. Our aim has been to achieve a proof construction tool which automates the construction of proofs which are rather small. It is supposed to be useful in an interactive proof construction environment as an aid for filling in not too complex sub-terms in a proof. It is not meant to compete with advanced algorithms for constructing higher-order proof terms. In- stead, the intended point of the approach is to add automation to a formal system for higher-order logic at a low cost.

The formalism we have chosen is a logical framework with dependent types, and recursive data-types and function definitions. Hence the proof checker is in fact a type checker, and will we from now on use the terminology of the Curry-Howard correspondence, i.e. refer to proofs as terms and propositions as types. We have implemented a type checker for the formalism in Haskell. Applying the narrowing search on this type checker indeed does not at first give a proof construction tool which could be used in practise. However, our experiments indicate that, by adding a couple of general features to the narrowing search, as well as introducing some small modifications to the type checker, the performance is substantially improved. We will present the most crucial (in our experience) of these general features and modifications. A central idea of the work is that the same code should in principle be able to serve as a description for both checking and searching. Hence, the modifications introduced to the type checking algorithm should preserve its meaning as a Haskell program.

Our underlying search procedure is based on narrowing. A survey of various narrow- ing strategies is found in [2]. A notion of parallel evaluation was presented by Antoy et. al. in [3]. We have used a slightly different notion of parallel evaluation, which is described in [10]. Higher-order term construction using first-order narrowing was investigated by Antoy and Tolmach[5]. Our work is related to this in the sense that we have also looked at using first-order narrowing to construct higher-order terms. The difference is that Antoy and Tolmach focused on constructing terms in the declarative language itself, whereas we encode a new language in a first-order data-type and search for objects of that data-type.

Finding efficient strategies for automatically constructing proof terms is an ex- tensively studied area. The concept of uniform proofs largely reduces redundancy in proof search and is implemented in e.g. the formal system Twelf [11,12]. Focused derivations is a development of this which further improves performance by detect- ing chains of construction steps for which the search can proceed deterministically

[1]. Tabling is another technique for narrowing down search space [13]. It is based on memoizing subproblems in order to avoid searching for the same proof more than once. Our approach cannot compete with these advanced proof construction strategies. Nonetheless we do add some restrictions to the type checker in section 5 which remove certain kinds of redundancy. More refined restrictions could proba- bly be introduced, and a tabling mechanism could possibly be added to the general search procedure. However, such advanced features are outside the scope of this investigation.

With a lazy narrowing strategy the expression for which the search is performed is evaluated in a lazy evaluation order, i.e. from the outside and in. Whenever an uninstantiated meta variable is encountered it is said to be in the blocking position. The meta variable in the blocking position is chosen for refinement. It is non- deterministically refined to one of the constructors in its type. For each constructor, fresh meta variables are inserted at the argument positions. Then the evaluation of the expression proceeds until a new blocking meta variable is encountered or a value is reached. If the value is True a solution has been found. If it is False a dead-end has been reached and the search back-tracks.

Proceeding with the example, we start evaluating the given expression lazily. Since tc does a case distinction on the third argument, we need to know the head constructor of the term. But the term is ?1, which thus blocks further evaluation. There are three possible refinements of ?1. The refinement ?1 := App ?2 ?3 yields an expression with (tiv empctx ?2) surrounding the potentially blocking position. Assuming that tiv returns Nothing for the empty context regardless of its second argument, the evaluation proceeds without further refinement with the result being False, which means no solution. The refinement ?1 := Pi ?2 ?3 ?4 immediately yields False since the type is not Set. Finally, the refinement ?1 := Lam ?2 ?3 results in the expression

However, the example could very well be formalized in a system without depen- dent types. In a logical framework with dependent types, argument types and the output type may depend on a previous argument value in applications. This leads to some complications which were not exposed in the example. In the following two sections these complications will be discussed along with suggestions for how to deal with them.

One complication which did appear in the example was the treatment of vari- ables. When constructing variable occurrences, the description of the search was rather irregular, stating that two variables should be the same rather than instan- tiating a single meta variable. Also, the variables which were never used were left uninstantiated. These problems are however easy to avoid. When representing vari- able occurrences by de Bruijn indices, no arbitrary choices need to be made, and no uninstantiated variables at binding position will appear. Furthermore, if recursively defined numbers are chosen to represent the indices, the narrowing algorithm will itself limit the search to the set of possible indices for a given context.

This section describes the two main non standard features of the general search algorithm we have investigated. As stated above, the search procedure targets weakly orthogonal TRSs. In order to deal this class of rewrite systems efficiently, a concept of parallel evaluation has been proposed[3]. In [10] a somewhat different notion of parallel evaluation is presented, which is used in our implementation. Using this feature for the purpose of parallel conjunction is discussed in section

As mentioned, the hazard of giving conjunctions a parallel meaning is that an intentional partiality in the right conjunct is exposed. The implications are different for non-definedness and for non-termination partiality. Non-definedness can be easily handled by treating a undefinedness error in the right conjunct of parallel conjunction as False.

With the needed narrowing strategy, there is always a unique meta variable to branch the search on. However, in the presence of parallel conjunction, or parallel evaluation in general[10], there is no longer a single meta variable blocking the evaluation. The order in which to instantiate meta variables must hence be further specified. A natural choice is to store them in a collection and extract them in either a queue or a stack manner. In our experience the queue is in general, but not always, the better choice regarding performance[10]. The order of instantiating blocking meta variables can also be controlled in more refined ways, which we will come back to in section 5.2.

Parallel conjunction was introduced in order to check several properties in parallel during the incremental instantiation of a term. This seems to be beneficial in various situations where the properties constrain the same part of the term. However, for problems where there are sub-terms with no dependencies in between, it seems undesirable to interleave the search for their solutions. Consider the situation

where P and Q have no meta variable occurrences. Interleaving the construction of a proof of P and a proof of Q is unnecessary and should lead to a larger search space than if the to subproofs were constructed separately. This is a drawback of switching to parallel conjunction as discussed in sec 4.1. Moreover the situation is very common. It can appear whenever attempting to prove a proposition by case

A solution to this drawback could be to add a feature of subproblem separation to the general narrowing search. One part of the mechanism would be to detect the presence on independent subproblems, i.e. unconnected graphs where parallel conjuncts and meta variables constitute the vertices and the edges represent meta variable occurrences in the conjuncts. When such a partitioning has been detected, a local search for each subproblem is spawned. When performing the search for several independent subproblems backtracking one of them should not affect the other ones, and when the search space is exhausted for one of them, itself and all of its sibling subproblems are cancelled. We have implemented this feature, but it should be considered a prototype.

The features presented in the previous section, parallel conjunction and subproblem separation, do not result in a proof search which is of practical use. In order to improve the performance, we have also experimented with some modifications of the type checker. In this section we will discuss a few such modifications which have proved to be important in our experiments.

Most logical frameworks allow writing essentially the same proof in many different ways. By restricting the type checker to accept fewer terms for a given type, a reduction of the search space can be accomplished. One restriction is to only allow normal terms. It can be easily achieved by adding a side condition checking that no sub-term is reducible. Imposing this restriction does not compromise the com- pleteness of the search. Another possibility could be to add restrictions which allow only uniform proofs.

One can of course also come up with a large number of restrictions, which do limit the completeness. These can be seen as representations of different heuristics. One example is to restrict induction so that no generalizations may take place. This clearly makes the search incomplete, but also contributes a lot to performance.

As mentioned in section 4.1, the search is based on keeping a queue of blocking meta variables and instantiating them one at a time. By slightly annotating the code of the type checker, one can introduce a notion of priority which refines the scheduling of the meta variable instantiation. Controlling the order of instantiation this way does not affect the completeness, apart from the possibility that an otherwise finite search space could become infinite.

In order to be able to prioritize proof and non-proof terms differently, there must be a way to tell them apart. One option is to distinguish between dependent and non-dependent function types. Application arguments which stem from depen- dent function types are treated as non-proof terms and those from non-dependent function types as proof terms. We have chosen this approach in our implementation.

the search must guess ?1 to be add ?2 ?3. This is of course a possible solution, but we would like to make better use of the information that is given in the initial type defining the problem. The meta variable on one side should be able to mimic the term on the other side, just like in unification.

We have performed some experiments with the presented approach. The imple- mentation consists of a general narrowing search system and a type checker for a logical framework written in Haskell. The narrowing system is constituted by a compiler of Haskell programs and a run-time system implementing the search algo- rithm. The narrowing algorithm accepts weakly orthogonal TRSs by implementing the parallel evaluation discussed in section 4.1 and presented in more detail in [10]. It also includes a prototype of the subproblem separation feature presented in sec- tion 4.2. The type checker is based on the one presented in section 3, but modified to enable parallel conjunction and the performance enhancing features presented

An inductive proof containing some kind of generalization serves well as an illustra- tion of the order of instantiation which is imposed by the prioritization presented in section 5.2. The example is to construct a proof of the proposition stating that a given function, sort, always returns a sorted list.

In order to save space we will omit the definitions of sorted and sort, but merely state that sort implements insertion sort. The reader thus cannot confirm that the proof is correct. Nevertheless, the mechanisms of the proof search should be clear. The function sort is defined in terms of sort' which, in turn, uses insert. The names List and Nat refer to the standard recursive definitions of lists and natural numbers. The proof search is provided an elimination constant for lists,

by adding a couple of non-standard features of the narrowing, as well as a number of small and rather general modifications of the type checker. We have made an implementation to get some empirical evidence of the usability of the approach. The preliminary conclusion is that the approach could be useful in situations where low cost is important rather the high performance. The experiments are however too limited to be able to give a more solid conclusion/

e.g. insertion sort. But the main obstacle seems to be that, although we restrict the search to terminating functions, a lot of very inefficient candidates are still gener- ated. This could be amended by adding some notion of function complexity to the type system.

