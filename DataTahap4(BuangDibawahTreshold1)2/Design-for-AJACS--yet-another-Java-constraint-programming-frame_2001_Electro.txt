The inefficiency of the implementations of JVM, the Java virtual machine, may seem to be a deterrent to using it to implement other programming paradigms, especially ones which focus on (relative) efficiency. However, in the case of CLP, the appeal of having a widespread binary-compatible platform seems to address the difficulty that such systems have and was previously mentioned: scarcity of a widely used (and easy to install) implementation. Just consider that most Web browsers have a built-in Java runtime system, regardless of the hardware/software platform they run under.

The remainder of this article is structured as follows: section 2 gives a formal description of each of the main concepts in AJACS. In section 3 we describe the structure of the Java implementation. Section 4 discusses in more detail how we deal with the subject of exploring a search space. Finally, section 5 makes a comparative balance between AJACS and other approaches and in section 6 we conclude and discuss a few planned developments.

A store is an indexed collection of values. The goal is that, in solving a CSP, several similar stores (w.r.t the number of values) will be created in which the set of values given by the same index across all stores represents a variable.

Since a store is obtained from another one by the application of a constraint propagation step (see below), a store must contain a reference to its ancestor. In the special case of the initial store, the ancestor is undefined. Each line 4 of the store is related with the values of a specific variable.

Values represent the set of integers that is possible for a variable to as- sume. They have three internal representations, a compact one, and two non-compact. Class Value implements compact intervals, class FddValue im- plements non-compact intervals as bit sets and class FdiuValue implements non-compact intervals as a disjoint union of compact intervals.

class if the object removed is one of the extremes of the interval (1), otherwise it will be transformed in a FdiuValue (2). An FdiuValue will be transformed into a Value if the interval union results in only one interval (5) and will be transformed into an FddValue if all the intervals of the union have only one element (3). In all the other cases, the FdiuValue stays an FdiuValue (6). An FddValue will be transformed into a Value if all the elements of the set are contiguous (4), in all the other cases it will remain an FddValue (7).

The Constraint class has an instance variable env, that stores the environ- ment of the constraints. This environment is filled with the constructor method of the class. Method update(s,i), will try to update all the variables env[k], for k /=i. The returned object is of type Status. It can then be a

The Problem class is implemented with three instance variables, an initial store initStore, a list of constraints C, and a list Cv, that is constitute by lists of ConstVar. The constructor new, is used to create a new problem, witch has an initial store defined by the Values, and two empty lists, C and Cv. Method add is used to add constraints to the problem, updating both lists. The update method will be used to propagate the effects of affect a new value to the ith variable of the store s. The propagation is done using all pairs (c, n) of Cvi , and calling c.update(s,n).

There is a total freedom to define any kind of search technique, by imple- menting a Search subclass. This is extensible to strategies. The combination of an appropriate strategy and the next store generation allows us to imple- ment a variety of search procedures. Depth-first, Breadth-first, Best-first are some examples. The most appropriate search strategy depends of the problem. It is possible that what is a solution under some search strategy is not ground.

