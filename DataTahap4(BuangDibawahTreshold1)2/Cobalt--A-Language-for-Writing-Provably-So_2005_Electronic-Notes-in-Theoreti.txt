This section overviews the current status of the Cobalt language. We in- formally describe Cobalt and our technique for proving Cobalt optimizations sound through a small example. More details on the language, the technique for proving soundness automatically, and the implementation of the language and its soundness checker are provided in an earlier paper [9]. Section 2 de- scribes our current and future directions for increasing the expressiveness of Cobalt while retaining automated soundness checking. Section 3 describes related work, and section 4 concludes.

A transformation pattern is sound if all the transformations it allows are semantics-preserving, for all possible intermediate-language procedures. For- ward transformation patterns have a natural approach for understanding their soundness. Consider a statement s transformed to s' in procedure P . Any execution trace of P that contains s' will at some point execute an enabling statement, followed by zero or more innocuous statements, before reaching

In addition to optimizations, Cobalt allows users to write pure analyses that do not perform transformations. These analyses can be used to compute or verify properties of interest about a procedure and to provide information to be consumed by later transformations. A pure analysis defines a new label, and the result of the analysis is a labeling of the given CFG. For instance, a

does-not-point-to analysis can be defined, which results in nodes of the CFG being annotated with labels of the form doesNotPointTo(X, Y ). The new label can then be used by other analyses, optimizations, or label definitions. For example, it can be used to make the definition of mayDef in section 1.2 less conservative in the face of pointer stores.

A forward pure analysis is similar to a forward optimization, except that it does not contain a rewrite rule or a profitability heuristic. Instead, it has a defines clause that gives a name to the new label. The strategy for proving soundness of a pure analysis is a slight variant on the strategy for proving soundness of a forward transformation pattern.

Our current work on Cobalt is geared toward further increasing expressiveness while maintaining the ability to automatically reason about soundness. We are designing a second version of the language, Cobalt V2, that incorporates the lessons we have learned from the first version, Cobalt V1, while significantly enhancing its capabilities. In this section we use a simple example to give a flavor for what Cobalt V2 will look like. We focus on pure analyses, which best illustrate the advantages of Cobalt V2, but transformations can be easily adapted to the Cobalt-V2 style as well.

A pure analysis in Cobalt V1 states under what conditions a node should be annotated with a particular label, which we also refer to as a dataflow fact. The conditions are global in that they talk about all paths in the CFG leading to the node in question. Global conditions are appealing because in one shot they concisely describe the nodes that should be annotated with a given dataflow fact. However, in order to automate soundness reasoning, restrictions have to be imposed on these global conditions, and in Cobalt V1 only one stylized form of global condition is supported. Instead of providing the analysis writer with this one stylized global conditions, the main idea in Cobalt V2 is to provide the analysis writer with stylized local conditions, which can then be combined in flexible ways to achieve many kinds of global conditions.

Another advantage of Cobalt V2 is that the local if-then rules can be seen as flow functions: given some incoming dataflow facts, they determine which outgoing dataflow facts to propagate. This interpretation of if-then rules pro- vides an explanation of Cobalt in terms of concepts already familiar to many analysis writers, thus making the language easier to adopt. Furthermore, because the flow-function formalism matches the commonly used formalism in the analysis community, much previous work on dataflow analysis should adapt seamlessly to Cobalt V2. For example, we will attempt to incorpo- rate into V2 some of our previous work on composing and staging dataflow analyses [8,18] and on deriving interprocedural analyses from intraprocedural ones [1].

The idea of analyzing optimizations written in a domain-specific language was introduced by Whitfield and Soffa [28]. By analyzing optimizations expressed in a language called Gospel, their system can automatically determine if one optimization helps or hinders another one. This information can then be used to determine an order in which to run optimizations. Their framework also in- cludes a tool, Genesis [27], for executing optimizations written in Gospel. The main difference between our work and the Gospel work is in the properties of interest: we explore soundness whereas Whitfield and Soffa explore optimiza- tion dependencies. Despite the different focus, our languages have similarities: both Gospel and Cobalt optimizations consist of a rewrite rule (an ACTION clause in Gospel) guarded by some condition (a PRECONDITION clause in Gospel). The Gospel rewrite rules are more flexible than the Cobalt ones, since they allow moving statements. On the other hand, Gospel has dataflow dependencies as primitives in the language, whereas Cobalt allows the user to define such dependencies with dataflow facts.

We have overviewed the Cobalt project, an approach for automatically proving the correctness of compiler optimizations. Our technique provides the opti- mization writer with a domain-specific language for writing optimizations. Cobalt is both reasonably expressive and amenable to automated correctness reasoning. Using our technique we have proven correct implementations of several optimizations over a realistic intermediate language. Aside from help- ing to ensure the reliability of compilers, Cobalt is a promising step toward the goal of user-extensible compilers, which would allow programmers to easily and safely add unusual or domain-specific analyses and optimizations.

