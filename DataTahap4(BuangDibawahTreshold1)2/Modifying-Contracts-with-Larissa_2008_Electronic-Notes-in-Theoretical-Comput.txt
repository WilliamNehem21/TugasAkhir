This paper combines two successful techniques from software engineering, aspect-oriented programming and design-by-contract, and applies them in the context of reactive systems. For the aspect language Larissa and contracts expressed with synchronous observers, we show how to apply an aspect asp to a contract C and derive a new contract C', such that for any program P which fulfills C, P with asp fulfills C'. We validate the approach on a medium-sized example.

Aspect-oriented programming (AOP) offers facilities to a base language which aim at encapsulating crosscutting concerns. These are concerns that cannot be properly captured into a module by the decomposition offered by the base language. AOP languages express crosscutting concerns in aspects, and weave (i.e. compile) them in the program with an aspect weaver.

All the aspect extensions of existing languages (like AspectJ [7]) share two no- tions: pointcuts and advice. A pointcut describes, with a general property, the program points (called join points) where the aspect should intervene (e.g., all the methods of the class X, all the methods whose name contains visit, etc.). The advice specifies what has to be done at each join point (execute a piece of code before the normal code of the method, for instance).

Most existing aspect languages cannot be used in the context of reactive systems, because they lack the semantic properties needed for formal verification, and the programming languages used for reactive systems are often different from general- purpose programming languages. Therefore, we developed the aspect language La- rissa [1] as an extension to the synchronous programming language Argos. Argos is a hierarchical automata language, based on Mealy machines. It seems a good can- didate as a base language, as it is the simplest language with the parallel structure

Design-by-Contract [14] is a design principle, originally introduced for object-orient- ed systems, where a method is specified by a contract. A contract is a specification in form of an implication between an assumption clause and a guarantee clause. A method fulfills its contract if after its execution, the guarantee holds if the assump- tion was true when the program was called.

Contracts have been adapted to reactive systems by [12]. Reactive systems constantly receive inputs from their environment, and emit outputs to it. Therefore, it seems natural to let assumptions restrict the inputs, and let guarantees ensure properties on the outputs. Additionally, what a program is allowed to do often depends to a large extent on previous occurrences of signals. A convenient way to express such temporal properties over input and output traces are observers. An observer [6] is a program that observes the inputs and the outputs of the program, without modifying its behavior, and computes a safety property (in the sense of safety/liveness properties as defined in [8]). Observers have a single output err, which is emitted to show that a trace is not accepted. They can be expressed in the same language as the program.

Deriving such new contracts appears to be an interesting approach to combine AOP and contracts. However, this seems very difficult for contracts for Java pro- grams and AspectJ, and it is not clear if meaningful contracts could be derived. In this paper, we present a way to derive new contracts for Argos programs and Larissa aspects. The idea is to apply an aspect asp to a contract C and obtain a new contract C', such that if P fulfills C, then Pa asp fulfills C'.

This section presents a restriction of the Argos language [13], and the Larissa ex- tension [1]. Argos is defined as a set of operators on complete and deterministic input/output automata communicating via Boolean signals. The semantics of an Argos program is given as a trace semantics that is common to a wide variety of reactive languages.

The core of Argos is made of input/output automata, the synchronous product, and the encapsulation. The synchronous product allows to put automata in parallel which synchronize on their common inputs. The encapsulation is the operator that expresses the communication between automata with the synchronous broadcast: if two automata are put in parallel, they can communicate via a signal s. The semantics of an automaton is defined by a set of traces, and the semantics of the operators is given by translating expressions into flat automata.

In aspect oriented languages, the advice expresses the modification applied to the base program. In Larissa, we define two types of advice: in the first type, an advice replaces the join point transitions with advice transitions pointing to an existing target states; in the second type, an advice introduces a Argos program between the source state of the join point transition and an existing target state. In both cases, target states have to be specified without referring explicitly to state names.

states of the base program P. T is the state of P that would be reached by executing a finite input trace from either the initial state of P, adv is then called toInit advice, or from the source state of the join point transition, adv is then called toCurrent advice. As the base program is deterministic and complete, executing an input trace from any of its states defines exactly one state.

It is sometimes not sufficient to modify single transitions, i.e. to jump to another location in the automaton in only one step. It may be necessary to execute arbitrary code when an aspect is activated. In these cases, we can insert an automaton between the join point and the target state.

Consider the MFF example from Section 1.2. We now want to make the MFF re-triggerable, meaning that if an a is emitted during several following instants, the MFF continues emitting b.  We do this by applying the aspect ret= (PC,

Therefore, we transform the observers of the contract first into non-determinis- tic automata (NDA), which produce exactly those traces that the observer accepts. We then weave the aspects into the NDA, with a modified definition of the weaving operator. The woven NDA are then transformed back into observers. The obtained observers may still be non-deterministic, and are thus determinized.

After weaving an aspect, the assumption must exclude the undefined part of any program which fulfills the contract. Therefore, it must reject a trace (by emitting err) as soon as there exists a program for which it cannot predict the behavior. The guarantee, on the other hand, emits err only for traces which cannot be emitted by any program which fulfills the contract. Therefore, after weaving an aspect, the new guarantee may only emit err if it is sure that there exists no program that produces the trace.

This paragraph describes the weaving of aspects into contracts in detail, and illus- trates it on our running example. First, Definition 3.1 defines the transformation of an observer into a NDA through two functions, one for guarantee observers and one for assumption observers.

We can now apply an aspect to a NDA. However, a trace may lead to several states. Thus, for each join point transition, several advice transitions must be created, one for each target state. We only give a definition for toInit advice, but the extension to toCurrent advice and advice programs is straightforward.

Existing determinization algorithms can be easily adapted to fulfill these re- quirements. We do not detail such algorithms here, but instead give conditions the determinization for assumptions and guarantees must fulfill. The new assumption and the new guarantee in the example are already deterministic, thus there is no need to determinize them.

We implement and verify a larger example, taken from the Lustre tutorial [11], a controller of the door of a tramway. The door controller is responsible for opening the door when the tram stops and a passenger wants to leave the tram, and for closing the door when the tram wants to leave the station. Doors may also include a gateway, which can be extended to allow passengers in wheelchairs enter and leave the tram.

a model that describes the possible behavior of the physical environment of the controller, i.e. the door and the tramway. These models are expressed as Argos observers, and are given in [15]. We then prove that the controller satisfies the contract, and that the contract in the environment never violates the safety property.

An alternative to this modular approach is to verify directly that the sample controller with the aspects does not violate the given safety properties. One dis- advantage of the alternative approach is that the woven controller may be much bigger than the woven contract. To illustrate this problem, we verified the safety properties using our implementation [9]. The source code of the door controller

example is available at [10]. Verifying the woven program takes 11.0 seconds 1 . On the other hand, weaving the aspects into the guarantee of the controller contract and verifying against the environment takes 3.7 seconds 1 , and verifying that the sample controller verifies the contract and verifying that the environment fulfills the assumption with the aspects takes < 0.5 seconds 1 . Thus, using this modular approach to verify the safety properties of the controller is significantly faster than verifying the complete program. Although the size of the woven controller is not prohibitive in this example, this indicates that larger programs can be verified using the modular approach.

We proposed a way to show exactly how a Larissa aspect modifies the contract of a component to which it is applied. This allows us to calculate the effect of an aspect on a specification instead of only on a concrete program. This approach has several advantages. First, aspects can be checked against contracts even if the final implementation is not yet available during development. Furthermore, if the base program is changed, the woven program must not be re-verified, as long as the new base program still fulfills the contract. Finally, woven programs can be verified modularly, which may allow for larger program to be verified, as indicates the example in Section 4.

