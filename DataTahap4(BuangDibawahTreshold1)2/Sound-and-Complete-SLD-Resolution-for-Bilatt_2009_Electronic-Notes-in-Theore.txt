and probabilistic programs, see [4,11,15,23,26,31]. Their use, however, gives rise to the obvious question of how annotated logic programming compares with logic pro- gramming based on (bi)lattices, see [14,15,21,24,25,28]. In this paper, we contribute to this discussion by combining the two approaches in that we make use of bilattice structures within the framework of annotated logic programs. Specifically, we in- troduce bilattice-based annotated logic programs (BAPs) and establish declarative and operational semantics for them. BAPs, being many-valued and quantitative in nature, enable us to work with statistical knowledge, and with databases which can be incomplete or inconsistent, and thereby introduce monotonic extensions of two-valued negation. But what is particularly important is that they possess all the desirable properties of classical logic programming. Thus, we define monotonic and continuous semantic operators for BAPs and develop sound and complete proof procedures for them based on classical binary resolution.

Finally, we establish sound and complete SLD-resolution for BAPs. As far as we know, this is the first sound and complete proof procedure for first-order in- finitely interpreted (bi)lattice-based annotated logic programs. Compare, for exam- ple, our results with those obtained for constrained resolution for GAPs, which was shown to be incomplete, see [15], or with sound and complete (SLD)- resolutions for finitely-interpreted annotated logic programs (these logic programs do not contain annotation variables and annotation functions) [2,10,14,23,24,25,31]. 4

In this section, we define annotated bilattice-based logic programs. Our definition extends previous definitions on this topic in various ways and, in particular, it ex- tends annotated (or signed) languages (see [2,4,15,23,24,25,31] and others) to the case of distributive bilattices. The languages we introduce allow variables and func- tions in annotations, unlike [14,23,24,25] and others, for example; they generalize some of the propositional lattice-based languages [4,28] to the first-order case, and allow negations unlike, for example, [4,23] and others.

Example 3.1 Consider a binary predicate connected, which describes the fact of existence of an edge in a probabilistic graph. These graphs can be used to describe the behaviour of Internet connections, for example. Then connected(a, b) : ( 1 , 2 )

Example 3.3 Suppose we want to implement a program P which is able to make decisions about delaying and cancelling airport flights without human supervision. Let this program work with databases which are obtained through accumulating information from weather forecasts taken from different sources. These sources may give inconsistent or incomplete information which is collected in the database of P . The first and the second elements of each annotation denote evidence for, respectively against, a given fact. Let B25 from Example 2.3 be the chosen bi- lattice.  Let individual variables x, y receive, respectively, values from the set

In [20], we introduced a semantic operator TP for BAPs, proved its continuity and showed that it computes the least Herbrand model MP for a given BAP P . Detailed analysis of some of the properties of TP can be found in [17]. We define TP next.

Semantic operators defined for many logic programs in the style of [4,6,7,15,31] use only some form of item (i) from Definition 4.2. However, this condition is not sufficient for the computation of the (least) Herbrand models for (bi)lattice-based logic programs, as we see next.

The resolution method was first introduced by Robinson, and was implemented (as SLD-resolution) in two-valued logic programming by Colmerauer et al. A detailed exposition of this can be found in [22], and for many-valued resolution procedures see [12,14,15,23,27,29], for example. Kifer and Lozinskii show in [14] that unlike classical refutation procedures, where only the resolution rule is applied, lattice- based theories need to have four procedures: resolution, factorisation, reduction and elimination in order to be sound and complete. This enriches resolution for many-valued logics which have linearly ordered sets of values, as it was defined, for example, in [12,31]. Some very interesting ideas about the relationship between resolutions for languages with ordered and non-ordered annotations can be found

in [24,25]. Comparing with these papers, we allow variables and functions in anno- tations and adopt the additional refutation rules (which correspond to some rules of [14]) in order to obtain soundness and completeness of SLD-resolution for BAPs. Note that in [14,24,25] only constant annotations are allowed in the language and therefore each logic program becomes finitely interpreted in these settings. We ex- tend all our results to infinitely interpreted programs with functions and variables in annotations. 6 Finally, we establish an operational semantics for BAPs and prove its soundness and completeness.

Note that certain items in the definition of derivation correspond to certain items in Definition 4.2 of TP . For example, item (a) corresponds to item (i) in Definition 4.2, and item (ii) corresponds to item (ii) in Definition 4.2. And, as we have noted before in relation to the definition of TP , all these items serve to reflect the model properties of BAPs captured in Proposition 4.1.

Next, we need to obtain the completeness with respect to correct answers. As in classical two-valued logic programming, it is impossible to prove the exact converse of Theorem 5.7. However, we can extend the classical result that every correct an- swer is an instance of a computed answer to the case of BAPs. The next lemma and associated theorem are straightforward (the proofs can be found in [17]), recall that we allow refutation to work over individual and annotation variables independently.

Further work to be done includes the elimination of annotations from the lan- guage in the same way as this was carried out in [16]. In particular, further in- vestigation of the possible computational effects of the translation of BAPs into non-annotated sorted programs [16] may be interesting. Another field of possible extension of our results is to relate BAPs to probabilistic logic programs, as they were defined and studied, for example, in [1,5] and other papers. Finally, it would be interesting to show how we can extend BAPs to logic programs with interval- based annotations, and thereby establish linear programming for them. Such work

