We study such a relaxed game model using an idealized type-free C-like language. The notion of available move is modeled using a notion of secret similar to that used in models of security protocols, formally represented using names. This leads to a notion of Opponent which is omnipotent but not omniscient: it can make any available move in any order, but some moves can be hidden from it. This is akin to the Dolev-Yao attacker model of security.

We introduce a simple type-free C-like language which is just expressive enough to illustrate the basic concepts. A program is a list of modules, corresponding roughly to files in C. A module is a list of function or variable declarations. An exported variable or function name is globally visible, otherwise its scope is the module. In extended BNF-like notation we write:

The conventional function-call rule (F) is only applicable if there is a function definition in the module. If the name used for the call is not the name of a known function then the normal operational semantics rules no longer apply. We now extend our semantics so that calls and returns of locally undefined functions become a mechanism for interaction between the program and the ambient system. We call

When a non-local function is called, control is transferred to the system. In game semantics this corresponds to a Proponent question, and is an observable action. Following it, all the names that can be transitively reached from public names in the store also become public, so it gives both control and information to the System. Its observability is marked by a label on the transition arrow, which includes: a tag

However, the part of the store which is private (i.e. with domain in N \ P ) cannot be modified by S. So S has no restrictions over what it can do with known names and to known names, but it cannot guess private names. Therefore it cannot do anything with or to names it does not know. The restriction on the continuation are just hygienic, as explained earlier.

These two programs, or rather libraries, implement a modulo-3 counter as an ab- stract data structure, using private hidden state x. The environment can increment the counter (inc) or read its value (get) but nothing else. The first implementation counts up, and the second counts down.

Secondly, and most importantly, we want to show that a meaningful and useful notion of context for the execution of terms can be constructed outside the syntax of the language. This has several advantages. The first one is modularity, as we can define the language and the environment in which its terms operate independently; the principle of functional composition is the consistency check that we need to satisfy for the two to be able to work together. The second one is realism, as real-life languages allow, through mechanisms such as separate compilation and foreign-function interface, programs which are syntactically heterogeneous so they cannot be characterised by the usual notion of context. The third one is simplicity, as we show how it is possible to formulate restrictions on the environment in a way which is not computational but epistemic, resembling the established Dolev-Yao characterisation of context in security. We believe this has the potential to offer a semantic foundation for the study of security properties of programs (such as information flow or tamper-proof compilation) in a way which is less dependent on the vagaries of syntax and more modular.

ried out in compositional compiler correctness [4]. Whereas our point of view is mainly analytic, being interested in characterising arbitrary (if not unrestricted) environments and examine operationally the behaviour of open terms in such en- vironments, compositional compiler correctness is a primarily a synthetic concern, aiming at defining constraints on machine code which allow safe composition be- tween code generated via compilation with code generated in arbitrary ways. We see these two approaches as two sides of the same problem and we believe a better understanding of the relation between them should be studied.

Semantic composition introduces a notion of private names: internal continua- tion names passed around between the two modules in order to synchronise their mutual function calls. As the previous lemma shows, these names remain private throughout the computation. Therefore, in checking bisimilarity for such reduc- tion systems, special care has to be taken so that these private names cannot be captured by external system transitions. This is achieved by selecting (only) these names from the auxiliary set Naux.

