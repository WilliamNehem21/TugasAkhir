made available for COWS. These include a type system to check confidentiality properties [20], a stochastic extension to enable quantitative reasoning on service behaviours [28], a static analysis to establish properties of the flow of information between services [5], and a logic and a model checker to express and check functional properties of services [14]. This is an important advantage over related approaches (see Section 6).

This section presents a survey of SRML and COWS. The overview of SRML gives a high-level description of the aspects captured by its modelling primitives. This is done over a scenario selected from an automotive case study being developed in Sensoria. Due to lack of space, the overview of COWS gives only a glimpse of its semantics, a full account of which can be found in [21].

An Overview of COWS. COWS is a formalism for specifying and combining services that has been influenced by the principles underlying WS-BPEL. It pro- vides a novel combination of constructs and features borrowed from well-known cal- culi such as non-binding receiving activities, asynchronous communication, polyadic synchronization, pattern matching, protection, and delimited receiving and killing activities. These features make it easier to model service instances with shared states, processes playing more than one partner role, and stateful sessions made by several correlated service interactions, inter alia.

This term directly invokes the service factory of the module OnRoadRepair with- out resorting to a discovery mechanism (recall that OnRoadRepair is an activity module). The operation create does not correspond to an interaction supported by the original SRML module but to the factory of the COWS implementation of OnRoadRepair . It has the effect of creating a new instance of the module and initialising it with the sensor monitor partner name sensorMonitor and the fresh instance identifier idsm . In parallel, the sensor monitor sends the collected data by invoking the COWS operation corresponding to the interaction activation provided

A SRML module corresponds to a persistent COWS service that can be instan- tiated by invoking the operation create with the partner name of the module (that coincides with the name of the module, as e.g., RepairService). We assume that names of modules are distinct; this is reasonable because, at the real implementation level, module partner names can be thought of as URIs.

To instantiate a module, a service has to provide its partner name (to allow the created instance to reply) and a conversation identifier (stored in xext id) that will be used for correlating inter-module communication to avoid interference among instances of the same module. To guarantee absence of interference during intra- module communication when a new module instance is created, a fresh conversation identifier idintra is generated. This identifier is necessary because communication among entities of an instance (i.e. components, wires and interfaces) are performed along the same endpoints used by other instances of the same module. The intra- module identifier differs from the external identifier to prevent external entities from directly contacting internal entities. Such an identifier is also used in the communication with Broker during the discovery phase.

F. Chesani, P. Mello, M. Montali, S. Storari, and P. Torroni. On the Integration of Declarative Choreographies and Commitment-based Agent Societies into the SCIFF Logic Programming Framework. Journal of Multiagent and Grid Systems, Special Issue on Agents, Web Services and Ontologies: Integrated Methodologies, 2009. To appear.

