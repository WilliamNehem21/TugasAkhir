rewriting steps of the environments generation by using a cache mechanism which is smarter than standard ones. This work can be seen as a dynamic completion of a set of rewriting rules. This completion increases the number of terms which are rewritten in normal form by the application of a single rewriting rule.

The main problem of FL-systems, compared to an exhaustive description, is the cost of the rewriting step. However, this cost can be reduced by reusing the result of previous rewriting processes. For example, in an urban environment, it is likely that two buildings appearing in different places will be represented by the same geometric object. It is even more likely that a geometric object representing a window will be reused in a lot of different places. It would then be interesting to be able to directly reuse a geometric object without going through the rewriting step if two modules representing elements of the environment are rewritten to the same geometric object. It is possible to implement this directly in the description of the environment. However this method complicates the work of the author of the FL-system and reduces the generality of the model obtained. Another solution consists in using a cache. Whenever a module has to be rewritten, if a key in the cache maps that module then the geometric object associated to that key is used as the result of the rewriting process.

This paper starts by presenting a simplified version of FL-systems. In Sect. 3, the dynamic dependency analysis used is formalized. Some properties of this analysis, relevant to the cache system, are stated in the same part. The following section presents the application of the theory to the practical case of the cache mechanism. Finally, related works and conclusion come in Sect. 5.

As stated before, an FL-system is a conditional rewriting system. It is a structural description of the geometric objects appearing in the environment. Those descrip- tions are shorter than standard descriptions of 3D environments. They are also more generic and allow an easier reuse of previous work. This section proposes a grammar and a semantics for FL-systems.

In this paper, we assume that an FL-system is valid only if any module, whatever the value of the parameters, can be and is rewritten to a unique normal form. A term in normal form is a term composed only of terminals. We also assume that there is no overloading of the module names. This means that a module name is always followed by the same number of parameters.

This section formalizes the method used in order to compute dynamically a set, as big as possible, of terms structurally joinable with the term currently rewritten. The method used is inspired by some work on confidentiality [10]. It is based on the modification of the semantics in order for it to manipulate labeled values. Rewriting a module parameterized with labeled values will then return a term in normal form and a label. This label depends on the labels of the parameters which have influenced the structure of the resulting term.

corresponds to the value used in Sect. 2. The first element of the pair (l) is a label. At the beginning of a rewriting process, a new label composed of a unique identifier is associated to the value of each parameter of the axiom (the initial module serving as starting point for the rewriting process).

This property is useful for the main goal of this paper, which is to develop a cache for the rewriting process of FL-systems. For each module rewritten, Corollary 3.5 enables the cache system to characterize a set, potentially infinite, of modules for which it already knows the structure of the rewritten term in normal form. How- ever, this corollary does not help to determine the values of the parameters of the terminals contained in the term in normal form. This is the subject of the next subsection.

As in Sem1, the rewriting process of a module A(v) returns the characterization of a set of modules S and a term in normal form NT (values in this term are expressions of identifiers). To get the final term in normal form with numerical values, the function eval is called on NT with the value store which maps the identifiers of the parameters of A to their respective value in v. In fact, as shown by Corollary 3.8, for any module in S with values w, the only thing to do to get the rewritten term is to call the function eval on NT with the value store which maps the identifiers of the parameters of A to their respective value in w.

Proof (Sketch) Theorem 3.6 comes from the way the generated label is con- structed. Indeed, all the parameters influencing the selection of the rewriting rule to apply to a module to be rewritten belong to the generated label. As a conse- quence, rewriting the same module, with parameters into which the original pa- rameters project themselves, will apply the same rewriting rule and then the same operations on the parameters. As there is no numerical evaluation of the values the two terms obtained are the same.	 

The main difference between Corollary 3.8 and Corollary 3.5 is that for Corol- lary 3.5 only the structure of the two final term in normal form are identical, whereas for Corollary 3.8 the two final term in normal form are exactly identical.

