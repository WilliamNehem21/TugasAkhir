expensive, (2) automated analyses can only find behaviors that they are designed to find, and (3) the mali- ciousness of any given behavior is application-dependent and subject to human judgment. To remedy these issues, we propose semantic-based program analysis, with a human in the loop as an alternative approach to malware detection. In particular, our analysis allows analyst-crafted semantic predicates to search and filter analysis results. Human-oriented semantic-based program analysis can systematically, quickly and concisely characterize the behaviors of mobile applications. We describe a tool that provides analysts with a library of the semantic predicates and the ability to dynamically trade speed and precision. It also provides analysts the ability to statically inspect details of every suspicious state of (abstract) execution in order to make a ruling as to whether or not the behavior is truly malicious with respect to the intent of the application. In addition, permission and profiling reports are generated to aid analysts in identifying common malicious behaviors.

To understand fine-grained use of security-critical resources, we need to statically analyze the application with respect to what data is accessed, where the sensitive data flows, and what operations have been performed on the data (i.e., determine whether the data is tampered with). Even then, automated malware detection faces three hurdles: (1) analyses may be prohibitively expensive, (2) automated analyses can only find behaviors that they are designed to find, and (3) the maliciousness of any given behavior is application-dependent and subject to human judgment.

In this work, we propose semantics-based program analysis with a human in the loop as an alternative approach to malware detection. Specifically, we derive an analytic engine, an abstract CESK* machine based on the design methodology of Abstracting Abstract Machines (AAM) [20] to analyze object-oriented bytecode. Then we extend the foundational analysis to analyze specific features: multiple entry points of Android apps and reflection APIs. Finally, we describe a tool that provides analysts with a library of semantic predicates that can be used to search and filter analysis results, and the ability to dynamically trade speed and precision. The tool also provides analysts the ability to statically inspect details of every suspicious state of (abstract) execution in order to make a ruling as to whether or not the behavior is truly malicious with respect to the intent of the application. Human-oriented, semantics-based program analysis can systematically characterize the behaviors of mobile applications.

The remainder of the paper is organized as follows: Section 2 presents the syntax of an object-oriented byte code, and illustrates a finite-state-space-based abstract interpretation of the byte code. Section 3 discusses analysis techniques to ana- lyze Android-specific issues: multiple entry points and reflection APIs. Section 4 presents the tool implementation with user-supplied predicates. Section 5 discusses related work, and Section 6 concludes.

Method invocation This rule involves all four components of the machine. The abstract interpretation of non-static method invocation can result in the method being invoked on a set of possible objects, rather than a single object as in the concrete evaluation. Since multiple objects are involved, this can result in different method definitions being resolved for the different objects. The method

A class object is created in Ln.1 and the method object for getExternalStorageDi- rectory 4 is created in Ln.2. Finally, the method is invoked in Ln.3 via the method object externalDir. Since it is a static method with no arguments, the receiver ob- ject being invoked is null. Otherwise, the argument aeco.newInstance() needs to be supplied in Ln.3.

Similarly like the transition rule for function call, the method resolution process is omitted here. The resolution process needs the information class-name and method-name. Also note that the resolution result is a set of public methods m, rather than one. The helper function newM ethodObject takes the newly allocated method object pointer, the set of method definitions in the domain MethodDef, the rest statements, the frame pointer, store, and the stack pointer and returns the successor states. Again, the method object value will be stored into the ret address.

Dynamic taint analysis has been applied to identify security vulnerabilities at run time in Android apps. TaintDroid [6] dynamically tracks the flow of sensitive information and looks for confidentiality violations. QUIRE [5], IPCInspection [8], and XManDroid [2] are designed to prevent privilege escalation, where an appli- cation is compromised to provide sensitive capabilities to other applications. The vulnerabilities introduced by interapp communication is considered future work. However, these approaches typically ignore implicit flows raised by control struc- tures in order to reduce run-time overhead.

In this work, we propose a human-oriented semantic-based program analysis for Android apps. We derive an abstract CESK* machine to analyze object-oriented bytecode. Then the foundational analysis is extended to analyze specific features: multiple entry points of Android apps and reflection APIs. We also describe a tool that provides analysts with a library of semantic predicates that can be used to search and filter analysis results, and the ability to dynamically trade speed and precision. It also provides analysts the ability to statically inspect details of every suspicious state of (abstract) execution in order to make a ruling as to whether or not the behavior is truly malicious with respect to the intent of the application. In addition, permission and profiling reports are generated to aid analysts in identi- fying common malicious behaviors. The technique can systematically, quickly and concisely characterize the behaviors of mobile applications, as demonstrated by case studies in the extended report.

