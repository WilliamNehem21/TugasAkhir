node (i.e., the node in which xef = 1) and all of its descendants, edges e and f must belong to the same path. When making the next branching decisions, we try to expand this path, by branching on a variable associated with an angle that contains either e or f . For each descendant node, we continue this process until the path can no longer be extended, at which point we start a new path. In order to carry out this procedure, it is necessary to store, in each node of the search tree, the information concerning the paths induced by fixed variables. As we show in the next section, this strategy was quite effective in a number of instances.

We now present a summary of our computational results. Experiments were run on an Intel Xeon CPU E5-2603, 1.60 GHz, with 32 GB RAM. Integer programs were solved with CPLEX 12.8 using traditional search with a single thread. The code was written in C++ and compiled with gcc 5.4.0. In all our runs, we imposed a time limit of 10 minutes.

A key aspect of BRKGA is that it adopts a standardized problem-independent encoding for the solutions. Each chromosome consists of a fixed number of random keys (or alleles), which are real numbers over the interval [0, 1). Therefore, all steps of the evolution process are also problem-independent. The connection with each

G. We construct a path decomposition by iteratively adding angles to an initially empty solution. Angles are processed in a greedy fashion, in non-increasing order of their associated allele values. An angle a can be added to a partial solution S if (i ) S has no angles that share an edge with a and that are supported by the same vertex as a; and (ii ) the inclusion of a does not introduce cycles to any elements of the decomposition induced by S. Note that conditions (i ) and (ii ) are analogous to constraints (1b) and (1c) of our ILP model, respectively.

We implemented our BRKGA heuristic using libbrkga [25], a library developed by Silva, Resende, and Pardalos. The evolutionary process is controlled by the following parameters: (i ) fraction of the population consisting of elite individuals; (ii ) fraction of the population to be replaced by mutants; and (iii ) probability that an offspring inherits an allele from its elite parent. We set these parameters to 10%, 20% and 70%, respectively (see [25] for more details on them). We also observed that the heuristic is often able to find a certificate for a given graph G with a very small population and few generations. Therefore, we employed the following strategy. We start with a population of size 2 and evolve it for four generations. If no certificate is found, we restart the BRKGA with a new population containing twice as many individuals and run another four generations. This process continues until a certificate is found or the population size grows above 32.

In this section, we describe the heuristic used when the BRKGA has failed to produce a certificate for Conjecture 1.1. The main difficulty encountered by the BRKGA heuristic is to deal with dense graphs, due to the high number of variables and their symmetry. To overcome this problem, we randomly choose edge-disjoint paths to add to the decomposition, which results in a graph with fewer variables and, hopefully, less symmetries.

In this paper, we presented an ILP model for computing the path number of a graph G and discussed how to use it, together with heuristics and known theoretical results, for verifying Conjecture 1.1 for a large collection of graphs. Applying the ideas discussed in this work, we were able to verify all the 11.716.571 non-isomorphic connected graphs with ten vertices within 35 minutes, using a single thread in a

In future works, we plan to verify Conjecture 1.1 for all the 164.059.830.476 graphs with twelve vertices (a number of graphs approximately 163 times higher than the number of graphs with eleven vertices). Moreover, we plan to compute the path number of these graphs. In another direction, we believe that Model 1 can be used to derive an approximation algorithm for the problem of computing the path number of a graph.

