Graphs are high-level constructs widely used for describing complex structures, like communication networks, neural networks, UML diagrams, microprocessor design, XML documents, biological systems. Graph transformation provides a rule-based modeling of their dynamic evolution. Different approaches have been proposed to formalize graph transformation and to define graph rewriting, summarized for instance in [18].

for a node is given by a list of pairs consisting of a neighbour and the corresponding edge label. If a node has no neighbour then its adjacency list is empty. A subgraph of a graph G is a graph whose node and edge sets are subsets of those of G. A graph

Graph Transformation. A graph transformation rule L ~ R consists of two graphs L and R called the left- and right-hand side respectively, and a correspon- dence between elements of the left-hand side and elements of the right-hand side. This correspondence is provided by some unique identifiers associated to nodes.

in the last step, depending on the mechanism chosen for establishing connec- tions between new and old nodes. Two particular problems are handled at this stage ([12,18]). The first one refers to whether or not noninjective matching is al- lowed. For example, if two different nodes L are matched to one node in the host graph, and one of the two nodes is deleted and the other preserved, will the node in the host graph be deleted or preserved? The second problem concerns the dan- gling edges in the host graph which are unmatched edges with one endpoint deleted by the transformation rule. These two problematic situations are referred to as the identification and the dangling problem respectively. We will see later how we handle these points in our framework.

We denote by Un the set of unmatched partial nodes, by Ue the set of unmatched edges (i.e., the not matched edges whose both endpoints are matched), and by B the set of bridges (i.e., the edges in G not matched by an edge of L, with one end a matched node and the other end not matched).

them. In order to model multigraph rewriting using algebraic terms, we need to handle the context of the multigraph in which the replacement is performed. This is done by a systematic enrichment of rewrite rules with extension variables that help storing the context and applying rewrite steps in subterms. This is a usual method employed when performing rewriting modulo associativity and commutativity [16].

where t1 d t2 is the extended rule associated to t1 d t2, the matching problem is solved using an ACU-matching algorithm, and S is a strategy which reduces a term to its normal form w.r.t. the cleaning and restructuring rules respectively.

