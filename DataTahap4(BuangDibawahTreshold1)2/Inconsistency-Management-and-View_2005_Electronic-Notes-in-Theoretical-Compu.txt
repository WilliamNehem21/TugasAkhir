Inconsistency management in component-based languages is the identification and resolution of conflicting constraints or expectations between the different components which make up a system. Here we present a category theoretical framework for detecting and classifying those inconsistencies which can arise throughout a simulation. In addition, the framework permits us to apply techniques developed for defining database view updates. With these, we can analyse the set of traces of a system with respect to a particular behaviour in a subsystem.

In this paper we present a categorical framework for inconsistency manage- ment and subsystem analysis for system specification languages. We draw on existing work in the field of view updates of databases [10] to construct the framework, which enables us to treat both individual states and individ- ual components as views of the dynamic system. The advantages of this are twofold. Firstly, we can identify and analyse inconsistencies with the aim of toleration. For example, an inconsistency may be persistent, enduring over

When all these facets are placed together, there are several potential inconsis- tencies due to shared variables. Section 6 shows how the framework presented in this paper might allow us to analyse these. These examples can be ex- pressed easily in both Z and VHDL, which means the ensuing discussion is also applicable to this general class of specification languages.

Definition 4.1 The nodes of G, the graph corresponding to a Rosetta sys- tem, are the datatypes (such as integer, bit) declared in the facets, and the edges are the functions, variables and constants declared in each facet. Vari- ables in a facet f1 of type dtype are represented as functions with domain f1-transition-number and codomain dtype, while constants of this type are represented as functions with a null domain and codomain of type dtype. A special terminal node t serves as the null domain.

Definition 4.4 Elements of C are datatypes dtype and those morphisms {mi} with codomain dtype which are intended to be implemented always as an ini- tial algebra. That is, every cocone within C is in fact simply a co-product of ones.

For our examples, the integers are also represented by a cocone within C. The user may, depending on the system, wish to define additional cones and cocones in L and C. For example, we can use limits to ensure that a function between two sets is injective.

These axioms do not capture the fact that facet f2 can see the public variable x from facet f1. The issue of consistency (that these are not in fact separate variables and so must have the one common value in each given state) is discussed in Section 5. In Example 2.1 the only relevant cocones in C are the abstract datatypes f1-transition-number and f2-transition-number.

Secondly, in order for a state to be consistent, any shared variable cannot have multiple values at one time, regardless of how many facets can see this variable. That is, all facets must agree on the value of any variables that are visible. To enforce these ideas of consistency, we define what it means for a trace element R to be consistent.

commute. Resolution for these is more flexible, as it is possible either to add information to the system (for example, adding axioms constraining the possible value of alarmon) or to relax constraints (for example, removing the axiom A0). In practice, such errors often indicate underspecified systems and as such the recommended practice is to further constrain the system. It is worth noting that this is possible because the nature of the problem is such that any functors that form a commuting diagram are also compatible with the other constraints.

Each component, or family of components P , also has a particular view of the entire system and there may be many underlying system state-changes which restrict to a particular state-change of P . The immediate example is where two families of components in a system share no common data. In this case, any system state-change involving only facets in the first family will always restrict to the identity (or no observable state-change) of those facets in the second family.

in the interaction of the facets, rather than the individual facets themselves. Such an error cannot be found by testing the components in isolation, as it only occurs when the facets are placed in an environment which implements these conflicting axioms. If R does not preserve limits and colimits, then the constraints imposed on one facet are mutually exclusive and this can be detected by testing in isolation. We may also use this when trying to assess the suitability of components for different environments.

We have produced a semantics based on category theory for the study of Rosetta and other similar specification languages such as Z and VHDL. By modelling a system as a category, we have abstracted away from individual language issues. By adapting the view update problem, we have enabled a user to analyse components both individually and within a chosen environ- ment, as well as study individual states and the progression between them. Our approach has also made it possible to study inconsistent systems and to identify the source of the inconsistency. In addition, the use of precocartesian and cocartesian morphisms within the same category theory framework has enabled us to compare the choices available in a non-deterministic system.

Further work will consider the possibility of defining degrees of correctness of systems, where certain inconsistencies may be tolerated or circumvented. We will also provide further definitions of morphisms between states, which will enable a user to examine a dynamic system from several different per- spectives. The application of fibrations [9] is a further extension which allows a user to deduce the behaviour of an unknown system based simply on the behaviour defined by a certain perspective or subsystem. By using a common framework we have ensured that the results from these different types of anal- ysis can all be expressed using the same vocabulary, and that any relationships between them will be immediately apparent.

