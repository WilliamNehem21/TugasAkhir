SecSpaces is a data-driven coordination model that supports a tuple-based coordination space extended with mechanisms for controlling and authenticating the access to entries. This is achieved exploiting the notion of (symmetric and asymmetric) abstract partitions inside the space. In this paper we consider one of the limitations of SecSpaces: it is not well suited for supporting the atomic access to more than one partition at once. In order to tackle this limitation we extend the SecSpaces model introducing an operator to combine partitions; output operations can use the new operator to make an entry visible in more than one partition, and data-retrieval operations can use it to access atomically more than one partition. We formally define, in terms of a process calculus, this notion and we demonstrate the flexibility of this new mechanism via examples.

Coordination languages and models aim at providing mechanisms and lan- guages for developing distributed applications in which the description of the internal behaviour of the active components and the description of their inter- dependencies are distinct and separated. In order to support this separation, general interaction models have been developed; one of the main approaches consists of separating the computation from the interaction information, and locating the former inside the active components and the latter inside a so- called coordination infrastructure. This approach is called data-driven coordi- nation when the interaction information is stored inside a shared data space. Linda [3] and its dialects [8,10,7,6] are the most prominent representatives of this family of coordination languages.

The native coordination model does not include any support for control- ling the access to the data. For example, any process able to access the repository is also able to introduce, retrieve and consume any of the tuples inside the repository itself. Recent distributed applications such as Web Ser- vices, applications for Mobile Ad Hoc Networks (MANETs), Peer to Peer Applications (P2P) are inherently open to processes, agents, components that are not known at design time. When the Linda coordination model is ex- ploited to program the coordination inside this class of applications (see e.g. WSSecSpaces [5] for Web Services, Lime [6] in the context of MANETs and PeerSpaces [11] for P2P applications) it is convenient to extend the native coordination model with mechanisms for controlling the access, for authenti- cating the producer/consumer of data, for ensuring the secrecy of information, and so on.

SecOS [9] follows a quite different approach. The access rights are not associated to the agents, but all control information are stored inside the data. More precisely, SecOS supports two forms of locks which are called symmetric and asymmetric. The former exploits the same key to protect and access the information, while the latter uses a pair of keys, one to protect and another

one to access. This two locking techniques can be applied to protect either one single field inside a tuple or the whole tuple. In the first case the used locks are called Field-locks, while in the second one, they are called Object-locks.

A more recent proposal, called SecSpaces [2], continues the approach initiated by SecOS by refining its access control policies. More precisely, SecSpaces refines the idea of object locks while field locks are not modeled. However, this is not a limitative approach because field locks can be easily encoded in our model. For example, in SecOS it is not possible to discrimi- nate between the non-destructive readers and the destructive consumers of a tuple, and there is neither the possibility to avoid a reader of a tuple to re- produce exactly that tuple. In SecSpaces, on the other hand, it is possible to associate to the tuples two different access control information, one to be used for non-destructive read and the other one for destructive input operations. Moreover, when a tuple is accessed in SecSpaces, the reading process receives only the coordination information inside the tuple and not the access control information; thus, it is unable to reproduce exactly that tuple.

SecSpaces essentially permits to associate to the tuples two pairs of infor- mation, that now we call entries. Each pair (p, k) contains a symmetric access information p (called symmetric partition) and an asymmetric access informa- tion k (called asymmetric partition). For both kind of access information a default value is defined, thus processes can also explicitly set only one or none of them. In order for a reader to access an information, it must demonstrate the knowledge of p as well as of k, the access information corresponding the asymmetric partition k. Two of these pairs (p, k) are used; the first one is considered in the case the reader is willing to perform a non-destructive read operation, and the second is considered for destructive input operations.

In this paper we investigate, in the context of SecSpaces, the problem of modifying during the lifetime of the application the access control policies. This is particularly useful in applications where the participants may become able to access new resources because, e.g., they pay for it, or in applications where processes may access the shared resources according to an associated level of trust, and this level may increase or decrease according to their run- time behaviour.

Tha native SecSpaces model is not particularly suited to support appli- cations with this dynamic aspects. For example, if two separated groups of users decide at run time to join in a unique group, it is necessary to explic- itly modify the access control information stored inside the entries currently used from both those groups of users. An alternative solution is to permit the users to exploit more expressive access rights indicating the intention to atomically access the data of both groups. Suppose, on the other hand, that

It is worth noting that these extensions involve only the symmetric parti- tions and not the asymmetric ones. This follows from the fact that the two kinds of partitions are intended to represent different kinds of information. The symmetric partitions are used to limit the access to entries, while the asymmetric partitions are used to authenticate the producer/consumer of an entry. To this aim, the asymmetric partitions are intended to be produced and distributed using off-line mechanisms (such as standard public key infrastruc- tures PKI) and not the mechanisms provided by the SecSpaces coordination model.

The coordination primitives of SecSpaces are the classical ones of Linda: out(e), in(t) and rd(t). The output operator out(e) inserts an entry e in the space. Primitive in(t) is the blocking input operator: when an occurrence of an entry e matching with the template t is found in the space, it is removed and its content is returned. The read primitive rd(t) is similar to in(t), but in this case the entry e is not removed from the space.

Access permissions on entries are expressed by the control fields; in order to discriminate between the rd and the in access permission, entries have two occurrences of control fields, one associated to in operations and the other one to the rd operations. Differently from entries, templates have only one occurrence of control fields that is not associated to a specific operation: they are dynamically associated to the operation the agent is willing to perform (i.e., rd or in).

The asymmetric partition fields, differently from partitions, make it possi- ble to discriminate between the write and the read/remove permission of an entry, simply by exploiting the different needed knowledge to produce or to read/remove an entry. For instance, in order to read an entry having asymmet- ric partition field set to k the process must use k as asymmetric partition field of the template, that can be an unknown value for the producer of that entry (because in only k is needed). Therefore, following the same idea of partitions, properly distributing these values we can assign processes the permission to perform a subset of possible operations on that entry.

performing the access to partition c and to c' until a matching entry is found. On the other hand, in order to produce an entry that should appear in more than one partition, an occurrence of the entry can be introduced in each par- tition in which it should be available. Transactions are necessary because, in order to consume that entry, the in operations should perform atomically the removal of the matching entry from each partition in which it appears.

While it is easy to manage the insertion of new entities in the group, because it can be done simply by transmitting (in a secure way) the secret partition of the group to the entity that is willing to enter (technically this is obtained by scope extrusion, see Section 3.2), it is more complicated to manage the removal of certain entities from the group communication, that is an usual function of group key management systems, because a new partition should be created and distributed to the processes in the group except the one to be removed. A more general problem is to restrict the access to certain entries to a subgroup of entities in the group. Section 4.1 explains how to manage

the group restriction by exploiting the merge operator. Finally, Section 4.2 describes how to combine partitions in order to manage, at run-time, the coordination among two (or more) independent groups of processes. More precisely, we intend to provide a support for those applications that need to publish some data and make them available to more than one group of users, or to control the flow of exchanged data among different groups.

We consider the case where two groups have to be coordinated, the exten- sion to an arbitrary number of groups is straightforward. Let G = {P1,... , Pn} and G' = {P ',... ,P '} be two groups of processes that exploit a shared (and

In order to be as general as possible, we consider that an hierarchical tree describes the security levels of the system, represented by nodes, and their (partial) ordering relation, that is: each node (level) is higher than each child. The model we intend to encode in SecSpaces allows, given a level l, to: i) produce a new datum at the specified level l, and ii) perform a data-retrieval operation that can access datum available either at the level l or at the levels higher than l. In other words, in this system, a datum produced by processes accessing level l are available in l and in all levels l' for which l is higher than l'. In this way, each leaf of the hierarchical tree can access each level in the path leaf-root and may be considered as the level with maximum privileges

