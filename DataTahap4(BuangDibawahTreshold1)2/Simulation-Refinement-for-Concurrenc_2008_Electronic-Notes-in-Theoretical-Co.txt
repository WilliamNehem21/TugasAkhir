In recent years, we extended the theory of Abadi and Lamport (1991) on the existence of refinement mappings. The present paper gives an overview of several extensions of the theory and of a number of recent applications to practical verifications. It concludes with a sketch of the results on semantic completeness, and a discussion of the relationship between semantic completeness and methodological convenience.

Indeed, one of the first problems with concurrent algorithms is the spec- ification. They are usually reactive programs: they start in a rather blank initial state, interact in meaningful ways with their environment, and when they terminate it is often by mishap. In particular they cannot be specified by preconditions and postconditions only.

Overview. Section 2 gives the basic formalism with specifications, execu- tions, behaviours, invariants, strict implementations and simulations, refine- ment functions and forward simulations. In section 3, we discuss a range of (non)atomicity conditions, to be used in section 4 where we verify a lock-free implementation of a row of atomically modifiable variables.

A visible specification K is said to strictly implement a visible specification L if every observed behaviour of K is an observed behaviour of L. In order to prove such a thing, however, we must be able to look behind the scenes. We therefore introduce simulation relations.

It is well-known that refinement functions are not enough to prove all simulation relations. A natural way to prove that one specification simulates another is by starting at the beginning and constructing the corresponding behaviour in the other specification inductively. This idea is formalized in forward simulations [7,22,23], defined as follows.

The minimal correctness assumption for a shared variable is that the cor- rectness of its read and write operations is guaranteed if and only if these operations are performed under mutual exclusion. In other words, chaos can result whenever two processes concurrently access the variable. Let us call such variables unsafe.

In other applications, the ABA phenomenon can be a problem. This prob- lem is avoided in the load-linked, store-conditional primitive LL/SC, which for a shared variable x is described as follows. The variable x gets a field links of type set of process.

When CAS variables or LL/SC variables are offered by the concurrency plat- form, they have simple types like Integer. It is therefore important to imple- ment atomically modifiable variables of arbitrary types by means of CAS or LL/SC variables of simple types. Alternatively, one may look for wait-free implementations of LL/SC variables by means of CAS or LL/SC variables of simple types, e.g. [17].

In [5,6], we considered the problem of implementing a row of atomically modifiable variables of an arbitrary type by means of safe variables of the same type. Given are N processes and M shared variables. Every process needs repeatedly to inspect and modify some variable according to some given argument. Logically the actions on the variables must be independent (done

The system is not allowed to modify arg and out. The only observable variables are out.p for all p. In other words, the observation function removes all other variables. The types Node, Arg , Item and command C are param- eters of the problem. In particular, command C can be used to observe the values of array node via result.

Before dealing with the correctness of this algorithm, we need to model the assumption that the elements of array ar are not more than safe. This means that during a modification of ar[mp], writing by some other process leads to chaos, while reading may return an arbitrary value. We model this by means of a boolean array wr[M + N ], initially false, with the intention that wr[j] indicates that some process is writing ar[j]. We introduce a location 11 where the acting process sets the flag wr(mp) to indicate that it will be writing there. If it is set already, chaos results. In the next instruction, reading of ar[mi] gives a nondeterministic result when wr[mi] holds. The flag at mp is reset after command C(arg, ar[mp], tmp). We thus obtain:

14. Aq0 is preserved because of Aq1 and Aq3. Aq1 is preserved because of Aq0, Aq2 , Aq3 , and Aq4. Aq2 is preserved because of Aq1, Aq3, and Aq4. Aq3 is preserved because of Aq1, Aq2, Aq4, and the new predicate

The purpose of the computation is in the values computed in 13 and trans- ferred in 12 and 14. We expect that the invariants for the values will be forced upon us by the proof of the refinement function. In the concrete algorithm, progress only occurs when the SC in 14 succeeds. We therefore take this event as the linearization point. In view of formula (1), we propose the refinement function

We come back to the private variable tmp used in lines 13 and 14. The programmer can just as well replace tmp by result in 13 and omit the as- signment to result in 14. Then, however, the refinement function fca is no longer correct because result changes in the line 13, which corresponds to a skip statement in the abstract specification. The easiest solution would be to introduce a history variable, say prev, that remembers the previous value of result, and to use prev in the refinement function. The introduction of prev would need a forward simulation.

Sometimes, when matching a concrete specification with the abstract specifi- cation it is supposed to implement, the verifier feels that the abstract spec- ification does a certain nondeterministic step earlier than the concrete spec- ification. In order to get a simulation between the two, they may then feel forced to extend the concrete specification with a ghost variable the value of which is guessed nondeterministically. This is called a prophecy. We give an example in section 5.3 below.

The conditions (epFW) and (epBW) are restricted versions of (F1) and (B1) for forward and backward simulations. Conditions (epTot) and (epCon) serve to connect episodes with nonepisodic periods. One may note that the graph of a refinement mapping is an episodic simulation for every episodic set.

In concurrency, we abstract from time, but not from the order in which phe- nomena occur. This means that the fact that a state remains unchanged during a finite number of steps is not observable. This is formalized by the concept of stuttering. We have therefore to complicate matters by allowing nonstrict implementations and simulations.

According to [1], therefore, specification K is called an implementation of specification L if every observed behaviour of K has a stuttering that is an observed behaviour of L. We thus allow the observed behaviours of the implementation to be slowed down by inserting stutterings. We now also get nonstrict versions of simulations and forward simulations.

This result was strengthened considerably in [16] where we eliminated the conditions of strictness and preservation of quiescence. We summarize the main results here. It may be unexpected, but we have to introduce a history variable that only expresses that time increases forever.

In this theorem, the clocking extension and the stuttering forward simula- tion g are needed merely to control the execution speed. The real power of the theorem is in the eternity extension. In the strict case, we do not even need arbitrary forward simulations. In the nonstrict case, the stuttering forward simulation g is used only to enforce stutterings. In some sense the eternity ex- tension is too powerful. We have come to regard it as a kind of sledge hammer that is to be applied sparingly and with the utmost care.

Semantic completeness must not be confused with methodological conve- nience. In the completeness result, we only used refinement mappings, but no refinement functions and no strict forward simulations. Yet refinement functions and strict forward simulations are the main tools used in practical verifications.

In [13], we extended this repertoire with splitting simulations in which the progress property (F2) of forward simulations is replaced by a condition in terms of states and the step relation. This work needs further extension, because (F2) is an invitation for sloppy reasoning but splitting simulations are not often applicable. Indeed, whenever possible, it would be good to replace even condition (f2) for refinement functions by a condition in terms of the state and the step relation. Work in progress indicates that this can be done when the supplementary properties are given in terms of weak fairness.

In [14], we proved a refinement criterion for atomicity of read-write vari- ables. The proof of this criterion is based on forward simulations, refinement functions, eternity extensions, and the new concept of gliding simulations. These gliding simulations are conceptually easier than eternity extensions, but technically nasty. The atomicity criterion provides a refinement justifica- tion for some older verifications and is also used in the recent verification [15] of algorithm C2 of Haldar and Vidyasankar.

In the course of several verification projects of concurrent algorithms, we were forced to use theorem provers, first NQTHM [2], later PVS [24], primarily for the administration of proof obligations. Using theorem provers forced us to emphasize the specifications that were to be proved. The adoption of refinement was forced upon us when we needed prophecies of the transactions in the serializable database interface of [10].

