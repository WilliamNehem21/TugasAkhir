We describe the design and the present state of the verification tool Augur 2 which is currently being developed. It is based on Augur 1, a tool which can analyze graph transformation systems by approximating them by Petri nets. The main reason for the new development was to create an open, flexible and extensible verification environment. Also, compared to the previous version, Augur 2 will include more functionality and new analysis techniques.

We started with a small tool that reads GTXL files and produces GXL files (GXL respectively GTXL are XML standards for the encoding of graphs and graph transformation systems [14]). Afterwards we faced the constant necessity of adding new features and new functionality. More specifically, we added analysis algorithms for Petri nets [21] based on coverability graphs [15] and backward reachability [1]. Furthermore we established an interface to Graphviz 1 for visualization purposes. We also added the possibility to specify forbidden paths in graphs using regular

The architecture of Augur 1 was strongly oriented towards the concrete task of approximated unfolding of GTSs. This made all changes mentioned above hard to implement and led to several versions of the tool, each with a different functionality. Hence the new version of Augur (called Augur 2) will have a more general and extensible software architecture and will have more functionality concerning analysis and visualization methods.

Another new feature of Augur 2 will be the possibility to work with attributed graphs, i.e., graphs with (integer and string) attributes assigned to nodes and edges. As a future research topic we plan to extend existing analysis techniques accord- ingly. Support for input and output will also be extended, for instance we are currently working on an interface to Agg [19]. Also, we defined a simple pointer- manipulating programming language, which can be translated into graph rewriting, as an additional means of input.

We use hypergraph rewriting where left-hand and right-hand sides can be (almost) arbitrary hypergraphs. Compared to the double-pushout approach our GTSs have to observe some restrictions: especially, the interface graph of a rule must be dis- crete, no nodes can be deleted and rules must be consuming, i.e., at least one edge is deleted. While the last two restrictions are essential for the unfolding-based ap- proach we are following, the first restriction (the interface is discrete) will be lifted in Augur 2.

Since GTSs are in general Turing-powerful, over-approximation techniques are needed for their analysis. In our case we abstract GTSs by Petri nets, which are a conceptually simpler formalism and for which several verification techniques have already been developed. More specifically, the tool is based on an approximated unfolding technique for GTSs, presented in [3]. Compared to a standard unfolding technique we are additionally using folding steps which over-approximate, but guar-

The Petri graph is an over-approximation in the following sense: (i) every reach- able graph can be mapped to its hypergraph component via a (usually non-injective) graph morphism and (ii) the multi-set image of its edges corresponds to a reachable marking of the net. For instance the five edges of the initial graph correspond to the five tokens of the initial marking of the net. More generally there exists a simu- lation relation between the reachable graphs and the reachable markings of the net, obtained by firing enabled transitions. More details can be found in [3,6].

erty, techniques for refining the approximation are available. One such technique is counterexample-guided abstraction refinement [13] which starts from a concrete counterexample found by coverability checking on the Petri net. Another possibility is to use depth-based refinement [6] which constructs an over-approximation exact up to a pre-defined depth in the unfolding. Counterexample-guided abstraction refinement usually results in smaller approximations and faster verification.

The central part of the software design is the concept of algorithms, which are implemented as classes. Each program module working with the common data structures should be realized as an algorithm and new algorithms can be added during the whole life time of the system. As examples of algorithms we mention here different operations on Petri graphs (firing of transitions, building the cover- ability graph, searching for matches of left-hand sides, performing folding/unfolding steps, etc.) and input/output operations (readers and writers from/to different data formats).

Several tools are available for the analysis of graph transformation systems. While some groups [22,9] pursue the idea of translating graph transformation systems into the input language of a model checker, others attempt to develop new specialized methods for graph rewriting. Work from our side goes in this latter direction, as well as [17], which led to the tool GROOVE for verifying finite-state GTS. Properties different from reachability (such as termination and confluence via critical pair analysis) can be analyzed using Agg [19].

In this paper we have summarized our plans for the development of Augur 2, a new version of an analysis and verification tool based on unfolding techniques. Some functionality is already present in the current version Augur 1, furthermore the core part of Augur 2, including the database management, has already been implemented. This tool will enable us to conduct further case studies, which will give us valuable stimulations for the future development of the verification techniques.

