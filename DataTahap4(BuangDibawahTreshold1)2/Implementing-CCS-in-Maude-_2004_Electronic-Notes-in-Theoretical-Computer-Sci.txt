This paper describes in detail how to bridge the gap between theory and practice in a new implementation of the CCS operational semantics in Maude, where transitions become rewrites and inference rules become conditional rewrite rules with rewrites in the conditions, as made possible by the new features in Maude 2.0. We implement both the usual transition semantics and the weak transition semantics where internal actions are not observed, and on top of them we also implement the Hennessy- Milner modal logic for describing processes. We compare this implementation with a previous one where transitions become judgements and inference rules become rewrites, and also comment on extensions to the LOTOS language.

We define the CCS syntax in Maude, which is nearly common for both implementations of the semantics described in the following sections. The only difference is that all the non-constant operators for building processes have been defined as frozen, a new feature of Maude 2.0 used only in our second implementation. We will explain the reason for this in Section 4.2.

We represent full CCS, including (possibly recursive) process definitions by means of contexts. We have defined these contexts together with operations to work with them in a module CCS-CONTEXT (see Appendix A). It includes a constant context used to keep the definitions of the process identifiers used in each CCS specification.

However, we found two problems while working with this approach. 4 The first one is that sometimes new variables appear in the premises which are not present in the conclusion. Rules of this kind cannot be directly used by the Maude default interpreter; they can only be used at the metalevel using a strategy to instantiate the extra variables. The second problem is that sometimes several rules can be applied to rewrite a judgement, but in general, not all of the possibilities lead to an empty set of judgements. So we have to deal with the whole computation tree of possible rewrites of a judgement, searching if one of the branches leads to emptyJS.

The presence of new variables was solved by using explicit metavariables [15], which make explicit the lack of knowledge that new variables in the right- hand side of a rewrite rule represent. The semantics with explicit metavari- ables has to bind them to concrete values when these values become known. Thus, we introduced in the semantics representation mechanisms to deal with these bindings and propagate them to the rest of judgements where the bound metavariable may be present. The modified representation also has rules with new variables in the righthand side, but now they are localized. The strategy that controls the rewriting process (see below) is in charge of instantiating these variables in order to build new metavariables.

The problem of nondeterministic application of rewrite rules was solved by a general search strategy defined at the metalevel. The strategy traverses the conceptual tree of all possible rewrites of a term, built by using the rewrite rules representing the semantics, searching for the term representing the empty set of judgements. If it is found, the transition represented at the root of this tree is a valid CCS transition.

We also extended the semantics implementation by including metavariables as processes (before that, we only needed metavariables as actions). If we start the search strategy with a judgement where the process in the righthand side of the CCS transition is a metavariable, like in P -- a --> ?P, and the search reaches the empty set, then the metavariable ?P has to be bound to one of the one-step successors of the process in the lefthand side, P, after performing action a. By extending the search strategy to find not only the first way to reach the empty set, but all the possible ways, we implemented a function that returns all the successors of a process after performing a given action. This function was then used to implement the Hennessy-Milner modal logic for CCS processes [16], by following the same techniques for dealing with new variables and with nondeterminism as in the CCS semantics, that is, by defining rewrite

Maude 2.0 is the new version of Maude, whose key features are: greater gen- erality and expressiveness; efficient support for a wider range of programming applications; and usability as a key component for developing internet pro- gramming and mobile computing systems [7]. We briefly summarize here the new features used in the following sections.

Another Maude 2.0 feature is the frozen attribute. When an operator is declared as frozen, its arguments cannot be rewritten by rules (we will explain why we use this operator in the following section). Note that using this at- tribute effectively changes the semantics of the frozen operator by disallowing the congruence proof rule.

which is the definition of the diamond modal operator. That is because the variable Q is existentially quantified in the rule condition. But we find a problem with the definition of the box modal operator, because it uses a universal quantifier over the possible transitions of a process. If we want to work with all the possible one-step rewrites of a term, we need to go up to the metalevel. By using the operation metaSearch, we have defined an operation succ that returns all the (metarepresented) successors of a process after performing actions in a given finite set.

We think that the second implementation has several advantages. This imple- mentation is closer to the mathematical, logical presentation of the semantics. An operational semantics rule establishes that the transition in the conclusion is possible if the transitions in the premises are possible, and that is precisely the interpretation of a conditional rewrite rule with rewrite conditions. The first approach needs auxiliary structures like the multisets of judgements to be proved valid and mechanisms like the generation of new metavariables and their propagation when their concrete values become known. This forced us to implement at the metalevel a search strategy that checks if a given multiset can be reduced to the empty set and generates new metavariables each time they are needed. It is the necessity of new metavariables what makes the strategy unavoidable.

Even if we used Maude 2.0 with the previous semantics implementation, we could not use the search command of Maude 2.0, because it cannot han- dle rewrite rules with new variables in the righthand side whenever they are not bound in any of the conditions, and that is what happens in the first implementation [20]. In the second implementation the necessity of searching appears in the rewrite conditions but the Maude 2.0 system solves the prob- lem, because it is able to handle these conditions together with new variables bound in some condition.

There are also differences found in the things that are done at the object level (level of the semantics representation) and at the metalevel (by using reflection). In the first implementation, the search strategy traverses the con- ceptual tree with all the possible rewrites of a term, moving continuously between the object level and the metalevel. In the implementation described in this paper, the search occurs completely at the object level, which makes it quite faster and simpler.

Milner modal logic, in order to compare this framework with ours. Isabelle has been designed as a logical framework and theorem prover, and therefore offers several automatic tools that help prove theorems, and which add a lot of power. In Maude, we only use the rewrite rules that define the semantics and the search that (blindly) uses them, being able to prove both sentences about CCS and the modal logic. Isabelle uses a higher-order logic to metarepresent the user logics. It is in this metalogic where resolution takes places. Due to the reflective property of rewriting logic, we can lower down this upper level, representing higher-order concepts in a first-order framework. In a sense, this comparison can be summarized by saying that we have shown in our CCS ex- ample how higher-order techniques can be used in a first-order framework by means of reflection; that is, reflection provides a first-order system like Maude with most of the power of a higher-order system like Isabelle.

