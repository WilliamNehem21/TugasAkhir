We compare the notions of refinement and compatibility for system models and their variants described as statecharts. Compatibility, in the sense of substitutability, means that a system can be used in any place where the original one was used. We show that existing definitions of refinement and compatibility are orthogonal, if they include an interface extension. Then, we focus on extended compatibility, which means that the system returns to a compatible behavior after some time even if the newly added features are used. Our new result shows under what conditions the usage of a newly added feature preserves behavior. More specifically, we perform a novel kind of elimination of the newly added behavior on a trace level. In this way, we can achieve extended compatibility even if the newly added features use existing input and output events, which is not possible with existing abstractions and refinement concepts.

In this paper, we focus on refinement and compatibility of system models and their variants represented as statechart diagrams. The idea is to start with a base model and then to add small features incrementally by adding new states and transitions. Such iterative and modular development of statechart models can be used for mod- eling variations and optional features, as for instance discussed in [10]. The question addressed here is compatibility of such extensions, i.e. whether the old behavior is preserved when extending a system.

There exists considerable work on semantic refinement, which is the process of adding details while preserving behavior of the original model. Preserving behavior hereby means that the (specification of the) refined module implies the original one. In our setting, we consider observable traces of input and output behavior.

For instance, consider the classical stack example. Assume we have a stack data structure where we add a counter which maintains the number of current elements in the stack. Such a new feature is clearly a refinement as it preserves the behavior, and is also compatible.

In the above example, the Snooze extension changes the control flow in the statechart, but it is easy to see that the extension preserves the original behavior. Existing work essentially separates old and new behavior by distinct, new events. This is however often too limited, as in this example. In many cases, a new feature

For such extensions, which use old and new events, we will show when com- patibility is possible. We develop novel refinements concepts, which eliminate the effect of the newly added features by removing elements from the input and output behavior. Our main result is a precise definition of such eliminations and a new result showing when the behavior is preserved under such elimination. Even if a new feature is used several times, we can show that behavior is preserved after this usage.

Interestingly, the notions of refinement and compatibility are covered in several existing works from quite different research fields using similar, automata-based ar- tifacts. This includes model-based development [13][8][12], model checking and for- mal methods [4][17], object lifecycle modeling [14], and UML modeling [15][10][16], including aspect-oriented modeling [17]. Furthermore, work on interface automata consideres a different notion of compatibility between two automata [1,5,2], focusing on input/output compatibility. The works above however do not capture the notion of compatibility and the results here.

In the following section, we introduce our statechart concepts. Then, we review and compare the concepts of compatibility and refinement for state charts where behavior is added or is even modified in Section 3. In Section 4, we introduce our new concept of refinement under elimination, where newly added features can be used while preserving behavior.

We use the notation event() / action[condition] for transitions. A transition can be initiated by an external event, here event(). It may have a condition and it may have an action that it initiates. This action describes the behavior triggered by the transition. Note that all three labels may be empty. In case the trigger event is omitted, we have an internal transition without an external event, also called spontaneous transition. For further details, we refer to [13][8].

Our semantic model builds on the work in [13][8][12] and employs an external black-box view of the system. It is based on event traces from the outside that trigger transitions. Only the observed input and output events are considered, not the internal states. A possible run can be specified by a trace of the events and the resulting output of the statechart.

In this section, we compare the notions of refinement and compatibility. Compat- ibility means that a new, refined system can be used in any place where the old system was and behaves in the same way. Compatibility is here not just syntactic compatibility wrt syntactic interfaces.

Based on the above definitions, we can now compare these two notions in more detail. The notion of refinement means adding implementation details, which should ideally imply compatibility. This is reflected in the above definition of refinement if an extension does not extend the interface, i.e. the input and output events. As our statecharts are non-deterministic but totally defined for any input, a refinement can remove options but cannot be undefined for some input. Hence, in case of identical interfaces, refinement is simple trace inclusion which implies compatibility in our setting.

We discuss in the following another limitation of the above notion of refinement. The technical problem relates to our approach on chaos semantics. While chaos semantics have been shown to be very valuable to use for stepwise refinements as reduction of non-determinism [13][12], what happens if the statechart gets into chaos state while traversing the extended features.

number of times, the system returns to a compatible behavior after some time. More precisely in terms of traces, this means traces of the extended statechart where new input events occur finitely many times, corresponding to the usage of new features. Then eliminating the new behavior (as defined below) yields a trace of the original one. We will formalize this below.

Regarding the first and second items, we observe that the extended feature is triggered by a new event, hence this can be seen as a refinement as the behavior is not specified before. However, existing definitions of refinement simply eliminate new events from the observed behavior. This is not sufficient for the cases considered here. In the following, we prepare the definition of our new notion of elimination.

In the following, we discuss related work on statechart refinement and related con- cepts like UML state machines and automata models. We claim that our concepts of refinement under elimination are new and can cover a practical class of examples where new features use existing events. Furthermore, we can also cover cases where new features add states which are undefined for some events and hence may lead to chaos behavior.

Earlier work on statechart refinement [13][8][12], which is using similar semantic models of statecharts, has developed several rules for refinement. These are ex- pressed in terms of statechart entities like adding transitions or states. The main results are that refinement follows from simple conditions on the operation on a statechart. For instance, adding a new transition, triggered by a new event, results in a refinement. These results however do not consider compatibility nor covers our notion of extended compatibility. Specifically, the work in [13] uses the notion of refinement as above, but does not cover the form of elimination nor extended com- patibility. The work in [12] is not explicit about eliminating newly added events or messages. It is assumed that in case of undefined events, the statechart goes to chaos state, which in turn does not allow to cover the compatibility after the usage of new features (as developed here).

For related work on UML modeling, the concepts developed in [15] essentially cover basic cases of refining a state into several ones, which is different and not covered here. The work in [10] focuses on modeling the added features as indepen- dent and modular entities, modeled as statechart fragments. Furthermore, feature interactions are modeled as such fragments. For refinement, the concepts in [8][12] are used.

Other work on UML in [16], which builds on concepts for object lifecycle model- ing [14], considers the problem of consistent inheritance and observation consistency, which are similar to our notion of compatibility. As in the work above, they consider abstraction from new input signals to show such properties. The case is however simpler, as they do not consider output events.

There is also recent work on compatiblity for interface automata [1,5,2]. Here, compatibility essentially means that the input and output behavior of two automata are compatible, in the sense that one automata may not send some event when the other one is not ready to receive this event. Refinement is based on alternating simulation (more input, less output) and is shown to preserve compatibility between two automata.

In other works, optional transitions in automata are marked explicitly and are called modalities [2,7]. Here, we strongly rely on a uniform notion of non- determinism. Even though the system model is quite different as discussed, our notion of compatibility is closer to the notion of conformance in [7], based on a sim- ulation relation between the states of two automata. This notion of conformance does however not cover the interfaces extensions by new events, as discussed here.

is preserved in an extended system (by some abstraction), compatibility means that such a system can be used in any place where the original one was used. Specifically, if new features extend the interface, these properties are independent. We have discussed under what conditions refinement implies compatibility. If an extended system produces new output events without explicit usage of new inputs, then refinement does not imply compatibility. In turn, if an added feature uses old input/output events, compatibility does not imply refinement based on simple elimination.

In many cases, added features change the behavior locally, but not the future behavior. To capture this, we have introduced the notion of extended compatibility, which extends compatibility by an additional premise: even if a newly added feature is used, the system returns to a compatible behavior after some time. Our new result shows under what conditions the usage of a new feature preserves the original behavior, even after repeated usage. Roughly speaking, we need to assume that the extension does not interfere with the base model and is triggered by new events.

Our main new result shows when extensions of a system preserve compatibil- ity. This can be used for incremental system development as well as for managing variations of one system, as shown above. In particular, we aim to show in many cases that an extension is compatible with an existing system, which is important in many application scenarios.

The main new technical concept is the elimination of the newly added behavior on a trace level. Essentially, we extract the possible, new behavior and eliminate this from the observable traces. This is possible in our representation using statecharts, as the control flow (state transitions) is very explicit in this model. In this way, our refinement concepts can still be computed from the traversals of the added functionality, and is considerably more precise than existing relations. Whereas existing work on refinement simply eliminates newly added events in an extension (which includes an interface extension), we can handle many practical cases where the extension uses existing events.

We construct such an elimination operation from a single usage of a new feature, following the graphical representation of such a statechart extension. Based on this, we can achieve extended compatibility even if the newly added features use existing input and output events. For this result, additional assumptions are needed to infer that multiple usage of a feature preserves behavior. In particular, usage of the new feature may not modify the state of the existing feature. This leads to many new applications which are not possible with existing abstractions and refinement concepts.

