Service-oriented architecture (SOA) for enterprise systems is a relatively new, but rapidly proliferating paradigm in software engineering. The business functionality of the individual systems is published as services with well-defined interfaces that are specified in a standard, platform-neutral way, such as Web Services Description Language (WSDL). Using elementary services, composite services can be created, or even complex workflows can be orchestrated that are capable of partly or com- pletely automating business processes. Among the several advantages of SOA based systems, we find flexibility, platform-independence and better reuse. However the

of XML serialization is hence composed of the CPU and network demand. In service-oriented applications, the service interfaces, including the message types, are described in WSDL, before the services are implemented. We show that using only the WSDL, and an estimation about the length of the dynamic data structures such as collections, the cost of XML serialization on a concrete system can be estimated if we measure this cost only for primitive types on that concrete system. The rest of this paper is organized as follows. Section 2 summarizes related work. Section 3 contains the explanation and the validation of the cost model of XML serialization. Finally, conclusions are drawn in Section 4, and future work is

The following questions are relevant when we want to take the overhead of XML serialization in a performance model of a service-oriented application into account: How does the cost of serialization depend on the data type of the messages to be serialized? How does the serialization overhead depend on the length of a dynamic data structure, such as an array? How does the length of a string affect the cost of its serialization? How can we estimate the serialization overhead of a known composite data type if we know the serialization cost of the composing primitive data types? To answer these questions, we performed measurements, built a model, and validated the goodness of fit against the measurement results, as presented in subsections 3.1, 3.2 and 3.3 respectively.

The first part of the test cases serializes a specific object 10, 000 times into the same network stream (i.e., sends the serialized XML over the network), and mea- sures the average execution time of the serialization. The measurement is performed

library in Java that provides a high resolution timer using the native timer capabil- ities of the operating system. The second part of the test cases measures the cost of deserialization by serializing an object into the memory, and deserializing it back 10, 000 times. The CPU usage during the test cases is recorded as well, the CPU and I/O cost can be separated this way. The test cases were executed on a PC with Microsoft Windows Server 2003 R2 Service Pack2, a 2.4 GHz Intel Pentium 4 processor and 1 GB memory. The target of the serialization is another PC with Windows XP, and a 3 GHz Intel Pentium 4 HyperThreading processor and 2 GB memory. The machines are connected via a 100 Mbit/s switched LAN. Both the

well. It can be seen that this value is very close to 1, indicating an excellent fit of the linear model. The linearity itself is not a surprising result, but determining these coefficients is important when we try to find a general formula to calculate the resource demand of composite types in subsection 3.3.

.NET Framework can be disassembled (decompiled) using .NET Reflector [3]. We found that the writing of characters to the output stream is buffered at multiple points. In .NET for example, a buffer of 256 and a buffer of 1024 bytes are used. To prove that this causes the more flat line for small string lengths, we wrote a similar code to that found in the .NET Framework. It turned out that removing the 256 sized buffer removes the cut-off point, hence we conclude that the buffering causes the better performance of the XML serialization for small string lengths, and we place the cut-off point at 256. In Java, a similar buffer is used with a size of 128. The lines for deserialization are less steep, and do not contain any cut-off points in

the coefficients retrieved with the multiple linear regression for composite types. For the other three cases (.NET serialization and deserialization, and Java deseri- alization) our starting point is confirmed, namely, that the serialization cost of one additional integer or double value (represented by the appropriate coefficients) is the same, the value is either a member in an array or a field in a composite object.

This observation has a very important practical implication as well. If we want to know the cost of XML serialization or deserialization on a given machine for any composite type containing integer and double fields, it is enough to measure the serialization or deserialization cost of the array for some lengths (in our case 1, 10, 20, ...1000), perform a linear regression, and the resulting coefficients can be reused in calculating the serialization overhead of any composite object.

