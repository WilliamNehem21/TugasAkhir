A type is a finite expression that denotes a possibly infinite set of ground terms. An integral part of any type system is its type language that specifies which sets of ground terms are types. Regular term languages [7], called regular types, have been used widely used as types [25,22,8,24,12,28,15,13,6,18,17,20]. Most type systems use tuple distributive types [22] which are strictly less powerful than regular types. Tuple distributive types are regular types closed under tuple distributive closure.

This paper gives an algorithm to decide if a type expression denotes the empty set of terms. The subtyping problem can be reduced to the emptiness problem in our setting since our language of types is closed under set union, set intersection and set complement. The correctness of the algorithm is proved and its complexity is analyzed. The algorithm works on regular types with parametric type defini- tions [24]. We allow parametric and overloading polymorphism in type definitions. These types are useful both in compilers and other program manipulation tools such as debuggers because they are easy to understand for programmers. Type ex- pressions may contain set operators with their usual interpretations. Set operators allow concise and intuitive representation of regular types.

Though using regular term languages as types allow us to make use of theoret- ical results in the field of tree automata [12], algorithms for testing the emptiness of tree automata cannot be applied directly as type definitions may be parameter- ized. For instance, in order to decide the emptiness of a type expression given a set of type definitions, it would be necessary to construct a tree automaton from the type expression and the set of type definitions before an algorithm for determining the emptiness of an tree automaton can be used. When type definitions are pa- rameterized, this would make it necessary to construct a different automaton each time the emptiness of a type expression is tested. Thus, an algorithm that works directly with type definitions is desirable as it avoids this repeated construction of automata. This is the main contribution of this paper.

The remainder of this paper is organized as follows. Section 2 describes our language of type expressions and type definitions. Section 3 presents our algorithm for testing if a type expression denotes an empty set of terms. Section 4 addresses the correctness of the algorithm. Section 5 presents the complexity of the algorithm and section 6 concludes the paper. Proofs in an appendix can be omitted in the final version of the paper.

conjunctive type expression. As we shall show later, this ensures the termination of the algorithm. Each of the four binary functions returns true iff the emptiness of the first argument is implied by the second argument and the set of type definitions. Tabling any other kind of expressions such as arbitrary type expressions can also ensure termination. However, tabling conjunctive type expressions makes it easier to detect the implication of the emptiness of one expression by that of another because lit(C) can be easily computed given a conjunctive type expression C which

We now address the issue of complexity of the algorithm. We only consider the worst-case time complexity of the algorithm. The time spent on evaluating etype(E0) for a given type expression E0 can be measured in terms of the number of nodes in the evaluation tree for etype(E0).

Another related field is set constraint solving [3,2,16,10]. However, set constraint solving methods are intended to infer regular tree languages as approximations to program properties rather than for checking the emptiness of regular types that are defined by a priori type definitions [24]. Therefore, they are useful in different set- tings from the algorithm presented in this paper. In addition, algorithms proposed for solving set constraints [3,4,2,1] are not applicable to the emptiness problem we considered in this paper. Take for example the constructor rule in [3,2] which states

