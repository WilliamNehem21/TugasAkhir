The purposes of this article are 1) to measure the benefits of the modular ap- proach and its drawbacks in terms of execution time and accuracy using paramet- ric examples and a newly developed benchmark suite for loop invariant analysis, ALICe [18], 2) to present a new technique developed to reduce the accuracy loss when computing loop invariants, namely control path transformers, 3) to evaluate the accuracy gains this new technique and older ones, previously discussed in [2] but not implemented, provide with ALICe test cases and 4) to compare the execu- tion times and accuracies of different tools using either precondition propagation or transformer computation. Namely, we compare ASPIC [8], which is a standard abtract interpretation (AI) tool based on widening and acceleration, PAGAI [13], a SMT-based AI tool, the Integer Set Library, ISL [24], which is a library including a transitive closure for Presburger relations and PIPS [15,14], which is a compila- tion framework using polyhedral sets to abstract transformers and preconditions. The comparisons are difficult because the tools have different input and output languages, but this is dealt with by the ALICe framework.

The outline of the paper is the following. Since the transformer-based approach is unusual, we introduce it briefly in Section 2. We then present a first set of experimental results to explore the accuracy and execution time issues existing with the techniques presented in [2] (Section 3). Accuracy issues encountered can be traced back to early convex hull operations, and several techniques designed to postpone them as much as possible are detailed in Sections 4 and 5. Finally, we measure the impact of these improvements with ALICe (Section 6) and conclude.

The algorithms used in PIPS assume no cycles in the call graph and proceeds as follows. First, each program command S, elementary or compound statement or procedure call, is over-approximated by an affine transformer  S, P , possibly using information about a precondition P of S. This is a bottom-up procedure, detailed in the next paragraphs, because a default value can be used for the pre- condition P when no information is available. Each function is analyzed once and its transformer is reused at each call site. Then, preconditions are propagated from the program starting point using the transformers.

Note that the pure bottom-up approach may be used or not. Since transformers are not computed concurrently but by traversing the AST, information gathered previously can be used right away. The range of a transformer or the condition of a test can be used as a precondition for the next statement to improve the accuracy of  . This explains, for instance, why condition n  60 appears in the transformer of statement n++;.

PIPS has been developed as a compilation framework, able to process large applica- tions interprocedurally [21]. It is important to check that the modularity provided by transformers results in the expected speed improvement and to measure the ex- tent of its negative impact on accuracy. We show firstly that PIPS obtains accurate results in a small amount of time with respect to three other tools, ASPIC, ISL and PAGAI, when dealing with loop nests and procedure calls. We then recall previous experimental results showing a lack of accuracy when dealing with small test cases previously published to illustrate invariant generation algorithms [18].

Since the tools have very different structures and execution times, we report either directly the sum of the User and IO times reported by the time command for ASPIC, ISL and PAGAI, or the times obtained using LOG_TIMINGS for the trans- former and precondition passes of PIPS. In this way, the C parsing part of PIPS is eliminated, as it is for ASPIC and ISL who use internal formats and for PAGAI who uses Clang for parsing, and we compare the execution time of the passes of PIPS that might be replaced by new passes based upon the other tools. Furthermore, the evolution of the execution times for each tool is fully relevant and interesting.

accuracy of various invariant generating tools. Version 1.0 supports three tools, ASPIC, ISL and PIPS, and contains 102 test cases gathered from papers dealing with loop invariant or termination. It uses the FAST format as neutral reference format and provide different encodings of each test case.

The modular approach, as implemented in PIPS, is effective in terms of accuracy and execution time when dealing with large programs using function calls and nested loops [21]. However, it lacks accuracy when computing invariants for small transi- tion systems often targeted in the literature about automatic invariant generation. The accuracy loss is mostly due to convex hulls performed in the transformer space before the transitive closure is approximated, but several integer overflows are also observed.

We are dealing with structured code. A control path set is built for each loop body. When a test or a loop is found, each pre-existing control path is duplicated to take into account the true and false branches, or the loop entrance and skip. This is not performed recursively down the branches or the inner loop bodies. Thus the total number of control path is at most 2k, where k is the number of (possibly compound) statements in the loop body.

P0 is the precondition holding the first time the loop is entered. P2 is obtained after two iterations with different control paths. P+ corresponds to the case when only one control path is used for all iterations; it includes P1, the precondition of the second iteration. Finally, P3+ is the loop precondition corresponding to all the longer control paths with at least three iterations and two different control paths.

The formula used to compute the loop invariant has been unrolled to take into account explicitly up to three iterations. It is possible to generalize this to k steps, with an exponential increase in the number of terms. But we are lacking experi- mental cases justifying this development.

Intermediate computations may generate polyhedra with huge coefficients, leading to arithmetic overflows even with 64-bit integers, because constraint constants are transformed into coefficients by the convex hull operator. Eventually, when an overflow occurs, some constraints may be dropped, and the resulting invariant is less accurate than it should. To address this problem, we added GMP support to some of the PIPS polyhedral operators. This seemingly purely pratical implementation decision allows for a drastical simplification of the polyhedral algorithms because overflow exceptions no longer have to be handled. It turns out that this positively impacts both the execution time (about 6 times faster now) and the comparison between transformer- and precondition-based analyses.

The invariant information is attached to control nodes. If their number is increased, more precise invariants can be found when using polyhedral invariants because the global invariant is the disjunction of the node invariants. Also, the behavior of the program may become easier to analyze because fewer arcs may join the split nodes. However, the presence of new nodes usually increases the analysis time and a trade-off must be found between accuracy and node number.

As pointed out in [2], there are different ways to encode the swap, and the above invariant may be more or less easy to generate. However, regardless of the encoding, the behavior is always periodic. More information is preserved if the transitive closure of the loop transformer is computed as a function of one of its powers [2]. For instance, the square is useful for idempotent function and functions with a period of 2:

Out of 102 test cases, the ALICe benchmark contains 9 test cases that involve non- Presburger invariants and PIPS finds invariant for 82. This leaves 11 cases to inves- tigate further, namely: halbwachs7, henry, metro, microsoftex2, microsoftex5, popeea, realheapsort, realheapsort_step2, subway, synergy_bad and ticket (http://alice.cri.mines-paristech.fr).

Case popeea [22,11] has a non-convex invariant, which can only be found by a convex tool if new control points are added. The heuristics used by ALICe, fsmnodesplit, probably fails to discover a proper node splitting. Case ticket [6] is interesting because it is easy to make the invariant convex. However, the number of control paths is large and the convex hulls used by PIPS lead to overflows when the while loop is unrolled. The algorithm is described as a transition system and the way it may be coded in C is critical to its analysis by PIPS.

These improvements, most of them described in [2], have been implemented in PIPS and tested against the 102 test cases of the ALICe benchmark. The results presented in Section 6 show that three improvements have a positive effect and that PIPS is now about as accurate as more specialized tools such as ASPIC and ISL. So, even though ALICe is a very useful first step, the developement of a general benchmark for research about loop invariants, affine or not, is still an open issue. The choices made for ALICe and its heuristics, fsm2c, should be revisited to support larger test cases and scalability studies. For instance, it would be useful to store C version of the test cases to ease the addition of new cases and to simplify the use of C analyzers such as PAGAI and PIPS.

