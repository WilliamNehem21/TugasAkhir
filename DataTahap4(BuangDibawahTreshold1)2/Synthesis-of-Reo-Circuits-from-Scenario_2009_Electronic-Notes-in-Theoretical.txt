Service-oriented applications consisting of services that may run on large-scale dis- tributed platforms are notoriously difficult to construct. It is well-known that most service-oriented applications rely on a collaborative behavior among ser- vices/components, and this implies complex coordination. Therefore, construction of these applications crucially depends on deriving a correct coordination model that specifies the precise order and causality of the actions of their constituent services. For example, in an online banking scenario, a user can log into the system only after the account information such as the account number and password is verified

Reo [3] is a channel-based exogenous coordination model wherein complex coordi- nators, called connectors, are compositionally constructed from simpler ones. We summarize only the main concepts in Reo here. Further details about Reo and its semantics can be found in [3,7,9].

have two source ends and no sink end. No data value can be obtained from drains since they have no sink end. A synchronous drain can accept a data item through one of its ends iff a data item is also available for it to simultaneously accept through its other end as well, and all data accepted by the channel are lost. An asynchronous drain accepts data items through its source ends and loses them, but never simultaneously. (A)synchronous Spouts are duals to the drain channels, as they have two sink ends.

There are some more operators given in [26]. For example, the negative operator neg designates that the fragment represents traces that are invalid; the ignore operator designates that there are some messages that are not shown within the fragment, which are insignificant and can appear anywhere in the traces; the critical operator designates that the fragment represents a critical region, which means that the traces of the region cannot be interleaved by other event occurrences (on those lifelines covered by the region). Such operators are useful, for example, for verifying system properties and test case construction. We can easily handle the cases for ignore and critical. For neg, the situation is a little more complex, since the behavior in the scenario is not permitted. However, it is still possible to deal with neg using constraint automata. We can first construct the constraint automaton

A message can also be found. A found message is a message whose receiving event occurrence is known, but has no sending event occurrence. This is because the origin of the message is outside the scope of the participants. We can describe

SDs. For example, a message m{0..t} states that the message m is constrained to Our construction can be easily extended to treat timing constraints in UML last between 0 and t time units. Note that the semantics of UML on such messages

is ambiguous and can have different meanings. For example, if the receiver of the message is not ready to accept it in t time units, the message can either be lost or be stored in some queue, waiting for the receiver to process it. Here we assume that the message can always be successfully transmitted to the receiver side and waits to be processed. For such an interpretation, we just need to connect the nodes Ai and Bj which are internal nodes of the synthesized circuit under construction, to the nodes for the sender and the receiver of the message, respectively via a P -

Among our next steps is the automation of the synthesis approach described in this paper. We already have a set of integrated, visual tools to support coordina- tion of components/services, including graphical editors, animation and simulation tools, and model checkers [1,11,19]. We expect our tool to be useful in model-based development of service-oriented applications. Our aim is to aid designers who are interested in complex coordination scenarios by enabling them to use UML SDs

The authors are indebted to the members of SEN3 for helpful discussions. The work reported in this paper is supported by a grant from the GLANCE funding program of the Dutch National Organization for Scientific Research (NWO), through project CooPer (600.643.000.05N12), and the DFG-NWO-project SYANCO.

