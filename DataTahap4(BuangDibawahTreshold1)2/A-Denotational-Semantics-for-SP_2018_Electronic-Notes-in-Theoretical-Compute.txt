The SPARC TSO weak memory model is defined axiomatically, with a non-compositional formulation that makes modular reasoning about programs difficult. Our denotational approach uses pomsets to provide a compositional semantics capturing exactly the behaviours permitted by SPARC TSO. Our approach facilitates the study of SPARC TSO and supports modular analysis of program behaviour.

A system providing the TSO weak memory model can be thought of as a collection of processors, each with a write buffer. Whenever a processor performs a write, it places it in its write buffer. The buffer behaves as a queue, and writes migrate out of the buffers one at a time, and shared memory applies them according to a global total order. Whenever a processor tries to read a location, it first checks its buffer for a write to that location. If it finds one, it uses the value of the most recent such write; otherwise, it looks to shared memory for a value. Because of buffering, it is possible for writes and reads to be observed out of order relative to the program order.

So far we have dealt with program orders as an abstract concept. However, there exist program orders having no TSO-consistent orders. Consider, for example, the program order {x = 1 < x = 2}. We therefore restrict our attention to program orders for well-defined programs in the simple imperative language given below. These program orders are defined in Section 3.2.

Our denotational semantics has two components. The first associates to each program a set of TSO pomsets, which serves as the abstract meaning or denotation of the program. This component is described in Section 3.3. The second associates to each pomset a set of executions, which describe its input-output behaviours. This is described in Section 3.4.2.

We now turn our attention to flushing. The intent is that a thread can flush arbitrarily many of its writes at any point in its execution. Thus, the pomsets associated with flushes for a buffer L are the prefixes Lj of L, and the resulting buffers are the remainders of L. We use split(L) to denote these prefix-suffix pairs:

In the first family of pomsets, we flush the writes immediately after inserting them in the buffers, while in the second, we flush the writes to x and y after reading y and x. In the third family, we flush x right after placing its write in the buffer, but fall into the false case of the conditional after reading some value v /= 0, thus taking the skip branch. In the fourth pomset, we read y after placing the write x := 1 in the buffer, but before it gets flushed, and both threads fall into the skip branch.

We show that our denotational account of TSO in Section 3 is sound and complete relative to the axiomatic account of Section 2. Soundness implies we capture only behaviours permitted by the axiomatic account; completeness implies we capture all behaviours permitted by the axiomatic account. Because all TSO-consistent orders are contained in TSO-consistent total orders and can be obtained by weakening these, it is sufficient to show that we capture all TSO-consistent total orders. We identify total orders and lists.

Other approaches to semantics for weak memory models mostly use execution graphs and operational semantics. Execution graphs [1,2] serve to describe the executional behaviour of an entire program, an inherently non-modular approach. We see our denotational framework as offering an alternative basis for program analysis, compositional and modular by design. Boudol and Petri [3] gave an operational semantics framework for weak memory models that uses buffered states. Jagadeesan et al. [8] adapted a fully abstract, trace-based semantics by Brookes [4] to give a fully abstract denotational semantics for TSO.

