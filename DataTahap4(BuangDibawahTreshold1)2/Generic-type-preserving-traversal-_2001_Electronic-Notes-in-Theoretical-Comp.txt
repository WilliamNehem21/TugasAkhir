A typed model of strategic rewriting with coverage of generic traversals is de- veloped. The corresponding calculus o ers, for example, a strategy operator 2( ), which applies the argument strategy to all immediate subterms. To provide a ty- peful model for generic strategies, one has to identify signature-independent, that is, generic types. In the present article, we restrict ourselves to TP|the generic type of all T ype-Preserving strategies. TP is easily integrated into a standard many-sorted type system for rewriting. To inhabit TP, we need to introduce a (left-biased) type-driven choice operator & . The operator applies its left argu- ment (corresponding to a many-sorted strategy) if the type of the given term ts, and the operator resorts to the right argument (corresponding to a generic default) otherwise. This approach dictates that the semantics of strategy application must be type-dependent to a certain extent.

To describe traversals in standard rewriting (without extra support for traver- sals), one has to resort to auxiliary function symbols, and rewrite rules have to be used to perform the actual traversal for the signature at hand (usually one rewrite rule per term constructor). Generic traversal primitives support an important dimension of genericity in programming. In [19], for example, generic traversal strategies are used for language implementation: Algorithms for free variable collection, substitution, uni cation and others are de ned in a generic, that is, language-independent manner by suitably parameterised generic traversals.

In Section 2, we shortly recall untyped strategies including primitives for traversals. In Section 3, we discuss standard many-sorted types for type- preserving strategies. 2 In Section 4, we provide a type system which includes a generic strategy type TP for generic type-preserving strategies. To this end, we also need to introduce a type-dependent choice operator to mediate between many-sorted and generic strategies. In Section 5, we discuss implementation issues. In the course of the article, we show that our type system for strategies is sensible from a strategic programmer's point of view. We envision that the presented type system disciplines strategic programs (employing generic traversals) in a useful and not too restrictive manner. We also show that generic type-preserving strategies can (more or less) easily be implemented. The article is concluded in Section 6.

The work of the author was supported, in part, by NWO, in the project \Ge- neration of Program Transformation Systems". The ideas developed in the article took shape during a visit of the author to the Protheo group at LORIA Nancy. I am particularly grateful for the interaction with my colleague Joost Visser|in Nancy and in general. Many thanks to Christophe Ringeissen who shared an intensive and insightful ELAN session with Joost and me. I want to thank David Basin, Hora- tiu Cirstea, H el ene Kirchner, Claude Kirchner, Paul Klint, Pierre-E  tienne Moreau, Christophe Ringeissen, Jurgen Vinju and Eelco Visser for discussions on the subject of the article. Finally, many thanks to the anonymous workshop referees for their constructive criticism.

We set up a rewriting calculus very much inspired by ELAN, the -calculus, and system S. We are very brief regarding explanations, examples, and details of the semantics. Some basic knowledge of strategic rewriting (as found in [2,21,5]) is a helpful background for reading the present article.

2 As for terminology, we use the term \type" even for types of many-sorted terms (as opposed to the term \sort"). The term \type" is more common in the context of type sy- stems. Also, we might easily go beyond just many-sorted terms, and deal with polymorphic datatypes.

There is a form of strategy t ! t0 for one-step rules to be applied at the root of the term. We adopt some common restrictions for rewrite rules. The left-hand side t determines the bound variables. (Free) variables on the right- hand t0 side also occur in t. If substitutions are applied, then we assume

New strategy combinators can be de ned by means of an abstraction me- chanism which we call strategy de nitions. Similar mechanisms are provided by ELAN, system S and Stratego. A de nition '( 1;::: ; n) = s introduces an n-ary strategy combinator '. An application '(s1;::: ; sn) of ' denotes the instantiation s[ 1 := s1;::: ; n := sn] of the body s of the de nition of '. Strategy de nitions can be recursive. 4

The rst two strategies are generic. try (s) applies s, but behaves like Id if s fails. repeat (s) repeatedly applies s as often as possible. The strategy ip-top is speci c in nature. It reconstructs the strategy of the same name introduced earlier in Example 2.1. The reconstruction illustrates the use of try.

Let us take a closer look at the generic traversal primitives to apply a strategy s to all children (2(s)), or to some child (3(s)). The operators 2( ) and 3( ) are de ned like in system S. For brevity, we do not consider the hybrid operator 32 from system S which applies a strategy to one or more children.

We extend our syntax for strategy types , namely we add one case for ge- neric types . In this article, we only consider one particular generic type, namely TP representing the type of all T ype-P reserving strategies. In [10], we also consider type-changing strategies. Our grammar of types is extended as follows:

Now that we have typed generic traversal operators, the question is how we inhabit TP. So far, we only have two trivial constants of type TP, namely Id and Fail. We would like to construct generic strategies from rewrite rules. It turns out that we lack a construct to perform inhabitation in a typeful manner. We also need to relax the typing rules for some existing combinators in order to make it easy to apply generic strategies in a speci c context.

One approach to the inhabitation of TP is to use a generic default (initially Id and Fail, but not just these) if the many-sorted strategy is not applicable for typing reasons. We might attempt to turn, for example, a rewrite rule ` into a generic strategy using the forms ` + Id or ` + Fail. This is not a good idea since the operator + is concerned with choice controlled by success and failure. What we are looking for in the context of quali cation of speci c strategies to become generic, is a di erent form of choice. We need a type- dependent form of choice where the speci c strategy is chosen if the actual term is covered by its domain. Otherwise the generic strategy (serving as a

Example 4.2 We recall the solution to the rst problem from the introduc- tion as given in Example 2.3. The original (Stratego-like) solution is not typeable because a many-sorted strategy, namely nat; N ! succ(N ), is pas- sed to stoptd which expects a generic argument. We recover typeability by the following rede nition of traverse(I):

w.r.t. success and failure. This separation makes it explicit where we want to become generic. There is no hidden way how speci c ingredients can get generic accidentally. Without separating the two kinds of choice, strategies get too easily (say accidentally) generic and typeable.

type of a congruence strategy (cf. rule [congr]) is dictated by the well-formed context which is used to lookup the sort of the function symbol at hand. The types of 2(s) and 3(s) are uniquely de ned as TP. The type of s1 &  s2 is the type of s2.

To eliminate the typing premise determining the type of the many-sorted strategy s1 in s1 & s2, the following approach is appropriate. We statically perform an elaboration step which follows the very scheme of the type jud- gement for strategies, but transforms strategies. We want to turn strategy expressions of the form s1 & s2 into s1 :  & s2 where we propagate the strategy type  of s1 explicitly as type annotation. During strategy applica- tion, the annotation can be used to organise the choice. The updated rules for strategy application will be shown in a second. The relevant elaboration rule takes the following form:

We also do not want to determine the type of the term at hand at rewriting time (as it is the case in the original rules for  &  ). In some way or another, we should tag terms with types. We show a replacement for the positive rules for & . The replacement relies on the elaboration described above, and on tagged terms in strategy application.

As we can see, the static typing context is not needed anymore. Instead the reduction of hs1 :  &  s2it :  relies on the annotations  and  . To be precise, the context is de nitely not needed for the semantics of & anymore, but the combinators 2( ) and 3( ) deserve an additional comment. As these combinators descend into terms, the types of the subterms of a term also need to be known. Some options to accomplish this knowledge are the following:

be de ned in a module dedicated to TP. Then, we need to overload  & for all sorts in the signature at hand in the same way as the ordinary many- sorted strategy combinators. Each application of the combinator  &  in a compound strategy refers to a speci c sort, and hence static elaboration is not needed to determine the type of the many-sorted strategy in a type- dependent choice. The rewrite rules for 2( ) and 3( ) could be generated by a pre-processor in similarity to the dynamic typing and implosion + explosion approach in [4]. One can also leave it to the rewrite engine to implement 2( ) and 3( ). As for type-dependent choice, the rewrite engine is in fact the more obvious choice. Here we assume that the rewrite engine has access to the type of the given term. To summarise, the described simple implementation is ena- bled by some fundamental concepts of ELAN, namely parameterised modules (needed for sort-indexed overloading of strategy combinators), and a general

There is no previous work on statically typed generic strategies in the narrow context of rewriting. In [4], dynamic types [1] are employed to cope with some generic (traversal) strategies in ELAN. A universal datatype any is used to represent terms of \any" sort. For that purpose, a parameterised module any[X] is o ered which can be imported for any sort which is subject to generic programming via the any datatype. The module o ers an injec- tion and a projection to mediate between any and the terms of sort X. As for generic traversals, there are explode and implode functions to destruct and construct terms (say to access the children of a term). The actual implementa- tion employs a (transparent) pre-processing approach to obtain a many-sorted instantiation of the interface of any[X] according to X, and program schemes

Another topic for future work is the integration of our results into existing rewriting calculi. The -calculus [5] provides an ambitious rewriting calculus. Part of the  -cube is typed (but not generic traversals expressiveness) [6]. One of the challenging properties of the  -calculus is that rewrite rules are higher-

[21] E. Visser and Z.-e.-A. Benaissa. A core language for rewriting. Electronic Notes in Theoretical Computer Science, 15, September 1998. In C. Kirchner and H. Kirchner, editors, Proceedings of the Second International Workshop on Rewriting Logic and its Applications (WRLA'98), Pont-a-Mousson, France.

