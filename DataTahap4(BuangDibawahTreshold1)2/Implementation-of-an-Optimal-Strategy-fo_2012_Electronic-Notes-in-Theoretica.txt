One of the most automatic debugging techniques is Algorithmic Debugging because it allows us to debug a program without the need to inspect the source code. In order to find a bug, an algorithmic debugger asks questions to the programmer about the correctness of subcomputations in an execution. Reducing the number and complexity of these questions is an old objective in this field. Recently, an strategy for algorithmic debuggers that minimizes the number of questions has been released. This new strategy is called Optimal Divide and Query and, provided that all questions can be answered, it finds any bug in the source code with a minimum set of questions. In this work we discuss the implementation of such a strategy in different algorithmic debugging architectures.

Debugging is often a hard task. Specially when we try to debug source code that we have not written ourselves or that we wrote a long time ago. When this happens, we usually know or remember what our functions or methods do, but we hardly remember how they do it. In these cases, the technique Algorithmic Debugging [10,11] can be very useful because it allows us to debug programs

without the need to inspect the source code. The technique automatically generates a series of questions and uses the answers of the programmer to find the location of a bug. The questions are always whether a given result of a method or function activation with given input values is actually correct. Therefore, the programmer only needs to know what a function is supposed to do (instead of how) in order to debug it.

The debugger points out the part of the code that contains the bug. In this case || should be &&. Note that, to debug the program, the programmer only has to answer questions. It is not even necessary to see the code.

The internal algorithm used by algorithmic debuggers to decide what nodes of the ET should be asked is crucial for the performance of the technique. In [6], we conducted a series of experiments to compare the performance of different algorithms, and Divide & Query (D&Q) and its variants [11] showed the best performance. In that work, we also proved that the variant Optimal D&Q asks (as an average) an optimal number of questions.

The rest of the paper has been organized as follows. In Section 2 we recall and formalize the strategy D&Q and its improved version Optimal D&Q. Then, in Section 3 we discuss the implementation of Optimal D&Q. Finally, Section 4 concludes.

In this section we formalize the strategy D&Q [10] focussing on the improved version by Hirunkitti [4]. We start with the definition of marked execution tree, that is an ET where some nodes could have been removed because they were marked as correct (i.e., answered YES), some nodes could have been marked as wrong (i.e., answered NO) and the correctness of the other nodes is undefined.

In [6], Optimal Divide & Query was introduced as a new variant of D&Q that optimally divides the remaining tree with every question. It is presented in Algorithm 2 where wn represents the weight of node n (i.e., the weight of the subtree rooted at n), and win represents the individual weight of node n (i.e., the weight of the single node n without taking into account its descendants). It is important to note that, in this algorithm, the weight of a subtree with root n is computed with the sum of the individual weights of all nodes in the subtree, but the individual weight of n is only added if it is marked as Undefined. In the case that it is marked as Wrong, then it is ignored.

Along this section, we will assume the existence of an object that imple- ments the strategy Optimal D&Q. We will refer to this object with the usual reference this, and thus, we can access the methods of this object as usual (e.g., this.node.getState(), this.moveNodeToChild(indexChild), etc.).

Fix MET architecture. Where the MET is never pruned; and thus nodes have a state attribute that indicates to the strategy whether this node can be buggy or not. Here again, it is assumed that all the nodes of the MET are already generated when the first question is asked.

the information from nodes. For this, we use a pointer that can point to any node in the MET. This pointer is the attribute node of the strategy that initially points to the root of the MET and can be moved to any node by means of the method selectNode. This method (selectNode) implements the Optimal D&Q strategy presented in Algorithm 2, and it uses 7 different methods during its execution:

The loop traverses the MET in a top-down manner in order to find the optimal node. We start the search in the root node and in each iteration we descend to one of its children. Once we have selected one child, the other children are discarded. Lines (8) to (22) determine this child and stores it in variable indexChild. If this child does not exist (e.g., the node is a leaf) then Lines (24) to (26) return the node itself as the optimal node.

Traditionally, the weight of a node represents the number of nodes of the subtree. In our approach the weight of a node represents the probability that the subtree of this node contains the bug. This probability is computed with method calculateWeight shown in Frame 2. This method does not take into account the wrong root when computing probabilities because it is not necessary to answer it again to determine that it is wrong.

In an architecture where no nodes are pruned and different debugging sessions can use the same MET, a debugging session can end up with multiple Wrong nodes. This means that, in order to maintain the standard behavior, the last node marked as wrong should be the initial (root) node of the strategy (Line (1) of selectNode method in Frame 1). However, some debuggers [9,1,3] allow the user to make manual debugging sessions. In these cases the user can select a node whose subtree already has a wrong node. The algorithm of the standard architecture is not prepared for METs with multiple wrong nodes, but this situation can be easily handled adding Lines (15) to (19) in Frame 3 between Lines (14) and (15) of method selectNode in Frame 1. These lines make the algorithm to restart the search in the subtree whose root is already marked as wrong. In order to do this, we use the wrong node as the new root of the algorithm (this is done implicitly), we update both weight and weightFather to the weight of the new root, and we re-execute the external

In addition, when the user marks a node as unknown, this node should be removed from the MET. But, because we do not prune these nodes, they remain in the middle of the tree. This means that the getNodeChildren method should be modified in order to exclude Unknown nodes. Moreover, it should also be modified to exclude Right and Trusted nodes that also remain in the

MET. This is performed by the new version of getNodeChildren shown in Frame 3, that stores in attribute children the children of the current node. If one of its children is an Unknown node, it is ignored, but the children of this Unknown node are also added. After collecting the children of the current node, we can use moveNodeToChild and moveNodeToFather methods in Frame 3 to move from father to children and vice versa. Finally, having correctly updated the weights of Right, Trusted and Unknown nodes, the calculateWeight method can be implemented as the one in Frame 2.

An algorithmic debugger can only ask questions to completed nodes, that contain not only arguments and initial context but also final context and return value. Therefore, method getNodeChildren(int numChildren) should exclude those nodes that are not completed yet. The implementation of this method is similar to the one from Frame 3 changing Lines (2) and (4) (see Frame 4). Note that both approaches can be used together using a && operator in Line (2) and changing Line (4) by else if (!node.isCompleted()

