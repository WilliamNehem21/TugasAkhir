The first positive test case tests the true value of the whole formula caused by the proposition p (i.e., moving); the second test case tests the proposition q. There is only one test case for false value of the formula and it is contributed by both propositions; notice that this test case is the same for weak and for strong evidence. A similar exercise could be repeated for all the flight rules appearing in the specification for any given scenarios. Using the methodology presented above to compute test cases with UFC coverage guarantees would be an improvement per se with respect to the current testing methodologies (currently, test cases for Europa 2 are generated manually and without coverage guarantees). But our approach can be refined further, to the benefit of plan developers: in the next section we present how the execution of tests can be automated by translating temporal formulae into

Traditionally, the problem of verifying planning domains has been approached by translating the planning domain into an appropriate formalism for a model checker, where verification can be performed either in a direct way, or by generating test cases, with the exception of [9] where a planning techniques are suggested for the generation of tests. This latter work differs from ours in that different coverage conditions are considered, and tests are not generated from flight rules (i.e., tem- poral specifications). Some issues remain to be investigated. For instance, we do not have a methodology to deal with the translation of nested temporal operators into planning goals (but we did not find nested temporal operators in the flight rules analysed). We are currently working on this issue and on a software tool to automate the methodology: we are implementing a parser from temporal patterns encoding flight rules to LTL trap formulae using the definitions in Section 2.2, and finally to NDDL code.

