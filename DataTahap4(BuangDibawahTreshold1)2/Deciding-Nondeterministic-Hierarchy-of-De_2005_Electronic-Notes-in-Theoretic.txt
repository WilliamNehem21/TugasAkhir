The problem appears somewhat easier if the input automaton is deter- ministic. Deterministic tree languages form a proper, but effective, subclass of all recognizable tree languages (we can determinize an automaton in EX- PTIME [13], whenever possible). Computing the level in the deterministic hierarchy can be accomplished by reduction to an analogous problem for word automata [12], see Remark 2.4 below. Note however that the level of a deter- ministic language in a nondeterministic hierarchy can be arbitrarily smaller than in the deterministic one 5 .

Given a tree t in T (A), there is a unique run of A^ on t. This defines parts of the tree accepted by different strongly connected components (SCCs) of A^. We can have an automaton without acceptance conditions that calculates in each node the state of the unique run of A on t. The automaton we want to construct will be a product of this automaton and (1, 2) automata, one for each SCC of A^. The role of the latter automata will be to check if all paths of the run of A^ that stay forever in a given SCC are accepting. The composition of these automata will give us (1, 2) automaton recognizing T (A).

Hence, the part of the run of A on t staying in C is a tree were the only splits (states with l and r arrows pointing to elements of C) are in nodes with states of rank n. If the run is accepting then in this part there can be only finitely many occurrences of states of rank n as n is odd. A (1, 2) automaton can recognize whether in such part all the paths are accepting. It can wait till there are no more splits and then use (1, 2) condition to recognize that

