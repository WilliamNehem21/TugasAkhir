Goanna is an industrial-strength static analysis tool used in academia and industry alike to find bugs in C/C++ programs. Unlike existing approaches, Goanna uses the off-the-shelf model checker NuSMV as its core analysis engine on a syntactic flow-sensitive program abstraction. The CTL- based model checking approach enables a high degree of flexibility in writing checks and scales to large code bases. In this paper, a new approach to pointer analysis for C is described. It is detailed how this technique is integrated into the model checking approach in order to perform interprocedural analysis. The performance and precision of this approach are demonstrated using a case study.

C++ programs, which differs from other static analyzers in that it uses model checking techniques to perform static analysis [12,21,20]. Using model check- ing to conduct static analysis allows a straightforward specification of desired program properties in Computation Tree Logic (CTL) [2]. Furthermore, if a specification is violated, a counterexample leading to the error is automatically generated, which is a valuable support for locating and fixing the defect.

Many static analyzers perform intraprocedural analyses without taking the effects of procedure invocations into account. Even though many defects can be found using intraprocedural analyses, other failures occur through the use of procedures in the wrong program context. A procedure may expose a correct local behavior but may still lead to a false program execution due to unexpected input values, for example. This paper describes an approach to interprocedural analysis of pointers for C based procedure summaries. Using procedure summaries allows to capture the influence of a procedure call on the program state and reuse these results whenever the corresponding procedure is called. In our approach, summaries are computed based on an intraprocedural pointer analysis.

Goanna is a static analyzer for C and C++ programs. This section first describes the general approach of Goanna, before the construction of models and the translation into the input language of NuSMV are detailed. NuSMV is used as the core analysis engine. A more thorough description of Goanna and the underlying intraprocedural analysis framework is given by Fehnker et al. [12].

In presence of aliasing, a memory location can be accessed through dif- ferent variables. In combination with structured types, this leads to complex problems to be tackled when analyzing pointer dependencies. Our under- lying memory model abstracts from the physical representation to a coarse symbolic model but does not handle complex pointer arithmetic. The pre- sented algorithm computes for each variable and each program location the sets of memory locations a variable can alias, its so-called points-to sets. The approach comprises the following steps:

In the memory abstraction used, memory locations are represented by sym- bolic values, which are induced through a number of constructs in C. A call of malloc(), for instance, allocates memory and returns an address, or memory locations may be introduced by parameters. Two special purpose labels are in- troduced: one for the address NULL, which is typically assigned to uninitialized pointers, and * to denote addresses resulting from operations not modeled in our abstraction. Nested pointers such as int** are currently not supported. The set of all memory locations in a procedure f is denoted by Mf . The

In the reduction step, references are resolved to distribute information from actions applied to non-owning variables to other aliases. Without this step, the effects would only be visible to the owning variable. As a result, all aliases correspond to the same memory labels. If we write v->v' in a structure, then

This section details how to capture the behavior of functions with respect to pointer analysis using procedure summaries based on the intraprocedural points-to sets. Moreover, it describes our approach of combining aliasing infor- mation with procedure summaries in the intraprocedural analysis framework of Goanna. This allows us to detect invalid memory accesses that result from procedure calls by extending the existing intraprocedural model described in Sect. 2.

We have evaluated the performance of the intraprocedural pointer analysis and the summary-based interprocedural analysis by analyzing some source directories of OpenSSL 0.9.8d. These directories contain between 1,633 and 28,916 lines of C code. This section first describes the applied checks and then presents the analysis results.

the evaluation, we found some files for which the poor performance results was caused by extensive use of preprocessor macros, which introduced large numbers of auxiliary variables. The analysis of the files in the crypto/engine directory, for instance, was slowed down by one file eng padlock.c, on which 70% of the overall runtime was spent.

Despite these downsides, we showed that the developed approach can be successfully applied to large code bases. We have also applied the approach to parts of the Firefox codebase, for which the slowdown was also linear. Applying Goanna to the complete source code of Firefox did not produce meaningful results due to the extensive use of C++ features such as templates. The performance drawback could be minimized by optimizing the XPath al- gorithm, which would lead to competitive runtimes. In practice, runtimes can be significantly decreased using incremental analysis. Only those program fragments affected by a modified summary have to be reanalyzed. Typically, this involves only small parts of the program.

Many defects found in real software are related to false handling of pointers. This is especially true for languages such as C, which allow arbitrary pointer arithmetic and have no built-in mechanisms for pointer safety. It turned out that static analysis based on purely syntactic properties of a program allows an efficient analysis but also generates large numbers of false warnings. We

The implementation smoothly integrates into the existing framework. The intraprocedural analysis alone improves the existing intraprocedural analysis framework. It integrates well with incremental analyses. The interprocedural NuSMV model is an extension of the original model. One of the advantages of using model checking for static analysis is the automatic generation of counterexamples. With interprocedural analysis using summaries, this cannot be achieved easily. During the analysis of a function, no information about the intrinsics of called functions is present. Hence, different techniques have to be developed to tackle this problem.

