and evolution semantics of the considered formalism elements. The solution of models is made possible by using a set of non-specialized solving engines used to generate automatically formalism-specific reusable solvers. This paper explains how formalisms can be created in SIMTHESys by showing how three widely known modeling languages are successfully implemented.

The paper is organized as follows. After a brief review of the SIMTHESys approach to multiformalism modeling in Section 2, in Section 3 the exponential transition based family of formalisms is introduced. Section 4 describes the imple- mentations of SPN, TFCQN and GNQN. Section 5 presents the solution engines for the mentioned family. Conclusions and future work are described in section 6.

[1] to Mobius	[3] [6] [18] [4] [5] and OsMoSys	[8] [21] [16] [20] [9] (that are the closest references for this research) proved the value of a formal (multiformal- ism/multisolution 6 ) approach to modeling and evaluation of systems. SIMTHESys is a new framework for the definition and analysis of performance ori- ented formalisms. It is based on the explicit definition of both syntax and semantics of all atomic components of a formalism and on a set of non-specialized solving en- gines, that are used to generate automatically and transparently (multi)formalism- specific reusable solvers.

A SIMTHESys formalism is a formal description language. It is defined in terms of its elements, that are its atomic components. Each element is characterized by a set of attributes called properties and a set of descriptions of its dynamics called be- haviors. Properties can be constant characteristics of the element, state information (useful for the solution of the model) or results (obtained by the solution process). Behaviors describe the semantics of the element (the effects of their presence in the model on the other elements, e.g. its execution policy, if applicable). A behavior is an algorithm implemented in a high-level programming language (that currently follows the syntax of Java) 7 . Every formalism has an additional container element that represents a (sub)model written in that formalism and whose properties in- clude global characteristics of a model. Formalisms are described by the Formalism Description Language (FDL).

A model is the description of a system being evaluated, written according to a for- malism. Models can be hierarchically composed, to separate reusable (sub)models of its subsystems, even if written in different formalisms 8 . Models are described by the Model Description Language (MDL) documents.

The SIMTHESys framework has been developed to be integrated with the DrawNET tool [11][12] and the OsMoSys framework. DrawNET is a formalism definition environment that provides data structures and the automatic creation of graphical user interfaces for the rapid development of performance evaluation tools. OsMoSys is a framework that supports the definition of formalisms and models to allow the use of multiformalism and multisolution techniques.

The family of formalisms presented in this paper are labeled as Exponential Event Formalisms (EEFs). In these formalisms, primitives represent entities capable of generating events. Such events (that can be used to represent the firing of a PN transition, or the end of the service in a queue) are characterized by the fact that they occur after an exponentially distributed time.

The solution engines expose a behavior Schedule that is used by the implemen- tations of the InitEvents behavior to define what must be executed whenever an event occurs. The code associated with the event updates the state of the elements to reflect the evolution of the model. The scheduled behavior updates the state of the affected elements of the model. For example a transition can move tokens among the places to which is connected by using specific arcs behaviors.

State Rewards return the mean value of a function of the state of the model. They are used to compute the mean length of a queue, or the mean number of tokens in a PN place. Each EEF define a set of state rewards by implementing three behaviors. Firstly, CountStateRewards returns the number of state rewards that a model is able to expose. Secondly, ComputeStateRewards computes the value of all the rewards associated with the model in a given state. Finally SetStateRewards allows the solution engine to return the computed indices to the model.

Impulse rewards are used to compute measures related to the firings of events, such as the throughput of queues or PN transitions. Each impulse reward is char- acterized by a unique reward name, and is defined by implementing two behaviors and by passing appropriate parameters to the previously defined solution engine Schedule. A formalism should list the reward names of all the impulse rewards by implementing the behavior ListImpulseRewards. Every time an event is scheduled, the formalisms pass to the Schedule behavior the name of a reward that should be

TFCQN is a variant of QN in which every queue has a finite number M of places for waiting customers (Finite Capacity). Only a single arc can leave a queue (Tandem network) 10 . If there is no room for a customer in a queue, the input stations stop serving until a place is available. This occurs as a result of a blocking mechanism.

The three most common are: Blocking After Service (BAS), Blocking Before Service (BBS) and Repetitive Service (RS). In the first case, the customer who does not find room in the destination queue is processed anyway and it is blocked right after service completion. In the second case, the source queue is blocked before processing the customer. In this case, either the customer enters the server (BbsSoQueue) or not (BbsSnoQueue, as a result the number of places in the queue is set to M-1 until it is unblocked). In the third case, if the destination queue does not have room left, a customer who finishes the service is reinserted in the same queue to be served again later (RSqueue).

TFCQN is implemented either by defining a generic queue object with an associated property that specifies the kind of block or by defining a different element type for each blocking policy. We chose the second alternative because it simplifies the coding of the behaviors. The next step to consider is to identify the kind of (discrete) event corresponding to the termination of a service provided to a customer.

The InitEvents behavior is defined in Algorithm 1. The object oriented like dot notation is used to name the behaviors and the properties associated to the elements of a model. The external object solver refers to the solution engine, that exposes the method Schedule to enable the events. This method has four parameters that identify: i) the rate of the exponential distribution that characterizes the firing time,

ii) the piece of code that must be executed when the event occurs, iii) the name of the impulse reward that is associated to the event, and iv) the increment of the reward. The notation q.id is used to identify the name of the queue. Since every queue has an associated throughput, the name of the queue is used as the name of the corresponding reward. Due to the fact that throughput counts the number of services in a queue, its corresponding reward value is always 1.

The IsActive behavior is identical for all the types of queues, and simply checks if the length of the corresponding queue is greater than 0. The CanSend behavior is used to check whether a station can start its service or it is blocked because it has reached the full capacity of the destination node. In an RSQueue, the behavior always returns true (because the service is always enabled, and it is re-issued if the destination node is full). Regarding the other types of queue, the CanSend behavior is specified in Algorithm 2.

The RSQueue algorithm checks if the destination queue is empty before sending the customer there. If the destination is full, it reschedules the same service. This is implemented in Algorithm 7. Note that instructions for the rescheduling are not necessary (this is automatically done in the InitEvents behavior).

Both algorithms use the Push behavior of the connecting arc to send the cus- tomer to the next station. The Push behavior in turn calls the AddOccupancy(1) behavior of the queue at the other end of the arc, which is implemented in the same way for all the queue types. The AddOccupancy(c) behavior adds c customer to the length of each queue.

Due to the EEF property, it is sufficient for the simulator to reschedule all the events after each firing. The simulator repeats the analysis for a fixed number Nruns of runs. Each run is executed until a global time Tmax is reached; statistics are collected only after a transient time of fixed length Ttrans. The parameters Nruns, Tmax and Ttrans are constants defined by the modeler. A snapshot of the initial state is taken, and after each run has finished, the snapshot is used to start a new simulation from the same initial state. The execution of each run calls the InitEvents behavior to find all the enabled events, and then draws an exponentially distributed sample for each of them. The event with the shortest sample is executed, and time is advanced accordingly until Tmax is reached. At the end of all the simulation runs, statistics are collected and returned to the model using the SetStateRewards and SetImpulsReward behaviors.

In this paper three example formalisms have been implemented by a new approach to multiformalism modeling. The SIMTHESys approach is based on the use of the concept of behavior to define formalisms and their semantics independently of the solver used. The three examples exploit the same solution engines and demonstrate the advantages of this approach. This research is the first detailed description of how a formalism and its solver can be implemented in SIMTHESys. Research in this area aims to better understand the possibilities opened up by the behavior mechanism. This could be achieved by implementing more formalisms linked to different families, solution engines and enhancing the usability of the behaviors by designing a dedicated scripting language. Other interesting perspectives are given by further investigation into multiformalism models and their application to different real world problems.

