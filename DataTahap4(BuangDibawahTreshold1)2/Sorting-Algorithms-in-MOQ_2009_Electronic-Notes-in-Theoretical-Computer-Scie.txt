for the scope of this paper. Section 4 will be an overview of the current state of the MOQA implementation and Section 5 will discuss the overhead of two algorithms written in this implementation. The two algorithms are insertion-sort and quicksort.

between data in its structures instead of the algorithms specifying what the relation is. Section 5 will show that the impact of this is a higher space cost and for the average-case time of quicksort, an increase in constant values. This paper will then conclude with a summary, Section 6, and an outline of future work in this area, Section 7.

The partial order in MOQA-JAVA is the LPO(Labeled Partial Order) class and the subsets created and returned by the MOQA functions are instances of the SubLPO class. The LPO class is described by the OrderedCollectionSet interface and the SubLPO class is described by the OrderedCollectionSubset interface. Both these interfaces are described by the OrderedCollection interface. Each value, which can also be described as a label, and any data associated with it, is stored in an in- stance of the NodeInfo class, which can then be added to one or more LPOs. When a NodeInfo is added to a LPO, the LPO creates a Node object to contain this NodeInfo. A Node has a one-to-many relation with a LPO and has package-level visibility so any algorithm outside the MOQA-JAVA package is unaware of the existence of the Node class. The purpose of the Node class is to record the relation between a Node and the other OrderedComponents within the OrderedCollection that directly contains the Node. Note that both the Node class and the OrderedCollectionSubset class in- herit the OrderedComponent interface. The OrderedComponent interface describes the type of object that can be in an OrderedCollection. A Node is not bound to the NodeInfo it initially contains. Due to the nature of some of the MOQA func- tions, such as product and relative delete, NodeInfos may be swapped between

After comparing the insertion-sort pseudo-code to the MOQA-JAVA imple- mentation of insertion-sort, it is clear that MOQA provides another level of abstraction.  With MOQA-JAVA there is no explicit reference to the posi- tion of the next element to be inserted correctly amongst the elements al- ready sorted, whereas in the pseudo-code the explicit reference to this posi- tion is the variable j, the index in the array of the next item to be inserted. In MOQA-JAVA an Iterator over the OrderedCollection to be sorted returns the next element for insertion.  The first two elements returned by the It-

erator are the parameters for the first product. Product removes these el- ements from the specified OrderedCollection oc, the OrderedCollection to be sorted, and connects the greater of the two above the lesser within a new OrderedCollectionSubset that is added to oc before being returned. After this for each product, a NodeInfo in oc is removed from oc and connected above the spec- ified OrderedCollectionSubset to form a new OrderedCollectionSubset that replaces the one previously added to oc. After being connected above the previ- ously returned OrderedCollectionSubset, the NodeInfo is pushed into its correct position in this newly created OrderedCollectionSubset, which is then returned by product.

in its traversal and manipulation being more intricate than that of an array. The current implementation is one way of storing this additional complexity. So for this implementation, what is the price of this extra information in the average-case time of an algorithm? It may be more useful to examine this question with a sorting algorithm that is not so simplistic in its approach to sorting.

Refactoring MOQA-JAVA. While the encapsulation of the partial order data structure within the OrderedCollection class is important, the indirect ma- nipulation of it through the current API is not flexible enough. This and other refactoring will take place, along with an extension to MOQA-JAVA that will include more specific partial orders types.

