identity, usually ending up in the possession of one or more secrets [12]. Security protocols consist of only a few messages but amazingly they are very hard to get right. For example, the detection of a flaw in the 3-message Needham-Schroeder public key (NSPK) protocol took roughly 17 years [7].

e.g. FDR [8] and OFMC [2]; and ii) theorem proving, e.g. the Isabelle inductive method [12] and Coral [13]. Model checking tools are capable of determining whether or not a (finite abstraction of a) protocol is valid. The verification process usually takes a few seconds and, in the case of unsatisfiability, a counterexample (a protocol attack) is output. Theorem proving may be slower, but has a wider range of application, as demonstrated by [13].

We are interested in a problem related to verification but far less explored: the correction of faulty security protocols. A flawed protocol is a mal-formulation. Mal-formulations is central to theory refinement. They often become evident by the appearance of a failed proof attempt, possibly yielding a counterexample. The analysis of this evidence often holds the key to the completion of proofs and for the correction of a faulty model.

non-trivial message parts shared in its runs, and using heuristics, it analyses these observations in order to both diagnose a possible fault and suggest a candidate patch (Section 5). We also present the methodology used in the invention of our patching method (Section 6). Finally, we have run a test on our method with encouraging results (Section 7). The test set includes 21 faulty security protocols borrowed from the Clark-Jacob library [5]. In addition, we also report a large number of results to validate phase iii) using the AVISPA tool.

the worst case, to be no longer susceptible to the same counterexample. For this, we must again use a model checker or a theorem prover. In this paper particularly we have used the AVISPA tool, a model checker, to deal with the first and the third phase of the full verification cycle. In the following sections we will explain a method for patching interleaving-replay attacks in more detail.

In this attack, the spy has accomplished an interleaving-replay attack: after monitoring a (possibly partial) run of a protocol, he has replayed in another different run of the protocol one or more messages, impersonating a friendly agent. As we can see such runs of the protocol interleave in execution. If the corresponding agent does not have any mechanism to distinguish who originated an inward message or whom such a message is intended for, or cannot associate with that message a time line, then she will be deceived. Often, the messages that the spy selects for replay contain one or more secret distributors.

