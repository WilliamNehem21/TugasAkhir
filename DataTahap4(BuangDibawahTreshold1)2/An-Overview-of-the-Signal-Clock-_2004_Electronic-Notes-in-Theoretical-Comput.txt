triggered by the presence of at least one of its input variable, say y. The clock of the component corresponds exactly to the set of instants where y is present: This set is by extension called the clock of y, denoted by y in the Signal context. Note that the potential absence of variables is now justified a posteriori: A variable has the double identity of a data-flow conveyer and (via its clock) of a sporadic event used to control behaviors like in the imperative paradigm.

Clocks are fundamentally the main way the programmer has to specify the control of its specification 7 , indicating the instants when some computations take place. Clocks are very widely used in Signal: Any object related to a computation (e.g. an expression, a data dependency) is associated a clock

operators (e.g. y ^= x ^+ z). But clocks of variables are not sufficient: The synchronizations induced by the under-sampling when operator involve the value of a boolean variable, y := x when c states that y is present iff x and c are present and c has value true.

The initial step is to build all partition trees: Any clock variable is root of such a tree or of a tree reduced to a root. Then the algorithm iterates the following process: 1. choice from synchronizations of a syntactical definition for some clock variable h3 of the type h1 op h2 s.t. h1 and h2 belong to a tree a'; 2. computation of def (h ) and insertion of the sub-tree a whose root is

Sub-tree Properties A sub-tree a contains a set of condition-clocks from which other clocks can be defined (we call it its context) and must respect two principles: 1. any clock h in a is such that var(h) belongs to this context (locality criteria); 2. a dft finds all variables of var(h) before h (this ensures a triangular shape for the clock system, i.e. the respect of dependencies in computations).

If a single tree is obtained the specification is declared endochronous, its mas- ter clock being the root. The algorithm progresses by computing definitions h1 op h2 s.t. h1 and h2 belong to the same tree. If no such expression can be found in synchronizations, another compilation module applies them some rewriting rules. The used rewriting system is ad-hoc and in particular incom- plete. If no convenient expression appears after rewriting, the calculus stops and the specification is declared not to be endochronous (while it may be so).

This paper gives an overview of the Signal compilation process under its main aspects. Before entering into technical details it focuses on fundamental notions that must be understood to fully appreciate principles of the clock calculus. It explains in particular what are clocks, how they are formalized as sets of instants but used as propositional variables to encode the combinational boolean part of specifications, and what is the difference with the encoding into Z/3Z (traditionally misunderstood).

