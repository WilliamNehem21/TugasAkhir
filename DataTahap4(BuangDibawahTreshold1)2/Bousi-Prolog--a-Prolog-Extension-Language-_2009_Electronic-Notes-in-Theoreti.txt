Fuzzy Logic Programming integrates fuzzy logic and pure logic programming in order to provide these languages with the ability of dealing with uncertainty and approximate reasoning. There is no common method for this integration, though, most of the works in this field can be grouped in two main streams. See for instance: [9,14,18,2,21,28], for the first line, and [4,5,6,7,25] for the second one. A possible way to go, if we want to grapple with the issue of flexible query answering 4 , is to follow

The evaluator module implements the weak unification algorithm and the weak SLD resolution principle, which is the operational semantics of the language. Weak SLD resolution is implemented by means of a meta-interpreter [27]. The next two sections are devoted to precise the details of this implementation. The evaluator

=1. When solve(A, DA) succeeds, but the approximation degree DA is less than 1, not(A) also succeeds with approximation degree D = 1 - DA. If it is the case that solve(A, DA) fails, not(A) succeeds with approximation degree D = 1.

The first one is represented by the theoretical works [6,7] and [5], where the concept of unification by similarity was first developed. However they use the cum- bersome notions of clouds, systems of clouds and closures operators in its definition. From our point of view, these notions endangers the efficiency of the operational semantics which uses them, because they are costly to compute. The main prac- tical realization of this line of work is the fuzzy logic language LIKELOG [4]: it is mainly implemented in Prolog using the aforementioned concepts and rather direct techniques.

features, such as the ability for implementing user defined operators and working with modules, are not covered. In the future we want to add these missing features to our language. Also we want to improve certain modules of our system, such as the parser, and to incorporate new non standard features. Regarding to this last point, we are working for adding to the system: a repository of fuzzy ontologies and an automatic generator of fuzzy ontologies in the line of the one proposed in [29].

On the other hand, the operational semantics used by Bousi~Prolog is imple- mented by means of a meta-interpreter. This is a cheap solution from the implemen- tation point of view but expensive from the point of view of the efficient execution. In order to solve the efficiency problem, we have investigated how to incorporate the weak unification algorithm into the Warren Abstract Machine. Some preliminary results for a pure subset of Prolog can be find in [16]. Also we want to develop this line of work to cover all the present and future features of Bousi~Prolog in a more efficient implementation.

