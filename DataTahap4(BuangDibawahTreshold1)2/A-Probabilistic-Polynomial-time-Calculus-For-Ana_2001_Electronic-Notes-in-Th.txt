Definition 2.4 [6] An oracle Turing machine is a Turing machine with an extra oracle tape and three extra states qquery, qyes and qno. When the machine enters state qquery control passes to the state qyes if the contents on the oracle tape are in the oracle set; otherwise, control passes to the state qno.

Definition 2.6 Let M be a poly-time oracle Turing machine. We can view M as a probabilistic poly-time Turing machine if we randomly choose an or- acle from the space of oracles that can be queried in the time bound of M . More precisely, let M be an oracle machine running in time bounded by the polynomial q. Since M (x) can only query the oracle with at most q(x) bits, we have a finite space of oracles that run in time bounded by q. Call this space

Definition 2.16 Let P be a process expression and let T be a term. If T is not in the scope of any input operator, we say that T is an exposed term. Similarly, let [T1 = T2].R be a subexpression of P . We will say that [T1 = T2].R is an exposed match if it does not appear in the scope of any input operator.

Definition 2.23 Let P and Q be process expressions and cp(|n|) be a channel. We say that P is bound by cp(|n|) in Q if cp(|n|)(x).D[P ] is a sub-process of Q for some variable x and some context expression D[ ].

Definition 2.24 Let C[ ] be a context and P a process. Then, C[ ] is minimal for P if every free variable of P is bound in C[P ] and each channel to which P is bound in C[P ] binds a free variable of P .

of P as being not exposed). Since we know that P will only contain terms that are substitution instances of terms from the set {T1,..., Tm}, we can associate each term Ui from P with an algorithm MTi' where Ti' is the term of which Ui is a substitution instance. By theorem 2.9 we have that MT computes, in polynomial time, the value to which Ti' evaluates on some input. Since Ui

evaluation time. So, our pTM evaluates each exposed term it encounters by evaluating the associated algorithm at the values specified by the substitution instance. Evaluating a match simply involves evaluating the two terms and writing either the 0 or outer-evaluating the bound process.

cost of outer-evaluating P on a pTM is a function of both the length of P and the costs of evaluating each exposed term that the pTM encounters. The length of P is given inductively in defn. 4.8 as length(P ). Assuming that

We can only guarantee such a property in the case that n is large enough as most any security system can be defeated by brute-force searches if the search-space is small enough. So, even though a context (i.e., a brute force search over, say, keys) may distinguish two process families (that is break one protocol and not the other), once we up the security parameter sufficiently, that context will get defeated.

