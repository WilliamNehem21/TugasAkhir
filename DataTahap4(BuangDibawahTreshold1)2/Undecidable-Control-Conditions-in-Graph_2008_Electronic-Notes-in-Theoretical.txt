Since diagrams and their manipulation have become increasingly popular in different domains, the field of graph transformation has become more and more important in the last years. Many applications for graph transformation can be found, with UML, MDA, software refactoring, and logistic processes being the most recent. Various graph transformation approaches, which differ in particular in the kind of graphs considered or the way in which graphs may be transformed, are proposed in the literature. For an overview, see the three-volume Handbook of Graph Grammars and Computing by Graph Transformation [14,5,6].

When trying to compute the semantics of a transformation unit, the termina- tion of the derivation process is essential. In [13] it is shown that it is generally undecidable to determine whether graph rewriting terminates. In the meantime several methods of restricting graph transformation systems in order to tackle the termination problem have been investigated. Concrete termination criteria based on the number of nodes and edges have been presented in [1]. A general approach based on measurement functions can be found in [2]. This work is extended and formalized in [4]. The termination criteria proposed in the latter two have been implemented as termination checks in the AGG system.

For this paper we want to consider a transformation unit which models an ar- bitrary Turing machine. As graph transformation approach we choose the double- pushout variant introduced earlier. For the graph representation of the tape a string graph is used. For technical reasons it is also necessary to be able to de- termine whether the head is positioned on the leftmost resp. rightmost cell. For this reason we introduce two special cells labelled D (indicating the left end) and (indicating the right end). The head can never be placed on these special cells.

Control conditions regulate the control flow along rule applications and use of im- ported transformation units. Various kinds of control conditions and the interre- lations between them are studied in [11]. Three kinds of control conditions have proved to be particularly useful in numerous examples: regular expressions, as- long-as-possible, and priorities. In this section, we will study these kinds of control conditions under the aspect of decidability.

Iterating a star-free regular expression over rules with as-long-as-possible yields a semi-decidable control condition. It is in general not decidable because the halting problem for Turing machines is only semi-decidable, and that is what the variant of the Turing machine simulation given above encodes. It is still semi-decidable since star-free regular expressions over rules are decidable.

Priority control conditions where a higher priority is given to some imported transformation unit are in general not decidable. Consider a rule r that replaces G() with some graph H distinct from G(). We want to know whether (G(),H) is in the semantics of the control condition r < PCP. If SEM (PCP) is empty, we may apply r, and the answer is yes. If SEM (PCP) is not empty, then it contains (only) the pair (G(), G()), and because of the higher priority of PCP we may never apply r, implying that the answer is no. Since the semantics of PCP is undecidable, so is the semantics of the priority control condition r < PCP.

over rules as well as iterating a single imported transformation unit with as-long- as-possible is generally undecidable and the latter is not even semi-decidable. The Turing machine example demonstrates that the undecidability of iterating a single imported transformation unit is not due to nondeterminism in control conditions. Similarly, priority control conditions that assign a higher priority to some imported unit are undecidable, whereas they are decidable if some higher priority is assigned only to rules. Therefore, a first implementation of graph transformation units should disallow as-long-as-possible and higher priorities on imported units.

Even though transformation units as a concept are independent of any particular graph transformation approach, this cannot be expected for a general verification method. In the future we will concentrate on verification of transformation units based on a given graph transformation approach. This is especially useful since we are about to implement a software system that allows to program with transforma- tion units and eventually admits the execution of said units.

