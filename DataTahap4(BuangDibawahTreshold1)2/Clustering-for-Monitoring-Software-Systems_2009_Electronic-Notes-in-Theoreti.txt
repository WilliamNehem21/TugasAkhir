Understanding low/medium level concepts and relationships among components at the function, paragraph or even line of code level by mining C and COBOL legacy systems source code was addressed in [25]. For C programs, functions were used as entities, and attributes defined according to the use and types of parameters and variables, and the types of returned values. Then clustering was applied to iden- tify sub-sets of source code that were grouped together according to custom-made similarity metrics [25]. An approach for the evaluation of clustering in dynamic

dependencies is presented in [31]. The scope of this solution is to evaluate the usefulness of providing dynamic dependencies as input to software clustering al- gorithms. Additionally, Clustering over a Module Dependency Graph (MDG) [20] uses a collection of algorithms which facilitate the automatic recovery of the mod- ular structure of a software system from its source code. This method creates a hierarchical view of system architecture into subsystems, based on the components and the relationships between components that can be detected in source code.

Clustering algorithms are also used by Mancoridis et al. [21] in order to support the automatic recovery of the modular structure of a software system from its source code. The algorithms selected in this case are traditional hill-climbing and genetic algorithms. Towards program comprehension, a crucial step is detecting important classes of the system, since they implement the most basic and high level actions. Zaidman et al [32] introduced four static web-mining and coupling metrics in order to identify such classes and generally analyze a software system.

The work presented in this paper differs from the literature discussed above in means of performing clustering on the software measurement data, aiming at com- prehending a software system and assessing its maintainability. More specifically, instead of applying clustering algorithms on graphs or directly on the source code, we employ the k-Attractors clustering algorithm on metrics that reflect the most important design aspects of a software system concerning its quality and maintain- ability. We employ a two-steps clustering analysis in order to provide a quick and rough grasp of a software system and depict its evolution by from version to version.

All the collected data (i.e. attributes and metrics) are stored into appropriate structured XML files. We have chosen XML because of its interoperability and its wide acceptance as a de facto standard for data representation and exchange. Storing the metrics in XML files enables further processing and analysis with a variety of tools. The basic unit of every XML file is the java-source-program. Every java-source-program is associated with a java-class-file and can include a package declaration (package-decl), a list of imported modules (import), a list of interfaces (interface) and a list of classes (class). For every such subunit, the XML file stores detailed information. For example, for every class we store its superclass, a list of its member fields (field), a list of its methods (methods) and its constructors (constructor) and finally the associated metrics.

Employ an alternative approach for monitoring cluster changes from version to version Another approach for monitoring cluster changes is to perform the clustering procedure for each one of the versions. We use all these clusters (each one with a different color according to the version that belongs) in a second clustering phase, using the corresponding centroids, in order to produce clusters of clusters in a hierarchical way. We can assume that each one of the level two clusters consists of the same cluster of data item through versions. Enhance the Extraction Method The proposed method processes information derived only from Java source code files (*.java). It is of great interest to extract data from other languages like C++, C and COBOL which were used for the development of the majority of legacy systems, a category of software systems which is very interesting in terms of program comprehension and maintainability.

