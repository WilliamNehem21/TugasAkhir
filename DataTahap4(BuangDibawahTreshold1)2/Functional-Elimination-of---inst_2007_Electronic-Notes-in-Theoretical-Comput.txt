Our representations of SSA and ANF are similar to those of [9], but we restrict our attention to a single procedure: function applications in ANF occur as tail calls. Given mutually disjoint sets Const of constants (including the special con- stants tt and ff and ranged over by c, d . . .) and Var of variables (ranged over by

Several authors have recently proposed type-based calculi for register allocation, often using an ANF-like language [28,1,2,24]. While we have restricted our attention to a first-order language with tail-recursive calls, a generalisation to higher-order functions, where caller and callee need to agree on specific register allocation disci- plines, is clearly desirable. Indeed, [28], [1] and [2] employ effect systems to record the impact of more general function calls on registers, and similar annotations are recorded in the types of code pointers in TAL [20].

Agat [1] proposes a type system for a low-level explicitly register-annotated func- tional form for machines with (finite) register files and (in principle unbounded) stacks. The transition from unallocated to allocated programs is obtained by two operational semantics, the first of which ignores the register annotations and uses a functional interpretation and the second of which models an imperative semantics on register files. In contrast to our setting, program variables do not correspond directly to registers and explicit instructions are introduced that move values be- tween different locations. The soundness result of the type system states that the two semantics coincide for well-typed programs and is proven using a further oper- ational semantics that unifies the two earlier ones. The type system includes effect annotations for closures which ensure that functions expect their arguments in the correct registers and do not interfere with live locations.

Similar to these formal systems, our type system was presented as a mechanism for specifying register allocations. Obtaining allocations amounts to inferring type judgements - a task which we did not address in this paper. Although the sys- tem was described using an unstructured set of registers, it can be generalised to include several types of registers (double precision,. . . ), or memory locations, for example by introducing a kinding system. The specific behaviour of different stor- age locations would then be represented by the availability of kind-specific typing or transformation rules. Thus, the effect of techniques such as spilling could be modelled, although the optimisation task of deciding which intermediates to spill would again be a matter of type inference.

