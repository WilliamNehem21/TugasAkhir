We present a prototype application for coordinating distributed agreements in multi-parties negotiations, where participants can dynamically join ongoing negotiations and where participants know only those parties they have interacted with. Our prototype is tailored to Ad-Hoc network scenarios involving the assignment of tasks for a rescue team operating over disaster areas. Our application is based on asynchronous communication and it exploits the d2pc protocol for committing or aborting a negotiation. Parties have

As a running case study we consider a typical scenario within the context of Mobile Ad-hoc NETworks (manets), i.e. networks where agent mobility coexists with dynamic infrastructures and net topology. manets are typical of wireless scenarios for small mobile units and their infrastructures (emergency teams, medical

teams, security units, press and information groups, hi-tech research and business meetings), where many local agents are involved (laptops, PDAs, and last generation mobile phones). Our case study considers a rescue unit composed by a central base and several teams, each of them having a leader and several operators. Roughly, the idea is that after having exchanged several messages, each member can either decide to commit her/his negotiated involvement in the task, or to abort the negotiation when the assigned activity cannot be performed. Note that team members often have a limited knowledge about the other participants in the task, i.e., they only know those members they have interacted with (by sending or receiving messages).

Components running Jocaml and Perl code are structured on three layers. The bottom layer hosts the distributed transaction manager, which is written in Jocaml. The other two layers (gui and coordinators) are written in Perl, because of its simplicity for developing prototypes. Components written in Polyphonic C follow the object oriented paradigm: the instances of the class d2pc are responsible for performing the commit protocol.

In both cases, programs at the application-level are just responsible for keeping track of the involved parties and to initiate the agreement protocol. The execution of the commit protocol is transparent to the application-level (and hence to team members) and it is handled either by the two lower layers in the Jocaml and Perl implementation or by the class d2pc in Polyphonic C . This abstracts away the application-level from the orchestration of the agreement, making the negotiation mechanism reusable for developing new applications.

All operators have answered in the affirmative. In this case l1 chooses two of them and sends them detailed instructions for carrying out the activity. Moreover, l1 communicates the decision to the excluded operator. Additionally, l1 confirms the Base about the successful assignment of the activity and commits the negotiation.

After having sent and received messages to / from other users as part of an agreement, a user will vote commit or abort. We assume that every participant will vote commit / abort after a finite amount of time. If the user votes abort, then the whole agreement is aborted. For this reason the graphical interface shows immediately the status abort. Moreover, all remaining users in that agreement will be aware of the abort after voting.

At the application level, two parties exchange messages when a user sends a message to another user. In this case, both the sender and the receiver update their syn- chronization sets with the identity of the other participant, i.e., from this moment both participants are part of the same negotiation. Messages at the application level have the following form:

All information about the commit protocol is processed locally by the d2pc al- gorithm, but messages to/from other nodes are managed (and forwarded) by the coordinator layer. Although the communication between components could be wired into the d2pc algorithm, the two functionalities are kept apart to make the d2pc al- gorithm independent from the communication model used by parties. For instance, components could communicate through udp sockets instead of tcp sockets only by changing the middle layer.

Jocaml is an extension of the Objective Caml (Ocaml), a functional language with support of object oriented and imperative paradigms, that implements the primitives of Join. Jocaml provides three main abstractions: process, channels, join-patterns. Processes represent communication and synchronization tasks. The simplest process is an asynchronous message. Complex processes are obtained by combining expressions with the parallel composition of other processes. Channels are Jocaml abstractions corresponding to Join names. There are two different kind of channels: synchronous and asynchronous. The syntax for defining channels is the following

in which all applications decide to commit: first User1 press the COMMIT button, then User2 and finally User3 do the same (see the order of PUT messages). Note that each application starts locally the protocol sending the PUT message to the manager. The parameters of PUT messages correspond to the list of contacted parties during the GUI phase. The LOCK messages are sent by the managers according to the d2pc algorithm. When the execution of the d2pc concludes, every manager will inform its application layer with the final decision (COMMIT, in this case).

Parties have been also implemented in the object oriented language Polyphonic C# [1]. Polyphonic C# extends C# with asynchronous methods (declared with the keyword async and synchronization patterns, called chords (defined by keyword when. A call to an asynchronous method is guaranteed to complete almost imme- diately, i.e., the caller never blocks. A chord is defined by a header (i.e., a set of method declarations) and a body. The body is only executed once all the methods in the header have been called.

receiving messages from other parties. The class User Interface handles the inter- actions with the user and the instances of d2pc execute the commit protocol. Note that the communication between classes inside a component is achieved by method invocation instead of socket communication.

Nondeterministic abort. The original Join coding allows a manager to autonom- ously initiate at any time the commit protocol voting abort while it has not received the PUT message that initiates the commit protocol with vote commit (nondeterministic simulation of abort decision). This rule, which guarantees the termination of any instance of the protocol, has the disadvantage that can be fired as soon as the manager is created, forbidding in this way the possibility to wait for a commit. Instead, in both the Jocaml and Polyphonic C implementation, the manager starts the commit protocol voting for abort only when it receives the abort vote (e.g. from the associated user). This implementation choice does not compromise the correctness and completeness of the D2PC as far as every parti- cipant in the agreement vote after a finite amount of time. As we are assuming that all users will eventually vote, this modification does not affect the properties of the protocol.

Non-linear pattern matching. Neither Jocaml nor Polyphonic C provide mechan- isms of non-linear pattern matching, although an extension of the Join calculus with linear pattern matching has been proposed in [10]. In the Join formulation of the d2pc, non-linear pattern matching is used for convenience on port commit, which represents an internal state of a manager. There are two cases, one in which there are managers to be notified, and the other when all known managers have been already notified. The d2pc allows both sending of notification and vote receptions from other managers to be interleaved freely. In our implementation we impose all notifications to be sent before accepting a vote from a manager. Clearly, this is a particular interleaving of the original specification, and therefore it satisfies all the properties of the protocol. In our encoding this is achieved by using an auxiliary port so to avoid non-linear pattern matching.

