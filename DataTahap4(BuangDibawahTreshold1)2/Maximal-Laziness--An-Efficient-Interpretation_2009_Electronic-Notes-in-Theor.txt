This section introduces a motivating example: a purely functional, domain specific language for which we want to implement an efficient interpreter with- out much effort. The DSL in question is the Nix expression language, which is used in the Nix deployment system [7,5] to specify how to build and compose software packages. A purely functional language is a good fit to the problem of specifying the building of software packages, because packages often need to be built in different versions or variants. For instance, different packages in the system may need to be built with different versions of the C compiler; and

Since helloFun is a function, to actually build an instance of the Hello package, we must call it. This is done at point 3 , and the resulting build graph is bound to the variable hello. The function is called with a set of arguments inherited from the surrounding lexical scope using the inherit keyword. (inherit

x is merely syntactic sugar for an argument specification x = x;, i.e.	the argument x is the expression x, where the latter x refers to the variable x in the surrounding scope.) Of course, the function can be called any number of times. For instance, if we had a value perl6 representing a different version of Perl, we could build Hello with it: helloWithPerl6 = helloFun {inherit fetchurl stdenv; perl = perl6;}. This is a lazy language: expressions are only evaluated, and the build graphs they represent only built, when they are actually needed. It is not the purpose of this paper to give a full treatment of Nix or its ex- pression language. (These can be found in [5] and in the Nix manual at http:

Recursive attribute sets allow attribute values to refer to each other. They are constructed using the rec keyword. Formally, each attribute in the set is added to the scope of the entire attribute set. Hence, rec { x= y; y= 123; }.x evaluates to 123. If rec were omitted, the identifier y in the definition of the attribute x would refer to some y bound in the surrounding scope. Recursive attribute sets introduce the possibility of recursion, including non-termination,

As an example of a simple rewrite rule, consider conditionals, if e1 then e2 else e3. Conditional expressions first evaluate the condition expression. It must evaluate to a Boolean. (Evaluation fails if it is not, but for simplicity I will not consider type errors here.) The conditional then evaluates to one of

For the remaining rules below, we need a notion of substitution of expres- sions for variables in other expressions. The substitution function subst(subs, e) (not shown here) performs a set of substitutions subs in the expression e. The set subs consists of substitutions of the form x ~ e that replace a variable x with an expression e. subst replaces all free variables for which there is a substitution. A variable is free in a subexpression if it is not bound by any of its enclosing expressions. Variables are bound in functions and in recursive attribute sets. In recursive attribute sets, only the recursive attributes (as1) bind variables; the non-recursive attributes (as2) do not. It is assumed that the expressions in subs contain no free variables, so subst does not have to perform renaming to prevent name capture.

A recursive attribute set is desugared to a normal attribute set by replacing all occurrences of references to the attributes with the recursive attribute set. For instance, if e = rec {x=fx y;y= x;}, then e is desugared to {x = f (e.x) (e.y); y = e.x;}, or in full, {x = f ((rec {x = f x y; y = x;}).x) ((rec {x = f x y; y = x;}).y); y = (rec {x = f x y; y = x;}).x;}. This desugaring is implemented by the Rec rule:

Using term rewriting, it is straight-forward to turn the semantic rules from the previous section into a concrete interpreter for the language. However, with- out maximal laziness, such an interpreter would not perform well. This section shows how we can obtain an efficient interpreter from a straight-forward trans- lation of the semantic rules using term rewriting and maximal laziness.

be evaluated, and returns a pointer to the ATerm representing the resulting normal form. Helper functions such as matchIf are used to recognise and build ATerms. The elided helper function evalBool(e) calls eval(e) and returns true if the resulting term is Bool(True).

Because of maximal laziness, we get some optimisations that are convention- ally applied to purely functional languages for free. For instance, the full laziness transformation [19] makes code more efficient by moving subexpres- sions outward as far as possible, e.g. let {f x = let {y = fac 100} in x + y} in f 1 + f 2, which computes fac 100 twice, can be transformed into let {y = fac 100; f x = x + y} in f 1 + f 2, which computes it only once in a conventional lazy implementation. With maximal laziness, this transformation is unneces- sary: repeated occurrences of the same subexpression across multiple calls to a function will be computed only once.

Traditional sharing : an implementation that updates variable bindings after they have been evaluated. This is the sharing model in most implementa- tions of functional languages. This implementation is a modification of the existing (maximally lazy) Nix expression evaluator, made for comparison purposes. It therefore does use the ATerm library, and maximal sharing to store terms efficiently.

Maximal laziness with closed term optimisation wraps substituted terms in closed nodes as described in ssec:subst. This very simple change alone makes maximal laziness fast enough: operations such as nix-env -qa now run in a few seconds, which is actually faster than similar operations in other package management tools that do not have package descriptions in a full-fledged programming language. We can thus conclude that the closed term optimisation is essential to make maximal laziness feasible. This is the variant that the production version of Nix uses.

