Structured reversible flowchart languages is a class of imperative reversible programming languages allowing for a simple diagrammatic representation of control flow built from a limited set of control flow structures, as ordinary structured flowcharts allow for conventional languages. This class includes the reversible programming language Janus (without recursion), as well as more recently developed reversible programming languages such as R-CORE and R-WHILE. In the present paper, we develop a categorical foundation for this class of languages based on inverse categories with joins. We generalize the notion of extensivity of restriction categories to one that may be accommodated by inverse categories, and use the resulting decision maps to give a reversible representation of predicates and assertions. This leads to a categorical semantics for structured reversible flowcharts, from which we show that a program inverter can be extracted. Finally, we exemplify our approach by the development of a small structured reversible flowchart language, use our framework to both straightforwardly give it semantics and derive fundamental theorems about it, and discuss further applications of decisions in reversible programming.

The semantic framework we are going to present in this paper covers the reversible structured languages regardless of their concrete formation, such as atomic operations, elementary predicates, and value domains. Reversible programming languages that are instances of this computation model include the imperative language Janus [27] without recursion, and the while languages R-WHILE and R-CORE with dynamic data structures [12,13]. Further, unstructured reversible flowchart languages, such as reversible assembly languages with jumps [9,2], can be transformed into structured ones thanks to the structured reversible program theorem [24].

Overview: In Section 2, we give an introduction to structured reversible flowchart languages, while Section 3 describes the restriction and inverse category theory used as backdrop in later sections. In Section 4, we warm up by developing a notion of extensivity for inverse categories, based on extensive restriction categories and its associated concept of decisions. Then, in Section 5, we put it all to use by showing how decisions may be used to model predicates and ultimately also reversible flowcharts, and use this to extract a program inverter. In Section 6, we develop a small language to exemplify our framework, and discuss other applications in reversible programming. Section 7 offers some concluding remarks.

The assertion p1 in a reversible while loop (marked by the circle) is a new flowchart operator: the predicate p1 must be true when the control flow reaches the assertion along the t-edge, and false when it reaches the assertion along the f -edge; otherwise, the loop is undefined. The test p2 (marked by a diamond) has the usual semantics. This means that B in a loop is repeated as long as p1 and p2 are false. The selection has an assertion p2, which must be true when the control flow reaches the assertion from B1, and false when the control flow reaches the assertion from B2; otherwise, the selection is undefined. As usual, the test p1 selects B1 or

Reversible structured flowcharts defined above corresponds to the reversible language R-WHILE [12], but their value domain, atomic functions and predicates are unspecified. As a minimum, a reversible flowchart needs blocks (a,b,d) because selection (c) can be simulated by combining while loops that conditionally skip the body block or execute it once. R-CORE [13] is an example of such a minimal language.

Restriction categories [6,7,8] axiomatize categories of partial maps. This is done by assigning to each morphism f a restriction idempotent f , which we think of as a partial identity defined precisely where f is. Formally, restriction categories are defined as follows.

As an example, the category Pfn of sets and partial functions is a restriction category, with f (x)= x if f is defined at x, and undefined otherwise. Note that being a restriction category is a structure, not a property; a category may be a restriction category in several different ways (e.g., assigning f = id for each morphism f gives a trivial restriction structure to any category).

One may now wonder when C (A, B) has joins as a partial order. Unfortunately, C (A, B) has joins of all morphisms only in very degenerate cases. However, if instead of considering arbitrary joins we consider joins of maps that are somehow compatible, this becomes much more viable.

In [8], it is shown that the existence of certain maps, called decisions, in a restriction category C with restriction coproducts leads to the subcategory Total(C ) of total maps being extensive (in the sense of, e.g., [4]). This leads to the definition of an extensive restriction category 5 .

as p or q  then has as witnesses the join of the witnesses of p  and q , and as counterexamples the meet of the counterexamples of p and q . With these definitions, it can be shown that, e.g., the De Morgan laws are satisfied.

To extend this elementary model to one that additionally models reversible condi- tionals, we observe that the partial inverse to a decision is precisely its corresponding assertion. Intuitively, a decision separates an object into witnesses (in the first component) and counterexamples (in the second). As such, the partial inverse to a decision must be defined only on witnesses in the first component, and only on counterexamples in the second.

Consider the following family of (neither particularly useful nor particularly useless) reversible flowchart languages for reversible computing with integer data, RINTk. RINTk has precisely k variables available for storage, denoted x1 through xk (of which x1 is designated by convention as the input/output variable), and its only atomic operations are addition and subtraction of variables, as well as addition with a constant. Variables are used as elementary predicates, with zero designating truth and non-zero values all designating falsehood. For control structures we have

