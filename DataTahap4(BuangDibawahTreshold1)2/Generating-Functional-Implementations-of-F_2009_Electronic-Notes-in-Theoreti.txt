Finite state automata (FSA) implementations are widely used in IT due to their rich application possibilities, flexibility, and their direct relationship with common goals set by regular business applications. Workflow- based programming has opened up a new exciting application area: workflows governed by FSA. The field is gaining more and more attention, the .NET 3.0 platform contains an engine called Workflow Foundation dedicated to managing workflows. However, due to the advantageous properties of FSA, it is often desirable to build applications around FSA implementations in simpler cases as well. In this paper an automata generator framework will be presented that makes it possible to use automata whenever possible. What makes this framework highly applicable and very flexible is the fact that the generation process might rely on not only static, but also dynamic information, so it can be performed during runtime as well. From the technical point of view, the interesting part is that the generated implementation is based on lambda expressions, the new functional enhancements of the C# 3.0 language.

A finite state automaton [1] or state machine is a mathematical machine that, at a given time can be in exactly one state from a finite set of states. One important subset of states contains initial states. When the automaton is switched on, it can be in any of the initial states. When input from a finite alphabet is fed to the automaton, and certain conditions or constraints are met, the automaton can leave its current state and switch to a next state. This is called a state transition. If the automaton is in a final state when there is no more input, it is said to have accepted its input.

Finite state automata are popular because they can be applied to many practical problems. Nowadays, when workflow-based programming is gaining more and more importance among programming paradigms, a very interesting application area is opening up. Workflows can be mapped to an automaton that governs business rules driving the workflow [9]. Although sophisticated frameworks supporting workflow- based programming such as the Workflow Foundation engine of the .NET platform have emerged [2], yet there are cases when it can be important to bring implemen- tation details closer to programmers. This should be done without exposing too many parts of the internal behavior to them or force them to setup complicated environments or even use additional designer tools.

The biggest improvement of the C# 2.0 language was the generics construct. How- ever, there were less important, but interesting new features as well. One of them was a new feature called anonymous methods. This feature allows programmers to create un-named or so-called anonymous methods. A similar concept of anonymous classes [6] has earlier been introduced in the Java programming language. Java does not define the notion of function pointers or delegates, it operates with interfaces and their implementation, that is why the anonymous level is that of the class.

In case of simple functions whose code is unlikely to be reused, it is inconvenient to define a separate function. C# 2.0 allows function pointers to be defined without naming them explicitly. The FilterRecordsWithDelegate function can be rewritten as follows using an anonymous delegate:

For each state, this container holds a lambda expression that decides the next state for a given input. The lambda expression is of the generic type Func<string, StateValue>. This denotes a lambda expression whose input is a string, and the result is a StateValue. (In the current implementation, the input of the automaton is always of type string. This can also be extended in future versions.)

The next step is that the declarative description is validated according to a previously prescribed schema. The xml file is valid, so the constant container, StateValue enumerations and lambda expression definitions will be generated. In this case, the StateValue enumeration contains the TWENTY, FIFTEEN, TEN, FIVE, SODA values.

Our pilot solution is limited in functionality, and there is a number of issues to work on. One interesting question is the handling of tail recursion. Unlike many functional environments, C# does not handle tail recursion. This might lead to stack overflows. However, there is a supported IL instruction called tail. Using this instruction it is possible to correct the emitted code at IL level.

We believe that this implementation can be extended in a number of ways. In the future, we plan to provide support for multiple start and end states as well as state transitions controlled by a guard condition. Seemingly, these extensions can be incorporated into the existing solution by applying only minor changes. However, implementing a non-deterministic automaton using lambdas is probably much harder.

