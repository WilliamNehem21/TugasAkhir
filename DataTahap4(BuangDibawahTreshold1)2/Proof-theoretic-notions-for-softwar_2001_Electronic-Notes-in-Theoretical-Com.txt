One crucial notion is the notion of use in a proof-theoretic setting. We give suggestions for formal definitions of such a notion depending on the underlying calculus. It allows us to control explicitly the parts of a program which are necessary or sufficient for a certain property. In particular, it provides us with a form of locality. This locality is essential for the possibility to reuse proofs, or parts of proofs, when a program is changed.

For our purpose we consider computer programs as syntactic object, i.e. as a piece of text. This is, of course, something different than the algorithm [24] or the (mathematical) function which is implemented by a program. Software maintenance is analogously understood as the update of a program, i.e. the change of the program text.

In theoretical computer science there is a standard procedure for the formal analysis of programs. A programming language S is associated with a formal framework F . By use of a translation T we can interpret programs of S in the formal framework F .

Such frameworks exist for essentially all higher computer languages. There are even different ones for a particular programming language which compete which each other with respect to complexity, expressivity and also practice handling. They can even differ in their intention, focusing on the denotational or operational semantics. But these aspects do not affect our approach. It works for theories axiomatizing the denotational semantics in the same way as for the operational semantics. However, often the operational semantics is more closely related to a proof-theoretic view while the denotational one is related to a model-theoretic view, cf. e.g. [25]. At the end of this section we give a brief discussion of formal frameworks given in the literature.

b is no longer in LC(P3), but this follows already from the fact that a was necessary for b. Of course, this kind of argument works only, as long as we retract something. When we add new clauses, there could be a new possibility to derive b.

In this case, the knowledge that a was necessary for b cannot be used directly. In particular, not in the way that the retraction of a disables the derivation of b. In fact, the addition of a :-c saves the derivability of b. To see this, we do not need to calculate LC(P6) as a whole. It is enough to show that the necessary axiom a which was retracted can be derived in the new context. This follows from the derivation:

As a general reference we recommend the second volume of the Handbook of Theoretical Computer Science [36]. As is generally known, the pioneer formal approach to programming language was given by Hoare [15], cf. Cousot [6] which contains an impressive list of more than 400 references.

The defined notions are very general and they should be applicable in arbi- trary contexts as long as we have an appropriate formal framework. However, for many computer programs the calculation and the bookkeeping of used formulae would probably be too space and time consuming. Nevertheless, be- side the conceptual clarification given by our approach, there are several areas where it should be applicable directly.

through the net. However, the whole proof could be already too big. So it is a question of balance which parts of the proof should be packed in the program in order to get an optimal relation between the size of the transferred code and the time for the local verification. To study these kinds of questions the analysis of used and necessary parts of proofs is clearly highly relevant.

Within this framework the idea of pruning realizes some aspects of our aims [11]. Let us assume we have extracted a program from a given proof which uses case distinctions. New information could result in a reduction of the possible cases. By using this information systematically, one can prune the distinctions and end up with a better, i.e. more efficient, program.

