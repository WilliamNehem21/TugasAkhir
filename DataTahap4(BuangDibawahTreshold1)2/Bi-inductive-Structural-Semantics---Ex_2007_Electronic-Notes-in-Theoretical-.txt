Since the natural semantics defines the finite behaviors but not the diverging behav- iors, an interpretation of the big-step evaluation rules as Horn clauses implemented in Prolog [2,9] will have its diverging behaviors determined by the implementation (e.g. Prolog interpreter with left-to-right evaluation).	 

We introduce an original big-step trace semantics that gives operational mean- ing to both convergent and divergent behaviors of programs. The compositional structural definition mixes induction for finite behaviors and co-induction for infinite behaviors while avoiding duplication of rules between the two cases. This big-step trace semantics excludes erroneous behaviors that go wrong. The other semantics are then systematically derived by abstraction.

The big-step trace semantics is first abstracted to a relational semantics and then to the standard big-step or natural semantics. These abstraction are sound and complete in that the big-step trace and relational semantics describe the same converging or diverging behaviors while the big-step trace and natural semantics describe the same finite behaviors. The big-step trace semantics is then abstracted into a small-step semantics, by collecting transitions along traces. This abstraction is sound but incomplete in that the traces generated by the small-step semantics describes convergent, divergent, but also erroneous behaviors of programs. This shows that trace-based operational semantics can be much more informative that small-step operational semantics.

We introduce a maximal trace semantics describing terminating and diverging computations. The trace semantics is then abstracted into a relational [20] and then an operational semantics [15]. Each semantics can be defined using small steps or big steps of computation. Each semantics can be defined in fixpoint or rule-based form.

