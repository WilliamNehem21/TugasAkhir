In this paper we continue the story and we define vertical refinement on our general model. Ver- tical refinement can be seen as a generalisation of what, in the literature, has been called action refinement or non-atomic refinement. Alternatively, by viewing a special model (from the previous paper) as a logical theory, vertical refinement can be seen as a theory morphism, formalised as a Galois connection.

ational semantics of the entities under consideration. Thus the interpretations that are usually fixed can now be changed during the development of a sys- tem by formal refinement steps. Using a series of examples in Section 4.1, Section 5.1 and Section 5.2 we show our definitions to formalise some quite natural development steps.

As a concrete example of this we implement the IBP layer in the broad- cast layer in Section 5.2. What is particularly interesting about this is that we can find no way to extend this to be able to implement handshake on broad- cast! The problem appears when considering the same processes that cause problems with the definition of determinism.

Extension refinement [3] and behavioural sub-typing [5] have been defined so that they make visible (i.e. reverse hiding and restriction of various kinds) in the concrete entity events not visible in the abstract entity. It now turns out that this sort of refinement can be formalised as another special case of theory morphisms.

Our definition is based on two semantic mappings: )v , that defines how to interpret the high-level abstract entities as low-level concrete entities; and vA, that defines how to interpret the low-level concrete entities as high-level abstract entities. The semantic mappings are vertical refinements if and only if any low-level refinement is interpreted as a high-level refinement and any high-level refinement is interpreted as a low-level refinement. Mathematically our vertical refinement is a Galois connection (or an adjunction) between the layers.

So, the system may have some features modelled by high-level events in alphabet ActH and others modelled by low-level events in alphabet ActL. We first model the features needing the high-level events, then we vertically refine this to an entity using only low-level events. This step preserves the meaning of the specification while embedding it in a more detailed low-level layer.

can be formally refined into other interpretations of behaviour. Thus the choice of how to interpret the ISO Z semantics need not be made as the first step in the development process but can be postponed until the choice, if ever, is needed. Importantly when the design decision is made it can be applied without leaving our formalism and a guarantee can be given as to the relation between the initial ISO Z specification and its new interpretation.

The second refinement step is a simple reduction of nondeterminism. It is in this step that the developer decides that the set is to have no more than three elements. Hence the guarantee is unchanged when sets never have more than three elements but any operation that attempts to increase the size to greater than three is free to return the new state X .

By applying vertical refinement to processes with LTS operational semantics we are able to refine processes based on actions with one style of interac- tion (e.g.handshake) on a layer of process with another style of interaction (e.g.broadcast). Before considering vertical refinement in general we consider the much simpler subset morphisms and show how to use them to model restriction and hiding as found in the process literature CSP/CCS/ACP.

The abstraction functions, Restriction and Hiding, can simply be applied to a process to remove events from a concrete process when ever the developer chooses. But here, as in [3,5], we are interested in reversing this process and introducing these events, new to the abstract process, and thus creating the concrete process. Further we are interested in viewing the introduction of these new events as a formal refinement step.

In this section we will define a particular vertical refinement between high- level IBP entities and low-level broadcast processes, both from the companion paper [13]. We will then show that we have been unable to extend the high- level to all handshake processes. The reason appears to be related to the way handshake processes have abstracted away the cause and response nature of event synchronisation.

