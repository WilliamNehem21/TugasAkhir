Although termination techniques for term rewriting have been transferred to the area of term graph rewriting (see e.g. [13] for an overview), transferring proof techniques to the general form of graph rewriting is often not directly possible, because they make use of the inherent hierarchical nature of terms and strings. Still, we think it is a worthwile area of research to see how much of the theory can be ported to a graph rewriting setting.

We work with edge-labelled directed graphs and employ the double pushout (dpo) approach to graph transformation. We refer to the standard literature for definitions and discussion, e.g. [7,15]. Here, we just recapitulate the most important concepts that are needed in some more detail later.

and edge-consuming (i.e. L contains at least one edge). Graph productions are represented graphically by drawing the left-hand side and the right-hand side in which some nodes are named. The interface can be reconstructed by taking only the named nodes, and the morphisms will be just the identities.

The definition of finite graph automaton is similar to the definition of a type graph: a regular graph language is the set of graphs of a specific type. However, where a type graph is usually meant to be a static structure which is set up in advance, our aim is the other way around: given an untyped graph transformation system, we want to generate an automaton which ac- cepts all the reachable graphs. For this reason, we prefer to maintain different terminology.

Example 5.8 Consider the fga G := G, where G is the graph from Ex. 5.4, and let the gts It from the same example be given. The language L(G) consists of all acyclic graphs with maximal path length 3, and because there is a bound on the creation heights in an unwinding of lift0(G), we conclude that L(G) is It -terminating.

The method described above depends on constructing an unwinding of the initial annotation of a graph. Since this unwinding is necessarily infinite if there is no bound on the creation heights, we cannot hope to find an algorithm which always terminates. However, usually the goal is to prove termination rather than non-termination, and thus a semi-decision procedure is already useful. We analyse the following algorithm:

as well as of infinite sets of source graphs. The approximations technique, however, ignores the structure of the graph, and focusses on the number of occurrences of elements of a certain type. In contrast, our approach can take the structure of the source graph(s) into account.

Obtaining similar results for more expressive classes of graph languages. Regular graph languages are not expressive enough to recognize the class of acyclic finite graphs or even the class of finite trees, while non-cyclicity is can be an important property for proving termination. Combining cre- ation heights with more expressive classes of graph languages may provide stronger results.

