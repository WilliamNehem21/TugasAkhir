Symbolic model checking is a technique for verifying temporal speci - cations of nite state machines. It is well known how nite state machines and the evaluation of the temporal speci cations can be expressed using Boolean formulae. We show how to do these manipulations using BEDs. We concentrate on examples which are hard for standard symbolic model checking methods.

Determining whether a formula is satis ability is a problem which occurs in veri cation of combinational circuits and in symbolic model checking. Often satis ability checking is associated with detecting errors. We examine how satis ability checking can be done using the BED data structure.

structure. Among other operations, we introduce an operator for computing minimal p-cuts in fault trees. A fault tree is a Boolean formula expressing whether a system fails based on the condition (\failure" or \working") of each of the components. A minimal p-cut is a representation of the most likely reasons for system failure. This method can be used to calculate approximately the probability of system failure given the failure probabilities of each of the components.

I would like to thank my two supervisors at the Technical University of Denmark (now both with the IT University of Copenhagen), Associate Pro- fessors Henrik Reif Andersen and Henrik Hulgaard, for giving me the op- portunity to work on this project. During my graduate studies, they have guided me, given me valuable comments and criticism on my work, and patiently answered my many questions. For this I am them grateful.

A special thanks is due to Professor Edmund Clarke from Carnegie Mel- lon University. I spent six months working with him and his model checking group in Pittsburgh. His vast knowledge of computer science and the inspir- ing atmosphere surrounding him and his group made it a joy to work with him.

During my research, I have had long and fruitful discussions with fellow doctoral students. Especially J rn Lind-Nielsen from Technical University of Denmark and Anubhav Gupta from Carnegie Mellon University have lent an ear, made helpful suggestions, and answered my numerous questions. Rune M ller Jensen, Ken Friis Larsen, Jakob Lichtenberg, Jesper M ller and many others have also been helpful.

I am indebted to the members of my Ph.D. committee: Associate Pro- fessor Hans Henrik L vengreen from Technical University of Denmark, Pro- fessor Parosh Abdulla from Chalmers University, and Nils Klarlund from AT&T in New Jersey. Thank you for valuable comments and criticism on my thesis.

Stories like this one show that human reasoning is prone to errors. We cannot always rely on our intuition. We need a systematic way of handling these tasks such that we know for sure that we have covered all possibilities and left nothing out.

In much the same way we can recognize structure in the systems we deal with. For example, we may recognize that one input i of the 100 inputs to a circuit is only used if another input j is high. Otherwise i is ignored. There is therefore no need to consider input combinations which di er only in	i when j is low.

ially simple or that someone else takes care of them. This does not mean that those transitions are uninteresting. On the contrary, they are very in- teresting. The whole idea of how to formalize a problem, including deciding which parts to abstract away and which parts to model, is a major research area these days.

The word \logic" stems from logos, the Greek word for reason. Propositional logic is the reasoning of propositions. A proposition is a statement that is either true or false; for example, \the sun is shining" or \4 is prime". We use 0 to mean false and 1 to mean true, and we use Boolean variables to represent basic propositions. These constants and variables are our atomic formulae. Atomic formulae can be connected using Boolean connectives forming compound formulae. There are two connectives of one argument: negation and projection. We only use negation, and we write it :, where negation is de ned as :0 = 1 and :1 = 0. There are 16 Boolean connectives of two arguments. Not all 16 Boolean connectives are necessary. For exam- ple, it is enough to have only negation and disjunction since the remaining

A formula is said to be a tautology if it evaluates to 1 for all possible variable assignments. Likewise, a formula is said to be a contradiction if it evaluates to 0 for all possible variable assignments. We say that a contra- diction is unsatis able since no variable assignment makes it evaluate to 1. A formula which is not a contradiction is satis able.

In the rest of this dissertation we often encode sets in propositional logic. We use the term characteristic function for the function encoding a set. Using characteristic functions it is often possible to greatly reduce the memory needed to represent a set. Another advantage is that characteristic functions allow us to work on the whole set as opposed to working on the elements of a set one at a time.

The following example illustrates characteristic functions. Assume we want to represent sets of integer numbers f0; 1; 2; 3; 4; 5; 6; 7g. Using three bits hs2s1s0i we can represent all eight numbers using their binary represen- tation such that hs2s1s0i = h000i represents the number 0, h001i the number 1, and so on up to h111i for the number 7. Now, the characteristic function:

In this dissertation we look at ways to solve problems in the domain of formal veri cation. We want our solutions to be systematic so they can be implemented on a computer. We also want our solutions to be able to deal with complex problems as they occur often in industry.

Fault tree analysis is the problem of calculating certain values based on a fault tree for a system. A fault tree is a Boolean function describing the conditions under which the system fails based on the condition (\fail- ure" or \working") of each of the components. Examples are nuclear power plants and airplanes. For both kinds of systems it is important to keep the probability of failure down.

 In model checking we compare two di erent kinds of objects: A nite state machine and a CTL speci cation. We encode the nite state machine in propositional logic. Based on the CTL speci cation, we compute a set of states which are valid initial states for the nite state machines. Finally we compare this set of states with the actual initial states.

There are, of course, other areas within formal veri cation than the ones we deal with in this dissertation. Gupta has written a thorough survey of formal veri cation methods with respect to hardware [Gup92]. We do not hesitate to recommend her paper to readers interested in getting an overview of formal veri cation. Clarke and Wing have written a paper on the state- of-the-art and future directions for formal methods [CW96]. It contains a wealth of references to examples where formal methods (including formal veri cation) have been applied with success.

Second, when verifying a system, we implicitly assume that it is isolated from the context in which it is to function. We verify, so to say, a stand-alone version of the system. However, as Dr. Leveson points out [Lev99], many of the failures of complex systems today arise in the interfaces between the

components, where the components may be hardware, software or human. A typical error is \mode confusion" where the assisting computer is in one mode but the human believes it to be in another mode. For example, an aircraft control computer may be in \ ight mode", but the operator believes it to be in \landing mode". While the computer works correctly by itself, the interface between the computer and the pilot causes problems.

In this dissertation we only consider formal veri cation. We want, how- ever, to stress that formal veri cation is not the solution to obtaining correct systems. It is one among several methods; each of which has strengths and weaknesses. Ideally, one should apply a range of such methods.

Chapter 2 introduces Boolean Expression Diagrams as a data structure for representing and manipulating Boolean formulae. We explain how to im- plement the data structure. The chapter gives a number of properties for Boolean Expression Diagrams. Finally, the chapter contains a number of algorithms for working with Boolean Expression Diagrams { especially for constructing them and for converting them to Binary Decision Diagrams.

the input formula is in conjunctive normal form (CNF). However, most problems in formal veri cation are not naturally described in CNF and it is therefore necessary to convert the formulae into CNF. The conversion is expensive as it either enlarges the state space by adding extra variables or results in an explosion in the size of the CNF representation. By do- ing satis ability checking directly on the Boolean Expression Diagram data structure, we eliminate the conversion to CNF. The chapter is based on the paper [WAH01]:

Chapter 8 contains the conclusions. We give an outline of the results we have obtained. We characterize both the problems on which our methods work well and the problems on which out methods do not work well. Finally, we identify topics for future research.

In order to examine the Boolean Expression Diagram data structure, we have made an implementation in the programming language C. It is a set of library routines for constructing and manipulating Boolean Expression Diagrams. On top of the library, we have built a shell-like interface. Here the user can interactively enter, manipulate and examine Boolean Expression Diagrams. Appendix A describes this interface. The library and the shell interface form the core with which the experiments in this dissertation have been performed. Both are available on online3.

In 1997, Andersen and Hulgaard proposed a new data structure for repre- senting and manipulating Boolean formulae [AH, AH97]. The data structure is called Boolean Expression Diagrams, or BEDs for short. It is a general- ization of Bryant's Binary Decision Diagrams (BDDs) [Bry86, Bry92]. In this chapter we present the BED data structure, its properties, and the al- gorithms for working with it. Part of this chapter is a review of Andersen and Hulgaard's work.

De nition 2.1.1 (Boolean Expression Diagram). A Boolean Expres- sion Diagram (BED) is a rooted directed acyclic graph G = (V; E) with vertex set V and edge set E. The vertex set V contains three types of vertices: terminal, variable, and operator vertices.

We use 0 and 1 to denote the two terminal vertices. The relation between a BED and the Boolean function it represents is straightforward. Terminal vertices correspond to the constants 0 and 1. Variable vertices have the same semantics as vertices of BDDs and correspond to the if-then-else operator x ! f1; f0 de ned by

Vertices are created by the Mk algorithm; see Algorithm 2.3. The call Mk( ; l; h) returns the identity of a ( ; l; h) vertex. If  is a variable, then ( ; l; h) is a variable vertex with variable  , low child l and high child h. If

Using Mk as the only means of creating vertices ensures that the BEDs are always reduced. If we do not create variable vertices with non-terminal children, then the resulting BEDs are always free. Hence, the BED for a formula is both reduced and free.

vertices. Once a vertex is created, it stays in the data structure. When the data structure is full, we perform a garbage collection by sweeping through the whole BED array and marking all the vertices which are still in use. The remaining vertices are removed and their corresponding entries in the array are freed. Unused vertices are placed on a free-list, which we implement as a linking through the low eld of all entries not in use.

It is clear that since a BDD is a special case of a BED, the latter has the expressive power of at least that of the former. Any extra power of a BED must stem from the operator vertices. However, Bryant proposed in [Bry86, Bry92] an algorithm, Apply, for connecting BDDs with Boolean connectives. Informally, any operator vertex in a BED corresponds to a call to Apply in a BDD, and thus BEDs do not have any extra expressive power. We summarize this in Observation 2.2.3:

We measure the size of a BED or a BDD in the number of vertices it has. Bryant [Bry86] has shown that there exists no BDD representation of a multiplier circuit, such that the BDD size is sub-exponential in the bit- width of the multiplier. However, we can build multiplier circuits using only a quadratic number of gates [CLR90]. Mapping each gate to an operator vertex, we can construct a BED of the same size. Thus, BEDs are more succinct than BDDs. We capture this in Observation 2.2.4:

Solving the satis ability problem for BDDs is easy. Because of the canon- icity of BDDs, there is only one representation of an unsatis able function: the terminal vertex 0. All other BDDs represent satis able functions. The satis ability problem can be solved by comparing a given BDD to the BDD 0

Assuming that it takes constant time to create a new vertex, we can construct a BED for a formula in time linear in the size of the formula. For BDDs this takes much longer. In the worst case it takes time exponential in the size of the formula.

One way to solve the satis ability and the tautology problems using BEDs is to convert the BEDs into BDDs. As stated in Observation 2.2.6, for BDDs both problems are solvable in constant time. It might seem counterintuitive to rst construct a BED and then transform it to a BDD when we could have constructed the BDD to begin with. BDDs are canonical, we might argue, and thus the end result is the same regardless of how we obtain it. The

drops. In some cases it drops to almost nothing. Consider constructing the BDD for  =  $ , where the BDD for  is large. The size of the end result is only one vertex as is a tautology. However, as an intermediate step we need to construct the BDD for , which is large.

The intermediate results needed to convert a BED to a BDD are not necessarily the same as the ones needed to construct the BDD to begin with. In some cases we can take shortcuts with BED to BDD conversion which we cannot do with standard BDD construction. These shortcuts, although simple, turn out to be quite e ective.

Andersen and Hulgaard present in [AH, AH97] two algorithms for con- verting BEDs to BDDs. The algorithms are called Up One and Up All. The idea behind both algorithms is the following: If we remove all operator vertices from a BED, we are left with a BDD. The algorithms Up One and Up All also ensure that the resulting BDD is ordered2.

\BED" instead of \BDD"), but this is not a problem since the BED for any Boolean formula (as de ned in De nition 2.1.8) is always ordered. If the original BED is not ordered, it is possible to patch the algorithms such that the  nal BDD is indeed ordered

Consider repeated application of Up One to the variables x1; x2;::: ; xn, where each variable is pulled to the root. On the way to the root, variable xi passes the variables x1;::: ; xi 1. The nal result is a BDD with the order xn; xn 1;::: ; x1. A lot of work goes into pulling variables up past the variables previously pulled up. The following \early stop" modi cation to Up One would help: Pull a variable up until it is at the root of the BED or just below a previously Up One'ed variable, whichever occurs rst. This would result in a BDD with the order x1; x2;::: ; xn. And no time is wasted doing a reordering at the top of the BED.

As Up One pulls a variable x to the root, it creates a lot of interme- diate variable x vertices. These vertices are only used as a means to pass information between the recursive calls in Up One. Algorithm 2.7 shows the pseudo-code for an optimized version of Up One where intermediate vertices are not created. The algorithm is somewhat simpler than the origi- nal Up One algorithm by Andersen and Hulgaard [AH97] (Algorithm 2.6). Instead of returning a vertex, Up One0 returns a pair of vertices. The cor- respondence between Up One and Up One0 is:

The Up All algorithm works by sifting all variables to the root at the same time. Like for repeated use of Up One, this eliminates operator vertices and the result is a BDD. Up All is related to Bryant's Apply- operator [Bry86, Bry92] on BDDs. Converting a BED to a BDD using Up All corresponds to calling Apply for each operator vertex in the BED in a bottom up fashion. Algorithms 2.8 and 2.9 show the pseudo-code for Apply and Up All. Up All constructs BDDs in a bottom up way.

Up One pulls one variables up to the root. Up All pulls all variables up. Both algorithms can be seen as special cases of a more general Up algorithm which pulls a set of variables up. Up has not been mentioned by

Algorithm 2.8: The Apply algorithm. It assumes l and h are BDDs. The imposed total order on the variable vertices is denoted <. In the code it is assumed that terminal vertices are included at the end of this order when comparing var (l) and var (h).

The syntax of all decision diagrams are directed acyclic graphs. Each vertex represents a function f over a set of n variables. The domain is Dn and the range is R: f : Dn 7! R. Many decision diagrams, for example BDDs, have D = R = B .

The graph vertices are labeled. All decision diagrams have vertices la- beled with variables. For decision diagrams with D = B , a variable vertex typically has two extra attributes: a low and a high child. There are three main types of semantics (or decompositions) for variable vertices: Shannon (S), positive Davio (pD), and negative Davio (nD). Assume the range R and domain D are both B . Consider a variable vertex v with variable x:

The negative Davio decomposition is also referred to as the Reed-Muller decomposition. The decomposition is xed for each variable in a decision diagram. However, it is possible to use two or more di erent decompositions within one decision diagram. The three composition types can be general- ized to functions with non-Boolean ranges, see for example [DBR97a]. The moment decomposition used in BMDs and BMDs is a generalized negative Davio decomposition [BC95].

Algorithm 2.10: The Up algorithm. It pulls a set of variables s to the root of a BED u. The total order < is de ned as for Apply (see Algorithm 2.8). For readability we use the abbreviation vl for \l is variable vertex and var (l) 2 s". The terms vh and vu are de ned in a similar way with h and u, respectively, instead of l.

Edges in decision diagrams are always directed. Sometimes edges carry attributes. A typical attribute is a negation mark. A negation mark means that the function of the vertex pointed to by the edge should be negated. Most decision diagrams can have negations on the edges, and we do not men- tion it explicitly. Other possible edge attributes are weights ( BMDs [BC95] and EVBDD [VPL96, LPV94]) and existential and universal quanti ers (XBDDs [JPHS91]).

In 1996 and 1997, Hett, Drechsler, and Becker presented a new method for BDD construction [HDB96, HDB97]. They called it MORE for Multi- operand synthesis OR-operations based on Existential quanti cation. Their idea is to introduce extra variables, so called coding variables, in the BDD. The coding variables are implicitly existentially quanti ed. Vertices contain- ing a coding variable are in e ect OR-vertices since (9s : s ! f; g) $ (f _ g) assuming that f and g do not depend on s. MORE constructs the BDD

For simplicity we say that we are comparing two circuits when in fact we are comparing the propositional logic formulae obtained from the descriptions of two circuits. Since we always deal with descriptions of circuits, we can never skip a test of the nal hardware circuits. Formal veri cation proves that the design works, but testing examines the physical implementation of the design. Formal veri cation and testing complement each other.

The functionality of the two circuits may not be 100% speci ed. Or the two circuits may be at di erent levels of abstraction. To take care of such situations, it is convenient to specify a set of variable assignments called the care-set. The care-set is the set of variable assignments for which f and g should evaluate alike. Outside the care-set, f and g may take di erent values. Let c be the characteristic function for the care-set. Then this problem can be cast as the tautology problem for c ! (f $ g).

We measure the size of a BED as the number of vertices it has. Almost all BED algorithms have runtimes depending on the size of the involved BEDs. By keeping the BED size down, we get faster algorithms and less memory usage.

Recall from Section 1.2 that not all 16 binary Boolean connectives are needed in propositional logic. Only a small number of them are necessary to express all the others. A set of connectives able to express all other connectives is called functionally complete. For example, the sets f^; _; :g and f^ g are both functionally complete.

The same idea can be applied to operator vertices in BEDs. Instead of allowing all binary Boolean connectives as op attributes, we can restrict ourselves to any functionally complete set. The remaining operators can be obtained using multiple ones from the set. Should we use a small or a large set of operators?

We apply our rules recursively. Rule (1) normalizes an operator vertex. Since the set of connectives we use is closed under symmetry, this does not introduce extra vertices. Rule (3) and (4) may replace an operator with a negation. In all other cases the rewriting rules locally reduce the number of connectives (and thus the number of operator vertices) in the BED. Thus,

 u is identical to u except that shared vertices are duplicated so no vertex has in-degree larger than one. Think of as an operator which turns a DAG into a tree. Consider a BED before (u) and after (u0) the application of a rewriting rule. Then the size of u0 is less than u, where size is measured in number of vertices. The only exceptions are rule (1) and part of rules (3) and (4) where the size is unchanged.

One could go a step further and extend the rewriting rules to even greater depth. This poses the question of which rewriting rules to include? With a greater depth it is no longer feasible to tabulate all possibilities. There is also no need to include rules which are combinations of a number of simpler rules. Another question is how do we match a BED against the rules? Ho mann and O'Donnell [HO82] show di erent methods for pattern matching in trees. Similar techniques must be developed for the BED structure.

A second simpli cation method, based on a greedy strategy, is Up One- minimizing. Each variable is in turn pulled to the root of the BED using Up One. If it shrinks the BED in size, then the new BED is kept, otherwise it is discarded and we continue to use the old BED. The process continues until no variable shrinks the BED further. The result depends on the order in which the variables are tried. Up One-minimizing can be generalized to n variables instead of just one variable. In the general version, n variables are Up One'ed, and the result is kept if it is smaller than the original BED. We continue until Up One of no combination of n variables shrinks the

is small. Typically, these heuristics consist of three steps to obtain a single global variable order: rst, an order of the primary outputs is constructed. Second, for each of the primary outputs in this order, the variables in the support of the output are ordered. Third, the orders for the di erent outputs are merged into a single global variable ordering. We only consider the step of nding a variable ordering for a given primary output, since di erent variable orders can be used for di erent roots of a BED. This allows a greater exibility in nding good variable orders since the orders of the primary outputs are independent. However, the cost is that there is no or little reuse between verifying di erent primary outputs. In most BDD packages, all BDDs must respect the same ordering of the variables.

Since Up All essentially works as Apply (property (iii) of Observa- tion 2.3.3), the variable orders that are good for BDDs are also good orders to use with Up All. Thus, when using Up All we can immediately use the variable ordering heuristics developed for BDDs.

has dependent variables close in the order. This allows Up One to collapse sub-circuits early in the veri cation process. Also, a good variable order has the variables that a ect the output the most early in the order. Up One then pull these variables to the root rst which allow the most reductions.

A number of variable ordering heuristics are based on a depth- rst traversal of the circuit [CHP93, FFK88, MWBSV88]. A depth- rst traversal is a sim- ple and fast heuristic that has shown to be practical for most combinational circuits [CHP93, JPHS91] since inputs that are close together in the circuit are also placed together in the ordering. The depth- rst based heuristics di er in how they decide in what order the inputs of a gate are visited. The Fanin heuristic by Malik et. al. [MWBSV88] uses the depth of the inputs to a gate to determine in what order to consider the inputs:

The Fanin heuristic does not capture that variables that a ect the output the most should be ordered rst, something which is particularly important for Up One. The Depth Fanout heuristic [Min96], shown for BEDs in- stead of circuits in Algorithm 3.10, attempts to determine the variables that a ect an output the most by propagating a value from the output backward toward the primary inputs. The value is distributed evenly among the input signals to a gate: if a value of c is assigned to the output of a gate with

n input signals, the value assigned to each of the n fanin signals is incre- mented by c=n (the signal may be input to several gates and thus obtains a contribution from each gate). After propagating the value throughout the circuit to the primary inputs, the Depth Fanout heuristic adds the pri- mary input with the highest value to the variable order. This input is then removed from the circuit and the process is repeated until all variables in the support have been included in the variable order.

BED to BDD conversion using Up One and Up All is not the only way to solve the satis ability and tautology problems for BEDs. St almarck's method [SS98] is a patented algorithm for tautology checking of formulae in propositional logic. In this section we show how to adapt St almarck's method to BEDs.

From a formula f we construct a parse-tree. Each leaf vertex contains a Boolean variable and we label such vertices with the variable they contain. Each internal vertex contains a Boolean connective. We label each internal vertex with a new unique Boolean variable. From such a parse-tree we construct a set of triplets | one triplet for each internal vertex. A triplet is a constraint on the variables of the internal vertices expressed in terms of the operator of the vertex and the variable labels of the children.

The zero-saturation of  deduces from  all possible relations between triplet variables based on the rules in A. Algorithm 3.13 shows the pseudo- code for 0-Sat. The sign `1 in line 4 indicates application of exactly one rule in Au to one axiom in C . In line 6, we update U with the parents of x and y as well as x and y themselves (discarding any negations as well as 0 and 1).

De nition 3.4.1 (Hardness). A formula for a tautology is said to be n- easy if it can be proven to be a tautology using n-saturation. The same formula is said to be n-hard if it cannot be proven by (n  1)-saturation.

St almarck's method works on triplets constructed from the parse-tree for a formula. BEDs o er a representation of the parse-tree for a formula where identical subexpression have been merged. A triplet in St almarck's method contains a Boolean connective and references to two other triplets. Substi- tute \vertex" for \triplet" and we have a description of operator vertices in BEDs. This similarity leads us to implement St almarck's method using BEDs as the underlying data structure.

The parents of a triplet/vertex are not readily available in BEDs. All edges are directed toward the children and not the parents. However, in a single pass through the BED structure we can label all vertices with the set of their parents. This is linear in the size of the BED and we only have to do it once.

The order in which we iterate through the variables in the set U in Algo- rithm 3.14 has no in uence on the results of the algorithm. However, it does have an e ect on how fast we obtain the results. We have experimentally found that a most-popular-vertex- rst strategy (highest fan-in and fan-out) gives good results. The reason for this is that information is spread to many neighbors fast. On our examples, other methods like top-down-breadth- rst and top-down-depth- rst run slower than most-popular-vertex- rst.

ever, the di erences are not large. Even though the Fanin heuristic gives an order of magnitude better results in some cases, there are only 10 to 15 seconds of time di erence. Most of this di erence stems from the fact that calculating the variable ordering using Depth Fanout is more expensive than using Fanin. Using Up All it was not possible to verify the c6288 case. This is because the c6288 circuit is a 16-bit multiplier. Bryant [Bry86] has shown that there exists no good BDD variable ordering for multipliers. In [YCBO98], the BDD size of a 16-bit multiplier is given to around 40 mil- lion vertices3. With Up All we try to construct the BDD for each of the two multipliers. With only 32 MB of memory we fail.

Up All does almost as well for the erroneous circuits. Only in one case (Depth Fanout on c2670 versus c2670nr-err) is Up All unable to perform the veri cation. In the other cases, Up All takes slightly longer for the erroneous circuits than for the correct ones.

Like for Up All, Up One does also well for the erroneous circuits. Again the case of Depth Fanout on c2670 versus c2670nr-err is prob- lematic. In most of the other cases, Up One takes slightly longer for the erroneous circuits than for the correct ones.

Kunz et. al. [KPR96] and Pradhan et. al. [PPC96] use a technique based on recursive learning combined with BDDs. The reported runtimes are com- parable to the BED runtimes for the smaller circuits, but for the larger cir- cuits their method shows a degradation in performance. The BED approach is in some cases two or three orders of magnitude faster.

Matsunaga [Mat96] uses a BDD based approach to exploit the structural information on the circuits. His results are comparable to the BED results. For some examples like the c7552 circuits, the BED approach is faster. On other examples like the c3540 circuits, his methods is faster.

Only 13 of the 234 LGSynth'91 problems are not veri ed in 32 MB of memory and 15 minutes by all four BED methods. Of these 13 problems, only ve are not veri ed by any BED method. Two of the ve are veri ed by CUDD. The remaining 221 problems are veri ed by all four methods; 165 of these are veri ed in less than 5 seconds for all methods. CUDD solves all but four problems. The following tabulars summarize the results:

 The two methods using the Depth Fanout heuristic have generally longer runtimes than the other methods. We attribute some of it to the Depth Fanout algorithm, which is more complex and time consuming than Fanin. For example, the Depth Fanout heuristic spends around 640 seconds on computing the variable orderings for the 684 outputs of s15850.1-map problem. For comparison, the Fanin heuristic uses just a second or two. For problems with many variables (s15850.1-map has 611 input variables), the Depth Fanout heuristic takes a long time.

 Except for mm9b-map and mm9b-opt, when CUDD is faster, the best BED method is at most 5 seconds slower. There are 17 problems for which CUDD is more than 5 seconds slower than the best BED method. (This is not counting the three cases which could only be solved by either BED or CUDD, but not both.)

^  ; _; !; ; $. At the same time we performed the rewriting rules described in Section 3.2.2. These di erences explain why our degree of hardness di ers for a couple of the test cases. Our implementation of St almarck's method is the fastest by up to an order or two of magnitude. This is also expected as

The main advantage of implementing St almarck's method in a BED framework is the additional availability of BED and BDD methods for tau- tology checking. Standard BED and BDD methods typically run out of memory before they run out of time. St almarck's method has it the other way around. Combining St almarck's method with BEDs gives the user the choice between time and memory.

Test generation techniques are also the basis for the recursive learning technique for nding logical implications between nodes in the circuits by Kunz et. al. [Kun93, KP94]. To enable the veri cation of larger circuits, the recursive learning techniques can be combined with BDDs [KPR96, PPC96]. The learning technique is further extended by Jain et. al. [JMF95] and by Matsunaga [Mat96], introducing more general learning methods based on BDDs and better heuristics for  nding cuts in the circuits to split the ver- i cation problem into more manageable sizes. Recursive learning is closely related to St almarck's method [SS98]. Both methods work by performing a number of 0/1 splits and then combine the knowledge learned in the two cases. For a conjunctive normal form (CNF) formula, the di erence between St almarck's method and recursive learning is that for the former you split on the variables while in the latter you split on the clauses.

Cerny and Mauras [CM90] present another technique for comparing two circuits without representing their full functionality. A relation that repre- sents the possible combinations of logic values at a given cut is propagated through the two circuits. A key problem with this and the other cut-based techniques [KPR96, Mat96, PPC96, vE97, vEJ94, JMF95] is that the perfor- mance is very sensitive to how the cuts are chosen and there is no generally applicable method to chose appropriate cuts.

The technique by Kuehlmann and Krohm [KK97] and later by Ganai and Kuehlmann [GK00] represents a recent development of the structural methods, combining several of the above techniques and developing better heuristics for determining cuts. Kuehlmann, Krohm and Ganai represent the combinational circuits using a non-canonical data structure which is similar to BEDs except that only conjunction and negation operators are used. This data structure is only used to identify isomorphic sub-circuits since no operator reductions are performed. We believe that the structural technique by Kuehlmann, Krohm and Ganai would bene t signi cantly from replacing the used circuit representation with BEDs.

Second, we discussed the variable ordering problem. Just like BDDs, BEDs are sensitive to the order in which the variables are pulled up using Up One. We examined two ordering heuristics developed for BDDs. Both gave good results when used on BEDs.

Third, we examined St almarck's method for solving the tautology prob- lem. We discussed the method and illustrated how to implement it on top of the BED data structure. The method works for combinational circuit veri cation, but it is much slower than Up One and Up All. However, St almarck's method uses little memory.

In this chapter we present a method for verifying that two hierarchical com- binational circuits implement the same Boolean functions. The key new feature of the method is its ability to exploit the modularity of the circuits to reuse results obtained from one part of the circuits in other parts. We demonstrate the method on large adder and multiplier circuits. This chapter is based on the paper [WHA99].

Due to the increase in the complexity of design automation tools and the circuits they manipulate, such tools cannot in general be assumed to be correct. Instead of attempting to formally verify the design automation tools, a more practical approach is to formally check that a circuit gener- ated by a design automation tool functionally corresponds to the original input. This chapter presents a technique for formally verifying that two hierarchical combinational circuits implement the same Boolean functions. The presented technique can also be used to check manual modi cations of a circuit to ensure that the designer has not introduced errors.

The outputs of a hierarchical combinational circuit are determined by the inputs. In the case of the 4-bit adder, the outputs are the sum of two 4- bit numbers on the inputs. We use a relation Rel(c) to capture this relation between the inputs and the outputs of a cell c. For a logic cell, Rel is determined by the logic of the gates (the Fct attribute):

De nition 4.2.5 (Cut). A cut K in a container cell c is a set of variables from Vars(c) such that any path p = hp1;::: ; pni through c with p1 2 In(c) and pn 2 Out(c) contains exactly one variable from the cut K.

The veri cation algorithm works by propagating a cut-relation from the inputs to the outputs. Let H0 be the input relation Hin, a cut-relation between the input cuts of c1 and c2. We move their cut-relation past instan- tiations of cells in c1 and c2 (assuming that c1 and c2 are container cells). In each step we calculate a new cut-relation, Hk+1, based on the previous one, Hk. When the cut-relation has reached the outputs, the resulting cut- relation, Hn, relates the outputs of c1 to the outputs of c2. If Hn is a subset of Hout, Hn  Hout, the circuits have the desired output relation.

We distinguish between two ways of moving cuts: Build and Propagate. Build determines the input/output relation Rel for a cell c and uses it to calculate the new cut-relation by moving the cut past an instantiation of cell c. Propagate moves cuts past two cells simultaneously by calculating the input relation Rin between the inputs of the two cells and from that calculate the output relation Rout for the same pair of cells. In the example above we only used Propagate.

an instantiation i, a cut-relation H, and a cut K. It is assumed that all input variables for i are in the cut. The lines 1 and 2 calculate the input/output relation for cell(i) using instantiation variables, line 3 calculates the new cut-relation, and line 4 calculates the new cut.

The Propagate algorithm shown in Algorithm 4.5 considers two cell instantiations at a time; one in each circuit. Propagate takes ve argu- ments; two instantiations i1 and i2, two cuts K1 and K2, and a cut-relation H over the cuts. The result is a new cut-relation and two new cuts. It is

Algorithm 4.4: The Build(i; H; K) algorithm where i is an instantiation, H is a cut-relation, and K is a cut. The output of the algorithm is a pair: a new cut- relation and a new cut. The algorithm moves the cut K past instantiation i and updates the cut-relation H accordingly.

Algorithm 4.5: The Propagate(i1; i2; H; K1; K2) algorithm. Both i1 and i2 are instances of container cell. H is a cut-relation over the cuts K1 and K2. The algorithm moves the cuts past the cell instances and updates the cut-relation ac- cordingly.

In line 1 Propagate calculates, using (4.2), the input relation Rin be- tween i1 and i2 based on the cut-relation H. The input relation Rin is described in cell variables, not in instantiation variables. Next, we calculate the output relation Rout for i1 and i2. If we have previously propagated a similar cut past the same cells, we reuse the previous result (line 3). Other- wise we have two ways of calculating Rout. If both i1 and i2 are instantiations of container cells, we can propagate the cut through these instantiations (line 5) by calling Prop, which allows us to use Propagate on the container cells. Alternatively, we compute Rout from the input/output relation Rel for each of the instantiations i1 and i2 (line 6). This resembles calling Build twice. The rest of the algorithm updates the cuts and calculates the new cut-relation.

Build works by constructing a representation of the input/output rela- tion for a cell which is used to update the cut-relation H. Such a relation captures the functionality of the cell. Using Build on the top cell corre- sponds to the standard veri cation method of building the BDD for the entire circuit. While this works well for smaller circuits, the BDDs tend to become quite large for more complex circuits.

Propagate works by moving a relation between input variables of two cells to a relation between output variables of the same two cells. In case of container cells, Propagate moves the cuts one step at a time past in- stantiations of cells in the container cells. It avoids constructing a BDD for the functionality of a cell as long as possible. For logic cells it is necessary to construct such a BDD. However, this BDD represents only the function- ality of a part of the circuit, not the whole circuit, and it is therefore more manageable.

cut-relation (s0 $ t0) ^ (s1 $ t1) when calling Propagate. We want to move the cuts past the negation cells. The new cuts contain the variables s1 and s2, and t0 and t2. We build the input relation Rin for the two negation cells:

where i1 and i2 are instantiations of the two negation cells. In this case Rin evaluates to 1, meaning that the inputs are unrelated; knowing the value of s0 does not imply a particular value of t1, i.e., they are unrelated. Rin = 1 results in H1 also being 1 and not the expected (s1 $ :t2) ^ (:s2 $ t0).

Cerny et. al. [CM90] split circuits into cells and each cell is described by a relation between the inputs and the outputs of the cell. Using a sweep strategy, they move either forward or backward through the circuits calcu- lating the relations between the circuits along a cut. The cells are lower level logic primitives and thus Cerny et. al. have a modular model, but not a hierarchical one.

We have presented a method based on cut-propagation for obtaining a rela- tion between the outputs of two hierarchically speci ed combinational cir- cuits. The key new feature of the method is its ability to exploit the hier- archy in the circuit description to reuse previously calculated results in the veri cation. We have demonstrated the power of the method by verifying large adders and multipliers.

The performance of the method depends on the order in which we pick the subcells when propagating cuts from the inputs to the outputs of con- tainer cells. Some orders may result in cut-relations which have large BDD representations. It helps if the hierarchical structure of the two circuits are similar. That way it is easier to pick good candidate subcells for propagating the cuts.

In this chapter we show how Boolean Expression Diagrams can be used in symbolic model checking. We present a method based on standard xed- point algorithms, and we use both BDDs and SAT-solvers to perform sat- is ability checking. As a result we are able to model check systems for which standard BDD-based methods fail. This chapter is partly based on the paper [WBCG00].

Symbolic model checking has been performed using xed-point iterations for a number of years [BCM+92, McM93]. The key to the success is the canonical Binary Decision Diagram (BDD) [Bry86] data structure for repre- senting Boolean functions. However, such a representation explodes in size for certain functions. Biere et. al. [BCC+99, BCCZ99, BCRZ99] introduced Bounded Model Checking as a way of avoiding BDDs. Instead of performing a xed-point iteration, they construct formulae for possible counterexamples and use SAT-solvers to prove or disprove the existence of such counterexam- ples. Abdulla et. al. [ABE00] also use SAT-solvers but keep the xed-point iterations.

In this chapter we combine BDDs and SAT-solvers in symbolic model checking based on xed-points. We use Boolean Expression Diagrams as the underlying data structure. The method is theoretically complete as we only change the representation and not the algorithms.  Going from a BDD to a BED representation, we have to give up canonicity. That has both advantages and disadvantages: Non-canonical data structures are more succinct than canonical ones { sometimes exponentially more succinct.

 xed-point iterations. One of the key elements of our method is the quan- ti cation by substitution rule:  9y : g ^ (y $ f ) $ g[f =y]. The rule is used (1) during xed-point iterations, (2) while deciding whether an initial set of states is a subset of another set of states, and nally (3) while doing iterative squaring.

The quanti cation by substitution rule helps remove some of the quan- ti cations. However, the remaining quanti cations still cause trouble in the form of a size explosion when we eliminate them. In the last part of the chapter we investigate the possibility of skipping the quanti cation of the remaining variables by simply leaving the variables in the formula.

In this section we describe model checking. We rst use set theory as the underlying theory. Then we rede ne model checking in terms of Boolean functions3. The systems we consider are nite state machines (FSMs) rep- resented by nite Kripke structures [HC74, CGP99].

De nition 5.2.1 (Finite Kripke Structure). A nite Kripke structure M is a tuple (SM ; IM ; T M ; `M ) with a nite set of states SM , a set of initial states IM  SM , a transition relation T M  SM  SM , and a labeling of the states `M : SM 7! P(A) with atomic propositions A.

This example seems to indicate that there are two kinds of state variables: Those that are restricted and those that are unrestricted. The restricted variables carry the information on which state we are in. The unrestricted variables carry the information of the inputs to the system. We use a modi-

De nition 5.2.2 (Modi ed Kripke Structure). A modi ed Kripke struc- ture M is a tuple (S; X; I; T; `) with a nite set of states S, a nite set of inputs X, a set of initial states I  S, a transition function T : S  X 7! S, and a labeling of the states ` : S 7! P(A) with atomic propositions A.

The transition function T speci es all the possible behaviors of a system. An FSM can only move from state si to state sj if there is an input x such that sj = T (si; x). We say that the FSM takes a transition from si to sj on input x.

Since the transition function is de ned for all (s; x) 2 S  X, it means that it is always possible to take a transition. Self-loops, i.e., transitions leading from one state to itself, are allowed. There are no dead-end states and thus all nite paths can be thought of as pre xes of in nite paths.

Given a state in a Kripke structure M and a CTL speci cation  for M , then either holds or does not hold for that state. Thus a CTL formula represents a set of states, namely the states for which the CTL formula holds. We denote that set of states [[ ]].

Model checking is the process of determining whether a Kripke structure M = (S; X; I; T; `) is a model of a CTL formula . We write M j=  to indicate that M models  . In the following, when we write CTL formulae, we also assume a given system M .

A CTL formula contains a propositional logic part with constants, nega- tion, conjunction and disjunction. Furthermore, it contains a number of temporal operators each consisting of a path quanti er and a path operator. There are two path quanti ers: E (\there exists an in nite path") and A (\for all in nite paths"). There are ve path operators:

In model checking of a Kripke structure M = (S; X; I; T; `), we use set transformers of the type  : P(S) 7! P(S). Algorithm 5.3 shows the pseudo-code for the least xed-point operator Lfp and the greatest xed- point operator Gfp, respectively.

The semantics [[ ]] of a CTL formula  is a set of states. For example, the CTL formula EG  denotes the set of states [[EG ]] such that from each state in [[EG ]] there exists an in nite path on which holds globally. Four of the most common CTL operators are EF, AF, EG, and AG. One may think of them as follows:

For both state and input variables we use subscripts to indicate ele- ments of the vector and superscripts to indicate di erent vectors. For state variables, we use the convention that unprimed variables encode the current state while primed variables encode the next state. For example, s0 = T (s; x) indicates a transition on input x from current state s to next state s0.

In the set version of model checking, each state was labeled with a set of atomic propositions. The atomic propositions were not speci ed. Now we assume that the atomic propositions are state variables. This means we can change the CTL grammar from De nition 5.2.6 to re ect this. De ni- tion 5.2.12 shows the modi ed CTL grammar.

De nition 5.2.13 (Modi ed CTL Semantics). Given a Kripke struc- ture M = (S; X; I; T; `), the semantics of a CTL formula is a set of states [[ ]] P(S) as described in De nition 5.2.10. In terms of characteristic functions, [[ ]] is a Boolean function of the state vector s de ned recursively as follows:

De nition 5.2.14 (Modi ed Model Checking). Let M = (S; X; I; T; `) be a Kripke structure and let be a CTL speci cation for M . We say that M models , and write M j= , if TAUT(I ! [[ ]]).

The second step was to compute a BED for [[ ]] using De nition 5.2.13. The rst six lines of the de nition are straightforward: The BED is con- structed recursively by adding either a terminal, a variable, a negation, a disjunction or a conjunction vertex. The three temporal operators are more interesting.

Abdulla et. al. [ABE00] also use quanti cation by substitution in their model checking algorithm. They call it inlining. One can think of quanti cation by substitution as a special case of pruning which we described in Section 3.2.3. We use the quanti cation by substitution rule in three places: EX com-

Quanti cation by substitution works for the quanti cation of the state variables in EX. The reason is our assumption on the form of T , where each next-state variable has a corresponding next-state function. Unfortunately, we cannot use quanti cation by substitution for the quanti cation of input variables since their values are not bound to a function as is the case for the next-state variables.

The [Ii=si] means a substitution of Ii for si. In the third step we use quanti - cation by substitution to replace a quanti cation by a substitution. In many cases the Ii functions are quite simple, e.g., a constant. In such situations this method reduces the number of variables and simpli es the formula.

Consider the case where I is a singleton set, i.e., there is only one initial state. Assume without loss of generality that this initial state is (0;::: ; 0). Our preprocessing step would simply replace all state variables in [[ ]] with zeros. There would be no variables left, and thus the whole expression would trivially reduce to either 0 or 1 making the check for tautology trivial.

Algorithm 5.5 shows how to compute [[EF ]] using a least xed-point method and iterative squaring. EX(2n ) is the EX operator with T (2n ) as transition function. After each iteration in the while loop, Q0 represents the set of states reachable in up to and including 2n  1 steps.

 The speci cation holds. This means that I ! [[ ]] is a tautology. We could use a SAT-solver to prove that the negation of I ! [[ ]] is not satis able. However, it is our experience that most SAT-solvers are not very good at proving a formula to be unsatis able. We can also use BDDs. By using the Up One algorithm, we can convert the BED for I ! [[ ]] to a BDD. This results in the BED 1.

SAT-solvers like Grasp [MSS99] and Sato [Zha97] expect their input to be a propositional formula in CNF. We must therefore convert our BEDs into CNF. For this conversion we use the technique of introducing new variables for every non-terminal vertex [BCC+99].

We convert a BED to CNF by introducing k extra variables { one for each non-terminal vertex in the BED. This avoids an exponential blowup of the size of the resulting CNF. However, we do increase the size of the state space by a factor of 2k which is unfortunate.

In this section we give an example of model checking using BEDs. We use a modulo-4 counter which only counts one type of events. The counter should start out being zero. Every time an event e happens, the counter should increment by one. The increments are done modulo 4. If an event other than e happens (we also consider idle an event, namely the event that no other event happens), then the counter keeps its value.

To implement such a modulo-4 counter, we need two Boolean state vari- ables s0 and s1. The value of the counter is the binary number s1s0. The input variable x models the presence and absence of event e: x is true if event e takes place6.

Q1 is s0_ s1, which is the result of the BED simpli cations from Section 3.2 applied to :s0 ^ :s1. The Q2 approximation is s0_ s1 _ EX Q1. The second line in the Q2 calculation shows the result after quanti cation by substitution by Algorithm 5.4. The third line shows the simpli ed formula. The fourth line shows the formula after quanti cation of the input x. The

We have constructed a prototype implementation of our proposed model checking method. It performs CTL model checking on SMV programs. For the experiments presented here we use Sato as our SAT-solver. We compare our method with the NuSMV model checker (release 1.1) [CCGR99] and with Bwolen Yang's modi ed version of SMV7, both of which are state- of-the-art in BDD-based model checking. Finally we compare reachability results with FixIt from Adbulla, Bjesse, and E en [ABE00].

This example comes from the BMC-1.0f distribution9. It is a 16  16 7! 32 bit shift-and-add multiplier. The speci cation is the c6288 combinational multiplier from the ISCAS'85 benchmark series [BF85]. For each output bit we verify that we cannot reach a state where the shift-and-add multiplier has nished its computation and the output bits of the two multipliers di er. The multiplier ts into the category of SMV programs that we handle well. The operands are not modeled as inputs. Instead they are modeled as state variables with an unspeci ed initial state and the identity function as the next-state function. This lets us use quanti cation by substitution for

by the BDD to BED conversion of I ! [[ ]]. The size of the BED for I ! [[ ]] as a function of the output grows as a polynomial with degree around 3/2. Since the BDD to BED conversion is exponential, this explains the super- exponential curve for the BED method. It looks as if the FixIt method has a better asymptotic behavior and will from output 14 or 15 be the faster method. However, both methods have at least exponential runtimes and neither method handles more than the rst 13 outputs at the moment.

We were able to nd a bug in the \correct" speci cation of the multiplier for the two most signi cant outputs. Iterative squaring allowed us to quickly compute the xed-points, and Sato instantly found the errors. The total runtimes to nd these errors were seven and eight seconds, respectively. It turns out that the two outputs have been swapped. The original net-list for c6288 does not contain information about which gates correspond to which multiplier outputs. However, each gate is numbered and the output numbers seem to be increasing with the gate numbers { with the exception of the last pair of outputs. This emphasizes the fact that SAT-based methods are good at nding bugs in a system.

This example is a barrel shifter from the BMC-1.0f distribution and like the multiplier, it also falls within the category of systems which we handle well. A barrel shifter consists of two register les. The contents of one of the register les is rotated at each step while the other le stays the same. The width of a register is log2 R, where R is the number of registers in the register le.

In this section we examine how to do model checking using quanti ca- tion by substitution for state variables and unfolding for input variables. We leave the input variables in the formulae instead of quantifying them out. Unfortunately, this means we cannot detect xed-points and hence we restrict ourselves to a xed-depth. Another drawback is that we have to restrict ourselves to a subset of CTL. However, by placing ourselves half way between BMC and standard xed-point methods, we can hope to handle

De nition 5.5.2 (lfp-CTL Semantics). Given a Kripke structure M = (S; X; I; T; `), the semantics of an lfp-CTL formula is a set of states [[ ]] P(S). In terms of characteristic functions, [[ ]] is a Boolean function of the state vector s de ned recursively as follows:

Proof. (by induction) The lemma holds for k = 0: ;  (;). Assume it holds for k = j  1: j 1(;)  j(;). As  is monotonic, we can apply on each side: ( j 1(;))  ( j(;)) After regrouping we get j(;)  j+1(;), which shows that the lemma holds for k = j.	ut

Proof. We rst prove [[ ]]k  [[ ]]k+1 by induction over the recursive depth of the semantics in De nition 5.5.2. We use set notation in the argumentation. The four base cases 0, 1, si and :si trivially hold. The disjunction case

monotonic set transformer . We prove the inclusion for [[EF ]]k; the other cases are handled in a similar way. Let 1 be the set transformer [[ ]]k [EX Z and  2 the set transformer [[ ]]k+1 [ EX Z. We prove by induction that

Proof. First we prove the existence of d. From Theorem 5.5.5 we know that [[ ]]k [[ ]]k+1. For each Lfp-computation, each step either adds at least one new state or we are at a xed-point. Since the state space is nite there exists

Now we prove that [[ ]]d = [[ ]]. Let s be some state in [[ ]]d. Then s is also in [[ ]]d+i for all i > 0 and thus more iterations in the least xed-point calculations do not result in any new states. We must therefore have reached

De nition 5.5.8 ( -renaming). Let  be a function of input variables xi;::: ; xi+j, then is a renaming of the input variables such that  is a function of xk;::: ; xk+j where xk;::: ; xk+j are new, fresh variable vectors.

The restriction in Theorem 5.5.11 that I has to be a singleton set is to prevent an alternation of quanti ers. The typical check is whether I is a subset of [[ ]]k. In terms of characteristic functions we check 8s : I ! [[ ]]k. However, since we compute [ ]k and not [[ ]]k, we would introduce an

ourselves to exactly one initial state, it is enough to check whether I and [[ ]]k have a state in common. It is possible to overcome this restriction by constructing a new system with a new single initial state ~i and transitions from ~i to all states in the old set of initial states I. Using the AX operator we go one step backward and only include ~i if all states in I were in [[ ]]. Unfortunately, the computation of [AX ] contains quanti cations so unless we nd some smart way of handling [AX ], we have just pushed the problem from a restriction of I to AX computation.

We use BEDs to represent the Boolean formulae. Each state variable cor- responds to a BED variable. Boolean connectives (negation, conjunction, disjunction) correspond to operator vertices. -renaming corresponds to variable substitution. We use quanti cation by substitution for quanti ca- tion of state variables.

Recall that we only have one initial state. Since we have a conjunction be- tween this state and [ ]k, we can compute SAT(I ^ [ ]k) as SAT([ ]k(I)), where [ ]k(I) means a substitution of all state variables in [ ]k with their unique assignment from I. This leaves only input variables. SAT-solvers like Grasp [MSS99] and Sato [Zha97] can then be used to determine sat- is ability.

Biere, Clarke et. al. have proposed Bounded Model Checking (BMC) as an alternative method to BDD-based model checking [BCC+99, BCCZ99, BCRZ99]. They unfold the transition relation and look for repeatedly longer and longer counterexamples, and they use SAT-solvers instead of BDDs. BMC is good at nding errors with short counterexamples. The diameter of

The three temporal logics have di erent expressive powers. There are CTL formulae not expressible in LTL, and vice versa. CTL* is a superset of both CTL and LTL. Any CTL and LTL formula is expressible in CTL*, however, there are CTL* formulae not expressible in either CTL or LTL. Please see [CGP99] for a full discussion on CTL, LTL, and CTL*.

Converting a formula to CNF is necessary for standard SAT-procedures like Greedy SAT (GSAT) [SLM92] and Davis-Putnam [DP60, DLL62]. The CNF conversion may lead to an exponential growth. A way to overcome this is to introduce new variables, each representing a subformula in the original formula. Unfortunately, this greatly enlarges the search space for the SAT-

procedures. Research has been made in the area of applying SAT-procedures to formulae not in CNF. Giunchiglia and Sebastiani [GS99, Seb94] have examined GSAT and Davis-Putnam.  St almarck's method also works on a non-CNF representation. Chapter 6 discusses how to do satis ability checking on the BED data structure.

Symbolic model checking can be expressed in QBF. We can think of our model checking algorithm as a decision procedure for QBF. Both Cadoli et. al. [CGS98] and Rintanen [Rin99] have presented algorithms for evaluation of QBF. Their work has been centered on the AI community and they have, as far as we know, not experimented with their QBF algorithms on model checking problems.

We have presented a BED-based CTL model checking method based on the classical xed-point iterations. Quanti cation is often the Achilles heel in CTL xed-point iterations but by using quanti cation by substitution we are in some cases able to deal e ectively with it. While our method is complete, it performs best on examples with a low number of inputs. In this case we can fully exploit the quanti cation by substitution rule.

In order to deal with the input variables, we have proposed lfp-CTL model checking. Inputs are left in the formulae and SAT-solvers are used to implicitly quantify them out when needed. Unfortunately, this restricts the power of the logic. Only reachability analysis is practically possible.

Future work includes investigating two variable ordering problems. One is the variable ordering when converting the BED for I ! [[ ]] to a BDD. The variable ordering is known to be very important in BDD construction, and since we, in some cases, spend much time on converting I ! [[ ]] to a BDD, our method will bene t from a good variable ordering heuristic. The other problem is the order in which we quantify the variables in the [[EX ]] computation. This is interesting especially in cases where we cannot use the quanti cation by substitution rule. Finally, it would be worth looking into

In this chapter we show how to determine satis ability of a formula repre- sented by a Boolean Expression Diagram. We compare our method with traditional SAT-solvers and with BED to BDD conversion. This chapter is based on the paper [WAH01].

or a \no, the formula is not satis able" answer. The resulting BDD encodes all possible variable assignments satisfying the formula. This is overkill as we are only interested in one of them { and sometimes just the existence of one.

A formula on conjunctive normal form (CNF) consists of a set of clauses. Each clause contains a number of literals, where a literal is either a variable or the negation of a variable. The literals within a clause are OR'ed together, whereas the clauses are AND'ed together.

5 handles unit clauses, and line 8 and 9 handle splitting on literals. There are di erent heuristics for choosing a literal in line 8. One heuristic is to choose the literal in such a way that the assignments in line 9 produce the most unit clauses.

If at any point we reach the terminal 1, then we know that the formula is satis able. This suggests a recursive algorithm which pulls up variables one at a time. The test for the empty set of clauses (line 1 in Algorithm 6.1) becomes a test for the terminal 1. The test for whether contains the empty clause (line 3) becomes a test for the terminal 0. We cannot nd unit clauses with BEDs. The unit clauses are used to reduce the CNF formula. Instead we use another type of reductions: The rewriting rules from Section	3.2.2.

The function choose-variable in line 6 of Algorithm 6.2 picks a variable to split on. With a clause form representation of the formula, it is natural to pick the variable in such a way as to obtain the most unit clauses after the split. This gives the most reductions due to unit propagation. We do

not have a clause form formulae. However, we can still choose the variable as to get the most reductions. We perform the splitting using Up One. In Section 3.3 we discussed di erent heuristics for picking good variable orderings for Up One. The rst variable in such an ordering would probably be a good variable to split on. In BedSat we do not need to split on the variables in the same order along di erent branches. We have chosen a simple implementation which does a depth- rst traversal of the BED and picks the rst variable it encounters.

In line 9 the algorithm forks in two: one fork for the low child and one fork for the high child. If a satisfying assignment is found in one fork, then it is not necessary to consider the other one. We have implemented a simple strategy of rst examining the fork with the smaller BED size (least number of vertices). We do not have any a priori knowledge of which fork to choose so picking the smaller one makes sense as the runtime of Up One depends on the the size of the BED.

To see how well BedSat works in practice, we compare it to other tech- niques for solving SAT problems. The problems we use in the comparison are from the ISCAS'85 benchmark series (see Chapter 3) and from model checking (see Chapter 5). All the problems have been turned into satis a- bility problems.

73 are satis able. We indicate this with \S/U" in the second column. The Up One and Up All methods take slightly longer on the erroneous circuits since not all BDDs collapse to a terminal. The SAT-solvers (Sato, Grasp and BedSat) perform strictly better on the erroneous circuits compared to the correct circuits; sometimes going from impossible to possible as for

\Result" column, \U" indicates unsatis able problems while \S/U" indicates both satis able and unsatis able problems. Both Up One and Up All use the Fanin variable ordering heuristic. All methods were limited to 32 MB of memory and 15 minutes of CPU time. A dash indicates that the computation could not be done within the resource limits.

10 final problem which the SAT-solvers are unable to handle. The SAT- solvers perform quite well { both on the satis able and the unsatis able problems. Most of the problems are solved in less than a second by all three SAT-solvers. While both Sato and Grasp take a long time on a few of the problems, BedSat seems to be more consistent in its performance.

\U" indicates unsatis able problems while \S" indicates satis able problems. Both Up One and Up All use the Fanin variable ordering heuristic. All methods were limited to 32 MB of memory and 15 minutes of CPU time. A dash indicates that the computation could not be done within the resource limits.

A Boolean Expression Diagram is an extension of a Binary Decision Dia- gram with operator vertices. The operators in the new vertices are binary Boolean connectives. In this chapter we add other types of operators to the data structure and examine their advantages compared to a data structure without them.

The proof of 7.3 is straightforward. The rst part is a Shannon expansion of the if-then-else operator and then a replacement of h for x. In the second part we push the substitution to the children of a variable y vertex. This is correct as y is not the variable to be substituted.

In the one variable version of existential quanti cation, we use the var eld to hold the variable to quantify. Now we need a vector of variables. We represent the vector as a conjunction of the variables. The high eld contains the BED for the conjunction.

Let x be a vector of variables. Let x be one of those variable, and let y be a variable not in x . Let f and g be functions represented by BEDs. We use ; to denote the empty set of variables (a vector of dimension zero). The terminal cases for existential quanti cation are:

Let x be a vector of variables. Let x be one of those variable, and let y be a variable not in x . Let f and g be functions represented by BEDs. We use ; to denote the empty set of variables (a vector of dimension zero). The terminal cases for universal quanti cation are:

Vector substitution is a substitution of a vector of functions for a vector variables; each element in the function vector is substituted for the corre- sponding element in the variable vector. This means we need two vectors and a function in which to perform the substitutions. To t it all in the data structure we need an auxiliary vertex, which we call map.

Let x be a vector of variables. Let x be one of those variable, and let y be a variable not in x . Let f and g be functions represented by BEDs. We use ; to denote the empty map list. The terminal cases for substitution are:

In symbolic model checking, we compute [[EX  ]] as 9s0;x : T (s; x; s0) ^ [[ ]][s0=s]. BDD-based model checkers often have one specialized function for performing the vector quanti cation and the conjunction in one single step. We now show how to combine the vector quanti cation and the vector substitution in one new operator type in BEDs4. We call the new operator ESUB.

The previous vector operators had explicit vector arguments represented as BEDs. We could actually do the same with ESUB, but we chose not to do so. Instead we illustrate another method. The idea is that we need relatively few di erent vectors: It is the same set of variables we constantly quantify out, or it is the same vector of variables we substitute with the same vector of functions. We let the vectors be implicitly given.

In the case of ESUB, we quantify out the input variables and the primed state variables. Then the unprimed state variables are replaced with their primed versions. Internally in the BED each variable is assigned a number. Assume that all unprimed state variables are assigned even numbers and the primed state variables are assigned odd numbers. A primed variable has a number one higher than the corresponding unprimed variable. The input variables are assigned odd numbers. This means that odd variables should be quanti ed and even variables should be replaced by the variable with one higher number.

In this section, we propose an algorithm based on BEDs for computing the minimal p-cuts of Boolean reliability models such as fault trees. BEDs make it possible to bypass the BDD construction, which is the main cost of fault tree assessment. This section is based on the paper [WNR00].

the two constants 0; 1 2 B and the usual operators ^, _, :, x ! y; z (if- then-else) etc. A literal is either a variable x or its negation :x. A product is a set of literals that does not contain a literal and its negation. A product is assimilated with the conjunction of its elements. A minterm over X is a product that contains either positively or negatively all variables of X.

Minimal p-cuts play a central role in the assessment of fault trees. Boolean formulae describe the potential failures of the system under study; variables represent component failures. Minimal p-cuts represent minimal sets of component failures that induce a failure of the whole system. This notion should be preferred to the classical notion of prime implicants5 that also captures the idea of minimal solutions [DR97, DR98].

Positive literals represent failures of the individual components. The failure probabilities are assumed to be independent. It is the failures that are of practical interest. The failure probability of each literal is generally quite low and thus products with a large positive part represent a negligible probability. Therefore, it is in general a safe approximation to consider only products with very few positive literals.

Minimal p-cuts approximate prime implicants by considering only posi- tive parts of implicants, and k-truncated minimal p-cuts restrict the result to those of size at most k. The latter is of practical importance in qual- itative analysis of fault trees, as it identi es sets of component with high probability of simultaneous failure that would cause the entire system to fail. To determine whether there exists a prime implicant of length k or less is a  P complete problem [Pap94]. Therefore, unless NP=coNP=P, there

Theorem 7.3.2 (Dutuit & Rauzy [DR97]). Let f = x ! f1; f0 be a Boolean formula with f1 and f0 not depending on x. Then, k(f ) can be obtained as the union of two sets  k(f ) = v: 1 [  0 where  0 =  k(f0),

minimal p-cut of f . In each step of the new algorithm, the Up One trans- formation lifts the smallest variable in a set L over any Boolean operators or other variable nodes, until it reaches a PC operator. A p-cut vertex	v denotes a Boolean function which encodes the set of k-truncated p-cuts for the function f over the variables in a set L. We write PC(f )[k; L] to indicate such a vertex, and we use the following attributes:

These results should be compared with the standard method (the Up All algorithm), which is unable to calculate the p-cuts for cea9601 and wes9701. The former could not be build using 300 MB while the latter could not be build in 48 hours. For das9601 it succeeds in building the BDD for the fault tree in about 2 hours. The variable orderings used in the experiments are the ones given in the anonymous data les. The standard method depends on the variable ordering, and using improved heuristics to determine a good initial variable ordering will de nitely improve the performance. However, the Up One method will also bene t from the use of an improved variable ordering heuristic.

Extending binary decision diagrams with operators has been done by other researchers. Section 2.4 mentions some of the new data structures. The most common operators are the Boolean connectives. Jeong et. al. use exis- tential and universal quanti ers in their XBDDs [JPHS91]. Hett, Drechsler, and Becker add existential quanti ers to obtain a new method for BDD construction [HDB96, HDB97].

The idea of giving the operators vectors as arguments is also known from standard BDDs. Most BDD implementations have quanti cation and sub- stitution algorithms which allow substitution and quanti cation of vectors. The ESUB operator combines two di erent operations in the compu- tation of [[EX ]]: the existential quanti cation and the substitution. In BDD-based model checking, existential quanti cation and Apply are of- ten combined. Combinations of this kind are very e ective compared to

In this chapter we have explained how to extend the Boolean Expression Diagram data structure with new types of vertices. We have given examples of existential and universal quanti cation vertices and of substitution ver- tices. Furthermore, we have presented an operator vertex, ESUB, combining existential quanti cation and substitution.

We have shown what properties an operator must have in order to be implemented as a vertex type in the BEDs. The properties are not very strict: The operator must have a terminal case and it must distribute in some form over if-then-else. Furthermore, only a limited number of attributes are available per vertex. An operator with these properties can be implemented in the BEDs by minor modi cations to the Mk, Up One and Up All algorithms.

As a more detailed example of a new type of vertex in the BEDs, we have chosen the PC operator. Based on this operator we proposed a new method to compute minimal truncated p-cuts. It makes it possible to compute minimal truncated p-cuts directly from the BED without ever constructing the BDD representation of the fault tree (that is often of gigabyte size). The experimental results show that our method has an advantage over the BDD methods.

St almarck : Reasoning-based method. As opposed to the other two meth- ods, St almarck's method does not convert or change the formula it works on. In terms of speed, St almarck's method does not work well on circuits. However, it uses little memory.

 Use BEDs as BDDs with Up All. The rewriting rules form a prepro- cessing step which helps speed up the veri cation by reducing the size of the initial BED. Especially the combination of Up All, rewriting rules and the Fanin heuristic gives good results. Since the rewriting rules are used only as a preprocessing step, all BDD speci c techniques can be used in the construction of the BDD.

  Use Up One to convert BEDs to BDDs. This method works best if the two circuits being compared have a high degree of structural similarity. For example, the two 16-bit multipliers in the ISCAS'85 benchmark suite are easily veri ed using Up One.

Circuits described in a hierarchical way may be converted to at circuits and then veri ed by the techniques above. However, we have focused on exploiting the structural information in the hierarchical circuit descriptions. The main idea is to reuse previously calculated results.

Our method works best if the two circuits being compared have simi- lar hierarchical structures. The advantage is that instead of working with representations of the functionality of the circuits, we work with represen- tations of the relation between the circuits. We call such a relation between the circuits for a cut-relation. In some cases, the cut-relation has a simpler BED/BDD representation than the functionality of the circuits. In cases where the hierarchical structure of the circuits are quite similar, the method performs well. For example, we have successfully veri ed large adder and multiplier circuits using this technique. Unfortunately, if the circuits have dissimilar hierarchical structures, then the cut-relation may become complex and the performance of our method degrades.

The second problem domain is symbolic model checking. We have pre- sented a method for CTL model checking based on xed-point iterations. We use quanti cation by substitution for the quanti cation whenever pos- sible. Quanti cation by substitution works well with BEDs. Quanti cation of all state variables can be done in just one traversal of the BED. However, we still need to quantify out the inputs. For this purpose we use scope re- duction rules to press the quanti ers as far down as possible in the formulae. Then we perform the quanti cation using Up One.

Systems with input variables is a problem as we are not able to use quanti cation by substitution to quantifying out the input variables. We propose lfp-CTL as a means of model checking such systems. The lfp-CTL logic is weaker than CTL. However, the nature of the lfp-CTL logic is such that we (often) do not need to quantify out the inputs.

The third problem domain is fault tree analysis. We have chosen to focus on the computation of p-cuts. A p-cut is a representation of the most likely reasons for system failure. We have extended the BED data structure to facilitate p-cut computation. Using Up One, we are able to gradually transform a BED for a fault tree to a BDD for the p-cuts.

Our p-cut algorithm utilizes the fact that not all the information in a fault tree is necessary to nd the p-cuts. The standard method is to construct the BDD for the fault tree and then compute the p-cuts. However, the BDDs are often huge and in many cases it is not possible to construct them. Our method avoids the BDD construction by only concentrating on the parts of the fault tree which contribute to the p-cuts.

We have proposed a method for solving the satis ability problem based on BEDs. The algorithm BedSat uses splitting on variables to divide the problem into smaller pieces. The splits are done using Up One, which allows us to take advantage of the rewriting rules during satis ability checking. We have compared a simple implementation of BedSat with state-of-the- art SAT-solvers. On satis ability problems from model checking, BedSat performs well.

{ Use Up One rst on a number of variables. Then switch to Up All to nish the BED to BDD conversion. We have sug- gested Up One-minimizing in Section 3.2.3. This may be a start- ing point for further research.

 Our proposed SAT-procedure BedSat does not utilize premature back- tracking. As a result it sometimes gets stuck { especially when working on unsatis able problem instances. We expect that the addition of pre- mature backtracking to BedSat will make it more robust. It would also be interesting to compare BedSat with the SAT-solvers proposed by Giunchiglia and Sebastiani in [Seb94, GS99]. Their methods also work on non-clausal formulae.

formulae represented as Boolean Expression Diagrams (BEDs). A BED is a generalization of a Binary Decision Diagram (BDD) which can represent any Boolean circuit in linear space and still maintain many of the desirable properties of BDDs. This BED package contains a number of algorithms for transforming a BED into a reduced ordered BDD. One (called Up All) closely mimics the BDD apply-operator. Another (called Up One) can exploit the structural information of a Boolean circuit.

The bed tool is used to manipulate Boolean formulae repre- sented by the BED data structure. One typical use of it is to transform a BED into a (reduced and ordered) Binary Decision Diagram (BDD). There are di erent ways to do this: by us- ing upall which mimics the standard BDD apply-call, by using upone to lift the variables up to the outputs one at a time, or by using upsome which lefts a set of variables to the outputs. Another usage is to determine satis ability of a function repre- sented by a BED. This can be done with the bedsat command. A number of other commands are available to obtain informa- tion about the BED data structure. All available commands a listed below. The syntax of the arguments is described after each command.

The operators bind as you would expect. imp is the implication operator, limp is left implication, nimp is negated implication, and nlimp is negated left impli- cation. The expression expr1 < var > expr2 is the if-then-else operator where expr1 denotes the low-child and expr2 denotes the high-child.

misc-assign represents a vertex in the extended version of BEDs described in Chapter 7. The  rst NO is a unique vertex iden- ti er. The ID is a variable eld. The two last NO's are the identi ers of the low and high children.

The operators imp, limp, nimp, nlimp, and biimp are impli- cation, left implication, negated implication, negated left im- plication, and biimplication. The operators :=, ?, ! and ESUB correspond to substitution, existential quanti cation, universal quanti cation and ESUB. The rest of the operators have stan- dard names. The negation operator not takes two identical arguments.

The substitution assignment denotes a Boolean function in which an input is replaced with another Boolean function. The existential (universal) quanti cation assignment denotes a Boolean function in which an input is existentially (univer- sally) quanti ed. In this case the input is no longer free and thus not a real input anymore. However, it should still be listed in the input part.

bed reads circuits.bed and executes in turn each command in script.com. The rst command iterates through all outputs in circuits.bed. For each output it rst sets the variable or- dering according to the Fanin heuristic. Then it calls Up All to convert the BED for the output to a BDD.

After converting all output BEDs to BDDs, the script executes the command stat outputs which gives the number of tau- tologies among the outputs. In this way we can see whether the veri cation succeeded (all outputs are tautologies) or failed (some outputs were not tautologies). The command halt exits the bed tool.

[CCGR99] A. Cimatti, E.M. Clarke, F. Giunchiglia, and M. Roveri. NuSMV: a new Symbolic Model Veri er. In N. Halbwachs and D. Peled, editors, Proceedings Eleventh Conference on Computer-Aided Veri cation (CAV'99), volume 1633 of Lec- ture Notes in Computer Science, pages 495{499, Trento, Italy,

[DBR97b] R. Drechsler, B. Becker, and S. Ruppertz. Manipulation algorithms for K*BMDs.  In Ed Brinksma, editor, Tools and Algorithms for the Construction and Analysis of Systems (TACAS), volume 1217 of Lecture Notes in Computer Science, pages 4{18. Springer-Verlag, 1997. 7

