The Java Card programming language [17] is a version of Java. Its programs are intended to run on very restricted architectures such as Smart Cards, SIM cards or security tokens. Many features and constructors of Java are not present in Java Card. These include some primitive types (such as integer or float) and most library classes.  A specific version of the Java Virtual Machine (JVM) has been

The motivation for our work is that, although the Java Card virtual machine is not able to deal with the code produced from a full JML specification, the safety of Java Card applets can be improved at least by a subset of JML. Such a subset can be defined in order to avoid all those features that are not supported by the Java Card virtual machine. It is necessary to ensure that both data and control structures involved in the specifications as well as the code generated for the verification of these specifications are compliant with the Java Card virtual machine.

This paper is organized as follows: Section 2 presents Design by Contract and JML. Section 3 introduces the Java Card platform and discusses related limitations and advantages. After that, Section 4 shows how Java Card restrictions affect the choice of the JML subset compliant with the Java Card virtual machine, called JCML. Section 5 introduces the implementation of the JCML compiler, including the translation rules from JCML assertions to Java Card code. Experimental results are shown in section 6, where we compare the code produced by the JCML compiler and that produced by the JML compiler in terms of size. Finally, sections 7 and 8 present some related work and the next steps to be taken to improve JCML and its compiler, as well as our final remarks.

Design by Contract [14] [15] is a software development method based on the def- inition of contracts between software units. The method proposes the run-time verification of these contracts. Design by Contract uses logical assertions (precon- ditions, postconditions and class invariants) to specify contracts. These assertions can be added to the source code of a program and can be dynamically verified.

Java Card is a Java platform designed for resource-constrained devices. Due to the nature of those devices, the platform is quite limited. Memory restrictions are crucial for the design of Java Card applications: typical smart cards have as low as 12KB RAM, 374KB ROM and 144KB EEPROM. The read-only memory is used to store the Java Card Virtual Machine (JCVM), a severely downsized version of the JVM. The main differences between JVM and JCVM standards are the exclusion of some important JVM features such as many primitive types, dynamic classes and threads.

Java Card applications are called applets. In order to run one of these applets in a Java Card device, one must: (1) write the Java Card applet; (2) compile the applet; (3) convert the binary classes into a converted applet CAP file; (4) install the CAP file on the card; (5) run the applet. Compliance problems are detected by an off-card component of the JCVM [5], the converter, before the applet is installed on the card.

terminal to which the card is temporarily connected. However, for safety reasons, some card data may not be seen by the host application. Such sensible data must be manipulated on the card, safely and correctly. That is one of the advantages of smart cards with respect to magnetic strip cards: their on-card code may be used to ensure the safety and correctness of data apart from the host application. And this is where tools for a rigorous specification and verification of on-card data and functionalities becomes necessary.

JML has been designed for standard Java. This means that all Java constructs can be used in the generated verification code. To specify and verify Java Card applications, only those commands that can be run on the device may be used. So, the verification code generated by our specification must be Java Card compliant. Besides, time and memory consumption have to be taken into account on the defi- nition of the modeling language and for the generation of code. The design of such a specification language has to consider the trade-off between expressiveness and feasibility.

We propose JCML: the Java Card Modeling Language [19]. JCML inherits as many JML constructs as possible. In particular, the specification part of the language is preserved. Only the Java part of JML has been pruned to cope with the restrictions of the Java Card language. The removed features include:

The complete JCML grammar is available at [19] 3 , and has been produced from the JML grammar [10] by selecting the set of rules concerned with lightweight specifications and removing all constructs not supported by Java Card. JCML specifications support Java Card expressions, in the same way that JML supports Java expressions. The (Java) code generated by our JCML compiler (section 5) obeys these constraints.

whose task is to verify the assertions and call the original method. The embedded methods are renamed and made private. The wrapper method has the same name and signature as the original method it wraps. The wrapper method checks the preconditions and invariants and then executes the original method. After that, the wrapper checks the invariant and any specified postconditions.

In JCML one can specify static and instance invariants. Static invariants are properties over static attributes. Instance invariants deal with instance fields. In- stance methods can contain both static and instance invariants. The JCML compiler generates a separate invariant method for each kind of invariant found in the source code.

In JCML, invariants for a class are properties that must hold throughout every instance of the class. JCML invariants are checked before and after each method is called. The only variables allowed to appear in JCML invariants are the class attributes.

This expression uses the universal quantifier to specify that the vector a is sorted at indexes between 0 and 9. According to the JML Reference Manual [10], in the absence of a range predicate, the quantified expression must be evaluated over every value of the type of the quantified variable. For instance, in the previous example,the verifier would check all the possible values of i and j, from MinShort to MaxShort.

Our implementation tackles this problem by using static analysis to reduce the state space. The algorithm processes the conditions in a quantifier, in order to re- strict the range of values assumed by each variable. Initially, our algorithm assumes the lower and upper bounds defined by [10]. The algorithm proceeds in two steps:

Even using our algorithm, this number of operations can be too high to be run on-card. Our JCML compiler issues a warning when such a situation arises. The user can enable the code generation for quantifiers, for instance to be used during the application test phase. This code will not be generated for the production, on-card version of the applet.

In the following, we explore the inlining optimization technique for the JCML compiler. Method inlining can have the advantage of reducing the processing time, at the cost of possibly increasing the size of the generated code. Due to the restric- tive nature of our applications, the use of this technique on the compiler should be carefully studied. We devised several versions of the compiler, using inlining to different extents:

annotated with JML specifications by using the Why [7] and Coq [20] tools. Why is a proof obligation generator and Coq is a proof assistant. Krakatoa translates Java/Java Card code into the Why input language (an ML-like language), which generates proof obligations to be interactively proved by means of the Coq proof assistant. The KeY system is intended to integrate the design, implementation and formal specification and verification of object-oriented languages. The KeY system is based on a theorem prover for the first-order Dynamic Logic for Java and can verify Java Card programs thoroughly. Both Krakatoa and KeY perform static verification only, as it is the case of other related works [12][16] [21].

Efforts towards runtime verification of Java (and Java ME) can be found in [18]. That work proposes the use of AspectJ to implement a JML compiler that takes specifications and generates bytecode compliant with both Java and Java ME virtual machines. Regarding their language constructs, Java ME is a richer language than Java Card and the architectures for which Java ME is targeted are less constrained than those in which Java Card applets run.

In the original JML compiler, assertion undefinedness is treated in such a way that assertion runtime checking considers the context and the kind of event that led to the exception to conservatively preserve JML semantics avoiding false positives as much as possible. This complex treatment given by JMLc is however too heavy for a smart card environment. Our choice was then to assume that any uncheckable specification is false.

The version of the compiler presented here is able to check some simple (yet meaningful) properties. Current work includes the extension of the class of speci- fications dealt with by the compiler. To be able to generate verification code for a greater class of specifications, additional optimizations need to be employed. Our next step is to deal with exceptional behaviour so that the application that runs on-card is able to gracefully recover from faults.

