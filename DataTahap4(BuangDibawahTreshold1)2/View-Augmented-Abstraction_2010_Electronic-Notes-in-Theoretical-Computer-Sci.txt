This paper introduces view-augmented abstractions, which specialize an underlying numeric domain to focus on a particular expression or set of expressions. A view-augmented abstraction adds a set of materialized views to the original domain. View augmentation can extend a domain so that it captures information unavailable in the original domain. We show how to use finite differencing to maintain a materialized view in response to a transformation of the program state. Our experiments show that view augmentation can increase precision in useful ways.

The relationships needed to obtain such information take specific, often complex, forms, depending on the actions of the program of interest. Uniformly increasing the precision of the underlying numeric abstraction to capture the entire class of more complex expressions is likely to severely encumber the overall analysis. For instance, to compute an index into a packed upper-triangular matrix involves the square of an index variable. To capture that relationship, one needs to use a domain that can handle polynomials; however, no scalable domains do so.

Observation 1.1 (Instrumentation Principle) Suppose that S] is an abstract value that represents the set of concrete states S. By explicitly storing in S] an abstraction of the values that an expression e has in S, it is sometimes possible to extract more precise information from S] than can be obtained just by the abstract evaluation of e with respect to S].

In contrast to the relationships built up during the course of program execution, individual state transformations are typically simple (e.g., x = x+1). When tracking views, the challenge is to incorporate the effect of state transformations on the values of complex view expressions (e.g., x2y2). Recomputation based on the underlying domain is generally too imprecise [22]. In this paper, we present a systematic framework that automatically updates view-variables, based on finite differencing

In Ex. 2.1, view-augmentation yields results that the unaugmented abstraction could not achieve on its own. While Ex. 2.1 is admittedly small and contrived, it demonstrates the benefit of a view-augmented abstraction: a view-augmented abstraction can capture, maintain, and use information that the unaugmented ab- straction cannot represent.

and view variable to the set of relations that contain them. The global dictionary Neighbors maps each variable to the set of variables that it shares a relation with. That is, Neighbors[v] =  variables in r r Relations[v] . Both Relations and Neighbors hold facts about symbolic relationships among views.

To test the capabilities of view-augmented abstraction, we implemented a proto- type analyzer based on the Apron framework [1] and Interproc analyzer [15]. The experiments were run on a machine with a 3.40 GHz Pentium 4 dual processor and 2 GB of memory, running 32-bit Red Hat Linux Enterprise 5.

Discussion.  These examples give positive answers to our first two questions. Each assertion in each test uses only the original program variables. Thus, the fact that view-augmentation can verify otherwise-unverifiable assertions shows that a view-augmented abstraction can increase precision for the set of original program variables, as well as for the view expressions themselves.

