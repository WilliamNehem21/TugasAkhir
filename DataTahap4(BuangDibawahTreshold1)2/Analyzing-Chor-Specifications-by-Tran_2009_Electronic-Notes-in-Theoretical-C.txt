A choreography specifies activities and interactions among a set of services from a global point of view. From this specification, local implementations or peers can be automatically generated. Generation of peers that precisely implement the choreography specification is not always possible: this problem is known as realizability. This paper presents an encoding of the Chor choreography calculus into the FSP process algebra. This encoding allows to: (i) validate and verify Chor specifications using the FSP toolbox (LTSA),

have already been proposed to specify choreographies: WS-CDL, collaboration dia- grams, BPMN, SRML, etc. From such specifications, local implementations, namely peers, can be automatically generated. However, generation of peers which exactly implement the choreography specification is not always possible: this problem is known as realizability.

Recent works on this topic [7,12,4,2] advocate techniques to check realizability of a choreography, or define well-formedness rules to be applied while writing the choreography specification in order to ensure its realizability. However, most of these approaches focus on theoretical aspects and lack of tool support. In addition, these works mainly focus on the realizability issue but do not allow to check choreographies (in order to verify that the overall goal of the composition is achieved) or generate code from such specifications.

The rest of this paper is organized as follows: Section 2 introduces the Chor and FSP calculi. Section 3 presents the encoding of Chor into FSP. Section 4 extends the FSP encoding to take the peer generation into account, and focuses on the realizability issue. Section 5 sketches the prototype tool that supports our approach and the Java code generation. Section 6 compares our proposal to related works, and Section 7 ends the paper with some concluding remarks.

Chor [12] is a simple process language, and a simplified model of WS-CDL, for describing peers from a global point of view. From this global specification, behav- ioral specifications of peers can be generated by projection. In this section, we will overview both the Chor language (global view) and the Peer language (local view) introduced in [12]. First of all, let us define the trace operators which are used throughout this paper.

differs from Chor by the description of interactions. Peer specifies them from a local point of view. Therefore, at the Peer level, an interaction activity is either an emission or a reception, and peers interact together by handshake communication (same channels, opposite directions).

Example 2.2 We will use throughout this paper a metal stock market as a running example. There are three peers in our example. First, peer Broker selects one of two metals, namely iron and steel, then look at the market as many times as needed until a sale on the selected metal becomes available. Broker sends his/her bid on the selected metal to the second peer (Market) of our example. After receiving a bid, Market performs the following two tasks concurrently: saving the bid in its own database, and checking to see if this bid is better than the best current one or not. Then, Market sends the result of this check and the name of the broker to the announcement Board (third peer of our example). If this bid is the best so far, Board will change the current winner and notifies the broker. Otherwise, Board does nothing (skip). In the Chor specification below, bk, mk, bd respectively stand for Broker, Market, and Board:

In this section we introduce our encoding of Chor into FSP, which allows to use existing tool support for FSP. Thus, the resulting FSP specification can be compiled into LTS (Labeled Transition System), and checked using LTSA (animation, LTL model-checking). This encoding, will also be used to generate peers and check for realizability (see Section 4).

c2fpi is a one-to-one function of type Chor ~ ProcessIdentifier generating fresh identifiers (the same ones for identical Chor specifications) as output, which obey naming rules 6 of FSP process identifiers. T.c2fpi returns a process identifier which is obtained by prefixing the result of c2fpi by T .

Generation of FSP processes for an arbitrary Chor specification is performed using function c2f, defined in Section 3. The behavior of each Peer P in the chore- ography C is generated by hiding in the corresponding FSP (c2fpi(C)) all actions to which P does not participate (Definition 4.1).

Finally, we run all these peers concurrently. The FSP process for the whole system is:  Peers = (Broker  Market  Board). As for the realizability test, first, we compute LTSs from FSP processes Stock and Peers, using LTSA. Next, we com- pare trace sets of these processes using ltscompare, one of the tools belonging to

Indeed, after Broker sends his/her bid to the market, (s)he should decides if (s)he will be notified by the board or not. On the other hand, Board also makes this decision according to the result which is received from the market. So if peers Broker and Board make different decisions, a deadlock occurs. To make our specification realizable we slightly change it as follows: Whatever value is received from the market, Board always notifies the broker about the result. Thus, the specification of the system becomes as follows:

created one separate thread, and used class CyclicBarrier (the Java utility class) to guarantee that the execution of both threads must be finished before the next activities are performed (cb1.wait() and cb2.wait()). Also, SynchronousQueue used in class ChannelImpl is another Java class which synchronizes its read/write operations, therefore our communication mechanism remains synchronous.

As regards tools automating the realizability test, WSAT [5] takes conversation protocols as input, and checks a set of realizability conditions on them. Another tool-supported approach was presented in [13] and showed on an example how realiz- ability can be checked using a LOTOS encoding. However, in [13] the choreography language, namely collaboration diagrams, was less expressive than Chor (no choice and a loop operator restricted to a single message), and the proposal focused only on abstract languages (no relationships with implementations or real code).

To sum up, first, most of these approaches focus on theoretical aspects. Our contribution is a tool-supported yet formal approach tackling the realizability is- sue for choreography, but considers a different choreography specification language compared to [5,13], and therefore deals with its own specificities. Second, the works presented in this section focus on the realizability issue but do not allow to check choreography specifications or generate code from such specifications, whereas our FSP encoding makes it possible.

In this paper, we have presented an encoding of the choreography calculus Chor into the process algebra FSP. This encoding allows to generate a set of peers corre- sponding to the choreography, and in a second step to check that (i) they realize the original choreography, and (ii) they ensure some expected properties (by animation and model-checking with LTSA). If the choreography is not realizable or erroneous, the Chor specification can be corrected and the process started again. Our approach is completely automated by a prototype tool we implemented and applied to a large number of examples.

Our main perspective plans to extend our approach to consider asynchronous communication. In this paper, we have focused on synchronous communication, and it makes the realizability computation and model-checking easier. Dealing with asynchronous communication is a realistic assumption with respect to implemen- tation platforms, however it complicates the analysis and verification stage. Asyn- chronous communication can be specified using queues. In this context, realizability results depend on queue size, and some theoretical issues are still open problems such as the relationships of realizability results for queues of size one, queues of size k, and infinite queues.

