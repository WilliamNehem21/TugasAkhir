This paper describes an extension to Lustre to support the analysis of globally asynchronous, locally syn- chronous (GALS) architectures. This extension consists of constructs for directly specifying the timeout automata used to describe asynchronous communication between processes represented by Lustre nodes. It is implemented using an extensible language framework based on attribute grammars that allows such extensions to be modularly defined so that they may be more easily composed with other language exten- sions.

There are many more domain-specific features that would make Lustre easier to use in new domains. For example, Lustre has been used for the analysis [15] and code generation [5,6] of GALS architectures. Our interests here are in using Lustre to specify and analyze (but not generate code from) the behavior of GALS architec- tures. Previous explorations of this idea, such as [15], assume that users manually construct a scheduler node and use it to manage the clocks of all of the asynchronous processes in the model. However, a scheduler could be automatically derived using a language extension, given the rates and drift of the asynchronous processes in the model. To support this process, we add to Lustre a timeout condact construct that defines the behavior of an asynchronous process within the architecture as follows:

This construct (defined in Section 2) specifies that node channel representing a periodic process within the architecture is to be executed every rate milliseconds subject to clock drift in the range min drift ..max drift . Like a condact expression, if the node does not evaluate, then the result of the expression is the value from the most recent evaluation, and before the first evaluation, the values init a and init b are used. Using this construct, a scheduler (implemented in the kernel Lustre language) can be automatically derived.

ditionally high cost of language development. We proposed an extensible language framework for Lustre based on attribute grammars as a possible alternative ap- proach to language development that satisfies the two criteria mentioned above. This approach is used to implement timeout automata as language constructs in Lustre. The primary contributions of this paper are the specification and implemen- tation of timeout automata as first class language constructs in Lustre. Section 2 describes the GALS approach to development and defines the timeout automata construct. Section 3 describes some aspects of the implementation of the timeout automata as a language extension in our extensible languages approach. Section 4 discusses related work and concludes.

The FGS system has two physical sides corresponding to the left and right sides of the aircraft. These provide redundant implementations that communicate over a cross-channel bus. Normally, only one FGS instance (the pilot flying side) is active, with the other FGS instance operating as a silent, hot spare. A transfer switch button on the flight control panel (FCP) can be used to toggle the pilot flying side. In some critical flight modes, both sides are active and independently generate guidance values for the autopilot, so that the autopilot can verify that they agree within a predefined tolerance value. 5

This construct specifies that node node representing a periodic process within the architecture is to be executed every rate milliseconds subject to clock drift in the range min drift ..max drift . Like a condact expression, if the node does not evaluate, then the result of the expression is the value from the most recent evaluation, and before the first evaluation of the node, the initial values init vals are used. It is assumed (and checked by the compiler) that timeout condact expressions are not nested within other clocked expressions; this matches the expectation within GALS systems in that the asynchrony occurs at the global level and synchronous clocking mechanisms are local to one of the modeled processes.

assert(((init_time_1 >= 0.0) && (init_time_1 <= (100.0 + 1)))); assert(((drift_2 <= 5) && (drift_2 >= -5))); assert(((init_time_2 >= 0.0) && (init_time_2 <= (20.0 + 5)))); assert(((drift_3 <= 1) && (drift_3 >= -1))); assert(((init_time_3 >= 0.0) && (init_time_3 <= (100.0 + 1)))); assert(((drift_4 <= 5) && (drift_4 >= -5))); assert(((init_time_4 >= 0.0) && (init_time_4 <= (20.0 + 5))));

Although tmoCondactExpr explicitly defines some attributes, it does not do so for attributes such as ctrans (or attributes for translating to the input languages of different model checkers). These attributes are implicitly defined using forward- ing [27] through translation to a condact (condactExpr) in the host language by using the forwards to clause. When a tmoCondactExpr node in the AST is queried for an attribute that is not explicitly defined by an attribute definition, it forwards that query to the forwards-to construct. The value defined there is returned as the value of that attribute for the timeout condact. Thus, the value of ctrans on a timeout condact is the value of the ctrans attribute on the generated (translated- to) condact construct. Therefore, all back-end tools only see the generated condact calls while Lustre programmers see the timeout condact calls they write.

Our initial efforts in extensible languages were in the domain of programming languages. We have built an extensible specification of Java 1.4 and specified a number of non-trivial language extensions [29]. One extension embeds the database query language SQL into Java so that queries can be written naturally and syntax and type errors in SQL queries can be detected at compile-time, instead of run-time, as is the case in library-based approaches.

There have been many other efforts to extend Lustre with new language features. Many of these features can also be implemented by translation to the a kernel Lustre language. For example, recent work to add state machines to Lustre [8] translates the state machine constructs into a kernel Lustre language and the addition of modules and generics proposed for Lustre v6.

More generally, several approaches have been described for extending languages with new features. Macros systems (lexical, syntactic, hygienic [18], etc) do al- low new languages constructs to be specified but they lack an effective means for performing the static analysis used to, for example, generate domain specific er- ror messages. Note that some modern macro systems (e.g. [1] however do a some limited facilities for error processing. Object-oriented frameworks, such as Poly- glot [22], have also been proposed for building extensible languages, but they do not support the automatic composition of language extensions that is provided by the attribute grammar-based approach.

