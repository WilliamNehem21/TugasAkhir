For validation purposes, simulation may be extended to a domain specific view, called animation view [8], which allows one to define scenario visual- izations which are closer to the application domain than the abstract, graph- based model. Such an animation view is defined by extending the alphabet of the original visual modeling language by symbols representing entities from the application domain. The simulation rules for a specific visual model are translated to so-called animation rules conforming to the animation view by performing a simulation-to-animation model and rule transformation (S2A transformation), realizing a consistent mapping from simulation steps to ani- mation steps. This visualization of animation steps in the animation view is called animation, in contrast to simulation, where simulation steps are shown as changes of the underlying abstract graph model.

The paper is organized as follows: In Section 2, our running example, an animation view for a Radio Clock Statechart, is introduced. Section 3 re- views the basic concepts of simulation, animation, and model and rule trans- formation. In Section 4, the main result on semantical correctness of S2A transformation is reviewed. As new contribution in this paper, it is shown that for each S2A transformation there exists a corresponding A2S backward- transformation. Semantical correctness of A2S transformations is shown for the case without negative application conditions (NACs). Extensions to cope with NACs are discussed. Section 5 discusses related work, and Section 6 concludes the paper.

Our aim is not only to transform model states but to obtain a complete animation specification, including animation rules, from the simulation specifi- cation. Hence, we define a construction allowing us to apply the S2A transfor- mation rules from Q also to the simulation rules, resulting in a set of animation rules. The following definition reviews the construction for rewriting rules by rules from [6].

Def. 3.3 extends the construction for rewriting rules by rules given by Parisi-Presicce in [14], where a rule q is only applicable to a rule p if it is applicable to the interface graph I of p. This means, q cannot be applied if p deletes or generates objects which q needs. In this paper, we want to add animation symbols to simulation rules even if the S2A transformation rule is not applicable to the interface of the simulation rule: Case (1) in Def. 3.3 corresponds to the notion of rule rewriting in [14], adapted to non-deleting S2A transformation rules. In Case (2), the S2A transformation rule q is not applicable to the interface I, but to the left-hand side of a rule p1, and in Case (3), q is not applicable to I, but to the right-hand side of p1. Note that it is possible that both Case (2) and Case (3) can be true for different matches of

rule graphs and to the initial radio clock graph. The initial S2A rule qClock adds the root symbol Clock to all graphs it is applied to. The remaining S2A rules add visualization symbols depending on the state of the current pointer. We visualize only basic states which do not have any substates. Superstates are not shown in the animation view, as they are considered as transient states which are active on the way of the current pointer up and down the state hierarchy between two basic states, but have no concrete visualization graphics themselves.

Proof. By Theorem 4.3 we have that S2A is semantically correct for rule- compatible S2A and terminating S2AM . By Theorem 4.10 and Theorem 4.12 we know that A2S is a valid backward-transformation of S2A and that A2S is semantically correct. Hence, according to Def. 4.13, S2A is a behavior- preserving model and rule transformation.	 

reactive animation approach by Harel [11], where behavior is specified by UML diagrams. The animated representation of the system behavior is im- plemented by linking UML tools to pure animation tools like Macromedia Flash or Director [12]. Hence, the mapping from simulation to animation views happens at the implementation level and is neither specified formally, nor shown to be behavior-preserving. Analogously, different Petri net tools also offer support for customized Petri net animations In general, approaches to enhance the front end of CASE tools for simulating/animating the behavior of models are restricted to one specific modeling language.

