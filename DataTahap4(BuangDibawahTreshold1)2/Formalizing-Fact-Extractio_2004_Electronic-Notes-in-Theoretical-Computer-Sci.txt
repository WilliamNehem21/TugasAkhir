Reverse engineering commonly uses fact extraction to transform source programs to factbases. These factbases are in turn used to determine particular views or aspects of the program, such as its architecture or its anomalous structures. Fact extraction is usually defined in an ad hoc manner, which is often incomplete or inconsistent. This paper takes the position that formal specification of fact extraction is beneficial to the reverse engineering community.

A formal specification can serve as an unambiguous and reliable standard for people who use, write or verify a fact extractor. We explain how a formal specification for extracted facts can be derived from the source language grammar in such a way that the relationship between the code and its corresponding extracted facts is made clear. To support our position, we report our experience with formalizing a version of the Datrix Schema.

According to [8], a schema is a description of the form of the data, in terms of a set of entities with attributes and relationships that prescribe the form of the instance data. There are particular schema for factbases, for example, Datrix and Columbus[2,9]. These schemas describe the form of factbase and relate entities in factbase to the source language. They also serve as a guideline of how to build the factbase.

In this paper, we will concentrate on fact extractors that input source code and parse it according to a context-free grammar. Not all fact extractors take this approach. For example, some use lexical, non-grammar approaches, and some analyze object code. However the approach we are concentrating on is commonly used.

Specifications of schema for facts extracted from source code are generally informal and incomplete. Due to ambiguities in these informal specifications, each developer of a fact extractor has to decide on his own the detailed form of factbase, which leads to errors and inconsistency in factbases. This paper describes our approach to formalize fact extraction and create a complete, consistent and comprehensible basis for fact extraction. Our formalization of fact extraction consists of three parts:

In our approach, the first part is given as the context-free grammar for the source programs. The second part gives the form or schema of the factbase, again as a context-free grammar. The third part, the mapping, is responsible for maintaining the semantics (or particular aspects of the semantics) for use in tools that input the resulting fact base.

A common mechanism for dealing with parsed source programs is to repre- sent them internally as an Abstract Syntax Tree (AST), and our approach will use this mechanism. The AST can be decorated to become an Abstract Se- mantic Graph (ASG) by adding various semantic information, usually at least links connecting variable references to corresponding declarations. In the case of Datrix, the factbase represents a variant of the ASG, so this approach is particularly convenient.

As mentioned earlier, the range of fact extraction, i.e., the form of the factbase, can also be specified as another context free language. The factbase can be considered to be an (possibly simplified version of) ASG, which can easily be represented in a form that has a context-free grammar. To illustrate this, consider this C++ expression:

We believe that validity could only be achieved by extensive testing and the success of our approach depends on tools that can test our specification automatically. Fortunately, this tool already exists. TXL is a rule-based language that performs transformations on context-free language. It can input our specification and performs transformations in our specification on source code.

the form of factbase. Based on this understanding, the designer creates a se- quence of transformation steps to map a source program to its representation as extracted facts, being careful to see that all parts of the input grammar are dealt with. Our experience indicates that creating these transformations is time consuming, and both inspection and extensive testing are needed to insure the specification is consistent and complete.

In our experience in formalizing a version of extraction for the Datrix [2] schema, we found it convenient to start with a set of mapping steps that transform source code into a standard intermediate representation. These steps carry out various common housekeeping functions, such as producing regularized ways of representing expressions and statements. This standard intermediate representation resolves any ambiguities that might be present in the source program. We then defined further transformations to map the facts to the format defined by the Datrix schema. We expect that it is not difficult to create transformation sets from this intermediate representation to the format for other schemas such as the Columbus schema. [9] This standard intermediate schema can save the designer of a schema the time and effort spent on details of a particular language such as C++.

Our approach forces the designer of schema to think carefully about the con- crete grammar of the source language. As a result the specification is more likely to be complete and consistent. Because a reliable schema is vital to ex- change of information, this work is worthwhile. With a less exacting approach, there is the danger of a lack of consistency among fact extractors because the specification of schemas is ambiguous and tends to omit low-level but essential details.

We have found that many of our transformations used in defining a schema are reversible. When this is the case, we can write reverse transformations. When the target schema is source complete (contains sufficient information to reconstruct the source program), or nearly so, we can use these reverse transformations to recover the source code from the factbase. Using reverse transformations we verified CPPX, which is a fact extractor developed by SWAG team in University of Waterloo.

This example can be a multiplicative expression of two variables TypeOrVar and p or a declaration of a pointer p that points to the type TypeOrVar, if TypeOrVar is defined as a type. These ambiguities cannot resolved at the level of a context-free grammar [1], which means tools like TXL cannot directly tell a variable from a type in particular circumstances. Our solution is to intro- duce an oracle, which is a program that distinguishes names from types. We use JLEX to generate this program. As for the above example, the oracle inserts the tag <type> when it determines that TypeOrVar is a type. As a result of this step, the program fragment is disambiguated by transforming it to:

Declaration (1) is shorter and more convenient for programmers. However, Datrix does not allow this shorter notation. In the ASG, each time a variable refers to x or y,a refers edge is drawn from that variable to x or y. Therefore, x and y have to be separate nodes in ASG.

The initial steps tag any ambiguous variables or types [4][7] and flatten all dec- larations. In terms of the AST, each declaration corresponds to a particular node and each statement or expression corresponds to a particular sub-tree. We can now deal with a program as a series of separate declarations, expres- sions and statements. These initial steps are potentially useful for creating factbases other than Datrix, for example, Columbia factbases.

We chose a postfix form of expressions, statements and declarations as the standard intermediate representation. The sub-transformation that creates this format is called postfixify. The postfix form of expression is well-known, but the postfix form of declaration and statement is not used very often, although it is not difficult. After this step has been carried out, the source program becomes a series of statements, expressions and declarations in postfix form.

The fourth step is to generate Datrix AST. The Datrix AST can be expressed as a bracket-denoted language, in which child nodes are contained inside brack- ets. The transformation from postfix representation to Datrix AST is straight- forward in most cases, because the syntax of the Datrix AST is simple. For example, in Datrix, declarations, the most complicated part of C++ language, are all of the following form no matter it is built-in type, pointer or class:

Our experience indicates that the formalization of fact extraction can provide a useful schema specification and a clear understanding of the relation between different schemas. Because most transformations in these specifications can be implemented by program manipulation tools such as TXL, our specification is also a powerful tool to verify both the specification and the actual fact extractors. When efficiency is not the main goal, the specification and TXL can also serve as a fact extractor prototype.

