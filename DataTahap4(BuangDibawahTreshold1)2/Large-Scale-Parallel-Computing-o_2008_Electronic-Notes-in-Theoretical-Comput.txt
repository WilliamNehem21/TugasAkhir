This paper argues that computational grids can be used for far more types of applications than just trivially parallel ones. Algorithmic optimizations like latency-hiding and exploiting locality can be used effectively to obtain high performance on grids, despite the relatively slow wide-area networks that connect the grid resources. Moreover, the bandwidth of wide-area networks increases rapidly, allowing even some applications that are extremely communication intensive to run on a grid, provided the underlying algorithms are latency- tolerant. We illustrate large-scale parallel computing on grids with three example applications that search large state spaces: transposition-driven search, retrograde analysis, and model checking. We present several performance results on a state-of-the-art computer science grid (DAS-3) with a dedicated optical network.

Next, the paper will discuss how algorithms and applications can be optimized to run in such an environment. We focus on applications that search large state spaces. As an introductory example, we will summarize earlier work and describe how a communication-intensive heuristic search algorithm can be optimized to run on a grid. As a more recent case study, we have implemented a retrograde analysis application that solves the game of Awari, which has 900 billion different states. Several optimizations were needed to obtain high performance on the DAS-3 grid. Finally, the paper discusses some preliminary results in using the DiVinE model checking toolkit on DAS-3. As we will show, DiVinE has many characteristics in common with the Awari solver, making it an interesting application for further research.

We think DAS-3 is representative for future grid systems. It is hierarchical and consists of multiple clusters with a fast local interconnect and a higher-latency wide-area interconnect. The wide-area network has a high bandwidth. In summary, the system can be characterized as hierarchical, high wide-area latency, and high bandwidth. In the rest of the paper, we discuss how to design parallel applications for such an environment, which are called distributed supercomputing applications.

The DAS systems are excellent testbeds for studying wide-area parallel algorithms, because they can be used for controlled experiments. Unlike on very heterogeneous production systems, it is feasible to do clean speedup experiments on DAS. We have produced many papers on this topic (e.g., [11,15]).

However, we have learned that many applications can be optimized to deal with the high latency of the wide-area network. The key idea is to be latency-tolerant. The bandwidth of wide-area networks is increasing very fast (much faster than CPU speed increases), as can easily be seen by comparing the bandwidths of the three DAS systems.

Heuristic search algorithms recursively expand a state into successor states. If the successor states are independent of each other, different processors can analyze different portions of the search space. During the searches, each processor maintains a list of work yet to be completed (the work queue). When a processor completes all its assigned work, it tries to acquire more work from busy processors, which is called work stealing.

All communication is asynchronous (nonblocking). Expanding a state amounts to sending its children to their destination processors, where they are entered in the work queue. After sending the messages the processor continues with the next piece of work. Processors never have to wait for the results of remote lookups.

The network latency is hidden by overlapping communication and computa- tion. This latency hiding is effective as long as there is enough bandwidth in the network to cope with all the asynchronous messages. With modern high-speed networks (like light paths) such bandwidth usually is amply available.

The algorithm also can have good load balancing, because it distributes the work randomly. However, the advantages of good load balancing should be balanced against loss of locality and additional network processing. Also, the highly asynchonous algorithm described does assume a homogeneous execution environment.

In this section we will summarize our more recent work on using distributed super- computing for large search-applications [22]. We will discuss how we implemented a retrograde analysis program that solves the game of Awari on the wide-area DAS-3 system. The original program [16] ran on a single cluster and was extremely com- munication intensive: it sent one Petabit of data over the local area network in 51 hours. We will discuss how such a communication-intensive application can be run efficiently using light path technology.

With the advance of optical networking technology, it becomes feasible to even run this type of application on a grid. We therefore studied the performance of the Awari RA program on the wide-area DAS-3 system [22]. We initially just ported the original C/MPI program and tested it on DAS-3. The (small) differences in CPU speeds in DAS-3, however, caused flow control problems, resulting in the faster CPUs to overwhelm the slower ones with work. This effect resulted in unrestricted job queue growths and thus memory problems. In Awari we solved this problem using global synchronizations (an alternative, proposed in a memory-limited, se-

DiVinE uses a Linear Temporal Logic (LTL) approach to model checking, where a verification problem is reduced to cycle detection in a graph representing the state space. The toolkit contains several parallel cycle detection algorithms designed to run efficiently on a cluster [2]. In addition, the toolkit implements on-the-fly distributed state-space generation for error detection and deadlock discovery. The DiVinE toolkit supports specifications in both its native modeling language DVE and in Promela [4], the modeling language of the popular model checker SPIN [10].

For our initial performance analysis we took two representative benchmark problems from the BEEM model checking database [14]: Anderson and Elevator. The An- derson specification concerns the correctness of a mutual exclusion algorithm for a varying number of processes. The Elevator specification determines the correctness of an elevator controller, given a certain number of floors and persons waiting for the elevator. For each problem we let DiVinE check the LTL specification of a cor- rectness property using the Maximal Accepting Predecessors tool (distr map) [2]. In both cases the entire state space must be searched, since there is no violation of the given property.

with retrograde analysis and model checking. Even the performance characteristics of these applications are similar. We therefore think it is interesting to study fur- ther optimizations of distributed model checkers, similar to the ones we describe for our Awari solver. Also, it is important to develop programming environments that simplify programming and deployment of grid applications, which is the topic of our ongoing research on Ibis [21].

