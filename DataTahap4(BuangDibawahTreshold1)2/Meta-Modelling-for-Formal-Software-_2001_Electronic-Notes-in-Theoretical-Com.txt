In this paper, we show how large programs can be defined in terms of different views that are instances of a single meta model. Each view represents one set of properties of the program and their composition defines the specification of the program. Transformations are used to convert views into program fragments that are composed together to build the whole program. The technique has been applied for the construction of many large systems that are in practical use.

In this paper, we describe a method for constructing an industrial-scale software system using multiple models. Rather than using unrelated notations and methods for different aspects of the program, the models in our method are all instances of a single meta- model. This provides a unified way of describing both the models and the system that is constructed using these models. It also leads to a simple and elegant implementation method. The method has been used extensively to construct medium and large-scale programs that are now in operational use in different countries.

We first describe how multiple models can be used for software development effectively in Section 2. We illustrate this using two examples: one using different models in the construction of program analyzers (Section 3) and another using multiple models to decompose a large problem into smaller components (Section 4). Finally, we discuss some problems that remain to be solved when using this approach in Section 6.

Instead, we make use of the model Mi, of which Ai is an instance, and implement general transformations for the model. These transformations can be applied to all instances of Mi. Defining transformations at the level of Mi, rather than for each instance Ai of the model, makes it possible to scale-up the method and handle large programs.

Example: Let A be an abstract specification of a compiler. A can be de- composed to represent the separate steps Ai in the compilation process. These steps are typically lexical analysis, syntax analysis, and code generation. Lex- ical analysis can be modelled by regular expressions (or a finite state transi- tion model) and syntax analysis by context-free grammars (with its underlying model). The model for code generation is usually defined informally.

Program analysis is an area where multiple models are used to represent dif- ferent sets of properties, e.g. syntactic properties and semantic properties. Each model encompasses a set of properties that are relatively complete and consistent. The models are related through the class of program objects that they describe.

Projecting the complex semantic model [ . ] into the two simpler models, LS and LA and ensuring that LA is consistent with [ . ] enables us to apply the analysis to a set of similar languages (such as all imperative languages) and the set of program properties covered by a single theory of analysis uniformly.

Example: Consider a simple central locking system (CLS) for a car. The system has a central control for two motors (RM, LM), one for the right door and another for the left door. The control may either lock both doors or unlock them.

A1, A2 and A3 are instances of models M1, M2 and M3 respectively. P is a composition of P1, P2 and P3, each of which is a refinement of A1, A2 and A3 respectively. This refinement is implemented by transformation functions f1, f2 and f3.

Program modelling These are instances of models Mi and correspond to Ai of Section 2. Objects and associations in this model are instances of the corresponding objects and associations of the corresponding model. Adex checks that all program models are well-formed according to the rules spec- ified in the corresponding model.

In addition, functions of the kind described as f1, f2 and f3 in Section 4 are defined to transform instances of models to corresponding fragments of a program. These functions can be implemented in a model traversal and transformation language supported by Adex. Thus, if f1 f2 and f3 are correct, then P1, P2 and P3 will always be a correct refinement of A1, A2 and A3.

In this paper, we have presented an approach to developing complex systems using multiple, related models. The models allow different sets of program properties to be represented as different views, or instances of models, that are derived from a common meta model. The technique has been used for developing large applications.

