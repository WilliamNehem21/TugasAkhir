For this specification language (called timed CSP-OZ) we furthermore propose a method for analysing component interfaces and we define a formal notion of implementation, which can - like refinement - be used for substitutability checks. The analysis method is based on a semantics for the language in terms of timed automata (or more precisely, timed transition systems, since the semantics will not always yield a finite state automaton). In case of a finite number of states we can then use one of the timed automata model checkers for verification (e.g. Kronos [27] or UPPAAL [3]).

Based on this semantics we can furthermore use the notion of implementation associated with timed automata for timed CSP-OZ. The implementation relation for timed automata is inclusion of timed traces (language inclusion for words with time stamps). We define timed simulation conditions and show their soundness with respect to this relation. This opens the way for a stepwise proof of implementation. The paper is structured as follows. Next, we start with a simple example of a timed CSP-OZ specification on which we explain the general idea and which will serve as an illustration of the main results in the next sections. Section 3 gives a short introduction to timed automata. We then define the semantics for timed CSP- OZ specifications in terms of timed automata. In Section 4 we show how to analyse interface specifications in timed CSP-OZ with the timed automata model checker UPPAAL. Section 5 gives timed simulation conditions which can be used to prove

Variables of type clock can be declared as attributes of classes and may (under some restrictions) appear in predicates within method schemas. The following ex- ample shows an abstract specification of the interface of a watchdog component. A watchdog component should control a certain method note which is to be repeat- edly executed within 10 time units after its last occurrence. An alarm can either be raised by a ring after the expiration of the deadline or after at least 8 seconds by using a flash signal. A component implementing this interface may choose one of these options. Below, the component is specified as an Object-Z class.

After having introduced timed CSP-OZ by means of a simple interface spec- ification, we are next interested in the analysis of such specifications and in the definition (and the checking) of an implementation relation between specifications. Such a relation could be used for substitutability checks. To this end, we will first define a semantics for timed CSP-OZ specifications.

Protocols of components are quite often described by finite state automata. Here, we choose a similar formalism for our semantics, namely an extension of finite automata to time, called timed automata [1,4]. The timed automaton for a timed CSP-OZ specification will capture the complete behaviour of the specification, including the data dependent aspects covered by Object-Z. Timed automata can, however, not be used to specify pre- and postconditions of methods, thus we do not directly use timed automata for interface specifications, only for their semantics.

Timed automata are finite automata enhanced with clock variables which can be queried and reset on transitions. To ensure decidability of the emptiness problem (and thus allow for verification), the conditions on clocks are usually restricted. We will later fix similar restrictions on our Z predicates over clocks to ensure that timed CSP-OZ can be safely mapped onto timed automata.

specification may contain a number of clock variables x1,... , xn and a number of Clock given with values from the nonnegative reals R+. Every timed CSP-OZ variables v1,... vm of other types. We then impose the following restrictions on the

These conditions ensure that timed CSP-OZ specifications can be mapped onto timed automata. For defining the semantics we next have to separate the clockless parts of the specification from those with clocks. We define cl (schema) to be the clockless part of a schema, i.e. the declarations and predicates over non-clock vari- ables, cc(schema) to be the clock part of a method schema, cinv (schema) to be the predicate(s) of the state schema relating clock variables and other variables, and reset (schema) to be the set of clocks xi with predicates x ' =0 in the schema. The events (or actions) of the timed automaton of a CSP-OZ specification will always

Note that the semantics generates a particular class of timed automata: all tran- sitions labelled with the same event have the same guards and clock conditions. Because of simplicity, we have restricted the clock conditions of a method to be state independent. However, an extension of the semantics to clock conditions re- lating clock variables and predicates over non-clock variables can be achieved.

The formal semantics gives us the possibility of analysing interface specifications. Provided the timed automaton has a finite number of locations (which is the case in our example) we can even use a model checker for the analysis. Several model checkers for timed automata exist; here, we will use UPPAAL [3]. To do so, we

For the first part, we have to make some global declarations of channels and clocks for UPPAAL. Thus, for our watchdog we declare three channels note, ring and flash corresponding to the methods of the CSP-OZ class. We also define two global clocks xr and xf representing the clocks xr and xf in our specification.

holds. By describing the desired behavior of Watchdog , we want to guarantee that after a certain time, an alarm is raised. That means that we must leave any state representing alarm = false after at most 10 time units. Therefore we have to verify the formula

Language inclusion for timed automata is in general undecidable [1]. Here, we give an approach to checking language inclusion of timed CSP-OZ specifications. The additional structure present in the specifications allow for a compositional language inclusion check, separately treating the CSP and the Object-Z part. The check for the Object-Z part has to be carried out manually, the check on the CSP part can be done by a CSP model checker.

We start with developing timed simulation conditions for timed Object-Z spec- ifications. These can be used to carry out an operation-wise proof of language inclusion between two timed Object-Z specifications. The conditions can be seen as one half of timed bisimulations [26], and are similar to those in approaches spec- ifying components by pre- and postconditions of their operations. For showing a simulation relation between an abstract and a concrete Object-Z specification we have to give a relation R relating the state spaces of both specifications:

Finally, these two results have to be integrated into one. So far, we have some means for showing an implementation relationship for the timed Object-Z parts and for the CSP parts. These techniques can separately be applied to specifications if the implementation relationship is preserved under the operator that we use for combining the semantics of the separate parts, namely under parallel composition. The following theorem states exactly this property.

In this paper we have proposed an extension of CSP-OZ with features for specifying timing constraints on components. The extension has been minimal in the sense that we neither added a third formalism to CSP-OZ nor exchanged one of the notations which have already been integrated into CSP-OZ. The only extension is a new type for variables in Object-Z. We believe this to be an extension which makes reading and writing of specification particularly easy: once a designer is familiar with CSP and Object-Z he/she can easily read and write timed CSP-OZ specifications.

example, how existing model checkers can in principle be used to analyse compo- nents interfaces and discussed simulation conditions for implementation relation- ships. This now gives us a high-level specification language for components which offers a richer set of facilities for modelling than timed automata do. The additional structure present in timed CSP-OZ specifications could furthermore facilitate static analysis of specifications which might prove fruitful for verification. By restricting our semantics to the traces model, we obtain a simple definition of timed simula- tions which is very close to the techniques and definitions used in the context of timed automata. Nevertheless we want to deal with parallel composition of several components which calls for a more precise semantics. Future work sees the expan- sion of our approach to the failures-divergences model of CSP [23] and the use of parallel composition and nondeterminism.

