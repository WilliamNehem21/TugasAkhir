In this paper we describe a network invariant for all con gurations of the Future- bus+ Cache Coherence Protocol. The network invariant was computed with PAX and veri ed by a model checker. Using this invariant we are able to prove a speci - cation of cache coherence correct for an arbitrary number of components on a single bus of the system. This speci cation includes a progress property not proven yet. We show how the result for the single bus system can be extended to tree-shaped systems. This is, as far as we know, the rst uniform proof of the protocol with multiple data-buses.

Considerable e ort has been invested into the veri cation of the IEEE Futurebus+ protocol [11,6,20,12]. Either these e orts have not presented a uniform proof of correctness, i.e., a proof which establishes correctness for all instances of the parameterised network, or they have only veri ed a subset of the cache coherence speci cation.

We base our proof method on the method described in [3,4,5]. It consists of building a model of the parameterised network in the theory of weak sec- ond order logic of one successor (WS1S) [8,15,28]. The dynamic behaviour is described with a WS1S transition system. An abstraction relation is for- mulated in WS1S. Both serve as input to the tools PAX, which computes an

In the next section we introduce the notation and de nitions used in this arti- cle. We recall the de nition of WS1S transition systems. Section 3 describes our extension of the proof method in [3,4,5] to synchronous parallel compo- sition. A short description of the Futurebus+ Cache Coherence Protocol is given in Sect. 4. Section 5 recalls the de nition of L-simulation and network invariants, summarises the results of [22] and describes the construction of the network invariant for the general case. We close this article with a short conclusion and comparison to related work.

Terms of WS1S are build from the constant 0, rst-order variables, and the successor function t:t + 1 applied to a term t. Second-order terms are either second-order variables, the constant ; denoting the empty set, or terms of the form X [ X0, X \ X0, or X n X0, where X and X0 denote second order terms. Atomic formulae are of the form b, t = t0, t < t0, or t 2 X, where b is a propositional variable, t and t0 are both terms, and X is a second-order term. WS1S-formulae are build from atomic formulae by applying the boolean connectives as well as quanti cation over rst and second-order variables. First-order monadic formulae are WS1S-formulae in which no second-order variables occur. WS1S-formulae are interpreted over models that assign nite subsets of ! (the natural numbers) to second-order variables and elements of

! to rst-order variables. The interpretation is de ned in the usual way [28]. Given a WS1S formula f , [[f ]] denotes the set of models of f . The set of free variables is denoted by FV(f ). By FV2(f ) we denote the free second-order variables, by FV1(f ) we denote the set of free rst-order variables. One says that f is ( rst-order) closed, if FV(f ) = ; (FV1(f ) = ;). WS1S is a decidable formalism. Given a WS1S formula f we can construct a nite automaton, which is enumerating [[f ]]. However, in [27] it is shown that the space needed to compute the set of models of a WS1S formula is bounded from below by a stack of powers of two the size of the length of the formula. Despite this discouraging fact, a decision procedure has been implemented in the MONA tool [18].

 (B)  f0;::: ; m 1g. 8nx:f abbreviates the formula 8x:(0  x^x < n) ! f , and 9nx:f abbreviates the formula 9x:(0  x ^ x < n) ^ f . Similarly for second-order variables B we abbreviate the formula 8i:i 2 B ! f by 8Bi:f and 9i:i 2 B ^ f by 9Bi:f .  The formulae in AF(n) are interpreted over

The transition relation is given by just one formula. However, the space needed to compute the set of models of a WS1S formula is bounded from below by a stack of powers of two the size of the length of the formula [27]. In our case study this resulted in a formula which is to large to be handled with our resources. This makes it necessary to keep the formula of the transition relation small. In [22] a method to remedy this situation is presented.

Initially, any cache line is invalid. An invalid cache line must issue a command or snarf a copy of the desired data to change its state (snar ng means reading the data from a transaction issued by another component). It is possible for a cache line to transition to any other state from the invalid state. A module that initiates a read-shared transaction and completes it successfully transitions to shared-unmodi ed state if TF is asserted and to exclusive-unmodi ed state, otherwise. It may assert tf during a read-shared, read-invalid or copy-back transaction to change its state to shared-unmodi ed. A module initiating a read-modi ed transaction that completes successfully will cause its cache line to change state to exclusive-modi ed.

A processor may change the state of a cache line in exclusive-modi ed state to invalid or shared-unmodi ed by initiating a copy-back transaction. It must assert tf to change state to shared-unmodi ed. If this module snoops a read- shared, read-invalid or read-modi ed transaction, it must assert iv to intervene and supply the data in place of the memory. It may keep a shared-unmodi ed copy if it asserts tf during a read-shared or read-invalid transaction. It al- ways changes the state of a cache line to invalid if it snoops a write-invalid transaction.

Furthermore, modules may split transactions if access time of a module is slow compared to bus access time. Cache and memory modules determine if they need to split a transaction by decoding the address and command for each cache-coherent read transaction that they snoop. If the module is responsible for that address and cannot respond immediately, it asserts sr.

In [19] illegal attribute combinations are speci ed. Whenever such a com- bination is observed, the system sets a bus-error. Even if the observed trans- action is legal, it may indicate an error. The absence of these error conditions is speci ed as (1).

De nition 5.1 Let (P; vL ) be a partially ordered set of processes, and k monotone with respect to vL, i.e., for all P; Q 2 P with P vL Q and for all R 2 P we have P k R vL Q k R. Then we call a process I 2 P a network invariant, if it satis es P vL I and P k I vL I for all P 2 P.

The rst step in the construction of the network invariant was de ning a parameterised model of the protocol as a WS1S transition system. In this particular case it was a simple task. We used the model described in [11] and translated it into a BTS (see Def. 2.1). Using the method described in Sect. 3 we have build a WS1S-TS from this description. The memory line and the bus itself are not considered in the model. They were added by hand to the WS1S-TS.

Much e ort has been invested into minimising the WS1S-TS. The transi- tion relation of the automata constructed from the WS1S description of the system may grow exponentially in the number of variables occuring in the system's description. Therefore, we minimised the number of second-order variables and the syntactic representation of the transition relation. This is described in detail in [22].

This is a \natural choice" for an abstraction relation. The idea is, that the abstract process should be able to \mimic" every behaviour of the system it is abstracting. The same idea is also used in [12]. We introduce an abstract

Using these abstractions and the fact that our parallel composition is monotonic with respect to vL (cf. [22]) the network invariant in question turns out to be the network invariant for the single-bus case (rf. Sect. 5.1). This will be established in the following paragraphs.

The rst step is to show, that the bus-bridge BB does not interfere with normal operation. In our model of the protocol the bus bridge itself has an in- stant transmission time and only communicates the most necessary behaviour. The delays introduced by message propagation are simulated by having the agents non-deterministically split read-commands on their local bus. Then it easy to see, that BB vL B, where B is a data bus. We have already shown, that M k B k P vL I, where I is the network invariant. Using the mono- tonicity of k with respect to vL and the fact that vL is transitive, one has MA k BB k CA vL M k B k P vL I.

The second step is to put these results together. A single-bus system is composed of the data bus, a memory unit and an arbitrary number of processors. By the abstraction MA vL M one can replace the memory unit on a bus by an memory agent without changing its behaviour. Similarly any processor may be replaced by an cache agent. Hence the bus turned into a tree node. The main point is, that any of these substitutions have the same network invariant, because the memory-agent and the cache-agent are

E. Clarke et al. [11]. They used temporal logic model checking to show that the protocol satis es a formal speci cation of cache coherence. They have veri ed a selection of examples and not a parameterised version. We have based our speci cation of cache coherence on theirs and extended it with a new progress property.

In [20] the states of a network are encoded as a regular language over an alphabet of the states of its component processes and the transition relation is represented by a nite state transducer. This idea is improved in [1,7], where this method is called regular model checking. This method has been implemented in the Pen program [24]. We have based our method on similar ideas. For some systems a network invariant can be computed using an algo- rithm proposed by D. Lesens [23], where widening techniques [13] are used to compute a network invariant for linear parameterised networks. This idea is similar to ours. All those methods are semi-automatic or may fail to terminate.

We have used PAX to compute a network invariant [21,29] for single-bus con gurations of the Futurebus+ Cache Coherence Protocol. Such network invariants are described in [12,22]. The network invariant given in [12] is not correct. Though the abstraction relations are similar, the proof in [12] was done by hand. Our semi-automatic method increases the con dence in the established proof.

In [16] it is shown that the veri cation problem for the linear Futurebus+ Cache Coherence Protocol is decidable. However, the veri cation with PAX is very fast. It only needed 2 Minutes to verify the system. Using a conven- tional model checker and 2 processors needed 36 hours to model check our speci cations.

