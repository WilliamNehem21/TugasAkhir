We use state transition systems to give semantics to the implementations and specifications of concurrent data structures. Section 2 formalizes state transition systems and our notion of refinement. We illustrate our runtime verification technique on a concurrent implementation of a multiset described in Section 3. Sections 4 and 5 present our technique for checking refinement at runtime. We discuss related work in Section 6 and conclude in Section 7.

We focus on concurrently accessible implementations of data structures writ- ten in object-oriented languages. The data structure makes available a number of operations each of which is implemented as a method. When it is necessary to distinguish these methods from methods only internally accessible by the data structure, we refer to them as public methods. Several application threads can issue calls to methods concurrently and portions of method executions can be interleaved for better performance. Throughout this paper, the domain Tid

represents the set of thread identifiers. Tid is the union of two disjoint sets, Tid app and Tid ds. The set Tid app contains identifiers of applications threads that call the public methods provided by the data structure. The set Tid ds contains identifiers of worker threads in the implementation used to perform tasks internal to the data structure.

t performs an action until the corresponding return action (t, Return, name, rets) has occurred. Thus, every atomic run is a concatenation of fragments of the run, such that only one application thread performs actions in any particular fragment. Each fragment begins with a call action by an application thread t and ends with the corresponding return action by thread t. A state transition system is atomic if all of its runs are atomic.

The call action at the beginning and the return action at the end of a fragment form the signature of the fragment. An atomic state transition system is deterministic if whenever two fragments of any two runs have the same first state and the same signature, they have the same last state as well. Thus, every trace of an atomic and deterministic state transition system is produced by a unique run.

ure 2), which looks for an available slot in the array for a single element x. If FindSlot finds an available slot, it reserves it by setting its content to x and returns its index. If no slot is available, it returns 0.

Observe that, for the InsertPair method, the method call action, the commit action and the return action may have an arbitrary number of inter- leaved actions by other application threads separating them. Thus, a witness interleaving based on the ordering of method call or return transactions would be in error. A complete proof, based on commit actions, of the fact that the multiset implementation I/O refines its specification is provided in the Ap- pendix.

Annotating the implementation with commit points is extra effort for the programmer. The reward for this effort is the capability to perform runtime checking of refinement efficiently. In addition, the process of analyzing the implementation using these terms may itself expose design flaws and result in a better design, even before runtime verification is used. Our experience with

Many concurrent data structures used in distributed systems, such as the Boxwood project[1], implement similar logs to restore system state reliably in case of a crash. With some modifications, the logging mechanisms in such sys- tems can be reused for the purpose of verification. Further, the fact that such systems tolerate the interference caused by a logging mechanism for recovery is evidence that the impact of logging for the purpose of verification may also be tolerable.

failure as return values, the runtime checks for I/O refinement would pass trivially. For useful checking, the test program must perform a number of calls to LookUp. But introducing a large number of calls to LookUp might not be desirable, as the concurrency characteristics of the program under this workload may be significantly different from regular use. Even if the test program did perform calls to LookUp, these calls may not get scheduled at the most interesting points in the execution. I/O refinement as a correctness criterion is thorough enough for static checking but needs to be strenghtened for runtime checking.

Observe that lock acquisitions and releases must also be logged to compute view in this case. With the addition of the auxiliary variable M to the imple- mentation, we get useful checking even with a test program that has no calls to LookUp. Now the refinement checking ensures that the implementation updates M in the same fashion as the specification. Note that the return value of any LookUp operation is uniquely determined by the value of M at the

This stronger correctness criterion is more likely to expose errors and pro- vide early warnings as the following example demonstrates. Consider a version of the multiset data structure that also supports a Remove operation. Sup- pose that a thread in the test program inserts an element a into the multiset twice, but, because of an error in the implementation, only the first a gets inserted into the array A. To expose the error through testing or I/O refine- ment checking alone, we need an execution that inserts a twice, followed by a removal of a, followed by a lookup of a. The probability of generating such an execution would be low. Even if such a test scenario were exercised, if the insert operations, the remove operation, and the lookup operation were sepa- rated from each other by large number of other method calls, then it would be difficult to locate the soucrce of the discrepancy. The use of M in the multiset will detect this error immediately after the attempt to insert the second copy of a.

represented by view. In this scenarion, view is used as a device to extract a canonical representation of the data structure state from the specification as well as the implementation. Such a device is useful if the specification itself contains detail in addition to the abstract view of the data structure state. Additional detail of this kind may make writing a specification easier. For instance, in the B-link data structure implemented by Boxwood, an indexing structure is needed to be able to update the data stored in the specification state. However, the indexing structure is not part of the abstract view of the data structure state.

Intrumentation of the updates to implementation variables introduces more computational overhead and possibly effects the concurrency characteristics of the implementation more than checking I/O refinement only. For this rea- son, it may be necessary to perform performance optimizations in the logging process. For instance, if it can be proven that inside the body of a method a code block has exclusive modify access to a set of variables V , then the entire update to the set can be written as a single entry to the log. In the actual execution, other updates to other implementation variables may have been in- terleaved with updates to V . However, the exclusive modify access guarantees that the interleaving does not interfere with the modifications entered into the log. In particular, at each commit point, the values of the variables obtained using this logging method are the same as they would have been without this optimization.

We provide an execution of the multiset implementation that is not lin- earizable. Consider an implementation with an array A of size two, and two application threads t1 and t2, concurrently invoking the InsertPair method. For the following interleaving of threads, both calls to Insert- Pair fail.

Run-time checking of refinement promises to be a powerful verification ap- proach with reasonable computational cost. In this paper, we investigated two notions of refinement and techniques for checking them. We are in the process of applying these techniques to an industrial software design.

Proof. Given an execution of the implementation, let us define a commit action for each method call. For calls to InsertPair that succeed, the commit action corresponds to line 12. For calls to InsertPair that fail, we define the commit action to be the call action to InsertPair. In this latter case, there are many other possible choices since failing calls to InsertPair do not modify the data structure state.

