Most large-scaled software systems are structured in distributed components to manage complexity and have to cope with concurrent executed threads. System decomposition and concurrent flow of execution are orthogonal. A sound semantic model that is powerful enough to handle distributed concurrent components but also realistic enough to provide a foundation for component technologies actually in use is still missing. Therefore, the paper introduces such an operational semantics for distributed concurrent component-based systems. Based on this formal model, UML-based modeling techniques are introduced. Tool support for modeling, code generation, and system execution is provided.

Software engineers are confronted with steadily increasing complexity of the software systems under development. On the other hand, we depend more and more on these software systems in our daily life. Hence, software engineers have to guarantee their dependability. Nevertheless, the development of software systems still includes a high level of uncertainty. More than 70 % of the development projects are not successful [1].

To implement those kinds of software systems with distributed concurrent com- ponents usually an object-oriented programming language like Java or C++ is used. Programming languages like Java offer basic constructs for concurrent programs, like for instance the util.concurrent library. Developing large-scaled distributed and con- current systems based on these primitives is error-prone. Higher-level abstractions are needed. To cope with distribution and network communication, component technologies like CORBA, J2EE, and .NET are broadly used. These technologies basically provide a component model and a remote method call. Thereby they lift the structuring of systems from objects to components and the concept of a blocking synchronous method call within a single process to a distributed environment.

In practice, before programmers start coding different specification artifacts have to be created to model the system under development. The primary focus is on the description of the component structure of the system using description languages like the UML [2]. UML provides diagrams for static and dynamic behaviour. These techniques may be extended with elements describing more precise aspects of be- haviour, such as JML [3] and OCL [4]. When it comes to integrate and refine these different parts of the models towards an implementation a clear semantical model of the relationship between the concurrent control flow and the component structure is missing, yet.

Various approaches have been elaborated to extend UML and to come up with a precise semantics for distributed and parallel systems [5,6,7]. All these approaches are based on active objects. Each concurrently executed thread belongs exclusively to a single object. Thereby, the established model - concurrent threads jumping from one component resp. object to another - is simply ignored.

[9]. In the theoretical foundation of object-oriented languages provided by Martin Abadi and Luca Cardelli [10], in Focus [11], and in *-Calculus [12] concurrency is modelled in the sense of active objects resp. components or agents. But again, it does not support concurrent threads jumping from one object resp. component or agent to another.

The rest of the paper is structured as follows: The next section introduces a simple program to show the most important behavioral aspects of distributed con- current component-based systems. In the following Sections 3 to 6, an operational semantics for distributed concurrent component-based software systems is elabo- rated. In Section 7 we show how this kind of distributed concurrent component- based software system can be modeled using UML. In Section 8 a short introduction into the modeling, code generation, and system execution tool environment for the presented approach is given. A short conclusion rounds the paper up.

Finally, the class FourWins could serve as an observable which can be observed for visualization or analyzing purpose 2 . Other components may add themselves as observers. Thereby object instances may be created and deleted. Moreover the connections between these objects represented by references and pointers may be changed during system execution like for instance by adding a new observer to the list of observers within the class FourWins. Thus, the operational semantics introduced in the next section has to support those kinds of dynamically changing structures.

The instance level - described in the Sections 3 to 6 - is the reliable semantic foun- dation of the description level. It provides an operational semantics for distributed concurrent components - it is an abstraction of existing programming models like CORBA, J2EE, and .NET. Thereby, it defines the universe of all possible software systems that may be specified at the description level and implemented using the mentioned programming models.

Furthermore, we assume an observation synchronous model because of the re- sulting simplicity and generality. This means that there is a global order of all ob- servation points and thereby of all method calls and returns. Note that this is not a critical constraint. Existing distributed component environments like CORBA, J2EE, and .NET control and manage all method calls and returns. Such a com- ponent environment may transparently force a global order of all method calls and returns.

Hence, such a run-time system is similar to a virtual machine. It observes and manages the execution of all threads. Again, this is not a critical constraint even in a concurrent and distributed environment. Existing distributed component environ- ments like CORBA, J2EE, and .NET control and manage all executed components within the environment. In Section 8 we show how the proposed approach can be implemented by extending such an existing and widely used component environment like CORBA, J2EE or .NET.

For instance, assume that a thread performs a method call. The value of an attribute is 5 as the thread has started the method call execution and the thread wants to change the value to 7 as it returns from this method call. At the observation point where the thread returns from the method call the value of the attribute is already 6, as another thread has changed the value in the meantime. Hence, a possible inconsistency caused by concurrent thread execution occurs.

next system snapshot. Thereby it can observe this consistency predicate and verify whether such a possible inconsistency situation occurs or not. If the run-time system detects such a possible inconsistent situation it may stop the system execution for reliability reasons. Note that this formal consistency concept for concurrent threads is similar to optimistic locking techniques in databases.

asynchronous message update() to all interfaces Observer which are connected via a connection Observation. Additionally to the normal observable functionality, the interface Observable provides the method deploy(). Calling deploy() results in creating a new component View with a corresponding interface Observer and attaching the interface to the Observable interface of the called component Data. In order to specify the behavior of methods and message processing for each method and for each message, an UML activity diagram is provided. Here, we use an extended version of UML activity diagrams or alternatively a textual representation

Thread 1 and Thread 2 could be the same thread. This depends on the caller. Either both have the same caller, then Thread 1 and Thread 2 are identical, or the callers are different, then Thread 1 and Thread 2 are not identical. Moreover Thread 3 and Thread 4 are newly created threads to process the received asynchronous messages update().

Software engineers can use DesignIt to model the component-based software system. To do this, the software engineer uses a CASE tool to develop a UML- based model of the desired component-based software systems. In doing so, the description techniques presented in the previous section should be used - component diagrams for the static structure and syntax, and activity diagrams to model the behavior of methods and messages.

XSLT transformations are used to generate the complete Java program code out of the XML files (step 2). The resulting Java components are then executed and debugged within the run-time system (step 3). When defects are detected in this step, the program can be debugged and analyzed.

The execution and debugging environment of DesignIt is distributed itself. It is implemented using CORBA as distribution and network communication technique. The execution environment is a CORBA server. For each component type, a sepa- rate CORBA server is started. Even the debugger is started within an own CORBA server. Hence, the execution environment, the debugger, and each component type can be executed on a separate computer.

Using this debugging environment, asynchronous messages or method calls from outside the system can be initiated. Once the messages resp. method calls are stored in the run-time environment, the whole distributed and concurrent system can be executed step by step. Each step represents an observation point in the sense of our operational semantics. Once an inconsistency appears, the debugging environment stops the system execution and informs the software engineer about the presence of a possible inconsistency situation as discussed in Section 6. The software engineer then can analyze the situation and fix the model until it is correct.

The ability to develop and maintain distributed concurrent component-based soft- ware systems is essential for modern software engineering. To bridge the gap be- tween the vertical component-based decomposition of software systems and the horizontal concurrent execution flow in software systems, an operational semantic for distributed concurrent components has been elaborated. This model also in- cludes hierarchical components - software systems that contain components which are again composed out of so-called sub-components. This has not been presented in the paper but it is included in the complete formal semantics in [15].

execution. The overall system behavior can be calculated from the concurrently executed threads and their behavior relations. Based on the operational semantics inconsistent system states, especially caused by the concurrent execution, can be detected during run-time and further system execution can be stopped.

Moreover, textual and graphical description techniques have been presented to describe this kind of concurrent component-based software systems. A complete and formally founded semantically mapping of the description techniques to the operational semantics has not been presented in the paper. This has already been elaborated in [15].

Based on this semantics complete code generation and execution within the run- time environment is supported. Tool support for modeling, code generation and system execution has been implemented and used in small case studies. However, further improvement has to be done.

Moreover tool support for reasoning on the specifications could be addressed. Currently in [15] concepts for reasoning about the changes of component composi- tion in case of component evolution are already elaborated and implemented. Fur- ther tool support concerning the consistency between specification and code may be a worth full improvement.

