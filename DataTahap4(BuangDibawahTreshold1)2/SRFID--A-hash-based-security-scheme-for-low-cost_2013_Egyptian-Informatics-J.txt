attached. Fundamentally, RFID tags provide the same func- tionality as barcodes but usually have a globally unique identifier. Using RFID, the identification is performed electromagnetically. Thus, there is, in contrast to barcodes, no line-of-sight necessary, and the identification can also be performed in contactless way. RFID also has the advantage that bulk reading is possible and that it is not susceptible to dust, dirt, or vibration like barcodes. Because of these characteristics, RFID is envisioned to be a convenient replacement for optical barcodes in the future. Unfortunately, RFID also introduces problems respecting data security and privacy arises. RFID systems have three main components [1]:

Desynchronization resilience. An RFID protocol should be resilient to attacks that are targeted toward desynchronizing the tag and the backend server. With the use of shared secrets and information, it is important that the copies of any shared secret or information stored at the tag and the backend server must be consistent.

After a successful mutual authentication, the tag ID is up- dated by both the tag and the backend server, which provides the forward security for the system. These secret update mech- anisms may results in desynchronization attack. To prevent this attack, the backend server keeps the current records and the previous records of the update process. While the server fails to authenticate a tag because of the desynchronization at- tack, it recovers the old ID from the previous secrete values up- date record to complete the authentication. A secret update protocol is also proposed for tag delegation and tag ownership transfer.

Step 2. Upon receiving R, the tag computes its current IDT = h(IDH||SQN) and the message M1 = h(IDH||R) then transmits them to the reader which forwards them along with R to the server. The backend server uses IDT to locate the tag in the database and uses M1 to authenticate the tag Step 3. When the backend server receives IDT and M1, it searches its database for ID to find the corresponding tag record.

Step 4. The backend server computers M '1 = h(IDH ||R) and compares it to the received M1 if they do not match, the connection is terminated. If, M '1 M 1, the tag is authenti- cated, Step 5 is performed.

Step 3. When the backend server receives IDT and M1, it searches its database for IDT to find the corresponding tag record. In this case, a match is not fond. So, it searches the database for IDold. If a match is found, the server com- putes M '1  h IDHold  R and compares it to the received M1

These values can be easily generated by the server, since the server does need to interact with the tag or the reader to gen- erate these values. These values are transferred to the entity via a secure channel. As a result, the entity can authenticate T a maximum of m times. However, the entity receiving the delega- tion right cannot update the tag secrets, as it does not know IDH or SQN.

Step 2. Upon receiving R, the tag computes IDT = h(IDH||SQN) and M1 = h(IDH||R) then transmits them to the reader which forwards them along with R to the server. Step 3. When the backend server receives IDT and M1, it compares them with the stored ID and M1. If they do not match, the connection is terminated. If they match, the backend server generates a random number R' and per- forms the following computations:

Eavesdropping: Throughout the SRFID protocol, the values the adversary can acquire via eavesdropping are R, ID, M1, and M2. Also, throughout the tag secret update protocol, the values the adversary can acquire via eavesdropping are R', R, ID, M1, M2, M3, and M4. The adversary tries to use this information to determine IDH and SQN. As these values are protected by the hash function and XOR operation, they cannot be exposed by simple eavesdrop- ping. Therefore, the proposed scheme is secure against eavesdropping.

Replay attack: An adversary cannot reuse messages used in previous sessions because each response is a crypto- graphic function of a fresh random number. More specif- ically, M1, M2, M3, and M4 depend on R. Also, ID depends on SQN which is shared secrete between the tag and the backend server and updated each authentication session.

Tag cloning: If an adversary wants to clone a genuine tag by creating a fake tag with the eavesdropping information, he needs to first query the tag and obtains a response which is ID and M1. Then, the adversary places ID on a counterfeit- ing tag. The adversary will succeed if the RFID reader believes that the fake tag is a real one. However, in the pro- posed scheme, the real tag returns a different hashed value M1 based on the random number R generated by the reader. Because the adversary cannot predict the random number R, the hashed value that the adversary obtains from the real tag (M1) is not the same as the hashed value that the reader obtains. Thus, the adversary cannot clone a tag to fool the reader.

Tag tracing and user privacy violation: In the proposed pro- tocol, tags responses are random in each session. More spe- cifically, ID is a hash of SQN which is secret number and is updated each authentication session. The identifier ID is also a hash of IDH which is secret and is updated each authentication session using SQN. Thus, the adversary does not know which tag the response belongs to. Therefore, the location privacy is guaranteed. However, the scheme still allows a degree of tag tracking, because a tag always replies with the same hashed ID before the next successful authen- tication. An authorized reader can query the tag every time period t to reduce this type of tag tracing attack.

construct the message M2 which is not possible. The attacker who wants to modify IDH and SQN of a valid tag, using the tag secrets update protocol, needs to know both the current IDH and SQN. The two secrets are hid- den by the hash function and the XOR operations. In addition, the secret information stored on each tag is per- tinent to itself. Unless the adversary broke the tag via physical method, he cannot know the secret information of the tag.

Indistinguishability: The proposed scheme uses ID to iden- tify tags. This ID is a hash of SQN which is secret number and is updated each authentication session. The identifier ID is also a hash of IDH which is secret and updated each authentication session using SQN. So, it is impossible to anticipate the response message of the tag each session which guarantees indistinguishability.

of the schemes proposed in [4,8,14,18]. However, the total size of messages of the proposed scheme is less than that of [19] which is lR + 3lH, that is, the difference is just 32-bits, which is the size of the random number. The storage cost of the pro- posed scheme is lS + lH bits for the tag, n(lS + 3lH) bits for the backend server, and lR bits for the reader. This outperforms the other schemes except the scheme presented in [19] in which the tag stores only lS, that is, the difference is just the size of the digest.

