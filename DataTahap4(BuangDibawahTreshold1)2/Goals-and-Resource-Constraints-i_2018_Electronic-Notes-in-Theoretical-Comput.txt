Examples of collective adaptive systems (CAS) are widespread in nature, ranging from the swarming behaviour of insects to patterns of epidemic spread in humans. These systems are characterised as consisting of a large number of simple entities or agents whose perception is limited to their own locality, but which nevertheless interact with their neighbours. Through these interactions complex emergent be- haviour may be formed at the system level, often of a form which is difficult to predict from the simple behaviour of the individual agents.

The rest of the paper is structured as follows. In Section 2 we present the Carma process algebra. The description of the proposed extension for specifying individual- level resource constraints and global goals is given in Section 3. The extensions are illustrated through a swarm robot model in Section 4. In Section 5 we present the developed software tool for experimenting with the proposed changes. Finally, we conclude this paper in Section 6.

Carma is a new stochastic process algebra for the representation of systems devel- oped in the CAS paradigm [10]. The language offers a rich set of communication primitives, and exploits attributes, captured in a store associated with each com- ponent, to enable attribute-based communication. For example, for many CAS systems the location is likely to be one of the attributes. Thus it is straightforward to model systems in which, for example, there is limited scope of communication, or interaction is restricted to co-located components, or where there is spatial het- erogeneity in the behaviour of agents.

Processes located within a Carma component interact with other components via the defined communication primitives. Specifically, Carma supports both uni- cast and broadcast communication, and permits locally synchronous, but globally asynchronous communication. Distinct predicates (boolean expressions over at- tributes) associated with senders and potential receivers are used to filter possible interactions. Thus, a component can receive a message only when its store satisfies the target predicate. Similarly, a receiver also uses a predicate to identify accepted sources. An interaction will occur only when the sender satisfies the predicate used by the receiver, and the receiver satisfies the predicate used by the sender. The exe- cution of communicating actions takes time, which is assumed to be an exponentially distributed random variable whose parameter is determined by the environment.

4 The precise syntax of expressions e has been omitted for brevity. We only assume that expressions are built using the appropriate combinations of values, attributes (sometime prefixed with my), variables and the special term now. The latter is used to refer to the current time.

In this section we shift our focus to global goals for systems. Global goals can represent the desired functional behaviour or global properties of the system. An example of the former would be specifying a target location that we want the com- ponents to navigate to. An example of a desired global property is the number of failed components being less than a given bound. Clearly these goals will have to be treated differently from the constraints as the system is not expected to start

In general state-based goals can be easily monitored: at each encountered state of the system we can decide whether the goal is satisfied or not. Thus, given a simulated trace, we can annotate it based on such goals. This can be done either on-line or off-line. Note that this does not change the behaviour of the system and thus the semantics of the model remain unchanged. In future work we would like to introduce more sophisticated ideas of control where the global goals are used to drive the behaviour of the system, through the evolution rule used in the environment of the model. However, in this paper we are using basic off-line monitoring based on global goals as a starting point.

would return a time-trajectory of the number of components named Robot that are in state Stop. For monitoring whether a goal is satisfied or not we are interested in boolean measures. Say we have a goal that the number of Robot components in state Stop state is less than five. This can be expressed in the following way:

Our simple initial implementation amounts to mapping the defined goals to measures like the StoppedLessThan5 example given above. However, with the current restriction of the language and its implementation, measure values cannot be accessed in the environment and so they cannot be used in the evolution rule. In order to be able to use the measures directly in making control decisions the Carma language will need to be modified in future work.

We have developed a software tool to experiment with the proposed changes to the Carma language. The implementation includes an extension to the parsing ma- chinery, to support the new syntax, but does not change the simulation framework. Instead, it transforms a model so that it only uses the standard Carma syntax, and can thus be analysed and simulated with the existing software.

The tool takes as input a Carma model and a scenario name, and, by examining the syntax tree generated by the parser, constructs a new Carma model which reflects the specified constraints and goals. The resulting model differs from the original in three ways. Firstly, it only includes the chosen scenario, with the rest being discarded. Secondly, the component definitions are modified appropriately by adding new guards and processes, following the mapping in Section 3.1. Thirdly, each goal is replaced by a measure, whose value at any given time is 1 if the goal is satisfied or 0 if it is not. The transformation process is described in pseudocode in Algorithm 1.

language features. While simple, it is a first step towards integration of the changes proposed here. We envision that a future release of the Carma tools will include not only support for the syntax, but also modifications to the simulator to fully and natively account for the presence of goals and constraints, with a view to allowing goal-based control of execution.

Stochastic process algebras have been shown to be a useful modelling paradigm for analysis of emergent phenomena in CAS [3,12,11,5]. The work in this paper is mo- tivated by studying emergent behaviour in the case of highly-distributed computer- based systems like robot swarms and wireless sensor networks. In particular, we are interested in applying a process algebraic framework to guide the design of control policies for such systems.

Winfield et al. [14] is an example of an early work on applying formal methods to study of CAS and in particular robot swarms. The paper presented a robot swarm model where actions of individuals were given in terms of linear temporal logic formulae. The aim was to use automatic theorem proving methods to prove or disprove whether the given emergent property, also expressed in linear temporal logic, holds. A more closely related approach, applying formal methods and mod- elling to the design of CAS and specifically swarm robotics, was taken by Brambilla et al. [4] and Konur et al. [8]. Both papers dealt with model checking properties of a population-based swarm model. Finally, there has been recent work on the use of formal models of robot swarms in conjunction with logic-based specifications of desired properties for automatic synthesis of control policies [7,9].

An example from the domain of swarm robotics was presented to demonstrate the use of resource constraints and global goals in the analysis of CAS. In particular, a model of a robot swarm was given a simple control policy and compared to the uncontrolled case. In both cases simulated trajectories of the system were monitored for satisfaction of the prescribed global goal.

