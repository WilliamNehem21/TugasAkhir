This paper describes an effort to assess the feasibility of model checking the software controlling a section of an actual subway system. A subway track may be large enough to make it necessary to divide it into many sections and to assign to each section a controller running its own specific (safety-related) software. A section normally encompasses a small number of stations, which means that the software controlling it may be relatively complex. In order to mitigate the risks of delivering an implementation with errors, the company developing the controller defines a verification and validation (V&V) process with inspection and test activities in well-defined phases.

We believe that there are some solid reasons for implementing an automatic verification process for that kind of development. Firstly, it is a well-known fact that fixing a software error becomes more and more expensive as the project progresses. The use of model checking immediately after the software is ready for release to the inspection phase may anticipate error discovery, thereby generating savings. Secondly, it may also contribute to an improve- ment in the quality of the final product, because an automatic verification may uncover subtle errors that would not be uncovered otherwise. Thirdly, the verification activities presented here may represent reduced man-hours when compared to other activities in the development process. Finally, most of the work done for the first software release may be reused during the de- velopment of the next releases.

There is some research on the automatic verification of railway control software. Since, in general, the controlled railway and its associated software can be easily and automatically reduced to a Finite State Machine (FSM), it is natural that model checking and other techniques exploiting that kind of formalism have been used to tackle the problem. Examples in the literature are [8], [7], [6], [9], [11], and [12].

The remainder of this paper is structured as follows: section 2 describes the system to be verified and discusses the benefits of our proposal that includes an automatic verification activity. Section 3 introduces the formalisms associated with BMC and explains how we implemented the use of induction proofs. Section 4 describes the experiments that we developed and shows their results. Section 5 discusses some issues and compares our results and proposals with others. Finally, section 6 concludes the paper and shows some future steps.

Except for 1L06 and 2L06, two transmitters delimit each track-circuit. Each transmitter is able to send a speed-code to a train occupying one of the track-circuits delimited by it. The speed-code informs the train of the maximum speed it is allowed to move on that track-circuit and it is transmitted by outputting a modulated electrical current throughout the tracks. There are speed-codes corresponding to 10, 35, 50, 60, and 68 km/h. Not all the transmitters are able to transmit all the codes. By construction, it is not possible that the signal transmitted by one transmitter reaches a track-circuit not delimited by it.

Track-circuits 1L06 and 2L06 are delimited by electrical insulators. The speed-codes thereon are transmitted by the transmitters installed at the ends of each track-circuit, like in any other track-circuit. The difference here is that the transmitters responsible for the speed-code of each of these track- circuits are interconnected, so in practice the same signal is generated by all the transmitters regardless of the direction of the train movement.

The most common challenge when using model checking is to deal with the state explosion problem created by the combination of all possible values of the system variables. Sometimes it is necessary to abstract some system behavior in order to enable the verification of a given specification with a simplified model. This approach has some drawbacks, namely that it may demand a manual interference in the process and cause some errors in the verification. If possible, we would like to avoid any kind of abstraction when trying to verify the control software we are interested in.

There are many model checking techniques which are intended to be used in different kinds of applications. They can be divided into two main groups: the group of techniques using an explicit representation for the states of the FSM and the group using a symbolic representation for them. In the first group, each state is individually analyzed and stored into the computer main memory, while the second group uses propositional formulas describing sets of states as well as transition relations. The explicit representation methods are usually used when the system can be modeled by an FSM limited in its size by some few million states. That limit is usually given by the amount of main memory available on the computers in use nowadays. Since we are dealing with systems with a number of states much larger than that limit, explicit representation techniques would not be our first choice.

The advantages of BMC over unbounded model checking are manyfold. First, the user does not need to set up the environment manually. Usually, the default parameters will suffice. Second, the model checker is able to deal with thousands of variables instead of hundreds and, in doing so, it uses much less memory and spends much less computer time. Third, the generated counter- example is guaranteed to be minimum, simplifying the analysis of the problem. The first and second features will be of great value for us in our verification process.

signal X99-A will be eventually (F) turned off and stay at that state until (W) X99-1 is not reversed. This sentence format has two drawbacks. The first one is that we have no information about the number of cycles the software takes to respond to the new condition. It is a sensible issue because if we keep the LTL specification as stated above, we are theoretically accepting long response times that could turn the implementation unable to quickly respond to an emergency situation, making it unsafe. Moreover, in order to use the inductive proof scheme we need to have a bound k on the number of software cycles and the sentence, as stated above, does not carry any information about

k and a generic initial condition, the safety rule we are interesting in would be verified if k is to be considered small enough. In fact, it would be proven that if the point is in reverse at any state si , then the signal is off at any successor state si+k . It also means that the signal will stay off while the point keeps its reverse state because if the point is still in reverse at si +1 then the signal will be off at si +k +1 and so on. In our example, we concluded after a quick source code analysis that the specification to be proved is (X99-1RWCK

We chose to check safety rules associated with the observable behavior of the track. The software has a large set of variables which are used internally and must comply to its internal rules. The violation of these rules may not necessarily bring the system to an unsafe state, because the internal variables do not directly change the current state of the track.

happens, then a safe state will eventually be reached and the system will stay at that safe state until the input condition is reset. Strictly speaking, those rules may also be considered invariant properties of the system, be- cause any Gf property can be considered to be so. However, in this paper, we will reserve the word invariant to the propositional formulas that must hold without any explicit dependency on the inputs.

codes corresponding to 35, 50, and 68 km/h only. The variables associated with other speeds are not defined in the program. Therefore they do not belong to the transmitter safe state definition. Similar condition/safe state pairs apply to the other transmitters.

Both points are locked whenever any signal is turned on. An on-signal enables the train passage through its points. Thus, for safety reasons, it is necessary that both points be locked in order to avoid any accidental point movement that may cause train derailment. This rule is input-independent and may be stated by the following invariant:

In order to prove the rules using the inductive procedure described above, we have to create LTL specifications for those rules. The specifications may be provable true after a finite number of cycles of the software being analyzed. We have already given an example in which we found that the software needs two cycles to turn signal X99-A off after point X99-1 is in reverse. Obviously, we could expect that at least one cycle would be necessary, because the software needs to be executed at least once before it can respond to any input change. However, we do not have any means to know the necessary number of cycles a priori without recurring to analysis. It could well be the case that the software needed three or four cycles to respond.

assignments of the variables used by the rule to be verified and of the interme- diary variables that may affect them. After the analysis, the LTL formula is written and checked. If the model checker indicates that the specification does not hold, it may be either because the LTL specification was incorrectly stated or because the software has some error. In both cases we have to re-analyze the program with the help of the model checker counter-example.

Another way of creating an LTL specification is assuming that the software is correct and starting from a tentative specification. If the model checker states that the specification holds, the process ends. Otherwise, we can create a new tentative specification until either we prove the rule or we give up and consider analyzing the source code. Although we may have to run some tentative specifications before we reach a valid one, we may save some time and effort because the model checker response time is short compared to the time needed to analyze the source code. In the example given above, we could

One interesting point is the origin of the X operator used at the beginning of specifications of groups 2.1, 3, and 4. These groups are responsible for checking the input-independent invariants. It means that the LTL specifica- tions depend only on the variables calculated by the software. According to the model we are using, the values of those variables are completely undefined before the first software cycle. Therefore, it is not possible to guarantee any rule concerning their values before the first iteration. The X operator in front of the formula reflects this argument. The LTL specification of group 2.1 has

The results described above are consonant with the successful results reported by [8] and [6]. The later achieved verification times of fractions of a second for a system of about 2000 variables and k = 1. Both system size and verification times are close to ours. [7] successfully verified the control software of two subway stations using a BDD-based model checker and proving specifications written in a format close to ours, although the specifications were written in CTL rather than LTL. During our experiments, we wanted to discover if we would also be able to verify our properties using BDDs. Unfortunately, NuSMV was not able to verify any specification, so we decided to experiment

with another easily available SMV implementation called Cadence SMV [1], trying to verify one property of each of the four groups defined above. The results for the simpler section ranged from 25 seconds of execution time and 65 Mbytes of memory for verifying a property of group 1 to a failure in the verification of the property of group 4, due to lack of memory. No specification of the larger section could be verified. Hence, although the good results re- ported by [7] with BDD-based model checking, we concluded that SAT-based BMC seems to be much more promising for our domain.

We have presented the results of model checking two different actual sections of a subway track. The main problem that we could have faced was the state explosion problem. However, experience showed that we were able to verify all the rules in relatively short time, with no need for further abstractions, which would demand more manual interference on the process as well as the possibility of inserting errors into the verification. An interesting point is that although we used a model checker, we actually did not need one. A SAT solver would suffice, because it is not possible to verify a temporal formula of depth k in less than k applications of the transition relation. Hence, there is no use in trying to find a counter-example smaller than k . However, we decided to use NuSMV because it easily represents the model to be verified and is freely available. Another point in favor of the model checker is that the time spent on finding counter-examples smaller than the depth of the formulas is not a problem, given its fast response time. We conclude that, for the specific kind of subway control software that was examined, an automatic verification process based on model checking and on the described approach seems to be feasible.

