Traversal strategies provide an established means of describing automated queries, analyses, trans- formations, and other non-trivial computations on deeply structured data (including, most notably, data representations of software artifacts such as programs). The resulting traversal programs are prone to programming errors. We are specifically concerned with errors that go beyond classic type errors, in particular: (i) divergence of traversal, (ii) unintentional extent of traversal into data, (iii) trivial traversal results, (iv) inapplicability of the constituents of a traversal program along traversal. We deliver a taxonomy of programming errors, and start attacking some of them by refinements of traversal programming.

Despite these advances, the use and the definition of programmable traver- sal strategies has remained the domain of the expert, rather than gaining wider usage. This could in part be due to necessary language, library, and tool sup- port, but we contend that the principal obstacle to wider adoption is the severity of some possible pitfalls, which make it difficult to use strategies in practice. Some of the programming errors that arise are familiar, e.g., type errors, but other errors are of a novel nature. Their appearance can be off- putting to the newcomer to the field, and it can limit the productivity even of experienced strategists.

1 Haskell in all its glory has infinite and partial data structures, such as trees with undefined leaves, or indeed undefined subtrees. In the presence of infinite and partial structures, the discussion of strategy semantics and properties (most notably, termination) becomes more subtle. We are currently limiting our discussion to finite, fully defined data. (The subject of coinductive strategies over coinductive types may be an interesting topic for future work.)

That is, a strategy returns Nothing to signal failure, while a successful compu- tation returns a value of the form Just x. The Data constraint in the definition of Strategy enables the non-parametrically polymorphic traversal capability of all and one. For our discussion, the further details of the SYB approach are not important. The above traversal schemes are all of the following type:

In the first pattern, if the constituents s1 and s2 are of the same type (or more generally, the type of s2 can be specialized to the type of s1), then s1 has no chance of being applied. Likewise, in the second pattern, if f1 never possibly fails, then f2 has no chance of being applied. Finally, in the third pattern, if f1 never possibly succeeds, which is likely to be the symptom of a programming error by itself, then, additionally, f2 has no chance of being applied.

The earlier problems with (polymorphic and monomorphic) defaults feed into a more general kind of problem: misunderstood success/failure behavior of traversal schemes and their strategy parameters. (We should generally note that the various kinds of programming errors discussed are not fully orthogo- nal.) Here is a simple example of misunderstanding.

In the above (contrived) example, misunderstood success/failure only leads to incorrect text output. In general, programmers may compose traversal programs in ways that their control pattern depends on assumptions as wrong as the one above. Even when misunderstood success/failure behavior does not affect correctness, it may instead lead to defensive and convoluted code. For instance, in the following strategy expression, the application of try (defined in

However, there are scenarios that call for polymorphic, problem-specific constituents of traversals; cf. [22,13,14] for some concrete samples. Hence, the original (generic) schemes must be retained. Some cases of strategies with multiple type cases can be decomposed into multiple traversals, but even when it is possible, it may still be burdensome and negatively affect performance.

We say that a strategy is infallible if it does not possibly fail, i.e., if it will succeed (or diverge). It is relatively easy to confirm the following claims about infallibility. Given is a strategy s. If s is infallible, then full td s and full bu s are infallible. No matter the argument s, the strategies stop td s and innermost s are infallible. No infallibility claim about once bu can be stated; this scheme is intrinsically fallible.

We can easily provide a (non-classic) proof of the above claims, where we use these claims as new types of the traversal schemes. That is, a type is made infallible by stripping off the monad wrapper from the type. The definitions of the infallible schemes remain unchanged, except that some of the basic strategy combinators also need to be trivially complemented by variations with infallible types.

In the following, we use an advanced Haskell library, HList [7], to describe the constituents of a traversal scheme as a family of monomorphic cases, in fact, as an appropriately constrained heterogeneous list of functions. Consider the pattern that we used so far: adhoc (adhoc g s1) s2. Two type-specific cases, s1 and s2, are involved, which are used to point-wisely override the generic default g. The type-specific cases can be represented as the heterogeneous list HCons s1 (HCons s2 HNil). 7 Such a list may be converted to a plain adhoc chain by a function, familyM, which takes a polymorphic default as an additional argument. This function also checks that type-specific cases do not overlap. Here are the schemes that are parametrized in families of cases; the new schemes leverage the original schemes. 8

Again, the Haskell experiment shown merely serves for illustration. In an im- proved, strategic programming language, all traversal schemes may be anno- tated by constraints for reachability, or these constraints may even be inferred automatically. All reachability constraints would be statically checked.

Constrained forms of traversal programming may be less prone to the er- rors that we discussed. For instance, one can limit the programmability of traversal (e.g., in ASF+SDF with traversal functions [21]), or impose more structure on traversal programs (e.g., in adaptive programming, where traver- sal specifications and computations or actions are separated). It is our goal to admit full programmability, but ban programming errors by static analysis

Some of the discussed strategy properties and the corresponding analyses naturally call for a more general treatment. For instance, dead-code elimina- tion, strictness analysis [17] or termination checking [1,2] are known procedures for functional programs, perhaps even generic functional programs. We hope to exploit this body of knowledge in the future. We assume that there is endur- ing value in studying properties right at the level of strategies because domain- specific languages are generally meant to provide domain-specific checks and optimizations, while feedback should relate to domain concepts, too.

of programming error.) We hope to eventually gather enough analytical power and strategy properties so that the declarative style of strategic programming can be mapped to highly optimized code. Here, we are inspired by previous work on fusion-like techniques for traversal strategies [6], and calculational techniques for the transformation of traversal strategies [3].

