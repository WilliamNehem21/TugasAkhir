Software coordination and adaptation are tightly related to modular software entities and access points. These entities (components or services) may be complex, dissimilar (various models) and designed at differ- ent granularity levels. In order to allow interoperability we need rich interface descriptions including service hierarchisation, flexible declarations and precise specifications. In this article we present a Hierarchical Behavioural interface description language that enables the structuring of services, their encapsulation and it also facilitates the use of component interfaces. We also investigate in this work the adaptation for Hi- erarchical Behavioural IDL. We recall various adaptation problems and we introduce modelling techniques and some solutions within hierarchical context considering precision of the interfaces, their layering and flexibility.

Component-based development is the process of building programs by gluing to- gether active software parts [12,19]. Usually the glue adheres on access points and when it does not, one uses adaptation techniques to make it adhere. Software adap- tation [27,16,8] includes the detection of interaction mismatches and their correction when it is possible. The correction can be either a dynamic adaptation at running time or the insertion of static adaptors (or transformers).

In a wide acceptance, a software architect would integrate software components from any provider and therefore with a non-restricted range of models. It means that the components can be components `a la CBSE or services, assuming that there are many different component models and many service models. In such a context, the software architect needs a language that helps her/him either to define clearly what she/he needs or to find components on the shelf and appropriate adaptation mechanisms. Usually, such a language applies at an interface level and should be

The article is organised as follows: Section 2 motivates and presents the hi- erarchical behavioural interface description language of our component model. In Section 3 we consider adaptation problems that are either introduced by the hier- archisation level or solved using specific features of our model. We conclude with the perspectives of this work in Section 4.

In the BIDL approaches [27,9,10,7,22], the interface specifies the ordering of ser- vice invocations and the dynamic behaviour using protocols. A protocol specifies the valid interactions between components. For example a protocol can be a state transition system [22], a regular expression [23], or a non-regular process type [25]. A protocol may be associated to a component, to an interface or to a connector 2 . In the first case the protocol merely controls the component lifecycle (like a pro- cess if there is only one protocol). In the second case the protocol controls the component interactions in some identified relations: an interface can hold on peer- to-peer channels (one per connected component) or on view (like database views). In the last case the protocol controls the communications on a structural access point: it manages the communication aspects of the components or it can be an explicit adaptor. The semantics and usage are slightly different from one approach to another, especially if we have in mind the adaptation issues.

The advantages of using a HBIDL are manyfold. It supports the definition and documentation of complex interacting services. The client-side documentation of a component has detailed information on the service usage. Indeed, the client gradually discovers the documentation of the components and services. First, the component interface shows the services that are accessible at a component level; then the specific interface of each provided service; therefore the client only gets step by step what she/he needs.

A service can provide optional subservices. For example, the askcode service can be linked to a service that does not need identification (ident service). Similarly the askformoney service can be linked to a withdraw service that does not need code (code service).

In Kmelia, a service behaviour is an extended labelled transition system (eLTS) [3] where the states define the service evolution steps and the transitions are labelled with possibly guarded combination of actions: [guard] action*. The actions are either elementary actions or communication actions. An elementary action, an assignment for example, does not involve other services; it does not use a commu- nication channel.

Granularity mismatch between a HBIDL and a BIDL: having a more expressive language does not mean every model uses the expressiveness to the full extent. For a new language to be effective, differences of levels of detail must be dealt with, as well as interoperability with models expressed in languages which intersect with the new one. Problems from this category can be treated like granularity mismatches in HBIDL by considering BIDL models as flat HBIDL models.

The COSTO prototype features several verification algorithms that check compati- bility of components and services at different levels: signature, interface, dependen- cies, behavioural compatibility. Behavioural compatibility is checked by exporting our Kmelia models to Mec [13] or Lotos [17] and reusing their respective model checking tools. We assume that the matching between names (of different com- ponents, services or messages) has already been established, either manually or automatically (e.g. by ontology-based approaches).

Then we explain how to generate systematically an adaptor and verify that it ensures compatibility. Depending on the constraints of the running environment, the adaptor can take several forms: a component inserted between two mismatch- ing components, a proxy service delegating to one of the services, or an alternative interpretation of a behaviour. We will focus here on the first one.

The parameter vs messages problem can be further complicated by the use of parameters with types of different granularity in the client and in the provider, for instance the deposit service could have had a structured type in its signature while the caller would have used primitive types in its call. The complexity of the detection and the generation is related to the complexity of the data structures used in the parameters (data might have to be constructed or decomposed) and the similarity metrics used for identifying the parameters. The diagnosis algorithm of COSTO for the parameter vs messages problem is parametrised with an identification method which has to be changed to incorporate the variants of the problem.

This Hierarchical Mismatch can be avoided using implicit adaptation when the creation of the service ident is coming from a refactoring of the service withdrawal. In such a situation the designer should be conscious that while identifying, naming and factorising some part of behaviour are good from the readability point of view, that breaks compatibility with client services that predate the change. The <||> operator is a vertical composition operator that could have been used instead of the <<>> operator in the example. This operator allows to branch to the subservice either by calling it or without the call in order to be compatible with both new clients and older clients 4 .

We have considered adaptation problems encountered in BIDL and also related to our HBIDL: hierarchy mismatch and parameter vs message mismatch. We moti- vated and showed what solutions are used for these problems in our Kmelia model. The vertical structuring mechanisms help to tackle the adaptation problems. Com- pared to BIDL related works, we have emphasised the impact of the hierarchical BIDL on the adaptation problems and we have shown that the use of structuring mechanisms may simplify design and verification of both services and adaptors.

