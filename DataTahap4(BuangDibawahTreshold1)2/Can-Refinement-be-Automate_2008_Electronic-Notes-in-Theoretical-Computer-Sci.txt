in demonic refinement algebra is almost two pages long and the proof search involved and the complexity of the axioms used is substantial. For the sake of readability we do not display all input/output files and the complete machine proofs. They can all be found at a web site [1].

Second, the predicate transformer model underlying the refinement calcu- lus of Back and von Wright [6] is excluded as well. Only universally conjunctive or disjunctive predicate transformers satisfy the Kleene algebra axioms [36]. Here, universal conjunctivity (disjunctivity) means distributivity of multipli- cation over arbitrary infima (suprema). This of course implies distributivity over the empty infimum (supremum), which yields the right zero axiom. Pos- itively conjunctive (disjunctive) predicate transformers, however, which only distribute over non-empty infima (suprema), do not satisfy the right zero ax- iom. But they are the appropriate models for demonically nondeterministic programs under the standard weakest precondition semantics.

The particular axioms of demonic refinement algebra can easily be moti- vated from the predicate transformer model with infinite iteration, cf. [36]. It is also immediately obvious that demonic refinement algebras do not cap- ture the relational semantics, since in the presence of the right zero axiom, the isolation axiom collapses strong iteration to finite iteration. However, all theorems of demonic refinement algebra that do not mention strong iterations are also theorems of Kleene algebra.

In the first part of the input, the precedence of operators is fixed. Here, the star and strong iteration bind stronger than multiplication which itself binds stronger than addition. The second part is a set of support list that contains the axioms of demonic refinement algebra. The third part is an additional set of support list that contains some useful laws of demonic refinement algebras that have previously been proved. The dual unfold law for strong iteration, for instance, will often be added to this set, too. The third part of the input lists the goal to be proved.

In this section we develop a toolkit of meaningful basic refinement laws in the context of demonic refinement algebra. It is common practice to use such laws for proving more complex refinement laws or for developing and analysing concrete refinements of programs and software systems. These more abstract laws can often replace the more low-level induction or coinduction axioms of Kleene algebra or demonic refinement algebra in computations.

We have already developed a toolkit of automatically verified theorems for Kleene algebras and several extensions that use the right zero axiom x0= 0 [15]. Many of these theorems are also valid in the weaker context of demonic refinement algebra. Since the Prover9 output files present all hypotheses used for proving a particular goal, this can easily be checked. In those cases where

We will automatically verify a basic refinement calculus that support these tasks. Many particular refinement laws can be found in [35]. All technical details, including the Prover9 and Mace4 input and output files, can be found at a web site [1].

In practice, when starting with a too small set of hypotheses, Mace4 usu- ally finds a counterexample. When adding more and more hypotheses, Mace4 eventually will not return a counterexample in reasonable time. Then Prover9 should be started. Expensive axioms such as commutativity of addition or the unfold rules should be added as late as possible. If a proof without commu- tativity is not possible, it often helps to commute terms in the set of support and the goal. Handwritten proofs in variants of Kleene algebras are usually quite short, i.e., less than ten lines. The number of permutations of terms is therefore strongly limited.

Back and von Wright have presented several laws for data refinement of ac- tion systems in the predicate transformer setting [6]. von Wright has already translated one of these laws into demonic refinement algebra. In this section, we provide an automated proof of this law. Here, for the first time, we leave the level of pure demonic refinement algebra and predominantly work at the more abstract level of refinement laws introduced and verified in Section 6. Our hypothesis learning heuristics now becomes particularly important for finding the right set of support for Prover9.

The first hypothesis says that b cannot loop infinitely. The second hypoth- esis expresses that a is data refined by a' with respect to upward simulation z. By the third hypothesis, 1 is data refined by b. The fourth and fifth condition expresses the standard data refinement of initialisations and finalisations.

The proof planning is now greatly simplified in the presence of some expe- rience with data refinement. It can be expected that some forms of denesting and semicommutation will suffice for deconstructing and reconstructing con- currency. For the transformation of interleaving, simulation laws seem highly relevant, whereas the laws of the additive monoid seem avoidable. The effect of the star and strong iteration axioms is hopefully captured by simulation, so that these laws should only be added if necessary. These considerations

This algebraic reasoning can easily be translated into diagrams, as used in term rewriting (cf. [33]) and refinement (cf. [6]). This has extensively been discussed in [13]. In particular, glueing of diagrams along edges corresponds to isotonicity reasoning. Therefore, the following diagrams describe the tran- sition from the succedent of the data refinement theorem to the analysis of the infinite loop.

Our attempts to prove the atomicity refinement theorem lead us to consider simplified variants. Setting r = 0 and l = 0, an automated proof can be obtained in a few seconds. Setting only l = 0, Theorem 9.1 simplifies as follows.

From the refinement point of view, it seems very interesting to extend demonic refinement algebras to encompass also downward simulations, which is needed in data refinement. As already mentioned, this could be achieved either by adding an operation of converse or through modal operators. More generally, modal demonic refinement algebras would considerably increase the expressiveness of the approach.

We are most grateful to Mark Schaefer for placing his powerful PC at our disposal for proof search. With our own slow machines we would possibly not have met the deadline. We would also like to thank our referee for interesting pointers to the literature.

