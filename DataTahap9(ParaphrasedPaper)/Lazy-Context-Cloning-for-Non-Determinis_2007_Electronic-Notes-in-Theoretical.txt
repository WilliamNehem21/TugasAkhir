The attractiveness of functional logic programming lies in its non-deterministic nature, where the execution of a program can yield multiple results from a single expression. To illustrate this concept, consider the example of a program designed to identify a suitable blood donor for a patient, as defined in the Curry language through declarations of blood types and compatibility.

This paper delves into both theoretical and practical aspects of implementing non-determinism. The second section highlights deficiencies in typical non-deterministic implementations and outlines the authors' proposed solution. Section 3 provides background information, while Section 4 defines the strategy and related concepts. The subsequent section proves the soundness and completeness of this strategy. Section 6 briefly discusses the challenges and potential solutions related to extending the strategy to narrowing, while Section 7 addresses related work. The paper concludes with Section 8.

Functional logic programs are commonly viewed as term rewriting systems (TRSs) with a constructor discipline. Program execution entails the iterative application of narrowing steps to a term until a constructor term is reached, signifying a successful computation, or an unnarrowable term with a defined operation, which marks a computation failure, e.g., attempting to divide by zero or retrieve the first element of an empty list.

For the TRSs considered here, the computation space of a term takes the form of a tree-like structure. A child results from the application of a step to its parent, and a tree branch is formed when the strategy computes multiple distinct steps on the same term. The order in which the strategy is applied to children and their descendants affects the traversal of the computation space but not its content.

The use of copying involves simultaneous, independent evaluations of terms, and if either evaluation produces a constructor term, it becomes a result of the computation. Both backtracking and copying have been utilized in the implementation of functional logic languages, but they have notable drawbacks.

The paper also touches on the evaluation of the correctness of the strategy and the challenging nature of proving completeness. It further emphasizes that certain so-called "bubbling steps" play a crucial role in determining the soundness and completeness of the strategy. Moreover, the correctness of bubbling is established irrespective of whether it is carried out in a rewriting or narrowing computation.