In today's interconnected world, code mobility is widespread, with even mobile phones and personal digital assistants supporting the installation of third-party applications from various sources. This ability to install applications from potentially untrustworthy sources poses a significant risk, as malicious or faulty applications can cause denial of service, financial loss, or leakage of sensitive information. To mitigate this threat, the research community has devised various countermeasures, including run-time monitoring and enforcement of predefined security policies.

This paper describes a tool developed as part of the Security of Software and Services for Mobile Systems (S3MS) project to address these concerns. The tool implements a monitor for the .NET platform using bytecode inlining and includes formally verified algorithms. It is capable of handling real-world applications for both the .NET Compact Framework (for mobile devices) and the full .NET Framework (for desktops and servers).

The tool's inliner examines untrusted application bytecode for calls to security-relevant methods (SRM), a task made challenging by dynamic binding and delegates supported by the .NET virtual machine. The tool implements an algorithm by Vanoverberghe and Piessens to address this issue. Additionally, the tool has extended support for inheritance and dynamic binding, which allows the consideration of runtime object types during the inlining process. To address potential synchronization issues, the tool partitions handler methods based on their access to distinct security state variables, enabling independent locking of different partitions.

The S3MS.NET run-time monitor is part of a comprehensive security architecture for mobile devices that supports the security-by-contract paradigm, which allows for dynamic policies, such as limiting the number of times a method can be invoked or setting quotas on resource accesses. However, the approach implemented in the tool has limitations, including difficulty in expressing certain policies as security automata over API method calls, such as limiting network traffic. This limitation arises from challenges in predicting resource consumption due to factors like DNS lookups and redirects.