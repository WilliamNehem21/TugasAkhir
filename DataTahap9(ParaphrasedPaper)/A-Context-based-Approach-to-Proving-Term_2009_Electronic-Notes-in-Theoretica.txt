We propose an approach to demonstrating the termination of evaluation in reduction semantics by leveraging Tait-style reducibility predicates defined on terms and contexts. Our framework covers the simply typed lambda calculus and its extension with abortive control operators for first-class continuations under the call-by-value and call-by-name paradigms.

The advantages of utilizing contexts are particularly apparent in programming languages with control operators, which are constructs that manipulate the current continuation/context. Context-based reduction semantics offers a convenient formalism for expressing and verifying type soundness properties, as demonstrated by previous work.

The syntax of reduction contexts is dictated by the selected reduction strategy, and consequently, the grammar of reduction contexts reflects the chosen reduction strategy. For this reason, the explicit definitions of reduction contexts for call by value and call by name are deferred to section 2.2 and section 2.3, respectively.

We establish the set of free and bound variables in a term in the customary manner and make the distinction between closed terms, which have no free variables. Furthermore, we equate terms that differ solely in the names of their bound variables.

In the conventional approach, the reducibility predicate on well-typed terms indicates that when a reducible term is applied to another reducible term of the appropriate type, the resulting term also possesses this property. Additionally, if a term is reducible, then it normalizes. The proof of termination involves demonstrating that all well-typed terms are reducible, which implies that all well-typed terms normalize.

We demonstrate that the empty context satisfies a continuation for any type. From lemma 2.4, we deduce that when a closed well-typed term is placed in the empty context, the resultant program evaluates to a value program.

While it may not be feasible to prove a stronger type soundness property in the general case, such a property can be achieved if only plain programs are considered. Specifically, plain programs can be shown to satisfy the strong type soundness property, which asserts that the type of a plain program and its final value are identical. This property, together with the termination theorem of section 3.1.3, ensures that any well-typed plain program evaluates to a unique value of the same type. However, even in the case of plain programs, a standard subject reduction property cannot be expected for our type system, as the capturing and substitution of contexts for continuation variables leads to non-plain programs during computation.

We aim to establish strong type soundness for the aforementioned type system by connecting it to a more restrictive system, namely an annotated type system that permits the application of contexts of one designated answer type. The annotated type system dictates the type of the entire program, of which the given phrase can be a part. Only contexts of that answer type are permitted to be captured and applied later on.

In this section, our objective is to prove termination of call-by-value evaluation of well-typed plain programs (therefore, of well-typed plain terms). The logical predicates for the language with callcc mirror those for the simply typed lambda calculus, and we formulate a termination theorem comparable to that of section 2.2.3.

Similarly, the plain language with the call-by-name reduction strategy satisfies both weak and strong type soundness properties. Using the logical predicates defined for the simply typed call-by-name lambda calculus in section 2.3.2, we demonstrate the termination of call-by-name evaluation for the language enhanced with callcc.

We observe that the presented typing rules for a and c are excessively permissive, failing to ensure type preservation by reduction due to the entirely unconstrained type b in the premises. Consequently, despite the fact that evaluation in the simply typed language with a and/or c always terminates, the program's type may change during computation. To ensure type preservation under the given reduction rules, we could employ a more restrictive type system that extends the annotated type system of section 3.1.2 with the rules for call-by-value and call-by-name reduction strategies. Furthermore, we provide evaluators derived from each of the proofs, which are instances of normalization by evaluation and are also in continuation-passing style. The continuations emerge as the computational content of the reducibility predicates for reduction contexts, demonstrating a logical connection between continuations and contexts.

Finally, we present example OCaml implementations of the evaluators from section 3.1.4 and section 3.2. Although these implementations can be considered as desired outcomes of a program extraction tool, they have not been obtained using such a tool and are generally less readable than automatically generated code.