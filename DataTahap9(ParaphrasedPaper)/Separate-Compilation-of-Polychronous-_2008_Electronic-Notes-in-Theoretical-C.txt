To benefit from the flexibility and ease of use offered by separate compilation services, we propose a simple analysis and code generation technique to address this limitation. Our approach involves relaxing the typical global safety objective, isochrony, and instead considering a more permissive version of weak isochrony that has been recently suggested.

Endochrony ensures that a system responds to events from an asynchronous environment by locally and deterministically selecting which events need to be synchronized at all times. It guarantees that local computations and communications are not affected by global network latency. However, it does not support compositional behavior.

In contrast, the approach proposed by Girault for the Lustre and Esterel languages involves replicating the automaton obtained from the synchronous module and then optimizing the elimination of replicated transitions, which are replaced by inter-partition communications. Our approach focuses on maintaining a less expensive yet compositional objective of weak isochrony while considering the composition of endochronous modules. This approach appears to be more cost-effective for code generation. We have implemented this methodology, which efficiently reuses most of the compilation tool chain of Polychrony, to propose a straightforward synthesis scheme that ensures the desired compilation objectives.

This article provides a tutorial on existing and contributed compilation techniques through a series of illustrative examples, without addressing or proving related formal aspects. It relies on existing analysis algorithms (and proofs) implemented in Polychrony.

The tutorial begins in section 2 with an overview of the signal data-flow specification language and its analysis of synchronization and scheduling relations. Section 3 continues this tutorial with a presentation of the code generation techniques currently implemented in Polychrony, the toolset supporting the signal language. Our contribution, built upon these techniques, is presented in section 4.

The data-flow synchronous formalism Signal allows for the representation of control-flow and data-flow graphs of multi-clocked specifications for analysis and transformation. In this structure, a clock "c" denotes a set of instants and defines a discrete sample of time, serving as the condition for the execution of a data-flow relation.

The transition function is a crucial aspect, as it translates the hierarchy structure and the serialized scheduling graph into C code, while making optimizations along the way. For instance, "r" has disappeared from the generated code, as the value stored in "y" from one iteration to another is the same as that of "r," and it is used in place of it for that purpose.

It is notable that the return code is true when the transition function finalizes, but false if it fails to receive the signal "y" from its input stream. This is suitable for simulation code, as the simulation is expected to end when the input stream sample reaches the end. Embedded code, however, operates differently, either waiting for "y" or suspending execution of the transition function until it arrives.

The buffer process satisfies the property of endochrony, meaning that the buffer is locally timed. In the transition function of the buffer, this is evident as the function synchronizes on either receiving "y" from its environment or sending "x" to its environment at all times. Hence, the activity of the transition function is locally paced by the instants at which the signals "x" and "y" are present.

For example, the composition of the producer and the consumer is weakly endochronous, as the presence of all signals in this composition is locally determined from the value or presence of signals in either the producer or the consumer, in a deterministic manner. The order of execution (producer first, consumer first, or both) does not matter, as they satisfy the diamond property, which defines weak endochrony.

In the controlled main program, variables prefixed with "pre_" register the values of signals until the next cycle. The generated "r" variables translate the synchronization obligation implied by the reported clock constraint as "r = ra && rb." Functions named {r|w}_main_x read and write the signal "x."

A necessary condition is that the graph of "p|q" must be acyclic, and a sufficient condition is that "p|q" should not react to the absence of a signal, i.e., all clocks in the graph of "p|q" should have a disjunctive form.

The generated code is otherwise unchanged. We achieve a concurrent code generation scheme that modularly and compositionally supports separate compilation. It efficiently utilizes the existing report functionalities of the present implementation of Polychrony to effectively support the synthesis of a controller that can assemble endochronous processes to maintain a global objective of weak isochrony.

We use "t(s)" to represent the chain of tags of a signal "s," and "min s" and "max s" for its minimal and maximal tag. The restriction of a behavior "b" to "x" is noted as "b|x" (i.e., such that "v(b|x) = x"). Its complementary "b/x" (i.e., such that "v(b/x) = v(b) \ x") satisfies "b = b|x b/x." We also use "t" and "v" to refer to the tags of a behavior "b" and the set of signal names of a process "p."