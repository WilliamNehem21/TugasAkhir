Despite extensive research on abstractions, the issue of state explosion remains a significant challenge for the practical application of explicit-state software model checking in real-world scenarios. One such abstraction technique for CTL model checking is known as path reduction. The fundamental concept behind path reduction is to condense single-successor chains in the state space if intermediate states do not impact the validity of a specification. This means that states are only stored when visiting program locations that cause a branching in the state space or influence the validity of the CTL specification, referred to as breaking points. For example, a program statement that alters the value of a variable used in an atomic proposition or reads a nondeterministic value, resulting in a branching in the state space, is considered a breaking point. By storing states only at these specific locations, the memory footprint of the state space is reduced, potentially at the expense of increased runtime.

To ensure the termination of the model-checking process, states must be stored in possibly nonterminating loops for fixed-point detection, necessitating at least one breaking location in each loop. However, existing termination proofs for high-level programs cannot be directly applied to low-level code.

This paper introduces a novel technique called on-the-fly path reduction, which dynamically performs state-space reductions while generating states. This approach is unique in that it conducts tasks such as detecting fixed points while states are being generated. Additionally, the paper outlines how to expand counterexamples obtained with path reduction to concrete counterexamples. The effectiveness of on-the-fly path reduction is evaluated by comparing its performance with results obtained using static detection of breaking points. The paper also discusses related work and concludes with a summary.

The criteria for a state to be considered a breaking point in the reduced state space are evaluated. For path reduction, this criterion is solely dependent on the program counter. Static analysis is used to identify breaking program locations. The conditions for a location to be considered breaking are as follows: the location must have more than one successor in the state space, any changes of variables used in the formula must be visible to the model checker, and there must be a breaking point in every loop in the program to enable fixed-point detection.

The paper presents an algorithm for on-the-fly path reduction that incorporates improvements in state generation. Furthermore, it discusses the accuracy and efficiency of the algorithm. The results of experiments on different programs demonstrate the impact of path reduction on state space reduction and runtime.

The differences between static path reduction and on-the-fly path reduction are analyzed, with an emphasis on the handling of loops. It is noted that on-the-fly path reduction compresses loop iterations more efficiently compared to static path reduction.

Several case studies are conducted to evaluate the effects of on-the-fly path reduction on different types of formulae. The results of these evaluations are presented, indicating the impact on the size of the state space and the time required for model checking.

The paper also discusses related work and compares the proposed approach with similar techniques implemented for other model checkers. It highlights the advantages and disadvantages of different approaches and emphasizes the effectiveness of on-the-fly path reduction in reducing state space.

In conclusion, the paper demonstrates the effectiveness of on-the-fly path reduction as a dynamic technique for state-space reduction in binary code model checking. It also discusses the expandability of counterexamples obtained using this technique and emphasizes the trade-off between runtime and memory footprint.