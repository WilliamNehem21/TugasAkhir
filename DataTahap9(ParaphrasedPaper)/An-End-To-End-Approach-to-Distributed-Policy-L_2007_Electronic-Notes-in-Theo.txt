Approaches to enforcing access control and information flow control through language-based security methods ultimately rely on expressive policy languages. However, the selection of an appropriate policy language and its implementation can vary widely for different applications. This paper explores an approach for implementing the policy language at the application level, utilizing trusted cryptographic libraries with secure interfaces to validate the correctness of the policy language implementation.

By leveraging these libraries, implicit enforcement of security policies for exchanged data occurs. These policies, often informally stated in program comments, can be formalized within a policy language, allowing for verification of adherence to the policies using automated or semi-automated techniques.

In the context of language-based security, a common approach is to incorporate policy languages into the type system, enabling typechecking to validate the proper manipulation of data according to the security policies expressed in program types. Additionally, the security policies can be linked to cryptographic libraries utilized for securing network communications through typed APIs for cryptographic operations, such as encryption for secrecy and digital signing for integrity.

As a specific example, this paper considers a policy language implemented as a library within a framework. The chosen policy language has two distinct implementations involving dissimilar sets of cryptographic operations, highlighting the benefit of separating the policy language implementation from the language itself. It is argued that a universal policy language satisfying all application needs, as well as a single universal implementation of a policy language, may not be practical or feasible.

The paper discusses the use of ordinary types for checking the correctness of values, including function and polymorphic types, as well as datatypes for structuring that go beyond traditional ML datatypes by allowing nonregular recursive type descriptions and implicitly existentially quantified type parameters in data constructors.

Additionally, the importance of differentiating between certificate types denoting the validity of a statement in the policy language and value-level representations for policy language statements is emphasized. The paper introduces concepts such as principals, roles, and propositions within the policy language, and explores ways to generate primitive policy language statements while ensuring their integrity.

Moreover, the concept of cascaded delegation, role-based access control, and static compile-time credential checking based on type-checking are discussed, emphasizing the need for cryptographic signing to prevent forgery and tampering of credentials when transmitted across networks.

The paper also presents the concept of combined signing and authentication keys, and discusses different approaches for ensuring the integrity of policy language statements. It acknowledges the reliance on cryptographic libraries and makes a case for exploring alternatives that do not necessitate expensive cryptographic operations and assumptions about key management.

Finally, the paper outlines opportunities for future work, such as generalizing the form of policies and exploring alternative approaches for access control beyond principals, as well as potential integration with existing security protocol verification methods that focus on preventing repeated use of nonces and exploiting weaknesses in protocols.