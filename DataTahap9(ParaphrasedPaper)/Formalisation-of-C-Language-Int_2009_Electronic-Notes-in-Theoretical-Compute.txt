In practical computing, the implementation of programming languages allows programs written in one language to call code written in another language, typically C. However, formal definitions of language interfaces are often omitted, making it difficult to reason about multi-language programs due to the lack of precise specifications. This paper presents an approach to interoperability of programming languages by systematically specifying the C interface of a real, rule-based programming language within a framework based on small-step operational semantics. This framework aims to simplify reasoning about mixed-language code and to specify interfaces for other programming languages implemented in C in a similar manner.

The seamless exchange of information across the global society is pivotal for facilitating collaborations and partnerships among individuals and businesses. As a result, computing systems need to adapt to these environments, leading to the non-trivial task of integrating existing systems to enable interoperability.

This paper formally defines a C interface for a real, rule-based programming language called Russel, and demonstrates the challenges in reasoning about mixed Russel-C code due to potential side effects of C code on the Russel implementation. The proposed framework addresses these challenges by precisely defining how inter-language calls affect the execution of a Russel-C program, allowing for the application of reasoning mechanisms provided by the original semantics of Russel and C.

The paper outlines the essential components of the programming language interoperability framework and presents the foundational elements for a comprehensive operational semantics of C, including its memory model. Additionally, it illustrates the application of the framework to describe a C interface for a real programming language, and provides future research directions before concluding.

Interoperating programs can be executed by different processes on the same machine, different machines, or within a single process, which is relevant to C interfaces where both C and language code are compiled into the same object language. The paper also discusses the three types of information exchange supported by a Foreign Language Interface (FLI) for each execution context.

The paper emphasizes that when two languages A and B are at the same level of abstraction without any relation between them, their implementations are independent, and without interoperability, there is no means for a program in language B to affect the execution of a program written in language A.

Furthermore, the paper introduces the concept of environments, including global and local environments used for global and local variables respectively, and presents an example of a Russel program fragment that demonstrates rule-based processing without the use of any C function calls.

Finally, the paper describes how calls to C functions from Russel programs are made using annotated expressions, indicating how Russel data is passed to the C program. It clarifies that single Russel expressions are passed by value, while annotated expressions using "ref" indicate that the Russel variable is passed by result, with the C programmer responsible for ensuring that the type declarations are adhered to.