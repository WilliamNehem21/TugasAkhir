The interpreter for a syntactic theory that corresponds to its evaluation function naturally involves a loop that decomposes, contracts, and plugs. Typically, the decompose step requires a depth-first search in the abstract syntax tree, resulting in a significant overhead proportional to the program size. Similarly, plugging can also take time linear in the program size, although it always takes at most as long as the following decomposition.

Assuming certain properties of the grammar of the language, we work with abstract syntax, where a program is represented as an abstract-syntax tree created by language grammar productions. Some syntactic categories contain only values and have no evaluation contexts. Therefore, it is unnecessary to distinguish between values and expressions, representing the syntactic category only by the term identifier and never by the associated value identifier.

The unique decomposition property is fundamental to syntactic theories for deterministic languages, and its proof is often technically simple but can be tedious and error-prone due to many small cases. Automated support for proving unique-decomposition properties has been developed to address this challenge.

If a syntactic theory satisfies a unique-decomposition property, its redexes are exactly the non-value terms that can only be trivially decomposed. This follows from the fact that redexes are exactly the non-value terms that can only be trivially decomposed, as established by the unique decomposition property.

In the context of reasoning about programs in continuation-passing style (CPS), a new CPS transformation has been designed by Sabry and Felleisen, which integrates a notion of generalized reduction and builds on the notion of a syntactic theory. Unlike other formalized CPS transformations, this transformation is not defined by structural induction over its input but is instead defined as the transitive closure of decomposing, performing an elementary CPS transformation, and plugging. An implementation of this transformation that operates in linear time over the source program is derived in the rest of the section.

The original specification is indexed with 0 (section 4.1), and explicit decomposition and plugging are made in the next iteration, indexed with 1 (section 4.2). Later, a version that explicitly uses a refocus function is presented, indexed with 2 (section 4.3). This work is based on the technical report "Syntactic Theories in Practice" by Olivier Danvy and Lasse R. Nielsen, which is an extended version of an article to appear in the informal proceedings of the Second International Workshop on Rule-Based Programming (RULE 2001).