We propose a design for program visualization called the observer architecture, which emphasizes modular, model-driven visualization with one-directional coupling, hierarchical delegation, message passing, and archival by visualizers. This architecture is scalable, enabling the resulting visualization to be distributed and modified independently of the underlying model. The observer architecture has been implemented in online programming tutors known as "problets."

In the observer architecture, each component in the program model is treated as an observable object, and is paired with an observer object responsible for tracking and visualizing changes in the state of the observable object. This design is inspired by the model-view-controller pattern used in graphical user interface construction. Message passing is employed for coordination among visualization objects, allowing them to communicate and coordinate their actions as needed.

Our work extends previous principles such as the separation of model and view, and one-directional coupling between the model and view, as proposed in the matrix framework for algorithm visualization. By incorporating hierarchical delegation, message passing for coordination, and archival functions, our architecture advances the capabilities of program visualization. The architecture is model-driven, meaning that the visualization is driven by a model of the domain that can be simulated. This allows for greater capture of the semantics of the domain being modeled and supports custom input data sets, thus reducing instructor oversight in the visualization process.

The proposed observer architecture is applicable to algorithm visualization and program visualization, provided that an appropriate model is available. However, it should be noted that creating the model needed for program visualization, such as a language interpreter, can be a challenging task. Problets are driven by parameterized templates, enabling users to execute and visualize new programs by simply entering their templates. The clear separation between observable and observer objects facilitates the provision of multiple visualizations of a programming construct, allowing users to select among them easily. Additionally, users can customize the visualization of individual program objects independently, such as changing the appearance or animation scheme of a variable.