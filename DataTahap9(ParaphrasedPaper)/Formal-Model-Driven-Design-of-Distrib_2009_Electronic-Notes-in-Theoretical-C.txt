Since our primary objective is to develop distributed algorithms supported by formal models, we begin by creating a formal model of the initial design concept. By "model," we refer to a system with well-defined semantics, in this case, a finite state system. Subsequently, we validate the model against a correctness specification, using verification as the underlying case study in this paper. The purpose of this study was to assess various proof strategies for a specific distributed agreement algorithm, i.e., different methods of proving known theorems. We then expand and enhance the algorithm through iterative development and, ultimately, offer a correctness proof for the extension.

We utilize communicating finite state automata with asynchronous fair message passing as the fundamental model. Fairness ensures that agents cannot indefinitely wait to receive messages already dispatched. All n agents communicate over a medium where messages are neither lost nor altered during transmission.

Initially, the automaton is in an idle state. It initializes by transitioning to phase 1. From there, it may either crash or move to the wait1 state, where it waits for a message or is in a state of suspicion. It iterates through all agents, progresses through a round, and returns to phase 1. After completing all rounds, it transitions to phase 2. At the wait2 state, all agents are iterated through again. Upon completion, it moves to phase 3, where it selects the final value.

The synchronous communication primitives of Uppaal are unsuitable since we require asynchronous communication. Instead, we utilize shared buffers, in which there are no test-and-set race conditions due to the interleaved semantics of Uppaal and agents writing to different locations in shared memory. We introduce the boolean arrays sent1[][] and sent2[]. If sent1[q][r] is true, then agent q has made a broadcast of a message in round r in phase 1. If sent2[q], then agent q has made a broadcast of a message in phase 2. The message is retrieved by an array lookup v = msg1[q][r][i], where v is the integer value at index i of the message tuple sent from agent q in round r. Similarly, v = msg2[q][i] represents a broadcast of a message with value v at index i from agent q.

We employ model checking on a bounded number of agents and fix the number of agents at three, which proves to be adequate for uncovering errors. The verification of properties (1) and (2) succeeds as expected, with a total of 278316 states explored and 5.2 seconds of time used.

We verify this model against the specification with n = 3 agents, resulting in a total of 154592 states explored and a time usage of 4.7 seconds. For n = 4 agents, we have been unable to complete the model check due to insufficient memory, and Uppaal identifies a counterexample to the termination property: assuming ti = 1 and that agents 1, 2, and 3 cooperate such that agents 1 and 2 reach a match and terminate (by transitioning to phase 3) while agent 3 waits at location phase 2. When agent 3 moves to wait2, a deadlock occurs. Agent 3 waits for a message from agent 1. Since it cannot suspect agent 1 (it is the ti), it will block until a message is sent. The issue is that agent 1 has bypassed phase 2, so it will never send the knowledge-vector to agent 3, and agent 3 waits indefinitely.

The termination, agreement, and validity properties are now satisfied for three agents, with a total of 514084 states explored in 12.3 seconds. Even though we cannot check the model for n = 4 due to a lack of memory, we still have an indication that the algorithm might be correct. Therefore, we proceed with a general correctness proof for any fixed number of agents.