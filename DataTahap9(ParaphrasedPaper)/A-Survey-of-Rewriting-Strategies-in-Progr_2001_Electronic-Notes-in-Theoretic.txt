The use of program transformation is widespread, with applications in compiler construction, optimization, program synthesis, refactoring, software renovation, and reverse engineering. Complex program transformations involve a series of modifications to the program, with transformation rules defining the fundamental modifications. A transformation strategy refers to an algorithm for selecting a path in the rewrite relation induced by a set of rules. This paper provides a survey of different aspects related to the definition of strategies in program transformation systems. It discusses various types of program transformation, choices in program representation, the fundamental components of a strategy system, and the design considerations for a strategy language. Additionally, the paper analyzes various styles of strategy systems available in existing languages.

The survey aims to understand the similarities and differences between program transformation systems by examining existing systems based on published literature. While many aspects of program transformation, such as parsing, pretty-printing, and formulating basic transformations, are well understood, this survey focuses on transformation strategies, which determine the order of application of basic transformation steps.

Program transformation entails changing one program into another, and it is employed in various areas of software engineering, including compiler construction, software visualization, documentation generation, and automatic software renovation. This involves scenarios where the source and target languages are either different (translations) or the same.

Reverse engineering aims to extract high-level programs or specifications, or higher-level aspects, from a low-level program. This involves actions such as decompilation, architecture extraction, documentation generation, and software visualization. Rephrasings are transformations that involve changing a program into a different program within the same language, where the source and target languages are the same. Rephrasing sub-scenarios include normalization, optimization, refactoring, and renovation.

Programming languages can be categorized into classes with structural and/or semantic similarities. A general framework for program transformation seeks to define transformations that are reusable across a wide range of languages. For instance, the notions of variables and variable binding are common across all programming languages.

A program representation should be accompanied by an exchange format that facilitates the interchange of programs between transformation components. Example formats include XML for exchanging tree-shaped data and the annotated term format for exchanging directed acyclic graphs while maintaining maximal sharing. 

The implementation level of rules and strategies may be intertwined. Rule application typically preserves the semantics of the program, with a rule recognizing a program fragment to transform and constructing a new program fragment to replace the old one. 

Different languages offer various features to enhance basic pattern matching, such as list matching, associative-commutative matching, higher-order unification, views, and overlays. Depending on the goal of a transformation task, a strategy is utilized to choose a path in the rewrite relation. 

The selection of a representation for programs and the programming paradigm used for implementing transformations determine the characteristics of a program transformation system. Lastly, the paper suggests that an extended survey should explore how strategies are modeled in paradigms other than term rewriting. Additionally, it points out the need for further research in areas such as the fusion of generic traversals, origin tracking for term rewriting, and the inheritance of origin information within systems with strategies.