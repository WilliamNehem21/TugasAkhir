A new specification language has been developed based on bidirectional computational tree logic (CTL) to naturally express typical optimization rules. By incorporating rewriting conditions to accommodate temporary variables and accounting for real-world language features such as exceptions, the system is capable of optimizing Java programs. Previously, it was deemed impractical to implement a compiler optimizer using temporal logic due to excessive computation time. However, our approach has resulted in a Java compiler optimizer that can compile seven SpecJVM98 benchmarks within a compile time ranging from 4 seconds to 4 minutes.

The conventional method for implementing optimizers involves using some form of programming language. However, there has been growing interest in implementing optimizers using CTL, a branching temporal logic, owing to two primary advantages of this approach.

In the context of model checking, it is essential to bind free variables before proceeding. Consequently, the presence of numerous free variables in the conditional expression leads to unrealistic processing times. Our experiments indicate that utilizing the node numbers of the Kripke structure as free variables, as done in prior work, significantly increases optimization time. Hence, it is crucial to formalize optimization using the minimum number of free variables.

Our developed specification language does not rely on the node number of the Kripke structure. Rather than calculating the instruction of a specific number, the model checker determines sets of instructions that satisfy the same condition. This approach facilitates the description of complex rewrite rules that apply to multiple instructions, while also improving efficiency by omitting free variables corresponding to the node number of the Kripke structure.

Traditionally, optimizers employing temporal logic were considered impractical due to extensive processing time requirements. However, by introducing processing for real-world language features, we have achieved several typical optimization phases for a Java language compiler, leading to performance on par with optimizers using traditional algorithms. Through our research, we were able to optimize seven SpecJVM98 benchmarks within a time frame of 4 seconds to 4 minutes, thanks to the aforementioned enhancements.

Instead of modifying an existing model checker, we developed a new model checker due to our belief that it can efficiently manage program features. Additionally, creating our own model checker will allow for easy future extensions to enhance its functionality, for example, by improving the algorithm and data structures to enhance efficiency, such as through the use of bit vectors (or partial evaluation).

Real optimizing compilers necessitate complex optimizations like partial redundancy elimination, for which multiple conditional formulas are required for specification. The system must rewrite a set of instructions satisfying the same conditional formula simultaneously. Writing specifications in CTLBD from scratch considering the meaning and condition of optimization is challenging.

While the use of free variables has been prevalent in prior work, as well as in our own, binding of these free variables leads to exponential computational complexity. An example of time explosion caused by free variables will be illustrated in section 8, where we introduce different formulas for copy propagation, one containing 2 free variables that can be bound at the match stage, and another containing 4 free variables with only 2 of them bindable at the match stage. This demonstrates the need to minimize unnecessary free variables in practical compiler optimizers, a focus of our efforts.

Binding can be omitted if the target is not on the path related to the temporal formula. For instance, when the CTLBD formula exclusively features future temporal operators, the checking of instructions on past paths can be omitted. Similarly, when the temporal operator is AX or EX, instructions far away from the next instruction can also be omitted. In our experiment, applying this technique to dead code elimination (which only includes future temporal operators) resulted in a reduction of processing time by roughly one-third.