We have introduced a rule-based notation with stochastic semantics, where the primary entities are objects with attributes defined at the type level, thereby ensuring that all objects of a type have these attributes. For instance, in the context of a diffusion model, a type x(n: int) could represent the position of a molecule in an array, and objects are instantiations of this type with specific attribute values (e.g., x(n= 1) for a molecule in the first cell). Rules govern the addition or removal of objects at the type level, thus providing a more concise representation of the model, as each rule encompasses multiple specific reactions. By considering species attributes as part of a type (e.g., cell(pos: int, x: int)), new cell objects also spawn new species, effectively addressing the issue of species instantiation. Our rule-based language resembles a colored Petri net and offers enhanced readability for larger models. Its integration with Haskell confers additional expressive power, as elaborated in Section 6.

In our framework, objects or agents serve as the primary entities, each being an instantiation of a type that delineates the general structure for all objects of that type. Agent types encompass a name and a set of named fields for their attributes, and the state of the system is represented as a multiset of objects of the defined types encased in{|...|} brackets. Rules entail a left-hand side, which matches the state of the system and can be substituted by the right-hand side. The left-hand side selects objects based on their type, binds field values to variables, and the variables are then employed in expressions for the right-hand side, rate, and condition. These rules are designed to be independent of the specific sets of expressions and variables, and in the Haskell embedding, they are instantiated as Haskell variables and expressions.

The language within our system allows for pragmatic querying and manipulation of the model components, thereby enabling the specification of rules, rates, and conditions in a manner that closely resembles the abstract syntax but with minor syntactic differences. Being embedded within a programming language affords the flexibility of utilizing any valid Haskell expressions in the contexts in which expressions are expected. Furthermore, our system accommodates various query constructs, with the potential for specialization to common use-cases through default filter and accumulation functions.

Our system exhibits parallels with colored Petri nets in terms of the representation of object types, objects, and rules. However, one distinction lies in the inclusion of union types in CPNs rather than just product types, as in our language. Although Simile features a graphical notation for modeling, it may present challenges for larger models, unlike our rule-based textual representation. Additionally, we have extended the representation of reactions by employing rich types (records with named typed fields), resulting in a more compact representation compared to traditional reaction settings. Furthermore, our system facilitates the writing of complex systems with a dynamic number of species and offers possibilities for the creation of new species by storing variables as object attributes.

Regarding simulation, our implementation aligns with the steps presented in Section 3. However, there is potential for enhancement in the generation of reactions, as currently, all active reactions are generated at every step, despite only a subset of them changing between steps. Optimizing the performance of calculating changes in the reactions set after a state alteration may yield efficiency gains, akin to techniques used in Kappa where matches are generated once at the simulation's outset and subsequently updated based on state changes.

Finally, our system acknowledges the variability of environments in which rules operate, a crucial consideration in fields such as plant biology, where plants exhibit adaptability to environmental inputs. The incorporation of a changing environment necessitates the integration of time within our language, a potent extension with practical implications.