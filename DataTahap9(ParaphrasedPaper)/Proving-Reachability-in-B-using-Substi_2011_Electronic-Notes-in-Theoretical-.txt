The while statement in (11) is not a valid while statement in the B notation because its loop body does not use implementation substitutions. However, the semantics and rules of the while statement are applicable to any substitution, allowing us to use them to generate proof obligations. By utilizing law 5.5, we can establish the validity of (11) provided that we discharge certain proof obligations.

To address this, we have incorporated the proof obligations derived from (5), (7), (10), and (11) as assertions in the library specification of appendix A in the assertions clause. These assertions give rise to 14 proof obligations, of which 10 are automatically proven and 4 are easily proven using the interactive prover.

In our case study, generating proof obligations results in a total of 28, with 14 remaining to be proved interactively. These have proven to be challenging. To aid in the proof of the while loop, additional variables have been introduced, resulting in a total of 88 proof obligations, 30 of which require interactive proof. This contrasts with our approach based on assertions and substitution refinement, which yields 14 proof obligations, only 4 of which necessitate interactive proof. Through stepwise substitution refinement, the specifier can work with abstract variables directly and manage the size of proof obligations by appropriately breaking down the proof into several smaller steps. Furthermore, the application of refinement laws helps us circumvent some of the proof obligations that the machine refinement approach must generate. This bears some resemblance to the bart tool, which proposes automatic refinement laws.