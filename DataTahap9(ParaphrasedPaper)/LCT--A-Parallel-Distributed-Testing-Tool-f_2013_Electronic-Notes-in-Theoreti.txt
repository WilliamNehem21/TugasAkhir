This paper presents two main contributions: (i) a detailed description of the distributed architecture of the system and the necessary modifications to the DPOR and sleep set algorithms to enable their use in this architecture, and (ii) a new experimental evaluation of the distributed nature of the tool on multithreaded programs, with a focus on exploring different schedules and their impact on test execution generation. The paper is structured as follows: Section 2 provides a brief overview of concolic testing and dynamic partial order reduction algorithms, Section 3 outlines the LCT and the modifications made to the algorithms used, Section 4 covers related work, and Section 5 presents an experimental evaluation of the distributed architecture in the context of multithreaded programs.

In concolic testing, a path constraint is formed by combining symbolic constraints that correspond to each branch decision made during an execution. To guide a test execution along an unexplored path, a prefix of a previously explored path constraint is selected, and the final symbolic constraint in this prefix is negated. SMT solvers are typically used to solve path constraints and obtain concrete input values. The symbolic constraints collectively form a symbolic execution tree, and each test explores a path within this tree. Since different subtrees of the symbolic execution tree can be explored independently, parallelizing the testing process becomes feasible.

For multithreaded programs, the schedule also influences the execution path. The nondeterminism resulting from thread interleavings can be addressed in concolic testing by assuming control of the scheduler and treating the schedule as an input to the system. To reduce the number of thread interleavings needing exploration, concolic testing can be combined with dynamic partial order reduction algorithms. These algorithms identify transitions that are in a race in the current execution and introduce backtracking points in the execution tree to ensure that different interleavings of these transitions are eventually explored.

The communication between the server and clients is achieved using TCP sockets, enabling the distribution of testing across multiple workstations. Constraints generated during test executions are expressed in bitvector theory, and the Boolector constraint solver is utilized. To minimize the exploration of unnecessary interleavings when testing multithreaded programs, the tool incorporates dynamic partial-order reduction and sleep set algorithms.

To facilitate backtracking, the system employs re-execution of the program, as it aligns well with concolic testing. This is because path constraints in concolic testing encode sets of concrete states, and even when a new path constraint shares a prefix with an old one, the inputs derived from the new constraint may lead the program to previously unvisited concrete states.

In addition to DPOR, sleep sets are used to further reduce the operations that need to be explored from backtracking states. The algorithm observes that after an operation t is explored from a state s, it is unnecessary to explore t again once other operations independent of t have been explored from s. Each reached state is associated with a sleep set, which comprises operations that are not executed from that state.

To compute sleep sets, when a state sj is explored from s, the candidate sleep set for sj is formed by combining the sleep set of s with the set of operations already explored from s. This candidate sleep set is then filtered to include only independent operations with the operation that led to sj. The sleep set of the initial state is initially empty.

The experimental results demonstrate that the distributed architecture performs well, especially with up to 20 clients. The time required to execute a single test, involving restarting the JVM to initialize global state, solving path constraints, and running the program both concretely and symbolically, is significantly longer than the operations the server needs to perform in a synchronized manner. Moreover, the majority of the time, there are a sufficiently large number of open paths in the symbolic execution tree, allowing each client to have meaningful work to accomplish.