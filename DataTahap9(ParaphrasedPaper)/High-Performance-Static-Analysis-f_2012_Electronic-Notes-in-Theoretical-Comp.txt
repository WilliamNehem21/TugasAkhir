The field of static source code analysis for detecting software bugs has evolved significantly from its origins as a compiler technology, incorporating more advanced algorithmic techniques such as model checking and constraint solving. However, concerns about performance have arisen with the adoption of these sophisticated methods. This paper presents an empirical study of the industrial strength source code analysis tool Goanna, which utilizes a model checking core for static analysis of C/C++ code. The study focuses on the performance of the tool in analyzing millions of lines of code and presents results from its participation in the NIST/DHS SAMATE program, demonstrating that formal verification techniques can be successfully used in practical industry applications at scale.

Efficient software development cycles are essential for competitiveness, and automation and tool support are crucial in achieving fast, cost-effective, and high-quality software delivery. Testing and debugging, which consume a significant portion of development costs, are areas with high potential for automation and cost saving.

New algorithmic techniques such as model checking, SAT solving, and abstraction refinement have been developed for software analysis, but they are often perceived as slow and not scalable to large code bases. This paper addresses these concerns by presenting qualitative and quantitative results from the SAMATE program, showcasing the scalability and accuracy of the model checking approach used in Goanna, as well as real-life software bugs found in large open-source code bases.

The paper describes the core technology of Goanna, including model checking, abstract interpretation, path-sensitive and inter-procedural analysis, and data flow analysis, and discusses their implementation and usage in detecting potential code issues, security vulnerabilities, and memory leaks. The study also presents the scalability of the model checking approach in terms of lines of code and number of checks performed.

The findings indicate that formal verification techniques, particularly model checking, can effectively detect safety and security flaws in large C/C++ code bases. Future work involves further integrating formal verification techniques such as SMT solving and automated theorem proving for more precise analysis without compromising performance, as well as addressing real concurrency issues resulting from multi-threaded code.