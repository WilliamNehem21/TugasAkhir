An Erlang program comprises a collection of modules, each of which contains a list of function declarations. In our example, the system is defined within a single module, which is initialized using the start function. According to the export declaration, the start function is the only accessible function from outside the module. By invoking the corresponding startup functions, three new processes are generated: one locker and two clients. The process creation is executed using the spawn builtin function, which takes as arguments the module identifier, the name of the function to be invoked in the new process, and its associated arguments.

A client process demonstrates complementary behavior by requesting access to a resource. The self builtin function returns the process identifier (pid) of the client process, which is then utilized by the locker process as a handle to the client. Upon receiving the "ok" message, the client process accesses the resource and then releases it.

The rules of deduction specify how the aforementioned transition rules are to be applied, enabling reasoning about concurrent systems whose states are represented by terms and evolve via transitions. The states are structured according to their signature, and the transition rules outline local transitions within this structure, while the deduction rules facilitate reasoning about the overall behavior of the concurrent system based on the local transformations.

Furthermore, each process is assigned a transition label and a current evaluation environment. The former denotes the type of the transition that led to the current state, while the latter stores the bindings between Erlang variables and their assigned values. It is modified by an assignment or pattern matching operation. Syntactic restrictions imposed on the code ensure that every occurrence of a variable name lies within the scope of a binding operation.

Live and dead processes can be combined using the associative and commutative parallel composition operator to create a concurrent process system. However, this only makes sense if each process is uniquely identified by its pid. Hence, a process system is considered well-formed if all pids occurring in the process tuples are distinct, and it is assumed that every process system is well-formed hereafter.

One of the fundamental concepts of Erlang, asynchronous message sending, is handled by the following rule. As will be demonstrated, the message is added to the mailbox of the target process. It is worth noting that a process can also send a message to itself.

Process generation is formalized as follows: the spawn builtin function consists of two argumentsâ€”a function atom and a list of arguments. The new process calls this function with the specified arguments, beginning with an empty mailbox and environment.