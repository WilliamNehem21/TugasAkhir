One notable characteristic of modern functional logic languages such as Toy or Curry is their ability to program non-strict and non-deterministic functions with call-time choice semantics. For almost a decade, the CRWL framework has been the sole formal setting that covers these semantic aspects. However, a new proposal has emerged, focusing more on operational aspects. In this paper, we investigate the relationship between both approaches, which is not immediately evident due to the substantial disparity between their descriptions, even at the syntactical level.

The remainder of the paper is structured as follows: Sections 2 and 3 introduce the key elements of CRWL and FLC required for their comparison. Section 4 outlines certain assumptions made in our work and provides an overview of the structure of our findings. Section 5 establishes the relationship between CRWL and CRWLF LC, a new intermediate formal description introduced as a bridge between CRWL and FLC. Section 6 constitutes the main part of the work, examining the connection between CRWLF LC and FLC. Finally, Section 7 presents some conclusions.

The subsequent algorithm carries out the procedure. It iterates through each function f defined in the program and operates on a set of program rules (initially Pf, the complete set of rules for f) and a linear call pattern f(t1, ..., tn) (initially the pattern f(x1, ..., xn)), which is consistent with the rules, i.e., the call pattern subsumes the left-hand side of all the rules.

As highlighted in Section 4, a major distinction of FLC compared to CRWL is that the former only offers head normal forms for the expressions to reduce, while CRWL allows obtaining any approximation to the denotation of such expressions. However, FLC can be made to provide a normal form for an expression by introducing an auxiliary function in the program. This is best illustrated with an example. Revisiting the program from Example 2 and the expression heads(repeat(coin)), in FLC, we can expand the program with the following predicate (i.e., true-valued function) to check if this expression (the corresponding normalized one) can be reduced to the normal form (0, 0).

We did not expect the proofs to be straightforward. Despite that, we are somewhat surprised by the significant challenges encountered, even with the imposed restrictions on expressions and programs. This suggests the need to explore new perspectives, not only at the level of proofs but also in the search for new alternative semantic descriptions of functional logic programs.

Proof. [for Lemma 8.4] (Sketch) Using Lemma 8.3, we know that there must be a binding for x, and all that remains is to ensure that this binding never changes. The only way a binding for a variable changes is through the rule varexp, but this rule cannot be applied if e is constructor-rooted, which is the case because e = c(y). Therefore, the binding for x remains unchanged.