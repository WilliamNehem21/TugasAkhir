Implicit computational complexity (ICC) focuses on inherent properties of complexity classes that do not directly depend on machine-based resources like computation time or space. In ICC, complexity measures defined in terms of machine models' resources, such as time and space, are matched with declarative paradigms restricted by functionality, linearity, repetitions, flow control, or similar parameters. The potential applications and advantages of this area of research are well documented, and there is particular interest in characterizing computational complexity classes using restricted yet natural declarative programming languages, as these languages automatically guarantee complexity bounds.

When considering resources, critical distinctions arise between Turing transducers over streams and Turing transducers for functionals (i.e., with functions as oracles), particularly with respect to their work-tapes. Although Turing transducers over streams can simulate Turing transducers for functionals if their work-tapes are unrestricted, differences become apparent when resources and real-time sequentiality are taken into account, contrasting stream transducers with the random access underlying oracle Turing machines.

It is justifiable to contemplate a variant of Turing transducers where the output tape is two-way, enabling the cursor to revisit an earlier output symbol. However, for logspace transducers, this extension does not induce differences. By utilizing additional work-tapes to track the intended positions of cursors, the output symbols at such positions can be recalculated. The space used for each calculation is immediately released at its conclusion, ensuring that the entire process remains within log-space.

The proof utilizes proposition 2.3 to demonstrate that 2-way cursors on a finite counter can be simulated by cursors that can be reset and that 2-way cursors on a global counter can be simulated by cursors that can be jumped to the position of other cursors. This involves carrying out step c and cj in tandem until cj reaches the end of the tape, enabling both c and cj to scan the entire finite work-tape once, with c lagging by one step, ending at a position preceding its initial one.

In proposition 4.5, it is shown that every 2-tier ramified lazy-corecursive function between finite streams is logspace in the usual sense, i.e., in the size of the input. However, the function e, which maps (1n, 1n) to a stream of length 2n, is not ramified lazy-corecursive, let alone ramified strict-corecursive.

A pertinent inquiry involves establishing a relationship between output-based complexity for finite streams and input-based complexity for functions over words. When the input itself is finite, positing an additional input 1n becomes nonsensical; thus, the extra input 1n is dispensed with in this context, and the finite input is used instead.

Lastly, there is discussion of while-programs over lists without recursion or the use of the cons function. Kristiansen provides a characterization based on a simple recursion scheme that does not employ cons, while Bonfante utilizes tail recursion, which bears structural similarity to corecursion, and employs tiering to limit branching.