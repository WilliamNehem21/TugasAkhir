The Elan language was among the early rule-based languages to establish a clear distinction between the concepts of rule and control, also known as strategy. Building on this foundation, the objective of this study was to incorporate these constructs into a widely used language such as Java. In this article, we outline the essential components that were taken into account during the development of the Tom language, which extends Java by integrating the concepts of rules and strategies. Furthermore, we elucidate how these components can be implemented and seamlessly integrated within a Java environment.

The concept of a rewrite rule serves as an abstraction that can be employed to model various processes. It has been extensively utilized for modeling, analyzing, and studying different aspects of complex systems, ranging from algorithms to operational software. It can be utilized to describe the behavior of a transition system, and also provides a theoretical framework for certifying and proving properties such as termination or confluence.

Programming with rewrite rules may seem straightforward initially: a complex transformation can be broken down into elementary transformations, encoded using a rewrite rule, and then the rule engine is relied upon to activate a rule whenever feasible. Typically, the objective is to produce a deterministic computation result. In other words, the result should be reproducible, and the set of rules should be both terminating and confluent. However, natural systems are rarely inherently confluent. One potential solution is to employ the Knuth-Bendix completion, but this approach is not feasible for large programs.

One approach to addressing this issue is to assign a priority to each rule, and to employ an execution mechanism that incorporates a fixed order of reduction, such as innermost or outermost (also known as call by value or call by name in functional programming languages). Another solution involves segregating the control from the rules; instead of encoding the control within the rules themselves, it is described in a separate expression or language, known as strategies. Designing such a strategy language is challenging, and several attempts and proposals have been made in this regard.

Maude adopted this approach and introduced the notion of the meta-level. In this framework, a rewrite rule is assigned a name, considered a constant, and can be explicitly applied using the meta-apply operator. The application of a set of rules can be controlled by another program, expressed through rewriting and by using the meta-apply operation. This new program can also be controlled by another program from the meta-meta-level. This reflexive hierarchy is sophisticated and expressive, but somewhat challenging to utilize.

Over the past decade, substantial experience has been accumulated in both implementing and using rule-based languages. This paper attempts to identify the essential constructs and features that need to be taken into consideration when designing a new rule- and strategy-based language. Additionally, the paper explains how these features can be smoothly integrated and effectively implemented in an object-oriented programming language such as Java.

The ability to assign the same label to multiple rules to define a rewrite system is a notable feature. The application of such a system needs to be explicitly specified by the user. Given a term, the application of a labeled rule performs a single step of reduction at the root position if the term is matched by a left-hand side. Otherwise, the application fails.

Another crucial feature inherited from Elan is the ability to automatically maintain terms in a normal form with respect to a rewrite system. This is achieved through the use of unlabeled rules, which are applied until an irreducible term is obtained. Of course, the considered rewrite system needs to be both confluent and terminating.

The maintenance of a data structure in canonical form is a crucial feature that enhances the quality of software. This eliminates the need for the programmer to manually maintain this by calling normalization functions. Moreover, it simplifies the writing of elementary transformations since only canonical forms need to be considered.

In the case at hand, the situation is somewhat unique as there is an underlying Turing-complete language, namely Java, in addition to the concept of rules. One attractive possibility for controlling the application of rules is to directly utilize Java, which inherently offers composition (;), repetition (while), and various other control statements. However, as Java is increasingly employed, it becomes more challenging to reason about programs and perform proofs. The challenge lies in demonstrating the termination of a rewrite system under a given strategy when this strategy is expressed in Java. Therefore, the problem at hand is to devise a strategy language that is both expressive and easy to use.

As previously mentioned, the expressiveness of several existing strategy languages has been studied and experimented with. The strategy language proposed by Stratego possesses several intriguing properties. It is atomic, composed of fewer than 10 elementary combinators, and expressive, allowing for the definition of various traversal strategies. Although initially not designed to support non-deterministic searches, it will be shown that this limitation can be elegantly removed using contextual information.

A specific term data structure is addressed by incorporating it as a parameter of the Tom compiler, utilizing a mapping mechanism. While this approach offers the advantage of making the %match construct usable on any type of data structure, it places the onus on the user to provide an implementation.

The notion of a labeled rule cannot be implemented using the same approach, as a labeled rule corresponds to an elementary strategy that needs to be manipulated as an object. It cannot be implemented as a function, as it is not a first-order object in Java. In this context, an elementary strategy is implemented as a class that includes an apply function. The implementation of such a class is automatically generated when using the %strategy keyword.

This results in a language where formally defining algorithms using terms, rules, and strategies is easy and elegant, without sacrificing the flexibility and versatility of the underlying host language. It enables the seamless integration of formal aspects into a conventional programming language, facilitating the gradual assimilation of formal methods into existing projects. In practice, this integration occurs naturally, as the use of algebraic constructs, such as those provided by Tom, streamlines the code, making it more concise, readable, and robust.