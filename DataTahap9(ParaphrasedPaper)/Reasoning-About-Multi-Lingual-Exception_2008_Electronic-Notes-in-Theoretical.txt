The final two lines of the Java class declare that the methods f and h have the specified signatures and are native, meaning they are not written in Java but are implemented as C or C++ procedures in a shared library.

To utilize the Java Native Interface (JNI) for integrating these methods, the next step is to execute 'javah,' a JDK tool that supports JNI usage. When given a class file as input, 'javah' generates a file called 'a.hh' that contains prototype declarations for the native methods of the Java class 'a.' These prototypes specify the Java_a_f and Java_a_h procedures, respectively, which are the expected names for the implementations of the f and h native methods of class 'a.'

The paper introduces the concept of reasoning about multiple programming language systems (PLS). It differentiates between programming languages, such as Java, and PLSs, such as the Java Virtual Machine (JVM), that can potentially support multiple programming languages. The key contribution of the proposed language, Ripls, is its ability to reason about multiple PLSs. The paper defines the language with an abstract syntax, typing rules, an abstract machine, and a set of transition rules (operational semantics). It has been proven, with mechanically-checked proofs, to be type-safe and to enable program progress. The type system and interesting aspects of the language's definition are discussed, and its usage is also outlined.

Ripls uses effects and mechanism annotations to enable reasoning about distinct PLSs. In this paper, the focus is on exception effects, which are created when an expression raises an exception and are retracted by exception handlers. The authors note that this is an unusual use of effects, and they use mechanism annotations to address whether a particular expression is capable of raising an exception. The paper discusses abstract mechanisms as tags for run-time availability of actual mechanisms, and distinguishes between control mechanisms and primitive mechanisms. The naming convention of the functions is also highlighted, indicating that the naming style chosen by the JNI leads to the need for writing glue code.

The paper discusses issues encountered when combining Java and C++ code and points out that while the code may compile and run, it can misbehave. When this code is translated into Ripls and subjected to type-checking, the type-checking fails, revealing a problem that is not detected by conventional tools such as Java and C++ compilers. The authors demonstrate the importance of translating components into a common formal language and analyzing the resultant program to expose problems not uncovered by traditional tools.

The paper emphasizes the value of formal foundations in informing practical methods or automated tools for developing correct systems comprising interoperating components written in different languages. The authors have initiated the development of such methods and tools, demonstrating initial prototypes that automate the generation of correctly interoperating Java and C++ classes, even when using exceptions. These early results reinforce the belief in the significance of solid formal foundations for the long-term goal of effortless and error-free multi-lingual programming.

Given the promising results reported, the authors plan to pursue further development of both the formal foundations and pragmatic tools. Future extensions to Ripls will focus on other aspects of multi-lingual object-oriented programming, with the goal of providing a complete treatment of interoperation in the C++ and Java environment. These extensions should include method dispatching (single-dispatching) and parametric polymorphism, and potentially support differences in memory models, such as garbage collection versus explicit memory management.