Software debugging is a time-consuming aspect of software development, often requiring developers to meticulously examine execution traces to identify errors. This paper discusses recent advancements that have transformed debugging into a more systematic and scientific activity, with a focus on the relationship between debugging and formal methods such as model checking. Additionally, the paper emphasizes the need for debugging methods that can accommodate evolving software, and demonstrates the potential of employing symbolic execution and satisfiability modulo theories (SMT) solvers to automate debugging processes for changing programs.

The article begins by reviewing the current state of debugging in Section 2 and explores available commercial debugging tools. In Section 3, it examines recent advances in debugging methods, particularly those that involve localizing bugs through trace comparison based dynamic approaches.

The paper highlights the limitations of traditional command line debugging tools, emphasizing the manual effort required to step through execution, set breakpoints, and observe variable values. It also stresses the necessity of systematic methods for selecting successful runs that correspond to failed execution runs, particularly in the context of constructing bug reports.

The differences between model checking and debugging are discussed to illustrate the unique nature of each process. Furthermore, the paper presents an approach for debugging evolving programs, showcasing its potential to handle different program versions and protocol implementations. This approach is based on symbolic execution and SMT formula solving, leveraging recent advancements in the scalability of SMT solvers and emphasizing the formal foundations of debugging methods.

The paper concludes by advocating for the development of debugging methods with formal foundations that can effectively address the challenges posed by large-scale industrial software. It suggests that symbolic dynamic analysis and SMT formula solving may be key components of such debugging methods.