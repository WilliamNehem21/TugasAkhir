The sparc tso weak memory model is axiomatically defined, and its non-compositional formulation makes modular reasoning about programs challenging. Our denotational approach employs pomsets to present a compositional semantics that precisely captures the behaviors allowed by sparc tso, enabling the study of sparc tso and supporting modular analysis of program behavior.

A system implementing the tso weak memory model consists of processors, each with a write buffer. When a processor performs a write, it places it in its buffer, which behaves like a queue. Writes migrate out of the buffers one at a time, and shared memory applies them according to a global total order. If a processor attempts to read a location, it first checks its buffer for a write to that location. If found, it uses the value of the most recent write; otherwise, it looks to shared memory for a value. Due to buffering, it is possible for writes and reads to be observed out of order relative to program order.

Considering program orders that have no tso-consistent orders, we focus on program orders for well-defined programs in a given simple imperative language. The denotational semantics comprises two components: the first associates each program with a set of tso pomsets, serving as the abstract meaning or denotation of the program, and the second associates each pomset with a set of executions, describing its input-output behaviors.

Flushing is introduced as the ability for a thread to flush multiple writes at any point during its execution. The pomsets associated with flushes for a buffer are its prefixes, and the resulting buffers are the remainders of the original buffer. We use split(l) to denote these prefix-suffix pairs.

The denotational account of tso is shown to be sound and complete in relation to the axiomatic account. Soundness ensures that we capture only behaviors permitted by the axiomatic account, while completeness ensures that we capture all of those behaviors. Since all tso-consistent orders are contained within tso-consistent total orders and can be derived by weakening these, demonstrating the capture of all tso-consistent total orders suffices. Total orders and lists are identified.

In contrast to other semantics for weak memory models, which mostly use execution graphs and operational semantics, our denotational framework offers a modular and compositional basis for program analysis. It provides an alternative to non-modular approaches that describe the entire program's executional behavior. Additionally, boudol and petri proposed an operational semantics framework using buffered states, and jagadeesan et al. adapted a fully abstract, trace-based semantics by brookes to provide a fully abstract denotational semantics for tso.