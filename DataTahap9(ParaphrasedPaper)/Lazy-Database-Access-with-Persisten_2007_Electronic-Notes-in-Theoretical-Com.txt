Developers require methods to retain application-specific data that persists across multiple program executions. Typically, they need to handle storage-specific code to access files or relational databases in order to accomplish this task. Functional logic programming provides a natural framework for transparent persistent storage through the use of persistent predicates, which are predicates with externally stored facts.

This paper builds upon prior research on persistent predicates for curry by introducing lazy database access. With this approach, the results of a database query are only retrieved as needed by the application program. Additionally, we present a type-oriented method to convert between database and curry values, which is utilized to implement lazy access to persistent predicates based on a low-level lazy database interface.

Programming languages necessitate mechanisms for storing data that persists between program executions. Both internal and external data must be managed; for example, web applications frequently retrieve data stored on a database server and present it to users in a structured format.

The paper is structured as follows: Section 1.1 explains the rationale behind persistent predicates by examining related work on database access in declarative programming languages. Section 2 outlines the interface of our database library, while Section 3 discusses the low-level implementation of lazy database access. In Section 4, we outline a type-oriented approach to converting between database and curry values, which is crucial for implementing lazy access to persistent predicates. Finally, Section 5 provides concluding remarks.

The issues of database access being confined to the IO monad and the provision of a transaction concept are effectively resolved. Eliminating side effects is particularly critical in the context of functional logic programming languages, which rely on sophisticated evaluation strategies. Our library, an extension of the implementation presented in a prior work, enhances the implementation with lazy database access and streamlines its interface. Additionally, a combinator library for Haskell is provided to construct database queries using relational algebra.

Furthermore, we discuss how an extension of Curry, akin to concurrent Haskell, which supports concurrent IO actions, could exploit this feature for synchronization. We also address functional limitations of retract and assert, where representing unknown parts as null-values initially seems appropriate, but suspension or failure may be more practical for retract and assert. We also provide insights into using encapsulated search for dynamic predicates and discuss the limitations and applications of certain functions.

In addition, we present a function for combining persistent predicates, along with information about performing atomic transactions. We have simplified the library's interface by discarding a specific function, transactiondb, in favor of using the function transaction for transactions, regardless of the database name.

The paper also delves into retrieving result sets of queries incrementally via an API from a Curry program, as well as the potential for communication between Curry and Java programs using ports for accessing various database systems. We emphasize the importance of ensuring type-correct message exchange in port communication, and provide examples of functions used internally in the implementation of persistent predicates.

Moreover, we explore the implementation of operations to access persistent predicates and the conversion between curry values and values of type dbvalue, using type-oriented database specifications. Finally, we touch upon the applicability of type-oriented combinators in other applications and outline potential future explorations in this area.