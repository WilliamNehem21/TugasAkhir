This study presents the results of an experiment that tested the Java programming language using Featherweight Java (FJ). The researchers used the syntax and binding structure of FJ to generate a set of non-isomorphic test programs and developed implementations of FJ type checkers to act as oracles for these tests. The goal was to ensure that the mainstream implementation of Java complies with the expectations set by FJ. The evaluation of the test programs was performed using code coverage techniques to assess the extent to which the Sun OpenJDK javac could be tested by FJ.

Developing compilers and type checkers is a challenging task due to the complexity of the code and the need for efficiency. Furthermore, the languages that compilers process are becoming increasingly complex, with intricate type rules and numerous possible edge cases. Complications also arise from the use of multiple intermediate representations within the compiler, each with its own invariants and properties.

Creating tests for a new language compiler is time-consuming. Test cases must be generated, and an oracle must be consulted to determine whether a given test should pass or fail. Human oracles may introduce errors, and there is the limitation of human imagination in generating test cases, potentially leading to the oversight of obscure corner cases. Additionally, if the test cases are generated by the compiler writer, there is a risk of bias or influence based on assumptions about the implementation or interpretation of the language.

Another challenge is the maintenance and updating of tests as the language evolves. Changes in language semantics during development can affect the validity of old tests, requiring a human oracle to review and validate all affected tests, while also generating new tests for interactions with existing and new language features.

The study explores the potential use of the formal presentation of a language theory as input to generate test programs and as an oracle for these tests. The effectiveness of these test programs in practice is evaluated.

The paper proceeds to provide a summary of Featherweight Java, highlighting features and omissions of interest. It describes the generation of test programs based on the grammar of FJ, as well as the utilization of knowledge of name binding to prune some isomorphic programs from the generated search space. The use of FJ type checkers as oracles is also discussed, including the presence of FJ programs rejected by FJ but accepted by javac. The setup used to test the OpenJDK Java compiler and the experimental results are presented, followed by a discussion of the implications of the work and its context before concluding and offering future directions.

The study identifies features of Java that are not included in the FJ abstraction and explains how some missing features allow FJ programs that fail to type check in FJ to be accepted in full Java. It also highlights that all FJ programs that can be typed are valid Java programs.

The paper details the process of generating test programs using the FJ grammar and the constraints imposed to delimit the exploration of the search space. Due to global binding of class, method, and field names, the algorithm used for generation proceeds in two phases. The authors propose potential improvements to the generation scheme by considering the relative order of declarations.

To validate the oracles, the generated test programs were used to compare outputs with another FJ implementation. Additionally, the implementation of javac was expected to be correct, so the oracles aligned with it in most cases, although some discrepancies were observed.

The study utilized a server program to aid in collecting code coverage results for the test suite. Notable trends were identified in the results, such as the increase in code coverage when moving from one test suite to another. The authors discuss the implications of these trends and the impact on code coverage for both FJ and javac.

The study also examined the accuracy of the "small scope hypothesis" in the context of Java libraries by using a tool to generate non-isomorphic Java programs of bounded size and evaluating how much of the code base of various library data structures was covered. While similar high levels of coverage were not achieved for the Java compiler, the study demonstrated that numerous small, simple tests can cover a substantial portion of the code base.