Unfortunately, when dynamic loading is present, the static resolution of objects in even simple applications becomes infeasible since the necessary information for object resolution is often only available at execution time when the contents of external methods are accessible. A simple escape analysis algorithm for Java Grande benchmark programs found that most candidates for object resolution cannot be optimized at compile time due to unknown constructors of created objects from different classes or the access to fields of arrays where the index is not known. Delaying the analysis until runtime means that the CPU cycles spent performing the escape analysis are not dedicated to executing the program. Thus, it is advantageous to minimize the runtime cost of the escape analysis, which can be achieved by performing a partial escape analysis at compile-time and attaching the results as annotations to the individual program modules.

Null-checking, index-checking, and type-cast operations can be generalized to include all type-cast operations. An xupcast operation involves a dynamic check and will cause an exception if it fails. If successful, it will copy the value being cast to the next available free register on the plane of the target type. The downcast operation never fails and will not result in any actual target code.

In the checkintersect parameter, p1 is assigned the type sbnd as the compiler can statically verify that the reference is safely bounded. On the other hand, the reference to the object produced by the new operator will be assigned type mbnd as it will be passed as an argument to the method intersects. In method intersects, the parameter is assigned type mbnd as it will be given as an argument to method incdefborder, but the parameter definition in method incdefborder is assigned an sbnd type since the reference variable created from p1 is safely bounded to the method.

The method checkintersect will be called during program execution, and the JIT compiler has not yet compiled this method. The classloader will first load class framecheck and conduct a preliminary analysis of method checkintersect to determine if the object referenced by variable lower could be a candidate for object resolution, as lower is of type mbnd. If an object resolution on this object can be performed, the classloader will then load class frect and verify whether the parameter of intersects escapes the method. Since the parameter of intersects is not defined as an sbnd type, class frameborders has to be loaded, and the analysis will proceed with the method incdefborder. The sbnd parameter declaration of method incdefborder indicates that the parameter does not escape its method. As a result, the analyzer concludes that the parameter definition of method intersects can also be safely bound and transformed into an sbnd type. This means that an object reference passed to intersects cannot escape the method, and hence an object resolution on the object accessible via variable lower can be performed.

Early investigations in escape analysis were conducted by Park and Goldberg, who developed an escape analysis for functional languages based on reference lifetime and operating on lists. Steensgaard has developed an interprocedural flow-insensitive points-to analysis with near-linear time-complexity. Whaley combines points-to and escape analysis into a points-to-escape graph and uses this data structure to eliminate superfluous synchronization of threadbound objects and to stack-allocate strongly-bounded objects. Threads are also addressed by Salcianu, who describes a technique for obtaining precise points-to and escape information for objects accessed by multiple threads. Vivien et al. provide an algorithm for incremental pointer and alias analysis.

While code annotation for program representations has not been as extensively researched as escape analysis, various annotations have been proposed recently to enhance the performance of JIT compilers using Java bytecode and other intermediate representations. Krintz et al. annotate bytecode to improve the performance of programs executed by JVMs. Franz et al. annotate program syntax trees with escape information and encode them for safe transportation, ensuring the safety of their annotations. Hannan uses a functional approach for the annotation of escape information types. However, he excludes dynamic class loading and does not provide an algorithm for the computation of types.