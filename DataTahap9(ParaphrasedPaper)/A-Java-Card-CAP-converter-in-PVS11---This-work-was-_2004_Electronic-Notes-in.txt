The paper is organized as follows. Firstly, we provide an intuitive explanation of why tokenizing Java Card class files is necessary, highlighting the differences in method resolution between Java Card class files and Java Card CAP files (section 2). Next, we describe the PVS formalization of the class file and the CAP format on which the CAP converter operates (section 3). Section 4 presents the development and proofs of the tokenization part of the converter. Following this, section 5 discusses componentization, focusing on the specification and implementation of constant pool merging within the CAP format.

In this section, we present the PVS specification of the class file format and CAP format, each of which is constructed as a PVS abstract data type, defined by its set of constructors, associated recognizer predicates, and accessors. These PVS models are strongly idealized versions of Java Card class and CAP files.

We define a class hierarchy as a forest, which can be empty or a nodehier(c, s, b) where c is a class, s is the forest of its sons, and b is the forest of its brothers. For example, a class c1 having two children c2 and c3 will be represented by a term nodehier(c1, nodehier(c2, empty, nodehier(c3, empty, empty)), empty), where c1 has a son c2 and c2 has a brother c3. In this data type, class, sons, and brothers are the accessors and empty?, nodehier? are the recognizers.

The section goes on to discuss the integer field next, which is used during recursive calls to count every method defined in the super method in order to find the number of the first token that can be used to tokenize the methods. If a method s is associated with a token t in the super method and s occurs in the list of methods, the searchmethod function ensures that s will be numbered by the same token t in the class.

In the Java bytecode format, constants such as integers, real numbers, strings, class names, and method names are stored in an array called a constant pool. There is one constant pool per class. In the bytecode of the class methods, every occurrence of a constant is replaced by its corresponding index in the constant pool.

This section deals with the componentization of Java Card packages. The Java Card definition specifies how a package of class files must be split into a number of components (method, class, export, constant pool, etc.) that together represent the package. We focus on building the constant pool component, demonstrating how to define and prove correct a function that, given a class hierarchy, produces two results: a global package constant pool and an offset function f. The global constant pool is produced by merging all the constant pools of the classes contained in the hierarchy. For every class of the hierarchy, the offset function gives the jump to perform in the global constant pool to find back the content of the constant pool of the class.

Section 5.1 introduces a specific theory for dealing with basic array copying and merging problems, while in section 5.2, we illustrate how this theory can be used to achieve the componentization function and its proof on class hierarchies.

We specify a function that copies the content of an array t1 between indexes from pos to toPos into an array t2 at a position at pos. The function's resulting type could be more precise, with the possibility of specifying that in the resulting constant pool, we must find the values of t1 between the indexes at pos and at pos+(to pos from pos) and that we must find back the original values of t2 outside of these indexes. However, using such a very precise subtype tends to generate intricate type checking conditions (TCCs), which are more difficult to prove than if the property is proven outside of the typing as additional lemmas: correct copy for property (1) and copy not modif outside values for property (2).

Thanks to the previous array copy function, it is easy to define a function sum that concatenates two constant pools. Furthermore, using the two previous lemmas, it is easy to show that the sum function is correct, i.e., in the sum of two constant pools t1 and t2, t1 can be found in the sum from indexes 0.

Similar to section 4.2 for the tokenization functions, the componentization function is supposed to be applied to a valid hierarchy. However, for componentization, an additional assumption is necessary: we assume that there is a bijection between classes and their names. The main theorem states that for all valid class hierarchies, if comp cp is the componentized constant pool, and if off fun is the related offset function, then for every class file cf in this hierarchy (having a non-empty constant pool), we can find back the i-th cell of the constant pool of cf at position jump + i in comp cp, where jump = get(get assoc(name(cf), off fun)). The value of the jump is in fact the value associated with the name of the class cf in the association list off fun.

However, typing this theorem raises two non-trivial proof obligations (TCCs) revealing two implicit assumptions that must be proved first as lemmas. The first lemma states that by looking for the name of the class cf in the association list, we will obtain at least one value for the jump, i.e., that the offset function is total with regards to the class names of the hierarchy. The second lemma states that for every class file cf, jump + i is within the bounds of the global componentized constant pool comp cp. Even if the details are rather different, the global proof sketches for those two lemmas and for correctness cp component are similar. We perform an induction on the structure of the hierarchy ch. The base case of the empty hierarchy is easily discarded since it is contradictory with the fact that cf is known to be in the hierarchy ch. Then for the general case, we achieve a proof by cases on the definition of...

We have specified the core algorithms of a CAP converter in PVS. These algorithms deal with the tokenization and the componentization of Java Card class files. The tokenization algorithm was proven correct by showing that it fulfills the constraints detailed in the Java Card definition of the CAP format, which was sufficient to prove the correctness of the conversion, as demonstrated in previous work. Componentization was proven correct in the particular case of merging constant pools.