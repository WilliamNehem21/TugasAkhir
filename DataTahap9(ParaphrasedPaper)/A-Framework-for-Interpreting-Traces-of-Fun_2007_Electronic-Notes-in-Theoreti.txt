This paper is part of a comprehensive strategy for debugging functional logic languages. The main objective of this project is to track the execution of functional logic programs through side effects, and then to provide various perspectives on the recorded data. By doing so, well-known debugging techniques such as declarative debugging, expression observation, redex trailing, step-by-step debuggers, and cost center-oriented symbolic profiling can be implemented as specialized views on the recorded data. Additionally, the creation of new views for specific debugging purposes should be relatively straightforward. This is the main contribution of this work - detailing how the recorded data is interpreted and preprocessed to create a simple yet flexible interface on which different views can be based. With this interface, implementing the basic functionality of declarative debugging, for example, only requires a few lines of code.

Declarative programming philosophy emphasizes abstracting from certain aspects of program execution to improve the code's quality. This includes omitting typical sources of errors such as memory management issues, type errors, and multiple variable allocation. The program is designed to be closer to the logic of the implemented algorithm rather than its execution, resulting in code that is more readable, understandable, and maintainable.

Visualizing computation provides a straightforward approach to identifying bugs by representing program execution in a human-readable form and providing tools for easy navigation of this representation. Tools such as step-by-step debuggers have been developed for many languages, both imperative and declarative. However, these tools often rely on specific backends of the supported language and generally lack portability. Various debugging approaches based on analyzing computed values, such as declarative debugging, observations for lazy languages, backward stepping, and redex trailing, have also been discussed.

In addition, the paper discusses an extension to the existing approach by recording information about the actual pattern matching performed during program execution. It is emphasized that this information is crucial when integrating the tools described previously. Unlike the Hat system, which is limited to emulating value-oriented techniques, the proposed approach allows for the reconstruction of the program's operational behavior, potentially enabling the emulation of a wider range of debugging tools.

The paper focuses on providing a simple yet versatile interface to traces of program executions in the functional logic language Curry. It describes the representation of traced data in Curry, proposes a simpler data structure to represent general computations, and outlines techniques for obtaining and processing this data structure. It is suggested that using this structure, it should be relatively straightforward to implement tools similar to those mentioned previously, at least with regard to accessing runtime data about program executions.

The basic idea is to categorize computation steps in functional logic languages as single steps, subcomputations, or branching, and to characterize value-oriented and operation-oriented techniques accordingly. It is emphasized that different views can be interpreted based on various evaluation strategies, such as strict and lazy evaluation.

The paper is based on two preliminary works, where a semantics for functional logic languages was extended by constructing a trace graph and a program transformation was presented to write side effect information into a file from which a graph can be produced.

The construction of the graph as a cyclic data structure is discussed, as well as an alternative implementation that represents the graph as a potentially infinite term. The definition of computations allows for their generation, combination, and processing in a monadic programming style, utilizing list and state monads to deal with nondeterminism and information that needs to be regularly updated during computations.

In summary, the paper demonstrates how different advanced features of Curry can be used to raise the low-level information contained in the execution trace to a higher abstraction level. It utilizes advanced programming techniques to create a framework for the elegant formulation of trace interpretation. Future work includes providing an overview of the different strategies and views realized using this framework.