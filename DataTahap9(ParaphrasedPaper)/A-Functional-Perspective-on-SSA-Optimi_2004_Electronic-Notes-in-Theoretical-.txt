The static single assignment (SSA) form is crucial for various optimization algorithms that depend on data flow information and, consequently, for the accuracy of compilers using these algorithms. It is widely recognized that the SSA form has close ties to lambda terms (i.e., functional programs). Given the substantial effort devoted to theories and frameworks for formal reasoning in lambda calculus, it is natural to exploit this connection to enhance our ability to reason about compiler optimizations. This study presents a new formalization of the mapping from SSA programs to a restricted form of lambda terms known as administrative normal form (ANF). We propose that this connection enhances our capacity to reason about SSA-based optimization algorithms, and we demonstrate this by introducing an ANF variant of a well-known SSA-based conditional constant propagation algorithm.

Kelsey and Appel (3, 2) have noted a relationship between programs in SSA form and lambda terms, which we believe can streamline reasoning about compiler optimizations previously based on the SSA form.

We view the findings of this paper as a step towards harnessing the established benefits of typed, functional intermediate languages in compilers for conventional languages. These advantages include simplified reasoning about the correctness of compiler optimizations, type-based validation of optimized code at compile time, and support for the generation of certified binaries (9, 20, 16, 14, 18). Additionally, ANF naturally integrates intra-procedural with inter-procedural analysis.

For our discussion, we do not specify the set of constants, which generally includes integers, floating-point numbers, and machine opcodes (primitives). To simplify matters, we assume that all variables and labels in a program are unique.

The translation process mirrors the structure of a program in SSA form. The entire program is translated by functions f and fp into a comprehensive outermost letrec. Within each procedure, functions fb and fl generate an ANF function for each SSA block, with each level of the dominator tree translated into a separate nested letrec. This permits variables defined along the dominator path to be visible via the typical scoping rules for nested procedures, while creating a new dynamic scope for each iteration through a translated SSA block. The dominator of a group is chosen for the body expression of the letrec. Furthermore, since the leaves of the dominator tree can only be reached through their immediate dominator, the scoping rules for ANF enforce the dominance property of the SSA form. If desired, the resulting program's nested letrec structure can be flattened using the standard lambda-lifting transformation.