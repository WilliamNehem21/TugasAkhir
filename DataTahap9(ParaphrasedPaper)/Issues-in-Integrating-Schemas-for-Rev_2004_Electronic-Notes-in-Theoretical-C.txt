After adopting a standard format like gxl for exchanging graphs of artifacts in reverse engineering tools, the next step is to define an appropriate schema for the information contained in these graphs. While various researchers have developed schemas, in practice it is difficult to choose an existing one, often leading to the need to implement new schemas tailored to specific tools or case studies. This paper discusses a potential scenario for integrating schemas, with the aim of improving the interoperability among reverse engineering tools.

Some research has been done to establish a standard schema for C/C++. Ferenc et al. explored building a standard schema for C/C++ at the abstract syntax tree level. Issues with the lexical, syntactic, and semantic structure were analyzed in the Datrix and Columbus schemas. The authors concluded that creating a standard schema for C/C++ is a complex problem, which presents many difficulties. Dean and Holt proposed a technique to combine two schemas to create a fact extractor.

In accordance with certain schemas, or due to missing elements of interest, we had to develop a new schema for C/C++ to be used with the Rigi reverse engineering tool. Preferably, more time would be spent analyzing the software system rather than writing a fact extractor and its schema. This paper discusses the challenges and benefits of integrating existing schemas, and also provides an example of integrating two given schemas.

Easier information exchange and methods to integrate data from diverse, complementary tools can allow users to choose the best tool for the task at hand. It is essential to ensure that the exchanged information conforms to common, agreed semantics in addition to having a common exchange format. Although the idea of integrating schemas comes naturally, it presents a significant challenge.

There are multiple schemas in the reverse engineering domain, developed independently with different structures and using varying terminology for entities, relationships, or attributes. As a result, the process of identifying the logically common parts between these schemas, known as schema matching, is necessary. Integrating the two schemas involves producing a mapping between the elements that match semantically and treating them as a union of the two schemas, with consideration given to the elements discovered in the schema matching process.

The problem of schema integration is old and remains unsolved. It has been investigated in the database field since the early 1980s and is also found in the artificial intelligence domain when integrating independently developed ontologies into a single ontology.

Jin et al. proposed a solution for transparent interoperability among reverse engineering tools, defining a special adapter to deal with a domain ontology and facilitate integration. This is similar to creating a common intermediate language for all reverse engineering tools, with more comprehensive ontologies leading to better integration.

Rahm and Bernstein created a taxonomy based on different criteria for matches and released an algorithm for general schema matching, called Cupid, incorporating automated linguistic-based matching. Madhavan et al. proposed a novel approach for matching schemas, extracting knowledge from past matching of schemas and applying this knowledge to new schemas.

Jin et al. presented interesting classifications for categorizing the schemas, considering the definition of the schema and the locality of the schema, leading to different subcategories of schemas or integrated schemas.

This paper presents an example of integrating two schemas intended for C/C++ elements: CPPDM developed by the University of Alberta and DMM developed by the University of Ottawa.

The aim of creating an integrated schema is to use it for integrating data from different fact extractors. For data integration, rules for mapping the elements from the initial schemas to the resulting schema need to be maintained, which may involve filtering or transforming data as needed.

An example of building attributes for the class entity in the new schema is provided, illustrating the process of integrating the attributes from the two original schemas.

In this paper, the need for integrating schemas for reverse engineering has been outlined, and a process for integrating two given schemas has been illustrated. Future work should involve additional case studies to apply the process, refinement of transformation rules, and an approach for further changes of the integrated schema to enhance its reuse for specific reverse engineering purposes.
