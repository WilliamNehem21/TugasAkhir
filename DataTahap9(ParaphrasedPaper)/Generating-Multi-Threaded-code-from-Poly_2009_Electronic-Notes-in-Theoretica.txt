In recent years, parallel processing has become increasingly important for enhancing the performance and power trade-off in general-purpose computing. Consequently, it is not surprising that multi-core architectures are beginning to penetrate the embedded processor market. Although major processor vendors have already introduced products with multiple cores on a single die, it is crucial for programmers to employ concurrent programming models to fully leverage the potential of these architectures. One such familiar programming model is the multi-threaded programming model. 

A recent update to the signal compiler enables the generation of multi-threaded code with close synchronization between concurrently executing threads, representing a significant advancement in managing concurrency. However, excessive use of multi-threading can lead to significant performance drawbacks due to the increased overhead of context switching. Our analysis suggests that the current signal compiler tends to generate a surplus of threads, resulting in unnecessary micro-threading and inefficient parallel computation.

This paper also reviews various related works on concurrent code generation stemming from concurrent computation specifications, including the discussion of models of computation (MoC) used to express concurrency between processes. The Kahn Process Networks (KPN) model is highlighted as a primary formalism for dataflow between processes, which has faced challenges related to buffer sizing during its transformation to the implementation level. The Dataflow Networks model, which is similar to the KPN model, provides an alternative approach for calculating buffer sizes based on the number of computations in the network.

Various tools have been developed based on these dataflow models. For instance, Simulink offers an environment for multi-domain simulation and model-based design for dynamic and embedded systems, and it comes with a stateflow coder that generates code traceable back to the stateflow chart. Similarly, a recent proposal for generating multi-threaded code from Simulink models with reduced communication overhead aligns with our current approach, which aims to focus on larger thread granularity to minimize thread synchronization overhead. Additionally, the paper mentions Lustre, a declarative synchronous dataflow language, and Esterel, an imperative language for control description, to exemplify the array of tools available.

In light of the current strategy where the programmer is shielded from decisions regarding the number and grouping of threads, the paper argues for the importance of programmers being informed about implementation details to tailor their programs according to the available hardware resources. As an alternative, the paper suggests a multi-threading solution inferred from the signal specification that utilizes only two threads for the starmac example.