The programming language P is defined inductively as follows. Its arithmetic expressions involve constants from set C (which includes integers and real numbers), variables from set V={v1,..., vn}, multiplications of a constant by a variable, and additions of two variables. Programs in P and instructions in I are defined by mutual induction, and there are only four basic instructions: an instruction that does nothing, the classic assignment, if-then-else branching, and the while loop.

It should be noted that P-programs are structurally finite objects. While the language P may not be convenient for actual large-scale programming, it allows simulating other classical branching and looping, as well as complex tests. Furthermore, its simple definition keeps the proofs and explanations at a reasonable complexity level.

The notion of size is important for defining functions involving programs and instructions, such as semantics functions and corresponding MPS. The size of programs and instructions corresponds to the number of control points that one may want to put in.

In the case of the PI algorithm, it performs a local search on the E-space of (1), whereas the algorithms mentioned in section 7 explore the entirety of the E-space, thereby always finding the guaranteed LFP. By comparison, a known sufficient condition for PI methods to find a guaranteed LFP is that the semantics function should be non-expansive in the sup norm.

By imposing variable values (similar to imposing that all boxes are in a large pre-determined box, akin to widening), we are able to reformulate all products between decision variables occurring in the MP to a linear form, yielding a MILP which we solve using the branch-and-bound solver CPLEX 11 on a 2.4GHz Intel Xeon CPU with 8GB RAM. It's worth noting that for most practical cases, the large bound need not be arbitrary, as automatic range reduction techniques for MILP can help considerably.
