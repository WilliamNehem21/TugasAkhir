Modern highly distributed networks, such as the internet, have become a prevalent platform for large-scale distributed programming. These environments, known as open environments, are characterized by their vast geographical distribution, high dynamicity (the emergence of new nodes and services), and lack of a global state.

Research efforts have been focused on managing the complexity of these environments by developing new paradigms, theories, and technologies for distributed applications. In this context, code mobility has garnered special attention due to its flexibility and potential applications in various fields, such as network management, electronic commerce, distributed information retrieval, advanced telecommunication services, active networks, active documents, workflow management systems, and disconnected operations.

Although there are existing standards, platforms, and languages available for mobile code, such as Java, which is widely used for its high portability and dynamic binding, there are still unresolved issues in establishing a robust support system for mobile code. One such issue is the lack of a formal basis for mobile code and active networks, as their ideas and implementations have mainly emerged from a practical approach. The development of an abstract semantic framework, encompassing methods for specification, verification, and analysis, is crucial to formalize the model of computation of internet applications.

Places serve as the necessary infrastructure to support mobile applications, providing hardware and software (middleware) support for running, moving, and leaving mobile components. These components have the capability to migrate from place to place during their execution, utilizing other components and essential facilities. In an open and dynamic environment, places need to offer a basic level of functionality and be easily configurable to accommodate various applications. Furthermore, they should be highly customizable to support different applications in a distributed environment.

In distributed environments like these, software components and places are independent entities with distinct ownership and decision-making authorities. As a result, they follow distinct life cycles, and there is no provision for obtaining a global state. Additionally, consideration of the failure behavior of the environment is crucial when designing distributed applications, as it is important for developers to anticipate and address potential failures during the application's runtime.

Graph transformation systems offer a natural way to model places and components as nodes, with relations representing spatial distribution and connectivity as edges. These systems also provide possibilities for a formal specification of the system's topology, making them advantageous in addressing the complexity of distributed environments.

In dynamic environments, it may be beneficial to allow the creation of multiple instances of the same component to perform specific tasks based on their parameters. Components have the potential to die at any moment, and the middleware is responsible for handling such situations by warning a component if it tries to communicate with a non-existing component and supporting distributed garbage collection.

When developing mobile code applications, it is important to address the unreliability of the open environment and provide levels of confidence in the system's implementation. Sophisticated analysis techniques are required to handle potential failures and ensure the correct behavior of the system under various scenarios.

In conclusion, existing research efforts are focused on developing formalized models and technologies to support and manage the complexity of distributed environments, with specific attention given to code mobility and the formalization of component behavior in dynamic and open environments.