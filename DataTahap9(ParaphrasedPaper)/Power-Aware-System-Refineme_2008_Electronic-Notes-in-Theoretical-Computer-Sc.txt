We propose a formal approach to refine systems with a focus on power awareness. This approach builds on the traditional refinement calculus of action systems and its extension, the time-wise refinement method. The adaptation provides a mathematical foundation for modeling systems using the timed action systems formalism. When refining an abstract system into a more concrete one, the designer must demonstrate satisfaction of both functional and temporal conditions, as well as power-related issues.

The proposed approach defines actions (a and ai, i= 1, 2), variables (x), expressions (e), and predicates (p and r). The write variables of an action are denoted as wa, while the read variables are denoted as ra. The body p of the procedure p: p(in x; out y): p can be any atomic action a, possibly with auxiliary local variables w, initialized to w0 each time the procedure is called. The action a accesses the global and local variables of the host system, as well as the formal parameters x and y. The interface part declares variables (u) that are visible outside the action system boundaries and introduces communication procedures that are either imported or exported by the system. A timed action system is considered closed if it does not have any interface variables or procedures; otherwise, it is an open system.

The iteration section contains the composition of actions defined in the declarative part and is responsible for the execution of the timed action system. The computation of a timed action system begins with an initialization in which the variables are set to predefined values. In the iteration part, actions are selected for execution based on composition and enabledness. If there are no timed actions available, the system is considered temporarily delayed until enabled by external interfaces.

We introduce a performance modeling framework for hardware systems to model the size of an action system (either timed or untimed), denoted as area complexity. This framework aims to identify differences in energy consumption between arbitrary actions and assess their area complexity. Additionally, we present a case study analyzing the accuracy of addition and multiplication operations using the buddy library, demonstrating the approximation of our area complexity model.

Furthermore, we discuss the power consumption of timed action systems, distinguishing between dynamic and static power consumption. We emphasize the significance of static power consumption, which is caused by leakage current and is becoming increasingly relevant in modern technologies. We provide a definition for the dynamic power consumption of an action, as well as the energy model and static power loss caused by an action.

We also discuss relative constraints and timing behavior, demonstrating how relative orderings and constraints play a role in restricting the temporal behavior of timed actions and ensuring that the functionality inside the observation period is not altered during refinement steps. We additionally mention research on self-timed methodology and techniques for noise reduction in network-on-chip interconnects.

Overall, the paper presents a comprehensive approach to refining systems with a focus on power awareness, defining formal models, and discussing power consumption and timing behavior implications in hardware systems.