Normalization is driven by the recognition that when reading structured values from their byte representation, padding fields are disregarded. Additionally, there may be multiple byte representations for a value in C, even for primitive types. Normalization enables us to quantitatively analyze and compare C types.

Further rules can be established to allow delving into a singleton heap assertion for a structured type value. This may be necessary for extracting points-to information to assist in fulfilling guard proof obligations or side-conditions of certain rules, such as theorem 6.4. It also proves beneficial in enabling the modification of the granularity of an assertion.

In comparison to our previous in-place list reversal example, the proof script exhibited a similar structure and size, at 67 lines. Based on our experience, lifts and heap-updates can be minimized as demonstrated for type-safe C, relieving users from this level of intricacy. However, achieving a comprehensive result is not feasible with this superficial treatment.