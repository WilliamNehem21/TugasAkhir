The rest of this paper is structured as follows: Section 2 outlines the fundamental aspects of the Erlang programming language, including its syntactic constructs and their intended meaning. Section 3 provides a brief introduction to the rewriting logic framework. Finally, Sections 4 and 5 form the main focus of this paper, delving into the rewriting logic specification of the operational semantics of core Erlang and its implementation in Maude.

A module is defined by a name, followed by a list of exported functions and a list of function definitions. In our example, the system is defined in a module called "locker," and it is initialized using the start function. By invoking the spawn builtin function, two additional processes are generated, both running the client function from the locker module. The self builtin function returns the process identifier (pid) of the locker process, which is then passed as an argument to the clients, enabling them to communicate with the locker.

The function names ai/ni are regarded as variables that encompass the special domain of function abstractions. Evaluation of a letrec expression produces a new binding whose scope extends over e and e1,..., em. This extended scope is reflected in the semantics by propagating the letrec statements into the bodies of the function abstractions (cf. the definition of e' in the premise).

Here, i1,..., in denote the included processes, and prunning(ik) indicates the existence of the kth process. The predicate pscheduled(ik) holds when the process with identifier ik caused the last system-level transition, and pblocked(ik) is true if the corresponding process is blocked during message reception. Intuitively, it asserts that whenever a process exists, it is scheduled at some point or becomes blocked while waiting for message reception.