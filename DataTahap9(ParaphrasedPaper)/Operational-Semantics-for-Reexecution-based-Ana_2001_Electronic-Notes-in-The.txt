We present both concrete and abstract operational semantics as a means to analyze logic programs that incorporate delay declarations. This work serves as the foundation for extending the abstract interpreter gaia to accommodate logic programs using dynamic scheduling. Our concrete and abstract semantics explicitly capture both deadlock information and qualified answers, allowing for the eventual inference of certain deadlock and non-deadlock information through the resulting analysis.

The majority of logic programming languages, such as Sicstus Prolog, Prolog-III, CHIP, and SICStus Prolog with CLP, do not strictly enforce the left-to-right scheduling rule typical of Prolog. Instead, for efficiency gains, they utilize dynamic scheduling, where atom calls are deferred until their arguments are sufficiently instantiated, and procedures are supplemented with delay declarations. The analysis of logic programs with dynamic scheduling was initially explored by Marriott et al. [15, 9]. Falaschi et al. extended the denotational semantics of this class of programs to the general case of Constraint Logic Programming (CLP), while verification and termination issues have been investigated by Apt and Luitjes, and by Marchiori and Teusink, respectively.

The remainder of this paper is organized as follows: Section 2 provides a brief overview of basic concepts related to logic programs with delay declarations. Section 3 outlines the transition rules for concrete semantics. Section 4 presents the key aspects of collecting and abstract semantics, and discusses our generic fixpoint algorithm. Finally, Section 5 concludes the paper.

We assume the existence of two separate and infinite sets of variables, denoted as pv and sv. Elements of pv, called program variables, are represented as x1, x2,..., xi,.... The set pv is totally ordered, with xi being the i-th element of pv. Elements of sv, referred to as standard variables, are denoted...

The concept of concrete behavior provides a mathematical model for the input/output behavior of programs. To simplify the presentation, we do not parameterize the semantics with respect to programs; instead, we assume a fixed underlying program p augmented with delay declarations.

The operation retrg is employed when analyzing a literal l occurring in the body of a clause. Let {xi1,..., xin} be the set of variables occurring in l. This operation expresses a substitution in terms of the formal parameters x1,..., xn.

Rules r3 and r4 specify the execution of built-ins: the standard unification operations are applied. It is important to note that built-ins can only occur in the g part of the goal, i.e., the subset of literals in the current goal that have not been considered yet.

Any domain abstracting substitutions can be utilized to describe abstract activation states. Similar to the concrete case, we differentiate between input states and output states. The accuracy of deadlock analysis depends on the alignment between delay declarations and the information represented by the abstract domains.

If a goal is reached, the interpretation halts and returns an abstraction of the corresponding concrete qualified answers along with no deadlock information. Otherwise, when a goal of the form (g, g) is reached, where for all atoms a occurring in g, the activation substitutions (possibly) do not satisfy its delay declaration, and for all atoms a occurring in g, a reexecution process may not refine the corresponding activation substitution. If the abstract domain accurately infers a definite deadlock, the execution ends and returns an abstraction of concrete qualified answers along with definite deadlock information. If this is not the case, the abstract computation continues without considering the deadlock information. Particularly, atoms whose activation substitution may satisfy the corresponding delay declaration are selected. This process improves the computed abstraction of the corresponding concrete qualified answers while returning the information that the concrete computation may deadlock.

The semantics discussed here form the basis of a project aimed at integrating various theoretical and practical aspects of abstract interpretation of logic programs developed by the authors in recent years. The goal is to create a practical tool capable of addressing a range of issues emerging from current research and development directions in declarative programming, with dynamic scheduling serving as an illustrative example. In the near future, we intend to adapt existing implementations of gaia systems to evaluate the accuracy and efficiency of these foundational ideas.