Reusing components is an important strategy for reducing the effort required to describe a system. To expand our modeling language to support component reuse, we aim to introduce a library of component types. When a component is reused, it is referred to as an instance of the component type. Instances of component types can be used wherever a regular component can be used, such as in the composition of another component. An instance needs to be aware of its component type in order to adapt to changes in the component type.

In the context of the CCS/Autofocus 3 framework, the challenge of incorporating libraries arose when the meta-model already included close to 100 classes and a substantial amount of core functionality had been implemented, resulting in over 50,000 lines of source code. To address this, we sought a minimally invasive solution that would have minimal impact on the meta-model and existing code due to limited resources for reworking the entire code base.

Our approach was to design a library mechanism that could operate independently of the existing meta-model and modeling tools to ensure transparent compatibility with existing code. This led us to develop an approach where instances function as complete replicas of the types. Unlike general cloning, our focus was on a more structured reuse mechanism where dedicated library elements could be instantiated. Furthermore, our approach allowed for the parameterization of instances generated by the type, offering a more flexible and adaptable solution.

The primary purpose of implementing library mechanisms is to facilitate the modification of library elements and ensure that such changes are reflected across all instances. This was achieved by marking instances with their origin and employing loosely coupled library references based on their names. To manage the modification of library elements, we incremented the version number of a library element with each change, allowing outdated library references to be easily identified and replaced by updated versions.

Updating all instances of a library element required a modified merge algorithm to replace the old model part with the new one while preserving references to external elements and layout and naming information. Despite the increased size of the models due to the storage of redundant information, the implementation and modification effort for our solution remained manageable. However, our approach has drawbacks, such as potential exponential growth in the number of model elements.

Although our approach has its limitations, such as increased model size, we have mitigated these issues and made the implementation and modification process manageable while supporting a more structured reuse mechanism that allows for flexible parametrization.