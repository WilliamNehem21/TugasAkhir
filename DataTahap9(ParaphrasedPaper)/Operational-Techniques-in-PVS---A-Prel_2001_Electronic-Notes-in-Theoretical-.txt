When working with complex specifications in PVS, it is common to feel overwhelmed by the number of type correctness conditions (TCCs) that arise. To address this issue, a mechanism is introduced to mitigate the accumulation of TCCs through judgments, which provide more specific information to the typechecker. These judgments come in two forms: constant judgments, which assert that a specific constant has a more specific type than its declared type, and subtype judgments, which assert that one type is a subtype of another. We indicate in the proof where we utilize the judgment mechanism.

The PVS prelude includes a comprehensive set of theories covering numbers, set operations, finite sets, ordinals, functions, induction schemes, and abstract data types, such as a list definition. Additionally, the prelude contains a variety of judgments.

The PVS prover is interacted with through commands in Emacs using a Lisp-like interface. These commands consist of high-level strategies and more specific rules. Strategies are designed to address a wide range of problems and ideally complete proofs automatically, while rules provide the user with greater control over the proof, albeit at a more detailed level. For instance, the split rule divides the current proof into multiple subproofs, while the prop strategy divides the proof and then applies propositional flattening and simplification. It is generally advisable to first attempt proofs using the higher-level strategies and only resort to lower-level commands when necessary. This approach not only increases the level of automation but also results in proofs that are more robust to changes in the specifications.

A PVS specification is divided into theories and data type definitions. Each theorem comprises a (potentially empty) list of parameters, import and export statements, type definitions, constant definitions, function definitions, judgments, and lemmas. The parameters can be types, subtypes, or constants. Exporting statements are used to specify the names visible to theories that import the current theory, while importing statements specify a list of theories to be imported and can be either parameterized or unparameterized.

The definition of fv allows for handling renaming and substitution. The renaming function replaces all free occurrences of one variable with another, and in some cases, it may be necessary to rename the bound variables of an expression to prevent capture.