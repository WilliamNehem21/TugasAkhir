Specifying concurrent program modules presents a challenging task as the specifications must be sufficiently strong to allow reasoning about the intended clients without needing to know the underlying module implementation. In this paper, we review a variety of verification techniques for specifying concurrent modules, focusing on four key concepts: auxiliary state, interference abstraction, resource ownership, and atomicity. We illustrate how these concepts can be combined to create effective approaches for specifying concurrent modules.

However, it is noted that these specifications are not robust enough to specify certain clients, such as the ticket lock. They do not retain any information about the value of the counter or how the operations affect this value. In fact, even if the read operation changes the value of the counter, it would still satisfy the specification. Unfortunately, assertions that define the exact value of the counter are not consistent.

The introduction of the concept of auxiliary state, as seen in the Owicki-Gries method, is significant for specifying concurrent modules. This abstraction allows for the abstraction of the internal state of threads, enabling more convenient reasoning using auxiliary variables rather than considering the program counter and local variables of each thread.

Despite capturing some of the intended behavior of "wkincr," the specifications are inadequate for reasoning about the ticket lock. With the ticket lock, it is possible for two invocations of the "wkincr" operation to be executed concurrently. This concurrent behavior is not permitted by the above specifications because they exclude all concurrent updates to the counter with an empty rely relation.

Permission accounting, introduced by Boyland, Bornat, et al. in separation logic, allows for the division of shared resources by associating them with a fraction in the interval (0, 1]. This concept enables the subdivision of shared resources, such as the counter resource, by associating fractions with them.

The concept of atomicity, proposed by linearisability, is important for specifying concurrent modules as it guarantees that observable interference from an operation will occur at a single instant in its execution. This abstraction allows clients to focus solely on the overall transformation performed by an atomic operation, without needing to consider intermediate states that might violate invariants.

To address the non-modularity of the Owicki-Gries method, Jacobs and Piessens introduced higher-order specifications for operations, parametrised by auxiliary code performed when the abstract atomic operation takes effect (the linearisation point). This approach ensures uniform instrumentation of the code, with the auxiliary code being determined at the call site.

Furthermore, a generalized version of the atomic triple is introduced to combine atomicity with resource transfer, enabling the specification of operations that involve transferring ownership of resources. These strong counter specifications support synchronization and can justify the correctness of the ticket lock. They are expressive enough to enforce obligations on both the client and the implementation.

This paper concludes by highlighting the value contributed by various proof methods for verifying concurrent programs, such as Owicki-Gries, rely/guarantee, concurrent separation logics, and linearisability. It also demonstrates how these ideas can be integrated to create specifications that are both expressive and modular.