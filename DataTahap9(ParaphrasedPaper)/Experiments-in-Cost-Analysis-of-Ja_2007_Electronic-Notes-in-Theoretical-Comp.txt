The availability of information regarding the execution cost [17,11] of a piece of code is highly valuable, as it plays a critical role in selecting among different implementations of the same specification. It can also be instrumental in certifying that an application's execution complies with specified resource-consumption constraints. Furthermore, cost analysis is particularly important in the context of mobile code, where resources are severely limited, and decisions regarding code acceptance or rejection may be based on its cost. In extreme cases, accepting mobile code without cost guarantees [6,12] can pose a risk of denial-of-service attacks, as the execution could be prohibitively costly, or even infinite. It is important to note that in these situations, access to the source code may not be available, and the focus is often on handling the compiled code directly.

In general, cost analysis is a non-trivial task that requires a considerable level of expertise on the part of programmers to develop an intuition about the implementation techniques that can lead to more efficient programs. This challenge is particularly pronounced when dealing with a low-level, object-oriented language such as Java bytecode. It is therefore expected that automating cost analysis of Java bytecode may not consistently yield meaningful results, especially for highly complex code. Thus, a key question regarding the cost analysis framework proposed in this paper, and which is examined in the present work, is whether the generated cost relationships can be automatically simplified into a closed form solution when considering the simple cost model traditionally used in complexity analysis, which counts the number of execution steps (bytecode instructions).

The subsequent sections of this paper are organized as follows. Section 2 presents an overview of our cost analysis framework for Java bytecode. This is followed by an examination of three classes of benchmarks. In Section 3, we analyze some well-known recursive procedures whose structure gives rise to cost relationships that can be easily managed.

From the control flow graph (CFG), we derive a recursive representation of the method, where iteration is transformed into recursion. In this representation, each block in the graph is represented as a rule. Additionally, the operand stack is flattened by converting its contents into a series of additional local variables. It is noteworthy that this is feasible since, in every valid bytecode program, the height of the local stack at each program point can be statically computed.

Regarding path length analysis, our analyzer does not yet support the analysis of arbitrary programs; specifically, the program is expected to meet certain correctness conditions: (1) data structures are not cyclic, and (2) whenever a reference is passed to a method, it is ensured that the corresponding structure (on the heap) is not updated by that method. To address these limitations, our analyzer should be enhanced by incorporating shared and cyclicity components, which is currently under development.

Moreover, it is essential to identify the set of variables that are relevant to the cost, i.e., those whose values may impact the program's execution time. For instance, the index of a for-like loop is typically relevant as it affects the number of iterations. On the other hand, a variable used to store partial results has no effect on the cost unless its value is involved in computations with variable execution times. Relevant variables are those involved in guards or method calls, as a guard influences the control flow and the cost of executing external methods can significantly impact the overall cost. This analysis is akin to program slicing and is carried out by propagating relevant variables backwards through the control flow graph. Once a fixed point is reached, each block is labeled with the sets of input and output relevant variables, which are used to derive cost relationships. While the use of slicing in one particular example does not eliminate any variables from the relations, in other examples, several variables can be eliminated, resulting in simpler cost relationships that would otherwise be unsolvable.

In the upcoming sections, we deduce the cost of two classical recursive procedures. In both cases and generally for recursive procedures where the base case depends on constant values, the cost relationships obtained from our analysis are directly solvable using Mathematica. For simplicity, the cost of all bytecode instructions is assumed to be 1; introducing a more refined cost model that assigns different costs to different bytecodes would not complicate the analysis. For clarity, we present only the original Java code rather than the bytecode.

We then explore various object-oriented features, focusing on how we handle dynamic dispatching and analyze the cost of reversing a list implemented as a class with field attributes. Additionally, we infer the cost of a linear search algorithm over the list, which to our knowledge, illustrates novel object-oriented features not previously studied in existing cost analyses for other languages and paradigms.

To evaluate the feasibility of our cost analysis framework, we have implemented a prototype analyzer in CIAO. The experiments were conducted on an Intel P4 Xeon 2 GHz with 4 GB of RAM, running GNU Linux FC-2, 2.6.9.

Our experimental results are preliminary, and there is still ample opportunity for optimization, primarily in the size analysis phase. The primary planned optimization involves the use of abstract compilation techniques to avoid recomputation of abstract operations related to the bytecodes. This is feasible because the analysis is denotational, ensuring that the bytecodes will always have the same abstract approximations.

This work was supported in part by the Information Society Technologies program of the European Commission, Future and Emerging Technologies under the IST-15905 MOBIUS project, by the Spanish Ministry of Education under the TIN-2005-09207 MERIT project, and the Madrid Regional Government under the S-0505/TIC/0407 PROMESAS project. S. Genaim was supported by a Juan de la Cierva fellowship awarded by MEC.