demartini, iosif, and sisto discuss applying the spin model checker to Java multithreading applications. They outline the process of translating Java source code into Promela, the input language of spin, aiming to verify source code using automatic abstraction techniques to simplify the model. They demonstrate their approach with toy examples. Havelund and Pressburger take a similar approach to the initial generation of their Java Pathfinder tool but with broader language support, noting successful results for Java programs of up to 2000 lines of code. Both translations are complicated by the need to model Java's concurrency primitives, whereas the method used by c2edl is not encumbered by these concerns. However, the translations of [15, 26] are in some ways simpler than c2edl's, as the Promela language allows them to retain much more of the original program's structure.

Visser, Havelund, Brat, and Park present the second generation of Java Pathfinder, which is a bespoke model checker for Java. In contrast, the authors did not develop a new model checking algorithm but utilized modeling techniques to enable the application of an existing one, generating finite state models from Java source code. They employ user-guided abstractions to reduce data set cardinality and provide a language for specifying additional abstractions. Their method is demonstrated on a threaded pipeline comprising 60 lines of Java code. In contrast, c2edl's approach is entirely automatic, and the authors present results for a non-trivial application.

Esparza, Hansel, Rossmanith, and Schwoon describe model checking algorithms for pushdown automata, abstracting all variable values similar to the approach taken by the authors. However, they are not limited to a finite stack, while c2edl produces a finite state model for rulebase. They report impressive results for randomly generated flow graphs (skeleton programs) of up to 20,000 lines.

The work described in this paper was conducted using rulebase, which was initially based on a version of SMV. After eight years of development, the original SMV code constitutes only a small part of the whole, though the garbage collection mechanism of SMV remains.

The paper acknowledges that interesting C programs are typically more complex than the presented function getmax(). Extending the translation to other types of branching and loop statements is feasible, but the translation process should also accommodate complex data types, pointers, and function calls, including recursive function calls. These challenges could be addressed by mimicking a compiler or starting the translation from assembly or machine code, though the authors note that such a theoretical solution would be hindered by the state explosion problem. The subsequent section outlines the approach used by c2edl.

Using a model built by c2edl, the authors checked the usage of the garbage collection mechanism in SMV version r2.4.4 and in rulebase. In this process, c2edl was invoked with bit vectors instead of integers, with the stack restricted to a depth of 5.

Rulebase itself was also subjected to verification. In particular, a function called reduction() was checked, revealing 47 out of 352 checked formulas to be problematic, with 39 related to the garbage collection mechanism. The usage of c2edl allowed these issues to be statically identified using rulebase before traditional regression testing of a new version had commenced. The authors highlight that the use of c2edl and rulebase facilitated the easy identification and resolution of these issues, avoiding unexpected results or mysterious segmentation violations, typically indicative of a failed test.

The paper details instances where false negatives can be avoided by adhering to specific coding conventions and acknowledges limitations related to the depth of the stack, which could lead to an inability to identify errors occurring at deeper levels of nested calls. The authors stress that false positives constitute a fundamental problem, rendering their method unfit for software verification but suitable for falsification purposes. They urge readers to consider their work in the practical context of falsification.

The author expresses gratitude to Ilan Beer for pointing out that the garbage collection mechanism could be expressed solely as a function of the program counter, as well as to Shoham Bendavid, Avigail Orni, and Yaron Wolfsthal for their time reviewing and offering helpful comments on the work.