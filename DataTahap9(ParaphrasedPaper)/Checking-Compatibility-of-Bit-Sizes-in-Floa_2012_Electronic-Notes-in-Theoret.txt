This academic paper introduces and outlines a straightforward static analysis method focused on verifying the compatibility of bit widths in comparisons involving floating point values, ensuring consistent precision ranges. The primary concern is precision mismatches caused by the variations in bit widths between the floating point registers within processors (typically 80 or 64 bits) and their corresponding widths when stored in memory (64 or 32 bits). The analysis aims to guarantee that comparisons between floating point values loaded from memory (such as array elements, instance fields, and static fields) and those held in registers (e.g., arguments or local variables) are appropriately managed.

The paper illustrates an example in which a field store operation truncates the value to 32 bits, leading to a loss of precision. Specifically, the value 9.42477822 is coerced to a float, resulting in the truncated value 9.424778 being stored in the field this.balance. As a consequence, when evaluating the postcondition, the truncated value of balance is retrieved from memory, while the addition in the postcondition is recomputed with the internal precision. The comparison of these two values ultimately causes the postcondition to fail.

The proposed analysis has been implemented in "Clousot," a static analyzer for code contracts. The process involves reading the intermediate language (IL) from disk, constructing a control flow graph for each method, integrating necessary contracts, simplifying the program by eliminating the evaluation stack and heap, reconstructing lost expressions, and finally generating a scalar program. Several analyses are performed on the resulting scalar program, including non-null, numerical, array, and arithmetic analyses. The detection of precision mismatches in floating point comparisons, as described in the paper, has been added to the arithmetic analysis. The analysis is described as fast and accurate, with minimal impact on processing time and a small number of reported warnings.

It is noted that the decision has been made to focus on detecting precision mismatches specifically in the context of comparing floating point numbers. This approach is preferred over an alternative analysis that would warn users about implicit casting of higher precision floats to nominal type width (effectively whenever a result is stored in memory) due to its potential for excessive warnings and the risk of missing implicit narrowings introduced by the compiler through register spilling into memory. The authors state that warning about comparisons addresses the problem in a more actionable manner.