Our concepts of SSA and ANF closely resemble existing approaches, with a focus on a specific procedure: in ANF, function applications occur as tail calls. Various recent proposals have explored type-based calculi for register allocation, often utilizing a language similar to ANF. While our examination has been limited to a first-order language with tail-recursive calls, extending to higher-order functions, which necessitate agreement on specific register allocation disciplines between caller and callee, is clearly desirable. This extension has been pursued by others, who have utilized effect systems to capture the impact of broader function calls on registers, similar to annotations present in the types of code pointers in TAL.

Agat has introduced a type system for a low-level explicitly register-annotated functional form designed for machines with finite register files and potentially unbounded stacks. The transition from unallocated to allocated programs is achieved through two operational semantics: the first ignores register annotations and uses a functional interpretation, while the second models an imperative semantics on register files. Unlike our approach, program variables in Agat's system do not directly correspond to registers, and explicit instructions have been introduced to transfer values between different locations. The soundness result of the type system asserts that the two semantics coincide for well-typed programs and is established using a further operational semantics that unifies the previous two. The type system also integrates effect annotations for closures, ensuring that functions anticipate their arguments in the correct registers and do not interfere with live locations.

Like these formal systems, our type system was presented as a means to specify register allocations, with the process of obtaining allocations involving inferring type judgments, an aspect that we did not delve into in this paper. Although our system was described using an unstructured set of registers, it has the potential to be extended to encompass various register types (e.g., double precision) or memory locations by introducing a kinding system. This extension could represent the distinct behaviors of different storage locations through kind-specific typing or transformation rules. Consequently, techniques such as spilling could be modeled, although the optimization task of determining which intermediates to spill would once again become a matter of type inference.