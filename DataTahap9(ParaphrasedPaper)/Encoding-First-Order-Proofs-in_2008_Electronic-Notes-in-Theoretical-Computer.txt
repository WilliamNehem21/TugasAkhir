Our initial chewtptp-sat implementation was successful on some problems, but certain encodings resulted in the creation of excessively large sets of clauses. Some aspects of the encoding represented decision-making processes, such as determining which clause to extend each literal with. Conversely, other parts of the encoding represented deterministic procedures, like assessing the consistency of unification constraints and confirming the acyclicity of the directed acyclic graph (DAG) to verify a specific property. Notably, in experimental results involving horn clauses, approximately 99% of the generated clauses encoded deterministic procedures, while only about 1% represented decision-making choices. We had an eager encoding of unification and acyclicity and believed that the implementation would be more efficient if...

In this paper, we present our implementation of chewtptp-smt and compare our findings with those of chewtptp-sat. We demonstrate that in the horn encoding, chewtptp-smt produces substantially fewer clauses than chewtptp-sat, along with a drastic reduction in the time required to ascertain satisfiability. However, this is not the case for non-horn clauses. We elucidate the reasons behind this discrepancy and offer a guideline for determining when theories should be utilized for encoding.

Our implementation allows users to choose whether chewtptp encodes the problem as a sat or smt problem. If the user opts for smt, our implementation utilizes Yices to test the satisfiability of the encoding. Alternatively, if the user selects sat, they can also decide whether to test the satisfiability using Yices or Minisat, employing a DIMACS encoding of sat.

We aimed to investigate whether working modulo theories would enhance the performance of chewtptp. In horn cases, the running time was significantly reduced, aside from a small percentage of exceptions. Conversely, in non-horn cases, working modulo theories often increased the running time. Generally, Yices outperformed Minisat on sat problems without theories.

We believe we have a rationale for our results. In horn problems, the number of clauses decreased by an order of magnitude, whereas in non-horn problems, there was not a substantial reduction in the number of clauses. This suggests that working modulo theories is only beneficial when there is a significant reduction in the clause size.

Considering the theories of Yices, we have maintained the propositional encoding. Consequently, even when the encoding of unification and acyclicity is removed, the overall coding of the problem remains O(n3). We posit a practical guideline for determining when it is advantageous to encode properties using theories. We hypothesize that if the number of clauses can be reduced by a factor of n, then the coding is advantageous, but if the asymptotic complexity remains the same, then it is not a viable approach.