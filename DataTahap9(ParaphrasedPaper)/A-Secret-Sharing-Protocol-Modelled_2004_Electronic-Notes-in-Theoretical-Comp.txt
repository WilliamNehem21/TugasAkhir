The process of secret sharing aims to address the conflict between the accessibility and confidentiality of a secret by distributing the secret to multiple servers in a manner that only allows it to be revealed if a subset of these servers are compromised. This is achieved through a scheme known as (n, t+1) secret sharing, which involves two key operations: split and reconstruct. The split operation generates a random set of n shares, referred to as a sharing, from a secret, while the reconstruct operation retrieves the secret from any subset of a sharing containing more than the specified threshold, t, of shares.

The initial protocol assumes a benign environment and is designed to proactively replace an existing sharing of a secret, which is collectively held by n servers, with a new sharing of the same secret. In this protocol, a sharing is created during one instance of the protocol and discarded in the next one. To compromise the secret, an adversary must obtain sufficient shares of a sharing to reconstruct it, thereby defining the window of vulnerability.

To separate the replication aspect from the secret-sharing component of the protocol, terms of sort aid are used to represent one or more concrete objects, identified by terms of sort oid. An a2c-map is introduced as a mapping from aid to setofoids. The protocol's messages are associated with a msgtype, and a quorummap maps a msgtype to a quorum, represented as a machineint. Additionally, a resprecognizer consists of pairs containing an expected response, of sort message, and a setofoids that have sent that response. The a2c-map and responses-quorums are dependent on the parameters n and t of the system, while the response-recognizer is initially empty and is built and modified as messages are transmitted.

The protocol also considers different adversaries, such as the link adversary who can eavesdrop on links, and the server adversary, who has access to the local information of a compromised server. Similarly, the second version of the protocol accounts for potential crashes of a coordinator, ensuring that there are at least t+1 coordinators present to initiate a run under such circumstances.

Subsequent modifications to the protocol aim to ensure the success of one of the competing runs in installing a sharing, while the next version defends against active link adversaries by incorporating elements for detecting and addressing various attacks. The availability and secrecy correctness criteria are discussed, emphasizing the need to verify that there are no protocol runs in which servers are unable to recover the secret or adversaries can access it.

The replication layer's behavior is described by conditional rules, which determine the transitions of the replication meta-object based on the messages it consumes. The availability and secrecy properties are identified as predicates on the state of the secret-sharing layer, and the computation tree that needs to be explored is described in terms of the state transitions within the secret-sharing layer.

The document also mentions the development of a strategy to reduce the search space and explores the use of Maude, a reflective language, for specifying strategies to control the rewriting process and meta-representing a specification at the next metalevel.

The paper concludes with a discussion on further work and exploration of more advanced features in newer versions of Maude for enhanced analysis techniques and a more complete specification of the protocol.