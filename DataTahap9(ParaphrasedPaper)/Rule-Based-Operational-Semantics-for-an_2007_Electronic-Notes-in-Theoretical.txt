The operational semantics of programming languages commonly come in two forms: big-step and small-step, both defined using deduction rules with a congruence rule allowing reduction in specific contexts. This paper describes the operational semantics of an imperative language in a rule-based style which is as abstract as other types of semantics, and combines this approach with store-based semantics that focus on memory states rather than values, making it more suitable for imperative languages.

Structural operational semantics (SOS) is the standard way of defining the operational meaning of programming languages, allowing two styles of specification: the big-step style, which defines a relation between programs and return values, and the small-step style, which defines a relation between program states. While the big-step style is often preferred, the small-step formulation is sometimes more convenient for certain applications, such as proving language properties.

In small-step presentations of programming languages, atomic steps are described as axioms, and a deduction rule allows reduction in a certain class of contexts, which may be applied an arbitrary number of times. This contextual semantics heavily relies on contexts and can be difficult to define. Additionally, conventional descriptions of semantics often emphasize values, which can be cumbersome when the focus is on memory states. Combining big-step and small-step approaches can result in a rule-based semantics for imperative languages, explicitly showing the evaluation flow and emphasizing memory states.

The paper also introduces new formalisms for defining the semantics of a language, such as restricting rewrite rules to atomic stores to enforce a reduction strategy and introducing intermediate notations to mark the evaluation of an expression. These frameworks have desirable properties compared to conventional approaches and can potentially bridge the gap between big-step specifications and implementations.

In conclusion, the combined approach of big-step and small-step semantics, focusing on memory states and evaluation flow, has potential applications in various areas and may facilitate the application of results and tools from rewriting theory to semantics.