The Coq proof assistant is an embodiment of the calculus of inductive constructions, which has been extended with inductive and coinductive types. Coinductive types were initially proposed by Coquand and then implemented in Coq by Gimenez. Coq has proven to be effective for working with various kinds of final coalgebras, such as the final coalgebra of streams, the final coalgebra of infinite binary trees, and others. For example, Coq has been utilized to define algebraic structures on real numbers [28,38,11].

The specification language of Coq enables the modeling of types and programs of typed programming languages, which typically provide basic types and a mechanism for defining inductive data types. When defining an inductive data type, constructors are introduced to generate elements of the new type. An example of a well-known inductive data type is the type of natural numbers, defined using two constructors: 0 and s.

In Coq, coinductive types can be defined similarly to inductive types, using basic constructors that are also associated with destructors through the pattern-matching construct. Destructors can also be used to emphasize the duality relative to inductive constructors.

Functions defined over inductive types are naturally recursive, as most functions defined on natural numbers necessitate recursive definition. Coq places the condition of structural recursion on every defined recursive function, ensuring that every recursive call is performed on a structurally smaller argument to guarantee termination.

While working with coinductive types in Coq, the notions of productivity [24,43] and guardedness [22,31] are important and are dual to those of termination and structural recursion. The guardedness condition prohibits many useful productive functions in Coq formalizations, a challenge that has been addressed in previous work [1,9,29,30].

A method for separating the inductive and coinductive components of productive coinductive values in Coq is proposed in sections 5 and 6. Section 5 focuses on the inductive component and provides a general characterization of the method for building ad-hoc predicates for formalizing productive values in Coq, while section 6 characterizes the coinductive component.

In Coq, both infinite streams and other types of infinite data, such as infinite binary trees and expression trees, can be handled using coinductive machinery. Expression trees, for example, are extensively used in formalizing real number arithmetic [38,25].

Productivity, first defined in [24,43] in terms of domain theory, is described from a computational perspective. A function is considered productive at the input value if it produces a productive value at that input, a slightly different approach compared to previous work [43,37,38] where productivity is based on taking productive values as input and producing productive values as output.

The relationship between termination and productivity, along with the syntactic definition of terminative and productive functions in Coq, is discussed. Guardedness is identified as a sufficient condition for productivity, and its relationship to various aspects of corecursive function definitions is explored.

The method used in Coq for implementing guarded corecursive functions, involving accessibility predicates and the separation of computational and logical parts of definitions, is detailed. This method enables the formalization of total functions and the characterization of corecursive functions in Coq.

The paper presents a systematic characterization of the inductive and coinductive components of productive functions in Coq, with a focus on modeling such components as Coq functions that depend on regular arguments as well as proofs about those arguments.

The technique described for modeling filter functions on streams and other data types using coinductive types and guarded corecursion is shown to have broad applicability. The authors outline areas for future work, including efforts to automate some parts of the technique and provide a detailed description of the class of functions for which the technique is effective.