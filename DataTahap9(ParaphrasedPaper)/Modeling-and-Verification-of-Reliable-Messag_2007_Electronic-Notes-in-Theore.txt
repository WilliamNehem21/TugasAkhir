The primary objective of our study is to expand the core SOA metamodel to incorporate features related to reliable messaging between services. Following the enrichment of the domain metamodel, we ultimately aim to develop a corresponding UML profile that offers customized extensions to the UML language, specifically tailored to a particular application domain. This involves introducing domain concepts, attributes, and relationships in the form of stereotypes and tagged values. However, the current paper solely concentrates on metamodel-level expansions for reliable messaging within the SOA metamodel.

The transformation process leaves the elements in LHS unchanged, while elements in LHS but not in RHS are removed, and elements in RHS but not in LHS are newly created by the rule. Adherence to negative conditions prevents the rule from executing in a specific matching scenario. Accordingly, we adopt the single pushout (SPO) approach, complemented by negative application conditions.

A graph grammar (GG) encompasses a start graph and a collection of graph transformation rules, while a graph transition system (GTS) represents the state space generated by a graph grammar. The various states of the GG, i.e., the derived instance graphs, are depicted as nodes, and the edges indicate state transitions brought about by the application of a graph transformation rule. An edge from state S1 to state S2 with label R, O signifies that one can obtain graph instance S2 from graph instance S1 by applying transformation rule R at match O.

This paper introduces a concise visualization method for graph transformation rules, initially introduced in the Fujaba framework and employed in Groove, in which the entire rule is consolidated into a single pattern. Newly created elements are denoted by solid thick (green) lines tagged as {new} in the editor, while deleted elements are represented by dashed blue lines tagged as {deleted}. Elements in the intersection of the LHS and RHS are visualized normally (in black), and elements of the NAC appear as thick dotted (red) lines. A negative condition is utilized to prevent the rule from generating an infinite number of new elements in the same matching scenario (e.g., in the case of messaging, ensuring that the same message is received only once).

The transformation rules were implemented in the Groove tool, which supports the generation of the state space (i.e., a graph transition system - GTS) derived by a graph grammar. The Groove simulator enables manual inspection of the state space from a given start graph for verification purposes. Although this is convenient for preliminary testing of the GT specification, it may not be entirely convincing for large state spaces. Regrettably, the current public version of Groove (March 2006) used in our experiments did not yet support the verification of CTL-like properties (as reported recently).

We managed to manually translate rich graph transformation rules and models (as employed in higher-level verification models with inheritance, types, attributes, etc.) into lower-level verification models (as used in Groove) through relatively simple modeling tricks.

Our work aligns conceptually with the approach described in [reference] for specifying services in SOA. The authors in [reference] discuss the application of graph transformations in the runtime matching of behavioral web service specifications. Additionally, [reference] focuses on graph transformations for conformance testing of web services and automated test case generation. However, none of these works address the aspects of reliable messaging. Our objective was to leverage the advantages of this approach by expanding the metamodel and the transformation rules.