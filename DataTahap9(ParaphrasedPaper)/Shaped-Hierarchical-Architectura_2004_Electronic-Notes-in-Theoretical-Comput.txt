The concept of style (or shape) checking signifies that an architecture can be classified as an instance of a specific software architecture (SA) style, which defines a set of structures sharing a common pattern. A style can be interpreted as a type for a particular architecture. Building upon this idea, we introduce the term "shape" to represent the rules used for typing systems. This terminology is borrowed from the field of graph grammars for typing pointer-based data structures in programming languages.

Our objective is to address modeling challenges in SA. The utilization of type systems and the linear representation of structures holds the potential for leveraging existing work on programming languages and static type checking. Furthermore, a graphical perspective is applicable to all components within this approach. As an example of this approach, we introduce a type inference system for shapes featuring hierarchies and global references. Drawing on initial ideas from previous studies, judgments describe graphs and shape rules (graph rewriting rules), hierarchy constructors are classified as rules, and architectures are derived from typing proofs.

We propose graph-reduction (GR) specifications for defining classes of pointer data structures (shapes). GR rules essentially operate as reversed graph grammar productions. We introduce context-free graph grammars to model shape types, and we present algorithms for membership testing and analyze their complexity. Furthermore, we define the relationship between levels as new morphisms. To achieve this, we extend the double-pushout approach for graph transformation to hierarchical graphs by recursively constructing pushouts and morphisms. Additionally, we introduce a flattening operation where frames at each level are replaced by their contents. The hierarchy is strict and does not permit border-crossing. In line with this, we integrate hierarchy and shapes, where edges and nodes have a hierarchical structure and shapes (context-free rules) are employed for typing hierarchical levels. Types are defined for variables that must correspond to a shape. In these works, the theory of double-pushout is redefined to accommodate hierarchy.

As a running example, we employ the airport case study. In airports, there are passengers and planes, with planes operating flights, as well as landing and taking off, transporting passengers and their luggage between airports. We simplify this example to focus on location-related classes, which define a hierarchy. Countries may contain airports, which in turn can contain planes and passengers.

This section introduces the approach to represent styles using types. We generalize the concept of style as a type using the term "shape" to characterize a class of graphs (representing instances of a style) generated from a set of graph rewriting rules called shape rules (i.e., rules that specify system typing). Subsequently, typing proofs establish a general framework based on inference rules, which can be instantiated to produce different type systems, enabling the selection of the most suitable solution for a specific purpose.

Our objective is to propose a general structure of inference rules, but due to space constraints in this paper, we directly present one possible instantiation that facilitates the handling of global references. This particular case also demonstrates how our approach is more comprehensive than hyperedge replacement, especially in terms of integrating shapes and hierarchies. Hierarchy can be treated as a strict structure in which nesting implies that elements cannot access other elements outside the same level (i.e., there are no global references). However, many programming languages allow global references, and architectural or design languages like UML make use of global references.

Definition 3.2 [Type System]: A type system TS = <A, I> is defined as a set of type judgments for axioms A and an inference rule I over judgments. A proof term is a composition of judgment names. A proof term is well typed if a typing proof exists that generates it. Here, we consider standard proof terms.

Graph terms include edges (as per definition 3.1) and variables that act as placeholders (for other graphs), connecting certain nodes (as for edges). Graphs and shape rules are type judgments. Basic types identify nonterminal symbols, and variables represent instances of nonterminals that appear in rules and in the derived graphs that use them. Types and variables are ranked according to the number of nonterminal branches.

We have presented a detailed type system for shapes with global references, but further exploration is required for other potential instantiations. With regard to shape analysis, some of the results in the related work on pointer data structures may be relevant to our approach, particularly in light of the correspondence with hyperedge replacement as stated in Theorem 3.6.