The initial step of the process involves modifying the proctype to ensure that all variables are adjusted to the size of an integer using compiler directives. Despite the introduced overhead, our performance and memory benchmarks demonstrate that this is effectively addressed (sec. 4). Section 3 details how MR can be encoded in the model.

We confirmed that our tools thoroughly examine all these models (see sec. 4). In some instances, we had to disable control flow optimization (-o3) due to its limited implementation in SPIN. The subsequent sections outline various verification strategies for these models using LTSmin and provide background information on the algorithms employed.

Symbolic model checking is carried out using the tool prom2lts-sym, which implements symbolic model checking and learns the symbolic transition relation dynamically. This approach is effective for models with high locality, as they possess a sparse pins dependency matrix. Our reordering algorithms (RGA) can further optimize these models for Binary Decision Diagrams (BDDs). Through a chaining heuristic, we are able to explore over 1020 states in a second using prom2lts-sym-RGAâ€“order=chain peterson5.prom. Counter-example exploration typically covers a large portion, as indicated in our previous work [6, sec. 4.2], and the Cndfs algorithm returns even shorter counter-examples than a parallel BFS-based algorithm [6, sec. 4.3]! Additionally, the BFS-based algorithms OWCTY and PB can be distributed on a cluster, as demonstrated by the Divine tool.