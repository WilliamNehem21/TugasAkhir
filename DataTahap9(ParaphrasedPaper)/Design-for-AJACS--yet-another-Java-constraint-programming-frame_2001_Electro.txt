The potential inefficiency of JVM implementations may appear to discourage its use for implementing other programming paradigms, particularly those focusing on relative efficiency. However, when it comes to constraint logic programming (CLP), the appeal of having a widely compatible platform seems to address the challenge of scarcity of widely used and easily installable implementations. Notably, many web browsers come with a built-in Java runtime system, regardless of the underlying hardware or software platform.

The following sections of this paper are structured as follows: Section 2 provides a formal description of the main concepts in AJACS. In Section 3, we detail the structure of the Java implementation. Section 4 delves into how we handle the exploration of a search space. Finally, Section 5 presents a comparative analysis of AJACS and other approaches, and in Section 6, we conclude and discuss planned developments.

A store is a collection of values indexed for solving a CSP, with the intention that several similar stores (in terms of the number of values) will be created, in which the set of values corresponding to the same index across all stores represents a variable.

As a store is derived from another through constraint propagation, it must contain a reference to its predecessor. In the case of the initial store, the predecessor is undefined. Each line in the store is associated with the values of a specific variable.

Values represent the possible set of integers that a variable can take on and have three internal representations: compact intervals, and two non-compact intervals. The class `Value` implements compact intervals, the class `FDDValue` implements non-compact intervals as bit sets, and the class `FDIUValue` implements non-compact intervals as a disjoint union of compact intervals.

If the object removed is one of the extremes of the interval, it will be transformed into a `FDIUValue`; otherwise, it will be transformed into a `FDIUValue`. An `FDIUValue` will be transformed into a `Value` if the interval union results in only one interval and into an `FDDValue` if all the intervals of the union have only one element. Otherwise, the `FDIUValue` remains unchanged. An `FDDValue` will be transformed into a `Value` if all the elements of the set are contiguous; otherwise, it remains an `FDDValue`.

The `Constraint` class includes an instance variable `env` that stores the environment of the constraints. This environment is populated with the constructor method of the class. The `update(s, i)` method attempts to update all the variables `env[k]`, for `k â‰  i`. The returned object is of type `status`.

The `Problem` class is implemented with three instance variables: an initial store `initStore`, a list of constraints `c`, and a list `cv` consisting of lists of `constvar`. The constructor `new` is used to create a new problem with an initial store defined by the values, and two empty lists `c` and `cv`. The `add` method is used to add constraints to the problem, updating both lists. The `update` method propagates the effects of affecting a new value to the ith variable of the store `s`, using all pairs `(c, n)` of `cv[i]` and calling `c.update(s, n)`.

Various search techniques can be defined freely by implementing a search subclass, which extends to strategies. The combination of an appropriate strategy and the next store generation enables the implementation of a range of search procedures, such as depth-first, breadth-first, and best-first. The most suitable search strategy depends on the problem, as what constitutes a solution under one search strategy may not be valid under another.