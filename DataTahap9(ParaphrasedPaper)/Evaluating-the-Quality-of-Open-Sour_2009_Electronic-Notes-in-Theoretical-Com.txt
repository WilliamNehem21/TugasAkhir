Historically, research on quality attributes was often conducted behind closed doors within organizations or by external parties using limited, proprietary methods. However, the rise of open source software has transformed this landscape by providing transparency into both software products and the processes behind their creation. Access to software source code and associated data stored in version control systems, bug tracking databases, mailing lists, and wikis now enables us to assess quality in a transparent manner. Furthermore, the abundance of competing open source projects allows for comparisons of the quality of similar systems within the same domain. By leveraging historical source code snapshots and significant events, such as bug discoveries and fixes, we can delve deeper into the causes and effects of software problems. In this paper, we present illustrative examples, tools, and techniques for evaluating the quality of open source software, and by extension, proprietary software as well.

Each of the aforementioned objectives does not represent a novel or unique tool idea. Several open source tools are available for evaluating the code quality of individual software projects by examining various aspects of the code. For example, PMD is a Java scanner designed to identify potential bugs in exception handling statements and code problems such as dead or duplicate code. Similarly, FindBugs conducts static analysis to uncover bugs in Java-based programs, and Checkstyle serves as a coding style checker for Java programs. Unlike the aforementioned tools, Sonar is a plugin metrics tool for Java that integrates various code measurement tools into a single application to provide comprehensive results. The presentation of results follows the ISO/IEC 9126 quality model. This framework oversees loosely-coupled collections of components, offering lifecycle and remote management capabilities. This design allows individual components to be replaced in the field without affecting the rest of the system, providing additional protection through a strict separation of modules within the system. The "Cruncher" component consists of the computation core, connection services for other tiers of an Alitheia deployment, and plugins that implement specific quality metrics.

The core of the "Cruncher" is a single module for OSGi, serving multiple distinct roles. This monolithic design was chosen to simplify testing and address performance concerns, as the core components are tightly coupled and are not intended to be updated separately. The connection layer includes a Java servlet container for web services and other connectivity. The OSGi framework benefits the collection of metric plugins, which can be extended, disabled, removed, and upgraded through a combination of "Cruncher" functions and OSGi functions.

Once the core has activated metric plugins for calculations, the roles of master and servant are reversed, with the metric plugins querying the core for services. The core provides two levels of data access, each with its own caching scheme, through thin and fat data services layers. While metrics can use either layer, the fat layer is recommended, as it provides more processed and cached data than the thin layer.

It is important to note that SQO-OSS is not just another metric evaluation system. Rather, it is a platform on which metrics can be developed, plugged in, and executed on projects of any size. The plans include extending and maintaining SQO-OSS to function as a digital repository for open source software research.
