An established format for proofs used by solvers for Satisfiability Modulo Theories (SMT) is suggested, which is based on the Edinburgh Logical Framework (LF). However, two challenges are identified: the validation of very large proofs, and the maintenance of compact proofs when dealing with complex side conditions on rules. To address these issues, an incremental checking method is proposed, which integrates the parsing and proof checking processes in a single step to avoid constructing in-memory representations of proof subterms. It is noted that the current lack of widespread support for proof production in SMT solvers is primarily due to the absence of a common proof format. The introduction of such a format, backed by a proof checker and defined as part of the SMT-LIB standard, is seen as instrumental in facilitating the implementation of proof production in SMT solvers and enabling the interface between SMT solvers and theorem provers.

The Edinburgh Logical Framework (LF) is seen as a suitable proof format for SMT solvers due to its inherent flexibility and support for Higher-Order Abstract Syntax (HOAS). These features are regarded as advantageous for encoding syntax with binding, which is prevalent in SMT formulas employing first-order quantifiers. Flexibility is deemed crucial for SMT solvers due to the diverse range of logical theories they support, the variability in deductive systems used to describe solving algorithms, and the early stage of development in the field. As a first step towards establishing a common logic, a common meta-logic is proposed, which would allow solver implementors to describe their axioms and rules.

Addressing the challenge of checking very large proofs, it is noted that the conventional approach of parsing textual input into an abstract syntax tree (AST) is impractical for handling these proofs due to memory limitations and the potential for stack overflow when dealing with deeply nested proofs. Furthermore, the issue of managing very large proofs is compounded when inferences must contain proofs of often implicit side conditions. For instance, the encoding of binary propositional resolution with factoring in pure LF necessitates proofs of side conditions showing that certain resolutions are valid. To address this, an approach called LF with Side Conditions (LFSC) is proposed, which allows for the encoding of side conditions in an LF-based system using a simple functional programming language.

In the LFSC approach, encoded inference rules may specify side conditions using code written in the designated functional programming language. Upon application of the inference rule, the associated side condition code is executed to verify the side condition. If the code execution fails, the LFSC type checker rejects the application of the rule. Additionally, an incremental checking judgment is introduced to handle scenarios where the verification of certain conditions is unnecessary. Overall, the proposed LFSC approach seeks to provide a spectrum of methods for proof checking, ranging from declarative (pure LF) to computational.