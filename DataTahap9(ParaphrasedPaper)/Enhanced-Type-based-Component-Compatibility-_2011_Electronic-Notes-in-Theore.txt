Research approaches for secure substitution aim to ensure reliable replaceability by using formal methods. However, the models used in these approaches are often too complex for average software developers to use, and the methods can suffer from prohibitive algorithmic or space complexity, as noted in previous studies (cf. for example [15,16]).

In contrast, industrial systems predominantly rely on simple metadata, mostly version identifiers, to manually tag components as compatible with their previous versions. However, this approach is vulnerable to fragility due to its dependence on human effort to provide accurate metadata.

At a high level, Georgas et al. utilize a model of application architecture at runtime to manage its evolution. Constraints can be specified on the policies governing the evolution (adaptation) in order to preserve chosen architectural properties. However, the work lacks concrete details about the model, the constraints, and ways to verify them.

Several research approaches have attempted to address the need for secure substitution using holistic approaches with global integrity properties [21,11]. For instance, Chaki et al. use compositional reasoning and dynamic assume-guarantee checks to provide formally sound evaluation of substitutability with practical properties similar to the contextual approach. However, most of these methods rely on advanced formal systems, such as model checking and behavioral subtyping, often supported by specialized specification notations, and they tend to suffer from prohibitive algorithmic or state complexity [16,9].

Only a few research works have focused on use in industrial component frameworks. For example, Polakovic et al. implement architectural consistency checks for a resource-constrained component model using a combination of compile-time type conformance verification and error handling code. However, in resource-constrained cases, our approach may be impractical due to its resource demands.

It has been noted that capturing the deployment environment of a specific component is useful for evaluating substitutability. This component deployment context contains other components and architectural connections within the environment in which the component is used. Our approach focuses on this area, simplifying the issue deliberately due to the challenges faced when working with industrial component frameworks, where specifications of advanced aspects are often not available or cannot be reconstructed from implementation, making semantic compatibility hard to verify.

Implementation of contextual substitutability needs to address several fundamental issues. Firstly, it must implement the element subtype relation at runtime and select the appropriate type representation for it. Secondly, there needs to be a method of extracting component types and contextual complement representation from various sources. In the following paragraphs, we will discuss our approach to addressing these issues for the OSGi case.

A fundamental issue is obtaining and representing the types of elements contained in the component specification. Typically, this responsibility is delegated to the relevant language compiler; however, in our case, a runtime component type representation is needed along with mechanisms to obtain it from both the installed and replacement components. Furthermore, in OSGi, the specification data is dispersed across several places, including the manifest file as the focal point, XML, and other additional metadata (e.g., for declarative services), and the bytecode of bundle implementation.

Besides the reasons provided in preceding sections, this design can be justified for the following fundamental reason: the method does not impose any restrictions on the types of component interface elements to which it is applied. Therefore, it can incorporate any semantic or behavioral specification compatible with our model of component types. An example of an advanced type of component interface element for which our method could be applied is the behavior protocol originating in the Sofa component model. In this case, the protocol compliance relationship plays a significant role.

Regarding further research, the formal definitions of the method should be extended to clusters of components (e.g., to support secure substitution of larger subsets of applications) and applied more specifically to inter-component relations in dynamic architectures. The practical implementation for OSGi will need to address the missing aspects of the component model and overcome the challenges of tighter integration in the frameworks.