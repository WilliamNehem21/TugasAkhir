This paper tackles the problem by incorporating the orchestration language "orc" as a domain-specific language in Haskell. The implementation involves realizing "orc" as a combinator library using lightweight threads and communication and synchronization primitives from the concurrent Haskell library. This implementation allows the creation of orchestrations that can reuse existing Haskell code and, conversely, can be reused within other Haskell programs.

The complexity of distributed computation necessitates the identification of efficient, reusable, concurrent programming patterns. The paper explores how the calculus of recursive schemes, commonly used in deriving functional programs, can be scaled to a distributed setting. Specifically, it illustrates how the entire class of binary tree hylomorphisms can be parallelized.

In the current landscape of software composition, there is a need to manage not only the complexity of constructing and deploying large applications within time and budget constraints, but also to handle the open-ended structure of autonomous components, potentially distributed and highly heterogeneous. The widespread presence of concurrency, from the perspectives of distribution and parallelism, calls for new approaches and languages for dynamically composing interacting software.

By implementing "orc" as a domain-specific language in Haskell, it becomes accessible to a wide community of users and developers. For instance, one of the motivations for developing horc was to enable the coupling of an "orc" animator to coorinspector, a tool for extracting coordination scripts expressed in "orc" from legacy code. horc facilitates the validation and potential transformation of such scripts.

Furthermore, the paper introduces the concept of primitive sites, which may return values for use by other site calls. These values are published by the site calls, and due to the need for generality, site calls have flexible semantics. Additionally, the paper discusses the abstraction of common sub-expressions through functions, as well as the use of a function to count the number of threads that are yet to finish.

The paper also investigates the composition of the "prune" operator, demonstrating how it is composed of two steps and detailing its behavior in different scenarios. Additionally, it showcases examples implemented in horc, including the solution to the eight queens problem and the expression of more general programming patterns such as hylomorphism and other implemented patterns like mapreduce and workflows.

Finally, the paper explores a generalized type of binary trees that replaces the recursive part with an additional type variable, and delves into the use of threads and communication primitives, as well as the semiexplicit parallelism provided by the gph approach. It positions horc as a higher level than using pure threads while still having fixed task division.