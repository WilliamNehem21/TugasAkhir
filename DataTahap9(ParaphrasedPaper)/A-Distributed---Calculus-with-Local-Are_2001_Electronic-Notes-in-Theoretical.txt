Introducing levels serves to differentiate between various modes of concurrency and communication within a single system. For instance, within a host, there may exist multiple applications, each represented at the "app" level, while communication between a host and a network could occur at the "subnet" level. By establishing a total order of levels, we can succinctly express the distinct nature of communication between different entities, such as threads within an application versus hosts on a network.

In definition 2.3, a process "p" is considered well-formed at level "l" if, for every top-level agent "m[q]", the level of "m" is less than "l", and "q" itself is well-formed at level "m", recursively. Similarly, an agent "l[p]" is well-formed if "p" is well-formed at level "l".

In certain cases, a single name may have multiple separate local areas within its scope. Additionally, a name can exist outside any local area of the appropriate level, in which case it can only be treated as data and cannot be used for communication. The operational semantics and proposed type system are designed to enforce this behavior.

The type service for "finger" and "daytime" expands to "(string@net)@host". This indicates that the channels can only be used for host-level communication, but the values carried will themselves be net-level names. The host-level communication occurs between "inet" and "finger" or "daytime", while the net-level communication involves the response sent out to the original enquirer, for example, the machine "carp".

The local area calculus offers a suitable framework for examining the use of names that are globally known but function locally. We have presented an operational semantics and demonstrated that it accurately captures this concept. Examples illustrating this include an internet service protocol and a pair of distributed agents.