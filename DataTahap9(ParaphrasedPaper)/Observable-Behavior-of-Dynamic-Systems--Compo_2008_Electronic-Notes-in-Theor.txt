To better capture the context of interacting distributed components, we utilize the concurrency and communication model of the creol language, which is based on concurrent objects, asynchronous method calls, and processor release points. This model restricts access to the internal state variables of other objects, where each concurrent object has its own execution thread. Processor release points affect the implicit internal control flow in objects, reducing the waiting time for replies to method calls in a distributed environment and enabling objects to dynamically switch between active and reactive behaviors (client and server).

The paper is structured as follows: Section 2 introduces and informally explains the language. Section 3 describes class invariants for observable behavior, Section 4 covers the language semantics, and Section 5 presents the derived proof rules. Section 6 provides an example, Section 7 discusses related work, and Section 8 concludes the paper.

In the creol language, the state of an object is built from the parameters and attributes of its class, with read-only access to class parameters. Objects do not have access to the attributes of other objects, and all methods are assumed to be available to the environment except for the special methods "init" and "run." The "init" method is used for object initialization, invoked immediately after object creation, while the "run" method, if provided, is called after initialization. After initialization, the remaining methods reflect passive or reactive object behavior, with "run" initializing active behavior.

In the asynchronous setting, objects can send messages at any time, and type checking ensures that only available methods are invoked for objects of given types. The run-time system guarantees unique identifiers for generated objects. Assuming type correctness, well-formed histories satisfy a well-formedness predicate, where completion messages can only occur after the corresponding invocation message in the history.

In nonterminating systems, specifying and reasoning compositionally about object behavior poses challenges. Instead, pre- and postconditions to method declarations are used to establish class invariants, ensuring the conditions hold after initialization and are maintained by all methods at processor release points. Class invariants serve as a contract between the different processes of object instances, facilitating reasoning about programs based on internal state and observable behavior.

In the asynchronous setting, objects can autonomously decide to send messages, which may arrive in a different order than sent. The invariant should restrict messages seen by an object but allow the existence of additional unprocessed input. The paper intends to extend the approach to combine processor release points, multiple inheritance, and history-based compositionality in future work. Adaptations to proof systems for active objects communicating via asynchronous method calls will be explored for larger programs.