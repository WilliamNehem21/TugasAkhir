While it is possible to manually write Java code for an artificial environment, the preferable approach is to automatically generate it from a high-level model of its behavior, which can be written by hand or constructed automatically based on the behavior of the component that is being checked. This paper focuses on efficiently detecting concurrency errors (such as deadlocks and race conditions) in Java components using the Java Pathfinder Model Checker (JPF). The primary challenge lies in determining the behavior of the artificial environment to enable JPF to identify concurrency errors without running out of memory or exceeding a reasonable time frame due to state explosion. The paper emphasizes that state explosion is mainly caused by a high number of parallel threads in the program and does not focus on big data domains.

The paper presents a method for executing a component's behavior for a finite number of times and in parallel with other method calls, allowing JPF to identify all errors. However, using such an environment may lead to state explosion due to the high number of parallel threads, even when employing well-known approaches to address state explosion. The paper outlines a process to construct a model for detecting concurrency errors, which involves analyzing control-flow graphs of methods and identifying shared variable accesses in the code.

The approach suggested in the paper is evaluated through experiments conducted on two real-life Java components: the ConcurrentHashMap class from the implementation of the java.util.concurrent package in GNU Classpath and the Daisy file system. The results of the experiments are measured in terms of the total time and memory required by JPF to find errors.

The paper suggests that using ordered pairs or ordered lists with specific combinations of values of the Static Variable Access (SVA) metric parameters that favor extreme sharing would be the most effective way to detect concurrency errors. However, it acknowledges that the SVA metric is heuristic-based and might not yield the best results for all components. Furthermore, the paper notes that while several approaches exist for measuring the complexity of concurrent programs in Ada, none of them can be used instead of the SVA metric for modern object-oriented programming languages like C++ and Java.

The proposed technique in the paper, although specific to Java components, can be adapted to other programming languages such as C or C#, provided that a model checker supporting verification of multi-threaded programs in the respective language is available.