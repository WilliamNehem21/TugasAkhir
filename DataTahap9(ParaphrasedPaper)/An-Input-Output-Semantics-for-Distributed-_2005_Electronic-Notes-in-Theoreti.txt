A compilation of laws for Occam was presented, focusing on achieving normal forms and defining the semantics of notation rather than simplifying via communication elimination. Similarly, laws for SPL are provided, incorporating an SPL semantics based on fair transition systems, but omitting communication elimination laws. Within the framework of SVL++, laws are presented but are deemed insufficient for communication elimination.

The concept of combining SPL module and procedure was introduced as modular procedures, allowing for parallel composition and invocation by procedure reference statements explicitly specifying the interface channels and variables. The names of all interface channels and variables are explicit in procedure reference statements, with common variables prohibited. The notation "r::= p(p)" represents a procedure reference, with "r" and "p" denoting the result and parameter lists of the interface, and "p" representing the procedure name. Modular procedures are simplistically referred to as procedures in this context. An example of a procedure, along with its procedure reference and body, is provided.

The distinction is made between variables (such as "r" and "p") and channels (such as "cr" and "cp"), where "r" and "cr" represent the results, and "p" and "cp" denote the parameters of the procedure. The declaration at the head of a procedure body is frequently omitted within this work. Furthermore, the allowance of common variables or channels is not permitted. A channel variable records a triplet consisting of the value passed at a communication event, a count reflecting the order of the channel event, and an input/output mark (i/o). In the case of internal events, a dot replaces the input/output mark. Extensions to this notion, such as input/output computation (IO-computation), are introduced to record the value histories of both variables and channels during execution.

The paper introduces the extension of SPL notions, such as input/output computation records, and describes computation rows and sublists used in the execution of procedures. Attention is then turned to communication selection and bounded communication statements, with a focus on the finite and constant number of communication events generated by the execution of bounded communication statements.

The subsequent section aims to outline laws that facilitate the elimination of communications from bounded communication statements, with additional coverage of communication elimination for extended forms, including indefinite iterations. The laws to be detailed enable the elimination of communications from bounded communication statements by defining a set of internal channels within the statements whose communications need to be eliminated. The remaining channels involved in the statements are external, with communications over these channels never coinciding with other communications within the statements.

The article concludes with an example program that illustrates the essential behavior of a pipelined processor software model, interpreting programs with ALU register-to-register instructions. The program includes references to procedures with inner parallelism and provides insight into the processor's interpretation of ALU operations and instruction registers.