This paper introduces a framework for interchangeable distributed algorithms, focusing on mutual exclusion, deadlock detection, and agreement protocols. The framework includes a library of algorithms, a framework for integrating them into new or existing systems, and a tool for evaluating performance. The goal is to isolate the complexity of distributed systems into separate components, allowing programmers to select the most suitable algorithms based on performance for a given application. The paper describes the framework's architecture in detail, with a case study on distributed deadlock detection, and discusses the challenges in making the middleware layer interchangeable. It also addresses the need for central monitoring and control of system activity, as well as the robustness of the system in handling failures. The paper emphasizes the importance of separating concerns in distributed applications and highlights the potential for the framework to adapt to new middleware technologies.

The framework categorizes algorithms into classes such as mutual exclusion, deadlock detection, agreement protocols, resource management, and failure recovery. It notes that algorithms within a class share similar methods, allowing for a unified interface that simplifies algorithm replacement without modifying the application itself. The paper also discusses the challenges in making the framework middleware-independent, especially in handling remote invocation failures, exceptions, and inheritance structures. It outlines a tool, algonrmic, for generating middleware-dependent proxies for algorithms, and suggests that the framework could be extended to support other types of middleware.

Additionally, the paper reflects on related work, emphasizing the unique aspects of the framework, and discusses future directions, including implementing a wider range of algorithms, extending support for interchangeable middleware, and enhancing performance visualization capabilities. The research presents practical insights into software composition, the impact of language features on system design, and evaluating complex systems at runtime.