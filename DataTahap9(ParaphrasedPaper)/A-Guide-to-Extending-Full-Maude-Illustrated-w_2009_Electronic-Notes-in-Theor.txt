The primary objective of this paper is to act as a practical manual for implementing enhancements to Maude by providing an overview of the development of the real-time Maude tool through an extension of the full Maude implementation. After summarizing the key features and structure of the full Maude implementation, the paper proceeds to describe the implementation of the real-time Maude language and tool, addressing critical aspects such as incorporating new types of modules, rules, and commands, as well as the need for additional information storage in the persistent state of the execution environment.

The success of Maude in modeling and analyzing concurrent systems has driven and will continue to inspire the development of extensions for various system types (e.g., real-time, probabilistic, stochastic, hybrid systems) and new analysis techniques for ordinary and extended Maude specifications (e.g., inductive theorem proving, narrowing analysis, TLR model checking, timed analysis, probabilistic analysis, etc.). The intention of this paper is to offer a practical guide for implementing Maude extensions by demonstrating the development of the real-time Maude tool through an extension of the full Maude implementation.

The Maude system provides robust meta-programming capabilities, which enable the development of execution environments for a wide array of languages and logics with significantly less effort than using conventional programming languages. Early application of these capabilities resulted in the implementation of full Maude, a language that extends Maude with support for object-oriented specification and advanced module operations. The full Maude implementation encompasses code for parsing user input, pretty-printing, module and theory storage, transformation of object-oriented modules, and more. As a result, when implementing an extension of Maude, there are essentially two options: extending the implementation of full Maude or creating a new implementation from scratch.

Our confidence in the convenience of building Maude extensions by extending the full Maude implementation has been reinforced by the recent development of tools that have followed this approach. They include the Church-Rosser and coherence checkers for Maude, the Maude MSOS tool for modular structural operational semantics, the automated circular coinductive prover CIRC, the strategy language proposed in a particular publication, and the implementation of membrane systems in Maude. Additionally, parts of the infrastructure provided by the full Maude implementation have been utilized for implementing tools for formalisms that are not extensions or variations of Maude, such as the LOTOS tool by Verdejo. It is also noteworthy that there are formal tools for Maude, written in Maude, that are not implemented on top of full Maude, such as the ITP and the SCC.

This paper does not aim to present a general methodology for extending full Maude but instead provides a guide based on our experience. The choice of focusing on real-time Maude is motivated by its being a mature and significant extension of full Maude, incorporating additional module syntax and numerous new analysis commands. This paper assumes familiarity with the Maude language, including its meta-level features.

Regarding the reasons for not wanting to extend full Maude directly, it is acknowledged that the implementation of full Maude is indeed complex. The purpose of this paper is to provide an overview of this implementation and offer a solid starting point for extending it, with detailed information available in specific references. Furthermore, one of the main issues with full Maude has traditionally been its lack of robustness. However, this paper demonstrates how full Maude allows for the creation of robust implementations that provide informative error messages without requiring a complete restart of the Maude session.

To gain a comprehensive understanding of different aspects of writing an interpreter and of the full Maude implementation, we have found it valuable to build an interpreter for a small subset of Maude from scratch using the techniques presented in specific sections of literature.

Real-time Maude extends full Maude by offering a library of predefined modules (e.g., for time domains) for importation by user-defined modules, introducing new types of modules and rules (tick rules), and adding extra analysis commands. Additionally, the tool must store certain additional data, such as a term of sort term, and return its representation as a list of quoted identifiers. Although this term could be manipulated directly, it is simpler and more appropriate to transform it into another term in a data types module, command, etc.

When interacting with the system, it is essential not only to issue commands or module expressions with specific arguments and obtain results but also to be able to store modules, theories, and views in a database for later reference when evaluating module expressions and commands. The full Maude specification encompasses a data type database for managing the database of modules, theories, and views. Additionally, most commands are assumed to be executed on a by-default module, usually the last entered module, which needs to be tracked as part of the persistent state of the system.

The parsing accomplished in the in rule only deals with the top-level syntax, and errors may still be present. While some errors can be detected when analyzing the different declarations in the module, others will require processing once the signature is completed and the bubbles can be processed. To report these errors, one of the components of the database constructor will store such messages. Furthermore, all objects in the rules handling the database are given using a variable of sort databaseclass as class, allowing the definition of subclasses of class databaseclass to add extra attributes to the persistent state as detailed in a particular section for real-time Maude.

The evalpremodule function initially normalizes the module structure by calling the normalize function and then collects all the subunits in the structure to build a single flattened module. This module is then used to create an initial version of the signature, with all the bubbles in the top pre-module parsed using the solvebubbles function. The final signature version and the flat unit are generated once the bubbles have been parsed.

The procrew function processes the rewrite command, and after parsing the bubbles in it, the metarewrite function is invoked. The function solvebubblesrew addresses the complexities of solving the aforementioned problems and returns a tuple consisting of the module in which the command is to be executed, the parsed term to be rewritten, the bound on the number of rewrites (or unbounded if the command did not specify a bound), and the set of variables in the module for executing the command. From this tuple, the term, module, and bound are obtained, and the actual rewriting is performed by calling the function metarewrite.

The approach for commands like rew is similar. The current module is first recompiled if necessary, and then solvebubblesrew is used to extract the module in which the command is to be executed, the term representing the initial state, and the bound on the number of rewrites. Additionally, the bubbles representing the time limit and the current tick mode in the module are parsed. Once these steps are completed, the command is executed using the timedmetarewrite function, the timed version of the metarewrite function, defined as an ordinary Maude function on Maude meta-modules and meta-terms.

In this paper, we have presented a practical guide to significantly extending full Maude, drawing on our extensive experience in developing various extensions and communicating their concepts to others. A high-level overview of the structure, main functions, and modules of the comprehensive implementation of full Maude has been provided, along with an explanation of how to extend this implementation by outlining the implementation of the real-time Maude tool. Real-time Maude expands the syntax supported by full Maude by incorporating real-time modules and theories, tick rules, and a range of commands for manipulating and analyzing real-time systems.