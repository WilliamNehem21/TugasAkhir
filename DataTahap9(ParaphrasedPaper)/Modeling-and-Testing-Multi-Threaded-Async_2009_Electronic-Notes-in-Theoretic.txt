This academic paper explores the intriguing field of modeling concurrent systems and testing multi-threaded implementations against the model. The work presented focuses on constructing and executing test cases for a large-scale multi-threaded application using a model expressed in the creol modeling language. The paper also discusses maintaining structural similarity between creol models and the finished implementation when repurposing them as test oracles, as well as introducing a conformance relation between the model and the system under test that requires less controllability than other relations based on automata.

While formal testing of single-threaded programs benefits from a robust theoretical foundation and industrial experience, formal testing of multi-threaded or distributed systems remains an ongoing area of research. The paper describes efforts to model a concurrent system and test it against the model.

The testing approach is validated through a case study involving "ask," an industrial software system designed to connect people via a context-aware response system. A significant portion of the ask implementation, primarily written in C, has been modeled in creol. The ask system is inherently multi-threaded and utilizes asynchronous communication.

The paper is structured as follows: Section 2 provides an overview of related work in formal testing, followed by an introduction to the creol modeling language in Section 3. Section 4 presents the ask system, with a detailed presentation of the approach provided in Section 5 based on a case study. The conclusions and potential future work are discussed in Section 6.

In the application discussed, the components are asynchronously linked, with input actions from the environment placed in a queue and processed in an order determined by the implementation, eventually emitting input events. The test verdict is determined by observing the interleaved input and output events.

Each object has its own object-internal scheduler, and there are no assumptions about the order of process execution in a standard setting. Processes in creol do not use preemption, but instead employ explicit conditional suspension points in the form of await statements to release a process and allow another process to execute. This cooperative scheduling, while potentially inefficient for a production language, offers significant modeling benefits by making scheduling points explicit and facilitating race condition detection.

The characteristics of creol make it well-suited for modeling distributed systems, where objects represent system modules communicating through defined interfaces. Methods are annotated with a co-interface to restrict possible callers and enable call-back using the caller variable. The prove statement and invariants on methods allow for runtime condition checking.

In the context of testing, a run of the system under test (SUT) is initiated, and the resulting behavior is evaluated against expected outcomes. For synchronous systems, a test graph can be constructed to link inputs and outputs, guiding the selection of new inputs to achieve specific test goals.

Actions in testing stimulate the SUT and model, while events indicate occurrences within the system. The paper discusses how the asynchronous nature of these systems can lead to different event timings and method execution orders.

A test is considered successful if the model successfully handles the same trace as the implementation and if all model assertions and invariants are true. A violated assertion indicates an inconsistency in the model, rendering any verdict about the implementation unreliable. Deadlocks during parallel execution of the tester and model signify a violation of test assumptions by the implementation, leading to a failed test.
