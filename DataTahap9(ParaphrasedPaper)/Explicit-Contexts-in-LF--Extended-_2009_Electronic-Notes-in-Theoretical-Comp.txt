When formalizing meta-theorems in twelf, challenges may arise due to the hypothetical interpretation, particularly in settings involving dependent types. Theorems concerning a distinguished bound variable (such as substitution or functionality) cannot always be directly proven by induction. In the subsequent section, we demonstrate the complications that can emerge in such scenarios.

The paper is organized as follows: Section 2 highlights the issues related to distinguished bound variables and dependent types. Section 3 provides a formalization of explicit contexts in LF and presents a usage example. Sections 4 and 5 detail the process of converting derivations between implicit and explicit contexts. Throughout the paper, it is assumed that the reader is well-versed in LF and twelf.

It is worth noting that the proof presented in this paper is an illustrative example rather than a motivating one. Although substitution is primitively provided in LF by function application, the theorem pertaining to it can be trivially proven non-inductively. Nevertheless, we chose this example for its simplicity. In section 2.2, we briefly present some motivating examples.

The proof is successful because we are able to alter the order in which the bound variables x and y are handled. Initially, y falls within the scope of x. However, during recursion, y is moved outside while x remains bound by the theorem itself.

The explicit context method developed in this paper offers a systematic, consistent, and reliable approach to address these challenges. Ad hoc solutions exist for the first two examples, but none are published at the time of writing. Additionally, for the narrowing example, Pientka has demonstrated that the difficulty can be bypassed by reformulating the LF encoding.

Regarding explicit contexts, an important observation is that the syntax encoding need not be altered at all. This is crucial as it allows explicit-context developments to coexist with conventional implicit-context developments. Thus, the syntax of terms and types remains unchanged.

In fact, whether the language in Twelf is dependently typed is determined by whether exp is subordinate to tp. Twelf infers the subordination relation from the signature, and either the p or pi declaration is sufficient to add the desired edge. The explicit context method would function similarly for any other formulation of dependent types that induce that edge.

The context formation judgment also checks another important property: the requirement that each variable appearing in the context is distinct. This is essential for ensuring that looking up a variable in the context returns a unique type.

Using the rule for typing b is convenient, as it happens to be closed. More significantly, we utilize it to import assumptions from the implicit-context setting into this explicit-context setting. This is crucial because we aim to shift into the explicit-context method at any point in a proof, not only when the implicit context is empty. Formally, this is reflected in the worlds declaration for our lemmas, allowing bind blocks as well as ovar blocks.

The main contribution of this paper is the demonstration that we can convert from implicit to explicit form. Once achieved, we can conduct a proof using explicit contexts (section 3.4) and then convert back to implicit form (section 4), thereby obtaining a general result with no reference to explicit contexts.

The proof is conducted by induction on the term m (not on its typing derivation). The variable case (i.e., when the second argument is ([x][d] d)) employs ofe/var and the provided lookup judgment. The closed case (i.e., when the second argument is ([x][d] d), where d does not depend on d) is trivial, using the ofe/closed rule. The of/app case is a straightforward invocation of induction.

Returning to the of-lam case of cut-of, two final observations can be made. Since the case involves two recursive calls, with the second operating on the result of the first, it is not feasible to conduct this proof by induction on derivations. Instead, we carry out the proof by induction on the term itself, which remains unaffected by the processing of typing derivations.