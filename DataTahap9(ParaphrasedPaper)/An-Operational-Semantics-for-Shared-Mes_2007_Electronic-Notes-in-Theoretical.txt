To achieve optimal performance, contemporary computer applications are typically run on networks of (multi)processors. Applications with high data rates, such as digital signal processing, are best implemented using micro-architectures that utilize shared memory for interprocess communication. However, programming with shared memory requires explicit management of data access and integrity, as failure to do so can lead to erroneous computations. On the other hand, message-passing architectures mitigate such errors by disallowing shared address space and by clearly separating computation and communication. Nonetheless, message-passing incurs drawbacks such as increased data latency and redundant data transfers.

In shared messaging communication, a token writes its data to the allocated memory region and then sends the token to the target node using message-passing. Upon receiving the token, the process reads or writes to the assigned memory region and either forwards the token to another node or releases it. In cases where the volume of data transferred is substantial compared to the overhead of token management, the overall performance of shared-messaging communication can be significantly better than direct data communication.

Shared memory communication (SMC) facilitates system-level design by abstracting certain features of implementations to a level amenable to formal verification. By using SMC, one can move beyond purely qualitative behavior descriptions and make quantitative assumptions about the underlying mode of data transfer relying on shared memory.

In SMC, each node operates on its private memory space, while communication between processes is based on shared memory, affecting the shared memory of the entire region. The semantics of SMC are given in two layers, where the semantics of single nodes are first defined, and then the semantics of regions are based on that.

The semantics of the commands in the grammar for SMC programs is standard, and assumes familiarity with its presentation by a set of rules. Concurrent assignments and non-scalar data structures may be assumed due to the unspecified expressions and locations. This modeling neglects a key property of SMC, namely that not all data written to shared memory by a source process is necessarily accessed by the target process. However, the emphasis of the modeling is on the administration of tokens, so a refined model is not provided in this context.

For applications with high data rates, shared messaging communication can be feasibly employed in the final implementation. Formal proof is provided in this section that any program using message-passing as a communication mechanism can be rewritten as an SMC-program such that the two programs are weakly bisimilar, showing that the non-deterministic structure of the message-passing program is preserved by the translation.

Ultimately, SMC may be seen as efficiently implementing message-passing for high data-rate applications, aligning with certain micro-architectural designs. SMC provides a new communication model that is transparent to the programmer, offering support for portability and reusability of software within a specific class of micro-architectures.