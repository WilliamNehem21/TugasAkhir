Object-oriented programming languages provide a powerful way to develop software in a modular fashion. They enable code reuse and management through mechanisms like inheritance and encapsulation, which allow program modules to share information while hiding implementation details. However, this characteristic necessitates new formal approaches for reasoning about and verifying object-oriented programs.

The rest of this paper is structured as follows: the next section defines the syntax and semantics of a C++-like language used in this paper, particularly focusing on class inheritance and method overriding. Subsequently, the paper introduces separation logic for this language, including the storage model that represents program states, the assertion language and its semantics, and the verification rules. The paper then presents the approach of enforcing behavioral subtyping, followed by an example illustrating the model for verifying multiple inheritance. Finally, the paper summarizes with related and future work.

To maintain simplicity, the paper excludes other features of C++ that are of less interest, such as arithmetic expressions and certain language constructs. These features will be gradually incorporated into the concern in future work towards the practical implementation of this system.

For the remainder of the paper, the following conventions are used: C and D represent class names with appropriate subscripts, F and M represent class fields and methods, and X (and sometimes Y) represent general variables. Additionally, the i-th component of a tuple A is denoted as A.i.

The paper emphasizes the promotion of dynamic polymorphism, which can lead to ambiguity when referencing object fields. To address this issue, the paper introduces the notion of inheritance class C : C1, ..., Cn and an object X typed C to handle such cases.

Separation logic, as introduced, focuses on reasoning about aliases and shared mutable objects. Since both aliases and sharing occur on the heap, the paper discusses the necessity of incorporating the heap into the storage model. Unlike classical hoare logic, where variables are accessed based on the stack, the model in this paper includes both heap and stack components. The paper also discusses the inclusion of auxiliary variables, which are not part of the storage but are helpful in describing program states and specifications. These variables are not type-specific and are designed to capture suitable values from both the stack and the heap.

The paper notes that the model of the heap slightly differs from classical separation logic to facilitate multiple inheritance. This design choice is made to account for cases where a class inherits many fields with the same name from its ancestor classes, necessitating both the name of the field and the actual containing class. Additionally, the paper replaces the assertion emp with the assertion X = null to express an empty heap and specify that a variable owns no corresponding allocated heap, providing a more accurate representation without dangling pointers.

The paper introduces two rules of assignment using an auxiliary variable X instead of traditional assignment rules with substitution in assertions. The auxiliary variable can be eliminated later in a proof. It is emphasized that an assignment changes the heap location that a variable points to.

Moreover, the paper presents a rule to ensure that a method is defined in the correct class C, followed by checking if the method body aligns with the specification {P} S {Q[X/ret]}. This specification is then added to the static environment to support potential method invocation, as depicted in a subsequent rule. The paper also discusses the concept of behavioral subtyping to ensure that each overriding method C.m(X) has a specification compatible with its counterpart in the superclass, D.m(X).

The paper provides an example to illustrate the extension of separation logic for the verification of object-oriented programs with multiple inheritance. It condenses the syntax of C++ to a core and establishes a storage model based on canonical separation logic, proposing verification rules according to this model and considering behavioral subtyping for runtime type decision.

Additionally, the paper mentions prior work by Parkinson, who introduced separation logic for Java program reasoning and abstract predicate families. The author intends to follow a similar route to construct another extension of separation logic for a more general case of class inheritance, particularly in situations where inheritance chains might have intersections, differing from single inheritance in both syntax and semantics.

Some future work includes implementing the extension of separation logic by adding more features of C++ to the language, such as stack variables for basic data types, arithmetic operations, and access control. These features will be combined with the model and rules to develop (semi-)automatic reasoners for implementation.