In relation to the topological theory of distributed computing, we will discuss theorem 3.6 in the context of representing protocol executions in the iterated model and the extended ifsc model. It is established that protocol complexes in the iterated shared memory model are connected, leading to the impossibility of solving consensus. However, in this paper, we contend that protocol complexes in the ifsc model are disconnected, yet still unable to solve consensus. The discussion on theorem 3.6 can be found in section 3.

Each process pi's state machine models a local protocol ai, dictating the steps taken by pi. It is assumed that all local protocols are identical, i.e., processes share the same state machine. A protocol comprises a collection a of local protocols a1, ..., an. This paper focuses on protocols in the iterated read/write shared memory model of distributed computing, hereon referred to as the basic iterated model. For simplicity, protocols are defined using pseudocode, and the following conventions are established: a lowercase variable...

One might perceive the defined iterated model as overly restrictive, as a process cannot revisit and reread the same shared array, and all processes must access shared arrays in the same order. Consequently, it may appear to lack generality when compared to the more standard, non-iterated wait-free shared memory model, which does not impose such restrictions on protocols. The pivotal question arises: does a task exist that is solvable in the wait-free standard model and unsolvable in the iterated model? The answer is no. Any task feasibly solvable in the wait-free standard model is also achievable in the iterated model. This is validated by an algorithm that simulates the standard model in the iterated model, as previously demonstrated. Hence, considering only protocols in the iterated model does not compromise generality for computability purposes.

The concept is closely linked with the notion of a span in [19, definition 4.4, page 884]. Herlihy and Shavit define the protocol complex as a larger geometric structure dependent on all possible input values of processes and all possible executions of protocol a. However, for most cases, working with the provided definition of protocol complex suffices. The defined approach is deemed sufficient for the introductory purposes of this paper.

The safe-consensus task is a result of relaxing the validity condition of consensus. Initially proposed by Yehuda, Gafni, and Lieber, they employ it to demonstrate that the g-tight-group-renaming task is as potent as consensus for g processes. New objects are introduced to expand the basic iterated model.

It is evident that safe-consensus shared objects are more powerful primitives than read/write shared memory. This is substantiated by the authors' presentation of two protocols that solve the consensus problem for n processes in a distributed computing model extending the standard shared memory model with safe-consensus objects, without any restrictions on the processes' usage of the safe-consensus objects. This affirms the equivalence of the safe-consensus task and consensus. It is noteworthy that, in this paper, the usage of safe-consensus objects is governed by imposing certain rules on the processes' invocation of the shared objects.

On incorporating the capability to use safe-consensus objects into the basic iterated model, the primary query that arises is: how does the protocol complex in the extended model behave? Do the topological properties remain unaltered? To address this, the first step necessitates a formal definition of the protocol complex for protocols in the new ifsc model. If a is a protocol in the ifsc model for n processes, the protocol complex sa of a is defined similarly to how we defined protocol complexes in section 2.3, with the only alteration being the view associated with a vertex. A vertex of sa is a tuple v=(i, smi, val), where i represents the id of process pi, smi denotes the local state of pi, and val denotes the return value of the safe-consensus object invoked by all processes.

Considering the case of n=2 processes, according to theorem 3.2, consensus of 2 processes ((2, 1)-set agreement problem) is resolvable with safe-consensus objects. As observed in this section, the protocol complexes of protocols in the ifsc model are disconnected, prompting an expectation of being able to solve consensus in this model. However, our subsequent results dispute this.

Proof of the lemma for l=1 suffices, as the general case follows easily from this instance. Let us suppose, without loss of generality, that s=s0 is v-valent, and sj=sl is vj-valent (v â‰  vj). Since s is v-valent, in every execution starting from s, at least one process outputs v. As per the agreement condition of consensus, all processes must output v as the consensus value, a principle also validated for sj, replacing v with vj. Let r denote the round number of both s and sj (this holds, as s and sj are adjacent, indicating they must share the same round number, which is part of the local state of each process). Consequently, uniting the lemma...

We have delineated the iterated model of distributed computing, an invaluable tool for understanding and analyzing distributed systems. Additionally, we have illustrated how protocol runs in this model can be depicted using simplicial complexes, and presented standard tools (e.g., connectivity of states, valency, etc.) commonly employed for investigating distributed systems. Furthermore, we have expounded on the set agreement task, an essential problem in distributed computing.

To showcase the potential achievements through the iterated model and the topological approach, we have introduced the iterated shared memory with full safe-consensus objects (ifsc) model, extending the basic iterated model using the safe-consensus task. We have detailed the analysis of protocol complexes in the ifsc model, revealing them to be globally disconnected. We have explained why local connectivity between certain pairs of vertices of the protocol complex suffices to establish the unsolvability of consensus in the ifsc model. Thus, it becomes evident that connectivity of the protocol complex (which relates to the concept of non-distinguishable states) is indeed fundamental in the study of distributed computing.