The section provides a brief introduction to the concept of graph transformation with cloning, followed by a description of the problem of flattening statecharts. The proposed approach involving graph transformation with cloning to address this problem is presented in Section 4. The paper concludes with a summary of the findings.

The concept of graph transformation with cloning is informally introduced in this section, with details available in another source. The approach involves defining rule schemes that represent an infinite number of rule instances by cloning specific subgraphs. Prior to describing the rule schemes, the paper explains the graphs that form their left-hand sides and right-hand sides.

A rule scheme is described as a double-pushout rule with left-hand side (LHS), interface, and right-hand side (RHS) as patterns, utilizing pattern morphisms extending graph morphisms. The RHS's cardinality variables must also occur in the LHS. A rule instance is presented as another double-pushout rule, and a rule is obtained by binding the RHS variables to the same values as those of the LHS and instantiating LHS, interface, and RHS.

The aforementioned rule schemes are introduced in Section 2 for specifying individual transformation steps. These schemes need to be combined with a control program to form a comprehensive algorithm for flattening hierarchical statecharts. The control program is informally notated rather than presented in an existing language, as the focus is on rule schemes and their programming implications within the graph. The flattening process needs to be repeated due to the potential presence of multiple and-states in the graph, with nested and-states being flattened from the inside out. This process aligns with the algorithm outlined in Section 3.

Application conditions ensure that the and-state under consideration does not contain any and/or or-states. This fundamental rule, essential for space constraints, is not detailed here. The control program attempts to apply the rule "mark bottom level and," then continues if the rule fails, indicating the absence of a bottom level and-state.

The paper presents the flattening of hierarchical statecharts as a case study for programming using graph transformation. Due to space restrictions, the treatment of simplified statecharts is limited, omitting concepts like history states, final states, firing conditions, transition actions, as well as the enter and exit actions of hierarchical states. However, these concepts can be straightforwardly incorporated, with a complete specification to be provided in the future.