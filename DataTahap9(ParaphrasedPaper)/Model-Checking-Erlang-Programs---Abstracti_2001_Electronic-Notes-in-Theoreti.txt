In this paper, an approach for verifying Erlang programs using abstract interpretation and model checking is presented. In prior work, a framework for abstract interpretations for Erlang was defined, ensuring that the abstract operational semantics preserves all paths of the standard operational semantics. Properties that must hold on all paths of a system, such as properties in Linear Temporal Logic (LTL), were considered. If these properties can be proven for the abstract operational semantics, then they also hold for the Erlang program. Automated proof using model checking is feasible if the abstract operational semantics is a finite transition system. However, for finite domain abstract interpretations, infinite state systems are obtained, making model checking undecidable. To address this, an abstraction of the control flow, replacing recursive calls in non-tail positions with jumps to the last call of the same function, is defined. The corresponding returns are replaced by jumps to the possible return points.

The abstraction only yields a finite transition system for a subclass of Erlang programs called hierarchical programs, where recursion is only allowed in tail positions. A technique for abstracting the context-free structure of functional programs to a regular one is defined to obtain a finite state transition system. The paper also introduces the syntax and operational semantics of a core fragment of Erlang, the framework for abstract interpretation, and its associated restrictions. Additionally, a graph semantics is presented as the basis for the abstraction, and the idea of the abstraction is motivated and formalized.

The paper explains that the technique of abstract interpretation can be applied to the Erlang semantics, but the strict functional programming language, extended with concurrently executed processes, presents challenges in identifying and modifying critical calls and returns of processes within the core Erlang term. The paper introduces a kind of call-string approach on the program level, where calls and returns are replaced by jumps, with detailed explanations and examples. The benefits and practical implications of using the proposed abstraction for verifying Erlang programs with model checking are discussed, and the potential integration of model checking in the Erlang verification tool is highlighted.

The authors also discuss the possibility of implementing the approach as a translation to Promela, the specification language of SPIN, as well as the integration of model checking in the Erlang verification tool. Finally, the paper concludes by stating that the presented technique can be considered for the formal verification of real systems implemented in Erlang, and it can contribute to improving the efficiency of verification processes.