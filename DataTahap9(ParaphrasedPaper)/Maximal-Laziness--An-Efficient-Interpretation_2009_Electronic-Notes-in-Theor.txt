Given that hellofun is a function, in order to create an instance of the hello package, we need to call the function. This call occurs at point 3, and the resulting build graph is assigned to the variable hello. The function is invoked with a set of arguments inherited from the surrounding lexical scope using the inherit keyword. (The inherit x syntax is simply a shorthand for specifying the argument x, i.e., the argument x is the expression x, where x refers to the variable x in the surrounding scope.) It's important to note that the function can be invoked multiple times. For example, if we had a value perl6 representing a different version of perl, we could build hello with it as follows: hellowithperl6 = hellofun { inherit fetchurl stdenv; perl = perl6; }. This is a lazy language, meaning that expressions are only evaluated and the build graphs they represent are only constructed when they are actually needed. It's worth mentioning that this paper does not aim to provide a comprehensive treatment of Nix or its expression language, as these can be found in the Nix manual at http://... 

As an illustration of a simple rewrite rule, let's consider conditionals in the form of if e1 then e2 else e3. Conditional expressions first evaluate the condition expression, which must yield a boolean value. The conditional then evaluates to one of the two resulting expressions.

For the remaining rules, we require a concept of substituting expressions for variables in other expressions. The substitution function subst(subs, e) (not shown) performs a set of substitutions subs in the expression e, where subs consists of substitutions of the form x ~ e that replace a variable x with an expression e. subst replaces all free variables for which there is a substitution. A variable is considered free in a subexpression if it is not bound by any of its enclosing expressions. Variables are bound in functions and in recursive attribute sets. In recursive attribute sets, only the recursive attributes (as1) bind variables, while the non-recursive attributes (as2) do not. It is assumed that the expressions in subs contain no free variables, so subst does not have to perform renaming to prevent name capture.

A recursive attribute set is transformed into a normal attribute set by replacing all occurrences of references to the attributes with the recursive attribute set. For example, if e = rec { x = fx y; y = x; }, then e is desugared to { x = f(e.x)(e.y); y = e.x; }, or in full, { x = f((rec { x = f x y; y = x; }).x)((rec { x = f x y; y = x; }).y); y = (rec { x = f x y; y = x; }).x; }. This desugaring is implemented by the rec rule.

Using term rewriting, it is straightforward to convert the semantic rules from the previous section into a concrete interpreter for the language. However, without maximal laziness, such an interpreter would not perform well. This section demonstrates how we can obtain an efficient interpreter from a straightforward translation of the semantic rules using term rewriting and maximal laziness.

As a result of maximal laziness, we benefit from some optimizations that are typically applied to purely functional languages. For instance, the full laziness transformation improves code efficiency by moving subexpressions outward as far as possible, eliminating repeated evaluation of the same subexpression. With maximal laziness, this transformation is unnecessary, as repeated occurrences of the same subexpression across multiple function calls are computed only once.

In conclusion, maximal laziness with closed term optimization, as utilized in the production version of Nix, significantly improves performance. This approach, which wraps substituted terms in closed nodes, is essential in making maximal laziness feasible and enables fast operations such as nix-env-qa to run in a few seconds.