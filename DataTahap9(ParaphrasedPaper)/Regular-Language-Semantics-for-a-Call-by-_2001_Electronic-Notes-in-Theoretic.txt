A concise and formal calculus that fully embodies the potency of games may be unattainable; however, calculi for restricted yet non-trivial subsets of game-based models are immensely useful. These calculi exemplify game semantics in practical scenarios, thereby making the subject more approachable for individuals who might find its abstract nature daunting. Furthermore, such calculi can provide a solid theoretical foundation for a novel and practical approach to program analysis. A similar line of research is explored by Hankin and Malacaria in the realm of static analysis.

It is not assumed that the reader possesses prior knowledge of game semantics to comprehend this article. Although it is not feasible to condense such a rich topic into a few pages, comprehensive introductory material is available. The specific games model utilized to interpret FOIL and upon which the present regular language model is built is the one developed by Abramsky and McCusker. In this section, we will only introduce some of the key intuitive concepts of game semantics, particularly as applied to call-by-value games. 

A strategy interpreting a term is not represented by a single game but rather by a family of games. The interpretation process involves two distinct stages: a protocol stage, during which one member of the family is selected, followed by a play in the selected game. This mirrors the characteristic of call-by-value, where all arguments are evaluated precisely once before the function's body is evaluated. Therefore, free identifiers can have only one value throughout the term's evaluation. In contrast, call-by-name permits identifiers to correspond to different values at different points in the evaluation.

A regular-language representation of the game semantics of FOIL is defined as follows. Games are associated with types and are represented as regular languages over an alphabet denoting the moves. Strategies, associated with terms, are represented as regular languages over the disjoint sum of the alphabets of the types of the free identifiers and the term itself.

The semantics of "if" is directly specified in the game semantics. Looping in game semantics is defined as an abbreviation using the recursion combinator. Although a general recursion combinator is not specified in this treatment, the fixed point can be manually calculated, and the semantics of "while" above is the result of that calculation.

We have presented a games-based regular language semantics for an imperative language with first-order procedures using call-by-value function application, with arrays and variables passed by reference. The model is obtained directly from the game semantic model by working out the details of the category-theoretical presentation and observing that much of the games apparatus (justification pointers, etc.) is unnecessary in handling the present language subset.