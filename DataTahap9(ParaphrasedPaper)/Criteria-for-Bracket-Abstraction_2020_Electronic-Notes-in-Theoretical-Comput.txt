This academic paper examines the concept of bracket abstraction as a syntax operator used to abstract variables in combinatory logic. The paper discusses various algorithms for different combinator systems and introduces a recursive algorithm scheme that generates a family of bracket abstractions. The scheme is accompanied by theorems that set forth specific hypotheses and properties pertaining to the resulting abstraction operators. These theorems lay the foundation for designing bracket abstractions that satisfy particular criteria.

The paper highlights that certain existing algorithms for bracket abstraction, such as h, fab, abf, and sh, are not efficient in terms of the size of the output term[x]at relative to the size of the input term t. For instance, fab and h exhibit exponential growth, while abf is of complexity O(n^3), rendering them unsuitable for implementing functional languages. The size of[x]at for different algorithms is analyzed in previous works (e.g., [10, 11]).

The paper also emphasizes the dependency of [x]p on sub-terms of p in the bracket abstraction algorithms discussed in the introduction, noting that the position of the sub-terms to be used depends on p. Therefore, formalizing the concepts of positions and replacement in a subterm position is deemed advantageous.

Furthermore, the paper demonstrates that each of the functions ti serves as a homomorphism with respect to [z|x]. For instance, in the case of sh, it is proven that t5(p, q, r, w)[z|y] = (bpw)[z|y] = bp[z|y]w[z|y] = t5(p[z|y], q[z|y], r[z|y], w[z|y]). Similar proofs can be established for the remaining ti functions.