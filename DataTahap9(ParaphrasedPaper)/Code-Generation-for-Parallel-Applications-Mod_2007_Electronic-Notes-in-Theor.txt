In the context of developing parallel applications, it is crucial to ensure functional properties early on, in addition to analyzing performance aspects. This not only reduces the time spent on application development and debugging but also results in significant cost savings. To achieve this, model-checking and automatic code generation are proposed as complementary tools for analyzing system behavior and rapidly generating corresponding code. In this paper, object-based graph grammars (OBGG) are suggested for specifying parallel applications, as OBGG is a formal, visual language suited for describing concurrent systems based on asynchronous message passing. OBGG models can be verified through model checking, and a translation from OBGG models to C code using the Message Passing Interface (MPI) is presented. A sample parallel application is modeled using OBGG, with its functional properties proven through model-checking, followed by the presentation of the corresponding C/MPI model and performance results.

OBGG is described as a formal, visual language suitable for specifying asynchronous distributed systems based on message passing, with implicit parallelism and support for non-determinism. The language's few abstractions and object-based style make it relatively easy to learn, and its formal semantics enable model-checking through a translation to Promela, the input language of the SPIN model-checker.

Furthermore, the paper proposes the use of OBGG for constructing parallel application models, with a translation step to generate C/MPI implementations from OBGG models. This approach aims to increase the level of abstraction offered to designers for specifying parallel applications and enables model-checking the OBGG models, which can then be directly translated to a C/MPI implementation. The paper also discusses the use of design patterns as an extensible library for parallel programming and presents the mapping of OBGG objects to processes and message passing communication among OBGG objects to message passing among processes.

The paper also addresses the translation of OBGG messages to MPI messages using C data structures and discusses the termination of objects in OBGG, which is not explicitly represented in the language, as well as distributed termination detection in real systems. Performance measurements for the parallel application generated from an OBGG model executed in the CPAD 8 cluster are presented, along with the impact of the abstraction provided by OBGG. The paper indicates areas under investigation to improve performance in the translation process.