The process of inverse computation for an n-ary function f involves determining the potential inputs v1,..., vn of f that result in the given output v. There are two distinct approaches to inverse computation: inverse interpreters, which perform inverse computation, and inversion compilers, which execute program inversion.

To streamline the discussion, we exclude the description of special rules in the form of invf(f(x1,..., xn)) x1,..., xn, as they are irrelevant for inverse computation in the context of functional programs using call-by-value interpretation. These special rules are only necessary for the inverse computation of normalizing computation in term rewriting.

In Section 5, we establish a sufficient condition of constructor trss that enables the inversion compiler to generate (innermost-)convergent dctrss. Subsequently, we outline an implementation of the modified completion procedure and present experiments involving the unraveled trss of dctrss obtained by the inversion compiler from injective functions demonstrated by Kawabe et al. We also provide an informal translation of the non-overlapping trss obtained by the procedure back into functional programs.

The patterns t1, sk, and tk in r are referred to as patterns (in r), denoted by pat(r). It can be deduced from the definition of u that pat(r) = pat(u(r)) up to variable renaming. Patterns represent data structures through matching, particularly in innermost reductions where patterns only match normal forms.

In this section, we apply the modified and simplified completion procedures to dctrss generated by the partial inversion compiler, post-processing the procedures as a part of u(nv()). Initially, we briefly introduce the feature of inverse systems for injective functions and subsequently present the results of experiments through an implementation of the framework.

We specify invrev(z) as u4(invrev(z), z) for the reason that we confine ourselves to injective functions whose inverse trss terminate. A sufficient condition has been identified in a previous work for the full inversion compiler to produce convergent inverse dctrss from injective trss. This condition is also applicable to the partial inversion compiler, inv.

It should be noted that if the dctrs nv(r) is op-sn, then the trs u( nv(r)) terminates. Theorem 5.2(i) indicates that if nv(r) is op-sn, it has innermost-confluence, which is essential for successful runs of the simplified completion procedure. Furthermore, nv(r) is confluent if r is convergent. In cases where r does not satisfy the condition in Theorem 5.2(ii), we verify the termination of u( nv(r)) directly. Simply put, when r fulfills the condition in Theorem 5.2(ii), we are exempt from the less efficient termination check of u( nv(r)).

This paper demonstrates that completion procedures are effective in generating (innermost-)convergent inverse trss of injective trss. Additionally, these procedures can be utilized to determine whether a (innermost-)convergent constructor trs is injective. If a given convergent constructor trs is not injective, then the procedures will not succeed for the trs. While it is generally undecidable whether a function is injective, it has been shown that injectivity of linear treeless functions is decidable. Notably, some of the examples mentioned in the experiments are non-linear or non-treeless, whereas the method proposed in this paper is not decidable.

The system contains special function symbols, denoted as and, which are not present in the original signature. In this system, the term invsnoc([a, b, c],) has a unique normal form [a, b], c. Nonetheless, translating the convergent trs into a functional program is challenging due to the presence of special symbols and, as well as overlapping rules. In contrast, the modified completion procedure in this paper unexpectedly succeeded in all experiments where the dctrss are confluent, and the resulting systems of the procedure are frequently non-overlapping. Moreover, for the dctrss that are not confluent but innermost-confluent, we proposed the simplified completion procedure, although its applicability to the transformation in is yet to be determined.