The Java Card platform, designed for creating multi-application smart cards, is based on a subset of Java that excludes features such as threading, garbage collection, and many API functions. To enable multiple applications to coexist on the same card, the platform utilizes the concept of an applet, with Java Card applets being implemented by extending the Java Card API class.

To address the limitations of the platform and enhance its capabilities, the Formal Design Techniques group at SICS has been developing automatic, low-cost verification methods. These methods could potentially be utilized by an on- or off-card runtime system to determine at load time whether a new applet should be allowed onto a card with existing applets or not.

In a preliminary experiment, the group analyzed inter-method calls of multi-applet Java Card smart cards using model checking of Java bytecode. In this paper, the group extends their analysis to incorporate memory allocation concerns. If the safety of an applet cannot be proven using model checking, the group employs a complementary technique of instrumenting a compiled applet with a runtime monitor to ensure adherence to a safe memory allocation policy.

To provide a semantic foundation for the analysis of Java Card applets, the group employs the abstract notion of a program graph, capturing the control flow of programs with procedures/methods. The behavior of these program graphs is defined through pushdown systems, which offer a natural execution model for programs with methods and recursion. The group details the translation process in section 3.1, and subsequently describes the logic and their use of the Moped model checking tool in further detail in sections 3.2, 3.3, and 3.4.

The group utilizes an external static analysis tool, Soot, adapted to Java Card 1, to generate call graphs that abstract from everything except the presence and order of method calls inside method bodies. This analysis tool performs a safe over-approximation with regards to preservation of LTL safety properties. The generated call graphs incorporate information about exceptional behaviors, with exceptional edges and nodes being translated into non-deterministic constructs, thereby increasing the non-determinism in program behavior in a conservative manner.

In the specific case study of monitoring memory allocation by an applet, the standard method call graph generation process is augmented to include information on invocations of the new and newarray Java virtual machine instructions.

The paper also discusses the implementation of a monitor for the Java Card platform, which is necessary given the platform's lack of threads and access to API libraries. The monitor can be implemented as part of a runtime system, as a separate thread or process, or directly inlined with the monitored application using code instrumentation techniques.

To validate these concepts, the group has implemented a facility for experimenting with the automatic instrumentation of Java Card programs using the Soot tool, which provides a high-level abstract view of Java Card bytecode methods and supports program transformations.