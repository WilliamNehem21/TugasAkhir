Suppose our objective is to create a model of a portion of a banking system in the PVS language. Each bank in this system contains a set of accounts, with each account being associated with an owner and a balance. To achieve this, we introduce a theory named "bankingsystem" that defines two uninterpreted types (bank and person) to represent sets of banks and individuals, as well as a record type for denoting an account. It is important to note that uninterpreted types do not make any assumptions about the implementation of the specification, which differs from interpreted types such as int, which impose all axioms of integer numbers.

In PVS, we have the ability to declare function types. In this context, we define two function types: mathematical relation and function. There are various methods of declaring functions in PVS. One approach involves solely declaring the function's name, parameters, and result types, as illustrated by the first function, which establishes the relationship between each bank and its set of accounts. Another approach is to also define the associated mapping, as seen in the second function, which represents the withdraw operation.

In the withdraw function, the expression "balance(acc)" denotes the balance of the account "acc," and the keyword "with" signifies the overriding operator. The expression containing the "with" operator in the withdraw function denotes an account with the same owner as "acc," but with a balance reduced by a certain amount. Similarly, we can define a function representing the credit operation.

In this example, an arrow with a closed head form (e.g., from "chacc" to "account") indicates a subset relationship, where "chacc" is a subset of "account." Since the two subsets share an arrow, they are disjoint. When the arrowhead is filled, it signifies that the subsets collectively exhaust the superset, indicating that there are no members of the superset that are not part of one of the subsets. In both object models representing a banking system, the subsets form a partition: each member of the superset belongs to exactly one subset.

The third property of a valid view ensures that there is exactly one valid item for each name in the alphabet that is not part of the models. Given that "v1" is a valid view for "m1" and "m2," it already has mappings for all names of "m1" and "m2" in the alphabet. Consequently, we must ensure that if the mapped name does not belong to one of the models (e.g., "m1"), then the expression mapped by this name cannot be evaluated in "m1," as it contains at least one name not belonging to "m1." This constraint guarantees that the item is not valid for "m1," preserving the property that the view has only one valid item for each name in a model.

Similarly, we have established a theorem for increasing a view. We only need to verify the same properties for decreasing a view, in addition to two other constraints: ensuring that the new item cannot be recursive and that it maps an element of the alphabet. Notably, these constraints imply that we can only introduce an item that is not used to compare the corresponding models, as indicated by the following theorem.

To decrease the view, we first apply the law to remove the item from it. Then, we can apply the law to decrease the alphabet. Importantly, the conditions for decreasing a view are syntactic, whereas for increasing an alphabet, we require semantic conditions to ensure that both models have the same values for the names added in the alphabet.