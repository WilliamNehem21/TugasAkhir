The present practice in software engineering utilizes object-oriented models as a representation of the artifact to be developed. This approach is beneficial, as models and diagrams based on it provide a way to abstract distracting details, thereby aiding comprehension. The paper demonstrates that design reuse is more effective and advantageous than code reuse. Similar to source code, models become more complex during development as additional details are added. In order to facilitate a free flow of ideas and a variety of approaches, the inherent integrity constraints of model systems should be weak. In well-defined software processes such as UMLComponents and Catalysis, these constraints often take the form of dependencies or mappings between stereotypical elements. However, due to a lack of standardized automation in case tools, these dependencies currently have to be manually enforced, leading to increased effort, costs, and error-prone processes.

In contrast to the QVT candidates, Prime is designed as an environment for transformations, with a strong emphasis on the tooling aspect. Adherence to design patterns and common terminology aims to support implementers' understanding of the environment. Syntaxes were designed to support adoption, and popular languages were chosen for OCLPrime as the reference language implementation to lower the learning barrier.

The transformation plays the role of the abstract expression at the root of the meta-language, while validation, query, and implementation are terminal expressions. In a simple, non-recursive scenario, the transformation collaborates with them in the following way: it receives a context from the client containing parameters, which are then passed on to the query. It invokes a validation as pre-validation, transfers the model into a query, transfers the selected model elements to the implementation, and then invokes another validation as post-validation on the target model. Afterward, the target model either replaces the original model or a copy is placed in a different location to create a view. In this case, the client receives a uniform resource locator (URL) of the location where the view was materialized.

Validation, query, and implementation are implemented as services in external components. They receive the context, i.e., the invocation environment, in the form of named primitive parameters, similar to Java properties but based on OCL basic types. Services may return feedback in any textual form, but Resource Description Framework (RDF) syntax is preferred.

Queries are written in a query language, and they receive a valid source model and provide variables that contain collections of model elements to the transformation. To aid in optimizing queries, access path descriptions may be returned as feedback. OCLPrime implements queries as OCL expressions.

Implementations construct the output model, and they are provided with a target model and a set of variables primed by a query. Execution traces and operations performed on the repository may be returned as feedback. In OCLPrime, the construction language is SQL DML.

In our implementation of OCLPrime, both pre- and post-validation apply the UML profile validator, which expects a UML model of a version between 1.1 and 1.5. To allow feedback to be delivered, the constraint descriptor may be used to transfer the base URI of the profile used for validation. First, the process validates all built-in constraints of the meta-model of that version for all model elements addressed. Then, it extracts the profile constraints and validates them for all model elements stereotyped accordingly. Feedback is provided in the form of RDF statements. The defective model is stored, and the URI of that location is the basis for pointers to offending elements. The second element of the RDF triplet is a pointer to a description of the constraint that was violated, based on the URI received along with the constraint descriptor. The third element points to the location in the transformation where the error occurred.

To enable structured reuse, a transformation is composed of steps. Each step is declared as a package, a rule, or a source. A package is the role name of a transformation that contains another transformation, and these packages also have an order.

OCLPrime does not address the generation of software artifacts that are not models, such as source code and documentation. However, a number of components for generative programming that are based on JMI and XMI are now publicly available and could be reused in Prime. Additionally, the emergence of RDF as a general standard for semantic information opens up interesting perspectives for documentation and reasoning on models.

Action semantics define a full-featured programming language and could be used to encode the behavior of the implementation part, or to describe the semantics of the language. However, at the present time, no checker or interpreter for UML action semantics is publicly available. Therefore, the use of action semantics in the project context is deferred.

Overall, OCLPrime can be characterized as a hybrid unidirectional language with selective, declarative queries, driven by a single input model to produce multiple outputs. Collaboration and distribution are important properties for Prime, with parameter passing between client and interpreter modeled as documents, and all resources meant to be loaded from or stored in distributed servers. Even if Prime is used without EVE, these properties can still be useful in local operation.