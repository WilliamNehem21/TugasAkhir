When analyzing the correctness of authentication protocols, it is crucial to ensure injectivity, as non-injective protocols are susceptible to replay attacks. The traditional methods for confirming injectivity rely on a counting argument, which appears to be applicable mainly in a verification approach based on model-checking, or on inference drawn from the specifics of the data model used. In this study, we introduce and investigate a property called the loop property, which can be verified syntactically and is adequate to guarantee injectivity. Our findings are generalizable across a wide range of security protocol models and are not contingent on the particulars of message contents or nonce freshness.

The introduction of a causal chain of messages from the initiator to the responder and back to the initiator, referred to as a loop, is found to be instrumental in the discourse on injectivity. The class of security protocol semantics in which our results hold is defined by the closure of the set of execution traces under event swapping. This class encompasses, for example, the process algebraic approach with the standard Dolev-Yao intruder model. In addition to the swap property, no other assumptions regarding the data model and the intruder model are required. As the loop property can be easily ascertained through static analysis of the security protocol description, we provide a practical syntactic criterion for verifying injectivity.

The main achievement of this paper is the identification of a general property that permits a modular proof of injective synchronization: once non-injective synchronization has been demonstrated, proving injective synchronization becomes straightforward. Notably, this property is independent of the data model and thus does not rely on properties such as nonces or functions applied to the nonces.

The remainder of this paper is organized as follows. In section 2, we outline a formal model of security protocols and the underlying assumptions of our main result. In section 3, we formalize injective authentication and the loop property and establish their relationship. Finally, in section 4, we draw conclusions and propose avenues for future research.

In this study, role events are labeled with labels drawn from a set, typically denoted as "l." Each role event in a security protocol is assigned a unique label, except for corresponding send and read events. We stipulate that the send event, sendl(r, r', m1), and read event, readl(r, r', m2), match with sender "r" and receiver "r'." It should be noted that the messages may differ, as the perspective of the sender and that of the receiver may also differ. The format of messages in "rolemess" is left unspecified, as is the format of claims in "claim." Other types of role events may also be present in "roleevent."

The semantics of a security protocol is defined as a set of traces. However, to accommodate the possibility of a single party executing multiple (potentially identical) instances of a role, we introduce additional machinery. We define "agent" as the set of agents, and a role executed by an agent is termed a "run." A unique identifier, "rid," from "runid" is assigned to each run to account for the potential of each agent executing multiple instances of a role. An event "e" with run identifier "rid" is denoted as "e rid," yielding a set called "runevent" consisting of run events.

It should be emphasized that the labels and run identifiers are not part of the messages and are thus beyond the control of the intruder. They represent information that is often left implicit in semantic models. The label signifies the state of the agent when the event is executed, and the run identifier indicates the run in which an event takes place.

In this section, we define a syntactic criterion for authentication protocols, called the loop property, and demonstrate its sufficiency in proving injectivity. First, we define a strong authentication property called synchronization. Second, we introduce the syntactic criterion and validate the main result.

The general definition of synchronization refers to a specific protocol "p" and a claim label. For simplicity, we assume that there is a single protocol "p" featuring a single claim role event denoted as "claim." It is important to note that multiple claim run events may occur in a trace, which can happen when the role carrying the claim has been assigned to various agents or more than once to the same agent.

Essentially, the lemmas express that the events involved in a valid synchronization claim are independent of other events in the trace. A valid synchronization can occur at any point in the trace, as it does not necessitate the involvement of other runs or the intruder. However, other events in the trace may be contingent on events involved in the synchronization. Consequently, we cannot shift the synchronizing events to the right, but we can shift them to the left, ensuring that any dependencies are not broken.

We have demonstrated that for a broad class of security protocol models, validating the injectivity of authentication protocols is straightforward once synchronization has been established. Previously, injectivity and authentication were tightly linked, but our new findings indicate that verifying the non-injective variant of synchronization suffices. Verification of injectivity is a simple and distinct task that is not reliant on any specific data model.

Rather than selecting a specific security protocol model for this result, we have characterized a class of models in which the theorem holds. This class encompasses nearly all models found in the literature, such as the strand spaces model, Casper/FDR without time, and term rewrite systems. These models share the following properties:

- Most correct protocols satisfy "ni-synch" as well as the loop property. It appears that the loop property is a necessary condition for injectivity, a fact confirmed for the Dolev-Yao intruder model. However, for specific intruder models, the loop property is not a necessary condition for injectivity.