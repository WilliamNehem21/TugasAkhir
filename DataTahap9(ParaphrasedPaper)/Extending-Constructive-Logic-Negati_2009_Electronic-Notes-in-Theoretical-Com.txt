Thanks to the utilization of types, our constructive negation is capable of producing specific values as outcomes, rather than constraints (as in our previous works). We offer comprehensive explanations of the semantics and implementation of classical, finite constructive, and intensional negation in our approaches. The paper also presents practical examples, enabling the assessment of computational behavior.

Negation is widely recognized as one of the most influential aspects of logic that was not initially integrated. Dealing with negation introduces considerable additional complexity. Nevertheless, the use of negation is inherent and holds a significant role in various knowledge representation and reasoning systems, such as web semantics, natural language processing, database constraint management, program composition, manipulation and transformation, coding rule checking, business rules, default reasoning, and negative queries (search for false information).

Considering what has been expounded in this section, it is evident that there is a strong interest in achieving a robust and complete implementation of these techniques. Constructive negation was initially introduced in early versions of the Eclipse Prolog compiler but was subsequently removed from the latest releases. The reasons appear to be associated with technical challenges related to the use of coroutining (risk of floundering) and the management of constrained solutions. We endeavor to fill a long-standing gap in this area, addressing the challenge of providing a correct, efficient, and comprehensive implementation integrated into a standard Prolog compiler (bearing in mind that the original papers date back to the late 1980s).

A distinction exists between the impact of typing in other programming languages (e.g., functional programming) and logic programming. In strongly-typed languages, well-typed programs are incapable of encountering errors (in the sense of well-definiteness of expression), while in logic programming, ill-typed programs ultimately fail.

Regular types can be defined by regular grammars, with terminal symbols representing basic types. We introduce base types and corresponding base type symbols, such as int, num, and char, denoting sets of integers, all numbers, and characters, respectively. Grammar rules generate combined types, potentially including constructors (possibly 0-ary, i.e., constants). Types can be defined using various syntactic methods. For our purposes, we will confine ourselves to using horn clauses, although they can also be automatically generated from other syntax. For example, the type for a list of integers can be defined as follows:

p(x) is a predicate descriptor, where it has a predicate symbol as the main functor, and all arguments are distinct free variables. The "pre" and "post" represent preconditions and postconditions, respectively. For our purposes, it suffices to consider that "pre" and "post" correspond to formulas relating variables of x. The meaning of assertions is twofold: first, the precondition "pre" expresses properties that should hold in calls to p, and second, the postcondition "post" expresses properties that should hold upon the successful completion of a computation of p, provided that "pre" holds upon the call.

The distinction highlighted above regarding prescriptive versus descriptive typing can be reconciled when a setting of type declarations by assertions is employed. Assertions can be included by the user (prescriptive typing) or detected by the compiler (using static analysis and abstract interpretation techniques, like those reported in [6, 22, 7, 19]).

The CIAO system is a programming environment for developing Prolog programs. It is important to note that in CIAO libraries, there is a distinction between modules and packages. Modules are regular libraries that can be imported from any Prolog program, and their code (or the code of some of their predicates) is added to the code of the program that imports them. Packages are libraries that define a transformation function for the code of the program that imports them. This transformation function generates an output code that is an expanded program.

Type checking in CIAO is implemented by the package "assertions" (refer to chapter 53 of the CIAO reference manual). The compiler raises an error if the type of the value assigned to a variable does not correspond to the type declared for it, although it does not generate valid values if searching for values for the variable. This functionality needs to be added to the implementation of assertions of CIAO Prolog.

This type information can be utilized by the pre-compiler for analysis, but we are interested in employing this information at runtime (execution time) by the compiler. Therefore, we need to incorporate it into the program. We accomplish this with some new packages, "gen types" and "intneg types," which we have implemented. These packages expand the original code by adding a clause containing useful information for each type declaration. Particularly, the function "add types/3" generates a new predicate "pred check types/n" for each predicate "pred/n". We use these new predicates to check all types of the arguments of "pred/n" according to the information provided in the original program using the success assertion.

As already mentioned, one of the most intriguing techniques for implementing constructive negation was proposed by Chan and later refined. We have utilized the implementation provided by Chan (particularly the predicate "cneg/1") as a basis to develop a new predicate "cnegt/1" that implements classical constructive negation with types. This predicate is implemented in the package "cnegt.pl," which also uses the "gen types" package.

The proposal by Chan involves obtaining all solutions first, followed by negating the disjunction of all of them. Obviously, this technique can only be used if the goal being negated has a finite number of solutions. In our implementation, we ensure this fact using finiteness analysis. We have provided an implementation for this technique with the predicate "cnegf/1," upon which we have defined a new predicate "cnegf t/1" that implements finite constructive negation with types. This predicate is implemented in the module "cnegf t.pl." Prolog programs that use this type of negation should also utilize the "gen types" package that we have developed.

The predicate "intnegt/1" negates goals but only goals of predicates whose code has no free variables. This limitation arises from the fact that we have not yet adapted the implementation of the universal quantification to work with types. This will be the next step to improve the implementation, and we will include it in future works (section 6).

We define the predicate "length/2" where the first argument is a list of even numbers (type "even list/2"), and the second argument is the number of elements in the list. We also utilize the predicate "even/1" defined in the first example of this section.