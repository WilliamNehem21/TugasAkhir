For many years, mathematicians and computer scientists have extensively utilized relation algebra as a convenient tool for problem solving. Its use in computer science is primarily attributed to its ability to model various datatypes and structures, such as graphs, hyper-graphs, orders, lattices, Petri nets, and databases, using relations. Problems related to these data structures can be naturally expressed using relation-algebraic expressions and formulas, and solutions to these problems can benefit from relation-algebraic reasoning and computations. Numerous examples and references to relevant literature are available, as documented in publications such as [17, 4, 6, 13].

The functional logic programming language Curry [8, 10] aims to integrate different declarative programming paradigms into a single programming language. It serves as a syntactic extension of Haskell with partial data structures and a distinct evaluation strategy. Curry's operational semantics are based on lazy evaluation combined with potential instantiation of free variables. While the operational model on ground terms resembles lazy functional programming, the handling of free variables involves nondeterministic instantiation as seen in logic languages. Nested expressions are lazily evaluated, wherein the leftmost outermost function call is selected for reduction in each computation step. When a reduction step encounters a free variable demanded by an argument position of a rule's left-hand side, the variable is either nondeterministically instantiated to the demanded values or the function call suspends until the argument is bound by another concurrent computation. The process of binding free variables is referred to as narrowing, while suspending calls on free variables is known as residuation. Curry supports both strategies, and the choice between them depends on the intended meaning of the called function.

In addition to these aspects, the library clpb offers a variety of functions for boolean constraints. For instance, it includes nine functions corresponding to the boolean lattice structure, where some functions represent standard boolean operations and the rest denote comparison relations on boolean, with the constant "false" being defined strictly smaller than the constant "true."

In this section, an outline of the implementation of relation algebra over finite, binary relations in the Curry language is presented. Relations are represented as boolean matrices, allowing the utilization of Curry's higher-order features for an elegant formulation of relation-algebraic operations, predicates, and constants. The seamless integration of relational constraints into Curry is facilitated by using free variables to represent unknown parts of a relation. Leveraging the nondeterministic features of Curry enables the natural formulation of the search for unknown relations that satisfy a given predicate.

The functional characteristics of Curry are well-suited for implementing relation algebra, as relations can be easily modeled as algebraic datatypes, and relational operations, predicates, and constants can be defined as Curry-functions over this datatype. The focus is on relations with finite domain and range, which can be represented as boolean matrices, as described in section 2.1. The type of relations is defined based on the type of matrices introduced in section 3.1.

It is noteworthy that the type "boolean" is used instead of "bool" for the matrix elements, enabling the application of the more efficient constraint solver "satisfied" described in section 3.3 for solving relational problems. Additionally, the use of a vector corresponds to a list containing exactly one list in our implementation.

In section 2.1, a fundamental combinator on relations, namely relational inclusion, was introduced. This operation differs from the other constructions as it does not compute a new relation but yields a truth value. We view relational inclusion as a boolean constraint over relations and implement it as a function that takes two relations of the same dimension and yields a boolean value. Its Curry implementation is straightforward, achieved by combining the previously used functions "foldr1" and "elemwise" with the predefined function "concat" that concatenates a list of lists into a single list.

The predefined function "replicate" computes a list of a given length that contains only the specified element. Another crucial function, "find," plays a key role in solving relational problems using Curry, as it takes a predicate over a relation and nondeterministically computes solutions for the predicate. While a generalization of "find" to predicates over more than one relation is possible, the simple version suffices for the problems considered in this paper.

Several example applications are presented, along with the results of practical experiments conducted using the Pakcs implementation of Curry on a PowerPC G4 processor. The limitations of the current Pakcs system, which is unable to use more than 256 MB of main memory, were identified as a constraint for some examples.

In the first example, a relational specification of a least element of a set with respect to an ordering relation is implemented without relying on the logic features of Curry. The specification is presented as a relation-algebraic expression instead of a predicate.

To compute a linear extension of an ordering relation, the "find" function introduced in section 4.2 can be utilized directly. The result is a function that takes an ordering relation as an argument and nondeterministically returns a linear extension of the given relation.

Using encapsulated search, the "linearextension" function can be employed to enumerate all linear extensions of an ordering relation. Our approach allows for a simple specification to compute all linear extensions, utilizing the nondeterministic features of Curry. Enumerating linear extensions is significant in computer science due to its relevance to sorting and scheduling problems. For instance, the NP-hard problem of computing a possible scheduling for a distributed system with dependencies given as an ordering relation can be addressed by computing all linear extensions of the relation and selecting the best linear extension.

If the given ordering relation represents the dependencies of tasks in a distributed system, each linear extension represents a possible scheduling expressed as a relation of type "rel." To evaluate a scheduling with respect to a quality factor, it is more convenient to represent it as an ordered list of tasks. This conversion is achieved using a function relying on the predefined function "sortby" to sort a list according to an ordering predicate, and the function "evaluate" to convert between boolean constraints and values of type "bool."

While our approach may not match the efficiency of specific algorithms for the considered problems, it focuses on offering automatic evaluation of relational specifications with minimal programming effort and reasonable performance for small problem instances. In comparison to a narrowing-based implementation that does not rely on a constraint solver but uses the hand-coded function "satisfied," our experiments demonstrate that using a constraint solver significantly improves performance while maintaining the declarative formulation of programs.

In this paper, we have demonstrated how the functional logic programming language Curry can be used to implement relation algebra and prototype relational specifications. The expressive power of Curry's functional features facilitates the elegant implementation of relations and their key operations. Furthermore, the execution of explicit specifications corresponds to the evaluation of expressions, while implicit specifications are addressed using a boolean constraint solver available in the Pakcs system, proving its superiority over a narrowing-based approach. Our approach also allows for the formulation of general relational algorithms, such as the computation of...

With our library, relational specifications can be checked using a high-level declarative style with minimal programming effort. We have shown that different programming paradigms can benefit from each other. Functional programming can be made more efficient using constraint-solving facilities, while constraint programming can be made more readable using abstraction mechanisms provided by functional programming languages. Higher-order functions and algebraic datatypes are particularly useful in implementing constraint generation at a high level of abstraction. Functional logic languages enable the seamless integration of functional constraint generation and possibly nondeterministic constraint solving with instantiation of unknown values.