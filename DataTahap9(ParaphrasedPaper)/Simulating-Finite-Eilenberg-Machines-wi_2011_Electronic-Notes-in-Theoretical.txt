The X set encapsulates data structures commonly found in language theory, such as tapes, counters, and stacks, which are utilized by automata on words, push-down automata, transducers, and other similar computational models. Additionally, binary relations inherently embody the concept of non-determinism. Various computational models, including automata, transducers, real-time transducers, two-way automata, push-down automata, and Turing machines, can be represented as Eilenberg machines.

The proof of correctness employs an inductive principle based on the multiset ordering across three mutually recursive predicates. Due to the complexity of the termination argument, it is essential to formalize the simulation in a proof assistant. By leveraging the Coq proof assistant and its program extension, a specification of finite Eilenberg machines is provided, accompanied by a mechanized proof of its termination and correctness.

Furthermore, the React function, which omits parameters h1, h2, and h in its definition, determines if the state is terminal and then yields an element of the stream to postpone the rest of the exploration by invoking the Choose function. The Choose function conducts a non-deterministic search over transitions, selecting them in the natural order induced by the list data structure. The Continue function manages the backtracking mechanism and the enumeration of finite streams of relations, always opting to backtrack on the last pushed value in the resumption. Notably, these three mutually recursive functions are written in a pure functional style, completely tail-recursive, and do not utilize any side effects. They employ the resumption as a continuation mechanism.

These functions collectively ensure that computed arguments are well-formed as a postcondition, given that the arguments are well-formed as a precondition in the h1 predicate. The h2 predicate guarantees a portion of the well-formedness of the list of transitions in the Choose function. Termination is guaranteed using the accessibility predicate on the list of chi in the h predicate, and the wfrext property ensures that all recursive calls are performed with structurally less argument of h.

The formal development outlined above employs the calculus of inductive constructions as its specification language, which is a version of higher-order logic suitable for abstract mathematical development and constructive reasoning about computational objects. It is important to note that the sort prop is utilized for logical properties, while the sort set is used for computational objects. This affords a technique of program extraction for extracting an actual computer program that verifies the logical specification. By leveraging OCaml as the target extraction language, the Coq proof assistant mechanically provides the resultant program.

In summary, a comprehensive specification of the finite Eilenberg machines model has been presented, and a restricted version of the multiset ordering has been formally specified. This has enabled the implementation of a reactive engine that simulates finite Eilenberg machines within the Coq logic of total functions. These formalizations have facilitated the formal proof of the correctness (soundness and completeness) of the reactive engine concerning finite Eilenberg machines. The definition of the reactive engine presented here closely aligns with the one introduced in OCaml in the article detailing the finite Eilenberg machine model.