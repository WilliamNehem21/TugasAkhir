In the first example, a1, the expression fst(x) is evaluated at runtime to yield the result name(n2). In the second example, a2, a process is demonstrated where a new name (n2) is created, signed with a private key pri(n1), and then sent. Another process receives it, verifies the signature, and uses the name n2. It is important to note that for a2 to function as intended, the term check(sign(n2, pri(n1)), pub(n1)) should evaluate to "ok", and removesign(sign(n2, pri(n1))) should yield the result n2.

Although general-subst is not employed, it is not wholly disregarded. The approach taken ensures that no new variables are introduced (via general-subst applied left-to-right), but allows for the elimination of variables and the application of substitution processes to adjacent processes (via general-subst applied right-to-left). To facilitate this, a reduction relation is introduced.

As 0 cannot perform any action, there is no rule for it. It is also worth mentioning that a conditional is only executed when the terms are ground; otherwise, it behaves as 0. Inputs and outputs also behave as 0 unless the subject is a name (or is reduced via ">>" to a name).

This section demonstrates the correctness of the cfa described in section 4 with respect to the formal semantics of section 3, achieved by proving a subject reduction result. Most proofs are conducted through structural induction or rule induction and are generally straightforward. In some cases, the proof is simply outlined.

In the given scenario, two participants (denoted as a and b) share a long-term symmetric key with a trusted server (referred to as s): the key kas is only known to a and s, and the key kbs is known only to b and s. Participant a generates a new key kab and aims to share it securely with b. To achieve this, a sends the new key to s, encrypting it with the key shared with the server. The server s decrypts it and then encrypts it again using kbs before forwarding it to b. Upon receipt, principal b not only receives the key from the server but also an encrypted term m from a. The continuation b' can then decrypt the key from the server and subsequently decrypt m.