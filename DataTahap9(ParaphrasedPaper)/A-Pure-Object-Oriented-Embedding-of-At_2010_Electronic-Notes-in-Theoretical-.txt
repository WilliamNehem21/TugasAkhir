In recent years, there has been a shift in focus within attribute grammar systems towards dynamically scheduled evaluation, where the attributes to be evaluated and the evaluation order are determined at run-time rather than at generation time. Notable examples of this approach include lrc, jastadd, uu ag, and silver. Dynamic scheduling offers the advantage of ensuring that attributes are evaluated at most once, but it also introduces runtime overhead. This tradeoff is particularly beneficial in applications such as integrated development environments, where not all attributes are needed at all times.

However, these recent systems are based on generators, which increase the learning curve and complicate the development and build processes. In this paper, we propose integrating a dynamically scheduled attribute grammar approach as a library into an existing modern, object-oriented language. We demonstrate how to achieve this integration through a pure embedding, where the syntax, concepts, expressiveness, and libraries of the base language are used directly. This approach retains the high-level declarative nature of the attribute grammar formalism and augments it with the flexibility and familiarity of the base language for both specification and implementation.

We provide an overview of the Kiama implementation in section 3 and discuss how language extension and separation of concerns can be achieved by leveraging the general Scala platform in section 4. In section 5, we evaluate the performance of Kiama. The paper concludes with a discussion of our approach in the context of other attribute grammar systems in section 6 and includes concluding remarks in section 7.

The "repmin" problem, a classic issue in tree analysis and transformation, is used to illustrate the use of lazy circular programs in functional programming to eliminate multiple tree traversals. This problem is often used as a simple test of attribute grammar systems. Similarly, other types of attributes are defined by similar classes with the same interface. For example, uncached attributes are a simple variant, while the "circular" class provides a functional interface to the fixed-point evaluation algorithms of Magnusson and Hedin.

Flexible static combination of attribution modules can be achieved using Scala traits to define components, and performing mixin composition to combine them. For example, the variable liveness problem of section 2.2 can be decomposed into three components dealing with control flow, variables, and the liveness computation itself, which can be abstracted by interfaces defined by traits.

We evaluate the performance of attribute evaluation in Kiama by comparing it to a handwritten Scala implementation and to a generated Java attribute evaluator. Our comparison includes jastadd, which, like Kiama, uses the Java platform and supports reference and circular attributes. Jastadd has been successfully used to implement a full-featured Java 1.5 compiler that offers performance competitive with handwritten implementations.

As a test case, we utilize the jastadd example picojava specification from, which has 18 abstract syntax productions and 10 attributes to perform name and type analysis. We tested the evaluation performance for relatively large, generated input programs. Since picojava only supports class definitions and not methods, our input classes contain 150 nested class definitions.

This section briefly compares the approach taken to develop the Kiama attribution library with generator-based systems that feature a dynamic evaluation approach. To our knowledge, Kiama is the only attribute grammar system that uses pure embedding. In many ways, Kiama has been inspired by the jastadd system and provides similar features. Jastadd provides an object-oriented variation of attribute grammars, supporting inheritance in their definition and references as attribute values. Like Jastadd, Kiama is based on the Java platform.

One advantage of a generator-based approach is the ability to check the attribute grammar for correctness at generation time. In Kiama, precise checking of this kind is not always possible, particularly if syntax extensibility is desired. However, a Scala case class can be marked sealed, which prohibits extension outside the current module. When compiling a pattern match against a sealed class, the Scala compiler can emit warnings if the patterns are not complete, providing Kiama with a form of completeness checking.

Dynamically-scheduled attribute grammars represent a powerful language processing paradigm that has been the focus of many generator-based implementations. The Kiama attribution library removes the generation step by using Scala to write the entire attribute grammar. The resulting system is lightweight and easy to understand, yet capable of competing in expressivity and performance with Jastadd, a mature generator-based system that uses a similar evaluation method.