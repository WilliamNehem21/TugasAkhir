However, if the goal is not real-time verification but rather an evaluation of a program based on its runtime behavior, it is reasonable to attempt to gather and consolidate as much information as possible about it. This suggests that one should aim to merge multiple traces in order to gain a deeper understanding of the underlying program. Several studies pursue this idea for various specific purposes.

It is worth noting that the technique presented in this paper may not be suitable in other contexts, such as when formal guarantees regarding the presence or absence of software defects are desired. Our method relies on certain assumptions and can only produce approximate models, which could result in incorrect responses from a model checker (i.e., false positives and false negatives). Nevertheless, in many situations, having an approximate understanding of a system is better than having no understanding at all. Furthermore, the quality of our approximations can be enhanced by incorporating more and longer traces.

We assume that the program traces are already available and, therefore, do not provide a method for collecting them. In this regard, we only define a trace file format that our proof-of-concept tool can read, thus not restricting the potential applications of our method to any particular type of program.

The paper establishes the formal foundations on which the merging algorithms are based. The algorithms are presented in section 4, and in section 5, we illustrate how model checking is actually performed on the merged traces. Section 6 presents some illustrative experiments using a simple economic simulation. Finally, section 7 reflects on the achieved results and discusses what remains to be done.

Similar to our work, Cho et al. propose approximate model checking algorithms, but their approximations are derived from a formal analysis of the system, whereas ours relies on the collected traces at runtime.

Once the traces are merged, a state-space is obtained that can undergo model checking using either LTL or CTL. From a theoretical standpoint, not much more needs to be done. However, from a practical standpoint, an actual implementation is necessary for performing the model checking. To this end, we simply translate the state-spaces to the input language of an existing model checker, NUSMV. NUSMV can be used to investigate the temporal properties of the finite state machine specified by the translated state-spaces.

Our model has variables of interest including inflation, economic activity, and standard of living, and their values are updated at each simulation step according to certain rules. The simulator runs the model several times, collecting traces, and ultimately produces a trace file that can be read by our trace merger.

To address questions about the utility of the uncertain answers provided by the model checker, it is important to understand that these answers are valuable if more rigorous methods are unavailable, as they reflect the behavior of the system, albeit in an incomplete manner. The technique is not designed to assert infallible propositions but only to suggest possible behaviors, given the available data and the suppositions concerning the simulated system. The user is expected to use such suggestions as guidelines for further scrutiny, either by providing more and longer traces to our algorithms or by employing other methods (e.g., writing specific test cases for the detected behavior, inspecting the source code).

The paper highlights the merging techniques that are of interest but acknowledges that other techniques may be more appropriate for different problems. For example, the change-preserving algorithm of section 4.3 also preserves the instant that a change takes place, but this may not be necessary for some applications. Furthermore, techniques where no merging takes place and each trace is analyzed independently were intentionally disregarded, as they do not align with the core subject of the paper.

Finally, the state-space produced by merging traces can be useful for purposes beyond model checking. As an approximate representation of an underlying program, it might be interesting to apply machine learning algorithms to it in order to extract new information about its behavior. For instance, a machine learning algorithm could reveal previously unrecognized relationships between different states.