Advances in technology, such as networking and parallel processing, have facilitated the development of distributed and concurrent systems. Many of these systems are comprised of autonomous or independent subsystems. In certain instances, there is a necessity to enable a sending subsystem to continue its tasks without waiting to ascertain the fate of its message. These characteristics collectively imbue the entire system with an asynchronous nature.

The idealized channels, which are without losses or delays, assumed in theoretical frameworks, do not accurately mirror real systems. Consequently, testing tools must be equipped to handle imperfect channels within systems. Furthermore, in cases where subsystems depend on external choices, testing tools must be capable of handling non-determinism.

Our pragmatic approach aims to make testing theory usable for practitioners. To this end, we first bring the system under test (SUT) and the testing tool to cooperate in an online approach. While this approach is partially present in existing tools, we have extended the capabilities of these tools to function in black-box testing environments, prioritizing available interfaces over internal workings of the system. Additionally, we have augmented existing tools to implement theoretical knowledge on managing asynchronous communications. Our approach addresses not only communication delays, but also communication losses, which are less commonly addressed in the literature. Finally, we rely on abstract models to guide the testing process.

The remainder of this paper is structured as follows. Section 2 describes a small system that serves as an illustrative example to clarify the concepts introduced in Sections 3 and 4. Section 3 outlines the notations and definitions for event structures used to model asynchronous distributed systems. In Section 4, we describe the process for conducting asynchronous testing of distributed systems, and in Section 5, we present details of a specific implementation of this process using existing testing tools. Section 6 provides an example of testing a more complex asynchronous distributed system. Finally, a brief description of related work and our conclusions are presented in Sections 7 and 8.

The system described in this paper is asynchronous in the sense that the sender does not need to wait for the receiver to accept or reject a file. The sender can transmit a file and then another one before observing any action performed by the receiver. This behavior can be represented in a graph by interleaving the actions related to each of the files being transferred.

Various types of event structures have been defined in the literature, derived from classical ones introduced in previous work. The specific event structure model considered in this paper was introduced by Van Glabbeek and Plotkin, and has been adapted to suit our purposes. Some preliminary concepts need to be introduced before defining this event structure.

In distributed systems, it is easy to distinguish different components of the system based on their locations. Generally, we can assume that there are two parts in these systems: one part whose actions we can control, and another part whose actions we can only observe. We have previously described a behavioral model that captures events occurring in both parts of the system.

We cannot predefine a list of actions to be executed because certain actions will become enabled (or not) depending on the non-deterministic responses of the other part of the system. Thus, we define two algorithms, the test generator and the execution observer, which run in parallel during the testing process. Both execute independently but communicate (and synchronize if necessary) by accessing two global structures: a queue of controllable events (qc) and a set of observable events (so).

The testing tool, smartmbt, takes as input a labeled transition system that specifies the behavior of a software system. The testing process is driven by the model, which provides the testing tool with a set of enabled actions calculated from its current state. While every action in a labeled transition system model will typically be available for execution at some point, this is not the case for asynchronous systems. There exist observable actions, which the SUT executes independently, usually in response to other actions. These actions should not be executed by the testing environment and should not be included in any set of enabled actions. However, they should be included in the model to update the state of the SUT and the model. We have included a mechanism to allow the modeler to tag observable actions and for the tool to recognize them.

This module is entirely new in the testing tool and has the ability to observe which observable actions have been executed in the SUT, usually in response to actions executed by the generator. This module implements our execution observer algorithm. It runs in a separate thread and is activated each time an action comes through the communication channel. Controllable actions are discarded, as the generator is responsible for updating the state of the model in this case. Observable actions are processed exactly as in the algorithm. This module relies on an extension of the client module, which is explained next.

In this paper, we have demonstrated our extensions to existing testing tools to enable automated testing for asynchronous systems. These extensions are based on sound theoretical foundations available in the literature. We have shown through an example that these extensions can handle real systems, such as an implementation of the FIX protocol. We believe that our use of event structures as the underlying model, together with an on-the-fly approach for test case generation and execution, represents a significant step in preserving concurrency in asynchronous testing.