The analysis of deletions in binary search trees poses challenges due to their lack of randomness preservation. In this paper, we introduce a modified version of the standard binary search tree, termed the ordered binary search tree, which includes a history element in its nodes to track the order of node insertions. By leveraging this additional information, we propose a new deletion algorithm that preserves both randomness and order.

It is generally accepted that an algorithm preserving randomness makes average-case time analysis feasible. This claim has been formally substantiated by Schellekens, who introduced the programming language MOQA, ensuring that all programs are randomness-preserving.

The remaining sections of our paper are organized as follows: in Section 2, we outline the ordered binary search tree and present the deletion algorithm along with its pseudocode. In Section 3, we compare the probabilities of different tree structures following a standard deletion with those resulting from the new deletion algorithm, using a tree of size three as an example. Subsequently, we offer a comprehensive proof of randomness preservation by demonstrating a bijection between the set of ordered binary search trees and the set of permutations that maintains the corresponding insertion and deletion operations. The average-case analysis of the algorithms is presented in Section 4, revealing that both the insertion and deletion algorithms exhibit an expected performance of O(log n). Finally, Section 5 contains our conclusions as well as suggestions for future research directions.

It is important to note that our evaluations have been limited to small-sized trees, and thus we cannot extrapolate our findings to all trees. To establish the universality of our conclusions, we first need to verify the correctness of the operations outlined in Section 2.2. In the following discussion, we aim to demonstrate that for a permutation p=(e1 e2... en) of the set x of keys e1 to en and an ordered binary search tree t=[e1, e2... en], the existence of multiple permutations for a single ordered binary search tree would imply discrepancies in key positions and, consequently, distinct tree configurations. Thus, we must show that such a scenario is inconsistent.

For the analysis of the deletion algorithm, we divide it into two primary phases. The first phase involves searching for the node to be deleted, denoted as the cost se. The second phase focuses on restructuring the tree to ensure its status as an ordered binary search tree, with the cost for this phase referred to as re. The cost se is determined based on arguments similar to those used for the insertion algorithm and directly reflects the number of nodes visited along the search path to identify the internal node. Therefore, we can express the expected depth of a node as se= de.

Moreover, our discussion addresses the process of inserting a tree of arbitrary size into a tree of size n, while considering the cost of calling reinsert on a smaller tree tsub with only s nodes and stopping when we reach an external node (i.e., when s= 0). Additionally, we highlight that inserting a tree is akin to inserting a single node, where we locate the appropriate position for the root and subsequently insert the entire tree through its children pointers. During the reinsert process, it is not mandatory to find an external node for tree insertion, resulting in a cost equivalent to finding a node in a tree of size n.