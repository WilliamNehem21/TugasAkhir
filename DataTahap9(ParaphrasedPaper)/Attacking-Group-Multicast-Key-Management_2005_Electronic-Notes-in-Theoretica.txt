The tanaka-sato protocol assumes the presence of a unicast authentication protocol that enables the server to establish an individual key (ik) with a new member joining the group, which is then utilized to encrypt all communication between that member and the server. The underlying authentication protocol is modeled on the basis of the existence of a long-term key shared by each potential member of the group with the KDS. As the focus is on identifying attacks on the protocol rather than on verifying it, this assumption is deemed justifiable. The attacks described in this paper would be effective for any initial authentication protocol, and it is also assumed that a spy has access to a valid long-term key.

In order to address the issue of creating a large search problem, the model has been modified to include details about the state of the principals. The unary function m(), which was previously used to store only the message trace, has now been adapted to store the trace, a counter, the current group key stored by the server, and the composition of the group stored as a list of triples. These triples store the agent's name, the individual key shared with the server for the session in the group, and the most recent group multicast key received. A boolean function ingroup has been defined on these lists of triples to determine whether a particular agent is in the group. Another change involves the modeling of freshness, where a counter is now used to model fresh values in the protocol, as opposed to utilizing the parts operator as used by Paulson. Multicast messages are modeled as hello(t), where t is the counter value when the message was sent, to ensure uniqueness of all (honestly sent) messages.

Additionally, Pereira and Quisquater aim to outline a set of desirable security properties for group protocols including implicit key authentication, perfect forward secrecy, and resistance to known-key attacks. However, certain properties identified by Taghdiri and Jackson as not being satisfied by the original protocol design do not fall within these categories, as the protocol in question is focused on managing a group key for an evolving group, rather than simply establishing a key for a static group.

The main distinction between the Iolus protocol and the Taghdiri-Jackson version of the Tanaka-Sato protocol lies in the fact that Iolus eagerly distributes new keys, while Tanaka-Sato distributes keys only on demand, i.e., as and when members of the group want to send or read messages.

Furthermore, the server generates a fresh individual key, ikm i, and a new group key with id n, gkn', and sends the group key to the new member in message 2, and to the old members of the group under the old group key, gkn, in message 3.