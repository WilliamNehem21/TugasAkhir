C++ template metaprogramming is often considered to be akin to a functional language; however, modern metaprogram libraries do not typically adhere to functional programming style. This paper presents a compile-time graph-rewriting engine based on the characteristics of the functional language Clean, with a particular emphasis on the lazy evaluation strategy. The engine enables the embedding of lazy functional-style code into C++ programs and the transformation of such code into template metaprograms. We illustrate the implementation of a lazy evaluation strategy with examples, including the handling of infinite lists.

The paper begins with an exploration of C++ template metaprogramming and its connection to functional programming in Section 2. Section 3 delves into lazy data structures, evaluation, and the template metaprogram implementation of the graph rewriting system from the Clean functional language. Section 4 provides a detailed discussion of the process for transforming the EClean system, while Section 5 outlines future work and Section 6 discusses related work. 

The most significant applications of metaprograms include concept checking (testing for specific type properties at compile time), the construction of data structures containing types at compile time (e.g., typelists), and the creation of active libraries, among others.

Despite the advantages of template metaprogramming, such as executing algorithms at compilation time, its widespread adoption in the software industry has been hindered by the absence of coding standards and software tools. Additionally, the complex syntax and verbose code of C++ template metaprograms make them challenging to read and maintain. While libraries like Boost::MPL assist programmers by abstracting the implementation details of certain algorithms and containers, a significant portion of the coding burden still falls on the user. The lack of a standardized interface for template metaprogramming has led to variations in naming and coding conventions among programmers, contributing to comprehension issues.

In the EClean system, Clean programs are represented by an expression graph within the compiler, which undergoes automatic rewriting in multiple phases at runtime. This process commences when the main function expression on the right side of the start symbol is evaluated.

The paper's running example utilizes the "enumfrom" feature. We define the "enumfrom" constructor to create an infinite list starting with a specific number. Consequently, the list [2..] can be expressed as "enumfrom 2" (or [2..]). To obtain the head element of a list, the expression must be rewritten to "cons 2 enumfrom 3" (or [2, enumfrom 3]).

The above example effectively demonstrates the application of lazy evaluation strategy. We implemented the rewriting algorithm using template metaprogramming to simulate the inner workings of the lazy functional programming language Clean. Our engine carries out the rewriting, as described in the subsequent section.

In our approach, EClean expressions are represented by types and typedefs. In this context, the start expression of our example takes the form "take<mpl::int<10>,sieve<enumfrom<mpl::int<2>>>>." Here, "take," "sieve," and "enumfrom" are all struct templates with corresponding signatures.

The "sieve" template involves two parameters, "prime" and "ys." This template embodies the operation depicted in the "r3" rule in our Clean example. If a subexpression takes the form "sieve<cons<n,t>>," where "n" and "t" are arbitrary types, the compiler selects the previously defined "sieve" specialization as a substitute for the subexpression. Notably, although "n" and "t" are general types, the "sieve" template expects "n" to be of type "mpl::int" and "t" to be a list of "mpl::int" types.

However, to apply this rewriting rule, an exact match is required during the rewriting process. For instance, in "f1," during the evaluation process, the previously defined "sieve" partial specialization is deemed applicable when rewriting the subexpression "sieve[2..]." The challenge arises when the argument "[2..]" (enumfrom 2) does not align with the sieve partial specialization parameter list, which anticipates an expression in the form "cons<n,t>" with types "n" and "t." Despite the C++ compiler instantiating the type "sieve<enumfrom<mpl::int<2>>," this constitutes a pattern matching failure that needs to be identified. Consequently, each function must implement a partial specialization for the general case when none of the rules with the same name can be applied, which is designated by the symbol "nomatch."

The functionality of "eval" is as follows: it takes a single argument, an expression "expr" with one parameter "t1." The type variable "t1" can be any type, such as "int," a list of integers, or a further subexpression. The return type "result" contains the newly rewritten subexpression or the same input expression if no rule can be applied to the expression and its parameters.

Unlike in Clean, the priority of EClean rewriting rules cannot be explicitly defined. For instance, if an alternative "factorial 1= 1" is defined alongside the general "factorial n= n*factorial(n-1)" in EClean code, the specialized alternative will never match. However, in template form, due to the nature of template instantiation, the "factorial<mpl::int<1>>" alternative will be matched even if it is defined after the general "factorial." At present, neither the parser nor the engine can handle multiple matching, but this represents an important and interesting avenue for future development.

Prior research has investigated functional language-like behavior in C++, with functional C++ (FC++) introducing functional programming tools to C++, including currying, higher-order functions, and lazy data types. However, FC++ functions as a runtime library, whereas our aim was to leverage functional programming techniques in compile-time.

The Boost::MPL library stands as a mature toolkit for C++ template metaprogramming, encompassing various compile-time data structures, algorithms, and functional-style elements such as partial metafunction application and higher-order metafunctions. Nevertheless, while Boost::MPL closely aligns with the interface of the C++ standard template library, it does not explicitly support lazy infinite data structures.