The concept of confluence is widely encountered in graph transformation systems (GTS) and constraint handling rules (CHR). This paper introduces a generalized embedding of GTS in CHR, enabling the consideration of strong derivations in confluence analyses. While confluence of a terminating CHR program is determinable, confluence of a terminating GTS is undecidable. The paper demonstrates that observable confluence in CHR aligns with confluence in GTS. 

The paper begins by outlining the fundamentals of graph transformation systems and CHR in Section 2. Section 3 then presents the proposed encoding of a GTS in CHR, with Section 4 establishing its soundness and completeness. Additionally, Section 5 introduces observable confluence and its role as a sufficient criterion for confluence of an embedded GTS, before concluding in Section 6.

Specifically, the paper utilizes a type graph consisting of a single node with a loop as an illustrative example. Additionally, a shorthand notation is employed to represent morphisms and transformations within the graphs.

To embed a GTS in CHR, the paper encodes its graph production rules as CHR rules and provides a conjunction of goal constraints corresponding to the host graph. The correspondence between graphs and their representation by CHR constraints, as well as the encoding of rules for recognizing cyclic lists and a comprehensive example derivation, are provided in Section 3.

The importance of degree variables with respect to the encoded GTS is discussed in Section 4, highlighting their significance in the strong joinability analysis presented in Section 5. The paper also establishes the soundness and completeness of the encoding and generalizes the results for a more generic host graph encoding.

Both GTS and CHR provide the notion of a confluence property, ensuring that any derivation from an initial state results in the same final state, regardless of the applicable rules. The paper presents the necessary definitions for GTS and CHR confluence, comparing the two notions and demonstrating how automatic observable confluence checking in CHR can be repurposed to yield a decidable sufficient criterion for GTS confluence.

Further investigation into critical GTS pairs and critical CHR pairs for CHR programs encoding a GTS is conducted, with the paper showing the existence of a corresponding CHR overlap for each critical GTS pair. The results of these investigations lead to the establishment of a criterion for deciding glocal-confluence, demonstrating that the automatic confluence check for terminating CHR programs can be utilized to prove confluence of a terminating GTS encoded as a CHR program.

In summary, the paper highlights the elegant manner in which CHR provides an embedding for GTS, offering concise rules directly related to the corresponding graph production rules. Moreover, it introduces a generalized encoding that facilitates the modeling of strong derivations used in the analysis of strong joinability.