The history of developing programs for parsing and analyzing Java bytecode is extensive, with ongoing development of new programs [2,3,4,7,13]. When creating such tools, a significant amount of effort is dedicated to building a parser for the bytecode and to (re-)developing standard control and data-flow analyses, which calculate, for example, the control-flow graph or the data-dependency graph.

Unlike in the JVM specification, the opal SPL does not have a predefined type hierarchy. Instead, each SPL specification contains a description of the type system utilized by the bytecode language being described. The only requirement is that all types must be organized within a single, strict hierarchy.

In opal SPL, the stack is represented as a list of operands, as opposed to a list of slots as described in the JVM specification. Although expressing the effect of an instruction such as dup2 in terms of stack slots is more straightforward, the majority of instructions naturally refer to operands. Notably, by basing the stack model on operands rather than slots, explicit modeling of the higher and lower halves of category-2-values, such as the high and low word of a 64-bit long operand, is avoided.

In accordance with the specification, two generators have been developed, both of which are implemented using XSLT. The first XSLT transformation generates classes that represent all instructions and spans 350 lines. Each generated class represents an instruction as a Java object and provides functionality to obtain an XML and a Prolog representation of the concrete instance of an instruction. The second XSLT transformation generates the parser for a code array, creating instances of the instruction classes on the fly and spanning 300 lines. This was compared with the bytecode code engineering library (BCEL) which utilizes a similar approach for representing and handling instructions. In comparison to the instruction-related code of BCEL, the generator is between 15 and 20 times smaller.

A further advantage of this approach is that changes affecting all instructions are localized. For instance, when testing several different representations of the prolog representation, which often affected all instructions, generally less than 40 lines of code of the generator needed to be modified.