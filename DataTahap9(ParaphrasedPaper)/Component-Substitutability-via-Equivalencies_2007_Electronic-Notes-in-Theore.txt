The component-interaction automata language described in [5,15] was created to model the interactions between components in hierarchical component-based software systems. It represents each component as a labeled transition system with structured labels and a hierarchy of component names, enabling detailed modeling of component interactions while maintaining broad applicability across various types of component-based systems with different synchronization strategies. This language is briefly reviewed in this section.

Lemma 5.1 can be extended to the replacement of multiple automata with a single automaton, a single automaton with multiple automata, or a set of automata with another set due to the concept of treating a set of automata as a virtual composite automaton consisting of all reachable transitions within the complete transition space, as discussed in Lemma 4.5. This concept can be applied to the following propositions as well.

In this section, we explore another interesting issue related to independent component development with the assurance that they can be safely reused in any system as long as their implementation conforms to the specified environment. The solution is based on defining a relationship between component specification and implementation to ensure this independent implementability, allowing developers to design systems as compositions of specifications and then search for suitable implementations. Note that the ability to independently implement components can be seen as the substitutability of component implementation for its specification, and thus the results of Section 5 can be utilized to a certain extent.

Systems with an unequal interpretation of input and output actions, where an output can be initiated at any time while an input needs to wait for a counterpart, are often referred to as non-blocking systems. However, not all systems are non-blocking, as there are also blocking systems where both input and output actions are blocked if a counterpart is not ready. Most specification languages for component interactions focus on either the blocking strategy (e.g., Tracta, Wright) or the non-blocking strategy (e.g., Interface Automata, Sofa Behavior Protocols). The component-interaction automata language incorporates both strategies, as it is designed to model a variety of synchronization strategies.

Another noteworthy approach, as studied in [7,6] by Chaki et al., focuses on component substitutability from a verification standpoint. The goal of this work is to provide an effective verification procedure that determines whether a component can be replaced with a different one without violating system correctness.