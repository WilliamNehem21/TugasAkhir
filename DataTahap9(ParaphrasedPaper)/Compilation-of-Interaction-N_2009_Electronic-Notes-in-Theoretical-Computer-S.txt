In the following section, we provide background information on interaction nets. Our source language is discussed in section 3, and we define the compilation schemes from our source language to C in sections 4 and 5. Section 6 outlines the implementation details, and we conclude the paper in section 7.

The introduction of agents with values allows for an efficient representation of data types in interaction nets. For instance, numbers can be represented in a manner directly supported by hardware, as opposed to using s and z agents. Additionally, we introduce a set of deterministic operations on the built-in data types, such as booleans, integers, and characters. The following example rule illustrates how the addition operation can be encoded in a way that is directly supported by hardware.

A net may contain multiple active pairs, enabling reduction to proceed via alternative routes. To ensure the uniqueness of normal forms (in the sense that the same net will always produce the same result), we employ a simple reduction strategy that reduces a net to full normal form using a last-in-first-out (LIFO) order. All active pairs are kept in a stack and reduced according to LIFO. We simulate this strategy using a big-step structured operational semantics.

In this section, we define the compilation schemes from our source language to C source code. We utilize existing C compilers to translate the generated C source files to native code. When executed, the generated codes will construct the corresponding net in memory and reduce it to full normal form.

The fundamental model involves compiling each rule and each net to a C function. The functions generated for rules take a pair of (active) agents as parameters and contain code that builds the right-hand side net of a rule and connects it to the agents that are linked to the auxiliary ports of the active pair.