The complete semantics of Nimo was established using graph grammars and was implemented in a graph transformation system known as Nimoagg. This initial prototype served as the foundation for the development of Nimotoons, the graphical environment for Nimo. The version being presented in this paper represents a significant advancement from the earlier work, with a focus on the new features and their potential applications. Notably, the inclusion of red multi-edges signifies the shared expressions generated by the duplicators. In Nimo, only constant values such as circles and list-ends are physically duplicated, with all other subnets being shared. However, to address potential confusion caused by shared expressions, the option for enforced duplication has been introduced. This can be achieved either locally on an in port or by utilizing a special-purpose process called the double-green-triangle, which precedes the output of a subnet containing shared expressions. 

Type inference in Nimo is both static and incremental, ensuring type consistency for each connection during net construction. The system is a graphical extension of the classical Hindley/Milner algorithm and is capable of handling multiple outputs and curried/uncurried conversion. A type graph associated with the net is incrementally constructed and evolves in parallel with the net.

Several other languages and tools share similarities with Nimo. For example, Gemcut is a graphical viewer for functions in a Haskell-like language called Cal, where the editor utilizes the inference system of the Cal compiler to prevent type errors. In Nimo, type inference is also performed graphically to provide the user with real-time visibility into the inference process. Additionally, tools like Typetool and System I are web-based applications designed for visualizing type inference of lambda terms, with a focus on teaching the basics of type inference algorithms for functional languages.

In terms of evaluation modes, a similar tool called Ptolomy employs a visual language based on actors with communicating interfaces, where parameters are displayed in separate windows. Notably, in Nimo, all program states are visualized, while Ptolomy deals with continuous data and operates under a uniform evaluation policy across various domains, such as the process network domain, which aligns with a data-driven policy.