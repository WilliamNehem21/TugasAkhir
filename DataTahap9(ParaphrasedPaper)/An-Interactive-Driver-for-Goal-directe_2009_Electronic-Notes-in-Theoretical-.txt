The traditional approach of presenting a proof in its foundational dialect does not account for the interactive nature of the tool. Users are not given any insight into the underlying processes or the reasons for possible failures when using automatic procedures. In the context of a didactical environment, it is important for untrained users to have the freedom to use automation facilities while also being able to comprehend the workings of the automatic procedure and understand the reasons for its failures.

To address this issue, we have developed an SLD engine that performs backtracking without relying on the call stack, and uses a carefully chosen selection function to provide users with a clear view of the ongoing computation.

In our implementation, the SLD resolution rule is represented as the apply tactic in Matita, allowing for interactive usage where the user provides the goal and the clause, and the outcome is a proof status or an exception if unification fails.

In order to present the user with only viable alternatives, the computational rule not only identifies good candidates, but also attempts to apply them, pruning false positives. Additionally, applying all found lemmas allows the system to sort these alternatives, such as by the number of newly opened goals.

The user interface displays the lemmas that can be applied to the conjecture, allowing users to interact with the choices and view additional information about the lemmas. The automatic procedure also finds relevant lemmas for the current conjecture, applies them, and evaluates the results. If one application fails, the next alternative is attempted, and if no alternatives remain, the system moves to the next alternative of the previous line.

When solving subgoals, the system may instantiate metavariables in a way that affects other goals, so the user is provided with a list of candidates associated with the subgoal and can interact with it.

To present this information to the user, the search procedure must be stackless and all information must be accessible through the graphical user interface. To achieve this, the procedure is designed as a tail-recursive function, keeping the computation tree and necessary information as a first order object that can be passed to the GUI.

The system uses decorators to indicate the status of goals, distinguishing between goals that are yet to be processed and those that have been solved, and may cache their proofs for future use.

To limit the exploration of the search tree, additional fields are added to the element structure, representing the depth and size of the tree. This allows for efficient tracking of the depth or size of the tree and ensures that the search process adheres to predefined limits.

The GUI and the automatic procedure run in different threads, with a communication mechanism in place to allow the automatic procedure to check for a pause signal from the GUI. The computation status is purely functional, and the GUI thread renders it by accessing a global reference to this variable.

Overall, our approach aims to provide users with a clear understanding of the automated proof procedure, allowing for interactive usage while maintaining transparency and clarity in the reasoning process.