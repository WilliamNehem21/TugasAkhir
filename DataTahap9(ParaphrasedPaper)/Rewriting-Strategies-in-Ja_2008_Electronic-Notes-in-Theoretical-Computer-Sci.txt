In any language designed for expressing transformations, the concept of a rewrite rule is a fundamental feature valued for its conciseness and strong theoretical foundation. Complementing this notion, the concept of a strategy describes the application of rules and is depicted as crucial. In this paper, we demonstrate the implementation of a high-level strategy language in a Java environment. We introduce the integration of the visitor combinator design pattern into TOM, serving as an interpreter for strategy expressions. To improve efficiency, we propose a compilation method based on bytecode specialization. Notably, this low-level transformation is expressed in TOM itself, utilizing rules and strategies.

The primary advantage of using strategic rewriting systems lies in their concise nature and robust theoretical foundations. In practice, elementary program transformations are explicitly represented as rules within the program, while separately defined strategies offer precise control over the application of these transformations. The separation of rules and strategies serves to ensure properties such as correctness and termination. In the context of constructing optimizers, a comprehensive library and support for built-ins such as integers, floating-point numbers, strings, input/output operations, and system calls are provided. Simultaneously, the design of the language is constrained, requiring the introduced constructs to be compatible with the Java model and syntax. In this paper, we present an overview of the TOM language in section 2, followed by the demonstration of how strategic programming, originally pioneered by OBJ, ELAN, MAUDE, and STRATEGO, can be integrated into the Java programming environment in section 3.

One of the main contributions of GOM is the provision of a hook mechanism for defining canonical forms that must be preserved. Essentially, a construction function can be associated with each algebraic operator, ensuring that terms are maintained in a normal form and thereby preserving invariants. For instance, we define a hook attached to the addition operator, ensuring automatic simplification when combined with a neutral element.

TOM is a language extension that adds pattern matching primitives to existing imperative languages. Pattern matching is directly related to the structure of objects, making it a natural programming language feature commonly found in functional languages. The unique aspect of the TOM system is its language and data-structure independence. From an implementation standpoint, it serves as a compiler accepting different host languages, with its compilation process involving the translation of matching constructs into the underlying native language. Since GOM generates Java implementations of terms, we consider Java as the host language.

The combination of basic strategy combinators and Java has been pioneered by JJTraveler. In this work, the key contributions include the ability to define elementary transformation rules using %strategy, the introduction and implementation of the explicit recursion operator mu, as well as the automatic generation of congruence operators. These contributions significantly enhance the usability of the framework and promote the adoption of formal methods in the Java community.

To create type-safe user strategies, we introduce a combinator called "fwd," which depends on the typed interface of the tree structure. The objective of this combinator is to dispatch the call to the generic "visit" method to type-specific transformation methods. Users can define new transformation strategies by extending this "fwd" class and redefining the typed variants of the "visit" method, ensuring type-preserving transformations.

The visit method of the "fwd" combinator invokes the "accept" method when applied to a term belonging to the "Pico" module (i.e., an instance of "PicoAbstract"), falling back to the default strategy otherwise. Each specific type-preserving "visit" method is implemented as a call to this default strategy.

The TOM formalism is particularly well-suited to describe low-level transformations directly on bytecode programs. In the following sections, we demonstrate how a compiled Java class can be analyzed and transformed using TOM, providing experimental results of optimizations on strategy code.

A key characteristic of Java is its targeting of a standard, machine-independent, low-level bytecode as the compiled form of programs, interpreted by the Java Virtual Machine. This makes it natural to perform program transformations at the bytecode level, often used to provide language extensions such as aspect-oriented programming, conduct sophisticated static analysis, generate middleware code, or improve runtime performance.

Previously, the efficiency of strategies was hindered by the implementation using the visitor combinator design pattern. Each strategy combinator is parameterized by strategies, and the visit method of a combinator calls the visit methods of the parameters. When dealing with a large strategy term, a significant portion of time is dedicated to these visit calls.

To express low-level program transformations, such as those involving Java bytecode, we illustrate bytecode transformations through the just-in-time compilation of strategy expressions using partial evaluation techniques. To facilitate this transformation, we present a TOM library built on top of ASM, allowing for the algebraic transformation of bytecode expressions. Leveraging the reflective properties of our strategy library, we use strategic programming to traverse the bytecode representation of strategy expressions, perform analysis, and conduct inlining.

In this paper, we have presented rules for method inlining on strategy codes. A logical next step would be to add new rules to implement classical loop-invariant code motion. Due to the recursive operator, the strategy code can contain nested loops, making it interesting to eliminate computations that can be performed outside.

Two real-life applications utilizing strategies are presented as examples. The first, a structure example, is a theorem prover in the calculus of structures, showcasing the traversal of a proof term to apply deduction rules. The second application involves manipulating polynomial expressions to find quasi-interpretations of functional programs, requiring traversals for transformations and substitutions.

Overall, this paper demonstrates the potential of strategic rewriting systems for low-level program transformations, exemplified by bytecode optimizations using strategic programming techniques.