Despite its numerous advantages, using JNI in its most basic form is both laborious and error-prone. It can be likened to conducting assembly programming on the JVM. Our objective is to make the interaction between Java and Haskell via JNI as convenient as programming directly in Java.

Typically, each native method implementation is furnished with an additional JNI environment (JNIEnv) argument, along with a reference to a Java object (jobject) or a Java class object (jclass) for static methods. The JNIEnv argument serves as an interface pointer through which the native method can communicate with Java, such as accessing object fields or invoking the JVM. The jobject (or jclass) reference represents the 'this' pointer (or class object) in Java.

Haskell interpreters, like Hugs, do not inherently support statically exported functions. However, we can dynamically export Haskell functions as if they were C function pointers. This capability greatly enhances programming with callbacks, as illustrated in the following example.

The Diethep component builds upon the foreign function interface defined for Haskell in previous papers and enables us to treat any Haskell module as an ordinary DLL. Clients of Diethep observe no distinction, aside from the added flexibility of specifying the calling convention at runtime when using GetProcAddressEx, between using an ordinary DLL via kernel32.dll and utilizing the Diethep primitives. Employing Diethep's extra level of indirection allows for abstraction from the underlying Haskell implementation, provided it supports the Diethep interface.

At this stage, we have demonstrated the fundamental integration between Haskell and Java. We plan to enhance the bindings to make them more user-friendly through several steps: abstracting commonly recurring patterns, concealing the explicit threading of the JNIEnv argument throughout all JNI-related code, and utilizing overloading to conceal the encoding of result types in JNI methods.

The JNIEnv pointer is only valid within its associated thread, so it cannot be placed in a global variable directly. However, the JavaVM pointer remains valid across different threads and can be safely placed in a global variable. To achieve this, we need to acquire the JavaVM pointer in which the current thread is running. We anticipate that current and future JNI implementations will provide a way to accomplish this, following the suggestions made by Liang in section 8.1.4.

Before we proceed with using overloading to streamline JNI, we need to briefly discuss marshalling. In section 3.1, we assumed the existence of a function `marshallString :: String -> IO CString` that takes a Haskell string and returns a pointer to a null-terminated array of characters.

Several points are noteworthy regarding the above code. First, it strongly depends on lazy evaluation, as the function `methodDescriptor` is contingent on the types of its arguments rather than their values. Secondly, the call to `unsafePerformIO` is solely to remove the `IO` from the result type of the `callMethod` function, which is entirely safe.

The preceding scenario is the only instance where we have to explicitly perform an upcast in Haskell. The question remains on how to handle the occasional necessity for downcasting. In Java, it is possible to perform unsafe casting between arbitrary classes, potentially resulting in a `ClassCastException`. Attempting to perform illegal arbitrary casting using Haskell's `cast` function may lead to a `ClassCastException` or other exceptions being thrown in Java, or result in an error being signaled by one of the underlying JNI entry calls.
The Haskell wrapper will capture these errors and convey them to the Haskell level by raising a `UserError` when returning, implying that using `cast` to simulate arbitrary Java casting in Haskell is no more or less safe than arbitrary casting in Java.

Lambda assists with tool support in conjunction with HDirect. HDirect is IDL-based, so assuming we can derive an IDL specification from a Java class or interface, HDirect will handle the generation of valid Haskell stubs. We accomplish this by offering a tool that utilizes the Java Reflection API to generate IDL interfaces (annotated with custom attributes) corresponding to Java classes or interfaces. With this information, HDirect is then able to automatically generate the Haskell callable stubs as described in this paper. HDirect is also capable of generating Java callable stubs for Haskell-implemented classes and methods.