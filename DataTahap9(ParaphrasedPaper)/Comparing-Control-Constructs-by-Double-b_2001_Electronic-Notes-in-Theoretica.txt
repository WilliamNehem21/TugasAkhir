A bewildering variety of control operators exists, often leading to the use of the same term to refer to distinct constructs, as observed with "catch" in early Scheme or "throw" in Standard ML of New Jersey, which actually differ significantly from the "catch" and "throw" in Lisp despite sharing the same names. Furthermore, it is noted that the Lisp "catch" is fundamentally similar to exceptions, despite their dissimilar and more complex appearance.

The labeling and jumping in control operators are manipulated symmetrically, with "here" making the jump continuation the same as the current one, while "go" sets the current continuation of its argument to the jump continuation. The additional jump continuation does not interact with the clauses for variables and applications; the former ignores it, and the latter distributes it into the operator, the operand, and the function call.

In the typing of call/cc, a "go" is potentially exported from its enclosing "here" (depending on "f"), while in the derivation of right exchange, a "go" is imported into a "here" from outside. Static binding is what makes everything work in these cases.

In both cases, the dynamic jump continuation "d" is fed to each function call but is never actually needed. Each function definition must expect this argument to be of a certain type. Because different calls of the same function may have dynamically enclosing "here" operators with different types, the type ascribed to "d" should be polymorphic.

In this paper, control constructs were compared by CPS transforms and typing of the source. A different but related approach compares them by typing in the target of the CPS. On the source, there is a dichotomy between intuitionistic and classical typing, whereas on the target, the distinction is between linear and intuitionistic typing. The hope is to relate these concepts in further work.