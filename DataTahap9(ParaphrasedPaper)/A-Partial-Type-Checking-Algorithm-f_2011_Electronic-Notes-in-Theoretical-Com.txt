Our primary contribution is to demonstrate the soundness and partial completeness of our approach. We define partial completeness as the guarantee that if the algorithm diverges, it is solely due to the presence of a loop within the program, its type, or their combination, rather than an error in the algorithm itself. Consequently, establishing termination for a given program point is sufficient to demonstrate that the algorithm is complete and effectively determines the typing relation. We view this as a promising approach because it enables the independent verification of fundamental syntactic properties of the typing algorithm, regardless of termination.

We initially present the type:type and verify some fundamental properties. Subsequently, we outline the type checking algorithm in relational form and validate the soundness of the inductive type checking relation. The completeness of the coinductive relation is then established using coinduction. Finally, we present an implementation of the algorithm in Haskell and discuss potential expansions of our current work.

The evaluation is lazy, with values represented as closures clos t rho, which are pairs consisting of an expression t and an environment rho. When type checking the body of an abstraction, the free variable is assigned a unique identifier, referred to as a generic value gen by Coquand. Consequently, the environment component rho may map variable names to either generic values or closures in turn. The (Haskell) type e of environments is passed as an argument.

The weak head normal form (WHNF) of a closure may either be an introduction, wtype, wpi, or wabs, or an elimination of a generic value, wne, i.e., an identifier applied to several closures. Evaluation does not proceed under binders, therefore the WHNF of a function closure clos(abs x t) rho is simply wabs x t rho, which must be recursively evaluated. Alternatively, it may be a generic value if x has become free by stepping under its binder. Applications are the source of redexes, which are resolved lazily (call-by-need), using the function app. Expressions of the other shapes, abs, pi, and type, are already in their WHNF.

We encapsulate the context within a monad of class monadcxt. The context provides both a type and a value for each name. The bind operation extends the context with both the type and the value, while new extends it with the given type, creating a new generic value. Newj creates just a generic value in situations where its type is irrelevant.

The input to the type checker consists of declarations in the form x: a= t, indicating that the name x has type a and definition t. The type checker will first ensure that a is a well-formed type, evaluate it lazily, then check t against the value of a, and finally bind x to the type value of a and the value of t in the current environment before moving on to the next declaration.

We implement contexts as finite maps from names to their type and value. They also handle the generation of fresh identifiers, with the next unused generic value stored in the field nextfree. Cxtlookup retrieves the type of a name, cxtext binds a type to a name, and cxtbind binds both the type and value to a name.

During type checking, we need to query the context and raise errors. The type checking monad wraps a reader monad readert cxt (provided in module control.monad.reader) around an error monad either string. The implementation of the monadcxt operations accesses the context through the monadreader operation ask and modifies it through local. The reader monad here is only used to conceal the plumbing used in a standard implementation of static binding. In particular, the implementation of shadowing of variables is achieved by replacing the previous definition.