The focus of our research is on identifying suitable models of reversibility that are applicable to functional programming languages. Functional languages are particularly relevant in a reversible context for two main reasons. Firstly, they are easier to analyze and verify properties about, which is advantageous for understanding the logic behind reversible programming. Secondly, they are inherently non-stateful, which facilitates the process of reversing programs. However, it is worth noting that existing reversible functional programming languages (as cited in [20,34]) still lack several desirable constructs that are common in the irreversible setting.

In contrast, irreversible functional programming languages like Haskell naturally adopt semantics in categories, where objects represent types and morphisms represent functions. Functional languages, being non-stateful by definition, are characterized by categorical semantics that only model pure functions. However, there are situations in which non-functional side-effects, such as exceptions, input/output, or state, can be useful. Irreversible functional languages elegantly address this using monads or more general constructs known as arrows.

The objective of this paper is to provide guidance on the design principles of robust reversible programming languages. The primary contribution lies in aligning desirable programming concepts with precise category-theoretic constructions. Consequently, this paper takes a theoretical perspective. To provide more context for readers with a practical background, we adopt the syntax of a typed first-order reversible functional programming language with type classes. We commence with an introduction to reversible base categories in Section 2.

Analogous to the approach taken in the reversible programming language Janus, variable assignment operates by means of built-in reversible update operators. For instance, the prohibition of destructive updating necessitates the updating of state using operators such as addition of a constant or the contents of another variable.

Bidirectional arrows offer a similar approach to invertibility. However, while the objective of inverse arrows is to add effects to already invertible languages, bidirectional arrows serve to introduce invertibility to otherwise uninvertible languages. Consequently, bidirectional arrows address different concerns than inverse arrows and do not guarantee invertibility in the general case.