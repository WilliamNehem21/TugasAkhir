We have developed a Haskell interpreter capable of handling various evaluation strategies and combined it with profiling tools to analyze the impact of these strategies on the performance of selected parallel skeletons implemented in Eden. The objective of this study is to move beyond experimental evaluations and conduct a more rigorous and comprehensive comparative analysis. The contributions of this paper include expanding the range of evaluation strategies that blend laziness and strictness, as well as formalizing each evaluation model. Although our study is centered on Eden, the concepts and findings can be applied to other parallel functional languages.

The paper is structured as follows: we provide a brief introduction to parallelism in Eden and describe the calculus used for our analysis. We then discuss possible evaluation strategies and classify them into three concepts. In the subsequent section, we present a distributed operational semantics for the calculus and formalize the previously defined evaluation strategies. We offer a collection of examples in the following section to illustrate how evaluation strategies can impact issues such as termination or deadlock. We conclude with a summary discussion on combinations of laziness and eagerness, and outline future research directions.

The underlying question in all of these discussions pertains to the allocation of computation between processes: how much work should be performed by the parent (or producer) of a process (or value), and how much work should be delegated to the child (or consumer)? This is a critical aspect of any parallel language and is not specific to Eden, although the features of Eden may provide more opportunities for exploration.

For instance, if free variables are required to be evaluated to weak-head normal form (WHNF) before being copied (i.e., eager-before-copying is enabled), the evaluation process may never terminate due to the impossibility of communication from the main process to its child. We also discuss the issue of losing currying in the first approach, and a less elegant yet currying-preserving alternative in the second approach, where the programmer only needs to force the evaluation of each desired free variable before creating the process.

Looking ahead, we plan to explore the application of similar techniques to other parallel functional languages like GpH. Additionally, we intend to expand the calculus to encompass other Eden features such as streams, enabling a more comprehensive consideration of the various semantic options and an analysis of the impact of these evaluation strategies on Eden skeletons.