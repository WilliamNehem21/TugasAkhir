The article is structured as follows: Section 2 introduces the updated version of the rule validation (Val) and compares it to its previous iterations. Section 3 focuses on describing the new method of generating invariants, which is the central topic of the paper. In Section 4, a new approach to computing data mapping associated with the new invariant generation process is discussed. The paper concludes in Section 5.

Alternative methods [8, 11] have explored translation validation for less restricted programming languages, such as those permitting nested loops, and have also investigated a wider range of optimizations. However, these methods were constrained to structure-preserving optimizations and were unable to directly address more aggressive optimizations involving code motion or loop reordering transformations.

The technique termed tvoc-sp derives invariants through fixed-point computations based on reaching definitions. However, for certain code, tvoc-sp fails to establish valid verification conditions as it cannot generate the invariant n3= 500 at location 5. The subsequent section introduces an invariant computation method capable of easily identifying this invariant.

The generation of invariants poses the most formidable challenge in the application of the validation (Val) technique. A novel invariant generation process is detailed in this section, which operates on intermediate representation (IR) programs in static single assignment (SSA) form. Since the current data-flow based method implemented in tvoc is strictly syntactic, and the new method involves semantic aspects, we anticipate that it will be both more efficient and capable of producing a greater wealth of information than the data-flow based method.

Moreover, irrespective of whether x is a loop header or not, the condition gen(x) holds after block x is executed. Consequently, out(x, g) represents a combination of in(x, g) and gen(x). Given that in(x, g) is assumed to be sound, the soundness of out(x, g) naturally ensues. According to Theorem 3.1, our method, which does not iteratively propagate information, is unable to determine for every initial location i of the control flow graph (CFG) to succeed. Similarly, the invariance of ai= bi in all cutpoints where ai and bi are defined is established by the value numbering algorithm but remains beyond the capability of our method due to its inability to navigate around loops.

Our technique may also be applicable to verifying properties of microcode. For instance, it may facilitate extending the work on proving backward compatibility of loop-free microcode, as described by Zhang et al. [reference]. Furthermore, we anticipate that the techniques employed in our work may be applicable to property verification of microcode programs.

Reference:

Zuck, L., Pnueli, A., Goldberg, B., Barrett, C., Fang, Y., & Hu, Y. (2005). Translation and run-time validation of loop transformations. Journal on Formal Methods in System Design, 27(3). (Preliminary version appeared in Proceedings of the Run-time Result Verification Workshop, Electronic Notes in Theoretical Computer Science (ENTCS), 2002, 70(4).)