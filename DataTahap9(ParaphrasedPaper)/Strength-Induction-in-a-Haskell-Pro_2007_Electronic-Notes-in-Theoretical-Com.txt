This paper outlines several strategies employed in Plover, an automated property verification tool designed for Haskell programs within the Programatica project. The tool's aim is to demonstrate the feasibility of automatically verifying formally specified properties of computer programs. Plover can ensure various useful properties based on the soundness of automated reasoning in a formal logic. Specifically, it implements reasoning in P-logic, the verification logic of Haskell98.

There are other language-specific verification logics, such as ACL2 for Common Lisp and Sparkle for Clean 2.0. When assertions are formulated in a language-specific verification logic, it eliminates the need to translate expressions and their asserted properties into another logical formalism, reducing the risk of introducing errors during the translation process.

Every predicate form defined in P-logic follows a typing discipline, where a predicate refines a Haskell type. P-logic offers basic constructions for unary predicates, including the arrow constructor (->), finite tupling, predicate constructor application, and predicate disjunction. Additionally, P-logic includes advanced predicate constructions that go beyond the constructions of Haskell types, such as predicate disjunction 2, predicate negation 3, predicate abstraction, least and greatest fixed-point constructions, and comprehensions utilizing formulas with quantified object variables.

The strategies employed in Plover include the use of data constructors as strategy constructors, where a data constructor, when lifted to become a strategy constructor, is satisfied by a term built with the same data constructor and its argument terms satisfying the respective strategy arguments given to the strategy constructor. The "id" strategy, a library strategy that always succeeds and leaves the current term and bindings unchanged, is used as an argument to a lifted strategy constructor, analogous to a wildcard designator in a pattern.

The paper provides examples of alternative strategies and discusses the use of the "whnf" strategy, defining its first and recursively defined alternatives. It further discusses the "replace" definition and outlines how the last alternative, separated by the operator symbol (<+), designates left-biased choice rather than nondeterministic choice of alternative strategies.

The paper also explores the use of structure-determining types in Haskell programs, emphasizing their greater utility in Haskell compared to many other languages. Additionally, it explains the semantics of let expressions and the order of listed definitions in Haskell.

In summary, this paper presents an overview of the strategies used in Plover, highlighting the power of strategies for controlling rewriting and providing an example of normalization strategies to achieve different normal forms for a simple lambda calculus. The paper emphasizes that Plover employs more than just normalization to verify Haskell programs.