The pervasive use of resource-constrained embedded systems has made them vital components, necessitating programmers to ensure strong guarantees about their runtime behavior to enhance reliability. One of the essential requirements is to provide an upper limit on live memory during runtime to prevent heap overflows. This paper introduces a semi-automatic technique to infer the space complexity of ML-like programs with explicit region management, aiming to unify existing formalisms to obtain consistent space complexity analysis for both imperative and purely functional programs.

The proposed approach involves the development of a programming language resembling ML that incorporates both purely functional and imperative features, along with an explicit region mechanism. Program memory interactions are captured through a static type and effect system, along with manual memory management using region-specific primitives. The type system aims to ensure compile-time absence of memory-related errors. The framework aims to combine various memory consumption analyses depending on the programming style used at the function level, providing an upper bound on live memory at compile time. The paper also explores related works, presents the language and its type and effect system, discusses how to handle purely functional and imperative features, and integrates them into a consistent framework. Additionally, it demonstrates the application of the proposed technique on an example and concludes with a discussion on current limitations and potential future enhancements.

The analysis builds on existing work in resource consumption analysis, adapting techniques developed for Lisp to analyze memory consumption based on recurrence relations. The paper describes previous projects such as RAML and RAJA, which infer upper bounds on live memory considering side-effects without user annotation. Additionally, the paper discusses the use of invariants over iteration spaces, outlining their application in the context of the proposed language and how they enable the inference of program space complexity.

Furthermore, the paper outlines the mechanisms for memory management in the proposed language, emphasizing the role of region handlers, capabilities, and the primitive operations for managing regions and accessing values within them. It discusses how these mechanisms provide an abstract view of the heap at compile time, thereby aiding in resource consumption analysis.

The proposed analysis considers both purely functional and imperative styles of programming, utilizing a language's effect system to distinguish between them. It presents the necessity of handling side effects through reference updates and outlines the analysis based on invariants on iteration spaces for imperative programs. It describes the constraints imposed on composing the analysis to ensure its accuracy and demonstrates the application of these techniques through examples.

In summary, the paper presents a comprehensive framework for analyzing the space complexity of ML-like programs with explicit region management, combining various formalisms and analyses to provide upper bounds on live memory at compile time, thus preventing heap overflows and enhancing the reliability of resource-constrained embedded systems.