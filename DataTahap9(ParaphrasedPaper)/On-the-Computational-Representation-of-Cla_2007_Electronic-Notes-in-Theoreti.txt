Several programming calculi have been developed to establish a correspondence with a logical proof system, also known as the Curry-Howard correspondence. In recent years, there has been a growing interest in designing calculi that explore the computational aspects of classical logic. Various authors have chosen different sets of primitive logical connectives and developed the syntax and reduction rules of their calculi accordingly. The implication connective is particularly popular due to its well-understood computational relationship with function abstraction and application. However, there are calculi that do not use implication, such as the one introduced by Wadler. In addition to implication, some calculi employ conjunction, disjunction, negation, and even more obscure connectives such as difference and constants for truth and falsity.

Defining the appropriate extra-logical reduction rules becomes necessary when introducing new syntax constructs into a calculus. Each new syntax construct necessitates a logical rule to specify a renaming of its introduced connector through a cut with a capsule. Furthermore, for each logical connective employed, a logical rule must be defined to demonstrate how a cut between the right and left introduction of the connective may be reduced. This facilitates the generation of new cuts between their subterms and simplifies the task of cut-elimination. The principal rule is the only one that cannot be methodically derived independent of the particular connective concerned. Therefore, when investigating the representation of a specific connective, we will only consider the principal logical rule for that connective in relation to reduction rules.

Regarding the analysis of logical connectives, we are primarily interested in connectives of arity 2 and below, as this is a common choice in the literature. Exploring connectives of higher arity is considered impractical due to the complexity involved. We will present the complete set of possible binary connectives and analyze them based on three questions outlined earlier. We aim to identify possible relationships between these connectives and examine how these relationships are reflected in their computational counterparts. The concept of duality, for instance, is known to relate binary logical connectives, and it will be demonstrated that this relationship carries over into their computational behavior.

It should be noted that employing multiple logical connectives in a term calculus can lead to the creation of untypeable cuts between their respective syntax representations, for which no reduction rule applies. Therefore, the notion of normal form is extended when dealing with more than one logical connective, allowing for the existence of untypeable normal forms that contain cuts.

Furthermore, we will explore the simulation capabilities of certain connectives, demonstrating that a calculus can encode the syntax of these connectives in a way that preserves reductions. When a calculus can computationally express a connective, it means that the connective can be simulated in a computational sense, even if it may not be expressible in a logical sense.

Additionally, we will investigate the computational capabilities of iff-terms and their potential to model a variety of computational behaviors, some of which may be novel.

Finally, the generic mechanism provided by the propagation and renaming rules in an 'x-style' term calculus is capable of simulating the reductions of 'x'. This mechanism performs the basic task of pushing cuts through subterms and renaming connectors, irrespective of the employed syntax.