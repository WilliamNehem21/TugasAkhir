In this research paper, we introduce an algorithm to translate security protocol specifications written in the HLPSL language, which is developed within the Avispa project, to a variant of the Applied Pi Calculus. This translation algorithm has two key scientific contributions: firstly, it offers an independent semantics of the HLPSL specification language, and secondly, it enables the verification of protocols specified in HLPSL using the ProVerif tool based on the Applied Pi Calculus. We have implemented and tested our technique on various security protocols, demonstrating its capability to handle a significant portion of the protocols modeled in HLPSL.

The HLPSL language is the input language for the Avispa tool. The Avispa tool takes an HLPSL specification as input, translates it to IF, and analyzes the result by invoking state-of-the-art back-ends, which then return any detected attacks to the user. Given the diverse capabilities of different verification tools, it is important to integrate HLPSL with other tools for the verification of security protocols. The available back-ends of the Avispa tool are based on three distinct technologies, covering a broad spectrum of the research landscape in security protocol verification.

In this paper, we propose a method for translating specifications in a subset of HLPSL to a dialect of the Applied Pi Calculus, supported by the ProVerif tool. This allows for the verification of secrecy, weak authentication, and strong authentication properties of HLPSL specifications by invoking ProVerif on the translated result, thereby expanding the available formalisms and technologies for HLPSL.

The paper is organized as follows: Section 3 describes the dialect of the Applied Pi Calculus to which the translation is performed, Section 4 details the translation algorithm, Section 5 explains how ProVerif can be used to verify the outcome of the translation, and Section 6 provides implementation details and experimental results on a selection of cryptographic protocols modeled in HLPSL within the Avispa project.

In HLPSL, protocol specifications are categorized into roles, with some serving as basic roles to describe the actions of a single agent in a protocol run, and others as composed roles, which instantiate basic roles to model an entire protocol run or session involving multiple agents.

Variables and constants in HLPSL are typed, with types including agent, channel, public key, text, nat, bool, symmetric key, message, function, and protocol ID. Transitions in HLPSL are defined by a label, trigger event, and action, and are non-deterministically chosen and executed when multiple events are satisfied.

The main role in an HLPSL specification must declare a constant representing the intruder and may also specify the initial knowledge of the intruder. Composed roles in an HLPSL specification form a tree, with the main role as the root. To translate composed roles, the tree structure is flattened by substituting role instantiations and using the parallel composition operator of the Pi Calculus. Additionally, constants declared in composed roles are renamed to avoid clashes, and are treated as free constants unknown to the intruder.

It should be noted that the semantics of HLPSL is not clearly defined. In some cases, decisions had to be made on interpreting HLPSL constructs, with an effort to follow the semantics implemented in the Avispa tool as closely as possible.

For instance, in the subset of HLPSL used in this study, it is not possible to model a scenario where a role receives a private key via a channel and decrypts a message using this private key. This limitation is due to the requirement that the private key must be known to the role at the start of its execution and included in the role's text using the 'inv' constructor, aligning with the Avispa tool's current lack of support for processing such situations.

In our experiments, ProVerif did not terminate on the specification of the ISO3 protocol, while for the other protocols, we identified known attacks against flawed protocols and verified the correctness of the sound ones. Notably, the attacks found aligned with those detected by the Avispa tool using OFMC as the back-end.

In conclusion, future work involves assessing the scalability of our approach through the identification of more complex protocols and exploring the use of other verification engines for the Applied Pi Calculus. One potential approach is to utilize the HAL model checker, given its effective handling of fresh names generation.