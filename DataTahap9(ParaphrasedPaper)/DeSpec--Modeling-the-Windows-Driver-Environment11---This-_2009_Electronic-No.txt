In recent years, there has been a growing focus on ensuring the correctness of Windows kernel drivers, which is crucial for maintaining the stability of the entire operating system. Microsoft has developed various tools for driver verification, including the latest static driver verifier model checker. However, the effectiveness of model checking in this context depends on the selection of an appropriate environment model. The current environment models used in existing tools suffer from two main limitations: they are overly non-deterministic, thereby compromising the precision of the model checker reports, and they are too simplistic, limiting the ability to verify specific properties of drivers. Furthermore, these models do not provide a formal or readable specification suitable for documentation purposes. This paper addresses these issues by introducing a new language for the formal specification and modeling of kernel drivers and their environment.

Kernel drivers in the Windows environment are typically small libraries written in the C language, running in a privileged mode that allows direct interaction with hardware. As a result, errors in drivers pose a significant risk to the stability and security of the operating system. Consequently, verifying the correctness of drivers is a critical aspect of software verification.

The remainder of the paper is organized as follows: Section 2 provides a brief overview of the Windows kernel environment focusing on driver verification. Section 3 introduces the Despec language, demonstrates its usage through an example, and explains how a model extractor should work with Despec specifications. Section 4 discusses related work, and Section 5 presents the conclusion.

The Despec language is designed as a bridge between the constructs of the C language and their models in the Zing language. It hides the models of constructs such as pointers, function pointers, unions, and other features that are not directly expressible in the Zing language behind the syntax of the Despec language. This design allows for the adjustment of models for these features without the need to rewrite the specifications.

Certain constructs that exploit memory layout, such as reinterpreting casts or unions, cannot be feasibly modeled and are not directly expressible in the Despec language. However, it is expected that these constructs will be used rarely, as the driver and environment interface should be as platform-independent as possible.

The Despec language shares a syntactical structure similar to that of C#. Each source file contains a list of declarations grouped into namespaces. Declarations include classes, integer enumerations, integer ranges, method delegates, method groups, and rules. A class declaration comprises its members, which, in addition to fields and methods common to standard object-oriented languages, can also contain rules that specify constraints on fields and methods using temporal logic patterns.

The method signature abstracting a kernel function defines the treatment of parameters within the specification. The placeholder token (a single underscore) is used for arguments that are not essential for the specification. Moreover, the Despec language distinguishes between synthetic and non-synthetic classes, methods, and attributes.

The Despec language allows for the declaration of synthetic classes, methods, and attributes, each serving specific modeling purposes. For instance, the language enables the declaration of synthetic attributes, methods, and classes, which can be used solely for modeling purposes. Notably, all elements used in the first example are non-synthetic.

The Despec language includes a mechanism for specifying temporal logic patterns. Each temporal logic pattern is formed by pattern keywords and pattern expressions, consisting of the property and the scope. These patterns can be split into two parts: the property and the scope, with the property being a boolean expression.

The Despec language also supports instance rules, which are implicitly quantified by a variable of the declaring type. Instance rules can refer to that variable using the "this" keyword, which can be omitted when referring to the instance members of the type. Unlike Bandera, Despec allows quantification over value types.

Once the top-level model is chosen, the model extractor generates a Zing model of the driver using its C source code and kernel headers, and combines it with the environment model. However, since the resulting model is too large to be verified, slicing should take place, retaining only those parts transitively referred to by the top-level model and the constraints being verified. The final result is a Zing model of the driver and the related kernel functions and structures.

In addition to model checking, detecting errors in drivers can also be done using Microsoft's Prefast tool, which performs static analysis of the source code to identify common error patterns such as memory leaks, dereferencing of null pointers, buffer overruns, and kernel functions called on incorrect IRQL levels. However, the analysis is function-scoped, leading to false negatives and a restricted set of detectable errors.