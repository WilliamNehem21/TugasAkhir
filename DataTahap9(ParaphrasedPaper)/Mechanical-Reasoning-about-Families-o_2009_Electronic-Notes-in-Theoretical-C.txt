The Unifying Theories of Programming (UTP) offer a framework for integrating various programming languages with different computational paradigms within a unified relational model. This framework encompasses imperative, functional, declarative, and concurrent languages, identifying common features and providing a uniform semantic presentation of programming theories. Additionally, it facilitates the formulation and reasoning about links between different programming theories, and serves as the basis for the semantics of various integrated programming and modeling languages. 

However, the existing semantic encoding presents subtle challenges when reasoning about refinement statements. These challenges stem from the lack of a dynamic notion of UTP theory and theory instantiation in the encoding. Instead, the encoding introduces a global universe of variable names without imposing any restrictions on their types. This approach introduces two problems: firstly, the axioms would restrict not only the predicates of a single UTP theory, but all UTP theories within the current proofpower theory scope. Secondly, the hierarchical organization of UTP theories poses limitations on the coexistence of predicates with different types within the same proofpower theory scope.

To address these limitations, a dynamic approach to the hierarchical presentation of UTP theories is proposed. This dynamic approach aims to enable the coexistence of predicates with different types within the same proofpower theory scope. 

The paper further details the main principles and ideas of UTP in section 2, and presents the relevant parts of their semantic encoding in section 3, defining the notion of alphabetized predicate, UTP theory, and instantiation. Sections 4, 5, and 6 discuss reasoning about UTP theories in general, refinement laws and reasoning about specific specifications, and the formulation and proof of properties about theory links, respectively. Section 7 discusses relevant design issues and revisits the introductory refinement conjecture, while section 8 presents the conclusions.

The alphabet of a theory defines the relevant observable properties, which may include state variables, auxiliary variables recording program termination or traces of events during program execution. Healthiness conditions are used to identify the set of predicates with the right alphabet that belong to the theory.

Operators in UTP include skip, assignment, and conditional operators, which need to be parameterized with an alphabet. The semantic model for an alphabetized predicate is a set of bindings describing the valuations that render it true, subject to type restrictions.

The UTP theory allows for the representation of arbitrary instantiations of UTP theories within the same proofpower reasoning scope. This facilitates the construction of theories through generic instantiation, strengthening existing theories, or specific instantiation of common UTP theories.

Instantiation is motivated by the need to reason about the predicates of particular UTP theories and construct verification arguments based on refinement. Additional means to characterize the predicates of these theories are provided, such as the function theorypredicates.

The paper also presents alternative approaches to express refinement laws specific to particular UTP theories, as well as solutions to handle type restrictions in certain UTP theories. The provided semantic encoding in proofpower-z allows for reasoning about specific instances of theories, in addition to theories in general.