In previous research, the influence of design choices on performance was investigated in the context of the Kool programming language, which is a pure, object-oriented language defined using rewriting logic semantics. The study concentrated on two specific aspects of language design: the representation of all values as objects and the use of a global flat memory representation. Enhancements to these facets led to significant improvements in performance. To address the first aspect, scalar values were introduced alongside objects, with the implementation of auto-boxing functionality to convert scalars to objects as necessary. For the second aspect, memory was partitioned into pools, one for shared memory and another for memory locations visible in a single thread. These modifications substantially enhanced performance, with auto-boxing also contributing to improved execution performance.

It is noted that in the Silf programming language, dynamic memory allocation and taking the addresses of variables are not possible. Consequently, it is feasible to discard all memory allocated for a function call when the function returns. One approach to achieve this is to transition from a flat memory model to a stack of memories, where the memory for the current function rests atop the global memory. Each set of memories can be managed as smaller units, containing only the cells allocated within the current function, and can be easily discarded by popping the stack upon function return. This reasoning suggests an appropriate alteration to the memory model for Silf.

The Klocs operation requires attention due to its primary role in accommodating new language features. As Klocs is defined for each computation item in the language that may hold locations, updates to the collector are essential when incorporating new computation items that can contain locations. The introduction of a method to automatically transform a theory into one with garbage collection could eliminate potential errors stemming from these updates.

An aspect that remains unaddressed is the correctness of incorporating a garbage collector into a language. The addition of a garbage collector should ideally not alter the results of any computation. To establish this, it must be demonstrated that the collector operates correctly, ensuring that root locations are adequately gathered, reachable locations are consistently marked, values at marked locations remain unchanged, and marked locations are not collected.

This research is connected to prior work on Silf and Kool, where performance-related studies mainly focused on analysis performance rather than execution performance. Previous work on Java concentrated on producing a high-performance analysis tool for both the Java language and bytecode, while prior research on Kool aimed to enhance analysis performance, potentially at the expense of reduced execution performance. Beyond the scope of rewriting logic semantics, extensive research has been conducted on memory management, including garbage collection. The collector presented in this paper is notable for its formal definition in rewriting logic, although its operation is fundamentally a mark-sweep collector. Additional resources on garbage collection, as well as research examining pure object-oriented languages, provide supplementary insights into this topic.