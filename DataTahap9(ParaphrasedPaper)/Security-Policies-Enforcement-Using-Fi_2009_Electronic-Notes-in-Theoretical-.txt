Security enforcement methods are utilized to prevent the violation of a policy that is meant to ensure the protection of an expandable system and its users. For example, web browsers that run applet programs or a database that allows user queries must ensure the system's behavior is not hazardous. This aim can be achieved through the use of a program monitor that enforces the security policy.

Schneider (references 7 and 3) introduced the first formal model of a program monitor and investigated the enforceable properties of this model. Ligatti et al. (references 4, 5, and 2) proposed a more comprehensive model based on edit automata. This monitor is capable of not only interrupting a program's execution when it violates the security policy, but also modifying its behavior using suppression and insertion mechanisms.

Our objective is to identify policies that can be enforced by edit automata with limited capabilities, particularly those with finite memory. We introduce a family of edit automata called bounded history automata and characterize the policies enforceable by these automata. However, it should be noted that the framework is different; the input alphabet and the set of states are not necessarily finite. The finiteness of these two parameters is crucial to our results.

Let us assume that "a" satisfies properties s0, s2, and s4 but not property s3. In such a case, there exists a cycle "ci" in "j'" which has an outgoing edge. Since the automaton is pruned, this edge can be extended either in a path that reaches "f" or in a path that reaches another cycle "cj". Due to Proposition 2 and Lemma 5, "ci" cannot reach "f", so it reaches another cycle "cj".