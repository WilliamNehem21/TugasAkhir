There exists a significant body of literature focusing on Java logics, semantics, and theorem proving tools, as evidenced by references [16,14,13,15,9,20,17,2,3]. In section 6, we will delve into this related work, while also examining similar works to ours, including the Maude ITP, ASIP-ITP tool [6,22], and the Javafan project [7,8], to which our work contributes at the theorem proving level. The remainder of this paper is structured as follows: Section 2 provides a summary of the CPS semantics of our Java fragment, while Section 3 explicates the first-order semantics of Hoare triples based on the initial algebra semantics of the language. Section 4 addresses our Hoare logic and its justification, and Section 5 discusses the mechanization of such a logic in the Java+ITP tool, along with its application in examples. Section 6 covers related work and conclusions. Additionally, the associated technical report includes a mathematical proof of correctness for the loop rule, as well as two proof scripts for Java programs.

From the perspective of program verification, it is important to note that a program variable is not directly mapped to its value, but to a location in the store. This results in a two-level mapping: of variables to locations and of locations to values. The location module defines the concept of a location; for example, l(17) represents a specific location. It also demonstrates how to concatenate multiple locations, as we typically work with lists of expressions.

In the context of program verification, the more abstract concept of environment/stores, as demonstrated in [6,22] for a very simple language, does not integrate well with the potential side-effects and hiding in our language. Therefore, the concrete variant we have selected is preferred. Moreover, this choice will facilitate the future extension of this subset of Java to a more comprehensive version. Conversely, a more abstract definition of state would not support the explicit storage of complex information, such as exceptions, loops, or locks.

The structure we have established enables us to determine program termination simply by examining the state's sort. If the state is of the sort superstate, there is still some remaining continuation and, therefore, code. Consequently, the program has not yet terminated. Conversely, if the resulting state is a wrappedstate, we can infer that all code has been executed. The definition of the treatment of an empty continuation incorporates and supports this functionality.

In instances where the state 's' is not obvious, we will revert to the 'evaltst' notation. Additionally, we utilize 't' within if or while constructs for its potential state change, as well as its role in not changing the state. The various uses of 't' are exemplified in our Hoare rule for conditionals.

In conclusion, we regard Java+ITP as a research platform for exploring the modularity and extensibility of programming languages and Hoare logics. It has proven valuable in uncovering nuances in the Hoare logic needed for Java, which are not present in toy languages or even in the Hoare logics of Java tools like Jive. Maintaining compositional Hoare logic reasoning at the source code level is another objective we have advanced as opposed to other approaches. However, this work represents just a snapshot of a work in progress. Our Java fragment is currently relatively modest, so we anticipate adding new features in the near future, such as exceptions and objects, with the expectation that this will be facilitated by the CPS semantics. Subsequently, we plan to incorporate threads and concurrency, and investigate Hoare rules for these new features. Our ultimate goal is modularity, enabling our Hoare rules to be applicable not only to Java but also to other languages using similar features in a modular fashion. Nonetheless, this remains an exciting prospect for the future.

