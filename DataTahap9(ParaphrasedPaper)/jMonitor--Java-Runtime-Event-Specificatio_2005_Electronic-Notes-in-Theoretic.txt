The jmonitor tool captures events that correspond to key Java programming abstractions, such as reading or writing a field in a class, method invocation, method return or throwing of an exception, and creation of a new object or array. Each event contains context information, including the name of the field or the method and the names of the class and method context, represented as strings using POSIX-compliant regular expressions.

Multiple event monitors can be associated with a single event, and the jmonitor instruments applications to capture the call context and invoke the monitor function with this information. The monitoring function is called before, after, or instead of the associated event, based on the event specification.

The paper is organized as follows: Section 2 introduces jmonitor events, event patterns, and event monitors. Section 3 describes different types of event monitors and the types of runtime context information collected and made available to the event monitor through jmonitor instrumentation. Section 4 presents the design and implementation overview, and Section 5 discusses how jmonitor relates to existing work in the field.

For event patterns built using the "of" and "from" constructs, no additional runtime checks are necessary to determine whether a specific Java instruction matches the event pattern. Event patterns that include the "in" context definitions incur a slight extra runtime overhead (single boolean test) during application execution around each instruction that potentially matches the event pattern. Each event pattern is associated with zero or more event monitors, and a jmonitor event monitor is a pure Java class inheriting from one of the abstract classes in the jmonitor package.

There is a limitation that event monitoring classes must be distinct from event specification classes (or declared within the specification classes as inner classes) to prevent dynamic class loading issues. The tool bearing the closest resemblance to jmonitor is java-mac, an implementation for Java of the monitoring and checking architecture. Another project similar in nature and design is valgrind, a framework for doing instrumentation of compiled x86 code.

Furthermore, the paper discusses a query-based debugging tool, similar to an SQL database query tool, developed by Lencevicius et al., and explores how jmonitor can be used for similar types of debugging scenarios. It is suggested that jmonitor can be used during the development, debugging, testing, and deployment stages of the software lifecycle and envisions powerful tooling and debugging environments to be developed around jmonitor technology. Additionally, it is envisioned to add tooling support to automate some aspects of event pattern specification and event monitor selection, and to support program guidance, including altering the behavior of legacy programs and exposing errors during testing.