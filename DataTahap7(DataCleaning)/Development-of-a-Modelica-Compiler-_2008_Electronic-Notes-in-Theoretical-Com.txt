as a fist step towards creating a flexible modelica-based modeling environment that can support these emerging methods, a new extensible compiler, entitled jmodelica, is under development. for this development we use the compiler construction tool jastadd[11,7]. this tool uses several declarative features such as reference attribute grammars and rewriting, in order to support building extensible compilers. in this paper we describe our experience from building a prototype of the jmodelica compiler, and how the complex compilation problems in modelica can be solved in jastadd in a modular, understandable and compact manner. in addition to name and type analysis, where modelica has advanced context-dependent rules, we discuss



the paper is organized as follows. in section 2, the compiler tool jastadd is described. section 3 gives an overview of the modelica language. the paper proceeds with a description of how key features in the modelica language have been implemented using jastadd in section 4. in section 5 the performance of the jmodelica compiler is compared to two other modelica tools. the paper ends with section 6 on conclusions and future directions.



support java 5. current state-of-the art hand-coded compilers do not support the fine-grained extensibility that is needed for such extensions, but usually have support only for simple modularization into separate compiler phases, e.g., using the visitor design pattern. jastadd is implemented in java, generates java code, and is available under an open-source license. this section gives a brief summary over the main features of importance for this paper.



object oriented abstract syntax the core of a language implementation is specified by an abstract grammar. jastadd generates a java class hierarchy from the grammar, including constructors and traversal api. for example, a grammar rule whilestmt:stmt::= cond:exp do:stmt; will generate a class whilestmt which extends stmt, with a constructor whilestmt(exp e, stmt s), and two traversal methods exp getcond() and stmt getdo(). any java-based parser generator can be used for building the abstract syntax tree(ast), using the constructors.



aspects with intertype declarations behavior of the ast classes is added using aspect modules that support intertype declarations. for example, a feature f that belongs to a class a, can be declared in an aspect module as a.f. the syntax is similar to the intertype declarations in aspectj, but dynamic aspect-oriented features like pointcuts etc., are not supported. typically, each different compiler problem, like name analysis, type analysis, code generation, etc., is defined in one or several aspect modules.



combining declarative and imperative code while most of the compilation is best defined by the declarative attributes, there will usually be a need for generating some output based on the attributed ast. the attributes constitute an api that can be used by imperative code, i.e., ordinary java methods. in the jmodelica compiler, the flat model is constructed imperatively, using the attribute api defined by the declarative name and type analysis.



the first version of modelica was published in september 1997. the effort was targeted at creating a new general-purpose modeling language, applicable to a wide range of application domains. while several other modeling languages were available, many of those were domain-specific, which made simulation of complex heterogeneous systems difficult. based on experiences from designing other modeling



instantaneous events the when-clause expresses an instantaneous event, i.e., when a specified condition evaluates to true, some actions should be taken, e.g., to reinitialize state variables. in the bouncingball example, the bounce is detected, and the new velocity in the opposite direction is set, taking the elasticity coefficient into account.



there are several compilers available for modelica: one commercial product is dymola from dynasim, and an open-source alternative is openmodelica,. our own prototype compiler, jmodelica, currently performs only the flattening step for a subset of modelica. in order to validate the results, the flat descriptions produced by jmodelica and dymola were(automatically) compared and verified. we compare jmodelica to both dymola and openmodelica in section 5.



let us first consider ordinary qualified names like a.b.c. here, c should be looked up in an environment decided by b, which in turn should be looked up in an environment decided by a. the environments may potentially be complex due to inheritance from other classes. to implement such normal oo name analysis we have applied the same basic design as in the jastadd java implementation, namely delegating lookup attributes.



the concept of types is not formally defined in the modelica specification,. however, a framework for representing modelica types is proposed in introducing two different kinds of types, classtype and objtype, for classes and components, respectively. a classtype is a hierarchical structure with a set of member declarations that are either of classtype or objtype. an objtype is also hierarchical, but its set can only contain declarations of objtypes, and not of classtypes.



this kind of covariant subtyping is safe since the components of a class are only assigned values when the class is instantiated, at which time the exact type is known. before implementing the general subtype relation between two general type objects, we start by implementing the supertype relation between a type and a modeltype object by introducing the parametrized attribute supermodeltype below.(type is a superclass to modeltype.) inheritance chains which will incur a circular dependency in the attribute. jastadd supports evaluation of circular attributes through fix-point iteration[8,16]. in such evaluation, termination is guaranteed if the value domain forms a finite height lattice and the function is monotonic. the example satisfies both conditions with a boolean



the environment in the pm compiler is modelled as a list of references to enclosing components and an ordered list of references to modifications. by inserting modifications at the end of the list, outer modifications will shadow inner modifications applicable to the same element. references allow us to query enclosing components and modifications to acquire more information about their context. each component computes a new environment but in a more complex way than in section 4.3.1. modifications in the enclosing environment and locally declared modifications are merged into a new environment, which is used for the recursive call to flatten. the use of references in the environment allow us to query attributes in the referred modifications, e.g., use name binding to determine whether a particular modification is applicable to a component.



in this paper, we have reported design concepts and experiences from a project where a modelica compiler, jmodelica, is being developed using the compiler tool jastadd. it has been shown how complex semantic rules in the modelica language can be implemented in a compact, modular and easy to understand manner. in particular, name analysis, type analysis and the flattening procedure have been treated.



the use of a declarative approach has also proved to be beneficial for extensibility purposes, which is an important goal for our future work. for example, the basic name analysis for oo was possible to extend in a modular fashion to handle also the modification construct. also, the implementation of flattening was possible to write in a simple and modular way, using the reference attributes defined in the name and type analysis as an api.



a striking observation can be made regarding the development time of the compiler. as of november 2006, approximately 3 man-months, have been spent on implementation. since the current version of jmodelica implements several important features of modelica, it is our experience that jastadd is very well suited for rapid development of compilers.



