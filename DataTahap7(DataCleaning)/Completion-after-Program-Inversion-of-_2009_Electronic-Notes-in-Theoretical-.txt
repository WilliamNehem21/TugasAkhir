inverse computation of an n-ary function f is, given an output v, the calculation of the possible input v1,..., vn of f such that f(v1,..., vn)= v. two approaches for inverse computation are distinguished: inverse interpreters[4,1] that performs inverse computation, and inversion compilers[18,28,9,25,24,7,19,20,2] that performs program inversion.



3 to simplify discussions, we omit describing special rules in the form of invf(f(x1,..., xn)) x1,..., xn[25,24] because they are meaningless for inverse computation in dealing with functional programs on callby-value interpretation. the special rules are necessary only for inverse computation of normalizing computation in term rewriting.



in section 5, we first show a sufficient condition of constructor trss from which the inversion compiler generates(innermost-)convergent dctrss. next, we describe an implementation of the modified completion procedure, and the experiments for the unraveled trss of dctrss obtained by the inversion compiler from injective functions shown by kawabe et al.. finally, we illustrate an informal translation of the non-overlapping trss obtained by the procedure back into functional programs.



t1 sk tk r are called patterns(in r). we denote the set of patterns in r by pat(r). it follows from the definition of u that pat(r)= pat(u(r)) up to variable renaming. patterns represents structures of data by means of matching. especially, in innermost reductions, patterns matches normal forms only.



in this section, we apply the modified and simplified completion procedures to dctrss generated by the partial inversion compiler, that is, we apply the procedures as a post-processor of u( nv()) to the unraveled trss. first, we briefly introduce the feature of inverse systems for injective functions. then, we show the results of experiments by an implementation of the framework.



invrev(z) u4(invrev(z), z). for this reason, we restrict ourselves to injective functions whose inverse trss are terminating. in, a sufficient condition has been shown for the full inversion compiler in to generate convergent inverse dctrss from injective trss. the condition is also effective for the partial inversion compiler inv.



note that if the dctrs nv(r) is op-sn then the trs u( nv(r)) is terminating. theorem 5.2(i) shows that if nv(r) is op-sn, then nv(r) has innermost-confluence that is necessary for successful runs of the simplified completion procedure. note that nv(r) is confluent if r is convergent. when r does not satisfy the condition in theorem 5.2(ii), we directly check the termination of u( nv(r)). in other words, when r satisfies the condition in theorem 5.2(ii), we are free of the termination check of u( nv(r)) that is less efficient than the check of satisfying the condition.



in this paper, we have shown that completion procedures are useful in generating(innermost-)convergent inverse trss of injective trss. the completion procedures can be also used for checking whether or not a(innermost-)convergent constructor trs is injective. this is because if a given convergent constructor trs is not injective, then the procedures never succeeds for the trs. it is known to be undecidable in general whether or not a function is injective. in, however, it is shown that injectivity of linear treeless functions is decidable. on the other hand, some of the examples we mentioned in the experiments are non-linear or non-treeless while the method in this paper is not decidable.



where and are special function symbols not in the original signature. in this system, the term invsnoc([a, b, c],) has a unique normal form[a, b], c. as described in section 1, however, it is difficult to translate the convergent trs into a functional program because the system contains special symbols and, and overlapping rules. on the other hand, the modified completion procedure in this paper unexpectedly succeeded for all the experiments where the dctrss are confluent, and the resulting systems of the procedure are often non-overlapping. moreover, for the dctrss that are not confluent but innermost-confluent, we proposed the simplified completion procedure but it is not yet known whether or not the transformation in is applicable.



