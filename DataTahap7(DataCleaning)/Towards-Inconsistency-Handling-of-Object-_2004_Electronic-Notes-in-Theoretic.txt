in this paper, we study the problem of inconsistency handling for objectoriented behavioral models, following our general methodology for consistency management developed in. first, we briefly report on existing work on consistency checking, introducing an example consistency problem. then, we elaborate on the concept of inconsistency handling. finally, we focus on using graph transformation during inconsistency handling for reconstructing uml models from outputs generated by model checkers.



in previous work, we have reported on the details of such a consistency concept. as a running example, we have chosen the formal method csp and the model checker fdr to evaluate consistency conditions. to support the software engineer in the complex task of translating submodels and defining consistency checks, we have developed the consistency workbench. briefly, this workbench allows the definition of rule-based translations of uml models into semantic domains and the definition of consistency checks as workflows, composing activities for translation and triggering external model checkers. currently, the consistency workbench contains pre-defined translations of statecharts and collaborations to csp and allows the execution of consistency checks for the previously described consistency problem.



inconsistency handling is a notion for activities and techniques that aim at dealing with inconsistencies in multi-view sofware development. depending on the types of languages and abstractions used within model-based development, quite different inconsistency handling techniques have been developed. in general, one can distinguish between changing actions and non-changing actions and the general decision of either tolerating or resolving an inconsistency. inconsistency handling comprises the identification of these actions as well as the evaluation of their costs and the evaluation of risks of not resolving an inconsistency. concerning inconsistency handling of object-oriented models, we will restrict ourselves to the discussion of actions for handling them, leaving the evaluation of risks and costs to future work.



in order to enable inconsistency management, it is important that the inconsistency is detected. this is performed by a consistency check. however, the result of such a consistency check is given in terms of the language in the semantic domain. in case of an inconsistency, this will usually be a trace to an



using the technique of back-annotation, it is possible to display a uml model illustrating the inconsistency found. in order to enable the software engineer to resolve the inconsistency, often further support is needed. this support usually depends on the type of underlying consistency concept i. e. for the wide range of inconsistencies quite different types of supports could be needed.



the goal of back-annotation is to construct from such a trace given in csp a uml model helping the software engineer to handle the inconsistency in the uml model. one problem associated with back-annotation is that we must be able to express information compatible with the source uml model: in the process of translation and abstraction to the semantic domain csp, we may have renamed concepts from uml to csp and left out details of the uml model. for example, in the concrete example ab itsb pout.send b corresponds to a sending of sc2 via the port p2, the information out.send is something added during translation into csp. further, the details of the receiver of the message b have been left out and are not visible in the csp trace.



what is needed here is an approach that allows us to reconstruct the abstraction level needed when translating the csp error trace back into a uml model. this approach must be intertwined with the translation from uml into csp at the first place. there, the information needed for backannotation must be determined and stored.



our concept for tackling this problem is as follows: when designing the translation from uml to csp(i. e. when abstracting), one has to determine which aspects will be necessary to reconstruct a uml model from the more abstract csp model. these aspects have to be mapped into a so-called reconstruction model which can then be used for generating/back-annotating a uml model in the process of inconsistency handling.



in the second part of this paper, we have elaborated on the problem of back-annotation. the concept of a reconstruction model has been introduced which serves the purpose of saving the information necessary within backannotation during the translation into a semantic domain. we have further elaborated how an existing approach of graph transformation using a rule format of compound rules which has already been successfully used for translating uml models into a semantic domain can also be used for back-annotation.



future work can be performed in the following directions: firstly, the problem of back-annotation must be studied in depth for different consistency problems, possibly leading to a richer set of transformations for back-annotation. a first idea would be to also include negative traces and make use of the rich set of model elements provided by the uml. furthermore, a distinction between mandatory and potential behavior could be useful. secondly, we aim at including our techniques of back-annotation into the consistency workbench. further, techniques such as specialized algorithms for user-directed inconsistency resolution should be developed.



