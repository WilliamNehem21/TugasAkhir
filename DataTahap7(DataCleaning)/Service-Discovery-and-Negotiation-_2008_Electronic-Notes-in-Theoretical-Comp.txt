to provide formal foundations to current(web) services technologies, in we have introduced cows as a formalism for specifying and orchestrating services while modelling their dynamic behaviour. cows, in fact, falls within a main line of research(see e.g.[9,10,24,27,21,7,11,12,25]) that aims at developing process calculi capable of capturing the basic aspects of service-oriented systems and, possibly, of supporting the analysis of qualitative and quantitative properties of services. while



the rest of the paper is organized as follows. section 2 presents the syntax of cows and its informal operational semantics. section 3 shows how cows can be used for concurrent constraint programming. section 4 describes some simple communication protocols that allow two parties to generate constraints through synchronization. section 5 presents the specification of a web hosting scenario, that is, in a simplified form, one of the typical soa scenarios where sla among organizations are largely employed. section 6 introduces some variants of the concurrent constraint programming constructs presented in section 3. finally, section 7 concludes the paper with a few observations.



we first provide some insights on the constraint system used. in cows, a constraint is a relation among a specified set of variables which gives some information on the set of possible values that these variables may assume. such information is usually not complete since a constraint may be satisfied by several assignments of values to the variables. for example, we can employ constraints such as



of course, since the protocol can diverge(i.e. an invoke can synchronize infinitely often with the same receive without modifying the store), a fairness assumption is essential to guarantee progress properties: if an invoke can synchronize with many receives and at least one synchronization produces consistent constraints, then eventually this synchronization will succeed.



the store and releases it, invoke and receive activities synchronize(i.e. the new constraints are consistent with the store), the encoding of the receive reads the store and, if the value is unchanged, adds the new constraints, otherwise it restarts the terms. the encoding is divergence-free in the sense that whenever the terms are restarted the value of the store of constraints differs from that in the previous



robust protocols(that, e.g., avoid also starvation) could be defined. however, they should rely on synchronization among more than two entities at the same time(as it is permitted, e.g., by the join input of the join-calculus), that goes against our choice to reconcile expressiveness and implementability.



