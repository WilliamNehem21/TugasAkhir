we use a special operational semantics which drives us in inferring quantitative measures on system describing cryptographic protocols. the transitions of the system carry enhanced labels. we assign rates to transitions by only looking at these labels. the rates reflect the distributed architecture running applications and the use of possibly different cryptosystems. we then map transition systems to markov chains and evaluate performance of systems, using standard tools.



intuitively, a sends b the plaintext a, b, n and an encryption readable only by a and the server s; b forwards it to s together with a message readable only to b and s. the server receives and decrypts both. if the components a, b, n in the encrypted messages match with the plaintext, s generates the session key kab and sends b the key twice; one encrypted with the shared key ka and the other with the shared key kb. finally, b sends a the first encryption. here, the basic cryptographic system is a shared-key one, such as aes: the same key shared between two principals is used for both encryption and decryption.



however, looking at protocol narrations is not sufficient. indeed, here you only have a list of the messages to be exchanged, leaving it unspecified which are the actions to be performed in receiving these messages(inputs, decryptions and possible checks on them). this can lead, in general, to an inaccurate estimate of costs.



here, we show how we can compare and measure protocols, specified in lysa. this allows the designer to choose among different protocol versions, based on an evaluation of the trade-off between security guarantees and the price for each alternative. also, our approach makes it possible to estimate the cost of an attack, if any. consider again our example based on the two versions of otway-rees protocol. the literature reports that both versions assure key authentication and key freshness, but they differ with respect to goals of entity authentication. in(or1), a has assurance that b is alive, i.e. that b has been running the protocol; indeed in receiving message.4, she can deduce that b must have sent message.2 recently. in(or2) instead, a does not achieve liveness of b. we will show below that they differ also in efficiency, confirming the intuition given above.



technically, we give lysa an enhanced operational semantics, in the style of. we then mechanically derive markov chains, once given additional information about the rates of system activities. more precisely, it suffices to have information about the activities performed by the components of a system in isolation, and about some features of the net architecture. the actual performance evaluation is then carried out using standard techniques



in summary, what we are proposing is a first step towards the development of a single, formal design methodology that supports its users in analysing both the behaviour and the performance of protocols, with a semi-mechanizable procedure. in this way, performance analysis is not delayed until a system is completely implemented, which may cause high extra-costs. also, we can use the available analyser of lysa to check security at the same specification stage. indeed, this integration is possible because we use lysa as a unifying specification language. moreover, our approach can be used with any of such languages endowed with an operational semantics.



we consider in the following the two versions of the otway-rees protocol specified in lysa, as our running example. in this section we only want to give the intuitive idea of our framework and therefore we will skip any technical detail. in particular, we give an intuitive introduction to the semantics, and the cost functions that enrich transitions with their costs; finally, we give the intuition on how to extract the necessary quantitative information to derive the continuous time markov chains(ctmc). the formal development is left to the appendix.



sent by a(l. 3 in tab. 1), where the term{a, b, n, na}ka represents the encryption of the tuple(a, b, n, na) under the symmetric key ka. tests associated with input are directly embodied in the input: an input succeeds, resulting in name instantiation, only if the first terms received coincide with the ones syntactically preceding the semi-colon. in the present



once the protocol has been specified in lysa, we associate a label to each transition, in particular to each communication and to each decryption. to this aim, we use an enhanced version of operational semantics called proved, in the style of[7,8](see appendix a for further details). in our proved operational semantics the transition labels are enhanced so that they record the syntactic context in which the actions take place, besides the actions themselves. the context part represents the low level routines performed by the run-time support to execute the transition itself. therefore, the enhanced label of a communication must record its output and input components and their contexts. we choose instead not to use contexts to enrich labels of decryptions.



the cost of an output depends on the size of the message and on the cost of each part(or term) of the message. note that the cost of an encryption is not constant: it depends on the algorithm that implements it, on the size of the cleartext, on the kind of the key(on its size and on its intended use, e.g. long-term or short-term).



here, we do not fix the cost function: we only propose for it a possible set of parameters that reflect some features of a somewhat idealized architecture and of a particular cryptosystem, e.g. we take into account the number of processors or the kind of cryptographic algorithms. although very abstract, this s to make our point.



as discussed before, the context of each action must be considered. contexts indeed slow down the speed of actions. we therefore determine a slowing factor for any construct of the language. nevertheless, for simplicity, in our example, we only consider the cost due to parallel composition.



crypted cleartext(we assume that input and output have the same cost). the cost of the third transition is instead 4d, that represents the cost of decrypting a ciphertext, obtaining a cleartext of size 4. the full list of the costs ci relative to the labels li in sys1 and sys2 are in tab. 3. note that cost parameters depend on the platform and on the actual protocol. for instance, in a system where cryptographic operations are performed at very high speed(e.g. thanks to a cryptographic accelerator), but with a slow link(low bandwidth), the cost for encryptions will be low and high for communication.



i.e. with any derivative of p, rather than to each transition, as often done in the literature, e.g. in. for instance, when calculating the utilisation of a cryptosystem, in order to perform a decryption, we assign value 1 to any transition in which the decryption is enabled. all the other transitions earn the value 0 as transition reward.



we have used an enhanced operational semantics, whose transitions are labelled by(encodings of) their proofs. taking advantage of enhanced labels, we have mechanically associated rates, i.e probabilistic information, with transitions. this is done symbolically, by looking at the enhanced labels, alone. actual values are obtained as soon as the user provides some additional information about the architecture and the cryptographic tools relative to the analysed system.



on enhanced labels, alone. once rates have been assigned to transitions, it is easy to derive the ctmc associated with the transition system of a process. from its stationary distribution, if any, we evaluate the performance of the process in hand. moreover, although many different timing models can be used, in this paper we concentrate on a continuous time approach.



it is worth noticing that our approach follows the same pattern presented in to derive behavioural information from our enhanced labels. also, behavioural properties, such as confidentiality and authentication, can be checked by using a tool integrated with ours, like the analyser of lysa. therefore, we propose our operational semantics as a basis to uniformly carry out integrated behavioural and quantitative analysis.



