for programming random systems, one solution is to use a classical(deterministic) language together with a random procedure. in some sense, non-determinism is achieved by relaxing deterministic behaviors. we have adopted an opposite solution where non-determinism is achieved by constraining chaotic behaviors; in other terms, the proposed language is mainly relational, not functional.



related works are abundant in the domain of models for non-deterministic(or stochastic) concurrent systems: input/output automata, and their stochastic extension; stochastic extension of process algebra[6,1]. there are also relations with concurrent constraint programming, in particular with works that adopt a synchronous approach of time and concurrency[13,8]. a general characteristic of these models is that they are defined to perform analysis of stochastic dynamic systems(e.g., model checking, probabilistic analysis). on the contrary, lutin is designed with the aim of being a user-friendly programming language. on one hand, the language allows to concisely describe, and then execute a large class of scenarios. on the other hand, it is in general impossible to decide if a particular behavior can be generated and even less with which probability.



example 2.1 we illustrate the language with a simple program that receives a boolean input(c) and a real input(t) and produces a real output x. the high-level specification is that x should get closer to t when c is true, or should tend to zero otherwise. the header of the program is:



a constraint(boolean expression) represents an atomic reaction: it defines the relations between the current values of the variables. scenarios are built by combining such atomic reactions temporal statements. we introduce the type trace for typing expressions made of temporal statements. a single constraint obviously denotes a trace of length 1; in other terms, expressions of type bool are implicitly cast to type trace when combined with temporal operators.



example 2.3 with those operators, we can propose a first version for our example. in this version, the output tends to 0 or t according to a first order filter. the nondeterminism resides in the initial value, and also in the fact that the system is subject to failure and may miss the c command.



note that, inside the loop, the first constraint(x tends to t) is not satisfiable unless c is true, while the second is always satisfiable. if c is false, the first constraint deadlocks. in this case, the second branch(x gets closer to 0) is necessarily taken. if c is true, both branches are feasible: one is randomly selected, and the corresponding constraint is solved.



we think that such a solution is too much restrictive and tedious for the user, and we prefer to slightly modify the semantics of the loop. the solution retained is to introduce the well-founded loop principle: a loop statement may stop or continue, but if it continues it must do something. in other terms, empty iterations are dynamically forbidden.



the parallel composition of lutin is synchronous: each branch produces, at the same time, its local constraint. the global reaction must satisfy the conjunction of all those local constraints. this approach is similar to the one of temporal concurrent constraint programming.



example 2.9 we can now write more elaborated scenarios for the system of example 2.3. in this new version, the system works almost properly for about 1000 reactions: if c is true, x tends to t 9 times out of 10, otherwise it tends to 0. during this phase, the gain for the filters(a) randomly changes each 30 to 40 reactions. at last, the system breaks down and x quickly tends to 0.



the execution takes place within an environment which stores the variable values(inputs and memories). constraint resolution, weight evaluation and random selection are also performed by the environment. we keep this environment abstract. as a matter of fact, resolution capabilities and(pseudo)random generation may vary from one implementation to another, and they are not part of the reference semantics.



actually, we use the solver that have been developed for the testing tool lurette[11,5]. this solver is quite powerful, since it covers boolean algebra and linear arithmetics. concretely, constraints are solved by building a canonical representation mixing binary decision diagrams and convex polyhedra.



the basic rule is to ensure some fairness between the solutions. this is achieved by simulating a uniform choice among the set of solutions. since uniform selection within a polyhedron is a complex problem, several options are available ranging from a simple, rough approximation to a very accurate, and thus costly one.



other works concern the evolution of the language. we plan to introduce a notion of signal(i.e. event), which is useful for describing values that are not always available(this is related to the notion of clocks in synchronous languages). we also plan to allow the definition of(mutually) tail-recursive traces. concretely, that means that a new programming style would be allowed, based on explicit concurrent, hierarchic automata.



