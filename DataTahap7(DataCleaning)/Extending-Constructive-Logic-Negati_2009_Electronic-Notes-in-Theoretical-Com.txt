thanks to the use of types, our constructive negation can provide concrete values as results, instead of constraints(as in our previous works). we provide details about the semantics and the implementation in our approaches of classical, finite constructive, and intensional negation. the paper also includes some practical examples additionally allowing for providing measurements of computational behavior.



negation is probably the most significant aspect of logic that was not included from the outset. dealing with negation involves significant additional complexity. nevertheless, the use of negation is very natural and plays an important role in many knowledge representation and reasoning systems, like web semantics, natural language processing, constraints management in databases, program composition, manipulation and transformation, coding rule checking, business rules, default reasoning, negative queries(search of false information), etc.



attending to what we have expounded in this section, it is clear the interest for achieving a sound and complete implementation for these techniques. constructive negation was, in fact, announced in early versions of the eclipse prolog compiler, but was removed from the latest releases. the reasons seem to be related to some technical problems with the use of coroutining(risk of floundering) and the management of constrained solutions. we are trying to fill a long time open gap in this area(remember that the original papers are from late 80s) facing the problem of providing a correct, effective and complete implementation, integrated into a standard prolog compiler.



there is a distinction between the effects of typing in other programming languages(e.g. functional programming) and logic programming. in strongly-typed languages, well-typed programs cannot go wrong(in the sense of well-definiteness of expression), while in logic programming ill-typed programs will fail.



regular types can be defined by regular grammars. terminal symbols are basic types: we introduce base types and corresponding base type symbols, like int, num, char etc., denoting respectively sets of integers, all numbers, characters, etc. grammar rules generate combined types probably including constructors(maybe 0-ary, i.e. constants). types can be defined in several syntactic manners. for our purpose we will restrict themselves to use horn clauses, although they can be also automatically generated from other syntax. e.g. the type for list of int can be defined by



p(x) is a predicate descriptor, i.e., it has a predicate symbol as main functor and all arguments are distinct free variables, and pre and post are preand postconditions respectively. for our purposes it is sufficient to consider that pre and post correspond to formulas relating variables of x. the meaning of assertions is twofold. first, the precondition pre expresses properties which should hold in calls to p 6. second, the postcondition post expresses properties which should hold on termination of a successful computation of p, provided that pre holds on call.



the distinction made above about prescriptive vs. descriptive typing could be overcome when a setting of type declarations by assertions is used. assertions can be either included by the user(prescriptive typing) or detected by the compiler(by using static analysis and abstract interpretation techniques, like those reported in[6,22,7,19]).



the ciao system is a programming environment for developing prolog programs. it is important to note that, in ciao libraries there is a distinction between modules and packages. modules are regular libraries that one can import from any prolog program, their code(or the code of some of their predicates) is added to the code of the program that imports them. packages are libraries that define a transformation function for the code of the program that imports them. this transformation function generates an output code that is a expanded program that



ciao type checking is implemented by the package assertions(see and chapter 53 of the ciao reference manual). the compiler returns an error if the type of the value that is assigned to a variable does not correspond to the type declared for it. but there is no generation of valid values in case of looking for values for the variable. this is what we have to add to the implementation of assertions of ciao prolog.



this type information can be used by the pre-compiler for analysis, but we are interested in using this information at run-time(execution time) by the compiler. that is why we need to incorporate it into the program. we achieve this with some new packages, gen types and intneg types, that we have implemented, which expand the original code adding for each type declaration a clause that contains the useful information. particularly, the function add types/3 generates a new predicate pred check types/n for each predicate pred/n. we use these new predicates to check all types of the arguments of pred/n according to the information that was provided in the original program using the success assertion.



as we already said, one of the most interesting techniques for implementing constructive negation was proposed by chan and refined later. we have taken the implementation provided by(particularly the predicate cneg/1) as basis to develop a new predicate cnegt/1 that implements classical constructive negation with types. this predicate is implemented in the package cnegt.pl that also uses the package gen types.



proposal by chan. that is, first all solutions are obtained and then the disjunction of all of them is negated. obviously, this technique can only be used if the goal that is negated has a finite number of solutions. in our implementation we are sure about this fact by using finiteness analysis.



we have provided an implementation for this technique in with the predicate cnegf/1. on top of this predicate we have defined a new predicate cnegf t/1 that implements finite constructive negation with types. this predicate is implemented in the module cnegf t.pl. prolog program that use this kind of negation, should also use the package gen types that we have also developed.



the predicate intnegt/1 negates goals but only goals of predicates whose code has no free variables. the reason is that we have not adapted yet the implementation of the universal quantification for working with types. it will be the following step to improve the implementation and we will include it in future works(section 6).



length. we define the predicate length/2 where the first argument is a list of even numbers(type even list/2) and the second argument is the number of elements of the list. we also use the predicate even/1 defined in the first example of this section.



