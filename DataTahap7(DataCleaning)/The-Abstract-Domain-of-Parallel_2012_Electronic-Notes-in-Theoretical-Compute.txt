when defining the abstract operators, the main problem we need to face is that many concrete operations are not closed with respect to parallelotopes. moreover, in many cases there is no unique best parallelotope which approximates the result of the concrete operation. therefore, we need to carefully choose, even resorting to appropriate heuristics, an approximating parallelotope which brings a good precision in the overall analysis.



if ci/= 0, then assign(i, c, b) is invertible and, most importantly, maps a parallelotope to a parallelotope. in this special case, it is possible to implement the abstract operator along the line of. intuitively, the operation assign(i, c, b) corresponds to the assignment xj= ct x+ b, where xj is the value of xi after the assignment. from



therefore, we need to make explicit the constraints hidden in p which do not contain the variable xi we want to forget. the problem is that, in general, there are more entailed constraints than we can represent with a parallelotope. we need a way to choose between competing constraints.



in order to overcome the above problems, we propose the following operator. first note that we may ignore the rows in p which are unbounded(i.e. with infinite lower and upper bounds) or whose i-th entry is zero: the first remain unbounded, while the second are not affected by the assignment. thus, in the following, we will focus on the remaining rows only, whose indexes are in j={j| aji/= 0, lj/=



we now propose a more complex variant of abstract union, inspired by the recently developed inversion join operator. the main idea of the algorithm is to generate a bunch of candidate linear forms. the corresponding constraints are obtained from the candidate linear forms by computing the lowest and upper bounds on pa and pb. we then assign to each constraint a priority.



union. obvious candidates are the rows of the matrices a and b. moreover, we also generate new linear forms using(a part of) the inversion join algorithm. given two constraints in pa and/or pb, the inversion join computes a new linear form obtained as a linear combination of the two constraints, under the condition that they form an inversion. the complete procedure is illustrated in algorithm 5.



