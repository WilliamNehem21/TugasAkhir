in this article we review the current state of concurrency theory with respect to its industrial impact. this review is both retrospective and prospective, and naturally encompasses process calculi, which are a major vector for spreading concurrency theory concepts. considering the achievements, but also the failures, we try to identify the causes that, so far, prevented a larger dissemination of process calculi. this suggests a new generation of formal specification languages that would combine the concurrent features of process calculi with the standard concepts present in algorithmic languages. finally, we underline two major evolutions in the software and hardware industries that open new application domains for the concurrency theory community.



it is organized as follows. section 2 recalls some important, yet partial, achievements of concurrency theory in general, and process calculi in particular. section 3 discusses three main issues that often prevent process calculi from being widely used in industry. section 4 mentions two important evolutions affecting the software and hardware industries, and discusses how these evolutions provide new opportunities to concurrency theory. finally, section 5 gives a few concluding remarks.



in this respect, the two questions quoted in the introduction sound like a reminiscence of the recurrent debate pure mathematics vs applied mathematics. same as for pure mathematics(illustrated by the bourbaki group), it exists a pure concurrency theory school, sometimes driven more by the abstract beauty of theoretical results than by their practical usefulness. but, as for applied mathematics(illustrated by j.j. lions and colleagues), it also exists an applied concurrency theory community, that takes its inspiration from real-world problems.



find a company that designs concurrent systems with a strong need for reliability. this step is rather easy, as there are more such companies than research teams in concurrency theory. typical application areas are communication protocols, distributed systems, hardware architectures, embedded systems, security protocols, etc.



in the united kingdom, for instance, the ccs and csp communities continued working with their favourite calculi. it is worth noticing, however, that(according to the publications) the definition of csp gradually evolved to become quite similar to lotos, at least for the untimed aspects(see e.g.), still with slightly different notations. additionally, the principles of csp gave birth to new languages such as fdr2 and occam supported by compilers and verification tools.



the lack of user-friendliness, which greatly hampers the dissemination of process calculi, is the result of unappropriate technical decisions. although process calculi were a scientific breakthrough, their design was not free from mistakes. we briefly evoke two main mistakes, which are directly related to the two questions raised in the introduction of the present article.



from the beginning, concurrency theory has been based on models, i.e., descriptions of real-world systems, which are simplified 5 to retain only those aspects pertinent to the study of concurrency. quite early, these models have been made formal, especially with the advent of process calculi.



although the concept of model is widely used in many branches of science and engineering(e.g., physics, biology, civil engineering, etc.), formal models of concurrency have been so far confined to specific topics(formal methods, model-checking) with little impact on computer science in general.



linear algebra is the same for, e.g., both automotive and aerospace industries. similarly, behind each process calculus(except a few calculi, such circal and chp[40,50], which explicitly target at hardware circuits), there was an implicit motivation that this calculus should be general-purpose and expressive enough to model concurrent systems of various domains.



ded systems. as the silicon surface of circuits increases, the electric consumption increases too, and it is common that 50% or more of the energy is used only to propagate the global clock in every part of the circuit. also, the regularity of synchronous designs makes them vulnerable to spying(e.g., by observation of their electromagnetic emissions), which is a drawback for secure applications such as cryptography. for these reasons, the synchronous design paradigm is being questioned, and there is a growing interest in asynchronous logic for circuit design[27,13,56]. however, asynchronous logic is more error-prone than synchronous logic(with a higher risk of deadlocks for instance), thus giving a crucial role to functional verification. in this respect, process calculi and model checking tools can greatly contribute to the design of correct asynchronous circuits,



