timed cases lead to inherently different parallelization strategies and challenges. timed model checkers are usually based on difference bound matrices(dbm). though they are symbolic representations of state space, they conceptually differ from binary decision diagrams which are the basic data structure for a large class of untimed model checking tools and their distributed counterparts. thus, most of the strategies and ideas for distributing bdd-based model checking algorithms(e.g., slicing large bdds) seem not to be directly applicable to the timed setting.



architecture. the problems found on both asynchronous and synchronous versions are described in section 3. then we present the techniques developed to overcome such issues. section 5 showcases some case-studies where these methods improved verification times. finally, we outline future research paths.



readers familiar with low-level system coding might have noticed that the real cost of a malloc() depends on the fragmentation of the memory at the time of the call. this is indeed the case on most platforms, so k is no more that an estimate. as can be seen further on, other uncertainties also had to be filled with estimates.



so when the real value needs to be estimated, its rounded estimated parameters sizes are looked up in the collected information. if no match is found, a default value is used. this is the worst case of the estimation. it should be noted that this is kind of a simplistic approach to best-fit matching, and more sophisticated algorithms could be used, but it has the advantage of having a small overhead in terms of both space and time, and featured very good



timed automata are a formalism that incorporates positive real valued clocks to automata notation. clocks record the time elapsed between events. all clocks are synchronized, that is, they all advance at the same pace. each control location(automata node) has attached an invariant(a clock constraint). when a transition is taken, clocks are allowed to be reset to zero. each transition has an associated guard(a predicate over the clocks that define its enabling condition), and a label to name the executed event.



at any time, the state is determined by the control location and the values of clocks which must satisfy the location invariant. the system can evolve in two different ways: either an enabled transition is taken, changing the control location and some clocks are reset while the others keep their values unaltered, or it may let some amount of time pass. in the last case, clocks increase according to the elapsed time while still satisfying the location invariant, and the system remains in the same location.



properties over models can be expressed in terms of tctl formulae. in practice, most properties can be written in terms of reachability(sometimes adding a virtual observer automaton), that is whether a given set of states is reachable from the initial state by an execution of the model. those target states are named by labeling locations with propositions.



structure called difference bound matrices(dbm) is typically used to manipulate such kind of information. non-convex sets are represented as union of convex sets. zeus performs reachability queries as a backwards propagation of non-convex sets over the graph of control locations. this propagation is a fix point calculation that can be informally described as: starting with the



is whether or not the initial states belong to the computed fix point(i.e., we want to know if the target states can be reached from the initial states, or not). when the target states are unreachable the complete state space needs to be explored, so this is usually considered a worst-case scenario.



