outline: we formalize b+ trees as a data structure invariant, formulated in separation logic, in section 2. we then introduce abstract machine semantics for b+ tree operations and show their correctness: insertion(section 3) and finding elements in a range query(section 4). deletion of elements is discussed in section 5. finally, we remark on some issues raised by this work, discuss our conclusions and indicate our planned future work in section 6.



the b+ tree is a ordered, n-ary branching, balanced, search tree supporting destructive updates. in order to preserve the b+ tree invariant, updates can trigger further updates at higher levels of the tree. data items are stored only in the leaves and all nodes except the root are guaranteed to be kept at least half full. leaf pages are maintained in a singly-linked list.



note that the btree predicates directly limit the maximum occupancy of a node to its maximum capacity, maxn. also, the btreeh+1 predicate limits the minimum occupancy of each child node to be at least half its maximum capacity. the usual occupancy guarantee of b+ trees, namely that all except the root node are at least half full, then follows from the obvious inductive argument.



they are split into 4 sections. the first contains the single rule for descending down the correct path of internal nodes in the tree, while pushing the path location information on the stack at each step. the second section describes the three cases that can occur when a leaf page is encountered:(i) the entry to be inserted has the same key value as an existing entry in the page and so replaces the existing entry and no further action is necessary(a single page result has occurred).(ii) the entry fits into the page so the page is updated. again no further action is necessary as a single page result has occurred.(iii) the entry did not fit and the page had to be split between the original leaf page and a new one. as a double page result has occurred, a new key/page pointer pair has to be inserted into the parent level



the third section describes the possible ripple in post operations up the tree. again there are three cases, each popping the parent location off the stack:(i) if the result from the level below was a single page, there is no change necessary in this level so we pass on a single page result to the level above.(ii) if the result from below was a double page, we have to insert a new pair in this level. if it fits then we return a single page result to the level above.(iii) if the result from below was a double page, and there is insufficient space in this node to insert the new key/pointer pair, then we have to split this page and return a double page result to the level above.



