in any language designed to express transformations, the notion of rewrite rule is a key feature. its conciseness as well as its strong theoretical foundations are essential. the notion of strategy is complementary: this describes how rules are applied. in this paper, we show how a high-level strategy language can be implemented in a java setting. we present the integration of the visitor combinator design pattern into tom. this corresponds to an interpreter for strategy expressions. to be more efficient, we present a compilation method based on bytecode specialization. this low-level transformation is expressed in tom itself, using rules and strategies.



the main interest of using strategic rewriting systems is the conciseness, as well as the strong theoretical foundations of this paradigm. in practice, elementary program transformations appear explicitly in the program as rules. the strategies defined separately allow the user to precisely control the applications of the transformations. the separation between rules and strategies helps to ensure properties such as correction or termination. in the context of optimizer construction, provides a large library and support for builtins such as int, float, and string, i/o, system calls, etc. as a counter part, the design of the language is more constrained since the introduced constructs should be compatible with the java model and syntax. in this paper, we give in section 2 an outline of the tom language. in section 3, we show how strategic programming, pioneered by obj, elan, maude, and stratego can be lifted into the java programming environment. in section 4,



a main contribution of gom is to provide a hook mechanism to define canonical forms that have to be preserved. in other words, to each algebraic operator, a construction function can be associated. this function ensures by construction that terms are in normal form, and thus that invariants are preserved. in the following example, we define a hook attached to plus, which ensures that the addition with a neutral element is automatically simplified:



tom is a language extension which adds pattern matching primitives to existing imperative languages. pattern matching is directly related to the structure of objects and therefore is a very natural programming language feature, commonly found in functional languages. this is particularly well-suited when describing various transformations of structured entities like for example trees/terms, hierarchical objects and xml documents. the main originality of the tom system is its language and data-structure independence. from an implementation point of view, it is a compiler which accepts different host languages and whose compilation process consists in translating the matching constructs into the underlying native language. since gom generates java implementations of terms, in the following, we consider java as the host language.



matches the current node. otherwise, the default strategy is applied(fail in this case). the evalconst strategy describes how to simplify the addition or the product of two constants. note the use of c1+ c2, which is a java expression. for example, it returns cst(12) when applied to mult(cst(3),cst(4)).



the combination of basic strategy combinator and java has been pioneered by jjtraveler. in the presented work, the main contributions are the possibility to define elementary transformation rules using%strategy, the introduction and the implementation of the explicit recursion operator mu, as well as the automatic generation of congruence operators. this is important since it makes the framework easier to use and contributes to the promotion of formal methods in the java community.



in order to create type safe user strategies, we introduce a combinator fwd which depends on the typed interface of the tree structure. the goal of this combinator is to dispatch the call to the generic visit to type specific transformation methods. in order to define new transformation strategies, the user has to extend this fwd class and redefine the typed variants of the visit method, thus ensuring type preserving transformations.



the visit method of the fwd combinator will call the accept method when applied to a term belonging to the pico module(i.e. instance of the picoabstract), and falls back to the default strategy otherwise. each specific type-preserving visit method is implemented as a call to this default strategy.



time, directly on bytecode programs. furthermore, the tom formalism is particularly well suited to describe such kind of transformation. in the following, we show how a compiled java class can be analyzed and transformed using tom, and we give some experimental results to express optimizations on strategy code.



a particularity of java is to target a standard, machine independent, low level bytecode as compiled form of programs, which is interpreted by the java virtual machine. then, it becomes natural to perform program transformations at the bytecode level. this technique is used in particular to provide language extensions such as aspect oriented programming, to perform sophisticated static analysis, generate middleware code or improve runtime performances.



we have seen previously that the main problem of strategy efficiency was due to the implementation by the visitor combinator design pattern. every strategy combinator is parameterized by strategies and the visit method of a combinator calls the visit methods of the parameters. when considering a large strategy term, most of the time is dedicated to visit calls.



asm) to an algebraic view(implemented by gom). therefore, a java class is represented by a term. for each event generated by asm corresponds an algebraic constructor. due to lack of space, we cannot explain in detail how a java class is described(asm generates more than 250 different kinds of events). in the following we consider that a java class is characterized by a list of methods. each of them has a name, a profile, as well as an associated list of instructions. this abstract view can be described using an algebraic signature:



in order to inline a call to visit, the first step consists of finding the calls to this method. given a strategy(i.e. a graph of objects), we consider the algebraic term that represents the list of classes that occur in the graph of objects. starting from the root, we have to find the implementation of the visit method. this is done by inspecting the list of methods associated to a given class.



in this example, the associativity of methodlist is used to search for a method whose name is visit. when found, the body of this method is retrieved and stored in the code variable. note also that syntactic matching is a concise way to retrieve information in deep subtrees(the slot name for example).



whose size ranges from 22 to 232 nodes. the strategies involved are extending failure. therefore, each time a rule cannot be applied to a subterm, a new exception is thrown and caught by a catch statement. we obtain a gain by a factor 2 when using the compiled strategy. this can be explained by the fact that the strategy code is inlined, and thus the exception mechanism is kept local to a method instead of being distributed across methods and objects. this makes the implementation



the two following examples are real life applications which use strategies. the structure example is a theorem prover in the calculus of structures, as presented in. this system features deep inference, which means it is necessary to traverse a proof term in depth to find new redexes where the deduction rules can be applied. the last application is a tool used to find quasi-interpretations of functional programs. this involves manipulating of polynomial expressions, traversing them to apply transformations and substitutions, replacing variables by values for evaluation, usually in a bottom-up way.



low-level program transformations, for example java bytecode. in particular, we illustrate those bytecode transformations by the just-in-time compilation of strategy expressions, using partial evaluation techniques. to express this transformation, we presented a tom library built on top of asm and allowing to transform bytecode expressions in an algebraic manner. due to the reflexive properties of our strategy library, we use strategic programming to traverse the bytecode representation of the strategy expressions, perform analysis and inlining.



in this paper,we have presented rules for method inlining on strategy codes. a next step should be to add new rules for implementing classical loop-invariant code motion. due to the recursive operator, the strategy code can contain imbricated loops and it would be interesting to remove the computations that can be performed outside.



