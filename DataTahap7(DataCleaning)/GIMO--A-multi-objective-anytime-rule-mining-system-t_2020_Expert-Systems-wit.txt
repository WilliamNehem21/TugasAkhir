some mining approaches create opaque models that cannot be analyzed by domain experts at all. some types of models(e.g., support vector machines or neural networks) are nearly always hard to understand, while for others(e.g., decision rules or decision trees) understandability depends on complexity.



one type of human input concerns the cost of misclassification. many approaches are not cost-sensitive at all or need a cost matrix to be specified at the start. in reality, problems are costsensitive, but the exact cost matrix is often not known. moreover, costs are usually assumed to be independent of each other for each input in an algorithm. however, costs often depend on each other, e.g., due to synergy effects.



multi-objective optimization, i.e., the system can find rules with varying trade-offs for objectives like reduction of false positives, reduction of false negatives, but also custom cost functions that take relationships between instances into account or estimate the understandability of a model. this avoids the need to specify a cost matrix at the start.



anytime, i.e., the user can explore the data and the current results and interact with the system at any time. the user rarely needs to wait for the system, and neither does the system need to wait for the user.



in a case study in a medium-sized software company, we extracted data from software repositories on which code change parts led to which remarks. the rule mining system described in the current article was then used to derive rules that characterize change parts that do not need to be reviewed.



for domain-specific use cases, there is a cost associated both with false positive predictions and false negative predictions. these costs can be modeled in a cost function cost(h, x, y) that estimates the costs using labeled data. for the remainder of this paper, we assume without loss of generality that cost functions should be minimized. thus, a learning algorithm should optimize the cost function, i.e.,



for our use case, we have three types of cost functions:(1) cost functions for the estimation of the effort spent by domain experts to act on predictions of the decision support system,(2) cost functions for the number of actions not covered, and(3) costs for the cognitive complexity of understanding the rules. the exact definitions of our cost functions will be given in section 6.3.



another property of ripper is that the label of an instance only depends on the instance itself, not on other instances. when the instances are independent given the class label, this is not a problem. however, this is not the case for our type of problem. instead, as stated at the start of this section, our labels can be explained by multiple instances at the same time: they form groups



this interaction should be iterative and allow users to modify the manually defined conditions and get feedback about the results at any time. please note that these interactions are different from active learning(settles, 2009): in active learning, domain experts may also interact with the algorithm, but only by labeling instances on-the-fly. in our case, labeled instances are available and the domain experts can directly modify the generated rules.



however, unlike in standard grasp-pr, the steps are executed by one or several concurrently working processes(mining threads).1 each mining thread runs in an infinite loop in which it processes work packages from a queue of work items. such a work package is a combination of a ruleset and a task that needs to be done with that ruleset, e.g., a newly created ruleset that now needs to be optimized by local search. when there is no open work, a mining thread generates new items, or it tries to improve existing solutions further. a second difference to standard grasp-pr is that our algorithm works on a pareto front of solutions and takes the multi-objective nature of the problem into account. this pareto front is kept as a shared data structure, which is updated every time a new ruleset is evaluated.



except for the preprocessing step during rule generation, we did not yet mention how to solve our problem that there is a relationship between instances, i.e., that the instances are not independent given the class label(section 4.2). due to the meta-heuristic design, the algorithm can be easily enabled to take these relationships into account by adding appropriate cost functions: the value of the cost function needs to decrease if and only if one instance that is the cause of an action is covered and if no other instance that is related to that action is already covered. we achieve this by counting the actions that are covered by the rules



changing the target function in several parts of the algorithm, the multi-dimensional cost vector needs to be transformed into a single numeric target value. this single number is used to select the best element when hill-climbing during the local search, as well as during path relinking. it is also used to pick a decent rule as a foundation for further search and generation. initially, this target function returns the precision of the ruleset. the user can change it to another function to try out other optimization biases at any time. this can be useful to try out different cost factors. additionally, results from msops indicate that switching between different target functions leads to a better approximation of the pareto front.



we evaluated gimo on a real-world data set in the context of review remark prediction. the details of the review remark prediction study are out of the scope of this article and available separately. within this article, we focus on the comparison between gimo and existing approaches for the mining of decision rules: the popular machine learning algorithms c4.5 decision trees(quinlan, 1993), ripper(cohen, 1995), and metacost+ ripper(domingos, 1999).



we compare gimo with c4.5, ripper, and metacost+ ripper. we use the implementations provided by weka(eibe, hall,& witten, 2016). we optimize the confidence factor for the pruning of the c4.5 tree with five-fold cross-validation and sampled values between 0.05 and 0.25 in intervals of 0.05. the optimal value is 0.25. we set the minimal number of objects per leaf node to 143, i.e., at least 1% of the instances of the minority class must_be. as stated in the introduction, one of the benefits of gimo compared to classic cost-sensitive algorithms like metacost is that the cost matrix does not need to be specified explicitly. for metacost, we chose the cost matrix so that a misclassification that leads to a missed review remark is 100 times as costly as a misclassification that leads to unnecessarily reviewing an instance.



ticket tgain, we observe by far the largest relative difference to gain for gmo, which drops from 23.2% gain to only 3.5% tgain. this indicates that gmo mostly saves effort by ignoring changes for a few very large tickets, but does not save effort in most cases. this limits the usefulness of gmo in a real-world scenario, as savings would only occur sporadically. a likely cause is overfitting of gmo, which only uses precision as the target function. overfitting is countered by the manual interactions with gimo.



overall, gimo is among the best algorithms for most performance metrics. we further observe that the interactive feedback provided by domain experts was very helpful for the overall result, i.e., at the cost of very few missed actions, there was a big gain in the saved effort. we also observe that standard rule mining sys-



for the missed actions, gimo performs second best with 1.3% missed actions and is only outperformed by gmo which misses 0.9% of the actions. thus, both the interactive and non-interactive variants of our approach are very good at identifying the actions. ripper and c4.5 both perform worse regarding this metric with performance values between 19.2% and 34.1%.



our study. with 17 features and roughly 40 conditions, one might ask whether the gimo ruleset is still too complex. on the other hand, due to the multi-objective nature of our approach, the domain experts could have easily chosen a simpler ruleset. because they did not do so, we consider this threat under control. the highly structured form of the rulesets and the interactive features of the ui might have contributed to ease understanding.



the explainability of opaque models, like deep neural networks, is heavily researched at the moment. one approach is to build a simplified human-understandable model that approximates the original model. as the right balance between understandability and approximation quality is of prime importance here, our multiobjective user-informed approach could be useful.



tobias baum: conceptualization, methodology, software, investigation, resources, data curation, writingoriginal draft, project administration, funding acquisition. steffen herbold: software, validation, investigation, resources, writingoriginal draft, funding acquisition. kurt schneider: resources, writingreview& editing, supervision, funding acquisition.



