this paper presents a formal framework for compositional reasoning about secure systems. a key insight is to view a trusted system in terms of the interfaces that the various components expose: larger trusted components are built by combining interface calls in known ways; the adversary is confined to the interfaces it has access to, but may combine interface calls without restriction. compositional reasoning for such systems is based on an extension of rely-guarantee reasoning for system correctness[27,21] to a setting that involves an adversary whose exact program is not known. at a technical level, the paper presents an expressive concurrent programming language with recursive functions for modeling interfaces and a logic of programs in which compositional reasoning principles are formalized and proved sound with respect to trace semantics. the methods are illustrated through a small fragment of an idealized file system.



compositional security is a recognized scientific challenge for trustworthy computing(see, for example, bellovin, mitchell, wing). contemporary systems are built up from smaller components. however, even if each component is secure in isolation, the composed system may not achieve the desired end-to-end security property: an adversary may exploit complex interactions between components to compromise security. such attacks have shown up in the wild in many different settings, including web browsers and infrastructure[3,4,20,10,19], network protocols and infrastructure[26,2,29,22,35], and application and systems software[34,8]. while there has been progress on understanding secure composition in specific settings, such as information flow control for non-interference-style properties[24,23,25] and cryptographic protocols[17,9,31,12,6,11], a systematic understanding of the general problem of secure composition has not emerged yet.



we discuss below closely related work on logic-based and language-based approaches for compositional security. orthogonal approaches to secure composition of cryptographic protocols include work on identifying syntactic conditions that are sufficient to guarantee safe composition[17,11]. another orthogonal approach to secure composition is taken in the universal composability or reactive simulatibility[9,31] projects. these simulation-based definitions when satisfied can provide strong composition guarantees. however, they have been so far applied primarily to cryptographic primitives and protocols.



compositional logics of security. the framework presented in this paper is inspired by and generalizes prior work on logics of programs for network protocol analysis[12,13,33,18] and secure systems analysis. at a conceptual level, a significant new idea is the use of interface-level abstractions to modularly build trusted systems and flexibly model adversaries with different capabilities by confining them to stipulated interfaces. in contrast, prior work lacked the interface abstraction and had a fixed adversary. also, the actions(side-effects) in the language were fixed in prior work to communication actions, cryptographic operations, and certain operations on shared memory. on the other hand, our programming model and logic are parametric in actions. one advantage of this generality is that the compositional reasoning principles(proof rules) are action-independent and can be applied to a variety of systems, thus getting at the heart of the problem of compositional security(see section 3.1 for details of the parametrization). we expect domain-specific reasoning to be codified using axioms; thus, the set of axioms for reasoning about network protocols that use cryptographic primitives will be different from those for reasoning about trusted computing platforms. the treatment of rely-guarantee reasoning in the presence of adversaries generalizes the invariant rule schemas for authentication, integrity, and secrecy properties developed earlier.



refinement types for verifying protocols. recently, bhargavan et al. have developed a type system to modularly check interfaces of security protocols, implemented it, and applied it to analysis of secrecy properties of cryptographic protocols. their approach is based on refinement types, i.e, ordinary types qualified



we start by describing our formalism for modeling systems and a logic of programs for specifying and reasoning about their security properties. in section 3.1, we describe a concurrent programming language for modeling systems. section 3.2 introduces our running example. section 3.3 presents the logic of programs that is used to express security properties of systems modeled in the programming language.



the expression t returns term t to its caller. act a evaluates the action a, potentially causing side-effects. let(e1, x.e2) executes e1 first, then binds the term obtained from its evaluation to the variable x and evaluates e2. if(b, e1, e2) evaluates e1 if b is true and evaluates e2 otherwise. call(f, t) calls function f with argument t: if write lock on the access control matrix p. the lock is necessary to avoid write-write and read-write races on the matrix. action read(p) reads the access control matrix, while insert(p,(f, k, p)) inserts the triple(f, k, p) into the access control matrix. finally, we have actions send(m), that sends a message m on the network(we assume that the source and destination fields of a message can be spoofed, so we do not model them), and recv that receives a message from the network.



technically, properties(1) and(4) follow from an analysis of the known program of the teacher, using principles introduced in section 4.2. properties(2) and(5) depend on the behavior of all threads, including those that are adversarial, so they must be proved by an analysis of available interfaces f only(section 4.3). property



the formula p@ u means that the atomic formula p holds at time u(on the trace against which the formula is being interpreted). p@ u is a hybrid modality[32,7]. it is known that all operators of linear temporal logic(ltl) can be expressed using p@ u and quantifiers, so this logic is at least as expressive as ltl. in addition to increasing expressiveness, using a hybrid logic instead of ltl allows us to express order between actions in security properties in an intuitive manner, facilitates reasoning about invariants of programs modularly(section 4) and also facilitates rely-guarantee reasoning without the need for additional induction principles(section 6).



example 1. as an illustration, we formalize in our logic the security property described at the end of section 3.2. suppose that the predicate update(i, f, d) holds at time u if at time u, thread i executes the action update(c, f, d) and predicate owner(i, k) means that principal k owns threads i. 1 then, the following formula z. note that the variable x in the body of the function differs from the x in its specification. in the former case, the variable is the argument of the function whereas in the latter case it is the result of the function.



composition logic[12,13,33,18] and the logic of secure systems encodes invariants using standard partial correctness assertions and a notion of prefixes of a program. however, prefixes are impossible to define in the presence of function calls and recursion. our treatment is novel and strictly more general because it allows for specification of invariants of programs with all control flow constructs.



next, we present a proof system that codifies compositional reasoning principles for establishing assertions about programs as well as security properties. in addition to standard rules for proving temporal formulas and syntax-directed rules for proving assertions about programs and functions, our proof system includes two rules of inference that allow deduction of properties of threads from invariants of their programs. we call a thread trusted if the program it executes is known, else we call the thread untrusted or adversarial. using the first rule(section 4.2), we may combine knowledge that a particular thread is executing a known program with any invariant of the program to deduce that the formula in the invariant holds forever. the second rule(section 4.3) embodies our central idea of reasoning about unknown, potentially adversarial, code by confining it to interfaces: if we know that an adversarial thread has access only to certain interfaces, then under certain conditions, we can show that a common invariant of all those interfaces always holds in the system, regardless of the manner in which the adversarial thread uses those interfaces.



rules for establishing invariance assertions are more involved, but are also modular. we illustrate their justification through the rule(il). in the conclusion of the rule we wish to establish an invariant that holds while let(e1, y.e2) executes. if this



example 3. the invariant in example 2 can be proved using the rules presented in this section, related rules for other types of program expressions, and some straightforward axioms for relevant actions. we list two such axioms below, leaving the rest to the full version of the paper. these axioms mean that the receive action recv and administrative reductions do not insert anything into the access control matrix. soundness of such axioms is easy to prove, as has been demonstrated in prior work[13,14].



next, we present the rule used to prove properties of trusted threads from knowledge of their programs. in the logic, we say that honestthread(i, e) if thread i executes program expression e only. let start(i)@ u hold if at time u, thread i is ready to execute, but has not performed any reduction. the following rule, based on the honesty rule in prior work on protocol composition logic, allows us to prove a property of thread i from an invariant of e if honestthread(i, e).



example 5. we sketch a proof of property(2) from the outline at the end of section 3.2. the property states that if a thread can insert a permission for file f into the access control matrix then the thread must have the administrate permission on f, or, formally,



often, a security property relies on specific behavior of threads that can be ascertained only if the security property itself holds in the past. for example, consider property(3) from the outline at the end of section 3.2: only the teacher ever obtains administrate permissions. reasoning that this property holds at any point of time relies on the property having been true at all points of time in the past. similarly, the analysis of secrecy of keys in security protocols often relies both on the keys having remained secret in the past as illustrated in prior work.



example 6. we outline briefly how property(3) mentioned at the end of section 3.2 can be proved using the rely-guarantee method described above. define the predicate hasonly(k, f, p, u) to mean that only principals in set k have permission p on file f at time u:



this paper makes significant progress towards developing a systematic foundation for compositional system security. we plan to extend this work in several directions. so far, we have considered reasoning principles for first-order programs where code cannot be passed as arguments or returned from expressions. however, many systems rely on passing code either as data or through pointers. to model and to establish security properties of such applications, we propose to extend the formalism with higher-order constructs and develop associated compositional reasoning principles. while this paper has focused on the technical foundations of the theory, we plan to apply this framework to develop a systematic basis for web security, to formalize attacker models for web browsers proposed in the literature and develop new ones, and to build an understanding of relevant security policies, endto-end security properties, attacks in the wild, and ways to defend and prove web applications secure against these attacks.



