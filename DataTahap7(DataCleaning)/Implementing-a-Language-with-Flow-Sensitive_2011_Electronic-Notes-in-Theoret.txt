numerous attempts have been made to bridge the gap between static and dynamic languages. scala, c#3.0, ocaml and, most recently, java 7 all employ local type inference(in some form) to reduce syntactic overhead. techniques such as gradual typing[46,50], soft typing and hybrid typing enable a transitory position where some parts of a program are statically typed, and others are



nullable references have proved a significant source of error in languages such as java. the issue is that, in such languages, one can treat nullable references as though they are non-null references. many solutions have been proposed which strictly distinguish these two forms using static type systems[18,17,41,35].



implementing these shapes in most statically-typed languages would be more cumbersome and more verbose. in modern object-oriented languages, like java, expressions must still be explicitly retyped. for example, after a test such as s instanceof circle, we must introduce a new variable, say c, with type circle as an alias for s, and use c whenever we wanted to access s as a circle.



whiley represents numbers on the jvm in a similar fashion to clojure. more specifically, ints and reals are represented using custom biginteger and bigrational classes which automatically resize to prevent overflow. whiley requires that integers are truly treated as subtypes of reals. for example:



since variable d is guaranteed to be a list of some sought, its type on entry is translated to list on the jvm. thus, whiley cannot use an instanceof test on d directly to distinguish the two cases. instead, we must examine the first element of the list and test this. thus, if the first element of the list is itself a list, then the true branch is taken 3.



since variable r is guaranteed to be a record of some sort, its type on entry is translated as object[]. thus, implementing the type test using instanceof does not make sense, as this will not distinguish the two different kinds of record. instead, we must check whether r has fields x and y, or not. to support this, the representation of records must also associate the corresponding field name with each slot in the object[] array. this is achieved by reserving the first slot of the array as a reference to an array of field names, each of which identifies the name ofa remaining slot from the outer array.



distinguishing between different record types can be optimised by reducing the number of field presence checks. for example, in the above, there is little point in checking for the presence of field x, since it is guaranteed in both cases. the whiley compiler generates the minimal number of field checks to be certain which of the possible cases is present.



information flow analysis is the problem is tracking the flow of information, usually to restrict certain flows based for security reasons. the work of hunt and sands is relevant here, since they adopt a flow-sensitive approach. their system is presented in the context of a simple while language not dissimilar to ours, although they do not account for the effect of conditionals. russo et al. use an extended version of this system to compare dynamic and static approaches. they demonstrate that a purely dynamic system will reject programs that are considered type-safe under the hunt and sands system. jflow extends java with



typestate analysis focuses on flow-sensitive reasoning about the state of objects, normally to enforce temporal safety properties. typestates are finite-state automatons which can encode usage rules for common apis(e.g. a file is never read before being opened), and were pioneered by strom and yellin[48,49]. fink et al. present an interprocedural, flow-sensitive typestate verification system which is staged to reduce overhead. bodden et al. develop an interprocedural typestate analysis which is flow-sensitive at the intra-procedural level. this is a hybrid system which attempts to eliminate all failure points statically, but uses dynamic checks when necessary. this was later extended to include a backward propagation step that improves precision.



