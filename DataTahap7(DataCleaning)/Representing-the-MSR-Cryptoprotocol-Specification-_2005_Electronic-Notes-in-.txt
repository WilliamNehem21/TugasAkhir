for the specification of complex cryptographic protocols, possibly structured as a collection of coordinated subprotocols[3,5]. it uses strongly-typed multiset rewriting rules over first-order atomic formulas to express protocol actions and relies on a form of existential quantification to symbolically model the generation of nonces and other fresh data. dependent types are a useful abstraction mechanism not available in other languages. for instance, the dependency of public/private keys on their owner can be naturally expressed at the type level. finally, msr supports an array of useful static checks that include type-checking and data access verification.



this work serves as the basis for a forthcoming prototype of msr, which will eventually run on top of maude. the linguistic affinity between msr and rwldt allow for a much simpler construction than a direct implementation. mapping msr into the popular capsl intermediate language would have been more difficult, because msr has a much richer typing infrastructure than cil.



the remainder of this paper is organized as follows: we introduce msr and rwldt in sections 3 and 4, respectively. in section 5 we define the mapping from msr into rwldt, state its key properties, and outline some simple optimizations. it is applied to our running example, the otway-rees protocol, in section 6. we conclude this paper with a discussion of limitations, implementation aspects, and possible extensions of our approach. first, some notation.



we use[] to denote the empty list and a comma to denote list concatenation. we write identifiers ranging over lists in bold, and indicate their length with a superscript. therefore, xn denotes a list of n elements. we will generally omit the length information when irrelevant or easily deducible from the context.



(x) and application. here, x can be either a bound variable or a previously declared identifier. for conciseness, we describe atomic types(i.e., objects of kind type) as if they were terms. reserved atomic types include the type of states(state), principals(princ) and messages(msg). we write{x: t}t' for



for the following we assume that msr specifications do not use names introduced by initial context other than state, princ and msg. we also assume that all declared and bound variables are distinct. this allows a clear presentation of the main ideas without worrying about renaming and capturing. we then define the translation of msr kinds, types, states, and contexts as follows:



the idea behind the definition of role is that it maps each msr role i to several rwldt rewrite axioms: there is one rewrite axiom labelled ai, representing the instantiation of this role. in addition, there is one rewrite axiom labelled aij(generated by rule) for each of its rules j. the first axiom ai, apart from the generation of fresh terms needed for the new instance, generates tokens(ti1 p l),...,(tin p l), representing the fact that none of the rules of this role have been executed yet. each of the remaining axioms aij simulates the corresponding msr rule j, so that each application of a rule removes its corresponding token. this realizes the msr policy that rules of active roles can only be executed once.



if there is at least one token(left) that represents the active role, then this token carries the full information, namely i, a, and n, to determine the initial role instance. unfortunately, we need to argue that together all tokens of the form(tij a n) uniquely determine the rules of this active role, i.e., the rules that still need to be executed. the only potential source of confusion is that the representation may contain several application of the rewrite axiom labeled ai(see definition of role) in rwldt. using the freshness invariance lemma is it easy to see that the existential quantifiers of role i are correctly instantiated using k fresh terms n which are generated in this process. apart from maintaining the freshness information, the only effect of the rule is that the terms(ti1 a n),...,(tin a n) are added to the rwldt state. this can only correspond to the addition of a new instance of role i to the active role set.



the idea behind these definitions is that the rewrite axiom labelled rij1 generated by rule1 simulates the effect of instantiating role i immediated followed by the execution of one of its roles, which is j in this case. as a consequence it generates the formal multiset of tokens(ti1 p l)...(tin p l) with(tij p l) removed, because the corresponding rule has already been executed. the rewrite axiom labelled rij2 generated by rule2 takes care of the execution of remaining rules, and hence remains unchanged compared with the previous section.



another obvious optimization is to omit the rewrite axiom rij when the role i contains only a single rule. this optimization relies on the fact that in this case tij can never appear in the state, an invariant that holds for the reachable states we are concerned with in the theorem. more generally, we drop any rule that depends on a tij that is never generated. this can happen, because the only rule that generates tij has been eliminated by previous optimizations.



the full rwldt specification successfully passes the occ type checker, which implies that the original msr specification is type-correct as well. the occ prototype can further be used to explore the dynamics of the protocol. for example, to restrict the protocol execution to one instance of each role and to observe termination we add starti and terminatedi tokens to respectively the first and last rules of each role i.



after starting the symbolic execution the system performs a series of actions each corresponding to the application of a rule. finally, the terminating state is reached, the explicit type information is preserved, and six fresh constants have been used. an exploration of the state space using maude shows that the above execution is the only possible one from the given initial state.



in this paper we have presented a shallow and hence efficient embedding from msr into rewriting logic with dependent types(rwldt), which has been introduced as a restricted instance of the open calculus of constructions(occ). this mapping forms the basis for an ongoing implementation of an msr execution and analysis environment. a mapping from rwldt into rwl has already been implemented as part of the occ prototype in maude. this enabled us to perform symbolic execution of the translated msr specification in our example. the user interaction takes place at the level of rwldt terms, which directly correspond to msr terms, and hence the user does not need to be concerned with the resulting translation into rwl. a similar interface for symbolic search and model checking would be easy to implement. at the moment, we can however already export the rwl translation of the rwldt specification and perform symbolic search and model checking at the level of



for the sake of clarity we made a number of simplifying assumptions in this paper. we decoupled the issue of inferring implicit parts of an msr specification from the actual translation phase, which is exactly the way we would like to organize the architecture of the translator. we also assumed the absence of name clashes, an assumption that is not necessary if we use the cinni explicit substitution calculus[13,14] and its term representation. in fact the theory and prototype for occ are already based on this calculus.



an important part of msr, the data access specification, has not been treated in this paper, because a sufficiently generic and concise formulation is still subject of ongoing work. our most recent idea to formalize the data access specification is to use predicates inside the type theory to express the accessibility of information relative to principals. in combination with the assertional propositions of rwldt this may simplify the representation of data access rules significantly and would provide a great deal of flexibility. furthermore, the proof that the data access specification is satisfied would become an object inside the type theory. in fact, the logical nature of rwldt is far from being fully exploited so far, which leads us to the last point of the conclusion.



