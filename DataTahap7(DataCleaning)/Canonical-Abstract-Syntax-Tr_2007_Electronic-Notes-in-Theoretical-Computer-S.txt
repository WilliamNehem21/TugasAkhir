this paper presents gom, a language for describing abstract syntax trees and generating a java implementation for those trees. gom includes features allowing the user to specify and modify the interface of the data structure. these features provide in particular the capability to maintain the internal representation of data in canonical form with respect to a rewrite system. this explicitly guarantees that the client program only manipulates normal forms for this rewrite system, a feature which is only implicitly used in many implementations.



one of the main originalities of this system is to be data structure independent. this means that a mapping has to be defined to connect algebraic data structures, on which pattern matching is performed, to low-level data structures, that correspond to the implementation. thus, given an algebraic data structure definition, it is needed to implement an efficient support for this definition in the language targeted by the tom system, as java or c do not provide such data structures. tools like



moreover, it provides a mechanism to describe normalization functions for the operators, and it ensures that all terms manipulated by the user of the data structure are normal with respect to those rules. gom includes the same basic functionality as apigen and vas, and ensures that the data structure implementation it provides are maximally shared. also, the generated data structure implementation supports the visitor combinator pattern, as the strategy language of tom relies on this pattern.



tom is a language extension which adds pattern matching primitives to existing imperative languages. pattern-matching is directly related to the structure of objects and therefore is a very natural programming language feature, commonly found in functional languages. this is particularly well-suited when describing various transformations of structured entities like, for example, trees/terms, hierarchized objects, and xml documents.



be used as a java function to perform addition. nat is the algebraic sort tom manipulates, which is mapped to java objects of type term. the mapping between the actual object term and the algebraic view nat has to be provided by the user.



an algebraic signature describes how a tree-like data structure should be constructed. such a description contains sorts and operators. operators define the different node shapes for a certain sort by their name and the names and sorts of their children. formalisms to describe such data structure definitions include apigen, xml schema, ml types, and asdl.



like apigen and vas, gom relies on the aterm library, which provides an efficient implementation of unsorted terms for the c and java languages, as a basis for the generated classes. the generated data structure can then be characterized by strong typing(as provided by the composite pattern used for generation) and maximal subterm sharing. also, the generated class hierarchy does provide support for the visitor combinator pattern, allowing the user to easily define arbitrary tree traversals over gom data structures using high level constructs(providing congruence operators).



we see in this example that it is possible to use tom in the hook definition, and to use the algebraic signature being defined in gom in the hook code. this lets the user define hooks as rewriting rules, to obtain the normalization system. the signature in the case of gom is extended to provide access to the default construction function of an operator. this is done here with the make_not(arg) call.



we describe here a real world example of a program written using gom and tom together. we implement a prover for the calculus of structure where some rules are promoted to the level of data structure invariants, allowing a simpler and more efficient implementation of the calculus rules. those invariants and rules have been shown correct with respect to the original calculus, leading to an efficient prover that can be proven correct. details about the correctness proofs and about the proof search strategy can be found in. we concentrate here on the implementation using gom.



this hook only checks the form of the element to add to the arguments of the variadic operator, but does not use the shape of the previous arguments. the hooks for conccop and concpar are similar, but they do examine also the previous arguments, to perform sorted insertion of the new argument. this leads to a sorted list of arguments for the operator, providing a canonical representative for commutative structures.



as the structure calculus verify the de morgan rules for the negation, we could write a hook for the neg construction function applying the de morgan rules as in section 3.2 to ensure only atoms are negated. this will make implementing the deduction rules even simpler, since there is then no need to propagate negations in the rules.



we ensure that we do not execute the right-hand side of the rule if either r or t are empty lists. the other tests implement restrictions on the application of the rules reducing the non-determinism. this is done by using an auxiliary predicate function canreact(a,b) which can be expressed using all the expressive power of both tom and java in a factory hook. the interested reader is referred to for a detailed description of those restrictions.



we have presented the gom language, a language for describing algebraic signatures and normalization systems for the terms in those signatures. this language is kept low level by using java and tom to express the normalization rules, and by using hooks for describing how to use the normalizers. this allows an efficient implementation of the resulting data structure, preserving properties important to the implementation level, such as maximal subterm sharing and a strongly typed implementation.



we have shown how this new tool interacts with the tom language. as tom provides pattern matching, rewrite rules and strategies in imperative languages like c or java, gom provides algebraic data structures and canonical representatives to java. even though gom can be used simply within java, most benefits are gained when using it with tom, allowing to integrate formal algebraic developments into mainstream languages. this integration can allow to formally prove the implemented algorithms with high level proofs using rewriting techniques, while getting a java implementation as result.



