the mentioned analyses are both based on bdds. this has as a drawback that circuits which are difficult to represent using bdds are difficult to handle using the method, since the method inherently relies on computing a bdd which represents the function that the circuit implements. also, the analyses involve a fixed point computation over bdds, which might introduce extra costs.



the rest of the paper is organized as follows. the first three sections can be seen as a tutorial on the subject and introduce background material, large parts of which are also presented elsewhere; in section 2, we introduce the definition of circuits, and what their naive, classical semantics is; in section 3, we show how to verify safety properties of these circuits, under the classical semantics, using a propositional theorem prover; in section 4, we present the constructive semantics of circuits, which corresponds more closely to what happens in electrical circuits. our main result is presented in section 5, where we show how safety properties of cyclic circuits can be proved, under the constructive semantics. finally, in section 6 we discuss related work and conclude.



the form x= f contained in c. a solution of a combinational circuit is a valuation, i.e. an assignment of all variables to a boolean value 0 or 1, such that all definitions are satisfied, using the usual interpretation of the boolean operators.



c,a safety property p is valid, if s(p)= 1, for all solutions s of c. if we want the safety property to be a more complicated property than just a variable, namely a formula f, we can simply add p= f as a definition to c. in the rest of the paper, we will sometimes do this implicitly.



proving combinational properties. in order to check if a given property p is valid for a given combinational circuit c, we can use a propositional logic theorem prover, often called sat-solver. there are many such theorem provers available. our choice of theorem prover is discussed in section 6. to check the validity of a safety property p, we simply prove:



complete induction. the method of temporal induction as described above is sound, but not complete. this means that there are safety properties which are valid but cannot be proved by the proposed method. in particular, when the safety property p is very weak, assuming it as an induction hypothesis is not enough for the induction step to be a valid formula.



however, it is possible that this process never terminates. this can happen when the unreachable state space contains loops. to exclude the loops and to make the method complete, we can add an extra assumption in the step case, namely that all states used in it are unique. it is sound to assume this, since if there is a solution path leading to a state where p is not true, there also exists a solution path leading to that state which consists of unique states. so, we define diff(d, i, j) to mean that the states in time instances i and j are



cyclicity. for a given combinational circuit c, and variables x and y, we say that x directly depends on y, if y is contained in the right hand side of the definition of x. by taking the transitive closure of this relation, we obtain the relation x depends on y.



electrical circuits. the circuits we have defined mathematically correspond to an obvious electrical implementation: the logical connectives can be implemented as the corresponding logical gates, points with the same variable name are wired together, and delayed definitions can be implemented using registers. for combinational acyclic circuits, we know that there exists exactly one solution for each input vector. this is also the solution that the corresponding electrical circuit computes.



however, we do not want the circuit to compute undriven values. thus, we make the following definition. a combinational circuit c is called constructive, if and only if, for all defined inputs, all values in the corresponding least solution are defined.



note that every delayed definition is turned into one delayed definition, and one normal definition. this means that the transformation does not increase the number of state variables in a circuit. this is correct since we can assume that the output of a delay component in a circuit is always defined. this assumption is however only valid if we really prove that the input to a delay component is always defined.



constructiveness as a safety property. now, we formulate the constructiveness condition as a classical safety property: for all defined inputs, all solutions are defined. this is the same as showing that the following property is a valid safety property for the transformed circuit.(we let i be the set of all input variables, and v be the set of all variables in the circuit.) circuit as mentioned above, and verify that the above safety property holds for the transformed circuit. we can use any formal verification method for that, provided it gives classical semantics to combinational cycles. for our purposes, the method of temporal induction presented in section 3 has worked well.



synchronous hardware description and verification workbench. formulating the constructiveness condition as a safety property has the advantage that we can implement the analysis independently from the underlying verification method. in lava, we just implemented a circuit transformation that performs the translation described in section 5. the analysis can then be performed by any built-in verification method using classical semantics, such as the ones described in section 3. the method we mostly use, as described, is induction with increasing depth. we have since extensively used the analysis in our hardware compilation framework.



possible improvements. one possibility for improvement which we have not pursued is to investigate the circuit structurally, and only apply the analysis on the strongly connected components, i.e. the parts of the circuit involved in a cycle. in practice, this would amount to not applying the dual-rail encoding on the paths that lead from the inputs to the parts of the circuit containing cycles, and not on the paths leading from the cycles to the registers.



