in this paper, we discuss in detail the alternative ways that exist for the reconstruction of java types by bytecode analysis and run-time introspection. the following section 2 focuses deeply on the motivating problem with real life examples. the features which are utilized in component dependencies actually depend on the component model used. since we work mainly with the osgi component model, we will provide short description of osgi in subsection 2.3.



the proposed method of java type reconstruction is described in the next two sections. section 3 describes a java type system representation employed by our method. the generality of its design allows the representation to be used in other projects to ensure java language type compatibility. section 4 describes the approach to deciding on component compatibility which uses algorithms working on the type system representation. the merits of these methods are discussed in the end of the work.



dencies between its parts(let say classes) are created at build time when they are also checked by the compiler to be type compatible. in case of problems found by the compiler, the resulting code is not created; when language types(classes and interfaces) are compatible, the application can be built and deployed to a production site. when a new version of software is developed, the whole monolithic code package is again moved to the production site for application upgrade.



in this section we describe a concrete example of the problem with component compatibility, showing how the user can be affected by this issue. it is one instance of a set of runtime failures which take hours to track down. methods which prevent such runtime exceptions can therefore save valuable amounts of development time. to develop a frontend for a research project we decided to extend the apache felix webconsole bundle. this webconsole is an extendable webpage for managing a running osgi framework. it embeds a servlet container which can be extended by registering a service implementing an interface



we have designed this layer according to the java language specification, third edition. the javatypes layer is very similar to the java reflection api but is more general because the contents can be obtained from other sources than just reflection. for reasons described below, the unique feature of javatypes is the ability to create the type representation also from component bytecode or the possibility to create representation of nonexisting classes by manipulation.



when creating the representation from bytecode, we use the asm and bcel bytecode analysis frameworks. asm provides a visitor pattern approach for accessing all parts of class data. we have implemented visitors for the particular javatypes classes. bcel is used for historical reasons(introduced earlier than asm to the project).



to be able to compare bundles, we have to create the representation of those bundles. this is performed in three steps. the first one is reading the bundle metadata information, in the second and third steps we follow the pointers from this metadata and go to bundle implementation to get the java layer representation.



the type reconstruction starts at the bundle level. for each exported package and service we create the corresponding jpackage or jservice objects. then, their jclass contents needs to be filled in. the situation is trivial for the service case when only one class(the service interface) is referenced. for packages, the list of all contained classes is first obtained by querying the classloader and then expanded by creating jclasses using the reflection type loader.



next we have to create the representation of all types referenced by public methods or fields of these classes because they will be used in the type-based bundle comparison. this process is bootstrapped by adding the jclasses from exported packages and services to the knowntypeslist queue. then an iterative algorithm for creating the whole transitive closure of interface types starts. all unprocessed types from knowntypeslist are handled consecutively. for each type t from knowntypeslist, the jtypes referenced by its members are retrieved. for each type r from these referenced types one of these possibilities is true:



in this section we describe the algorithm of component type-based comparison. because the focus of this paper is on type representation reconstruction, only the main principle will be illustrated through an example. we first describe a function used to compare type structures, then show some typical use cases for this method.



in the second version one method(void setsize(int)) in interface logger was deleted and at the same time one method(void flushallloggers()) of another interface logservice was added. whereas the logger was generalized the logservice was specialized. these two changes in the same package are contravariant, so that the resulting difference is a mutation of the type.



as described in detail in previous work, the bundle comparison method can be used for automated versioning of components. this process can simplify the error-prone task of assigning version identifiers to components and their features. the type differences described above can be used as an input to an automatic creation of version identifiers describing the real evolution of component interface. in the case of osgi for example, the version numbering scheme is governed by rules which nicely map to the difference values. when using such automated versioning in a component system, its administrators can rely on the reliability of the version identifiers.



this use case applies the method at the bundle release time, when bundle type representations obtained by bytecode inspection of two last component revisions are compared. the first bundle in the comparison is the last previously released component with version identifier. the second bundle is the next release candidate for which we want to determine the version identifier.



another use case of the method is applicable at the deployment time of components. in this case we can use the subtyping comparison to ensure that the new version of a bundle is compatible with the previous one, regardless of the version numbers assigned to both(taking the conservative stand that their reliability is low and that a robust method is needed to ensure application type consistency). alternativelly, the method can be similarly applied to comparing a new version to the actual context of its deployment.



in this use case the method is applied at component deployment time. the representation of the old bundle version is obtained from reflection, including the imported side(resolved to existing package exporters). the representation of the new bundle version is obtained via bytecode analysis.



when using safe updater as an updating tool we can prevent the situation from introductory example in section 2.4. the safe updater searches the interfaces of providers and importers recursively and verifies if types referenced by these two sides of the contract are compatible. the subtyping rules applied recursivelly guarantee those errors preclusion.



the last application scenario we mention is the process of resolving the components with additional subtyping checks. resolving, similar to the linking stage of a compilation process, is used to bind imported packages to corresponding exporters. these bindings are made only on matching names of imports and exports.



the additional checks ensure that all mutual component interfaces in a component system are compatible with each other. here, our method is applied at the start time of the component framework, after component installation or update. both compared interface sides are loaded via reflection.



in both research and industry world bytecode analysis and manipulation techniques are common. the asm library can be used to modify existing classes or dynamically generate classes and it is focused on simplicity of use and performance. other frameworks with similar functionality are jmangler or javaassist. classes are represented by objects which contain all the symbolic information of the given class: methods, fields and byte code instructions, in particular. this approach is less efficient than asm visitor design pattern, thus asm is the best choice for dynamic systems.



a distinct class of frameworks uses xml for bytecode representation and manipulation[17,19]. they are comparable in features to the above approaches and support advanced operations including crosscompilation. the latter work discusses the need to transform or wrap api calls embedded in the bytecode.



unlike javatypes, none of these approaches deals with the problems of reconstructing the referenced types not found in the analysed bytecode, which is a key need in the cbse context. another advantage of javatypes is the ability to compare the reconstructed types by subtyping rules. on the other hand, javatypes is not intended for bytecode manipulation and intentionally supports only a limited subset of java language features.



the ability to perform type-based compatibility checks is important for enhanced robustness of component applications. in this paper, we have described a supporting representation of the java language types which constitute the interface of components together with a set of methods for obtaining this representation. our system allows to use a mixed set of sources in these methods, including the reflection api and bytecode analysis using the asm tool.



