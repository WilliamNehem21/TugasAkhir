our main interest in this paper is in designing a forward inverse method prover for the logical framework twelf. twelf supports the specification of deductive systems, given via axioms and inference rules, together with the proofs about them, and has been extensively used over the past few years in several applications. the theoretical foundation for twelf is the logical framework lf. the lf language, a dependently typed lambda-calculus, can be briefly described as follows:



we define an lf type called tp, with the constructors top, arr, and all. the type for the constructor all takes in two arguments. the first argument stands for the bound and has type tp, while the second argument represents the body of the forall-expression and is represented by the function type(tp-> tp).



next we consider the implementation of the subtyping relation. since we represent variables of the object language implicitly, we cannot generically represent sa-ref and sa-tr where both these rules are applicable for all type variables. instead of a general variable rule, we will add rules for reflexivity and transitivity for each type variable. reflexivity and transitivity rules are dynamically introduced for each type variable.



next, we must iterate over the set f of uniform facts and the set r of pre-compiled derived rules to generate new facts by forward chaining. essentially we need to plug the facts into the open premises to generate new facts. there are essentially two possible loop structures which we both briefly discuss. both of these two loops have been implemented and tested for the horn fragment.



iterate over rules in this alternative implementation, we keep the two sets of facts f and fn and iterate over the set r of rules. initially, all facts generated during the pre-compilation phase are in the set fn and f is empty. given a rule with the premises p1,..., pn, we try to find a fact f from the set fn which unifies with p1 up to pn. if we succeed in unifying with pi, we continue to search over the set f and fn to find instantiations of the remaining premises. if all the premises are unifiable with some fact f, we generate a new fact p which is temporarily added to a set f', if there is no fact f' in f, fn or f' s.t. p is an instance of f'. this add fn to the set of facts f and f' will be used as our new set of facts fn. in this loop, the size of r remains constant. on the other hand, we may unify multiple times a given premise pi with a given fact from f. we terminate if no new facts are generated, i.e. f' is empty.



while the number of rules generated by the if loop is not quite as large as for fibonacci, it is still substantial. for 3 tokens, we generate 54 rules up to 182 rules for 9 tokens. this is compared to 13 rules which are generated during the precompilation phase in the ir method. these results clearly demonstrate that tabling cannot easily be outperformed. the inverse method is costly, and especially in the implementation if the number of facts is growing substantially more. our other



in the future we intend to extend our implementation of the inverse method to hereditary harrop formulas and cover the full higher-order fragment. to achieve a basic implementation seems not that difficult, however to build an inverse method prover with competitive performance we must tackle several issues. the first issue is efficient higher-order unification which seems central to the inverse method. related to this issue is the fact that our theoretical development and implementation only deals with higher-order patterns where unification is decidable. to handle the full fragment of higher-order terms, we carefully need to revisit the issue of constraints.



another important question is how to bound the inverse method search. while we do get a decision procedure when we execute the parsing algorithm with tabling, the inverse method does not directly yield a decision procedure. one way of addressing this problem may be to incorporate ideas from chaudhuri et al. and distinguish not only between left focusing and uniform proofs, but also introduce a right focusing phase. as observed in, this may have a substantial effect on performance. however, it remains unclear how to in general classify atoms as being left or right biased or mix the two biases. extending the given theoretical framework to consider different bias for atoms is in principle possible.



finally an important question is how to bring some goal-directed search into the inverse method. while the subformula property restricts the proof search on the level of formulas, it does not restrict the possible instantiations for the objects occurring in formulas. this has been already observed in the logic programming community and lead to the development of magic sets. magic sets transform the original program in such a way that a forward chaining logic programming engine is goal-directed and will only generate the relevant subgoals for a given query. incorporating magic sets into the inverse method could substantially reduce the number of generated intermediate goals, and only generate relevant subgoals thereby yielding a competitive engine compared to backward chaining logic programming.



kaustuv chaudhuri, frank pfenning, and greg price. a logical characterization of forward and backward chaining in the inverse method. in u. furbach and n. shankar, editors, proceedings of the third international joint conference on automated reasoning, seattle, usa, lecture notes in artificial intelligence(lnai). springer-verlag, 2006.



