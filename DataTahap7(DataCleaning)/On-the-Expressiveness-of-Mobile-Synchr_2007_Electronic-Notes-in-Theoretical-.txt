as proved in, both ubiquitous nets and mobile synchronizing nets without identifiers can be simulated by ordinary petri nets. however, we did not know yet which was the expressiveness of mspn systems when these identifiers are introduced. since all along the paper we only consider this extension with identifiers, we will just use the term mspn systems to refer to them. by means of labelled natural numbers that cannot be forged we get a mechanism to obtain authentication, that abstracts from the particular cryptographic techniques used to achieve it, typically proving possession of a secret key issued by some authority. in our setting this authority coincides with the principal asking for authentication, as usually happens in ubiquitous computing. in particular, it is enough to implement the most widely used authentication policy in ubiquitous settings, the resurrecting duckling policy. but one can argue that this mechanism based on natural numbers is too concrete, so that by examining the values of the corresponding tokens we can get information about when the identifiers were created. this is why we have also studied a more abstract version of the model, which we will call abstract mspn systems, where fresh identifiers are used instead of natural numbers.



we study the expressive power of both models by proving several decidability and undecidability results for several instances of the classical reachability and coverability problems. in particular, we prove that reachability and coverability are decidable for mspn systems, but reachability of submarkings is not. also, we prove that coverability is decidable in the case of abstract mspn systems, but reachability is not. these results show that their expressive powers lie somewhere between p/t nets and turing machines.



the paper is structured as follows. section 2 gives an overview of mspn systems, together with an example. section 3 considers reachability issues, whereas coverability results are presented in section 4. finally, conclusions and directions for further study are discussed in section 5.



a mspn is a special kind of coloured petri net, with only three different colour types: one for localities, one for identifiers and a singleton colour type for ordinary black tokens. arcs are labelled by variables that range over the set of values of the colour of its adjacent place, as stated in(i). condition(ii) says that the variables in the outgoing arcs of a transition must appear in some incoming arcs, so that tokens can be consumed or moved by autonomous transitions, but not made up. condition(iii) establishes the existence of a single locality precondition for movement transitions, those labelled by go, from where the net chooses its destination. according to the last two conditions, each net has at most one successor transition, in which case it has a single identifier precondition place that we will call counter of the net(denoted in the previous definition by c), that is also a postcondition of that transition, and that it is neither a precondition nor a postcondition of any other. these restrictions avoid the possibility to use these transitions as a mechanism to simulate ordinary counters, that is, natural variables. in particular, every time the succ transition is fired it produces a new value.



in this section we will consider the classical reachability problems. we will prove that reachability is decidable for mspn systems, but undecidable for abstract ones. instead, submarking reachability is also undecidable for mspn systems, what will distinguish them from p/t nets, proving that they are more expressive.



at each marking there will be a single valid identifier value. to identify that value we use a special place current, where we storage the identity token with the current valid name. then, we will simulate the value of the counter ci with the amount of(valid) tokens in place ci. we use ordinary places{s0,..., sk}, one for each state of the tcm, so that a token at si means that the tcm is at the state si. moreover, we will use some other auxiliary ordinary places to manipulate the control.



in the previous section we considered reachability problems. in particular, reachability in abstract mspn systems and submarking reachability in mspn systems have been proved to be undecidable. fortunately, safety properties of our systems are usually defined in terms of coverability. in this section we prove that coverability is indeed decidable both for mspn systems and abstract mspn systems.



in this paper we have proved several results regarding expressiveness of mspn systems with natural numbers as identifiers. in particular, we have shown that reachability and coverability are decidable for mspn systems, but submarking reachability is not, for the particular class of mspn systems in which identifiers are basically unforgeable natural numbers generated by a counter mechanism. although one could expect that submarking reachability should be easier to decide than reachability, the special restrictions constraining the use of the counter places, used to generate the identifiers, which cannot be either decreased or emptied, are responsible for this special feature of the model.



as future work, we plan to make our approach scalable. more exactly, we are investigating how, and under which hypothesis, we have to modify our name generation mechanism so that it also works in open environments. in addition, the coverability techniques seen so far can only be applied to closed systems. for instance, deciding coverability in the example shown in section 2.2 only checks the system when the clients have that particular form, which is clearly insufficient to prove the safety of the system in an open setting, where the clients can have any unknown behaviour. we are currently developing an alternative version of our operational semantics that take into account any potential environment. of course, in order to be able to prove properties, we have to assume that the environment does not know certain things about the system(secret keys, passwords,...), so that this semantics must be parametric with respect to that knowledge. in this new setting we can define the analogous problems of the original semantics, such as coverability. in order to make that semantics manageable we are defining an abstract version of that open semantics, that we can use to prove properties of the original semantics. we also intend to study our model in the presence of an alternative primitive for interaction between components, namely broadcasting instead of synchronization, given that broadcasting is a widely used primitive, specially in the ubiquitous computing framework. finally, we plan to extend our model with recursive or



