this paper presents the implementation of a program transformation that removes square roots and divisions from functional programs without recursion, producing code that can be exactly computed. this transformation accepts different subsets of languages as input and it provides a certifying mechanism when the targeted language is pvs. in this case, we provide a relation between every function definition in the output code and its corresponding one in the input code, that specifies the behavior of the produced function with respect to the input one. this transformation has been implemented in ocaml and has been tested on different algorithms from the nasa accord project.



systems, one usually rely on a finite representation and an analysis of rounding errors via abstract interpretation or interval arithmetic[3,5]. alternatively, one might want to directly prove the correctness properties not on real numbers but on the effective implementation the system uses, e.g., floating point numbers, but in this case the proofs become very difficult since any mathematical intuition is lost.



the semantics of such a language is quite straightforward. the expression letin x body scope is interpreted as letx= body in scope and letfun f(v,tv) t body scope is the definition of the function taking v as argument of type tv and returning an element of type t, i.e., let f(v: tv): t= body in scope; their semantics use call by value. the detailed semantics of this language can be found in, chapter 3 and 4. we denote jp)env the semantics of a the program p in the environment env. function and variable definitions allow for multi-variable definitions(e.g.,let f(x,y)= x+ y) but partial application is not allowed. this language can represent a subset of many programming language and programs written in such a subset can



of course we can not remove square roots and divisions from all programs,(e.g., the program sqrt(2) will still have to return a rounded value of 2). however, when square roots and divisions are eliminated from all the boolean expressions and all the definitions, the boolean values of such a transformed program can be exactly computed. thus the control flow of the program is protected from any rounding.



side, in minipvs, every definition has a scope and thus every program is complete. this allows us to specify that the transformation is correct by stating that the semantics of such a program is preserved, as stated in definition 2.1. on the other



without any scope that would allow us to state the semantics preservation. in, the mechanism introduced to transform definitions in this program transformation, provides a correctness relation between every input definition and its corresponding definition in the output program. thus, we extend the minipvs language by adding a constructor that adds a sub-typing predicate to every transformed definition.:



as mentioned previously the program transformation relies on a square root and division elimination in boolean expressions. this elimination is described in but in some places different rules can be preferred. for example the elimination of divisions in a comparison can be done using case distinction or by using the square of the denominator, e.g.,



in a similar way the elimination of square root can use variable definition inside boolean expressions to reduce the size of the output term, since its complexity is exponential in the number of square roots in the expression. however the user might want to use the transformation only for expressions built with boolean and arithmetic operators and restrict the transformation to such an expression language. thus the transformation provides two schemes for square root elimination.



this transformation greatly reduces the size of the output file since the large expressions corresponding to the transformation of boolean expression are now factorized in functions. moreover these new comparisons functions can also be generated in a separate file and then imported in the transformed program and shared between different transformed program. in this way the transformed programs have exactly the same structure as the input one.



a complete pvs specifications can be processed by the ocaml implementation of the transformation linked with pvsio. in this section we present the transformation of a conflict detection algorithm, namely cd2d, that has been developed by nasa in the accord framework. this algorithm aims at detecting loss of separation between two aircrafts in a two-dimensional space. a formal verification of this algorithm assuming floating point arithmetic has been presented in, the algorithm is described in that paper but we recall its main characteristics.



isons are replaced by functions such as gt 0 e or lt 1 e used in the minmax and maxmin function. their use is factorized since both minmax e and maxmin e use the same comparison functions. these comparison functions are defined in a separate file, namely cd2d operators.pvs, as introduced in section 4.2.



as one can notice, the number of lines in the output program is more than twice the length of the input one. however this is mainly due to the length of the subtyping predicates associated to the transformed functions. all of these subtyping predicates can be proven by first unfolding the functions of the input program and then using the(grind-reals) strategy.



we have presented a program transformation that eliminates square roots and divisions from straight line programs in order to allow exact computation with addition and multiplication. this transformation embeds a certifying mechanism that is used to prove the semantics preservation between the definitions of the input and the output program. eliminating square roots and divisions in a proof assistant also allows the use of some decision procedure that were not handling such operations in a first place.



