we must also restrict the use of implication in the bodies of de nitional clauses, otherwise cut-elimination does not hold. to that end we assume that each predicate symbol p in the language is associated with it a natural number lvl(p), the level of the predicate. we then extend the notion of level to formulas and derivations. given a formula b, its level lvl(b) is de ned as follows: more natural that what we intend to prove is rather:\if(if b m m)+ v is provable then m+ v is provable." to explore this possibility, consider introducing the predicate. that serves as an operator for provability. in this case, we now need to distinguish between two logics, one meta-level logic and one object-level logic. to do so, we shall use the type o to denote meta-level logical expressions and obj to denote object-level logical expressions. the meta-logic uses the symbols 8 of type(! o)! o, 9 of type(! o)! o and^ and, both of type o! o! o for universal and existential quanti cation at type, for conjunction, and for implication, respectively. the object-logic



., provability of m+ v directly from its horn clause speci cation or indirectly via the use of this interpreter are essentially the same:(uniform) proofs in one setting map naturally to(uniform) proofs in the other setting. from a practical point of view, this distinction does not provide any proof search advantages.



prolog, elf, isabelle, and coq, to name a few, all implement a form hoas and many earlier papers have appeared exploiting this style of syntactic representation[24,25,26,34]. since the earliest papers, however, there has been a tendency to consider richer-calculi as foundations for hoas, moving away from the simply typed-calculus setting where it was rst exploited. trying to encode a syntactic category of abstraction by placing it within a rich function spaces can cause signi cant problems(undecidable uni cation, exotic terms, etc) that might seem rather inappropriate if one is only trying to develop a simple treatment of syntax.



we shall follow the presentation of the-calculus given in. we need three primitive syntactic categories: name for channels, proc for processes, and action for actions. the output pre x is the constructor out of type name! name! proc! proc and the input pre x is the constructor in of type name!(name! proc)! proc: the-calculus expressions x y:p and x(y):p are represented as(out x y p) and(in x y:p), respectively. we use j and composition and summation, and of type(name! proc)! proc to denote restriction. the-calculus expression(x)p will be encoded as n:p, which itself is abbreviated as simply x:p. the match operator,[=] is of type name! name! proc! proc. when is written as a pre x, it has type proc! proc. when is written as an action, it has type action. the symbols# and", both of type name! name! action, denote the input and output actions, respectively, on a named channel with a named value.



proof outline. follows almost directly from propositions 4.1 and 5.1. the induction needs to be strengthen slightly to handle the case where the bound variable l in.l are free in the judgment, which can happen, of course, when a universally quanti ed goal is interpreted. 2 negation, h= i: name! name! assert! assert for the match modal, h i: action! assert! assert for the possibility modal for non-binding actions, and the following four modal operators used to encode the possibility of a bound actions: h# i; h# il; h# ie; h" i: name!(name! assert)! assert. the rst three of these modals are used to code the\basic",\late", and\early" versions of the bounded input pre x while the forth encodes the bounded output action. natural numbers are encoded as the type nat with constants z: nat and succ: nat! nat. the satisfaction relation is de ned using two predicates: j= at type(evs! proc)!(evs! assert)! o as well as at the type nat!(evs! proc)!(evs! assert)! o. this extra argument is used to help stratify this de nition in the presence of negation in the assertion language. the predicate depth is of type(evs! assert)! nat! o



finally, the approach to encoding syntax and operational semantics used here is strongly motivated by proof theoretic considerations. there has been much work lately on using a more model-theoretic or categorical-theoretic approaches for such syntactic representations, see for example[4,5,10]. comparing those two approaches should be quite illuminating.



catuscia palamidessi has made a number of comments on a draft of this paper. anonymous reviewers also made several corrections to the presentation of this paper. this work is funded in part by nsf grants ccr-9912387, ccr9803971, int-9815645, and int-9815731.



