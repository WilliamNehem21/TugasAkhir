symbolic execution was first defined for programs. the underlying concept consists in executing programs, not for concrete numerical values but for symbolic parameters, and computing logical constraints on those parameters at each step of the execution. symbolic execution allows computing semantics of programs or models and representing them efficiently in an abstract manner. model-based testing(mbt) is one of the most popular applications of symbolic execution[11,10,14,2]. symbolic execution has been used to select some parts of the resulting symbolic representation of models, which may be infinite due to the presence of unbounded loops for example, according to some coverage objective. test data are then generated from those chosen parts using constraint solving techniques. the increased efficiency of solvers in recent years[9,8,4] has helped symbolic execution to be adopted more widely for this purpose. many symbolic execution based tools for formal treatments have been developed for diverse usages, for example the ones used in(model-based) testing cited in the following survey. compared to these tools, the objective of the diversity platform is to offer an extensible platform to take into consideration various formal analysis possibilities. for this, diversity provides a common symbolic execution platform:



assuming y is initially assigned with some value v before executing tr: if this block is not used, this gives rise to assigning x with v+ 1, yet in the semantics of interest, x has to be assigned with v. in the case where the action of tr is an input, the assignment induced by the input is taken into account before the other assignments. then the transition is fired, if its data guard is satisfied before any data variable update in the case of an output action; and in the case of input action, only the assignment induced by the input is considered besides.



a system in our framework is defined by a set of communicating sts acting asynchronously, including for data passing. in fact, for any output of a value on a given channel(i.e. write to the associated buffer), that value may be consumed later by a different sts using an input action on the same channel(i.e. read from the associated buffer).



step(i) selection of ec candidates for step(ii): one or more ec are selected from the queue according to a customizable strategy. for the moment, the following exploration strategies for generating the symbolic tree are implemented: random traversal, classical bfs(breadth first search) and dfs(depth first search) traversals. some heuristics may however associate a weight with each of the ec, and thus induce an order of the ecs in the queue which means that the queue becomes a priority queue.



the firmware is in charge of scheduling which commands the hardware executes. commands must be executed according to attached priorities. furthermore, the commands can be executed in several phases. there are two tasks that the firmware must complete:(firmwaretaska) pre-processing the commands it receives for maximum efficiency, adding relevant information and separating the command into several sub-commands, and(firmwaretaskb) computing an execution schedule on the fly and sending the sub-commands to the hardware according to this schedule.



the behavior described in diagrams sdpreprocessing, sdenqueuing, sdprocessing and sdfinishing can be repeated an unknown number of times, which is captured by the loop operator. furthermore, the four scenarios happen in parallel(as expressed by the par operator) though they share some data, such as the commands being treated. each of the component roles is represented by a vertical lifeline where time evolves from top to bottom and where messages representing pieces of data transmitted between lifelines are represented by arrows between them. messages have type signal, which carries attributes, such as the specifics of a command to be executed, e.g. its priority and its weight. we use two lifelines to specify the role of the firmware: firmwaretaska and firmwaretaskb. firmwaretaska is tasked with the communications with the host and the preprocessing of commands received from the host. firmwaretaskb is tasked with will inform each other of their choice by sending coordination messages through dedicated scheduling channels schedi, schedj. so ai being busy with previous executions, may receive from aj in schedi successively op1, op2, op1 informing it to follow their nested behaviors to be consistent with the choices of aj(see the transition trfollowop 1, trfollowop 2). or ai may operate at a faster rate and initiate the choice(see the transitions trchooseop 1, trchooseop 2). note that reads from communication channels are by hypothesis blocking, i.e. ai cannot test for emptiness of schedi. we use an counter channel counteri which is filled: by 1 each time a value is written on schedi and; by a particular symbol nil that indicates the end of the buffer. this counter channel forces ai to read all the values in schedi while nil is not read(see transitions trreadsched). all the operand names read from schedi are



we provide for several values of k the success rate for 10 trials. for the most effective execution among successful trials, we also give the following metrics: the number of execution steps computed, the number of jumps, the execution time and the number of ecs computed. we parametrized the symbolic exploration strategy as follows: the fixed maximal depth n for the exploration of a sub-tree was 5, the number of ecs to be kept in the event of a hit(at least one transition of interest was covered during the exploration of the current sub-tree) was 7 and the number of ecs to select in the event of a jump(no transition of interest covered in the sub-tree at the end of its construction) was 5.



