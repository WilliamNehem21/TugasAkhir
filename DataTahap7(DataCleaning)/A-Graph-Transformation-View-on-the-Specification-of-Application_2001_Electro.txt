highly distributed networks(e.g. internet) have now become a common platform for large scale distributed programming. these environments are often called open environments, being characterized by: massive geographical distribution; high dynamicity(appearance of new nodes and services); no global



research e orts have been directed to manage this complexity through the development of new paradigms, theories and technologies for distributed applications. within this context, code mobility has received special attention due to its exibility and potential use in various application elds, like network management, electronic commerce, distributed information retrieval, advanced telecommunication services and active networks, active documents, work ow management systems, and disconnected operations(namely, the ability to launch remote computations, switch o the local node(e.g., a laptop), switch on the node later, and receive the results of the remote computations).



currently there are standards, platforms and languages available for mobile code. java is being widely used due to high portability and dynamic binding, among other features. however, there are still problems to be addressed in order to build a sound support for mobile code. one of them is the lack of formal basis: the ideas around mobile code and active networks and their implementations emerged from a practical approach. an abstract semantic framework(including methods for speci cation, veri cation and analysis) to formalize the model of computation of internet applications is clearly needed, and missing. such semantic framework may provide the formal basis to discuss and motivate controversial design/implementation issues and to state and certify properties in a rigorous way.



places represent the needed infrastructure to support mobile applications. this infrastructure comprises hardware and software(middleware) support to o er locations where mobile components can run, move into and leave. beyond these basic functions, places can be con gured to support additional functionalities as needed. while building mobile applications, the developer assumes that places o er a given level of functionality. the lowest level is the support to mobility and to communication among components in the same place.



mobile components are software components that, during their execution, may migrate from place to place to use other components as well as basic facilities like processing power, storage and communications. a mobile component has internal data or state, code, and a set of meta-data or attributes(e.g. identi er, credentials, originator, operational status, etc.). mobile applications can be build from various mobile components, which may run concurrently and cooperate.



open/dynamic environment: places must o er a basic functionality level and be easily con gurable in order to better t the goals of the distributed infrastructure. in many situations, places must be highly customizable in order to support di erent applications in a distributed environment. it is important to easily install components in various places and use them afterwards(e.g. for active networks).



the distributed environment considered is characterized by being open. software components and places are independent in the sense that they have distinct ownership and therefore distinct authorities to decide upon their management. in such an environment, these entitites have distinct life-cycles, and no global state can be provided/obtained. nonetheless, entities often cooperate in order to achieve their goals.



failures: while designing a distributed application the designer has to assume some behavior of the environment where the application is to run. this has already been stated for places. another very important aspect is to consider the failure behavior of the environment. therefore it is desired that the designer may state the expected failure behavior of the environment and build its application to work on it.



using graph transformation systems, it comes natural to model places and components as nodes, and the relations modelling spatial distribution(like adjacency of places, presence of a component on a place,...) as edges. actually, the possibility of having an explicit representation of the system's topology is a strong point in favour of this speci cation formalism.



tems exists, see for an informal comparison of some of them. in all such approaches a module includes at least a description of the class of graphs handled by the modules(for example, via a type graph) and a collection of graph transformation rules. concerning the export interfaces, some of the approaches(like grace and progres) only allow to export procedure names, while others(like diego and tgts) also allow to export rules. this feature could be used to describe abstractly the behavior of the component in terms of kinds of observable events(for example, messages received/sent by a component). this would allow for a rely{guarantee approach.



dynamic environment: in many situations, it is interesting to allow the creation of multiple instances of the same component. for example, if there is a list of places to visit asking for some information, one could create one mobile component to visit each of the places and bring the information back. the only di erence among them is the place they have to visit. some approaches to modularity in graph transformation allow one to specify formal parameters for modules. for example, in both progres and cgspec the procedures exported by a module may have parameters that can bound by the client at instantiation time.



components may die at any moment, even if other components have pointers to them(for example, know their names). the middleware is responsible for handling these situations: it warns a component in case it tries to communicate with a non-existing component. also, the middleware may support distributed garbage collection. in this case, a component does not die but may



in a graph transformation approach, a possible way to handle deletion of components is to mark them as dead and provide(exception) rules for handling the cases when a component tries to communicate with them. these rules, as well as those for distributed garbage collection, if any, should be part of the speci cation of the middleware, as this is a service provided by this level. it would be desirable to have exceptions handled by the semantics in a clean way.



failures: mobile code applications have to cope with the unreliability of the open environment. typically, one should provide levels of con dence in the implementation of this systems. for example, one may want to ensure that provided nothing fails, the system behaves as expected; or that if some servers(these must be speci ed) fail, the system still behaves correctly, etc. sophisticated analysis techniques would be needed for addressing such issues. an approach to the static analysis of graph trasformation systems is pro-



a rst attempt in this direction is reported in[4,5], where a restricted form of graph grammar is used to model code mobility. components, places and messages are modeled as nodes. the behavior of places is speci ed by rules which realize typical middleware functionalities, like forwarding messages to agents located on a remote place, or handling the migration of agents. the behavior of each component is speci ed in a reactive way: each rule must delete a message vertex, meaning that this message triggers the application of this rule. no true module concept is used in the speci cation, but there are some further restrictions to rules to assure encapsulation properties of components.



ehrig, h. and engels, g., pragmatic and semantic aspects of a module concept for graph transformation systems, in proceedings fifth int. workshop on graph grammars and their application to computer science, lecture notes in computer science, vol. 1073, springer, 1996, pp. 137{154.



