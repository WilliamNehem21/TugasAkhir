transformation systems are particularly well suited to implement modular rules, transforming one language feature of the source language into a single or a composition of language features of the target language. however, in practice, transformation rules must be written which take one language feature and transform them into several language features belonging to various locations in the output program. the implementation of these so-called local-to-global transformations with rewrite rules is very complex and tightly coupled which imposes severe constraints on maintenance and evolvability. the four main coupling problems of the current-day implementations are presented and we indicate how these can be eliminated and reduced by our extension of the rewrite rule system. furthermore we show how complex invasive compositions can be solved by abstract, reusable algorithms and mechanisms, rendering the implementation of local-to-global transformations into a semi-automatic process.



the implementation of local-to-global transformations solely by means of rewrite rules is very complex and tangled. extensions of transformation systems to the rewrite rule paradigm with various data acquisition techniques like queries and tree traversals did not reduce the tangling. we found that, similar to other software development techniques, this tangling severely jeopardizes future maintenance and evolution.



in the following section, we investigate the fundamental problem that forces a developer to write tangled rewrite rules. section 3 introduces our solution architecture, which explains the architecture in more detail. in section 4 the architecture is evaluated and the implications of the approach are discussed. the related work is discussed in section 5 and the paper concludes in section 6.



in various software development methodologies one of the most common approaches to facilitate evolution and maintenance is by minimizing the tangling and coupling within an implementation. by doing so, the components of an implementation can be more easily replaced by another one and can be reused in other implementations. since the implementation of a set of transformations can be regarded as a normal software artifact, the reduction of the tangling and coupling hold the same premises. in the reminder of this section the coupling and tangling issues of the workaround strategy are discussed.



the first problem is the tight coupling of the secondary traversals and rewrite rules and the outcome of the primary rewrite rules. consider the secondary traversals and rewrite rules to collect and move the non-locals of the inputfield transformation: the two non-local statements(an assignment(line 12) and two method calls(lines 13 and 15)) of the topmost cons cell(line 10). these two nonlocals must be moved to the enclosing method node. writing such a traversal heavily depends on the context node(line 9) produced by the page transformation and the non-locals of the inputfield transformation(line 12-15), in order to make sure that the correct non-locals are matched. like the traversals, the left hand side, the triggering condition and the right hand of the secondary rewrite rule that integrates the nonlocal on the correct location, is also expressed in terms of target nodes, which results in the same deficiencies.



the second problem is the scheduling problems of the secondary traversals and rewrite rules in order not to violate the context conditions of other secondary traversals and rewrite rules. let us take a look at the scheduling of the secondary traversal and rewrite rule of the inputfield transformation and those of the default value transformation and the key transformation. the latter handle the non-locals in the nested cons cells of the cons cell(line 10, produced by the inputfield transformation). the correct location of the non-local statement(line 22) produced by the key transformation is in the beginning of the main method. however, depending on the strategy to deal with the cons cells the non-locals might end up in different locations. a breadth-first(topdown) strategy, places the non-local statement(line 22) inside its enclosing method defvalue. but a depth-first(bottom-up) strategy to deal with cons



to distinguish the non-local target nodes from the local target nodes in the rewrite rule, the non-local nodes are attached to a special nonlocals(...) node, which is in turn, together with the local target nodes, part of a cons cell. the example code below shows how the key transformation can be written as a normal rewrite rule.



a crucial part of the system and difference between the workaround is that non-locals can carry any kind of information. this is heavily exploited by the semi-automatic composition system to identify the non-locals and to guide the integration process of the non-local(see section 3.3.2). to ease and standardize the identification of the nonlocal, nonlocals always have at least a name or an identifier. in contrast to the common approaches dealing with names and identifiers, these need not to be unique within a rewrite rule nor amongst other rewrite rules. the advantage of this naming schema is that the name or identifiers can be used as a grouping mechanism, abstracting the actual number of nonlocals. the additional information can be used to select subgroups adhering to certain criteria. in the above example, the name of the first nonlocal is datamember, and the second nonlocal is initialize. no other additional information is provided, since their names suffice to distinguish between both of them.



the relocation step is executed after the execution of all modular rewrite rules. in this step, the non-local target ast nodes are moved to their correct location in the target ast. the correct location for the non-local ast nodes is determined by(1) the grammar of the target language and(2) custom semantics which is specific for the desired target program. the relocation for non-locals, which correct location is based the grammar of the target language, is now driven by the target language grammar and can even be automated. the relocation for non-locals, which correct location is based on custom semantics, needs to be written manually.



automatic relocation only works in cases where the location of the nonlocals can be determined unambiguously or in cases when there is a simple satisfying strategy to disambiguate. in case of domain specific languages(dsls) automatic relocation is very well suited. dsls bear a lot of language constructs that may only be used in a certain context, so disambiguation is not often needed. the technique is also useful for target languages which are general purpose languages. classes, datamembers, methods and statements are typical language constructs that are only allowed in a specific context. if the location of other language constructs like expressions and statements cannot be unambiguously determined but the nearest possible location is often the desired one. however, automatic resolution fails for most types of non-locals in languages, like for example html, where most language constructs may be used in every other language construct. for these languages custom relocation must be used.



the parts enclosed in underscores are merely place holders for the values they denote. the non-local node produced by a certain source ast node is referred to by its name and the source ast node. it is rewritten into a non-local with a custom relocation path.



the above rule will substitute the initialize non-local node(denoted by nonlocal(initialize, node)) produced by transforming the key source ast node, into a non-local with the specification path attached to it. the path//wizard points to the main method target ast node obtained by transforming the source ast ancestor wizard. the language to express the path is xpath.



integration ensures that the non-locals are correctly integrated in the subtree pointed to by the relocation path according to the semantics of a particular integration and to particular language constraints. for example, the integration of the non-local statements, produced by the inputfield transformation, into the main method body must obey the user-defined order of the different statements(first creation of all inputfields, followed by the attachment of listeners and finally their initialization with default values). another example is the integration of the non-local datamember, produced by the same transformation, into the main class, which must enforce the uniqueness constraint of the datamembers within a class.



integration is a close interplay of three different policies: integration, correspondence and combination. the integration policy is called for each non-local that was relocated to an ast node. its task is to integrate the non-local in the ast node itself or in one of its children. the correspondence policy is used by the integration policy to check if nodes in the ast need to be combined with the non-local. the correspondence policy is more like a predicate defined on nodes to check if they correspond. the combination policy performs the combination between nodes.



naturally, custom integration rules can be provided as well. the integration for the non-local statements produced by the inputfield transformation must regroup the statements so that firstly all the inputfields are created, secondly the listeners are installed and finally the inputfields are initialized with a default value. we will exploit the openness of our system, in particular the fact that each non-local can carry an arbitrary amount of information to guide the integration process(see 3.1). by attaching to each non-local statement an identifier, we can easily group during integration the statements. the order of the groups can be specified by additional information which can be interpreted by the integration rule.



below the two rewrite rules that implement this integration rule are shown. the non-local node node is annotated with the group(name) to which it belongs, and a triplet specifying its integration. the integration contains besides the name of the integration rule(group) also the name of the group of statements(name2) that must come before it. the first rule inserts the non-local node into the list of statements(stats) before the first statement belonging to the same group(name) as the non-local does. when there is no such statement, the second rule inserts the non-local right after the last statement of the group of statements that must come before it.



combination rules are declarative specifications that combine two ast nodes together in one node. they are implemented with rewrite rules that operate on a combination node. like the correspond node, a combination node contains three parts: a name, and the two nodes that need to be combined. the first node is the non-local node and the second node is the node that is part of the ast. the result of a combination is a new node.



the above rule simply concatenates the method bodies without taking possible variable declaration clashes into account, or differences in the parameter names of the methods. the later can be amended by proper reconciliation of the deviating method body. the former can be amended by extending the rule with a simple traversal and a condition(rule shown below). to avoid duplicate variable declarations within the scope of the merged methods, the intersection of the variable declarations of the two methods must be empty(line 3). calculating the set of variable declarations is done by a top-down traversal of the bodies of the two methods where each variable declaration is collected a set(line 1). the traversal breaks when other nodes are encountered(line 2) to prohibit traversing into inner-scopes.



the correspondence check facilitates many necessary and interesting mechanisms. the two most important mechanisms are the combination of partial results and the enforcement of uniqueness constraints. by establishing a correspondence between the two partial main methods, these got combined together into a complete method during the integration. by establishing a correspondence among datamembers nodes(section 3.3.3), we were able to enforce that datamembers within a class must be unique.



the process of handling non-locals is divided into a number of separated modules: the generation, the automatic relocation, the custom relocation, and the three integration, combination and correspondence rules. each part addresses a tangible and separated concern of the implementation and captures its intention in a clear declarative way. we can thus conclude that the first coupling(section 2.3) between the mechanisms to implement local-to-global transformations and a particular implementation for a transformation, has been eliminated. the other couplings mentioned in the beginning of the paper have been adressed and discussed in the previous sections 3.2.3, 3.3.5.



the decoupling and disentangling of the implementation relies on the correct use of names and the extra information attached to the nonlocals. the names themselves do not contain any semantics. hence it is up to the user to properly use the names to guide himself in the implementation of the local-toglobal transformations. a specification language to express these semantics would be more solid.



by reducing and eliminating the coupling in the implementation maintenance and evolution is facilitated. the impact of maintenance and future evolutions is limited to specific modules. changes to the source language have only an impact on the custom relocation. changes to the target language have only an impact on the three rules(integration, correspondence and combination rules) and on the automatic relocation. since the latter is an automated process based on the target language, the changes to the target language are automatically reflected in the automatic relocation. finally changes to the transformations of the source language to the target language are localized to and affects only the implementation parts of that transformation i.e. generation, relocation and integration. during generation the rewrite rule may produce all the results(both local and non-local) that are derivable from the source node under transformation without taking other transformations into account. if custom relocation was necessary, attaching the relocation path and the path itself is only dependent on the fact that one transformation produces a result with a particular name, instead of all the transformations. the integration rules are solely defined on top of the target language nodes which yield them also independent of the other transformations.



there are a couple of limitations of our approach. first, the automatic relocation process is limited to the grammar of the target language. using more information about the semantics of the target programming language could improve the system. second, the integration process is incremental. this incrementability increases the complexity of the integration rules. a full discussion of these issues can be found in.



the validation of our approach is based on early experiments including the implementation of the compiler for the wiz language used in this paper. we are currently involved in several experiments to validate our technique: the development of a dsl for quizzes with the flemish broadcasting company, the development of a open set of language components for a family of dsls to describe advanced transaction models, and the development of modular language features for developing ejb specifications. to implement these languages local-to-global transformations and other invasive composition mechanisms are needed. these languages will be used as a case study and serve as an empirical validation for our approach. the mechanisms proposed in this paper were implemented on top of the linglet transformation system(lts)(previously known as the keyword based programming toolkit). the modularity of the system immediately acted as additional validation mechanism, testing whether the implementation of our semi-automatic mechanism obeyed this. since modularity reduces the dependencies, this modularity is a key enabler for a better maintainable and evolvable language implementation.



in the survey of jonne van wijngaarden et. al. current day transformation systems are compared and classified according to three transformation mechanics i.e. scope, direction and stage. transformations with a wide target scope and a single node source scope are called local-to-global transformations. the survey explored whether the basic mechanisms like querying and traversing the parse tree are available in current day transformation systems in order to implement local-to-global transformations. in this paper we went a step further and investigated the repercussions of those mechanisms on the complexity, maintainability and evolvability of their implementations. we found that those mechanisms easily result into over-complex implementations and severely constrain maintainability and evolvability.



transformation systems, in particular rewrite rule systems, fail to deal with local-to-global transformations without corrupting maintainability and future evolvability. our solution architecture enables the use of modular and simple rewrite rules to implement local-to-global transformations hereby avoiding complex, tangled traversals and rewrite rules and scheduling problems. we identified four identified coupling problems in current-day implementations. all of these have been reduced and some have been eliminated by our approach. furthermore no other undesired couplings were introduced in the process. the impact of maintenance and future evolutions of one transformation to the implementation parts of that same transformation is localized and limited to specific modules. the relocation mechanism and the reusable integration, correspondence and combination rules across different implementations render the implementation of local-to-global transformation into a semi-automatic process, hence significantly reducing the implementation effort. this has a positive impact on the maintainability and future evolvability of the implementation.



