in we introduced the syntax and semantics for the core model and language. it has been incrementally enriched later. we focused on the dynamic aspects of composition: interaction compatibility in, on component protocols with service composition in. following this incremental approach, we consider in the current article an enrichment of the data and expressions in kmelia and its impact on the language syntax, its semantics and the verification of properties. our objective is twofold:



assertions are useful i) to define contracts 1 on services(with pre/post-conditions); contracts increase the confidence in assembly correctness(by constraining the pre/postconditions of the involved services) and enable rich query expression when searching for a component in libraries, ii) to ensure the consistency of components with respect to the invariant. the actions implement a functional part of the services which should then be proved to be consistent with the contracts. therefore the correctness verification aspects of the kmelia model is enhanced via the use of assertions.



services, consistent components and correct contract-based assemblies. first, the kmelia language is enriched with data and assertions so as to cover in an homogeneous way structural, dynamic and functional correctness with respect to assertions. second, we deal with state space visibility and access through different levels of nested components; in addition to service promotion we define variable promotions and the related access rules from component state in component compositions. last, feasibility of proving component correctness using the assertions is introduced. we show how structural correctness is verified and how the associated properties are expressed with the new data language.



the article is structured as follows. section 2 gives an overview of the kmelia abstract model and introduces its new features. in section 3 a working example is introduced to illustrate the use of data and assertions. the formal analysis is treated in section 4; we present various analysis to be performed, the ones that are currently implemented and we focus on component consistency and on checking assembly links. section 5 concludes the article and draws discussions and perspectives. this work is supported by the costo tool which is presented during the tool demo session of the conference; in the appendix a we give an extract of the kmelia syntax concerning the new data part. an overview of costo is given in appendix b.



the behaviour of a component relies on the behaviours of its services. a service describes a functionality and a behaviour using actions combined with a labelled transition system. a service is started when it is called(by a client service), it is then said to be activated and should evolve until it reaches its final state.



a service shares the state space of its component with other services of the same component. during its evolution a service s may call other services or communicate with them using messages. all the interacting services of s are defined in the interface of s. due to dependencies and interactions between services, the actions of several activated services interleave or synchronise, but only one action of an activated service may be observed at a time.



components are composed through their references by assembly links in component assemblies or by promotion links in composite components. a link is an abstract communication channel which connects two distinct services. a sublink is a link defined in the context of another link according to the service dependency structure(cal and sub).



a composite is a component that encapsulates assemblies or other components. some features(variables and services) of the nested sub-components can be promoted at the composite level. in a previous version, we defined promotion links to promote services with possible service renaming. promotion is extended here to state variables promotion and it permits pre-condition weakening and post-condition strengthening with respect to the state variable promotion. we current apply the same observability schema for assembly clients or composite clients except that observable variables can be promoted at the composite level.



manages product references(catalog) and product storage(stock). the main service models a vending process. the system administrators have specific rights, they can add or remove references under some business rules such as:"a new reference was not in the catalog" or"a removable reference must have an empty stock level".



data types in kmelia. the data types are explicitly defined in a types clause, in the shared libraries(predefined or user-defined). the following library(named stocklib) declares some specific types, functions and constants. the data types in this part are rather concrete; more abstract data types are in the process to be included in the predefined library.



a kmelia component and observable state. the listing 4 shows an extract of the kmelia specification of the stockmanager component. the state of stockmanager declares an observable variable catalog which will be available for a context mapping. two arrays( plabels and pstock) are used to store the current references labels and available quantities. the invariant is a set of named predicates[obs][@name]:<pred_expr>, where labels in front of the assertion are(optional) predicate names. the prefix obs means that the predicate belongs to invo. as example@borned states that the catalog has an upper bound;@referenced establishes that all references in the catalog have a label and a quantity;@notreferences expresses that the unknown references have no label and no quantity.



a kmelia service with its assertions. listing 5 shows the specification of newreference, one of the service provided by stockmanager. its pre-condition expresses that the catalog does not reach its maximal size. the prefix obs means that the predicate@resultrange belongs to posto. the observable post-conditions state that we may have a result ranging in 1..maxref or noreference; in the latter case the catalog remains unchanged. the non-observable post-condition(without the prefix obs) indicates how the non-observable state variables plabels and pstock would evolve.



the formal analysis of a kmelia specification consists in checking various kind of properties at the kmelia model. the verification goal is to detect the specification errors: the violation policy is postponed to implementation issues. some analysis are performed directly in the costo tool which supports kmelia, the others are delegated to appropriate external tools. in this section, we address those aspects



our approach consists in reusing existing proof tools such as the b tools and especially the atelier b 5 and rodin 6 frameworks. the main issue is to present the verification of the necessary kmelia elements in an appropriate manner to use efficiently the b provers. we design a systematic verification method that enables us to reuse the proof obligations generated by the b tools for our specific purpose.



we are currently developing a plugin(named kml2b) in the context of the costo tool. a first presentation of kml2b is available in. it extracts b specifications to enable the verification of invariant consistency rules(a, b, c) and to mechanise the proof for assembly link contract rules(d, e, f, g, h, i). in the following we present the systematic verification method and the manual experimentations done with rodin.



event-b and rodin frameworks. rodin is a framework made of several tools dedicated to the specification and proof of event-b models. event-b extends the classical b method with specific constructions and usage; it is used for the modelling of general purpose systems and for reasoning on them. proof obligations(pos) are generated to ensure the consistency of the considered model, i.e. the preservation of the invariant by the events. other pos ensure that a refined model is consistent, i.e. the abstract invariant is preserved and the refined events do not contradict their abstract counterparts. pos can be discharged automatically or interactively, using the rodin provers.



verifying kmelia specifications using event-b. the main idea is, first to consider a part of the kmelia specification involved in the property to be verified(a service, a component, a link of an assembly, an assembly, etc), then to build from this part of the specification, a set of(event-)b models in such a way that the pos generated for them correspond to the specific obligations we needed to check for the kmelia specification assertions. this approach was investigated before in[17,20] on the context of classical b and uml components.



we are not going to deal in this article with the details of the translation procedure and result 7. for short, kmelia invariant and pre-condition translations are quite systematic, whereas the post-condition concept does not exist in classical b. therefore we abstract the post-condition by using an any substitution that satisfies the post-condition(once translated) as proposed in the context of uml/ocl to b translations. in event-b, translations of the post-conditions are quite systematic. listing 8 depicts the event-b translation of the service newreference of the kmelia component stockmanager.



in this article we have presented enrichments to the kmelia abstract component model: a data language for kmelia expressions and predicates; visibility features for component state in the context of composite components; contracts in the composition of services. the formal specification and analysis of the model are revisited accordingly. the syntactic analysis of kmelia is effective in the costo tool that supports the kmelia model. we have proposed a method to perform the necessary assertion verification using b tools: the contracts are checked through preliminary experimentations using the rodin framework. we have illustrated the work with an example which is specified in kmelia, translated manually but systematically, and verified using rodin.



like sofa or wright, rather than to the concrete models like corba, ejb or.net. the java/a or archjava models do not allow the use of contracts. we have already emphasised(see section 1) the fact that most of the abstract models deal mainly with the dynamic part of components. some of them[18,27] take datatypes and contracts into account but not the dynamic aspects. some other ones[13,15] delay the data part to the implementation level.



basic types such as integer, boolean, char, string with their usual operators and semantics are permitted. abstract data types like record, enumeration, range, array and set are allowed in kmelia. user-defined record types are built over the above basic types. specific types and functions may be defined and imported from libraries.



,!=, or, and, implies, not,...). an assignment is made of a variable at the left hand side and an expression at the right hand side. in the following, each identifier class is denoted by a non-terminal symbol(c: constants, v: variables, o: operators, t: types). identifiers are symbols built on letters, digits and the"" character according to the usual rules. the third rules includes the function calls.



