the rest of the paper is organized as follows. in section 2 we discuss the concept and concept map language constructs. in section 3 we describe the concept map modularization problem to be addressed in the paper. section 4 discusses our solution for the problem, and the preprocessor implementing our approach. in



the logging part of this concept map contains several redundant lines of code. on one hand this leads to long function bodies in the concept map. on the other hand the actual original function calls(c.f() and c.g()) will be lost in the long code. it may be useful to trigger a separate helper function call at these points, however, there is no well situated place to put these functions. it is possible to put the helper functions into the global namespace, but if they are related only to the concept map this solution will be confusing and makes our code harder to understand.



the only compiler currently implementing concepts for c++ is conceptgcc. we are not intending to create a new concept compiler, rather to write a preprocessor transforming our code into valid conceptc++ code and still keeping our new structural advantages. the idea is to put the private and protected parts of the concept map to a unique namespace and put the namespace scope before the function calls in the public part. we have implemented a precompilerlike program to carry out this transformation. after the transformation we get the following code:



as seen in example 9 the concept map itself can be template. in this case the template argument may appear inside the helper functions. transforming this kind of concept maps is not so simple as it was in the previous example. when the helper function definition is moved from the body of the concept map to the unique namespace, the template arguments of the concept map became unknown types. thus it is necessary to transform these helper functions to template functions with the same template arguments as the concept map. it is necessary to instantiate these helper functions explicitly in the public part of the concept map, because the template arguments may not be part of the function parameter list. in the following example we create a new concept map(which contains helper functions) to concept stack defined in example 9.



the concept map is not a template the helper function can be defined in a separate file. it is necessary to put the outside definition into the same namespace as the concept map. in the following example we implement the logger functions outside the concept map.



