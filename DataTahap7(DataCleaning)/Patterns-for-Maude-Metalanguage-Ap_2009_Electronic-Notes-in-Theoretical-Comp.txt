one of the most effective ways of improving the quality of software engineering, system design and development, and communication between the people concerned with these problems, is provided by software patterns. in this paper we present a set of basic patterns for maude metalanguage applications. we show the viability of the defined patterns by comparing them to the developing approaches for several well-known maude tools.



there is already a significant number of metalanguage applications in maude. some of them are written by people with maude programming experience; their applications have a high performance and a good quality design which make them reusable for other software engineers. an application written by someone less familiar with maude has a low degree of re-usability. the success of the learning process by a new maude user strongly depends on the kinds of examples he/she studies. we think that maude has reached a certain maturity level when the best practices should be accessible to a large class of users. this goal can be reached by the means of a good software engineering problem-solving discipline. such a discipline is given by patterns. the general goal of the patterns is to support design and development. the contribution of this paper is the definition of a set of basic patterns which may be used in a wide range of maude metalanguage applications. the design of these patterns is based on the experience acquired by the authors during the development of some applications[10,2] or by studying other applications like those presented in[11,8,7]. the referred applications are: the inductive theorem prover(itp), the maude termination tool(mtt), the church-rosser checker(crc)



the idea of defining patterns for maude metalanguage applications came when we started to develop a new implementation of membrane systems using strategy controllers. the design of the new application is based on adapting some technologies used by other applications and on the maude strategy language. during the adaptation process we had to answer some standard questions like which part is application dependent and which one is independent. we realized that these questions can be avoided if we follow a problem solving discipline. that was the moment when we started thinking about patterns. the current version of the maude strategy language includes good design practices which inspired us in defining the patterns presented in this paper. actually defining the patterns did not prove to be an easy task. we needed to answer many difficult questions: how should a pattern be structured, which pattern should a certain development activity be associated to, which activities are repetitive and which ones need not be performed more than once during the development of a system, how are the patterns related to each other, how should a system implementation process be formalized.



patterns were first introduced by christopher alexander and used in urban design and building architecture. patterns provide a common language that people use in order to formulate problems and to solve them. briefly, a pattern describes a design problem, a context in which the problem occurs and the core of a solution to that problem. the same solution sketch can be used by different people in order to solve their own particular problems and speed up the development process.



the current system state can be changed or interrogated by using commands from scl. the execution of a command is guided by the system specification language semantics and depends on the current system state and the provided parameters. each command cmd is associated an operation proccmd that denotes its semantics.



we assume that all these operations are included or defined in the previously mentioned system-lang-semantics module. this module can also be thought of as an api of the system. it is used by the user interface pattern but can as well be used by other applications. for instance, the semantics for membranes is given by using the api of the maude strategy language.



context. maude uses the loop mode(see, section 17.1) to design user interfaces. the loop mode works with triples[input:qidlist, state:state, output:qidlist], also called loop objects. these triples are provided by the loop-mode maude module. the input argument is the text introduced by the user(if any), the output argument is the text displayed by the system(if any) and the state argument is the(current) system state.



if avoiding the definition of the system grammar from scratch is desired, the existing full maude grammar can be used. by doing this, the created system will be able to handle anything the full maude system can. this is accomplished by appending system-lang-sign to the provided grammar module. the addimports metalevel appending operator is defined within the unit module and grammar is defined at metalevel within the meta-full-maude-sign module.



here, the full maude-specific database constant is used to instantiate the state class databaseclass. the inherited attribute db contains detailed information regarding full maude loaded units. our attribute defaultposet receives the constant value nullheader, denoting that in the initial state no module is selected to describe a partial order relation.



the mtt, crc, rtm and str tools define the grammar module within a meta-system-lang-sign-like module. mtt, crc, rtm and str extend the full maude grammar while itp defines its own grammar from scratch. str defines a second grammar from scratch for internal use.



rtm and str define new attributes for the system state in the manner described by the pattern. the attributes are defined in a system-state-handlinglike module. the itp tool defines attributes using an internal defined sort, other than attribute. all the tools define the[init],[in] and[out] rules in a system-interface-like module.



system-cmd-lang-sign. this module is used for command declarations. for each command a new operator defining its signature must be added. if, for instance, the form of the command is resword param1 param2., the operator defining its signature is:



in most cases, commands receive basic identifiers or lists of basic identifiers as parameters, meaning that@paramx@ is either@token@ or@bubble@, respectively. commands are operators of the predefined@command@ sort. the declaration of this sort is found in the full maude-specific commands module.



in one or more dedicated*-sign-like modules, mtt, crc, rtm and str define commands. they all use the provided@command@ sort in order to declare commands. rtm and str define unit input-like signature, the former using the provided@module@ sort and the latter using an internal defined sort. str does not define a system-sorts-like module because it defines the external unit corresponding sorts within the system-lang-sign-like module.



solution. each top or partial input must be handled by its own parsing operator. besides these operators, a set of rules which transfer the input to the corresponding top unit parsing operator must be implemented. this is achieved by defining a parsing-dedicated module and writing extra code for the previously defined system-state-handling module(see section 4.1):



known uses. the maude tool which follows most of the steps described by this pattern is str. it creates parsing rules for the unit-like input within the system state handling module. the operators dedicated to unit parsing are also declared in this module(no system-lang-parser is created). the other tool defining internal units(rtm) uses some parsing operators provided by full maude.



as stated in section 4.1, one of the predefined attributes of the system state structure is the input attribute. its value is the metarepresentation of the current user input. at initialization, this attribute receives the niltermlist value. the system can only receive input when the input attribute has this value(check the[in] rule from section 4.1 for details).



solution. for a unit parsing rule[parsetopmetavar], a dual rule able to handle the error is created:[parsetopmetavar-error]. the new rule fires only when[parsetopmetavar] cannot be applied because of an input error. the error handling rule must stabilize the system and print an error message to the output.



let us consider the parsing rule needed to call the parsetopmetavar operation. as stated in section 4.1, metaparse can be regarded as the basic metalevel parsing operation. therefore parsetopmetavar either calls this operation itself or some of its suboperators must do so. the metaparse operator fails when the returned value is not of sort resultpair, but of sort resultpair?. this is why a parsing operator that makes a direct call to metaparse must check its returned value and if a basic parsing failure occurs, an error must be generated.



the error handling rule[parsetopmetavar-error] modifies the system state by operating only on the input and output attributes. the rule checks if the value returned by parsetopmetavar is errortopmetavar(error message). if that is the case, then the input attribute receives the niltermlist value(in order to stabilize the system) and the ql error message is transferred to the output attribute of the current state(for feedback).



crc and rtm use the error handling operators provided by full maude. the operators are used internally in the same manner described in this pattern. srt fully applies this pattern. the tool implements parsing rules able to detect errors. they make use of error handling operators for each top and partial input.



all the tools check if the user input corresponds with the system grammar. for crc the check is made directly by the initial[in] rule. mtt and str make this check in the same way described in the pattern. itp and rtm add two new error checking rulesone for syntax errors and the other for ambiguous input(when the input can be parsed in more ways).



maude metalanguage applications can be developed by using an iterative strategy. the idea is to build the base version of the system to be implemented and then, at each iteration to add new capabilities to that system. every time an iteration is performed, the enriched system has to be tested for errors.



