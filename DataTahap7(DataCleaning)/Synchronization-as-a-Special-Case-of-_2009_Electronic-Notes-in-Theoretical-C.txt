methods declared as async are executed in new threads as in polyphonic c#. an invocation of produce_consume creates a buffer and two threads concurrently accessing the buffer. the compiler associates b first with empty:true specified in the constructor of simplebuffer and then replaces this token with the less informative tokens empty:true?false and empty:false?true needed in produce and consume(see section 3). arrows in the annotations of the formal parameters p and c indicate that the tokens move from the actual parameter b to p and c and never come back to



programmers think in terms of accessibility at a high level instead of low-level synchronization. compilers ensure synchronization with properties like race-freeness and(to some extent) continuity. concurrency need not dominate the program structure, and we can concentrate on other important programming principles.



interfaces specify accessibility. clients need this information to avoid access and synchronization conflicts. since we specify in interfaces only necessary information we keep the black-box view of objects and can take advantage of data hiding: changes of implementation details do not affect clients.



tokens move between references also on assignment. when executing x= y; the tokens associated with x before assignment get lost. the tokens associated with y are divided into two parts as needed in further computations; x becomes associated with one part, and y remains to be associated with the other part. the compiler can always determine at compile time(for each class separately) how to divide the tokens using techniques similar to those proposed in.



clients invoking put in an instance of buffer usually own only a non-exclusive token size:0..(max-1)?1..max, and those invoking get own size:1..max?0..(max-1). in this case clients have no static knowledge of size, and when acquiring locks the threads must wait for appropriate values of size.



simple mutex synchronization on x occurs in all other cases of synchronization on x. the execution neither depends on variable assignments in other threads nor wakes up other threads because of variable assignments. for example, we have simple mutex synchronization on i when using an instance of counter. simple mutex synchronization is a property of the access constraints of all methods in a class and does not depend on the context of an invocation.



sometimes b has to be annotated with size:0..(max-1), and sometimes with size:1..max(where max= 1) depending on the value of e. in larger examples there can be many more conditional annotations of the same variable, and explicit annotations with all possibilities would be a large burden for programmers.



5 in this article we take a rather conventional view of synchronization based on locking. when using techniques like memory transactions we can relax this condition to get more concurrency. the use of such techniques in our approach especially for simple mutex synchronization is important future work. we do not discuss this topic here because the focus is on dependent synchronization.



direct accesses literally occur in the code of the method. accesses within other methods invoked by the method in question do not count. formal parameters, local variables, and constants(these are variables declared as final) need not be considered because they are not shared or not modifiable. instance variables in constructors are not considered because we preclude concurrency during object creation.



programmers must provide access constraints on methods as well as annotations of formal parameters and results. this information must be considered in(behavioral) subtyping because it has major influence on object behavior. we consider annotations of formal parameters and method results to belong to corresponding types. on such annotated types we use the following subtyping rules:



unfortunately, access constraints and synchronization in subtypes cannot be more restrictive than in supertypes(except for simple mutex synchronization) according to the principle of substitutability. programmers usually want to have it the other way around. therefore, the more flexible solution for simple mutex synchronization(which probably occurs more often than dependent synchronization) can be quite helpful in many situations. it allows programmers to introduce synchronization in derived classes even if there is no synchronization in base classes.



systems) it is actually possible to get static guarantees. however, they come at very high costs. we must accept restrictive design rules and inflexible tools, need experienced and expensive experts who put much effort into low-level programming and program analysis, and get long development times.



method invocations using t1 and t2(as above) do not block each other because of nonterminating computations. the execution of each method invoked using these tokens must terminate in finite(and for practical reasons short) time. programmers have to ensure that there are no infinite loops in such method executions.



concurrency. the invocations shall occur in different threads. the compiler shall warn if two different?-tokens of the same variable name occur in the same method. because of insufficient aliasing information there will be false positives, that is, the variables in the tokens can belonging to different objects. furthermore, in some cases it is useful for t1 and t2 to temporarily occur in the same method, for example in an initialization phase while starting concurrent threads.



without warning there can be no deadlock because all locks must be acquired in a specific order; there can be no cycles. however, the compiler will find false positives(as above), and complete avoidance of cycles is a very restrictive property. sometimes developers prefer possible(but unlikely) deadlocks over very expensive program refactoring to avoid cycles.



in the proposed approach, concurrency is based on rather conventional threads, locks, and values of shared variables. in this respect there are many similarities with the scoop model of concurrency. both, the scoop model and our model, disclose information on the variables used for synchronization. however, the way how and the time when such information becomes available to clients is different: every client can get access to such variables at runtime in the scoop model while access control in our model causes much information to be available at compilation time and usually only few clients actually access the variables at runtime. the access control mechanism adds a further dimension to concurrent programming and reduces the importance of synchronization at the presence of static information.



many proposals ensure race-free programs[4,8,15]. some approaches depend on explicit type annotations while others perform type inference. such techniques can lead to more locks because no approach accurately decides between necessary and unnecessary locks. program optimization can remove some unnecessary locks[9,34]. unfortunately, we usually must analyze complete programs for good results.



there is also much work on deadlock prevention[1,15,19]. a major problem of all such proposals is that static deadlock prevention considerably affects the flexibility of the language. the approach proposed in the present work is no exception. therefore, we argue that a potential deadlock found by a compiler is no more than just a hint for the programmer to have a closer look into the code.



concurrency to be independent of the object model. a concept similar to the one expressing synchronization in the actor-like language became more useful as an access control mechanism, and a new concept for synchronization was needed. there are several approaches related to process types. especially linear types



several programming languages[5,14,25] were developed based on the join calculus. for example, in polyphonic c# we combine methods that must be executed simultaneously to a chord which is executed as a single unit. clients can see how methods in a chord are synchronized. since only one method in a chord is executed synchronously and all other methods are asynchronous, only specific forms of synchronization are supported. communication in polyphonic c# and similar languages resembles that of the rendezvous concept in ada. there is no way to constrain method invocations as with our token concept, and there is no obvious way to use chords in controlling aliasing.



in previous work the author often used dependent types(these are types depending on values) to increase the flexibility of the system. in the present work we avoid dependent types as much as possible because they are difficult to deal with. we get the necessary flexibility by dynamically changing tokens based on results of dynamic type queries(instanceof).



the present work is in an early stage. there exist only fragments of a prototype implementation, and a rigorous practical evaluation of the proposed approach has not yet been carried out. an evaluation is important future work. in further future work we want to address(among others) the following topics:



synchronization and access control ensuring exclusive access to shared variables fit together quite naturally. we explored an approach to integrate synchronization into a static access control mechanism based on tokens giving information about exclusive access to variables and supposed types of their values. it is possible and beneficial to annotate methods with access constraints not distinguishing between static access control and dynamic synchronization. clients decide if they prefer access control or synchronization. object interfaces provide all the information that clients need to avoid conflicts of dependent synchronization, and simple mutex synchronization can be regarded as an implementation detail. static type checking guarantees exclusive write-access and consistent read-access to shared variables and thereby ensures race-free synchronization. we get flexibility by using dynamic type information in tokens. the approach supports subtyping and ensures to some extent continuous operation of the system.



