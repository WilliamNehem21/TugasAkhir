semantics syntax. in addition to it, the tool combines the modularity aspects observed in the object-oriented approach with the efficient execution and analysis of the maude system. we use mooat to describe syntaxindependent specifications of programming languages. in this way, we show how constructive objectoriented action semantics(cooas) may be achieved as a combination between object-oriented action semantics and constructive action semantics(cas) using mooat, in order to increase the modularity characteristics of both denotational semantics and operational semantics. in action semantics, semantic functions specify the meaning of the phrases of a language using actions. these actions represent the denotation of the phrases. the action notation is defined operationally and contains basic actions and action combinators. altough action semantics inherently presents good reusability, the standard action notation lacks of syntactic support for the definition of libraries and reusable components. in order to overcome this problem, a modular approach for action semantics has been proposed in, where action semantics modules allow isolated specifications elements viewing and modules composition. in this way reusability



this work is organized as follows: the next section briefly introduces maude msos tool. section 3 gives an overview of object-oriented action semantics. constructive action semantics is summarized in section 4. mooat notation and implementation are explained in section 5. in section 6 we discuss how constructive



the syntax adopted by mmt is based on the modular sos definition formalism(msdf) created by mosses to be used in msos specifications. both languages are fairly similar, in this way, those that use msos probably would easily understand a msos specification in mmt. nonetheless, small differences exist between them due to peculiarities in the maude parser[5,6].



command is the abstract class. the syntax section introduces the syntactic tree cmd. the semantics section introduces the semantic function execute, establishing a mapping from commands to actions. in ooas, semantic functions are seen as methods. now, every particular command behavior should be defined. the tactic is to define any specific command as a specialized class, as follows:



notice that while is a subclass of command. reusability can be achieved employing object-orientation concepts. the extending directive states a particular command behavior(iteration). the using directive allows us to reuse existing classes(as e:expression and c:command). in the semantics section, while is specified, as a plain action semantics action.



ooas has shown to be a practical alternative to modularity. ooas notation is simple, inspired by the notions from object-oriented programming and similar to the original action notation. instantiation and extension permit the construction of libraries of programming languages concepts, improving reusability. in fact, ooas notation is a mixture of the original action notation with the class notation created by the object-based approach. ooas semantics has been specified by sos rules and it has been reported in.



in ooas, the semantics description of a given programming language is a hierarchy of classes. in this regard, all defined classes belong to a pre-defined root class called state. such class is the base-class for all ooas classes and it is responsible to implement the attributes and operations that are used in those classes specifications.



in other words, the classes defined in the object-oriented formalism are subclasses of state, turning visible both attributes and operations to its sub-classes. the state attributes are concerned with the information processed by actions, such as: transients, bindings and storage. some operations are available to handle state attributes. such operations are all basic actions and action combinators.



a complete ooas description as well as its sos specification can be found in. in addition to it, an ooas library of classes has been proposed in[1,12], intensely using this method. in the following section we introduce constructive action semantics. a constructive approach concerned with reusability and focused on the formal specification of programming languages syntax independently.



it is common to find semantically similar constructors in programming languages, even if these constructors have very different syntax. in this regard, it is interesting to reuse parts of the programming languages specifications that represent the same behavior. the constructive approach introduced in helps with the code reuse by supporting independent definitions and using named modules to describe individual languages features.



constructive action semantics[10,18] is based on the idea that each language feature is defined by a separate and independent basic abstract construct. the semantics of a complete language is achieved by translating its constructs into the basic abstract constructs. that is, the main idea of this approach consists in mapping concrete language constructs to combinations of basic abstract constructs.



constructs might be considered as basic or derived due to the several constructs present in the developed programming languages. basic constructs represent common features that have the same interpretations and are found in many programming languages. the constructs that have a specific behavior regarding the programming language are classified as derived constructs, they are included in few languages and specified by combining basic constructs.



in the module cmd/while we have a derived module from cmd module. notice that the individual basic abstract construct cond-loop(exp, cmd) was used to specify the semantics of a while-loop command with a boolean condition independently of its syntax. in this way, such a module could be used in any project that needs a while-loop. the specification of a whole language in constructive action semantics is achieved by combining modules that implement the necessary basic individual constructs into a single module.



we have introduced the constructive approach proposed in, focused on its usage with action semantics. however, it also can be used with modular sos. the concrete constructs of core ml have been translated to basic constructs as a constructive action semantics case study in and the formalism has been successfully validated to describe programming languages semantics syntax independently. motivated by these results, in section 6 we will present how constructive semantics can be applied to object-oriented action semantics using the tool described in next section.



a formal specification in object-oriented action semantics is a finite set of classes. such classes create the necessary hierarchy to represent the formal specification of a language or library. the relationship among these classes is defined according to the instantiated objects, as well as the position where classes are found in the specified hierarchy.



the class structure is defined in the rules(1) to(3). a class begins with the directive class and ends with endclass. the body class is composed basically by the declaration of base classes and by the class definition. notice that more than one class can be specified as a base class.



if the tool notation is compared to the ooas notation introduced in, some differences might be found. amongst which we point out the changing of extending to extends and the exclusion of the directive using. the former was done for the reason that the directive extending already exists in maude and if we redefined it we would have the pre-regularity problem discussed in. the latter was done for the fact that now object declarations are done automatically in the methods definition.



an abstract method works as a signature of a method that will be specified in a class or in a sub-class and may result in an action or in a data sort. a method implements the semantics of a programming language concept using actions and action combinators. methods must be used to give the semantics of the abstract syntax defined in the class. when such abstract syntax is used in the method declaration, syntactic sorts must be changed by object declarations.



the while class is the sub-class of cmd and a while-loop is implemented in it. the syntactic sort cmd is overloaded with the command syntax and the semantics is given in the overloaded method execute. the objects e:exp and c:cmd were used to give the while semantics, that is, the command in the object c:cmd is executed until the expression in the object e:exp is true.



notice that, previously an object was declared by an identifier and its respective class in the directive using. however, now it is directly declared by an identifier and its respective syntactic sort in the method definition. in this way we have introduced the automatic object creation concept.



data notation has been specified by reusing datatypes that are provided by both maude and mmt. for instance, the sorts int and boolean defined by mmt were used to represent integers and truth-values respectively. however, some coercion functions were needed to avoid the ad-hoc overloading problem in these datatypes specification. it can be observed in the rule(15) in section 5.1.



notice that the msdf modules basicoutcomes and functionaldata were included in functionaloutcomes. in such module the terminated sort is redefined to accept the values introduced by the sort completed, which are: completed, to determine that an action is completed, and gave(data), to specify a transient data production. when no data is given then the action is simply completed.



in the cmd/while class we have a specialized class of cmd that implements the construct of a while-loop, cmd-while(exp, cmd). notice that the main difference between object-oriented action semantics and constructive object-oriented action semantics is in overloading the syntactic sort with a basic abstract construct instead of using the language concrete construct. this basic abstract construct is also used when the method execute is overloaded in order to give its semantics.



for expressions constructs we have exp class and its respective sub-classes that deal with arithmetical and logical values and expressions. as well as in the examples mentioned in this section, the class cmd and its sub-classes are related to commands constructs. the class dec introduces declarations constructs which will be used in its specialized classes of declarations. a class to specify a program construct was also implemented and it was called prog.



in this paper we have presented mooat, the first implementation of objectoriented action semantics. our first idea consisted on developing an isolated ooas tool from scratch. however, it seemed impracticable knowing the existence of mat. the better choice, in our view, was creating an extension of mmt. the idea was to aggregate the object-oriented apparatus to a brand new tool based on mat and developed using mmt. in mooat, the user can create ooas specifications, and perform the necessary tests, inside the standard maude environment. this is interesting, considering that the user can create maude, mmt, and mooat specifications using the same tool.



this implementation has contributed to the formal specification of ooas since a modular sos definition has been provided to its action notation using mmt and the maude system has been used to define its classes notation. it means that the previous specification of ooas using sos has been rewritten using msos and implemented using the msos language provided by mmt. also, that a language to specify ooas classes has been built in maude.



moreover, the introduction of constructs in ooas has contributed to improve the modularity aspects observed in the object-oriented approach. since such combination is capable to describe syntax-independent specifications of programming languages. this happens due to the fact that we see the constructive approach as an idea that helps with code reuse when adopted into existent formalisms, as well as it happened with msos, as and now ooas. notice that cooas has been shown using mooat though it could be used as a specification approach independently of the tool usage.



we would like to thank mmt authors, christiano braga and fabricio chalub, for the interest in this work and for the helpful support while we were using their tool to develop mooat. also, we would like to thank the anonymous referees for the comments that helped to improve this paper. we are most greatful with lsfa 2007 organizers for funding the presentation of this research at such nice event.



