we argue that a realistic model for quantum computations should be general with respect to measurements, and complete with respect to the information flow between the quantum and classical worlds. we discuss two alternative models for general and complete quantum computations based on probability distributions of quantum state vectors and on density matrices with classical outputs. we show that both models can be structured using a generalization of monads called arrows.



in recent work we established that a general model of quantum computing(including measurements), based on density matrices and superoperators, is an instance of a generalization of monads called arrows. that work is strictly based on quantum data(any classical value must be represented as quantum). the model cannot express the passage of information between the classical and quantum worlds.



the paper is organised as follows. in section 2 we introduce indexed monads and indexed arrows in the context of haskell. section 3 briefly reviews our previous work on modelling superoperators as arrows. we then show two alternative general and complete models for combined quantum and classical computations structured as indexed arrows in section 4. section 5 concludes.



since the work of moggi, several natural notions of computational effects were discovered which could only be expressed as generalisations of monads. of particular importance to us is the generalisation of monads known as arrows which is also internalised in the programming language haskell. in this section, we briefly discuss a small variation of these notions in the context of the programming language haskell, which we call indexed monads and indexed arrows. those are the right notions needed to structure quantum computations.



a monad is used for formulating definitions and structuring notions of computations(possibly non-functional) in programming languages. in this context, a program, which features notions of computations, can be viewed as a function from values to computations. for instance a program with exceptions can be viewed as a function that takes a value and returns a computation that may succeed or may fail.



however, sometimes we want to select some objects(sets) from to apply the constructor t. this notion is slightly more general than monads, and it is captured by the definition of kleisli structure. basically, for indexed monads(as we prefer to call kleisli structures), the function t does not need be an endofunctor on c. we can select some objects from c to apply the constructor. this is exactly the return just lifts values to vectors, and bind, given a unitary operator(i.e., unitary operator) represented as a function a vec b, and given a vec a, returns a vec b(that is, it specifies how a vec a can be turned in a vec b).



can elegantly express quantum computations involving measurements. however, that work is strictly based on quantum data, we can not express algorithms with combined interactions of quantum and classical operations directly. yet as noted in[4,12] a complete model for expressing quantum algorithms should accommodate both measurements and combined interactions of quantum and classical data.



based on the idea that fully expressible languages/models for quantum computation are supposed to include more than one final measurement operation, that is, they should accommodate both measurements and combined interactions of quantum and classical data, in this section we structure two alternative general(involving measurements) and complete(involving both quantum and classical data) approaches for combined quantum and classical computations as indexed arrows. the first one is based on a measurement approach for quantum programs. basically, at each step(a part) of the density operator representing the global quantum state is measured, a perspective on the classical measurement results is returned, and the state is left in a new density operator. the second one is based on probability distributions over quantum state vectors. attached to each vector in the distribution there is a list of classical valuesthe eigenvalues which are the output of performed measurements.



we present a model for quantum computations based on a measurement approach. the idea is to have a density operator representing the global quantum state, and a probability distribution of classical values representing the classical part of the state. a quantum program acting on this state is interpreted by a special tracing superoperator, which in the general case traces out part of the state, returning a classical output, and leaving the system in a new state(possibly in a space with reduced dimension).



the function uni2qprog constructs a quantum program, acting on a combined state, from a unitary operator. the idea is to apply the default construction to build a superoperator from a unitary transformation. note that the classical input is ignored and the classical output is empty: there is no interaction with the classical world when considering unitary transformations. for instance:



similarly, the program tra forgets(measures) all quantum state returning only a classical probability distribution as the result. to construe the classical probability distribution we consider that any value from the type being measured can appear in the output quantum state. hence each value from the basis is attached to the probability 1. the real probability to appear in the final state is calculated by the function app below, which given a program and a combined state calculates the new density matrix and the classical result(if there is some).



the output density matrix is calculated by simple matrix multiplication: the superoperator matrix by the input density matrix. note that the overall operation may depend of the classical state. the probability distribution of classical values is calculated by the multiplication of the probability of the observable value in the operator by the probability of the respective observable value in the input density matrix. also we take into account the output density matrix in the calculation as it may be the case that a unitary operation is applied before the measurement.



the idea is to have a combined state, where the classical part is as before(i.e. a probability distribution of classical values), and the quantum part is represented by a explicit probability distribution over quantum states. a program acting on this combined state can act on the quantum part, on the classical part, or on both parts. combined programs acting only on quantum data are of two kinds: i) the unitary transformations, which reversibly transform the state vector and nothing happens to the classical probability; and ii) measurements, which probabilistically yield one



more specifically, a probability distribution over a basis set a is represented by a pair formed by: a list of real values ev, the eigenvalues which are the outputs of previously performed measurements, and a state vector, vec a. we chose to keep a list of eigenvalues ev to maintain a history of measurements. for now this list does not include information about the source of eigenvalues, i.e., about the position of the qubit which was measured in the global state.



we have presented two general and complete models for combined(quantum and classical) computations structured as arrows. the presentation is a stepping stone to develop a language in which the classical, probabilistic, and quantum layers are separate, which would simplify reasoning about quantum programs. the implementation is a prototype of the ideas in haskell. we hope to integrate the results in some quantum programming language like qml.



