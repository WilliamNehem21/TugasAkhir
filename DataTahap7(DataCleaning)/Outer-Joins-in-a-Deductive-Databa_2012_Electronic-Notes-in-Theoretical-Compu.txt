outer joins are extended relational algebra operations intended to deal with unknown information represented with null values. this work shows an approach to embed both null values and outer join operations in the deductive database system des(datalog educational system), which uses datalog as a query language. this system also supports sql, where views and queries are compiled to datalog programs. so, as sql statements are ultimately solved by a datalog engine, it became a need to integrate null-related operations into datalog in order to support a wider set of sql. since des implements a top-down-driven bottom-up stratified fixpoint computation based on tabling for solving datalog queries, we show how to compute outer joins in such a context by means of source-to-source transformations applied to datalog programs.



des implements datalog with stratified negation as described in with safety checks[30,31]. stratified negation broadly means that negation is not involved in a recursive computation path, although it can use recursive rules. the system can compute a query q in the context of a program that is restricted to the dependency graph(which shows the computation dependencies among predicates) built for q so that a stratification can be found. this means that, even when a program could be actually non-stratifiable, a query



sql dql statements are translated into and executed as datalog programs(basics can be found in), and relational metadata for ddl statements are kept. submitting a dql query amounts to 1) parse it, 2) compile to a datalog program including the relation answer/n with as many arguments as expected from the sql statement, 3) assert this program, and 4) submit the datalog query answer(x), where x are n fresh variables. after its execution, this datalog program is removed. on the contrary, if a ddl statement defining a view is submitted, its translated program and metadata do persist. a dml statement including either a where condition for filtering or a select data source is translated into a datalog query and program, so that results obtained from executing this query are used to modify base relations, depending on the statement(delete, update, or insert).



in the sense that, in addition, it deals with negation, undefined(although incomplete) information, nulls and aggregates, also providing a more efficient tabling mechanism(however, this system does not pretend to be competitive with current implementations but a system capable of showing the nice aspects of the more powerful form of logic we can find in datalog systems w.r.t. relational database systems).



for non-stratifiable programs(cf. next subsection), it is also possible to infer both a positive and a negative fact for a given call. then, an undefined fact replaces the contradictory information. the implementation simply removes the contradictory facts and informs about the undefinedness. however, the current algorithm for determining undefinedness is incomplete as this feature is only kept for teaching purposes on rather small examples(for instance, xsb includes a complete implementation of the well-founded semantics which deals with undefined facts).



unknownness has been handled in relational databases long time ago because its ubiquitous presence in real-world applications. despite its claimed dangers due to unclean semantics(see, e.g., the discussion in), null values to represent unknowns have been widely used. including nulls in a datalog system conducts to also provide built-ins to handle them, as outer join operations. des includes the common outer join operations in relational databases, providing the very same semantics for outer join operators ranging over null values, which are described next.



