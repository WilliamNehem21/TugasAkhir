performance problems are continuously prevalent in many software systems. model-based prediction methods try to tackle these problems during early design phases to avoid the problem of implementing architectures which are not able to fulfil certain performance goals. based on architectural models of the system(e.g. uml models), the software architect can create formal analysis models(e.g.



additionally, the isolated improvements of performance properties alone is problematic, because changes to improve performance usually affect other properties of the system, e.g. cost or maintainability. decisions to change the software architecture must take other extra-functional properties into account.



to meet the difficulty of solving detected performance problems, we propose an approach to automatically optimise the performance of a component-based software systems by automatically generating and evaluating design alternatives based on performance analyses of the software architecture. the novelty of our approach is the use of metaheuristic search techniques[6,8](such as random-restart hill climbing, genetic algorithms or others) together with performance domain knowledge formalised as heuristics to systematically create and evaluate new architecture candidates. for example, bottleneck resources can be resolved by finding a better allocation of components to servers or changing the sizing of resources. in addition to solutions based on performance domain knowledge, we undirectedly(e.g. randomly) generate new candidates and integrate them in the search to allow a larger search space to be explored. in this work, we present a list of design change operations for the palladio component model(pcm) performance prediction approach. additionally, we discuss how other extra-functional properties can be considered as constraints or even as additional decision criterion in a multicriteria optimisation in future versions of our approach.



the paper is structured as followed: section 2 introduces the idea of optimisation of extra-functional properties in general using both heuristics and undirected search. section 3 presents our approach which is specific to performance predictions for component-based systems and presents our current prototype implementation based on the pcm. in section 4, we present our proof-of-concept case study and explain the behaviour of the prototype step-by-step. finally, section 6 presents the related work in the area of model-based software performance improvement, and section 7 concludes.



we call the possibility to change a component-based system(including its allocation) in a certain way without affecting the functionality an(extra-functional) design option. for example, a component a in a design could be replaced by a number of components b, c and d that offer the same functionality, but have different performance characteristics. also, resources offer design options, for example the number of replications of an application server or the processing speed of a cpu.



software architect constraints: the software architect may have reasons to exclude some values of a design option or constrain a design option to a certain value. for example, he might chose to use the soap communication protocol for all communications in between the components, as this is a company-wide standard. thus, all candidates using other protocols(e.g. rmi) are not considered in this case.



as this set of tuples can also be seen as a mathematical relation, any language to specify relations could be used to allow an easier specification of the constraints than by enumerating all forbidden candidates. for some modelling languages and meta-(meta-)models, specialised constraint languages already exist. for example, if the candidate modelling uses the meta-object facility(mof), we can use the object constraint language(ocl) for constraint specification. however, as the design space is finite, there is no difference in principle.



metaheuristics are general strategies that guide the search process using underlying problem-specific heuristics(see for a more thorough characterisation). examples are genetic algorithms, simulated annealing, or random-restart hill climbing. the use of metaheuristics allows the automated search to pass over local optima that are not global optima. in contrast to that, pure rule-based approaches might be stuck in local optima and cannot make use of model parameters whose influence on the extra-functional property to be optimised is unknown.



for performance, there are design options with known influence on the overall system. for example, if we increase the processing speed of a highly utilised resource, the response time of a system will likely decrease(although there are exceptions). we formulate such performance domain knowledge into a set of heuristics.



exchanging a for b in c'' could have different effects(e.g. slowing down the system) than in c'(e.g. speeding up the system). here, we want the metaheuristic to try solutions we have no prior knowledge of, thus we create undirected operations to



undirected operations could include local search or random change. for local search, all neighbouring candidates(e.g. with one component exchanged, or with a processing resource speed increased by one increment) are evaluated. for random change, a number of design option values are changed for candidates to randomly chosen values.



although the concepts of automated performance improvement described in section 2 are generic, our goal is to apply the approach on performance prediction for component-based software systems. this section explains how we have tailored the approach to deal with the specifics of component-based systems by applying it on the palladio component model(pcm)(section 3.1). we specifically describe the design options available for component-based systems(section 3.2). afterwards, we describe an initial, prototypical implementation of performance-oriented performance improvement for the pcm(section 3.3).



the pcm is a modelling language specifically designed for performance prediction of component-based systems. the language allows the component developer specify the behaviour and the performance properties of components in a parametrised form. then, software architects can combine these component specifications with specifications of component assembly, user behaviour, and resource environment to form an architectural model. a model transformation into a discreteevent simulation of generalised queueing networks allows software architects to predict various performance metrics such as utilisation or response time distributions of the system and of individual components.



usage profile: the number of users as well as their input parameters can have an effect on the overall performance of the system. these values are included within a pcm instance. adding these values to the changeable parameters of the model, the scalability of the system at hand in relation to other design options(as presented above) can be studied.



instances. it is realised as a plugin for the eclipse framework and thus seamlessly extends the pcm bench. the pcm bench relies on the eclipse modelling framework(emf) for modelling the component-based system. during the search, peropteryx manipulates the emf instance of the pcm to generate new candidates. to evaluate a candidate, its emf instance is automatically transformed in a generalised queueing network system and analysed using a discrete-event simulation. both transformation and analysis are provided by the existing pcm bench implementation and described in detail in. from the various resulting performance metrics, peropteryx currently uses the mean response time of an entire usage scenario for assessing a candidate.



know about the effects of replacing components in advance before trying them in the actual system. the component models are highly parametrised and components compete for resources. the rationale behind this operation is that multiple components for one task could be available from third parties and that some of them might lead to better performance.



we specified that the mean response time of the brs for the expected usage should be less than 2.5 seconds. the usage was expected to be an open workload with a user arriving every 1.3 seconds. we specified no further constraints. for the webserver component, there are two alternatives named webserver2 and webserver3 available in the repository.



design options: not all design options for component-based systems(as presented in section 3.2) are supported by the current prototype. adding the missing design options would further increase the number of possible candidates and thus increase the potential for design improvement.



priate to just optimise a single extra-functional property, because other extrafunctional properties can worsen. several more sophisticated metaheuristics exist that explicitly take several criteria into account and perform multicriteria pareto optimisation, for example. we plan to integrate such metaheuristics together with a simple cost model of initial cost and operating cost for both software and hardware as a next step.



during the analysis of a system at hand, we might be able to learn correlations of design option values and performance for that specific system. for example, during the search, we can learn that component a is better than component b for most candidates. possibly, we can even find further heuristics for undirected operations that are valid for many systems and create new heuristic operations. some proposed metaheuristics such as already incorporate such learning techniques that could be adopted for our automated performance improvement.



another future extension for our approach is to add an interactive mode. the software architects could evaluate candidates during the search, so that their judgement would be a further criterion(interactive optimisation,). additionally, software architects could guide the search when several options how to evolve candidates are at hand and prioritise the available operations(comparable to interactive modes of model checker tools).



cortellessa et al. propose an approach for feedback generation for software performance analysis, which aims at systematically evaluating performance prediction results using step-wise refinement. the approach relies on the manual detection of performance anti-patterns in the performance model. there is no support to automatically solve a detected anti-pattern, and there is no suggestion of new architecture candidates.



other than the former quantitative approaches, there are qualitative architectural evaluation methods, such as atam or saam. these approaches do not formally model software architectures, but instead rely on textual specification of usage scenarios. therefore, these approaches only allow an informal discussion of performance properties and architecture candidates, but no automated support for exploring the design space.



using this approach, software architects can more easily create high-quality component-based software designs. the automation of the search saves the software architect effort for a manual exploration. thus, the gap between applying formal performance prediction methods and actually improving the design of a system can be closed.



the first steps to extend our work will be the integration of a cost model and the use of multi-objective-enabled metaheuristics to support trade-off decisions among different extra-functional properties. the prototype will be extended with more design change operations such as changing the allocation of components and more performance domain heuristics. the integration of a framework for metaheuristic search will allow the comparison of several metaheuristics. in the long run, we aim to evolve the prototype into a framework for extra-functional property optimisation for component-based software systems.



