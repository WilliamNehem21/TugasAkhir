this work proposes a dependent type system for the llvm intermediate representation language for keeping track of pointer bounds information. the system employs a combination of static analysis and runtime checks to avoid spatial memory safety violations, such as buffer overflows. by working on llvm ir, the system serves a foundation for ensuring spatial memory safety in languages which can be compiled to llvm, such as c and c++.



a number of techniques have been proposed to provide memory safety in c[8,11,10]. typically such systems keep their own bounds information and instrument the program to ensure that memory safety is not violated. a different approach, named deputy, employs dependent types to enable the programmer to annotate the already existing bounds information kept manually in c programs, so that the compiler can identify it and insert checks which ensure its correct usage. because the compiler-inserted checks use the same metadata as the checks written by the



this paper is organized as follows. section 2 presents background for this work. section 3 describes the llvm ir language. section 4 describes the proposed system, how it fits in the llvm environment, and the type rules and transformations it implements. section 5 presents conclusions and future work.



there are different kinds of memory safety. temporal memory safety refers to the property of not attempting to access memory that has been deallocated or not allocated yet, while spatial memory safety refers to the property of not attempting to access memory outside of the bounds of an object. the methods for ensuring each kind are different. this work addresses only spatial memory safety. other mechanisms, such as conservative garbage collection, can be used complementarily to ensure temporal memory safety in c.



works also vary in the granularity at which memory safety is considered. some works, such as, consider whole data structures as the basic unit for memory, so that access past the limits of a field in a data structure is not considered a violation if the access is still within the same data structure. this limits the damage caused by buffer overflows or overreads, but does not completely eliminate them. other works, such as deputy, address memory safety at the level of single variables and structure fields. the present work uses this more strict version of memory safety.



dependent type systems vary in their degree of expressivity. some dependentlytyped programming languages allow any expression to appear in types, which may lead to undecidability because an expression may fail to terminate. other languages allow a subset of expressions to be used in types, thus avoiding undecidability at the expense of expressivity.



meaning that the array parameter of function f is a pointer to a region of len integers. when the program is compiled, deputy inserts assertions in the code which ensure that pointers are within the declared bounds before they are used. a second compilation pass then looks for assertions which can be proven true at compile time, and thus can be safely removed, thus reducing the performance impact of the checks. it also looks for assertions which can be proven false at compile time, which are reported as compile-time errors to the programmer, thus providing static checks when possible. expressions which can appear in a dependent type are limited to local variables, constants, and arithmetic expressions, which is usually sufficient for describing bounds in c programs.



llvm is a widely used language-agnostic framework for program compilation, analysis and transformation designed around a uniform intermediate representation(llvm ir), a typed assembly-like language for an abstract machine. various backends exist for translating llvm ir to machine code of different architectures. the use of a uniform, well-defined language for code representation makes it relatively easy to extend llvm with new analysis and transformation passes.



llvm ir is a typed assembly-like language for an abstract machine with an infinite number of registers. the llvm ir language is in static single assignment(ssa) form with respect to its registers: each register is assigned exactly once, and each definition dominates all of its uses. memory access is done through typed pointers. the ssa restriction applies only to registers, not to memory locations.



the branching instruction(br) takes a boolean and two labels, and jumps to either label depending on the value of the boolean. br lab is an unconditional branch to lab, and can be regarded as syntactic sugar for br true, lab, lab. ret returns to the function caller with the specified value.



