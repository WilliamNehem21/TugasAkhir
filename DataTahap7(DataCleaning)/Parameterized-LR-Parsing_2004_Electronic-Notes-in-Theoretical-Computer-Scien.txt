lr parsing is a powerful tool in the toolbox of the language designer. it provides a parsing algorithm that works in linear time for a wide range of context-free grammars. the theory of lr parsing has been explored in numerous works and it has become a standard part of lectures and textbooks on compiler construction. it also forms the foundation of a whole range



while there has been some evolution of the tools with respect to modularization of parsing actions and integration of the specifications of parsing and scanning, the actual raw matter, the grammar, remains in its original form in the parser specification. since large grammars may well run into several hundred productions, grammar maintenance can become a tedious task. hence, it is surprising that none of the parser generators has a facility for introducing abstractions over grammar rules.



used like functions. they can be invoked with actual parameters in the righthand side of a production. some care must be taken to restrict the actual parameters suitably, for example, to only one nonterminal or one formal parameter. without restriction to the actual parameters, we would obtain the notion of a macro grammar which is strictly more powerful than a context-free grammar.



before developing the theory of parameterized lr parsing, we make an excursion into formal language theory to introduce the reader to macro grammars and macro languages in section 2. after defining a suitably restricted notion of macro grammar, section 3 introduces the basic definitions for parameterized lr parsing. section 4 defines the parsing algorithm, starting with a nondeterministic specification and then defining the notion of conflict to obtain deterministic parsers. section 5 is devoted to attribute evaluation. it defines a type system that assigns polymorphic types to parameterized nonterminals. section 6 describes our implementation of parameterized lr parsing in the 3 the definition we are giving above is not the one that has been used to obtain the cited results. the original definition considers strings as trees build from monadic operators(the characters) so that standard nonterminals in a context-free grammar are also monadic operators serving as placeholders for trees. in a macro grammar, nonterminals receive additional parameters that range over monadic operators. adding further parameter sets leads to higher levels in the mentioned hierarchy.



example 2.4 a restricted macro grammar for a fragment of the grammar of javascript expressions serves as running example. the fragment encompasses constants, c, array literals enclosed in[ and], as well as object literals enclosed in{ and}. array and object literals both contain comma-separated lists modeled with the parameterized nonterminals l and n. object literals consist of key-value assignments as described by nonterminal a. terminal



in traditional lr parsing, the state of a parser is the closure of a set of kernel items. in parameterized lr parsing the state of a parser is a mapping from tuples of nullary nonterminals to a set of plr(k) items. the notion of closure corresponds to a notion of consistency of a state.



parser combinators[20,8] are a highly flexible way of specifying parsers in functional programming languages. in particular, the use of polymorphic functions and parameterized parsers is a natural way of structuring code with parser combinators. in contrast to the present work, they perform predictive or top-down parsing. recent advances have widened their scope considerably with respect to earlier, inefficient proof-of-concept implementations. the present work makes some of the polymorphism and flexibility that make parser combinators attractive available to the construction of lr parsers.



the syntax definition formalism sdf supports arbitrary context-free grammars and creates glr parsers[12,21,15] for them. for convenience, right-hand sides may contain an extended set of regular operators. an sdf specification also defines a lexical syntax. sdf includes an abbreviation mechanism which works by expansion.



one reviewer mentioned van wijngaarden(or w-) grammars, a turingcomplete parameterized grammar formalism used in the definition of algol 68. conceptually, w-grammars consist of two-levels. the first level defines context-free languages of interpretations of grammar symbols. these interpretations are used to generate the actual grammar productions by substitution into rule templates. however, w-grammars are a conceptual modeling tool and are not geared at generating efficient recognizers. rather, they have been designed for describing context-sensitive aspects of programming languages. they lack the conciseness and ease of use of direct parameterization, which is a familiar concept from programming practice.



