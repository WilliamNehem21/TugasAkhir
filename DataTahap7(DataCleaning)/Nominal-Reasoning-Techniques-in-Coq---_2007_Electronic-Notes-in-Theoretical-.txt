both of these points reflect common practice with pencil and paper formalizations. more generally, our nominal approach is designed to eliminate the need to reason about any terms that do not actually appear in paper proofs, e.g., pre-terms, shifted terms, and exotic terms.



the primary contributions of this paper are to demonstrate that a nominal approach to variable binding is indeed possible in coq and to highlight the issues that arise when implementing such an approach in a dependently typed type theory. while we do not yet have the system described above, we have assessed the theoretical and practical viability of this approach in the particular instance of an untyped lambda calculus, while bearing in mind the issues that arise in more complex languages. we feel that our experience with this specific case will allow us to build a complete system as described above.



the rest of this paper is structured as follows. we first describe the foundational components of our approach in section 2 and the design and implementation of our signature for an untyped lambda calculus in section 3. we then give some empirical observations about using this signature in section 4. we discuss related work in section 5 and conclude in section 6 with an overview of our ongoing work.



as in previous work on nominal approaches for variable binding[7,8,9], we base our work on atoms, swapping, and support. since swapping and support cannot be defined parametrically for all types, we use an encoding of haskell-like type classes to quantify over all types for which these notions are defined. we discuss each of these components in this section.



the record type is parameterized by t, the type of elements carried by the sets. the actual type of finite sets over t is given by the field extfset, and in is a set-membership predicate. the names of these fields are constants(i.e., record field selectors) whose full types are classes. each record type defines a type class, and fields of the record type are fields of the type class. to quantify over only those types which are members of a given type class, we quantify over its dictionary. we do not use modules for this purpose because we cannot quantify over all modules implementing a given signature.



in theory, the user may use any definition of swapping for a given type that satisfies the properties in swapt, but in practice there is usually a natural one defined by the structure of the type. the simplest form of swapping is the swap of atoms a and b of type atom a applied to the atom c, also of type atom a, denoted by swapa a(a, b) c. we provide the constructor mkatomswap that uses the swapa function to construct the swapt record. for types where no atoms(of the sort being swapped) appear(e.g., the type nat), the only reasonable definition of applying a swap is to leave the object unchanged.



