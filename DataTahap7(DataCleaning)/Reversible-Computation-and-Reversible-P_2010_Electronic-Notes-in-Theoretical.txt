a reversible programming language supports deterministic forward and backward computation. this tutorial focuses on a high-level reversible programming language janus. in common with other programming paradigms, reversible programming has its own programming methodology. janus is simple, yet powerful, and its constructs can serve as a model for designing reversible languages in general.



conventional computing models such as turing machines and random access machines(rams) destroy information at each computational step. the symbol written on the tape in the previous state will be overwritten by the new symbol, and the value written on the registers will be updated into the new one. at the first sight, we tend to think the destruction of information is necessary to computation. however, it was shown by landauer that any irreversible computation can be simulated by reversible computation by adding the extra storage to remember the history of computation. moreover, this garbage information can be erased by its inverse computation. thus, in theory we can simulate any irreversible computation with reversible computation provided that a given storage is infinite.



to provide a flavor of reversible programming, we show a janus procedure for computing fibonacci pairs. given an integer n, the procedure fib computes the(n+1)-th and(n+2)-th fibonacci number. for example, the fibonacci pair for n=4 is(5, 8). returning a pair of fibonacci numbers makes the otherwise non-injective fibonacci function injective. variables n, x1, x2 are initially set to zero. parameter passing is pass-by-reference.



a reversible assignment updates an integer variable or an array element. the variable x on the left-hand side of an assignment must not appear in the expression e on the right-hand side. similarly, array variable x must not appear in the expression e on either side of the assignment. this, together with the reversible modify operator procedure body in the local store of formal parameter variables. a procedure uncall invokes inverse computation of the procedure. all parameters are passed by reference. as usual, the number of parameters in a call must correspond to the number designated in the procedure declaration and the types of the actual parameters should meet those of the formal parameters. the actual parameters must be variable names in the scope of the procedure invocation. to avoid problems with aliasing, we prohibit passing the same reference to more than a single parameter.



this is an important mechanism of reversible languages, and capturing the concept by switching input and output store for inverse constructs is a promising semantics technique. we use the same technique in defining a pop as the inverse of a push(cf. rules push and pop).



each programming paradigm has its own methodology. reversible programming also has its own techniques[30,32]. for example, janus can implement janus interpreter and the tower of this reversible self-interpreter constitutes non-standard hierarchy. any level of self-interpreters can be both inverted and uncalled. a reversible self-interpreter for the original janus and a tower of reversible interpreters were reported in.



several introductory articles and surveys on reversible computing have been published(e.g.,[13,24,9,20,3]). the concept of reversibility has been studied by using various computation models, including reversible turing machines[2,21], reversible cellular automata, reversible flowchart, reversible combinatory logic, reversible process calculi, reversible boolean logic circuits[10,5], and reversible finite automata.



one of closely related concept to reversible programming languages is program inversion. generalized program inversion generates a semi-inversed program, in the sense that given some of the original inputs and outputs it returns the remaining inputs and outputs[23,19]. bidirectional languages, which also have the concept of forward and backward semantics, are desined for the view updating problem[7,22].



