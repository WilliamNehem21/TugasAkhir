refinement is a key practice in the model-driven architecture initiative of the object modelling group. however, the practice is loosely defined, overloaded, and open to misinterpretation. in this paper, we outline ongoing work on providing a precise definition for refinement via consistency checking, not only in the context of mda, but more generally for model-driven development in a variety of domains.



mdd is not a development method or process; it can be implemented in a number of ways, e.g., via extreme programming, the rational unified process, the b-method, or a refinement calculus. the key element in mdd is the construction and transformation of models that are fit for the purposes of the development project. the languages and processes used in construction and transformation will vary from project to project.



perhaps surprisingly, refinement is a key concept in mda. this is surprising for two reasons. first, the languages prescribed in mda are uml-based and generally do not provide the level of formality one might expect in a refinement-based method. second, the languages used in mda are multi-view, and as such it is difficult to achieve seamless refinement-based development with them.



the issue of what constitutes a valid refinement step is an interesting one. the idea in mda is that predefined transformations(written in a standard transformation language, qvt) will be applied in order to go from pim to psm, or from psm to code. custom(often hand-written) refinement steps will be used in order to refine within a particular type of model, e.g., from pim to pim. the latter type of transformation is usually dependent on the application context. thus, it is assumed that in general many of the transformations that are being applied have been previously validated by an mda expert, and thus are safe to applyproviding that the rules for applying the transformation are obeyed 2. however, this does not help in validating custom, hand-written



there are two essential parts to mda: languages for expressing models, and transformations applied to models. the languages used in mda are generally uml-based, and as such are built atop the meta object facility(mof), which is a core language for defining languages. thus, the transformations used in mda are defined in terms of mof and its core constructs, e.g., classes, objects, features.



the difficulties associated with this rigorous approach to defining refinement in mda are typical of attempts to attach formal analysis techniques to semiformal languages after the languages have been defined. the difficulties are perhaps more pronounced in mda because of the layered nature of the languages used, i.e., uml defined in terms of mof.



a diagram can be used to express one or more views of a model; nongraphical languages can also be used to capture views. a diagram is expressed in a language. the language itself consists of a syntax and a metamodel, which defines the wellformedness constraints for the language. for example, the metamodel for uml class diagrams will contain a constraint stating that all classes in a diagram must have unique names.



we can express rules like these(and others) in ocl so that ocl evaluation can be carried out. this process is quite straightforward and simple to implement. for example the ocl fragment below implements the first rule of the above list.



in mda, structural and state-based rules are insufficient to fully capture model consistency, since the overall system model is split into several parts, e.g., pim and psm. thus, the rules discussed in the previous section must be applied to check for consistency. as well, at least two additional kinds of consistency must be checked.



consistency of psms with the domain: each domain(e.g., information systems, database design) has domain-specific rules that should not be broken. since these rules might not be directly imposed by the modelling language syntax, extra mechanisms i.e., stereotypes or metamodel refinements must be applied in order to ensure their application. thus, for each different application domain, a set of domain-specific rules must be checked.



the same approach can be used for psm-domain consistency: a domain model(e.g., for databases) has a metamodel and a syntax and thus crossmodel consistency rules can be captured in the same way as for pim-psm consistency. this is additional evidence that the distinction between pim, psm, and other models in mda is not always particularly useful.



a and b must obey any cross-model consistency rules relevant to their context. for example, if a is a pim and b a psm, then all pim-psm consistency rules relevant to the transformation of a into b must be satisfied. similarly, if a is a psm and b a domain model, then all psmdomain consistency rules must be satisfied.



