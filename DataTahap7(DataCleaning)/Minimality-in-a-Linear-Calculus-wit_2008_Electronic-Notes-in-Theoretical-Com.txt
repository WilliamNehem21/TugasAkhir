we present reduction strategies for the weak reduction relation: call-by-name, call-by-value, and call-by-need(emphasising this last one), proving that they are indeed strategies in a technical sense. since neededness is usually undecidable, extra features(like sharing graphs, environments, explicit substitutions) are generally added to actually implement call-by-need. in contrast, for system l, we can define call-by-need within the calculus in an effective way.



in general, call-by-need(and even minimal strategies) may copy expressions in some situations(for example inside abstractions). sharing of subterms across different instantiations of bound variables is addressed by optimal reduction strategies[19,17,12,21,28]. although this line of research applied to system l is a promising one, optimal reduction in this sense is not an issue in this paper: here we follow the weak reduction approach, as is standard in the implementation of functional languages.



we do not want to recall too much about higher-order rewriting. the systems defined in this paper will fit the framework of context-sensitive conditional expression reduction systems(cers). in particular, the notion of residuals make sense in these systems.



in, van oostrom gives a method to reduce the global problem of proving that a strategy is minimal(or maximal), to a verification of certain properties of local reduction diagrams. to avoid recalling all that work here, we combine some parts of theorems 1 and 2 of, as the following theorem, which will be used to show the minimality of call-by-need among weak strategies(theorem 6.8).



proof. apart from easy syntactic verifications, we have to notice that all descendants of a redex are redexes. this comes from the preservation of linearity constraints, subject reduction, and the fact that a closed term cannot become open during reduction.



semantically, we have: iter(sn0) u w= wn(u)(i.e. n copies of w applied to u). however as shown in the given rewrite rules, we actually make use of n+ 1 occurrences of w, and then throw one away. to circumvent this defect we change the definition in order to stop at s0 rather than 0:



we remark the relation with fold right and fold left for lists in functional programming. these operators encapsulate recursion patterns on lists, in the same way as an iterator on numbers encapsulates recursion patterns on numbers. the difference between foldl and foldr is simply the order in which the elements of the lists are accessed: left-to-right, or right-to-left. a left-to-right approach can start working on elements of lists, even infinite lists, whereas the right-to-left approach works well in the finite case(i.e. it is strict in the list). the same reasoning applies to our iterator. of course, the origins of these operators on lists are indeed iterators on numbers(primitive recursive schemes).



with the inner-iter reduction policy, iter is strict in its first argument. for example, in an untyped calculus, if the number is not terminating, then neither is the iter(irrespectively of the evaluation order). this will not be a problem in system l because it is a strongly normalising calculus.



definition 6.1 call-by-name reduction is leftmost outermost weak reduction. in particular, iteration is by name. call-by-value differs from call-by-name by reducing the argument of an application before contracting the redex and by using iteration by value instead of iteration by name.



otherwise, for some multi-hole context c, this reduction can be decomposed as w''[iter(s t) u w/x] dn1 c[w, w,..., w] d c[w', w,..., w] dn2 v with n= n1+n2+ 1, and we can mimic this reduction on w''[iter(s t) u w'/x], omitting at least one step(because at least one residual of a needed redex is needed): w''[iter(s t) u w'/x] dn1



system l is a calculus that isolates the linear and non-linear components of a computation. we have used this calculus to make a study of evaluation strategies in this context, where it is precisely the non-linear aspects of the computation that we need to control. this leads to a simple description of strategies and to a definition of minimal strategies within the calculus. moreover, we anticipate that we can make heavy use of these results in current implementation work based around system l.



