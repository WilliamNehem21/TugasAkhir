we are interested here in causing the checked code to behave according to a given suspicious execution, which may be the result of a verification or testing effort. we want to be able to reconstruct and inspect this behavior in the context of the tested or verified code. due to nondeterminism associated with concurrently executing events, we are not guaranteed to recover the given execution without enforcing some modification to the checked software. we therefore concentrate on minimizing the effect of the changes to the original code. we suggest a simple and automatic transformation that can be applied to the code in order to recover the suspicious behavior. our method gives the verification engineer or tester a tool for checking and demonstrating the existence of the error in the code. we impose the following constraints on the suggested software transformation:



here, both processes proceed to signal that they want to enter their critical sections, by setting c1 and c2 to 0(lines 7 and 8), respectively. because turn= 1(turn is checked in lines 11 and 12), process p 1 has priority over process p 2. this means that process p 2 gives up its attempt, by setting c2 to 1(line 13), while process p 1 insists, waiting for c2 to become 1(checked in line 14) and then enters its critical section(line 15).



a(global) state of a program is a function that assigns values to the program variables, including the program counters. we assume that the program can be translated into a set of atomic actions a. each atomic action consists of a condition and a multiple assignment(changing the values of some program variables, including program counters). some of the conditions are implicit to the text of the program, e.g., a check that a program counter has a particular value. similarly, part of the multiple assignment does not come



in order to perform the transformation, we prepare the code, while translating it into a set of actions. we keep pointers to the text location corresponding to the beginning and end of actions. in most cases, the transformation consists of adding code at these locations, i.e., before or after an action. for simplicity, we start presenting the transformation with the unrealistic assumption that we can add code for the existing actions in a way that maintains the atomicity of the actions. since this will result in rather large actions, which cannot realistically be executed atomically, we split them in a way that is detailed and explained below.



advanced note. in order to avoid introducing unnecessary delays or even deadlocks, we must guarantee that the implementation of waitji must not block the process pi. specifically, if vij is 0 and process pj is waiting for it to become 1, process pi needs to be able to progress, which will allow it to eventually increment vij. such blocking could exist, e.g., on a single processor multitasking the concurrent program, with wait ji performing busy waiting for vij to become 1, the scheduler is unfair to process pi. it is interesting that



as in the case of programs with shared variables, we need to add code for activating the additional checks only when enforcing a suspicious execution, i.e., when checki= true. similarly, we include the last action in every process in the counting, in order to halt the execution. note that with no shared variables and under handshake communication, the code added in the transformation is completely local to the processes.



