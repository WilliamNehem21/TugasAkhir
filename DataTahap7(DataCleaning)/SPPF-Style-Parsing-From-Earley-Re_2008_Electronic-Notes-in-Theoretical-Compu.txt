a grammar not only defines the syntax of a language, it is also the starting point for the definition of the semantics, and the grammar which facilitates semantic definition is not usually the one which is lr(1). this is illustrated by the development of the java standard. the first edition of the java language specification contains a detailed discussion of the need to modify the grammar used to define the syntax and semantics in the main part of the standard to make it lalr(1) for compiler generation purposes. in the third version of the standard the compiler version of the grammar is written in ebnf and is(unnecessarily) ambiguous, il-



in there is given an outline of an algorithm to turn the recogniser reported there and in into a parser, but again, as written, this algorithm will generate spurious derivations as well as the correct ones. the recogniser described in is not applicable to grammars with hidden left recursion but the closely related riglr algorithm is fully general, and as a recogniser is of worst case cubic order. there is a parser version which correctly constructs sppfs but as these are tomita-style sppfs the parser is of unbounded polynomial order.



we could walk the above structure in a fashion that is essentially the same as described in example 1 above. however, in order to construct a binarised sppf we also have to introduce additional nodes for grammar rules of length greater than two. thus the final algorithm is slightly more complicated.



j and i. thus each non-packed node has at most o(n) packed node children and there are at most o(n3) packed nodes in a binarised sppf. as non-packed nodes are the source of at most o(n) edges and packed nodes are the source of at most two edges, there are also at most o(n3) edges in a binarised sppf.



