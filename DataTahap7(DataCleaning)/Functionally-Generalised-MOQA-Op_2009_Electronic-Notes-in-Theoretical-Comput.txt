moqa is a new programming language, based on a kernel of basic operators, introduced by m. schellekens in order to facilitate the average execution time analysis(a-eta) of its programs(cf.[5,7,4,6,8]). the design of moqa is developed in[5,7] where the semantics of the basic operators is given via operations, refered here as basic moqa operations. in this article, we present functional-generalisations of three of these operations: the projection, the unary product and the split.



in section 2, we present several notions, in particular the notion of random preservation. note that we will introduce a distinction between random preservation and automatic random preservation, a distinction which is not done in[5,7]. in section 3, we define the notions of isolated subsets of a poset and local transformation. isolated subsets are used in particular to express the restrictions on the applicability of moqa operations. then in section 4, we introduce moqa operations and their generalisations. finally, section 5 we discuss the rp property of the generalisations. we remark that this article is essentially self-contained. in particular we introduce the notions from[5,7] we need.



we drop the index p in the notations above as soon as there is no ambiguity on the poset p. a similar convention is used whenever a subscript can be removed without loss of clarity. we define now the hasse diagram of a poset.



an operation or a program applied on different inputs may leed to the same output. in order to keep track of the number of inputs corresponding to a given output, the notion of output multiset is defined below. but first, we introduce multisets and two of their constructors.



in other words, a local transformation of y modifies the digraph p at most locally on y. in particular, condition ii in the definition implies that r' t(x\ y)= r t(x\ y). we link now the two notions of isolation and local transformation.



natural and easy to control than the isolation one. the operations are defined in two steps: on the poset first and then on the lpo. we remark that it is done in the same way in and so proposition 4.19 is immediate.



a near-lpo is a lpo where the biggest label has been replaced by a fresh label(a label not appearing in the lpo). the behavior of pushdown is illustrated using example 4.24 below. the first step is obtained by replacing the biggest label, here 4, by a fresh one, here 2. then, pushdown first checks if the replacing label is bigger than all labels below it. if it is true then pushdown stops. if not, which is the case in our example, it swaps the replacing label with the biggest label below it, that is, in our example, it swaps 2 and 3. then it iterates the same operations, continuing to push down the replacing label, until either the replacing label is bigger that all the labels below it or it is placed on a minimal element of the poset. in our example, after the first swap 2 has reached a minimal node and so pushdown stops. it is straightforward to verify that, when pushdown stops, the results of its swaps on the near-lpo is a lpo(in particular from the fact that the swaps always involve the biggest label below the label to be swapped).



inition 2.5) using an algorithm written in pseudo-code. it is then generalised to every lpo where y is atomic isolated. we present first that algorithm. for that, we introduce here a special notation atsplit for the operation implemented by the algorithm. moreover, as for, we prefer to define atsplit(ay, l) as a labeling instead of a lpo as it is done in.



as already mentioned, rp-domains and def-domains of moqa operations are identical. it is not the case for the generalised ones and it would be easy to exhibit random structures where they are defined but not rp. nevertheless, propositions 4.19, 4.29 and 4.40 express in particular that the generalised operations, when restricted to the domains of the corresponding moqa operations, coincide with these operations. that fact implies in particular that the rp-domains of generalised operations contain the rp-domains of the corresponding moqa operations. in fact we have a stronger result.



in this article, we introduced three generalised moqa operations. these operations have several advantages compared to their correspondent moqa operations. first, they extend the domains of definition of the latter in a non trivial and still meaningful way, using more natural restrictions. secondly, as shown in the previous section they extend also the domains of random preservation of the corresponding moqa operations. the fact that the examples given in section 5 can be generalised indicates that this extension is non-trivial and quite rich.



