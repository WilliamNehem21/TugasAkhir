an increasingly wide range of tools based on different approaches are being used to implement domain specific languages(dsls), yet there is little agreement as to which approach is, or approaches are, the most appropriate for any given problem. we believe this can in large part be explained by the lack of understanding within the dsl community. in this paper we aim to increase the understanding of the relative strengths and weaknesses of four approaches by implementing a common dsl case study. in addition, we present a comparative study of the four approaches.



and the intentional domain workbench(idw) are two workbenches that typify this new class of tools. the workbenches essentially provide an integrated development environment(ide) with underlying base languages. for instance, idw comes with cl1 language; and mps comes with three base languages: structure for defining the abstract syntax of a language; editor for defining the concrete syntax of a language; and semantics for defining the semantics of a language. using these language building tools, dsls can be developed and integrated to implement a domain specific application.



in this paper we evaluate four approaches to dsl implementation. in similar style to czarnecki et al., which evaluates the compile-time meta-programming abilities of three languages, we use a case study to evaluate these approaches. our case study is a small but realistic dsl example of a state machine language. although our work involves a single case study, the dsl implemented for our case study is indicative of a much wider range of dsls which have been implemented



the structure of the rest of this paper is as follows. section 2 introduces the case study, which then provides the basis for our dsl implementation in antlr, ruby, stratego and converge in sections 4, 5, 6 and 7 respectively. section 8 presents a comparative analysis of the four dsl tools and their approaches based on selected dimensions and metrics. section 9 then presents our experiences of the relative strengths and weaknesses of the four dsl tools.



antlr is a parser generator tool that provides a framework for implementing language translators. in antlr, the generated parser can be implemented as a translator in one of two forms: it can execute the semantic actions; or it can execute the semantic actions to generate a target program using templates. for the purposes of this paper, we discuss antlr as a translator that emits a target program.



in ruby, methods accept a code block as a final argument. however, if a method is defined with a block argument(an ampersand-prefixed final argument of the form&ablock), then a code block(supplied as an argument to the method) will be implicitly converted to a proc object. a proc object is essentially a ruby object representing a block of code which can then be passed around as an object and executed either by using yield or by invoking its call method(any arguments passed to the call method will be assigned to the block parameters). in the above code, since the transition method defines a block argument(&ablock), the proc object associated with it is passed as an argument to the load block method of the transition object. the following code fragment shows how the&ablock object is eventually executed by calling yield self(self refers to transition object from the above code fragment):



the use of a where clause in a transformation rule enables the programmable application of rules. for instance, the<trans-tail> ttail1 construct within the where clause of the guard-init rule, will invoke either of the trans-tail rule, depending upon the value of ttail1 at run-time. the value returned from invoking the trans-tail rule on the ttail1 aterm is assigned to the bstm 1 meta-variable which is then spliced back into the transformation rule to generate the target language construct(the grammar definition of the java language defines bstm 1 as a meta-variable).



method can then be used to call the appropriate t function. for our case study we implement sm translator class(inherits traverser::traverser class) that contains the necessary t functions( t system, t transition etc.). the generate function initiates the translation process by invoking t system function(system is the top-level rule for our grammar). a code fragment showing the definition of the sm translator class and the use of self. preorder method to invoke the necessary t function depending upon the value of the node is as follows:



program: first, the template engine is unaware of the type of data that is being pushed from the parse; second, the well-formedness of the generated program depends on the syntactic and semantic well-formedness of the constructs within the template. in ruby, dsls are essentially host language constructs, and therefore, any guarantees with regards to both syntactic and semantic well-formedness are provided by the ruby interpreter. in stratego, few guarantees are given with respect to producing a syntactically and semantically well-formed target ast. for instance, a meta-variable within a transformation rule can be associated with an incorrect type that can lead to the generation of an invalid ast. similarly, the target ast can contain semantically ill-formed constructs, which are only reported at the time of compilation of the end language. in contrast, the converge compiler guarantees the syntactic and semantic well-formedness of the translatedto host language constructs at the time of translation.



and semantic well-formedness. since in ruby and converge errors related to wellformedness are reported(at run-time and compile-time respectively), diagnosing such errors is lot easier. in antlr and stratego, since well-formedness errors are reported only when compiling the end language, users may have to revisit the transformation program or the grammar definition to determine the source of the offending construct(see the error reporting dimension).



reuse we identify two aspects that are potentially reusable: the grammar of the dsl; and the transformation module. in antlr, the grammar has limited reuse because the parser rules are interspersed with semantic actions and template calls. however, antlr supports the use of templates for code generation that enables a clear separation between data(dsl) and logic(parser) from presentation(template). this, for a given grammar, allows code to be generated for multiple target languages. in ruby, since the dsls are essentially host language constructs, the aspect related to the grammar does not apply. further, the interleaving of the dsl program and the host language constructs that evaluate the dsl program limit the reusability of the dsl implementation. in converge, since the grammar of the dsl and the dsl constructs are closely integrated with the host language constructs that perform the translation, large sections of the dsl implementation have limited reuse. in stratego/xt, the modular sdf definition of the object language, and sections of the transformation program that implement the expression and the type transformations can potentially be reused for other dsl implementations.



user-defined aspects. in antlr the reusability of the grammar for multiple targets is useful in cases where code needs to be generated for multiple languages. in ruby and converge, the dsl constructs are embedded within the host languge program thus making it difficult to reuse any of the user defined aspects. in stratego, when code needs to be generated for multiple object languages, the grammar definitions related to meta-variables and sections of the transformation program related to type and expression sub-systems can potentially be reused.



the fourth entry in the backtrace is related to multiple source locations: the third and fourth line indicates the location within the source dsl(runfsm.cv); and the others(only one is shown for brevity) are within the dsl translator(fsm translator.cv). thus src infos provide useful debugging information to both the user and the dsl developer to determine the cause of an error. further,



from an end user perspective, we want the dsl tool to report errors in terms of the source dsl. in antlr and stratego, errors related to transformation are reported only at the time of the compilation of the end language, thus leading to increased development time and cost. in ruby and converge, the ability to report an error with a complete stack trace results in much quicker implementation.



antlr uses a stand-alone approach to implement dsls. antlr comes with antlrworks, a grammar development environment with editing and debugging facilities that allows developers to quickly prototype and test their dsls. the use of scopes allows data to be shared between the parser rules, which then enables context-sensitive translation. antlr supports the use of templates that enforces separation of data(dsl) and logic(parser) from presentation(template) which then allows the grammar to be reused for generating target programs in different languages. however, this separation also means that the data that is passed from



ruby and converge both use an homogeneous embedded approach to implement dsls. in ruby, dsls are implemented using its host language features; therefore, the implementation will be quick and the dsls implemented will be lightweight in nature. converge supports implementation of dsls using its compile-time metaprogramming facility. the close integration of the parser kit and the compile-time meta-programming facility with its host language, enables it to provide a systematic approach to implement dsls. the concept of src infos is unique to converge, which enables it to report errors precisely in terms of the source dsl. however, integrated dsls in converge are obviously distinct from normal language constructs, which can be aesthetically jarring.



in this paper, we implemented dsls using a stand-alone approach and three different embedded approaches. the stand-alone approach showed the traditional method of implementing of dsls using antlr. the three different embedded approaches include: a weakened form of homogeneous embedded approach using ruby; a heterogeneous embedded approach using stratego; and a homogeneous embedded approach using converge. further, we presented a comparative study of the above approaches using a case study. from our comparative study we observed that each approach has its merits and demerits and there is no single approach that would apply to all scenarios. nonetheless, we have highlighted strengths and weaknesses of four approaches that could serve as a guideline for future implementation of dsls.



