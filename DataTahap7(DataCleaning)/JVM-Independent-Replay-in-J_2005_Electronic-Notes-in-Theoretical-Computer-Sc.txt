cyclic debugging is still an important means to locate the source of a fault in a program. non-determinism of any kind makes cyclic debugging difficult. in programming languages such as java or c#, concurrency adds an important source of non-determinism. however, most debuggers provide limited support for debugging multi-threaded applications.



programs. several solutions that capture and deterministically replay the execution of a multi-threaded application have been proposed for java[5,10,15]. the above approaches provide an integrated solution for capture and replay. in this paper we present a separate replay facility. it can enforce a thread schedule as it might occur during the execution of a multi-threaded java application on a uniprocessor. the replay facility is independent of a specific virtual machine, i.e., any compliant virtual machine can be used for replay. replay is achieved by instrumenting the class files of the application



section 2 gives an overview on related work. the format of a thread schedule is detailed in 3. section 4 explains the mechanisms used by our implementation. results on the performance of the replay mechanism are stated in section 5. in section 6 we outline a more general format for thread schedules. the last two sections discuss open aspects and conclude.



russinovich and cogswell reconstruct the scheduling of an execution on a uniprocessor by putting all but one threads to sleep to achieve replay for the mach operating system. our basic approach for replay and representation of a thread schedule is probably closest to theirs. they use a software instruction counter, i.e., the number of backward control transfers and the current instruction pointer to decide when a thread switch should happen, while we directly count the executions of an instruction. the implementation is based on a modified debug version of the mach system libraries. an application needs to be compiled with a flag that keeps one of the processor registers free to hold a counter for the backward control transfers. then, as in our approach, assembly files are instrumented, linked with a debug library, supplied with a schedule file, and can be executed in an existing debugger.



we only cover replay of non-determinism introduced by concurrency. a description of a prototype of a tool for java that replays other forms of nondeterminism is given by steven et. al.. in principle, our schedule format is flexible enough such that additional commands to replay input/output behavior or random numbers could be incorporated.



if a thread terminates, a thread switch has to be performed. however, the dying thread must not be blocked. a command die is used in this case. the replay engine waits for the dying thread to terminate until it hands control to the next thread. a terminate command can be used to unblock all threads and disable replaying. if performed before the proper end of execution, this may leave the application in an inconsistent state. if the end of a schedule is reached without executing terminate, the last switched to thread continues. finally, a log command can be used to print messages.



to replay a schedule the replay engine ensures that only the thread specified by the schedule may proceed in its execution. the remaining threads are kept in a blocked state. each location in the application where an action should occur at some point in the schedule is instrumented with a call to the replay engine. the engine checks with the schedule whether the next location and the specified counter value has been reached. if this is the case, actions following the event command are performed. in the case of a thread switch the next thread according to the schedule is unblocked by the current thread that thereafter blocks itself.



isinterrupted are therefore replaced with calls to the replay engine. at the level of the virtual machine neither notification nor joined state are the same during replay as during the original execution. instead, the state of a thread is tracked in the replay engine, the substitutes to interrupt, interrupted, and isinterrupted use that information to replay the original behavior. not emulated is behavior w.r.t. interruptible channels and selectors.



when a terminate command is processed in the schedule all threads are unblocked. thus, threads that were blocked due to an invocation of wait or join will continue with their execution even if they should remain blocked according to the original trace. if the schedule ends without a terminate, the replay engine remains active, as does the last thread that was switched to; threads that were left blocked remain blocked.



in this section we briefly describe how to capture execution traces on the fly. we then report on a series of experiments that indicate performance and portability of our replay engine. finally, we mention an extension of java pathfinder that generates schedules for replay.



a schedule can be generated easily on the fly during an execution of a java application if the virtual machine offers a means to invoke a user-defined routine after each executed bytecode. the virtual machine needs to provide information on the last and next threads and the last and next bytecodes of the last thread as well as on the state of each thread. it then suffices to count the number of times each bytecode is executed between two events and to log corresponding events and actions. for proper replay thread switches, calls to notify, time-outs, thread deaths and deadlocks must be included. a corresponding procedure is given in appendix c.



the replay engine and instrumentation facility are part of the jnuke project of the formal methods group at eth. goal of jnuke is to develop a framework for dynamic and static analyses of java bytecode. as first component a virtual machine for java was implemented that allows rollback of execution steps to explore different thread schedules as was done by rivet. on top of the vm, the eraser algorithm is used to check for data races. an algorithm to dectect high-level data races has already been implemented. work in progress aims at performing rollback also for input/output events.



source code debugging is preferable in most cases. transparency can be achieved in this case(see sect. 5.2.2). however, some concurrency errors will only be understandable at bytecode level. thus, transparent stepping through bytecode would be desirable as well. this could be implemented by providing an additional attribute in class files that tells a debugger which bytecodes belong to the original application and which have been added or removed for replay.



