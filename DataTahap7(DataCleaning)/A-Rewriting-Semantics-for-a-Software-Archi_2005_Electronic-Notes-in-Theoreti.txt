cbabel is an adl that, besides the usual architectural primitives such as components and ports, provides contracts[33,16,4] as first class constructions. in that way, coordination aspects can be described with cbabel contracts. basically, the designer can describe mutual exclusion properties constraining the use of input ports, or in-ports for short, of a functional module and specify guards to govern synchronization and consistency properties for those in-ports. the described coordination aspects are encapsulated in connectors that mediate all interactions among functional modules. with this approach, we separate coordination aspects concerns from functional aspects, which do not need to be included in the design or implementation of functional modules. in fact different instances of a same component can be submitted to distinct coordination specifications.



the remaining of the paper is organized as follows. section 2 exemplifies the cbabel syntax. section 3 gives the necessary background in rewriting logic and object-oriented rewrite theories in maude. section 4 defines the rewriting semantics of cbabel. section 5 presents the execution and verification of cbabel descriptions in maude using the cbabel tool. in section 6 we discuss related work. section 7 concludes this paper with our final remarks.



in the producer-consumer-buffer example there is a producer willing to access a buffer, which may be bounded, to add an item it has just produced, and a consumer willing to access the buffer to consume an item from the buffer. there are at least two problems in such a situation:(i) the producer and the consumer should not access the buffer at the same time, which is the so called race condition, and(ii) the buffer is bounded and the producer should not add more items than the buffer can hold and the consumer should not remove an item from an empty buffer.(actually, in section 5, we also check for deadlocking.)



the declaration of ports also includes rules in the associated rewrite theory. however, the treatment for rule generation is different for modules and connectors since connectors, as opposed to modules, declare contracts that coordinate the interactions, that is, the message flow among the objects that represent an architecture instance, also know as a topology. in the reminder of this section we will explain how rules are derived from port declarations in modules and section 4.3 will give a detailed explanation on how rules are derived from port and coordination contracts declarations in a connector.



and apples with dollars and quarters, inspired by the example presented in. a cake costs a dollar and an apple three quarters. one may insert dollars and quarters but the machine only accepts buying cakes and apples with dollars. when one wants to buys an apple, the machine takes a dollar and returns a quarter. the machine can also group four quarters into a dollar. the modules buy-apple, buy-cake, add-dollar and add-quarter represent the concurrent events that may be executed in the machine. the sold-apple and sold-cake connectors must guarantee that apples and cakes are sell when pro-



in this paper we have given a rewriting logic semantics for cbabel, a software architecture description language. cbabel components are understood as rewrite theories, or more specifically, as object-oriented modules is our maude implementation. the rewriting logic semantics maude implementation gave rise to the cbabel tool prototype, which allows cbabel software architecture descriptions to be executed and verified as rewrite theories in maude. the use of cbabel tool is exemplifies by means of two examples:(i) three variations of the producer-consumer-buffer example with the verification of the properties of race condition, deadlocking, and buffer overflow and underflow; and(ii) a vending machine architecture, verified its correct design.



