there have been only a few results on the formal analysis of group management protocols(e.g., pereira and quisquater analyzed a-gdh and meadows discovered security flaws in early versions of gdoi). the analysis of group management protocols poses new challenges for formal analysis techniques. new language features and models are necessary to appropriately capture the concepts of such protocols. mucapsl(multicast common authentication protocol specification language) and its intermediate language mucil(mucapsl intermediate language) have been designed to meet these needs. the underlying design principles are



mucapsl and mucil are extensions of the capsl and cil protocol analysis effort for unicast protocols[5,6,4]. mucapsl provides high-level specification concepts for multicast security protocols,such as message passing using unicast and multicast addressing, group membership data, and basic cryptographic operators. mucil is closer to state-transition representations of protocols. it serves two purposes: to help define the semantics of mucapsl in terms of multiset term rewriting,and to act as an interface through which protocols specified in mucapsl can be analyzed by using a variety of tools. the emphasis in this paper is on mucil and its term rewriting semantics.



we will illustrate the ideas of modeling group communication protocols with the help of the group-diffie-hellman(gdh) protocol suite. an overview of gdh is given in section 2. a semantic framework for multicast protocols is provided in section 3. rewrite rule generation is covered in section 4. section 5 describes future work.



we illustrate the semantic model with the help of the group diffie-hellman(gdh) protocol, which served as the basis for the cliques protocol suite[13,14]. gdh is an extension of the two-party diffie-hellman key agreement scheme to an arbitrary group size. the gdh protocol suite consists of a key distribution algorithm and protocols for member addition and deletion. for the purposes of this paper, we chose the key distribution protocol as an example because it incorporates unicast messages addressed to a particular group member as well as broadcast messages addressed to all group members. the group key in gdh is computed from secret contributions from each



these diagrams abstract away many important details, such as how received messages are stored, when new key contributions ni are computed, and how messages are composed. those details are part of the mucapsl specification and can be found in. the graphical notation is only meant to give an overview of the relevant protocol roles and to illustrate the main message flow and message content.



a message fact has the form mmsg([...]), where the terms represent the message fields. we do not keep sender or receiver addresses in message facts because these addresses make no difference from the viewpoint of security analysis, since an active attacker can always forge addresses. there is also no difference between a unicast message and a multicast message, since an attacker can either rebroadcast a unicast message, or prevent any message, multicast or not,from reaching more than one,or any,destination.



here, m1 is not a role name, but rather a variable of type gdhagent, even though this identifier was borrowed from the role name given in the specification. the role name keydistm1 is a constant produced automatically by combining the protocol and role names. we have to do this because role names are not unique across protocols. this example has no component terms because the role does not need any session-specific memory; it uses and modifies the group member memory only.



because group member state components persist across protocol sessions, they are never considered undefined, but are always treated as held. however, unlike agent state variables, they may be updated during any protocol session. in fact, they could conceivably be updated several times by one role or concurrently by two or more agents of the same group member.



in both cases, the agent state label is incremented. a receive transition may also modify components of the member and agent states. note that the member and agent state facts are tied together by reference to the same group member.



according to the semantics of rule firing, a receive rule removes the message fact from the multiset. if the message is supposed to be multicast, how does more than one group member receive it? there are three choices for the answer. one possibility is to change the rule to include the same message fact on the right,so that it will be preserved for other recipients. this redundancy was considered undesirable because it clutters the rule generator output. alternatively, we could just make an exception in the mucil rule semantics for message facts. finally, we observe that no exception is necessary to preserve state reachability, since the standard attacker is assumed to be able to duplicate messages.



the implementability algorithm determines what an agent must do to send or receive a message(multicast or unicast), and passes judgment on whether the explicit and implied actions are possible, given the current state of the agent. the state transition rules are, in effect, the product of the implementability algorithm. a failure of implementability implies that a rule cannot be generated that correctly models the event.



where m is of a subtype of groupmember having attributes a,b,..., and so on. we assume that there is only one member state per principal and group. this assumption is important because it eliminates ambiguity as to which member state is affected by role transition rules. this uniqueness assumption should be expressed by the if-condition. it is awkward to express because it refers to the entire multiset of facts. the rule generator does not attempt to produce member initialization rules.



an assumption on member attributes serves the purpose of identifying which roles it may execute. for example, in gdh, role m1 is the only role possible when pos= 1. assumptions constraining attribute values become if-conditions for the initialization rule for that role.



one might also ask whether it is possible to create more than one agent instance for the same role. this is possible with the formalism but usually considered undesirable. the protocol specification can prevent concurrent role duplication by explicitly adding a semaphore attribute to the member state. this sort of concern is described further below when we discuss the abort operation.



in the prelude, the most general object type is object, and its most important subtypes are boolean and field. an object of type field can appear as a message content field. field has a subtype atom containing familiar object types such as principal, nonce, and nat(natural numbers), and some cryptography-specific types such as pkey(public key). nonatomic fields are formed, for example, by concatenation using the constructor cat. the prelude declares the public-key encryption operator ped and the symmetric-key encryption and decryption operators se and sd. arithmetic operations are defined on type skey for finite-length symmetric keys.



where v in mmsg takes the place of at(a,n) in the message,and with updates an array by replacing one element at a given index. notice that v is a new dummy variable of type field. it is not allowable to receive an event at(a,n) if a is a state variable because state variables can be set only once, and that must be with an entire array object.



however,this is cheating,because there is no function type in mucapsl. function symbols like f do not have a type,so update is not a real function, because it does not have a legal signature. depending on the expressiveness of a tool or analysis technique,means to handle update predicates in rules have to be found individually in the context of each analysis technique or tool.



where m, r, n, and t are all variables,so that any single nonabort agent state is matched and terminated. the single-threaded property can be guaranteed by adding an invisible semaphore attribute,and modifying initialization transitions(except for the abort role) to test and set it, and terminating transitions to reset it. in mucapsl, giving a groupmember subtype a mutex property causes the semaphore to be added by the translator.



to make mucapsl useful to protocol analysts,we need to make translation tools as well as documentation available. we are currently in the process of finishing the mucapsl-mucil translator that parses and typechecks mucapsl specifications and generates mucil rules for the protocol. in particular, we will add an optimization stage to combine successive mucil rules when possible,as we have done for cil.



