while these models and tools are useful for teaching and learning programming, there is continuous need to create more tools for supporting novices, targeting specific programming constructs. studies have shown that practice improves programming ability. we also know that constructs such as nested loops are often difficult to comprehend for novices[3,18]; hence, the problem addressed in this paper is the synthesis of nested loop exercises. the synthesised exercises can be manually solved with pen and paper as a practical support for novice programmers. to do this, we have designed a context-free grammar(cfg) for the formalisation of specific syntactic patterns for nested loop exercises. we have also designed algorithms that makes use of the cfg rules in rendering valid nested loop exercises. these rules and the resulting exercises are targeted for python programming language, as this is one of the most used languages in introductory programming around the world today.



the remainder of this paper is organised as follows. section 2 presents background information and section 3 discusses related works. section 4 presents grammar design for the synthesis of nested loops and section 5 explains the algorithms for loop synthesis. section 6 describes the implementation and results, and section 7 presents evaluation. section 8 presents the conclusion and future work.



in this section, we discuss the difficulties faced by novices in learning how to write computer programs. we starting with general difficulties to specific ones around the comprehension of nested loop structures. we further discussed the importance of loops and highlighted the motivation behind this work.



students often struggle with the practical understanding of loops in introductory programming modules[3,18]. they find it difficult to understand the process of program iteration. some of the difficulties with loops faced by novice programmers include: misconception of loop construct and loop execution, and difficulties in solving problems with the use of a loop constructs. when loops are nested, it becomes more difficult for novice programmers to understand.



this work is motivated by these challenges and needs in learning programming. we have devised a formal technique(based on a cfg) for synthesising exercises of nested loop problems that novice programmers can use as practical problems. in the next section, we present research works that are related to this study.



context-free grammars(or cfgs) are a class of formal languages that can be used to, formally, specify context-free languages(cfls). the formal definition of cfgs is presented in section 4.1. we have used cfgs as a medium of expressing the rules for formulating new problems in nested loops, for the following reasons:



formal languages and automata theory(flat) is a well known aspect of theoretical computer science. this aspect has also been known to have many mathematical or computational theories with little or no real life applications. however, adopting an aspect of flat(cfgs) in this work shows that flat can find new applications in topics like procedural content generation, and computer science education.



the syntactic definitions of programming language recognisers and parsers are done with cfgs. this is preferred over regular languages(or rls) because it handles more complex structures such as the language of balanced parenthesis. the use of cfgs in parsing programming languages is not new, and like any other formal language, they can be used for both recognition and generation tasks. the application of cfgs for recognition can be found in compiler constructions, and its applications in generation can be found in ade-ibijola.



artefacts gulwani synthesised a range of objects with interface models and algorithmic methods for repetitive drawings and mathematical concepts(such as algebraic identities, bit vector algorithms, compass based geometry constructions, etc.). ade-ibijola proposed an algorithm for the automatic generation of hypothetical social network graphs that were graphically rendered using the microsoft automatic graph layout api. this algorithm produced random hypothetical names as vertices, and random directed edges connections between them. sunbeom and hakjoo developed a tool for the generation of different patterns of characters through synthesis of pattern program. the algorithm synthesised the desired program through the integration of enumerative search, constraint response, and program exploration. another work by ade-ibijola



some of the terms used in this section include: symbol, alphabet, string, and context-free grammar(or cfg). we define these terms as follows. a symbol is an item or single token; an alphabet is a finite set of symbols; strings consist of a concatenation of zero or more symbols(when it is zero, its called an empty string, represented as k), and grammar(g) is a formal way of representing rules describing the syntax of a language.



able initialisation(this is done with a function presented in algorithm 1). rules 5 and 6 describe statement blocks. in rule 5, variables are initialised first, and these variables are used in arithmetic expressions or as an alternative, logical expressions are generated with boolean variable initialised in rule 4. rule 6 allows for an optional statement block to be generated. this is later used in building nested loop programs that may or may not have statement blocks in specific parts of the source code. rule 7 enumerates the types of loops covered, and this is passed to rule 8 for the synthesis of an actual loop instance using the function getloopstatement(), defined in algorithm 2. to maintain the structure of a nested loop, the newline and tab characters are combined in rule 9 to manage indentation of code.



at this stage, a question that comes to mind is: what if we want more than two sub-loops? or, what if we want to define these rules such that it allows infinitely many sub-loops to be derivable from the start symbol? hence, it becomes compelling to define the subloops recursively. rules for this is presented in section 4.4.



in this section, we present an algorithm(algorithm 1) for the generation of loop types defined earlier in rule 7. algorithm 2 describes the getloopstatement() function used to perform the operation defined in production 8. this algorithm takes five parameters described on line 1 and returns a loop statement. one line 2, a syntactic end of line character in python is initialised, and the loop string is set to null on line 3. the switch statement that begins on line 4 allows for a selection of loop type. loops



algorithm 3 traces the steps of derivation of the grammar, g. this algorithm takes the number of loops to be derived as a parameter and returns a list of these loops. at each step, it attempts to replace all nonterminals in the grammar rules with terminal productions or symbols. line 10 adds the final string derived from g to a list of nested loop strings. this list is returned on line 13.





the survey included 210 university undergraduates, both firstyear students(87.7%) and returning or old students(13.3%). the sample population consists of male and female students of computer science and other relevant courses who are taking the introductory programming course for the first time and those who have previously taken it. this audience is appropriate for the study since the goal of the research is to aid novices in overcoming challenges in program comprehension.



the findings show that a large proportion of the students involved in this survey are at the early stage of learning programming including those who are currently doing the course and those who did it before. computer programming courses have been shown to be difficult for the majority of students to learn, particularly the use of loops, suggesting that students need the support of learning aids. this result compare well with the reports of[3,26] which indicated that students struggle to understand nested loops at early stage of programming. the synthesised nested loop exercises were correctly formulated and are solvable with pen and paper, indicating that the tool was well-designed to achieve the purpose of the study. by practicing the generated exercises, novice programmers can learn more about the use of loop statements in programs, making it easier for them to improve their programming skills in python. this finding agrees with the suggestion of that practice improves programming ability.



