the mondex formal development featured a refinement proof from an atomic abstract model to a multi-step protocol at the concrete level. the principal component of this refinement proof was a backward simulation from abstract to concrete. at the time of the original development, the development team did try to construct a forward simulation, but were not successful. for a long time it was believed that a forward simulation refinement was impossible. it is by now known that a forward simulation is entirely possible, and more than one has been constructed[3,22,12].



in this, the original framework, the backward simulation correlated with an early synchronisation, i.e. the single non-trivial abstract step was(1, 1) matched with a step that occurred early in protocol runs. by contrast, the more recently discovered forward simulations correlate with a late synchronisation, namely, the various possible non-trivial abstract steps are(1, 1) matched with steps that occur late in protocol runs.



the preceding described the workings of a successful run of the protocol. beyond that, all events after the start events can be replaced by abort events, corresponding to runs of the protocol that are unsuccessful for whatever reason. the fact that despite abort events, the protocol still enjoys the unforgeability and atomicity properties, is what makes mondex non-trivial theoretically. however, the details of how this comes about do not concern us in this



a further issue is that the mondex protocol is isolated, i.e. once the protocol has commenced, the two purses take note only of the arrival of the next message expected in the playout of the protocol, and of calls to abort, ignoring all other messages or calls from the environment and reserving the option of responding to such unexpected events by performing a self-initiated abort whenever appropriate.



for(15), we note first that by assumptions 3.1.(iii), vt is reachable from some initial vi. we use this to assert a ui such that rp(ui, vt) holds, after which we argue as for case(13). we are done.



definition 3.4 given an initial vi, a synchronisation assignment(sa(vi)) for the relevant valid subtree of a protocol computation tree is a subset of its steps, such that for each maximal path through the valid subtree from vi, exactly one of its steps is in sa(vi). steps in sa(vi) are called sa steps.



our aim is to show that when given a big-diagram refinement of an atomic action to a protocol of the kind we have described, if we wish to break the big-diagram refinement down into a collection of small-diagram refinements of zero or one atomic action steps to individual steps of the protocol, one can always use forward simulation reasoning, except for the bs steps. in fact one can use forward simulation reasoning for all steps except branching bs steps(a term explained below), though it comes at a price. likewise, we have the option of using backward simulation reasoning for all steps if we so wish. we discuss these points later.



since at both abstract and protocol levels, the transpose of the step relation is a partial function, backward simulation is always aligned with a decrease of nondeterminism in both abstract and protocol transition functions. therefore we get the following(cf.).



firstly, it is illuminative. one can be convinced of the correctness of a protocol with respect to an atomic action, without having the details of a refinement already worked out. in such a situation, it may not be clear how to synchronise the atomic action with the lower level description. theorem unique successor cannot force a distinction between the choices for uf. so for nonbranching bs steps, a forward simulation inference will succeed. however, it comes at a price. if a forward simulating bs step immediately follows a backward simulating bs step, the r1(uf, v) value at the v state that they share, occurs as a hypothesis in both the backward po(20) and the forward po(19). it thus remains as an unproved assumption in the overall single-step verification of the big-step refinement. as such it allows the verification to succeed vacuously. for this reason we phrased theorem 3.7.(ii) as two inductive processes that meet in the middle, since it is much better to verify some r1(uf, v) twice independently, than to leave some other r1(uf, v) unproved, thus undermining the whole verification.



the basic idea is that the previous section should be understood as describing(the various possibilities for) a single isolated protocol run, performed by however many agents would be appropriate in practice, with the protocol state recording the full history of the protocol so far(regardless of whether such knowledge is obtainable in principle by the individual agents), and ignoring the rest of the universe. the latter not only regarding other agents/activities in the rest of the universe, but also regarding what the agents of the single protocol run might do both before and after the run itself. so the previous section described an idealised pattern or template for what collections of agents might do over some period of time towards the achievement of some goal described in principle by the atomic action that the protocol implements.



patterns or templates are normally made to correspond with what happens in the real world by some process of matching, and that is the basis of our approach too. since we have remarked that our protocol states can include unrealistically detailed history information, our matching process must include a projection mechanism to allow the unrealistic parts to be forgotten. in such a scenario, protocol states that were previously distinct can be matched to the same system state, destroying the previously assumed tree property of the valid subtrees that interpret the protocol. but this is ok. at the system level, we do not need the backward reachability properties that trees guarantee.



the decomposition into agent subspaces just described, represents the fact that an instantiation of a protocol is normally executed by a number of agents inside a real system. however a real agent in a real system can play many roles during the running of the system, including acting out different roles in different instances of the same protocol at different times. so we need to distinguish the various agent roles in a protocol definition from the different instantiations of these during system runs. the next definition introduces the technical machinery for this.



which is 2p. an external dependency definition(xdd) for them is, a pair of sets(ids, ods) of(not necessarily disjoint) steps. ids is the input dependency set, and ods is the output dependency set. a protocol is xddnormal iff:



the different choices for the synchronisation points was one motivation for us to study the general possibilities here. another one was to provide a general formalization of using past and future simulation relations(rp and rf). instances of such relations with a schematic encoding into dynamic logic are not only used in the case study but also in earlier work. future simulation relations occur in the correctness proof of asm refinement. past simulation relations are used in coupled refinement as noted in.



