queueing network formalisms are very good at describing the spatial movement of customers, but typically poor at describing how customers change as they move through the network. we present the pepa queues formalism, which uses the popular stochastic process algebra pepa to represent the individual state and behaviour of customers and servers. we offer a formal semantics for pepa queues, plus a direct translation to pepa, allowing access to the existing tools for analysing pepa models. finally, we use the ipc/dnamaca tool-chain to provide passage-time analysis of a dual web server example.



however, while queueing networks are very good at representing the broad structure of a system, they are typically weak at describing the evolution of the individual customers within the network. indeed, it is quite common to treat all customers as opaque, indistinguishable entities. these customers have no individual internal behaviour but may be segregated into a small set of static classes, when needed.



choice the component p+q represents a system which may behave either as p or as q. the activities of both p and q are enabled. the first activity to complete distinguishes one of them: the other is discarded. the system will behave as the derivative resulting from the evolution of the chosen component.



token is the state of a pepa component. this state can change as the system evolves either independently, or in cooperation with their neighbouring components. the places on the net are typed with a component name; they may only be occupied by components that are derivatives of that type. net-level transitions have associated action-types and rates. components move in the net when a mobile component performs a net-level transition action, in cooperation with the net itself, to move into an appropriately typed empty slot.



pepa nets are a good example of a higher level formalism. as well as having their own explicit semantics, they may also be compiled into pepa, and so analysed with the existing array of pepa tools. this inspires our approach for pepa queues, where we embed pepa components in a queueing network, rather than a petri net.



note that the state of a pepa queue is given by the current state of each of the components waiting in the queue, in order, and the state of the local component. this cannot typically be represented by a vector of buffer occupancies, as would be the case with typical, opaque customers. it is instead akin to having a multi-class queueing network where the class does not influence the queueing discipline.



network therefore has a fixed and finite population of customers. there are no losses when destination queues are full; queue services that lead to full queues are blocked. handling open networks, unbounded buffers, triggers and negative customers is desirable, but the translation into pepa of these entities is less straightforward. here we focus on a simple core, which we can build upon in the future.



although we allow cooperations at the network level, they should be used with care. the intention is to use the queueing network to separate local behaviour from spatial migration. allowing network-level interactions breaks this separation, but can be put to good use for inherently global actions like closing down the whole system, and a variety of forms of reset. typically we would have, as in the example above, a straight parallel synchronisation between the queues.



pepa queues allow a succinct expression for many queueing mechanisms. for example, we could model breakdown and repair in a network of pepa queues as follows, allowing individual servers to fail and be repaired, or with a global reset if all the servers have failed. we omit the definition of the customers, p, for brevity.



we do this by converting pepa queues into pepa. every pepa queue model can be mechanically rewritten as a pepa model with no change in its behaviour. some of the structure of the original may be obscured in the compiled pepa model, so tools will typically prefer to work with the pepa queues directly.



declares that in order for a customer to move between queues, the server component at the first queue must perform a routing action, leading to a queue which has at least one space. the moved customer moves to the first empty slot. where n is the largest such n to describe the blank spaces in q: b. routing actions may not appear in the inter-queue cooperation set, lq.



note that we do not allow cooperation between the queues for routing actions. if we did then we would be including a potentially interesting class of synchronised, coupled queues but at the expense of a substantially more complex translation. with our present translation, we use the names of the routing actions, decorated with where they are occurring to provide us with global, unique names for each of the routing actions. if we allowed cooperation at this level, we would need some other mechanism for migrating components. it may be possible to extend still further the information we carry in the expanded action names, but needing to represent which pair of processes is cooperating in the action name would lead to a large explosion in the number of names used. we could conceivably use a synchronous immediate action to achieve these coupled queues, but we would first need to define that concretely.



note that to be allowed to move, the destination slot must be empty. this means that in the example from sect. 3.1, when all four customers are in queue a, the redo action is disabled. even though there would be a free slot after the lead customer moves, there is not one until then. if we allowed this form of movement it would give preferential treatment to customers coming from the same queue. that is, a customer would still be able to move to the back of its own queue, while arrivals from other queues were blocked.



the server components are altered to account for the expanded names of routing actions and to ensure that the local cooperation actions are distinct for each queue. so, for a server component, s, residing at queue a, we make a new component sa. the local cooperation set at a is la. for each action-type, a, that s performs, there are three cases:



for case 1, we do not need to modify the action at all. for case 2, we add the queue name to the action name, to ensure this action cannot occur when a customer is at a different queue. for case 3, we replace each occurrence of a with a choice of new action-types representing all the destination slots the action could lead to. we denote these four sets of action names l1, l2, l3 respectively.



suppose that the queues are named a, b,..., z, that the initial populations at each are a, b,...,z and that our initial customers are a p at queue x at position i', through to a p' at queue y at position j'. the cooperation set between all the queues is lq.



the server spage doles out pages and the server simages serves images. after spage has issued a getpage, it releases the client from the first queue, a, with the send action, which routes the client on to the next queue, b(only if there is room in the downstream buffer for that client). the simages server, after sending images to the client, then does some internal processing before issuing a repeat action which routes the client back to the first buffer again.



in this paper, we have introduced pepa queues, a formalism for expressing individual customer behaviour and routing in queueing networks. queueing customers are described in pepa, as are individual servers in the network, with interactions between customers and servers deciding the exact routing pathway for a customer. this synergy of a behavioural description and a spatial formalism is similar to pepa nets but is obviously tailored to situations where queueing models would be a more appropriate spatial formalism.



inter-customer cooperation in some real-world systems, the customers may cooperate with one another in the queue. this may be a reasonable way to represent negative customers. these cooperations could be just between neighbours or amongst all the customers awaiting service. zero-automatic queues, for example, allow neighbouring customers of a shared group of classes to interact and coalesce into a single customer.



