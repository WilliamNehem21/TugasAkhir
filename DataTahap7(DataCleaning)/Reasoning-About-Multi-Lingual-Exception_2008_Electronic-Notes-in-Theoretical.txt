the last two lines of the java class are declarations that methods f and h have the signatures noted and that they are native, i.e., they are not written in java, but are c or c++ procedures to be found in some shared library.



since the programmer is going to use the jni to assemble these two pieces, the next step is to run javah, the jdk tool supporting jni use. given the a class file as input, javah will produce a file called a.hh containing prototype declarations for the native methods of java class a. these prototypes specify two procedures, java_a_f and java_a_h, which are the names that the jni expects for the implementations of the f and h native methods of the class a.



languages using the same programming language system(pls). we distinguish between programming languages, such as java, and plss, such as the jvm, which can potentially support multiple programming languages. the major contribution of ripls is the ability to reason about multiple plss, e.g., a jvm and a c++ runtime system.



ripls is defined in the usual way with an abstract syntax, typing rules, an abstract machine and a set of transition rules(an operational semantics). the language has been proven(with mechanically-checked proofs) to be type-safe and to make progress. in this section we will introduce the type system of the language and show the portions of the definition that are interesting or unusual. the full language is given elsewhere. in the next section we will discuss how the language is used.



the ripls language uses effects and mechanism annotations to allow us to reason about distinct plss. in this paper the only effects we are interested in are exception effects; these are created when an expression raises(throws in java and c++ terminology) an exception, and are retracted by exception handlers. this is an unusual use of effects; the authors are unaware of other systems that retract effects, and yet it seems the most natural approach for our purposes. if an exception is always handled inside a particular expression, does it really have any effect outside that expression? we use mechanism annotations to deal with the related issue of whether a particular expression is able to raise an exception. we distinguish paper, but leaves room for future extensions. we assume that there are a set of stack continuation mechanisms of interest, but do not specify them; similarly, we assume an unspecified set of exception-handling mechanisms. these abstract mechanisms serve as tags; indicators that at run-time an actual mechanism of the appropriate variety will be available. in a sense, they are like types for values. continuation mechanisms are always stack-based in this paper. we say that a mechanism is a control mechanism if it is a continuation mechanism or an exception-handling mechanism; these are the only mechanisms that can have an effect on the control flow of the program. finally we talk about primitive mechanisms. currently the only primitive mechanisms are control mechanisms; in the future we will add memory mechanisms, and possibly others.



note the form of the names of the function called. they begin with the string java_ followed by the name of the class, then by another _, then by the name of the method. if the method were overloaded there would be another part to the name indicating the type of the arguments. the result of this style of name, which is chosen by the jni, is that programmers end up writing glue code, an extremely simplified snippet of which follows:



as we saw in section 2, the java and c++ code shown does compile and will run, but will misbehave. when we translate that code into ripls and attempt to type-check it, the type-checking fails, indicating that there is, in fact, a problem with the combined java and c++ code. this problem is undetected by the java and c++ compilers, which only analyze their respective pieces of the multi-lingual system. we conclude that our methodology of translating the components into a common formal language and analyzing the resultant program will expose problems that are not exposed by conventional tools.



of course, our formal foundations will be most valuable to practicing programmers if those foundations can serve as a basis for practical methods or automated tools to assist in the development of correct systems comprising interoperating components written in different languages. we have begun working on such methods and tools and have demonstrated some initial prototypes, improving on our earlier exu and jexu tools, that are informed by the formal foundations described here and that automate the generation of correctly interoperating java and c++ classes even when those classes use exceptions. these preliminary results reinforce our belief in the importance of solid formal foundations to our long-term goal of maximally effortless and error-free multi-lingual programming.



given the promising results reported here, where use of our ripls formal foundation enables rigorous analysis of an important aspect of multi-lingual objectoriented programming, supports identification of a problem that occurs in real uses of exception handling and informs the design of automated tools for multi-lingual programming, we are pursuing future development of both the formal foundations and pragmatic tools. we plan to produce additional extensions to ripls that will focus on other aspects of multi-lingual object-oriented programming, with the goal of providing a complete treatment of interoperation in the c++ and java environment. at a minimum, the set of such extensions should include method dispatching(single-dispatching) and parametric polymorphism. in addition it ought to be possible to extend ripls to support other things such as differences in memory models: garbage collection versus explicit memory management.



