typically, for efficiency, the underlying abstract domains used in value analysis are based on conjunctions of linear constraints, e.g., polyhedra, octagons, etc. while in practice these abstract domains are precise enough for bounding the loops of many programs, they are often not sufficient when the considered program involves non-linear arithmetic operations(multiplication, division, bit arithmetics, etc). this is because the semantics of such operations cannot be modeled precisely with only conjunctions of linear constraints. in order to overcome this limitation, one can use abstract domains that support non-linear constraints, however, these domain typically impose a significant performance overhead. another alternative is to use disjunctive abstract domains, i.e., disjunctions of(conjunctions of) linear constraints. this allows splitting the behavior of the corresponding non-linear operation into several mutually exclusive cases, such that each one can be precisely described using only conjunctions of linear constraints. this alternative also imposes performance overhead, since the operations of such disjunctive abstract domains are usually more expensive.



in this paper, we develop a value analysis that handles non-linear arithmetic operations using disjunctions of(conjunctions of) linear constraints. however, similarly to, instead of directly using disjunctive abstract domains, we encode the disjunctive nature of the non-linear operations directly in the(abstract) program. this allows using non-disjunctive domains like polyhedra, octagons, etc., and still benefit from the disjunctive information in order to infer more precise relations for programs with non-linear arithmetic operations. we have implemented a prototype of our analysis in costa, a cost and termination analyser for java bytecode. experiments on typical examples from the literature demonstrate that costa is able to handle programs with non-linear arithmetics that could not be handled before.



value of z1 in the output variable r. note that z1 refers to the value of z upon exit from procedure m2(the loop), it is generated by the ssa transformation. procedure m2 corresponds to the while loop, and is defined by two mutually exclusive rules. the first one is applied when the loop condition is evaluated to false, and the second one when it is evaluated to true. note that m2 has two output variables, they correspond to the values of y and z upon exit from the loop.



in this paper we follow the analysis approach used in, which divides the value analysis into several steps:(1) an abstract compilation step that generates an abstract version of the program, replacing each instruction by an abstract description(e.g., conjunction of linear constraints) that over-approximates its behavior;(2) a fixpoint computation step that computes an abstract semantics of the program; and(3) in the last, we prove termination or infer bounds on resource consumption using the abstract program of point 1 and the abstract semantics of point 2.



abstract procedures avoids merging the calling contexts, which usually results in a loss of precision. in addition, non-linear arithmetic instructions that do not affect the termination of the program can be abstracted as before, i.e., to{x= t}, and thus avoid the performance overhead caused by unnecessary auxiliary abstract procedures. these instructions can be identified using dependency analysis, similar to what have been done in for identifying program variables that affect termination.



procedure add pre adds a new pre-condition for q if it does not imply the current one, and adds the corresponding event to q. procedure add post adds a new post-condition for q if it does not imply the current one, and adds events for all procedures that call q since they might have to be re-analyzed. note that both procedures use the least upper bound h of the underlying abstract domain in order to join the new preor post-conditions with the current one. note also that since we use abstract domains with infinite ascending chains, in practice, these procedures incorporate a widening operator in order to ensure termination.



costa, with the new value analysis, was able to prove termination of all benchmarks. note that without this value analysis costa could not handle any of these benchmarks. we have also analyzed the benchmarks using other termination analyzers for java bytecode. julia 1 was not able to prove termination of any of



in this paper we have described how we handle non-linear arithmetic instructions in the value analysis of costa. it is well-know that handling such operations is problematic when the underlying abstract domain allows only the use of conjunctions of linear constraints. it is also well-know that the use of disjunctive abstract domains is a possible solution to this problem, however, on the price of performance overhead. in this paper, instead of using disjunctive abstract domains, we encoded the disjunctive nature of non-linear arithmetic instructions into the abstract program itself. this encoding, when combined with a value analysis that is based on non-disjunctive abstract domains such as polyhedra or octagons, makes it possible to dynamically select the best abstraction depending on the context from which the code that correspond to the encoding was reached. our experiments demonstrate that costa is now able to prove termination and infer bound on resource consumption for programs that it could not handle before. for future work, we plan to improve the scalability of the analyzer, support overflow in arithmetic operations, and support floating point arithmetic. note that, given the latest developments in the parma polyhedra library, supporting overflow and floating point arithmetic is relatively straightforward.



