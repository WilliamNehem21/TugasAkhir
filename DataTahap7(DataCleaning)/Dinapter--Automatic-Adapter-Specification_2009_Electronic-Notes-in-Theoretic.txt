in this work we present dinapter 4, a tool for the automatic generation of specifications for behavioral adapters(adapters which overcome incompatibilities at signature and behavioral levels). dinapter accepts as input the behavioral interfaces of the components written in abstract bpel and it returns adapter specifications which describe how the mismatches(in signature and behavior) can be resolved. these specifications are used by other proposals[7,11] to generate the final adapter.



in the following section(section 2) we will present an example to illustrate how dinapter works. in section 3 we will explain the parameters of our tool along with several results obtained. we will comment on related work in section 4. finally, we will present future work and some conclusions in section 5.



dinapter accepts as input the behavioral description of the two components to adapt written in abstract bpel and returns a set of adapter specifications. internally, the tool uses a combination of an a* algorithm and an expert system. the heuristic function used by the a* algorithm and the expert system rules represent the adaptation policy used to generate the adapter specifications.



the integration within itaca has enhanced dinapter by providing it with more information about the similarities between the components to adapt. a comparison of the semantics behind the operations to adapt is provided by another tool(sim) which uses wordnet::similarity. the inclusion of this semantic information in dinapter enhances the matching of name-mismatch situations, improves the adaptation of event driven conditions(picks) by taking into account the underlying semantics, and it reduces the number of search steps needed to find a correct specification.



moser et al. developed a platform(viedame) based on activebpel for the monitoring and service adaptation of bpel processes. they dynamically replace services based on qos in a non-intrusive manner using aspect oriented programming. they use transformers for service adaptation but these transformers must be designed manually. their work can be complemented by our tool by automatically generating these transformers.



as regards automatic generation of adaptation specification, schmidt and reussner focused on the synchronization of two components accessing, or being accessed, by a third one. they introduced an algorithm based on synchronous product computation to solve missing message incompatibilities, but their approach fails to overcome signature mismatches and behavioral incompatibilities like missing messages or message splitting/ merging. autili et al. proposed a methodology for the automatic synthesis of adapters considering as input behavioral descriptions of components and a specification of the interactions that must be enforced in the system. then, their tool(synthesis) generates composition code that exhibits only the specified interactions, and prunes those which lead to deadlocks. similarly to, synthesis does not overcome name mismatches, and some behavioral incompatibilities cannot be solved, such as message splitting/ merging. in addition, their tool relies on a high-level description of the composition goal, and therefore does not work without such description.



let us now mention two related works[6,13] that tackled web services adaptation. in the first one, brogi and popescu outline a methodology for the automated generation of adapters capable of solving behavioral mismatches between bpel processes. in their adaptation methodology they use the yawl workflow as an intermediate language. once the adapter workflow is generated, they use lock analysis techniques to check if a full adapter has been generated or only a partial one(some interaction scenarios cannot be resolved). they solve message reordering incompatibilities but their approach fails with signature mismatches. in addition, even if we applied our approach to bpel services as well, our approach is able to work with abstract descriptions of components/services that can be extracted from abstract bpel but, due to its integration within itaca, it also accepts other languages and platforms like symbolic transition systems and windows workflows.



motahari nezhad et al. presented a schema matching tool called coma++ for assisting the developer to adapt new versions of existing web services based on the services wsdl signatures. dinapter has some similarities with their work(the heuristic used by our tool plays a similar role to their evidences) and they introduce some interesting ideas about deadlock handling. however, although they are able to generate a mismatch tree that gather all protocol mismatches, its resolution is not automatic.



in this work, we have presented a tool for the automatic generation of adapter specifications which overcomes signature and behavioral mismatches. the generated specifications successfully solve missing messages and they are able to merge and split messages depending on their arguments. there are several works in the literature[4,8,16] which use these specifications to automatically build behavioral adapters. traditionally, these specifications were manually written and they required the designer to fully understand the details of the components involved. our tool complements this previous work by automatically generating these specifications.



dinapter tackles behavioral and syntactic mismatches using a heuristic function, so it can still be misinformed by deceptive components where the behavior, arguments and operation names guide the generation process to a deadlock-free, yet invalid specification. however, we are currently working on including linear temporal logic(ltl) formulas in the expert system. in this way, dinapter will give us the option to further refine the specifications using both customized expert system rules and ltl properties.



