c++ template metaprogramming is often regarded as a functional language, however, nowadays metaprogram libraries are not implemented in functional programming style. in this paper we discuss a compile-time graph-rewriting engine based on the properties of the functional language clean. the most important property imported from the functional paradigm is the lazy evaluation strategy. with the help of the engine it is possible to embed lazy functional-style code into c++ programs, and transform it into template metaprograms. we present the implemented lazy evaluation strategy by examples including also infinite lists.



template metaprogramming is an emerging new direction in c++ programming for executing algorithms in compilation time. the relationship between c++ template metaprograms and functional programming is well-known: most properties of template metaprograms are closely related to the principles of the functional programming paradigm. on the other hand, c++ has a strong heritage of imperative programming(namely from c and algol68) influenced by object-orientation(simula67). furthermore the syntax of the c++ templates is especially ugly. as a result, c++ template metaprograms are often hard to read, and hopeless to maintain.



the paper is organized as follows: in section 2 we discuss c++ template metaprogramming, and its relationship with functional programming. lazy data structures, evaluation, and the template metaprogram implementation of the graph rewriting system of the clean functional language is described in section 3. in section 4 the transformation process of the eclean system is discussed in detail, section 5 discusses future work, and related work is presented in section 6.



programming languages). the most important applications of metaprograms are the implementation of concept checking(testing for certain type-properties of in compile-time), the implementation of data structures containing types in compiletime(e.g. typelist), the construction of active libraries, and many others.



despite all of its advantages tmp is not yet widely used in the software industry due to the lack of coding standards, and software tools. a common problem with tmp is the tedious syntax, and long code. libraries like boost::mpl help the programmers by hiding implementation details of certain algorithms and containers, but still a big part of coding is left to the user. due to the lack of a standardized interface for tmp, naming and coding conventions vary from programmer to programmer, which causes comprehensibility problems.



clean programs are represented by an expression graph in the compiler. this graph is rewritten automatically in several phases in runtime. the rewriting process is starting when the main function expression on the right side of the start symbol is evaluated.



our running example uses enumfrom. we defined the enumfrom constructor to create an infinite list starting at a certain number. the list[2..] can thus be written as enumfrom 2(or[2..]). of course to acquire the head element of a list we need to rewrite this expression to cons 2 enumfrom 3(or[2,enumfrom 3]),



as a rewriting rule has been applied, we return to the outermost expression which is now(f2). again, neither this whole expression, nor its first argument can be rewritten, thus the second argument sieve[2, enumfrom 3] is examined. the(r3) rule can be applied here with prime=2 and rest=enumfrom 3 respectively.



the above example presents very well the applied lazy evaluation strategy. in order to simulate the inner workings of the lazy functional programming language clean, the rewriting algorithm was implemented using tmp. the rewriting is effectuated by our engine, described in the next section.



the eclean expressions are represented by types and typedefs. in this approach the start expression of our example has the form take<mpl::int<10>,sieve<enumfrom<mpl::int<2>>>>. here take, sieve, and enumfrom are all struct templates having the corresponding signatures.



the sieve template has two parameters, prime and ys. this template describes the workings of(r3) in our clean example. in case a subexpression has the form sieve<cons<n,t>> where n and t are arbitrary types, the previously defined sieve specialization will be chosen by the compiler as a substitute for the subexpression. note that even though n and t are general types, the sieve template expects n to be a mpl::int, and t a list of mpl::int types.



however, in order to be able to apply this rewriting rule, an exact match is needed during the rewriting process. for example in(f1) during the evaluation process the previous sieve partial specialization will be considered as applicable when rewriting the subexpression sieve[2..].



the problem is that the argument[2..](enumfrom 2) does not match the sieve partial specialization parameter list, which is expecting an expression in the form cons<n,t> with types n and t. during the compilation the c++ compiler will instantiate the type sieve<enumfrom<mpl::int<2>>>. however this is a pattern matching failure which has to be detected. therefore each function must implement a partial specialization for the general case, when none of the rules with the same name can be applied. the symbol nomatch is introduced, which signs that even though this template has been instantiated with some parameter xs, there is no applicable rule for this argument. nomatch is a simple empty class.



the working mechanism of eval is as follows: eval takes one argument, an expression expr with one parameter t1. the type variable t1 can be any type, e.g. int, a list of integers, or a further subexpression. the return type result defined in line 13 contains the newly rewritten subexpression, or the same input expression if no rule can be applied to the expression and its parameters.



the priority of eclean rewriting rules cannot be explicitly defined as opposed to clean. in the eclean code if factorial 1= 1 alternative is defined under the general factorial n= n*factorial(n-1), then the specialized alternative will never match. however, in template form, due to the nature of the template instantiation mechanism, the factorial<mpl::int<1>> alternative will match even if defined below the general factorial. at this moment neither the parser nor the engine are capable of handling multiple matching. however, it is an important and interesting future development direction.



functional language-like behavior in c++ has already been studied. functional c++(fc++) is a library introducing functional programming tools to c++, including currying, higher-order functions, and lazy data types. fc++, however, is a runtime library, and our aim was to utilize functional programming techniques in compile-time.



the boost::mpl library is a mature library for c++ template metaprogramming. boost::mpl contains a number of compile-time data structures, algorithms, and functional-style features, like partial metafunction application and higherorder metafunctions. however, boost::mpl were designed mainly to follow the interface of the c++ standard template library. there is no explicit support for lazy infinite data structures either.



