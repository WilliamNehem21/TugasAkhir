software components are now widely used in the development of systems. however, incompatibilities between their behavioural interfaces may make their composition impossible. the objective of software adaptation is to compensate such incompatibilities building as automatically as possible corrective connectors or components. constructing component-based systems from scratch is difficult, in particular when components cannot be used directly since they have to be adjusted with respect to their mates. incremental construction methods are therefore essential because they make it possible to build systems step by step and therefore to master the complexity of their adaptation. in this paper, we propose an incremental approach to build component-based systems which relies on the generation of adaptors to overcome behavioural incompatibilities. the adaptation stage can be automated being given an abstract mapping formalising the properties of the system to be adapted.



software components are now widely used in the development of systems, including embedded systems, web services and distributed applications. the main challenges of component-based software engineering are composition, adaptation and verification of component applications. software adaptation[16,7] aims at generating as automatically as possible component adaptors. their role is to compensate incompatibilities appearing in a system constituted of communicating entities. it is now



building a software system from scratch is a difficult task even if one of the promises of the component-based approach is to make the reuse of existing software entities easier. moreover, composing components is a task which must take also into account adaptation of incompatible components. we propose an approach to build incrementally component-based systems, and where the generation of adaptors is fully automated if the software architect gives an abstract description of the properties of the system to be adapted, i.e., an adaptation mapping.



the rest of the paper is organized as follows. section 2 presents the formal model of components, and the architectural style we rely on. section 3 focuses on adaptation, and presents mechanisms to check if adaptation is needed, to compute adaptors, and to assess them. in section 4, our approach for incremental construction involving components and adaptors is presented. we describe how the system is updated as automatically as possible when one component is added or removed. section 5 illustrates our incremental approach on several case studies. we end in section 6 with concluding remarks.



various definitions of behavioural mismatch have been proposed in the field of software adaptation and software architecture analysis. we build on the most commonly accepted one, namely deadlock-freedom. intuitively, a system made up of several identified components is deadlock-free, and therefore does not need any adaptation, if its synchronous product has no deadlock.



in practice, behavioural mismatch can be computed(i) encoding the set of ltss in the exp.open input format,(ii) computing the product, and(iii) checking the absence of deadlocks on the resulting automaton. note that to distinguish final states and real deadlocks within exp.open ltss, we first add specific loop transitions labelled with accept over final states. point(i) has been encoded in adaptor, a prototype tool under development dedicated to the adaptation of software components. points(ii) and(iii) are computed automatically calling cadp



in this section, we follow the adaptor generation process proposed in. to check if a system made up of several components presents behavioural mismatch, the synchronous product of their lts behavioural interfaces is computed and then the absence of deadlocks is checked on it. the protocol of an adaptor is given by an lts which, put into a non-deadlock-free system yields a deadlock-free one. for this to work, the adaptor has to preempt all the component communications. therefore, prior to the adaptation process, component message names may have to be renamed prefixing them by the component name, e.g., c:message!.



once a new adaptor is generated, we propose different means to assess the new system and make the architect sure that this system still contains all the expected services. being given a set of components and their adaptors, the synchronous product is computed. then, we propose several techniques to assess the adapted system.



the addition of a component does not always need protocol adaptation, e.g., when adding the first component or when the test of mismatch does not detect a deadlock. however, our approach associates an automatically generated no-op adaptor to every component as in. such an adaptor basically reproduces from an external point of view the same behaviour as its component, and then routes



step(iv)(b) takes into account two slightly different cases, since an erroneous system can be worked out either proposing a new mapping instead of the former one and then replacing the last adaptor, or keeping the last adaptor and proposing an additional mapping to build another adaptor to be connected on top of the previous one. we will illustrate such a situation in section 5.2. last, mappings have to be kept while building the system since in case of suppression, they may be modified and their corresponding adaptors updated.



phil1 and phil2 have different behavioural interfaces(they are given below). in the classical formulation of this problem, philosophers share the same behaviour which may cause a deadlock when they both interact to access the two forks. in this example we have simplified the classical formulation by isolating only the behaviour of each philosopher that may cause a deadlock, when both of them are present. the behavioural specifications of phil1 and phil2 are the following: different names can be inserted into the system, the two philosophers have also a mismatching interaction protocol. the system deadlocks whenever, e.g., phil1 asks for and obtains the access to the first fork and then, phil2 asks for and obtains the access to the second fork. at this stage, both philosophers are blocked waiting for their complementary fork that will never be assigned to them.



the addition of the two fork components f1= f1:fork and f2= f2:fork is done analogously to what we have done in section 5.1 for the addition of the vod server. the no-op adaptors of f1 and f2 are a f1 and a f2, respectively.



is stated that the system(a f1| a f2| a phil1| phil1:phil1) has no service analogously to what we have done in section 5.1, the adaptor is assessed and it lost(wrt. the services provided by f1 and f2). thus, phil1 and its adaptor are



pda1 is a pda which can, among other possible actions, ask the music system to(i) play a chosen mp3 file, i.e., play!,(ii) stop playing, i.e., stop!,(iii) stop the player temporarily, i.e., pause! and(iv) resume a temporary stop, i.e., resume!. its behavioural interface is:



to the best of our knowledge, the closer works to ours are dedicated to incremental protocol enhancement. in it is shown how to compose component wrappers to augment connector behaviour. in, the authors have revisited providing approach automation. in, the starting point is a centralized adaptor that is always generated. conversely to this, we try to solve mismatches by only producing local adaptors and we produce a centralized one only when it is unavoidable(e.g., dining philosophers problem).



