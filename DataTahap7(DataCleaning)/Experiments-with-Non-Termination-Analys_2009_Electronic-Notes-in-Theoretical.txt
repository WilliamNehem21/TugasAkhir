non-termination analysis proves that programs, or parts of a program, do not terminate. this is important since non-termination is often an unexpected behaviour of computer programs and exposes a bug in their code. while research has found ways of proving non-termination of logic programs and of term rewriting systems, this is hardly the case for imperative programs. in this paper, we describe and experiment with a technique for proving non-termination of imperative, bytecode programs by relating their non-termination to that of a(constraint) logic program. moreover, we show that our non-termination test effectively helps a termination test, by avoiding expensive search for termination proofs of those portions of the code where such proofs do not exist.



this paper provides a first experimentation with the automatic derivation of non-termination proofs for java bytecode programs. we start from our previous work on a tool julia+binterm for the termination analysis of java bytecode. there, we translated the original java bytecode program p into a constraint logic program pclp whose termination entails that of p. here, we show how, in those cases when the approximation of the bytecodes is exact, the non-termination of pclp entails that of p. hence, we use the same tool as in to prove the nontermination of java bytecode programs by exploiting previous results from nontermination analysis of logic programs; namely, we prove the non-termination of pclp and hence infer, when possible, that of p. although these results are far from being a definite solution to the problem of non-termination analysis of java bytecode programs, they represent a first step in that direction and highlight weaknesses of the current approach, that must be solved if non-termination analysis must be applied to real java and java bytecode software. note that, while a notion of existential non-termination for c is considered in, we instead consider a notion of universal non-termination here for the clp program derived from the java bytecode program.



java bytecode is a low-level object-oriented type-safe language. its static analysis is complicated by the fact that it has no explicit structure, differently from highlevel languages, and that it uses a stack of temporary variables. hence the number and type of the variables are different at different program points inside the same method.



after the execution of each instruction in the bytecode: the size or path-length of a variable bound to a data structure is the maximal length of pointers that one can follow from that variable; the path-length of a variable bound to an array is the length of the array; the path-length of a numerical variable is its value; the path-length of a boolean variable is 0 for false and 1 for true. the result of the path-length is finally used to express the relationship between the size of the variables at the beginning and at the end of each basic block of the program. this is written in terms of a constraint logic program pclp over linear constraints, whose predicates b(vars) correspond to each basic block b of p and vars are the variables at the beginning of the execution of b. these approximations build constraints that are later used in order to derive bounds on the values of variables in programs, which is crucial for termination and non-termination analyses to work. the main result proved in, wrt. termination analysis, is the following:



the converse, however, does not hold in general: we can find programs p and a basic block b of p such that, in the translation pclp, predicate b(vars) does not terminate for some fixed initial integer values for vars, although all executions of p starting at b do terminate. this is due to the approximations done during the translation of p into pclp: both sharing and cyclicity analyses are approximated, so that, for instance, the analyser might not necessarily prove that a non-cyclical list is actually non-cyclical. moreover, some bytecodes have an inherently non-linear behaviour, such as multiplications and divisions, and cannot hence be approximated by using the linear constraints available for the path-length.



is non-terminating wrt. p by using the standard semantics of constraint logic programs. this means that an infinite computation can be built for that query in the program p. note that we do not consider any precedence between the clauses of p, that is, we assume a non-deterministic resolution of a predicate with all the clauses that define that predicate. the following results provide simple non-termination conditions for constraint logic programs.



these theorems provide a simple mechanism to infer ground non-terminating queries: first, use theorem 3.1 to infer a set of non-terminating queries from the recursive clauses of the program and then complete this set with the help of theorem 3.2.



the method iter(intended to perform an iteration over a list) contains a bug since it recurs on the same list rather than on its tail(iter() instead of tail.iter()). the bytecode version of this program has an exact approximation as our cyclicity analysis correctly infers that the list l in the method main is not cyclical. the



a completely different use of our non-termination tests consists in proving the nontermination of clauses of the pclp program generated during the termination analysis of a java bytecode program p. by removing such clauses, which cannot have any termination proof, we help the termination checker by simplifying its task. since our non-termination tests are extremely efficient, while a thorough quest for a termination proof is in general expensive, the trade-off is positive and we get a more efficient termination analysis still keeping the same precision.



of 356; among the removed clauses, there is a huge scc containing 122 clauses where the arity of the involved predicate symbols is 8, which explains the gain in efficiency. on the contrary, the clauses removed for kitten are several but include relatively small components and have small arity, so that the gain in efficiency is not significant there. this is because the cost of the termination analysis increases significantly with the arity of the predicates and, by removing clauses with small arity, we do not affect very much the efficiency of the termination analysis.



