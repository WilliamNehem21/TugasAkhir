reuse of components is a key technique to reduce the effort for the description of a system. now we want to extend our modeling language in a way that it supports the reuse of components. in the following, components that can be reused are called component types. we should be able to make component types available through a so-called library. when it comes to reuse of a component, the reused component is called an instance of the component type. an instance of a component type can be used wherever a regular component can be used, e.g., in the composition of another component. an instance has to be aware of its component type, so that it can adapt itself to changes of this component.



into a modeling language. the first approach solves the problem at the level of the meta-model by introducing new classes, whereas the second approach solves it at the level of the meta-meta-model by introducing a generic cloning mechanism. we detail the characteristics of either approach, apply them to our running example, and mention their implications for the meta-model and the modeling tools.



for the ccts/autofocus 3 framework we started thinking about libraries, when the meta-model already consisted of nearly 100 classes and much of the core functionality, such as graphical editors, the expression evaluator, a simulator, and first parts of a code generator, were already implemented, resulting in more than 50.000 lines of source code. thus the solution had to be minimally invasive, affecting the meta-model and the existing code as little as possible, as resources for going over the entire code base just were not available.



the overall idea was to design a library mechanism, which is orthogonal to the existing meta-model and modeling tools as far as possible. so for the existing code the change should be transparent by providing models that are compatible to those used before. this lead us to an approach similar to where instances are actually full clones of the types. the main difference is that our focus is on a more structured reuse mechanism, where elements may not be arbitrarily cloned, but only dedicated library elements may be instantiated. in addition, our approach generalizes cloning in a way that allows us to parametrize instances that are actually generated by the type. in contrast to gme, where cloning is deeply integrated into the meta-modeling framework, our approach can be easily built on top of each existing meta-modeling framework. our modeling tool for instance is implemented on top of emf(eclipse modeling framework 5). it however replicates some of the features of gme in the implementation of the modeling tool. in the following, we outline the overall approach and provide more technical details and implications of our approach.



the most important reason for building library mechanisms is to support the modification of a library element, which should then be reflected by all of its instances. as we model reuse only by marking instances with their origin and library references are only loosely coupled by their name, we have to deal with certain aspects of reuse in the implementation of our modeling tool. the first part is that the version number of a library element has to be increased with every change to it. as these changes are performed using the modeling tool, this should not be problematic. using the version number, we can easily identify libraryreferences, which are outdated(i.e., point to an earlier version of a library element) and thus have to be replaced by an updated version. in our implementation this check is triggered manually by the user to allow full control of the modification of an existing model, as changes in a library are a potential threat to the correctness of a model. however, depending on the tooling infrastructure, such a task could also be performed automatically on certain events. as the prototypes of a library element may again be library instances, the check and update procedure has to be performed in a recursive fashion.



the more interesting part is the update of all instances of a library element. actually, we have to replace a part of the model by a new one, which was generated by the generate() method. a simple exchange of the model parts is not sufficient here, as an instance might include elements which are referenced from other parts of the model(e.g., a channel to one of its ports) or layout and naming information, which we do not want to loose. our solution uses a modified merge algorithm, which replaces the old model part with the new one, but retains all references to external(relative to the part being exchanged) elements. using modern reflective meta-modeling frameworks such as emf, this can be achieved in a generic fashion using only a small amount of code(our implementation has about 300 code lines including comments). however, this piece of code has to be slightly adjusted for the meta-model used, as it has to treat some data differently. for example in autofocus 3, the name of the top-most element in an instance may be changed by the user and should not be overwritten by a change in the library.



all in all the implementation and modification effort for our solution was quite manageable, especially as the full(rolled out) model is available and the identification and referencing of individual elements is easy. however, our approach also has some drawbacks. the most obvious is the increased size of the models, as redundant information is stored. while in theory the growth in the number of model elements can be exponential, in our experience the elements being reused are often relatively generic and small, so their number is not a major problem. the larger elements being reused usually solve specialized tasks and thus are used only a couple of times(e.g., a component for monitoring the wheel pressure of a car). our estimates rather indicate a growth by a constant factor, which depends on the actual model but is in plied in the context of any meta-model, as it only uses standard meta-modeling constructs. this also applies to our generative approach, as we do not rely on special features of the meta-modeling framework. only the implementation might be slightly more complex, if the meta-modeling framework does not support reflection. in contrast, generic cloning is currently only implemented in gme and the extension of a different meta-modeling framework to support generic cloning is a non-trivial task.



both with instance classes and generic cloning only rather simple parametrization mechanisms are supported. typically an instance is just a duplicate of the type with possibly some attributes depending on parameters. with our generative approach, where the instance is generated by a method of the library element, any feature of an instance, including the model structure of the instance element, may be affected by parameter choice. this also simplifies the inclusion of different parametrization concepts and thus eases experimentation here.



