because of their size and complexity, and especially are extremely delicate languages to disambiguate. to this end, the transformersproject initially used algebraic specification formalism(asf), then stratego, and we finally decided to implement tag, an attribute grammars(ags) engine for syntax definition formalism(sdf) grammars david.06.iccp. in this paper, we compare these three approaches.



outline the remainder of this paper is organized as follows: in section 2, we present sdf and sglr and the three environments we used to implement disambiguation filters: asf, stratego, and tag. they are evaluated in section 3 on the various layers of phenix. section 4 summarizes the results, and section 5 concludes.



tag ags knuth.68.jmst express syntax-driven specifications of the semantics of context-free languages. attributes hold values that are attached to symbols of the grammar. semantic rules are bound to production rules, and they express only local computations: they relate attributes of the symbols of the production only. attributes computed using values from the parent are inherited, whereas those using values from the children are synthesized. at run-time, an evaluator computes the(global) order in which attributes can be computed for the whole parse tree.



this section introduces the layers of phenixand their disambiguation by the three methods. the first layer is especially detailed to present how disambiguation(i.e., the removal of invalid derivation trees) is performed in the three frameworks. but because of space constraints only the most significant results are presented. knowing the three tool-sets is probably needed to fully understand the code.



even though strategosupports specification of patterns in the concrete syntax of the object language, this feature is not employed because phenixis too ambiguous. each construction should be prefixed to make it clear to which node it refers. in fact, the matching with the abstract syntax tree is simpler. tag attributes are embedded in sdf using the attributes annotation.



this first extension adds scoping: a variable name may denote different bindings. declarations made in a scope must be discarded when leaving it. in the following example, the innermost use of foo is bound to the float declaration, whereas the outermost foo is an int.



stratego with this extension, another dynamic rule(get-access) must be added to keep a list of accessible namespaces. this rule needs to be used everywhere the strategocode uses the other dynamic rules to find the type of a variable. this extension leads to an update of all the previous code.



tag this extension is very intrusive: many changes are necessary. the attribute ns does not suffice to know whether a variable is reachable. a new attribute, access ns, stores a list of reachable namespaces. this attribute must be added and kept up-to-date in all the rules.



strategois very expressive. complex traversals can be expressed easily using the various combination operators and user-defined strategies. additional flexibility comes with the concept of scoped dynamic rules, which allow to have a global context without explicitly carrying it everywhere. scoped dynamic rules provide an excellent support for modularity: they traverse transparently unrelated nodes, and directly apply where needed. of course, when the grammar is extended, one must be careful to make sure that the code can handle it because strategomodules are not directly linked to the grammar.



