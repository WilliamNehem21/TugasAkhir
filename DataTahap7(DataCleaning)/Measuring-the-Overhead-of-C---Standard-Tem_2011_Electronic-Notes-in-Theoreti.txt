the c++ standard template library is a widely-used library that is based on the generic programming paradigm. the usage of this library does not warrant bug-free programs. furthermore, many new errors may arise from the inaccurate use of the generic programming paradigm, like dereferencing invalid iterators or misunderstanding remove-like algorithms.



the c++ standard template library(stl) was developed by generic programming approach. in this way containers are defined as class templates and many algorithms can be implemented as function templates. furthermore, algorithms are implemented in a container-independent way, so one can use them with different containers. c++ stl is widely-used because it is a very handy, standard c++ library that contains beneficial containers(like list, vector, map, etc.), a lot of algorithms(like sort, find, count, etc.) among other utilities.



the stl was designed to be extensible. we can add new containers that can work together with existing algorithms. on the other hand, we can extend the set of algorithms with a new one that can be work together with existing containers.



objects too. these techniques is quite typical in stl: different function templates for standard behaviour and for arbitrary one. developing function templates for parameter deduction is very common in the stl. however, there is a problem in this case: when we have an iterator as an argument of lower bound, we cannot use these template functions.



legacy stl-based codes can be easily transformed to use this vector container with extra checks. just an extra parameter should be passed to the vector type. however, there is no trivial assignment and copy between an untested and tested vector container, but a special template copy constructor and assignment operator can be added.



another approach is that the list is maintained when the iterators are destructed. it is easy to erase the iterator from the list in the destructor of vector::iterator. the advantage of this approach is that in the list only the existing iterators can be found. this is marked with 2nd variant in the comparisons.



in the future we consider how the invalidation can be passed as a trait. it would be quite useful if one can parametrize the strategy of invalidation and pass it to containers. maintenance of contained iterators is also can be more sophisiticated, and it also should be a trait. another direction can be mentioned according to the type system. it would be elegant to support checks with the type system of c++ to caching the results and avoid unnecessary runtime checks.



