

autowrite was initially designed to check call-by-need properties of most of the examples presented in. most of the time no alternative proofs exists. it implements the tree automata constructions of the call-by-need theory and many operations on terms, term rewrite systems and tree automata.



in the first version of autowrite, only the call-by-need properties and a few other simple properties were available from the graphical interface. this new version of autowrite includes many new functionalities. there are new functionalities related to trss, but the most interesting new feature is the possibility to directly handle(load, save, combine with boolean operations) bottom-up tree automata. in addition, we have added on-line timing information. since the first version the run-times have been considerably improved due to better choices of data structures. the new features allowed testing many properties of examples presented in for which no easy proof can be written.



a ground term does not contain variables. a linear term does not contain multiple occurrences of the same variable. a redex is an instance of the lefthand side of a rewrite rule. a normal form is a term without redexes. the set of all ground normal forms of a trs r is denoted by nf(r). an etrs is left-linear(right-linear, linear) if the left-hand sides(right-hand sides, both left and right-hand sides) of its rewrite rules are linear terms. an etrs is right-ground(ground) if the right-hand sides(left and right-hand sides) of its rewrite rules are ground terms. a left-linear trs without critical pairs is orthogonal. orthogonal trss have the property that every term has at most one normal form.



next we define the approximation mappings s, nv, and gr. let r be a trs. the strong approximation s(r) is obtained from r by replacing the right-hand side of every rewrite rule by a variable that does not occur in the corresponding left-hand side. the non-variable approximation nv(r) is obtained from r by replacing the variables in the right-hand sides of the



then we check that the current term is not recognized by the current automaton(as it is not a normal form). next we compute the complement of the current automaton(which recognizes reducible terms) and check that the current term is recognized by the complement automaton. finally, we check that the complement automaton does not recognize the empty language.



the main idea is to compute the automaton incrementally. we start building the rules having a constant left-hand side. this gives the first set of accessible states. then we compute the rules whose left-hand sides contain the current accessible states which may give new accessible states. we stop when no new accessible state is created.



