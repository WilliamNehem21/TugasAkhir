modern software is increasingly concurrent, timed, distributed, and therefore, non-deterministic. while it is well known that tests can be generated as ltl or ctl model checker counterexamples, we argue that non-determinism creates difficulties that need to be resolved and propose test generation methods to overcome them. the proposed methods rely on fault modeling by mutation and use conventional(closed) and modular(open) model checkers.



test generation from deterministic specifications using verification techniques and tools is a well-known approach. it is suggested by and refined by several authors, e.g.,,,,,,,. however, modern systems are non-deterministic due to asynchrony, concurrency, multithreading, timing issues, non-observable or non-controllable elements. moreover, even if an implementation under test(iut) itself can be regarded as deterministic, in a model or specification, non-determinism may occur due to incompleteness of knowledge of implementation choices, limitations of a modeling language, and abstractions. conservative model abstraction is widely used to reduce complexity(state space) or to remove constructs, which are difficult for simulation and verification(e.g., time aspects). in declarative object oriented conceptual modeling, non-determinism allows to better reflect inherent non-determinism of the domain, reduce complexity, and achieve a better separation of concerns. the problem of coping with non-determinism is a long-standing one in protocol testing,,,,,,.



a connection between the two types of testing. in fact, to kill(detect) a mutant obtained simply by mutating an output, a test that covers the affected transition(or, in the case of moore machines or kripke structures, a state) is necessary and at the same time sufficient. the problem of finding mutant-killing tests can be reduced to the problem of reaching states of a module composed of a specification and faulty sub-modules which satisfy a given property. this approach could be used to derive tests that combine specification coverage and fault propagation,. however, those interested in coverage based techniques could find extensive literature elaborating usage of model checking tools for particular data or control flow coverage criteria, such as,,,.



for fsm, deterministic as well as non-deterministic, test generation is a well studied theoretical problem, e.g.,,,,. however, methods developed for classical fsm are rarely applied for real size specifications due to state explosion problem. the current trend is to use model checking technology, which embraces various sophisticated optimization techniques to cope with state explosion problem, such as bdd, partial orders, and sat.



the paper is organized as follows. the next section introduces necessary definitions of test, module, model checking, and module checking. section 3 discusses test generation from a counterexample derived by model or module checking in the presence of non-determinism. section 4 discusses how our results apply to the case of multiple mutants. in section 5, we briefly discuss some related work and conclude in section 6.



notion of a module, which could be seen as a kripke structure with a partition of atomic propositions onto input, output, and internal(hidden). in mealy machines, differently from kripke structures, the labels are assigned to transitions and not to states. in some cases, mealy machines allow for more intuitive and compact specifications than kripke structures, especially in the black-box testing context. however, our choice is motivated by the fact that temporal logics, used in model checking, are traditionally defined over kripke structures. as we later show, the input-output behavior of a module could be modeled by a mealy machine. in the presence of hidden variables, the model of extended finite state machine could be used to obtain a compact representation of the module.



input i is enabled in the state w if w has at least one successor state s with input inp(s)= i. otherwise, input is disabled. a module is input enabled(completely defined) if each input labels an initial state and is enabled in every state. in this



at the same time, we discuss possible use of more traditional and widespread ltl or ctl model checking techniques for simpler cases of the most general problem. moreover, we show that candidate test verification and, hence, incremental test derivation is possible for non-deterministic specifications and mutants. yet, we doubt that one could use conventional ltl or(non-modular) ctl model checking technique to derive strong test or decide its existence without significant computational efforts on the model transformation. an exponential growth of the size of the system or property being model checked is expected. indeed, the complexity of ctl model checking is linear in terms of state space, while finding strong tests is pspace-complete.



for most of complete model checking algorithms and tools, which compose modules prior to property analysis, replacing m' by obs(m) may somewhat reduce space state, but the gain is relatively small for on-the-fly model checking, when only a fragment of the composition, which is relevant to the property, is usually constructed. an incremental generation of a strong test can be performed by consecutive verification of all candidates of a given length. if the state number of modules is finite, an upper bound of the test is known. technically, it is possible to define a module that consecutively tries all possible test candidates of the given length. such approach could be faster than model checking multiple systems, but we do not see how it could be organized efficiently in the terms of the memory consumption.



first mutant should start with i= 1. similarly, any strong test for the specification and the second mutant should start with i= 0. thus, there is no single test for the specification and both mutants at the same time.



