a widely used technique to integrate decision procedures(dps) with other systems is to have the dps emit proofs of the formulas they report valid. one problem that arises is debugging the proofproducing code; it is very easy in standard programming languages to write code which produces an incorrect proof. this paper demonstrates how proof-producing dps may be implemented in a programming language, called rogue-sigma-pi(rsp), whose type system ensures that proofs are manipulated correctly. rsp combines the rogue rewriting language and the edinburgh logical framework(lf). type-correct rsp programs are partially correct: essentially, any putative lf proof object produced by a type-correct rsp program is guaranteed to type check in lf. the paper describes a simple proof-producing combination of propositional satisfiability checking and congruence closure implemented in rsp.



the integration of congruence closure with the propositional validity checker follows the so-called eager approach, where assignments to atomic formulas are asserted to the decision procedure as they are made. cc is responsible for notifying sat immediately if the current set of asserted literals l1, l2,..., ln is determined to be inconsistent. if such an inconsistency is detected, the current branch of the validitity check search is closed.



assumption(tactics): we assume we have the ability to write general programs(tactics) which can manipulate h=-proofs. we use this assumption in just one case below, namely for the deduction theorem, whose proof is just a proof-transforming program(section 2.8). we do not assume that we have the means to verify that tactics have properties like termination or case coverage. hence, we do not assume that tactics always succeed.



the approach adopted here to producing proofs from cc in rvc is different from the approach followed in cvc[13, chapter 5]. in cvc, each time a literal is asserted by sat to a subsidiary dp like cc, the literal must be accompanied by a proof(that the literal holds). this is reasonable in proof systems with local assumptions, where the sat solver may introduce a local assumption u that the literal holds, and provide u to cc as the proof of the literal. in the absence of local assumptions, this cannot be done directly. reasoning under assumptions is admissible in h=, however, due to the following elementary meta-theorem:



using the instrumenting approach to proof production, rvc currently needs 52 lemmas to justify all the inferences it does. these lemmas have all been derived from the basic rules of h=. it is most convenient to derive lemmas using the deduction theorem. since, as discussed above, the proof of the deduction theorem is essentially an untrusted tactic, we insist that proofs of lemmas using the deduction theorem be expanded out completely into proofs consisting just of primitive rules of h= and other lemmas(see section 3.4).



check, and the soundness of rvc with respect to provability in h= has thus been statically verified. bugs in the implementation could still cause rvc to fail to be complete. furthermore, it can happen that due to run-time errors like pattern-matching failure, proofs could be generated with the special symbol null in them. these proofs will not check. the exact statement of the guarantee provided by rsp is thus the following: any proof produced which does not contain null is guaranteed to check.



for purposes of this paper, rsp can be thought of as an ml-like language with some additional features. the basic features rsp shares with ml are support for case analysis based on pattern-matching, and(general) recursion. rsp has pattern abstractions, which are essentially rewrite rules l-> r. these abstractions are applied(using an explicit@ operator) as functions to terms to transform them. if the pattern does not match, an application of such an abstraction evaluates to null. pattern abstractions can be joined with the deterministic choice operator| to perform case analysis. for example, is a pattern abstraction transforming any expression of the form(f x x), where x is an int(the only built-in type in rsp), to x+x. for this to be welltyped, we should have f declared to have type int=> int=> a for some type a. a need not be int, because just as for ordinary functions, the domain and range type of a pattern abstraction need not be the same.



