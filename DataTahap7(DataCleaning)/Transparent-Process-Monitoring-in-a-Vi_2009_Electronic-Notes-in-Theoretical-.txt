thus, in(i) a flex-generated scanner recognizes system calls as tokens of the language. to create cfg(p), the parsing of the source code in(ii) is decomposed into two further steps. in the first step, the semantic actions of the generated parser export an ast. the internal nodes of this tree represent either functions defined in the source code of p or statements/expressions, whereas leaf nodes represent system calls. in the second step, the parser visits the ast to build cfg(p) by applying gga. cfg(p) is represented through the bison syntax so that in(iii) we can exploit bison to generate the parser for l(p) that is used at run-time to check that the trace of p is legal.



analysis and it consists of:(i) a context-free grammar cfg(p) that defines the legal system call traces;(ii) a set of invariants inv(p)={i(p, 1),...,i(p, n)}, each paired with a program point i where p invokes a system call. the implementation



the i-vm can access each component of the mon-vm, for example any memory region and any processor register, to inspect its running state and evaluate assertions on p state, i.e. on the values of its variables. each invariant is paired with a system call and, in general, it constrains the values of the system call parameters or relates them to variable values. during the execution of p, the mon-vm transfers control to the i-vm each time p invokes a system call. at this point, the i-vm checks that the current trace satisfies cfg(p) and it evaluates the invariant i(p, i) paired with the point i that p has reached.



the important assumptions underlying the adopted approach are that:(i) the source code executed by p is known;(ii) the vmm can be trusted;(ii) introspection safely extends the trusted computing base(tcb). two reasons support the latter two assumptions. firstly, the vmm has full visibility of the mon-vm, because it can access every components of it. secondly, the vmm is more robust than commodity oses because:(i) it exports a simple interface to the higher levels, which is more difficult to subvert than, for example, the one of a kernel that implements hundreds of system calls;(ii) the small size of the vmm code reduces the likelihood of a compromise and makes it possible to validate its correct implementation through a formal analysis. notice that the kernel of the mon-vm does not belong to the tcb because its integrity can be checked by the i-vm. in conclusion, since the vmm has full visibility of the vms but it is strongly isolated from them, the complexity of compromising the vmm or of eluding the introspection monitoring capabilities of the mon-vm is very high. nonetheless, there are known threats against the vmm that also have to be considered.



xen is the adopted technology to create the vms that implement the dynamic tools. we adopted the xen vmm mainly for its high performance and complete integration with the linux kernel. psycotrace exploits the para-virtualization approach, in which oses are aware of the existence of the xen vmm.



the current dynamic tools are the himod and the analyst, that run, respectively, in the kernel of the mon-vm, and at the user-level of the i-vm. the himod is a kernel module that hijacks the system calls that p invokes. every time p invokes a system call, himod notifies the analyst, which can apply the consistency checks on the self of p. the analyst includes the bison-generated parser and an assertion checker that, respectively, check the traces of p and evaluate the invariants. the analyst starts by listening for communications from the himod about system call invocations. this interaction is synchronous, i.e. each time a system call is invoked, p is paused and the execution is resumed only after the analyst has completed the security checks. notice that the ability of implementing the analyst at the user level strongly simplifies its implementation with respect to the case in which it is implemented at the kernel level in the mon-vm.



by the vms in the xen architecture, which enables a privileged machine to access information about the running vms. himod stores the base address of the shared page in a well-known token in the xenstore tree. the analyst accesses the token and uses the address to map the page in its address space. the overall solution enables the analyst to retrieve the information about the system call in the shared memory page.



calls. the himod consists of 2.5k lines of c code, while the analyst is composed of about 3k lines of c code, including the introspection library. the definition of the extended c grammar including the semantic actions to generate cfg(p) is about 1k lines of c++ code. finally, the generated bison parser for cfg(p) is about



in the current psycotrace prototype, the himod monitors a single pid. this implies that a process that forks some children processes is not correctly monitored. thus, psycotrace also needs to monitor the children, for example by retrieving their pid through introspection anytime a fork is called. finally, we are currently working on the definition of the static tools that extract the set of assertions from the source code.



