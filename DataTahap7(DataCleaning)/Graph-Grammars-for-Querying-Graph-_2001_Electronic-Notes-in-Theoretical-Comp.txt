ed by a regular expression[4,7,9,11,23,16]. however, this kind of navigational queries is not completely satisfactory since in many cases we would like to express queries verifying whether the graph has a given structure(e.g. a tree or a chain) or to extract from the source graph a subgraph which satis es some property.



our paradigm permits to de ne queries that search in a given graph for a subgraph belonging to the language de ned by a given graph grammar. in this way it is novel: while other query languages intend to nd some nodes in a graph such that each of these nodes has a certain property(e.g. the set of the nodes which are the answer of a path query), our model searches for entire sub-structures. let's consider the following example. assume that we want to extract all the available online\books" about swing classes from a web site containing documentation about java. in particular we are interested in extracting web pages having a hierarchical structure like the one shown in the following gure:



in the following sections we de ne our graph query language, by introducing a restricted form of node replacement context-free graph grammars, called parsing graph grammars and specifying how these grammars identify subgraphs of the original data graph. we point out that our paradigm can also be used to create new graphs. however, in this paper we only consider the extraction of subgraphs.



x is a nonterminal node label, d is a graph and c is the set of connection instructions. a rewriting step of a graph h according to such a production consists of removing a node u labeled x from h, adding d to h and adding edges between d and h as speci ed by the connection instructions in c. the pair(d; c) can be viewed as a new type of object, and the rewriting step can be viewed as the substitution of the node u with(d; c) in the graph h. intuitively, these objects are quite natural: they are graphs ready to be embedded in an environment. their formal de nition is as follows.



let be an alphabet of node labels and an alphabet of edge labels. a graph with embedding is a pair k=(d; c) where d is a graph over and and c n fin; outg is the connection relation of k. each element(; 1; 2; v; d) 2 c is a connection instruction of k and is generally written as(; 1= 2; v; d). the components of a graph with embedding k will be denoted as nk; ek; k and ck.



intuitively, for a graph with embedding k, the meaning of a connection instruction(; 1= 2; v; out) is as follows: if there was a 1-labeled edge from a node u which has been substituted by k to a-labeled node w, then the embedding mechanism de nes a 2-labeled edge from v to w. similarly, the meaning of a connection instruction(; 1= 2; v; in) is as follows: if there was a 1-labeled edge from a-labeled node w to a node u which has been substituted by k, then the embedding mechanism de nes a 2-labeled edge from w to v. the feature which replaces edge labels is called dynamic edge labeling. let h be a graph over and, k be a graph with embedding over the same alphabets, and let v 2 nh. the substitution of k for v in h is denoted by h[v=k]. in the following connection rules of the form(;=; v; a)(i.e. rule which do not re-label edges) are simply written as(;; v; a).



de nition 2.2 a node replacement(nr) grammar is a tuple g=(;; p; s) where is the alphabet of labels, is the alphabet of terminal labels, p is the nite set of productions, and s 2 is the initial nonterminal symbol. a production is of the form x!(d; c) where x 2 and(d; c) is a graph with embedding. 2



we start by de ning a simple graph model on an alphabet with two di erent types of symbols: constant and variables. a variable can take any value and, therefore, it can be associated to any constant. in the following, constants are represented by strings starting with digits or lowercase letters(e.g. b1), variable names are denoted by strings preceded by a dollar(e.g.$b1) and non terminal symbols are denoted by strings starting with uppercase letters(e.g. x).



de nition 3.1 given an alphabet, a graph over is a tuple g=(n; e;) where n is a set of nodes, e f(u;; v)ju; v 2 n; 2 g is a set of labeled edges and: n! is a node labeling function. we way that g is a data graph if contains only constants otherwise it is called query graph. 2



the alphabet used by(general) graphs may also contain, other than terminal symbols(variables and constants), non terminal symbols. thus, data graphs contain only constants and they are used to represent the input database, query graphs are used to denote graphs which can be`mapped' on data graphs and general graphs are used in the intermediate states of the derivation process. graph grammars can be used to denote sub-structures from a given data graph.



a data graph d is recognized by a graph grammar pg if there exists a derivation from s to a query graph(s)) and a mapping from to d. the set of data graphs recognized by pg is denoted dl(p g). the set of subgraphs of a given data graph d recognized by pg is denoted dl(p g; d).



observe that t erminal() is a query graph, i.e. a graph whose node labels can be either constant or variables. like embedded graphs, mapping pairs can be seen as a new type of object consisting of query graphs(derived from graph grammars) mapped over a given data graph. the derivation of query graphs from parsing grammars can be extended to mapping pairs. let d be a data graph, pg a graph grammar and(;') a mapping pair over d. we say that a mapping pair(;) is directly derived from(;') through a production of pg(and write(;'))(;)) if and only if) and extends'. 1 moreover, we say that a mapping pair( n;'n) is derived from a mapping pair( 0;'0) over a data graph d if( 0;'0)) 1( 1;'1)) 2) n( n;'n). given a graph grammar pg and a data graph d,(p g; d) de nes the set of mapping pairs derived from(s;;) where; denotes an empty mapping.



a mapping pair applied to a data graph d allows us to identify a subgraph of d having the property de ned by the grammar. each node of the extracted subgraph can be associated to more than one node of the query graph, if these nodes have di erent\role" labels. di erent labels are used to distinguish di erent classes of nodes and arcs(e.g. in a tree internal nodes and leaf nodes may have di erent labels).



note that the production de ning the axiom(start symbol) of the graph grammar) contains an arc whose start node is marked with the constant label n1. this means that all derived query graphs are trees whose root node is marked with n1. therefore, every tree generated by such grammar can be mapped only to a tree whose root node has label n1. in the above mapping ated a variable. although not represented in the gure, the arcs in the query graph are mapped to arcs in the data graph; for instance the arc e=(1; 2; a) and the arc'(e) have the same label a(i.e.'(e)=('(1);'(2); a)). 2



de nition 3.8 let d be a data graph d and m a mapping pair on d. a checking property for d and m is a formula of f o(cou nt) over the relations used for storing d and the variables appearing in m. 2



de nition 3.10 an extended graph query q is a pair(p g;) where pg is a graph grammar and is a fo(count) formula. the answer to an extended graph query q over a data graph d is q(d)= fmjm 2(p g; d)^(m; d)g.



