concretely, implementors of mathematical tools can either avoid ambiguity, by choosing an artificial but unambiguous grammar, or they can develop heuristics. in sect. 2 we briefly recall the advantages and disadvantages of the former solution. the focus of the paper is, however, on the second one. moreover, we only focus on ambiguity in formulae, even if more complex forms of ambiguities are possible, e.g. in commands applied to arguments that are ambiguous. the main challenge is that there is the concrete possibility that the heuristics fail to assign the intended meaning to the formula components. this leads to three problematic scenarios that all raise challenging user interface problems.



in the rest of the paper we discuss how the user interface of matita deals with disambiguation. as far as we know, this is the first paper presenting an user interface of this kind. starting from the one of whelp, the current user interface has evolved in the last two years to satisfy users that faced showstopping situations. examples of them are when the time spent acting against the system becomes significant or when the system picks wrong interpretations on a regular basis. currently, no user has faced show-stopping situations for a long time.



a serious evaluation involving a group of users faced with alternative interfaces has not been attempted yet due to a major difficulty: the experiment cannot be repeated in time under the same conditions without accumulation of knowledge by the user. this knowledge biases the experiment. thus we should use replication in space by involving a large group of users. nevertheless our current group of users is highly non-omogeneous. for instance, implementors should not take part of the group since, knowing exactly the disambiguation algorithm that is implemented, they infer from error messages more information of what is exposed. similarly, students that have not received a reasonable training period do not provide an interesting population since they may have difficulties with the logic itself that could be erroneously identified with difficulties related to ambiguity. finally, replication of the experiment in time, but on different topics, is also unreliable: on the one hand no previous knowledge is accumulated; on the other hand, the set of mistakes made by a user on the formalization of one topic is likely to be very different from that related to another topic. one of the referee suggested a complementary evaluation approach that is not affected by the previous considerations: an analysis of the interface according to an hci usability framework. this has not been attempeted yet, but we plan to do that in the future.



conclusions in the large. on the other hand, we have tried to put transferrable value in the paper by discussing all the previous experiments we tried and why they failed. this is no proof that the current interface behaves well or that it cannot be improved but, on the other hand, the failed experiments constitute a good list of common pitfalls to be avoided.



in sect. 2 we present further motivations for dealing with mathematical ambiguity. then in sect. 3 we present several sources of ambiguity in mathematics before giving in sect. 4 background material on how ambiguity is handled in matita and whelp. the next three sections describe the behaviour of the user interface of matita in the three scenarios already discussed. conclusions follow in sect. 8.



however, replacing the standard notation with a non-ambiguous one has a clear advantage also from the user point of view: the system and the human assign the same meaning to every component of the formula. thus, if the formula is accepted, it is for sure the one intended. otherwise, if an error is shown, the error is surely meaningful.



to conclude, the decision between the standard language or an ad hoc one is often forced by the scenario where the tool is going to be used. in several situations, only the first solution is viable. one example is applications of theorem provers to education. according to our experience, it is possible to convince mathematical teachers to make students experiment with a proof assistant only if it understands the exact notation used in class. another example, that motivated us from the beginning, is that of mathematical tools to explore or reuse parts of an unknown mathematical library. since the notation is usually part of the library, avoiding the traditional mathematical notation makes impossible to issue queries on the library involving formulae. indeed, we started working on mathematical disambiguation when we developed the whelp search engine that allows the user, among other things, to look for theorems whose conclusion is an instance or a generalisation of a given formula. once again, the main difference between the user interface of whelp and the one of matita has been driven by the user interaction scenario of the two tools. in whelp there is no clear correlation between the previous queries and the current one. on the contrary, in matita the user works on the same topic for a while and so the heuristics can observe the recent interactions to learn isation is done. nevertheless, it is not unusual to have different alternative representations in the library of one system and we are convinced that the wealth of alternative representations is a peculiar mathematical feature that humans exploit all the time, moving, often implicitly, from one representation to the next one when needed. this becomes an ambiguity problem as soon as a mathematical library contains alternative representations.



interpretations generated in one pass are all characterised by some criterion of adherence to the aliases. the criteria of later passes are obviously looser than the one of former passes, so that an interpretation generated in an early pass resembles interpretations for formulae typed recently by the user. currently, we have adopted the next five passes. each pass is tried only after the ones that precede it, and only if they failed to produce a valid interpretation. in examples are given to motivate the need for each pass.



multiple correct interpretations generated in the same pass are ranked in the same way. thus the user interface must collect from the user enough information to pick the right interpretation among those maximally ranked or, on demand, among all rankings. this is the topic of sect. 6. when there is just one maximally ranked interpretation, the system avoids user interaction but risks picking the wrong one. thus, as in the first scenario, it is important that the user interface provides non-invasive feedback on the interpretation given to formulae. this is the topic of sect. 5.



spurious error detection can be efficiently integrated in our efficient disambiguation algorithms and, according to our benchmarks in, is effective in reducing the average number of errors to be presented to the user. nevertheless, we need a lightweight user interface to present the remaining non-spurious errors to the user, possibly ranked according to passes, and to present on demand also the spurious errors in the rare case of false positives. this is the topic of sect. 7.



since the mathematical notation is overloaded and interpretations are automatically chosen by the system among the correct ones, it is important to provide feedback to the user on the way formulae are interpreted. we believe that hyperlinking every symbol, constant and notation to the definition of its semantics already provides on demand enough feedback. in the matita theorem prover and in the helm/mowgli web interfaces, this is achieved with hyperlinks that are followed when the user clicks on a symbol or constant. moreover, a status line shows the uri of the hyperlink when the mouse is put over the symbol. the status line and the hyperlinks serve different purposes. the first one helps the user to understand what meaning has been assigned to a symbol; the second one is used more rarely when the user has forgot or ignores the exact mathematical definition associated to that meaning.



in place of hyperlinks, there are two other possibilities we know of. the first one is printing the formulae dropping all user-provided mixfix notations. this is also implemented in matita and can be activated from the view menu. nevertheless, dropping the usual infix notation, a formula can get rearranged in such a way that it becomes difficult to relate it to the original form. thus this feature is mostly used for debugging. the second alternative is to follow the mathematical tradition and decorate every symbol so as to make explicit its interpretation, as is usually done when using two operators coming from different mathematical structures. this had been implemented in the past in an early version of the helm/mowgli web interfaces and we plan to port it to the interface of matita. the drawback is that switching between decorated and undecorated forms heavily changes the shape of the formula and may provides excessive information. hence, instead of doing it globally as we previously implemented, we plan to do it locally only on formulae selected by the user, as suggested by one referee.



since the system is unable to decide which maximally ranked interpretation is the one expected by the user, it computes a tree of discriminating questions among interpretations. each node in the tree is a multiple answer question about the meaning of a symbol, where the possible answers range among the meanings used in the set of correct interpretations. the node has a child for each possible answer. the root of the tree is the question that allows the higher number of interpretations to be pruned. its children are computed recursively according to the same criterion applied to the remaining set of correct interpretations. in our example, we get a degenerate tree with only one node, since one question is sufficient to identify just one maximally ranked interpretation.



our approach is very satisfactory from the user point of view, especially when the content of the library is unknown. for instance, students are usually unaware of the organisation of the standard library of matita and thus fail to include in advance all scripts they will depend on. this is witnessed by the explicit aliases automatically inserted by the system in their scripts every time they use some lemma or definition in a script they forgot to include. moreover, when the script is executed again, no penalty is spent in searching lemmas in the library since the inserted aliases are tried before. finally, from the uris in the aliases it is possible to infer the correct include commands if the user prefers to make all dependencies explicit at the beginning of his file.



matita now implements the new interface described in the paper and we plan to port a modified version of the new user interface also to whelp. the main difference will be in the use of aliases to rank interpretations. indeed, in an interactive theorem prover it is possible to understand when the user stops working on some topic to start something completely different. in contrast, a search engine just answers to a stream of queries that could be related or not. hence the user should be given more explicit control on the management of aliases in order to drop them and start from scratch a new session of queries forgetting the previous disambiguation choices.



as discussed in the introduction, user validation of the system and of alternative variants for its interface is particularly complex, since we do not have a large group of users with uniform skills that can try to formalise the same thing in parallel. making the same user redo the same formalisation was attempted, but gave biased results since the user has improved his understanding of the domain and the library and tends to commit different mistakes when writing formulae. we also feel that comparing the user experience on different formalisations may be misleading. a more viable alternative, as suggested by one referee, would be to evaluate the system according to some usability framework. this is currently left as future work. thus, right now, the main evidence for the benefits of our work is the current degree of satisfaction of our users, to be compared with their degree of insatisfaction with previous versions of the system, where disambiguation often proved to be a show-stopper because of user interface issues. this has no longer been the case since the implementation of the interfaces described in sect. 6 and sect. 7.



