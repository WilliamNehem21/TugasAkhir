automatic cost analysis of programs has been traditionally concentrated on a reduced number of resources such as execution steps, time, or memory. however, the increasing relevance of analysis applications such as static debugging and/or certification of user-level properties(including for mobile code) makes it interesting to develop analyses for resource notions that are actually application-dependent. this may include, for example, bytes sent or received by an application, number of files left open, number of smss sent or received, number of accesses to a database, money spent, energy consumption, etc. we present a fully automated analysis for inferring upper bounds on the usage that a java bytecode program makes of a set of application programmer-definable resources. in our context, a resource is defined by programmer-provided annotations which state the basic consumption that certain program elements make of that resource. from these definitions our analysis derives functions which return an upper bound on the usage that the whole program(and individual blocks) make of that resource for any given set of input data sizes. the analysis proposed is independent of the particular resource. we also present some experimental results from a prototype implementation of the approach covering a significant set of interesting resources.



a resource is a fundamental component in our approach. a resource is a user-defined notion which associates a basic cost function with some user-selected elements(class, method, statement) in the program. this is expressed by adding java annotations to the code. the objective of the analysis is to approximate the usage that the program makes of the resource.



as illustrated by the example, these java annotations allow defining the resources to be tracked(which is done by simply mentioning them in the annotations) and to provide cost functions for the built-in and external(library) blocks that are relevant to the particular resource(i.e., which affect the usage of such resource). they also allow defining data size relations among arguments and defining and declaring size measures. the resource usage expressions are defined using the following language(which we will call l): base case, in which we return null, here represented as an assignment of null to the return variable r5; the sibling corresponds to the recursive case. the virtual invocation of format has been transformed into a static call to a block method named encoder.format. there are two block methods which are compatible in signature with that invocation, and which serve as proxies for the intermediate representations of the interface implementations in trimencoder.format and unicodeencoder.format. note that the resource-related annotations have been carried through the cfg and are thus available to the analysis.



the control flow graph is composed of block methods. a block method is similar to a java method, with some particularities: a) if the program flow reaches it, every statement in it will be executed, i.e, it contains no branching; b) its signature might not be unique: the cfg might contain several block methods in the same class sharing the same name and formal parameter types; c) it always includes as formal parameters the returned value ret and, unless it is static, the instance self-reference this; d) for every formal parameter(input formal parameter) of the original java method that might be modified, there is an extra formal parameter in the block method that contains its final version in the ssa transformation(output formal parameter); e) every statement in a block method is an invocation, including builtins(assignment asg, field dereference gtf, etc.), which are understood as block methods of the class builtin.



decompiling cond, while we attach cond to its sibling. a similar approach is used in virtual invocations, for which we introduce as many block methods in the graph as possible receivers of the call were in the original program. a set of block methods with the same signature sig can be retrieved by the function getblocks(cfg, sig). user specifications are written using the annotation system introduced in java



in the cfg are inferred. the next step is the decomposition of the cfg into its strongly-connected components. after these steps, two different analyses are run separately on each strongly connected component: a) the size analysis, which estimates parameter size relationships for each statement and output formal parameters as a function of the input formal parameter sizes(sec. 4.1); and b) the actual resource analysis, which computes the resource usage of each block method in terms also of the input data sizes(sec. 4.2). each phase is dependent on the previous one. the data dependency analysis is a dataflow analysis that yields po-



we now show our algorithm for estimating parameter size relations based on the data dependency analysis, inspired by the original ideas of[17,16]. our goal is to represent input and output size relationships for each statement as a function defined in terms of the formal parameter sizes. unless otherwise stated, whenever we refer to a parameter we mean its position.



longest path-length of a variable is the cardinality of the longest chain of pointers than can be followed from it. more complex measures can be defined to handle other data types such as cyclic structures, arrays, etc. the set of measures will be denoted by m.



the other scenarios occur when the invoke statement is non-recursive. either a resource usage function costalg for the callee has been previously computed, or there is a user annotation costusr that matches the given signature, or both. in the latter case, the minimum between these two functions is chosen(i.e., the most precise safe upper bound assigned by the analysis to the resource usage of the non-recursive invoke statement) or a warning is issued.



