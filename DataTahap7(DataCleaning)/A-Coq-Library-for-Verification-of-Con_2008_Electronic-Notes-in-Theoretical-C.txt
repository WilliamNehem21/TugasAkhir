concurrent programs are ubiquitous: multi-threaded programs in network servers, distributed programs for database applications, etc. in order to guarantee their correctness and security properties, it is important to verify them formally. the main difficulty in formally verifying concurrent programs is the size of their state space. the latter can be very large(because of non-determinism) and even infinite(for non-terminating applications, such as reactive systems).



regarding concurrency, previous work using proof assistants has focused on abstract concurrent systems rather than on realistic concurrent programs. there are many formalizations of pure concurrent calculi(e.g.,[13,17,18,28,29]) and experiments with the combined use of proof assistants and model checkers for minimal concurrent languages(e.g.,[22,32]). this work demonstrates the usefulness of proof assistant-based formal verification for concurrent programs. however, the formalized calculi and languages are cumbersome to verify realistic concurrent programs because of the lack of datatypes. moreover, in view of the large proof developments in previous work, it is questionable whether such verifications can be done in practice. for these reasons, we think that formal verification of realistic concurrent programs has not yet been addressed satisfactorily.



a collection of lemmas in order to facilitate formal proof. the most effective lemmas are based on confluence properties. they allow for smaller formal proofs by reducing the state space that needs to be explored for the purpose of verification.



our encoding can be said to be a deep embedding because we define the syntax as an inductive type that we use in the next section to define the operational semantics. however, the ability to integrate coq functions gives it also the flavor of a shallow embedding. see and for definitions.



concerning temporal formulas, an important issue developed in our specification language is formalization of strong fairness. intuitively, strong fairness is a system property enjoyed by execution environments in which communications that can execute infinitely often are eventually scheduled for execution. it is an important assumption without which we cannot write satisfactory specifications for realistic concurrent programs. for example, let us consider the following program:



a property that one might want to check is that the process outatom e v is eventually revealed. however, without the fairness assumption, this property does not even hold. we show in sect. 3.1 how we encode the fairness assumption and in sect. 3.2 we give the semantics of the formulas of our specification language.



we formalize the notion of strong fairness. informally, strong fairness says that any process that is infinitely often enabled is eventually reduced 5. we need a few intermediate definitions. we say that p is a subprocess of q when q consists of the parallel composition of p with some other process(es). the predicate reduced p q r intuitively means q reduces to r by reducing its subprocess p. the formal definition is omitted for lack of space.



in our implementation, the satisfaction relations are axiomatized. this is because the formula for negation does not respect the positivity constraints imposed by coq. this problem has already been observed in. this is not problematic as long as we do not study formally the properties of the formulas.



at this point, we are able to write a concurrent program p, a(temporal) property f, and we can try to prove tsat f p using coq tactics. this direct approach is tedious because the coq native tactics are too low-level and not adapted to the problem at hand. our solution is to propose a collection of lemmas(and accompanying tactics) to facilitate formal proof.



the main difficulty in proving properties of concurrent programs is non-deter minism. in order to prove a property for some program, one often needs to check all possible runs. this is at best costly and often impossible because there may be infinitely many runs or because some process is unknown. to deal with these



we evaluate feasibility of verification of concurrent programs using our library. our case study is the smtp receiver part of an existing mail server. in short, this program receives and processes smtp commands, sends back smtp replies and queues received electronic mail.



we chose this application for the purpose of comparison. indeed, we have already performed verification of this application in coq using a different approach that consists of building a faithful functional model. in short, the original java implementation was turned into a coq function using monadic style programming, third-party programs(client and file-system) were modeled using coq predicates and non-software aspects were modeled using functional constructs(for example, non-deterministic system failures were modeled using infinite lists to serve as test oracles). arguably, this approach has little overhead because it takes advantage of the coq built-in support for functional programs. therefore, comparison should highlight the overhead of using our library for verification.



coupet-grimal proposes an encoding of linear temporal logic in coq. temporal formulas are defined for an abstract transition system and their properties are collected into a library that has been used to prove correctness of a garbagecollection algorithm. it would be useful to integrate similar reasoning on temporal formulas for our language.



