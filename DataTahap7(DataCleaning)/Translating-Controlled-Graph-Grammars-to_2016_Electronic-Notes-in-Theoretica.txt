software and hardware systems are found everywhere and each day we face more complex and sophisticated systems. the development of systems has been a hard task to be performed, making it necessary a complete specification with no mistakes. each day, these systems grow in scale and scope, often having to interact with other complex and independent environments. along this increase of complexity, the possibility of mistakes is intensified which can lead to catastrophic losses, either in terms of time, money or even lives. therefore the techniques to assist the development of reliable and correct systems are becoming more and more necessary. one of the ways to reach such a goal is through the use of formal methods, techniques based in mathematical formalisms which can offer strict and efficient measures to project, model and analyze computer systems. a specification must be compact, accurate and with no ambiguity, that is, it must be given through a language with well-defined syntax and semantics, which use mathematical concepts. these concepts are important as they enable stating if a computational system presents a certain property or fulfills its specification.



in the last decade several case studies and industrial applications confirmed the significant importance of the use of formal methods to improve the quality of both hardware and software systems. however, the high cost to use formal methods causes them, in a general way, to be used only in the development of high integrity systems, where there is a high probability that the mistakes result in the loss of lives or serious damages. well defined specifications, verified with respect to critical properties, have provided a basis for a correct and efficient source code generation. an outstanding example is the paris metro system. the system is fully automatic and had its critical safety parts formally developed by matra transport international using the b method.



instead of using simple graphs which only have vertices and edges, some typing mechanism in the graphs is generally used. the graph typing can be done through labels, attributes or type graph. in the case of this paper, the typing is provided by a type graph. a type graph of a grammar characterizes all the types of vertices and edges allowed in the system, and all graphs of the grammar are restricted to these types. this restriction is defined by a graph morphism mapping each graph in the type graph.



should be present in the graph so that it can be applied and the changes are made by its application, where some elements are eliminated and others are created. the behavior of a graph transformation system is determined by the application of rewriting rules, also called graph productions. following the double pushout approach(dpo), a rule is composed by three graphs: the left-hand side l, the right-hand side r, and interface k which represents elements that l and r have in common. it specifies that, once an occurrence of the graph l is found in the current state, it can be replaced by the graph r, preserving k.



in general, a graph grammar describes a system which is composed by a type graph, that characterizes the types of vertices and edges allowed in the system; an initial graph, that represents the initial state of the system; and a set of rules, which describe the possible state changes that may occur in the system. besides this, the rules can have associated names. to do this, a set of rule names is defined and each name is associated to a rule by a function.



the behavior of a system specified using a graph grammar can be described by applications of the graph grammar rules in graphs which represent the system states. thus, the semantic is given by a set of graphs which derive from the initial graph. the application of a rule to a graph(derivation step) is enabled as long as there is an occurrence of the left-hand side of a rule in the present state graph, that is, if there is a total graph morphism mapping the left-hand side of the rule into the state graph.



the construction of the diagram above depends on the existence of d, called pushout complement. to ensure this existence, the match m must satisfy the gluing condition with respect to l. this condition is divided into two parts: the dangling condition, i.e., if a vertex is deleted, there can be no edges arriving or leaving from this vertex; and the identification condition, i.e., two vertices can be identified by m only if they are preserved.



if there is a rule that create some item that is needed by another one it is possible to consider that it causes this second rule. this stresses the idea that a cause provides the necessary condition for some action. in addition, because some rules can be applied simultaneously(in parallel), it is necessary that these rules are not in conflict, that is, one rule cannot delete some item used by the other rules. the following definition review causal dependency and conflict relations.



since the restrictions imposed by the res cannot be translated to a control structure of the event-b, the control structures imposed by the res are transferred to the data. in order to do this, a translation of the cggs to the ggs was defined by adding dependencies and conflicts in the rules of the grammar. these dependencies and conflicts are necessary to keep the order of the application of the rules that are defined by the res. in order to introduce dependencies and conflicts, the rightand the left-hand side of the rules and the initial graph are changed, adding new vertices. each added vertex must be new(it must be from a type which does not exist yet), since it cannot cause side effects, that is, it cannot create other dependencies or conflicts besides the expected ones. all new vertices must also be added in the type graph of the new grammar. since a rule can appear several times in a re and have different order restrictions, there can be several instances of the same rule, where each one will have different added dependencies and conflicts.



the functions right and left differ from right and left, respectively, by using the functions upfinalnames and upinitialnames instead of the originals. these new functions, change the name of an old rule by a non-deterministic choice between the old and the new rule names. this modification enables also to keep the original rule(needed to start and finish the iteration cycle).



observe that new vertices are added in the type and initial graphs, as well as, in the leftand right-hand sides of the rules. in the type graph are added all new vertices used to create the dependencies and conflicts:,,,, and. in the initial graph only one vertex was added, since there is only the start rule in the initial rules of the re. this same vertex was also added in the left-hand side of start.1 rule. given that the new vertex is only on the left-hand side of start.1 rule, this rule does not conflict with any other. note that there are two versions of start rule, this occur due to the closure operation. one version(start.1) is applied



graph grammar is a visual and intuitive language that allows specification and formal verification of systems with complex characteristics. this language was chosen because there are different techniques and tools that allow the use of model checking and theorem provers for the verification of systems properties that were described in that language. controlled graph grammars permit to set an order on the rule applications that does not take into account the state but rather an auxiliary control structure, such as regular expressions. nevertheless, there are no tools that allow formally verify properties for this kind of grammar.



