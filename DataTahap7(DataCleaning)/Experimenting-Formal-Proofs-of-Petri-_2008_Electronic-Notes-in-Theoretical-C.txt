coloured petri nets and the different refinements. then, the deduction systems and their use are presented in section 3. afterwards, a case study is addressed in section 4, where we describe different formalisations experimented. conclusions and future work are finally discussed in section 5.



in this section, we present the formalisms used in this paper, and in particular the kind of petri nets we consider. we also describe the various petri nets refinements, briefly for the type refinement, and with more details for the subnet and node refinements. we do not describe here the formal specification regarding type refinement, but we give a sufficient description for the reader to understand the discussion in section 5.



the petri nets refinements we base on, from, were defined for coloured petri nets(cpn). the definition of refinement is first adapted here for place/transition petri nets. we will show our approach first for these and will extend the work by adding colours in section 4.5.



a petri net can be represented as a bipartite graph. note that there is at most one arc in each direction for a given couple(place,transition), and the action of an arc is expressed by its direction and the value of w. note that if w is null there is no arc.



as mentioned above, three types of refinement have been defined. for the reader to understand the discussion in section 5, we provide below a brief description of these refinements. a mathematical description of the subnet refinement will also be given, since it will be formalised in section 4. the three types of refinement are presented here, and further described in.



the formal definition of this refinement is given in. as for type refinement(see section 2.2), we will only give an idea of that kind of refinement. this refinement has been formalised using one of the methods explained in section 4; we do not give all details here, but we will refer to them in section 5.



the subnet refinement can be seen as an extension of initial abstract net with a subnet linked only by input arcs to abstract net transitions. this ensures that the behaviour preservation condition holds. indeed, when adding input to transitions the firing is more constrained. therefore, if the transition is enabled in the refined net, it is also enabled in the abstract one.



hints to the system. depending on the degree of automation, the prover can essentially be reduced to a proof checker, with the user providing the proof in a formal way, or significant proof tasks can be performed automatically. we have chosen coq in order to specify and prove our refinement problem.



we present hereafter three main parts of formalisations of the subnet refinement formal proof(lemma 2.7) in commented coq code that use the three sets formalisations presented in section 3. note that the properties introduced by these different representations are not involved in our proofs, so the difference between the three possibilities will only be in the way the proof can be achieved, and also generalised.



we distinguish arcs from a place to a transition and arcs from a transition to a place. arcs are labelled by their weight(for simple petri nets, the weight is the number of tokens involved in firing the transition). an arc from a place to a transition can be represented as a pair((place, transition),n) where n is its label(that is the weight of the arc), and similarly((transition, place),n) for an arc from a transition to a place. a marking can be represented as a pair(place,n) where n is the number of tokens.



is_subnet_refinement), thanks to the tactic language ltac mentioned in section 3. the keywords match goal with allow us to match the goal(i.e. hypothesis and conclusion) with some patterns and to apply the corresponding appropriate tactics(split, unfold,...) to this goal.



we plan to solve this problem using an interface to pnml(petri net markup language,). pnml is currently being standardised within iso/iec 15909-2. it aims at becoming the common language for petri nets tools, e.g. cpn-ami, cpn-tools or other tools which handle petri nets, like fast. such files can be directly translated in coq(as in the third formalisation) so as to generate the places, transitions and arcs.



our goal is to provide a petri net refinement specification that enables a user, not familiar with formal proof assistants, to make a formal proof as well. while refinement was extensively studied for other specification languages(e.g., b, vdm/raise,...), to our knowledge, there exists neither such a work nor such formalisations of cpn and proofs of refinements.



