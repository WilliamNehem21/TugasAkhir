the question is of significance for various reasons. to start with, it is one way to determine the limits of the applicability of turing categories in studying computability. if it where impossible for the total maps of a turing category to be exactly, say, the linear time functions, then one cannot hope to use turing categories as a basis for investigating feasible computation at very low complexity levels. on the other hand, if one knows that the total maps of a turing category can be of such low complexity then turing categories can be a tool for formally unifying computability and complexity theory and allowing a fluid flow of ideas between the subjects.



the third point of interest lies not so much in the question itself as in the methods used here to provide the answer. the proof that a cartesian category satisfying certain conditions can be embedded as a category of total maps in a turing category makes use of two ideas: first, it uses the yoneda embedding to create a canonical category of partial maps into which the original category embeds. next, we use the concept of a stack machine in the presheaf category to create a partial combinatory algebra which in turn will generate the desired turing category. a stack machine can be thought of as a categorical implementation of the canonical rewrite system in combinatory logic(but augmented with additional data). as



we start the exposition by considering the much more general question of how a category can arise as the subcategory of total maps of an arbitrary restriction category.(for background on restriction categories we refer to.) this leads to the notion of a totalizing extension of the given category, and we show that the category of totalizing extensions of a particular category has a final object which is naturally a restriction category. this insight allows us to transfer the general question of finding a turing category which extends a given cartesian category into finding a partial combinatory algebra in this final extension whose total maps include the given maps. this perspective allows us to propose necessary conditions for a cartesian category to be the total maps of a turing category, see section 3. to show that these are sufficient we demonstrate that one can build, using a simple abstract machine, a combinatory algebra in the final totalizing extension(actually of a slightly modified category) which has elements representing all the total maps: this suffices in view of theorem 4.12 of. finally we provide simpler sufficient conditions to show the wide applicability of the theorem.



we are now in a position to collect the necessary conditions for being the total maps of a turing category. clearly the total map category has to be cartesian(i.e. has finite products), as turing categories are cartesian by definition. the remaining conditions are somewhat more technical. however, it should be stressed that in many cases of interest these conditions greatly simplify.



recall that an object h is called preinitial if there is at most one map from that object to any other object. it is strict preinitial if any object with a map to h is itself(strict) preinitial. preinitial objects are quite common: for example in the category of(commutative) rings z is the initial object, while zn is preinitial for each n. however, neither z nor zn are strict preinitial.



it may be useful at this stage to provide an example of a total map category which has a universal object and yet cannot be the total maps of a turing category. the simplest example, which also shows that such a category cannot consist entirely of preinitial objects, is when the category is a meet-semilattice. then the only element is the identity on the top and this must be disjoint from itself, forcing the top to also be the bottom thereby collapsing the lattice.



the step partial function is the join of all its individual components. for step to be well-defined all these components must be compatible, in the sense that they agree on overlaps of domains. those which are in separate components of the stack object by design are disjoint and so compatible. however, the names of maps are all in the same component and, thus, we must establish compatibility of the implementation of names.



to unify the abstract notion of computability embodied in turing categories with the study of feasible computation(e.g. linear, logspace, ptime,...) minimally one must know whether these functional complexity classes can form the total maps of a turing category. in it was shown that both logspace and ptime functions had a natural description as the total maps of turing categories. however, in order to obtain those results, it was necessary to use the well-known facts from complexity theory that transducers and turing machines can universally simulate themselves with an overhead which can be accommodated within(respectively) logspace and ptime. this meant the argument that these complexity classes could be modelled by turing categories relied heavily on the details of the machine models and the way in which resources were measured. in particular, as there is no widely accepted machine model which can simulate itself with a linear time overhead, the linear time maps could not be so readily included in this approach.



