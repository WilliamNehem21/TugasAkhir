consider one of the well-known proof rules of the hoare calculus. if one wants to prove that a recursive procedure p is correct wrt. a precondition p and a postcondition q, then one assumes that for all recursive calls of p within the body of p, precondition p and postcondition q hold. if p always



the hoare calculus rule for procedures is essentially an overlay of two rules. the first considers the terminating case with a postcondition. the second models the non-terminating case where the precondition holds at each procedure entry. we will see the same overlay of rules for natural semantics.



natural semantics is a deductive method to define the semantics of programs. axioms and inference rules specify semantic properties wrt. the abstract syntax. the semantics of an abstract syntax tree is defined as a state transition from the initial state into the final state. this state transition is defined compositionally in terms of the state transitions of the direct subtrees of the abstract syntax tree. consider e.g. the rules for the while-loop:



traditionally, natural semantics specifications are interpreted with finite derivation trees because only then, a unique final state exists. this traditional view corresponds to an inductive or least fixed point interpretation. in this paper, we argue why a greatest fixed point or coinductive interpretation is more appropriate. it also allows for a semantics for non-terminating programs while not changing the usual inductive semantics for terminating programs.



ple. starting at the root node of a tree, we specify how its marking is propagated through the tree. therefore we define how the marking of a node is derived from the marking of its predecessor. the first principle is structural induction and defines unique markings on finite trees. the second principle works also for infinite trees. even though a tree might not be finite, the coinductive definition specifies a possibly infinite marking process well-defined at each step.



the inductive definition principle corresponds directly with the inductive proof principle. it states that some predicate q holds for all elements in the least fixed point lfp(spec). an inductive proof is entirely constructive. q can only be verified for elements which can be constructed.



proof. analogous to the proof of theorem 3.3: by contradiction: assume that d/= d'. then there exists a position pos=[l| pos'] of minimal length such that mark(d|pos)/= mark(d|pos) and mark(d|pos')= mark(d|pos'). but then the second condition in theorem 3.4 implies that mark(d|pos)= mark(d'|pos) which is a contradiction to the assumption d/= d'. hence d= d'.



we start with the observation that each natural semantics defines an abstract data type. then we show that each natural semantics is a specification in the sense of definition 3.1. we prove that the least fixed point of such a specification describes the execution of all terminating programs while the greatest fixed point defines also a semantics for all non-terminating computations.



one can also consider the case that there are specifications such that no final state can be computed because, e.g., there might be no applicable rule. such a case is called a stuck computation. to keep the presentation simple, we do not discuss such situations here.



second condition: we need to show that those markings of the direct subtrees of eff part(d) and eff part(d') which do not denote trees are the same. these markings are the constructor symbols(i.e. the applied inference rules), the program annotations(element of prog) and the initial states in the markings of the direct subtrees of eff part(d) and eff part(d').



of natural semantics by translating it into a small-step format. induction is used to reason about the thereby defined finite and infinite state transition sequences. this is only a half-hearted approach as it does not separate between the coinductive character of the state transitions and the inductive nature of the final result defined on top of them. we want to emphasize that induction is not the appropriate proof method to reason about the state transition behavior of programs, see also our explanations about induction and coinduction for lists at the end of this section.



