design methodology for gals: the design methodology we propose for gals design can be summarized as follows: given the description of a system, the first step is to identify the behaviors of the system as a collection of concurrent processes communicating asynchronously with unbounded fifos according to a kpn moc. to ensure the correctness of the kpn model, the specification can be validated for its decidable properties related to composition, determinacy, etc. architectural exploration can then be performed to identify the appropriate gals architecture based on the kpn model. some of the constraints for choosing an appropriate architecture that we identify include area(for example, number of extra interconnects, storage elements, etc), and latency for enabling communication. based on the result of architectural exploration, appropriate refinements are applied to the kpn model.



the components in gals are associated with clocks, which are unknown to the designer. the clocks for these components are assumed to be independent. these clocks can either be generated locally by using gates such as inverters in a locked loop fashion, or can be from an external source.



we now propose a new gals architecture based on the principles of lips. recall that the communication is handled by valid-stall signals which are generated on the clocks of the components. valid and stall signals are added for each inter-component signal.



input interface process with barrier synchronization(iip): the iip is placed at the input of the synchronous component. the main idea of this process is to barrier synchronize(align) all the valid inputs for the computational block. the block can only execute once all the inputs have been realized. each iip contains buffers for each input signal to store input data values. there are exactly two storage elements for each input. this is because when the computation block is stopped by the iip, the incoming inputs need to be stored, and the stall signals for the appropriate source components have to be enabled. the need for the stall signal is realized as soon as the first storage element is filled. by the time the stall signal is enabled, the source component could have placed another valid value on the signal. therefore, the second storage is needed to store this value.



iip takes input data signals with their corresponding valid signals from its source components, and a stop signal from oip to indicate that oip is not ready to accept new values. iip provides data to the computation block, a dv signal(stands for data-valid signals) to the oip indicating it is sending a valid value, and stall signals to its source components. the iip works in two phases: in the first phase it reads all inputs and stores the data values in its buffer. in the second phase it provides the data values to the component based on its input valid signals which are written to its output.



pros and cons: the number of valid and stall signals added would increase from the handshake based gals architecture because of the fifos placed inbetween the components. however, the components in this architecture may not necessarily stop after every execution. a component will only get stalled when no data is seen on any of its inputs, or if the fifo buffers at its output channels become full. the stall signals form a back pressure mechanism that ensure that the data is not lost during communication. this type of architecture is closely related to the static dataflow architecture with the difference that more number of tokens can be stored on the channels. the fifo-based architecture will have a better performance with respect to the handshake-based architecture, and increases parallelism.



the storage structure contains fields for the inputs and outputs. each input and output field is divided into two parts: address and bound. the address part points to the location of the inputs/outputs in the lookup storage. initially, the address part for each input and output field contains its initial(starting) address. the bound part represents the maximum number of valid data locations that can be stored starting from the initial address location. in other words, the bound represents the maximum valid values that can be saved at a given time.



purpose of the structure: the organization of the fields clearly helps in identifying the addresses of the inputs and outputs simultaneously. once the address is accessed, to either read or store another value, the address can be incremented by 1 until the bound is reached. in other words, to access the next location, the address part is incremented as follows:(address+ 1)% bound. here, address and bound represent the corresponding address and bound locations(of the input/output).



we now look at how the data is organized in the lookup storage. we assume that the data that is retrieved is 32 bits. from these 32 bits, the most significant bit(msb) represents the present bit. the present bit if set to 1 implies that the data is valid, otherwise it is invalid. the actual data is 31 bits.



functionality of a storage mapping unit(smu): the smu maps the addresses of each input/output to the correct lookup storage locations. the smu contains local storage elements to store the inputs/outputs that were retrieved earlier. this is based on the number of input and output fields. we assume initially that all storage is empty. the smu also has the capability to extract the msbs of the data retrieved. this can be implemented as a simple function.



