in this paper we show how the refactoring rules can be proved using the rewriting system cafeobj. moreover, a case study showing the application of the refactorings is also developed. in this way, this work complements the formal rigour of, as manual proofs can easily hold mistakes. in addition, the results achieved suggest that rewriting systems can be used as supporting tools for the construction of refactoring environments.



this paper is organised as follows. section 2 introduces rool, the language used to formalise the refactorings. in section 3 we present three refactoring rules used to illustrate the work here developed. the rewriting system cafeobj is briefly introduced in section 4. section 5 presents the mechanisation of the refactoring proofs, as well as the implementation of two refactorings in cafeobj. a case study developed to validate the work is described in section 6. finally, section 7 gives the conclusions and directions for future work.



a complete set of rool laws can be found in. here we only introduce some laws of command and laws of classes, necessary to understand the mechanisation of the proofs, presented in section 5. the explanations of these laws are extracted from.



a comprehensive set of refactoring rules which captures and formalises most of the refactorings informally introduced in is presented in. refactoring rules are described by means of two boxes written side by side, along with where and provided clauses. we use the where clause, when necessary, to write abbreviations. the provisos for applying a refactoring rule are listed in the provided clause of the rules. here we present three examples of refactoring rules. the first one allows extracting and inlining a method, and is used to illustrate the mechanisation of a refactoring proof in cafeobj. the second one introduces set and get methods and is used to show an implementation of a refactoring rule in cafeobj, as well as its application in an arbitrary example. the last onde moves a method from a class to another, and is used in the case study developed here.



rule 1, when considered from left to right, coincides with the refactoring extract method presented by fowler[10, p. 110], whereas the application in the reverse direction corresponds to the refactoring inline method[10, p. 117]. when applied from left to right, it turns a command c2, which is present in a method m1, into a new method m2. occurrences of the command c2 in the original method m1 are replaced by calls to the newly introduced method.



in method m1 on the left-hand side of the rule, the attribute x appears in the expression exp1 and there is also an assignment to this attribute. on the right-hand side of the rule, the occurrence of self.x in expression exp1 is replaced by the local variable aux declared in m1. this variable receives the result of the call to method getx. the assignment is accomplished by a call to method setx, passing by value the expression exp2. these changes also occur in mtsa. to apply this rule from left to right, the methods getx and setx cannot be declared in the superclass of a, in a itself, nor in any of its subclasses. to apply this rule in the reverse direction, the methods getx and setx cannot be called in cds, c, or a.



on the right-hand side of this rule, the method m1 in a becomes just a delegating method: it calls the corresponding method of class b and passes the parameters in pds as arguments. the class b declares a method called m1 similar to the method m1 that appears on the left-hand side of the rule. the attribute x is accessed by means of the get and set methods declared in b itself.



(the class to where we move the method). in this way, the parameter declaration of the method in the target class would include an additional parameter: one whose type is the source class. also, clients of the target class that call the method that was moved would also need to declare an object of the source class and pass such an object as argument in the method call. to avoid the additional parameter, we restrict the method m1 not to access attributes nor call methods declared in a. for applying this rule from right to left, the method m1 must not be called in mtsb, cds, or c, as this method is removed from b.



cafeobj is a new generation algebraic specification and programming language. as a successor of the obj family(obj1, obj2, obj3), it inherits features such as: powerful typing system with sub-types; sophisticated module composition system, featuring several kinds of imports; parameterised modules; views for instantiating parameters and the module expressions, among other issues. cafeobj implements new paradigms, such as rewriting logic and hidden algebra, as well as their combinations. it is mainly used for system specification, formal verification of specifications, rapid prototyping, programming and automatic theorem proving.



the mechanisation of the proofs of refactoring rules comprises two steps: the implementation of the rool grammar and laws(section 5.1) and the automatic derivation of the rules from the laws already implemented(section 5.2). after proved, the refactoring can be implemented as a rule and used to perform program transformation(sections 5.3 and 5.4).



of the newly introduced get and set methods. the gettype operator simply returns the type of the given attribute present in the list of attributes as. operators fromlisttoconcat and fromconcattolist make the term simpler for the applications of other operations. basically, they turn an assignment of a list of variables to a list of expressions into a concatenation of assignments, with each variable assigned to its corresponding expression in the list. the function containsattribute receives an expression and an attribute name and returns true if such attribute occurs inside the given expression. the function replaceonmethod replaces inside the



createmethod operator, who creates in the target class the new method. the operator removemethod is called upon the source class and deletes the method(through the operator deletemethod, lines 35 to 37) or turns it into a delegation, using the function createdelegate, lines 30 to 33. all the remaining operators are auxiliary.



prod e supp, which represent, respectively, the date when the product was acquired from the supplier, the price payed to the supplier, the value(percent) to be added to that price, the product itself and the supplier of this specific item. to represent the sale of an item, the class sale is used. among other attributes, this class maintains the sold item, who sold it and to whom it was sold. therefore, when, for example, one wants to know if there are any products for sale it is possible to look for objects of item that are not sold.



;( var d: string@(( self. prod. get description)< d>; print< d>) end; var m: brand@(( self. prod. get brand)< m>; print<( m.



result class item: classname pri acquisitiondate: variable: string;( pri purchaseprice: variable: double;( pri profit: variable: double;( pri supp: variable: supplier: classname; pri prod: variable: product: classname;))) meth printprod: methodname^=(@(( self. prod. printprod)<>)) meth printdata: methodname^=(@( print: parcommand< self. acquisitiondate: variable>;( print: parcommand< self. purchaseprice: variable>;( print: parcommand< self. profit: variable>



;( print: parcommand<( self. supp: variable. name: variable)>; self. printprod: methodname<>))))) end class product: classname pri name: variable: string;( pri brand: variable: brand: classname; pri description: variable: string;) meth printprod^=(@( var n: variable



: string@( self. getname: methodname< n: variable>; print: parcommand< n: variable>) end;( var d: variable: string@( self. getdescription: methodname< d: variable>; print: parcommand< d: variable>) end; var m: variable: brand: classname@( self. getbrand: methodname< m: variable>; print: parcommand<( m: variable. name: variable)>) end)))( meth getname: methodname^=(( res r: variable: string)@( r: variable:= self. name: variable))( meth getbrand: methodname^=(( res r: variable: brand: classname)@( r: variable:= self



the majority of refactoring rules and laws of classes includes side conditions. when deriving the refactoring rules, we considered that these conditions are satisfied. nevertheless, to construct a refactoring environment using a rewriting system such as cafeobj, we need to provide an efficient way to check the validity of these conditions in an arbitrary program, before applying the reduction. this is a challenge task, as many condition that appear in refactoring rules rely on information provided by the rool type system. in order to implement these conditions in cafeobj, we also need to describe the rool type system or, at least, to obtain type information from the program. this is our immediate future work.



