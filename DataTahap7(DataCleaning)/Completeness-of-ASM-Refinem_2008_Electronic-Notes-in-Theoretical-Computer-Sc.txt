asm refinements are verified using generalized forward simulations which allow to refine m abstract operations to n concrete operations with arbitrary m and n. one main difference to data refinement is that asm refinement considers infinite runs and termination. since backward simulation does not preserve termination in general, the standard technique of adding history information to the concrete level is not applicable. the powerset construction also adds infinite runs and is therefore not applicable too. this paper shows that a completeness proof is nevertheless possible by adding infinite prophecy information, effectively moving nondetermism to the initial state. adding such prophecy information can be done on the semantic level, but also by a simple syntactic transformation that removes the choose construct of asms. the completeness proof is also ported to give a completeness proof for io automata.



this paper shows that a completeness proof is possible anyway. the basic idea is to define a uniform transformation that moves all nondeterminism of the concrete system into the initial state. this is possible on the semantic level by constructing a prophecy automaton, but also on the syntactic level by using choice functions. the refinement between the resulting asm and an abstract one then can always be verified using a forward simulation.



before the completeness proof, a summary of the basics underlying asm refinement is given(more details are in and). transition systems which are the semantics of asms(but also of other operational formalisms) are defined in section 2. to express proof obligations for syntactic asm rules, kiv uses a higher-order variant of dynamic logic(or wp-calculus) described in section 3. the definition of refinement correctness for asms is given in section 4 together with an improved criterion for generalized forward simulation.



for case studies it is simpler to use a logic which allows to use the syntax of asm rules directly. in kiv, higher-order wp-calculus is used for this purpose, using notations from dynamic logic. this section gives a characterization of the two main operators ef and af in terms of this logic. the logic of kiv allows to combine rules which are given operationally as abstract programs with predicate logic formulas. three operators are defined: 2 the definition of asm refinement in had separate relations ir and or for initial and final states and used io for intermediate states only. the relation io used here is their disjunction. using one relation simplifies the formulas of the completeness proof.



intuitively, the proof condition says: if states as and cs are related by r and not both final, then it must be possible to add a commuting diagram, such that r holds at the end. either this diagram may consist of abstract steps only to form a triangular m:0 diagram(first disjunct,<m0 must decrease), or(second disjunct) it must finally be possible to complete a diagram for whatever concrete steps are chosen(the size of the diagram may depend on the choices). the number of abstract steps needed to complete the diagram may be positive, resulting in a m:n diagram where both m, n> 0, or it may be zero and<0n must decrease.



since both constructions are not applicable, it seemed for a long time impossible to find a completeness proof. the key idea to finding a solution anyway is to dualize the standard constructions of completeness proofs: both, adding the full history and the power set construction remove all nondeterminism from the past and move it into the future, enabling backward simulation. instead moving all nondeterminism to the initial state enables a forward simulation. moving the nondeterminism of a transition system m to the initial state is done by predicting the full run of the system. the resulting sytem det(m) has deterministic steps only:



the proof is almost trivial by inspecting the definitions. note that the relation io is a backward simulation between m and det(m). it is a harmless one, since it preserves infinite traces. it turns out that this is the only one that is needed: given a refinement from am to cm it is always possible to define a generalized forward simulation between am and det(cm).



the semantic construction of moving all nondeterminism to the initial state is not really convenient for proving actual refinements since it involves recording all the details of future states in the initial state. in practice this is unnecessary. it is sufficient to record the outcomes of nondeterministic choices using additional dynamic functions. this can be done by a purely synactic transformation, since asms explicitly specify nondeterminism with a choose construct of the form



the construction of moving nondeterminism to the initial state is also not limited to asms. for languages based on relational calculus the task is a little more complicated since one has to check for each variable, whether it is changed nondetermistically, and on which other variables the outcome depends, in order not to introduce unneccessary parameters for the choice function. as a simple example consider the translation of z operation op to the deterministic operation det(op). since ctr is changed nondeterministically depending on the old value, a function choice(n, ctr) is needed that is specified by choice(n, ctr)> ctr.



in this paper we have given a completeness proof for asm refinement. the proof shows that generalized forward simulation alone is sufficient to prove correctness of any asm refinement, provided that in some cases nondeterminism of the concrete asm is moved to the initial state by adding choice functions that predict decisions taken during the run. the construction we have used is dual to well-known completeness proofs that add history information and prove the existence of a backward simulation, which are not applicable here, since termination must be preserved for asm refinement.



