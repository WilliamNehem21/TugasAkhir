symbolic model checking is pspace complete. since qbf is the standard pspace complete problem, it is most natural to encode symbolic model checking problems as qbf formulas and then use qbf decision procedures to solve them. we discuss alternative encodings for unbounded and bounded safety checking into sat and qbf. one contribution is a linear encoding of simple path constraints, which usually are necessary to make k-induction complete. our experimental results show that indeed a large reduction in the size of the generated formulas can be obtained. however, current qbf solvers seem not to be able to take advantage of these compact formulations. despite these mostly negative results the availability of these benchmarks will help improve the state of the art of qbf solvers and make qbf based symbolic model checking a viable alternative.



bounded model checking(bmc) has the motivation to improve on bdd based symbolic model checking by using sat procedures. already in the original paper the use of qbf decisions procedures was suggested as a tool to make bmc complete without using bdds. completeness means that an ltl property can also be shown to hold as opposed to just being able to find counter examples. in this paper we focus on simple safety properties, for which we want to prove that a bad state is not reachable. more general properties can be handled for instance through techniques from.



the completeness result of uses the fact that the diameter of the system, which is the length of the longest shortest path between two states, is an upper bound on the length of potential counter examples. the question is how the diameter can be calculated. in a qbf formula is presented parameterized by d, which is satisfiable resp. true, iff d is an upper bound on the diameter. nevertheless this



however, it is possible to generate a purely propositional sat formula without quantifiers for almost the same problem. if it is unsatisfiable, it constitutes an upper bound on the diameter. this formula is parameterized by r and is unsatisfiable iff there is no cycle free path of length r. in graph terminology a cycle free path is also called simple path, while in the maximal length of a simple path is called reoccurrence diameter.



these concepts can be refined in two ways: first the diameter and the reoccurrence diameter can be initialized. the paths, both in the qbf and in the sat case, can be forced to fulfill the additional constraint that exactly the first state is an initial state. furthermore, instead of looking for maximal simple paths starting from an initial state in a forward manner, one can work backward from a bad state. in particular the maximal length of a simple path for which exactly its last state is a bad state is also an upper bound on the maximal length of counter examples that need to be searched. we call such paths terminal.



in the special case k= 1 this technique amounts to check that the good states are an inductive invariant of the transition relation. therefore the technique is also known as k-induction. it seems to be much more successful in practice than forward checking, since it can utilize locality of properties, even if it is just implicitly through the sat solver, while a forward formulation will need to take all state bits into account.



however, simple paths can be exponentially larger than their corresponding diameters, both in forward and backward reasonings. therefore the question still remains, whether an approach using qbf reasoning would not allow to terminate the search for counter examples much earlier. also the state of the art in qbf solver technology improved considerably in recent years.



to our knowledge, there are no published results on using qbf for backward reasoning yet. unfortunately our experimental results for backward reasoning provide a strong indication that similar to the forward reasoning results of[10,17] qbf based fixpoint algorithms can not yet really compete with bdd based or other complete model checking algorithms using sat as discussed for instance in. not a single instance was solved that could not be solved with k-induction as well.



finally, we experimented with functional and relational unrollings of the next state logic. the experiments clearly show that a functional unrolling is much more compact. the generated cnf is much smaller when using syntactic substitution for next state functions instead of conjoining the transition relations. the run times of the sat solver also decreases considerably.



if these constraints are conjoined with path constraints, they allow to obtain a complete model checking procedure. if the path constraints are initialized and the result becomes unsatisfiable, then k is a bound on the reoccurrence diameter. if no counter example up to this length exists, no bad state is reachable. similarly, if the simple path constraints are conjoined with a terminal path constraint, as in kinduction, then the unsatisfiability of the result, again shows that k is an upper bound on the maximal length of counter examples that need to be considered. the formula that is checked in k-induction is the following:



we have implemented our approach in a tool called smv2qbf. it reads flat smv specifications with simple safety properties as input and translates them to qbfs. the tool has several switches corresponding to different model checking problems. it is possible to perform standard bmc, compute diameter and reoccurrence diameter, compute fixpoint, and do k-induction proofs. for most of these problems, there are two or more encodings, the standard propositional one and one using more compact qbfs.



cessing steps), like functional substitution(see sect. 6) but also bounded cone of influence in an efficient manner. 4 indeed, it should be noted that for some test cases(like the examples vis.prodcell.*), when the smv model is made fully relational and thus no functional substitutions are possible, qbf encodings sharing the transition relation(columns t(l) and t(b)) perform better than the sat encoding(column t(ir)).



this paper on one hand again provides negative results on using qbf for unbounded model checking and less negative for bounded model checking. on the other hand we were able to show that in practice qbf formulations can be much more compact than sat instances and sometimes solved faster for relational encodings. our results clearly show that much more research in qbf is needed to be able to use qbf as alternative to sat based model checking, even in the bounded case.



