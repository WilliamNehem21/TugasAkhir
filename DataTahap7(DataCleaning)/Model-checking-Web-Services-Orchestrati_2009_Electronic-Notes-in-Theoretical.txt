web services represent a well accepted implementation of service-oriented computing(soc)and their composition allows for the creation of customized complex applications based on reutilization and composition of existing services. orchestrations describe the way in which separate web services can be brought together in a consistent manner to provide a higher value service. business process execution language for web services(bpel) is the widely accepted standard that permits to define the business logic between processes interacting in an orchestration. a bpel process defines how multiple service interactions between partners can be coordinated internally, that is their orchestration, in order to achieve a business goal.



this paper is organized as follows. section 2 introduces some preliminaries e.g. syntax and semantics of the bp-calculus(section 2.2) and the logics(section 3.2). in section 3 we present the behavioural properties of the bp language. section 4 presents the verification framework that is used in section 5 to verify the illustrating example and to present the results of the verification. in section 6 we conclude and provide and some directions for future works.



terms: the set of terms t consists of variables v, names n and values(u)(integers, booleans, strings,...). for each term t, fv(t) is the set of variables in t. a message is a closed term(i.e. not containing variables). the set of messages is denoted m.



rules sco, han and s-par define the behavior of scopes and handlers. these constructs are defined as multihole contexts. thus, they can be derived from previous rules since handlers are processes. rules ift-m and iff-m model the conditional. rule eval handles function evaluation.



we then check if the formulas hold for the defined processes. if they are invalidated by the tool, we iteratively correct the processes and/or the formulas and we repeat the verification process until the system is validated. at this time, a version of the bpel process is automatically generated.



the example in the next section shows that the approach is practically feasible. since design languages usually describe few, interesting properties of a system(e.g. its behavior w.r.t. concurrency and communication), while often full verification is impossible due to the size of the implementation



a customer places an order to sell a quantity of shares by contacting a broker service. the broker invokes other composite services to check the feasability of the transaction and to perform it. this scenario is well-suited to our study because it involves several composite services.



the event handler is enabled using the eneh channel and waits for a unique event(the timeout) on channel et. then, it processes an activity(at imeout) associated with this event. it is disabled using the diseh channel and yeh signals the disabling of the event handler.



the fault handler deals with three kinds of faults: sf={fbb, fesd, fasd} together with their associated activities: f={fbb, fesd, fasd}. it is enabled using the efh channel and then the activity associated with the triggered fault is processed. finally it signals its termination to the calling scope and the activating throw using the yfh and the channel r. it is finally disabled using the channel disfh.



in this model all the desired properties have been validated(except one safety property that is accepted anyway). in the case where some properties are invalidated, one must modify the specification in such a way that all the properties are accepted. the verification process is re-iterated until all the desired properties are validated. at this time, we can proceed to the automatic generation of the bpel code.



