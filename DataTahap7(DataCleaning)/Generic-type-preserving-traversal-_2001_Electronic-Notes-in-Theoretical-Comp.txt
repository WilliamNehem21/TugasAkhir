a typed model of strategic rewriting with coverage of generic traversals is developed. the corresponding calculus o ers, for example, a strategy operator 2(), which applies the argument strategy to all immediate subterms. to provide a typeful model for generic strategies, one has to identify signature-independent, that is, generic types. in the present article, we restrict ourselves to tp|the generic type of all t ype-preserving strategies. tp is easily integrated into a standard many-sorted type system for rewriting. to inhabit tp, we need to introduce a(left-biased) type-driven choice operator&. the operator applies its left argument(corresponding to a many-sorted strategy) if the type of the given term ts, and the operator resorts to the right argument(corresponding to a generic default) otherwise. this approach dictates that the semantics of strategy application must be type-dependent to a certain extent.



to describe traversals in standard rewriting(without extra support for traversals), one has to resort to auxiliary function symbols, and rewrite rules have to be used to perform the actual traversal for the signature at hand(usually one rewrite rule per term constructor). generic traversal primitives support an important dimension of genericity in programming. in, for example, generic traversal strategies are used for language implementation: algorithms for free variable collection, substitution, uni cation and others are de ned in a generic, that is, language-independent manner by suitably parameterised generic traversals.



in section 2, we shortly recall untyped strategies including primitives for traversals. in section 3, we discuss standard many-sorted types for typepreserving strategies. 2 in section 4, we provide a type system which includes a generic strategy type tp for generic type-preserving strategies. to this end, we also need to introduce a type-dependent choice operator to mediate between many-sorted and generic strategies. in section 5, we discuss implementation issues. in the course of the article, we show that our type system for strategies is sensible from a strategic programmer's point of view. we envision that the presented type system disciplines strategic programs(employing generic traversals) in a useful and not too restrictive manner. we also show that generic type-preserving strategies can(more or less) easily be implemented. the article is concluded in section 6.



the work of the author was supported, in part, by nwo, in the project\generation of program transformation systems". the ideas developed in the article took shape during a visit of the author to the protheo group at loria nancy. i am particularly grateful for the interaction with my colleague joost visser|in nancy and in general. many thanks to christophe ringeissen who shared an intensive and insightful elan session with joost and me. i want to thank david basin, horatiu cirstea, h el ene kirchner, claude kirchner, paul klint, pierre-e tienne moreau, christophe ringeissen, jurgen vinju and eelco visser for discussions on the subject of the article. finally, many thanks to the anonymous workshop referees for their constructive criticism.



we set up a rewriting calculus very much inspired by elan, the-calculus, and system s. we are very brief regarding explanations, examples, and details of the semantics. some basic knowledge of strategic rewriting(as found in[2,21,5]) is a helpful background for reading the present article.



2 as for terminology, we use the term\type" even for types of many-sorted terms(as opposed to the term\sort"). the term\type" is more common in the context of type systems. also, we might easily go beyond just many-sorted terms, and deal with polymorphic datatypes.



new strategy combinators can be de ned by means of an abstraction mechanism which we call strategy de nitions. similar mechanisms are provided by elan, system s and stratego. a de nition'( 1;:::; n)= s introduces an n-ary strategy combinator'. an application'(s1;:::; sn) of' denotes the instantiation s[ 1:= s1;:::; n:= sn] of the body s of the de nition of'. strategy de nitions can be recursive. 4



the rst two strategies are generic. try(s) applies s, but behaves like id if s fails. repeat(s) repeatedly applies s as often as possible. the strategy ip-top is speci c in nature. it reconstructs the strategy of the same name introduced earlier in example 2.1. the reconstruction illustrates the use of try.



let us take a closer look at the generic traversal primitives to apply a strategy s to all children(2(s)), or to some child(3(s)). the operators 2() and 3() are de ned like in system s. for brevity, we do not consider the hybrid operator 32 from system s which applies a strategy to one or more children.



we extend our syntax for strategy types, namely we add one case for generic types. in this article, we only consider one particular generic type, namely tp representing the type of all t ype-p reserving strategies. in, we also consider type-changing strategies. our grammar of types is extended as follows:



now that we have typed generic traversal operators, the question is how we inhabit tp. so far, we only have two trivial constants of type tp, namely id and fail. we would like to construct generic strategies from rewrite rules. it turns out that we lack a construct to perform inhabitation in a typeful manner. we also need to relax the typing rules for some existing combinators in order to make it easy to apply generic strategies in a speci c context.



example 4.2 we recall the solution to the rst problem from the introduction as given in example 2.3. the original(stratego-like) solution is not typeable because a many-sorted strategy, namely nat; n! succ(n), is passed to stoptd which expects a generic argument. we recover typeability by the following rede nition of traverse(i): w.r.t. success and failure. this separation makes it explicit where we want to become generic. there is no hidden way how speci c ingredients can get generic accidentally. without separating the two kinds of choice, strategies get too easily(say accidentally) generic and typeable.



type of a congruence strategy(cf. rule[congr]) is dictated by the well-formed context which is used to lookup the sort of the function symbol at hand. the types of 2(s) and 3(s) are uniquely de ned as tp. the type of s1& s2 is the type of s2.



to eliminate the typing premise determining the type of the many-sorted strategy s1 in s1& s2, the following approach is appropriate. we statically perform an elaboration step which follows the very scheme of the type judgement for strategies, but transforms strategies. we want to turn strategy expressions of the form s1& s2 into s1:& s2 where we propagate the strategy type of s1 explicitly as type annotation. during strategy application, the annotation can be used to organise the choice. the updated rules for strategy application will be shown in a second. the relevant elaboration rule takes the following form:



we also do not want to determine the type of the term at hand at rewriting time(as it is the case in the original rules for&). in some way or another, we should tag terms with types. we show a replacement for the positive rules for&. the replacement relies on the elaboration described above, and on tagged terms in strategy application.



as we can see, the static typing context is not needed anymore. instead the reduction of hs1:& s2it: relies on the annotations and. to be precise, the context is de nitely not needed for the semantics of& anymore, but the combinators 2() and 3() deserve an additional comment. as these combinators descend into terms, the types of the subterms of a term also need to be known. some options to accomplish this knowledge are the following: be de ned in a module dedicated to tp. then, we need to overload& for all sorts in the signature at hand in the same way as the ordinary manysorted strategy combinators. each application of the combinator& in a compound strategy refers to a speci c sort, and hence static elaboration is not needed to determine the type of the many-sorted strategy in a typedependent choice. the rewrite rules for 2() and 3() could be generated by a pre-processor in similarity to the dynamic typing and implosion+ explosion approach in. one can also leave it to the rewrite engine to implement 2() and 3(). as for type-dependent choice, the rewrite engine is in fact the more obvious choice. here we assume that the rewrite engine has access to the type of the given term. to summarise, the described simple implementation is enabled by some fundamental concepts of elan, namely parameterised modules(needed for sort-indexed overloading of strategy combinators), and a general



another topic for future work is the integration of our results into existing rewriting calculi. the-calculus provides an ambitious rewriting calculus. part of the-cube is typed(but not generic traversals expressiveness). one of the challenging properties of the-calculus is that rewrite rules are highere. visser and z.-e.-a. benaissa. a core language for rewriting. electronic notes in theoretical computer science, 15, september 1998. in c. kirchner and h. kirchner, editors, proceedings of the second international workshop on rewriting logic and its applications(wrla'98), pont-a-mousson, france.



