the verification logic for rewriting logic(vlrl)[3,10,11] is a modal action logic in which rewrite rules are captured as actions. it supports the verification of properties of systems specified in rewriting logic[6,7]. in order to express the properties of the system, vlrl allows the definition of observations of the behaviour of the system. in this way, it is the user who determines in each case the facts of the system that he wants to emphasize.



propositions from observations; then the translation of a vlrl action formula to an ltl formula is explained. section 5 shows the use of the maude model checker for proving some vlrl formulae. finally, the appendix contains the complete specification of the example presented in the paper.



rl[a-enter]:$< a, wait>=>< a, critical>. rl[b-enter]:#< b, wait>=>< b, critical>. rl[a-exit]:< a, critical>=>< a, wait>#. rl[b-exit]:< b, critical>=>< b, wait>$.



it may seem surprising that the concurrent action a-enter b-enter actually corresponds to two steps in the transformed theory: this is enforced upon us by the fact that the maude model-checker works by taking one-step rewrites. since it is not possible to foresee in advance what concurrent steps will take place, the best we can do is just to translate each original rule into a single one in the transformed theory and to rely on their interleaving to allow for all possible concurrent actions. it is precisely the second argument, when its value is concur, which tells us that the interleaving must be interpreted as a concurrent action whose complete name appears as the third argument.



the first operation adds to a state information about the action used to obtain it. these extended states are the result of applying a transformed rewrite rule of the original system(see, e.g., rule a-enter at the end of this section). the second operation is used to single out the subterm to which the rewrite rule will be applied. this operation is combined with the last one and the rule descend below to decompose a state into its components.



the first one eliminates the marks of a marked state. the second one updates the marks of the state given as its second argument with those of the marked state given as its first argument. and the third operation constructs an action out of two actions by adding the first to the second one. we illustrate their behavior with the following reductions, that arise in the last step of the second example in section 3.1:



the presented procedure is general, in the sense that it can be adapted to any system specified in rewriting logic. for a specification with a commutative and associative structure like that in the mutex example the changes should be minor, if any. for arbitrary theories the underlying idea is the same but the construction is more involved. in particular, we have been able to use a single sort action(together with a supersort) to represent actions because the rules in the system only involve terms of a single sort, conf. but if there were rules for more sorts then it would be necessary to have a pre-action sort for each of them, and to modify the extension of the operators in the signature to actions in a corresponding manner.



