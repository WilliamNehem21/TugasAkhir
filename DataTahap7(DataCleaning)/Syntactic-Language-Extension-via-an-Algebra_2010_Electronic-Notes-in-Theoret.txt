catamorphisms. these transformations are specified relative to a source and a target language which are defined via context-free grammars(cfgs). catamorphisms have previously been studied and proven sufficiently expressive as a means for extending a large variety of programming languages via transformation[5,6,7]. hence, the main focus of this paper lies not so much in addressing the expressiveness and which transformations can be achieved as on showing how algebraic combination of languages and transformations results in highly modular and incremental language extension. incremental and modular means that any previously defined languages or transformations may be composed algebraically to form new languages and transformations. safety means that the tool statically guarantees that the transformations always terminate and only map syntactically legal input terms into syntactically legal output terms; efficiency means that any transformation is guaranteed to run in linear time(in the size of input and generated output).



the tool may be used for many different transformation purposes, such as transformation between different languages(e.g., for translating java programs into html documentation in the style of javadoc or for prototyping lightweight domain-specific language compilers), transforming a given language(e.g., the cps transformation), format conversion(e.g., converting bibtex to bibtexml). however, in this paper we will focus on language extension for which we have the following usage scenarios in mind: 1) programmers may extend existing languages with their own macros; 2) developers may embed domain-specific languages(dsls) in host languages; 3) compiler writers may implement only a small core and specify the rest externally; and 4) developers or teachers may define languages incrementally by stacking abstractions on top of each other. we will substantiate these usage claims in section 6.



a catamorphism(aka., banana) is a generalization of the list folding higherorder function known from functional programming languages which processes a list and builds up a return value. however, instead of working on lists, it works on any inductively defined datatype. catamorphisms have a strong category theoretical foundation which we will not explore in this paper. a catamorphism associates with each constructor of the datatype a replacement evaluation function which is used in a transformation. given an input term of the datatype, a catamorphism then performs a recursive descent on the input structure, effectively deconstructing it, and applies the replacement evaluation functions in a bottom-up fashion recombining intermediate results to obtain the final output result.



a key issue in building the tool was the choice of whether to work with abstract or concrete syntax. everything we have presented so far has been working exclusively on the abstract syntactic level. for practical usability of the tool, however, it turns out to be more convenient to work on the concrete syntax. note that because of the addition operators of the algebra, it is important that particular choice of parsing algorithm be closed under union.



systems based on attribute grammars(e.g., eli, jastadd, and silver) may be used to indirectly express source-to-target transformations. this can be achieved through turing complete computation on the ast of the source language which compute terms of the target language in a downward or upward fashion(through synthesized and inherited attributes), or combinations thereof. in contrast, catamorphisms are restricted to upward inductive recombination of target asts. our transformations could easily be generalized to also construct target ast downwards, by simply allowing catamorphisms to take target typed ast arguments(as detailed in, p. 17). this corresponds to a notion of anamorphisms and hylomorphisms, but would compromise compile-time elimination of composition(since anamorphisms and catamorphisms in general cannot be fusioned into one transformation, without an intermediate step).



in order to issue strong safety guarantees, in particular termination, we clearly sacrifice expressibility in that the catamorphisms are not able to perform turing complete transformations. however, previous work using constructive catamorphisms for syntactic transformations(e.g., metafront and xsugar) indicate that they are sufficiently expressive and useful for a wide range of applications.



