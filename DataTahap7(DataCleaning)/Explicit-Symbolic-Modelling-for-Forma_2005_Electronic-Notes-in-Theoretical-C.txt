due to the ever-growing complexity of computing applications, automatic tools have been used to help developers to find bugs in hardware and software systems. two approaches that have been applied to achieve this goal are simulation and formal verification. the simulation approach consists of executing tests over given inputs and examining the results. this technique can easily evaluate both control and data aspects, but generally only part of the set of states is examined. in other words, simulation can state that specifications hold for some inputs, but it does not prove correctness over the whole set of states.



formal methods include mathematical based languages, techniques and tools for specifying and verifying hardware and software systems. complex systems and critical applications benefit from formal methods because they make systems more reliable. different from simulations, formal verification techniques execute exhaustive searches over problem domains, proving conformity to specifications instead of only pointing errors for some input data.



in this paper, we propose a model for combining explicit and symbolic representations in an explicit-symbolic formal verification model. we intend to use explicit and symbolic techniques together to verify the same model and to make it possible to employ the most efficient technique to each aspect of the model. in the next section, we present related works and our main goals. after that, we develop the explicit-symbolic model and show how generate it from a labeled state-transition system. then, we discuss how formal verification tools can use our model to verify systems given in the verimag intermediate format. the algorithms developed for the integration of underlying models are also shown. finally, we present our next steps and some remarks.



our explicit-symbolic model integrates the underlying explicit and symbolic models. so, it has to do with explicit and symbolic verifiers and their techniques. currently, spin and jpf are well-known and largely used explicit-state model checkers. on the other hand, smv, nusmv and verus are representative and successful symbolic-state model checking tools. existing algorithm optimizations from such tools, like the on-the-fly technique used by spin, should be considered for the implementation of underlying models in order to improve the model checking.



the approach adopted in the slam project is the one that more closely relates to our project, as it employs both explicit and symbolic models inside a same environment. slam extracts abstract models from c code and statically checks temporal properties of software. also, slam uses predicate abstractions, symbolic reasoning and iterative refinement. bebop is the part of slam liable for performing reachability analysis of boolean programs.



comparing to our explicit-symbolic model, slam lacks flexibility because control-flow and data-flow information must have explicit and symbolic representations, respectively. the proposed model is more general because it allows us to move variables between explicit and symbolic spaces according to any policy. thus, we can experiment with a variety of combinations and choose the one that best fits the system needs. see section 7 for more details about the flexibility of the proposed model.



although an explicit-symbolic model can be directly generated from a labeled state-transition model, we decided to accomplish this task in two distinct steps. initially, both explicit and symbolic models are generated as projections induced by the partitioning of variables of the original model. next, the explicit and symbolic models are combined to compose the explicit-symbolic model. such approach provides a more intuitive and clear procedure to understand the formalization of the model.



the intermediate format, also called if from now on in this paper, is a language that has been developed in order to model asynchronous communicating real-time systems. it has been used as interchange format between a set of validation tools known as if validation environment. if models are composed from process instances, running in parallel and interacting asynchronously through shared variables and message-passing. message-passing is accomplished by means of signals, instances of signal routes and fifo communication buffers.



in this section, we apply the explicit-symbolic modelling to if models. first, we describe the main components in the language and present some examples of its constructions. next, we show how those components are employed for generating both explicit and symbolic models. finally, we combine explicit and symbolic models in order to emulate the behavior of the original model by means of the explicit-symbolic model.



control states define the behavior of a process by means of actions, transitions to other states and, possibly, substates. there is not theoretical limit for the number of nested substates. state specifications include temporal constraints and the set of deferred signals. the initial state is defined by the keyword#start during the state definition. because model checkers need to keep track of the current state being visited, our explicit-symbolic model uses a variable for storing such information. from now on, we refer to such variable as the program counter.



our algorithms assume the system properties are given in computation tree logic, ctl for short. ctl is an important branching temporal logic with a discrete notion of time. ctl is sufficiently expressive for the formulation of an important set of system properties, allowing safety, liveness, fairness and deadlock freedom to be specified. for details regarding the semantics of ctl, please refer to.



during the parsing of atomic propositions, we must consider two different situations. first, the atomic proposition ap can be explicit, being represented in an explicitly coded state. second, ap can be symbolic, being represented by a bdd. independently of the situation, inputs must produce a set of explicitsymbolic states s.



rithm of tarjan, for example. next, line 05 adds all the explicit-symbolic states belonging to the strongly connected components into the solution s. finally, lines from 06 to 13 are used for finding all of those states that lead to states in s.



given the input state set i1={(es1, ss2),(es2, ss1),(es4, ss1)}, consider that it is processed in the order presented. each iteration of the outer loop of the ex algorithm considers a specific input explicit-symbolic state. for the first state,(es1, ss2), the algorithm initially computes the set of predecessors e1 for its explicit component, es1, by using line 04. after that, the loop spanning lines 05-15 computes predecessors of the symbolic component, ss2, by considering only symbolic transitions associated to relevant explicit transitions. the relevant explicit transitions are those from states of e1 to



in this paper, we proposed a model that combines explicit and symbolic representations. the conceived explicit-symbolic model considers that explicit and symbolic techniques should be used in an integrated and synchronized fashion, allowing us to have a better exploration of the search space of the modeled systems. thus, our main contribution is the proposal of a flexible environment for the formal verification of systems. currently, our efforts are driven to the computational implementation of the explicit-symbolic model and its algorithms, considering systems specified in the intermediate format. such implementation will help us to improve the conceptual model and will make it possible to measure the impact that different representations have over the verification of control and data-flow intensive systems. according to the literature, it seems to be a good choice to represent control-flow explicitly and data-flow symbolically, as done in slam. future experiments will make it possible to have more information to answer this question.



