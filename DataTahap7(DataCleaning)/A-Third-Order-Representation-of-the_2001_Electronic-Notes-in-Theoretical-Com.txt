the-calculus[11,10,4], a proof theory for the implicational fragment of classical logic, has been established as a general tool to reason about functional programming languages with control, e.g. continuations and exceptions. it is basically an extension of the-calculus by a second binder. some of its properties like strong normalization and con uence are very fundamental for its use in functional programming and proof systems; a formal veri cation of these basic properties is therefore desirable. human proofs are error-prone; even these which have undergone the scienti c review process. for instance, the rst published proof of con uence for the-calculus contained a aw that was only recently corrected.



to our knowledge, properties of the-calculus have not been veri ed mechanically so far. this article intends to provide a working point by giving two possible encodings of the-calculus in a higher-order abstract syntax. as it will be seen, the-calculus is one of the rare examples that can best be represented in a way that involves a third-order constructor. this representation will enable a natural implementation of the structural or mixed substitution that has been discussed controversially in the literature[10,16,6,4].



the contra rule is analogous to the fact in logic that:a and a entail a contradiction. note that there is no rule which constructs an inhabitant of a cotype. thus, if c: a holds, c must be a-variable a. the term[a]m resulting from the application of a-variable a to a term m has no type, but it is said to be named by a and hence is called a named term.



in the simply-typed-calculus each normal term m has the subformula property: if x1: a1;:::; xn: an` m: a then each subterm of m is an inhabitant of a type given by a subformula of a or ai for some i. each term m has a normal form which can be obtained by a nite number of-reductions. the reduction relation is given by the compatible closure of the-axiom.



the reduction relation induced by the three axioms, and is con uent. however, a straightforward adaption of the tait and martin-lof parallel reduction method fails. this was overlooked in the original con uence proof, and only after years a correct proof was given by baba, hirokawa and fujita. they found that in its straightforward de nition parallel reduction does not have the diamond property. this is due to the twofold e ect ofreduction: it may create a-redex but at the same time disrupt a-redex.



the-calculus can be extended by datatypes, case-distinction and recursion to form the core of a programming language. this has been done by ong and stewart who named the resulting toy language pcf. we will stick to its core v which is the-calculus with a call-by-value reduction strategy.



terms. the crucial question is:\what do-variables stand for?" the smallstep semantics suggested that they are placeholder for evaluation contexts. this is con rmed by the nature of the structural substitution which replaces contexts with contexts. we make use of the fact that contexts can be represented directly in! as functions from terms to terms and set= tm! nam. hence, the type of the constant mu is third-order:



in the following we will re ne and encode the small-step semantics(m; e))(m0; e 0) given in sect. 3.2. the original formulation has a little aw: during the process of evaluation the environment e grows monotonically and accumulates contexts that will never be used again. we give a modi cation that uses substitution instead of environments and includes the decomposition of the subject m into evaluation context c and redex r. the-constant eval denotes the top level evaluation context.



context c" but on the right hand side it is just the named term[c]m. after each step we decompose the reduct n afresh into[eval]m. this is possible since the following invariant holds: if c and m are closed and[c]m) n, then n=[eval]m0 for a closed term m0. obviously it holds for the rules),



an application of this rule has the following e ect:[a] b:m is reduced by the-rule, and additional reductions may occur within m. the hypothesis introduces a new parameter b since we step under the binder. to make this rule local, it has to be added for each-variable that is introduced as a parameter and therefore also for b. thus,=) has to be inserted into itself. this leads to an in nite chain of local rules and cannot be implemented.



to improve support of the second-order representation, the logical framework could be extended to allow type re nement. the type of canonical expressions would be a re nement(a subtype) of the type of expressions. the fact whether a term h is canonical could be decided and the proof of can h would be irrelevant and could be hidden. the theoretical foundations for such an extension of the logical framework have been laid by pfenning.



the third-order representation can be used to prove many properties of the-calculus. for a start, i have formally shown soundness of the big-step semantics given by ong and stewart wrt. to an evaluation-frames-stack small-step semantics. i expect more applications of the encoding in the future.



it was ralph matthes who rst interested me in the-calculus. frank pfenning and brigitte pientka deserve my gratitude for many discussions and ideas. for comments on the draft i thank ralph, frank and the two anonymous referees. last but not least, i thank the creator for the framework in which human life and thinking can take place.



baba, k., s. hirokawa and k. fujita, parallel reduction in type freecalculus, in: proceedings of cats 2001(computing: the australasian theory symposium), electronic notes in theoretical computer science 42(2001), also appeared as technical report doi-tr-177, kyushu university, fukuoka, japan.



