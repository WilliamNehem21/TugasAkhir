the first four lines of commutativegroup are declarations(the parameter keyword) of a set s, a constant zero, a binary operation add, and a unary operation neg on s. the implicit type declaration says that, unless otherwise specified, variables x, y and z are presumed to range over s. with the definition keyword we define a binary operation sub, while the four axioms say that s, zero, add and neg together form a commutative group.



there are several ways to characterize or construct real numbers. even though they all result in isomorphic structures(as ordered fields), the choice of a representation and basic operations can have an enormous effect on efficiency of an implementation. since we wanted to achieve performance that was comparable to fast implementations of exact real arithmetic such as irram[15,14], reallib[10,9] and mpfr, we looked for a theoretical model that would correspond closely to these under translation by rz. a good starting point are the following observations about characteristics of irram, reallib and mpfr:



it may seem wasteful to restart entire computations from scratch when the initial precision turns out to be too low. indeed, earlier implementations of exact reals worked by propagating the precision backwards through intermediate computations in order to guarantee a final result with goal precision. but this often turned out to be even more expensive because the needed intermediate precisions tend to be overestimated so that too much work is done.



the fact that the nonnegative integers satisfy the induction principle determines the ring of integers uniquely up to isomorphism. the rest of the axiomatization of integers deals with quotients and powers of two. this part of the theory is not strictly necessary, but is useful for an implementation of dyadic rationals.



where stage x k is the approximation to x obtained at stage k. this is very similar to dense above, except that there is no guarantee about the quality of k-th stage. instead, all we know is that the next stage is no worse than the previous one 9 and that x is the only number which is approximated by all stages. in other words, x is the supremum of the chain of its approximations, which strongly suggests that we should look at a domain-theoretic construction of real numbers.



we finally come to the theory of real numbers, shown in appendix e. we first include the theory orderedfield, see appendix a, which takes care of basic arithmetic and the lattice operations min, max. the rest of the axiomatization deals with the relationship between reals and the interval domain, continuity of arithmetic operations, completeness properties of reals, linear order, and the archimedean property. we briefly comment on each of these.



the reals are isomorphic to the space of maximal elements of the interval domain. thus we postulate two maps to interval and of interval which convert real numbers to maximal intervals and vice versa. because in the implementation we happen to use the same datatype to represent both reals and intervals, the conversions are just identities. in fact, we could have avoided them altogether if we defined reals to be the maximal intervals, but we did not do that because we wanted to keep a clear distinction between the abstract characterization of reals and their representation as maximal intervals.



metic. we hoped, but did not expect the performance of era to rival that of other libraries. indeed, initial measurements involving just basic arithmetic operations show that irram is about 40 times faster than era. such a large difference can be partially explained by the fact that c++ generally compiles to more efficient code than objective caml, and that irram is a much more mature and highly optimized piece of software. the gap ought to decrease in the future, as we find ways to improve the performance of era.



rz is similar to various tools for formalization of mathematics, most notably to the proof assistant coq, which not only allows one to axiomatize theories, but also to construct models and formally prove their properties. coq is able to extract trusted code from proofs, which gives us a specification as well as its implementation. while this has turned out to be a very successful technique in many respects, current code-extraction methods produce only purely functional code which does not compare favorably to efficient hand-crafted code at all. the goal of rz was to give programmers a light-weight tool which would allow them to connect the theoretical models with implementations, but would not force them to write proofs instead of programs.



in fact, one could use rz to axiomatize theories and then proceed with their implementation within coq. in this case rz can be seen as a tool which automatically separates the computationally relevant and irrelevant parts of a theory, 12 something that is done by hand in coq. another possibility would be to manually write code and then use a proof assistant such as coq, to prove that the code actually satisfies the rz specification.



the current era implementation is only an initial prototype which we intend to extend and improve. the objective caml module system allows us to easily experiment with various libraries for big integers and interval arithmetic, as well as to mix floating point computations with exact ones. these are all possibilities we wish to explore.



