delphin is a functional programming language built to facilitate the encoding of, manipulation of, and reasoning over dependent higher-order datatypes. delphin is a two level system that separates data-level functions from computation-level functions. the data level is the logical framework lf, which supports dependent types and higher-order abstract syntax(hoas). the computation level provides mechanisms such as case analysis and recursion to allow for the manipulation of



delphin is first and foremost a general purpose programming language supporting complex data structures. however, it also contains strong tools for metareasoning allowing one to determine if functions are total and hence delphin can also be used to formalize proofs. thus, it is well-suited to be used in the setting of the logosphere project, a digital library of formal proofs that brings together different proof assistants and theorem provers with the goal to facilitate the exchange of mathematical knowledge by converting proofs from one logical formalism into another. delphin has been successfully used in expressing translations between hol, nuprl, and various other logics.



we distinguish lf terms from computation-level expressions by enclosing the former in<...>. for example, the expression ef refers to computation-level application whereas the application in<m n> occurs at the lf level. similarly, terms of type<a1-> a2> are<m> where m is an lf function.



delphin pervasively distinguishes between lf types a, parameter types a#, and computation-level types t. in the expression{<x>}e, the variable x has type a#. additionally, x also has type a, and as such a# can be seen as a subtype of a.



since one may dynamically create arbitrary parameters, a delphin function expects arguments that are constructed from constants in the signature as well as dynamically introduced parameters. for example, given a function foo, the evaluation of{<x:(exp a)#>}foo<x> would get stuck if foo did not provide a case for parameters of type exp a. in delphin, we use the params keyword to indicate which parameters our functions are intended to handle. note that a function may call a function with a different params specification as long as the callee can handle all the parameters of the caller. the ability to call functions that make sense with respect to different parameters is known as world subsumption.



we write t1-> t2 for the type of non-dependent functions, and we write<x: a>-> t when x can occur in t. observe that the variables a and b occur free in the type of ba. the full type of ba is<a: tp>-><b: tp>-><comb a-> comb b>-><comb(a ar b)>. the omission of the first two argument types tells the frontend to treat the first two arguments implicitly. this greatly simplifies our code as it is redundant to explicitly supply an input argument which is indexed in another input argument. when applying the function, the reconstruction engine will automatically fill in the implicit arguments. this support is just a frontend convenience and does not affect the underlying theory.



since computation occurs with respect to a dynamic collection of parameters, determining if a list of cases is exhaustive is a non-trivial problem. if a list of cases is incomplete, delphin will return a match non-exhaustive warning providing a list of cases which are missing. additionally, if one tries to call a function which makes sense with respect to an incompatible collection of parameters, delphin will return a world subsumption error. if no warning message is generated, then programs are guaranteed not to get stuck(i.e. type safety holds).



the problem of determining if a list of cases is exhaustive is also referred to as coverage checking. earlier work determines coverage of closed lf objects. this was extended for use in twelf by supporting lf objects which are open with respect to a collection of blocks. in delphin, we support lf objects that are open with respect to a collection of parameters, and handle coverage on computation-level expressions in a similar way.



if a function passes the coverage checker and is terminating, then it is total and may also be interpreted as a proof. the termination checker for delphin is currently only a prototype and supports lexicographic extensions of the subterm ordering over the inputs. the default termination order is lexicographic on the first input, followed by the second, and so on. however, we omit(1) implicit arguments



hindley-milner type inference. we have an extensive case study of mini-ml. we have implemented the operational semantics, proved value soundness, and proved type preservation. the most interesting feature is a hindley-milner style typeinference algorithm. parameters are used in place of references, where a new parameter can be thought of as a fresh memory location.



unlike delphin, twelf cannot support parameter functions as its meta-logic is not higher-order(i.e. inputs and outputs cannot be meta-level functions). instead, twelf uses blocks to specify that certain parameters are introduced together. one can convert twelf programs to delphin, where blocks are replaced by parameter functions, whose extensions can be naturally and succinctly expressed using the with keyword.



delphin provides a top-level interactive loop where one may write, execute, and experiment with programs. error and warning messages are reported in the same format as in sml of new jersey, allowing one to use the sml emacs mode to jump to error locations easily. one may load lf signatures(twelf files) by typing sig use"filename" and may run delphin files by typing use"filename". for illustrative and debugging purposes, delphin provides the ability to pretty-print arbitrary delphin expressions with options to make pattern variables and implicit arguments explicit. additionally, delphin allows the disabling/enabling of the coverage checker and the termination checker.



