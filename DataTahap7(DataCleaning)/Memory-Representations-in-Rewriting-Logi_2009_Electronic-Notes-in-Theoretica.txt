in earlier work, the impact of design decisions on performance was explored in the context of kool, a pure, object-oriented language defined using rewriting logic semantics. that work focused on two particular facets of the language design: the representation of all values as objects, and the use of a global flat memory representation. analysis performance was improved by making changes to each of these facets. for the first, scalar values were introduced alongside objects, with auto-boxing functionality used to automatically convert scalars to objects when needed. for the second, memory was divided into pools, one global pool for shared memory, and one local pool for memory locations visible in only one thread. these modifications improved analysis performance dramatically, with auto-boxing also improving execution performance.



as mentioned above, it is not possible in silf to dynamically allocate memory or take the addresses of variables. this prevents addresses from escaping a function, since there is no way to return a pointer to something inside the function; because of this, it should be possible to discard all memory allocated for the function call when the function returns 5. a conceptually simple way to do this is to change from a flat memory to a stack of memories, with the memory for the current function on top and the global memory on the bottom. memories can still be treated as sets of storecells, but each set can be much smaller, containing just the cells allocated in the current function, and each set can easily be discarded simply by popping the stack at function return. following this reasoning, the memory model for silf can be changed appropriately:



klocs deserves special comment, since it is the main operation that needs to be modified to account for new language features. klocs is defined for each computation item in the language that may hold locations. this means that, when new computation items which can contain locations are added, the collector must be updated properly. a method of automatically transforming a theory into one with garbage collection would eliminate this potential source of errors.



one point which has not yet been addressed is correctness. adding a garbage collector to a language should not actually change the results of any computation. the proof that this holds true is sketched here, and will be included in full in a technical report.



first, by definition, if the collector works correctly program behavior will not change. this is because only unreachable locations will be collected; since the values stored at these locations cannot be used in the computation, removing them will not alter the results of the computation. only if the collector either alters the value at a location or collects a reachable location will program behavior potentially change. showing that the collector is correct then involves showing that the following facts hold: 1) when the root locations are gathered from the state, no root locations are missed; 2) locations reachable from the root locations are always marked; 3) values at marked locations are not changed by the collector; 4) marked locations are not collected.



. the work in this paper is related to prior work on silf and kool[14,13]. research in rewriting logic semantics focused on performance has mainly been aimed at analysis performance instead of execution performance. earlier work on java focused on producing a high-performance analysis tool for both the java language and java bytecode[11,9], while earlier work on kool focused on improving analysis performance, even potentially at the expense of reducing execution performance. there has also been some work on techniques, such as partial-order



outside the realm of rewriting logic semantics, research on memory management, including garbage collection, has been extensive. the collector presented here is novel only in that it has been formally defined in rewriting logic, but beyond that is a fairly basic mark-sweep collector. resources on garbage collection, including research focused on pure object-oriented languages[27,28], provide additional information on this topic.



