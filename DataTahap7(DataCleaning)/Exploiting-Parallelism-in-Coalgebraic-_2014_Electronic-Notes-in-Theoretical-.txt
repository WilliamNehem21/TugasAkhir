we present a parallel implementation of coalgebraic logic programming(coalp) in the programming language go. coalp was initially introduced to reflect coalgebraic semantics of logic programming, with coalgebraic derivation algorithm featuring both corecursion and parallelism. here, we discuss how the coalgebraic semantics influenced our parallel implementation of logic programming.



the endofunctor pf pf necessarily has a cofree comonad c(pf pf) on it. it has been noticed in, that, if a logic program can be modelled by a pf pfcoalgebra, then the sld-derivations may be modelled by a comonad c(pf pf) on this coalgebra. the main result of established that, if c(pf pf) is the cofree comonad on pf pf, then, given a ground(variable-free) logic program p, the induced c(pf pf)-coalgebra structure characterises the parallel and-or derivation trees(cf.



an empty list of references in the and-nodes. after the transformation pass, each and-node corresponding to a clause body atom is visited again and its open list is populated with references to the unifiable clause-tree root nodes. this is a one time process at the initialisation and does not need to be done again for different queries.



note that implementing the above restricted(ground) logic programs can have practical value of its own. logic programs containing variables but no function symbols of arity n> 0 can all be soundly translated into finitely-presented ground logic programs. the most famous example of such a language is datalog[12, 22]. the advantages of datalog are easier implementations and a greater capacity for parallelisation. from the point of view of model theory, datalog programs always have finite models.



apart from the size, there is another reason which prevents the speedup when increasing the number of expand threads for the uta programs. in principle, keeping every expansion thread busy expanding a concrete part of a tree instead of directing it to work in different parts of the tree results in the best speedup. an ideal implementation would adapt to the tree shape and size, and would dedicate new expansion threads only for computations of sufficiently large parts of the tree. however, in unbalanced trees, it cannot be known in advance if part of a tree is large enough to offset the setup costs of dedicating a new thread to it, instead of just executing the work in the current thread. as a result, when a new thread is dedicated to expand a part of a tree that is not big enough, the expansion process is slowed down and execution time increases.



we proceed to extend our coalgebraic approach to the general first-order case. unification and sld-resolution algorithms are p-complete in the general case[7,12]. in practical terms, p-completeness of an algorithm means that its parallel implementation would not provide effective speedup. the problem can be illustrated using the following example.



we employ an optimisation technique to minimise the work for constructing go-coinductive trees. when checking a referenced root node for term-matching, it is also checked whether it can be unified. if it is not unifiable, then term-matching is impossible even if substitutions will be applied later when processing the tree. therefore, non-unifiable references to clause-tree roots can be immediately removed from the open lists. this process of filtering open lists and copying or-nodes and their child nodes during tree expansion can be done in parallel as no variable sub-



organisation of the work queue. the work queue is sufficient to keep track of all trees which have derivation steps that still need to be evaluated. this list of coinductive trees can be managed either as a first-in-first-out queue or alternatively as a last-in-first-out stack. this determines the search strategy that is employed to find success trees in the possible derivation chains: depth-first in the case of last-in-first-out stack(this is the strategy followed in prolog), and breadth-first in the case of first-in-first-out queue(which is the strategy followed in coalp).



this is implemented by buffering success trees in a priority queue. if it is determined that the work queue and all workers only hold derivation trees with the same or higher number of derivation steps, the solutions up to that number are returned from the solution queue. if the work queue is empty and all worker threads are idling, then all the solutions in the queue are returned and the program exits. note that the program may continue(co)recursively for indefinitely long.



a prolog-like system with deterministic depth-search would produce solutions btree(empty), btree(tree(empty,0,empty)), btree(tree(empty,0,tree(empty,0,empty))), but not e.g. btree(tree(empty,1,empty)). thereby, it does not generate the same set of solutions even if run indefinitely, and does not discover some of the solutions that coalp does for the binarytree program.



