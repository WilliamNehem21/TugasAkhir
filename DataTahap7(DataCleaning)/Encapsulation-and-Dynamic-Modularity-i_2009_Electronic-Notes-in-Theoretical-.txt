it should provide constructs for modularity, in the standard, informal sense that programs should be built as an assembly of relatively independent computation units(or modules) interacting at explicit interfaces. moreover, modularity should come with encapsulation features, e.g., it should be possible to exchange two modules implementing the same interface without affecting the rest of the code.



in this paper, we describe our proposal for a core process algebra to represent and analyse dynamic modularity(this section). in designing this formal model, we have put a stress on the possibility to deploy and execute processes in a distributed fashion. in sect. 2, we describe our prototype implementation by defining an abstract machine for the distributed execution of processes. this description is given via the definition of a new process calculus, where low-level aspects related to the implementation(notably, communication protocols), as well as the data structures at work in the machine, are made explicit.



passivating a module. the input prefixes and restriction are binding constructs, and we write fn(p) for the free names of process p.{b/x}(resp.{p/x}) denotes the capture avoiding substitution of name x(resp. process variable x) with name b(resp. process p).



passivation cannot be atomic, because the hierarchy of modules has been flattened, as described above(this departs importantly from the machine in). thus, we implement it in an incremental fashion, from the passivated module down to its sub-modules, transitively. along the propagation of a passivation session, we must handle two main sources of interferences.



more importantly, we need to clean up running communication sessions in the passivated sub-modules. as explained above, this is not problematic for communications on names belonging to the passivated module. for communications on names that reside above the passivated module, we use simple interactions with the modules owning the involved channels: status messages are used to query whether commitment to a communication already occurred, so that the computation can be either completed or aborted.



in the ocaml implementation h and g correspond to two channels(implemented either with shared memory or with sockets, depending on the physical locations of the endpoints). in turn, k and g correspond to two threads, listening to those channels. messages transmitted on these channels are of the forms i and g, respectively.



in order for the machine to work correctly, we need to make sure that names are not extruded outside their defining module. a solution would be to inspect the content of each message at runtime, and to block illegal communications. to avoid the inefficiencies induced by this approach, we want to rely on a type system to enforce statically this confinement policy: a well-typed term never attempts to extrude a name out of its scope.



its scope. since this property is preserved by reduction, we can avoid checking for scope extrusions at run time. although we need to experiment further with the expressiveness of our type system, preliminary attempts show that the policy enforced by our system is reasonable, in the sense that the examples we have in mind can be typed in a rather natural way. we defer the presentation of the type system, as well as the corresponding correctness proof, to a future presentation of our work.



