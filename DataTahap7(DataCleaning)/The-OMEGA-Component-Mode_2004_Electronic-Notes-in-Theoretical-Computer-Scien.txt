in an oo setting there is always a class diagram underlying an application. the same is true for a component based application designed with our component model. in the omega deliverable d1.1.2 we have presented a formal reduction from a hierachical component model to a flat class diagram. in this paper we will present in sect. 5 a formal justification of our component model in terms of a compositional trace semantics and its corresponding logics.



component interfaces are grouped into ports. component ports correspond with special purpose classes inside components that provide the only interaction points between components. at runtime, all communication between components is going via instantiated ports. in our component model, a port is used as a class, and it is also used as a type specification for one or more runtime objects. ultimately these runtime objects are instances of classes in the underlying class diagram, because our model is designed in an oo setting.



syntactically the components in our component model are much like the components in the uml 2.0 submission by u2partners in september 2002 and in januari 2003. one of our main objectives in omega is the development of an omega component model which is compatible with their uml 2.0 submissions. but there are some semantic differences that will appear in the rest of this paper. we can mention here already one of the most important differences: in the submissions by u2partners a component itself is instantiable whereas in our model it is the component ports that are instantiated(as instances of uml classes); this way the component provides a conservative extension of the underlying object-orientation so it can remain a software abstraction. another difference is that in order to keep our model small, simple and elegant, we do not explicitly model connectors and therefore we have not defined new uml entities for connectors. this provides a user of our component model with a choice: the user may decide to extend our model and use the uml 2.0 connectors, or the user can choose to model connectors as components themselves.



a port is a specialization of a both a uml class and a uml interface. a port can be regarded as a uml class, whereby the interface of the class is known but the name of the class is unknown. creating an instance of a port means creating an object with a known interface, but without the need of knowing the class of the object.



a basic component is a component consisting of classes and their relations as defined in the omega kernel model. some of the classes are associated with ports: they can depend on them or they can realize them. the basic component is a specialization of a blackbox component.



an interface(an ordinary uml interface, not a component interface) in the class diagram inside the basic component that depends on something from outside, should be modeled as a component interface. the designer is free to allow class libraries from outside that can be used inside a basic component, but this would be a strange design: it would raise the question why the designer did not turn the interface into a component interface. although it would be a design some would frown upon, we do not want to go as far as to forbid it completely. there can be practical considerations, for example it could be difficult to use an existing library in a component framework setting because there is not enough library source code available.



the labels on the arrows in these statecharts contain omega action language and they are of the form[guard] trigger/ action where guard is a boolean expression, trigger is an event or a method name with its parameters and action is a primitive action in the omega action language. these primitive actions use standard oo dereferencing with the dot notation and are of the form a:= a0.a1, a0.a1:= a, return:= a and other simple statements; see the omega kernel model document and for a complete enumeration.



as mentioned in the introduction, in the omega project we have chosen a subset of uml 1.4 so we will be able to use formal techniques. this subset consists of class diagrams and object diagrams for structural modeling, and statecharts and ocl for behavioral modeling. we also use live(lsc) sequence charts in omega but they are not part of uml. the subject of this paper is about the extension of this omega uml subset with com-



in our component model we define component diagrams that relate to architectural diagrams like class diagrams relate to object diagrams. when designing oo software, both class diagrams and object diagrams are useful; they serve different purposes: with class diagrams the designer gives a definition view, with object diagrams a runtime view is given. likewise, both component diagrams and architectural diagrams are useful.



in order to provide a semantic basis for the compositional verification of components, in this section we briefly outline the formal trace semantics of components which describes the external observable behavior of a component as determined by its ports. omega deliverable d1.1.2 describes a formal operational semantics of uml class-diagrams where the behavior of the object instances of each class is described by a statechart(). this semantics abstracts from the actual deployment unto a specific execution platform. it is formalized in terms of a translation relation on object-diagrams which specify for each existing object the values of its attributes and the values of some system variables which encode some relevant control information(such as the current state in the associated statechart).



note that adding the caller as an explicit parameter, together with the encapsulation condition, implies that all interaction between components is via their port instances. that is, we do not allow an internal object of a component(i.e., objects that are not instances of a port class) to call the provided services of a port instance of another component.



in this section we discuss more practical aspects of modelling applications with components in omega. in the omega user guide the concrete syntax for component models can be found, here we suffice to say that in the absence of a case tool that supports uml 2.0 components, the correspondence between component diagrams and class diagrams gives the possibility to use class diagrams to model components. it will give the user a little more administration to do to remember which diagrams are for components and which are for classes. likewise, object diagrams can be used to model architectural diagrams.



the additional structuring and abstraction mechanism provided by the notion of component allows a considerable simplification of an underlying kernel model language like in omega, which basically consists of removing the distinction between active and passive classes. more specifically, every instance of any class has its own single thread of control and its own event queue. acceptance of signals and operation calls by an object are defined only in terms of the local state of the object itself. objects are grouped together only by means of the static structuring mechanism of components.



that components are not units of instantiation and do not need to have a unique run-time identity. moreover, having ports as instantiable interfaces, in comparison with the recent component model proposed by the u2 partners for uml 2.0, has the advantage of permitting the existence at run time of multiple ports with the same set of interfaces per component, each port attached to the necessary number of runtime links. these runtime links are modeled as connectors in uml 2.0.



