concepts is a useful feature for generic programming, allowing programmers to specify the interface and behaviour of abstract data types. the concept feature was introduced to c++0x(the upcoming c++ standard revision) in order to give clearer error messages in templated code, and to provide a way to more easily glue together generic code. similar features are available in other programming languages.



notational clarity: certain problems are most clearly expressed in an algebraic or functional style, which is close to the notational style of mathematics, a notation developed over the centuries for clarity of expressions. many formal specification languages, e.g., the larch shared language and casl use the functional style due to its clarity. a program written in an algebraic style is easy to relate



we will now proceed with a deeper discussion of the matter. the rest of this paper is organised as follows: first, we introduce the necessary features of the magnolia language(sect. 2). then we define mutification and functionalisation, and explain how they are applied to magnolia programs(sect. 3). we continue by discussing some limitations and pragmatic considerations, and the benefits and possibilities of the approach(sect. 4).



this section gives a brief overview of the magnolia programming language. magnolia is based on c++, with some features removed, some features added, and some changes to the syntax. we have designed it to be easier to process and write tools for than c++(this is actually our main reason for using a new language, rather than working with c++), while being similar enough that we can easily compile to c++ code and use high-performance c++ compilers.



definition 3.1 functionalisation, f, maps a procedure declaration to one or more function declarations. this makes procedures accessible from expressions, at the signature level. since a procedure can have multiple output parameters, and a function can only have one return value, we get one function for each output parameter of the procedure(numbered 1 to i):



nested expressions must be broken up. this is done by moving a sub-expression out of its containing expression and assigning it to a temporary variable. when functionalising a program, the reverse operation(expression inlining) can be applied to make as deeply nested expressions as possible, thus enabling easy application of high-level transformation rules.



fluent languages combine functional and imperative styles by separating the language into sub-languages, with procedures which are fully imperative, observers, which do not cause side-effects, functions, which do not cause and are not affected by side-effects, pures which are referentially transparent(no side-effects, and return the same value on every evaluation). the invariants are maintained by forbidding calls to subroutines with more relaxed restrictions. our mutification, on the other hand, takes responsibility for protecting against harmful side-effects, allowing calls to procedures from functions.



link to axioms and algebraic specification. the algebraic notation can be directly related to the notation used in specifications, thus bridging the gap between practical programming and formal specifications. this enables the use of axioms for high-level optimisations and for automated testing.



our initial experiments with mutification were done on c++, because the excellent, high-performance compilers available for c++ make it a good choice for performance-critical code. languages like c++ are however notoriously difficult to analyse and process by tools. the idea behind magnolia is to cut away the parts of c++ that are difficult to process or that interfere with our ability to reason about the code, and then add the features necessary to support our method. the magnolia compiler will produce c++ code, allowing us to leverage both good compilers and good programming methodology.



more work remains on determining the performance improvement that can be expected when using imperative vs. algebraic styles, and the productivity improvement that can be expected when using algebraic vs. imperative style. both these aspects are software engineering considerations. further work on formally proving the effectiveness and correctness of mutification is also needed.



