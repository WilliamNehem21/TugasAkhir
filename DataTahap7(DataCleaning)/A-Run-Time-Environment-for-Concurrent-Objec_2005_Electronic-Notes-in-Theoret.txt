constructs for concurrent objects are proposed with an object-oriented design language creol, based on processor release points and asynchronous method calls. processor release points are used to influence the implicit internal control flow in concurrent objects. this reduces time spent waiting for replies to method calls in a distributed environment and allows objects to dynamically change between active and reactive behavior(client and server).



as arguments to methods, including as subtypes the object identifiers obj and data types such as bool. expressions expr evaluate to data. we denote by var the set of program variables, by mtd the set of method names, and by label the set of method call identifiers.



in creol, the control flow inside concurrent objects may be influenced by potential processor release points. these are explicitly declared in method bodies using guarded commands, as introduced by dijkstra, and may be nested within the same local variable scope. when an inner guard evaluates to false during process execution, the remaining process code is suspended to the internal process queue and the processor is released. after processor release, an enabled process from the internal process queue is selected for execution.



here, wait is a construct for explicit release of the processor. the reply guard l?(x) checks whether the reply to a method call has been received, as further execution of a process will often depend on the arrival of a certain reply. if this is the case, l?(x) returns true and instantiates x with the return values. evaluation of guards is done atomically.



with nested processor release points, the processor need not wait actively for replies. this approach is more flexible than future variables: pending processes or new method calls may be evaluated instead of blocking the processor. however, when the reply has arrived, the continuation of the original process must compete with the other enabled and pending processes in the internal process queue.



cesses(see section 2.2) allowing all kinds of queue orderings, and lvar and att the local and object variables, respectively. finally, lcnt is the method call identifier corresponding to labels in the language. thus, the object identifier id and the local label value provide a globally unique identifier for each method call. external message queues have a name and contain a multiset of unprocessed messages. each external message queue is associated with one specific creol object.



objects communicate by asynchronous method calls. in the operational semantics, two messages are used to encode a method call. if an object o1 calls a method m of an object o2, with arguments in, and the execution of m(in) results in the return values out, the call is reflected by two messages invoc(l, o1, o2, m, in) and comp(l, o1, out), which represent the invocation and completion of the call, respectively. in the asynchronous setting, the invocation message must include the reply address of the caller, so the completion can be transmitted to the correct destination. as an object may have several pending calls to another object, the completion message includes a unique label l, generated by the caller.



creol has three types of guards representing potential processor release points: the standard boolean expression, a wait guard, and a return guard. rules for evaluation of return guards in the active process are now considered. return guards allow process suspension when waiting for method completions, so the object may attend to other tasks while waiting. a return guard evaluates to true if the external message queue contains the completion of the method call, and execution of the process continues.



many object-oriented languages offer constructs for concurrency. a common approach has been to keep activity(threads) and objects distinct, as done in hybrid and java. these languages rely on the tightly synchronized rpc model of method calls, forcing the calling method instance to block while waiting for the reply to a call. verification considerations suggest that methods should be serialized, which would block all activity in the calling object. closely related are method calls based on the rendezvous concept in languages where objects encapsulate activity threads, such as ada and pool-t. the latter is interesting because of its emphasis on reasoning control and compositional semantics, allowing inter-object concurrency.



languages based on the actor model[2,3] take asynchronous messages as the communication primitive, focusing on loosely coupled concurrency with less synchronization. this makes actor languages conceptually attractive for distributed programming. representing method calls by asynchronous messages has lead to the notion of future variables, which is found in languages such as abcl and concurrentsmalltalk, as well as in eiffel//, cjava, and polyphonic c. the proposed asynchronous method calls are similar to future variables, but the proposed nested processor release points further extend this approach to asynchrony.



