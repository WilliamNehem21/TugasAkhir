in 1981, kozen described a semantics for probabilistic programming languages in terms of linear operators on banach spaces. a program is then a linear map from an input probability measure(the joint distribution of the initial values of its variables) to an output sub-probability measure(since there may be some probability of non-termination). monniaux and di pierro and wiklicky use two different ideas to extend abstract interpretation to these domains, resulting in a probabilistic abstract interpretation.



this paper is structured as follows. in section 2 we describe a simple imperative language with message passing, and give a concrete probabilistic semantics in section 3. following this, we review the framework of abstract interpretation in section 4 before presenting our abstraction and abstract semantics in section 5. we conclude with section 6.



note that these expressions are always linear. this does not reduce expressivity, since non-linear operations can be encoded using loops. by defining our language in this way we will need only to abstract loops in order to abstract non-linear behaviour, hence two separate abstractions are not necessary.



note that without loss of generality, we only allow a variable to be compared with a constant. since we can construct more complex comparisons by first defining a new variable, this serves to simplify our abstraction as we shall see later. furthermore, conjunctions and disjunctions of conditions can be expressed(albeit inefficiently) by nesting if-statements, hence are not necessary as primitives.



before we describe our semantics in terms of probabilistic automata, we first need to describe the data environment of a program; in other words, the domain of its variables. rather than considering individual values that a variable can take, we consider it to take a range of values according to some probability distribution. in essence, variables are viewed as random variables and the operation of the program is to transform them. however, since we are only concerned with the distribution of these random variables(specifically, their joint distribution), we can treat the program as operating on this distribution directly.



calling a function f, defined f(xj1,..., xjn){ c}, can be thought of as modifying the denotation of the body of the function so that the argument variables are replaced by the actual arguments, and the return call is replaced by the appropriate variable assignment. more formally: is the composition of the originals. if there is more than one start or exit transition, we must take all possible combinations. hence in the worst case, the size of the automaton may grow exponentially in the number of branching instructions.



classical abstract interpretation is a mathematical framework that relates a concrete domain to an abstract one. properties in the abstract domain are safe approximations(supersets) of their concrete counterparts. by constructing a suitable abstract domain and abstract semantics, we can reason about properties of a program that would otherwise be undecidable in general, at the cost of some precision.



in the probabilistic setting, our domains are banach spaces rather than preordered sets, but the above approach still applies. by applying classical abstract interpretation to the probabilistic setting, we take an approach similar to monniaux. rather than comparing measures by their total measure, however, we choose a much stronger comparison, which we call the strict ordering on measures.



an alternative approach taken by di pierro, wiklicky et al[6,5] is to look for a probabilistic analogue of the galois connection. this, the moore-penrose pseudo inverse, gives the closest approximation to the inverse of a function, leading to a probabilistic notion of safety. while this approach has had much success, it is difficult to use in practice for infinite banach spaces(i.e. continuous measures), such as the ones we consider.



we would like our concrete domain to consist of all possible measures, and our abstract domain to be the truncated multivariate normal measures, as described. unfortunately, constructing an abstraction function from such a domain is not a simple task. not only does it contain measures that we cannot write down, but it is difficult to satisfy the relational homomorphism property(definition 4.1). instead we restrict our concrete domain to those measures that can be computed by a series of linear operations and truncations applied to a multivariate normal measure. whilst this is restrictive, it still allows us to represent a useful class of measures, and loosening this is the subject of future work. more formally:



the interesting case is the last one, which identifies loops whose variables are only incremented or decremented by a constant value. this occurs when the covariance matrix is unmodified, meaning that the variables have only been shifted by a constant amount. we can extend this to detect other types of loop activity(for example, a multiplicative update), but that is beyond the scope of this paper.



we conclude this paper with a brief discussion of the abstract collecting semantics. as we have seen, our memoised abstract interpretation associates a set of measures to each state in the abstract semantics. we are not interested in the set itself, however, but in the sum of the measures it contains. thus our collecting semantics can be seen as a way to safely approximate this sum to a measure that is easier to compute. this need not be a truncated multivariate normal measure as the result of this final stage of analysis is not needed for further computation.



at present, the only general solution we have is a numerical one. to compute an upper bound of the measure on a particular interval[a, b], we iteratively sum all the measures in the set, applied to this interval. although the set of measures will in general be infinite, we note that the iterated sum will quickly converge as the residual probability mass exponentially decreases. it is easy to calculate such measures from a truncated multivariate normal measure, by performing eigenvalue decomposition to separate it into independent truncated normal measures. this loses some precision, since we over-approximate the truncation interval, but it is a safe approximation.



in this paper, we presented an abstract interpretation of a probabilistic automaton semantics for a simple imperative language. we believe that this work is complementary to other approaches to probabilistic abstract interpretation, allowing an efficient approximation to the behaviour of programs whose input is governed by a probability distribution. there is clearly some way to go in terms of improving this approach, for example finding a better abstract collecting semantics and a greater range of widening operators. we also need to carry out some larger case studies, to investigate the precision of the bounds in comparison to other methodologies.



the ultimate aim of this work is to provide a formal framework for the ideas presented in, where we attempt to derive stochastic models of communication protocols directly from source code. the advantage of abstract interpretation is that it can be easily automated, and therefore fits in well with the aim of providing tools that can be used by real developers. we feel that the abstract interpretation presented in this paper is an important milestone towards this goal.



