program.(if we view a set of states as a predicate that is true only in those states then this corresponds to the weakest state predicate.) of course, an enumerative approach, where we consider each state as a potential initial state, is impractical. our goal in this paper is to identify efficient techniques for identifying the largest set of legitimate states for a given program.



the rest of the paper is organized as follows: first, we define the problem statement in section 2. then, we present our algorithms in section 3. next, we illustrate our algorithm in section 4. we discuss related work in section 5 and the conclusion is in section 6.



in this section, we present our algorithm to automatically generate the weakest invariant using the program transitions and its specification. the goal of our algorithm is to generate the weakest possible invariant from where the program satisfy its safety and liveness specification. our algorithm consists of three main parts: the invariant generator, the safety checker, and the liveness checker. we will describe each of the three algorithms in subsection 3.1-3.3.



first, the algorithm initializes the invariant isf to be the initial invariant iinp excluding the states in spec bs(line 1). then, the algorithm starts a fixpoint computation that removes undesired states from the initial invariant. if isf contains a state s0 such that the program can execute the transition(s0, s1), which violates safety, then s0 cannot be in isf. hence, we remove s0 from isf(line 4). note that a state is removed from isf only if the given program violates safety from that state. thus, if isf contains a state s0, p contains a transition(s0, s1), and s1 has been removed from isf, then s0 must also be removed from isf(line 5). this process continues until a fixpoint is reached. at this point, it exits the loop and returns the desired invariants isf.



in some cases, the program actions are partitioned in terms of system actions and environment actions. it is expected that the environment actions will eventually stop(for a long enough time) so that the system actions can make progress(and satisfy liveness property). in such cases, we can apply the above algorithm as follows: the program actions used in safetychecker will consist of both the system actions and the environment actions. the program actions used for livenesschecker will consist of only the system actions.



line 5 of safetychecker: if s1 is a state already removed from the final invariant, i.e., there is a program computation that starts from s1 and violates the specification, and(s0, s1) is a program transition then there exists a computation that starts from s0 and violates the specification.



removed. now, the loop on lines 5-7 removes all deadlock states in invf. if any state, say s0, in j is not removed then that implies that there are infinite computations of tmpp that start from s0. for instance, this happens if a cycle is reachable from s0. by construction, this computation cannot reach 7. thus, if a state s0 is removed on line 9 of livenesschecker then there is a computation from s0 that violates the specification.



in subsections 4.1-4.2, we describe and analyze case studies, namely the token ring program, and the mutual exclusion program. we chose these classical examples from the literature of distributed computing to illustrates the feasibility and applicability of our algorithm in generating the weakest invariant.



since we focus on the design of distributed programs, for brevity, we specify the state space of the program in terms of its variables. each variable is associated with its domain. a state of the program is obtained by assigning each of its variables a value from the respective domain. the state space of the program is the set of all states.



throughout this section, all case studies are run on a macbook pro with 2.6 ghz intel core 2 duo processor and 4 gb ram. the obdd representation of the boolean formula has been done using the c++ interface to the cudd package developed at the university of colorado.



several techniques have been developed to verify program correctness[6,16,9,7,10,8]. for most of those methods, the program is translated into a logical formula that describes the program behavior and properties. then, tools are used to verify the correctness of the program. for many of these tools identifying the program invariant is an essential step. several approaches have been proposed to improve the automatic invariant generation[15,2,17,3,4]. these methods can be widely classified as either top-down or bottom-up approaches. the top-down approach starts with the weakest possible invariant and uses program specification to strengthen that invariant. the bottom-up approach performs forward propagations of the program actions to derive the invariant. our algorithm is a top-down approach since it starts by initializing the invariant to be the whole state space and later removes states that violate the predefined safety and liveness specifications.



our algorithm uses the program actions and specification to automatically generate the weakest invariant. our algorithm consists of two main steps. the first step is to generate the initial invariant to be the set of the states the given program dose not violate the safety specification. then, the algorithm ensures that the generated invariant satisfies the liveness properties by removing any state that violates such properties. in the two case studies we used to demonstrate our algorithm, we generated the exact same invariant used in the automation of fault-tolerance for each of those cases. furthermore, we note that the time needed to generate such invariants was very small.



