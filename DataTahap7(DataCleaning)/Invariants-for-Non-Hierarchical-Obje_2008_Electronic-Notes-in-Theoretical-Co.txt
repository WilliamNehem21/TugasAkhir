when the aim is met, propagation of invariant properties is prevented, significantly reducing specification overhead. furthermore, the code is more flexible, as a re-implementation of a method can rely on a different set of invariants without affecting users. besides these advantages, invariants allow the specification of data consistency properties and behavioral properties to be separate concerns. this makes communication of such properties much easier. finally, they support the specification of a class in terms of an abstraction of its data(see section 4).



execution of a program that has been proven correct with the classical technique meets the premises of theorem 2.1. in the classical technique, described and proven sound in, only local invariants are admissible. a local invariant is an invariant that only depends on the fields of the object it applies to(i.e., the predicate that defines it only contains references of the form this.f).



we call a specification feasible when there is an implementation of this specification that can be verified. this section shows that many natural oo designs that include non-local invariants are infeasible due to the third premise of theorem 2.1. the specification construct inc is presented as a solution to this problem. it allows a method m to specify that m preserves, but does not rely on certain invariants of certain objects. it is also argued that many non-hierarchical designs are only feasible in a specification language that includes a construct like inc. there is a hierarchy between two objects if, when a method m is called on one, no method can be called(or field accessed) on the other until m terminates.



loanedto of book b needs to be updated. this is not possible without a method call. book provides method loanto for this purpose. however, the invariant needs to be re-established before the method call that re-establishes it is allowed! updating loanedto before loaned is similarly impossible. the essence of the problem is that no single method can update all relevant fields when re-establishing an invariant.



the specification construct inc(for inconsistent), first introduced in, offers flexibility at little cost. in this particular example, the specification of method loanto includes inc: mi(m). this makes explicit that(the verification of) loanto does not rely on invariant mi of parameter m. this allows loanto to be called by method loan after the assignment to this.b. method loanto does not have to reestablish the invariant(but from its postcondition it can be deduced that it does). more generally, with every method m, a so called inc-set is associated. the incset is specified by the inc construct. by default, the set is empty. in the approach introduced in the inc-set can only be specified as a fixed set of reference invariants



i(r). this approach is generalized here. the inc-set of a method m is a set of elements(c, i, p), with c a classname, i the name of an invariant specified in class c and p a predicate. references in p start with either a method parameter(for instance, this) or the logical variable inc. the meaning is that for any object inc of class c such that p holds when m is called, i(inc) is preserved, but not relied upon by method m. an element i(r) is shorthand for the element(c, i, inc= r), where c is the class that defines invariant i referred to by r. theorem 3.1 reflects the addition of the inc construct.



the premise of theorem 3.1 is weaker than that of theorem 2.1. for any method m, for any invariant i, the conclusion is weaker only in two cases: 1) m calls a method while i is invalid. however, given such a call, premise 3 of theorem 2.1 is not met and theorem 2.1 cannot be applied. 2) m specifies that it does not rely on



the call to the update method in setd is allowed as update specifies that it does not rely on invariant i of any object inc of class cobserver that observes the same csubject as the object that update is called on. this set of invariants cannot be specified as a fixed set of reference invariants. note that update preserves all invariants, even those specified in its inc-set. this allows the verifier of setd to conclude that invariants of objects that have been updated already are preserved by an update call. setd is not a proper user of onode. this could be modified.



so far, an important concept in oo verification has been ignored, namely that of information hiding. information hiding is an important oo design principle. design decisions that are not relevant to a user should be hidden from that user(by means of abstraction). these decisions can then be changed without affecting that user. with modular development of(a method of) a class c we mean that all except a finite and explicit set of classes are hidden from the developer of(this method of) c. the benefit(of modular development) is that changes to hidden classes, or the addition of new classes, do not affect the verification of(this method of) c. given a mechanism that can hide an invariant from a class, most oo designs are infeasible unless invariants are restricted. due to the second premise of theorem 3.1, the verifier must prove, for an arbitrary hidden invariant i of an arbitrary object of an arbitrary class, that i 1) cannot be invalidated by the statement or 2) is re-established before the end of m.



6 illustrates the intuition behind this construct. an assignment to field i of a cobserver object can invalidate invariant i of that object. as field i is specified as int i coop i(this), a verifier can assume that that invariant is the only invariant that might be invalidated.



more generally, a so called coop-set specified by the coop construct is associated with every field f. by default, the coop-set is empty. we generalize the approach in. a coop-set associated with a field f is a set of elements(c, i, p), with c a classname, i the name of an invariant specified in class c and p a predicate in which all references consist of one of the keyword logical variables this or dep, followed by zero or more field accesses. we say field f cooperates with invariant i of any object dep of class c for which p holds at the time field f is assigned to. the admissibility obligation guarantees the following property. when a field f of an object is assigned to, any invariant not cooperated with by f is not invalidated by the assignment. an element i(r) is shorthand for the element(c, i, dep= r), where c is the class that defines invariant i referred to by r(i.e, it specifies that the field cooperates with invariant i of object r, when such an object exists).



den from class csubject. we borrow an abstraction technique from(but omit some of the associated details). abstract fields and invariants can be introduced by the keyword abstract. such fields and invariants can be implemented differently by different subclasses. the specification of a method is inherited by an overriding method. the need to include inherited flanking invariant j as a conjunct of i is a technical detail that is due to the admissibility obligation(see section 5).



the proof technique introduced in this section can complement any proof system that proves correctness of statement annotations(that has some standard properties for logical variables). given this complemented proof system, any execution of a program that is proven correct meets the premises of theorem 3.1. hence, the conclusion of the theorem allows to assume the validity of(most) invariants when a method is called or terminates.



the presentation of the proof obligations is orthogonal to the rest of the proof system, i.e., it is assumed that every method body is fully and correctly annotated. when, during method execution, control is at a certain program location, the corre-



the statement assign(r) is an assignment to reference r, where the right-hand side is a reference or a primitive value. mc(r, mc) is a method call to method mc with reference r as receiver(the call might be dynamically dispatched to a subclassmethod md). for simplicity, method parameters(other than this) are not allowed. removal of this restriction is straightforward. the use of object creation statement new(lc, d) and constructor-only statement dtc is explained in section 5.3.



an edge e is a tuple(n, n'). when there is an edge(n, n') in the graph, the program location n' can be reached from program location n in a single execution step. when the program counter identifies n in a particular execution state, in the next execution state it identifies a node n' such that(n, n') is an edge in the graph. a graph g is a tuple of a set of nodes n and a set of edges e. a union



here, node n' is the program location directly after the dtc statement(section 5.3). this proof obligation establishes that, no matter how control flows through a constructor, the invariant of the newly constructed object is established, and no method that relies on it is called before this is done, which is needed for the third premise of theorem 3.1. one way to establish that this proof obligation is met is to use a breadth-first algorithm that searches for a node that establishes the invariant(and stops after a full cycle is traversed). for instance, apv(n, g, i(sc)) implies that every cycle-free path from n in g is safe for i(sc) and that every cycle-free path from n to end(g) in g establishes i(sc). a proof by induction on the length of cycle-free paths is straightforward.



this obligation combines the techniques of the previous two to deal with assignment statements. note that, when n is an assignment node, there is exactly one outgoing edge(n, n'). an invariant that does not hold in the precondition of a method is trivially preserved. for simplicity, this is not capitalized on by the proof obligation.



data induction allows a method to rely on an invariant without it being specified in preand postconditions. we have introduced an approach that allows this for invariants over object structures. the inc construct specifies that a method does not rely on certain invariants. we argue that this is essential for the specification of many natural, non-hierarchical designs. the coop construct specifies which invariants can be invalidated by an assignment. this allows the verification of invariants even when their definition is hidden. in particular, this makes the approach suitable to modular development. we introduce proof obligations that guarantee data induction is allowed.



