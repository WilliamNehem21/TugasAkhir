the robust transform based on the weighted median operator algorithm calculates the transform of a signal when it has been exposed to impulsive noise. since this algorithm demands very long execution time, it is not useful for real time signal processing systems. in this context, this work presents several strategies to improve its performance, such as the reduction of redundant calculations, optimization in the memory access, and a multithreads version of the algorithm. besides, the original estimation method is modified to decrease even more the average execution time, keeping the quality level of the numeric results. the experimental results show a 30% performance improvement by reducing redundant calculations and optimizing the memory access, without making modifications to the estimation method and without using multi-threaded processing; 93% performance improvement by introducing modifications to the estimation method; and 97% performance improvement by incorporating the multi-threaded processing.



through a medium, it uses to be affected in a degenerative way. this effect is known as noise. impulsive noise shows sharp increases in signals intensity, although the duration of these increases is short compared to the time between them. this kind of noises is usually modeled with distributions that have tails more weighted than those of the gaussian distribution, for example, the laplacian distribution.



in this sense, we propose several strategies to reduce the execution time of the rtwm algorithm, which consist on the reduction of redundant calculations, the use of the hierarchical memory system, and the use of multiple threads of execution. in addition, modifications are made to the original structure of the algorithm that allow improving the execution time while preserving the quality of the numerical results. the experimental results demonstrate an improvement in performance of up to 30% by reducing redundant calculations and optimizing the memory access, without making modifications to the estimation method and without using multithreaded processing; 93% performance improvement when introducing modifications to the estimation method; and 97% performance improvement by incorporating multi-threaded processing.



the reminder of this work is organized as follows. section 2 describes the basis of the rtwm algorithm. in section 3, we present the improvements related to redundant calculations, memory access, and the estimation method. section 4 is dedicated to the multithreaded version. experimental results are presented in section 5. we conclude this work in section 6.



however, when noise follows a heavy-tailed distribution bigger than those of the gaussian distribution, the performance of this method degrades significantly. the laplace distribution is a distribution that maximizes the probability when the location parameter is adjusted to the median. this distribution is usually used to model phenomena that have heavy-tailed distribution bigger than those of the gaussian distribution, for example, impulsive noise.



number of iterations has been made. the method used to determine the weighted median in each of the iterations has an important influence on the performance of the algorithm. in this work we use the method described in, whose algorithmic complexity is o(n), with n being the size of the vector, and consists of selecting the pivot so that it is an element close to the median and thus increase the amount of items discarded per iteration.



the regularization parameter depends on the value of the component to be estimated. the closest known value is that obtained in the previous iteration and is therefore used for estimation. on the other hand, since the value of the numerator is unknown, it is suggested that the regularization parameter be refined as the iterations happen and the solution vector converges. in this way, initially this parameter is given high values to favor dispersion, decreasing on each iteration; thus, it is possible to have non-null components with less impact on the constitution of the estimated vector.



this optimization represents to save n multiplications and n sums, replacing them with just one sum. this is an important optimization because operations performed with complex floating point numbers and double precision are expensive at processing time. the algorithm 2 shows the modifications made with respect to the original version presented in section 2 on the lines marked in red.



b= 1 have been used. it shows that for the first iterations, no progress is made towards convergence. this can be attributed to the fact that in this region the regularization parameter has not been reduced enough to allow the appearance of non-null components and thus reduce the error in the estimate.



the parallelization scheme proposed for the rtwm algorithm consists on distributing the estimation of the components of the transformed vector among the execution threads. in this way, the inner loop executed on each iteration is parallelized. this implies that each thread must be able to calculate the vectors z and w, calculate their weighted median, and update the vector x. in addition, the results of these updates must be gathered to construct the vector yj, with which the energy of the error reached in the current external iteration has to be checked.



each thread must have private and shared memory resources, as well as synchronization mechanisms that allow avoiding race conditions when accessing shared data. this should be done trying to minimize the amount of private memory and the number of instructions made within critical sections(i.e., code sections where shared variables are accessed).



shared memory: in the rtwm algorithm, the data structure that consumes a greatest amount of resources is the inverse transformation matrix. this consists of n 2 pairs of floating point numbers. this matrix and the y vector are not modified during execution, their entries are only used for reading. because of this, these data structures are made available to the threads as shared memory between them.



the results of the algorithm are mainly the vector x, which contains the estimated transform and the vector yj that maintains the estimate of the inverse transform. the vector yj is discarded at the end of the iterations, however, it maintains the information with which the estimation of the components of the vector x are made. therefore, the vector yj is the main channel through which threads can expose their results when working together. for this reason, the yj and x vectors are stored in the shared memory. however, to avoid excessive synchronization instructions, each thread keeps a copy of the yj vector in its private memory and, at the end of each outer iteration, this copy vector is exchanged with yj, which has the results of the last iteration performed.



d. in this way, at the end of the estimation of the components that correspond to them, the threads can add up their accumulated contribution within the vector yj. the vector d must be reset to zero after each outer iteration.



persion and is symmetric. therefore, to obtain vectors that, when applied the dft, generates transformed with these characteristics, the transformed vector is first generated by introducing dispersion and symmetry. then, using the inverse transform, idft, the vector representing the signal without noise is calculated. the last step is to add laplacian noise in the components of the vector obtained following the previous procedure.



energy is not used. the latter allows to appreciate in greater detail the numerical behavior of the estimate. finally, the tests were performed on fixed dispersion percentages ranging from 0% to 90%. the experiments are carried out on an intel core i7-7500u computer, with four cores and 16gb of ram, with ubuntu.



200 a reduction in the performance of 8% can be seen, however for the other lengths an average improvement of 7% is obtained. noting that for the latest optimizations the shorter lengths have received a cumulative improvement greater than the rest, this reduction is opposed to this, but maintains a balance of performance growth. for this reason and for the improvement in the quality of the numerical results, the adoption of this optimization is justified despite the reduction in shorter lengths.



parallelization involves an important parameter that is the number of threads. increasing the number of threads does not necessarily generate a better performance in the program. this is due to the fact that the necessary mechanisms for the support and synchronization of the threads generate a considerable load in the execution of the program. for the experiments performed, a number of four threads was selected because the processor in which the algorithm is executed has four processing cores and is therefore optimized to support this number of threads.



in this paper we present five improvements in the performance of the iterative algorithm of calculation of robust transforms based on the weighted median operator(rtwm), presented in. improvements of up to 30% were achieved without making modifications to its estimation method and without using multi-threaded processing. by introducing modifications to the estimation method an improvement in the average performance of 93% is achieved and by incorporating the multi-threaded processing an average improvement of 97% is achieved. the development scheme and methods used in this investigation can be applied to similar algorithms that also depend on the calculation of medians such as those presented in and. since arithmetic operations represent a significant fraction of the instructions executed in the algorithm, greater improvements could be achieved by using graphic processing units(i.e., gpu), which are optimized for the calculation of arithmetic



