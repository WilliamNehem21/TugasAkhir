the importance of temporal representation and reasoning is well known not only in the database community but also in the artificial intelligence one. contextual logic programming(cxlp) is a simple and powerful language that extends logic programming with mechanisms for modularity. recent work not only presented a revised specification of cxlp together with a new implementation for it but also explained how this language could be seen as a shift into the object-oriented programming paradigm. in this paper we propose a temporal extension of such language called temporal contextual logic programming. such extension follows a reified approach to the temporal qualification, that besides the acknowledge increased expressiveness of reification allows us to capture the notion of time of the context. together with the syntax of this language we also present its operational semantics and an application to the management of workflows.



contextual logic programming(cxlp) is a simple and powerful language that extends logic programming with mechanisms for modularity. recent work not only presented a revised specification of cxlp together with a new implementation for it but also explained how this language could be seen as a shift into the objectoriented programming paradigm. finally, cxlp was shown to be a powerful language in which to design and implement organizational information systems. temporal representation and reasoning is a central part of many artificial intelligence areas such as planning, scheduling and natural language understanding. also in the database community we can see that this is a growing field of research[12,9].



for this overview we assume that the reader is familiar with the basic notions of logic programming. contextual logic programming(cxlp) is a simple yet powerful language that extends logic programming with mechanisms for modularity. in cxlp a finite set of horn clauses with a given name is designated by unit. the vocabulary of contextual logic programming contains sets of variables, constants, function symbols and predicate symbols, from which terms and atoms are constructed as usual. also part of the vocabulary is a set of unit names.



i.e. one which is shared by all clauses defined in the unit. therefore, as soon as a unit argument gets instantiated, all the occurrences of that variable in the unit are replaced accordingly. for instance if the variable name gets instantiated with bill we can consider that the following changes occur:



since in the same program we could have two or more units with the same name but different arities, to be more precise besides the unit name we should also refer its arity i.e. the number of arguments. nevertheless, most of the times when there is no ambiguity, we omit the arity of the units.



for a given cxlp program, we can impose an order on its units, leading to the notion of context. contexts are implemented as lists of unit designators and each computation has a notion of its current context. the program denoted by a particular context is the union of the predicates that are defined in each unit. moreover, we resort to the override semantics to deal with multiple occurrences of a given predicate: only the topmost definition is visible.



in an informal way, we can say that we ask the context for the position for which we want to calculate the base salary. variable p is instantiated to teachingassistant and computation of goal position factor(teachingassistant, f), index(i), s is f*i is executed in context[basesalary(s), employee(bill, teachingassistant)]. using the clauses of unit basesalary we get the final context[basesalary(2000), employee(bill, teachingassistant)] and the answer s= 2000.



one major issue in every temporal theory is deciding what sort of information is subject to change. in the case of contextual logic programming the temporal qualification could be performed at the level of clauses, units or even contexts. in order to be as general as possible we decided to qualify units, more specifically, units designators. this way we can also qualify:



from an ontological point of view we can classify the temporal relations into a number of classes such as fluents, events, etc. normally, each of these classes has associated a theory of temporal incidence. for instance the occurrence of an event over an interval is solid(if it holds over a interval it does not hold on any interval that overlaps it) whereas fluents hold in a homogeneous way(if it holds in an interval then it holds in each part of the interval). our theory of temporal incidence will be encoded by means of conditions in the operational semantics and to be as expressive as possible unit designators can be considered as events or as fluents according to the context, i.e. the current context will specify if they must hold in a solid or homogeneous way(see inference rule reduction of page 10).



we may now enumerate the inference rules which specify computations. we will present just the rules for the basic operators since the remaining can be obtained from these ones: for instance, the extension u:> g can be obtained by combining the inquiry with the switch as in:> c,[u|c]:< g. together with each rule we will also present its name and a corresponding number. moreover, the paragraph after each rule gives an informal explanation of how it works.



workflow management systems(wfms) are software systems that support the automatic execution of workflows. although time is an important resource for them, the time management offered by most of these systems must be handled explicitly and is rather limited. therefore, automatic management of temporal aspects of information is an important and growing field of research[8,6,7,13]. such management can defined not only at the conceptual level(for instance changes defined over a schema) but also at run time(for instance workload balancing among agents).



