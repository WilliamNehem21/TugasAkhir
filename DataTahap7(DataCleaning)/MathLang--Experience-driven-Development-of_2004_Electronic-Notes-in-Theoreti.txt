data management has become an important area for automation. editing, storage, publishing, data retrieving and other computations are gratefully helped by computers with appropriate software. nowadays computers could be used at each step of writing texts, the use of pen& paper may not be essential. could we make the same remark for mathematical work? would it be possible for a mathematician to use computers as a help tool from scratch to treatise?



the first concern is to be able to automate computations of data encoded in mathlang to use computer skills. for this reason we have designed mathlang using a full symbolism(that is to say every element of the language consists of recognisable symbols). this facilitates the manipulations that can be done by the computer.



when using existing formal languages to write mathematics, one needs to be sure that the mathematics used will fit in the underlying logic of the language. this restricts the expressivity of the language. to cover all mathematics, mathlang is intended to describe the structure of mathematical texts and their reasoning steps.



since mv and wtt are said to help provide a language to encode mathematics which can be used at every level of mathematical work, we set out to test these languages through the foundations of analysis(e. landau) which is already fully formalised in automath by bert van benthemjutting. since our aim is not the full formalisation, but an encoding which allows a full formalisation at a later stage, we felt that choosing a fully formalised book for our encoding, would allow us in the future, to compare the already existing full formalisation, with the full formalisation that could be built on top of our encoding. this paper reports the extensions that had to be made to wtt to encode the first chapter while remaining faithful to



lang constructions: flags, definitions by cases, blocks and references. as to the notations we use to print mathlang texts, note that the language mathlang is still in development since the translations of the other chapters will no doubt call for further extensions. for this reason the mathlang texts given here are rendered with an experimental syntax which we intend to improve. currently, the concrete syntax of mathlang is implemented using the xml recommendations. we have made this choice to facilitate transformations on mathlang data. one of these transformations produces automatically the renderings shown in this paper. below is an example.(i) being line numbers and{i.i} being block indices. in a line, the symbol d separates the context from the new statement or the new definition.



the set z describes the four constructions which declare a new variable. in the first two constructions, the colon states the belonging of the declared variable. the variable on the left side of the colon belongs to the entity on the right side of the colon. the first construction introduces a term variable by stating in which set the term belongs(expression from s). the second also introduces a term variable but by stating of which noun it is an instance of(expression from n). with the keyword: set(resp.: stat), the third(resp. fourth) construction introduces a new set(resp. statement) variable.



in mathlang, a definition by cases defines a constant using several lines. each line being one case. this construction brings mathlang closer to the original text for two reasons. first, to each original case corresponds one case in mathlang. second, in this encoding we are not using additional constants. we do not need logical symbols as we did in the earlier translation of mv and wtt. these logical constructions may not always be explicitly defined in the mathematical text.



in mathlang, a block denotes a structure. it is possible to restrict the definition of a constant to a precise block, we call this constant local. an example of these local constant could be seen in our translation of the first chapter of with blocks{2.5.1} and{4.2.1}. each of these blocks represents a part of a proof of a theorem(respectively part a of theorem 4 and part a of theorem 28) where the local constants a and b are defined.



these rules assign a type to the expressions taken from the phrase and the sentence levels. that is to say variable instances, constant calls, binding expressions and adjective attributions. a special rule rec-cons allows calls to annotated constant which is currently being defined(c' with its input types wti). this rule allows recursive definitions of constants(see rules full-def and case-def-first).



these rules check the coherence of contexts. the first one states that an empty context is a valid context. the last one checks if an assumption in the context is a well formed statement expression. the three remaining rules correspond to the three constructions of variable introduction. the grammatical category of the introduced variable must fit the kind of construction used: either a set or a statement or a term.



a block could either be empty, end with a line or end with a block. the rules below describe how to build a block from an already well-formed one. this is done by adding a line or a sub-block to the existing block.



we have implemented a type checker that analyses a mathlang text by applying the rules of the type system(see section 3). this software has been programmed using camlp4(parser part) and ocaml(type inference part). this program checks the typing of a given mathlang document. if the typing succeeds, the xml document is then considered as a well formed mathlang



as we said earlier, mathlang is still under development. we believe that it is important that this development be guided by existing mathematical texts and practice and that the encoding should be in the language under development and not in syntactic sugaring versions of it. it is also important that the metatheory and implementation be as faithful as possible to the language itself.



specifications. the mathlang language is still in development. we need to incorporate references in the mathlang syntax and to put the notion of blocks into action by adding some constructions to enable us to derive information about blocks. these extensions will always be made in parallel with the guiding translation work. at every stage, we will make sure that the metatheory is well developed and that the implementation is faithful to the language.



framework. because our language will be as exhaustive as possible in its way to encode mathematical texts we will need to have a specific editor to assist the mathematician. this editor should have a user friendly interface. it should be able to print mathematical symbols on the screen. an integrated checker should give instantaneous feedback about the type analysis of the text. we have planned and started to use the what-you-



y. baba and m. suzuki present a grammatical analyser which extends its own grammatical rules on the fly. after translating one sentence, the grammatical analyser will be able to recognize the same kind of pattern used by the mathematician in the rest of the text.



