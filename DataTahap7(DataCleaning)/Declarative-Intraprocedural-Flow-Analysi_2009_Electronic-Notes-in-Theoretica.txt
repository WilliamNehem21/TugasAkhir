we have implemented intraprocedural control-flow and data-flow analysis of java source code in a declarative manner, using reference attribute grammars augmented with circular attributes and collection attributes. our implementation is built on top of the jastadd extensible java compiler and we have run the analyses on medium-sized java programs. we show how the analyses can be built using small concise composable modules, and how they provide extensible frameworks for further source code analyses. preliminary measurements indicate that there is little difference in execution time between our declarative data-flow analysis and an imperative implementation.



in this paper we show how control-flow and data-flow analysis can be performed directly on the ast used in a compiler frontend while retaining good performance and compact specification size. moreover, our approach is completely declarative, enabling both modular and extensible specifications. we have implemented the analyses on top of the jastadd extensible java compiler, using an approach based on extended attribute grammars. the analyses reported in this paper are intra-procedural, i.e., local to a method. extending the technique to support inter-procedural analysis is part of our ongoing work.



to evaluate the efficiency and scalability of our presented approach we implemented an analysis for java to detect dead assignments to local variables. the control-flow framework is less than 300 lines of code(loc), and the dataflow framework is less than 30 loc. the dead-assignment analysis adds an additional 8 loc which gives us all in all less than 340 loc. we ran the deadassignment analysis on real java applications of sizes around 40000 loc, with execution times less than 9 seconds, including static-semantic checking, e.g., name binding, type checking, etc. initial experiments indicate that there is little difference in execution time when comparing our declarative implementation of data-flow analysis to an imperative implementation using explicit fixpoint iteration.



the rest of this paper is structured as follows. we first describe the implementation of the control-flow analysis in section 2. then we present the data-flow analysis in section 3 and show how both analyses can be used to analyze real-life applications in section 4. we compare our work to related approaches in section 5 and conclude and outline future work in section 6.



its children. an ifstmt has a condition expr,a then branch, and an optional else branch. a whilestmt has a condition expr and a stmt which is executed each iteration in the loop. certain exprs can act as stmts and we therefore introduce an exprstmt turning an expression into a statement. the value of an assignexpr is its rvalue and the lvalue is assigned that value as a sideeffect. a varaccess refers to a variable and can act as both an lvalue and an rvalue. a methodaccess is a method invocation with a list of arguments. a more thorough introduction to the abstract syntax definition is available at.



the successor to a blockstmt is the first contained statement or the following set if the block is empty. the blockstmt acts like a mediator giving each contained statement permission to execute in order. if statement i in a block completes then the successor is statement i+ 1, unless i is the last statement in which case the block completes and gives control to the following set.



the first rule declares a collection attribute(coll) called pred for stmt nodes. its value is of type set, and is defined as the call to empty(a method on set) combined with a number of contributions, each added by a call to add(also a method on set).(the contributing method of a collection attribute, add in this case, must be such that the order of adding the contributions does not matter.)



the second rule defines the contributions(contributes... to... for each). this rule says that a stmt contributes itself(this) to the predecessor set(stmt.pred) of each of its successors(succ). a more detailed presentation of collection attributes and their evaluation in jastadd is available in.



we use synthesized attributes to propagate information upwards in the ast. for example, sets of unmatched throw statements can be acquired via an attribute called uncaughtthrows defined for all nodes of type stmt. information about, e.g., enclosing trystmts, are broadcasted downwards in the ast using inherited attributes such as enclosingtrystmt. these synthesized and inherited attributes are matched against each other. for example, the set given by the uncaughtthrows attribute is matched against catch clauses in the closest enclosing try statement given by the enclosingtrystmt attribute. if no match is found, the control flow is directed to the finally block of the enclosing trystmt, if there is such a block, otherwise it is passed on to the next enclosing trystmt, and so on.



similar techniques are used to deal with break, continue and return statements. for example, after a break statement has been executed, all enclosing finally blocks between the break statement and its enclosing target statement, e.g., a while statement, need to be executed before the target statement. the control flow for a return statement is just a special case of this scenario, with the exit node as the constant target statement.



to evaluate the efficiency and scalability of our approach, we have implemented a simple analysis for java which detects dead assignment of local variables, i.e., the assignment of variables whose values are not used later in the program. this analysis can easily be added as an extension to the liveness analysis described in the previous section. we use the following definition to detect dead assignments:



to collect all dead assignments in a compilation unit, we add a collection attribute deadcode() to the compilationunit ast node. the dead assignments contribute themselves to the collection of their compilation unit using a contributes clause. the reference to the compilation unit is propagated to the statement nodes using an inherited attribute called enclosingcompilationunit.



soot,, is a framework for optimizing, analyzing, and annotating java bytecode. the framework provides a set of intra-procedural and whole program optimizations with a wider scope than the analyses presented in this paper. soot is based on several kinds of intermediate code representations, e.g., typed three-address code, and provides seamless translations between the different representations. java source code is first translated into one of these representations in which some high-level structure is lost. the control-flow and data-flow frameworks in soot are indeed quite powerful with reasonably small apis. a major difference, as compared to our approach, is that the soot approach is not declarative and therefore relies on manual scheduling when combining analyses, or adding new analyses as new specializations of the framework.



we have shown how reference attributed grammars augmented with circular attributes and collection attributes provide an excellent foundation for declaratively specifying control-flow and data-flow analysis. the specifications are concise and close to text book definitions, yet the generated analyzers are sufficiently efficient for real applications. the specifications are also extensible in that the analyses can be extended modularly when new features are added to a language.



there are several interesting ways to continue this work. the design ideas and frameworks presented in this paper are general and it would be interesting to see how they extend to more advanced analyses, e.g., object-oriented call graph construction and inter-procedural points-to analysis. we already have promising work in this direction, for example simple whole program devirtualization analysis. we would also like to design and implement declarative frameworks for other traditional backend analyses such as translation to ssaform. another interesting area would be to apply the same techniques to do domain-specific source level analyses, for example, enforcing framework conventions.



