this paper is based on a recently developed technique to build debugging tools for lazy functional programming languages. with this technique it is possible to replay the execution of a lazy program with a strict semantics by recording information of unevaluated expressions. the recorded information is called an oracle and is very compact. oracles contain the number of strict steps between discarding unevaluated expressions. the technique has already been successfully employed to construct a debugger for lazy functional languages.



in we have formalized a technique to automatically record and replay such step information. apart from showing the soundness of the approach we were able to prove interesting properties about the magnitude of resources needed to compute the oracle information. in we have then proposed a tool for debugging lazy functional programs with the oracle approach. this paper is concerned with the extension of the approach to functional logic languages.



before we discuss the details of our solution we first give two well known examples for the two topics. first we will introduce the non-deterministic operation(?) on base of which all following non-deterministic operations will be defined.(?) takes two arguments and non-deterministically returns one of them.



the connection between generators and free variables can be illustrated with the narrowing example. evaluating the expression replacing the variable with a generator, i.e.,(guard(head(genlist genbool())) 1) also yields 1 with the expression being evaluated only as far as needed, that is to the expression(true:genlist genbool()). not only with regards to semantics there is a close correspondence between generators and free variables, e.g., the result is 1. but also operationally the correspondence is tight as could be shown in. wherever we have a free variable in the substitution part of a narrowing derivation, we find a non-evaluated generator in the expression for the derivation with generators.



to project the search tree to a value we need a set of choices. such a set defines for which reference which alternative to take. for example the one choice could be(1,1) representing that for reference 1 we take the first alternative whereas(2,2) would represent the choice to take the second alternative for reference 2. projecting the resulting tree of the above example by the set of choices[(1,1),(2,2),(4,2)] we would obtain the list[1,2,3]. a search now boils down to the systematic construction of sets of choices. in order to illustrate this last point we also complete the definition of operation sorted defined above. as sorted matches on more than one constructor we have to introduce an auxiliary function. in general, in the resulting program each function matches at most one constructor. this makes it possible to continue the computation in the arguments of an or node. the completed declaration of sorted is accordingly:



the reason is that any path to the sub tree corresponding to(permute[3,1,2]) leads over the choices[(1,1),(2,2),(4,2)]. therefore these choices are also applied for this sub tree leading to the one possibility[1,2,3] only. in addition any choice including(1,2) can only yield a failure.



necessary lookup of choices. however, possible optimization techniques are beyond the scope of this paper and we concentrate on the main advantage of the described technique for building debugging tools. this advantage is that because the main computation is now clearly separated in a deterministic derivation and a projection, the oracle technique developed to replay functional programs can be extended for functional logic programs in a straightforward way.



as detailed in the search tree approach is well suited to implement search strategies as traversals on the tree structure. this is also compatible with the presented approach. if, for instance the programmer would have been interested in a first solution only with, e.g., a depth first strategy, the above expression would have been evaluated to(or 1 3(head(1:insert 3))) only and the corresponding oracle would have been[1,2,0].



we have implemented the ideas introduced in the last section into a debugging tool for the language curry. the tool is an extension of the one presented in for the functional subset of curry. in this section we will describe the basic ideas of how to present curry derivations to the user.



in the approach described in section 2.2 the end result of this derivation would be(1?1 2,[1,2]?1[2,1]). the references(here denoted as subscript to(?)) are then needed to reconstruct the fact that both parts of the tuple share the same choice, i.e., that(1,[2,1]) is not a valid projection of the result. in bubbling, in contrast, the next step is to copy the whole let expression.(if there was an outer context of this expression, that context would not be copied.) in the notions of, the tuple constructor is the dominator.



one of the main open problems with generator functions is how to reclaim the power of the unification operator(=:=). this operator introduces a new quality to functional logic programming. where narrowing only binds free variables to nonvariable constructor terms,(=:=) can also bind free variables to other variables. in this section we can only sketch the main ideas to solve this problem for the oracle approach.



finally, the projection from search trees to values described in section 2.2 has to be extended to a constraint solver. due to lack of space we cannot describe the implementation of such a solver and leave this part for future work.



we have presented a recently developed technique to record compact data about programs written in a lazy functional language. we have shown how this technique can be extended to include the advanced features of lazy functional logic languages, especially with respect to narrowing and non-deterministic operations. the extension to unification has only been sketched and a more thorough treatment is part of future work.



