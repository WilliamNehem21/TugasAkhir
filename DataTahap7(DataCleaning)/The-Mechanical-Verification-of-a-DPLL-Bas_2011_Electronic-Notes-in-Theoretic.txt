a step toward the verification of an efficient implementation of the satisfiability procedure. our verification of a sat solver is part of a larger program of research to provide a secure foundation for inference using a verified reference kernel that contains a verified sat solver. our verification exploits predicate subtypes and dependent types in pvs to capture the specification and the key invariants.



inference procedures have a number of important applications in programming as well as in other disciplines. in recent years, there have been rapid advances in the power and efficiency of inference procedures, particularly with solvers for propositional satisfiability(sat) and satisfiability modulo theories(smt). these procedures are used in assertional verification, bounded model checking, unbounded model checking, and planning. in addition to making these procedures efficient and



our verification, though interactive, exploits several features of the pvs language and inference mechanisms. in particular, we used pvs to interactively explore the details of the formalization so that our proofs at this point involve a fair amount of manual guidance. we plan to use our development to explore strategies for greater mechanization, particularly through the greater use of solvers for propositional satisfiability and satisfiability modulo theories.



pvs is a specification and verification framework based on higher-order logic and interactive proof. the pvs specification language enriches simply typed higherorder logic with predicate subtypes, dependent types, abstract datatypes and codatatypes, inductive definitions, type judgements, parametric theories, and theory interpretations. proofs in pvs are constructed interactively by combining a variety of powerful automated tools such as boolean simplification, ground decision procedures, rewriting, symbolic model checking, heuristic quantifier instantiation, and induction. new proof strategies can be defined in terms of old ones using a strategy



the pvs formalization consists of a formalization of the resolution rule of inference, a representation for partial assignments, the definitions of the basic operations used in the formalization, and the three key procedures: propagate, analyze, and dpll. we make heavy use of predicate subtypes and dependent types to capture the key invariants. typechecking with these types generates proof obligations called type-correctness conditions(tccs) that must be discharged using the pvs theorem prover. we only present the key definitions. the full formalization is available from the corresponding author.



before we define the main dpll search procedure, we introduce two other operations that are used in this definition. the parametric lift datatype from the pvs prelude library essentially adds, by way of a disjoint union, a bottom element to the given type t. it is used to represent the result of the search.



the main dpll search procedure is also defined recursively. in addition to the partial assignment, it takes the input clause set k in, which is included for specification purposes, and the current clause set k which extends k in with the conflict clauses learned through analysis during the search. the signature of this procedure dpllr is given below.



if propagation turns up a conflict and the decision stack is empty, then dpllr reports unsatisfiability. otherwise, if the decision stack is not empty, dpllr applies analyze to the conflict clause. if analyze returns an empty clause or a clause at level 0, then dpllr reports unsatisfiability.



the termination of the dpllr procedure is the major part of the correctness argument. as the informal proof showed, the soundness and completeness are not as challenging as termination. we describe the proof obligations in the correctness proof in the next section.



the bulk of our proof is devoted to proving the termination of dpllr. the challenge here is in showing that the partial assignment, which grows and shrinks, must eventually stop growing. the challenging parts of the proof are not in the orderings themselves, but in showing that the ordering is bounded and that the datatype invariants are satisfied.



we have described a mechanical verification using pvs of a dpll-based search procedure for propositional satisfiability. this procedure poses interesting challenges for verification and can used as a challenge for various automated and semi-automated tools. it is also a good example for experimenting with different styles of formalization. our verification is a initial step toward the construction of a trusted/verified reference kernel for checking the results of other untrusted verifiers.



respond to the individual cases of a larger proof. while our proof represents a preliminary and exploratary attempt, we plan to investigate avenues for better formalization and greater automation, and to examine the verification of satisfiability procedures, including smt solvers, that are more efficient and expressive. while it is encouraging that a relatively untrained user could build complex proofs with only a modest amount of effort, we believe that there is plenty of room for improvement.



