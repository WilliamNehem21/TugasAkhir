term rewriting has been shown to be a good environment for both programming and proving. for analysing and debugging rule-based programs, we propose in this work a formalism based on the rewriting calculus with explicit substitutions(-calculus). this formalism also allows us to build the proof terms of rewriting derivations. therefore, term rewriting proofs can be exported to other systems by translating them into the corresponding syntaxes. that is, using a proof checker, one can certify these proofs and vice versa, this method allows us to get term rewriting in proof assistants using an external system. our method not only works with syntactic rewriting but also with rewriting modulo a set of axioms(e.g. associativity-commutativity).



in a proof assistant, formal proofs are composed of deduction steps performed by the user with the possible help of tactics. these steps should be memorised if one wants to check the proofs and to communicate them with other systems[24,14]. in some proof assistants(e.g. alf, coq, lego), the proof terms of all deduction steps are explicitly stored. in other systems, proof term memorising was not given the rst priority but some attempts have been done to get this feature, for example, in isabelle or in hol.



hence, proof assistants must, in this situation, trust programming environments and consider the computations they perform as axioms in their proofs. this approach is not completely reliable since these computations are not checked. in other words, when correctness is crucial, rule-based programs should return the proof terms of their computations.



in this paper we present a representation of the proof term of rewriting derivation based on-calculus. we have generated the proof term of syntactic rewriting and ac rewriting in elan. the translation of this proof term into coq-syntax is described and is proved sound. this translation has also been implemented in elan. as a result, we get the corresponding proof term for coq proof assistant. this proof term is then formally checked by coq to ensure correctness. this work allows one to certify term rewriting proofs in elan and hence, to get term rewriting in coq using elan.



lemma 4.5(rewriting derivation) if 1;:::; n are respectively a proof term of the derivations t1! t2,...,tn! tn+1, then x![ n](:::[ 1](x):::) is a proof term of the n-steps derivation t1!:::! tn+1



the proof of this lemma consists simply in applying the tactic rewrite x= y on t. after being proved, this lemma can be used as a new constant for building coq proof terms. let s and v be two terms of type a. if is a proof of s= v, then(ctx t s v) is a proof of t[s]p= t[v]p.



where s is any-term which represents the proof term of a rewrite step(see section 4); ct x is a fresh constant representing the hole in a context; concat f inherits the arity from f 2 f and combines the proof terms at disjoint branches of f; trans concatenates the proof terms of two consecutive derivations; ref l represents a proof by re exivity; ctx represents the proof term of a non-root rewrite step. the introduction of ctx aims to separate the context from the proof term of a rewrite step and hence, to reduce the size of proof terms in coq-syntax as described in section 5.3.



in elan a proof term of proposition t= s in coq. we rst implement a tracing mechanism for syntactic rewriting and ac rewriting in elan. the generated trace includes the rewriting context, the used substitution and the applied rule in each rewrite step. we next transform the trace into a proof term in



this proof term in order to reduce its size by the rules in gure 2. a set of lemmas and their proofs in coq is then generated from this normalised proof term via the translation described in section 6. these lemmas include the main claim which states that t= s. finally, all generated lemmas are automatically checked in coq.



this trs is expressed in a natural way by the elan speci cation in gure 5. syntactic function symbols and their arity are described in section ops. section acops contains the ac function symbols(with arity 2). in section type, we need to precise the carrier type used in coq since this type is required in building coq proof terms. section vars declares the variables used in de ning rewrite rules. these rules are given in section rules with their label in the following syntax:[label] lhs! rhs.



