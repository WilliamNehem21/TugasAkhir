first, in the main boilerplate, we refer to two different systems(i.e. the writer and the fifo). this specification style, due to the used boilerplate, entails the invocation of two different functions; it is therefore represented with the invokes relationship between the push function(in main), and a new function, say function_001. for the sake of understandability, we name function_001 as add, to express that where beg(m), occ(e1), obs(s1) are mapped to events(component ports) corresponding to the occurrence of the main specification(beg(m)), the occurrence of e1 and the observation of s1 in execution traces of the model of system design. p2.1 is a safety property, whereas p2.2 is a liveness property; for both, a formal semantics has been defined



a widely used repository of patterns for functional properties is reported in. the semantics of these patterns is defined in computation tree logic(ctl) and in other logic languages. according to this approach, every property is specified using a scope(optional) and a property pattern. the scope(six different patterns) selects the subset of the model state-space, where the property is expected to hold; for the rest of the state-space, the property is undefined. the property pattern defines an expected occurrence of a given event/state(four different patterns) or the relative order of multiple events/states(four patterns) during system execution.



for extra-functional properties, the authors of[36,37] were based on the repository of, to introduce patterns for real-time specifications, while in the authors organized them in a unified framework and introduced some additional patterns, which complete this repository. a different set of patterns for timing properties has been also proposed in. finally, in the author has presented a repository of patterns for probabilistic properties, which have been used for real-world requirements focused on reliability, availability, performance, safety, security, and performability.



(properties derivation). due to the creative nature of this process, its obvious dependencies on two types of models and the form of the system design process(top-down vs. bottom-up design), human involvement cannot be vanished and therefore it can be only partially automated. in next section, we survey some noteworthy proposals of tool-support in recent bibliography.



