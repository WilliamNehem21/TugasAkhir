a higher-order strategic programming framework called tl is described. in tl it is possible to dynamically construct strategic expression of the kind mentioned in the previous paragraph. a demonstration follows showing how the higher-order constructs available in tl can be used to solve several problems common to the area of program transformation.



1 this work was in part supported by the united states department of energy under contract de-ac04-94al85000. sandia is a multiprogram laboratory operated by sandia corporation, a lockheed martin company, for the united states department of energy. victor winter was also partially supported by nsf grant number ccr-0209187.



as the distributed data problem(ddp). when the data to be distributed is independent of the input(i.e., constant for all input terms), simple strategies for distributing data can oftentimes be constructed statically. for example, consider constructing a strategy that will rewrite every integer in a term to the integer 2. here the objective is to distribute the integer 2 throughout a term structure by rewriting every integer encountered. this is an example of data distribution involving data that is independent of any specific input term.



strategic/rewriting systems are often provided with extensions in order to enhance their ability to describe the distribution of data. parameterization is one extension that is widely used as a mechanism for data distribution. for example, asf+sdf has been extended with a fixed collection of parameterizable traversal functions. another extension is to allow rule instances to be dynamically constructed using problem dependent data. in stratego for example, a mechanism is provided making it possible to alter rule bases at runtime through the dynamic construction and destruction of rules.



in this paper we look at higher-order extensions to strategic programming. specifically we will describe how the higher-order rules, strategies, and traversals of a strategic programming language called tl can be used to effectively distribute(dependent) data throughout term structures. though tl is presently a theoretical framework, a restricted dialect of tl has been in implemented in the hats 3 system and is freely available. all of the examples presented in this paper have been implemented in hats.



the remainder of the paper is organized as follows. section 2 gives an overview of tl. section 3 takes an in-depth look at the inner workings of a strategic implementation of set union in tl. section 4 looks at two manipulations common in the area of program transformation. section 5 discusses some related work, and section 6 concludes.



tl is an identity-based higher-order strategic system for rewriting parse trees. we use the term identity-based to denote rewriting systems in which the failure of rule application to a term leaves the term unchanged. we use the term failure-based to denote systems where the unsuccessful application of a rule to a term yields a special failure value. in contrast to tl, the strategic programming systems stratego and elan are failure-based.



when the dominating symbol and specific structure of a parse expression is unimportant the parse expression will be denoted by variables of the form t, t1,... or variables of the form tree, tree1, tree2, and so on. parse expressions containing no schema variables are called ground and parse expressions containing one or more schema variables are called non-ground. and finally, within the context of rewriting or strategic programming, trees as described here can and generally are viewed as terms. when the distinction is unimportant, we will refer to trees and terms interchangeably.



tl provides support for user-defined higher-order traversals. tl also provides a number of standard generic higher-order traversals. there are four degrees of freedom for a generic higher-order traversal:(1) whether a term is traversed bottom-up or top-down,(2) whether the children of a term are traversed from left-to-right or right-to-left,(3) which binary combinator should be used to compose the result strategies, and(4) which unary combinator should be used to wrap each resulting strategy.



in this section we look at how the union benchmark can be solved in tl. our approach is to lift basic operations on data(e.g., insertion of an element into a set, etc.) to the strategy level. for example, when implementing union, we wish to create a strategy that inserts a particular element into our union set only if the element does not already occur in the set. in tl the construction of these types of problem specific first-order strategies can be accomplished though higher-order strategies.



another difficulty in this example results from the structure of a block as defined by the grammar. specifically, a block has intentionally been defined to consist of a declaration list followed by a statement list. note that renaming must occur both within the declaration list as well as the statement list.



note that this transient strategy that can only be applied once and will perform either a restricted or free rename. during the course of a top-down traversal, the idea is to have this transient apply to the declaration which generated it after which it will reduce to skip for all subtrees of that declaration. if this can be accomplished, then any traversal that continues on to the initialization expression will leave all occurrences of the declared variable unchanged. in addition to this behavior, we would like the renaming to continue for the rest of the block(e.g., the remaining declarations and statements). it is precisely this behavior that can be accomplished by td br.



given this understanding of the interaction between td br and the transient combinator, let us consider the parse expression dec list[[ dec1; dec list1]]. when applied to this term, the strategy td br s will first apply s to dec list[[ dec1; dec list1]] yielding the strategy s'. a copy of the strategy s' is then broadcast to each of the children of dec list[[dec1; dec list1]]. in particular, both dec1 and dec list1 will receive their own copy of s'. more specifically, let us consider what happens when s is transient((restricted id1 id2)<+(free id1 id2)). in this case, the application of s to dec list[[dec1; dec list1]] will leave s unchanged(e.g., s= s'). next a copy of s' will be broadcast to both dec1 and dec list1. if dec1 is the declaration responsible for generating



s', then s' will apply to dec1 but will not apply to any subterm below dec1(e.g., the initializing expression in dec1). in contrast, within dec list1 s' will continue attempting to apply and broadcast its own copy of s' to its children. this will enable the strategy(free id1 id2) within the transient s' to rename all remaining occurrences of id1 to id2 within the block which is what is desired.



the strategy fun inline uses matching to split a block into its declaration list and statement list. the declaration list is then processed by the strategy fun dec which creates an in-lining strategy for each function declaration and composes the results into a strategic expression. this strategic expression is then applied to the original declaration list in order to in-line all the function calls within the declaration list. then this in-lined declaration list is again processed by the strategy fun dec. this time the resulting strategy is applied to the statement list which has the effect of in-lining all function calls. the resulting statement list is then cleaned up(e.g., excess parenthesis are removed from expressions) by the strategy remove parens whose implementation is not shown. finally, the resulting statement list is substituted for the statement list in the original block, as is the in-lined declaration list.



the strategy fun dec accomplishes its transformational objective through the help of the strategy inline. this strategy is given the name of a function id1, its formal parameter list id list1, and its body expr1 in curried form. with this information, the strategy inline is capable of rewriting a function call f[[ id1(expr list1)]] to an appropriately in-lined body f[[(expr2)]]. it accomplishes this with the help of the strategy zip.



the formal parameter list of a function. this traversal will create one transient strategy for each formal parameter id in id list. let s denote the resulting strategic expression. next, a traversal on the actual parameter list expr list is performed with the strategy s. this will result in a strategic expression



the higher-order nature of tl rules can be understood as a form of currried rewrite rule. in this context, curried arguments can be bound during the course of a higher-order generic traversal. the composition of strategies created during such generic traversal is related to a morphism. specifically, the one-layer generic traversal combinators that are used to construct full traversals are similar but not identical to hylomorphisms over rose trees found in functional programming frameworks. similar observations have been this strategy. stratego views the dynamic instantiation of rules as a rule base(i.e., a strategy where rules are composed using the left-biased combinator and newly created rules are placed on the left-most end of the rule base). it would be interesting to extend the dynamic rule generation mechanism of stratego to enable more control over the structure of dynamically generated rule bases. this idea has been recently proposed by martin bravenboer.



