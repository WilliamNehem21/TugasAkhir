proofs and computations performed with the system are correct with respect to the semantics of swinging types[17,18,19]. a swinging type is a functionallogic specification consisting of a many-sorted signature and a set of(generalized) horn or co-horn axioms(see section 3) that define relation symbols as least or greatest fixpoints and function symbols in accordance with the initial resp. final model induced by the specification.



of course, many conjectures can be proved both comprehensibly and efficiently without any human intervention into the proof process. such proofs often follow particular schemas and thus may be candidates for derived inference rules. however, proofs of program correctness usually do not fall into this category, especially if induction or coinduction is involved and the original conjecture must be generalized in a particular way.



in fact, the simplifier of expander2 performs certain normalizations. but they are in compliance with natural deduction and deviate from classical normalizations insofar as, for instance, implications and quantifiers are not eliminated by introducing negations and new signature symbols, respectively. on the contrary, the simplifier eliminates negation symbols by moving them to literal positions and then are removed completely by transforming negated(co)predicates into their complements. axioms for relations and their complements can be constructed from each treemode indicates whether the list trees of current trees(or other rooted graphs) is a singleton or represents a disjunction or conjunction of formulas or a sum(= disjoint union) of terms. true, false and() are the respective zero elements. the slider between the canvas and the text field of a solver window allows one to browse among the current trees and to select the one to be displayed on the canvas.



section 3 presents the syntax of the axioms and theorems that can be handled by expander2 and describes how they are applied to terms or formulas and how the applications build up proofs. section 4 shows how axiom applications are combined to narrowing or rewriting steps. section 5 goes into the logical details of the simplifier and lists the simplification rules for formulas. section 6 provides induction, coinduction and other rules that expander2 offers at the top level of interaction. the correctness of the rules presented in sections 4, 5 and 6 follows almost immediately from corresponding soundness results given in[16,17,18]. the concluding section 7 focuses on future work.



the underlined terms or atoms are called anchors. each application of a clause to a redex, i.e. a subterm or subformula of the current tree, starts with the search for a most general unifier of the redex and the anchor of the clause. if the unification is successful and the unifier satisfies the guard, then the redex is replaced by the reduct, i.e. the instance of prem, u or conc, respectively, by the unifier. moreover,



a guarded clause is applied only if the instance of the guard by the unifier is solvable. the derived(most general) solution extends the unifier. guarded axioms are needed for efficiently evaluating ground, i.e. variable-free, formulas. axioms or theorems used as lemmas in proofs, however, should be unguarded. otherwise the search for a solution of the guard may block the proof process.



(3) or(8). axioms determine the least/greatest fixpoint model of a specification(see section 1). theorems are supposed to be valid in this model. narrowing and rewriting consist of automatic axiom applications(see section 4). applications of individual axioms are restricted to the top level of interaction(see section 6).



a derivation is correct if the derived disjunction/conjunction(resp. sum) of the current trees implies(resp. is a possible result of) the original one. the underlying semantics is described in section 1. built-in symbols are interpreted by the simplifier. expander2 checks the correctness of each derivation step and delivers a warning if the step may be incorrect.



the narrowing procedure of expander2 applies axioms and simplification rules repeatedly from top to bottom and from left to right, first to the currently displayed tree and then to other current trees. usually, all applicable axioms for the anchor of a redex are applied simultaneously. hence narrowing steps within a proof provide case distinctions.



narrowing removes predicates, copredicates and defined functions from the current trees. the simplifier does the same with logical operators, constructors and symbols of the built-in signature. simplifications realize the highest degree of automation and the lowest level of interaction(see section 2). the reducts of rewriting or narrowing steps are simplified automatically.



similarly to narrowing and rewriting, the simplifier pursues a top-down strategy that ensures termination and the eventual application of all applicable rules. this is necessary because it usually works in the background. for instance, narrowing reducts are simplified automatically before they are submitted to further narrowing steps.



compilers that translate functional or relational programs written in, e.g., haskell, maude, prolog or curry into simplification rules. this might involve the combination of particular programming language constructs and their semantics with the pure algebraic-logic semantics of expander2 specifications. related work has been done by combining the algebraic specification language casl with haskell.



narrowing and fixpoint(co)induction complement each other with respect to the direction axioms are combined with conjectures: in the first case, axioms are applied to conjectures, and the proof proceeds by transforming the modified conjectures. in the second case, conjectures are applied to axioms and the proof proceeds by transforming the modified axioms. moreover, narrowing on a predicate p is, at first, a computation rule, i.e. a rule for evaluating p, while fixpoint induction on p is a proof rule, i.e. a rule for proving something about p. strinkingly, the situation turns upside down for copredicates: narrowing on a copredicate q is rather a proof rule, whereas coinduction on q is used as a computation rule. this observation makes it worthwhile to look for a uniform proof/computation strategy that uses fixpoint(co)induction already at the medium level of interaction.



