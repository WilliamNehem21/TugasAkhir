we wanted to support bookmarks i.e., the ability to mark a subterm as bookmarked and then later to return the cursor to that location. however, if the user makes a change to the term by manipulating a subterm, we want to be able to detect which bookmarks may have become invalidated by that change, and fix them in some way.



(to e.g., a string) and outline how clase makes this easier and more idiomatic for a user to do. another feature of clase is its support for bookmarks into the cursor, which are explained int section 5. finally in section 6 we outline related work and conclude.



expressions are either lambda abstractions, abs, which carry a string name for their variable, a type for their variable and an expression in which the variable is in scope. application expressions are the familiar application of two expressions to each other. variable expressions carry a de bruijn index indicating which enclosing abs binds the variable this var refers to. types are either arrow types, arr or some notional unital type, unit.



a simple cursor is a pair of the value(i.e., subterm) currently in focus(sometimes referred to hereafter as it), and some context, which will allow reconstruction of the entire term. our cursors are analogous to the zipper design pattern, allowing o(1) movement up or down the tree. in the down direction there are ways to choose which child should be visited.



as we saw in the diagram, when we move around our term, we build up a stack of context s. if our contexts were ordinary data types we could use a list, however we need to ensure that the to parameter of our first context matches up with the from parameter of the next context. to do this we use a new data type called path.



a language needs to have data types(expressed using associated data type families) corresponding to its context s, primitive movement s and a way of reflecting on the different types in the language(typerep). the context lam is as shown earlier. primitive movement s are gadt constructors that witness all of the one-step movements up or down that the cursor could do. for example, for lam they would be:



for simple languages, such as our lam language, the instance of language is straightforward and easily mechanically derivable. for such languages we provide a template haskell function that can automatically generate a module containing the language lam instance. as the current state of template haskell precludes the inline generation of gadts and associated data types, our generation function outputs the module as a source file that can be imported later.



clase also provides a set of generalized movement operators. these do not need the calling context to know anything about the cursor they are being applied to. there are four ways of generically moving around a tree, up, depth-first down, or moving left/right to the adjacent sibling of where you currently are. since it is unknown what type the focus of the cursor will be after applying one of these operations, they return cursor s with the type of it existentially quantified.



an editor developed using clase may want to keep track of multiple locations in the tree(e.g., to provide bookmark or quick-jump functionality). ideally we would like these bookmarks to be persistent across updates to the tree, and where this is not possible, for there to be some way of dealing with the now invalidated bookmarks. any position in the tree can be reached from any other by a series of up movements, followed by a series of down movements. using the path data type from



one of the fundamental underpinnings of our work(and much of the related work) is that of a one-holed context. these have been discussed in, and provide an interesting relationship between differential mathematics and data structures. indeed it is due to this link that we know we can automatically generate the context s for simple data structures using our template haskell scripts.



an alternate approach to the cursor library was explored in. here, the zipper library is parameterised by a traversal function and uses delimited continuations to move around the tree. the authors also show how to support a statically known number of sub-cursors, allowing something like our route/bookmark functions. they however, are working in the context of filesystems and do not need to consider lexically bound information in the interface they present.



