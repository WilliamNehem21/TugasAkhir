logical frameworks are meta languages designed for representing various formal systems prevalent in programming language semantics, logics, and protocol design. by design, a logical framework is foundationally uncommitted, meaning that it is primarily concerned with the way formal systems are represented and not with reasoning about their properties. logical frameworks have, in this spirit, undergone significant extensions, leaving the design of meta logics far behind. modern logical frameworks incorporate linear types to model resource awareness(useful when designing programming languages with effects), ordered types(to model formal systems that access resources in a particular order), and even monadic types that capture concurrency.



into the llf setting. l+ is first-order, intuitionistic, and not linear. aside from t, it does not define any logical constant symbols. it does however inherit proofs by induction over arbitrary higher-order types without the restrictive positivity condition, including those that take advantage of both linear and intuitionistic assumptions. furthermore, it supports quantification over llf contexts. l+ can be used to reason about meta properties of languages encoded in llf. for instance, it should be possible to show type soundness of a simple programming language with references or cut elimination for a linear logic. l+ must be dependently typed to



be a type constant, an application, a dependent function type, the linear function type, the additive product type, or the additive unit. objects can either be an object constant, a variable, an intuitionistic function or application, a linear function or application, a linear additive pair or projection, or the constructor for the additive unit. a signature binds type and object constants. an llf context is either empty, or a smaller context extended with an object binding.



properties about llf objects in section 3.1. next, we describe how the meta level deals with llf contexts, and how the interface there works. the necessary vocabulary having been built, we then discuss the meta logic proper, starting with its syntax and semantics, then moving to the proof theory. the running example will be continued to illustrate the concepts in question.



meta variables and context variables form the basic interface between llf and the meta level. this would be sufficient if we only wanted to reason about closed llf terms. but the goal of the paper is significantly more ambitious than this, i.e. to reason about all higher-order llf encodings, including those that may very well be open. the meta theoretic view of openness inevitably impacts the llf level. for reasons that have not been discussed so far(but will be in the next section),



the semantics of l+ portrays its intended use as a meta logic to reason about llf encodings. any proof within this meta logic should convince a critical observer of the validity of the statement, lemma, or theorem. it is almost certainly possible to give a categorical or model theoretic explanation of proof. we have instead chosen to view proofs as total programs via a realizability interpretation. a proof hence acts as a transformation in between llf encodings. its input/output behavior is fixed by the formula, its type.



