testing is a validation technique aimed to find defective behaviours on a system either during its development, or once a final version is issued. it remains one of the most feasible methodologies to ensure the expected behaviour of a software. this is notably due to its ability to cope with continual growth of system complexity. however, reducing its cost and time consumption remains a very important challenge sustained by a strong industrial demand.



the remainder of this paper is organized as follows. sect. 2 describes the underlying theory of j-post and sect. 3 describes the toolchain itself. in sect. 4, we depict one of the experiments conducted with j-post on a travel agency application. sect. 5 exposes some conclusions and perspectives opened by this work.



l. formulas of l are built upon a finite set of n-ary operators fn and a finite set of predicates{p1, p2,..., pn}. the abstract syntax of such a logic could be defined as follows: formula::= fn(formula1, formula2,..., formulan)| pi.



test controllers tf n, associated with each n-ary operator fn of the logic l. their purpose is to control the execution of the test process associated to each of their operands by means of basic signals(start, stop, loop), and to collect their verdicts in order to produce a resulting verdict corresponding to this instance of operator fn. one can find controllers for several logics in the research reports provided in.



the test designer of j-post is a user assistant that helps to elaborate the formal requirements and the corresponding test modules through dedicated editors available within the eclipse modeling framework. each test module is stored into an xml file(their j-post internal representation). moreover, the test designer provides a tool(based on graphviz) to vizualise them in a more intelligible way. this avoids any error-prone manipulations of xml files from the user.



the first stage is the construction of a communication tree obtained from the abstract syntax tree of the formula. this tree expresses the communication architecture between the test processes that will be produced by the test generator. its leaves are abstract test modules(atm) corresponding to the atomic predicates of the formula, taken from the library. its internal nodes are(copies of) generic test controllers, corresponding to the logical operators appearing in the formula(they are obtained from a finite set of generic controllers provided by the logic plugin). finally, the root of this tree is a special test process, called testcaselauncher, whose purpose is to initiate the test execution and deliver the resulting verdict.



