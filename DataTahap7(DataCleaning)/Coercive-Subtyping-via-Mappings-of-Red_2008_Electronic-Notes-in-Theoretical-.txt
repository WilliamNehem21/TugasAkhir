this paper explores one novel alternative. we start from the idea that coercion means that we wish to use a value v in source type u as if it was a value in target type t, or more specifically, that we wish to compute with v in terms of t. this intention does not force us to convert v into a representation in t. instead, a mapping is constructed between the computation behaviours of u and of t in terms of the elimination operators of both types which allows easy transformation of operations on t into operations on u. this clearly avoids converting v to t, but we suggest there are several other important benefits, including(a) the links between source and target type are made explicit and are in terms which are fundamental to both types, so it is thus clearer why and how u can be treated as t;(b) making such information more explicit has several benefits in establishing key properties, not least simplifying some of the proofs;(c) it provides a framework to discuss and characterise different proposed coercions, and possibly to impose meaningful structure on sets of coercions.



converted to functions on vectors in exactly the same way. the modification reflects how the types are related and this is independent of actual functions. we aim to use this relationship to allow computation on a source value in terms of the target type, without converting the source value. a particular form of elimination operator is proposed to encode this relationship in a clear way: operators exy should take the parameter, motive, and branch function arguments of the eliminator for type x, but take a value in type y as the elimination target, and should be defined in terms of ey. for the vector-to-list example, this means:



to use these terms, we propose that coercion becomes a two-stage process. initially, a coerced term is marked(with a form of constructor), and when this reaches an eliminator of the target type, the exy term is used to map the computation to the source type. hence no conversion(of value) takes place, and nothing happens until a computation acts on the coerced value. this process is clearly type-safe, although formal metatheory relating to canonicity and convertibility remain to be studied as further work.(some preliminary remarks are made.) we briefly consider how the exy terms affect the proof of relevant properties. the key point is that composition via exy terms eventually reduces to elimination on the source type.



inductive families are a generalisation of inductive types, where a family of types is inductively defined. an extended schema replaces constant x with an indexed form x q and modifies the construction of operators to insert indices at appropriate places. these indices are different in nature from the parameters above: parameters are fixed for any instance of a type, but the indices may vary inside the value depending on how it has been constructed.



time taken to do the extra work. this is wasteful, especially with the intuition that the folding could, in some sense, just traverse the vector structure and pick out the useful information. can sumv(sum on vectors) be defined in terms of how summation works on lists? the composition of suml with v2l works, but a better(e.g. more efficient) version is possible when we have access to the arguments to the elimination operator inside suml. that is, when:



thus we have defined sumv purely by modification of the arguments of the eliminator in suml. this sumv is convertible with the direct definition on vectors. in fact, given arbitrary c, f0, f1, we can transfer any elimination on lists to one over vectors. we aim to use this kind of transformation as the basis for coercive subtyping.



as a first attempt, the transformations will be expressed as a particular fixed form of eliminator: the parameters, motive and branches(i.e. functions for each constructor) will be based on the target type, but indices and the value to eliminate over will be based on the source type. the head symbol of the function body will also be the eliminator of the source type. defining this as a well-typed term also guarantees the type correctness of a transformation. for the vector to list example, this means a term elv as defined below.(such terms are henceforth named exy, where x is the target type and y the source type.) target type. in the standard approach,(a) the coercion function performs the transformation on non-blocked terms and convertibility can proceed; or(b) the term is blocked, e.g. as a variable, so the coercions remain in place and conversion fails unless the coerced values are convertible.



are to be taken as canonical values of the target type. subtyping does blur the notion of canonicity. an answer to this question has bearing on how reductions of the form above are used. we leave this issue for further work.



we now consider how the exy terms behave under composition. the transitivity rule of coercive subtyping forms new coercions by composition, and coherence requires a check that new coercions are consistent with existing coercions. a related case is where values are coerced to one type and in the course of later computation are coerced again, possibly back to the original type, that is where a term coy p' q'(coz p'' q'' v) is formed(p and q represent parameters and indices).



assuming the properties of identity eliminations suggested above, convertibility is blocked here only by the vector length component, i.e.(length a(cov a n v))= n is not derivable intensionally. it can be proved extensionally by induction over n or v. note that this is still a computation applied to a coercion, but reduction via



the full mechanism, including identity elimination reductions in conversion, will be straightforward to implement. identity eliminators can be derived from schemata. the types of exy terms can be generated automatically from the relevant schemata. derivation of definitions of exy terms may be possible for simple cases, else the user can develop the definition by refinement. the existing algorithms for generating and matching coercions will not need changes.



improvements in efficiency of coercion execution are expected. firstly, there is no intermediate structure to be built and then traversed: computations are applied directly to the original data(this technique has parallels with deforestation in functional programming). secondly, the exy computations can be improved in several ways, not least some form of partial evaluation or normalization by evaluation on the branch functions to avoid repeated work later, or the collapsing of chains of coercions(e.g. projections on algebraic structures) to simpler functions.



this work is still in early stages, but early results are promising and there are several interesting extensions to pursue. the work contributes in several ways:(a) characterising an important subset of coercion functions;(b) enabling proof of key properties of this subset;(c) supporting greater efficiency of coercion use. progress has been made towards simpler proofs on functorial coercions, and towards new proofs for more general cases of coercion combination(e.g. compositions involving several distinct types) that were previously identified as problematic. all of these aspects are important to promote coercive subtyping as a useful and practical abbreviation mechanism.



