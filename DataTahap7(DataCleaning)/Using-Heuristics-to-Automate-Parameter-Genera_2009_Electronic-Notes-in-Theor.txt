the contribution of this paper is a novel self-correcting approach for the automatic generation of input parameters for java methods, based on formally-defined heuristics. the heuristics help to find parameters which can be used in meaningful benchmarks. the presented approach detects inappropriate methods arguments on the basis of thrown exceptions, automatically approximates underlying exception causes using novel heuristics and recovers them by generating new and appropriate input parameters. the generation of the parameter values for a method is not based



the remainder of this paper is organised as follows. section 2 describes the foundations, and section 3 gives an overview of the presented approach. after presenting the heuristics used for generating arguments in section 4, advanced heuristic algorithms that are useful to handle runtime exceptions are specified in section 5. the case study is described in section 6. section 7 reviews related work, while section 8 describes our assumptions and limitations. the paper is concluded in section 9.



our approach is designed to work for any java api, not only the java platform api. however, the classes of the platform api, such as java.lang.string, are very heavily used in all java apis. hence, instances of types from the platform api are needed as parameters of methods in other apis and we have started with the platform api.



to establish the inheritance and implementation relations discussed in sec. 2, our approach starts in step 1 by parsing the compiled bytecode of the api implementation. then, in step 2, a navigable api model is built, which includes a type graph. to facilitate usage and maintenance, the api model is designed to extend the official java reflection api. step 2 also computes a complexity metric for each method signature, based on the number and on weighted complexities of input parameters(see sec. 5 for details).



and with respect to dependencies on returned values(e.g. if a method returns a type instance needed as input parameter by other methods, as identified by the parameter graph). for each method, steps 3 through 5 are performed. if a method execution fails with given input parameters, it is decided whether that method should be abandoned or if other input parameter instances should be tried by performing steps 6 and 7. this decision is controlled by the possibility to choose other nodes in the parameter graph, by the importance of the method, and by the number of repetitions spent for the given method signature. the default strategy for this decision proved to be sufficiently successful for the java platform api(cf. sec. 6),



in step 4, the resulting parameters are used to execute the considered method, using java reflection api. for non-static methods, the construction of the invocation target is also accomplished in step 4. if the method returns a value(i.e., not void), that value needs to be recorded in the repository, as it can be later used as input parameter to other methods.



often, the constants declared in dc and its superclasses are the input parameters which are more likely(or even exclusively) accepted by the considered method: for example, the method java.util.calendar.set(int year,int month,int date) should make use of static int fields january etc. in that class



according to the declared component type of the container, hpg randomly generates l elements of the declared component type, except where the component type is objectin such cases, hpg generates object values having the same dynamic type as dc. details about the generation of reference component types(i.e. object and its subclasses) are described in the next section.



ones that declare fewer but reference type parameters. if the simplest constructor turns out to be inappropriate(i.e. it throws runtime exceptions or returns null objects, or empty objects such as a string of length 0), other constructors or factory methods are tried.



for collections such as classes implementing lists and maps, hpg constructs empty instances and then fills them with n objects(n smaller than the above fixed capacity/length) in respect to the type parameter bounds they declare. for example, in order to generate a list<e extends number>, hpg constructs an empty java.util.arraylist instance and fills it with objects having a dynamic type that is subtype of the type parameter bound number(long is such a subtype of number).



an indexoutofboundsexception is thrown when an index is out of range for a container class(e.g. list, queue, etc.), for an array, or for a string. our heuristics handle indexoutofboundsexceptions as well as its subclasses arrayindexoutofboundsexceptions and stringindexoutofboundsexceptions. indexes are inttyped parameters, and as discussed in sec. 4.1, they are generated after other parameters have been generated. in particular, we assume that all container-typed parameters have already been generated.



classcastexceptions are thrown to indicate that the code has attempted to cast an object to a class type of which that object is not an instance. in order to handle classcastexceptions, we designed a heuristic that attempts to determine the appropriate dynamic type of the parameter. if several object-typed parameters exist, the heuristic is applied to all of them.



collections contain a set or a list of elements. some collections allow duplicate elements and others do not; some are ordered and others unordered. most collections have capacity-restricted implementations, which means that exceptions are thrown if the collection capacity is exceeded after an add operation, or if a remove operation cannot be performed because the collection is empty.



in order to handle such exceptions, we mapped each collection operation to its relative one(e.g. add vs. remove). special attention was paid to filling the collections: capacity restrictions should not be violated. the number of elements to add in a collection should not exceed its declared capacity.



none of the 34 methods declared in the class java.lang.securitymanager could be executed since the creation of a securitymanager instance is not trivial to automate. the only constructor declared by that class throws a securityexception if a security manager already exists and its checkpermission method does not allow the creation of a new security manager.



these metrics were collected for the methods declared in the classes of the java platform api packages java.util and java.lang, which were already discussed above. as we are not aware of a reference implementation or approach that uses completely-random parameter generation, we currently cannot analyse the effectiveness of the initial parameter generation(i.e. before the heh is applied).



we have assumed an exception mechanism which allows to catch exceptions and to continue program execution. while many modern languages and execution platforms provide such mechanisms, some do not, e.g. c++ and older operating system that execute unmanaged binary code. in such contexts, our approach is not applicable.



in the work presented in this paper, we assume that work on parameter generation starts from the scratch. if execution data already exists, heurigenj could make use of it to find additional parameter values, or find values faster. the current implementation of heurigenj has no support for this.



the principles of heurigenj can be applied to apis that are made available through other languagues than java. for example, there exists no automated approach for input parameter generation for methods declared in the.net runtime api. many object-oriented principles and problems addressed by heurigenj(e.g. polymorphism, abstract-typed parameters, complexity of method signatures, exception handling) are similar in.net and other modern managed languages, especially those that compile to bytecode.



