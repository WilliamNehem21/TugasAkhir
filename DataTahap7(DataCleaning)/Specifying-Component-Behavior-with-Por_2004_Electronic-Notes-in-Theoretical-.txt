behavior protocols capture the behavior of a component via a set of traces. a textual notation similar to regular expressions is provided to approximate the behavior with a regular language. in[1,17], the compliance relation and consent operator are defined to reason on consistency of component composition; a verifier tool is available for the compliance relation.



[4,5,6,15]. however, in uml state machines, significantly different mechanisms are employed to specify events received and sent. events received(in case of a component corresponding to operations on the provided interfaces), are captured as triggers associated with transitions of the state machine. a state machine uses activities to specify its responses to events received(i.e., events sent and internal actions). an activity(a petri-net like abstraction in principle) consists of actions, some of these actions correspond to sending events. however, the spectrum of actions is rather huge and it is not possible to establish a one-to-one correspondence between the triggers and actions related to a communication; thus, it is not possible to derive the behavior resulting from the composition of communicating components(exchanging events) specified with state machines.



considering the motivations discussed in sect. 1.2, we propose port state machine(posm) with the following goals:(1) provide a notation that allows to capture interleaving of events sent and received(by a port of a component) and support nested calls in such a way that the behavior can be captured with a trace model based on atomic events.(2) moreover, a verifiable compliance relation should be defined for posms.



this paper is structured as follows: sect. 2 introduces the port state machines(posms), in sect. 3, we show how composition verification can be achieved with posms; a case study follows in sect. 4. sections 5 and 6 evaluate the contribution, discuss related work and line out future research; the paper concludes in sect. 7.



portstatemachine is defined as a subclass of protocolstatemachine. thus, a posm contains one or more regions; a region contains vertexes and transitions. a transition connects a source vertex to a target vertex. a vertex may be a pseudostate or a state. a pseudostate is a syntactic construct to model entry and exit points of regions.



a state may contain zero or more regions. a state not containing any region is a simple state. finalnode is a specialization of a state representing the completion of a region; a finalnode may not contain any regions or have outgoing transitions.



a transition in a portstatemachine must be either a porttransition or a protocoltransition; a transition that is not a porttransition may not specify any triggers, i.e., can only accept the completion event. a porttransition may only originate in a state(but may target a pseudostates).



definition 2.11 the set of all traces of all possible runs of pa forms the execution language of pa, denoted le(pa). communication language of pa, denoted lc(pa) is the restriction of le(pa) to the domain of communication events ce.



also please note that we define the call state and call transition notation shortcuts by specifying how they expand into elements defined in the posm metamodel. we consider this approach to be the most efficient with respect to readability of the paper, in particular of the trace semantics definition. alternatively, we might define call state and call transition in the metamodel and either extend the semantics definition also to these elements, or to define a transformation of a model employing these constructs to a model based only on the already considered metamodel elements; both these approaches are feasible.



proof sketch: a posm pa can be transformed to a finite automaton. by following the structure of pa, orthogonal regions may be replaced with cartesian product of states; a composite state can be replaced with its substates, redirecting outgoing transitions to all substates(except those that already have a higher-priority transition) and redirecting the incoming transition to the substate targeted by transition from initial pseudostate. the generalized finite automaton(employing empty transitions). this way we yield a non-deterministic finite automaton, generating a regular language.



behavior protocols provide a behavior compliance relation, which can be used to verify composition of components based on their behavior specifications. in this section, we first briefly review behavior compliance as it is defined in behavior protocols and describe how behavior compliance can be used to address consistency issues in the composition of software components. afterwards, we show how behavior compliance can be applied to posms. finally, we discuss how this can be used to address the consistency issues in composition of uml 2.0 components.



+(alternative),|(parallelism, based on arbitrary interleaving of traces) and(parallel-or, a b is a shortcut for a+ b+ a|b). further, the composed operators are composition(hx), adjustment(|x|) and consent(qx). the notation also uses the shortcuts discussed in sect. 2.3 and parentheses.



and b results into an error. the types of errors considered are badactivity(a emits a but b is not ready to absorb a), noactivity(similar to a deadlock situation) and divergence(interaction of a and b never stops). the consent operator implicitly provides a relation for checking the composition of a and b, by considering the composition to be correct if a qx b contains no erroneous traces.



by adjusting l(a)/s with l(prot a)/sprov(the dictated inputs) over sprov, only traces from l(a)/s with inputs dictated by l(prot a) are considered; these traces must be contained in l(prot a/s). for reference, the original definition of behavior compliance is available in. the case study in sect. 4 provides demonstrations of the behavioral compliance relation.



in behavior protocols, the issue(a) is addressed by the compliance relation(employing the composition operator to obtain the composed behavior). the compliance relation may be also used to address the issue(b). finally, the issue(c) is addressed by the consent operator.



both posms and behavior protocols describe behavior in a way that yields a set of communication traces, conveniently a regular language. it is possible to transform a behavior protocol into a posm, i.e., construct a posm generating the same communication language as the behavior protocol(restricted to the communication events contained in s).



in a similar vein, we may consider constructing a behavior protocol for a port state machine. however, in the general case, the only solution is to first transform the state machine into a regular automaton(expanding composite states) and afterwards, apply the generic algorithm for transforming a regular automaton into a regular expression. such process would significantly impair readability of the resulting behavior protocol.



?dbnotify.newbalance may be processed zero or more times; and that the call!log.logdeposit will be issued while processing?dbnotify.newbalance, each time this call is received. surprisingly, lc(p r3) is compliant with the lc(p s). although the pr3 can call!log.logdeposit more than once(or not at all), this may occur only in runs where?dbnotify.newbalance is called



more than once(or not at all). thus, after reducing(via the adjustment operator) lc(p r3) to traces with inputs contained in lc(p s)(i.e., traces where?dbnotify.newbalance is called exactly once), the resulting behavior calls!log.logdeposit exactly once(in an order permitted by the ps) and therefore, condition(ii) of 3.2 holds; condition(i) holds trivially.



with the aim to employ posms to model use cases, our future goal is to further investigate operations for assembling behavior scattered in multiple posms into a single posm. currently, composition is defined only for communication languages of posms, yielding the composed behavior as a language. we aim to explore composition of posms at structural level, with the goal to construct a posm representing the composed behavior. moreover, broadening the definition of behavior compliance to include also state events(for entering/exiting a state) remains a challenge.



moreover, as posms use atomic events, the behavior on a port specified by a posm is captured as a set of traces, forming a language upon a finite alphabet. the behavior compliance relation has been established to reason on compatibility of posm specifications. as the language of a posm is regular, the compliance relation is decidable; conveniently, an already existing verification tool can be employed for this task.



