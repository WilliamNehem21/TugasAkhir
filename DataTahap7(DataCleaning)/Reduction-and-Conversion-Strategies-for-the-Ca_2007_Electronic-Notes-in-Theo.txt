implementations of the conversion check risk to perform more reduction than required and to analyse reduced terms that become larger than expected. conversion strategies can be used to control and minimise the amount of reduction performed. orthogonally, we can choose reduction strategies that differ both in reduction time and in the shape and size of the reduced term(e.g. call-by-value weak head normal forms differ from call-by-name weak head normal forms).



this paper is about performance evaluation of several combinations of conversion and reduction strategies for the calculus of(co)inductive constructions(cic). the goal is to assess their degree of independence and to suggest improved strategies or combinations. to isolate the strategies from the rewriting rules employed, we adopt a reduction machine parameterised over the reduction strategy and we pick a set of rules for conversion that define a conversion algorithm also parameterised over conversion strategies. in the second part of this paper we will choose a different set of conversion rules and we will analyse again the same combinations of strategies on the new rules. this way we will assess the degree of independence of the strategies from the rules.



in this paper we look for strategies that behave reasonably both in the common situation and when two level reasoning is employed. however, better results could probably be achieved exploiting different strategies according to the terms to be tested for convertibility. this research direction is mostly unexplored for cic and is left as future work.





of cic. in sect. 3 we describe the basic conversion algorithm whose performance is evaluated in sect. 4 in combination with several conversion and reduction strategies. sect. 5 and sect. 6 describe two conversion strategies. reduction strategies for a parametric reduction machine described in sect. 7 are discussed in sect. 8.



in the rest of the paper we reserve c for constant names, i for inductive type names, k, k1,..., kn for inductive constructor names, s for sorts of the form set, prop, type(j) for j being a natural number, t, f, u, t, n, m for well formed terms and j, n, m, l, r for positive integers.



example 2.1 let tree and forest be two families of mutually inductive types indexed by one parameter a that is the type of the elements of the trees. the types are constructed by the constructors node, empty and cons according to the following definition in matita syntax.



in this section we present the idea behind a simple algorithm to test convertibility that is easily adapted to cumulativity. we call it the basic conversion algorithm. the algorithm will be presented as an almost syntax directed judgement that, seen as a rewriting system, presents critical pairs that must be solved using strategies. moreover, the judgement is parameterised over a class of reduction algorithms that leave great freedom in the choice of the reduction strategy. in the following sections we will evaluate a few strategies.



definition 3.2[redex in head position(r.h.p.)] a subterm r is the redex in head position of a term t iff r is t and t is a redex or r is the redex in head position of t' and t' is the subterm in head position of t.



the benchmarks show the effect of convertibility and reduction strategies on type-checking time. the improved strategy and the further improved strategy will be discussed in sect. 5 and sect. 6 respectively. the benchmarks have been performed running the kernel of the matita interactive theorem prover on a subset of the library of the coq proof assistant. all the tests have been run on a pentium iv 2.5 ghz with 1gb of ram. matita is written in ocaml.



let us consider now the improved convertibility strategy of the previous section. the strategy is optimal for identical terms. let t1 and t2 be the two smallest non identical subterms in corresponding position(i.e. in two identical contexts). to check their convertibility, both terms are reduced to their w.h.n.f., possibly performing other reduction steps as well according to the reduction strategy.



the way to improve the situation is: 1) to be able to detect in advance which one of the two terms is more likely to reduce to the second one; 2) reduce it only until the second one or a w.h.n.f. is reached.



having considered three different convertibility strategies, we want now to compare their behaviour when combined with different reduction strategies. to make the comparison, in our phd. thesis we have described gkamcic, a generic reduction machine, based on the abstract machine of krivine, that is parameterised over the reduction strategy.



definition 7.1(parameters of the reduction machine a.k.a. strategies) the reduction machine is abstracted over the following parameters. any instantiation of the parameters is called a strategy. the first two parameters are the abstract datatypes used for the environment items and the stack items:



the following theorems are proved in. together with the strong normalisation property of cic for well typed terms they show that the reduction machine implements strongly normalising reduction on well typed terms when instantiated on correct and lively strategies. moreover, weak head progress is granted.



call-by-name is implemented by immediately reading back a closure before pushing it on the stack. thus the stack and the environment are made of terms; pushing a stack item to the environment does not change it and fetching a machine state from the environment builds a new state from a closed term. an alternative implementation consists in keeping closures both on the stack and the environment, yielding an instantiated reduction machine that is isomorphic to the kam extended to cic.



strategies seem more effective than reduction strategies; 2) call-by-name(also in the call-by-need variant) gives better results than call-by-value, and a strategy that is somehow intermediate between the two of them from the point of view of convertibility or reducts gives intermediate results. however, we can also observe the existence of a very heavy theorem that can be type-checked in reasonable time only in a call-by-value setting. similar theorems, all based on two level reasonings, are also found outside the standard library, in the user contributions. notice, however, that several other theorems proved with the same approach in the standard library are type-checked in a reasonable time with our best combination of strategies.



solution, that is the one adopted for a particular strategy in the coq proof assistant, is under implementation in matita and it seems to give results compatible with the ones of coq. the subject of the second part of this work will be the description of this alternative algorithm and a performance evaluation of the conversion and reduction strategies presented here when applied to that algorithm. we claim that for cic the relative performance of the strategies is actually independent from the choice of the algorithm, i.e. from the term representation and the exact rewriting rules employed.



