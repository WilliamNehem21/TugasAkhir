we consider two distinct subtyping relations in our framework: the static subtyping relation simply models subtyping which could be possibly provided by the static type system, whereas dynamic checks are modeled by a dynamic subtyping relation, which is intuitively expected to be more liberal. indeed, in order to refuse communication in as few cases as possible, the runtime check accepts even mobile code which would be rejected if statically available, by automatically inserting coercions driven by the dynamic subtyping relation. in this way, mobile code exchange is both safe, since after coercion code has a statically permitted type, and flexible, since more code can be accepted.



the rest of the paper is organized as follows: we first present the untyped version of our calculus in sect.1, then add static and dynamic checks in sect.2. we formalize the notion of type safety in our parametric framework and provide tion at the core level. note that core code can be either sent or further reduced in a non deterministic way, and analogously for core code in a rebinding. this means that we do not care about where core mobile code is executed, either by the sender or the receiver, even though this will of course make a difference in practice, e.g., in case of non termination. sending a process term, instead, intuitively means sending coordination code to be executed by the receiver.



we prove the above proposition as a case of the following, which takes into account communication steps with the outside world. intuitively, when receiving code e, no unbound variables are introduced only if e has no more free variables than those it declares. conversely, code sent to the external world has no more free variables than those it declares(this is inductively used to prove the property on internal steps).



we ensure type safe exchange of mobile code by a runtime check analogous to that considered in for mixin classes, to solve the classical problem of interference in record/object types. that is, dynamic subtyping corresponds to standard width subtyping on record types, together with a coercion function which removes additional fields 9. then, the type declared by mobile code is a subtype of the expected type, hence communication can take place. mobile code is adapted to the local code by the following steps. first, y is replaced in the received code via coercion from posint to int, which is the identity, obtaining{x: 0,y: 1,z: 2}. then, x is replaced in the local code via coercion from{x: int,y: int,z: int} to{x: int,y: int}, obtaining a safe record extension in send({x: 0,y: 1}+{z: 3}).nil.



the contribution of the paper can be summarized as follows. first, we have extended previous work introducing an abstract framework for type-safe exchange of mobile code to the(non trivial) case of open code. the outcome is a parameterized process calculus which allows to express in a simple and clean way rebinding of code in a distributed environment. in this respect, some work which has directly influenced our approach is that on dynamic software updating in, e.g.,[5,6,15]. however, here we consider arbitrary core calculi rather than lambda-calculi, and an explicit language for the process layer, whereas in[5,6,15] the basic primitive is an update primitive which when performed changes local code in a less controlled way.



