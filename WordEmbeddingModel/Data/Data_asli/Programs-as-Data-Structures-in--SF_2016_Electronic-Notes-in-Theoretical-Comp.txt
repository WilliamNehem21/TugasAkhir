this expressive power can be used to support arbitrary queries of closed normal forms. in this sense, we can identify the data structures with the closed normal forms. what about programs? the standard interpretation of programs does not yield normal forms since recursion is modeled by a fixpoint function that does not have a normal form. however, traditional combinators can be used to identify programs, even recursive ones, with closed normal forms. hence, we can identify the programs with closed normal forms, to get



the identification of programs with(closed) normal forms in an untyped setting is rather unusual. of course, we cannot isolate the terminating computations, as this would solve the halting problem. if, further, we allow any computation to be a program, i.e. albeit one that takes no inputs, then the game is over. however, by separating the program from its inputs, we can use combinatory techniques to block any troublesome reductions in the program until the input is given. in this manner, programs can be made strongly normalising, and so can be identified with(closed) normal forms.



the proofs of all the named lemmas and theorems in the paper have been verified using the coq proof assistant. details can be found in the source files. this section will reprise some of the key definitions and theorems, to gain some feeling about how well aligned are the manual and automated approaches.



domain specific languages users are driven to create their own, domain-specific programming languages because general purpose languages prove to be sub-optimal for their needs. one approach is to grow a language from a small core[19,10]. this will be easier once program analysis and evaluation strategies are definable.



