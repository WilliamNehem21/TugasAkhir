we do not allow var to occur in the scope of other control statements. assignments are atomic. parameters are passed by value. a mutual recursion statement can trigger an infinite computation. components are passive. the active part of a program is just a piece of code, typically a collection of concurrently running interleaved threads. the syntax of control statements deliberately makes tail-recursion the only expressible form of repetitive behaviour. we give no details on the type system and tacitly assume an appropriately many-sorted system of dc.



which express that computation time is negligible, a process can never be both running and terminated, and, once terminated, is never re-activated. a dedicated pair of state variables r and w describes the status of each thread. n marks negligible time for all threads. the formulas



mean that the variables from v preserve their values. kr(v) additionally means that the thread is active throughout the reference interval. the clauses below define[[.]]v, where v is the set of program variables which are in the scope in the given code.



for all k can be derived in pitl and, by the definition of, limk ak= fc(t). taking this limit briefly takes us outside pitl. the part of the derivation within pitl is a formalisation of a standard calculation. let



