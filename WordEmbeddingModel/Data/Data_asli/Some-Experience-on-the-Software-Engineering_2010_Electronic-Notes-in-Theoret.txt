internally, expressions are represented with normalized bdds/mtbdds. compared to apron, bddapron do not need any more the notion of constraints, which are replaced by general boolean expressions. last, the operations supported by bddapron are exactly the same as those supported by apron.



(ii) it also enables without effort an efficient memory management(abstract values are not stored in a global graph, but in local variables of recursive procedures, so a garbage collector can free them automatically). however it presents also strong drawbacks. it combines our front-end and solver components and it is inherently less modular in this respect. handling gotos(especially backward goto) is complicated, and more generally it is not suited to the unstructured systems handled by nbac(because of partitioning) or concurinterproc(because of the interleaving of threads). combining forward and backward analyses is also made difficult.



our experience is that in the modular architecture we promote for static analyzers the most modular component is the fixpoint solver component, followed by the abstract domain component, whereas modularity does not really make sense for the front-end part of the analyzer. the good practice is to try to push as much things as possible into the two first components to minimize the duplication of similar code in the front-end of analyzers. designing and implementing such modular components is demanding in term of efforts, but we think it definitively worth it. in the case of abstract domains, it enables effortless comparisons between them, as shown by the interproc analyzer which was implemented to illustrate the apron library and which has been exploited since by several research papers.



the risk of a modular design is the increased complexity of the apis. we think that we avoided successfully this risk for the fixpoint solver, which has been used by several external users(for instance). concerning apron, the flexibility of the coefficient and linear expression sub-language for instance induces some burden for the user. about this issue, we point out that the use of a high-level language featuring higher-order functions and polymorphic typing(namely ocaml) was greatly responsible for the quality of the api.



the most mature work related to ours is the pag tool, which makes different architectural choices compared to us. first, it integrates our solver, abstract domain and part of front-end components in a single package. second, it provides a specialized specification language for defining abstract domain datatypes and transfer functions.



