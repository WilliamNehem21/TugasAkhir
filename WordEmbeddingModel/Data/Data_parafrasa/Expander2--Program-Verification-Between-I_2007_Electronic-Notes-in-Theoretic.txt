The system's computations and proofs are accurate in accordance with the semantics of swinging types, which are functional-logic specifications comprising a many-sorted signature and a set of (generalized) horn or co-horn axioms. These axioms define relation symbols as least or greatest fixpoints and function symbols in accordance with the initial or final model induced by the specification.

While many conjectures can be proven comprehensibly and efficiently without human intervention, proofs of program correctness often do not fall into this category, particularly when involving induction or coinduction and requiring the original conjecture to be generalized in a specific manner.

The expander2's simplifier performs certain normalizations that align with natural deduction but differ from classical normalizations in some aspects. For example, the simplifier eliminates negation symbols by moving them to literal positions and then removes them completely by transforming negated (co)predicates into their complements. Section 3 outlines the syntax of the axioms and theorems handled by expander2 and describes how they are applied to terms or formulas to build up proofs. Section 4 details how axiom applications are combined to narrowing or rewriting steps, while Section 5 delves into the logical details of the simplifier and lists the simplification rules for formulas.

Moreover, Section 6 provides induction, coinduction, and other rules offered by expander2 at the top level of interaction. The correctness of the rules presented in Sections 4, 5, and 6 follows from corresponding soundness results given in prior works. The final section focuses on future work.

Each application of a clause to a redex begins with the search for a most general unifier of the redex and the anchor of the clause. If the unification is successful and the unifier satisfies the guard, then the redex is replaced by the reduct.

Additionally, guarded axioms are necessary for efficiently evaluating ground formulas, whereas unguarded axioms or theorems used as lemmas in proofs should be unguarded to avoid blocking the proof process.

A derivation is considered correct if the derived disjunction/conjunction or sum of the current trees implies or is a possible result of the original one. Expander2 checks the correctness of each derivation step and delivers a warning if necessary.

The narrowing procedure of expander2 applies axioms and simplification rules repeatedly from top to bottom and from left to right, providing case distinctions within a proof. Narrowing and fixpoint (co)induction complement each other with respect to the direction axioms are combined with conjectures, serving both as computation and proof rules in different scenarios.

In addition, the paper discusses translating functional or relational programs from languages such as Haskell, Maude, Prolog, or Curry into simplification rules and combining programming language constructs with the algebraic-logic semantics of expander2 specifications.