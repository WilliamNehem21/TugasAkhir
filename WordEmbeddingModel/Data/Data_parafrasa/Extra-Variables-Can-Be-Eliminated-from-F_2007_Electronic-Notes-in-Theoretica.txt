The remaining sections of the paper are structured as follows: We present introductory ideas and discussions in the next section, with the core of the paper in section 3, providing a precise description of our method and the results of soundness and completeness within the formal setting of a well-known semantic framework for functional logic programming. Section 4 addresses practical issues and provides experimental results, while section 5 summarizes conclusions, discusses limitations, and outlines possible future work. Additional details, particularly concerning practical issues, can be found throughout the paper.

Creating the modified program p' without introducing extra variables is straightforward: we substitute extra variables with a non-deterministic constant, represented by the 0-ary function gennat, which takes on values from the set of all natural numbers. The resulting program p' incorporates the definition of the gennat function.

While our primary focus in this paper is theoretical, in this section we briefly address practical issues related to the use of grounding generators and present the outcomes of a small set of experiments. This section is not formal; instead, explanations are provided through examples. Although we use toy as the reference language, the majority, if not all, of the discussions are also applicable to curry.

To develop complete generators that are compatible with depth-first search, we can adopt an iterative deepening approach, progressing through levels of increasing complexity, ensuring each level is finite and that the union of all levels covers the entire universe of data values for the given type.

We have introduced a method for eliminating extra variables in functional logic programs, that is, variables appearing in the right-hand sides but not the left-hand sides of rules for function definitions. Thus, extra variables are theoretically unnecessary in our context. In comparison to logic programs or more restricted classes of rewrite systems, the task is facilitated in our setting by the option to construct non-confluent programs offered by languages such as curry.

We have become aware of another independent work proposed concurrently, presenting a program transformation similar to ours for eliminating extra variables in functional logic programs. However, there are several distinctions to be noted. One difference is the absence of any indication of practical results.

The primary distinction lies in the formal framework employed in each work: ours proves the completeness of the transformation relative to ordinary rewriting, while soundness is demonstrated for a variation of rewriting that considers explicit substitutions to reflect call-time choice. Otherwise, the transformation is unsound, as noted in section 2. We find this change in the formal setting somewhat unsatisfactory since completeness is not truly established for call-time choice, which can yield fewer results than ordinary rewriting (run-time choice). Additionally, we believe that using the specific formal framework allows for a simpler proof.