The concept of strong strategies introduces a subtler question regarding the encoding of theorem 3.2, which provides a linear simulation of Turing machines (TM) for every strong strategy while reducing weak redexes or weak head redexes before any strong one. An example of the former is strong call-by-value, which is typically achieved by iterating weak call-by-value under abstractions, while an example of the latter is leftmost-outermost evaluation.

An interesting case study is the maximal strategy, which is a perpetual strategy that diverges whenever possible and, when it terminates, takes the maximum number of steps to reach the normal form. This strategy is highly inefficient and does not seem to be reasonable because it does not allow for the simulation of Turing machines.

In an open setting with open terms, reasonable implementations must avoid the substitution of neutral terms (i.e., uselessness of the first kind) but can substitute abstractions whenever. It is important to note that in the open size exploding family (as described in proposition 4.2), the explosion is caused by the duplication of neutral terms.

Similarly, in a strong dialect, reasonable implementations of strong evaluation must also avoid useless replacements of the second kind, with an optimization sometimes referred to as "substituting abstractions on-demand." It is crucial to consider the key restriction for avoiding substitutions on x under abstractions as detailed on page 10.

The research on establishing the reasonableness of strong call-by-value and call-by-need strategies is an active topic. The tools to handle strong call-by-value have primarily been developed in [9,12], and it is anticipated that they can be adapted to strong call-by-need, given that the operational semantics of the latter is currently being formalized. While the subterm property still holds, as well as the schema for proving the reasonableness of these strategies, the challenge lies in handling the technical details of implementing strong evaluation and useful sharing for call-by-value/need.

The iterated subterm property offers the capability to chain substitutions of subterms of the initial term into subterms of the initial term, leading to size explosion and an exponential gap between the number of steps and the size of the duplicated objects. In contrast, the plain subterm property helps to avoid this issue.