This research paper introduces a term rewriting based library designed to manipulate Java bytecode. The authors define a mapping from bytecode programs to algebraic terms and leverage TOM, an extension of Java that incorporates pattern-matching capabilities, for describing transformations. TOM, uniquely, offers a potent strategy language to articulate tree traversals and govern the application of transformation rules. Additionally, the authors employ CTL formulae as conditions and demonstrate how their satisfiability can be ensured using the strategy formalism. Through small-scale examples, they showcase how bytecode analysis and transformations can be elegantly defined. Notably, they outline the implementation of a classloader parameterized by a security policy that restricts file access.

While existing libraries, such as SERP, BCEL, and ASM, are potent, effectively utilizing them may necessitate a deep understanding of the API. The paper proposes introducing an abstraction level based on terms and rewriting to simplify the definition of high-level transformations and analysis. This approach, by delineating concerns between rules and strategies, introduces well-founded constructs, enabling reasoning about transformations and enhancing reusability and expressiveness. The authors also emphasize the significance of the term data structure, leading to the development of GOM, a generator of typed tree structures efficacious in time and space.

The paper elucidates the representation of bytecode programs through an algebraic signature, enabling the representation of any bytecode program by a typed term. They utilize ASM to read the content of a Java class and construct an algebraic representation of the complete Java class, much akin to BCEL. The authors describe a multitude of constructors within the given signature that represent various components of a Java class.

The paper highlights the originality of the TOM system, particularly its language and data-structure independence, attributing to its compilation process, which translates matching constructs into the native language. It further delves into the use of CTL formulae to represent invariants and fatalities in the code, and explores the combination of classical strategy operators to obtain temporal strategy aliases.

The authors also discuss the simulation of control flow using strategies during the traversal of the list of instructions, thereby obviating the need for explicit construction of a control flow graph and mitigating the memory overhead.

Moreover, the paper presents an application of bytecode rewriting for secure class loading by redirecting method invocations to new targets, particularly enforcing the use of a safe API for file access. It introduces the concept of defensive class loading as opposed to defensive virtual machine, and demonstrates its implementation through bytecode rewriting to ensure that only secured classes are loaded in the JVM.

In summary, the paper provides a comprehensive account of a library for bytecode transformations through strategic rewriting and illustrates its applications, spanning from control flow graph examination to secure class loading. Their approach not only simplifies the definition of transformations but also enhances code confidence by bridging the gap between transformation description and implementation.