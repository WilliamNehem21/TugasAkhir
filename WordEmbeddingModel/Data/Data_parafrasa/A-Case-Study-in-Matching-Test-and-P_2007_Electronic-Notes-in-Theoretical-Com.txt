This study investigates the synergistic nature of test and deductive proof methods for Java programs specified in JML (Java Modeling Language). The proof process for a program can be arduous and complex, especially when automated provers are unable to reach a conclusion. When a theorem cannot be automatically proven, there are two possibilities: either the theorem is correct and there is insufficient information to facilitate the proof, or the theorem is incorrect. To distinguish between these alternatives, testing techniques are employed. The paper presents experiments using the Jack tool to verify Java programs annotated with JML assertions. When Jack is unable to resolve proof obligations, the combinatorial testing tool Tobias is employed to create extensive test suites that exercise the unproven parts of the program. A key challenge is to ascertain the relevance of the test suite in relation to the unproved proof obligations. To address this, code coverage techniques are used, leveraging the statement orientation of the Jack tool to compare the statements associated with the unproven proof obligations and those covered by the test suite. Additionally, the confidence in the test suites is ensured by evaluating them on mutant program killing exercises. These techniques are implemented and illustrated through a simple case study.

The paper proposes three methods to modify the system: init, which resets all buffers to zero; add(x), which increases the total number of system elements by x (where x > 0) by adding x elements to the buffers distributed in b1, b2, and b3; and remove(x), which decreases the total number of system elements by x (where x > 0) by removing x elements from the buffers.

The Jack tool, part of the Java Applet Correctness Kit, provides a framework for verifying Java and JavaCard programs annotated with JML. Jack's primary objective is to prove properties of a given Java class expressed as JML assertions, using an automated weakest precondition calculus to generate proof obligations from annotated Java sources.

The paper describes the outcome of various checks during testing, including pass, fail, and inconclusive verdicts based on the behavior of the operation in relation to its specification. It also explains the process of combinatorial testing, code coverage, mutation analysis, and the importance of a final proof activity to ensure program correctness.

The authors share findings from a real-world case study involving a Java application comprising 500 lines of code distributed across 8 classes. They applied testing schemas to the classes and presented the results of mutation analysis, identifying classes for which the testing schemas were not sufficiently relevant, and the need for more insightful test schemas. 

Finally, the paper discusses the significance of using path coverage instead of statement coverage in the context of JACK, the automatic nature of the testing process, and the potential benefit of feeding assertions generated from tests back into the proof process.