In this paper, we introduce a variant of separation logic designed for modular reasoning about concurrent programs that involve dynamically allocated storable locks and dynamic thread creation. The program logic employs a Kripke model over a recursively defined set of worlds to model assertions, and its soundness is established through a Kripke relation to the standard operational semantics. This innovative approach addresses the issue of circularity that arises from lock resource invariants depending on worlds containing lock resource invariants.

Our program logic aims to enable modular reasoning about shared-variable concurrent imperative programs composed of dynamically allocated storable locks and dynamic thread creation. We follow the prior work in establishing a logic in which a lock is responsible for protecting a resource invariant, which is conceptually transferred between threads. The resource invariant moves with the lock itself, changing ownership through acquire and release operations. As the resource invariants associated with locks describe properties of heaps while locks are stored in the heap, resolving a form of circularity is crucial for developing a model that demonstrates the soundness of the logic. We propose an elegant solution to this circularity issue, showing soundness with respect to the standard operational semantics. Additionally, we illustrate our approach on a simple, yet illustrative language and provide an example of applying the resulting logic.

To maintain simplicity, the language does not support freeing of resources, including regular memory cells or locks. This design choice allows us to omit the system of fractional permissions found in previous works.

In order to express lock properties, we utilize two predicates: ex(e, p) and locked(e, p). The ex(e, p) predicate states that the interpretation of expression e points to a lock in the heap with resource invariant p, without making assumptions about whether the lock is available. The locked(e, p) predicate is similar, with an additional assertion that the current thread owns the lock.

We introduce a side condition (*) requiring that all occurrences of the predicate variable r in p are guarded, i.e., they only appear under a locked or ex predicate. This represents a departure from the conventional way that heap sharing has been handled in concurrent separation logic. Instead of having a general shared space, we include duplicate values of the shared memory cells in relevant private spaces, reflecting the locking variables' scope and enabling finer granularity, with locks known only to a limited number of threads.

We establish soundness for each proof rule separately, utilizing strong induction on the safety predicate index. The proofs primarily involve unfolding various definitions, considering all reduction steps that can be taken from the initial state, and proving the safety of the new state.

Finally, future work may involve extending the language with new features, such as storable procedures, and exploring opportunities for formalization and automated machine proving. This may entail leveraging existing work by Benton et al. in these areas.