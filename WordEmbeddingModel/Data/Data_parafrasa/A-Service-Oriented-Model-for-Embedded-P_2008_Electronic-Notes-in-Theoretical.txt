After introducing the syntax of the SMEPP primitives in Section 2, an abstract semantics for a simple calculus over these primitives is presented in Section 3. This semantics formallly establishes whether a set of processes, namely peer or service codes, can be executed together without locking, and it provides a solid foundation for developing tools for the analysis and verification of SMEPP specifications.

Peers must be uniquely identifiable, groups must provide a basic abstraction for service providing, and security must be bound to groups. Additionally, peers must be able to securely create, locate, and join groups. Provider peers must offer services in groups, and client peers must join the respective groups to be able to invoke the offered services. Services must be identified by contracts, which will include information to allow their discovery, adaptation, use, or composition with other services. The middleware must support asynchronous, synchronous, and event-based communication between peers and services.

Events are a loose method of communication among entities. For simplicity, events are modeled as operations, where raising an event is somewhat similar to invocating an operation, and waiting for an event is somewhat similar to waiting for an operation to be invoked. Modeling events as operations allows for the use of only one schema to define both asynchronous operations and events, as well as the use of only one primitive for the reception of messages modeling both operation invocations and events. Unlike operations, the entity that raises an event does not have to wait for another entity (an event subscriber) to receive it.

Peers use the 'joingroup' primitive to check whether the caller peer is allowed to join the group. If the call succeeds, the middleware adds the caller peer to the list of members of the specified group. A peer may join several groups, and joining the same group several times does not raise an exception. However, a mismatch between the credentials supplied by the peer wishing to join the group and the security level of the group raises an 'accessdenied' exception. Furthermore, calling 'joingroup' with an invalid group ID raises an 'invalidgroupid' exception.

Peers use the 'leavegroup' primitive to exit a group identified by group ID. When a peer leaves a group, the peer will be removed from the list of members of the group, and all the services published by the peer in the group will be removed as well. Peers can stop offering services in a group by 'unpublishing' them from the respective group. Calls to 'getservices' allow for matching published services, with the output consisting of a list of triples: services identified by service contracts, which are published in specified groups, and have corresponding identifiers. 

An 'event' is somewhat similar to an asynchronous invoke... (text too long, truncating)

In conclusion, the abstract semantics presented in this paper provide a foundation for constructing a verification environment to analyze properties like lock freedom and correct termination in p2p systems. While the model was developed with embedded systems in mind, it can also be applied to specify general peer-to-peer systems. Future work will involve exploring the expressiveness of the model by specifying real and more complex case studies, extending the model with more complex compositional structures, and developing a verification tool based on the rules presented in this paper. Additionally, the model will be deployed for devices with varying computing capabilities, ranging from laptops to smart phones, to address the embeddedness at the software architecture and implementation levels.