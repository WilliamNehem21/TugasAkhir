This paper introduces the concept of "conditions" as a graphical formalism for specifying valid objects and morphisms, which are used to describe system or program states and specify matches for transformation rules. The formalism provides an intuitive way to represent structural properties and is well-suited for reasoning about the behavior of transformation systems.

The paper presents an algorithm for conditions over a class of replacement-capable categories. Instead of exhaustively enumerating all possible objects of a category, the algorithm uses the input condition in a constructive manner. It starts from an initial object, such as an empty graph, and adds elements of positive statements as needed while checking for the absence of forbidden patterns. The resulting algorithm is monotone (non-deleting) and progresses non-deterministically towards a satisfiable object. Specifically, for each condition, the paper generates a program called "seeksat," which operates on morphisms of the considered category to facilitate information transfer between computation steps.

The paper is structured as follows: Section 2 reviews the definitions of conditions and introduces programs over rules with external interfaces for high-level structures such as graphs. Section 3 presents the satisfiability algorithm, demonstrates its correctness and completeness, and proves its termination for a fragment of conditions, thereby establishing its capability to decide. Section 4 discusses practical aspects related to implementation and optimization, while Section 5 relates the results to other work. Finally, Section 6 presents a conclusion and outlines directions for further research. Further details and detailed proofs can be found in the extended version of the paper.

The paper tackles the satisfiability problem of conditions within the framework of weak adhesive higher-level and replacement-capable categories. External interfaces, akin to input/output types, are introduced to control the location of rule applications. An external interface object i corresponds to standard transformation rules, and to concatenate rule applications, an external interface object x must match the right-hand side of the preceding rule. The paper also considers the concept of partial morphisms as inputs for programs over rules with external interfaces.

The paper acknowledges the undecidability of the satisfiability problem of graph conditions and high-level conditions in general and aims to provide a correct and complete algorithm, which may not always terminate. Seeking to answer "yes" as soon as a result is found, "no" if it terminates without results, and otherwise remaining undecided in the case of non-termination.

In contrast to existing approaches, "seeksat" does not involve a translation process. Instead, it is based on a tree search where internal nodes correspond to partial solutions (morphisms), branches represent choices (partitioning the search space), and leaf nodes are either complete results or dead ends. While the paper recognizes the algorithm's limited termination guarantees, it is discussed that "seeksat" can be made aware of the propositional structure of a condition to exclude entire branches of the search tree without sacrificing results, thus strengthening its relation to enumeration algorithms like the DPLL algorithm.