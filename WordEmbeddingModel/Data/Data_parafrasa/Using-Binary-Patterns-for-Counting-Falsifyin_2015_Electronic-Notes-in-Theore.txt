The use of binary patterns to represent the set of falsifying assignments of clauses has proven to be advantageous in developing algorithms for solving the problem of counting the number of falsifying assignments of conjunctive forms (denoted as #fal). This study introduces a deterministic algorithm for computing #fal for a conjunctive form formula expressed by m clauses defined over n variables. The algorithm works by computing non-intersecting subsets of falsifying assignments of the formula until the entire space of falsifying assignments is covered. Additionally, the study establishes a relationship between #sat (the number of satisfying assignments) and #fal, where #sat(f) = 2^n - #fal(f), allowing results about #fal to be inferred from #sat. The time complexity of the proposed algorithm for computing #fal is determined by the number of clauses and variables in the formula.

The problem of counting models for a Boolean formula (#sat problem) can be applied to various tasks in approximate reasoning, such as estimating the degree of belief in propositional theories, generating explanations to propositional queries, repairing inconsistent databases, Bayesian inference, and truth maintenance systems. These problems stem from applications in artificial intelligence, including planning, expert systems, and approximate reasoning.

This paper addresses the combinatorial problems of computing the number of models (#sat) and falsifying assignments (#fal) for Boolean formulas in conjunctive form (cf). It is shown that both #sat and #fal are classical #P-complete problems, even for the restricted cases of monotone and horn formulas. The study also introduces the use of string patterns as a concise representation of the set of falsifying assignments of conjunctive formulas.

The approach used to solve #sat problems typically involves variants of the classical Davis and Putnam (D&P) method, designed to handle the satisfiability problem. However, many modern variants have exponential-time complexity. In some cases, #sat can be computed in polynomial time by considering the graph-topological structure of the constrained graph of the formula, and a threshold is identified that determines when #sat can be computed in polynomial time based on the number of models.

The paper presents an incremental method for computing #fal with respect to the set of clauses in the formula. It involves ordering the clauses of the formula and utilizing binary strings representing the falsifying assignments of a set of clauses. To accelerate the computation of #fal, the study reduces the cardinality of the set of clauses by applying reductions among clauses, such as the independent reduction rule and subsumed clause rule.

The organization of the paper is as follows: Section 2 introduces basic notation and definitions. Section 3 describes the binary pattern-based approach for 2-cf cases and extends the approach for cf cases. Section 4 provides the algorithm associated with the proposed method. Section 5 presents the conclusions of the work.

The study identifies hard cases for determining whether #sat(f) = k, particularly when k > p(n), depending on the number of clauses and variables in the instances of f. Reductions and manipulations of string patterns are used to represent and form the set of falsifying assignments of a conjunctive formula. The computation of excluded subsets of falsifying assignments of f is carried out until the entire space of falsifying assignments is covered, allowing results about #fal to be inferred dually from #sat. Various reductions are employed in the procedure, such as subsumed clauses and the independent reduction involving dependent clauses, to accelerate the computation of #fal.