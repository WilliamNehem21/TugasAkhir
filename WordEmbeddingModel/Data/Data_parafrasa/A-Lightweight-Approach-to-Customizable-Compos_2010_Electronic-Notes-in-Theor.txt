The previous method involved programmers writing code fragments (classes in Java-like languages) that are not self-contained and depend on other fragments. These dependencies can later be resolved by combining fragments using composition operators to achieve different behaviors. Inheritance (single and multiple), mixins, and traits all enable the combination of classes, thus defining a composition language as described.

The paper is structured as follows: Section 1 introduces the approach informally with examples, Section 2 formalizes a simple class composition language, and Section 3 outlines the paper's contributions and future work. The appendix provides the proof of soundness. This paper represents the full version.

To demonstrate the use of meta-programming for improved software composition, a language is introduced that allows for the composition of classes using operators. In this language, a class declaration associates a class expression with the declared class name. The simplest form of a class expression is the base class, comprising a set of field and method declarations.

The paper also examines the meta-level, focusing on the first class declaration in the program that is not annotated. This is checked to ensure that its right-hand side expression is well-typed. If the type check succeeds, the class declaration is annotated code; otherwise, an error is raised.

The paper categorizes metaprogramming approaches according to two properties: whether the meta-language coincides with the conventional language (the metacircular approach) and whether code generation occurs during compilation. It compares its work with other languages such as OpenJava, C++, D, meta-trait-java, and MorphJ, within these categories.

The paper also contrasts its approach with dynamically typed languages, emphasizing the specific nature of their approach compared to other languages that support meta-circular facilities, such as Java and Groovy.