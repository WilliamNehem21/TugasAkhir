Polarized strong categories have a close relationship with specific fibrations (over the opponent world). This perspective provides an alternative and compelling view of these settings, which we aim to explore. This section therefore aims to establish the connection to fibrations and also introduces r-sized sets, which will serve as a consistent example to illustrate the theory.
  
The x-strong categories of interest in this context have a more intricate structure: the player category is affine closed, with products and coproducts. This section outlines how this structure is defined for x-strong categories and presents the corresponding interpretation in terms of fibrations. Finally, the parallel structure in r-sized sets is also discussed.

One notable feature of the fixed point calculus in this setting is that inductive data (i.e., fixed point data) does not generally provide material from which one can construct more inductive data. This is due to the fact that inductive data does not typically organize itself into a polarized operator.

In initial settings, it is often the case that every object in the opponent world is actually a lifted player object. In such scenarios, the polarized operators are entirely determined by the player side. As a result, specifying these operators in the player world is frequently the crucial aspect.

Each constructor increases the size of its input by 1, making them maps in the player category. The map "cons" is the cotuple of these constructors, and therefore, it too is bounded by a size increase of 1. The inverse map does not increase size, and therefore lies in r-setconst, indicating that this object is a fixed point in r-setconst.

To bound the recursion principle conveniently, we utilize the transformation of proposition 5.1 and derive the size bounds from the fixed point form of the map. This process must then be evaluated to obtain the desired map.

These issues are currently being addressed in ongoing work. This document describes a complete programming language and type system to support the development of a ptime programming language called pola. It is a more complex system than the one described here, utilizing bunched logic for programs in the player world, featuring type inference, and supporting both inductive and coinductive data. Coinductive data has constant-time destruction, and thus, like the closed structure discussed in this document, is entirely in the player world. The inductive data is essentially as discussed here (though a slightly more powerful recursion principle is used).

One can easily program ptime Turing machines in this language, making it certainly ptime complete. Assuming the distributive law for products over coproducts is valid for all data, then qsat can be programmed (following the observation of Hofmann). Consequently, this language is also pspace complete. The arguments for soundness are based on structural induction: they first demonstrate that the language (with the distributive law) is pspace sound, and second, that if one drops the distributive law (for higher-order, coinductive, and universal types), the language is ptime sound (ptime completeness is not affected).