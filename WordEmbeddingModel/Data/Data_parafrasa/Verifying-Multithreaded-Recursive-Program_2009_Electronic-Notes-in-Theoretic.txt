(iii) The utilization of recursive procedures;
(iv) The utilization of fundamental components such as spawn that allow the dynamic generation of concurrent processes; and
(v) The synchronization between concurrent processes. Ramalingam demonstrated that when synchronization and procedure calls are considered, the reachability problem, even for a single control point, becomes undecidable for programs. Due to this undecidability, the analysis of software requires the identification of general semi-algorithms that are not guaranteed to terminate in general, but exhibit favorable behavior and terminate in the most practical cases [4, 18, 9].

We propose a category of rewriting systems that can be employed to simulate multithreaded recursive programs with integer variables. The concept involves using terms to represent integers (e.g., the term s(s(s)) denotes the integer 3) as well as the control structure of the program, and term rewriting systems to capture the dynamics of the program.

We implemented our methods in a tool prototype based on Maude, and applied our tool to various case studies. We obtained promising results, including the automatic detection of two bugs in two distinct versions of a Windows NT Bluetooth driver. These bugs had already been identified in Spade. The novelty of our approach compared to Spade is that it enables the explicit modeling of the integer variables of the program, whereas Spade required a pushdown stack to encode the variable values.

Related work: Abstract-interpretation methods have been utilized to address data across unbounded domains. More recently, automated predicate-abstraction techniques have been proposed to tackle this problem [3, 16, 8]. In contrast to predicate abstraction, where the exact value of the variables is abstracted, our modeling remains precise for integer variables, and we can use predicate abstraction to handle the other non-integer variables in the program.

Where i is in {1,..., k} and n is the control point of the program corresponding to this instruction. We assume that c â‰  0. (The other cases can be handled similarly). Let tc be the term in nat representing the value c (tc is the term s(s(s)) if c is 3). Intuitively, this assignment can be represented by the following rule:

Where x1,..., xk are term variables representing the values of the local variables a1,..., ak. However, to ensure that this rule can only be applied to the points n that are at the top of the stack and not elsewhere in the term, we need to represent it with these two rules:

This rule expresses that when the procedure p is called, its entry point ep is placed at the top of the stack and its local variables are all initially set to 0. When this procedure terminates, the control returns to point n2. There is a similar rule that corresponds to the case where x is empty, i.e., where n1 is the only control point in the stack.

The Bluetooth v1 is our model of the Bluetooth driver program used by Windows NT as provided in the source. The Bluetooth v2 is a corrected version of Bluetooth v1 proposed by the authors of the source. We were able to identify two bugs in these programs. Spade also detected these bugs, but the Spade model of these versions encodes the values of the integer variables in the stack of a pushdown system, whereas with our new model, the integer variables are explicitly and accurately represented. To the best of our knowledge, this is the first instance where the integer variables of these programs are explicitly modeled.