We propose a formal method for refining systems that takes into account the timing aspect of the system. This time-aware refinement method is an extension of the traditional refinement calculus of action systems and provides a solid mathematical foundation for the stepwise refinement of systems modeled using the time-spiced action systems formalism. During the refinement process from an abstract system to a more concrete one, a designer must demonstrate that both functional and temporal properties are satisfied.

Conventional action systems is a formal language for system description introduced by Back and Kurki-Suonio, based on an extended version of a guarded command language by Dijkstra. It is used for specifying and developing reactive systems with correctness preservation. Initially tailored for software system design, it has since been successfully applied to hardware system design, both synchronous and asynchronous.

We introduce a refinement-based development method for several specification languages. Some of these do not guarantee the correctness of a concrete model after multiple refinement steps, while others allow a stepwise development method, forming a chain of refinements. We briefly discuss three different refinement approaches, one of which shares similarities with our approachâ€”refining high-level timed MSC model into a design specification. While their approach resembles our trace refinement, we do not consider the refinement of time constraints, as in our target environment, VLSI systems, the system constraints are specified and not allowed to be relaxed. However, time constraints are permitted to be refined to meet the new, refined timed action system.

We identify three main sections within the system: interface, declarative, and iteration. The interface part declares variables visible outside the action system boundaries, while the declarative part introduces local variables, action definitions, and constraints. The iteration section, represented by the do-od loop of a timed action system, initializes both global and local variables and defines the reactive behavior of the system.

The delay of a timed action is determined by the predicate in the delay clause located in the declarative part. We introduce the two most commonly used delay predicates: deterministic and nondeterministic delay predicates, which are denoted by abbreviations and are defined by three operational segments: commence, end, and time.

Conventional action systems are designed in a stepwise manner within the refinement calculus framework to preserve the correctness of actions during the refinement procedure. We focus on applying the well-founded refinement calculus framework for timed actions, extending it from conventional actions.

The data refinement rule presented earlier will also be used for timed actions in the next section, where we introduce trace refinement of a timed action system. We do not introduce a data refinement rule for a timed action due to the modeling approach chosen in the previous section and the constraints.

In the trace refinement of a timed action system, we adopt the first five conditions from the trace refinement of a conventional action system, justified by the fact that timed action systems extend conventional action systems by introducing a delay that determines the time when the result is written onto write variables.

The maximum allowed operation time for the timed action M is d: q{M, d}. Although we decompose the action into two parts, the scope of the deadline remains unchanged. In calculating the delay for the composition, we use a specific delay calculation rule. To keep the constraints up-to-date, they are changed to meet the new action definitions. However, the scope of a constraint remains the same.