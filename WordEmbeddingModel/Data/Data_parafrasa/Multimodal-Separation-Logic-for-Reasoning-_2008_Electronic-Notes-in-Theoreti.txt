In the following section, we will outline the general structure of programming language semantics that we address. Subsequent sections will provide examples of various programming languages, with increasing complexity. The distinctive requirements of each language will be used to justify different aspects of our model. Our approach will adopt a somewhat informal style, focusing on the practical applications of the techniques.

We have chosen to analyze deterministic small-step operational semantics. These are relatively easy to construct for both low-level languages, such as assembly language, and higher-level languages. Operational semantics can correspond more closely to the intended meaning of low-level languages than axiomatic semantics, for example. Our focus on small-step semantics is motivated by our specific interest in languages with shared-memory concurrency. Using big-step operational semantics would make reasoning about potential interleavings difficult. Moreover, stipulating deterministic semantics provides convenience in reasoning; we can utilize simple induction over the number of steps taken rather than induction over all possible paths. Nondeterminism is accommodated within this framework by employing oracles to determinize, as discussed in section 7.

The final element of a traditional Kripke model is a binary relation on worlds, denoted as "r" and referred to as the accessibility relation. This relation is utilized to impart meaning to the modal operators of the logic. Accessibility relations in multimodal logics are of particular interest, as we will elaborate in section 4.

As mentioned in section 2, a standard Kripke semantics of modal logic comprises three components: a set of worlds, a forcing relation, and an accessibility relation. Although there is a well-established tradition in the literature of presenting Kripke semantics in this manner, such a presentation biases towards logics with a single modality (and possibly its negation dual). Our experience has shown that this approach is overly restrictive. Instead, we aim to accommodate a variety of modalities for diverse purposes.

It is important to note a subtle difference between this definition and our earlier attempted definition. In the definition of "listf," we have introduced a "later" operator, which renders the definition of "listf" contractive. This enables us to use the "fold_unfold" lemma to prove "list_unfold." In practical terms, the "later" would typically be integrated into the semantic definition of "pair," which is naturally contractive.

Safety or partial-correctness proofs in CSL naturally demonstrate that the program does not become stuck in this operational semantics. The resource invariants are assertions of the object logic, CSL, and are modelled as predicates on worlds. Consequently, these predicates not only indicate the addresses controlled by the lock, but also articulate the invariants upheld on the memory contents at those addresses at any time the lock is unlocked. While a thread holds the lock, it is not obligated to satisfy the invariant.

Now that we have a functional definition of resource maps, we can define joinability. Firstly, two resource maps must be of the same age to join. Additionally, it must be the case that the resources at each location join pairwise. Two resources join if they are compatible and their shares join. Regular value resources are always compatible, while two lock resources are compatible if their resource invariants are identical. Value and lock resources are incompatible. As before, we extend the concept of joinability.

Pratt's study involved relatively simple languages. For instance, in one of his early papers on the topic, Pratt examined the language generated by a basic assignment operation and the regular language operators (union, concatenation, and Kleene closure). In a subsequent paper, additional basic operations were introduced, but Kleene closure remained the sole method for generating iterative behavior. While the set of programs that can be generated by regular grammars is interesting, it does not align well with the languages commonly used by programmers.

Sadrzadeh developed a Coq encoding of a modal linear logic using the deep embedding approach. This logic lacks quantification, and all the modalities are assumed to be S4 (reflexive and transitive). Through her embedding, Sadrzadeh demonstrates proofs of classic puzzles in epistemic logic.

Our techniques have proven their effectiveness in a real-world application: the soundness proof for the operational semantics of concurrent cminor. This proof, comprising approximately 50,000 lines of Coq code, serves as a substantial software-engineering artifact. More significantly, the proof represents an impactful result concerning a realistic programming language. As we increasingly relied on modal techniques in this proof, it evolved from being infeasible to feasible, and subsequently became more concise and manageable. We anticipate that continued refinement of this proof through an enhanced and consistent integration of modal techniques will further simplify and modularize the proof, reducing its size and enhancing its elegance.