When the objective is achieved, the spread of unchanging characteristics is stopped, significantly lessening the burden of specification. In addition, the code becomes more adaptable, as a re-implementation of a method can be based on a different set of invariants without impacting users. Moreover, invariants enable the specification of data consistency properties and behavioral properties as separate concerns, making the communication of such properties much simpler. Finally, they facilitate the specification of a class in terms of an abstraction of its data.

Execution of a program verified as correct using the conventional technique meets the conditions of theorem 2.1. In the conventional technique, only local invariants are permissible. A local invariant is an invariant that relies solely on the fields of the object it applies to (i.e., the predicate defining it contains only references of the form this.f).

We consider a specification to be feasible when there exists an implementation of this specification that can be verified. This section demonstrates that many natural object-oriented designs containing non-local invariants are infeasible due to the third condition of theorem 2.1. The specification construct 'inc' is proposed as a solution to this problem. It allows a method 'm' to specify that 'm' preserves, but does not rely on certain invariants of certain objects. It is also argued that many non-hierarchical designs are only feasible in a specification language that includes a construct like 'inc'. A hierarchy between two objects exists if, when a method 'm' is called on one, no method can be called (or field accessed) on the other until 'm' terminates.

The 'loanedto' of the book 'b' needs to be updated, which is not possible without a method call. The 'book' provides a method 'loanto' for this purpose. However, the invariant needs to be re-established before the method call that re-establishes it is allowed. Updating 'loanedto' before 'loaned' is similarly impossible. The root of the problem is that no single method can update all relevant fields when re-establishing an invariant.

The 'inc' construct, introduced in the previous work, offers flexibility at minimal cost. In this particular example, the specification of method 'loanto' includes 'inc: mi(m)', making explicit that the verification of 'loanto' does not rely on invariant 'mi' of parameter 'm'. This allows 'loanto' to be called by method 'loan' after the assignment to 'this.b'. Moreover, with every method 'm', an 'inc-set' is associated, which is specified by the 'inc' construct. According to the approach introduced, the 'inc-set' of a method 'm' is a set of elements (c, i, p), with 'c' being a class name, 'i' the name of an invariant specified in class 'c', and 'p' a predicate. The meaning is that for any object 'inc' of class 'c' such that 'p' holds when 'm' is called, 'i(inc)' is preserved, but not relied upon by method 'm'. The effectiveness of this approach is reflected in theorem 3.1.

An important concept in object-oriented verification that has been overlooked so far is that of information hiding, which is a fundamental object-oriented design principle. Design decisions that are irrelevant to a user should be concealed from that user through abstraction, enabling changes to be made without affecting the user. Given a mechanism that can hide an invariant from a class, most object-oriented designs are infeasible unless invariants are restricted. Due to the second premise of theorem 3.1, the verifier must prove, for an arbitrary hidden invariant 'i' of an arbitrary object of an arbitrary class, that 'i' (1) cannot be invalidated by the statement, or (2) is re-established before the end of 'm'.

Section 6 illustrates the intuition behind the 'coop' construct, which specifies which invariants can be invalidated by an assignment, allowing the verification of invariants even when their definition is hidden. Additionally, the adoption of a proof system that proves the correctness of statement annotations is proposed, complementing the presented proof technique.

The obligations presented in the proof system are independent of the rest of the proof system, assuming that every method body is fully and correctly annotated. The statement 'assign(r)' denotes an assignment to reference 'r', where the right-hand side is a reference or a primitive value. The method call 'mc(r, mc)' is a call to method 'mc' with reference 'r' as the receiver, and the call might be dynamically dispatched to a submethod. An edge 'e' is a tuple (n, n'), indicating that the program location 'n'' can be reached from program location 'n' in a single execution step.

These are some of the major points from the academic paper. Let me know if you need specific information or details!