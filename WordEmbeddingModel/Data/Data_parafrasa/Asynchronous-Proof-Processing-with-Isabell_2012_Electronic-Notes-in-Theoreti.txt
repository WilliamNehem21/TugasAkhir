Many proof assistants still rely on a traditional text-based user interface and operate in a synchronous mode, where the user interacts with the system through single commands that require immediate response. Efforts have been made to integrate proof assistants into larger integrated development environments (IDEs) while retaining the existing interaction model, but there is a question of whether a better approach is possible. The authors propose using the Scala language to connect Isabelle/ML to the external world due to its similarity to ML and ability to leverage Java libraries. By building interfaces for Isabelle in Scala, it becomes feasible to seamlessly integrate the prover into existing IDEs. The authors focus on experimenting with the jEdit editor framework, which can be extended with plugins written in Scala, leveraging the Scala actor library for parallel and interactive programming.

The authors discuss limitations of using Emacs as the environment for proof assistants and highlight the benefits of using jEdit as a powerful alternative editor framework, particularly for their experiments with integrating Isabelle.

The document operations are described as persistent and are intended to be updated using purely functional methods, with each version identified explicitly. The operation of editing a document involves inserting and removing commands, resulting in a new document version, with the prover reporting internal state changes subsequently. The asynchronous toplevel maintains multiple related document versions, and results from new document versions are reported incrementally in parallel with the evaluation process managed by the prover.

The authors emphasize the goal of building provers rather than re-implementing editors or IDEs from scratch, and hence prefer to link to existing frameworks, even though this requires accommodating the split into two different processes: ML vs. JVM. They acknowledge that explicit interprocess communication and the language differences between ML and Scala can introduce additional complexities.

The authors argue that dividing the system components across these process boundaries complicates the integration, and maintaining complex protocols is challenging. They discuss the ease of implementing jEdit plugins and the availability of interactive exploration and debugging tools for the platform.

They describe the process of input wiring, text edit handling, and the use of the Isabelle/Scala library to convert text edits into larger chunks based on the command structure of the proof language.

Additionally, they discuss the implementation of a dockable protocol that displays prover input and output messages and the use of a Scala sub-plugin for a read-eval-print loop in the console.

In addressing the cultural and technical challenges, the authors propose keeping ML as the implementation language for the prover and utilizing Scala on the JVM for GUI/IDE connectivity, emphasizing the capabilities of higher-order programming in Scala and the access to relevant frameworks implemented in Java, as well as the efficiency of Scala actors for parallel and interactive components.