The C++0x standard proposal 3 suggests incorporating axioms into the new concept construct. The purpose of concepts is to enable programmers to impose constraints on template parameters. For example, a generic sorting function may stipulate that its argument must be an indexable object with elements that can be compared using the less-than operator. Without concepts, programmers would have to rely on using the indexing and less-than operators without any enforced restrictions.

The remainder of this paper is structured as follows. We will begin by introducing axioms, followed by a discussion about their use for rewriting (section 3) and testing (section 4). Subsequently, we will outline some implementation considerations (section 5) and conclude with a discussion (section 6).

To allow any statement to be used within the axiom body, particularly for testing purposes (as described in section 4), the actual axiom can be identified using the assert keyword. Additionally, axioms can be declared outside of concepts, enabling simple axioms to be directly attached to a class without the need to declare concepts and concept maps for it.

Rules are applied to expressions, and if we desire to apply a rule to an entire program (i.e., all expressions within the program), we must employ a rewriting strategy, as discussed below. A rule may succeed if it matches and its condition is true, or it may fail. If it succeeds, the rewrite is executed and the process is complete. If it fails, we can attempt other rules if we are applying a group of rules until we find one that succeeds. A typical rewrite strategy would involve visiting all expressions in a program and applying rules repeatedly until no rules succeed.

It is expected that a rewrite system based on C++ axiom will be both nonconfluent (i.e., applying rules in a different order produces a different result) and non-terminating. However, rewrite strategies in conjunction with axiom groups provide a practical solution to this and enable careful control over rule application.

User-defined strategies offer detailed control over when and how various rewrites are applied, allowing for further optimization. Boyle demonstrated in the TAMPR system that such control was necessary to achieve many of the goals of program optimization from rewrite rules.

Axioms and strategy definitions are then extracted from the program tree. Axioms may be compiled to rules that apply at the concept level and, after applying concept maps, to rules at the class/user level. Testing code is generated following the application of concept maps.

Incorporating optimization rules within programs is not a new concept, as user-defined rules in Codeboost drew inspiration from the rewrite rules in the Glasgow Haskell Compiler. However, the Codeboost implementation was more sophisticated and supported both conditions and multiple strategies (through a simpler version of the axiom groups introduced in this paper). Conditional rewrite rules are well-known in transformation languages such as Stratego and Elan, as well as in term rewriting in general.