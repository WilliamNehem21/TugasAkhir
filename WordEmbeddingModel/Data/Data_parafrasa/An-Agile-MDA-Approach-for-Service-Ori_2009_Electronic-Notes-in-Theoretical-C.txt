Another important aspect of component models and frameworks pertains to the development approach. Approaches that prioritize modeling as a central part of the development process also streamline the construction of components. Well-known approaches that embody this principle are based on UML and MDA. 

UML 2 has become the standard for modeling software systems. However, in practice, UML models are often used as templates that are then filled in with code. Furthermore, contemporary agile development processes, such as agile model-driven development and test-driven development, tend to minimize the modeling phase and the utilization of UML models.

The MDA framework provides a method for specifying systems independently of a specific platform and for transforming the system specification into one for a particular platform. MDA is considered the OMG approach to model-driven engineering (MDE). MDE approaches can be based on either MDA or on domain-specific modeling. MDE emerged as a solution for applications that must contend with increased platform complexity and domain concepts. MDE aims to elevate the level of abstraction in program specification and increase automation in program development. The system can be developed based on models at different levels of abstractions, and then model transformations partially automate certain steps of program development. However, development processes based on MDA are not widely used today because they are seen as heavy-weight processes that cannot deliver partial implementations to be executed as soon as possible.

Concerning composite components, UML 2.0 offers two ways of modeling subcomponents: subcomponents as parts and subcomponents as nested elements. In the context of iComponent, composites use UML composite structures to indicate their internal structure. Subcomponents modeled as parts are shared components that can be referenced by many composite components.

In the execution environment, a global service registry is offered, where component instances publish their provided interfaces. Other component instances can automatically acquire references to these global services through their wrapper containers. However, in order to isolate the component instances and services of an application, the instances of a composite are not published globally by default.

The services model, typically defined by the system analyst, outlines the services that the system will provide. The modules that reference the services model may include any data type, such as classes, interfaces, or components. The interfaces contain the operations provided by the services.

The structural model, typically defined by the system architect, identifies the component instances that will implement the services. At this stage, the system is decomposed into a set of components, either simple or composite. Composite components enable the architect to decompose the system functionality in a hierarchical manner. Each composite component has an attached composite structure diagram, describing its internal structure using component parts (simple or composite) and connectors between ports, and specifying which components will be instantiated. The rules for constructing the diagram are as follows:

1. Add a test. Developers write the tests using either graphical or textual notations, both of which are compiled into the same UML repository model. During the construction process, the framework allows the use of inline expressions, represented and evaluated according to the pull model for actions.