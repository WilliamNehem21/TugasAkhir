The characteristics of a system may not be immediately apparent from a quick examination of the corresponding event-B model. To gain a better understanding, users typically depend on animation, scenario analysis, and inspection of state transition graphs to uncover specific system behaviors. In order to address this, we propose a methodology for creating a hierarchical representation of the system to visualize event-B models. Our visualization is concise and offers multiple viewpoints to facilitate a better comprehension of event-B models.

In event-B, the desired global properties of the system are expressed as invariants, and the proofs of invariant preservation ensure that these properties are upheld by the system following the execution of any enabled event. However, it is not straightforward to determine which events will be enabled or disabled next after the execution of an enabled event. Users generally rely on animation, scenario analysis, and inspection of state transition graphs to grasp the behavioral aspects of the system. The Prob Animator, assisted by a model checker, can create graphical visualizations of the state space of a B machine; however, due to the flat nature of the Prob state space representation, reducing the complexity of the state space graphs proves challenging even with the utilization of state space reduction techniques. In general, hierarchical state transition diagrams have been found to be advantageous in reducing the complexity of the state transition diagrams.

To represent a discrete event system, we employ a Hierarchical Abstract State Transition Machine (HASTM) representation, which incorporates the concepts of hierarchical states and guarded transitions similar to those in statechart diagrams. The state space in HASTM is organized in the form of a tree (referred to as a state space partition tree), with the root node of the tree representing all the valid states of the system, i.e., the states defined by the conjunction of all the invariants.

The HASTM representation applies to a specific event-B model in the event-B refinement chain. Each event-B model in the refinement chain will have its own separate HASTM representation. In this work, we do not establish a link between HASTM representations corresponding to abstract and concrete event-B models.

Initially, we define a primitive HASTM representation of an event-B machine, which is a straightforward HASTM with a single abstract state, denoted as I. Consider the event-B machine M described in section 2.2, and let R be the number of events in M.

The proof obligations for all the transitions in the primitive HASTM are the same as those of M. It is straightforward to verify that the primitive HASTM of M satisfies the conditions mentioned in section 2.2, and therefore represents M.

We then strengthen the post-state of the transition to Y'. With Y' as the new post-state, we repeat the above step until we fail to fulfill the proof obligation or we reach a basic abstract state. The algorithm for this process is provided in function strengthenpoststate in algorithm 1.

For a particular transition, the pre-state I, along with the transition guard (dooropen = t), does not imply (dirup = t) or (dirup = f). Therefore, this transition is not amenable to partitioning of I with predicate (dooropen = t). As outlined in step C, we have two choices: i) to not modify the transition, or ii) to split the transition into two new transitions. In this case, we opt for the latter choice and create two new transitions accordingly.

We begin with a primitive HASTM of M and then recursively partition the abstract state I. At each basic abstract state in the state space partition tree, a further partitioning predicate is selected to maximize the number of events amenable to partitioning with the selected predicate. This allows us to strengthen the pre-state of these events without an increase in the number of transitions in the generated HASTM.

While much work has been conducted on deriving formal B models from specifications in visual representations (largely UML), our approach takes the opposite direction. We begin with an existing event-B model and build multiple visual representations that concentrate on different behavioral aspects of the system.