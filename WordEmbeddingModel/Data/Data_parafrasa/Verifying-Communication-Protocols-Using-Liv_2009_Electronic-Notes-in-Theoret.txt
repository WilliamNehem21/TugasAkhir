The development environment for system-on-chip (SoC) designs is rapidly incorporating third-party intellectual property (IP) cores and blocks. The use of heterogeneous IP cores requires multiple communication protocols to achieve the desired interactions, behavior, and functionality. Verifying these systems, as well as the third-party modules and communication protocols, is crucial to ensure correctness and compliance with the system specification, particularly for vendors seeking to introduce their products to new markets and development environments. This paper addresses the challenges of verifying SoC designs and proposes a method that uses Live Sequence Charts (LSCs) as a specification language and automaton-based verification techniques. It also presents a case study of verifying Promela models against the specification for the Basic Virtual Component Interface (BVCI) protocol.

The paper is organized as follows: 
- Section 2 provides an overview of related work in the field of LSCs and verification using LSCs.
- Section 3 introduces LSC constructs and provides a detailed example of an LSC.
- Section 4 presents an overview and examples of the LSC to automaton translation method.
- Section 5 discusses a case study and presents results of verifying Promela models against the BVCI LSC specification.
- Section 6 contains the conclusions.

LSCs have been widely used to model and specify various systems such as air traffic control systems, radio-based communication systems, and train systems. They have proven effective in specifying and verifying complex system behaviors. Additionally, LSCs have been used to specify SoC communication protocols and for automatic synthesis of systems. Two primary methods for verifying systems against LSCs have been proposed. The first method involves translating the LSC specification to temporal logic properties and verifying these properties on the system. The second method involves converting the LSC to an automaton and using language containment-based verification techniques.

The paper also discusses the various components of LSCs, such as locations, messages, conditions, and coregions, and explains their roles in specifying system behaviors. Additionally, it introduces the concept of delayed choice semantics when dealing with subcharts, hierarchical charts, and cold constructs, to address non-determinism in the specification language.

The verification approach presented in the paper uses LSCs as the specification and verifies the system by detecting accepting cycles on the synchronous composition of the system automaton and the negative automaton of the LSC. The negative automaton is used to detect unwanted behaviors in the system. The paper further extends the translation of LSCs to cover the complete grammar of LSCs, including constructs such as kleene stars, subcharts, and hierarchical charts.

The translation of LSCs to automata is described, and the paper presents the case study of translating the BVCI protocol to an automaton and verifying systems against this specification. The results and experiences indicate the usefulness of LSCs as a specification language for formal verification and their applicability in the initial stages of protocol development.

Additionally, the paper includes a reference to related work on applying LSCs to the specification of an air traffic control system published in the proceedings of the 2nd International Workshop on Scenarios and State Machines, held at the 25th International Conference on Software Engineering in 2003.