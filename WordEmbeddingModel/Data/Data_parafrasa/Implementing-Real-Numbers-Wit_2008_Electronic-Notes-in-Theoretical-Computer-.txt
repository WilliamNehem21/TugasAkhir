The initial four declarations of commutativegroup concern the set s, the constant zero, the binary operation add, and the unary operation neg on s. The implicit type declaration states that unless otherwise specified, variables x, y, and z are assumed to belong to s. The definition keyword is used to define a binary operation sub, while the four axioms assert that s, zero, add, and neg together form a commutative group.

There are multiple approaches to characterizing or constructing real numbers, each resulting in isomorphic structures as ordered fields. However, the choice of representation and basic operations can significantly impact implementation efficiency. To achieve performance comparable to fast implementations of exact real arithmetic like irram[15,14], reallib[10,9], and mpfr, we sought a theoretical model closely corresponding to these under translation by rz. A useful starting point includes several observations regarding characteristics of irram, reallib, and mpfr.

Restarting entire computations from scratch when the initial precision is too low may seem wasteful. Prior implementations of exact reals propagated precision backwards through intermediate computations to ensure a final result with the desired precision. However, this often proved to be more costly due to overestimation of intermediate precisions, leading to excessive work.

The induction principle determining the ring of integers uniquely up to isomorphism arises from the fact that the nonnegative integers satisfy it. The remaining axiomatization of integers concerns quotients and powers of two, elements which are not strictly necessary but are useful for implementing dyadic rationals.

The theory of real numbers, as presented in appendix e, includes the theory orderedfield (see appendix a) to handle basic arithmetic and lattice operations such as min and max. The remaining axiomatization addresses the relationship between reals and the interval domain, continuity of arithmetic operations, completeness properties of reals, linear order, and the archimedean property. Each of these aspects is briefly discussed.

The reals are isomorphic to the space of maximal elements of the interval domain. Consequently, two maps to and from the interval are postulated, converting real numbers to maximal intervals and vice versa. In the implementation, the same datatype is used to represent both reals and intervals, so the conversions are simply identities. However, this approach could have been avoided if reals were defined to be the maximal intervals; the decision not to do so was made to maintain a clear distinction between the abstract characterization of reals and their representation as maximal intervals.

Although we hoped for, we did not expect the performance of era to rival that of other libraries such as irram. Initial measurements of basic arithmetic operations showed that irram is approximately 40 times faster than era. This significant difference can be partly attributed to the fact that C++ generally compiles to more efficient code than Objective CAML, as well as to the maturity and high optimization of irram as software. The performance gap is anticipated to narrow in the future as we discover methods to enhance the performance of era.

Rz bears similarities to various tools for formalizing mathematics, most notably the proof assistant Coq. Coq not only allows for axiomatizing theories but also for constructing models and formally proving their properties. While this approach has been successful in many respects, current code extraction methods yield only purely functional code, which does not compare favorably to efficiently hand-crafted code. The goal of rz was to provide programmers with a lightweight tool to connect theoretical models with implementations without necessitating writing proofs instead of programs.

Rz could be utilized to axiomatize theories and subsequently proceed with their implementation within Coq. In this context, rz constitutes a tool that automatically separates the computationally relevant and irrelevant components of a theory, an aspect typically done by hand in Coq. Another potential use case involves manually writing code and then using a proof assistant like Coq to verify that the code satisfies the rz specification.

The current era implementation is an initial prototype that is intended to be expanded and enhanced. The Objective CAML module system enables us to easily experiment with various libraries for big integers and interval arithmetic, while also integrating floating point computations with exact ones. These are all avenues we aim to explore.