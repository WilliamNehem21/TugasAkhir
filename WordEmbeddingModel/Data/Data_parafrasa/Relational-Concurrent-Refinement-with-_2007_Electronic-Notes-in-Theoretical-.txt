In a concurrent setting, refinement, as demonstrated in a process semantics, can take various forms, often depending on the concept of observation, i.e., which system events it is willing to accept or reject. Concurrency refinement relations include trace refinement, failures-divergences refinement, readiness refinement, and bisimulation.

Another perspective on this is found in a process algebra, where different process semantics give rise to distinct refinement relations. For example, in CSP, trace refinement, failures refinement, and failures-divergences refinement can be employed, while CCS typically uses bisimulation, and in LOTOS, reduction, extension, and conformance are defined. A comprehensive overview of prominent refinement relations is provided. These relations are often motivated by the description of an idealized machine used for system manipulation and behavior observation, leading to variations in concurrent refinement relations based on the machine's functionality.

To comprehend the nature and structure of refinement, as well as to integrate specification languages and their development methodologies, it is essential to grasp the connection between data and process refinements. Several works by different researchers have explored the relationship between these two paradigms. The paper summarizes existing research that links relational models of refinement to their process algebraic counterparts and introduces new findings related to incorporating the effects of internal operations into the relational model.

The paper is organized as follows. Section 2 presents key elements of the background material, referring to other sources for comprehensive details. Section 3 surveys existing work on relating refinement in relational and process semantics. Section 4 extends the blocking model to include internal operations, and Section 5 concludes the paper.

In contrast, a process algebraic description of a system represents traces of events, and there are various semantic models for CSP, each inducing its own refinement relation. In the blocking model, the effect of calling an operation outside its precondition is simply the inability to perform any events associated with that operation, reflecting the intended meaning of the blocking model. For ADTs with deterministic outputs (or no input/output), the corresponding process results in data refinement corresponding to singleton as opposed to failures-divergences refinement.

In the non-blocking model, as no operation is blocked, every trace is possible, leading to divergences arising from applying an operation outside its precondition. Additional restrictions (i.e., observations) on the standard definition of data refinement are necessary in both the non-blocking and blocking models to achieve failures-divergences refinement in process semantics, as illustrated via an example in the paper.

The results presented in the paper extend by considering the explicit presence of internal events in the blocking model. Future work in this area includes extending the results to the non-blocking model and fully considering input and output and their impact on the derived results. This will be the subject of an expanded version of the paper.