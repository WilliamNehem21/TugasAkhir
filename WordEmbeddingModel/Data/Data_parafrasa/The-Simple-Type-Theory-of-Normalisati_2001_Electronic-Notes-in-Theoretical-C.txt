The concept of normalisation by evaluation (NBE) was initially explored about ten years ago by Berger and Schwichtenberg. NBE is a technique that uses the meaning function (also known as the evaluation functional) of a language model to normalise terms of the language. In simple terms, NBE is a type-indexed function that takes a semantic object corresponding to a term as its argument and returns the long-normal form of that term at the given type. Despite all computation being carried out in the model, the result is a syntactic term rather than a semantic object in the traditional sense. As a result of this function, the model theory of NBE generally involves enhancing standard models with the relevant syntax, which is a highly non-trivial task.

Initially, the NBE algorithm was primarily motivated by practical considerations. The algorithm was developed to obtain syntactic representations of the internal proof objects of the Minlog proof system at LMU, Munich. Apart from the domain-theoretic correctness proof, the main focus of the algorithm was the utilization of the quote and unquote constructs of the programming language Scheme to provide a native (as opposed to interpretative) implementation of the algorithm for the simply-typed calculus. The intricate details of how such a native implementation operates in a more traditional programming language setting are provided in related work. Additionally, prior research has substantiated the utility of NBE for purposes of partial evaluation and, specifically, semantics-based compiling (i.e., automated compiler derivation).

It will be demonstrated that NBE has significant theoretical implications in a rewriting-based setting. Specifically, it will be shown that the algorithm computes long-normal forms using very limited computational powers, i.e., Plotkin-style-evaluation semantics, making it interesting from a practical, compiler-technology perspective as well. This will be achieved for call-by-name (CBN), call-by-value (CBV), and their combination, call-by-whatever (CBW). NBE will be used to refer to all three in conjunction. One level of NBE will assume the role of the model, while the other will assume the role of the target syntax. The syntactic level will evidently not be subjected to evaluation. The core of the NBE algorithm will be expressed as the canonical inter-level term coercers in NBE.

Although semantics-based approaches naturally use constructive models, it is believed that the current approach is superior in explaining the effective means by which the computation of NBE is performed, for example, via the NBE machine, which is hoped to facilitate more practical programming language applications of NBE.

In addition, the combination of "0 combined with ! behaves well for other typing paradigms, such as unit types and system F. Further considerations in categorical rewriting and algebraic rewriting have led to the restricted-expansion assuming a de facto status as the choice-relation for most typed purposes. However, the study of the rewriting properties of the restricted-relations is non-trivial.

This paper introduces a two-level NBE-calculi aiming to capture the type theory of the NBE algorithm under different evaluation paradigms. Some of the design techniques employed can be used to define a more general notion of two-level calculi, although the focus here is quite narrow on NBE.

Lastly, additional considerations on the correct way of selecting fresh variable names for reify and reflect are provided, along with examples using the implementation of the NBE machine. The output code is available from the authors' homepage, and the paper also references an extended version available as a technical report.