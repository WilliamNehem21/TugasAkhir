Over the past two decades, significant progress has been made in developing techniques and tools for testing and ensuring the reliability of complex software. A notable investment in formal methods has led to the creation of powerful languages, algorithms, methodologies, and tools that can be effectively applied to software models. Today, it is possible to extend these methods to real programs in a transparent manner by integrating verification functionality within the compiler.

This optimistic outlook is primarily due to advancements in two major techniques: static program analysis and model checking. Static analysis involves conducting a static (abstract) execution of a program to extract accurate information about its behavior during execution. This information is utilized to identify and discard programming errors early on and improve program compilation. On the other hand, model checking is a technique that involves exhaustively examining the states produced by concurrent programs to verify the satisfiability of desired program behavior. Our work leverages model checking as a method for implementing static analysis, which can be seamlessly integrated with compilers.

As an example, the intended result for the live variable analysis shows which variables (e.g., x or y) are live at different points in the program. For instance, variable y is not live at the first two lines of the program because its value is updated before being read.

Another aspect of our work involves demonstrating the specification capability of the BES (Boolean Equation System) by encoding classical deterministic finite automata (DFAs). These DFAs are effectively implemented using a generic algorithm, which evaluates different BES encodings over a given program described as an implicit labeled transition system (LTS). The algorithm has been integrated into the widely known CADP toolbox, and experiments have confirmed its efficiency in realistic examples.

In addition, our work involves storing the program counter as an element of a specified set and labeling program instructions as boolean expressions, assignment expressions, or system calls to an API of interest. This information is valuable for certain static analyses, such as influence analysis, and enables both property verifications and program optimizations. Furthermore, this format facilitates the automatic and incremental construction of the resulting LTS based on a program's control flow graph.

We also address the efficiency of our analysis algorithm, demonstrating that every transition in the LTS is traversed exactly once per program variable or expression. We assume that BES resolutions are linear in the size of the LTS, and the resolution of already solved boolean variables is done in constant time.

We conducted several experiments to compare the results of our DFAs with those found in the literature, as well as to assess the effectiveness of influence analysis. Additionally, we considered specific C program examples and Promela examples, demonstrating the applicability of our tool to different specification languages.

To illustrate the applicability of our tool to a third specification language, we utilized a LOTOS description of the Dekker mutual exclusion protocol. By testing nine currently implemented DFAs, we showed that none of the nine variables present in the specification were live at all states, indicating that program verification can ignore many variables without losing relevant information.

In conclusion, our work demonstrates the potential for integrating static analysis resulting from the interconnection of annotator and C.open into CADP to the model extractor socketmc. Additionally, we aim to explore translating other static analysis problems, such as reset variables analysis, into BES resolution and integrating them effectively with existing compilers.