In this paper, we introduce a method for representing software architecture in a modular manner that focuses on component failure properties rather than on expected correct behavior. We argue that it is more feasible for an engineer to manually analyze the failure behavior of individual components than to analyze the entire system. We propose recording the failure behavior of components in a fully compositional manner to enable the automatic determination of the failure behavior of the entire system. To this end, we outline a semantics of failure propagation and transformation called Failure Propagation and Transformation Calculus (FPTC). We suggest that automatic analysis has the potential to significantly reduce the cost of change, as the failure behavior of the whole system can be calculated from the composition of its parts, allowing for the prediction of the impact of component or architectural changes at low cost.

While our focus in this paper is mainly on software, we believe that the techniques presented may be adaptable to complete engineering systems, including physical hardware, electrical and hydraulic components, and other domains. We also acknowledge that our emphasis on failure properties does not cover the full range of safety concerns, but it does provide valuable evidence for constructing safety arguments.

We acknowledge the presence of other types of failure dependencies between components, such as the allocation of schedulable software units to CPUs, which should be integrated into the representation. We view failure propagation as a common behavior of software components in the absence of further design work, and highlight the importance of explicitly noting components that can detect and correct failures, as this is an unusual occurrence.

We prefer a rule based on generality/specificity concerning the inclusion of overlapping patterns, as it reduces syntactic clutter and improves readability. Despite the additional semantic complexity, experience with established programming languages such as ML and Haskell demonstrates that the inclusion of overlapping patterns is beneficial for identifying potential problems before code is written, when they are less costly to fix.

We conducted a detailed implementation involving the injection of individual failure modes to potential sources of errors, and performed automated analysis to determine how errors flowed through the network. We envision that our work can simplify re-analysis and reduce the cost of safety recertification in high-integrity software.

We also identified two key deficiencies in Failure Propagation Token Network (FPTN) compared to the Failure Propagation and Transformation Calculus (FPTC). We demonstrated the utility of FPTC analysis at early stages of a project and highlighted its potential value in incremental safety certification and product-line families. Our future goals include extending the FPTC framework to address quality of service issues, such as assessing the impact of changes and detecting possible single points of failure in complex designs.