since the natural semantics defines the finite behaviors but not the diverging behaviors, an interpretation of the big-step evaluation rules as horn clauses implemented in prolog[2,9] will have its diverging behaviors determined by the implementation(e.g. prolog interpreter with left-to-right evaluation).



we introduce an original big-step trace semantics that gives operational meaning to both convergent and divergent behaviors of programs. the compositional structural definition mixes induction for finite behaviors and co-induction for infinite behaviors while avoiding duplication of rules between the two cases. this big-step trace semantics excludes erroneous behaviors that go wrong. the other semantics are then systematically derived by abstraction.



the big-step trace semantics is first abstracted to a relational semantics and then to the standard big-step or natural semantics. these abstraction are sound and complete in that the big-step trace and relational semantics describe the same converging or diverging behaviors while the big-step trace and natural semantics describe the same finite behaviors. the big-step trace semantics is then abstracted into a small-step semantics, by collecting transitions along traces. this abstraction is sound but incomplete in that the traces generated by the small-step semantics describes convergent, divergent, but also erroneous behaviors of programs. this shows that trace-based operational semantics can be much more informative that small-step operational semantics.



we introduce a maximal trace semantics describing terminating and diverging computations. the trace semantics is then abstracted into a relational and then an operational semantics. each semantics can be defined using small steps or big steps of computation. each semantics can be defined in fixpoint or rule-based form.



