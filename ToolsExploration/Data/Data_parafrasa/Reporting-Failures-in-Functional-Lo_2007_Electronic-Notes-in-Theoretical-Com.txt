Functional logic languages combine important aspects of functional and logic programming to offer a wide range of programming concepts. For example, they incorporate features such as demand-driven evaluation, higher-order functions, and polymorphic typing from functional programming, as well as logic programming features like working with partial information (logic variables), solving constraints, and searching for nondeterministic solutions. This fusion, along with effective evaluation strategies and new design patterns, results in improved abstractions in application programs, including the implementation of graphical user interfaces and dynamic web pages [21, 23].

Functional logic programs, such as Curry or Toy, commonly contain components that are evaluated deterministically as well as other parts where solution search is involved. These parts are at times combined by encapsulating the search process, allowing the results to be processed in a deterministic portion of the program. Consequently, working with failure is a standard programming technique in nondeterministic computations, and encountering a failure in deterministic parts is usually considered a programming error [10, 27].

One approach to implementing functional logic languages is to transform them into Prolog programs to take advantage of the available implementation technology. Various strategies exist for implementing functional logic languages with demand-driven evaluation in Prolog [2, 4, 14, 18, 29, 30]. Given that modern functional logic languages are built on non-strict lazy evaluation of functions, the main challenge for Prolog-based implementations lies in efficiently achieving this behavior. A common idea in such implementations is to translate source operations into predicates that compute only the head normal form of a call to the operation, among other strategies [2.1, 1].

One novel aspect in functional logic programming is the use of the "fail" constructor to transmit information about failing computations. This new value must be considered in all pattern matchings, and the pattern matching predicates need to be extended with a "fail" clause. However, this extension does not have a negative impact on the execution of these predicates and is essential for supporting separate compilation [2.1, 1].

Overall, the implementation scheme only incurs a minor overhead in the absence of failing computations and exhibits substantially different behavior from standard execution only in the event of a failure [2.1, 1]. Furthermore, applying specific search operators can control nondeterministic behavior in I/O operations, and encapsulated search disables failure reporting, although it can be activated during top-level execution if needed [2.1, 1].

In the future, it will be important to explore methods for generating more structural information in the case of errors, as the current call stack structure may not be optimal for presentation to the programmer [2.1, 1]. Additional practical experience is necessary to refine appropriate presentation structures.
