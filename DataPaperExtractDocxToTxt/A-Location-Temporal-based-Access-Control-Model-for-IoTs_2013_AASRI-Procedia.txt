Available online at www.sciencedirect.com
ScienceDirect

AASRI Procedia 5 (2013) 15 – 20


2013 AASRI Conference on Parallel and Distributed Computing and Systems
A Location Temporal Based Access Control Model for IoTs
Chao Leea,b,*, Yunchuan Guoa, Lihua Yina
aInstitute of Information Engineering, Chinese Academy of Science, Beijing,100185,China
bGraduate University of Chinese Academy of Science, Beijing,100049,China




Abstract

Internet of things (IoTs) is a hot topic in recent years, and its various applications have been applied in several fields. The essence of IoTs is to connect all the things including the devices embedded RFID, sensors, etc. together, to help people utilizing the information from the things to improve their life. The things are always located at different places at different times, and the information of the thing may have different access right at different location during different time. Therefore, the access control mechanism in IoTs should consider location and temporary constraints in order to enhance the security of an application. In this paper, we propose a model that combines location and time with security level to control access to the information within the sensing layer of the IoTs. This model is called Location-Temporal Access Control Model(LTAC). The main principle of LTAC is its use of a lattice approach to decrease the size of policy bases. We show that how the different components in the model are related with location and how this location information can be used to determine whether a subject has access to a given object.

© 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and/or peer review under responsibility of American Applied Science Research Institute

Keywords: Access Control; Internet of Things; Location; Temporal; Information policy








* Corresponding author.
E-mail address:lichao@nelmail.iie.ac.cn









2212-6716 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license. Selection and/or peer review under responsibility of American Applied Science Research Institute doi:10.1016/j.aasri.2013.10.053


Introduction

Internet of things (IoTs) is a hot topic in recent years, and its various applications have been applied in several fields[1] . The essence of IoTs is to connect all the things including the devices embedded RFID, sensors, etc. together, to help people utilizing the information from the things to improve their life. The things are always located at different places at different times, and the information of the thing may have different access right at different location during different time. Therefore, the access control mechanism[2] in IoTs should consider location and temporary constraints in order to enhance the security of an application.
The mainly existing access control schemes for the IoTs concentrate on authentication while ignoring more general models. To summarize, Benenson etc. provides a solution for defense against node capture through the collaboration of sensor nodes [3], while Shen proposes three access control schemes using the one-way key chain and the Merkle hash tree [4]. In [5], a solution to the problem of new node admissions is provided; however, the solution is not secure against replay attacks according to [6]. [7] lists influential works. These studies favor specialized schemes and show that few general access models are proposed for the IoTs.
In this paper, we propose a model that combines location and time with security level to control access to the information within the sensing layer of the IoTs. This model is called Location-Temporal Access Control Model(LTAC). The main principle of LTAC is its use of a lattice approach to decrease the size of policy bases. We show that how the different components in the model are related with location and how this location information can be used to determine whether a subject has access to a given object.

Location formalization

In the IoTs, there are several ways to represent location information, such as geometrical coordinate, symbolic representation, etc. In geometrical coordinate representation, a location is represented by 2 or 3 dimensional coordinate obtained by GPS devices, while in symbolic representation approach, each location is represented by a symbolic name, such as Beijing (a city name), CCTV building (a building name) and Room 656 (a room name).
Locations can be specified at different levels of granularity, and the smallest granularity of locations is a point. In this paper, we use the notion of logical location, which is formally defined as follows.
Definition 1. (Logical Location) A logical location lloci is a non-empty set of points (ploc1,…,plocn).
LLOC={lloc1,…llocn} represent a set of names of logical locations.
Given two logical locations, a containment relation may exist, so we define the location containment relation as follow.
Definition 2. (Containment relation) Logical location lloci is contained in another logical location llocj, written as  , if  .
Temporal formalization

In order to describe operations that can only be executed within a given period, we first model time. Here, we use the notion of a calendar [8]. A calendar consists of a countable set of contiguous intervals. In a typical example, a calendar is set in years, months, and days. Since two calendars can have different granularities, a sub-calendar relationship can be established among them: given two calendars c1and c2 , c1is a sub-calendar of c2 (written as   ) iff there exists  with  , where N is a set of natural numbers. For example, days are a representative sub-calendar of months. Obviously,  is a partial order relation. A calendar base, written as CB, represents a set of calendars and will generally change with different contexts.


For example, if a school curriculum is comprised of years, semesters, and weeks, then the corresponding CB
is {years, semesters, weeks}.
Definition 3 (Calendar time): Given a CB={c1,…,cn}, calendar time ct is defined as  , where,   and for all  we have   .
Let CT be a set of calendar times. Generally, any two calendar times are always comparable. That is, for any ctx and cty in CT, we have ctxcty, or ctyctx. In the IoTs, there exist different types of time constraints such as the earliest access time, the latest access time, the earliest finish time, and the latest finish time, etc. In this section, the earliest access time (eat) and the latest finish time (lft) are adopted. Now, we formally define time constraints.
Definition 4 (Time Constraints): Time constraint  is a set of two-dimensional vectors of calendar times, where the first dimension and the second dimension represent eat and lft, respectively. Time constraints must satisfy the following condition: for any  ,   .
Example 1. Given TC={(ct11,ct12),(ct21,ct22)}, and if an event satisfies TC, then (1) its starting access time is greater than or equal to ct11 and its finish time is less than or equal to ct12; or (2) its starting access time is greater than or equal to ct21 and its finish time is less than or equal to ct22.
Given a time constraint {(1,3),(2,4)}, the constraint can be reduced to {(1, 4)}. This is related to the following definition.
Definition 5 (Simplest Time Constraints): A time constraint TC is the simplest, if for any (ct11,ct12) and
, min{ct12, ct22}<max{ct11, ct21}.
time constraints are always the simplest.
Definition 6 (Order relation on TC): Given any tc1 and tc2 in TC, tc1  tc2 (meaning that tc2 is stricter than tc1) iff	and	, where tc1=(ct11,ct12) and tc2=(ct21,ct22).
Proposition 1.  on TC is a partial order.
Proof: Here we only prove that is transitive. For any tc1, tc2 and tc3 in TC, and let			,	 , where	,	,		. From tc1  tc2, we have		and		; Similarly, from tc2 tc3, we have		and		. Thus,   and	. So, tc1 tc3.
In some cases, logical time (such as work time or class time) is more important. We define logical time as follows.
Definition 7. timeAssigned:		is a function providing intersection from LT to the non-empty power set of TC, where	represents a set of names of logical time.

Location-Temporal Access Model

In this section, we discuss our formal model, LTAC.

Basic Components of LTAC

The basic LTAC model is comprised of the following components: is a set of node IDs;
is a set of logical time constraints; is a set of logical locations;
is a set of operations; is a set of objections;
is a set of permissions;
is a set of access bases;
is a many-to-many map of connections between permissions and the power set of


access bases.	means  that  any  access  base  in  y  has  permission  x.  For  example, if		, then a node satisfying the constraint of lt1 at location lloc1 can execute operation op to object o, and a node satisfying the constraint of lt1 at location lloc2 can execute operation op to object o;
assigns	a	permission	level	to	access	bases,	where
;
assigns  an  access  base  to  permissions,  where  permAssigned
(accbase)={perm|(accbase,perm)	PA};
AccessRequest: ID×OP×O is a predicate; if this is true, then a node id requests operation op to object o; AllowRequest: ID×OP×O is a predicate; if it’s true, then a node id is allowed to execute operation op to o; DenyRequest: ID×OP×O is a predicate; if it’s true, then a node id is not allowed to execute op to o;
RevokeRequest: ID×OP×O is a predicate; if this is true, then the permission node id executes operation op
to o will be revoked;
 maps id to access bases, which returns the current access time, and the current logical locations when node id requests an access.
In order to return the logical locations of a node, its physical location should be first obtained, and then its logical locations can be computed. Because a physical location can be assigned to many logical areas, the locations returned by CurrentTL comprise a set of logical locations.

Mechanism for authorization and revocation

Intuitively, if a node is located in an appropriate area with the ability to satisfy the given time constraints, its requests to execute some operations on an object should be allowed. In order to not use too many symbols, we overload the notion  , as follows.
Given  id,  op,  and  o,  let  CurrentTL(id)={ltid,{llocid1,…,llocidn}}  and  accbaseAssigned((op,o))
={(lt1,lloc1),…,(ltn,llocn)},	CurrentTL(id)    accbaseAssigned((op,o))	iff	there	exists	(lti,lloci) 
accbaseAssigned((op,o)) with ltid  lti and lloci  {llocid1,…,llocidn}. Now, we give the authorization schemes
(1)	.
(2)	.
(3)	.
Formulas (1) and (2) show that: (1) if the a node id requests permission to execute operation op to object o, and CurrentTL(id) satisfies the conditions of executing op to o, then the requests will be allowed; (2) If a node id requests to execute operation op to object o, but CurrentTL(id) doesn’t satisfy the conditions of executing op to o, then the request will be denied. Formula (3) suggests that if node id owns the permission of executing operation op to o and CurrentTL(id) is no longer able to satisfy the conditions of executing op to o, the permission will be revoked.
Figure 1 provides an overview of LTAC. This figure shows that even when an access request is allowed, it is still necessary to check this request with any time delay since reputation or location have the ability to change.

Access Lattice

Since PA is a many-to-many map of connections from permissions to access bases, the size of PA’s access base may be large. Querying this map may consume more energy and computing resources, thus decreasing the efficiency of queries. If we assume that a node with a high reputation owns all the operations as a node


having a lower reputation, then a corresponding access lattice constructed from access bases can be adopted to decrease the size of PA.
Definition 8 (Order relation	on ACCBASE): Given any (lt1,lloc1) and  ,
iff	,	.
Theorem 1:	is a lattice.
Now we give an example to show that using the lattice is an efficient way of decreasing the size of policy bases.
Fig 1 LTAC

Example 2. Let PERM={(Open,MicroWave), (SetParameter, MicroWave), (close, MicroWave)}, ACCBSE={ (lt1,lloc1 ),(lt2 ,lloc2 ),(lt3,lloc3 ),(lt4 ,lloc4 ) }. The access base for each permission is as follows: accbaseAssigned((close,	MicroWave))=	{	(lt1,lloc1 ),(lt2 ,lloc2 ),(lt3,lloc3 ),(lt4 ,lloc4 ) }, accbaseAssigned((SetParameter, MicroWave))={ (lt3,lloc3),(lt4,lloc4 ) } and accbaseAssigned((Open, MicroWave))={ (lt4,lloc4 ) }. From above, the cardinality of accbaseAssigned((Close, MicroWave)), accbaseAssigned((SetParameter, MicroWave)) and accbaseAssigned((Open, MicroWave)) is 4, 2, 1, respectively. Assuming that a lattice can be formed from these access bases as shown in Fig 2, then the access base for each permission could be changed as follows: accbaseAssigned((close, MicroWave))= { (lt1,lloc1)}, accbaseAssigned((SetParameter, MicroWave))={ (lt3,lloc3 ) } and accbaseAssigned((Open, MicroWave))={ (lt4,lloc4 )}. This means that the cardinality of all three bases is 1. Given an access request AccessRequest (id, Close, MicroWave) of node id locates at lloc3 and the current time satisfies lt3, then AllowRequest(id, Close, MicroWave) will be true since  . From this example, we are able to deduce that the size of policy bases can be decreased using an access lattice.

Fig 2. An Access Lattice


Conclusion

Traditional access control models do not take into account environmental factors before making access decisions. Such models may not be suitable for IoTs. Towards to this end, we have proposed a location- temporal access control model in this paper. In our model, the access to an object is determined by their location and time with reputation, to solve the problem of deciding when and where to authorize access requests, and who is able to access information, and utilize the notion of access lattice to decrease the size of policy base. In the future work, we will consider the situation that when a node moves into a location where communication is unstable, and the authorization information cannot be obtained in time.


Acknowledgements
This research is supported by the National Natural Science Foundation of China (61070186) and the Strategic Priority Research Program of the Chinese Academy of Sciences(XDA06030200)


References
L. Atzori, A. Iera, and G. Morabito, “The Internet of Things: A survey,” Computer Networks, vol. 54, no. 15, pp. 2787–2805, 2010.
D. Bell and L. La Padula, “Secure computer system: Unified exposition and multics interpretation,” Bedford, 1976.
Z. Benenson, F. C. Gartner, and D. Kesdogan, “An algorithmic framework for robust access control in wireless sensor networks,” in Wireless Sensor Networks, 2005. Proceeedings of the Second European Workshop on, 2005, pp. 158–165.
S. Yu-long, M. A. Jian-feng, and P. E. I. Qing-qi, “An Access Control Scheme in Wireless Sensor Networks,” in Network and Parallel Computing Workshops, 2007. NPC Workshops. IFIP International Conference on, 2007, pp. 362–367.
H.-F. Huang, “A novel access control protocol for secure sensor networks,” Computer Standards & Interfaces, vol. 31, no. 2, pp. 272–276, 2009.
I. Butun and R. Sankar, “A brief survey of access control in Wireless Sensor Networks,” in Consumer Communications and Networking Conference (CCNC), 2011 IEEE, 2011, pp. 1118–1119.
J. Liu, Y. Xiao, and C. L. P. Chen, “Authentication and Access Control in the Internet of Things,” in Distributed Computing Systems Workshops (ICDCSW), 2012 32nd International Conference on, 2012, pp. 588–592.
J. B. Joshi, E. Bertino, U. Latif, and A. Ghafoor, “A generalized temporal role-based access control model,” IEEE Transactions on Knowledge and Data Engineering, vol. 17, no. 1, pp. 4–23, 2005.
