Python [17] is a language that comes close to straddling the boundary be- tween programming and scripting. Among its features are built-in tuples, arrays, lists, and dictionaries; string pattern matching using full regular- expression notation; iteration over tuples and lists; exceptions; list comprehen- sions; first-class functions; and a (crude) object model. These features betray the influence of languages as diverse as Perl and Miranda. Python has a clean concise syntax, and very good feature integration. Its core language is small but powerful, and its rich module library provides very high-level functionality such as string pattern matching.

By contrast, a Java program to solve the same problem would be rather less concise. It would contain a lot of type information, some of it redundant. It would be rather clumsy in its string pattern matching (even using the Pattern library class). Finally, it would need auxiliary methods.

Despite these differences, it is clear that programming and scripting lan- guages are converging in most respects. Modern scripting languages such as Python are absorbing programming language principles such as readable syntax, rich control structures, rich data types, data abstraction, and rich li- braries. On the other hand, scripting languages still tend to favor dynamic typing and implicit variable declarations.

Convergence between programming and scripting languages is desirable because it combines the advantages of both. Maintainability is important for (non-throwaway) scripts as well as programs. Rapid development is desirable for programs as well as scripts. Very high-level functionality is important for both programs and scripts, although it need not necessarily be built into the core language.

The main obstacle to complete convergence seems to be the issue of static vs dynamic typing. Static typing enables compilers to certify absence of type errors and to generate efficient object code. Dynamic typing is costly in run- time checks. However, dynamic typing provides flexibility that is essential in many scripting applications. Scripts must be able to process heterogeneous data, often derived from web forms or databases.

Thus object-oriented languages actually support a measure of dynamic typing. In fact, their type system combines static and dynamic typing rather smoothly. The programmer is able to choose the degree of dynamic typing, by locating each individual variable at a particular point in the class hierarchy. Thus static and dynamic typing need not be mutually exclusive: they can be seen as opposite ends of a spectrum.

Early versions of Java did not support generics, and this was widely recog- nized as a serious weakness. If a program needed a homogeneous set (say) with components all of the same class, the programmer had to settle for a heterogeneous set, of class Set, with arbitrary objects as components. In other words, the programmer was forced to use dynamic typing, with all of its disadvantages but none of its advantages.

Java 5 has largely eliminated this weakness by introducing generic classes. Our programmer can now achieve a homogeneous set by declaring a generic class Set<X>, and then instantiating it as in Set<Person> or Set<Date>. Un- fortunately, Java 5 generic classes can be instantiated only at object types; an instantiation at a primitive type, such as Set<int>, would be illegal.

(1) and (2) are surely the wrong way round. A particular Set<Number> object could be populated entirely with Integer members, so it seems perfectly rea- sonable to treat a Set<Integer> object as if it were a Set<Number> object. In other words, we would like to allow some generic classes, such as Set<X>, to be covariant.

The type-erasing translation in effect translates a generic class such as Set<X> to a non-generic class Set. At run-time, all objects of type Set<Date>, Set<String>, and so on are represented as objects of class Set, and are tagged accordingly. No information about type arguments exists at run-time.

The specializing translation in effect translates each instantiation of a generic class to a distinct non-generic class. For example Set<Date> would be translated to Set$Date, Set<String> to Set$String, and so on. Information about type arguments is encoded in the names of the generated classes.

