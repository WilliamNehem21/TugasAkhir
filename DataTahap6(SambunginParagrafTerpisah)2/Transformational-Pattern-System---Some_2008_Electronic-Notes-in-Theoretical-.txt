In the context of Model Driven Architecture (MDA), most model transformation mechanisms aim for rigorously and unambiguously defined, fully automatic transformations. We argue that such techniques, even when fully mature, are not applicable in all cases of software development. These difficult cases would benefit from flexible and semi-automatic open transformations. We present a mechanism, so called transformational pattern system, and show how it can combine human made decisions and intentionally vague and incomplete rules to perform a transformation.

Automatic transformations do not get rid of complexity. Instead of relying on the expertise and wisdom of a designer to create a target model, we rely on the transformation engineer to create a transformation. The transformation must solve a more generic problem and apply to more cases than one, and is therefore more difficult to build. The relative development cost is reduced, if the transformation is applied to several products. For a one-of-a-kind product or for a small organization, it might not be cost-efficient to develop (and maintain!) another piece of software,

We present an experiemental semi-automatic transformation mechanism based on so called transformational patterns. This paper extends our previous work [10], where transformational patterns were used alone, by adding a method for joining several patterns together. The mechanism is fully transparent and allows the user to choose the order of tasks and make manual changes to the models. At this time, we do not attempt to tackle problems caused by incremental changes to the source model. We illustrate the use of the mechanism with an example.

model, where each node has a type and can have named values attached. Whenever a production is used, the associated action is triggered. The productions reduce the input graph step by step, while the actions construct the resulting pattern system. In other words, the GRS is used to recognize or parse the source graph.

As an example, consider the seemingly simple transformation from a structure model (a UML Class Diagram) into a relational database schema. It seems quite straight forward, but there are details, options and exceptions that add complexity. For ex- ample, there are different ways to interpret and transform composition, inheritance and other relations between classes, and there is not always enough information in the source model to make the decision. It is in managing these details and varia- tions where the real challenge for a transformation mechanism lies. With transfor- mational patterns, their inherent flexibility and interactive nature helps overcome some of these difficulties.

Triple graph grammars [9] are grammars spanning three related graphs; one for the source model, one for the target model, and one for the relationships between the models. Each production alters all the graphs (models) at the same time, keeping them always synchronized and confirmant with their schemas (metamodels). A transformational pattern system contains elements for the source and target models and their relations. In that sense, a pattern system is an abstract triple graph. Due to the flexibility in binding, it represents a group of triple graphs.

With triple graph grammars, additions to the source or target models can be dealt with simply by applying further productions. We have not yet addressed the problem of incrementality for pattern systems. Triple graph grammars are also bidirectional. Although a transformational pattern itself is not directed, a derived task graph always is. The assembly rules, too, create a bias towards a direction.

A transformational pattern system, once all the roles are bound, is also a map- ping between the source and target models. So, model mapping techniques [6] are in some way similar. However, they are typically bidirectional, whereas transfor- mational patterns are not.

Although incrementality was not considered in this work, it is very important for open transformations. As it is now, any significant change to the source model demands a reassembly of the pattern system, effectively forgetting the previous user decisions. Supporting incremental transformations needs to be researched. The pattern assembly mechanism also has to be better integrated with the pattern tool, to improve the user experience. For the same reason, the production rules need a well-defined and intuitive notation.

We also intend to strengthen the theoretical foundation of our approach with, e.g. graph grammars. For example, it has been pointed out to us that transformation pattern systems might bear resemblance to graph processes [3]. This is an interesting connection we intend to explore further.

