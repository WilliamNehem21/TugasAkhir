Weighted automata have a simple weight or cost on each transition and have been extensively studied since the early days of computer science [16,26]. These automata have been shown to have practical applications, an example of which is the work of Mohri et al. on speech processing [23,24]. Buchholz and Kemper

Priced or weighted timed automata [2,9] model time using clocks and have costs on states and transitions. The cost of each transition is paid each time the transition is made whereas the costs of each state is paid once for each time unit the automata spends in that state. This provides an expressive model of costs and time that is, in many cases, undecidable [11].

This paper is intended to be a first presentation of our notions and ideas and so, also due to lack of space, it is relatively informal with only a preliminary sketch of initial results. In the next section we introduce our cost algebra and then in Section 3 we define our automata. Restriction and channel communication are discussed in Section 4 where it is shown how the synchronous style of communication between automata can be used to model various kinds of channels. Finally in the concluding Section 5 we briefly discuss how, as future work, the possibly infinite maximum cost

It is easy to see that the product of two Q-algebras is indeed a Q-algebra. Sometimes elements of a product in two different Q-algebras represent the same resource. When we take the product of these algebras we do not want to replicate these entries, but rather combine them. This can be achieved by using a Q-algebra with members that are tuples of labelled elements. The following definitions add labels to the algebra, which can be used for comparison when the product of two (labelled) Q-algebras is calculated. These definitions allow us to write values such as: (power:2, cpu:10) and (power:7, errors:1), rather than (2,10) and (7,1) and for their product to be the (power:9, cpu:10, errors:1) rather than (2,10,7,1). These products are only defined if the operations on identically labelled algebras are the same.

We also note that even if automaton P1 sends a message on channel stdout at the same time that P2 receives a message on stdout, it does not automatically mean that P1 and P2 have communicated. Indeed, P1 may receive a message on channel stdout from some other component while P2 sends a message to some other component over the same channel. This is the difference between the {stdout} and the {stdout?, stdout!} action sets and it allows us to prove that constructing products of Q-automata is associative.

happen at the same time. Moreover only one input may synchronise with only one output. To model a wider range of communication styles including asynchronous, lossy and multicasting, we explicitly model channels as automata (in a similar way as for constraint automata [3]).

an infinite number of computations can only be generated by looping. A single loop may either add a fixed cost to a computation (leading to a potentially infinite cost), or may set a new, level cost, or might have no effect at all. Therefore a single traverse round a loop is enough to tell you what the effect of an infinite number of traversals of that loop will be. This means that we can calculate the maximum cost in finite time, even if that cost is infinite.

