We first describe Protocol Composition Logic (PCL) in brief to help make the paper accessible to readers unfamiliar with PCL. We then discuss the well-known Trans- port Layer Security (TLS) protocol, which we use as a running example throughout the paper. Readers familiar with PCL and the analysis of TLS using PCL may skip to Section 3.

The proof system extends first-order logic with axioms and proof rules for pro- tocol actions, temporal reasoning, properties of cryptographic primitives, and a specialized form of program invariance rule called the honesty rule, described in Section 2.3. We list below the axioms we use in this paper. For the proof of soundness of the axioms and the rules, we refer the reader to [6,11,7].

In this section we discuss the Transport Layer Security (TLS) protocol [9]. Broadly, TLS involves two principals called the TLS client and the TLS server. TLS guaran- tees mutual authentication and establishes a shared secret between the two princi- pals. We focus on the proof of the authentication property and identify the program invariant that it needs. We also established other security properties of TLS as part of a larger study [12] on IEEE 802.11i.

We start by describing our encoding of PCL programs. Recall from Section 2.3 that we must show that the invariants holds at the conclusion of every initial segment of every protocol that an honest principal may execute; we describe invariant checking process for one such initial segment, the general case is simply a conjunction of such steps.

PCL  programs  are  modeled  as  a  set  of  facts  involv- ing the action predicate.  The action predicate has the form action(thread, actionnumber, output, actionname, input).  For instance, the first initial segment of the TLS Client role (TLS : Client0 from Section 2.4) is written as the following set of facts. The second fact action('X', 1.1, t1, cat, [nx, vx]) asserts that thread X concatenates terms nx and vx to generate the term t1. The actionnumber field is ordinal and helps assert the ordering of actions within a thread.

outputs, the action on the network is treated as a side-effect. In general, the num- ber of inputs to an action depends on the type of action. The main difference between the PCL program listing and the logic program encoding is the explicit modeling of the concatenation actions. An alternative encoding could have used the list construct, but we found that this leads to computational inefficiencies in practice.

We now discuss the proof of the main theorem. We show that invariant checking is sound for a standard decision procedure on logic programs. Recall from Section 2.3 that the invariant must be deemed to be true for every initial segment of every protocol that the honest principal executes; we describe the process for one such initial segment and show that, if our decision procedure outputs failure on the query

In the following proofs, we prove that a decision procedure employing SLD- resolution [17] in a left to right, depth first manner is sound for checking invariants. We also use the fact that SLD-resolution tries every rule in the logic program before failing. Most Prolog interpreters implement SLD-resolution in a left-to-right, depth first manner [16] which means that we can use standard tools to realize the decision procedure. In particular, we used SWI-Prolog as our prototype tool [18].

