The second benefit of mechanization is machine-readabilty: we can use the mechanized pGCL theories to support the creation of automatic proof tools that use weakest-precondition semantics for reasoning. For example, verifying pGCL programs typically involves much numerical calculation, and this can be formally carried out by rewriting with relevant theorems about real numbers. Since HOL4 is a theorem prover in the LCF family, it provides a full programming language (ML) for the user to write such tools [2]. Consistency is enforced by the logical kernel, a small module that is solely empowered to create objects of type theorem, which it does by applying the inference rules of higher-order logic.

We created many small tools to speed up mechanization and program ver- ification, including the rewriting described above for real numbers. We also implemented a tool which takes as input an annotated program C, precon- dition P and postcondition Q, and generates verification conditions that are sufficient for partial correctness (the Hoare triple {P }C{Q}). It proves as many of these verification conditions as it can, simplifies the remainder and then returns them to the user as subgoals to be proved interactively.

initial state yet produces not a definite final state, but rather a probability distribution over final states that reflects the probabilistic branching in its execution. Demonic branching is indicated by relating the initial state to more than one final distribution. The following example shows both why we need relations instead of functions, and probability sub-distributions.

The left hand side of the definition includes switch as a parameter of the contestant; this is used in the program on the right hand side to determine whether to switch curtain in the last step. The postcondition is the desired goal of the contestant, i.e., and has been proved elsewhere for pGCL [13]. Moreover simple techniques based on program variants have also been derived. However, for the remainder of this paper we will be solely interested in partial correctness, and so questions of termination will not concern us.

It is therefore left to the user to provide a useful loop invariant P in the Assert around the while loop. Note that the Prolog tactic will succeed on the first subgoal, deriving a lower bound for the body of the while loop, but the second subgoal will fail because there are no applicable rules. In our tactic failed subgoals do not initiate backtracking, but are instead turned into verification conditions. Therefore in this way each while loop in the program will generate one verification condition, in this case that the supplied P is in fact a correct invariant for establishing Q. Nested while loops work in exactly the same way: the invariant for the outer loop will be propagated backwards through the body, and when it meets the inner while loop a verification condition will be generated.

Recall the interpretation of a pre-condition with respect to a given post- condition. The expression on the right at (1), evaluated at an initial state s, gives the probability that the postcondition will be established (namely that there is a unique winner). This must be at least the expression on the left, which is at least 2/3 for all initial states except i = 0 (when the satisfaction of the postcondition would be impossible in any case).

This work demonstrates the benefits of mechanizing a theory of program semantics using a theorem prover. In particular, the fact that the theorem prover was interactive fitted very nicely with the verification-condition genera- tor: if subgoals appeared that could not be proved automatically, then instead of causing a failure they could be passed on to the user for manual proof. Moreover we took advantage of the LCF design of HOL4 , which preserves the consistency of user-defined tactics: the verification-condition generator is highly complex, but nevertheless any theorems that it creates have a high assurance of soundness.

Michael Huth. The interval domain: A matchmaker for aCTL and aPCTL. In Rance Cleaveland, Michael Mislove, and Philip Mulry, editors, US - Brazil Joint Workshops on the Formal Foundations of Software Systems, volume 14 of Electronic Notes in Theoretical Computer Science. Elsevier, 2000.

