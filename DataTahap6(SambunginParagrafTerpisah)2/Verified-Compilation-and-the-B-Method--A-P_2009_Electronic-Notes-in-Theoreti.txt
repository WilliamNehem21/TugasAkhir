The B method manages to successfully span the development process from mod- elling down to the algorithmic level. However, to cover the remaining steps towards a running implementation, one needs to synthesize the algorithmic model to some programming language and then compile the resulting code into the target platform assembly language. These last two steps cannot be verified using the formal verifica- tion approach provided by the B method. Indeed, code synthesis maps constructs of languages that do not have common semantic underpinnings. Compilation is even more troublesome, since, in addition to the semantic gap, there is also usually a deep transformation of the code structure caused by optimisation and other trans- formations, and the effort put in the B-based development may be jeopardized by a bug in the compiler. To increase the confidence on the generated code, industrial adopters of the B method employ a redundant tool chain, using two distinct imple- mentations of code synthesis and compilation. This pragmatic approach however does not provide a theoretically satisfying evidence of the result correctness and comes at the cost of having to deal with the execution of redundant programs.

The paper is structured as follows. Section 2 provides a general introduction to the B method and briefly outlines the proposed approach, comparing it to a classical application of the B method. Section 3 presents the main lines of the definition of a B model for the instruction set of a simple, yet computationally rep- resentative, micro-controller. Section 4 presents the mapping of the main constructs of the algorithmic language B0 to assembly constructs, through a series of simple examples, and introduces thus the structure of an assembly program as a B imple- mentation. Experimental results of the application of this approach to commercial micro-controllers are also reported in this section. Finally, Section 5 draws prelimi- nary conclusions on this work and an agenda for future research in the direction of constructing a production-level verifying compiler based on the B method.

The B method for software development [2] is based on the B Abstract Machine Notation (AMN) and the use of formally proved refinements up to a model suffi- ciently concrete that programming code can be automatically generated from it. Its mathematical basis is first order logic, integer arithmetic and set theory, and its constructs are similar to those of the Z notation [18]. Its structuring constructs are more closely related to imperative modular programming language constructs. Also, its more restrictive constructs simplify the job of support tools, and industrial software for the development of B based projects is widely available [8,3].

Finally, so-called implementation modules form a special case of refinement where the abstraction level is similar to that of a programming language. This paper uses the term algorithmic model to qualify such modules. The part of the B notation that may be used to define implementations is called B0 (e.g. it does not contain non-deterministic constructs). Using as input an implementation module, it is possible to generate source code in a conventional program language such as C or ADA.

Essentially, a B module contains two main parts: a state space definition and the available operations. It may additionally contain auxiliary clauses in many forms (parameters, constants, assertions), but those are essentially for practical purposes (i.e. to promote modularity, reuse, etc.) and do not extend the expressive power of the notation. In the remainder, we will restrict our discussion to the core clauses of the module specification.

The specification of the state components appears in the VARIABLES and IN- VARIANT clauses. The former enumerates the state components, and the latter defines restrictions on the possible values they can take. If V denotes the state variables of a machine, the invariant is a predicate on V . Verifications carried out throughout the development process have the intention of checking that no invalid or local) variables to which they are applied. The semantics of the substitutions is defined by the substitution calculus, formalizing how the different substitution forms rewrite to formulas in first-order logic. Let S denote a substitution, E an expression, then [S]E denotes the result of applying S to E. For instance, an operation that would increment a counter variable v can be specified as v := v + 1. Indeed, the basic substitution is very similar to the side-effect free assignment construct

The target platform may be modeled with the B abstract machine notation: the state of the machine represents the state of the platform (i.e. registers and memory), and each operation represents an assembly instruction. This only needs to be performed once for a given target platform. Further details are provided in Section 3, where a model of the Random Access Machine model of computation is

The algorithmic model has to be further refined into an assembly-level model. The latter model is defined on top of the target platform model discussed previ- ously. A general strategy for this refinement is to map the state variables of the algorithmic model to different addresses of the platform memory, and to trans- late the algorithmic-level operations to combinations of operations defined in the platform model corresponding to the assembly language instructions. The result- ing assembly-level refinement needs to be proved compliant with the corresponding functional model. We then obtain a software artifact at the assembly level that formally refines the initial functional model.

This strategy needs a loop construct that halts when the program counter reaches the end marker. We call this the fetch loop: it associates each possible value of the program counter with the corresponding assembly instruction. The local variable pc maintains the value of the program counter of the ram machine. The local variable end stores the end marker of the program and remains constant. Both variables are employed in the formulation of the variant and invariant of the loop. As the algorithmic model does not jump backwards, the variant can be expressed as the distance between the end of the program and the value of the program counter. The invariant of the fetch loop establishes the relationship between the variables of the ram machine and the local variables of the operation and the state of the ram memory for each possible valuation of the program counter:

This assembly model follows the same pattern as the previous example. Instructions 0 and 1 codify the preamble, 2 to 6 the increment loop, and 7 is the end of the program execution. Note that we need a variable, here called i , to keep track of the number of times the increment loop has been executed. Its value is initially zero and it is incremented whenever the program counter is 6, i.e. when the algorithm jumps back to the evaluation of the loop condition. Also, observe that the invariant of the fetch loop states that when the value of the program counter is two, the algorithmic loop condition shall hold.

All the examples only manipulate simple integer or scalar values. A full-scale project would certainly involve more complex data structures that can be described in the B0 language. On the other hand, it is worth noting that, in order to avoid certain classes of bugs, software in safety-critical projects is often restricted so that it does not use features such as dynamic memory allocation and pointers.

Micro-controllers provide a number of facilities (i.e. dedicated hardware), such as input/output and interrupt pins for interfacing directly the processor with its environment, timers, etc. In the presented examples, such facilities have not been taken into account. Future work include modelling and using such facilities in the B development.

However, much work remains to be done to meet the goals of building a full- fledge tool chain based on the B method and targetting an assembly-level industrial platform. We shall define and implement formal rules for the construction of as- sembly level models from algorithmic models. The application of such rules would result in a set of proof obligations that would need then to be verified. In order to address expected scalability issues in this verification effort, different solutions may be investigated. First, the restrictions imposed by B method on refinements could be relaxed, so that the translation may be realized in small steps, using inter- mediate models mimicking intermediate representation of compilers, where issues such as register allocation and code optimization are more easily implemented and verified (in a way similar to that of, e.g. [14]). Also, some proof obligations need manual assistance with the current tool support for B. Another line of work is to investigate if and how the automation of these provers can be improved (by devel- oping and applying additional proof rules). Another solution would be to generate proof scripts corresponding to these proof obligations along the translation process. More work also needs to be done from the modelling viewpoint. On the one hand, more elements of the B0 language need to be addressed, allowing for richer data structures. In order to cater to designers of safety-critical systems, one also needs to provide support for facilities such as interrupts, timers and input/output.

