This paper presents a high-level access control model of the seL4 microkernel. We extend an earlier formalisation by Elkaduwe et al with non-determinism, explicit sharing of capability storage, and a delete-operation for entities. We formally prove that this new model can enforce system- global security policies as well as authority confinement. By treating sharing explicitly in the abstract access control model we simplify considerably the refinement proof towards the seL4 implementation. To our knowledge this is the first machine-checked access control model with explicit sharing of authority.

Our attempts to prove refinement between the access control model and the operational specification have shown that features of seL4, which are also present in other capability systems, make proof especially complicated. These features are, in increasing order of complexity: non-determinism, deletion of entities (not just capabilities), and sharing of capability storage. The first, non-determinism, is mostly technical and easy to treat. The second, dele- tion of entities, is conceptually simple, but introduces a mismatch between entities that occur in the security specification and those that exist in the im- plementation; an example is presented later. The third, sharing of capability storage, introduces a conceptual problem. Moreover, if one naively formalises the classical approach, a great deal of unnecessary complexity into the relation between abstract and concrete states in the refinement proof.

we provide the first formal model and security analysis of shared capabil- ity storage. Shared capability storage changes the basic predicates of the analysis and introduces additional possibilities for transmitting authority and information. We show how the analysis can be adjusted to account for shared authority and we prove that the adjusted system is still suit- able for enforcing mandatory, system-global access control policies as well as authority confinement and isolation.

While the refinement proof is not yet complete, enough progress has been made to expose a security problem in an early version of the operational spec- ification: even though a grant operation to transfer authority from a thread A to another thread B is checked explicitly when started, an interruption may occur, and another check is not made upon resuming the operation, even though the authority could have been revoked from A during that interrup- tion. The completion of the operation would therefore be unauthorised and would not refine the security model where all such operations are atomic. The problem has been fixed in the meantime, and shows how refinement can be used to expose subtle defects such as this one.

Isabelle supports tuples with named components. For instance, we write record point = {x :: nat, y :: nat} for the type point with two components of type nat. If p is a point, a possible value for p is notated (| x = 5, y =2 |). The term xp stands for the x -component of p. Updating p from a current value (| x = 5, y =2 |), with the update notation p(| x := 4 |), gives (| x = 4, y = 2 |).

Sharing is traditionally addressed by arguing around it: that B and C share capability storage amounts to grant authority between them in both directions and should be modelled as such. Any action on the capabilities of B must be immediately mirrored on those of C. There is nothing conceptually wrong with this argument, but as sharing structures become more compli- cated, so too does the relationship between the abstract model and the details of an implementation. The security model must express both normal grant ca- pabilities as well as additional ones to account for sharing. The formalisation of the relationship between it and an implementation model is complex, and proving that it holds is cumbersome. Moreover, there is no longer a simple correspondence between operations executed in the two models: actions in the security model depend on the state of the implementation model.

We contend, in this paper, that it is much easier and more convenient to model sharing explicitly and to account for it directly during security analysis. Further, any security monitor that operates according to the main theorems of the model will have to account for sharing anyway. An explicit model of sharing thus also benefits implementors of security monitors.

Following the Elkaduwe model, we do not distinguish between active (e.g. a thread) and passive (e.g. memory) objects, but rather call all kernel objects entities. Formally, an entity is just a set of capabilities, which is the only property of interest at this level.

a Grant right to another is able to grant its capabilities to this other entity. The Store right models the concept of shared capabilities. If an entity has a Store rights to another entity, then it has direct access to all the capabilities stored in that entity. Since multiple entities can have a Store capability to a single entity, this allows sharing of capabilities. We use the term all-rights to denote the set of all access rights; formally all-rights = {Read, Write, Grant, Create, Store}.

Neither the SysRead ec nor the SysWrite ec operation change the state of capabilities in the system. They clearly do not connect disconnected entities. The SysCreate e n c1 c2 operation creates a new entity (n) by using free memory provided by an existing entity (e1) and by assigning a new capability for controlling access to n to existing capability storage (e2). It is only legal if the initiating entity e has both a capability (c1) with create rights to e1, and a capability (c2) with store and write rights to the CNode e2 where the new

This operation clearly has the possibility of adding a capability to an entity that did not previously possess this capability. In fact, if an entity x is store connected to e3 and e2 store connected to y, then introducing a store connec- tion between e3 and e2 will connect x and y. However a connection between e3 and e2 is only ever created if a connection existed between e and e2, and since e and e3 are already connected, any connections introduced are already transitively present beforehand.

Both the SysRemove e c1 c2 and SysRevoke e c operations remove capa- bilities: in the former case from the entity pointed to by c1 and in the latter case from a whole set of entities. As in the Elkaduwe model, we do not specify explicitly which set of entities is removed by revoke, because this set is tracked in a complex data structure cdt (capability derivation tree) in the implementa- tion that adds nothing that is relevant for our purposes to the security analysis. Our formulation with nondeterminism makes this more natural than before. Given this set, the revoke operation is then just a repeated call of remove.

Since we define the state as a partial function from entity-ids to entities, the definition of executing delete is trivial. SysDelete simply removes an entity; therefore it cannot connect disconnected entities. We will see in the next subsection that delete has an interesting side effect that slightly changes the formal statement of theorem 4.4 and theorem 4.5 as well as theorem 5.1.

A function step combines precondition checks on the current state, from legal, with the effects of operations, from step '. In contrast to the Elkaduwe model, operations now return a set of possible states. The definition of step ensures that the result always includes the initial state, thereby accounting for the possibility that an implementation of seL4 may abort an operation for reasons that are ignored in step '. For example, an implementation of the SysCreate operation will fail if it is not provided with sufficient memory, but this kind of detail is irrelevant in the security model.

This subsection introduces the formal statements of the main lemmas in the security proof. We define sane as an invariant that is a precondition to most theorems in our security model. We call a state sane if all capabilities point to entities that exist.

Instead of strengthening the precondition, we could get around this by introducing names for entities that are unique not only over the lifetime of the entity, but over the lifetime of the whole system. These names would have to come from an infinite set. We chose not to do so, because this problem exists in the implementation as well, and there is no way to implement such system life-time names in reality unless the system runs for a known finite time only. As for shared capability storage, we believed it better to bring the problem out into the open and reflect it explicitly in the security analysis.

The definitions are unchanged from Elkaduwe et al. The subsys-caps function takes the set of entities in the subsystem, and then the union of all their capabilities. Here, these are all capabilities that the entities transitively have access to. A capability c dominates a capability set C (c :> C ) if C provides at most as much authority as capability c over the entity c points to.

Theorem 4.5 (Confinement of authority). Given a sane state s, a non-empty subsystem spanned by x in s, and a capability c with a target identity y in s, if the authority of the subsystem does not exceed c in s, then it will not exceed c in any future state of the system for as long as x and y both exist.

The security analysis so far was concerned with de-jure rights, i.e. rights that are directly conferred by capabilities. If we are interested in the flow of in- formation through the system, then we need to consider de-facto rights. As mentioned previously, de-facto rights model entities that may try to collab- orate to transport information through indirectly authorised channels. If A has read access to B, and C has write access to B, then de facto, A has read access to C even though de jure, no read operation from A to C will ever be

As mentioned previously, our seL4 access control model is inspired by the take-grant model [12]. The original analysis on the take grant model [12, 2] already uses the same approximation to model the exposure of access rights: the transitive, symmetric closure on the given initial graph. The difference here is that we make capability storage and sharing explicit and that we conduct all proofs in Isabelle/HOL.

Rushby [15] provides a formulation of isolation called non-interference. Non-interference is stronger than the concept of isolation we use in this for- malisation, because it goes beyond access control. It also includes covert storage channels, whereas we are only concerned with the overt, explicitly authorised, but still possibly indirect flows of information. The difference is that non-interference would for instance cover things like leaking informa- tion by making an observable decision in the program that depends on secret data. Non-interference traditionally talks about different security levels that should be kept separate, whereas we are in this model more interested in which entities can communicate with each other in a highly dynamic setting. Non-interference is not necessarily preserved under refinement, so special care would need to be taken to connect such a property to the operational model and the C implementation of seL4.

