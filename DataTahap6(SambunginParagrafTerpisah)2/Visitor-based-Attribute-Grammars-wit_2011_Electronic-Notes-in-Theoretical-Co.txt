The visitor design pattern is often applied to program traversal algorithms over Abstract Syntax Trees (ASTs). It defines a visitor, an object with a visit method that is executed for each node in the AST. These visitors have the advantage that the order of traversal is explicitly under control of the programmer, which is essential to deal with side-effectful computations. Unfortunately, the exchange of results between traversals is error-prone.

Attribute Grammars (AGs) are an alternative way to write multi-traversal algorithms. An attribute eval- uator decorates the AST with attributes in one or more traversals. The attributes form a convenient mechanism to exchange results between traversals. Unfortunately, AGs discourage the use of side effect. In this paper, we present ruler-front, a language capturing the combination of the above approaches. A ruler-front grammar can be translated to traversal algorithms in multiple languages. In this paper, we translate to the imperative, dynamically-typed language JavaScript.

Algorithms for traversing tree-shaped data structures appear in many applications, especially in compilers. A lot of effort has been invested in proper abstractions for tree traversals, for example in the form of Attribute Grammars (AGs) [11]. In the last years, we applied AGs in many small projects (to teach compiler construc- tion [21], master projects, etc.), and several large projects, including the Utrecht Haskell Compiler [4], the Helium [8] compiler for learning Haskell, and the edi- tor Proxima [19]. The use of AGs in these projects is invaluable, for reasons that become clear in Section 2.

language to be learned. Also, the AG formalism poses too severe restrictions to be used effectively in these areas, such as prohibition of side effect, or tool support may simply be absent for the programming language in question. The purpose of this paper and associated work is to treat the above two technical challenges.

Considering the first challenge, for imperative languages like JavaScript, a programmer either writes recursive functions, or takes a more structured approach via the visitor design pattern [7,17,16]. Tool support for the visitor design pattern is available for many languages. For example, the parser generator SableCC [6] generates visitor skeleton code for the ASTs that the parser produces, and we used these once to write a type checker for MiniJava [18]. We also used ASM [3], a library used in many big Java projects that provides visitor skeleton code to traverse Java bytecode, to transactify Java programs [1]. With visitors, we use side-effect to carry results computed in one visit over to the next. In our experience, scheduling visits and side effect is an error-prone process, due to absence of the define-before-use guarantee. We elaborate on this in Section 2.1.

Attribute grammars offer a programming model where each AST node has at- tributes (named values per node). The programmer writes code that computes attributes in terms of other attributes. The attribute grammar evaluator automat- ically schedules this code over visits, and define-before-use can be verified with the circularity test of AGs. The implicitness of scheduling is a serious advantage, be- cause it saves us from writing this scheduling manually, and cannot do it wrong. Unfortunately, the implicitness of scheduling comes with a severe restriction: side effect cannot be used reliably and should not be used in attribute computations. In web applications, for example, we typically would like to use a bit of side effect to influence the contents of a webpage. We elaborate on this in Section 2.2.

To accomplish this goal, we also address the second challenge, which is to make our approach available for many target languages. We present ruler-front, a small but powerful language for tree traversals. We managed to isolate the language- dependent part into a small subset called ruler-core, and show the translation from ruler-core to JavaScript. In a related paper [14], we showed a transla- tion to Haskell. With these two languages, we cover the implementation issues regarding the full spectrum of mainstream general purpose programming languages available today.

plemented both in a single tool written in Haskell using UUAG 2 . In Section 2 we in- vestigate the above challenges in more detail. In Section 3 we present ruler-core, with a translation to JavaScript in Section 4. In the extended version of this paper [15], we give a translation from ruler-front to ruler-core.

In this section, we motivate the claims of the introduction in more detail, and intro- duce the background information relevant for the remainder of the paper. We take as usecase the alignment of an HTML menu in a web application using JavaScript, based on a multi-visit tree traversal over an abstract description of the menu. We first show a solution using the visitor-pattern, then a near-solution using attribute grammars, finally followed by two solutions using ruler-front.

In the visitor design pattern, each node of the Abstract Syntax Tree (AST) is modelled as an object, which stores references to the subtrees, and has an accept method. The accept method takes a visitor as parameter. A visitor is an object with a visit-method for each type of node. The accept method of the AST node calls the appropriate visit-method on the visitor and passes the node as an argument. This visit method consists of statements that manipulate the state of the visitor or the AST node, and can visit a subtree by calling the accept method on the root of a subtree, with the visitor-object as parameter.

Furthermore, this data-type declaration introduces JavaScript constructor func- tions to construct ASTs. Each production is mapped to a constructor function that gets as parameter an object corresponding to the symbols in the RHS of the pro- duction. Each nonterminal is mapped to a constructor function that creates a base object that each of the objects corresponding to the productions inherits. Due to the inheritance, we can verify at the point of construction that the AST matches

These attribute names are mapped to object properties named inh depth and syn gathMax . At some point during attribute evaluation, given a participating Menu object m, the objects properties m . inh depth and m . syn gathMax will be defined. An inherited attribute may have the same name as a synthesized attribute: they are mapped to differently named properties. As an aside, nodes may define a number of local attributes, which can be seen as local variables.

Similarly, the right-hand side consists of a JavaScript expression, with embed- ded attribute references. In this case, we may refer to the synthesized attributes of children, or with lhs to the inherited attributes of the current node. The terminals of a production are available as local attributes. In production Menu, there is a terminal called name, which is available as attribute loc : name. The translation of attribute references is similar as described above.

Evaluation of an attribute grammar corresponds to traversing the AST one or more times, and executing rules, according to an evaluation strategy. In this paper, we restrict ourselves to the class of well-defined attribute grammars, whose attribute dependencies can be statically proved to be acyclic [11]. For those grammars, a traversal is possible that visits each subtree a bounded number of times. This corresponds precisely with typical uses of the visitor-design pattern.

Out of the semantic definitions for e.g. Menu, a function sem Menu is generated containing the evaluation algorithm. Furthermore, to interface with the decorated tree from JavaScript code, a function eval Menu is generated that takes the AST, the function sem Menu, and an object containing values for the inherited attributes. It applies the semantic value, and returns an object with the synthesized attributes.

To layout the HTML item, we need to execute a number of statements, and encode this as an expression. In JavaScript, this can be accomplished in a variety of ways. In the example, we choose to use a parameterless anonymous function.

The AG code has several nice properties. The order of appearance of the rules is irrelevant. This allows the rules for e.g. depth and count to be written separately and merged automatically [20]. In the example, we give all the rules in one go to fit the page, however, for bigger projects the ability to write such rules separately is important to write coherent code.

Finally, we check statically if there is an evaluation order of statements such that all attributes are defined before their value is accessed. The attribute declarations describe the attributes that must be defined, and those that are available. The rules describe what attributes must be available before computing an attribute, and an evaluation order is possible if the transitive closure of the dependencies is non-cyclic [11].

However, the above code has a number of problems, because the order of evalu- ation of rules is determined only by dependencies on attributes. In particular, the side-effect that rearranges the HTML items is not a dependency of any rule. Thus it is not clear when it is evaluated, if it is evaluated at all. Similarly, it is neither clear at what moment the widths of the HTML items are obtained. When there are other rules in play that have side effect that effects these widths, the interleaving of these side effects becomes even harder to predict. Finally, the root of the tree does not have any attributes defined, so there is actually no reason to expect any of the rules to be executed in the first place.

The order of appearance of visit declarations dictates the order of visits to AST nodes with this interface. In order to visit a node, all previous visits must have occurred: the actual visits on a node must be a prefix of the declared visits. Values for inherited attributes must be provided prior to the visit. Values for synthesized attributes are only available after a visit has been performed.

Scheduling constraints. Rules can be constrained to visits. With a visit-block, we constrain rules to that visit, or a later visit. The example below illustrates the various possibilities. An attribute definition prefixed with the keyword match is an exception. It is constrained to the visit it appears in, and is executed even if the attribute it defines is never needed. We explain its precise meaning later.

In the above example, we combined both side effect and attribute evaluation. We retain the advantages that AGs offer, such as the ease of adding attributes. Further- more, the extension is orthogonal to various optimizations for attribute grammars, including incremental evaluation and multi-core parallel evaluation.

We present sem-blocks of the form sem nonterm : Interface, which introduces a nonterminal nonterm, with visits and attributes described by Interface. The productions are not defined by a data-type definition, but through clauses and rules per visit, as we explain below. Additionally, the code generated from a semantics- block is a constructor-function that produces an AST node described by Interface, which we can store in a variable, and may use in rules.

During attribute evaluation, the clauses of a visit are tried at runtime in the order of appearance. The next clause is tried when either a match-rule fails, or when there is no succeeding clause for a visit to a child. Failure of any other form of rule simply aborts the entire evaluation. This way, the match-rules allow us to distinguish clauses Cons and Nil of ntMenus by matching on the length of the list. Missing visits are implicitly defined with a single empty clause. A visit without clauses implicitly has a single clause. Therefore, we neither have to specify the visit layout nor clauses for it in the semantics of ntMenus. Also, due to the automatic ordering of rules, many of the rules defined in visit layout of ntMenu, could also be

There are some essential differences in contrast to ruler-front that we grad- ually introduced by example in the previous section. The order of appearance of rules the evaluation order, and each invocation of a visit must explicitly be stated through an invoke rule. Special syntax for data-types is not part of ruler-core. Through clauses and (match) rules, we have a general mechanism to inspect and perform case distinction on arbitrary JavaScript datastructures.

We make no assumptions about the syntax of j . The embedded blocks may occur anywhere in a JavaScript program. It is up to the programmer to ensure that semantic-blocks and attribute references occur at expression-positions, and that interface-declarations occur at statement positions. Neither do we make any assumptions about scopes of j ; instead, we assume that all embedded blocks are in the same scope.

The black nodes represent the state of the AST-node prior to a visit, and the white nodes indicate a branch point. Upon creation, an AST node is in the state represented by the root node. With each edge are alternately associated the rules of a visit or of a clause. With each visit, an AST node tries to switch state to a next black node by executing the rules on the path to such a node. Execution of all of the rules must succeed. At a branch-point, rules on edges of clauses are tried in order of appearance. Results produced by executing rules are in scope of rules further along the path.

The pattern p must match the value of the right hand side. If the evaluation of e results in an exception, or the match fails, a backtrack is made to the next clause. If p represents an attribute, the attribute gets defined.

Executes visit x of child c. The inherited attributes of x must be defined, and all prior visits to c must have been performed. The invocation may fail if no clause matches. In that case, it causes the current AST node to backtrack to the next clause. If successful, the synthesized attributes of x become available.

In this section, we describe how to translate ruler-core programs to JavaScript. We translate each semantics-block to a coroutine, implemented as one-shot contin- uations. Each call to the coroutine corresponds with a visit. The parameters of the coroutine are the inherited attributes of the visit. The result of the call is an object containing values for the synthesized attributes, and the continuation to call for the visit.

To deal with continuations, we use closures. The function to be used for the next visit, we build in the previous visit. This function has access to all the results computed in the previous visit. Furthermore, we store values for attributes in local variables. Those values that are not needed anymore, are automatically cleaned up by the garbage collector.

The above translation is relatively straightforward. In practice, the selection of a clause is functionally dependent on the value of an inherited attribute, or a local attribute computed in a previous visit. In those cases, the selection of clauses can be implemented more efficiently using conventional branching mechanisms.

We verified that the above implementation runs in time linear to the size of the tree, when we use version of the slice operation that does not make a copy of the array. With a throughput of about hundred array elements per microsecond, and about a thousand per microsecond with the exception handling replaced by conventional branching, this is still about one or two orders of magnitude slower than using a hand-written loop. In our experience, however, performance is rarely an issue. In general, the asymptotic complexity of the traversal is linear in the size of the tree, and the actual time taken by traversing the trees is insignificant compared to the work performed by the right-hand sides of the rules in a real application.

In Section 2.1, we discussed advantages and disadvantages of modeling traversals with this pattern. In particular, side effect is permitted, and used to store results for use in later visits. The side effect makes it hard to predict if results needed in a next visit are actually stored by a first visit. This is a fundamental problem of visitors. Oliveira, et al. [16], for example, show many enhancements with respect to the type safety of visitors, but do not address the transfer of results between visits. Attribute grammars [11,12] were considered to be a promising implementation

Recently, many Attribute Grammar systems arose for mainstream languages, such as Silver [25] and JastAdd [5] for Java, and UUAG [20] for Haskell. In con- trast to the work in this paper, these systems strictly discourage or even forbit the use of side effect. The design of ruler-core is inspired by the language of exe- cution plans of UUAG. In certain languages it is possible to implement AGs via meta-programming facilities, which obliviates the need of a preprocessor. Viera, et al. [22] show how to implement AGs into Haskell through type level programming. The ideas presented in this paper are orthogonal to such approaches, although the necessary dependency analysis may be difficult to express depending on the expres- siveness of the meta language.

Moreover, we presented ruler-core, a subset of ruler-front, which serves as a small core language for visitor-based Attribute Grammars. In ruler-core, the lifetime of attributes is explicit, as well as the evaluation order of rules and visits to children. A ruler-core program has a straightforward translation to many languages. In Section 4, we showed a translation to JavaScript .

Another direction of research is to allow destructive updates on attributed trees. For example, to support event-handling traversals over data structures that are dynamically changed based on user input or external events. In ruler-front, the visits performed on an attributed tree explicitly specify which attributes are defined. When we apply a destructive update to the tree, we thus know precisely what information is based upon the previous structure of the tree, which is beneficial when reasoning about mutations to the tree. Incremental evaluation of Attribute Grammars received attention in the past, and may be used to efficiently recompute attributes after an AST change.

mars, because the effects are not visible in attribute dependencies. In the Haskell version of ruler-front, the left-hand side of a rule can be a match against a data constructor. If this data constructor is a GADT, the match brings type assumptions in scope, to be used to coerce types in rules that follow. Similarly to side effect, these type assumptions are implicit. However, with ruler-front, we can explicitly schedule rules to be after such a match. This allows us to combine GADT features with Attribute Grammars. This may be sufficient to target dependently-typed pro- gramming languages, and a direction towards verified compilers using AGs.

