Our study of the Turing category computation model takes the form of building a type-theoretic formal language description (formalization) of the relevant con- cepts. The concepts we have selected to formalize lay the groundwork for (for- mally) proving abstract interpretations of standard theorems in recursion theory. The key motivation behind this approach is the level of organization, consistency, and guaranteed correctness it provides in working with proofs and definitions for which unformalized presentations may omit important and interesting details.

Turing category theory can be viewed as an (up until recently) non-formalized mathematical framework that describes a precise model of computation. As compu- tation on a physical computer is a precise procedure, it seems natural to verify that a formal description of this framework exactly fits the selected categorical model. This is the motivating idea and the main objective of this work. There is not a huge

We start from a library for general category theory developed by Timany and Jacobs [24], designed to take advantage of advanced features in Coq 8.5 such as type classes and universe polymorphism. This library successfully develops many of the basic concepts, and thus we chose to adopt the style of definitions and for- malization strategy used in this library. With this library as a starting point, we specify the mathematical definitions found in the framework of the Turing Cate- gory computation model, as well as abstract versions of other types of structures naturally occurring in the traditional computation model. We then formally prove (the abstract versions of) a number of results from traditional recursion theory.

In addition to formalizing the categorical concepts, we formalize several exam- ples of categories. These examples provide validation of our formalization approach and formalized results. They also provide a mechanism to formally study these specific example categories. Our main example is the formalization of traditional computation on the natural numbers and the categorical interpretation of all the structure found therein, illustrating that these indeed conform to the Turing cat- egory model formalism. We base our formalization of traditional recursion theory on a formalization due to Zammit [30].

Examples of restriction categories include familiar categories of partial functions (formalized in Sections 2.5 and 2.6 below) as well as the category of topological spaces and partial continuous functions with open domains. Continuous functions which preserve open sets, called open maps, have also been axiomatized abstractly and play an influential role in computer science [14]. This allows topological no- tions to be lifted to other categories and forms an important part of the theory of restriction categories [8] (see also Section 2.4 below).

A similar approach is used to define the notions of a total subcategory, trivial restriction structure, etc. [9]. For cartesian restriction structure, we formalize re- striction products and restriction-terminal objects, which are similar in structure to true products and true terminal objects. We have formalized restriction products and the restriction terminal object following closely the example of how the true products and the true terminal object are defined in the category theory library we are using. In order to define a cartesian restriction category, we build a class that takes as parameters a category, a restriction combinator in this category, partial products for all pairs of objects in the category, and the partial terminal object.

We have formalized Comp(A) and Split(Comp(A)) (the Karoubi envelope of Comp(A), i.e. the idempotent-splitting completion of the category Comp(A) [16]) as cartesian restriction categories. The resulting terms can be instantiated to give specific instances of Comp(A) and Split(Comp(A)) when supplied with arguments including the base category C, the object A : C, as well as cartesian restriction struc- ture in C (which, by our construction, will be inherited by both of the resulting categories). In the process of building these terms, we have discovered additional

The maps f^ are obviously idempotent. Open maps as presented in [14] allow an abstract characterization of ranges. For example, it is shown in [8] that a restriction category C is a range category if and only if every map is open.

The categorical concepts on which the tools we developed in (i) are based provide us with the advantage of allowing us to model both partial and total computation constructively. The tool framework itself is integrated into an existing comprehen- sive category theory Coq library, and it conforms to the structure existing therein. Such a formal development enhances the traditional study of abstract compu- tation by introducing structural and hierarchical integrity and making precise all definitions. Furthermore, building our tools as an extension of an existing library facilitates future research on the topic by using and building on the categorical

While most of the formal results we have proved confirm what has already been shown in the literature, formalization also gives us the ability to find omissions in the definitions, proofs and propositions. For example, in the process of formalizing a result about ranges in Turing categories, we saw that we were not able to directly express the result in terms of range structure, and had to instead formulate and prove a very closely related result in terms of open maps (see Section 2.4).

The most noteworthy result we have formalized is the constructive version of the category of sets of the form Nn and partial recursive maps between them, which is meant to categorically represent traditional computation. This has not previously been done. Through our work, we have gained an understanding (as well as formal constructions) of the additional results, concepts and machinery that are needed to build such a category. In the process of building this category in the formal sense, we have also encountered several proofs whose completion necessitated the use of specific versions of the Axiom of Choice, as mentioned earlier.

tegrated way than the Coq development. The Lean system has two modes, the proof irrelevant mode (which is incompatible with homotopy type theory), and the homotopy type theory mode. This system is another option to consider for future work on formalizing categorical examples of abstract computation.

