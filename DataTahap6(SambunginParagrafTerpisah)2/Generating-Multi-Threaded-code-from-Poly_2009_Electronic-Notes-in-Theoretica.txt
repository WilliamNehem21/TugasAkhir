In the last few years, parallel processing has claimed its niche in improving perfor- mance and power trade-off [12] for general purpose computing. So, it is no surprise that multi-core architectures will make inroads into the embedded processor mar- kets as well. Currently, major processor vendors have already released products containing multiple cores on a single die [11], however, one must employ concurrent programming models when designing their programs to exploit the architecture with multiple cores in such products. One such programming model, and one that most designers are familiar with, is the multi-threaded programming model.

A recent enhancement of the SIGNAL compiler generates multi-threaded code with tight synchronization between atomically executing threads. We find this a valuable step towards managing concurrency, but multi-threading if not judiciously employed has severe performance drawbacks due to the usage of too many threads resulting in high context switching overheads. The current SIGNAL compiler, in our opinion, performs micro-threading that generates C programs with an unnecessary number of threads in relation to the parallel computation. We illustrate this with the following pseudo SIGNAL code example:

In this section we outline a few relevant related works on concurrent code generation from concurrent specification of computation. We discuss some of the Models of Computation (MoC) used to express concurrency between processes. Other than that, we reemphasize some of the issues we have with existing synchronous pro- gramming languages based multi-threading implementations.

Kahn process networks (KPN) [13] is a primary specification formalism for dataflow between processes. KPN model has been proposed to capture concurrent processes in a system. In a KPN, the processes (nodes) communicate by unbounded unidirectional FIFO channels (arcs), with the property of non-blocking writes and blocking reads on channels. A KPN model when transformed to implementation level faces problems related to buffer sizing. Several scheduling algorithms have been proposed for estimating the buffer sizes for KPN models and for validating their correct behavior [9,18]. Another MoC which closely resembles KPN model is dataflow networks [16]. Here the nodes represent actors which when fired takes in a finite number of tokens and put out another finite number of tokens. In contrast with KPN, this MoC can calculate the buffer size with respect to the number of computations in the network.

Many tools have been developed based on these various dataflow models. Simulink is an environment for multi-domain simulation and model-based design for dynamic and embedded systems [20]. Simulink has a Stateflow coder that gen- erates highly readable code which can be easily traced back to the Stateflow chart. Recently, a method for multi-threaded code generation from Simulink models with reduction of thread communication overhead was proposed [6]. This work is sim- ilar to our current methodology in the sense that they also concentrate on larger granularity for threads to reduce overhead of thread synchronizations. Lustre [10] is a declarative synchronous dataflow language used for describing reactive sys- tems. Esterel [5] is an imperative language for describing control. It consists of

Supervisor and Monitor entities. The Supervisor is responsible for reacting to the major functions of flight control such as computing possible next coordinates to move to. The Monitor on the other hand only focuses on maintaining the elevation of the STARMAC testbed by proposing adjustments to the elevation when below a certain threshold. Labels X, Y , and Z represent the x, y and z coordinates of the STARMAC and the in and out suffixes the respective inputs and outputs from this supervisory control unit. Zm is the allowable minimum elevation for a particular rotor.

In the current strategy, the programmer is kept away from decisions regarding the number of threads and how they should be grouped. In order to utilize multi-core architectures, it is important for the programmer to be aware of the implementation level details, so that he can tailor it according to the hardware resources available to him. Therefore, we suggest an alternative multi-threading solution that may be inferred from the SIGNAL specification, which uses only two threads for the STARMAC example.

