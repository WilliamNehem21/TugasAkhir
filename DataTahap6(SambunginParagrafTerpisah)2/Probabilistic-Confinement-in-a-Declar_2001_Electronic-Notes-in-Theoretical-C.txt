We show how to formulate and analyse some security notions in the context of declarative programming. We concentrate on a particular class of security proper- ties, namely the so-called confinement properties. Our reference language is con- current constraint programming. We use a probabilistic version of this language (PCCP) to highlight via simple program examples the difference between proba- bilistic and nondeterministic confinement. The different role played by variables in imperative and constraint programming hinders a direct translation of the notion of confinement into our declarative setting. Therefore, we introduce the notion of identity confinement which is more appropriate for constraint languages. Finally, we present an approximating probabilistic semantics which can be used as a base for the analysis of confinement properties, and show its correctness with respect to the operational semantics of PCCP.

Previous approaches,notably the work by Volpano and Smith [19,17] and by Sands and Sabelfeld [14,13], consider imperative programming languages. Our choice of a declarative language, and in particular the PCCP language, is essentially motivated by the availability of a simple and mathematically sound semantics for this language which forms a base on which a systematic design of program analysis can be developed. In fact, the ultimate aim of this research is the development of a methodology for a probabilistic security analysis of (probabilistic) programs which resembles the classical program analysis methods [12].

For example,a computer operating system might try to protect certain user information,e.g. passwords,etc. (high level information),from being accessed by some applications,e.g. spreadsheets,browsers,etc (low level applications), though it might well allow these applications (the low level) access to other data, e.g. the system time, etc. If the low level applications are unable to access this high level information,e.g. the password of a user,we can say that

It is important to notice that nondeterministic confinement is somehow weaker than probabilistic confinement, as it is not able to capture those sit- uations in which the probabilistic nature of an implementation may allow for the detection of the confidential information, e.g. by running the program a sufficient number of times [9]. In the context of imperative programming lan- guages,confinement properties with respect to the value of high and low level variables,have been recently discussed in [17,20,18] where a type-system based security analysis is developed. Another recent contribution to this problem is the work in [13,14], where the use of probabilistic power-domains is proposed, which allows for a compositional specification of the non-interference property underlying a type-based security analysis.

We will adopt a control-flow analysis approach. In Section 4 an abstract specification of this analysis is defined by considering only those elements of the transitions occurring in an execution of the program which contain information essential for detecting the violation of the confinement property. The analysis is then proved to be safe with respect to the semantics of the language (cf. Section 5).

The syntax and the basic execution model of PCCP are very similar to CCP. Both languages are based on the notion of a generic constraint system C, defined as a cylindric algebraic complete partial order (see [16,2] for more details), which encodes the information ordering. In PCCP probability is in- troduced via a probabilistic choice which replaces the nondeterministic choice of CCP,and a form of probabilistic parallelism,which replaces the pure non- determinism in the interleaving semantics of CCP by introducing priorities. In the following we recall the syntax and the basic operational model of PCCP agents.

Rule 1 describes the effect of , (c). This agent always terminates successfully with probability one,and the new store is the least upper bound of the constraint c and the current store d, i.e. c H d. Note that the agent s  o represents successful termination and is used to distinguish success from other forms of termination, e.g. deadlock (no guard is enabled) or in general situations in which agents get stuck.

We observe that this operation may not always result in a probability distribution when infinite computations are involved. In particular, this may happen when the derivation tree has infinitely many infinite branches. This case needs a more complicated, measure-theoretical treatment which we will not develop here as it is not essential for the purposes of this paper.

Note that this notion of observables differs from the classical notion of input/output behaviour in CCP. In the classical case a constraint c belongs to the input/output observables of a given agent A if at least one path leads from the initial store d to the final result c. In the probabilistic case we have to consider all possible paths leading to the same result c and combine the associated probabilities.

A more general notion of computational path can be defined which cor- responds to a computation starting from any store c and not necessarily the empty one. Given an agent A we will denote by Comp(A, c) the set of all general computational paths starting from store c. Of course, Comp(A) cor- respond exactly to Comp(A, true).

Our aim is to develop a framework for analysing confinement properties of PCCP programs. Our analysis intends to construct the set of all possible transitions for the program in order to detect different behavioural structures of agents which will eventually allow us to reveal their identity. For this anal- ysis we abstract the full semantics in as far as we ignore the concrete agents involved in each computational step, and only record possible transitions be- tween stores (constraints) together with their probabilities.

Very often it is possible to reconstruct the full semantics from this approx- imated semantics by considering maximal paths. Intuitively, a maximal path is a path which starting from the initial transition in the store true goes as deep in the graph as possible. Formally this notion can be defined as follows.

