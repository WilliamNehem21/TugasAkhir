(iii) the use of recursive procedures; (iv) the use of primitives such as spawn that al- low the dynamic creation of parallel processes; and (v) the synchronisation between parallel processes. Ramalingam [20] showed that as soon as synchronisation and procedure calls are taken into account, the reachability problem (even of a single control point) is undecidable for programs. Due to this undecidability, to analyse software, we need to find general semi-algorithms that are not guaranteed to ter- minate in general, but that behave well and terminate in the most practical cases [4,18,9].

We propose a class of rewriting systems that can be used to model multi- threaded recursive programs with integer variables. The idea is to use terms to represent integers (e.g. the term s(s(s)) represents the integer 3) as well as the control structure of the program; and term rewriting systems to represent the dynamics of the program.

We implemented our techniques in a tool prototype based on MAUDE [10]. We applied our tool to different case studies. We obtained encouraging results. In particular, we were able to find automatically two bugs in two different versions of a Windows NT Bluetooth driver. These bugs were already found in SPADE [17]. The novelty of our approach w.r.t. SPADE is that it allows to model explicitely the integer variables of the program, whereas in SPADE, a pushdown stack was needed to encode the values of the variables.

Related Work. Abstract-interpretation techniques [7] have been used to deal with data ranging over unbounded domains. More recently, automated predicate- abstraction techniques [14] have been proposed to deal with this issue [3,16,8]. In contrast to predicate abstraction where the exact value of the variables are ab- stracted away, our modeling remains precise for integer variables. We can use predicate abstraction to deal with the other non integer variables of the program.

where i is in {1,... , k} and n is the control point of the program corresponding to this instruction. We suppose that c /= 0. (the other cases can be treated similarly). Let tc be the term in Nat that represents the value c (tc is the term s(s(s)) if c is 3). Intuitively, this assignment can be represented by the following rule:

where x1,... , xk are term variables that represent the values of the local variables a1,... , ak. However, to make sure that this rule cannot be applied anywhere in the term, and that it can be applied only to the points n that are on the top of the stack, we need to represent it by these two rules:

This rule expresses that when the procedure P is called, its entry point eP is put on the top of the stack and its local variables are initially all set to 0. When this procedure terminates, the control goes back to point n2. There is a similar rule that corresponds to the case where x is empty, i.e., to the case where n1 is the only control point in the stack.

The BlueTooth v1 is our model of the BlueTooth driver program used by Win- dows NT and given in [19]. The BlueTooth v2 is a corrected version of BlueTooth v1 proposed by the authors of [19]. We were able to find two bugs in these pro- grams. SPADE [17] found these bugs as well, however, the SPADE model of these versions encodes the values of the integer variables in the stack of a pushdown sys- tem, whereas with our new model, the integer variables ar explicitely and accurately represented. As far as we know, this is the first time that the integer variables of these programs are explicitely modeled.

