Spartacus decides the satisfiability problem for H(E, @), the basic hybrid logic ex- tended with global modalities. Notationally, our description of H(E, @) follows [21]. We distinguish between variables for states (x, y), properties (p, q), and relations (r). From these variables, the expressions of H(E, @) can be obtained by the following grammar:

Every time we want to apply R to a formula sx, we need to check if Pxs is expanded. Instead of computing this information from the branch we use a special data structure, called the pattern store, to record and query which patterns are expanded. The pattern store contains all patterns that are known to be expanded because of previous diamond rule applications. Whenever R is applied to a formula sx, the pattern Pxs is added to the pattern store. When checking if R  applies to a formula sx, we have to check if the pattern store contains a superset of Pxs. The efficiency of this operation, called subset matching following [9], is crucial for the performance of PBB.

The implementation of PBB in Spartacus is inspired by modal caching tech- niques, in particular the one described by Giunchiglia and Tacchella [9]. In fact, the sets of expressions that are considered in [9] are nothing other than patterns, and the satisfiability cache of [9] provides exactly the kind of storage and lookup op- erations that are also necessary for PBB. So how does PBB differ from satisfiability caching in [9]? While PBB subsumes satisfiability caching, the converse is not true. In particular, the system of [9] does not terminate in the presence of transitivity or global modalities and hence needs to be complemented by a blocking technique. To retain completeness in the presence of blocking, however, satisfiability caching needs to be refined considerably [13].

Compared to lazy unfolding, LB is more general in that it is applicable in more cases. On the other hand, in cases where both techniques apply, lazy unfolding is likely to be more effective. This is because, rather than restricting the processing of delayed disjunctions, it does not generate such disjunctions in the first place.

LB for propositional literals and boxes is implemented as an additional layer on top of the rule application queue. While conventional rule application heuristics (as in [30]) influence the position of a pending rule application in the queue, LB prevents disjunctions from being added to the queue as long as they are delayed. This allows LB to work independently of the conventional rule application strategy.

All provers are compiled and run with the default settings. Unfortunately, we were not able to include into the comparison the prover DLP [27], reportedly one of the fastest provers for K. The reason is that DLP relies on an outdated version of the SML/NJ compiler that we were not able to install on our test machine. To get an impression of the performance of DLP, refer to [28,7].

