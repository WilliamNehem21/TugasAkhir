Rewriting arbitrary propositional formulae to conjunctive normal form (CNF) yields a worst-case exponential blowup in formula size if the number of propo- sitional variables is to be preserved. To avoid this, all practical verification environments take advantage of satisfiability-preserving transformations that yield linear-size encodings through introduction of a linear number of auxil- iary variables [27,25,28]. The price for introducing a linear number of auxil- iary variables is, however, a worst-case exponential blow-up in the size of the search tree upon backtrack search. Yet, it has been observed that both causes of blow-up can often be avoided, as the Davis-Putnam-Loveland-Logemann search procedure for satisfying valuations generalizes smoothly to zero-one linear constraint systems (ZOLCS), which are the constraint parts of zero-one linear programs [7,29,2,16]. Zero-one linear constraint systems are expressive enough to facilitate a linear-size encoding of, e.g., gate-level netlists without use of auxiliary variables.

There are various ways of doing this, all with specific strengths and weak- nesses. Yet all the reasonable ones share the property of featuring a plethora of structurally similar sub-formulae stemming from the iterated application of the transition relation and from the iterated continuous evolution in the k-fold unrolling. In order to exemplify this, we present here one particular form of such an unrolling which is very similar to the one used by Audemard et al. for MathSAT-based BMC of linear hybrid automata [4] and by Bemporad et al. for MILP-based BMC of linear hybrid automata [8].

Like all pure backtracking algorithms, the classical DPLL procedure suffers from thrashing, i.e. repeated failure due to the same reason. To overcome this problem, modern SAT solvers implement a technique called conflict-driven learning [31], which attempts to derive sufficiently general reasons for con- flicts being encountered and stores them for future guidance of the search. The standard scheme traces the reason back to a small (ideally minimal) number of assignments that triggered the particular conflict, and stores this reason by adding the negation of that assignment as as clause, termed con- flict clause, to the clause database. Besides learning, state-of-the-art SAT solvers, as the one being integrated in HySat, enhance the basic DPLL pro- cedure by sophisticated heuristics for selecting the assignment performed at decision steps [22,24], and add various algorithmic refinements, among them non-chronological backtracking [23,24], random restarts [5] and lazy clause evaluation [24], to accelerate the proof search.

After each deduction phase in which no Boolean conflict was encountered, the SAT solver checks if new constraints have been added to the linear pro- gramm since its last evaluation. If so, the linear programming routine is called to decide the feasibility of the set of constraints residing in its database. If the linear program turns out to be inconsistent, a conflict is reported to the SAT solver. Otherwise the SAT solver can proceed with the next decision step.

Note, however, that BMC is not fully symmetric because of the initializa- tion properties of runs (clause (v) of the translation scheme of section 3) and perhaps the verification goal. This implies that only conflict clauses inferred from facts which are independent from such asymmetric formula parts may be soundly replicated. Such dependency can be traced cheaply by marking initialization/goal predicates and dominantly inheriting such marks upon all inferences, inhibiting isomorphy inference whenever a mark is encountered.

When carrying out BMC incrementally for longer and longer unrollings, the consecutive formulae passed to the solver share a large number of clauses. Thus, when moving from the k-instance to the (k + 1)-instance, we can simply conjoin the conflict clauses derived when solving k-instance to the formula for step k + 1. However, this is only allowed for conflict clauses that were inferred from clauses which are common to both instances. We do currently decide this based on simple syntactic criteria, namely that the conflict clause was inferred purely from clauses stemming from the automaton. I.e. the inference may not involve the verification goal, which tends to become a weaker predicate on longer instances, as it usually entails reachability or recurrence. More elaborate schemes have, however, been investigated for propositional BMC in [21].

