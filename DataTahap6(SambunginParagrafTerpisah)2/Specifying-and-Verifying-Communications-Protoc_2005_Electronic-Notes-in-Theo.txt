In the following sections we briefly describe IP and TCP and mixed intu- itionistic linear logic. We then present an outline of our specification of the user interfaces for IP and TCP, demonstrating the role of the linear operators in the axioms. We present a specification of the data transfer component of the TCP protocol; and finally, we outline verification process undertaken to prove key properties of IP and TCP.

The Transmission Control Protocol (TCP) and the Internet Protocol (IP) are two essential elements of the communications stack at the heart of many network-based applications. Both of these protocols are typical of state-based distributed systems. IP is responsible for transmitting data from one internet node to another, but does not guarantee the delivery of data to the destination node. TCP is a protocol that sits on top of IP and it has the responsibility of establishing an end-to-end error free connection between peer TCP entities.

The basis of our specification consists of a series of axioms, presented using the linear operators, which specify the valid transitions that can take place in the system. For IP we use ordinary commutative linear logic, since IP datagrams may be reordered in transmission. However, since order of receipt is important for TCP, we make use of a combination of commutative and non-commutative operators in its specification.

d. The variable b is a boolean flag which is false once an end of stream (EOS) character is written to the stream. A full TCP session will thus consists of a pair of these streams, one each for s and d.

Axiom (6) specifies the operation of reading some data at d, which transfers exactly l octets from m1 to m2. The function drop(n, l) returns a list with n elements removed from the beginning of list l. The function take(n, l) returns a list of the first n elements from list l.

The IP specification guarantees very little about a message sent from one node to another, since messages may be corrupted, duplicated or even lost. However little the IP specification guarantees, it does imply that a message that arrives at a node must have been created at some node. If a node receives a message with a correct header - as validated by the checksum - then some node must have sent a message with the same header (the actual message itself may be corrupted, of course). In fact, if the initial datagram is not lost, a message sent from node A to node B may result in one or more multiple messages, with correct header, being received by node B. These messages will not appear out of mid-air.

