broad range of implementations. For example, MOP admits implementations that are out-of-order or not, speculative or not, superscalar or not, etc. This approach allows us to separate the implementation-independent proof obligations that relate ISA to MOP from those that rely upon the details of the MA. This can potentially amortize some of the proof effort over several different designs.

The rules pc update and speculate govern the program counter updating. The first is based on the next pc value of the last parcel and implements the regular ISA flow. The second implements practically unconstrained speculative updating of the program counter, specified by an arbitrary branch predict function.

about 400 goals, which are individually proved with CVC Lite. For MA we used the textbook DLX model [9] and proved it is simulated in MOP by constructing the chains (1) and verifying them with CVC Lite. This proof is sketched in some detail below.

(1) parcel p4 writes back and retires; (2) p3 performs memory access; (3) alu computes the result of p2 or the address for its memory access; (4) p1 receives data from the register file or by forwarding, and if it a branch, its target is computed as well as whether the branch is taken or not; (5) a new parcel p' is fetched and pc is incremented. (b) If p1 is a taken branch, action (4) is modified to include updating the pc with the computed target (becoming action (6) in the picture), and no parcels are fetched. (c) The machine stalls one cycle if p2 is a load and p1 depends on it.

Shen and Arvind [15] were first to prove an example of Burch-Dill correctness using the flushing function defined as the normal form in a confluent system. They model an abstract out-of-order processor and a simple specification machine as term rewriting systems. Their implementation model is similar to our intermediate specification MOP , and its Burch-Dill correctness against the specification ISA is the main result of [15]. We go a step further by proving stuttering bisimulation. Also, MOP is for us only an intermediate model that, in turn, allows us to reason about deterministic and more realistic implementations.

As an example, we specified a concrete intermediate model MOP for a simple load-store architecture and proved its correctness. We also verified the textbook machine DLX against it. However, our MOP contains more than is needed for verifying DLX : it is designed for simulation of microprocessor models with complex out-of-order execution that cannot be handled by currently-available methods. This will be addressed in future work. Also left for future work are improvements to our methodology (manual decomposition of verification goals into subgoals which we prove with CVC Lite [4]) and performance comparison with other published methods.

