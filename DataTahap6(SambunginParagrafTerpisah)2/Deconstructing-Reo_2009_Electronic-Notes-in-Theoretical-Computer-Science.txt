Coordination in Reo emerges from the composition of the behavioural constraints of the primitives, such as channels, in a component connector. Understanding and implementing Reo, however, has been challenging due to interaction of the channel metaphor, which is an inherently local notion, and the non-local nature of constraint propagation imposed by composition. In this paper, the channel metaphor takes a back seat, and we focus on the behavioural constraints imposed by the composition of primitives, and phrase the semantics of Reo as a constraint satisfaction problem. Not only does this provide a clear intensional description of the behaviour of Reo connectors in terms of synchronisation and data flow constraints, it also paves the way for new implementation techniques based on constraint propagation and satisfaction. In fact, decomposing Reo into constraints provides a new computational model for connectors, which we extend to model interaction with an unknown external world beyond what is currently possible in Reo.

Reo is generally presented as a channel-based coordination language wherein component connectors are compositionally constructed out of primitives, which are typically 2-ended channels. 4 The behaviour of connectors are described in terms of the constraints imposed by the channels and their composition, in terms of three of kinds of constraints: (1) data is accepted on an input channel end if by accepting it the channel can satisfy its behavioural constraints; (2) data is offered by an output channel end if by offering the data the channel can satisfy its behavioural constraints; and (3) nodes connecting the channel ends (1:1, in the direction of data flow) must pass on any data they receive, that is, data offered by one channel end must be accepted by the other. This is all achieved under the restriction that the only communication between entities occurs though the channels.

Constraint automata [8] and connector colouring [9] provide the basis for both semantic models and implementations, as well as for model checking and visualisa- tion tools for Reo. Constraint automata provide the semantics of each primitive and composition in Reo, by representing the synchronisation possible in a connector, along with a description of the data flow, in an automata-based model. The actual constraints are based on the state of the primitives, and transitions in the automa- ton correspond to data flow in the connector. Connector colouring is based on the simple idea that ends where data flows and data does not flow in a connector can be coloured with different colours. Each primitive has a set of possible colourings describing its possible behaviours. The semantics of a connector is determined by plugging together the colourings of the primitives in such a way that the colours match, meaning that data flow into a node is the same as the flow out of the node.

Challenge 3: Limited support for external primitives Research on Reo fo- cusses exclusively on the connectors, without much consideration on the inter- action with the unknown outside world. Indeed, constraint automata models preclude any external primitives. Primitives of interest may include data trans- formers or filters whose details are externally computed.

In this paper, we address these challenges by adopting a different view of Reo. The channel/circuit-view of a Reo connector becomes a mere metaphor. Instead, a Reo connector is seen as a set of constraints, based on the way the primitives are connected together, and their current state, governing the possible synchronisation and data flow at the channel ends connected to external entities.

This paper is organised as follows. We elaborate on Reo in Section 2 using an example. Section 3 describes our encoding of Reo-style coordination as a constraint satisfaction problem. Section 4 describes an extension of this encoding to incorpo- rate state, so that connector semantics can be completely internalised as constraints. Section 5 presents the main contribution of the paper, namely, a reformulation of Reo as iterative and interactive constraint satisfaction. Section 6 and 7 present related work and our conclusions.

FIFOEmpty1 and FIFOFull(d)1 FIFO1 is a stateful channel representing a buffer of size 1. When the buffer is empty it can only receive data on a, but never output data on b. When it is full with data d it can only output d through b, but cannot receive more data on a.

The assumption made thus far is that all state information for a primitive is known in advance. In this case, there is no need to actually supply an implemen- tation of the primitives, as they are redundant. This is already the case with the constraint automata-based implementation of Yeo [3].

on ends a and b are passed to the primitive p. In addition, the primitive may use the uninterpreted function symbol res to encode information to guide its external activity. Note that this encoding and way of interacting with primitives means that data is not passed through the channel ends, but to the primitive directly.

Here the engine asks the primitive to evaluate the function fp with arguments t1,..., tn, and the primitive returns result tres. External predicates are evaluated in a similar fashion. For consistency, we assume that primitive p returns the same answer to each call of fp or Pp with the same arguments. This interaction with the primitive does not cause the primitive to change state, as this is achieved using the mechanism described in the previous section.

The timed concurrent constraint (tcc) programming framework [15] was intro- duced by Saraswat et al. to integrate the concurrent constraint (cc) programming paradigm [13] with synchronous languages. Time units are rounds, all the con- straints are updated in each round, as ours are, whereas inside each round the constraints are computed to quiescence. cc programs are compiled into a con- straint automata model, where states are cc programs and transitions represent evolution within a round while solving the constraints. In contrast, transitions in the constraint automata model for Yeo describe the evolution between rounds. Furthermore, the tcc approach avoids non-determinism as it targets synchronous languages, whilst Yeo, as a coordination language, embraces non-determinism.

The constraint-based approach offers the possibility of using existing research and tools to develop an efficient implementation of Yeo. Constraints also provide a flexible framework, so it may be possible in the future to mix-in other constraint based notions, such as service-level agreements. Future work will explore these directions, in particular, the increased expressiveness. We will also try to exploit the parallelism inherent in constraints.

