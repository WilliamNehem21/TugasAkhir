In previous work we have developed an effective rewrite system for specialization and optimization of generic programs. In this paper we extend it to also cover recursive data types. The key idea is to specialize traversal combinators using well-known recursion patterns, such as folds or paramorphisms. These are ruled by a rich set of algebraic laws that enable aggressive optimizations. We present a type-safe encoding of this rewrite system in Haskell, based on recent language extensions such as type-indexed type families.

Unfortunately, the obvious advantages provided by this style of generic pro- gramming come at a price: the performance of generic functions is much worse than analogous non-generic ones. In [18], the SYB implementation of a standard set of benchmark functions was reported to run 7 times slower in average than the non-generic implementation. Part of this performance loss is due to the run-time checks needed to determine at each node whether to apply specific or generic be- havior. The remaining is due to structural reasons inherent to this style of generic programming: the traversal combinators must blindly traverse the whole data struc- ture, even if a certain branch does not mention types where the specific behavior applies.

Some new SYB-like generic programming libraries have been proposed to address this efficiency problem. According to a recent survey [20], two of the most efficient are Uniplate [18] and Smash [11]. The former outperforms SYB by restricting the power of the traversal combinators. The latter offsets some of the run-time checks to compile-time, but needs extra work from the programmer in order to support new data types.

In previous work [7], we have taken a different approach to tackle this problem: we developed a rewrite system that specializes generic functions for specific types. This specialization proceeds in two phases: (1) the generic functions are specialized to non-optimized point-free definitions; (2) these definitions are then optimized using standard algebraic laws for point-free combinators. The major drawback of that approach was the lack of support for user defined recursive types, such as the Company type above.

The major contribution of this paper is to extend that specialization mechanism to also cover recursive data types. More specifically, we will focus on inductive data types that can be defined as fixpoints of functors. The key idea is to special- ize traversal combinators using well-known recursion patterns for inductive types, such as folds or paramorphisms. Likewise to standard point-free combinators, these recursion patterns are also characterized by a rich set of algebraic laws that en- able further optimizations after specialization. Most of the definitions that result from the new rewrite system have runtimes close to the hand-written non-generic ones. Another contribution is the Haskell encoding of these new laws: thanks to recent language extensions such as type-indexed type families, we managed to get an implementation that closely mimics the theory.

The key to avoid infinite expansions is to specialize traversal combinators using an alternative definition based on standard recursion patterns such as folds. Likewise to point-free combinators, these recursion patterns are characterized by powerful algebraic laws, that will enable us to optimize the specialized definitions. For a comprehensive presentation of most standard recursion patterns and the respective laws see [17].

In order to overcome this problem, we decided to represent functors using type- indexed type families [21,3], a new extension to the Haskell type system already supported in GHC. Developed with type-level programming in mind, type families are type constructors that represent sets of types. Set members are aggregated according to the type parameters passed to the type family constructor, called type indices: family constructors can have different representation types for different type indices. A type family to represent functors can defined as follows.

The first example is the generic transformation to increase all salaries. In order to increase the readability of the specialized point-free definitions, we will consider that the type-specific behavior is for the Employee type instead of Salary . In SYB we have the following definition.

Unlike systems specially designed to implement fusion (such as [23]), our rewrite system cannot implement the full power of the fusion laws. However it covers most of the particular instances that occur during the specialization of generic functions. For example, the above optimization was possible due to the following instance of fusion-Cata.

As expected, for both examples, the SYB generic definitions perform much worse than the hand-written, and the loss factor grows with the database size. The SYB GADT variant is at least twice as fast, but still much slower than the hand-written. The specialized point-free definitions perform closer to the hand-written, with loss factors of 1.11 (increase 100) and 2.85 (salaries) for the biggest sample. This per- formance loss is mainly due to the use of in and out to convert between user defined types and they structural representation as a sum of products. For these particular examples, the performance of the specialized point-free code is tangentially better than Uniplate. As discussed in the next section, Uniplate also has some mechanisms to avoid traversing unnecessary branches, which justify the proximity in the results. Although quite standard when comparing generic programming libraries, these example are not particularly flattering to our optimization mechanism: in fact, there are no large branches of data that can be avoided in the traversals. For example, if the Company data type had any other information besides departments (not con- taining the type Salary ), the runtime would remain the same, further widening the gap to SYB. We also achieve a significant advantage when optimizing compositions of generic functions: for example, in the higher salaries example our specialized point-free definition was already 1.35 times faster than Uniplate for the biggest

Unlike SYB, some generic programming libraries have been designed with per- formance issues in mind, usually at the cost of expressiveness. One such library is Uniplate [18], that is among the fastest libraries currently available for generic programming in Haskell [20]. That fact, together with the SYB-like flavor of its com- binators, motivated an obvious inclusion in the comparative performance analysis of the previous section. The key idea behind Uniplate is that most generic traversals have value-specific behavior for just one type. Building on this insight, this library provides two key combinators to specify bottom-up generic transformations:

The main advantage of Uniplate is that generic functions execute fast out of the box, without the need of an explicit optimization phase. On the other hand, likewise to SYB, our optimization technique can handle more powerful combinators, that target different types in a single traversal. Using fusion techniques, our approach can also further optimize combinations of traversals, while Uniplate speedups are constrained to individual traversals.

Another very efficient SYB-like generic programming library is Smash [11]. In- stead of using run-time checks to find the target types, it offsets them to compile- time by using heterogeneous collections [12] to encode the type-specific cases of generic functions. Unfortunately, the speedup obtained with this technique comes at the cost of extra work from the programmer: in order to support a new data type, all different traversal combinators must be defined from scratch, while in SYB they can all be generically implemented using just two primitive methods.

A different approach has been followed in [1], where a technique named symbolic evaluation was developed to optimize Generic Haskell programs [15]. It focus on the specialization of fully applied functions and tries to eliminate conversions between types and their structural representations. Symbolic evaluation guarantees that the intermediate structures are completely removed from the optimized code. A similar technique could be used in our framework to further optimize the point-free definitions, via an additional translation step to explicitly recursive point-wise code.

As previously mentioned, our main goal was to extend the specialization mech- anism presented in [7] to also cover inductive types. In [7] we already described how it could be used to optimize the structure-shy XPath query language. This technique was harnessed into the prototype schema-aware XPath compiler XPTO [8]. Query compilation in XPTO proceeds as follows: the XML Schema is parsed into a sum of products representation using Type a; the XPath query is parsed into a type-safe representation of type PF a; the rewrite system is used to specialize the query to the given schema; the specialized point-free definition is output into a new Haskell program to be compiled and linked with an XML parser and point-free execution library; the resulting program can then be used to execute the original query against XML files conforming to the given schema. We are currently deploy- ing the new technique presented here into the XPTO compiler in order to handle

We have extended an existent mechanism to specialize SYB-like generic functions to also cover user defined recursive data types. By focusing on inductive types (fixpoints of functors) we were able to use recursion patterns such as folds and paramorphisms to encode generic traversals. These recursion patterns are charac- terized by nice algebraic laws, that were incorporated in a type-safe rewrite system to further optimize the specialized code. The definitions produced by our specializa- tion mechanism perform close to hand-written non-generic ones. Thanks to recent extensions of the Haskell type-system, such as type-indexed type families or general- ized algebraic data types, our implementation of the rewrite system closely mimics the theoretical presentation.

The major limitation of the current approach is that it only supports single- recursive inductive types. We are currently investigating how to extend it to cover more general forms of recursion, such as mutually-inductive data types or nested data types. Particularly relevant to this endeavor is the work described in [10], showing that higher-order functors can be used to give an initial algebra semantics to nested data types (likewise to standard inductive types).

