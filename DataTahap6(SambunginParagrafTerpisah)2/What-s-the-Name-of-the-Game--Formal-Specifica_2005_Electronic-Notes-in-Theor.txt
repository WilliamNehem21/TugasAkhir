Game playing is one of the oldest areas of research in Artificial Intelligence. The first studied games were board games, like chess. In the past years, re- search evolved to cover multi-agent games with sophisticated agent interaction, including simulation of human behaviour.

Some modern FPS games have extensible AI. For example, Half-Life [18] offers a bot kit using C++ as the programming language. Some games, al- though classified as entertainment, have only programmable bots and no hu- man player. One example is AI Wars [20], with a programming language mix- ing specialized commands with basic programming resources. The Robocode project [13] implements a robotic battletank. The behaviour of the bots is defined using the Java programming language.

The Gamebots project [1,11] has been designed for education and research in artificial intelligence. It has created a test-bed for multi-agent systems using an extension for the commercial Unreal Tournament game engine [7]. Unlike other extensible AI games, Gamebots does not define a single benchmark task. The wide variety of predefined tasks and environments can be extended in various ways, using a C++-based scripting language called UnrealScript [25]. Communication between the game server and bots are done via sockets, so bots can be programmed in different languages. Examples using Java and Soar [21] are available.

Our work is similar to Gamebots, in the sense that the proposed games have no predefined tasks. But our approach is much more general, since we can define any kind of game. The proposed games are not restricted to a predefined environment or style. In the Gamebots project, games can be extended and even new games created, using Unreal Script, but in a limited way. And in order to understand the rules of the proposed game, it is necessary to know the script language, which was not designed to be a good formal specification method. We believe that Abstract State Machines are a very elegant solution for this problem. The semantics of the rules are clear as long as they are where v is a variable, U is a finite universe and R0 is a rule. An instance of rule R0 is created for each element belonging to universe U , associating the variable v to each of these elements. Then, all rules are executed in parallel.

To execute the transition rule of a module, it is necessary to dynamically create an agent based on this module. The exception is the Main module, for which an agent is automatically defined. When an agent executes the transition rule of a module, the function name self is interpreted as the current agent.

There is also a special kind of action designated loop action. In this case, the transition rule of the action is repeatedly executed until a return command is executed. But a call to a loop action has the same semantics of a call to a simple, non-loop action: all updates are collected and fired in parallel, affecting only the next state of the run.

the game, and programs created by users, simulating the behaviour of com- petitors. In this section, we discuss these programs and other components of a multi-agent artificial intelligence game in detail. It is important to understand the relationship between these components before we present the framework we have built, in Section 6.

Two or more bots may be running the same program code. In this case, they will present the same behaviour. A bot may update several objects, and an object may be updated concurrently by several bots. When there is just one internal bot in the system, objects have a centralized control. In Robocode [13], for example, the environment is controlled by a single agent, responsible also for producing visual representation. When objects are updated by differ- ent internal bots, the rules of the game are defined by a distributed program. This multi-agent definition for the environment is used in the framework pre- sented in Section 6, and represents a more general approach than the one adopted in systems like Robocode. No assumption is made for the relative execution speed of internal and user bot programs.

To better illustrate the concepts presented in Section 5.1, we now show a simple example that uses all the main components of a general multi-agent artificial intelligence game. The example involves a game designated as the snake game, which is also used in the following sections.

User bots may control the snake actions indirectly, changing their direction of movement. If two snakes have the same behaviour, they may be controlled by user bots that run the same program code. But each snake may be con- trolled by a single user bot.

agent has the chance to proceed. But sometimes it is interesting to define a more restrictive order of execution. For example, consider the snake game of Section 5.2. A special internal agent produces a visual representation for the environment. Every time an internal bot executes a move on a snake, a visual change should be produced. In order to create good animation, the agent that provides visual representation should be executed immediately after the execution of any other internal bot of the system.

all internal bots that move the snakes (all agents of the system, except exib and the user bots). Lines 4-9 choose, non-deterministically, an agent from the nextAgents set. This agent is activated, removed from the nextAgents set and defined as the current active agent. Lines 11-12 will only be executed after curAg has executed its transition rule, when it is automatically deactivated. Then, agent exib is activated to show the possible changes produced by curAg. Line 14 will only be executed after exib has executed its transition rule. A new agent is selected from the nextAgents set, in lines 4-9, until this set becomes empty. Then the process starts again in lines 1-3 with the set of all bots, except agent exib. Rules of lines 16-18 assures that all user bots will always be active, so the transition rules of the user bots may be executed at any time.

The execution order of agents may be programmed directly in the code of the internal bots. But separating the rules for the scheduling policy from the rules of the game can make the specification more clear. It can also make proofs of properties related to the scheduling policy easier.

the rules of game, defining the code executed by internal bots, which produce movements for the snakes. Competitors may write user bots to control the direction of movement of the snakes. Finally, a Main module creates instances of the user bots.

used here for the definition of the body of derived functions and actions. For example, given a snake descriptor, function getLength returns its length. Suppose that p is a position neighbour to the head of a snake described by a SnakeDescriptor s. Then action moveToPosition changes the position of the snake head to p, moving also the cells of the snake body. Notice that call-by-reference parameter passing is important for this action to work properly.

An user bot has access to its own agent using function self, but it has no access to other agents. The framework gives the permission of this kind of access only to the Main module. This restriction ensures that an user bot can only affect the direction of movement of the internal bot associated to it by function snakeControl.

The action login receives an user bot as a parameter. It creates a new agent, an internal bot, to move a snake. The new internal bot is associated to the user bot using function snakeControl. A descriptor is created to store information about the new snake. This descriptor is associated to the new internal bot using function snakeInfo. Using action login is the only way new snakes are inserted into the game.

Artificial intelligence games are usually defined using logic languages like Pro- log. Examples of simple games created with Prolog can be found in [23]. A much more complex Prolog game is described in [15,16]. But problems with efficiency of generated code prevent logic languages of being used on games with visual animation.

competition will be established among students, who are supposed to write programs for bots representing the competitors in the proposed games. Ad- vanced artificial intelligence techniques may be used in order to produce the best programs. We expect that this competition will make students feel also motivated for learning formal specification methods like ASM.

