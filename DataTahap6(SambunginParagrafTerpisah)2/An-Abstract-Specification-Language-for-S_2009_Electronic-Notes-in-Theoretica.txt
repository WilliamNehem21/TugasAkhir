Static program analysers typically come with a set of hard-coded checks, leaving little room for the user to add additional properties. In this work, we present a uniform approach to enable the specification of new static analysis checks in a concise manner. In particular, we present our GPSL/GXSL language to define new control flow checks. The language is closely related to CTL specifications that are combined with XPath queries. Moreover, we provide a number of specifications as implemented in our tool Goanna, and report on our experiences of adding new checks.

checker language we developed for adding new checks or modifying existing ones according to needs. Goanna is a state-of-the-art static analysis tool for C/C++ programs that is based on model checking techniques. Goanna works primarily on a syntactic program abstraction, i.e., control flow graphs (CFG) that are labelled with objects of interest, e.g., where memory is allocated, used or de-allocated, and does CTL model checking on this abstraction. The CTL property expresses syntactic checks as for instance, whether dynamic memory is still referred to after de-allocation.

Our control-flow centred checker language GPSL/GXSL has been moti- vated by describing typical checking patterns in a straightforward declarative way. It is split in two parts aiming at two different audiences: The first is GPSL, a high-level abstract language that is a collection of the most common checking patterns plus a large library of pre-defined objects of interest. These pre-defined objects themselves are queries such as for locations where memory is allocated, used or de-allocated. This language is targeted to end users, who like to define new checks based on patterns that are instantiated with objects from that library.

There are several approaches to define static checks and temporal logic patterns. Engler et al. define the meta-compilation language Metal [8] to specify new checks. Metal is in essence a state machine written in a C-like language, where certain accepting states are indicating a property violation. Using C as the underlying specification language has advances as well as dis- advantages: On the one hand most developers are already familiar with this language, on the other hand it is known to be error prone and it lacks simple abstraction mechanisms. Moreover, Metal is evaluated on individual program paths making it similar to LTL rather than CTL checking.

Mygcc is a research tool for static code analysis using the Condate language[18]. Condate is a minimalistic declarative language for expressing user-defined checks. It is less powerful than Metal, but supports identifying patterns in a program and defining regular path expressions over them. In na- ture, the declarative approach is similar to GPSL/GXSL, but Goanna uses more expressive CTL formulas and supports familiar XPath queries in GXSL.

A rather different approach has been chosen by Lam et al. [14]. The authors combine a static Program Query Language (PQL) with a dynamic observer. PQL enables to identify syntactic constructs of interest in a program and instruments the application to make the occurrence of these constructs visible to the outside. In a second step those occurrences are observed at run- time with respect to a pre-defined pattern that has been specified as a state machine. While having some similarities with our work PQL focuses primarily on dynamic behaviour and run-time verification.

The remainder of this paper is organized as follows: In Section 2 we in- troduce the Goanna tool and its underlying framework to motivate some of the choices made in designing the GPSL/GXSL language. The language itself is defined in detail in Section 3. We report on some of our experiences on using GPSL/GXSL for real software in Section 4 and present our conclusions in Section 5.

approaches to static analysis, the automata based approach [5,12,17,16] defines properties in terms of temporal logic expressions over annotated graphs. The validity of a property can then be checked automatically by graph exploring techniques such as model checking. Goanna 1 itself is a closed source project, but the technical details of the approach can be found in [9,10].

Temporal relations are commonly specified using temporal logics. There are several different flavours of temporal logics; common are Computational Tree Logic (CTL) and Linear Temporal Logic (LTL). As described in Section 2, Goanna uses CTL. For static analysis, it is helpful to be able to distinguish among different possible execution paths. Statements over implicitly all pos- sible paths, as done in LTL are often not sufficient.

For static analysis purposes, it is desirable to be able to quantify properties over sets of, e.g., program variables. For instance, for all variables of a program a certain property should hold, or for all variables that are used in certain operations only. CTL alone is not enough as it does not allow quantification over sets of atomic propositions. E.g., the CTL formula (1) expresses a check for the variable res of program 1 (a) only.

The Goanna Property Specification Language extends CTL in such a way that it is possible to quantify CTL expressions over sets of syntactical con- structs of the source code, like all variables, all for-loops, all function calls etc. Moreover, GPSL provides a mechanism to issue tailored warning messages, as well as referring to specific parts in a counter example, i.e., the likely source of an error.

GPSL provides a range of pre-defined patterns to specify properties. These patterns define some of the most commonly used temporal relations in static program analysis, and are partly based on ideas by Dwyer et al.[7,6]. Each pattern is mapped to a CTL formula expressing the desired relation. The patterns contain variables a, b, etc. that must refer to GXSL functions like read(var) or write(var) (see Section 3.2). The control flow graph will be labelled accordingly to the results of these function calls.

On all possible execution paths, if there is a node labelled with b, there must have been a node labelled with a before. If there is no node labelled with b, then there is no need for a node labelled with a either. This pattern can be extended with the STRICTLY keyword, which checks that the first node labelled with a is not the same one as the node labelled with b. It is realised by the CTL formula A [!b W (a & !b)].

If a property is violated a warning message must be displayed to the devel- oper. GPSL provides the means to specify a warning message that can be instantiated with a variable name and a line number, that will result from a certain location in the counter-example. This location will be determined by the occurrence of a certain node in that counter-example. Typically, it is sufficient to use the first or last such occurrence.

The identification of statements can be performed on the abstract syn- tax tree of the program. The XPath[3] language is well suited for expressing queries on tree shaped data, like an abstract syntax tree. However, XPath queries themselves are typically only static strings. For each different pro- gram these strings must be dynamically applied depending on variable names, function calls or function parameters. These names are typically not known at the time the query is designed.

The GXSL language extends XPath with functions and variables. A GXSL function is a function that returns a set of nodes of the control flow graph to be labelled 2 . Because the labels generated by Goanna must be unique within the control flow graph, each GXSL function must also have a unique identifier that can be incorporated in the label name. The GXSL functions may have a parameter that can be used to instantiate the generic XPath query (e.g. the var in the read(var) example). The parameter is specified as a node of the CFG, which allows the GPSL language to use a parameter-less GXSL function to quantify a temporal relation, and to use the single items of the result set as parameters for further GXSL functions. Additionally to the parametrized XPath query and the unique identifier, GXSL also adds a type system.

fairly familiar with the AST Goanna produces. To write XPath queries that pick exactly the right nodes out of the AST and taking the many subtleties of C/C++ into account, involves sufficient experience that needs to build up over time. On the other hand, we currently have no good debugging mechanism for GXSL. This means, once nodes are queried and combined, there is no direct debugging feature/output that shows immediate query results and selected node. This certainly needs to be address to make GPSL more user-friendly.

just standard compilation and parsing by Goanna took roughly 200s for a software package containing roughly 3, 500 functions. Adding more checks successively increased the run-time only moderately. It is worth to mention that different checks have different complexities and, as seen earlier, a single check should rather been seen as a class of checks as it sometimes ranges over dozens or even hundreds of different program variables. It can be seen, however, that adding 16 classes of checks does not even double the total run-

In general, GPSL/GXSL has proven to be no worse than hand-optimized hard-coded checks. In fact, in many cases the GPSL/GXSL proved superior due to more efficient caching and reuse of queried objects. The results of GXSL functions are automatically cached without the need for the developer to care about saving results and looking up previous data. With this cache, other properties that use the same set of nodes (e.g. properties which also need nodes where variables are written) immediately benefit from not having to perform potentially time consuming node lookups again.

This paper presents an approach for specifying user-defined checks. It allows for convenient, automatic, user-defined labelling of programs and specifying complex temporal relationships easily among those labels using an expressive set of predefined patterns. This specification method has been successfully integrated into a modern static analysis tool (Goanna) and is now a standard component of this tool. Nevertheless the specification languages themselves are independent of the tool and the programming language that should be analysed.

