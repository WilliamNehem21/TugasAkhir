implementation of term-graphs based on this formalism. As Tom provides rewriting strategies, integrating such structures in the language offers strategic graph rewrit- ing for free. After introducing the notion of relative positions, we will explain how the language can be extended to offer facilities for strategic graph rewriting. Finally, we will illustrate the use of this extension by an implementation of lambda-calculus normalization.

The originality of the previous approach is that pattern matching on terms with references built upon T (F, X ) is simply defined as pattern matching on terms of Tref (F, X ). There is therefore no need to extend the notion of rewriting, which allows us to reuse existing results and rewriting tools. However, the questions raised by this formalism are situated at another level: we would like the rewrite system to rewrite only valid terms. Giving some non-trivial criterion on rewrite rules implying this property remains an open question for the moment. The next sections of this paper therefore focus on technical aspects of the pattern matching problem implementation.

Let us elaborate on the mapping mechanism. It provides an algebraic view of some Java object (e.g. seeing integers as Peano natural numbers, or seeing an XML tree as a term). It is divided into two parts: the destructive part and the constructive one. The destructive part is used by the matching algorithm and its

On the other hand, the constructive part is used by the compiler to build an algebraic term. It usually consists in calling the constructor of the Java class implementing the term. Although our goal is to work as much as possible on top of classes and mappings generated by Gom, we will punctually adapt some mapping to our needs.

Given these language constructs and the terms described in Section 2.2, there are many ways to express matching against patterns with references. As for term construction, patterns can be expressed at low-level using directly positions or by a syntax based on labelling. In each case, it refers to a stated subterm whose position is well-known. To compare two references by value instead of references, we will introduce a deref operator in patterns implemented using Tom mappings.

not differentiate two types of children. Therefore, it may be convenient to have the patterns s(x:a(),x) and s(x,x:a()) match either s(a(),pos(-1,1)) or s(pos(-1,2),a()). The normal form mentioned in Section 2.2 enables such a feature: it is sufficient to maintain normalization of both terms at runtime and

Even if the classical [3] representation of term-graphs by a labelled graph is similar to ours, the conditions on rewrite rules are more restrictive (the left-hand side of a rule is limited to trees). For now, term-graph rewriting in Tom is expressed by syntactic term rewriting. Contrary to [3], there is no garbage collection phase and referenced subterms can disappear or change, leading to invalid terms. One solution would be to integrate this garbage collection phase in the Tom matching. An other attractive approach would be to implement the formalism presented in [6] where the right-hand side of the rewriting rules consists in a set of actions on the pointers.

Tom provides a powerful strategy language inspired by ELAN and Stratego. The purpose of strategies is to describe how transformation rules should be applied. In case of terms with references, the strategy language must be extended in such a way that we can traverse them as graphs.

One noticeable property of strategic programming with Tom is that it is possible to get the current absolute position inside the visited term during a traversal. This allows for instance to collect in one pass the set of reduced forms of a term for a given rewrite system. In our case, we will make use of this feature in the next section to collect the positions of bounded variables occurences under an abstraction.

A major part of the presented propositions has been implemented. We are now working on the definition of a rewriting step similar to the one of [2]. Another field of investigation would be the writing of Ref strategies aborting infinite loops appearing during the traversal of a graph with cycles. This could be achieved by some map associating counters to visited nodes.

As shown by the last section, this model has interesting applications and opens promising perspectives in terms of program transformation and code analysis. Be- sides, the normal form described in section 2.2 makes it a solid basis for experi- menting transformations on term-graphs in a concise and expressive manner.

