Bytecode verification forms the corner stone of the Java security model that ensures the integrity of the runtime environment even in the presence of untrusted code. Limited devices, like Java smart cards, lack the necessary amount of memory to verify the type-safety of Java bytecode on their own. Proof carrying code techniques compute, outside the device, tamper-proof certificates which simplify bytecode verification and pass them along with the code. Rose has developed such an approach for a small subset of the Java bytecode language.

Type safety of program code is an essential issue. It has to be guaranteed that every bytecode instruction operates always on program objects which have the correct type, e.g. that arithmetic instructions do never operate on object references because pointer arithmetic would compromise the security of program execution.

The remainder of this paper is structured as follows. First, we concentrate on the fundamental extensions of the Rose approach and our new technique for memory optimizations. Then we present the results of our evaluation. The section on related work focuses on alternative approaches to bytecode verification in resource-constrained environments.

extensions to the type system itself, while the special size of the data types long and double influences the implementation of the verifier slightly. In ad- dition, we discriminate references to objects that have not been initialized yet within our type system. This is an elegant way to solve a special verification task completely transparent to the verification algorithm.

Definition 2.2 A type transfer function of an instruction maps a given frame type to a frame type that characterizes the effect of execution according to the type based semantics of the instruction. Additionally, the type trans- fer function states the preconditions that have to hold if the instruction is executed.

Input and output frame types correspond to the situation right before and after an instruction while the final input frame type denotes the type inference result for an instruction. If all instructions can be executed on their final input frame type the program is type safe. Otherwise, the verification fails.

over the bytecodes only, because the final result of the data flow analysis, i.e. the final input frame type of the actual control flow node, is always at hand. An additional off-card phase determines the certificates by the classical data flow analysis without the resource restrictions of the Java Card. The certificate that is transmitted to the card holds the pieces of information that are essential to reconstruct the data flow analysis result from a initial input frame type computed by the verifier. Usually, the certificate entries are empty

However, this simplicity comes at the cost that the correctness of the in- formation in the certificate has to be checked: Every final input frame type has to comply with the final output frame type of all predecessor nodes. The merge process guarantees this condition for the direct successor node because the difference information in the certificate can only produce a more restric- tive final input frame type. Additionally, the verifier has to ensure that the final input frame types of all other successor nodes are more restrictive than the actual final output frame type, too. These final input frame types have either been computed already or they are computed later in the verification process. Thus, the verifier has to store some frame types temporarily.

Every edge in the control flow graph causes a test for compliance because the final output frame type of the source node has to be checked against the final initial frame type of the target node. Such a check can be done as soon as both frame types have been computed i.e. when their nodes have been verified. Hence, a frame type has to be stored for every edge that crosses the cut because then one of the participating nodes is not computed yet.

are represented by a single edge. This edge determines the lifetime of its frame type. The frame type remains in memory as long as the edge crosses the cut of the actual transition. The number of cut edges is the number of simultaneously stored frame types of the actual transition. The cut with the maximum number 5 of edges determines the memory consumption of the whole verification pass when frame types are stored just as long as they are needed.

The verifier uses the type lattice in two different ways. First, it ensures that the type transfer function is evaluated only if the precondition holds that the actual input frame type contains subtypes of the operand types. Moreover, the verifier merges frame types by applying the LeastUpperBound relation successively to all stack elements and local variables.

On the bytecode level the creation of new objects is decomposed into two distinct instructions. The NEW instruction allocates memory for the object while its constructor is invoked later with the INVOKESPECIAL instruction. The verifier has to ensure that references to an uninitialized object are only used in a very restricted way. For example, other method invocations than constructor calls with INVOKESPECIAL are not allowed.

introduce new uninitialized types into the type system. These new types make up a completely new part of the lattice which is not related to the original class hierarchy. The verifier will reject the code if uninitialized references are used as operands of conventional instructions because the subtype checks fail. The type transfer functions of the NEW and INVOKESPECIAL-instruction produce and consume the uninitialized variants of types.

The conversion of uninitialized types into their initialized counterparts has to convert all copies of an uninitialized reference. To find these copies in the actual input frame every NEW instruction produces an own type. These types are distinguished by the offset of the NEW instruction.

We focus our investigations on the worst cases because they must remain manageable within the few kilo bytes of memory in a Java Card. The average case is usually not a challenge because between 40% and 60% of the analyzed methods contain only a single control flow node. We have analyzed the stan- dard API supplied by the Java Card Development Kit, two packages of the standard Java Runtime Library, and the jDFA data flow analysis framework on which our certifier prototype is based.

presence of multi-branches that arise from SWITCH-instructions the original idea of propagating the output frame type to all successor nodes would lead to copies of the same frame type. Again our model determines the lifetime of every output frame type and stores it until its last use. The effect is show by the Java Card API where the number of result frame types of the worst case decreases significantly.

However, all RosePass worst cases suffer from a large number of output frame types that arises from the depth first traversal. The comparison to the OptPass values show the expected effects if an optimizer determines a flexible traversal in combination with our lifetime model. The worst case of the Java Card API shows the most significant improvement that arises from the early choice of nodes with many predecessors like exception handlers.

