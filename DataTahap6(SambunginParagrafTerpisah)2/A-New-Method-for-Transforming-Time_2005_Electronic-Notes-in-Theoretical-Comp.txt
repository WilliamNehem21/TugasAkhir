automaton (RA) [2]. The state space of a RA is finite but can suffer from state explosion [2]. To reduce such a state explosion, several minimization methods have been proposed to transform a TA into an automaton with much less states than the corresponding RA [3,15,5,6,14,1].

Hypothesis 2.1 Each TA is assumed deterministic, i.e., if Tr1 and Tr2 are two transitions executing the same event from the same location, and are en- abled at the same time, then they lead to the same location and reset the same clock(s).

alarm. It is clear that these two expressions define the same timing constraint. In this example, SetExp can be used to obtain the second specification from the first one. The programming of the alarm corresponds to a Set event, and the occurrence of the alarm corresponds to an Exp event.

SetExp, that transforms a TA A = (L, A, C, T , l0) into a SEA SetExp(A), is realized in two steps. Step 1 does not modify the structure of A: it replaces the resets of transitions by Set events (substep 1a), and rewrites the guards of transitions in the form of order constraints relatively to Exp events (sub- step 1b). Step 2 generates SetExp(A) that describes explicitly all the possible orders of events, including Set and Exp events in addition to the events of the alphabet of A. Steps 1 and 2 are presented in Sects. 4 and 5, respec- tively. The results of Steps 1 and 2 will be denoted A' = StepOne(A) and B = SetExp(A) = StepTwo(A'), respectively.

Lines 3-4 : We consider the case where: Exp(ci ; k ) is the expected next expiration of ci, and another Exp(ci ; k ') becomes expected after Exp(ci ; k ). In Line 3 the assignment models the fact that Exp(ci ; k ) has occurred and that Exp(ci ; k ') is the expected new expiration. (k' is indicated by Kr (ci )[1 ].) In Line 4 , k' is removed from Kr (ci ) because Kr (ci ) is a se- quence that specifies the values to which ci will expire after its next expi- ration Exp(ci ; k ').

Theorem 6.1 states correctness of SetExp and implies the possibility to transform a study of a system modelled by a TA A into a non-real-time form (i.e., SetExp(A)), and thus, we can adapt non-real-time methods of study. This idea has been used in conformance testing [7,10] and supervisory con-

Property 6.2 is more interesting than Property 6.1 because it does not restrict the modification of constants of guards by multiplying all of them by the same value. The determination of a class of TA in which Property 6.2 holds, is not trivial and we intend to study it in a near future.

Properties 6.1 and 6.2, and Remark 6.1 show an advantage of using SEA instead of RA. In fact, contrary to RA, in practice the state space of SEA does not increase with the magnitudes of the constants used in timing constraints.

