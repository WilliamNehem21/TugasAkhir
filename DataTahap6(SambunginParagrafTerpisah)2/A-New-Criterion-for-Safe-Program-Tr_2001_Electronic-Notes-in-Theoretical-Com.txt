The second criterion is space safety: a program transformation is space safe if it does not raise the complexity of programs. Clearly, program trans- formations used in a compiler must satisfy this criterion. However, we think that this criterion is too loose. This criterion does not impose any restric- tion for programs without inputs. However, showing space safety is simpler than showing space efficiency, in the sense that it is possible to adopt a sim- pler profiling semantics that ignores details such as sizes of closures and stack frames.

The criterion we propose is a property of a whole-program transformation. On the other hand, some transformations used in compilers are based on local program transformations. We therefore also study the connection between the properties of local transformations and the properties of global transfor- mations. We will show that some restricted class of local transformations induces whole-program transformations satisfying our new criterion.

We review the safety criteria of program transformations with respect to per- formance discussed in previous studies. To formalize safety criteria we must first develop semantics to formalize performance of programs. We call such semantics profiling semantics. For a simple programming language, profiling semantics can be given as a partial function eval(M ):

Although many program transformations used in compilers seem space efficient, some useful transformations are not space efficient, but only space safe. Furthermore, to show that a program transformation is space efficient we must consider too many details of the operational semantics of the source language. In the study of the CPS transformation it was necessary to revise the semantics proposed by Blelloch and Greiner [3] to show that the CPS transformation was space efficient [8].

The theorem above is still not enough to use a local transformation in a compiler. In a compiler we usually apply local transformations n times in one phase of a compiler where n is proportional to the size of a program. Even for such composition, a strong improvement relation induces a space efficient transformation.

We have shown weak efficiency only for stack space for two semantics of a simple functional language. It will not be very difficult to deal with execution time or heap space. For example, the proof that the CPS transformation is space efficient [8] can easily be modified to show that the CPS transformation is weakly space efficient with respect to a simpler space semantics of the source language that ignores the sizes of closures and stack frames.

We have shown no examples of local program transformations that are weak improvement relations or semi-strong improvement relations. We are planning to show that various optimizations formalized as local program trans- formations have these kinds of properties. In this area, Gustavsson and Sands have developed a theory of space improvement relations for call-by-need pro- gramming languages and have shown that several local transformations are weak improvements [7]. Their work will be also applicable to call-by-value languages.

