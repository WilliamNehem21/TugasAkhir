4 This work has been developed in the context of a research cooperation between Motorola Inc. and CIn- UFPE. We thank the entire group for all the support, criticisms and suggestions throughout the development of this research. We also thank Joabe Jesus for developing the tool support.

CSP [15,7], for instance, is a very attractive formalism to describe concurrent and dynamic aspects of computer systems. One of the fundamental features of CSP is that it can serve as a notation for describing concurrent and communicating processes at different levels of abstraction. Furthermore, it is possible to prove refinements and classical properties, such as deadlock and determinism, as well as domain specific properties of CSP specifications using the FDR [5] refinement checker. However, CSP lacks intuitive graphical visualization; therefore it can be difficult to understand and to be used by non-specialists. Hence it can be costly and error-prone to informally associate the dynamic behaviour of CSP constructions with structural elements of the design phase such as components and independent processes.

On the other hand, graphical modeling notations are tremendously used to structure and visualize systems, but usually do not embody a consolidated for- mal foundation to allow reasoning about classic and domain specific properties. Even semi-formal graphical notations such as UML [10] and ROOM [17] do not offer a reasoning framework to prove refinements and classic and domain specific properties. Some initiatives have been proposed to give formal semantics to UML and to some of its profiles [4,12], through translations of diagrams and elements of UML into specifications in formal notations, such as CSP, Z [19] and Circus [16]. However, these initiatives address only a small subset of UML.

sound transformation laws for UML-RT [12]. The design becomes incrementally more concrete, with the advantage of having a formal basis in its origin. How- ever, not everything should be translated into graphical notation. Certain parts fit better as textual form, such as constraints representing invariants and pre or post conditions, for instance.

The next two sections give a brief overview of CSP and UML-RT. A set of transformation rules are presented in Section 4, where we also briefly discuss tool support and present an example to illustrate the translation strategy. Finally, Sec- tion 5 draws conclusions and discusses related and future works.

can be used to model the real action of turning on the button of a radio. Besides events, CSP provides channels that are used as a collection of events. The main difference between events and channels in CSP resides in their declarations. The declaration

The hiding operator takes a set of events and a process as arguments, and makes the events invisible in the process. These events continue happening inside the process, but other processes and the environment cannot see them. The renaming operator is useful to change the name of events (or to create copies of a process with different alphabets). In what follows, the process P executes the event a continuously. The process Q, although defined in terms of the process P , renames all occurrences of a with c.

UML-RT [18,8] is a conservative extension of UML. It contains specific conceptual elements of ROOM (Real-Time Object-Oriented Modeling language) [8] that make it possible to model architectures and dynamic relationships of real-time event-driven systems. A capsule, for instance, is a stereotype of UML active class adjusted to the ROOM actor concept. Capsules, like processes, are behavioural description units, with specialized semantics to represent components or independent processes, and can have multiple interfaces, named ports. Capsules communicate among them- selves exclusively through messages, which should flow between connected ports of capsules. Ports have output signals for sending messages, and input signals for receiving messages. In order for two ports to be connected, the ports must be com- patible; that is, every output signal in a port must be an input signal in the other port. An event represents the reception of a message by a capsule.

Ports realize protocols, which define the input and output signals. Protocols can play two or more roles, in accordance with the ROOM standard. However, the UML-RT specification commonly uses binary protocols, involving just two roles. Only one role, named Base role, needs to be specified. The other one, Conjugate role, can be derived from the Base role simply by inverting the incoming and out- going signal sets. In this way, ports are run-time entities that provide full two-way interfaces to capsules. Furthermore, a protocol fixes the data types and the order of messages flowing between connected ports. This order is useful to show the po- tential interactions of a capsule instance with the external environment. In a sense, a protocol captures the contractual obligations that exist between capsules [18].

UML-RT offers state machine diagrams to model the internal behaviour of a capsule when messages arrive on its end ports. A state machine is a directed graph of states that are connected by transitions. Except for the initial transition, which is automatic, the other transitions in a state machine are triggered by the arrival of messages on a capsule port. There is no final state in capsule state machines, because capsules are active classes that never terminate.

The communication between capsules can be either synchronous or asyn- chronous. Asynchronous operation calls are stored in an event-queue of the receiver, and the sender remains free to execute its next actions. The receiver always checks the first element in its event-queue. If it is ready to execute a trigger involving this first call, it should perform the associated transition and continue its execution; oth- erwise, it discards this call. On the other hand, synchronous operation calls involve a rendezvous between the sender and the receiver: when the sender executes the operation call, it is suspended until the receiver synchronizes with it (that means executing a corresponding trigger). If the synchronization proceeds, a return value is sent back to the sender, after which both the sender and the receiver resume their own executions. Otherwise, an internal system controller sets free the sender, but the message will be lost. The uses of synchronous and asynchronous messages are

This section presents a systematic strategy for translating CSP specifications into UML-RT models. We propose compositional rules that take certain CSP patterns as input and output corresponding UML-RT elements. The exhaustive application of these rules translates a specification into a compound UML-RT model.

The mapping of data type declarations is not included here because we assume that these are mapped into simple UML classes. We consider that each data type represents a class of messages used by the system. Compound data types must also be translated as a unique class, which accepts any possible value of each type involved in the composition.

Actually, the translation of CSP processes involves capsules and protocols, be- cause the communication events occurring among capsules should be transmitted through ports, which realize protocols. The protocol signals should carry objects that correspond to values of CSP events. A possible mapping would be to create a protocol for each channel defined in the specification, or for each data type, in which case the occurrence of a channel in a process implies in the creation of a port that realizes the protocol of the channel data type. Instead, for simplicity, we use a unique protocol to transmit all messages between capsules, as long as its signals accept any type of object. This decision is merely structural, and does not affect the communication between capsules because CSP events can be represented by synchronous messages in UML-RT, and the communication mode of these messages is not influenced by the representation of protocols. In this way, our rules consider only the construction of capsules, since the protocol is fixed. Here, this protocol is named CSPMessageProtocol.

Recall that, in UML-RT, capsules can have Base and Conjugate ports, for send- ing and receiving messages concerning the signals orientation. However, the capsules generated by this translation strategy have been simplified so that they contain only Conjugate ports to represent the channels on processes, except in especial cases de- scribed later. This decision was taken in order to simplify the UML-RT model, but it does not change the semantics of the model, since it is possible to duplicate signals or represent the CSP specification without event orientation. In our trans- lation strategy, the external environment, which is implicit in CSP specifications, is made explicit in the generated UML-RT models. Furthermore, only the external environment, which is connected to capsules through Base ports, can send messages to capsules, using output signals defined with a Base role.

tions that refer other capsules. This special port uses the protocol CSPBehavior- Protocol, whose signal term carries the expression that represents the new intended behaviour of the CSP process being translated. We name this special port of be- havioural port. Each capsule has a unique behavioural port. In the implementation

and is always updated when some internal capsule informs a new process term. All actions of SystemController, such as forwarding an incoming message to a capsule role, creating or removing capsule roles, must consider this variable. Although the capsule SystemController centralizes the control flow, its construction is also com- positional. In each rule below we show how its structure and state machine are progressively constructed to handle the overall control flow.

Now, we show a progressive simulation of the capsule SystemController with the follow example. Consider the capsules roles in structure diagrams representing the active capsules in that moment (the inactive capsule roles are omitted). Further- more, we show only transitions executing during that moment in the state machine diagrams. Consider SC the current state of the capsule.

We have proposed rules to map CSP processes into UML-RT capsules. This trans- lation benefits from similarities between processes and capsules; both have be- havioural views and can be defined in a compositional way. On the other hand, while CSP has a rich set of operators to combine processes, UML-RT has no op- erator to build capsules from existing ones. So we had to encode the semantics of each CSP operator during the translation. Although formal proofs are suggested as future work, the rules are intended to preserve the semantics of the source model.

eling and system analysis. Other initiatives [4,12] propose the inverse process: give a formal semantics to UML through translations into specifications in formal nota- tions. However, these initiatives address only a small subset of UML. As alternative approaches, there are programming languages offering support by implementing concurrent systems specified in CSP, such as CTJ [6] and JCSP [20]. But the size of real concurrent systems can make their implementation problematic and with communication patterns usually very complex. Moreover, the visualization of the system structure is usually as difficult as the CSP specification. Our approach has the advantage of the diagrammatic representation in addition to the code genera- tion, as discussed previously.

Furthermore, these rules can be adapted to UML 2 [11], with possible improve- ments on diagrams. Despite of the fact that UML 2 uses several concepts from UML-RT, its elements and diagrams are still ambiguous and unclear [14,2], hence we have chosen to work with UML-RT. Actually, all relevant concepts to represent CSP specifications in this strategy relates to UML-RT, which has more consoli- dated tool support, and whose capsule and protocol concepts are clearer and more intuitive than that of UML 2.

Selic, B., An Efficient Object-Oriented Variation of the Statecharts Formalism for Distributed Real- Time Systems, In D. Agnew, L. Claesen, and R. Camposano, editors, Computer Hardware Description Languages and their Applications, pages 321-330, Ottawa, Canada. Elsevier Science Publishers B.V., Amsterdam, Netherland.

