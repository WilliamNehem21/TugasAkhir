The Tanaka-Sato protocol assumes the existence of a unicast authentica- tion protocol that allows the server to establish an individual key (IK) with a new member joining the group. This IK is used to encrypt all communication between that member and the server. We model the underlying authentica- tion protocol by assuming the existence of a long-term key shared by each valid potential member of the group with the KDS. Since we are looking for attacks on the protocol rather than trying to verify it, we can easily justify this. We can simply take the attacks we discover and examine them to see if the specific way we implemented the authentication phase was exploited. The attacks described in this paper would be effective for any initial authentica- tion protocol. Additionally, we make the standard assumption that the spy has access to a valid long-term key.

creating an enormous search problem. So, the model was changed to include some information about the state of the principals. The unary function m() that was previously used to store just the message trace is now an arity 4 function storing the trace, a counter, the current group key stored by the server, and the composition of the group stored as a list of triples. The triples store the agents name, the individual key which he shares with the server for this session in the group, and the most recent group multicast key he has received. We define a boolean function ingroup on these lists of triples that determine whether or not a particular agent is in the group. A further change is our modelling of freshness. We used to use the parts operator as used by Paulson, but in our model for this protocol, we have a counter, and use this to model fresh values. Our motivation for this was that so many fresh values have to be created in a typical scenario, for individual keys, group keys and multicast messages, that our checking of the parts literals would quickly slow down the search process. We model multicast messages as hello(T ), where T is the counter value when the message was sent, thus ensuring all (honestly sent) messages are unique.

In [22], Pereira and Quisquater attempt to lay down a list of desirable security properties for group protocols. They define implicit key authentication, that an outsider cannot learn the group key; two flavours of perfect forward secrecy, i.e. that the compromise of long-term keys does not compromise past session keys; and resistance to known-key attacks, i.e. that compromise of session keys does not lead to the loss of future session keys. However, the properties Taghdiri and Jackson found not to be satisfied by the original protocol design fall outside of this categorisation. Essentially, this is because we are analysing a protocol for managing a group key for an evolving group, not just establishing a key for a static one.

The main difference between the Iolus protocol and the Taghdiri-Jackson ver- sion of the Tanaka-Sato protocol is that Iolus eagerly distributes new keys, whereas Tanaka-Sato distributes keys only on demand, i.e. as and when mem- bers of the group want to send or read messages.

long-term key. The server generates a fresh individual key , IkM i, and a new group key with ID n , Gkn' . In message 2, the group key is sent to the new member, and in message 3, it is sent to the old members of the group under the old group key, Gkn.

G. Steel, A. Bundy, and M. Maidl. Attacking a protocol for group key agreement by refuting incorrect inductive conjectures. In D. Basin and M. Rusinowitch, editors, Proceedings of the International Joint Conference on Automated Reasoning, Cork, Ireland, July 2004. To appear.

