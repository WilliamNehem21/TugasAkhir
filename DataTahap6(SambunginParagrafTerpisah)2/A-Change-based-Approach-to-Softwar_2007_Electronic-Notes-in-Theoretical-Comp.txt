Software evolution research is limited by the amount of information available to researchers: Current version control tools do not store all the information generated by developers. They do not record every intermediate version of the system issued, but only snapshots taken when a developer commits source code into the repository. Additionally, most software evolution analysis tools are not a part of the day-to-day programming activities, because analysis tools are resource intensive and not integrated in development environments. We propose to model development information as change operations that we retrieve directly from the programming environment the developers are using, while they are effecting changes to the system. This accurate and incremental information opens new ways for both developers and researchers to explore and evolve complex systems.

This paper presents our approach to tackle both problems of accurate informa- tion retrieval and developer use of evolution tools. We believe the most accurate source of information is the Integrated Development Environment (IDE) the de- velopers are using. By hooking our tools into an IDE, we can capture evolution information as it happens, treat it in an incremental manner, and interact with the environment to improve the usability of our tools. Our approach is based on a model of the changes developers are applying to the system and hence treats changes as first-class entities. In that sense, we do not make a distinction between the system and the changes that are performed on it, i.e., software engineering is part of software evolution.

Keeping track of a program-level (not text-level) entity among several versions of the system is hard since it involves parsing several versions of the entire system while taking into account events such as renames of files and entities due to refactorings. Hence some analyses are performed on data which has been sampled [7], [8]: only a subset of the versions are selected because of time and space constraints. This increases the changes between each versions, and makes it harder to link entities across versions since the probability they have changed is higher. Other analyses do without the parsing of the files altogether, basing themselves on coarser-grained information such as the number of lines or the size of directories [4], [6].

He then commits these changes. This is a very small commit, less than a minute of work, since in current IDEs all these refactoring operations can be semi- automated. Commits usually imply larger change sets than this simple example. According to the information gathered from the versioning system, the following

Moreover, the simple scenario depicted above assumes that a developer commits after every couple of minutes of work. In reality, it is more on the order of hours. The change amount would be greater, and changes would be much more diluted and less recoverable.

This approach is clearly only suited for an off-line activity, because even if sam- pling is used it is time-consuming (hours or days to complete on a large-scale sys- tem). Currently, forward and reverse engineering are two very distinct, separate activities. When applied in practice, reverse engineering is performed by special- ized consultants acting on unknown systems under time constraints.

First-class change entities are objects modeling the history of a system following the incremental way it was built. They contain information to reproduce the pro- gram of which they represent the history. When executed, they yield an abstract representation of the program they represent at a certain point in time. They also contain additional information interesting for evolution researchers, such as when and who performed which change operations.

The literature shows that a few versioning systems have attempted a change- based, rather than version-based approach to versioning [12] [13]. However, these approaches are solely focused on merging, whereas our model is more general and allows the change operations to be used in various ways. We also think that by not replacing the versioning system layer, but rather complementing it, our approach will encounter less resistance.

Although we model program evolution with first-class change operations to ease reverse engineering, we believe it is useful for forward engineering as well. Most end-user applications feature an undo mechanism, but most program editors do not provide a sensible one at the semantic level. First-class change operations could enable this, hence facilitating exploratory programming by trial and error. First- class change entities can also ease arbitrary program transformation to facilitate program evolution, following the same scheme as semi-automated refactorings[15].

Applicability. Our approach is language-specific, which involves more effort to adapt it to a new language than conventional file-based approaches. However, our current prototype implementation is split into a language-independent part and a language-dependent one. Only the latter one must be adapted to other languages/IDEs.

identified independently from their name: a rename is a trivial operation. SpyWare can also generate the source code of the program it is monitoring at any point in time, by applying or reverting change operations. It also features basic support for interactive visualizations of the history.

Facilitating program comprehension. Processing finer-grained changes will allow us to detect and characterize changes with greater accuracy. Storing all the refactorings performed on the code will enable us to track specific entities for their entire lifetime, even after renames and moves. We also believe that it is possible to characterize changes as either bug fixes, refactorings or feature additions and that this information will allow to focus analysis on specific changes by contextualizing them.

Our model allows us to characterize or classify changes and entities in arbitrary ways (using properties or annotations). This facility can be used to ease understand- ing of the code as well. Contrary to classical versioning systems where branches are fixed and are set up before modification, our model permits the modification of properties of changes while reviewing them. Changes that need to be grouped can be tagged for an easier handling.

Recording the complete history of a system allows for fine-grained understanding of a dedicated piece of code by reviewing its introduction and modifications in context of surrounding modifications, e.g., it is useful to know whether a line is present from the beginning of a method or much later because of a bug fix.

Since the curriculum at our faculty includes several projects, we chose to use data generated by our students for this case study. During the course of their second semester, students had to program in Smalltalk a pair-project for a period of a week. Out of a class of 22 students, 11 pairs were formed. Each pair had to choose a topic out of these three:

To gather data, we had programming environments tailored for student use. Their environment included the monitoring part of our prototype, which in its current incarnation periodically uploads new changes as files to an FTP server. It also included a notification that they were involved in such an experiment.

Session such as session S2 are stagnant : The growth is slow, with some occasional removals of methods. This indicates a much more cautious approach, where the road to follow is not as clear as in stair-shaped sessions. If certain methods are modified several times during this session, this could be a bug-fixing session, involving several tries before finding the correct fix.

