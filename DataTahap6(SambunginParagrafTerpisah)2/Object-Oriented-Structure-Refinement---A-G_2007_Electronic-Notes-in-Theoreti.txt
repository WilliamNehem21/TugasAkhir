In UML, the general structure of objects, their attributes and relations are modeled as a class graph, and an instance of a class graph is defined as an object graph. The class graph of a system determines the general properties of objects and how objects collaborate in realizing a use case. In this paper, we define class graphs and their object graphs as directed labelled graphs, and investigate in a graph theoretical approach what changes in the object structure maintain the capability of providing services. We define the general notion of structure refinements. A structure refinement is a transformation from one graph to another that preserves the capability of providing services, that is the resulting class graph should be able to provide at least as well as the original graph. We give a small set of structure refinement rules that is proved to be sound and complete for a kind of structure refinement.

Structure refinement is important for an object oriented design to be main- tainable, reusable and cohesive. In this paper, we propose a calculus of structure refinement by using graph transformations. We define a class declaration section as a directed labelled graph, called a class graph. The nodes are labelled with names of classes or primitive data types, such as Int, Char and String, and edges are labelled with attribute names (also represents UML associations) or symbol Q denoting the direct inheritance relation.

Section 2 shows how a class declaration section can be defined as a directed labelled graph. In Section 3 we define object graphs for class graphs to represent system states. We also propose an informal, yet precise and obviously formalizable, operational semantics of programming commands based on class graphs and object graphs. In Section 4, we define structure refinements between class graphs and their derived relations between object graphs. Section 5 establishes a set of class graph refinement rules and prove that they are sound refinements. We also show that this set of rules are complete with respect to a restricted notion of structure refinement.

A class declaration section can be represented as a directed and labelled graph. We use names of data types and classes to label the nodes and names of attributes and an annotation of inheritance to label the edges. For this, we assume an infinite set CN of class names, an infinite set T of names of primitive data types, an infinite set A of attribute names, and a single name Q to annotate the inheritance relation. Let N be union of types in CN and T .

We have proposed a graph theoretical approach to studying the relation between changes in class declarations and changes in method definitions. The main purpose is to make the semantics and refinement of object oriented programs easier to un- derstand and more operational. We believe this is important for development of tool support to object system development by transformations [11].

Another contribution of this paper is the proposal of an operational semantics for object oriented programs in the graph theoretical notation. This allows us to un- derstand the execution of an object program in the same as an imperative program by taking graphs as the states. In our future work, we will study this operational semantics together with the study of operations and properties of graphs. This will lead to the development of a Hoare-logic for object-oriented programs with predicates of graphs.

