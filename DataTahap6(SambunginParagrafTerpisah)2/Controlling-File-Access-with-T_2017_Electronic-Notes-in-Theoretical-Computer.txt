Accidental misuse of shared files by authorised users is a predominant problem. This paper proposes a well-known static analysis approach, namely a type system, to prevent such accidental misuse. We develop a type system that intercepts commands issued by users in a file system and enforces policies on each file. Commands issued by users to manipulate files will be subject to type checking by the type system. Type- checked commands are then guaranteed to not violate policies of the files. The focus of this paper is on a particular policy that allows owners of files (users who created files) to specify the number of times a file can be read by limiting the number of times a file can be copied. Therefore, a file can be read as much as it can be copied. If the file cannot be copied, then it can be read only once. This approach can be extended to other properties.

Information flow control can be enforced statically [4,5,15,16] or dynamically [13,2]. The former analyses information flow within a program prior to executing, while the latter analyses information during the execution. The dominant approach for enforcing secure information flow statically is the use of type systems.

The rest of this paper is organised as follows. Section 2 presents the security types and policies of files. Section 3 describes the language syntax and semantics for manipulating files, defines security errors and an algorithm for checking syntactical errors. Section 4 describes the type system, and includes properties. Section 5 introduces a type checking algorithm and proves its soundness and completeness. In Section 6 we give a brief review of related work, and finally we conclude the paper in Section 7.

Our approach to limiting the number of times a file can be read is by limiting the number of copies the file can produce. Therefore, a file can be read as much as it can be copied. If a file cannot be copied, then it can be read once. To enforce this policy, we need to restrict the access to copy operations and restrict the information flow caused by all operations such that restrictions of files over copy operations are not violated. To control the access to copy operations on files we define three security types which are UC, LCn, and NC each of which specifies a distinct policy of how copy operations can be performed on them. UC stands for Unrestricted Copy, which means that a file associated with this type can be copied without restriction. The copied version of a file of type UC should be allowed to be copied in the same way, so should also be of type UC. LCn stands for Linear Copy, which means that a file associated with this type can be copied n number of times, after which the file cannot be copied anymore. However, unlike UC, the copied version of a file of type LCn should not be copied anymore. NC stands for No Copy, which means that a file associated with this type cannot be copied at all. Hence, the copied version of a file of type LCn should be of type NC.

It is useful to show that commands in our language are monotonically increasing, in the sense that types of files never decrease during commands evaluation. This is a straightforward property since we only allow commands to change a type of a file to be the least upper bound of its type and the source type. Since the least upper bound of any two types will be at least as restrictive as both of them, types of files will never decrease.

If f finds a type for a command, then there is a derivation for that command. This property is called soundness, and means that the algorithm will not give wrong an- swers. We first prove soundness, then show that the algorithm can find all deriva- tions, a property called completeness.

Furthermore, enforcing non-interference can only control how information flows from one security level to another; but cannot control how information at a par- ticular security level is manipulated [10,3]. For example, regardless of the security level assigned to a variable, the variable can be read, concatenated with itself and saved back as long as these operations only manipulate the variable at the same security level assigned to it. This is because conventional security levels represent only information flow policies which restrict the information flow but not the op- erations which cause such flow. Our security types, however, represent both access control and information flow policies which restrict the operations to be performed on types and the information flow caused by performing the operations.

In this paper we have presented our approach to prevent accidental misuse of the shared files. The focus was on enforcing a particular policy, namely limiting the number of times a file can be read. This is achieved by developing a type system that controls the access to copy operations and the flow caused by all operations including copy, such that the policies for copying files are not violated. The type system plays the role of a reference monitor that intercepts each command and checks whether or not the command will cause run-time errors. Run-time errors are caused by executing commands that violate files policies. Therefore, type-checked commands are safe to be executed since they do not cause any policy violation. We have proven the soundness and completeness of the type system with respect to the operations semantics and define a type checking algorithm that is shown to be sound and complete.

The language and the type system presented in this paper is kept to a minimum to avoid complexity in presenting our approach. Various extensions useful in prac- tice including conditionals, loops, recursion, and variables are left for future work. We aimed to start this line of research with a very simple language with the desired properties and then extending it while ensuring these properties are still preserved. In future work we aim to extend the language with various features and the type system to enforce different kinds of policies useful in practice.

So far we have taken a significant step towards realising these features. In particular, we extended the type system to enforce additional policies to control read and write operations. By defining a new set of security types to control read and write operations, we found that the same typing rules presented in this paper with a few additional constraints can be used to enforce the new policies. Therefore, we have added these additional constraints to the current type system and defined security types of files as pairs that consist of a security copy type and a security access type. The former type represents a policy to control the access and flow of copy operations; and the latter type represents a policy to control the access and flow of read and write operations. The resulting type system controls the access to copy, read and write operations and the flow caused by all operations.

We have also extended the policies of files to specify which operations can be performed on which types of files and by whom. We have done this by defining security types of files as labels that not only consist of a security copy type and a security access type, but also of ownership and authorisation information. The ownership and authorisation information in a label indicates the owners and the authorised users of a file associated with the label. Based on the definition of labels, we extended the type system to not only control the access and flow of operations but also control which user can perform these operations. Furthermore, we have also looked at possible extensions to allow owners to manipulate their files policies. Thus, we extended the commands in our language to include commands that manipulate file policies. Accordingly, we extended the type system with typing rules for these commands along with a typing algorithm for typing phrases.

