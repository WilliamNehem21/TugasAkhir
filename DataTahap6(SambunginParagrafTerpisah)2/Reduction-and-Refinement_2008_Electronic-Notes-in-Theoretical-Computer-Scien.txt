In Section 2 we define the concept of reduction and briefly explain its use in complexity theory and cryptography. In Section 3 we explore the mutually dependent concepts of refinement and implementation. In Section 4 we ex- amine how refinement can be viewed as a special case of reduction; the more useful and general view of reduction as a special case of generalised refinement is set out in Section 5. Finally, we draw some conclusions and indicate areas for further research.

many process algebra and relational refinements and standard Z refinement [10]. However, the implication is really in the less useful direction: it positions the problem we can solve as a special case of the one which we would like to solve. We need, then, to look for the other direction, namely: how we can generalise refinement relations in order to characterise (and ultimately, to verify) a wider class of reductions.

The particular instance of IO-refinement for Z abstract data types is de- scribed in [7] and [10, Chapter 10]. To define IO-refinement for our generic notion of refinement, we need notions of input/output transformers, and to assume an operation in our specification language that allows pre-composing a specification with an input transformer, and post-composing it with an output transformer. The input/output transformers, and the composition operation, which we will denote o, will have different instantiations in different specifica- tion notations; e.g., see [7,10] for the Z version of input/output transformers and the >> operator that is used to compose them with Z operations and with each other.

This normally implies that it is total, i.e., it transforms every possible input of s' into some output of s, and that ot is injective: it transforms outputs of s into outputs of s' while retaining enough information to allow the abstract outputs to be reconstructed.

vided to the user. This is reflected in Definition 4.2: it defines IO-refinement modulo it and ot , where they appear both as a part of the notion and its characterisation, and they are not (explicitly or implicitly) existentially quan- tified.

>> is restricted to pairs of schemas with perfectly matching output/input names. The operator >> is indeed monotonic with respect to refinement in this context; composition of contexts corresponds to composition using >> of the IO-transformers. Identities also exist for each type.

Example 5.6 Reduction (as in Definition 2.1) is refinement with a penalty determined by the complexity of the reduction algorithm. Note that here the penalty function is not compositional i.e., the penalty of combined reduction steps cannot be computed from the penalties of the individual steps 13 . How- ever, in most cases only the complexity class of the reduction algorithm is relevant, and classes of interest (e.g., polynomial) are closed under this sub- stitution.

Example 5.8 If IO-refinement holds in both directions with bijective trans- formers, we have isomorphic specifications. However, it is also possible for refinement in one direction to be achieved using an input transformer, and in the other direction using an output transformer, in which case their composi- tion clearly is not the identity for all specifications.

13 Consider a linear time algorithm AP with an oracle for Q . Its unit steps may be due either to oracle calls or to other elementary operations; thus, we abstract away from how many calls it makes to the oracle for Q . If we substitute for the oracle an algorithm AQ that solves Q , we cannot determine the resulting complexity from the individual complexities. For example, if AP uses a single oracle call, and AQ is quadratic, then the overall complexity

