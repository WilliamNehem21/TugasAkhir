tured by the output it produces, which is determined by the supplied input. But reality is often more complicated, for one may have to deal with com- ponents whose behavioral pattern is, e.g., partial or even non deterministic. Therefore, to proceed in a generic way, the behavior model is abstracted to a strong monad B. Of course, B = Id retrieves the simple deterministic behav-

The central idea of our research on the formalization of UML is that a set of UML diagrams denote coalgebraic specifications as introduced by Jacobs [8,9]. More precisely, we intend to translate all the graphical symbols and annotations in the UML syntax, into functors and properties of a coalgebraic specification. Therefore standard definitions in universal coalgebra, such as bisimilarity and refinement, become available to reason and transform UML designs.

In UML, a class is an abstract description of a set of objects with similar structure, behavior and relationships. The description of a class includes the attributes and operations common to all of the objects belonging to it. Every object o of a class C in a system has an identifier ido which is unique within the system. We denote the set of all identifiers by Id. Therefore, an object o : C is semantic functions for visibility of attributes, operations, interfaces, etc. which can be found in [14]. Note that in this framework attributes and operations are very similar: only the form of the signature functor changes. The distinction lies in the difference between observation and computation, only the latter being the source of change in object states.

Every association has three basic components: a name, a role and the multiplicity at each of its ends. The semantics for an association is given by the corresponding observers in each of the classes being related by the association. Let A be such an association between classes U and V. The role names and multiplicities on the two ends are, respectively, uA, vA, and mU , mV , the later being two sets of non-negative integers. Then the semantics of A is defined as a pair of the coalgebraic observers: and may be given to associations in a class diagram. For example, UML allows an association to have its own attributes, which is represented by an associa- tion class, i.e., an association which is also a class. Generally, an association class can be represented as a class with two one-to-many associations.

Generalization relations organize classes into a lattice, with the most gen- eralized class at the top of the hierarchy (eventually an abstract class). The meet and join operators are defined as the superclass and subclass (for mul- tiple inheritance) of classes respectively. Note that an abstract class may not have direct instances, and, therefore, it can not be interpreted in the same way as a concrete class. However, from the generalization relationship between an abstract class and its subclasses, its semantics can be recovered as the smallest superclass of all of its subclasses (or the least upper bound in the lattice of classes). Translated to category theory this means that the semantics of an abstract class with respect to its subclasses is the colimit of the corresponding subclass coalgebras, i.e., structure, and makes the verification of system properties more effective (as shown by D. Pattinson in [18] ). A detailed discussion can be found in [16]. Furthermore, the generic notion of component refinement, proposed by the authors in [15], can be adapted to the context of UML and used for checking consistency of different models. Such is purpose of the following section.

To make proper use of UML models in a development process we need a clear notion of refinement between components clarifying what it means for a component to implement another. Orthogonal to the horizontal decompo- sition of the system structure, the vertical refinement of concrete components from abstract ones provides an approach for stepwise separate development of component-based systems. In the coalgebraic framework sketched in this paper, three kinds of refinement relations between components can be de- fined. In any case the semantic mapping defined for UML models makes them associated with a proper refinement ordering.

Behavioral refinement characterizes the preservation of component behav- ior. But if we rely solely on behavioral refinement, the inability to change the syntactic interface will force us to work at the same level of interface abstrac- tion throughout the whole development process. To avoid this, a more general notion of refinement, called interface refinement is introduced, which relates components with different interfaces.

[6] (see [5] for a recent account). However, for component-based systems, the situation is far more complex (see, e.g., [4]). In this paper we investigated re- finement at three, inter-related, levels: behavioral, interface and architectural level. Our framework allows the notion of refinement to change the interface and granularity of components.

A major influence in our work was Jacobs and Tews research on object- oriented systems [8,9,23]. However, instead of defining and resorting to a spe- cific (coalgebraic) specification language (Ccsl), we adopt a rather pragmatic approach: that of using UML diagrams to denote coalgebraic specifications. Another difference between our work and the formalization of UML in [23] is that we do not restrict ourselves to class diagrams.

