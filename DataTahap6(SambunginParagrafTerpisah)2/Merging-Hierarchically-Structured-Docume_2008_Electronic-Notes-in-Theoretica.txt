The data perspective of a workflow management system puts emphasis on the flow of business documents between activities. A complex workflow system may consist of several subsystems distributed over a computer network. These subsystems can concurrently update partial views of the document. At some points in time we need to reconcile the various local updates by merging the partial views into a coherent global document. Merging of structured documents has already been considered in previous studies on the structural merging of XML documents [23,8,9,21,4,24], on file synchronization [6], or on software merging [15,25]. However, the merge operation that we have in mind here is much simpler than these. One initiates a new activity (a case) in a workflow system by introducing a document (e.g., a form). During its lifetime within the system this document grows by incorporating new information until the processing of the case is complete and the document exits the system. Therefore, normally such a document has a finite lifetime and when updating such a document there is no need to erase information (In general, it would even be considered undesirable to do so). This situation greatly simplifies the merge operation in comparison to the existing strategies noted above, where conflicts during the merge operation essentially come from erasing or restructuring operations.

A hierarchical-structured document is intentionally represented as a tree deco- rated with attributes. Some of these attributes may describe the physical appear- ance of the document. The set of legal structures is given by a context-free grammar together with some constraints on attributes (that may be given, for instance, by the semantic rules of an attribute grammar). We forget about the attributes; these are related to semantic issues that can be treated independently of the purely structural aspects that we address in this article. Therefore, we do not consider any concrete syntax of the document, since these concrete syntaxes can also be given by spe- cific attributes. Therefore, we forget about the terminal symbols of the grammars and end up with so-called abstract context-free grammars. These grammars may be identified with tree automata, thus characterizing legal documents as a regular set of (abstract syntax) trees. Under the mild assumption that any production is characterized by its left and right-hand side, abstract-syntax trees (trees labelled by productions) coincide with derivation trees (trees labelled by grammatical symbols).

We not only consider that documents flow in the system but also that some copies of a same document may simultaneously exist in different parts of the system and can asynchronously be manipulated by a set of independent actors. For instance, some actor, with a specific domain of expertise, can operate on the document through interfaces based on a domain-specific language corresponding to his particular role. There is no reason that these tools, that can have be developed independently, can be aware of the global grammar and can manipulate the document as a whole. Thus, each such actor operates on a distinct partial view of the whole structure of the document. In this paper we consider that a specific view (of the grammar) is given by a subset of grammatical symbols, namely those corresponding to syntactical categories that are meaningful in the corresponding domain of expertise. The partial view of the document interpreted as a derivation tree (or projection of the document according to the view) is the tree obtained by erasing invisible grammatical symbols while preserving its structure (a node in the projection is a successor of another node if and only if the same relation holds in the original document). Of course this notion of view is reminiscent of similar, and more involved, notions that were introduced in the context of database theory or more recently in the XML community [1,7]. In this context, views are often defined in terms of a set of operations on XML documents [10] combining projection (by restriction to certain XML elements), selection (from the value of certain attributes) and swap (changing the order of appearance of certain elements). These XML views can be created using query languages like XSL [34] or XQuery [33] advocated by the World Wide Web Consortium. Since we have discarded attributes and, in particular, are not interested in the physical appearance of documents, the simple notion of view that we are considering fits perfectly our needs. We can relate the abstract view of documents used in this article to more concrete representations using bidirectional tree transformations [28,29,30].

We define a binary merge operator so that merging a finite set of partial views can be realized by an iterated application of that (commutative and associative) bi- nary operator. Even if we assume that the set of all partial views should determine unambiguously the global document, there is no reason to believe that the binary merge operator produces a unique document; in general, it would even produce an infinite set of documents. It happens that the set of (legal) documents associated with a given partial view is a regular set of trees generated by a tree automaton starting from the partial view considered as the initial state. Such a tree automa- ton is presented as a coalgebra for a certain functor; the carrier of the (unique) fixed point of this functor is thus a coinductive data type whose elements can be interpreted as representations of a potentially-infinite sets of trees. We call the anamorphism associated with a tree automaton the canonical coalgebra morphism from the tree automaton, viewed as a coalgebra, to the terminal coalgebra. Then the set of trees recognized by a tree automaton from an initial state is encoded by the image of this initial state by the associated anamorphism. Merging partial views then amounts to computing the intersection of the corresponding regular sets of trees which can be obtained using a synchronization operation on coalgebras.

We introduce a coinductive data structure to represent potentially infinite sets of trees. Elements of that data type, defined as the fixed point of a functor, are called arenas by analogy with game theory: a tree is a member of an arena if it can be viewed as a strategy for the game defined by the arena. We show that we can decide whether a finitely-presented arena is empty. An arena presented by a coalgebra (a generator) together with an element of the carrier set of this coalgebra (a germ) is the image of the germ by the anamorphism associated with the generator (i.e., the unique coalgebra morphism from the generator to the terminal coalgebra). A coalgebra can be interpreted as a tree automaton and then the arena presented by a tree automaton and an initial state (the germ) is simply a representation of the regular set of trees generated by the tree automaton from the given initial state.

An arena arena represents the set of trees whose shape conforms to one of the pat- terns given in the corresponding list unOr arena (a disjunction). Each such pattern is a pair (a,arenas) made of an element a and a list of arenas (a conjunction). A tree conforms to that pattern if its root is labelled a and its subtrees conform to the respective patterns in the list unAnd arenas. The derived isomorphism

We present the following algorithm to decide the emptiness of the extension of a finitely-presented arena. It is an adaptation of the function isEmpty which amounts to applying this function to the pruning of the arena. For that purpose we add a parameter that accumulates the set of states encountered along the path so that we can prune at the first repetition of a state.

where the selectors give, respectively, the list of production names, the list of gram- matical symbols, the left-hand side and right-hand side of each production. To conform to Def. 3.1 we shall nevertheless assume that each production is character- ized by its left and right-hand side. A grammar is a coalgebra:

In this section we try to elaborate on a model of document manipulations in workflow systems using adaptations of the expansion algorithm and of the synchronization operator defined in the previous section. Adaptating the definitions is necessary because a document in a workflow system is bound to grow as it flows between activities. Some leaves of the document (viewed as a tree) are then marked as open to indicate that the tree may expand from these nodes; a marked leaf is said to be a bud of the tree.

It will probably be simpler and more realistic to adopt a bottom-up approach: we suppose having a set of tools associated with specific activities in the workflow that we would like to coordinate. Each such tool is associated with a grammatical structure describing the family of manipulated documents together with a dynamic system representing all possible evolutions of these documents (using the tool). Thus, we have to fuse these grammatical structures into a larger one and, simul- taneously, to synthesize some control so that any vector of partial views of a same global document can always be unambiguously merged into another global docu- ment as soon as each local modification is executed under the supervision of the controller.

As previously mentioned, the expansion algorithm presented in this article, can be seen as some kind of generalized functional parser where tokens used for parsing have an internal tree structure exploited by the algorithm. We would like to design a set of functional parser combinators, in the line of [11,17], in order to obtain a domain-specific language for writing the expansion algorithm by specifying, using these combinators, the abstract grammar and the view. Since expansion is an inverse to projection, this expansion algorithm is also related to the more general problem of program inversion. It could be interesting to verify whether our solution to the merge of partial views could be understood within the framework presented in [3,26,27].

Web services emphasize the use of active documents where queries are attached to some nodes in order to collect information from other documents [2]. It could be interesting to perform such queries on partial views during their merge operation as it would allow more information to flow between the corresponding activities. We intent to address this problem in the context of attribute grammars using the functional evaluations of attributes presented in [19,12,5]. Indeed, the value of an attribute of a visible grammatical symbol may depend on the value of attributes of invisible symbols (but visible for a different view) and thus, attribute computation may provide a means of coordination between the activities operating on different views of a document.

