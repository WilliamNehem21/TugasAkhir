Unfortunately, assuming ideal encryption to analyse password protocols is not realistic, since most practical encryption schemes are far from this ideal. In practice, password protocols are designed to be secure when instantiated with a particular encryption scheme, which makes the security against dictionary attacks dependent on the chosen cryptosystem. Typically, the security of an encryption scheme is characterized by certain properties that the ciphertexts satisfy. For instance, an encryption scheme is said to be repetition concealing [2] if an adversary cannot detect two instances of the same message encrypted with the same key (to achieve this, probabilistic [10] or stateful encryption is needed). Similarly, an encryption scheme is which-key concealing if an adversary cannot deduce if two messages are encrypted under the same key [2]. Besides these general properties, usually each particular cryptosystem has its own subtleties that can also provide useful information to an adversary. For example, a public key in RSA consisting of a pair (n, e) can be distinguished from a random string because e is odd and n contains no small prime factors. As discussed by Mellovin and Merritt [3], this simple fact allows a dictionary attack over EKE when instantiated with RSA.

which-key concealing, and ciphertexts and public keys are indistinguishable from random noise. Interestingly, our analysis helped us to identify a vulner- ability of EKE that arises when ciphertexts are identifiable. To solve this, we propose a simple modification that (to the best of our knowledge) is novel.

V . {x = V } can represent the situation in which a term V has been sent to the environment, but the environment may not have the atomic names that appear in V . Still, the environment can refer to V by using x.

Besides names and variables, we have the usual pairing constructor, along with its projections. Given a name K representing a private key (and thus usually appearing restricted) we can derive a public-key pk(K) that can then be used for (public key) encryption 4 . We also define the usual hash construc- tor. Our constructors for encryption (both symmetric and asymmetric) take a name r as randomness parameter. This allows us to model probabilistic encryption. By explicitly considering the randomness parameter as a name, say r, we can model easily repetition concealing vs. revealing cryptosystems by simply restricting or not r (This modelling was already suggested in [1]). On the other hand, decryption is deterministic.

(A1) First, in particular cryptosystems, it can be the case that ciphertexts are distinguishable from pure random noise, even though the plaintext or encrypting key is not leaked. For example, a usual indication of the presence of a ciphertext can be found in the length of the messages (this can happen, for example, when padding is weak or non-existent). In block ciphers, for instance, ciphertexts typically consist of a certain number of blocks (e.g. a multiple of 128/256 bits). Similarly, numbers close to each other in RSA also give a good indication of a ciphertext. As another example, in the McEliece cryptosystem [15] every ciphertext is a codeword, with a small vector error added to it. This makes ciphertexts distinguishable from random noise.

Process PS models what happens after the session was established success- fully. Note how the public key pk(KS) is exported in variable pks. We assume that none of the values used during the protocol appear in PS, and also that PS never discloses KS. If the decryption fails, then the process would abort (executing the implicit 0 of the else branch). The user process U is:

Acknowledgements. We would like to thank Pieter Hartel and the anony- mous reviewers for helpful comments. We would also like to thank Jonathan Herzog for mentioning a helpful comment that lead to this work. This work was carried out in the context of the LicenseScript project, supported by the Telematica Instituut.

