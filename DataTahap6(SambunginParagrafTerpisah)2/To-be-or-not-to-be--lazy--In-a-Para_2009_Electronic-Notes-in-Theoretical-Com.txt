have implemented an interpreter, written in Haskell, capable of dealing with all of them. The interpreter was combined with a set of profiling tools in order to analyze the influence of the evaluation strategies in the performance of some chosen parallel skeletons implemented in Eden. The purpose of the present work is to depart from those experimental evaluations and to achieve a more rigorous and complete comparative analysis. Therefore, the contribu- tions of this paper are an extension of the spectrum of evaluation strategies mixing laziness and strictness, and the formalization of each evaluation model. Although the study is based on Eden, the involved concepts and the conclu- sions that we have obtained can be transferred to other parallel functional languages.

The paper is organized as follows: We start with a brief introduction to parallelism in Eden, and we describe the calculus used for our analysis. In Section 3 we discuss on the possible evaluation strategies, and we give a clas- sification of these around three concepts. Then in Section 4 we present a distributed operational semantics for the calculus, and we formalize the evalu- ation strategies defined before. In Section 5 we present a collection of examples that shows how the evaluation strategies may affect issues like termination or deadlock. We conclude with a summary discussion on the lazy-eager combi- nations and outline future work.

All these questions are related to the distribution of computation between processes: How much work should do the parent (resp. producer) of a pro- cess (resp. value), and how much work should be left for the child (resp. consumer)? This is a crucial point in any parallel language, and it is not par- ticular to Eden, although the features of Eden maybe offer more possibilities for discussion.

Example 5.1 Let us consider again the expression given in Example 2.1. As explained before, if free variables are to be evaluated to whnf before being copied (EBC=yes), then the evaluation never terminates, because the com- munication from the main process to its child is impossible:

The problem with the first approach is that currying is lost because in Eden parameters can be curried while channels cannot. The second alternative is not as elegant as the first one, but it preserves currying. The programmer only needs to force the evaluation of each free variable that it is desired to be evaluated before the creation of the process.

As a future task, we will investigate how to apply similar techniques to other parallel functional languages like GpH. Besides, it is our intention to widen the calculus in order to include other Eden features such as streams. In this way, we will be able to extend the work in [7] to consider all the semantic options explained in this paper, and thus to analyze the influence of these evaluation strategies on Eden skeletons.

