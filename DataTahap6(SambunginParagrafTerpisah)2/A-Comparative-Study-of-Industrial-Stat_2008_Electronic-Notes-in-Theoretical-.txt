Almost all software contain defects. Some defects are found easily while others are never found, typically because they emerge seldom or not at all. Some defects that emerge relatively often even go unnoticed simply because they are not perceived as errors or are not sufficiently severe. Software defects may give rise to several types of errors, ranging from logical/functional ones (the program sometimes computes

The main objective of this study is (1) to identify significant static analysis func- tionality provided by the tools, but not addressed in a normal compiler, and (2) to survey the underlying supporting technology. The goal is not to provide a ranking of the tools; nor is it to provide a comprehensive survey of all functionality pro- vided by the tools. Providing such a ranking is problematic for at least two reasons: Static analysis is generally only part of the functionality provided by the tool; for instance, Klocwork K7 supports both refactoring and software metrics which are not supported by the two other tools. Even if restricting attention only to static analysis functionality the tools provide largely non-overlapping functionality. Sec- ondly, even when the tools seemingly provide the same functionality (e.g. detection of dereferencing of null pointers) the underlying technology is often not comparable; each tool typically finds defects which are not found by any of the other tools.

Studying the internals of commercial and proprietary tools is not without prob- lems; in particular, it is virually impossible to get full information about technical solutions. However, some technical information is publicly available in manuals and white papers; some of the tools also originate from academic tools which have been extensively described in research journals and conference proceedings. While technical solutions may have changed somewhat since then, we believe that such information is still largely valid. We have also consulted representatives from all three providers with the purpose to validate our descriptions of the tools. Still it must be pointed out that the descriptions of suggested technical solutions is subject to a certain amount of guessing in some respects.

Languages such as C and, to a lesser extent, C++ are designed primarily with efficiency and portability in mind 4 , and therefore provide little support to avoid or to deal with runtime errors. For instance, there is no checking in C that read or write access to an array is within bounds, that dereferencing of a pointer variable is possible (that the variable is not null) or that type casting is well-defined. Such checks must therefore be enforced by the programmer. Alternatively we must make sure that the checks are not needed, i.e. guarantee that the error conditions will never occur in practice.

By the term static analysis we mean automatic methods to reason about run- time properties of program code without actually executing it. Properties that we consider include those which lead to premature termination or ill-defined results of the program, but precludes for instance purely syntactic properties such as syntax errors or simple type errors. 5 Nor does static analysis address errors involving the functional correctness of the software. Hence, static analysis can be used to check that the program execution is not prematurely aborted due to unexpected runtime events, but it does not guarantee that the program computes the correct result. While static analysis can be used to check for e.g. deadlock, timeliness or non-termination there are other, more specialized, techniques for checking such properties; although relying on similar principles. Static analysis should be con- trasted with dynamic analysis which concerns analysis of programs based on their execution, and includes e.g. testing, performance monitoring, fault isolation and debugging.

If the property checked for is a defect then we refer to case (ii)(b) as a false positive. Hence, if the analysis reports that a program may divide by zero we cannot tell in general whether it is a real problem (item (i)) or if it is a false positive (item (ii)(b)). The precision of the analysis determines how often false positives are reported. The more imprecise the analysis is, the more likely it is to generate false positives.

Path- and context-sensitivity rely on the ability to track possible values of pro- gram variables; for instance, if we do not know the values of the variables in the boolean expression of a conditional, then we do not know whether to take the then- branch or the else-branch. Such value analysis can be more or less sophisticated; it is common to restrict attention to intervals (e.g. 0 < x < 10), but some approaches rely on more general relations between several variables (e.g. x > y+z). Another important issue is aliasing (see e.g. [14,28]); when using pointers or arrays the value of a variable can be modified by modifying the value of another variable. Without a careful value and aliasing analyses we will typically have large numbers of false positives, or one has do ungrounded, optimistic assumptions about the values of variables.

It is sometimes claimed that static analysis can be applied to incomplete code (individual files and/or procedures). While there is some truth to this, the quality of such an analysis may be arbitrarily bad. For instance, if the analysis does not know how a procedure or subprogram in existing code is called from outside it must, to be sound, assume that the procedure is called in an arbitrary way, thus analyzing executions that probably cannot occur when the missing code is added. This is likely to lead to false positives. Similarly incomplete code may contain a call to a procedure which is not available, either because it is not yet written, or it is a proprietary library function. Such incomplete code can be analyzed but is also likely to lead to a large number of false positives and/or false negatives depending on if the analysis makes pessimistic or optimistic assumptions about the missing code.

6 Soundness can be used in two completely different senses depending on if the focus is on the reporting of defects or on properties of executions. In the former (less common) sense soundness would mean that all positives are indeed defects, i.e. there are no false positives. However, the more common sense, and the one used here, is that soundness refers to the assumptions made about the possible executions. Even if there is only a small likelihood that a variable takes on a certain value (e.g. x=0) we do not exclude that possibility. Hence if the analysis infers that X may be zero in an expression 1/x, there is a possibility that there will be a runtime error; otherwise not. This is why a sound analysis may actually result in false positives, but no false negatives.

While PolySpace appears to be aiming primarily for the embedded systems mar- ket, Klocwork and Coverity have targeted in particular networked systems and ap- plications as witnessed, for instance, by a range of security checkers. Klocwork and Coverity address essentially the same sort of security issues ranging from simple checks that critical system calls are not used inappropriately to more sophisticated analyses involving buffer overruns (which is also supported by PolySpace) and the potential use of so-called tainted (untrusted) data. The focus on networked appli- cation also explains the support for analyzing resource leaks since dynamic manage- ment of resources such as sockets, streams and memory is an integral part of most networked applications.

an incremental analysis may take significantly less time than analyzing the whole system from scratch. With the other tools analysis of the whole system has to be redone. All of the tools provide the possibility to analyze a single file. However such an analysis will be much more shallow than analyzing a whole system where complete paths of execution can be analyzed.

trivial and writing new, non-trivial checkers is both cumbersome and error prone. There are no explicit guidelines for writing correct checkers and no documented support for manipulation of abstract values (e.g. interval constraints). There is also no support for reusing the results of other checkers. Termination of the checker is another issue which may be problematic for users not familiar with the mathematical foundations of static analysis, see e.g. [6,27].

All three tools support analysis of the C programming language and C++. At the initial time of this study only Klocwork supported analysis of Java but Coverity was announcing a new version of Prevent with support for Java. Only PolySpace supported analysis of Ada. Klocwork was the only provider which claimed to handle mixed language applications (C/C++/Java).

On the more exotic side Coverity provides a checker for stack use. It is unclear how useful this is since there is no uniform way of allocating stack memory in different compilers. Klocwork is claimed to provide similar functionality but in a separate tool. PolySpace set themselves aside from the others by providing checkers for non termination, both of functions and loops. Again it is unclear how useful such checkers are considering the great amount of research done on dedicated algorithms for proving termination of programs (see e.g. [13,2]). Coverity has a checker for uncaught exceptions in C++ which was still a beta release. PolySpace provides a useful feature in their support for writing general assertions in the code. Such assertions are useful both for writing stubs and may also be used for proving partial correctness also of functional properties; see [25].

None of the tools provide very sophisticated support for dealing with concur- rency. Klocwork currently provides no support at all. Coverity is able to detect some cases of mismatched locks but does not take concurrency into account dur- ing analysis of concurrent threads. The only tool which provides more substantial support is PolySpace which is able to detect shared data and whether that data is protected or not.

Several users had expected the tools to find more defects and defects that were more severe. On the other hand, several users were surprised that the tools found bugs even in applications that had been tested for a long time. There might be a difference in what users find reasonable to expect from these tools. There might also be large differences in what users classify as a false positive, a bug or a severe bug.

Many of the defects found could not cause a crash in the system as it was defined and used at the moment. However if the system would be only slightly changed or the usage was changed the defect could cause a serious crash. Therefore these problems should be fixed anyway.

Evaluation 1 (Coverity and FlexeLint): The chosen application had been thoroughly tested, both with manually designed tests and systematic tests that were generated from descriptions. FlexeLint was applied and produced roughly 1,200,000 defect reports. The defects could be reduced to about 1,000 with a great deal of analysis and following filtering work. These then had to be manually analyzed. Coverity was applied to the same piece of code and found about 40 defects; there were very few false positives and some real bugs. The users appreciated the low false positive rate. The opinion was that the defects would hardly have been found by regular testing.

The users had expected Coverity to find more defects. It was believed that there should be more bugs to be found by static analysis techniques. It was not known if this was the price paid for the low false positive rate or if the analyzed application actually contained only a few defects. The users also expected Coverity to find more severe defects. Many of the findings were not really defects, but code that simply should be removed, such as declarations of variables that were never used. Other defects highlighted situations that could not really occur since the code was used in a restricted way not known to the analysis tool.

was known to have some memory leaks was analyzed using Coverity and Klocwork. In total Klocwork reported 32 defects including 10 false positives and Coverity reported 16 defects including 1 false positive. Only three defects were common to both tools! Hence Klocwork found more defects, but also had a larger false positive rate. Although the tools looked for similar defects the ones actually found were largely specific to each tool. This suggests that each of the tools fail in finding

Looking at only the memory leaks the results were similar. Klocwork reported 12 defects of which 8 were false, totalling 4 real defects and Coverity reported 7 defects all of which were true defects. None of the tools found any of the known memory leaks.

Evaluation 4 (Coverity and Klocwork): Old versions of two C++ products were analyzed with Coverity and Klocwork. Trouble reports for defects that had been detected by testing were available. One purpose was to compare how many faults each of the tools found. Another purpose was to estimate how many of the faults discovered in testing were found by the static analysis tools.

Coverity found significantly more faults and also had significantly less false pos- itives than Klocwork. One of the major reasons for this was the handling of third party libraries. Coverity analyzed the existing source code for the libraries and found many faults in third party code! Klocwork did not analyze this code and hence did not find any of these faults. Besides that the analysis of the libraries that Coverity did resulted in fewer false positives in the application code since it could be derived that certain scenarios could not occur.

CodePro Analytix (developed and marketed by Instantiations) is a tool aimed for analysis during development. It is integrated into the Eclipse IDE and the results of an analysis cannot be persistently saved, but only exist during the development session with the IDE. The analysis is not as deep as that of Coverity or Clockwork, but is faster and can easily be done interactively during development. The tool generates a great deal of false positives, but these can be kept at a tolerable level by choosing an appropriate set of analysis rules. No detailed analysis was done of the number of faults and if they were real faults or not.

String and pattern matching approaches: Tools in this category rely mainly on syntactic pattern matching techniques; the analysis is typically path- and context-insensitive. Analyses are therefore shallow, taking little account of se- mantic information except user annotations, if present. Tools typically generate large volumes of false positives as well as false negatives. Tools (often derivatives of the lint program) have been around for many years, e.g. FlexeLint, PC-Lint and Splint. Since the analysis is shallow it is possible to analyze very large pro- grams, but due to the high rate of false positives an overwhelming amount of post-processing may be needed. These tools are in our opinion more useful for providing almost immediate feedback in interactive use and in combination with user annotations.

Sound dataflow analyses: Tools in this category are typically path- and context-sensitive. However, imprecision may lead to analysis of some infeasi- ble paths. They typically have sophisticated mechanisms to track aliasing and relationships between variables including global ones. The main difficulty is to avoid excessive generation of false positives by being as precise as possible while analysis time scales. The only commercial system that we are aware of which has taken this route is PolySpace Verifier/Desktop. The great advantage of a sound analysis is that it gives some guarantees: if the tool does not complain about some piece of code (the code is green in PolySpace jargon) then that piece of code must be free of the defects checked for.

tool only means that the tool was unable to find any potential defects. As witnessed in the evaluations different unsound tools tend to find largely disjoint defects and are also known not to find known defects. Hence, analyzed code is likely to contain dormant bugs which can only be found by a sound analysis.

