Debugging is one of the most time-consuming activities in program design. Work on automatic debugging has received a great deal of attention and there are a number of symposiums dedicated to this field. Automatic debugging is usually invoked when a test fails in one situation, but succeeds in another. For example, a test fails in one version of the program (or scheduler), but succeeds in another. Automatic debugging searches for the smallest difference that causes the failure. This is very useful when working to identify and fix the root cause of the bug.

A new testing method instruments concurrent programs with schedule-modifying instructions to reveal concurrent bugs. This method is designed to increase the probability of concurrent bugs (such as races, deadlocks) appearing. This paper discusses integrating this new testing technology with automatic debug- ging. Instead of just showing that a bug exists, we can pinpoint its location by finding the minimal set of instrumentations that reveal the bug.

forefront. Concurrent defects, such as unintentional race conditions or deadlocks, are difficult and expensive to uncover and analyze, and such faults often escape to the field. Production of multi-core processors is another trend that highlights the need for testing and debugging of multi-threaded applications in the client space. As a result, commercial enterprises such as Intel, IBM, and Microsoft are giving increased attention to developing methodologies and tools for this domain.

Much research has been done on testing multi-threaded programs. Research has examined data race detection [20], [21], [15]; replay in distributed and concurrent contexts [4]; static analysis [23], [14], [7]; and the problem of generating different interleaving to reveal concurrent faults [8], [24]. Model checking [22], coverage analysis [18], [9],[3], and cloning [13] are also techniques used to improve testing in this domain.

In a previous paper [6], we demonstrated how to build a testing tool that ran- domizes the interleaving on top of AspectJ. AspectJ implements aspect oriented programming for the Java language. Using 12 lines of AspectJ, we created a testing tool similar to ConTest [8], an IBM commercial tool that proved useful in finding concurrent bugs. This kind of testing tool [8],[24] works by instrumenting locations whose timing may impact the program result, such as access to global variables, with randomly executed sleep statements. When we wanted to carry out a full implementation of ConTest, we found that AspectJ was missing some features. Be- cause AspectJ is open source, we claim that test tool makers can add the features themselves without waiting for an AspectJ version that contains them.

In this paper, we describe our work on a new debugging tool that is based on noise creation testing technology. Noise creation, in our context, is insertion of delays, random or otherwise to modify the timing of the program under test. Noise generation is very useful in finding intermittent bugs. Our tool looks for the minimal set of noise that contains instrumentation that reveals the bug. If one or several locations can be found where the instrumentation of noise reveals the bug, the description of these locations can be very useful to developers. As expected, our experiments found that it is valuable, in debugging, to know where a thread switch causes a bug to be manifested. A different approach [10] uses genetic algorithms. In that work, instead of looking for the minimal set of changes, they searched for the set of changes that yields the maximum likelihood of finding the bug.

create technology for self-healing. For intermittent bugs that depend on specific in- terleaving, it may be possible to automatically detect and remove the bug-causing interleaving. While the work is not yet mature, we believe that it is interesting due to the following contributions: we show, at least on small programs, that the combination of a DD technique and testing via noise generation yields a practi- cal concurrent debugging technique. We show a new DD algorithm that, in some scenarios, is better than those found in the literature. In addition, the actual imple- mentation is detailed, which includes modifications to AspectJ that can be applied to other applications.

We implemented our work using AspectJ, an aspect-oriented extension to Java. With just a few new constructs, AspectJ can extend Java to provide support for the modular implementation of a range of cross-cutting concerns [19]. Dynamic cross-cutting makes it possible to define additional implementations that run at certain well-defined points in the execution of the program. Static cross-cutting makes it possible to define new operations on existing types. Dynamic cross-cutting in AspectJ is based on a small but powerful set of constructs: join points are well- defined points in the execution of the program; pointcuts are a means of referring to collections of join points and certain values at those join points; advices are method- like constructs used to define additional behavior at join points; and aspects are units of modular cross-cutting implementation, composed of pointcuts, advices, and ordinary Java member declarations. We use dynamic cross-cutting to implement the features of ConTest using AspectJ, in a manner similar to that used by the ConTest instrumentor [16].

This section describes the algorithms we use to find the minimal amount of instru- mentation needed to uncover the bug. First, we have to deal with the fact that the bugs are not deterministic. If execution succeeds (i.e., if it finds the bug), it does not necessarily mean that the instrumentation is in the correct location, since the bug would be found anyway with some degree of probability. When execution fails to find the bug, it does not necessarily mean that the instrumentation is not in the correct place, for two reasons. As discussed earlier, the instrumentation must be activated with probability, and in this execution it may have been activated at the wrong time or not activated at all. Additionally, there may be other thread switches

A very important issue is the expected size of F , which is the minimal group of changes needed to reveal a bug. Studies on bug patterns [12],[17] have shown that F is generally very small and is often a singleton. Finding a singleton is very easy. The simplest algorithm we use creates |n| mutations of the program, each created with a single addition of a sleep statement, and then checks which mutation finds the bug. The advantages of this trivial algorithm are its simplicity and the fact that it is oblivious to the existence of bad changes. A disadvantage is its complexity, as the number of possible changes is linear in S. The number of changes from which we select is dominated by the number of accesses to global variables in the files that contain synchronization elements; this turns out to be about the number of lines of code divided by five in the program we viewed (mainly industrial middleware programs). The second disadvantage is that this algorithm only works if the set of changes is a singleton. If more than one change is necessary, this algorithm fails.

At each stage in this algorithm we apply half of the remaining changes. If a bug is found, we continue with that half, and if not, we continue with the other. The complexity of this algorithm is log(n), which is very good; however, it is still limited to a singleton solution. If the solution is not a singleton, then the half we choose may contain a subset of the changes, in which case we continue with the other half

We set out to devise an algorithm that is optimized to search for small sets as we expect most of the solutions to be small. Another advantage of the algorithm is that every query has a relatively small number of changes. This property is desirable for efficiency, as every instrumentation incurs costs in runtime and accuracy. We have seen [2] that a program with more instrumentations is less likely to exhibit the bug than a program that uses less instrumentation but has it in the correct places. Having less instrumentation is also beneficial from a performance point of view. Due to the existence of bad instrumentation and the non-monotonicity of the problem, the less instrumentation we have, the less likely we are to face these problems, assuming, of course, the right instrumentation.

or part b, there is no change. If the changes are in both a and b, search for the relevant changes in part a (as before). Next, search for the relevant changes in part b, while holding only the relevant changes in part a (as opposed to holding all the changes). While the algorithm can no longer be parallelized, it is more efficient for our application when run on a single processor.

This algorithm is slightly better than our modification of the DD algorithm. To find a singleton (if we do not know that the reply is a singleton), the average complexity of the DD algorithm is 1.5log(N). This is because every time we check, we choose with 50 percent probability in the first try and with 50 percent in the

We conducted several experiments to show the feasibility of our approach, mainly on code taken from the concurrent bugs benchmark [11]. We illustrate the ap- proach using synthetic programs created for this work and a program from Sun that demonstrates concurrent issues. For each program, we examine the perfor- mance of each search algorithm described in Section 3.

We synthesized a short program in which one location is not enough to reveal the bug. We chose this program because its entire code can be shown here. We have seen quite a few examples in the field where one location is not enough.

The technique for automatically locating the relevant concurrent faults is a step towards automatically fixing concurrent bugs. In previous work, we exposed existing bugs and studied bug patterns. After pinpointing the bug location, the next step is to suggest a fix. This goal is still far from being attained, especially

To achieve our goal, we developed a new DD algorithm. This algorithm is superior for our implementation and may be of further use to other applications. Traditional DD algorithms can easily take advantage of parallel computing. Dif- ferent usage scenarios lend themselves to different algorithms.

We are now performing experiments on real applications. The key point is the question of monotonicity. If, in practice, the problem proves to be monotonic, then the algorithms suggested in this paper have practical applications. Even if there are 100,000 instrumentation points, due to the logarithmic nature of the algorithm and the use scenario the running time will be reasonable. If the problem turns out to be non-monotonic, then alternative search techniques will be necessary.

Another problem is that even if the bug can be seen, the probability of exposing it depend on the instrumentation points chosen. If it goes down bellow a certain threshold it will be very hard to detect it. To find the bugs automatically many tests need to be run. It will take longer on long running tests. Deadlocks can also be found using this technique as the tests that find them use timeouts or look for circular lock probability.

In our previous work [6], we saw that AspectJ can be used for testing but fell short in fulfilling the needs of ConTest [9] because some features were missing. In this paper, we took advantage of the fact that AspectJ is an open source tool and altered it to meet our needs. Performing our changes to AspectJ was relatively simple, since it is well written and easy to comprehend. Using our altered version of AspectJ, we were able to implement our tool to its fullest extent. The change we made is useful for a number of other testing tools, for example when performing coverage measurement and aiming to reduce the performance impact. Coverage measurement is usually done by instrumenting the code and measuring which instrumentation points were executed. The main performance impact is due to the commonly executed instrumentations. After each test, removing the instru- mentation points that were executed results in very good performance. Creating such coverage tools with AspectJ is now feasible due to our enhancement.

