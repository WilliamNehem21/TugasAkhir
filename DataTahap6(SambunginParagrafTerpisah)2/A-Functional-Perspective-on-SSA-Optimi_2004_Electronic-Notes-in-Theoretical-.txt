The static single assignment (SSA) form is central to a range of optimisation algo- rithms relying on data flow information, and hence, to the correctness of compilers employing those algorithms. It is well known that the SSA form is closely related to lambda terms (i.e., functional programs), and, considering the large amount of energy expended on theories and frameworks for formal reasoning in the lambda calculus, it seems only natural to leverage this connection to improve our capa- bilities to reason about compiler optimisations. In this paper, we discuss a new formalisation of the mapping from SSA programs to a restricted form of lambda terms, called administrative normal form (ANF). We conjecture that this connec- tion improves our ability to reason about SSA-based optimisation algorithms and provide a first data point by presenting an ANF variant of a well known SSA-based conditional constant propagation algorithm.

Kelsey [12] and Appel [3,2] pointed to a correspondence between programs in SSA form and lambda terms (i.e., functional programs). We believe that this correspondence can be leveraged to simplify reasoning about compiler optimisations that hitherto were based on the SSA form. In particular, we

We like to regard the results in this paper as a step towards reaping the well established benefits of typed, functional intermediate languages in com- pilers for conventional languages. These benefits include simplified reason- ing about the correctness of compiler optimisations, type-based validation of optimised code at compile time, and support for the generation of certified binaries [9,20,16,14,18]. Moreover, ANF naturally integrates intra-procedural with inter-procedural analysis.

assignments ending with a jump. For the purpose of this discussion, we leave the set of constants unspecified; in general, it will include integers, floating point numbers and machine opcodes (primitives). For simplicity, we assume that all variables and labels in a program are unique.

The translation follows the structure of a program in the SSA form. The complete program is translated by F and Fp into an all-encompassing outer- most letrec. Within each procedure, Fb and Fl generate an ANF function for every SSA block, with each level of the dominator tree translated into a separate nested letrec. This makes variables defined along the dominator path visible through the usual scoping rules for nested procedures, while con- structing a new dynamic scope for each iteration through a translated SSA block. The dominator of a group is selected for the body expression of the letrec. Further, since the leaves of the dominator tree cannot be reached except through their immediate dominator, the scoping rules for ANF en- force the dominance property of the SSA form. If desired, the nested letrec structure in the resulting program can be flattened using the standard lambda- lifting [10] transformation.

