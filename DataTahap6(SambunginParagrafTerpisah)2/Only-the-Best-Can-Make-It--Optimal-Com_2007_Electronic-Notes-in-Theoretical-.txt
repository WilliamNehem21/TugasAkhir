Our work is a major contribution to the field of component-based software engi- neering as it improves reusability of components and automation in the construction process of component systems. Moreover, our method is generally applicable, not only for software components but also for hardware components or in the area of hardware/software-codesign as well. In all these cases, components are described by the functionality that they offer and need to be selected depending on their in- dividual cost and on the context of the overall system in which they are employed. Adaptor code (which can be both software or hardware) may be needed for the integration of the selected (software or hardware) components.

This paper is structured as follows: In Section 2, we introduce our notion of a component. Based on this definition, Section 3 gives an overview of our approach of component selection and integration. Section 4 deals with preliminaries concerning term rewriting and optimal code generation, which we need to explain our concept in detail. Section 5 gives a comprehensive presentation of our method. In Section 6, we describe the implementation of our approach, and Section 7 presents the introduced case studies in more detail. After discussing related work in Section 8, we conclude in Section 9.

2 Consider complex load operations, which perform addition and multiplication to determine addresses. Hence, a load with address calculation can be mapped to multiple simple commands or to the complex load instruction. Another example is multiplication by 2 which can be realized by a multiplication operation or by the much cheaper shift-left operation.

In our approach, we use the idea of coupling term rewriting with A* as proposed by [9]. This guarantees an efficient search. We give a short overview of term rewriting with respect to cost functions, and introduce then the concept of A* search. Finally, we describe the coupling between both and discuss complexity issues.

A search can be guided by a heuristic function to approximate the cost for the re- maining transitions. The A* search ([6]) guarantees minimal exploration (w.r.t. the heuristic function) of the search space while finding an optimal solution, given that the heuristic function is admissible. Admissible means that the function always un- derapproximates the actual cost. If we take the zero function as heuristics, we end up with the same behavior as uninformed search. The more precise the heuristic function predicts the costs, the less expensive the search will be. The heuristics provides a valuable mean for dealing with the problem of combinatorial explosion.

A common and descriptive example for search is the problem of finding an optimal route from one location to another. The nodes correspond to the locations, and the edges represent connections, e.g. streets. The cost of a given edge is its distance. The heuristic function for a node defines its distance (here meant literally)

It is a general search problem to find the optimal solution for a given term. The search space contains all terms, the transitions are given by the rules. If we take A* search with an admissible heuristic function, it is guaranteed that we find the optimal solution in minimal time with respect to that heuristics. This application of A* to term rewriting in the context of code generation in compilers has been initially proposed by [9].

As mentioned before, selecting a subset of components for a given set of services is NP-complete (this problem is in NP and is reducible to SAT), even without the constraint to find an optimal solution. Considering term rewriting, in general it is undecidable whether a given term is reachable (corresponding to finding a solution), even termination alone is undecidable 6 . Restricting the rewriting to ground terms (i.e. forbidding variables in the rules), reachability of a goal term is decidable. Least-cost instruction selection on DAGs is NP-complete [1]. While ground term rewriting has to deal with the problem of combinatorial explosion, it nevertheless yields a constructive algorithm for finding a solution, and by restricting the class of allowed rules and appropriate reduction of the search space, the problem becomes feasible for practical scenarios.

The algorithm works as follows: We keep a list of currently active xterms. In each iteration step, we select the minimum (with respect to the cost function) of this list and replace it with all successors which could be generated by application of a rewrite rule. We finish if we reach a goal term, in which case we report success, or if no terms are remaining to be examined, which means failure. If we end up with a goal term, the selection of the minimum in the loop guarantees that we found the optimal solution.

We have implemented our approach for the construction of component systems based on term rewriting in ML. ML is particularly suited for this purpose because of its higher-order power. In our implementation, a higher-order function realizes the generator generator. Given a concrete specification of the available components, it outputs a function that, given the desired component system specification as input, outputs a set of components and adaptors that implement the desired target system. Terms are represented via a generic datatype. The term rewriter starts with the input term, computes all possible successors and puts them into a candidate list. During the following, the least-expensive (w.r.t. the previous cost and the expected cost) candidate is removed from the list and replaced by its successors. This process

The role of the heuristic function must not be neglected. As an example, let us consider a first toy example we have modeled, consisting of 4 services and 7 components. Even for such a small setting, the search space contains 174 nodes. To find the optimum, 25 nodes were visited with uninformed search. If our earlier explained heuristics is used (minimal cost for a component selection presumed), only 10 nodes were visited, while still yielding the same result.

In this section, we discuss our two case studies. We first revisit the example from the introduction for an automotive system. Then, we present a case study in which we have modelled a software component system in the EJB (Enterprise Java Beans) framework [4]. Taking a repository of components for granted, a running system has been created (inclusive adaptors) from the specification.

As second case study, we have modelled an application intended for entertainment on handheld devices. The application should act as a virtual conversational partner for the user, as a so-called chatterbot 8 . We used the Enterprise Java Beans (EJB) component framework as target platform.

The process of component selection can start with no constraints at all. In this case, constraints are dynamically selected during the rewrite process. On the other hand, we can preselect certain constraints. In the given example, if we start with no

For brevity, the description of adaptor specification has been ommitted. How- ever, in the case study, the interfaces of the different components did not match to each other, and interoperability was only achieved by adaptor specification. Start- ing with the specification of the system (services, components, adaptors) and with the given Java Beans for the components, components were selected and integrated by adaptor code generation in a complete automatical process, leading to a deployed application.

Concerning the problem of the generation of adaptors, [14] makes an important contribution. They model protocols with finite state automata and provide a for- mal definition of properties like dead-lock-freeness and liveness. Starting from a functional description of an adaptor, they show how to generate the corresponding adaptor code.

We have presented a framework for the construction of optimal component systems based on term rewriting strategies. By taking these techniques from compiler con- struction, especially optimizing code generation, we have been able to develop an algorithm that finds a cost-optimal component system in minimal (wrt. the applied heuristics) time. The importance of the heuristics is very important as it directly determines the efficiency of the construction algorithm. In our case studies, we have demonstrated that a good heuristics can reduce the search space drastically.

