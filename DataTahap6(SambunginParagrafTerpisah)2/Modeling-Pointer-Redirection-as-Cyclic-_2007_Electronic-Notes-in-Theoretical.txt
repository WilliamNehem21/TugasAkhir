Pointers are programming tools which allow one to design efficient implementa- tions of algorithms. Their manipulation is well-known to be error-prone, due to their flexibility and power. And so, programs which handle pointers are more diffi- cult to write and to maintain. Formal techniques, to write and validate programs manipulating pointers, are thus crucial to enhance the quality of software. For- mally, data-structures constructed by means of pointers are particular graphs where pointers are represented by edges. In the literature, general frameworks of graph transformation are now well established, see e.g. [30,18,19]. Furthermore, rewriting techniques have been shown to be very useful to establish formal bases of very high level programming languages as well as theorem provers. These techniques have

In this paper we follow the double pushout approach [13,24] of graph trans- formation and propose a new class of graph rewrite systems aiming at rewriting (cyclic) data-structures with pointers such as circular lists, doubly-linked lists etc. In general, such data-structures may be subject of four main operations, namely: (i) addition of new records and pointers (ii) redirection of existing pointers (iii) redefi- nition of existing records and (iv) deallocation of some records in order to be swept by a garbage collector. Our proposal focuses on the two first operations. The third operation can be achieved via compilation techniques, as objects are defined up to isomorphisms in categorical approaches. However, we do not tackle the fourth oper- ation in this paper. We dedicate a particular study of garbage collection, following a categorical approach, and apply it to graph rewriting in [16].

In the proposed class of rewrite systems, a special care has been dedicated to define redirection of pointers. We distinguish two kinds of pointer redirections: local redirection and global redirection. Informally speaking, a local redirection redefines the target of a specific pointer, which is determined by a pattern. This is the kind of redirection one may find in imperative languages. A global redirection of pointers consists, instead, in redirecting all pointers targeting a node toward another one. This kind of global redirection are often implicit in declarative languages based on rewriting techniques. It happens when a rooted structure is replaced by another one. In such situation, all pointers targeting the old root should be redirected to point the new root. One may also use such redirections in order to easily update databases when, for instance, old data are to be replaced by new ones. Notice that global redirection can be simulated by means of a series of local redirections, but this is done in general via some cumbersome encoding.

In [23,14] jungles, a representation of acyclic term graphs by means of hyper- graphs, have been investigated. We share with these proposals the use of the double- pushout approach of rewriting. However, we are rather interested in cyclic graphs. In [8,26,17] cyclic term graph rewriting is considered using the algorithmic way.

Pointer redirection is limited to global redirection of all edges pointing to the root of a redex by redirecting them to point to the root of the instance of the right-hand side. In [7], Banach, inspired by features found in implementations of declarative languages, proposed rewrite systems close to ours. We share the same graphs and global redirection of pointers. However, Banach did not discuss local redirections of pointers. We differ also in the way to express rewriting. Rewriting steps in [7] are defined by using the notion of an opfibration of a category while our approach is based on double-pushouts.

The difference between our proposal to generalize term graph rewriting and previous works comes from the motivation. Our aim is not the implementation of declarative programming languages. It is rather the investigation of the elementary transformation rules of data-structures as occur in classical algorithms. In such structures pointers play a key role that we tried to take into account by proposing for instance redirections of specific edges within rewrite rules.

The rest of the paper is organised as follows. The next section introduces the cat- egory of graphs we consider. Section 3 states some technical results that help defin- ing rewrite steps. Section 4 introduces data-structure rewriting (including global and local redirection of pointers) through a double-pushout approach. Conclud- ing remarks are given in section 5. Proofs may be found in the appendix. We assume some familiarity with basic notions of category theory (see e.g. [3] for an introduction).

In this section we introduce the category of graphs we consider in the paper. These graphs are supposed to represent data-structures and are the ones introduced in [8]. We define below such graphs in a mono-sorted setting. Lifting our results to the many-sorted case is straightforward.

We use the double-pushout approach to define a rewrite step. We do not deal with deletion of items in this paper ; this could easily be performed by means of the notion of rooted graphs and the use of garbage collection. A categorical approach of garbage collection and its application to graph rewriting may be found in [16].

The reader may notice that the rewrite rules we consider are different from disconnected productions of [21]. Actually, we do not use the same notion of discon- nected graphs. In general, disconnected graphs according to our definition do not fulfill the disconnection conditions given in [21].

We proposed a new framework for cyclic data-structure rewriting, where data- structures were represented by means of cyclic term-graphs [8]. Rewrite steps were defined following the well-known double-pushout approach [13,24]. However, in the considered category of graphs, pushouts do not always exist and complement pushouts are not unique, when they exist. Nevertheless, we have shown in Theo- rem4.6 that a rewrite rule can always be performed as soon as a matching homomor- phism is found. The main feature of the proposed rules is the possibility to handle pointers explicitly through local and global redirection of edges. This advantage has a price that one pays when analysing the induced rewrite relation. Indeed, insuring confluence or termination become trickier than in classical term rewrite systems or even graph rewrite systems with injective morphisms.

