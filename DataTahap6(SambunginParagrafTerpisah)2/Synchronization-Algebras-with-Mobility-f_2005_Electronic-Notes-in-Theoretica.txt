We propose a generalization of synchronization algebras that allows to deal with mobility and local resource handling. We show how it can be used to model communication primitives for distributed and mobile computations, such as the ones used in the global computing area. We propose a graph transformation formalism in the Synchronized Hyperedge Replacement approach which is parametric w.r.t. the synchronization algebra and thus allows to model complex systems based on the chosen communication primitives. We thus unify different models described in the literature and we allow to easily define new ones. We present various examples and a case study on Fusion Calculus, showing how different semantics for it can be derived using different synchronization algebras.

We choose graphs (or, more precisely, hypergraphs) as basic model, since they have a suggestive representation and they naturally model the topology of distributed systems. We associate to graphs the following computational interpretation: edges represent processes or subsystems, while nodes model channels or ports. Communication is performed via shared nodes.

We want to model systems using hypergraphs, which generalize graphs al- lowing (hyper)edges to be connected to any number of attachment nodes. In particular, we use (hyper)graphs with labelled edges, that is an edge is an atomic item with a label (from a ranked alphabet LE = {LEn}n=0,1,...) and with as many ordered tentacles as the rank rank(L) of its label L. A set of nodes, together with a set of such edges, forms a graph if each edge is con- nected, by its tentacles, to its attachment nodes. A graph is connected to its environment by an interface which is a subset of its nodes. Nodes in the interface are called free nodes, while other nodes are said bound. We con- sider graphs up to isomorphisms that preserve free nodes, labels of edges, and connections between edges and nodes.

As already said, in our approach edges model processes, nodes model chan- nels and free nodes model public channels. It is worth noting that nodes are bound when they are created, since they are not known by the environment. A bound node becomes free (we say that it is extruded) when it is merged with a free node or when a reference to it is exposed on a free node.

As notation we use f |S (resp. f |\S) to denote the restriction of function f to the new domain S (resp. dom(f ) \ S). We also use v[n] to denote the nth element of vector v and Set(v) to denote the set of elements of v.

Example 5.2 (The Game of Life) 3 The Game of Life [1] is a well-known cellular automaton, that is a grid of evolving cells. A cell can be empty or populated (alive). A living cell dies if it has one or no alive neighbours (loneli- ness) or if it has four or more alive neighbours (overpopulation) and survives otherwise. An empty cell becomes alive if it has exactly three alive neighbours. In order to model the Game of Life we use edges that represent cells, with labels A for alive and E for empty. Edges are connected to their eight neigh-

Suppose that processes can perform only the actions out and (in, 1), the others being auxiliary. During synchronization the inputs are merged, but until m of them have joined, the parameter of the output is kept separate. Thus in order for the processes doing input to get the piece of information in the output, at least m of them must participate to the synchronization. If they are not enough synchronization is performed but no data exchange occurs.

