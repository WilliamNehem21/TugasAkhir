In this paper, we propose to apply declarative debugging to Datalog programs. Our approach relies on program semantics rather than on the computation mechanism. The debugging process starts when the user detects an unexpected answer. By asking questions about the intended semantics, the debugger looks for incorrect program relations. While usual declarative debuggers for other languages are based on computation trees, we show that graphs are more convenient structures for representing Datalog computations. The theoretical framework is complemented by the implementation of a debugger for the deductive database system DES, a publicly available open-source project.

based on the SLD resolution principle [7], which deals with SLD computation trees, whereas Datalog computation model is based on a number of proposals, ranging from interpreters [17] to compilation to Prolog using magic sets [3]. The first pro- posal needs some sort of fixpoint computations to solve queries, which is not the computation model the user might have in mind. The second proposal makes things even worse, in the sense that the program is transformed before applying SLD res- olution. This semantic gap between program semantics and program execution makes debugging Datalog programs a hard task if one tries to use existing tools for debugging in a quite different level the user thinks about (for instance, using a trace debugger in the level of the transformed program).

What a Datalog programmer would find useful is to catch program rules or relations which are responsible for a mismatch between the intended semantics of a query and its actual computed semantics. Our system, by means of a question- answering procedure which starts when the user detects an unexpected answer for some query, looks for those errors pointing to the program fragment responsible for the incorrectness. For this procedure, we propose to use computation graphs as a novel data structure for declarative debugging of Datalog programs. We find that these graphs are more convenient for modeling program computations, instead of computation trees, which have been typically used in declarative debuggers for other languages (e.g., Prolog [12], Java [5] and Toy [4]).

case. A Datalog program is a finite set of Datalog facts and rules. In order to fit with database notation, the term relation is used in lieu of predicate. A database relation is, therefore, a set of rules with the same predicate symbol and arity. If a relation is only defined with facts, it is called an extensional-database relation (EDB), whereas it is otherwise called an intensional-database relation (IDB). A query (term preferred in a deductive database context) or goal (term preferred in a logic programming context) is a literal (i.e., an atom or a negated atom) which can be solved by a Datalog system with respect to a given program. Analogously to literals, we say that a positive query is an atom, and a negative query is a negated atom. In contrast to facts, queries may contain variables.

The example program is intended to compute the parity of a given base rela- tion br(X), i.e., it can determine whether the number of elements in the relation (cardinality) is even or odd by means of the relations br_is_even, and br_is_odd, respectively. The relation next defines an ascending chain of elements in br based on their textual ordering, where the first link of the chain connects the distinguished node nil to the first element in br. The relations even and odd define the even, resp. odd, elements in the chain. Finally the relation has_preceding defines the elements in br such that there are previous elements to a given one (the first element in the chain has no preceding elements). The rule defining this relation includes an intended error (fourth rule in the example) which will be used in forthcoming sec- tions to show how it is catched by the declarative debugger. The symbol < denotes a built-in relation checking if some element is less than another w.r.t. the predefined term ordering. Observe that relations br_is_even, and br_is_odd are not range restricted because variable Y occurs only in a negative literal, and that therefore the program does not fulfill the usual safety conditions [17]. In fact, our setting

The graph contains the two subgoals occurred during the computation together with their respective answers. It also indicates that p(X) and q(X) are mutually dependent. We will call such graph the computation graph for the goal w.r.t. the program. Observe that this graph is different from the predicate dependency graph [19] of the Datalog program, which show the connections between the relations from a static point of view. In the example, the dependence graph will include a vertex for the relation r connected to the vertex for p. However, our computation graph depends on the initial goal and the subgoals that occur during the computation and hence does not include any vertex for r.

{br is even}, because the relation br contains two elements: a and b. However, the answer returned by the system is { }, which means that the corresponding goal was unsuccessful. Therefore, the user will start the debugger. The debugger proceeds by following the stages:

Second, the CG obtained in the previous phase is traversed asking to the user about the validity of some vertices looking for a buggy vertex. A vertex is called buggy when it is non-valid but all its immediate descendants are valid. A buggy vertex always corresponds to an incorrectly defined relation, which is pointed out by the debugger as the cause of the error.

In fact, our approach does not match the general scheme proposed by L. Naish in [8] for declarative debugging, because it is based on a graph rather than on a tree. However, some of the basic results are still valid. For instance the correctness of the technique:

The informal reasoning behind this result is easy: since a buggy vertex is an incorrect vertex, this means that it contains an incorrect answer for its associated query. Also, in the graph construction algorithm, it can be checked that the im- mediate descendants of the vertex are the subqueries whose result were needed to produce such incorrect answers. But, if the subqueries returned correct values, the error must come from the relation itself, which is therefore incorrectly defined.

q(a). In either of theses cases f = {p(a), q(a)}. Then, we will have a CG with two incorrect vertices and with no buggy vertex. In this case, our debugger will not point out any relation, but a set of connected relations as the cause of the error. Fortunately, this situation that leads to less informative diagnosis, is not usual in common Datalog programs.

The second phase consists of traversing the CG in order to find either a buggy vertex or a set of related incorrect vertices. The vertex associated to the initial query Q is marked automatically as non-valid by the debugger. The rest of the vertices are marked initially as unknown. In order to minimize the number of questions asked by a declarative debugger, several traversing strategies have been studied [4,13]. However, these strategies are only valid for declarative debuggers based on trees and not on graphs and new strategies are still to be investigated for this structure. Nevertheless, the currently implemented strategy already contains some ideas of how to minimize the number of questions in a CG:

In the previous sections we have presented a framework for the declarative debugging of Datalog programs. The proposed technique finds incorrect relation definitions in Datalog programs by comparing the results of the computations to the intended interpretation of each relation, which is assumed to be known by the user. Thus, our technique relies on the program semantics for debugging, disregarding the imple- mentation issues. In Datalog this is not only an advantage; it is almost a necessity. The Datalog computations are based on operational features or program transfor- mations that make the execution very difficult to follow and understand using the normal trace facilities included in logic languages such as Prolog.

declarative debugging, which is based on trees rather than on graphs. Nevertheless, declarative debugging using computation graphs lacks some of the nice properties of usual declarative debugging such as completeness. We have shown that indeed in some Datalog programs is not possible to point out a single relation as the cause of an unexpected computation result, and that in those programs the debugger can only detect sets of mutually dependent relations as possible error sources, meaning that one or more of these relations are incorrectly defined. However, these situations are not common in practice.

