We propose splitting tools into front- and back-ends where an operational semantics acts as the link be- tween the two. We will not have much to say about the front-end and the link in this paper since it is theoretically straightforward. Instead, we concentrate on the second part and provide a well-motivated, general, mathematical framework to form the underlying theory that gives great flexibility to the back-end of a tool which is concerned with developing software via stepwise refinement.

We note that refinement is defined in different ways in different formalisms e.g. CSP, IOA, B, Event B, Z etc., and these differences can be subtle and make it hard to relate the different definitions. This may be important if, for example, we wish to specify some parts of a system in one language and other parts in another language. For example event-based specification may be appropriate for the interactive parts of a system and state-based specification may be appropriate for the purely transformational parts.

We have shown [1,2] that contexts and observations can be selected in such a way that some of the well-known refinements found in the literature can be expressed as specialisations of our general model. Further we have shown [3] that using our general model of refinement we are able to transfer a definition of refinement from one (state-based) formalism to a different (event-based) formalism in which setting it appears to be new. The bridge between state- and event-based formalisms used in [3] is the well-known isomorphism between a state-based operational semantics (sets of named partial relations, Npr) and an event-based operational semantics (labelled transition systems, LTS).

Taking a very high-level view for a moment we can say there is a wide variety of different formal models, each with different syntax. CSP, CCS, IOA, CBS, Z, B, Event B etc. all have an operational semantics based on LTS or Npr. Thus we can use the operational semantics as a common intermediate language.

In order to model this design step we have had to take a relaxed view of both operation refinement and data refinement. Rather than define two new definitions of refinement, one for operation refinement and the other for data refinement, we have defined one general notion and then shown how to specialise this to both operation and data refinement. So, thinking back to this being a theory for the basis of a tool, we see that by implementing flexible refinement we can build other, more specialised, definitions of refinement (like operation and data refinement shown here) simply by defining the values to two parameters for each specialised refinement.

In Section 2 we give an informal definition of refinement and a motivating exam- ple. The technical detail of the semantics on which to base the flexible back-end of a tool is given in Section 3. Then in Section 4.1 and Section 5 we show how to apply

This paper is about the refinement of entities represented by some operational semantics. It does not matter to us what syntax is used to define the entities. We take our example, formalised in Z, from [4], but wish to stress our paper is not about Z. We are simply using Z to express an entity because the published example did.

We will show how to formally model the development of SetA into SetC as a re- finement step and show that its formal guarantee corresponds to the above informal guarantee. Clearly the example is very small and we could easily have given the concrete specification in the first place. The point we make, though, is that if one were given a large complex specification on which a lot of time has been spent, then one would be reluctant to throw away all this effort and start again.

Note that the informal notion of refinement in Section 2 talks about not only the entities involved in the refinement, but also the observations a user can make of them. Also, since the user, in order to make observations, must presumably use the entities they must have been placed in some contexts (e.g. programs which call the operations the entities provide). We should be careful when formalising refinement not to lose track of, or throw away, these contexts and observations. They were important enough to be employed in the informal notion of refinement, so they might also turn out to be useful in the formalised version too.

X. We model the observer as a passive user U that is a third entity that observes or interacts with X, but cannot block the X events. The user U is formalised by O , an observation function that returns sets of traces of observed events.

(recorded). Although this definition of vertical refinement may seem unusual when considering the entity to be a single operation, it is no more than an application of Galois connections as have appeared widely in the literature. It is the adding of the new observations that makes our formal model (of both single operations and machines) so flexible. In addition it is the preservation of the guarantee that allows us to view theory morphisms as refinements.

Theory morphisms and general refinement, which together constitute what we call flexible refinement, have been given without being specific as to what means of representation is to be used nor what will appear in the interface between entity and context. Machines consist of both state and operations (sometimes called events or actions). Here we focus on the situation where the interface is considered to consist of state and not operations.

It should be clear that state-based flexible refinement can only introduce nonde- terminism by allowing the operations of the abstract machine to terminate in new states, i.e.states not in the abstract machine. The intuitive reason for this being that the new states, X in our example, are thought not to have been considered in the abstract specification.

Let us assume that the concrete machine is the same as the abstract except for the existence of new operations i.e. new named relations. Firstly by definition the abstract machine can not be placed in any program that uses one of these new operations. Secondly if the concrete machine is placed in a context that only calls operations with the same name as operations in the abstract machine then what can be observed of the concrete machine is exactly what can be observed of the abstract machine. From the previous two statements it can easily be seen that the abstract and concrete machines are related by a subset morphism.

We have also considered the usual informal notion of refinement. By seeking to preserve as much of that informal notion as possible, we have been led to a new and general definition of refinement. We have shown how to apply this definition to both expand the state space of an entity and its set of operations.

