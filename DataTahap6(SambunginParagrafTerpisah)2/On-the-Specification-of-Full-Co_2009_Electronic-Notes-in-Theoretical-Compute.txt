Contracts specify properties of an interface to a software component. We consider the problem of defining a full contract that specifies not only the normal behaviour, but also special cases and tolerated exceptions. In this paper we focus on the behavioural properties of use cases taken from the Common Component Modelling Example (CoCoME), proposed as a benchmark to compare different component models. We first give the full specification of the use cases in the deontic-based specification language CL, and then we concentrate on three particular properties in order to compare deontic and operational specifications. We conjecture that operational specifications are well suited for normal cases, but are less easily extended for exceptional cases. This hypothesis is investigated by comparing specifications in CSP (operational) with specifications in CL. The outcome of the experiment supports the conjecture and demonstrates clear differences in the basic descriptive power of the formalisms.

The paper is organised as follows. In next section we provide a general descrip- tion of CoCoME. In section 3 we present the language CL and we give the CoCoME specification. In section 4 we present in detail the three properties to be specified in section 5 using CL and CSP, and we briefly comment on the suitability of LTL and CTL as specification languages in this context. We compare the specifications in section 6, to conclude in the last section.

Once the manager starts the order products process (startOrderProcess) the sys- tem is obliged to show the full list of items and the list of items that are running low (listItems&listLowItems). After this the manager has the permission to enter the amount of items he would like to order (entersAmount) after which he is per- mitted to press the order button (mngOrderButton) in which case the system is obliged to place the order and display the order id (placeOrder&displayOrderID). This use case does not have any exceptional behaviour specified.  Further- more, the distinction between the system permitting the manager to do cer- tain actions (e.g. P (entersAmount)) and the system being obliged to respond (e.g. O(placeOrder&displayOrderID)) is not explicitly described in the CoCoME specification but rather assumed from the common expectations.

we defined the action completeCorrect since the obligation is on the supplier to send the correct information. Thus here we have that once the delivery is made (deliver) the supplier is obliged to have sent the complete and correct delivery (completeCorrect). If however the supplier has violated this obligation, the man- ager is obliged to send the order back (sendBack), otherwise he is obliged to pro- cess the order (mngOrderButton) and the system is obliged to update accordingly (updateInventory).

customers are only allowed to buy a small amount of goods and must pay cash in order to keep each transaction short. (6) Each Cash Desk has its own Cash Desk PC where the software handles the sale process, and takes care of the communication with the Bank. Furthermore, it integrates all devices at the Cash Desk.

The Relational Calculus of Object and Component Systems (rCOS) is a method for developing component based systems. Syntactically, it is rooted in Unified The- ory of Programming (UTP) [6] which has been adapted for object and component based use [4]. Behavioural aspects are syntactically expressed by UML diagrams. Semantically and for verification purposes, they are translated to CSP [5].

It is always the case that once we go to the express mode a certain behaviour needs to be followed until we go back to normal mode. In the case that the client has less than eight items, then the cashier is obliged to service the customer. However, if the client has more than eight items the cashier is obliged to choose to either service the customer or send back the customer to another cash desk and both possibilities should exist. The last property is thus specified in CL as follows:

The specification of the example using the different notations shows that CTL and CSP allow the specification of exceptional behaviour aspect of a contract which cannot be specified in other notations such as LTL. Thus making it possible to spec- ify full contracts. However, model based formalisms cannot express global properties such as fairness or liveness of a transition system, because they essentially model the individual transitions.

Though our aim is to compare the specification style of temporal logics, oper- ational and deontic specifications, we are also interested in what we can do with those specifications, namely how easy it is to analyse them. It is well known that both LTL and CTL are amenable to model checking [1,7]. In the case of CSP suf- fices, so one can take advantage of the existing tool FDR2 [9] to do the analysis. It may be used to check CSP refinement as well as other properties such as deadlock freeness, trace refinement, etc. However, it is unclear what refinement should be checked for F 3 since it contains contrary-to-duty actions, which do not blend well with ordinary refinement.

One prevailing view of contracts is that of properties which the underlying sys- tem must satisfy. In the gist of this view, we have shown how they can be expressed in terms of appropriate standard logics, CTL and LTL. One main disadvantage of this approach is that obligations, permissions and prohibitions are encoded in terms of the underlying logic, making it difficult, in some cases practically impossible, to relate behaviour of the system back to these operators. The encoding also leads to loss of compositionality of contracts for exception handling or contract violations, as in the case of CTDs. Reasoning about CTDS and CTPs would be difficult. In particular, the detection of deontic inconsistencies, as explained at the end of the previous section, cannot be done in temporal logics, and quite difficult in many operational models.

