practical applicability of our prototype on a series of common, framework-specific analysis and transformation problems. In Sec. 4, we discuss the implementation details of our prototype. In Sec. 5, we cover related work. In Sec. 6, we discuss some trade-offs related to our technique before we conclude in Sec. 7.

Our prototype system is available as a stand-alone, command-line application based on Eclipse, and as a reusable Eclipse plugin. In stand-alone mode, the system performs source-to-source transformation. The user supplies the path of a project and a script to execute. The scripts use the FFI to traverse the project directories and to parse source files, to obtain their AST. After rewriting, the scripts use the FFI to write modified ASTs back to disk, as source code. In plugin mode, interpreter

Patterns are written using prefix notation on the form SimpleName("b"), and can contain variables, e.g.  SimpleName(n), where n is a term variable. A term is a pattern that does not contain variables. Lists are written as [1,2,3]. Terms are built (instantiated) from patterns using the build operator (!): !MethodInvocation(obj, name, [], []), where obj and name are variables.

The primitive traversal operators one, some and all are used to traverse terms by local navigation into subterms. all(s) applies the expression s to each subterm of the current term, potentially rewriting each. all(s) succeeds iff s succeeds for all subterms, e.g. all(!1) applied to the term [1,2,3] gives [1,1,1]. one(s) and some are similar, and applies s non-deterministically to exactly one or as many as possible but at least one subterm, respectively. Both fail iff s never succeeded.

Strategies may be named and parametrized, e.g. try(s) = s <+ id defines a strategy try(s) that attempts to apply s, and defaults to id if s fails. Generic traversal strategies can be built from the primitive traversal operations, e.g. bottomup(s) = all(bottomup(s)); s and topdown(s) = s; all(topdown(s)). A rewrite rule R: pl(x) -> pr(x) with name R, left-hand side pattern pl(x), and right-hand side pattern pr(x), x symbolizing term variables, is syntactic sugar for R = ?pl(x) ; !pr(x). A where(s)-clause temporarily saves the current term, applies s to it, then restores the current term. The clause fails iff s fails. wheres

In this section, we motivate the applicability of our system by showing some framework-specific analyses and transformations. The examples in this section il- lustrate what an advanced framework developer with a good working knowledge of language processing and Stratego could implement. However, Stratego is capable of performing significantly more advanced analyses and transformation than shown here. See [15,4,10] for some examples.

Software projects of non-trivial size always adopt some form of (moderately) consis- tent code style to aid maintenance and readability. We are concerned with checking for proper implementation and proper use of domain abstractions. Consistency of implementation may be improved by encouraging systematic use of particular idioms. The following idiom is taken from the AST implementation in ECJ.

Totem propagation is a kind of data-flow analysis where variables in the source code are marked with annotations, called totems [10]. These assert properties on the vari- ables which are later used by other analyses and transformations. A meta-program will perform data-flow analysis and propagate the asserted totems throughout the code, following the same principles as constant propagation.

All dimensions are compatible for the first two operations, but not for the final z.mult(m,w). The matrix operations in MTJ will verify dimensions before calcu- lating and throw exceptions if the preconditions are not met. Performance-wise, this is costly, and latent mismatches may lurk in seldom used code.

To alleviate this problem, we can apply a totem propagator which knows how to propagate and verify the dimension of matrix operations. Initial dimensions can be picked up from programmer-supplied assertions (on the form of a comment // @dim(m,4,3)) or from the variable initialization. Whenever a dimension is asserted for a variable in the code, a new, dynamic rule Dimensions: name -> dim is created that remembers the asserted dimensions dim for a variable name. Dynamic rules are like normal rewrite rules, except they can be introduced, updated and removed at runtime. If an existing Dimensions rule with the name left-hand side already exists, it is updated to a (potentially) new dim. This rule can then be ap- plied (and updated) when propagating the dimension totem across a transposition:

The where clause is a rewriting condition which ensures that the mult call is on the correct data type and that the dimensions are compatible. This rewrite rule is all that is needed to turn the analysis from Sec. 3.2 into an optimizing code transformation.

The ECJ AST is a class hierarchy consisting of abstract and concrete classes. For example, all expression nodes, such as InfixExpression, inherit from the abstract Expression class. The root node of the hierarchy is the abstract class ASTNode. The AST hierarchy is adapted to the term interface expected by the rewriting engine using the POM adapter.

The getPrimitiveTermType() method returns an integer specifying which primi- tive term type is represented by a given ITerm object. Most AST nodes are appli- cation nodes. An application C(t0, ..., tn) consists of a constructor name C and a list of subterms t0 through tn. The number and types of the subterms are given together with the constructor name in a signature, e.g.

Languages for refactoring such as JunGL [20] and ConTraCT [11] provide both program analysis and rewriting capabilities. JunGL is hybrid between an ML-like language (for rewriting) and Datalog (for data-flow queries) whereas ConTraCT is based on Prolog. JunGL supports rewriting on both trees and graphs, but is a young language and does not (yet) support user-defined data types. Stratego is a compar- atively mature program transformation language with sizable libraries and built-in language constructs for data- and control-flow analysis, handling scoping and vari- able bindings, and pattern matching with concrete syntax (not demonstrated in this paper) that comes with both a compiler and interpreter, and has been applied to processing various other mainstream languages such as C and C++ [4].

A related approach to rewriting on existing class hierarchies is presented in Tom [13]. Tom is a language extension for Java that provides features for rewriting and matching on existing class hierarchies. Recent versions also support generic traversals in the style of JJTraveler, but its library of analyses is still rather small.

It works by adding a new match construct to the Java language that is expanded by the Tom pre-processor into Java method calls. A generator, Gom, is available for generating classes that implement term structures. These are specified algebraically, much like the signatures of Stratego.

High-level analyses are also provided by Engler et al [8], where a system for checking system-specific programming rules for the Linux kernel is described. These rules rules are implemented as extensions to an open compiler. Our system is different in that it can also perform arbitrary code transformation, and that the language we use to implement our rules is a feature-rich transformation language designed for language processing. For language processing problems, Stratego has the advantage of a sizable library of generic transformations, traversals and high- level data-flow analysis, in addition to its novel language features. The net result is that transformation code becomes both precise and concise.

Recent research has provided pluggable type systems, style checkers and static anal- ysis with scripting support. The appealing feature of our system, and that of JunGL and ConTraCT, is that we can also script source code transformations based on the analysis results. The tradeoff with using a domain-specific language for scripting is that the same language features that make the language powerful and domain- specific also make it more difficult to learn. This may be offset in part by good documentation, and a sizable corpus of similar code to learn from.

