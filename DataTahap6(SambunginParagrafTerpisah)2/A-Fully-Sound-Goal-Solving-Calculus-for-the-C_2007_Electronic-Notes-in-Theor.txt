constraints (so-called bridges) supplied by M. Under natural correctness assumptions for the projection operations, the cooperative goal solving calculus can be proved fully sound w.r.t. the declarative semantics of CFLP (C). As a relevant concrete instance of our proposal, we consider the cooperation between Herbrand, real arithmetic and finite domain constraints.

The structure of the paper is as follows: Section 2 introduces the basic notions of constraint domains and solvers underlying the CFLP scheme. Section 3 describes the constructions needed for coordination in our setting, namely coordination do- mains, bridges and projections. Programs, goals, the lazy narrowing calculus for cooperative goal solving (with a typical example), and the full soundness result are described in Section 4. Section 5 summarizes conclusions and future work.

In this section, we recall the essentials of the CFLP (D) scheme [11], which serves as a logical and semantic framework for lazy Constraint Functional Logic Programming (briefly CFLP ) over a parametrically given constraint domain D. The proper choice of D for modeling the coordination of several constraint domains will be discussed in Section 3. As a main novelty w.r.t. [11], the current presentation of CFLP (D) includes now an explicit treatment of a Milner-like polymorphic type system in the line of previous work in Functional Logic Programming [4].

The Cooperative Constrained Lazy Narrowing Calculus CCLNC(C) presented in this section generalizes [2] to cooperative goal solving in CFLP (C) for any coordi- nation domain C and has been proved fully sound w.r.t. CRW L(C) semantics, as shown in Subsection 4.4. Moreover, projections (as understood in this paper and [8]) can operate over the constraints included in the constraint stores of the current goal, while the propagations used in [2] can only operate over constraints in the C part of the current goal, that are not yet placed in any particular store. Due to this difference, projections are computationally more powerful and more difficult to implement than propagations.

R. We compute all the solved forms from the constraint rc (par RA RB) == 200 and the program rules given in Subsection 4.1. At each goal transformation step, we underline which subgoal is selected. For the sake of readability, we omit explicit quantification of existential variables. See Section 5 for a comparison between the computations below and those sketched in [8].

