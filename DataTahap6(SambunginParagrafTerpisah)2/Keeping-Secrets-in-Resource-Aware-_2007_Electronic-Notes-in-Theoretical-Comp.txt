Component-based software development allows programs to be reused, interchanged and even downloaded onto a running system. Sometimes the maker or user of a component would like to keep some of the data inside the component secret from other components on the same system. This goal is complicated as the potential attackers may be running on the same computer as the target component and so can monitor its resource usage. We develop a framework for automatically check- ing how well values inside a component are kept secret from an attacker that can communicate with the component and monitor its resource usage.

Weighted automata have a simple weight or cost on each transition and have been extensively studied since the early days of computer science [14,22]. Our automata model differs from weighted automata by using a Q-algebra to provide the costs; this allows us to define a truly compositional model of the resource usage of components. Timed automata models label transitions with costs representing the time they take [1]. Priced or weighted timed automata [2,3] model time using clocks and have costs on states and transitions. The cost of each transition is paid each time the transition is made whereas the costs of each state is paid once for each time unit the automata spends in that state. This provides an expressive model of costs and time that is, in many cases, undecidable [8]. Our model is also similar to some process calculi, such as CCS [19], one of the main differences, apart from the automata setting, is that we allow multisets of actions to happen at the same time. In the context of computer security, there are several papers on modelling re- source consumptions of different execution scenarios, [9,17]. A conceptual difference between our work and these papers is that they mainly focus on measuring the re- sources consumed by the attacker in an attack, whereas we allow the attacker to measure the resources consumed by the target system, and possibly use it to launch an attack. In this respect, our work is close to the body of research on side channel

In the next section we introduce our automata model and cost algebra. In Section 3 we extend these automata to pass values and define secrecy degrees for these values. Section 4 introduces our automatic tool to check secrecy. Finally Section 5 concludes the paper.

The set of actions of P , written Act , contains four types of actions: Input on a name from a segment of the domain a?(x)[d1,... , d2], output on a name a!(n1), internal action on a name a(n1), and conditionals on data values if (n1 = n2) as well as if (n1 /= n2). 1 4. For this automata our tools tell us that vsd(1) = 2 : 2, vsd(2) = 2 : 3 and vsd(3) = 2 : 3. While this is not perfect secrecy, these increased secrecy degrees show that the attacker cannot learn which value was the first choice and which was the second.

