Visibility is one of the most important problems in computational geometry, and it is a subproblem of many others, such as finding the shortest path in a plane with obstacles or the hidden line elimination problem. Diverse applications like video games and robotic motion planning have to deal with visibility. In this paper, we will focus on visibility from a point into a set of segments. Our goal is to provide an efficient parallel algorithm for modern parallel architectures such as the ones presented in current GPUs.

The visibility problem on GPUs has already been seen by Shoja and Ghodsi [5]. In their work, they give a parallel algorithm to solve the point visibility problem on a simple polygon in O(log n) time with O(n) processors. Our algorithm will solve the problem for a less restricted set of obstacles, a set of non-intersecting segments, taking the same computational time, which is optimal for the visibility of line segments [9].

Our algorithm is based on the technique given by Atallah et al. [2] for solving computational geometry problems on a divide and conquer paradigm for the CREW- PRAM computational model. We also take several visibility concepts from the work of Asano et al. [1] where they build a data structure to find a visibility graph in O(n2).

Let S be a set of n arbitrarily oriented segments on the plane P allowed to intersect only at their endpoints, and let q be an arbitrary query point. The visibility region VS(q) is the set of all points on P that are visible from q [6]. A point p is visible from q if the segment pq does not properly intersect any of the segments in S. We say two segments properly intersect if they share exactly one point and this point lies in the interior of both segments.

x-axis. If a segment with endpoints a and b crosses the positive x-axis on point c it is going to be divided into the segments ac and cb. We will call this new set of segments Sq and let nq = |Sq|.

In the cascading divide and conquer technique we model the solution process as a binary tree. Each node represents a sorted list of some type. For the inner nodes, the list is the sorted merge of their two children in a rather complex way. The starting lists of the leaf nodes depend on the nature of the problem. We find the solution of the problem by merging the nodes in a bottom-up fashion. The root of the tree represents the final solution.

In this section, we propose an algorithm based on the cascading divide and conquer technique for the point visibility problem. For simplicity we will assume that the segments have already been translated so the query point is the origin, the collinear segments with the query point have already been removed, and the segments that cross the x-positive axis have already been broken in two. Then we explain how we can query in logarithmic time whether a point is inside the visibility region or not using the resulting data structure. The section ends with an insight on how parallel merge works and how can be used for the parallel version of the algorithm.

Since the additional operations take constant time to compute, the time com- plexity for the Visibility Merge algorithm is the same as a regular merge, O(n). As in mergesort, in order to merge all the elements we need to do O(log n) passes, each pass taking a total of O(n) time. The final time complexity to find the visibility region is O(n log n).

Given that this algorithm is so akin to mergesort we can use parallel merge [4] to parallelize it. The way parallel merge works is by splitting the lists to be merged into non-overlapping sublists. Each processor then does a serial merge of the two sublists assigned to it.

The problem with parallel merge is that the workload is not evenly divided and processors have a different amount of elements to merge. This is not efficient for GPU architectures because threads are grouped in warps that must execute the same instructions, and it could lead to idle threads while others are working. This problem is solved by GPU merge path [7]. Merge path divides the lists into sublists

The CUDA programming model is described in [8]. Basically, we can invoke C functions on the GPU, named kernels, that are called N times on N threads in parallel. The threads are organized in blocks. One block is a group of threads that have access to a shared memory. Multiple blocks reside in a Stream Multiprocessor (SM), which has hardware limitations in the amount of shared memory and number of threads that can be executed concurrently.

Visibility regions are then computed at two levels. First at a block level where we independently compute the visibility region of the nv segments assigned to each block. We use GPU merge path to partition the lists and assign them to the nt threads. After log2 nv passes we get the visibility region of the nv segments.

At the next level we compute the visibility region of all segments. We merge the n/nv visibility regions cooperating between blocks. Just as at the block level we use merge path to partition the lists and assign the sublists to the blocks. The blocks then again divide their sublists and assign them to their threads. We do this for log2 (n/nv) passes and finally obtain our result.

CUDA code was compiled with CUDA toolkit 9.1 and C++ compiler g++ 5.4.0. The compute capability version set for compilation was 3.7 to target the Tesla K80 GPU. Additional flags were -std=c++14, -O2 and -use fast math. The serial version was compiled with just the -std=c++14 and -O2 flags.

