Code Generation is an increasing popular technique for implementing Software Product Lines that produces code from abstract specifications written in Domain Specific Languages (DSLs). This paper proposes to take advantage of the similitude among the products in a domain to generate them by analogy. That is, instead of synthesizing the final code from scratch or transforming the DSL specifications, the final products are obtained by adapting a previously developed domain product. The paper also discusses the capabilities and limitations of several currently available tools and languages to implement this kind of generators and introduce a new language to overcome the limitations.

Code Generation is an increasing popular technique for implementing Software Product Lines (SPLs) [1] that produces code from abstract specifications written in Domain Specific Languages (DSLs) [2,3]. The next paradox usually comes up when a DSL compiler is developed. A DSL is a specialized, problem-oriented language. From the point of view of the DSL user, it is interesting that DSL is as abstract as possible (supporting the domain terminology and removing the low-level implemen- tation details). On the other hand, from the point of view of the compiler developer, the DSL abstraction makes harder to build the compiler. That is, the further DSL specifications are from the final code, the more difficult is to transform them into final code.

This paper introduces an intermediate solution, the Exemplar Flexibilization Language (EFL), that provides new operators to overcome the regular expressions limitations. EFL also supports the integration with parsers to manage marginal complex exemplar modifications. Besides, EFL supports the implementation of crosscutting generators, that manage variability scattered over the exemplar, and the decomposition and combination of generators.

The rest of the paper is structured as follows. Section 2 summarizes EFL. Section 3 introduces the EFL capabilities to overcome important regular expression limitations. Section 4 lists successful applications of EFL to solve several examples taken from the generative programming literature and to develop real SPLs. Finally, the section 5 summarizes the presented work.

A technique for developing a DSL interpreter quickly is embedding it into a dy- namic general purpose language [14]. This way, all the host language capabilities are implicitly available from the DSL. Unfortunately, the pay-off is that the DSL concrete syntax has to fit in the host language concrete syntax. EFL is currently implemented applying this technique: it is a library of the Ruby object oriented language 6 [15]. As we will see, thanks to the Ruby extensibility, the EFL concrete syntax is reasonably usable.

There are two fundamentally types of regular expressions engines: the Determinis- tic Finite Automaton (DFA) and the Nondeterministic Finite Automaton (NFA). Being irrelevant for DFA engines how the regular expressions are written, the be- haviour of NFA engines, however, depends on the representations of the regular expressions 13 . According to Jeffrey E. F. Friedl [9], most of the programming languages 14 implement NFA engines because give more control to the program- mer, since the representation of a regular expression sets the way the NFA engine backtracks during the matching resolution. Besides, NFA engines provide inter- esting features, such as capturing parentheses and the associated backreferences ($1, $2...), and lazy quantifiers.

Writing a complex and time-efficient regular expression for an NFA engine may be quite hard. To simplify this work, EFL provides the zoom operator (>) that supports the step-by-step writing of regular expressions. Thanks to this operator, regular expressions can be chained to specify progressively a text pattern; i. e., the expression:

Writing a /[(] ...[)]/ regular expression for each particular case is quite hard and repetitive. Fortunately, this work can be automatized using the Ruby meta- programming capabilities. For example, the next nested parentheses method receives a levels number of balanced parentheses and generates the corresponding regular expression 16 . Internally, this method makes a string that contains the Ruby code for the corresponding regular expression and, then, calls the eval method for asking to the Ruby interpreter to evaluate the string 17 .

We have discussed the capabilities and limitations of some currently available tools and languages (such as text templates, regular expressions, metaparsers and transformation languages) to implement this kind of generators. We have introduced the Exemplar Flexibilization Language (EFL) which overcomes some important limitations of the studied tools and languages. In addition, we have shown that, instead of being an exclusive alternative to these tools or languages, EFL can easily be integrated with many of them.

