Implementation of a rule-based transformation engine consists of several tasks with various abstraction levels. We present a new tool called mtom for the efficient implementation of rule-based transformations. This engine should help to bridge the gap between rewriting implementations and practical applications. It aims at implementing well-identified parts of complex applications where the use of rewriting is natural or crucial. These parts are specified using rewrite rules and integrated with the rest of the application, which is kept in a classical imperative language such as C, C++ or Java. Our tool, which can be viewed as a Yacc-like pre-processor, does not depend on a given term representation, rather it accepts implementation of terms (or term like data-types) of yet existing applications and it permits to define and execute rewrite rules upon those types. From our experiences, this system is well-suited for industrial use as well as for implementations of rule-based languages. The paper introduces several features supported by mtom.

Only few industrial applications are implemented using tools that perform rewrite rules. However, rewriting is of greatest interest for symbolic and alge- braic computations, program transformations, compiler constructions, etc. A couple of existing rule-based programming languages (such as ASF+SDF [17], Cafe-OBJ [12], ELAN [5] or Maude [7]) have been yet used in the development of large applications but their connections with industrials are rather limited. This is probably not because of a lack of will on both sides (industrials as well as rule-based programming promoters). For example, several serious attempts have been made to use ELAN in industrial applications. But those attempts

To bridge the gap between rewriting implementations and practical ap- plications, we propose a new tool called mtom (for Many-To-One Matching). Its design follows our industrial experiences and our works on the efficient compilation of rewriting [30,16]. From our point of view, this new tool is very useful for implementing well-identified parts of complex applications. These parts are specified using rewrite rules and integrated with the rest of the ap- plication, which is kept in a classical imperative language such as C, C++ or Java, called goal language in the rest of the document.

When trying to integrate a black-box tool into an existing system, one of the main bottlenecks comes from data conversion and the flexibility of- fered to the user. One of the main originality of our system is to allow a flexible term representation. The programmer can use (or re-use) his own data-structures for terms and then execute rule-based functions defined upon those data-structures. We propose to access terms using only a simple user- defined Application Interface (API). This allows the programmer to work on multiple term representations, including user-defined data-structures as well as existing built-in data-types. The proposed tool is also able to cooperate with a variety of memory management methods and does not impose any particular evaluation strategy. It is general enough to permit the user to im- plement his own rewriting strategies. The innermost normalisation remains the default strategy and we will use it in most of the cases.

The paper is organized as follows. After this introduction, we start with a brief overview of our approach that has led to the development of mtom (Section 2). The notations and definitions are given in Section 3. Then, we present in Section 4 how to encode innermost rewriting using mtom. The specification language of mtom is given in Section 5. Its main features are discussed in Section 6. Eventually, we compare our tool with existing works (Section 7), and we conclude with some final remarks (Section 8).

way and we believe that there is no need for a particular new syntax to rep- resent them. Simply, let us suppose that for each n-ary function symbol occurring in the signature, we have implemented a term constructing func- tion (n-ary) f, written in the goal language and whose evaluation returns the term f (t1,..., tn), when called with t1,..., tn as arguments. In this case, the construction of a given term (right hand side of a rule), can be directly imple- mented in the goal language by several nested function calls. For example, in order to construct the term f (g(a)) we just write the code: f(g(a())).

Because of the above discussion, our tool will only process left hand sides of rules, which are called patterns. Given a set of patterns, the tool generates a many-to-one matching function in the goal language. Each pattern has a semantic action, which is executed if the given pattern matches the input term. The semantic action is directly written in the goal language and is supposed to construct the right hand side of the rewrite rule.

Our tool can be seen as a Yacc-like pre-processor. The input is a set of patterns together with their semantic actions (written in the goal language). The output is a function, say mtom main(input term), providing many-to- one matching of the input term against the given set of patterns. Similarly to Yacc, semantic actions are inserted directly into the generated function. In order to keep the tool general and simple, the mtom main function per- forms matching only at the top position of the input term (see Section 4 and Section 6.5 for full normalisation implementations). If a particular pattern matches the input term, then the corresponding semantic action is executed. This also explains why we call our tool mtom, since it provides basically a Many-To-One Matching compilation. In order to be as general as possible, we restrict our tool to this unique functionality. Hence, even elementary rewrit- ing strategies must be implemented by the user. However, as we will see in then translated into a specific goal language such as C, C++ or Java. This code can then be compiled by a standard compiler and linked together with other files of the whole project. An important question is: what will be the form of rewrite rules given to mtom? We will give an answer to this question after explaining how to implement efficiently an innermost rewriting.

As a special support for innermost normalisation, mtom generates a skele- ton of normalising term construction function for each defined function sym- bol. There are two reasons that explain why mtom does not generate a term construction function for constructor symbols of the signature and is only restricted to defined symbols. The first main reason is that mtom does not construct terms, and a term construction function for a constructor symbol always results in the construction of a constructor-based term. Another reason is that we suppose that the description of a rewrite system can be organized into several files sharing the same signature. In this case, the generation of functions for all symbols in each of those files would generate conflicts at link time.

The two first functions (zero and suc) use the ATmake function, which only consists in constructing a term for the pattern introduced as a string (first ar- gument). The third function (plus) is more interesting since it decomposes its first argument u, using the ATmatch function 1 , and returns either y (corre- sponding to the first rule), or suc(plus(x,y)) (corresponding to the second rule). As we can see, the compilation of innermost normalisation of a term is quite easy and straightforward. If we need to get the normal form of a term, say Plus(Suc(Zero()),Plus(Suc(Zero()), Zero)), we just write in the goal language the expression plus(suc(zero()), plus(suc(zero()),zero())). The result of its evaluation will be the term Suc(Suc(Zero)).

The generation of normalising term constructing functions does not restrict the user to an innermost normalisation strategy: there is no obligation for the user to construct terms with this set of functions generated by mtom. When implementing other evaluation strategy, the user can define its own term construction functions. The reduction mechanism is therefore kept fully under the control of the user.

In order to be flexible, the user is not restricted to have only one uni- form term representation (see Section 6.2 for more details): the API can be parametrized by the type name of the class of terms to be considered. Those types are enclosed between < and > signs.

Patterns and rewrite rules are introduced by the %rule keyword followed by a pattern, the %--> sign and by a semantic action. The semantic action will be executed if its corresponding pattern matches the input term. In this case, local variables (generated by mtom) record the matching substitution. If a return statement occurs in a semantic action it is supposed to return the right hand side of the rule.

rewriting, rewriting with local assignments, strategy controlled rewriting, etc.), possible ambiguities are solved as follows: If there are several patterns appli- cable on the given input_term then the first applicable rule is taken, i.e. the semantic action corresponding to the first applicable pattern is executed. If a semantic action does not exit by the return statement, then the next possible match of this rule is taken and the semantic action is executed again for the new substitution (this applies only on possible extensions of matching, see Section 6.4). If there is no more different matches for the same pattern then the next applicable pattern (in order of appearance) is taken and its semantic action is executed. Those rules permit us in particular to implement condi- tional rewrite systems, where the construction of each right hand side will be enclosed in an if statement (this if statement comes from the goal language, it is not an mtom construction, of course). Let us take for example two rules (note that this example involves built-in data-types of the goal language, see Section 6.1):

Until now, we did not take into account the question of memory management. This is because the user has to take care of this problem. However, unless an automatic garbage collector is used (like for instance with ATerms [27]), some kind of cooperation is desired. This concerns mainly accessing parts of a term matched by a pattern. Some parts should be freed after an application of rewrite rule. Semantic actions need to be able to access particular subterms of the term to be reduced. In mtom, a special mechanism is provided to handle this situation. By convention any subterm of the input term corresponds to a local variable denoted by its position in the pattern. For example, the local variable _1 denotes the first subterm, whereas the variable _2_1 denotes the first subterm of the second subterm. Note that when a particular semantic

A variable may have multiple occurrences in a pattern. Such non-linear pat- terns cause that mtom will need to compare two subterms of the input term. Because mtom is not supposed to know the entire term representation, the user needs to specify how to compare two terms in its API part.

c) (where + is associative and commutative), then x has to be instantiated by the (b + c) which did not exist before. It must be created during the matching process. Second, specific non-syntactic matching algorithms are usually working with their own internal term representations. In order to be efficient, this would oblige the users to adopt this term representation and we would loose another nice mtom property, which is to be independent on a particular term representation.

When starting our work on mtom we thought that a particularly good choice of the many-to-one matching algorithm would be essential. Now it seems that the tool design has its importance in its own. It offers a specification language for industrial use of rewriting. When a user practices with mtom, its application will not depend on a concrete implementation of the many- to-one matching algorithm. The user is free to switch among different mtom implementations with different pattern matching algorithms.

For the moment, the concrete choice of the many-to-one algorithm does not have so much importance. However, we feel that such an algorithm should have reasonable time and space complexities. In the future, we plan to make experiments with sophisticated pattern matching algorithms like the one in- troduced in [26].

As we have mentioned previously, the user can define its own evaluation strate- gies when using mtom. If semantic actions are just building right hand sides of rules instead of reducing them, then mtom itself does not provide and does not impose any reduction strategy. It turns into a simple tool for many-to-one matching and the generated function mtom_main provides one reduction step at the top position of its input term. Using this function, the user can easily define its own evaluation strategies.

However note that this case is much more complicated. For example, the fact that no rule is applicable does not necessary mean a wrong design. It may mean that an argument is not sufficiently evaluated at the moment. Due to this fact, the default rules should evaluate their arguments before causing an error message. Also conditions have to explicitly call an evaluation function before failing in the application of a rule.

Let us take for example a rewrite system computing the (infinite) list of all prime numbers. This example defines a function ilist computing the (infi- nite) list of all natural numbers; a function isprime testing whether a number is prime or not by trying to divide it by previously computed prime numbers; a function pfilter getting the infinite list of natural numbers and filtering it by the isprime function which results into the list of all prime numbers. The pfilter function also keeps the list of already computed prime numbers in its second argument. Semantic actions use functions Cons, Ilist, Isprime, Pfilter which are supposed to construct corresponding terms without trying to reduce them. This example acts on Peano arithmetics and uses functions mul, mod and div implementing respectively the multiplication, module and division between two Peano integers. Those functions are supposed to re- turn normal forms of the result (innermost normalisation), so the example demonstrates also a combination of different rewriting strategies in a single program.

In this example we have to define two C functions controlling applications of rewrite rules: the function lazystep providing a single application of a rule and the function lazynf computing a normal form of a given term. Both functions act in a lazy manner meaning that they reduce an outermost position first. Those functions use global variable mtom reduction occured. This variable is cleared by the mtom main function in case that it did not provide any reduction.

In some languages (ELAN for example), rewriting is performed in a non- deterministic way, meaning that several possible rewrite steps are explored successively by backtracking. Non-determinism occurs when several rewrite rules can be applied on a single term. In such a case, all the possibilities should be explored.

instruction and the default rewrite rules (applied when no regular pattern matches) execute the fail() function. This ensures that a choice point is set and then the right hand side is constructed and returned (the true branch of the if statement). In the case that a fail occurs somewhere in further compu- tation, the control comes back to the last if(setChoicePoint()) statement and pass throw the false branch at the end of the semantic action. This will cause that next match and the next applicable pattern will be examined.

In the single-match style, a successful match yields just one binding. This style is usually taken in declarative programming languages. In partic- ular, most functional programming languages [4] such as CAML [8,31], Clean [6,24], Erlang [2,1], Gofer [14], Haskell [15,23], or ML [9,18] allow defining functions by pattern matching.

The compilation scheme consists of two phases: (a) The abstract syntax tree is transformed (using mtom itself) into another tree representation where each group of rule constructs is replaced by a matching automaton. (b) The latter is pretty-printed according to the chosen goal language. If one wants to enrich the generator with another goal language, it is sufficient to parameterize or to extend this phase according to the goal language constructs (How to declare a variable? How to assign a variable? How to perform an if-then-else? etc.)

A new match primitive is added. Contrary to the existing rule construct, the match construct can be used everywhere a goal language instruction is allowed (in blocks or functions for example). Furthermore, this construct is more powerful since it can be used to group any set of patterns (even those with different top symbols). This feature is particularly useful when com- piling strategy controlled rewriting [5,29] (i.e. a set of rules applied under a given strategy). It is clear that the current rule construct is implemented using this more atomic construct.

