To create a formal hardware and software description that are in accord with each other, codesign[3,8] provides a design framework where an embedded system is captured in a unique system design without discriminating hardware and software. The system design is partitioned into respectively a specific de- tailed hardware and software design for implementation of them. However, such codesigned software models cannot be often implemented correctly and completely due to hardware and software interaction problems, such as com- municating timing. The behavior of embedded software, in addition, gener- ated from a codesigned system can often differ from the behavior of original software model because of resource constraints where processes are limited to the use of resources. Thus, it is necessary to capture and reason the behavior of embedded software that is restricted by not only communicating time but also resource constraints.

Embedded system models can be divided into structural model and behavioral model[2]. Software developers are usually even more concerned about how these structural elements behave dynamically as the system runs. Douglass[2] suggests a behavioral description using statechart[4]. However, He does not discuss how to define hardware properties, such as time, resource restriction, in the embedded system model.

Resources in computer system are physical and logical elements that applica- tion software needs in processing data. For instance, some embedded software needs physical elements, power and bandwidth, to meet QoS and CPU, mem- ory, and I/O devices, to process its data. Some embedded software needs a logical element, data structure, semaphore, message queue, mailbox, net- work data packet served by operating systems for accessing to such hardware devices.

ROM defines software behavior restricted by hardware constraints, such as timing and availability, as a property of resource model. The software behavior in ROM can be verified against such hardware constraints. The re- source model in ROM is originated from hardware engineers. They prove its timing properties using hardware timing verification techniques. And then, the hardware model can be abstracted in a software engineer view for pro- viding hardware constraints to software engineers, and software engineers can build their software behavior model based on the software-oriented hardware behavior model and verify it against the hardware model.

In resource-oriented models, there are software behavior model, software- oriented hardware model, resource model, Resource-Independent Model, and Resource-Oriented Model. The first three models are embedded system com- ponent models, and the last two models are embedded system models. To explain each property of resource-oriented models, we present an example of a signal and gate control system.

In Example 6.3, The functionality of gate control system is captured in ACSR. The gate starts its closing operation when it is opened(OPENED) and receives a signal tick from a timer. If the signal of green is on and the others are off, it continues its actual closing operation with sending a signal GO to the signal control software(('Go, 1).CLOSIN G).

design we discuss here pursues a modeling of a resource including more explicit and specific behavior of a hardware component. That is, only an exclusive use of a resource in modeling a resource can be captured in the specification of ACSR. Meanwhile, the resource-oriented design pursues capturing not only the exclusive use of a resource but also a specific impact of resource behavior on the behavior of software.

