The introduction of the tactic calculus and the definition of its semantics go further than syntactic packaging of the underlying system of open terms in the sense that they allow us to define proof-search procedures as terms in the tactic calculus. In these search procedures we may use constructs not available in the underlying calculus as unification, failure handling and recursion. The idea is that the result of such procedures should be related to the calculus of open terms in order to guarantee that the process of interactive proof construction is sound. Next to stating that successful evaluations of tactics produce a well- typed result, the soundness theorem gives a relation between the state of the prover before and after the execution of a tactic. This means for example that when we execute a tactic that is supposed to solve a goal, this does not happen by just introducing a new axiom.

instantiating operation that allows us to fill in a value for an unknown. For details on the calculus of open terms we refer the reader to [3] 3 . Here we will only note that a meta-variable has a declaration ?m[x1 : A1 ... xn : An]: A (typically given in a context) and instances m[t1 ... tn] that occur in terms.

Non-terminating recursion. We will allow tactics to be defined by recursion without imposing syntactic constraints that guarantee termination. There are two reasons for allowing non-restricted form of recursion. The first one reason is that a terminating system will necessarily be incomplete and the second is that in the presence of the unification constraints the formulation of a syntactic criterium that guarantees termination seems to be a difficult problem to which we have not found a satisfactory solution (i.e. a decid- able syntactic criterium that covers the examples that we intend to give semantics to).

A tactical can generally be described as a mapping that transforms proof states by solving and introducing meta-variables generated by tactic terms. The most basic tactical is the tactic application tactical. It takes a tactic term as an argument, evaluates it in the context of the current goal and instantiates and introduces meta-variables as prescribed by the tactic. Other tacticals include different kinds of composition, failure handling, tacticals for handling of naming etc.

Unfortunately, due to space restrictions we cannot go into a detailed dis- cussion on tacticals and their semantics. In Section 4.1 we will give an im- pression of the intended semantics of the tactic application tactical because it is essential for our discussion on the semantics of tactic terms.

The rule for evaluating defined tactics makes sure that the arguments of the tactic are well-formed. Then it propagates them through the body of the tactic and evaluates the result. We may think of T in this rule as one of the tactics defined in Section 3.

Last, but not least, our work has been influenced by the Pure Pattern Type Systems (PPTSs) of Barthe et al. [1] which is an extension on previous work on the rewriting calculus (see e.g. [4]). Our approach relates to this work in the following way: In a PPTS one abstracts a pattern and then this pattern is matched to the actual argument given to the function. As in our case, this results in an instantiation. The fact that matching is performed (as opposed to unification) means that the pattern reduction is localized only to the redex that we contract, while in our case there may be side effects that make the reduction non-local.

