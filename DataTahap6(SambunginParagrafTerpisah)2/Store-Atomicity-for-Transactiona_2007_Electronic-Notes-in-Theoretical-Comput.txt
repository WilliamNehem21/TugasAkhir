Having established a local ordering < among the instructions in a single thread, we must now describe the behavior of multiple threads which execute together. The only means of communication between threads is via Stores and Loads. At the highest level, any multithreaded execution must be serializable modulo reordering. We begin by giving a formal definition of serializability in a transactional setting; this definition is more complex than the definition of non-transactional serializability.

Note that we have pictured only one of several possible executions of this fragment. It is possible for L5 to instead observe S2. In that case, no known ordering would exist between S2 and S3, and L6 could observe either S1 or S4.

We have written the above procedure to be as clear as possible. However, it is not a normalizing strategy : A program which contains an infinite loop can get stuck in the graph generation and execution phases and never resolve a Load. More complicated procedures exist which fix this problem (one starting point is to avoid unfolding or execution past an unresolved Load).

What distinguishes speculation from mere reordering is the possibility that it can go wrong. We can describe speculation in our graph-based formalism in two ways: First, we can perform value speculation, guessing values and verifying them later; we defer this to future work. Second, we can resolve instructions early, before all of their dependencies have been satisfied. This can result in violations of Store Atomicity. In [4] we discuss a particular example, address aliasing speculation, arguing that while it permits new behaviors compared with a non-speculative model, it leads to a simpler and easier-to-understand memory model.

The operational framework given in Section 4.1 limits Load Resolution to a transaction which contains a mix of resolved and unresolved Loads. Conceptually, it is simple to permit Load Resolution to occur in any thread: simply discard a behavior if it is ever discovered to contradict the rules of Store Atomicity. An actual system, however, only works with one behavior at a time. When an inconsistency occurs, we must decide which instructions to roll back.

The literature on memory models is a study in the tension between elegant, simple specification and efficient implementation. Collier [5] is a standard reference on the subject for computer architects, and established the tradition of reasoning from examples which we have continued. The tutorial by Adve and Gharachorloo [1] is an accessible introduction to the foundations of memory consistency.

locks. However, data races are still possible in a transactional setting if shared data is manipulated outside a transaction. The idea of properly synchronized programs [2] will continue to be relevant, albeit under simplified assumptions. The community is just beginning to formulate transactional consistency protocols comparable to release consistency [7,13].

Better understanding of transactional serialization: Store Atomicity is a property that captures which instructions must be ordered in any serialization of an execution. In this respect, our semantics for transactional memory are not yet completely satisfactory: in practice many implementations interleave the instructions of multiple transactions without harm. The conditions outlined in Section 3.5 are a starting point, but further refinement of these conditions is undoubtedly possible.

Tools for verifying memory model violations:  It should be relatively easy to take a program execution and demonstrate that it is correct according to a given memory model without the need to compute serializations. Graph-based approaches such as TSOtool [9] have already demonstrated their effectiveness in this area. Techniques similar to those described here (most notably routing inter- thread dependencies through Trans and Commit operations) have been suggested for checking transactional memory models. Similarly, it would not be difficult to adapt the techniques of UMM [20] to perform exhaustive model checking in a transactional setting.

an easy to understand memory model. It is our hope that transactional models are simpler to understand, particularly for programmers. It has been conjectured [8] that transactional techniques (particularly batched updates) can scale well even when a relatively strong memory model is chosen. It remains to be seen how well these claims stand up on very large systems (those with tens, hundreds, or even thousands of multi-core CPUs).

Krste Asanovic played a vital role in targeting our work to computer architects. Our work has benefited greatly from numerous comments and conversations over the years. For our treatment of transactions in particular we would like to thank Maurice Herlihy, Victor Luchangco, Yossi Lev, and the rest of the Scalable Synchronization Research Group at Sun Microsystem Laboratories. Jan-Willem Maessen would like to thank the Fortress team. Arvind was supported in part by the IBM PERCS project. Both projects were funded in part by the DARPA HPCS program.

