The development of distributed systems is known as a difficult task. Besides dealing with the inherent complexity of concurrent systems, the developer also has to take distribution aspects into account. In such cases, communication latencies and availability of nodes and services, among others, become important aspects to consider which may lead to the success or not of the application.

Although model-checking is an important analysis method, in many situations one has to evaluate, as early as possible during the development, non-functional as- pects like availability and performance of the system under consideration. Moreover, in many classes of applications it is not possible to assure certain properties. In such cases it is important to be able to associate probabilities to satisfaction or not of the property under reasoning.

Stochastic processes allows one to model the interaction of distinct phenomena, each described by a different probability distribution. Among various stochastic pro- cesses, Markov Chains [13] have been extensively investigated and used in computer sciences and engineering. Markov Chains are discrete state stochastic processes that can be continuous or discrete time, and have the memoryless property. This prop- erty assures that the transition to the next state depends only on the current state of the system and not on the previous ones. The use of exponential and geometric probability distributions associated to the transitions assures the memoryless prop- erty for continuous and discrete time Markov Chains, respectively. The solution of a Markov Chain results in the probability of each state of the chain, considering the steady state situation.

In [7] a first step towards the stochastic analysis of graph transformation sys- tems is given. In that contribution, the authors associate (exponential) probability distributions to rules. With this, the transition system obtained from the graph grammar gives raise to a Continuous Time Markov Chain that can be analyzed with existing tools.

The paper is organized as follows: the next section presents OBGG and the running example - the model of a token ring network. Section 3 presents the main characteristics of SAN. The extension of OBGG is proposed in Section 4. The translation from OBGG to SAN is discussed in Section 5. Section 6 analyzes the example and final remarks are in Section 7.

The specification of an object-based system is done via an (object-based) graph grammar. We will present the kind of graphs and rules that will be used for the specification of object-based systems. These graphs are called object-based graphs and were introduced in [5].

The token-ring protocol is used to control the access of various stations to the shared transmission medium in a ring topology network [14]. According to the protocol, a special bit pattern, called token, is transmitted from station to station in only one direction. When a station wants to send some content through the network, it awaits for the token, holding it, and sends the message on the ring. The frame circulates the ring and the destination station may copy its contents. When the frame completes the cycle, it is received by the originating station. The originating station then removes the frame from the ring and sends the token to the next station, which then may act as already described. Having only one token, only one station may be transmitting in a given time.

In the Stochastic Automata Network (SAN) formalism, a system is modeled by interacting subsystems which, in turn, are represented by automata that may behave independently or may have dependencies. According to [13,2], SAN has exactly the same application scope as Markov Chains, with the advantage that models are constructed componentwise and the mathematical solution is optimized in terms of state space [10]. SAN models can be discrete-time or continuous-time. In this paper we focus on the continuous-time case. Here we will use a less general definition of SANs, since we do not need all features of this formalism to describe a sthocastic extension of OBGGs.

An automaton is composed by states and transitions labeled with event names. A SAN model is composed by various automata. These automata may evolve inde- pendently with local events (that may affect only the local state of the automata participating in this event), whereas synchronizing events are used to model joint evolution of two or more automata. With the association of distribution probab- ilities to the events, the labeled transition system generated by a SAN gives raise to a Markov Chain and it is possible to calculate the steady state probability of each state of a SAN. More concretely, to each event there is an occurrence rate associated. The inverse of the occurrence rate is the mean value of the exponential distribution function that regulates the time interval between two occurrences of the event.

A SAN defines the set of events that are used to synchronize the different auto- mata during the execution. The state changes of SANs are possible when all different automata that may engage in some event are in some state in which a transition labeled with this event is possible. Note that, since there may be different trans- itions labeled with the same event, there may be different reachable state starting with the same state and executing the same event.

In this section we will define stochastic object-based graph grammars. In a graph grammar, state changes are modeled by rules. Associating occurrence rates to rules (as done for events in SAN and for transitions in SPN, for instance) it is possible to obtain a transition system semantics where each state of the system will have a probability associated, which is the probability of the system being in that state in a steady state situation (i.e. the transition system semantics gives raise to a Continuous Time Markov Chain).

We shall define stochastic OBGGs, short SOBGGs, over (typed and attributed) hyper graphs, i.e., graphs where edges can be connected to any (finite) number of vertices. Graphically, an edge is depicted as a box (whose shape may vary), and the connections to the vertices are drawn as thin lines, called tentacles. The tentacles of an edge are labeled by natural numbers. The main characteristics of object-based graphs are:

Now we introduce object-based graphs and partial morphisms. As discussed above, each hyperedge has one target vertex, and may have many source vertices. Source vertices are identified by different numbers of the tentacles, that is, a hy- peredge is associated to a list of vertices.

The behavior of a SOBGG is obtained by applying the rules successively to a start graph. Each rule application deletes one message (the trigger of the rule) and may change the value of internal attributes, create new messages and/or ob- jects. Formally, the effect of a rule application is obtained by a pushout in the corresponding category (typed object-based graphs).

The computations of a SOBGG are exactly the same as the underlying OBGG (grammar without the tax function). The following definition of the behavior se- mantics describes these computations, without considering the stochastic behavior (that will be considered in section 5.2).

Based on the class graph and the initial graph of an SOBGG, we will construct the sets of automata states that will be used to build the corresponding SAN. In the following definitions, we will use as attributes of classes and parameters of messages lists of n elements, but note that n may be zero, leading to an empty list. The initial graph will be used to get the information about the data values (defined in the algebra component) and objects that may exist in the system. We will use a function states that, given a vertex, returns the set of values of this type. In case this vertex is the name of a data type, the result is the corresponding carrier set of the algebra. In case it is an object type, it returns the set of vertices of this type (object ids) in the initial graph.

A token ring network with four nodes was modeled, having a static topology, i.e. a node does not change its neighbors. Due to the static topology of the example, the automata next Node1 to next Node4, representing the next attribute of the instances are not necessary. Therefore, each node was modeled with three automata. One for the attribute sent and two for the possible input messages. There are two states in each automaton. This results in 12 automata and a product state space of 4096 states. However, considering the initial state as described, only 20 states are reachable.

Other scenarios could be specified changing the values of the rates. This could be useful, for instance, to guide a system developer to predict the network throughput (considering various workloads). The definition of rates to represent a specific reality (a real network) will be addressed in future work.

As could be noticed, in order to analyse the SOBGG model the user has to know the generated SAN model to extract results. More concretely, the user writes integration functions about the states of the various SAN automata and their prob- ability. One important future work should be to allow the analysis of the model based on the SOBGG abstractions and not on the generated SAN, which should be, ideally, hidden from the user.

In the case studies carried out so far, we could notice that SOBGG models, when translated to SAN, tend to generate a large product state space but a re- duced reachable state space. The PEPS tool, in the current version, first calculates the product state space and then solves the system, assigning probabilities to the reachable states. Therefore our models are restricted in the product state space. A new version of the PEPS tool is being developed whereby the product state space is avoided and the reachable state space is calculated directly. This enhancement will allow the stochastic analysis of models with considerable size.

