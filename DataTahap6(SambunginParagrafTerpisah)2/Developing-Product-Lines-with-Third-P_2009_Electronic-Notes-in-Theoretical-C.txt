The trends toward product line development and toward adopting more third-party software are hard to combine. The reason is that product lines demand fine control over the software (e.g., for diversity management), while third-party software (almost by definition) provides only little or no control.

In this paper, we describe our solution to this problem which combines the Koala component model developed within Philips with the concept of build-level components. We show that by lifting component granularity of Koala components from individual C files to build-level components, both trends can be united. The Koala architectural description language is used to orchestrate product composition and to manage diversity, while build-level components form the unit of third-party component composition.

Cost reduction and time to market are driving factors for developing software product lines. Often proprietary technologies are used for managing diversity to enable quick product development. Until recently, it was common practice to develop most (if not all) software in-house, especially for industrial prod- uct line architectures. Today, the trend toward reduction of cost and time to

Unfortunately, third-party software usually does not integrate well with proprietary product line technology. Product-line technology typically de- mands specially flavored components and fine-grained control over software artifacts. Since product-line technology is not standardized, it is very likely that third-party software does not fit, and that it is not allowed or possible to make it fit. As a result, either the use of third-party software is preferred over product-line technology, or the other way around. Clearly, this is not an optimal situation.

Koala [10,11] is such a proprietary component technology for creating prod- uct lines. It has been used successfully for about 10 years for defining and constructing a large variety of products. Its key features are diversity manage- ment by means of composition and variation, and the architectural description language (ADL) to define component compositions and to drive code genera- tion.

Koala [10,11] is a component model consisting of an architectural descrip- tion language (ADL) and tool support. The ADL serves to define interfaces, data types, basic components, and compositions (which are components them- selves). The tooling serves to generate products from component composi- tions. Koala was primarily designed for resource-constrained software and is applied in the consumer electronics domain.

Koala is a hierarchical component model where larger components are con- structed by instantiating smaller components. The leaves of a composition tree are formed by Koala modules, which correspond to individual C files. 2 The Koala tooling includes a compiler which creates bindings between components, creates code to manage unbound diversity parameters, and which generates a script to compile/link a composition. Below we will briefly describe a subset of the Koala ADL.

As can be seen from this example, functions from interfaces are prefixed with their instance name. These are called logical names in Koala. In its simplest form, compilation of a Koala composition consists of binding C function calls to C function definitions according to the interface bindings in the Koala composition. A binding is accomplished by mapping the logical names of a function call and definition to a common physical name. These bindings have the form of: association. This split-up enables the use of the Koala language and front- end to drive the composition of other artifacts than C source files. It is this observation that gave rise to the idea of this paper to extend the application of Koala to more coarse-grained components to enable adoption of third-party software. For this purpose, we will propose build-level components as atomic units of composition.

Below we give a small example of a build-level component which makes use of GNU Automake and Autoconf. The component is called Foo and consists of a single library libfoo.a. Its implementation is contained in the C source file libfoo.c. The component has one dependency on the component Bar. Its build interface is generated by Automake from the following build process description:

A normalized composition specification defines a composition tree where nodes represent components and leaves represent modules. At the build-level we will follow this composition tree. Directories will represent components and modules. A Koala module maps to a build-level component. A build-level component is placed in the directory of the corresponding module. A directory for a component is a container which delegates all build-level operations to its subdirectories.

A build-level composition is a build-level component itself. This implies that the composition has its own build process definition. This build process is simple because the top level directory merely serves as container. Hence, most build actions are simply delegated to the subdirectories. The dist and distcheck actions are special and cannot be delegated. These actions con- struct a distribution by packaging all needed files from the composition.

3 In [3] we described an approach for build-level component composition where the com- position tree is always flat. A flat component structure hinders real abstraction, because a component cannot embed another component instance. The structuring in (sub) directo- ries, that we propose now, is much more flexible and allows for composite components at the build-level.

In this section we demonstrate how we can define our Koala compiler in terms of itself (i.e., as a composition of Koala components) and how this composition can be realized by actually running the compiler. We show how Koala allows structuring components to our needs, how nested components can be (re-

We observed this trend within Philips, where third-party (open source) software did not integrate seamlessly with the successful Koala component model. In this paper, we describe a possible solution to this problem by combining the Koala component model and the concept of build-level compo- nents. We have shown that by lifting component granularity of Koala compo- nents from individual C files to build-level components, both demands can be united. The Koala ADL can be used to orchestrate product composition and to manage diversity, build-level components can form the unit of third-party component composition.

In this paper we explained how Koala modules form the mapping from the architectural level to the realization level, and that they can represent arbitrary units of composition (in addition to plain C files). We then defined how a composition of Koala modules can be mapped to a composition of build- level components. Next, we extended our Koala compiler product-line with a new back-end to automate the realization of compositions at the build-level. Finally, we showed how our approach can be used in practice, by defining the Koala compiler in terms of a composition of build-level components.

