A number of authors [2,12,15,18] have recently shown how abstract interpre- tations of program control flow can be extracted from higher-order programs, via the use of type effect systems. In these works, the type effects predict atomic events, and the order in which they occur. In all of these systems ex- cept [12], the effects form simple labeled transition systems (LTSs) on which standard model-checking algorithms can apply to relate abstracted programs with specifications. Such a program analysis allows for automatic static verifi- cation of program properties, including resource usage analysis [15] and access control [18].

The idea of using some form of abstract program interpretation as input to model checking [19] for verification of specified program properties has been explored by many authors, including [7,3,5]. In these particular works, the specifications are temporal logics, regular languages, or finite automata, and the abstract control flow is extracted as an LTS in the form of a finite automa- ton, grammar, or push-down automata. However, none of these works defines a rigorous process for extracting an LTS from higher-order programs.

The system of [12] is based on linear types, which are related to, but dif- ferent from, effect types. Their usages U are similar to our history effects H, but the usages have a much more complex grammar, and do not appear amenable to model-checking. The systems in [8,4,14,5] use LTSs extracted from control-flow graph abstractions to model-check program security prop- erties expressed in temporal logic. Their approach is close in several respects, but we are primarily focused on the programming language as opposed to the model-checking side of the problem. Their analyses assume the pre-existence of a control-flow graph abstraction, which is in the format for a first-order program analysis only. Our type-based approach is defined directly at the language level, and type inference provides an explicit, scalable mechanism for extracting an abstract program interpretation, which is applicable to object

In this extended abstract we focus on transformations of FJsec history effects, showing how they can be useful. First, we define a simple stack transforma- tion called stackification to generate an abstract interpretation of the possible stack states at runtime. This transformation is particularly useful for security analyses such as Java stack inspection [20]. Then, we show how exceptions can be interpreted by another transformation called exnization. A principal benefit of our approach is that a variety of language features can be treated in a modular fashion, without redefinition of type effect inference.

Our program analysis is a type and effect inference system, where effects are approximations of program histories. This approach allows sophisticated type inference techniques to be applied, e.g. constraint-based polymorphic subtyping. This expressiveness has benefits in higher-order functional [18] and object-oriented settings [16]; the latter has a more complete discussion of the type inference system presented here, and its benefits for Java in particular.

e.g. in [17]; however, since security mechanisms such as that proposed in [1] re- quire both a history- and stack-based perspective, we believe that our uniform approach is simpler, hence more efficient, than e.g. combining direct stack- and history-based inference in such a context.

