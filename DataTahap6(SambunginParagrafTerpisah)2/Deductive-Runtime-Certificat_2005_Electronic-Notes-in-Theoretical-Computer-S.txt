This paper introduces a notion of certified computation whereby an algorithm not only produces a result r for a given input x, but also proves that r is a correct result for x. This can greatly enhance the credibility of the result: if we trust the axioms and inference rules that are used in the proof, then we can be assured that r is correct. Typically, the reasoning used in a certified computation is much simpler than the computation itself. We present and analyze two examples of certifying algorithms.

We have developed denotational proof languages (DPLs) as a uniform platform for certified compu- tation. DPLs integrate computation and deduction seamlessly, offer strong soundness guarantees, and provide versatile mechanisms for constructing proofs and proof-search methods. We have used DPLs to implement numerous well-known algorithms as certifiers, ranging from sorting algorithms to compiler optimizations, the Hindley-Milner W algorithm, Prolog engines, and more.

Complete deductive verification of software systems can be extremely onerous. It is a major challenge to prove mechanically that a complex piece of software will always produce the correct output for any given input. The difficulty is due partly to the fact that deductive technology has not yet reached a suffi- ciently advanced state of the art, and partly to the inherently high complexity of software. Nevertheless, formal proofs are a superb methodology for increas- ing reliability, and we would like to find a use for them even when it is not practical to prove a system completely correct.

As given above, the algorithm relies on these two theorems tacitly. In order to prove that the algorithm is correct, the connection must be made explicit. For purposes of static verification, one would use strong induction on b to show that for any given a and b, euclid(a, b) produces gcd (a, b).

As a programming language, Athena is a higher-order strict functional language in the tradition of Scheme and ML. Such a language affords distinct advantages for certified computation, e.g., higher-order proof continuations can be freely passed around, and this often comes handy. Nevertheless, this is not essential. Other programming languages, e.g., an object-oriented language such as Java, could just as well be meshed with the abstract syntax and semantics of DPL proofs in a conservative manner (i.e., so that a Java program that does not contain any DPL proofs looks and behaves exactly as prescribed by the Java specification).

to do so. They also have the option of introducing arbitrary axioms, rules, and decision procedures. The choice of where to anchor the proofs is left up to the users, to be decided on an individual basis by the context of each application. For instance, in the unification example of the next section we introduce five inference rules as primitives. They are not the simplest possible rules: in the worst case, applying four of them takes linear time in the size of their inputs, while the fifth takes quadratic time. The rules could be further reduced, expressed as trusted methods in terms of simpler rules and axioms, albeit at the expense of additional work. But even if we leave them as they are, we will already have accomplished a remarkable trust reduction: instead of having to trust the conventional Martelli-Montanari algorithm, which has a complex control structure and exponential complexity, we need only trust five very short and simple inference rules of quadratic complexity at worst.

Another methodology for attaining reliable software is static program ver- ification, and we have already discussed the main tradeoff between it and our approach, namely, generality vs. feasibility. Another advantage of program verification is that a static proof has a fixed cost. Once correctness has been established, the algorithm can be confidently executed arbitrarily many times without additional effort. By contrast, our model has a runtime price: the algorithm has to do extra work to justify itself every time it generates a re- sult. Nevertheless, in our experience runtime certification has never strictly

We have espoused a notion of certified computation where program results are derived deductively rather than merely generated by arbitrary processes. We have illustrated this approach with examples, and shown that it can result in dramatic reductions of the trusted computing base without being inordi- nately difficult. We have demonstrated that it is a realistic methodology by developing a key enabling technology for it: DPLs, a class of languages that significantly facilitate the formulation of algorithms as theorem provers. We have extensively investigated the theoretical foundations of DPLs, and we have built an efficient implementation of Athena, a DPL that integrates a higher-order functional language with natural deduction. We have success- fully used Athena to express many interesting algorithms as theorem provers. Other programming languages could also be conservatively extended to in- clude DPL-style proofs and proof methods.

