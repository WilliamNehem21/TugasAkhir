The component approach to building systems is gaining audience because of the in- teresting properties of components. We can imagine that software will soon be very large collections of components and that the reuse and sharing of components will be common practice. However, components are often developed by different groups and their dependencies are not clearly specified. Hence installing (or deinstalling) a component is often a gamble since all the dependencies are difficult to find. Using current approaches, installation may not achieve success [15] (an installed compo- nent does not work) and installation or deinstallation may not be safe and disrupt the system. To face the evolution towards component based systems, our aim is to build a tool with formal foundations ensuring the success and safety of deployment.

This paper is organized as follows. First, section 2 introduces the concept of component deployment and illustrates deployment dependencies using the example of a mail server. Next, section 3 presents our description of dependency deployment and section 4 the description of environmental constraints. Then, in section 5 and section 6 we present a formalization of the installation and deinstallation of components and the management of their effect on the target system respectively. Finally, we discuss related work in section 7 and conclude this article by presenting some future work in section 8.

Agent (MTA), Fetchmail that allows to recover mail by an electronic mail transport protocol (e.g., Pop) from a distant host (the messages are redirected to the local transport), Procmail, a Mail Deliver Agent (MDA) that manages received mails and allows, for example, the filtering of a mail. Finally, Sylpheed, a mail manager for reading and composing mail called a Mail User Agent (MUA).

Once the component is proved to be installable, we need to calculate the effect of its installation on the system. This effect consists of new available services, new forbidden services, new forbidden components and a new dependencies (represented by a dependency graph). Before giving the installation rules, we will show how this effect is calculated by defining two operations: CalcF that determines forbidden services and components and the dependency graph calculation.

ment predicate of SMT A is denoted P ). During this phase, the optional dependency is checked to determine whether it provides services (here it contributes the SAV ser- vice). After the installation of postfix, the MTA service (SMT A) and the anti-virus (SAV ) are provided and the component sendmail (CSM ) becomes forbidden. The dependency graph G corresponds to the union of the dependency graphs deduced

The effect of the deinstallation of a component c on a context Ctx involves the set of nodes that must be removed from the dependency graph. This set of nodes contains all provided services of c and all (optional) services depending on them. Once the concrete deinstallation is carried out, Ctx will be updated by removing c (and its provided services, forbidden services and forbidden components) from C and removing 8 from G all nodes of the effect.

A lot of research focuses on the description and the management of component-based systems. Deployment tools such as COACH [9] and deployment specifications such as of the OMG [13] do not support the description of deployment dependency. The constraint one may express in those framework is limited to constraints on the target environment.

