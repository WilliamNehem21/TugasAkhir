The paper suggests a two-level approach to describe visually software architectures and their evolution. One visual modeling formalism is used to describe the ar- chitecture level while another is used to model the behavior of each component (component specification level). Graph transformation is applied for both levels to describe the modeling formalisms and the model evolution in a formal way. The graph transformation based visual modeling approach GenGEd allows the designer to define the concrete and abstract syntax of each formalism. Thus, the choice of the visual formalisms is not restricted to existing ADLs or modeling languages but new visual languages can be defined by the user according to the problem domain. The architecture and component specifications are related over their abstract syn- tax. Here, it is possible to enforce coherence between the two levels while the user is changing the model in the editor generated by the GenGEd tool. The ideas are illustrated by a small example using UML-like class diagrams for the architecture and Petri net like networks for the component behavior.

An appropriate architecture representation has to follow this decomposi- tion paradigm and to support component interactions using an appropriate visualization. A visual tool environment for the visual description of an ar- chitecture should be available. Moreover, the tool environment should allow the user to perform syntactical checks on his model concerning e.g. the im- port/export relations between the component interfaces.

In [15], Kramer and Magee state that the key feature of change manage- ment is a clean separation of functional concerns of individual application processing components on the one hand and architectural coordination of components on the other hand. Additionally, we expect that a method for change management should have a formal background to allow mathematical reasoning and serve as a basis for tool support. The system architecture and the internal behavior of components should be specified by appropriate visual modeling languages. The method should relate changes on the architectural description level to the underlying component specifications and vice versa to allow syntactical checks of change properties.

Hence, we suggest an approach of employing visual modeling techniques on two levels, the architecture and the component specification. Evolution steps are specified as rule-based modifications on both levels. The focus of our concept is the independence from a specific visual modeling technique, taking into account the large variety of common architecture description languages and visual specification techniques. The user therefore may define a subset of an existing ADL or own visual modeling languages adapted to his purpose. Thus, we aim at a generic visual modeling approach for model evolution at the design level.

Our approach is based on GenGEd [1], a visual modeling approach sup- porting the syntax specification of arbitrary visual modeling languages. Gen- GEd is based on the formal specification technique Algebraic Graph Transfor- mation [3], thus allowing rule-based modifications of the system behavior as well as the architecture. The formal basis also gives rise to analyzing properties of components and their connections (see e.g. [21] for a first discussion). Gen- GEd admits the visual specification of a visual language and (up to now) au- tomated editor generation for diagrams of this language. Graphical constraint solving techniques are used to compute the layout of diagrams. GenGEd has been successfully applied to a variety of visual modeling techniques, including simplified versions of UML class diagrams, statecharts, Nassi-Shneiderman diagrams and Petri nets.

Evolution steps are modeled by changes within a service net (local changes) that do not alter the input and output parameters, or by changes of the archi- tecture (global changes), e.g. by removing/adding components or by changing a method signature. Global changes at the architecture level influence the component specification level. Whenever components are added or removed, method nets have to be added or removed, too. When a method signature is changed, the service has to be adapted accordingly. Examples for global changes are e.g. the addition of a Scanner component class (plus the needed bined to the insertion of an association between two class symbols. Here, two cases are distinguished. The first rule is applied if there exists already an association: the import method name is added to the import section of of the class. The second rule is applied if no association arc exists to the class ex- porting the method: here, the association is inserted and the method is added to the import section.

/ not shared objects consistent. We need three rules for different situations: Rule insNewPlace(sn,pln) inserts a place pln in net sn. The place named pln did not exist in any service net before; hence it is marked as not shared. Rule insShareFirstTime(sn,pln) inserts a place that is shared with a place of the same name of another service net. Up to now this place has been not shared. The rule therefore marks both places as shared after the insertion. Rule insSharedPlace(sn,pln) inserts a place that is shared with more than one other places (already marked as shared). This new place also is marked as

We here do not depict all rules (e.g. we omit the insertion rules for tran- sitions and arcs), but their definition works analogously to the depicted rules. Additionally, rules deleting and changing elements in the editor have to be included in the grammar.

Summarizing, using the GenGEd approach, an evolution step is a graph transformation induced by the application of one or more rules to a graph (a sentence of our visual language) that models a system on the two levels architecture and component specification. The rules ensure that the evolution steps are consistent (e.g. no method is added in the architectural level without a corresponding service net being generated). Additional checks may be added by enhancing the abstract alphabet and the grammar rules.

An overview over architecture description languages (ADLs) based on com- ponents and connectors can be found in [14]. In our example we use architec- ture design diagrams related to UML class diagrams. Work on architecture descriptions based on (extended) UML diagrams is done in [13] and [18] where the aim is to validate architectural properties by formal means.

serves as example for our two-level approach presented in this paper. The OCoN tool environment supports the visual development of OCoNs but not their relation to the architectural level. Other examples for visualizing archi- tecture and (restricted forms of) their evolution can be found in ADL tool environments [2]. None of these tools allow a generic description of the visual model as we suggest in our approach using GenGEd.

We introduced our concept of visual model evolution and illustrated the basic notions using a small print server example. The main ideas are on the one hand a concept of visually representing a system on two levels and on the other hand a rule-based approach for the description of consistent system evolution. We then have reasoned about the benefits of a visual environment for the em- ployment of visual modeling techniques at two levels of abstraction discussing the GenGEd approach and its advantages in this context. In general, exist- ing tools supporting visual modeling are restricted to a fixed visual modeling language. Moreover, they are often complex and not easy to use because they are intended to cover as many software engineering steps as possible. The advantage of the GenGEd approach is to support the generation of a small application specific visual modeling environment.

Some future work is needed to use the formal basis of our approach to formalize and check e.g. invariants of component behavior and interrelations in an appropriate way. Accordingly, we will enhance the GenGEd tool en- vironment in order to model and check system behavior. More examples and larger case studies using different visual modeling techniques will be investi- gated to validate the usefulness of our approach towards a rapid prototyping environment for visual model evolution.

