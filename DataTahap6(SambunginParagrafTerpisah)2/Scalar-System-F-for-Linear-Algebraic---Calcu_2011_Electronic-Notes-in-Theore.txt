these logics arise via the study of type systems for the language [12]. Related to our motivation there is already a quantum logic [4], which was developed before quantum computing. However it is not known to have a clear relation to quantum programs.

Theorem 4.12 ensures that all the typable terms have a normal form, hence we do not need the restriction of closed normal forms on the reduction rules of Lineal, as they were there only due to the impossibility of checking the normalisation property in the typeless setting. This is an important simplification of the language.

In [2, sec. IV] it is shown how to encode quantum bits and gates in an original manner. Such an encoding no longer works under the scalar type system. This is because conditional functions have to have the same type on each branch, which in this case entails that they must have the same scalar in their type.

We can use the Curry-Howard isomorphism in an original way: instead of making the relationship between an already set logic and our type system, we can remove all the terms from the inference rules of scalar and set up the Scalar Logic. This Scalar Logic (SL) is the first non-trivial logic obtained from a Curry-Howard isomorphism of a type system for a language inspired by quantum computing. In this sense it is not an ad hoc logic that we have fabricated in order to convey an a priori meaning, but rather a logic that arises naturally and legitimately by applying a well-established method upon a quantum programming language. This discussion section is an attempt to understand the a posteriori meaning of this logic. It is somewhat informal, experimental, yet provides several intuitions ending with a clear-cut result (theorem 5.7).

[7] or bounded linear logic (BLL) [8]. However LL and BLL do not only count the amount of resources available, they make it impossible to add new resources. In LL the context puts a definite limit on how many resources we can use. In SL, on the other hand, we are counting the amount of proofs we used modulo cut-elimination, but nothing prevented us from using many more proofs. To make this more formal let us introduce some notation:

This scalar type system is the first step towards a future vectorial type system. The scalar type system is able to handle the magnitude and signs for type vectors. In a future system we will deal with the direction, i.e. addition and orthogonality of types.

