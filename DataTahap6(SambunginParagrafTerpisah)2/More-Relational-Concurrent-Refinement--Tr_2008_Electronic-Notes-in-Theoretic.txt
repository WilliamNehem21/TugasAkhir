Data refinement in a state-based language such as Z is defined using a relational model in terms of the behaviour of abstract programs. Downward and upward simulation conditions form a sound and jointly complete methodology to verify relational data refinements. On the other hand, refinement in a process algebra takes a number of different forms depending on the exact notion of observation chosen, which can include the events a system is prepared to accept or refuse.

This paper continues the programme, by considering more concurrent re- finement relations, many of them based on the partial relations model. The structure of this paper is simple. In Section 2 we provide the basic definitions and background. In Section 3 we provide the simulation rules for a number of

This background section presents the standard refinement theory [15] for ab- stract data types in a relational setting. The relational model of data refine- ment where all operations are total, as described in the 1986 paper by He, Hoare and Sanders [17], traditionally received the most attention. The stan- dard refinement theory of Z [28,15], for example, is based on this version of the theory. However, later publications by He and Hoare, in particular [16], dropped the restriction to total relations, and proved soundness and joint completeness of the same set of simulation rules in the more general case. De Roever and Engelhardt [13] also present the partial relations theory, without putting much emphasis on this aspect.

Testing scenario: The machine for testing failures has, in addition to the interface of the completed trace machine, a switch for each action in Act . One can then observe which actions are blocked. If the process reaches a state where all actions are blocked, then this can be observed by an empty display. Observations are thus the failures of a process.

This was covered in detail in [5,14,4], although we used an embedding into the totalised relational model there. Lemma 3 in [4] suggested this was not necessary:  appears as a possible outcome iff somewhere along the trace the next action of the trace could be refused. Thus, below we give a simpler embedding into the partial relations model.

Testing scenario: The display in the machine for testing failures traces is the same as that for failures. However, it does not halt if the process cannot proceed, rather it idles until the observer allows one of the actions the process is ready to perform. The observations are traces with idle periods in between, and for each idle period the set of actions that are not blocked by the observer. It has been argued [19,20] that this is a better notion for testing than simply observing failures of a process, and is appropriate when one can detect that a process refuses an action, and if this is the case, one has the ability to

The ready trace semantics is similar to the failure trace semantics, except ac- ceptance sets replace failures in the traces observed. The relational embedding is the same as that for the failure trace, except with the substitution of an appropriate acceptance set. Similar derivation can be made for the simulation rules.

Although not considered in [27], a number of alternative preorders for process algebras have been suggested motivated by testing and the need for test gen- eration. Specifically, in the context of testing from LOTOS specifications [6] these have included extension and conformance [10]. To define these formally we need the following notation which defines refusals sets after a particular trace.

The relational embedding we use to model extension is, in fact, a totalisation over the space of partial relations, and is the standard non-blocking model (e.g., as discussed in [15]), that is, we use the same construction to record the effect of extension in a blocking model as we did to record failures in a non-blocking model.

Although downward and upward simulations (Definitions 4 and 5) are com- plete, their totalised versions are not. However, complete simulations can be given for each semantics, e.g. the failures semantics simulations are known to be complete. A separate completeness proof for simulations is needed in each embedding, this waits for an extended version of this paper.

