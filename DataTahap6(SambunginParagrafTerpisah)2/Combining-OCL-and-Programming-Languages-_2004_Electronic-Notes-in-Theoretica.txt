Model processing tasks, like model checking, merging, slicing, and synthesis, need efficient and maintainable mechanisms to define models, as well as to query, compare and manipulate information in them. Although the Object Constraint Language (OCL) is primarily meant for expressing constraints for UML models, it can also be used for various model processing purposes. In this paper we discuss the needs for, and possibilities of, using OCL for processing models, and show how we have applied and extended OCL. We also introduce a model processing tool using OCL as an integral part of model manipulation facilities. We especially emphasise the need of combined use of OCL and programming languages in UML model processing.

As a specification language OCL naturally lacks facilities for user interac- tion and for reading from, or writing to, files. But the biggest problem, from a model processing point of view, is that OCL is defined to be side effect free. It is therefore not possible to change a value of an object or create a link between objects. The restriction is an integral part of the language, affecting many of its aspects, and can not be simply ignored. Side effects can be described using

To summarise, we need a mechanism for processing UML models, pro- viding not only primitive access to the model but also high-level support for implementing model processing tasks. In this paper we discuss the needs and possibilities of using OCL for model processing purposes, and show how we have applied and extended OCL. We also introduce a model processing envi- ronment, xUMLi [1], where we have used OCL as an integral part of model manipulation facilities. We especially emphasise the need of combined use of OCL and programming languages in UML model processing.

The main goal of our research is to provide automated tool support for vari- ous software engineering processes, each introducing a set of model processing tasks. We argue that these tasks can be performed by, and composed of, a set of primitive model processing operations. The model operations, in turn, are combined together to form a task using a higher-level composition mechanism, offering constructs such as flow of control (e.g. decisions, guards, flows, syn- chronization). We refer to the usage of these operations with the term model processing.

Perhaps the simplest example of a model operation is searching for, and filtering of, information in given UML models. These operations provide side effect free checking and validation of models. An obvious example of such an operation is enforcing the standard UML Well-Formedness rules [17]. Sim- ilarly, an operation could check whether a model follows given process or domain specific heuristics: for example, ensuring that all nodes in an inheri- tance tree should be abstract classes and all leaf classes should be concrete is a heuristics rule suggested by the OPEN software process [8, pp. 90]. Other examples of model operations are transformation operations, projection oper- ations, refactoring operations, and set operations.

diagrams [23][29][27], synthesis of structure diagrams from interaction dia- grams [25][11], and synthesis of class diagrams from object diagrams [6]. A projection operation produces a new UML model based on an existing one, the new model being a projection of the original one (e.g. abstraction or slicing). As an example of a projection operation especially useful with large models produced during a reverse engineering process, consider generating compressed structure diagrams based on existing ones [20].

OCL has a set of predefined types and operations for these types. They are defined in what is called the OCL Standard Library, and it is mandatory for implementations to include them. The predefined types include Integer, Real, String, Boolean, and a very useful set of structured data types. The type structure is also appended by all the classifiers from the current application model. In some situations there is need for more operations, e.g. taking the square root, or even new types. OCL offers powerful extension mechanisms for altering the language.

-directive in C and C++. There is also a stronger mechanism for attaching a variable to a type as a new property or a method. This is especially useful for augmenting a classifier from the application model with a method that simplifies the OCL expressions used. For serious extension needs, it is possible to define new basic types or new methods independent of the application model. These extensions are placed in a namespace and can be used in normal OCL expressions.

Since OCL is by definition side effect free, it can be used directly only for operations, which do not modify the state of the modelled system. This rules out OCL as a viable option for many model processing operations, e.g. the transformation operations. The restriction of not being able to modify the model is too inherent in the language to be dismissed lightly. There is more to changing that than simply introducing an assignment operator to the syntax. If it was possible to modify objects, the evaluation of an expression could no longer be considered instantaneous. In order to keep the expressions deterministic, execution order would have to be defined. One might also have to rethink the way failed navigations and other operations are handled, etc. As stated before, the restriction is interwoven deep into the language. In order to change it, one would need to think carefully what other aspects might be affected.

separating the side effect free part from the assignment. The approach could be carefully modified to allow more than one post condition and even loops, but it does take some effort. Although it works with the simple example given, in practice operations are much more complicated and expressing them with above mentioned crippled post conditions yields hopelessly illegible operations. It takes a lot of skill and planning even for an implementer with extensive knowledge and experience on OCL to craft the necessary OCL expressions. If the operation is defined in a declarative way, translating it into a normal OCL post condition is often rather straight forward. This is no longer true for the limited post conditions. If the operation is defined as an algorithm, the translation becomes very difficult indeed.

General purpose programming languages can, of course, be used for model processing. They often have a wide variety of structured data types, good selection of flow control statements, and sufficient mechanisms for user in- teraction, etc. However, for model processing purposes, they are a bit too general. Lacking direct support for processing UML models causes even sim- ple queries to turn into long and complicated code. The point gets lost in the middle, and it is no longer clear what the high level idea was. This is the trade off between a general purpose programming language and a high level domain language. By narrowing the scope, a domain language can offer more complicated and better suited operations for specific tasks, but is no longer as useful for tasks outside its scope.

The example, albeit longish and not optimized for performance, shows a convenient way of establishing a constraint. The example also illustrates one nice feature of OCL, the ability to navigate over sets. For example, on line three, navigation stereotype.name refers to the names of all stereotypes of all the fetched classes. This makes it easy to state a constraint for a series of attributes.

approach is to enable authoring small model operations and combining them together, as if they were the primitive expressions of a very high level model processing language. The chaining of operations can be done with traditional programming languages, or by using a special visual language, VISIOME [18]. VISIOME provides a very high level, visual programming paradigm that relies heavily on the usage of OCL together with a set of fundamental pro- gramming constructs, and is especially useful when defining software process related model processing functionality. The environment is not dependent of any specific CASE-tool, but offers a plug-in interface for components that

The OCL interpreter was developed in 2001, and therefore follows the OCL 1.4 specification. The interpreter was intended to be used internally by the VISIOME engine, but was later found very useful for individual model operations as well. Due to the close relationship with the visual language and its simple type structure, the interpreter considers all user defined objects to

This section contains observations we have made during our two years of using OCL. We discuss some short comings of OCL as well as areas where it could be improved. The thoughts expressed describe specific problems, but we do not have detailed solutions to propose.

There are probably several factors involved. For example, the users are not as versed in the use of OCL as they are in their preferred programming language. The lack of guidelines for formatting expressions, e.g. indentation rules, might play a role, too, but it is not completely a matter of inexperienced users and badly written OCL. Although the clarity can be improved with comments and variable definitions, it seems that the syntax is prone to hiding the structure of the expressions. Undoubtedly the obscurity of the OCL 1.4 specification is partly responsible for the initial confusion. The readability and the organization of the specification have been greatly improved in the OCL 2.0 draft.

An example of a different kind of an advanced navigation is the transitive closure according to a specific navigation. This is quite a common expression, even the UML Well-Formedness rules are littered with them. For example, rule three for GeneralizableElement [17, pp. 2-59], which forbids circular in- heritance, uses a transitive closure of the navigation generalization.parent [17,

If the language contained better support for accessing this type data, OCL could be extended using OCL itself even in the case of advanced generic opera- tions. Ability to define extensions in that way would mean that the extensions worked in any OCL interpreter, regardless of its origin. This would further improve portability of OCL expressions themselves. Although portability of extensions is not important at the moment, it might become an issue in the near future, if CASE tools (and software designers) adopt OCL in a larger scale.

Even before the eve of OCL 2.0 there have been papers where the writers have found, somewhat similar to us, OCL useful for querying information. For instance, Hobart and Malloy discuss using OCL queries for debugging C++ [9], and Marder et al. propose a UML repository and an API, based on UML metamodel, for managing and querying UML models [13]. In the latter environment, OCL constraints can be used to specify and check UML models. The constraint can, for instance, hold design guidelines or semantic invariants to enforce validity of UML models.

nipulation of UML models. They use the UML action language to specify transformations, and OCL to express the selection criteria of the transfor- mations. They mix an action language and OCL together to better describe both queries to the models and the manipulation of the models. Although the approach of UMLAUT is close to ours, there are also differences. They use a domain specific language, and concentrate on model transformations. We have also a domain specific language for combining the operations, but the operations can be specified with any language supporting COM, and our tool allows developing practically any kind of program, including arbitrary user interaction and external repository use.

We have used our environment for couple of years now, and it has proven its suitability for non-trivial model processing tasks and process support. Ac- cording to our practical experience, using clearly separated OCL expressions for queries, etc. makes the code better organized and easier to comprehend. This improved readability also makes the code easier to maintain, which is very helpful during the early phases of the development.

In addition to using the platform to develop tool support for different pro- cesses and performing some case studies, we are also going to further develop the platform in the future. For instance, we will adopt UML 2.0 including OCL 2.0, and develop the OCL support of VISIOME further.

