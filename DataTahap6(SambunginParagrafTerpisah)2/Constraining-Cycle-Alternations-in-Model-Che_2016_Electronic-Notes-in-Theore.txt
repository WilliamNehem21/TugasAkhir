Model checking is one of the most effective techniques in system verification, that allows one to verify a formal specification of the desired properties of a system against a model of its behavior. It has been widely and systematically investigated in the context of classical, point-based temporal logics, whereas it is still almost unexplored in the interval logic setting. In [4,12], the authors propose interval tem- poral logic (ITL) as a natural and expressive formalism for temporal representation and reasoning. On the one hand, thanks to its high expressiveness (compared to that of standard point-based logic), ITL is well suited for a number of computer science applications, ranging from computational linguistics to formal verification,

In this paper, we focus our attention on the model checking problem for HS and its fragments [5,6,7,8,9], for which little work has been done, if compared to LTL or CTL model checking. In the classical formulation of model checking, systems are modelled as (finite) labelled state-transition graphs (Kripke structures), and point-based temporal logics are used to analyse, for each path in the graph, how proposition letters labelling the states change from one state to the next one along the path. In HS model checking, to verify interval properties of computations, we interpret each finite path of a Kripke structure (track) as an interval, whose labeling is defined on the basis of that of the states composing it.

Condition (iii) of Def. 2.10 simply states that no two subtrees, whose roots are siblings, can be isomorphic. A B0-descriptor D for a track consists of its root only, denoted by root(D). A label of a node will be referred to as a descriptor element.

algorithm is in general incomplete: it aims not at analyzing all the behaviors of a system, but at finding counterexamples to relevant properties. The idea is to con- sider only some representatives of computations, for which a bound on the number of their cyclic subtracks holds. At the expense of completeness, we have decreased of an exponential the (spatial) complexity of the algorithm given in [8]. We expect that this new algorithm can be easily implemented and used for practical purposes.

