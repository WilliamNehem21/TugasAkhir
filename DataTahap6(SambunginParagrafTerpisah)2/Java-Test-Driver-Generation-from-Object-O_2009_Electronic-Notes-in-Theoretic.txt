In the context of test-driven development for object-oriented programs, mock objects are increasingly used for unit testing. Several Java mock object frameworks exist, which all have in common that mock objects, realizing the test environment, are directly specified at the Java program level. Though using directly the programming language may facilitate acceptance by software developers at first sight, the entailed syntax noise sometimes distracts from the actual test specification, speaking about interaction traces.

We propose a Java-like test specification language, which allows to describe the behavior of the test harness in terms of the expected interaction traces between the program and its environment. The language is tailor-made for Java, e.g., in that it reflects the nested calls and return structure of thread-based interaction at the interface. From a given trace specification, a testing environment, i.e., a set of classes for mock objects, is synthesized.

Testing is of prime importance in assuring the quality of software. In contrast to exhaustive methods for system verification and validation, testing aims at detecting faults, thereby increasing confidence in the system under test [19]. To manage the complexity of modern software, testing should be systematic and integrated into the software development process. Test scripts should be generated automatically from the specification and tools should take care of the automation of the several aspects and levels (e.g. unit, integration, or system testing) of the testing framework [11].

The paper is structured as follows. Section 2 defines the specification language, used to describe the trace-based behavior of the observer. Section 3, the core of the paper, describes the code generation from the abstract specification. In Section 4 we discuss briefly the extension of the specification language to the multi-threaded case. Finally, Section 5 concludes with related and future work.

After initialization, the actual interaction is described. First, a new instance of the component class Census is created by calling its constructor method and waiting for the return value which is assigned to the local variable c. In the specification language, we view the instantiation of a component class as a particular case of a call of a method of the component by the tester as explained in detail below. Next, the tester calls the method census of component object c. It passes a copy of the set of voters to the component (note, that passing on the set of voters itself would give the conjunction, the component has to find out the votes of the voter objects of set voters. This is modeled by a call of a method of a voter by the component. Note that this method belongs to the tester. Such calls we indicate by question marks. After having received all this calls, census returns to the tester the final result.

ning and end of a block construct. 6 These different block constructs are denoted in the syntax by sin and sout . In a single-threaded setting, the flow of control between the component and the tester is reflected by alternating nested block statements sin and sout . These block statements form the basic building block of the language. Of particular interest is the use of sin statements in the context of a callswitch:, which allows the specification of non-deterministic choice between incoming calls.

Apart from the interactions between the component and the tester, the specifica- tion in general also will involve internal computations. For example, for computing values for communication and driving the test execution. In the syntax these state- ments are denoted by sint . Note that such an internal computation assumes that the tester has control. Thus, we cannot specify internal computations right after an outgoing call. The above example shows, however, that in practice it is convenient

A terminating execution of a test specification is successful if not generating a failure report. In general, failures are caused by violated assert statements and where-clauses and unspecified incoming method calls and returns. As an example of the latter kind of failures consider the following specification fragment.

This example can give rise to two kinds of failures. First, the constructor of com- ponent class C returns without calling any method of the tester. Second, the con- structor calls a different, unexpected method of the tester. The implementation of the specification language generates automatically appropriate failure reports.

which, after instantiating a test class T , calls the constructor of component class C and then expects an incoming call with the newly created instance of T as parameter. As the instantiation of a tester class by the tester itself is an internal action this newly created object is unknown to the component unless the tester communicates it. Of particular interest are thus techniques which identify such failures. As it is impossible to identify all such failures statically, we provide a runtime check by recording all identities of tester objects known to the component. If a test execution leads to a situation where a tester object, which actually cannot be known by the component, is expected in an incoming communication, the tester reports an invalid test and aborts.

Note, that !c and ?r are used here as abbreviations for an outgoing call and its corresponding incoming return. Moreover, l is a new label and the assignment next := l says that the next expected incoming communication is the incoming return labeled with l. The statement snxt describes the expectation of the next incoming call according to sin .

occurrence. E.g., the outgoing call x!m' is preceded with the update of next with label l of the next expected incoming call of method m''. After the outgoing call we check whether next refers to the label of its return. Right before we return from this call of method m next is updated to the next expected occurrence of an incoming call or return.

tion presented in Listing 6. Here, we have two nested incoming calls of the same method m. However, the outer method call uses x as its formal parameter whereas the inner method call uses y and also has access to x. Therefore, we model these formal parameters as static variables of the Tester class which are globally accessi- ble. To describe the scope of the variables we annotate them with the label of their occurrence. For the above specification, the implementation fragment is given in Listing 7.

| while (ebooL) do stmt | callswitch: (cin : stmt )+	 statements sint ::= x : T | x := e | e.f := e | assert(ebooL) | x.m(v,..., v)	internal stmts sext ::= cin | cout | rin | rout	 stmts ext

graphical specification formalism used for the generation of test cases [16]. The fo- cus of MSCs, however, is on the timed order of message exchanges and often many test suite details are hidden, like expression evaluation and data generation. This differs from our approach where a test suite is specified in more detail. [4] proposes a specification-based (i.e., black-box) testing method for object-oriented software. The desired interface behavior is described in the object-oriented specification lan-

