We propose Observer architecture for program visualization. The principles of Observer architecture are modular, model-driven visualization with one-directional coupling, hierarchical delegation, message-passing and archival by visualizers. The architecture is scalable. The resulting visualization can be distributed and modified independent of the model. The Observer architecture has been implemented in online tutors for programming called problets.

In the Observer architecture, visualization of a program is driven by observation of its execution. Observer architecture relies on the availability of an observable model of the executing program. We will present the details of such a model in section 2. We will present the principles of Observer architecture of visualization in section 3 and provide an example of its implementation in online tutors that we have developed for programming, called problets (www.problets.org). We will enumerate the advantages of Observer visualization in section 4 and end with discussion in section 5.

Our programming tutors, called problets, automatically build a model of the pro- gram presented in each problem [8]. The model consists of the structure and be- havior of the program. The structure describes the programming objects and con- structs, and how they are interconnected within a program. The behavior describes the execution semantics of the constructs used in the program. Consider the fol- lowing C++ pointer code with a nested block:

In the Observer architecture of program visualization, each component in the pro- gram model is an observable object. Each of these objects is coupled with an Observer object whose responsibilities are to track and visualize the changes in the state of the observable object. The overall structure of the visualization objects is isomorphic to the structure of the model. This architecture is inspired by the Model-View-Controller pattern used for graphical user interface construction [5].

Message-passing for coordination: Since each visualization object is modu- lar, it is often necessary to coordinate among two or more visualization objects, e.g., when animating the assignment of the value of one variable to another, or depicting the assignment of a pointer to point to a variable or heap object. Message-passing is used for such coordination. In message-passing, a visualiza- tion object that needs to coordinate with another visualization object passes a message up and down the visualization hierarchy. A visualization object that receives the message acts on it if it is the intended target of the message, and passes it onwards if it is not.

Some of these principles, viz., separation of model and view, and one-directional coupling between the model and view have been proposed in the Matrix framework for building algorithm visualization [6]. Our work may be seen as an extension of the Matrix architecture in that we have proposed hierarchical delegation, message- passing for coordination and archival functions. Whereas a static repository is used in the Matrix architecture to keep track of the visualizations, we use hierarchical delegation.

Observer-architecture is model-driven, i.e., visualization is driven by a model of the domain that can be simulated. Model-driven visualizations are capable of capturing more of the semantics of the domain being modeled [14]. They sup- port custom input data sets, one of the ways to improve the effectiveness of visualization [13] - in the case of program visualization, this includes visualizing learner-written programs. They reduce instructor overhead, one of the impedi- ments to adoption and use of visualization [13], because, instead of specifying the visualization, the instructor can specify the program for which the visualization is desired, and let the model-driven observer architecture automatically create the visualization for the program.

We have proposed Observer architecture for visualization. The architecture is gen- eral and domain-independent - it can be used for algorithm visualization just as well as program visualization, as long as an appropriate model is available. This may be seen as a disadvantage of Observer architecture for program visualization: the model needed for program visualization is a language interpreter, constructing which can be a daunting undertaking.

The best known model-driven program visualization system is Jeliot 3 for Java [2]. It uses a modified version of the source code interpreter DynamicJava (www.koala.ilog.fr/djava) as its model. It uses an intermediate code and an inter- preter for the intermediate code to coordinate the model with the visualizer. The objects in the intermediate code interpreter, such as Value and Variable maintain a reference to their corresponding visualization objects, called actors, such as Value-

Problets are driven by parameterized templates. The user can execute and visualize a new program by simply entering its template into a problet. By defining a clear separation between observable and observer objects, Observer architecture makes it easy for the developer to provide multiple visualizations of a programming construct. When the developer provides alternative visualizations, the user can select among them as easily as selecting from a menu. The user will be able to customize the visualization to the extent that the individual visualization objects allow them, e.g., visualization of a variable may permit the user to change its appearance or animation scheme. Since the visualization objects are composed to build the overall visualization, the user can customize the visualization of each type of program object independent of the visualization of the other objects.

