The Mono Model Checker (mmc) is a software model checker for cil bytecode programs. mmc has been developed on the Mono platform. mmc is able to detect deadlocks and assertion violations in cil programs. The design of mmc is inspired by the Java PathFinder (jpf), a model checker for Java programs. The performance of mmc is comparable to jpf. This paper introduces mmc and presents its main architectural characteristics.

FeaVer) is a tool that can be used to mechanically extract high-level verification models from implementation level C code. These verification models can then be verified with Spin. Another example of this approach is the first version of the Java PathFinder [10], that translated Java programs to Promela models, which were then verified with Spin.

state-space of a Java program, thereby generating it on-the-fly. It reduces the size of the state-space by applying partial order reduction techniques [8], as well as (heap) symmetry reduction [3,14]. The size of each individual state is reduced using the recursive indexing method [11]. By systematically exploring the state-space the jpf aims to find deadlocks and uncaught exceptions. jpf is an open source application and is available from [19].

The development of mmc has been inspired by jpf. The architecture and design of mmc is also heavily based on jpf. And although the object-oriented design and the actual implementation of mmc (in C#) and organization of the classes and algorithms are different, all credits for the verification approach should go to the developers of jpf. Other than providing an actual model checker for cil bytecode, we do not claim any major novelties here.

This section describes the most important components of mmc. For a more detailed and thorough discussion on the design of mmc and its implementation, the reader is referred to [1]. Before describing mmc itself, we first discuss the context of .Net and the Mono project.

During exploration, mmc will check for deadlocks and assertion violations. A deadlock is a state where there are no runnable processes in the system, but not all processes have terminated. An assertion is a user-defined condition that has to hold in a certain state.

The instruction executors (ies) are objects responsible for executing the cil instruction. There are many ies: one for each type of cil instruction. Each ie is implemented by its own C# class. This approach closely resembles the command design pattern [7]. The merit of using the command pattern in the mmc is that code to execute cil-instructions can be seen as first-class-citizens. This allows us to add more cil-instructions to mmc without modifying existing code. Furthermore, meta-data (such as the list of exceptions an instruction can throw, the safety of instructions, etc.) that is associated with the instructions can be added to the executor classes, thereby eliminating the need for big look-up structures.

In mmc, a transition between two states consists of zero or more safe instruc- tions together with one unsafe instruction. A safe instruction is an instruction whose execution is not visible (or relevant) to any of the other threads. An unsafe instruction is an instruction that might influence other processes. The merging of safe instructions into one transaction can be considered a mild form of partial order reduction [8]. Spin employs a similar technique called statement merging [12]. Note that within mmc instruction merging is not a feature, but rather a necessity. With- out instruction merging the number of states would soon become unmanageable.

All states that are visited by the explorer are stored. However, mmc does not only suffer from the infamous state explosion, the individual vm states can become quite big as well. To reduce the size of the states that are being stored, mmc uses a technique called recursive indexing (or collapse compression), which is also used in Spin [11] and jpf.

the heap, classes and thread pool. The heap holds all dynamic allocations: objects, arrays and delegates. The static fields are stored in the classes component. The thread pool contains the concurrent processes that are currently running. For each process it contains the complete stack of method calls by that process.

We have performed some preliminary experiments with mmc on some C# programs. To get a feeling of the performance of mmc, we have translated these examples also to Java, and checked these with jpf. The experiments have been carried out on an amd Thunderbird 700 CPU with 768Mb of RAM running Linux. We used Mono version 1.1.13.6. In this paper, we only briefly discuss the results on the well-known dining philosophers problem.

In this paper we presented mmc, a model-checker for cil bytecode programs. Due to several refactorings, the design and implementation of mmc is clear, readable and extensible. We feel that mmc is a useful platform in an academic environment where ease of experimentation with different implementations is an important virtue.

