In this paper, a formal model is introduced for reasoning about resource allocation and scheduling in real-time systems. We extend the concurrent refinement language Circus [19] through integrating continuous time and resource information. This model reflects resource issues when modelling the behavior of a system, and allows temporal properties to be accurately determined. We also apply the model to the problem of partitioning in co-design, and show how the partitioned programs preserve the behavior of the specification correctly.

The timing behavior of real-time systems depends on not only process syn- chronization, but also the availability of resources provided by systems. Many timed models are proposed for the design and verification of real-time systems, for example, TAM [15], Timed CSP [2], Timed CCS [17,9], TCOZ [12] and Real-Time Refinement [4]. These models have the implicit assumption that unbounded resources are available. However, in practice, real-time systems are

In this paper we present a series of semantic models that can reason about resource allocation in real-time systems. The models are based upon Circus, a well-defined specification language combining the features of CSP and Z. Circus has a formal semantics based on the Unifying Theories of Program- ming(UTP) [5]. We extend the core languages of Circus by adding time infor- mation for reasoning about real-time programs. Moreover, we introduce the resource information into the model, and make it possible in analyzing the resource allocation of real-time systems, for example, the resource conflict, where two parallel programs access the same resource simultaneously.

Sherif and He [16] did the first step to add time into Circus, and they used discrete time in their model. Though discrete time models are easily imple- mented by computer systems, it is more natural to adopt the continuous time as the nature of time in the real world is continuous. Like other studies, such as TAM [15], Real-Time Refinement [4], Timed CSP [2], we use continuous time in our models and go further than [16]. When integrating time into Cir- cus, a number of healthiness conditions are posed on the continuous model in order to specify its correct behavior.

3. Section 4 introduces two resource models based on the time model, and explores the relations among them. In Section 5, we present an example from co-design field to show how these models are applied to verify the correctness of program. We conclude in Section 6 with a discussion on future work.

To define a time model, we adopt a simple language CT , which is a subset of Circus and introduced in [16]. For simplicity, we only consider actions, guarded commands and assignment as the basic actions, other constructs of the lan- guage, such as abstractions and declarations, have little effect over the model. CT is also extended with timed structures, such as idle d, deadline d, idle etc. The informal description about CT will be given later with the semantics. The syntax of CT is as follows:

The semantic space is introduced here. The continuous time is adopted to express the behaviors of the system at the design stage. Moreover, through the appropriate mapping from continuous model to discrete one, the system specification can be implemented by computers. We use the similar semantic space from [5]. The behaviors of Timed Circus are defined by means of pred- icative semantics. Here are some observational variables used in our models.

In this section, we introduce some healthiness conditions, which distinguish feasible descriptions of reality from infeasible ones. Healthiness conditions can reject a specifications if it makes implementation demonstrably impossible in the target programming languages. We list four healthiness conditions which are satisfied by all feasible Timed Circus programs. Some predicates which will be used in this paper are defined as follows:

Conditional Choice. The conditional choice P b D Q executes P if b evaluates as true, otherwise executes Q instead. We assume that the evalua- tion of b takes no time. Actually, this assumption can be removed by adding idle action before P and Q respectively.

External Choice. The behavior of an external choice can be observed in two points: before the choice is made and after the choice is made. Before the choice, the system is in waiting state and only internal actions can take place. Moreover, an event is refused only if it is refused by both P and Q . After the choice is made, the rest of the behavior is described by either that of P or Q, depending on which action corresponds to the first event.

The parallel composition is a little complicated. It is defined in terms of the merge parallel composition introduced in [5]. The parallel composition of two actions terminates whilst both components do. The action idle in the following definition just plays a role for this observation.

m . We use tr1 and tr2 to stand for two traces. Let xi (i = 1, 2...) denote members of cs, and yi (i = 1, 2...) denote events that do not belong to cs. Operator m is defined by following rules:

In this section, we extend the model of the previous section in order to rep- resent the resources used by actions. Two resource models are proposed here, one is an unlimited resource model, and the other is a limited resource model. The latter is a natural extension of the former. In the unlimited model, we assume resources in the real-time environment are enough for the execution of any action.

The assumption that the resources are unlimited is somehow unreasonable in reality, because it is not true in many cases. A limited resource model can be formalized as an extension of the unlimited model. We use [P ]]lt to denote the semantics of P in limited resource model. We only need to modify the definitions of basic actions and some composition structures.

In this section, we will show how the semantic model with resources can be applied to verify the correctness of specifications in the field of co-design, specially the hardware/software partitioning stage. Co-design studies sys- tematically design of systems containing both hardware/software components. Hardware/software partitioning is one of the key steps in co-design [18], which intends to partition a specification into hardware and software components. Most of the approaches proposed earlier are based on heuristic searching [14,11]. One of the key problem here is to preserve the behavior of the specification after partitioning. Some authors introduce algebraic methods to handle this issue [13,6], but they did not consider, for example, time and resources. We can use our resource models to verify the correctness of the partitioning pro- cess.

Here we adopt a simple model of partitioning. Suppose a specification contains a series of actions. The partitioning divides these actions into two sets, where actions belong to each set are put into software and hardware respectively. The actions in software and hardware need to communicate with each other.

Suppose the left side of the parallel structure is put into the software, and the right side into the hardware. As c is an internal event, it is hidden from the environment. Suppose the total resources in hardware is 10 units known in ad- vance. The assignment and weak idle actions both consume one unit of control resources, and communication action consumes two units of control resources in hardware. If a program is put into software, the resources consumed are regarded as memory. Here we assume that the memory resources are enough for the program. Now we would like to identify the following implication:

In this paper, we proposed an approach to integrate time and resource infor- mation into the specification language Circus, which can help us to analyze and reason about resource in real-time systems. We also give an example from co-design field to show that the model can be used to prove the correctness of refinements. A proof-assistant tool is being developed based on our semantic model.

Another issue we would like to do in the next step is to give a set of refinement laws for our models. Circus is a good language for refinements [19]. Woodcock and Cavalcanti [1] discussed the refinement strategy for Circus. The refinement laws enable us to develop the program more easily, and to make the procedure of verification of the real-time systems automatically. We hope to develop a set of refinement laws based upon our models as one part of the future work.

