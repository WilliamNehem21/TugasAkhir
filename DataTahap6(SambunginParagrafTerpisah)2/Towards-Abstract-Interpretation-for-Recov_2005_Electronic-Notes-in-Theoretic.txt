One technique that can be used for recovering design information is Logic Meta Programming [11]. This technique revolves around the use of logic pro- gramming for posing queries on a program. Using a library of logic rules that define which high-level relationships between program elements hold under which conditions, a programmer can build an understanding of a program by querying it for such relationships.

We have currently explored how pattern detection rules based on behaviour can be written using an ad-hoc model based on execution trace information. Our position for this workshop is that Abstract Interpretation research can provide a better theoretically-founded model. We wish to receive further feed- back from the Abstract Interpretation community on this position. To provide the necessary background this paper further explains the following: section 2 gives a brief overview of the current LMP approach, section 3 describes a par- ticular design pattern in more detail, sections 4 and 5 respectively contrast the current structural-based pattern detection approach and our proposed novel behavioural-based one and in section 6 we consider the question of how ab- stract interpretation can be used.

Logic Meta Programming is a technique in which a Prolog-like language [3] is used as a meta language for reasoning about object-oriented programs. Over the years, it has been applied to a variety of problems in object-oriented soft- ware engineering, some examples are: reasoning about object-oriented design [11,10]; checking and enforcing programming patterns [7]; supporting evolu- tion of software applications [8] and checking architectural model conformance [12]. Following the example of these researchers, we use the SOUL logic meta programming system to conduct experiments on programs written in Smalltalk [5]. The SOUL approach to logic meta programming is however generic and can be applied to most class-based object-oriented programming languages, as is evidenced by the existence of SOUL for Java [2].

logic queries both to verify whether there is a hierarchy relationship between two classes and to detect the classes another class has in its hierarchy. In the first of the two example logic queries below, the isInHierarchyOf: predicate is used to verify that the class String somehow inherits from the class Object, in the second query it is used to find all classes that inherit (in)directly from the class Object. For the first query the logic evaluator will try to logically prove that the isInHierarchyOf: predicate holds for the given arguments and for the second query it will return all the values for the variable ?x that make the predicate hold.

Finally, approximate reasoning is another path we are pursuing in parallel in our research for a more flexible detection of software patterns [1]. Our initial experiments have shown that approximate reasoning aids in overcoming small discrepancies between the facts needed to prove the existence of a pattern and the program facts at hand. Later research might also entail investigating how these two approaches can be combined conceptually: approximate reasoning about approximate program semantics.

