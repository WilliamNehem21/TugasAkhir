Graph searches and the corresponding search trees can exhibit important structural properties and are used in various graph algorithms. The problem of deciding whether a given spanning tree of a graph is a search tree of a particular search on this graph was introduced by Hagerup and Nowak in 1985, and independently by Korach and Ostfeld in 1989 where the authors showed that this problem is efficiently solvable for DFS trees. A linear time algorithm for BFS trees was obtained by Manber in 1990. In this paper we prove that the search tree problem is also in P for LDFS, in contrast to LBFS, MCS, and MNS, where we show NP-completeness. We complement our results by providing linear time algorithms for these searches on split graphs.

We focus on connected searches, that is, a graph search or graph traversal that starts at a vertex and explores the graph by visiting a vertex in the neighbor- hood of the already visited vertices. If no further restriction is given, we call such a search a generic search. The search paradigms of BFS and DFS can be simply characterized by using a queue or a stack as the data structure for the unvisited ver- tices in the current neighborhood. However, there are more sophisticated searches like Lexicographic Breadth First Search (LBFS) [21] and Lexicographic Depth First Search (LDFS) [7]. In this article, we also consider Maximum Cardinality Search (MCS) [25] and Maximum Neighborhood Search (MNS) [7]. A short overview of these searches can be found in the full version of this paper [3].

A structure that is closely related to a graph search is the corresponding search tree. Such trees can be of particular interest, as for instance the tree obtained by a BFS contains the shortest paths from the root r to all other vertices in the graph. The trees generated by DFS can be used for fast planarity testing of graphs [18]. Moreover, if a cocomparability graph has a hamiltonian path, then such a path can be found by a combination of various graph searches [5]. First, one can use at most n LBFS runs, where n is the number of vertices, to find a cocomparability ordering [11]. Afterwards, the last visited vertex of an LDFS on this cocomparability ordering is the first vertex of a hamiltonian path. Finally, the search tree of a right most neighbor search on the LDFS ordering is a hamiltonian path.

So far, there is no satisfactory answer as to why graph searching works so well. An interesting example are multi-sweep algorithms, such as finding dominating pairs in connected asteroidal triple-free graphs [8]. One can prove that these algorithms are correct. However, it is not clear why multiple runs of a simple algorithm could give such a strong insight into graph structure. Indeed, there seem to be some hidden structural properties of graph searches, which are waiting for discovery and algorithmic exploitation.

A problem that is closely related to the search tree recognition problem is the so- called end-vertex problem, i.e. the problem of determining whether a given vertex v in a graph G can be visited last by some graph search method. As a result of numerous new applications in algorithms, the end-vertex problem has received some attention in recent literature. In particular, the end-vertex of an LBFS on a chordal graph is always simplicial [21]. Furthermore, in a cocomparability graph, the end-vertex of an LBFS is a source/sink in some transitive orientation of its complement [15]. End-vertices are of particular interest for multi-sweep algorithms, as every consecutive search starts at the end vertex of the previous search. For example, one can use five LBFS executions followed by a modified LBFS to recognize interval graphs [9]. Crescenzi et al. [10] have shown that the diameter of huge real world graphs can usually be found with only a few BFS executions.

Surprisingly, the problem of deciding whether a vertex can be an end-vertex of a graph search is hard. In 2010, Corneil, Kohler, and Lanlignel [6] showed that it is NP-hard to decide whether a vertex can be the end vertex of an LBFS. Later, Charbit, Habib, and Mamcarz generalized this result to BFS, DFS, and LDFS [4]. Furthermore, they extended these results to several graph classes. Recently, Beisegel et al. [2] proved NP-hardness results for MCS and MNS, and they also provided linear time algorithms for this problem on split graphs and unit interval graphs.

Our contribution. Although research initially began with the recognition of search trees, the results on the end-vertex problem are currently more extensive. In the light of the new results, we fill in the gaps in the analysis of the complexity of the search tree recognition problem. In this paper, we extend the tree recog- nition problem to LBFS, LDFS, MCS, and MNS for F- or L-trees, respectively, by showing NP-hardness results for most of these searches on general graphs, a polynomial time recognition algorithm for L-trees of LDFS on general graphs, and linear time algorithms for the F-tree and the L-tree problem on split graphs for various searches.

A tree is an acyclic connected graph. A spanning tree of a graph G is an acyclic connected subgraph of G which contains all vertices of G. A tree together with a distinguished root vertex r is said to be rooted. In such a rooted tree a vertex v is an ancestor of vertex w if v is an element of the unique path from w to the root r. In particular, if v is adjacent to w, it is called the parent of w. Furthermore, a vertex w is called the descendant (child) of v if v is the ancestor (parent) of w. A tree is a caterpillar tree, if and only if it admits a dominating path P , i.e., every vertex is either in P or adjacent to a vertex in P .

If a vertex xi is visited, then q receives a larger label than xi, as they otherwise share the same set of neighbors among the visited vertices up to that point (and analogously if xi is visited before q). Thus, q must be chosen between any literal vertex and its negation. The largest subset of X that can be visited before q must, therefore, be an assignment of I. As I is not satisfiable, any such assignment must leave at least one clause unfulfilled. If Ci is such a clause, then at the point at which q is chosen, ci does not contain any neighbors among the visited literal vertices. As a result, ai receives a larger label than ci and is visited earlier.

As Lexicographic Depth First Search is a special case of DFS, the most natural search tree to be considered here is the L-tree. We give a polynomial-time algorithm (Algorithm 1) which, given a graph G and its spanning tree T , decides whether T is an L-tree of LDFS on G. This is an interesting contrast to the fact that it is NP-complete to decide whether a given vertex is an end-vertex of LDFS, as shown by Charbit et al. [4].

However, Algorithm 1 and Lemma 4.1 imply that P cannot be an L-tree of LDFS on G[V (P )]: As we start in r and as P is a path, we must choose all vertices up to u in the order of the path. Due to Lemma 4.1, the vertices have the same labels as they did when Algorithm 1 halted. Therefore, v has a lexicographically larger label than w. As a result, P and, thus, T cannot be a L-trees of LDFS.  2

Surprisingly, for split graphs the set of F-trees is the same for the searches BFS, MNS, MCS, and LDFS, even though this does not hold for the respective search orders. We exploit this special structure to derive a linear time algorithm for split graphs. Note that LDFS is considered together with an F-tree.

We have shown that the F-tree problem is NP-complete for LBFS, MCS and MNS. Furthermore, we have given polynomial time algorithms for the L-tree problem of LDFS and for both the F-tree and the L-tree problems of LBFS, LDFS, MCS and MNS on split graphs. To the best of our knowledge, no hardness results for the L-tree problem were known before. Thus, the question arises whether the L-tree recognition problem is easy in general for every graph search.

For the end-vertex problem, there are polynomial algorithms for some chordal graph classes besides split graphs (cf. [2,4,6]). Can these results be transferred to the tree-recognition problem? Up to now, there is no known combination of graph class and search for which the end-vertex problem is easy but the tree-recognition problem is hard.

Moreover, we have considered the search tree recognition problem for labeled, unrooted trees in this paper. As a variant of this problem, one could fix the starting vertex of the search, i.e., the input would be a rooted search tree. As we have already seen in Section 4, if we can solve the problem with fixed start vertex in polynomial time, we can also solve the general problem efficiently by solving it for every vertex as the starting point of the search. Nevertheless, it could be possible that the problem without fixed starting vertex is easier than the problem with fixed start vertex. That is, maybe it is easy to find a search order with arbitrary root, that generates the tree, but it is NP-hard to find one that uses the given root.

As a second variant, one can also consider the unlabeled problem, i.e., no span- ning tree is given, but a tree with a matching number of vertices. Thus, we are looking for a search tree which is isomorphic to the given tree. Obviously, this problem is NP-hard for L-trees of DFS, since it includes the hamiltonian path problem. However, it remains open whether there are searches and graph classes where the unlabeled case is easy or even easier than the labeled one.

