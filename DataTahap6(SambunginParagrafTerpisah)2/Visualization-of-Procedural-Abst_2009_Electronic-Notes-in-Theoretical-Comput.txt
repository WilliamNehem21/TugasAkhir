Visualizing impacts of an optimization pass helps to reason about, and to gain insight into, the inner workings of the optimization pass. In this paper, we visualize the impacts of two procedural abstraction passes. For this, we modified two procedural abstraction post pass optimizers to visualize for each the difference in machine code before and after optimization by drawing abstracted fragments in the original program. We then explain how the generated visualizations aid in better understanding the optimization passes.

Visualizations are often used in mechanical engineering, chemistry, physics, and medicine [3], but are occasionally used in computer science as well to aid pro- gram understanding (see for example the ACM Symposia on Software Visualization (SOFTVIS), the IEEE Workshops on Visualizing Software for Understanding and Analysis (VISSOFT), or the Program Visualization Workshops (PVW)). For pro- gram understanding, program executions often generate very large traces. It is a challenging task to represent these masses of data in a digestible form and a lot of research is conducted for appropriate visualization techniques.

To reduce the cost of finding fragments, Debray et al. limit the search for fragments in their compactor to whole basic blocks, only [2]. We learned from our visualization that this would drastically reduce the efficiency of at least our compactor.

Earlier work on tail merging procedural abstraction in [5] and [8] did not provide any comparison with traditional procedural abstraction, and it remained unclear whether there is an actual improvement for real programs. This lack of comparison data motivated us to write not only a traditional, but also a tail merging procedural abstraction post pass optimizer. The reduction for mpeg2enc under traditional procedural abstraction is 1.160% and for tail merging procedural abstraction is 1.242%. The reduction over all seven MediaBench programs is on average 2.502% and 2.716%, respectively.

We intend to write an interactive program map, e.g. a java applet which lets the user interactively explore abstractions in a program. It will be able to not only display the program maps discussed here, but it will also allow one to see references between abstractions of a procedure, e.g. clicking on a fragment will highlight multiple occurences of the same fragment. Interactively removing and re-adding fragments will show the current reduction and, if sufficient profiling information is available, show the estimated run-time of the program.

