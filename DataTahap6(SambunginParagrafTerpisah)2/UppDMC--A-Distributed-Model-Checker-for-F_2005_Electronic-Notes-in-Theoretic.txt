In this paper, we describe the actual implementation of the algorithms for workstation clusters and supercomputers, in a system called UppDMC. The system is developed in C++ using the message passing standard MPI [9] for communication among the different computers. The current version is mainly intended to show the effectiveness and benefits of parallel model checking in practice, still leaving opportunities for optimizations. The system is available at http://www.it.uu.se/research/project/parallelMC.

To make the forthcoming implementation section more understandable, we recall the main ideas of the parallel algorithms that are implemented. How- ever, we restrict our exposition to the algorithm for L1 [3]. Instead of formal definitions, we just give examples. See [3] and [12] for further details.

We have implemented the previously mentioned algorithms in a system called UppDMC . The system is developed in C++ using the message passing standard MPI [9] for communication among the different computers. It does not depend on the previous implementations in Haskell or C++ [2] and is more focused on performance. The current version is mainly intended to show the effectiveness and benefits of parallel model checking in practice.

While some of the algorithms in [3] and [12] can be carried out on-the-fly, the current version of UppDMC only makes partial use of it. Especially in the measurements shown in the next section, we work on previously generated transition systems. This only due to practical reasons: To be able to compare our system with existing model checkers, we use the precomputed transition systems made available as the VLTS benchmark suite. 6 It is easy to adapt our system to one behaving in an on the fly manner.

The game graph module defines the main data structure of the model checker. Game graph nodes are stored hashed on subformula to avoid storing the subformula in each node. Storing nodes grouped by subformula makes it easy to find the initial nodes of a component since all initial nodes in a component have the same subformula. Recall that the parallel algorithm works on components of the game graph one after the other. Therefore, the initial nodes of components are needed.

The labelling of the nodes in the coloring algorithm is roughly as follows. If it is a kind of or-node, it becomes green when one successor is green, and red, if all successors are red. Checking the latter could be costly when successor nodes and parent nodes are placed on different computers. In general, this suggests to keep information of colors of children also in the parent node to avoid this. However, for our algorithm, we can do better: The algorithm implies that successors only change their color once. Hence it is sufficient to just count the number of red and green successors given that we know the total

The transition system and game graph data structures are designed to give a reasonable time as well as memory efficiency. They are not optimized from a memory usage perspective. However, our focus has been to check the practical applicability of the algorithm and not to integrate it with more efficient data structures (like BDDs). This could be a direction for future work.

