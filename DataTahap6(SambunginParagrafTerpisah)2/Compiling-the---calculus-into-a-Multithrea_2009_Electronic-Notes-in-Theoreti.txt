The type system we propose for MIL closely follows the tradition of typed as- sembly languages [20,21,22], extended with support for threads and locks, following Flanagan and Abadi [8]. With respect to this last work, however, our work is posi- tioned at a much lower abstraction level, and faces different challenges inherent to non-lexically scoped languages. Lock primitives have been discussed in the context of concurrent object calculi [7], JVM [9,10,16,17], C [12], C-- [27], but not in the context of typed assembly (or intermediate) languages. In a typed setting, where programs are guaranteed not to suffer from race conditions, we

Tuple creation in registers. In order to initialize read-only tuples, these are created directly in registers. As long as the tuple remains local to the (single threaded) processor there is no need to protected it with a lock nor to gain permission to manipulate it. If the tuple is to be shared, the share instruction allocates memory in the heap, copies the tuple in the register to the heap, while protecting it with a lock or marking as read-only.

Polymorphic types. We discussed how to introduce universal and existential types in [30]. Here we incorporate both kinds of polymorphism, in particular existential types over locks. Universal and existential types over locks allow a lock variable to escape the static scope where it was declared.

Whenever the buffer is empty, as in the initial state of the monitor, the operation that removes the first element from the queue is undefined. We make sure that the consumer waits until the producer has made the queue nonempty. The queue is assumed to be infinitely large, thus there is always room in the queue for producers to append new elements. For this reason, and contrasting with removing from the buffer, appending does not block.

