The Event-B method is a formal approach to modelling systems, using refinement. Initial specifi- cation is done at a high level of abstraction; detail is added in refinement steps as the development proceeds toward implementation. In software systems that use concurrent processing it is neces- sary to provide details of concurrent features before implementation. Our contribution is to show how Event-B models can be linked to concurrent, object-oriented implementations using an inter- mediate, object-oriented style specification notation. To validate our approach and gain further insight we automated the translation process with an Eclipse plug-in which produces an Event-B model and Java code. We call the new notation Object-oriented Concurrent-B (OC-B). The nota- tion facilitates specification of the concurrent aspects of a development, and facilitates reasoning about concurrency issues in an abstract manner. We abstract away implementation details, such as locking, and provide the developer with a clear view of atomicity using labelled atomic clauses. We build on techniques introduced in UML-B to model object-oriented developments, introducing non-atomic operations and features for specifying implementation level details.

When defining the mapping to Java we need to ensure freedom from in- terference by restricting visibility of its data, and enforce a mutual exclusion policy for access to shared data. It also utilises conditional waiting, but incor- porates restrictions to avoid the nested monitor problem [15] (wherea monitor incorrectly retains a lock when a thread waits). In particular we are concerned with preventing interference between concurrently executing processes. Con- current execution of interleaving processes is a typical way of scheduling ac- tivities in a system where, using time slicing, each process can periodically undertake some of its processing. Interference can occur when processes share memory; values observed by a process are changed unexpectedly by some other

Section 2 introduces the definition of a system with processes and program counters. Section 3 introduces our definition of monitors, which we extend in section 4 with object-oriented features. Section 5 introduces some syntactic sugar, and we show an example refinement of an Event-B model to an OC- B model in section 6. Section 7 describes the mapping to Java, section 8 discusses related work and we present conclusions and ideas for future work in section 9.

In order to define TP we introduce a function TNA that maps a non-atomic clause to a set of events. The label supplied to TNA is the successor label. Each non-atomic clause has a successor label which is the label of the non- atomic clause that follows it. TNA is typed as follows,

Clause l1 is guarded by g ; if g is true then b occurs, the program counter is unchanged and the loop body can be evaluated again. In the case where the guard is false the action is Skip, and the program counter is set to the value supplied as the Label parameter. We now present the mapping where the optional non-atomic clause, na, is present. In the following definition the program counter is updated to allow evaluation of na using the label identified by sLabel(na). The last event arising from the clauses of na resets the program counter to the initial value, this models the behaviour where the loop can begin again, or exit depending on the guard.

Transformation of a labelled guarded atomic action is defined next. The trans- formation TLA takes an atomic statement, the end label and owning process name as parameters, and returns an event. If the guard is omitted from the specification then a true guard is assumed.

We define a TLA mapping for the new clause. We ensure the type of the return variable matches the assigned variable in a static check. We impose restrictions on A, so f1,... , fk can only appear in guards and expressions; and return only appears on the LHS of an assignment.

In the mapping we use substitution; formal parameters are substituted for actual parameters in the guard and action, and the return variable is substituted by the assigned variable on the LHS of the call. We show a small example of substitution where a variable of the caller, v, is assigned the value returned by a procedure call, pn. We assume the monitor has some variables, x and r. We define the procedure, pn(Integer z){x := z  return := r}, and call v := m.pn(y). Then substitution is as follows, (x := z  return := r)[z\y][return\v] = (x := y  v := r). Substitution for guards is similar to that for actions.

procedures with the reserved name, create. Each monitor and process class must have a constructor procedure where initialisation of variables takes place. A new instance is constructed when the create procedure is invoked. Actual parameters, a, supplied to constructors may be used to initialise variables, by substitution of formal parameters, f. A system is modelled as a class with the name Main and type MainClass, its non-atomic clause corresponds to the Java main method - the entry point for execution in the implementation.

Non-atomic operations contain labelled atomic clauses which map to events. Program counters values (derived from labels of the atomic clauses) are used to model the flow of execution through the non-atomic operations. It is assumed that process instantiations begin processing immediately, that is, in the implementation the threads are started immediately following creation. We add to the syntax an atomic constructor-call clause involving class C, and add ProcessClass and MonitorClass.

variable, and refer to it with respect to an instance. The instance may be the caller; the target, in the case of a procedure call; or a new instance, in the case of constructor initialisations. This occurs in both actions and guards of the mapping. If v is a variable, and s is an instance, of class C, then v(s) refers to the value of variable v belonging to instance s. To rename a variable we apply the function, TV, which takes a guard, action or expression parameter, and maps it to the corresponding Event-B representation. We additionally supply a set of variable names (those of the class being referred to) and the name of the Event-B variable representing the instance. The type of TV is defined as follows,

We show an example mapping with a variable v, used in a labelled assign- ment l1 : v := v + 1, and a calling instance s. The mapping using TV is, TV (v := v + 1, vn, s) = (v(s) := v(s)+ 1) where vn = {v}. The effect of function application is that wherever a variable in vn occurs it is referred to with respect to s.

We now look at the definition of TLA for monitor procedure calls. We define a call of procedure named pn on target m, a variable belonging to instance s; j = m(s) types an Event-B local variable referring to the monitor instance being called. We will perform a static check to ensure the return type of the procedure matches the variable being assigned to; and we prohibit use of the return variable in gp, and on the RHS of assignment expressions in A.

We now show how the translation functions may be applied to give rise to Event-B. Firstly we show some details of an example that we may want to refine. The abstract development models a set of processes and shared objects, with the event U pdateI which repeatedly assigns the value of a variable val to i and records the number of attempts. The assignment is however only made if the assigned value is greater than zero. The event setV al changes the value of val. The variables are declared and typed as follows,

We now consider the translation of the run operation of the process class Prc which gives rise to three events. The events arise from the translation of the first clause l1 with the true guard; l1 with the false guard; and the second clause l2 of the body. We now show the event evt l1 true, the true branch that arises from the clause labelled l1. The refinement consists of two aspects, one of which deals with the newly introduced program control structure; the other refines the existing abstract events; the following event refines U pdateI of the abstract model.

state and behaviour of a class, and variables can take the type of a class. Inheritance mechanisms are used to clarify the structure of the systems and aid refinement and verification. Object-Z differs from OCB in a number of ways, for example we do not incorporate the notion of inheritance and we do not refine an OCB specification. OCB forms a link in the development process between the Event-B modelling language and the implementation, Object-Z is used for system specification.

VDM++ [5] is an object oriented approach which is an extension of VDM- SL [11], UML diagrams are used to specify an object oriented development which are mapped to an underlying VDM++ model. VDM++ can be trans- lated to Java but is not able to model features involving concurrency. Circus combines CSP [9,19] and Z [26]. The JCircus [7] translation tool gives rise to Java code which is intended to serve as an animator for circus. JCircus makes use of the JCSP libraries and gives rise to Java code that is based on the message passing approach, in this respect it is similar to JCSProB.

The mapping to Java was then discussed, and an example of the resulting Java code presented. The OC-B specification makes use of clearly defined atomic regions, which map to Java code with corresponding atomic regions. We are confident that the mapping will give rise to interference free execution, due to the restrictions we impose. We are also confident in the correctness of

We have developed prototype tool support for our approach, integrating with the RODIN Event-B tool. It is based on the Eclipse Platform [27] and incorporates an Eclipse based utility for construction of OC-B specifications. We have developed plug-ins to translate OC-B specifications to Event-B and Java source code. We have used the tool development to gain insight, and validate our theoretical work. We also hope the tool will be a useful legacy to be extended further with more useful features in the future.

In future work we plan to introduce transactional constructs. These will allow access to multiple shared objects, and will allow us to remove some of the restrictions in place at the moment. We plan to use the java.utils.concurrent packages for greater efficiency and flexibility, for instance techniques can be applied to overcome the nested monitor problem by controlling lock acquisition and release. We believe that specification using OC-B can ease the transition between formal modelling, at an abstract level, and providing a concurrent implementation. Reasoning about concurrency is simplified by abstracting away details of locking, and by providing a clear view of atomicity.

