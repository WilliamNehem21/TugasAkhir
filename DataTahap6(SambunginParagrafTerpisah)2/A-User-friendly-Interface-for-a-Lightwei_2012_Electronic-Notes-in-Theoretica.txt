User-friendly interfaces can play an important role in bringing the benefits of adopt- ing a machine-readable representation of formal arguments to a wider audience. There exist many such benefits both in mathematical instruction and in research efforts involving mathematical rigor. These include reusability, automatic evalu- ation of examples, and the opportunity to employ machine verification. Machine verification can offer anything from detection of basic errors, such as the presence of

It is the task of the parser to process the concrete syntax of the portion of an argument that is to be considered for verification. The parser for the concrete syntax is constructed in Haskell using the Parsec parser combinator library [17], which is expressive enough for constructing infinite lookahead parsers for general context-sensitive grammars. This library is simple to use and allows for a succinct parser implementation. The aartifact parser performs without noticeable delay on all inputs on which it has been tested (the infinite lookahead capability is utilized at only a few points in the parser definition, such as to allow expert users to define their own infix operators). The overall approach to handling syntactic idioms using a context-sensitive parser is similar to the approach employed in the design of the parser for the Fortress programming language [26].

We have utilized [16] the aartifact system in defining and reasoning about a compositional formalism for a typed domain-specific language [4]. The ability to implicitly invoke propositions dealing with the algebra of sets was essential in mak- ing this process manageable and in allowing the resulting proofs to be legible. This exercise also led to the discovery of a few minor errors and to the simplification of a few definitions in the compositional formalism.

Somewhat relevant work in providing search capabilities for a library of ex- pressions has been done within the context of Haskell. Search facilities have been developed that allow users to retrieve and browse expressions within a context by their type [13], and there exists an online search tool called Hoogle for exploring the Haskell libraries [20]. The work of Hallgren and Ranta [9] presents a proof editor that uses a natural language parsing framework in conjunction with type checking to interactively help the user utilize supported formal and natural language syntac- tic constructs while authoring a verifiable proof. Matita [3] is a proof assistant the automation of which is heavily based on an integrated search engine. There has also been work on retrieval of library functions, and even automated construction of programming language code snippets, using collections of keywords [10,18]. This work suggests that our own future efforts can be directed into better integrating the real-time lookup functionality with validation capabilities. For example, the real-time lookup hints can actually provide suggestions for valid expressions that consist of variables that are within the scope of an assertion in an argument. More generally, it may be possible to represent some simple validation techniques (e.g. unbound variable detection) in their entirety as JavaScript applications.

