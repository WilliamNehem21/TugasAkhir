The emergence of efficient SAT solvers over the last decade [21,25,26,11] has greatly contributed to the success of BMC. The new generation of SAT solvers improves over the classical DPLL procedure [8,7] in several ways. Of interest to us are conflict analysis and clause recording: When a conflicting assignment is found, it is analyzed to identify a subset that is still conflicting. The disjunction of the negation of the literals in the subset is a conflict-learned clause (or, more concisely, a conflict clause) that can be added to the given SAT instance to prevent the examination of regions of the search space that are guaranteed to contain no solutions. Not all conflict clauses are worth keeping; many SAT solvers periodically discard those that have proved ineffective.

where V is the set of (current) state variables, W is the set of combinational variables, I(V ) is the initial state predicate, and T (V, W, V ') is the transition relation. The variables in V ' are the next state variables. All sets are finite, and all variables range over finite domains.

order in which their implications are propagated. A conflict clause is obtained by disjoining the negation of the literals forming a cut in the implication graph that separates the conflict node from the roots of the graph. The First Unique Implication Point (UIP) approach [26] starts from the conflict node and looks for the first cut such that it contains exactly one literal implied by the most recent decision.

is turned into auxiliary by negating its literal. In general, the usefulness of conflict clauses that depend on the primary objective is dubious, even when they do not contain the objective literal. Hence, in the following, we propose two techniques to identify objective-independent clauses.

whether the objective is in the transitive fanin of the conflict node. However, most modern SAT solvers, including CirCUs, use the first UIP to find con- cise explanations of conflicts. Therefore, standard conflict analysis does not need to traverse all the transitive fanin of the conflict node. Hence the naive approach may incur overhead.

Since we propagate the objective flag during implication, we can check if the conflict is related to the objective by checking the mark of the conflict node. If the conflict node is not marked then we need to traverse the implication graph to check whether objective-dependent conflict clauses are the reason for the current conflict. However, we only traverse until the first UIP is found. Even though the rest of the implication graph has objective-dependent conflict clauses, they can be ignored. The reason of the conflict is isolated from those clauses by the first UIP.

In [20], the author propose a method to identify conflict clauses to be forwarded in BMC based solely on the circuit structure. First, all the clauses created from the circuit structure are marked. Once a conflict happens, one checks if all clauses leading to the conflict are marked. It so, the conflict is derived from inconsistency between the current assignment and the circuit structure. Therefore, the conflict is marked for forwarding. This method does not account for auxiliary objectives, which, as shown in Section 4, often speed- up BMC. Second when BMC is applied to optimized circuits, in which most redundancies have been removed, the clauses that are solely derived from the circuit structure tend to be few. This occurs in our experimental setup, since we apply BDD sweeping [16] to remove redundancy.

Although the criterion of Section 3.1 forwards more clauses than the one of [20], it is still rather conservative and may miss many useful conflict clauses. Therefore, in this section, we develop a semantic criterion that is applied to small clauses that failed the syntactic check based on dependency on the objective.

To distill a clause under the new objective, we check whether the clause is satisfied under the assignments that are implied by the unit clauses of the new SAT instance. If the clause is satisfied, it is discarded. Otherwise, we assert the negations of its literals and carry out the resulting implications. If this does not result in a conflict, the clause is discarded. (Therefore, distillation can be applied also when not all clauses can be forwarded.) Otherwise, the clause obtained by conflict analysis is the distilled version of the given clause and is forwarded.

The distillation process has several advantages. First, it is a semantic approach that may derive clauses that were not produced by previous SAT checks. Second, some of these clauses are reusable because they do not depend on the current objective. Since the criterion based on tracing the objective is conservative, we often find many objective-independent clauses from the objective-dependent clauses of the previous run. Third, the quality of conflict clauses usually is improved by distillation. This is partly due to the different order in which assignments are made, and which results from the traversal of the trie. Moreover, the first UIP tends to be closer to the conflict than the literals in the clause to be distilled that it replaces.

We have implemented the clause forwarding techniques in CirCUs, which is built on top of VIS-2.1 [4,22]. To show the effectiveness of objective tracing and distillation, we compare non-incremental SAT to incremental SAT. The non-incremental version of CirCUs was shown to be competitive with a popular CNF SAT solver, Zchaff, in [14].

The experimental setup is as follows. We build BMC instances for given LTL properties from the VIS benchmark suite [22]. We check for counterexam- ples of length up to 20. We first expand the AIG for the prescribed number of time frames and then apply BDD sweeping [16] to the result to remove redun- dancy. The maximum number of literals of a clause that undergoes distillation is 50.

The fifth and sixth columns show the number of clauses forwarded by distil- lation. The objective-independent clauses from distillation are collected from all timeframes, but the objective-dependent clauses from distillation are gen- erated from the last timeframe only. Only the objective-independent clauses are forwarded to the next runs.

