This paper presents an approach for the development of model-checkers in a framework, called TOM, merging declarative and imperative features. We illustrate our method by specifying in TOM the Needham-Schroeder public-key protocol that aims to establish a mutual authentication between an initiator and a responder that communicate via an insecure network. We describe the behavior of the agents exchanging messages as well as the intruders and the security invariants the protocol should verify using the rewrite rules of TOM. The (depth-first or breadth-first) exploration of the search space is described using the imperative features of the language. We propose several optimizations and we compare our results to existing approaches.

Programming with rewrite rules and strategies has been already used for de- scribing several computational logics and transition systems. In rewrite based languages like ELAN [2] or MAUDE [4] the transitions can be described by conditional rewrite rules and the way these rules are applied is defined using strategies. For example, one can define a strategy that applies exhaustively all the rules in all the possible ways and thus verify if, starting from an initial state, a certain state can be reached (by successive transitions). It is then natural to use such rewrite based frameworks in order to model-check tran- sition systems and, in particular, cryptographic protocols like the Needham- Schroeder public-key protocol.

The Needham-Schroeder public-key protocol [14] has been already ana- lyzed using several methodologies from model-checkers like FDR [15] to ap- proaches based on theorem proving like NRL [10]. Although this protocol is described only by a few rules it has been proved insecure only in 1995 by G. Lowe [8]. After the discovery of the security problem and the correctness proof of a modified version [9], several other approaches have been used to exhibit the attack and obtain correct versions [10,12,5].

The final goal of the protocol is to provide mutual authentication between agents communicating via an insecure network. The agents use public keys distributed by a key server in order to encrypt their messages. We consider here a simplified version proposed by G. Lowe in [8] where we assume that each agent knows the public keys of all the other agents but it does not have access to their private keys.

The state transitions of the agents and of the intruder as well as the in- variants the protocol should satisfy are described by TOM conditional rewrite rules. The specification is both natural and concise, the rewrite rules describ- ing the protocol being directly obtained from classical presentations [8]. In order to improve the efficiency, the imperative features of the language are used.

The strategy guiding these rules and thus exploring the search space is completely defined using the imperative part of TOM. We obtain a very flex- ible and efficient specification of depth-first and breadth-first strategies. The execution of the specification allows one, on the one hand, to describe attacks and, on the other hand, to certify the corrected version by exploring all the possible behaviors.

public-key protocol is described in Section 3 together with an attack and a corrected version. Section 4 presents the encoding of the protocol and com- pares our results with other approaches. The last section concludes the paper and presents perspectives to this work.

TOM is a language extension which adds new matching primitives to exist- ing imperative languages. This is particularly well-suited when describing various transformations of structured entities like, for example, trees/terms and XML documents. The main originality of this system is its language and data-structure independence. From an implementation point of view, it is a compiler which accepts different native languages like C or Java and whose compilation process consists in translating the matching constructs into the underlying native language. Its design follows our experiences on the efficient compilation of rule-based systems [7]. For an interested reader, design and implementation issues related to TOM are presented in [13].

matching, also known as associative matching with neutral element. Let us consider the associative operator conc used for building lists of naturals (NatList). In TOM, an associative operator is variadic and each sub-term could be either of sort element or list (respectively Nat or NatList in our case). To illustrate the expressiveness of associative matching, we can define a sorting algorithm as follows:

The initiator A seeks to establish a session with the agent B. For this, A sends a message to B containing a newly generated nonce NA together with its identity and this message is encrypted with its key K(B). When such a message is received by B, the agent can decrypt it and extract the nonce NA and the identity of the sender. The agent B generates a new nonce NB and sends it to A together with NA in a message encrypted with the public key of

The intruder is a user of the communication network and so, it can initiate standard sessions with the other agents and it can respond to messages sent by the other agents. The intruder can intercept any message from the network and can decrypt the messages encrypted with its key. The nonces obtained from the decrypted messages can be used by the intruder for generating new (fake) messages. The intercepted messages that can not be decrypted by the intruder are replayed as they are.

An attack on the protocol is presented in [8] where the intruder imperson- ates an agent A in order to establish a session with an agent B. The attack involves two simultaneous runs of the protocol: one initiated by A in order to establish a communication with the intruder I and a second one initiated by I that tries to impersonate A (denoted by I(A)) in order to establish a com- munication with B. The attack involves the following steps, where I.n, II.n represent steps in the first and second session respectively and I(A) represents the intruder impersonating the agent A:

The agent A tries to establish a session with the intruder I by sending a newly generated nonce NA. The intruder decrypts the message and initiates a second session with B but claiming to be A. The agent B responds to I with a message encrypted with the key of A and the intruder intercepts it and forwards it to A. A is able to decrypt this last message and sends the appropriate response to I. The intruder can thus obtain the nonce NB and sends it encrypted to B. At this moment B thinks that a session has been established with A while this session has in fact been established with the intruder.

In this section we give a description of the protocol in TOM. The TOM rewrite rules correspond to transitions of agents from one state to another after send- ing and/or receiving messages. The strategies guiding the application of these rewrite rules describe a form of model-checking in which all the possible behav- iors are explored. This exploration can be done in a depth-first or breadth-first manner. The former approach is more efficient for detecting an attack when it exists and thus when the exploration of the search space is not complete, while the latter approach is more efficient when a corrected version is analyzed and thus all the possible states are eventually explored. The specification tech- nique we have proposed in this paper allows us to explore a finite state space and thus, it is well suited for detecting the attacks against the protocol and not for proving its correctness in an unbounded model.

Each agent is characterized by a state that is modified when it sends or receives a message. The transitions of the agents and, more generally, of the global environment, from one state to another are specified by TOM rewrite rules. All the possible behaviors are then explored by trying to apply each of the defined rules on the current state.

As mentioned previously, the datatypes are defined abstractly using many- sorted signatures and, more precisely, we use ApiGen to generate a Java imple- mentation which ensures maximal sub-term sharing. A complete specification of the agents, messages and the network is described in section 4.1. In sec- tion 4.2, we show how TOM can be used in order to describe concisely the behavior of the agents (using transition rules) and the exploration of the search space (using Java native code).

When using this kind of encoding, if the agent that generated a nonce memo- rizes it then, the agent knows at each moment who is the agent with whom it is establishing a session. For example, the agent alice generates and mem- orizes the nonce N(alice,bob) when trying to establish a session with bob. A dummy nonce DN is defined as N(dai,dai) where dai is a dummy agent identity.

If the destination of the previously sent message is a responder in the state SLEEP, then this agent gets the message and decrypts it, if encrypted with its key. In this latter case, the responder sends the second message of the protocol to the initiator and goes in the state WAIT where it waits for the final acknowledgment. For efficiency reasons we can suppose that all messages are intercepted by the intruder and only afterwards forwarded to the concerned agents. We implement this optimization proposed in [11] and we consider that the initiator and the responder listen only to messages coming from the intruder:

Once again, due to the associative matching used for the message lists, the position of the message in the network (i.e. the moment when the message was sent) is not important. Notice that the message should not only have y as destination but it should be also encrypted with its public key. The encrypted identity of the sender of the message will be used in order to build the response to this message.

Two other rewrite rules describe the other steps of the protocol. For these rules as well we consider only messages that have been intercepted and for- warded by the intruder. The specification of the original version of the protocol can be easily adapted in order to obtain the corrected one. Since the agents

The case where the intruder cannot decode the message and thus just stores it, is handled in a similar and simpler way. These (encrypted) messages stored by the intruder are sent to all the agents without modifying the encrypted part but specifying that the message comes from the intruder. The TOM rule describing this behavior is similar to the previous ones: the message to be sent and its destination are selected non-deterministically from the list of stored messages and from the list of senders/receivers respectively.

Due to the associative matching used for selecting nonces and agents, every time this rule is applied either a different message is generated or the message is sent to a different destination. This way the intruder generates all the possible messages and sends them (if not already sent) to all the possible agents. A similar rule describes the construction of messages containing only one nonce.

The invariants used to specify the correctness conditions of the protocol are expressed as well by rewrite rules. We have to check the authenticity of the responder, that is, to check if the agent that replied to the initiator is indeed the correct one (and not the intruder, for example). Similarly, we should verify that the communication was established with the agent that initiated it, that is, the authenticity of the initiator.

The rewrite rule describing the negation of the first invariant and thus, the possibility of an attack checks if an initiator has concluded the protocol (i.e. is in the state COMMIT) while the corresponding responder (that is not an intruder) has neither committed nor sent an appropriate response (and thus ready for committing). More precisely, an attack is possible if there exists an initiator in the state COMMIT such that the corresponding responder is neither in the state COMMIT nor in the state WAIT (waiting for an acknowledgment from the initiator).

In a previous implementation written in ELAN, the backtracking mecha- nism was used to explore the search space: when a message does not lead to an attack, a backtrack is performed and a new destination and/or address are selected. We go on like this until an attack is discovered or no new mes- sages can be generated. This allows the intruder to generate all the possible messages and send them (if not already sent) to all the possible agents. One difficulty, when using a backtracking approach, is to model a strategy other than the depth-first one. In our case, since several transitions can lead to the same state, it is interesting to explore the search space with a breadth-first strategy and to delete the doubles reducing this way the number of states to explore.

When using TOM, contrary to systems like ELAN or Prolog, the search space has to be handled explicitly. On one side this leads to more complex implementations, but on the other side, this gives more flexibility for the description of search strategies which are thus specific and optimized. In the current implementation, we start with a set of states which contains the initial state. Then, for each state of the set, we compute the set of successors: all the states that can be reached by applying a single transition step. This process is repeated until either an attack is found in the set of states or a fix-point is reached: no more transition can be performed.

In ELAN the rules describing the protocol and the strategy guiding these rules are defined at the same level. We obtain thus a uniform specification but, although the strategy language is fairly powerful and the definition of a depth- first search method is natural and simple, the description of breadth-first strategies is complex and needs a modification of the existing rules. Several operators like, for example, the ones used for building the list of messages, are declared as associative-commutative avoiding thus some implicit manipulation like sorting the messages.

First, we can compare the ease of modeling of these approaches. For this, we need to use some kind of metric like the one used in [1]. As the metric reflects only part of the story, care must be taken in interpreting the results. We will compare the number of lines in the different parts of the specification. This is not problem free, as the number of lines is influenced by layout conventions, and there must be compromise between code size, clarity of the specification and development time.

This fine grained control over the execution of the model leads to an op- timized execution of the model. Tests are performed on a 1,4 GHz Xeon workstation with 512MB memory and 256KB cache. For these tests, we con- sider the fixed version of the protocol, as described in [9]. We explore thus the entire search space, showing that there are no attacks in the corrected version of the protocol when variable numbers of agents and messages in the network are considered.

We have proposed an approach merging declarative and imperative paradigms for the verification of the Needham-Schroeder public-key protocol. The rules describing the protocol are easily represented by TOM conditional rewrite rules. The built-in list-matching available in TOM allows us to express and easily handle the random selection of agents from a set of agents or of a message from a set of messages.

