State-of-the-art security mechanisms are often enforced in isolation from each other, which limits the kinds of policies that can be enforced in distributed and heterogeneous settings. More specifically, it is hard to enforce application-level policies that affect, or use information from multiple distributed components. This paper proposes the concept of a Security Service Bus (SSB), which is a dedicated communication channel between the applications and the different security mechanisms. The SSB treats the security mechanisms as reusable, stand-alone security services that can be bound to the applications and it allows the enforcement of advanced policies by providing uniform access to application-level information. This leads to a security infrastructure that is more flexible and more manageable and that can enforce more expressive policies.

Distributed applications consist of interacting components that are deployed on various locations in the network. Nowadays, instead of being programmed from scratch, applications are often built by composing heterogeneous, reusable compo- nents. When security becomes a priority, several techniques exist to bind security mechanisms to these components. For instance, security mechanisms can be sup- ported by the middleware such as an application server or a virtual machine, they can be injected in the code by security automata [20] or aspect-oriented program- ming techniques [6], or they can simply be embedded in the code of the components.

In Section 2, we illustrate the need for the SSB by means of a concrete example. In Section 3, we discuss the SSB concept in more detail. Section 4 shows how to the SSB facilitates the enforcement of the policies from Section 2 and points out some other interesting applications of the SSB. Section 5 discusses related work and Section 6 concludes the paper.

The first and second policies illustrate that a policy might need access to in- formation that is not local to the enforcement point for that policy. In the first policy, the access control mechanism of the web container needs information from the .NET component and in the second example, the access control mechanism of the .NET environment needs information about the EJB component. The third policy illustrates that security policies might affect several distributed components: the detection of an event at the web container triggers a change in the policies of different security mechanisms.

Without any further support, supporting policies like these is not straightfor- ward. The first and the second policies depend on information that is located in other (remote) components. Some information about the caller (mainly its identity and/or its credentials) is usually propagated over communication protocols such as IIOP and SOAP, but evidently it is not feasible to propagate all kinds of informa- tion the security mechanisms will ever need, especially when this is application-level information that is not always known beforehand. One way of implementing these policies without any further support is to make all the components interoperable using a common protocol such as SOAP. Another approach is to let some com- ponents be proxies for components they are connected to. For instance, the EJB component could expose the bad payer attribute from the payment component to the web shop. For supporting the third policy, the auditing policies of the different middleware platforms would need to be exposed to the web container and the audit mechanism on the web container would need to be able to detect the attempted access to the management interface.

Applications are bound to the SSB by means of an application binding. This is a wrapper component that presents an abstract view on an application to the SSB. The SSB aggregates all these views on the applications and provides a uniform abstraction layer to the security services that is independent of all application- specific details and that contains all application-level information available. When a

The application binding implements of an enforcement interface and an informa- tion interface. The enforcement interface specifies all resources that are contained in the application and lists all the actions that can be performed on these resources. Resources and actions can correspond directly to low level concepts in the imple- mentation of the application (such as a class and its methods), but they can also represent more abstract entities. The application binding guarantees that the be- havior of the security services can be invoked each time an action on a resource is called. The security services can then use the SSB for obtaining information about the subject that wants to execute the action, the action itself and the resource on which the action is executed.

In the context of security information, events are things that happen in a system that are relevant for security. Often, an event is a trigger of security logic. Usually, an event is triggered by the invocation of an operation or the sending of a message. Security events are found at two levels: interesting problems that can be tackled more easily when a SSB is provided. Sup- pose that we have a single security domain consisting of many subdomains. In such a case, the flow of security information needs to be controlled very tightly. Guaran- teeing this without an SSB would be very cumbersome. However, when applications within these domains would be connected by a SSB, they could explicitly advertise the information flow policies and rely on the SSB for enforcing them in a uniform way.

Several authors have explored the enforcement of advanced security policies that can take into account more information than the typical user/action/resource at- tributes. For instance, the dimension of time can be included and decisions can be made depending on previous events [20,2] or future events [12,9]. In the field of access control, several authors have proposed ways of representing, using and ob- taining application-level information for use in access control policies [3,24]. These advanced policy enforcement mechanisms work well in local and homogeneous en- vironments, but because of the lack of a uniform communication channel, it is hard to apply them in a distributed and heterogeneous setting. The work that perhaps comes closest to the SSB is Tivoli Access Manager [13], but this approach only considers access control and as such it does not address the problem of generically binding the applications with security services.

The security mechanisms within some platforms are architected with flexibility in mind in the sense that third parties can develop pluggable modules that extend the security functionality. For instance, the Java Authentication and Authorization Service (JAAS) [4] and the Java Authorization Contract for Containers (JACC) [21] allow customization with new authentication mechanisms and authorization engines respectively. The SSB can be seen as a generalization of these approaches that is inherently distributed.

Existing ways of sharing security information are mostly found in middleware protocols such as IIOP, .NET Remoting or SOAP. When propagation at the protocol- level is not possible, alternative solutions are needed. In the literature, different approaches exist for attaching security metadata to an execution context at a lower level than the protocols. Stateful Distributed Interposition (SDI) [19] and Cause-

In this paper we have motivated the Security Bus concept as a way of interconnecting security services and we have illustrated how to apply this idea to the enforcement of a set of policies that span multiple distributed applications. This work discusses the general concept of an SSB rather than a fully worked-out architecture. We are currently designing the first version of our architecture in detail and we aim to validate it in a prototype.

