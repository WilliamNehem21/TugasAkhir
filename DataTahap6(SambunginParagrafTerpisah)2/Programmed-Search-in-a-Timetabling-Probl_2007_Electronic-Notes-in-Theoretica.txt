In the last years, the number of applications of timetabling has grown spectacularly. Timetabling [6] refers to the allocation, subject to constraints, of given resources to objects being placed in space-time, in such a way as to satisfy as nearly as possible a set of desirable objectives (also known as the cost function). Timetabling problems are NP-complete and, therefore, these problems have been usually tackled with four techniques: evolutionary computing [25,15], integer programming [13], constraint programming [18], and constraint logic programming [19]. Evolutionary computing is based on rules simulating natural evolution and solutions are stochastically looked

In this paper, we perform a programmed search based on the knowledge about the solution structure. It amounts to generate a seed [24], as a case of local search space pruning [5,29,4,7]. This search consists of a fast generation of a seed which will be used as a starting point for the classical propagation and labeling techniques present in constraint solving (see also [20,8]). In contrast to other approaches, as stochastical (such as evolutionary computing and simulated annealing), we will be able to quickly find a first solution but retaining the ability of searching the whole solution space by using the efficient constraint solving classical techniques (i.e., propagation and labeling). We can apply this technique for those problems in which solutions are close to the seed because of the problem structure itself.

This paper is organised as follows. Section 2 presents the specification of the timetabling problem in the concrete real case we faced. In Section 3, we describe our approach to the programmed search. Section 4 and 5 introduce, respectively, an outline of the implementation with both OPL 3.7 and T OY 2.1.0 systems. Section 6 resumes the performance results during a calendar up to one year, comparing and analysing the results from both systems. Finally, in Section 7, we summarise some conclusions and propose future work.

Each worker works during a time slot. With respect to worker qualification, we find two levels: workers with level 1 are experienced and can be workers in charge on all time slots. Workers with level 2 are apprentices and cannot be in charge of a team. In every team there is a worker with qualification level 2 and two workers with qualification level 1. A worker which has been working during a night must rest during the next two working days, at the least. The number of working hours during a year is established by a working calendar, and there are maximum and minimum limits, both monthly and annual, over working hours which cannot be violated. In every team, only one worker can simultaneously enjoy holidays.

Workers have to be assigned to time slots during the working calendar, which usually extends to one year, although plannings can observe shorter time intervals. Usually, a team works every four days. In a working day, there should be three workers available. Every worker has to be assigned to a different time slot (T1, T2 or T3). The joker has assigned the time slot T6 in absence of incidents. Saturdays and holidays feature two workers available with time slot T1 and the extra worker does not work. Time slots rotate for the workers in a team each time they complete a time slot. December 24th and 31st are special days without continuous service in which there must be two workers available, every one gets the time slot T5, and at least one worker must have a qualification level 1. When an incident happens because a worker is absent, and if the joker is available, then the joker replaces the absent. Otherwise, only two workers will cover the absence with time slots T1 or T4.

As stated in the introduction, in order to gain performance in the search-for- solutions process, we quickly generate a seed which is not expected to fulfill all the constraints imposed by the problem, and then we apply classical propagation and labeling techniques. The idea is to generate an assignment for the decision vari- ables present in the implementation of the problem such that the solution structure is observed. This means for our particular problem that we assign rotating time slots to each member of all the teams each four days in a consistent way with the working calendar, and ignoring some other constraints. Although this seed may not meet all the constraints, such as the limits imposed on the maximum number of working hours during the planning, it behaves as a good starting point for the classical constraint solving techniques to find a first solution.

The procedure to develop the seed is to assign the time slots T1, T2 and T3 to workers for working days, and T1 to two workers of the same team if either the day is Saturday or there is a known incident. Time slots rotate next days. Then, we assign incidents to workers. In such a way, the number of working hours of each worker is uniform along the planned calendar. If there are few incidents, we have found that the seed is close to a feasible solution because the labeling strategy finds a solution by processing a few nodes in the search tree.

The next code fragment shows how the searching is implemented in the OPL section devoted to user-defined search procedures. It features some (reflection) functions as dsize(v), which returns the size of the domain of v. bound(v) is true if the domain of v is a singleton. dmin returns the minimum value in the domain of v. let m = expression assigns to m the value computed for expression. try v = value 1 | v = value 2 assigns to v the value 1 and adds this assignment to the constraint store together with a choice point. On backtracking, v is assigned to the value 2 and the choice point is removed.

W. The reflection function fd min V returns the minimum value in the domain of V, whereas fd max V returns the maximum. rest V W removes the value W from the domain of the decision variable V. generate list X V generates a list of values including the value V and all the values in the domain variable X, assumed that maybe V is not a feasible assignment for X. The first element of the generated list is the value of the seed for X. try V [W|Ws] tries, by backtracking, to label the decision variable V with every value W of its second argument. my search [X|Xs] [V|Vs] tries to assign each value V in the list, which is in its first argument, to each corresponding decision variable X, which is in its second argument. ++ is the list concatenation operator.

In this section, we show the performance results we have obtained for finding the first solution of the stated real problem as implemented in the systems T OY 2.1.0 and OPL 3.7, both running on a Pentium III at 1 GHz with 256 Mb of RAM and Windows 2000 Professional. We have considered several calendar sizes, ranging from a week to a year, and also we consider built-in search strategies of these languages in order to compare with our programmed search based on the generation of a seed. We have obtained running times for these parameters as the average of four runs.

In this work, two of the best state-of-the-art constraint programming systems (in their corresponding settings) have been taken into account for implementing the specification of a real problem. From the performance results we have found that the average time for finding the first solution is low compared to classical techniques in the field of constraint solving, even if the seed is not a solution. It is therefore not necessary to specify a first solution to depart from in our searching proposal. The execution time becomes moderate with few different values in variable domains. OPL gives responses faster than T OY because T OY version 2.1.0 did not enjoy key features present in OPL as arrays indexed by decision variables. Implication and disjunction constraints were also not included, and we have implemented them, showing that their use augments program readability and introducing a reasonable burden.

Although OPL behaves clearly better than T OY, this system enjoys a more homogeneous syntax for solving problems in the sense that the same program con- structs are used to generate the seed, post constraints, and specify the search strat- egy. That is, there is no the impedance mismatch that can be found in OPL when used from a host language. OPL, in turn, has three sections in a program with iso- lated syntaxes: initialisation of data, decision variable and constraint declarations, and search procedures section (among others such as database handling). We have found that the implementation of the problem is easier in a language as T OY since it seamlessly embodies constraints into a very expressive general purpose language because of its declarative nature. In addition, the propagation solver for the T OY underlying system behaves reasonable fine w.r.t. the solver of OPL. Finally, while OPL is a commercial system, T OY is for free.

Some lines we emphasise as being amenable to explore as future work are: First, the inclusion of the array data structure with direct access on its elements, along the possibility to index such an array by means of decision variables. Second, a memory usage analysis (including garbage collection) in the context of a complex operating system. Finally, an algebraic component should be added to the language in order to be able to compactly declare constraints and decision variables. The algebraic notation would allow more compact programs, whereas (static) decision variable declarations would do for faster memory allocations.

