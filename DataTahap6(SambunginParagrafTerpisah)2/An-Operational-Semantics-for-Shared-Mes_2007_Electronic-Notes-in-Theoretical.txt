To achieve high performance, modern computer applications are executed on net- works of (multi)processors. Those with a high data rate like digital signal processing are most efficiently implemented on micro-architectures employing shared memory as a means of interprocess communication. However, shared memory programming has to deal explicitly with correct data access and data integrity and the negligence of these cause faulty computations. Architectures based on message-passing pre- vent such errors by barring shared address space and by their clear separation of computation and communication. But message-passing has the drawback of high data latency and redundancy of data transfer.

token (by get unused memory), writes its data to the granted memory region and then sends the token to the target node (send token) by message-passing. On the receiving side, the process receives the token (receive token), reads or writes on the assigned memory region and then either sends the token to another node or releases it (usage over). In general, when the volume of data transferred is very high, compared to the expense of granting, releasing, sending or receiving a token, the overall performance of shared-messaging communication can be significantly better than direct data communication.

SMC supports a system level design where certain features of a class of imple- mentations has been abstracted to a level which is amenable to a formal verification (cf. [6]). Employing SMC one goes beyond the purely qualitative behaviour de- scription. A current program using SMC as model of communication does not only specify the (qualitative) computation with respect to functionality but also makes (quantitative) assumptions by taking the decision that the underlying mode of data transfer should rely on shared memory.

Each node operates on its private memory space while interprocess commu- nication is based on SMC which affects the shared memory of the entire region. Accordingly, the operational semantics is given in two layers. First we define the semantics of single nodes and based on that the semantics of regions is given.

The semantics of the commands in the first line of the grammar for SMC-programs is completely standard (see e.g. [11]) and we assume familiarity with its presentation by a set of rules. In notation we use a for an arithmetic expression, b for a boolean

As we have left expressions and locations unspecified one may also assume con- current assignments and by this we may assume non-scalar data structures. This modelling admittedly dilutes a crucial property of SMC, namely, that not all the data written to the shared memory by a source process will not necessarily be ac- cessed by the target process (by csm). However, as the emphasis of our modelling is the administration of tokens we do not give a refined model here. The model as described in [9] assumes tokens of a predefined size (which we assume to be one).

For an application with a high data rate it is feasible to employ shared messaging communication in its final implementation. In this section we formally prove that any program using message-passing as communication mechanism can be rewrit- ten as an SMC-program such that the two programs are weakly bisimilar (up to some renaming of communication actions) which shows, in particular, that the (non)deterministic structure of the MP-program is preserved by the translation. We first give a formal description of the message passing model and then relate it in terms of bisimilarity to the SMC-presentation.

where for each node just one token handle is used. This substitution is described by the mapping T which we later on generalize to a relation between states of MP- and SMC-regions. As stated above, an MP-program will be related to their SMC- counterpart by weak bisimilarity. So far we have only considered so-called strong transitions opposed to weak transitions which are transitions preceded and followed by an arbitrary number of internal actions. In our setting internal actions are those concerning the administration of token handles, only. Let Act denote the set of all transition labels occurring in Section 1 and

By a tedious case analysis which is outlined in the next section one can establish the preorder result for a MP-program and its representation as an SMC-program. As, finally, our aim is to prove that the SMC-program is more cost-efficient than the original MP-program, and the efficiency preorder suggests the opposite result, we do not phrase it as a theorem. However, the following straightforward corollary shows the correctness of our translation.

The discussion in the previous section has shown that a comparison based on match- ing actions, only, does not capture the different performance of systems but rather suggests a relation which on intuitive grounds one would reject. However, if one assigns costs to actions and matches actions while keeping track of the current cost balance, the quantitative performance can also be observed. To this end, amortised bisimilarity has been introduced in [7]. In short, it combines bisimilarity with an quantitative cost evaluation.

shared messaging communication without loosing functional correctness but with higher efficiency if the volume of data transferred is high. SMC may be seen as a mechanism efficiently implementing message-passing for high data-rate applications and as such it goes in line with e.g. FLASH architecture [3], ARACHNE protocol [4] or efficient implementations of value passing languages [5]. However, SMC provides a new communication model transperant to the programmer and this supports portability and reusability of software within a certain class of micro-architectures.

