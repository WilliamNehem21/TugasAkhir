The purpose of the paper is to present our approach for specifying system behavior during analysis, part of the Fondue software development method. The approach is exemplified on a case study, a Drink Vending Machine (DVM). It is based on Operation Schemas and a Protocol Model. The Protocol Model describes the temporal ordering of the system operations by an UML protocol statemachine. An Operation Schema describes the functionality of a system operation by pre- and postconditions; they are written in the Object Constraint Language (OCL), with a few amendments and extensions.

The Concept Model, a special-purpose class model, is used to describe all the concepts and relationships part of the system, and all actors that are present in the environment. Therefore, the class model as we define it here is not a design class model. Classes and associations model concepts of the problem domain, not software components. Objects and association links hold the system state. Classes do not have behavior; the decision to allocate operations or methods to classes is deferred until design.

Both the Operation Model and the Protocol Model are refined from Use Cases and they combine to define a precise specification of system behavior, the Be- havior Model. An approach for mapping Use Cases to Operation Schemas has been proposed in [11]. To see how this work fits into a software development analysis activity, the reader is referred to [10].

The use of the Fondue method for specifying a system will be showcased on a Drink Vending Machine. This machine corresponds to a typical, but simple, reactive system. It is composed by a controller, whose software has to be developed, and several peripheral hardware devices. These devices interact with the software system by exchanging asynchronous messages. Ordering constraints for the messages are specified by the Protocol Model, whereas the effect of receiving a message is specified by an Operation Schema.

The money box is composed of two different collectors of coins: the first one keeps coins until the consumer presses the eject button or chooses a drink; in the latter case the coins are released by the first collector to the second one. Drinks are stored on shelves. Each shelf is associated with a beverage kind and a price. The service person adds drinks to the shelves. Initially, there are

The DVM does not have a clever money system. One might e.g. suppose that it accepts only one kind of coins, e.g. quarters, and that all prices are multiples of the value of that coin, e.g. 25 cents. Also, it is then easy to return coins that are too many compared with the price.

The Environment Model identifies all messages the system sends to and receives from the environment. The environment is modeled by actors. Note, that Fondue allows (in opposite to official UML) actors to be decorated by a star (PhysicalShelf, ShelfSelectBtn). This indicates that more than one in- stance of the actor can interact with the system.

The component class Shelf is a logical representation of the component PhysicalShelf and has two attributes with obvious meanings. The two as- sociations between PhysicalShelf, ShelfSelectBtn, and Shelf and the chosen multiplicities ensure that every ShelfSelectBtn belongs to exactly one Physi- calShelf. The id stereotype means that the system can identify an actor starting from an object belonging to the system, e.g., given a shelf s, we can find its corresponding physical shelf, denoted in OCL by s.physicalShelf. The reason for the  id  stereotyped association is that the system can only send a message to an actor that can be identified. Identifying an external actor form inside the system will be the only use of  id  stereotyped associations.

The Protocol Model defines the temporal ordering of system operations. Each input message for the DVM from the environment refers to an asyn- chronous operation invocation and the corresponding event. The message, the event, and the invoked system operation have usually the same name.

A Protocol Model is described with a UML statechart which has no guards. As usual, a transition in the Protocol Model is triggered by an input event only if the system is in a state to dispatch it, i.e., there exists an arc with the name of the input event. If not, the input event is ignored. A transition from one state to another leads to the execution of the system operation with the same name as the input event.

The state Ready is left once the event insertMoney is dispatched. The target state is CollectingMoney. Further coins can be inserted into the first collector due to the self-transition from CollectingMoney to CollectingMoney triggered by event insertMoney. Note that once it is full the first collector will reject additional coins automatically without sending an insertMoney message

Dispatching the event ejectMoney in state CollectingMoney causes a tran- sition to Ready. After dispatching the event selectDrink in state Collecting- Money the triggered transition is nondeterministic. The controller can change its state to Ready or can remain in the state CollectingMoney, depending on the amount of inserted money and the availability of drinks. Nondeterministic state changes are permitted in Protocol Models because the nondeterminism usually disappears once the operation behavior is taken into account.

In state Ready the event isEmpty as well as boxIsFull can be dispatched causing a state transition to Ready and OutOfOrder, respectively. The two events isReplenished and setPriceOfShelf cause a self-transition when dis- patched in state Ready or OutOfOrder. The event boxIsNotFull is ignored in state Ready. It causes a state transition to Ready when dispatched in state OutOfOrder.

The messages isEmpty and boxIsFull are sent once it is detected that a shelf is empty or the money box (second collector) has exceeded its capacity. For the correct working of the DVM it is necessary to assume that all other messages which are sent later are also processed later. However, this cannot be guaranteed if the current semantics of UML statecharts is assumed.

Not all aspects of the system behavior are expressed in the Protocol Model so far, e.g. we would like to specify that by inserting money into the first collector the money display is updated as well. Fortunately, the missing information can be expressed in an elegant form by OCL constraints.

Most of the operations produce output messages which are sent to actors. Thus, the specification takes advantage of the message construct recently in- corporated into OCL. The expression receiver^message can only occur in the postcondition of an operation and indicates that during the execution of the operation the message message has been sent to the object receiver. For a detailed account see [8, Section 2.7].

Another peculiarity of our specification is the usage of the keyword sender. This keyword is not part of the OCL standard but has proven to be extremely useful in our specification. The keyword sender refers to that actor which has invoked the operation. Recall, that every operation in Fondue is only invoked after a message with the same name was dispatched. The keyword

In the postcondition of operation selectDrink() the attribute collecting- Money is set in order to indicate whether the DVM remains in state Col- lectingMoney or takes the transition to state Ready. This resolves the non- determinism in the Protocol Model mentioned in Section 6. Unfortunately, the specification has to keep track of the value of collectingMoney in all op- erations which can enter or exit state CollectingMoney, i.e. the postcondition of insertMoney and ejectMoney has to set collectingMoney as well. This is rather clumsy since the post-state value is already known from the Protocol Model.

oclInState If the OCL specification needs information about the current Pro- tocol Model state, there are basically two possibilities. One can either in- troduce a new attribute encoding the state, or one can use the construct oclInState, which was incorporated into OCL recently (for a discussion of its semantics the reader is referred to [4]). We discussed both solutions in our case study and pointed out their advantages and disadvantages.

sender In the analysis phase of Fondue, operations are always system oper- ations, which can be invoked only after a corresponding input event has been dispatched. Sometimes, we have to know the sender of the mes- sage, for instance when an internal data structure (e.g. shelf ) representing the state of the sending actor (e.g. PhysicalShelf ) has to be updated (e.g. sender.shelf.isEmpty = true).

