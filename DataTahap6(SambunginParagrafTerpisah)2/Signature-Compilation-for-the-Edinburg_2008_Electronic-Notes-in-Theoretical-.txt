The intended use of sc is for generating backend checkers, which are optimized for the case when the proof successfully checks. Thus, sc does not report useful error information for failed proofs. Also, backend checkers allow (untrusted) proofs to contain additional definitions, but not additional declarations, which might subvert the deductive system defined by the (trusted) signature. The ideal case for use of sc is when many proofs expressed with respect to the same signature need to be checked efficiently. In such a case, reuse of the custom checker generated by sc makes up for the time needed for signature compilation.

The Signature Compiler inlines the code needed to compute the type of an ap- plication of a constant declared or defined in the signature. The expected types of arguments are hard-coded into the emitted checkers, and the substitutions which must normally be performed at run-time to compute the return type of an ap- plication of a dependently typed function are performed instead during signature compilation. The emitted checkers thus completely avoid the expensive operation of substitution when computing the return type of an application of a constant declared or defined in the signature.

ted checkers over Twelf and sc itself, and substantial improvements over the flea checker. A form of implicit arguments is supported by sc, offering further space and performance improvements. Future work includes further support for proofs from decision procedures: the second author is proposing LF, backed by the Signature Compiler, as appropriate technology for a standard proof format for the SMT-LIB (Satisfiability Modulo Theories Library) initiative.

