In recent years, attribute grammar systems have focused on dynamically sched- uled evaluation, where the attributes to be evaluated and the evaluation order are determined at run-time rather than at generation time [14]. LRC [23], JastAdd [11], UU AG [2], and Silver [25] are prominent examples of this approach. A dynamic schedule has the advantage that attributes are evaluated at most once, but adds runtime overhead. In applications such as integrated development environments, the tradeoff is particularly worthwhile, since not all attributes are needed at all times.

Nevertheless, these recent systems are based on generators that add to the learn- ing curve and complicate the development and build processes. We show in this paper how to integrate a dynamically scheduled attribute grammar approach as a library into an existing modern, object-oriented language. We use a pure embedding where the syntax, concepts, expressiveness and libraries of the base language are used directly [12,18]. The high-level declarative nature of the attribute grammar formalism is retained and augmented with the flexibility and familiarity of the base language, both for specification and for implementation of the formalism itself.

Kiama implementation is outlined in Section 3. Section 4 considers how language extension and separation of concerns can be achieved by leveraging the general Scala platform. We evaluate the performance of Kiama in Section 5. The paper concludes with a discussion of our approach in the context of other attribute grammar systems in Section 6 and concluding remarks in Section 7.

Repmin is a classic problem of tree analysis and transformation, originally employed to illustrate the use of lazy circular programs in functional programming to eliminate multiple tree traversals [3]. Repmin is often used as a simple test of attribute grammar systems. The problem is to take a binary tree with integer leaves and transform it into a tree with the same structure, but with each leaf value replaced by the minimum leaf value of the original tree.

Other kinds of attributes are defined by similar classes with the same inter- face. For example, uncached attributes are a simple variant. circular uses a CircularAttribute class that provides a functional interface to the fixed-point evaluation algorithms of Magnusson and Hedin [16].

Flexible static combination of attribution modules can be achieved using Scala traits to define components and performing mixin composition to combine them [21]. For example, we can decompose the variable liveness problem of Section 2.2 into three components dealing with control flow, variables, and the liveness computation itself. The first two of these can be abstracted by interfaces defined by traits.

We evaluate the performance of attribute evaluation in Kiama by a comparison to a handwritten Scala implementation and to a generated Java attribute evaluator. For the former, we specify attributes as regular methods in the AST classes, and perform caching by hand, at a cost of modularity and boilerplate code. For the latter, we compare to JastAdd, which, like Kiama, uses the Java platform and supports reference and circular attributes [11]. JastAdd has been successfully used to implement a full-featured Java 1.5 compiler that offers performance that can compete with handwritten implementations [9].

As a test case, we use the JastAdd example PicoJava specification from [27], which has 18 abstract syntax productions and 10 attributes to perform name and type analysis. We tested evaluation performance for relatively large, generated input programs. Since PicoJava only supports class definitions and not methods, our input classes contain 150 nested class definitions.

This section briefly compares the approach taken to develop the Kiama attribution library with generator-based systems that feature a dynamic evaluation approach. We are not aware of another attribute grammar system that uses pure embedding. In many ways, Kiama has been inspired by the JastAdd [11] system and the features provided are similar. JastAdd provides an object-oriented variation of attribute grammars, supporting inheritance in their definition and references as attribute values [11]. Like JastAdd, Kiama is based on the Java platform, but

One advantage of a generator-based approach is the ability to check the attribute grammar for correctness at generation time. For example, completeness and well- formedness checks [7] give confidence that the generated evaluator is not incomplete. In Kiama, precise checking of this kind is not always possible, particularly if syntax extensibility is desired. A Scala case class can be marked sealed which means that it cannot be extended outside the current module. When compiling a pattern match against a sealed class, the Scala compiler can emit warnings if the patterns are not complete, giving Kiama a form of completeness checking.

Dynamically-scheduled attribute grammars are a powerful language processing paradigm that has been the focus of many generator-based implementations. In most cases, a general purpose language is used to express attribute computations. The Kiama attribution library removes the generation step by using Scala to write the whole attribute grammar. The resulting system is lightweight and easy to un- derstand, yet capable of competing in expressivity and performance with JastAdd, a mature generator-based system which uses a similar evaluation method.

