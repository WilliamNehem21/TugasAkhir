Predicting defect-prone software components can play a significant role in allocating relevant testing resources to fault-prone modules and hence increasing the business value of software projects. Most of the current software defect prediction studies utilize traditional supervised machine learning algorithms to predict defects in software applications. The software datasets utilized in such studies are imbalanced and therefore the reported results cannot be reliably used to judge their performance. Moreover, it is important to explain the output of machine learning models employed in fault-predication techniques to determine the contribution of each utilized feature to the model output. In this paper, we propose a new framework for predicting software defects utilizing eleven machine learning classifiers over twelve different datasets. For feature selection, we employ four different nature-inspired search algorithms, namely, particle swarm optimization, genetic algorithm, harmony algorithm, and ant colony optimization. Moreover, we make use of the synthetic minority oversampling technique (SMOTE) to address the problem of data imbalance. Furthermore, we utilize the Shapley additive explanation model for highlighting the highest determinative features. The obtained results demonstrate that gradient boosting, sto- chastic gradient boosting, decision trees, and categorical boosting outperform others tested model with over 90% accuracy and ROC-AUC. Additionally, we found that the ant colony optimization technique outperforms the other tested feature extraction techniques.

The rest of the paper is structured as follows: section 2 showcases a variety of related studies conducted in the field. Section 3 illustrates the proposed software defects prediction framework, used datasets, feature selection approaches, and employed classifiers. Section 4 shows the used evaluation metrics and hyperparameters tuning process. Section 5 dis- cusses the experimental results and shows classifiers output explana- tions using SHAP. Finally, the conclusion and future directions are shown in section 6.

Many experimental, investigational, empirical, and comparative research approaches have recently been proposed in the domain of software defect prediction. In [7] using seven datasets obtained from the National Aeronautics and Space Administration, six machine learning classifiers were tested: logistic regression, random forest, naive Bayes, gradient boosting, support vector machine, and neural networks. Moreover, the results showed that neural networks offer the greatest results with an accuracy of 93% while utilizing 10 folds cross-validation. In [20] deep learning and bio-inspired feature selection methods are being used. Particle swarm optimization (PSO) was used to evaluate neural network performance by reducing strongly correlated features. In addition, four NASA datasets were gathered and preprocessed with

Using a firefly search-based algorithm (FA) for feature selection [23]. Three machine learning classifiers were used to evaluate the utility of FA for selecting the best features and enhancing model performance: sup- port vector machine, Naive Bayes, and k-nearest neighbors. When compared to the original findings, the support vector machine resulted in the best results and improved accuracy by 4.53%. The study in [24] proposed a new method comprising the use of several deep learning approaches for software defects prediction utilizing the genetic algo- rithm (GA) for features selection and particle swarm optimization (PSO) for data clustering. Moreover, five NASA datasets were collected and cleaned from missing values. The results revealed that deep neural networks outperform others with an accuracy of 98.47% using 10 folds cross-validation.

Several research recommends combining numerous feature ap- proaches into a single list rather than using individuals. In [25] Intro- duced a novel method to handle the problem of high dimensionality data and filter method ranking in software defect prediction by combining various feature filter methods: Chi-square, information gain, and relief. The suggested method compares the outcomes by assessing the effec- tiveness of decision trees (DT) and Naive Bayes (NB). In addition, nine NASA datasets were used and sanitized. The findings show that the suggested method outperforms the employment of individual methods, with NB accuracy increasing by 6.73% and DT increasing by 1.87%.

also obtained and preprocessed. However, for minimizing highly correlated features, a greedy search-based algorithm was used. The findings of the ensemble learning techniques indicated that boosted SMO yields the best results when compared to others, with an accuracy of 88.2%, and voting produces an accuracy of 87.9%.

Imbalanced data, also known as imbalanced target classes, is a data distribution problem that causes machine learning classifiers to be biased toward one category over others, negatively affecting prediction [32]. NASA datasets, on the other hand, exhibit a wide distribution gap across target classes. As a result, this study is based on the employment of SMOTE for data balance. SMOTE is an oversampling technique that generates synthetic data samples to increase minority class data samples by locating the nearest K - neighbors, computing the distance between them then multiplying a random value between 0 and 1 for the new sample [33].

referred to as a particle and a group of birds is referred to as a swarm (i. e., population). The core notion of PSO is that each particle represents the best solution to the problem. However, following the random initialization, the location of each particle is modified, resulting in new

KNN [41] is a distance-based method that determines the distance between training and test samples. KNN classifier is a sluggish algorithm since it learns during the evaluation phase and saves data samples during the learning stage. Without standing, the KNN passes through many phases. Begin by determining the value of K (number of nearest samples), then calculate the distance between the training samples and the new data sample using a distance function. Furthermore, the dis- tance values will be sorted and the nearest samples identified based on the value of K, and the prediction value will be determined based on the majority of the class values.

RF [43] is a bagging ensemble-based classifier. As the basic learners, it divides the training data into several decision trees. RF is also a non- parametric model. However, a restricted random number of rows is chosen from the data population, and a set of decision trees is built for each segment to generate classification output. An individual decision tree might be bigger than others. A majority vote in RF indicates a meta- classifier, which is a classification decision made based on the judgments of the basic learners. It supports numeric and categorical data types, as well as complicated predictor functions.

XGBoost [50] is an ensemble method based on boosting. It is a more advanced version of gradient boosting. It was also created for large and intricate datasets. Unlike adaptive and gradient boosting, the XGBoost employs unique regression trees. Forming what is known as born-again trees. XGBoost tree formation, on the other hand, begins with a single leaf, much like gradient boosting. Furthermore, gradient boosting and regularization are critical steps in XGBoost. For many years, XGBoost has been one of the most effective boosting methods. In their experi- mental investigation, Ismail and Faisal [51] demonstrated that XGBoost outperforms other classifiers such as RF, SVM, radial basis function neural network, and naive Bayes. It is simple to use and provides a high level of discriminative prediction accuracy. In addition to its ability to

The findings of the proposed classifiers for predicting software de- fects are discussed in this section. SMOTE was utilized for data balance after data preprocessing. Four Meta heuristics methods, on the other hand, were tuned and used for feature selection. We employ the logistic map function as a chaotic type and 20 initial particles with 20 iterations in ACO. We utilized a population size of 20 with 20 iterations in PSO. In GA, we employed a crossover probability of 6% with a maximum gen- eration of 20. In addition, we employed the logistic map function in HA with 20 iterations and population size.

KC1 datasets before and after using meta-heuristic feature selection al- gorithms. The testing accuracy average, on the other hand, was computed to highlight the comparison of outcomes. Overall, the results showed an improvement in testing accuracy. GB, SGB, and CatBoost, on the other hand, outperform the others. This is not surprising given that boosting methods enhance variance while decreasing bias. In addition, by expanding minority class samples, SMOTE increases the number of data samples.

comments have the strongest impact in Cat Boost at the 10th observa- tion, at 25.17, relative to the base value of 0.6, however, the design complexity metric has a negative impact. Overall, it can be notated that lines of code comments, design density, and Halsted content metrics have the highest discriminative power to the predictive models.

However, the MC1 dataset is regarded to be one of the largest NASA datasets, with a total of 9277 occurrences, and we were able to retain the same accuracy by applying the GA algorithm due to the broad data dispersion over training and testing sets. The findings of the MC2 dataset revealed that six classifiers, including DT, KNN, GB, SGB, AdaBoost, and RF, out of eleven, had the best accuracy by comparison. Additionally, SMOTE and PSO yield the best outcomes, with an average accuracy of 99%.

The plots show the contributions of 35 data samples. The x-axis in global force reflects the number of data samples, while the y-axis shows SHAP predicted values. In addition, we employ a bee swarm plot to emphasize the features with the highest discriminative power. For clarity, the most significant features of overall classifiers are call pairs, global data density, and essential density metrics.

