We strongly believe that declarative languages such as Logic Programming (LP) [9], if integrated with the web, will play a crucial role as computational paradigms in the Semantic Web vision, as noted, e.g., in [15]. Also abduction [14], as it is a

We could specify a number of rules which any web site for shows should fulfill. For example, we could specify that the right structure of a show tag must admit a showname tag element and a year tag element as its children. In the example, we would have a structural error, due to the lack of a year tag element in the second show. Moreover we could specify that showlist must contain only those shows produced since the year 2000. In this case we would have a data error due to the first show being produced in 1998.

In this section we briefly present the checking capabilities of CIFFWEB, fully ad- dressed in [13,14]. We start with some background notions about web rules and abductive logic programming with constraints. Then we give a very brief descrip- tion of the translation process from web checking rules to abductive logic programs for checking (programs for checking for short) and finally we show a CIFFWEB run on the theater example.

is exactly how positive rules are mapped into abductive logic programs. The head of I is composed of an abducible predicate abd err/2 whose arguments are (1) the variable list occurring in the error part of the rule and (2) the error message. The body of I instead, is composed of the conjunction of the components occurring in the condition part of the rule, represented as appropriate pg el and data el atoms. The translation of Rule1 is the following 5 :

In order to run the CIFFWEB system 6 the web rules in Xcerpt syntax and the XML/XHTML pages are needed. The query is always the empty query (also for repair). The system will compile all the rules and the sources, producing the corre- sponding program for checking. Running the system with the three rules and the XML page seen above, the following abductive answer is produced: ing rules and errors arising from missing data: negative rules lead to errors of that type (we denote those errors as negative errors and each error drawn from a pos- itive rule as a positive error ). This is very intuitive because the without and the without data statements express the absence of information. For example, each error arising from the negative rule Rule2 seen before, represents the absence of a year tag as a child of a show. The idea is that an abductive answer could suggest to insert such a year tag in the XML data. We leave the repair of other error types as future work.

In a program for repairing there is a last issue to cope with: the identifiers of the abduced XML elements. As seen in Section 3.3, each element in the original XML data is associated to a unique numerical identifier and these identifiers maintain the original XML tree structure. When a XML element is abduced a unique identifier should be assigned to it in a similar way. Obviously, for each pair of abduced XML elements, their identifiers should be distinct and each newly generated identifier should be distinct from each identifier of the original XML elements. This can be done by adding, in a program for repairing, a set of integrity constraints of the form:

Then if the Year variable (in the example the X), is constrained to be less than 2000 a new error is abduced too. This is general issue and we argue, that, usually, it might be preferable to avoid that abduced XML elements introduce new errors satisfying the bodies of the positive web checking rules. A way to avoid this is imposing that an instance of an integrity constraint obtained from a positive rule leads to a failure in the abductive process if its body is satisfied through (at least) an abduced atom. I.e. we could replace the abductive errors in the head of the integrity constraint by false. In this way, if an abduced atom leads to a new error, then the abductive process fails searching for an alternative abductive answer.

where each abd i represents the abducible version of the correspondent el i atom. It is worth noticing that among the 2m integrity constraints, only one of them does not contain abducibles in its body. For simplicity we say that this integrity constraint is I1. If we want to avoid that the abduced atoms could not generate new errors we simply need to replace abd err by false in each integrity constraint other than I1. Adopting this solution, the latter abductive answer would not be returned by the system, because constraining X to a value less than 2000 would lead immediately to failure (since CIFF never computes answers containing false).

part of a rule allows for a bit more expressiveness. Another key difference is that the GVERDI-R system relies upon an ad-hoc computational counterpart for its framework, while our system relies upon the general purpose CIFF abductive proof procedure. Conversely, the GVERDI-R system allows for the use of functions for managing strings and data in a non-straightforward way, e.g. by matching strings to regular expressions or using arithmetic functions on numbers. While the CIF- FWEB system deals with arithmetic functions thanks to the underlying integrated constraint solver, it lacks the use of other types of functions. As pointed out in [1], this is an important feature for a web verification tool. A more sophisticated use of functions in CIFFWEB is work in progress.

Another interesting approach of modifying web data instances is represented by the XChange framework [5] which is proposed by the same Xcerpt authors and form which it derives. It proposes a framework to make the web data aware of events which should lead to changes in the web data. We are currently studying possible interrelations with our repair approach even if the Xchange framework is not focused to verify and to repair web site instances but rather it seems to propose new data paradigms which can accommodate event-driven changes.

