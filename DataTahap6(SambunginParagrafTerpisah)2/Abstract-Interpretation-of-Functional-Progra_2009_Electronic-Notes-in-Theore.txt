We describe an algorithm for abstract interpretation of an intermediate language in a Haskell compiler, itself also written in Haskell. It computes approximations of possible values for all variables in the program, which can be used for optimizing the object code. The analysis is done by collecting constraints on variables, which are then solved by fixpoint iteration. The set of constraints grows while solving, as possible values of unknown functions become known. The constraints are collected by decorating the abstract syntax tree with an attribute grammar based preprocessor for Haskell. An introduction to this preprocessor is also given.

In a naive implementation, the function reference can be a tag, and a special evaluation function performs case distinction on this tag. Peyton Jones et al. describe an encoding, where the tag is actually a pointer to the code of the function [13,11]. Evaluating a closure now amounts to just calling that code. On modern pipelined processors, this is a costly operation, as it stalls the prefetching pipeline. Therefore, Boquist proposes to return to the naive encoding [3]. To avoid the overhead of calling the evaluation function which

To do the pruning it is necessary to know for each closure what its possible tags are. This is to be determined by a global control flow analysis. Boquist sketches an algorithm for this abstract interpretation [4]. Here we present a full implementation we employ in our experimental Haskell compiler [6](a few left out details can be found in an accompanying technical report [8]).

The implementation is presented by giving the actual code. We use a pre- processor for Haskell that enables us to use notions derived from the realm of attribute grammars [9]. This makes the code concise enough to present it (almost) in full. To make the paper self-contained, we include a description of this preprocessor as well. The aim of this paper is twofold:

We describe the main features of the preprocessor here, and explain why they overcome the five problems mentioned above. The abstract syntax of the language is defined in a syntax declaration, which is like a Haskell data declaration with named fields, without the braces and commas (see section 3 for an example). Constructor function names need not to be unique between types. The preprocessor generates corresponding data declarations (making the constructors unique by prepending the type name, like Expr Const ), and generates a custom fold function. This overcomes problem 1.

In many situations, sem rules only specify that attributes a tree node inherites should be passed unchanged to its children. To scrap the boilerplate expressing this, the preprocessor has a convention that, unless stated otherwise, attributes with the same name are automatically copied. A similar automated copying is done for synthesized attributes passed up the tree. When more than one child offers a candidate to be copied, normally the rightmost one is taken, unless we specify to use an operator to combine several candidates:

We describe a slightly modified version here by means of syntax declarations for the AG preprocessor. We do not provide a concrete syntax for the language, as Grin programs are only an intermediate representation. We start with a definition of toplevel constructs. A program consists of a name, and a list of function bindings. Each binding binds a parameterized name to an expression.

Grin programs manipulate five kinds of values: integers, standalone tags, nodes with a known tag and a list of fields, pointers to a node stored on the heap, and the empty value. The first three have a direct syntactic repre- sentation as a Term, pointers and the empty value have not. Another possible Term is a variable, which can refer to any of the five kinds of value.

Two constructs have a side effect on the heap: Store, which stores a node value in a new heap cell and returns a pointer to it, and FetchUpdate, which copies the contents of a heap location to another location, and returns the empty value. Next, we have Call for calling a Grin function. Boquist proposes the use of two builtin functions eval and apply , which can be called to force evaluation of a variable, or to apply an unknown function in a strict context, respectively. As these functions behave quite different from ordinary functions, we include special constructs Eval and Apply for these cases.

In this section we describe an abstract interpretation algorithm, which solves a set of constraints by fixpoint iteration. Constraints are first collected in a walk over the tree that represents the Grin program. We start with a description of an abstract domain, and a language for specifying the constraints.

In the AbsTags case, abstract interpretation reveals to which tags a variable can possibly refer. Similarly, for AbsLocs we determine to which locations a pointer can point. In the AbsNodes case, we not only determine the possible tags of the nodes, but for each of these also a list of the abstract values of their parameters. As for concrete values, the elements of the fields of a node are never AbsNodes themselves, but can be AbsLocs pointing to locations which store inner nodes.

In the case of a Unit we distinguish the four combinations of target pattern and source term (each variable or node). When both are variables, the target is constrained to hold a superset of the source; when the target is a variable and the source is a node, the target can hold that node. If the target is a node and the source is a variable, all the fields of the node should be projections of the source variable. When both are nodes, their corresponding fields should be unified. For the last two cases we have auxiliary functions:

An alternative approach to collect information on a syntax tree is using ASF [5]. In comparison, the AG approach is lightweight, in that it relies on the underlying language for the definition of semantic rules. Yet another approach would be to provide combinators that manipulate attributes within the lan- guage, instead of as a preprocessor [12].

The information revealed by the abstract interpretation is detailed enough to do the intended inlining of Eval and Apply expressions. Ultimately we strive to replace indirect jumps by a resonable number of direct branches. This depends on more optimizing transformations in the compilation pipeline which we have not yet implemented all, so we can not yet be decisive whether the optimizations have the desired effect.

