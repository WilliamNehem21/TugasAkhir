Multi-adjoint logic programming [11,12,13] is an extremely flexible framework com- bining fuzzy logic and logic programming. Informally speaking, a multi-adjoint logic program can be seen as a set of rules each of which is annotated by a truth degree (a value of a complete lattice, for instance the real interval [0, 1]) and a query to the sys- tem, that is, a goal plus a substitution (initially the identity substitution, denoted by id). Given a multi-adjoint logic program, goals are evaluated in two separate computational phases. During the operational phase, admissible steps (a general- ization of the classical modus ponens inference rule) are systematically applied by a backward reasoning procedure in a similar way to classical resolution steps in pure logic programming. More precisely, in an admissible step, for a selected atom A in to save some computations, at execution time, that were done only once at PE time. To fulfill this goal, PE uses symbolic computation as well as some techniques provided by the field of program transformation [1], specially the so called unfolding transformation. Unfolding is essentially the replacement of a call by its definition, with appropriate substitutions.

As we want to support the computation of reductants by means of PE techniques, in [7] we have introduced a preliminary definition of the concept of PE for multi- adjoint logic programs and goals. The idea is to adapt, for this new framework, the techniques arisen around the field of partial deduction of pure logic programs [3,8,10]. Following this path, we try to unfold admissible goals, as much as possible, using the notion of unfolding rule developed in [5,6] for multi-adjoint logic programs, in order to obtain an optimized (specialized) version of the original program.

We can optimize the construction of PE-reductants if we use an adaptation of the notion of unfolding tree (Definition 2.5) where: i) nodes contain information about an upper bound of the truth degree associated to the goal component; and ii) a set of threshold values is set dynamically to limit the generation of useless nodes. This last feature provides great opportunities to reduce the unfolding tree shape, by stopping unfolding of those nodes whose truth degree upper bound component falls down a threshold value V.

As for a classical proof procedure, three points are important: the computation rule (that is, the selection function used to decide which atom must be exploited in the next computation step 4 ); the order rule (i.e., the order in which the rules of the program are tried for unfolding) and the search strategy (either a breadth-first or a depth-first). The algorithm we present is parametric with regard all these points, as well as a stop criterion to ensure termination ofunfolding 5 .

Observe that the list LEAVES can be accessed either as a LIFO (stack) or a FIFO (queue) structure, which respectively corresponds with a depth-first or breadth-first generation/ traversal of the underlying tree. The experience shows us that there are not advantages (with regard the elimination of useless nodes) when choosing either a breadth-first or a depth first strategy. We have examples where the breadth-first strategy has a better performance in comparison with the depth first strategy and vice-versa. Also there is not any evidence indicating if a concrete computation rule can improve the elimination of useless nodes. However, the order rule has a mayor impact in the removal of useless nodes. We saw that an order rule which reorders

Our last example illustrates the benefits achieved by our threshold-based technique for computing PE-reductants when it is compared with Definitions 3.1 and 3.2. Firstly, we are interested in evidencing that the original program is not able to com- pute a concrete correct answer. Secondly, we focus our attention in the comparison of the computational effort needed to compute and execute different forms of PE- reductants, as well as their own shapes, which highlights the main advantages of our algorithm.

Reductants are crucial to cope with completeness in multi-adjoint logic program- ming. In this paper we have defined a method for computing the so called PE- reductants by using partial evaluation techniques based on unfolding with a set of dynamic thresholds. Moreover, we have discussed the benefits of our technique by means of several comparative examples, referring to the gains in efficiency achieved not only when constructing the proper PE-reductant, but also when using it at ex- ecution time. Nowadays we are working in the formulation of the set of properties fulfilled by our improved definition of reductant.

