Design patterns are not only beneficial to the forward engineering process but also help in design recovery and program understanding, typical reverse engineering activities. In this paper, we introduce DPVK, a reverse engineering tool to detect pattern instances in Eiffel systems. In order to get better detection results, we analyze many different patterns and examine Eiffel software in terms of both static structure and dynamic behaviour. DPVK is implemented as an Eclipse plug-in to ensure better compatibility and extensibility.

A typical system structure for pattern detection tools includes three parts: a parser, a detector, and a database. The parser extracts facts from the implementation. Then, the detector retrieves pattern definitions from the database, compares these definitions with the facts, and outputs the detection result. The database can also be used to store detected pattern instances for further analysis.

eliminate most false positives of pattern instances. Many recently developed tools use multiple passes[18], or recursive filtering[10], to improve the detection output. Meanwhile, both static structure and dynamic interaction[5] have been taken into account in order to increase the hit rate and reduce the missing rate of true pattern instances.

KT[1]: KT is a tool that can reverse-engineer design diagrams from Smalltalk code and use this information to detect patterns. The author of KT advocates that any tool designed to detect the artifact of design patterns must support both static and dynamic modelling constructs. In terms of diagram, static information includes is-kind-of and has-a rela- tionship and dynamic information includes object interaction or message flow. Three GOF design patterns are analyzed: Composite, Decorator and Chain of Responsibility. The methods used for the detection of these patterns are coded directly into the KT source code.

environment has a three tier architecture. From bottom to top, they are object-oriented database, repository schema and end-user tools. The lowest tier provides physical storage of the reverse engineering model and design information. The middle tier contains the object-oriented schema of the reverse engineering model, comprising static structure and dy- namic behaviour. The upper-tier consists of end-user tools implementing domain specific functions, such as source code capturing and visualization analysis.

Heuzeroth-Holl-Hogstrom-Lowe[5]: The authors present a way to auto- matically detect patterns by combining both static and dynamic analysis. The former restricts the code construction and the latter the runtime be- haviour. This analysis does not depend on coding or naming convention. A pattern instance is defined by a tuple of program elements such as classes, methods or attributes. These elements must conform to the rules of a certain design pattern.

First, source code is processed by static analysis which transforms the implementation into tuples of AST(Abstract Syntax Tree) nodes. Then, static analysis computes predefined pattern relationships on the AST nodes and generates the candidate set of pattern instances. The dynamic analysis takes this set as its input. It monitors the execution of the nodes of every tuple. It also tracks the output of the executed nodes to check whether the candidate complies with dynamic pattern rules. The candidate is eliminated if the rule is violated. Finally, the remaining candidate set contains the detected pattern instances.

protocol conformance of patterns. So far the tool can detect Observer, Composite, Mediator, Chain of Responsibility and Visitor Patterns. Ac- cording to [5], when the tool is applied on Java SwingSet Example and the tool itself, the number of false positives is small, in most experiments even zero.

Classes in each design pattern interact in a precise manner and each class is expected to show proper behaviour. Eiffel provides a mechanism, namely, Design by Contract[16], to define such mutual obligations and benefits among classes. Design by Contract has a sound theoretical basis, and it provides a guideline for constructing robust designs. It lets developers precisely specify the obligations and explicitly assign the responsibilities of clients and suppli- ers. In the language level, assertions, precondition and postcondition clauses, are used to define contracts between clients and suppliers. Moreover, class invariants enable the definition of general consistency properties within each class. A failure to comply with the contract indicates a bug. This can help developers discover and deal with such design bugs.

[20] is a notation for analysis and design of object-oriented systems, which emphasizes seamlessness, reversibility and software contracting. There are two major reasons we chose BON for our work. First, BON is integrated with EiffelStudio. EiffelCase, an integrated tool of EiffelStudio directly interfaces with the other tools of the ISE environment and supports generation of new system architectures as well as reverse engineering of existing ones. Second, BON has similar function with UML while the former is easier to learn and use. BON is based on concepts similar to those of Eiffel but can be used independently of Eiffel.

In order to get a better understanding of GOF patterns and to detect them in Eiffel source code, we analyzed both their static structure and dynamic be- haviour. As a by-product, a diagram catalogue of GOF patterns is compiled[22]. In this catalogue, each design pattern is analyzed and presented from both static and dynamic perspective. The static diagram illustrates the pattern structure, especially the inheritance and invocation relationships between com-

Reverse engineering tasks are commonly done by means of text-based search tools such as grep, sed, or awk, or by querying graph representations of source code, such as an ASG (Abstract Syntax Graph). Our implementation, DPVK, is an integrated text-search tool that detects design patterns in Eiffel pro- grams. DPVK is written in Java to gain better compatibility and portability for multiple operating systems and development environments, such as Eclipse.

Grok is a relational calculator that supports a scripting language. It was initially created by Ric Holt in 1995 in order to manipulate binary relations with the purpose of understanding large-scale software systems. It includes an interpreter that can be treated as a relational processor.

A key aspect of detecting a design pattern is how to model and define a design pattern precisely and how to express that definition. In DPVK, each design pattern has two definitions: one definition is based on the static structure of the pattern and the other is based on its dynamic behaviour. DPVK uses the special structure and behaviour to identify and pinpoint design patterns and differentiate a design pattern from another.

More specifically, DPVK compares these two definitions with the static and dynamic fact files of the target software system respectively. This approach is similar to the one used in [5]. Theoretically, if both static and dynamic defini- tions are complete and precise, all design patterns will be found and no false positives will be output. If we treat each definition as a set of conditions, then complete and precise definition means no redundant conditions are included and no necessary conditions are missing.

In the real world, a particular design pattern may be implemented as a number of different variants in a given system. Although each variant can still be illustrated and analyzed statically and dynamically in a similar way, to collect all possible variants of each design pattern would be an endless work as software systems evolve. Our solution is to create a design pattern definition repository which stores as many variant definitions as possible. It is clear that, the more complete the factbase, the better the chances we will find design patterns and their variants in software systems.

The static fact extraction navigates around the source file directory, scans and parses all .e files(Eiffel source code files). The output of this stage is static relationships between all classes. All relationships are expressed as a triple of the form (relationship, entity1, entity2 ). The relationships we include are inheritance (inherit class1 class2 ) and client-supplier (use ClientClass SupplierClass).

Static relationships are retrieved by using EC (Eiffel Compiler). EC is a command-line Eiffel compiler developed by ISE[9] (it is the same compiler EiffelStudio uses). The extraction module manages EC to traverse all .e files to collect static information, and consolidates the static information into static facts. Finally, it renders the collected static facts into RSF format to interface with Grok in stage two.

In this stage, we compose the definition of the static structure of each de- sign pattern we would like to detect. This definition is rendered as RSF and it defines the inheritance and invocation relationship among classes partici- pating in the design pattern. Using Grok, we compare the definition with the facts about static relationships derived in stage one.

Once a set of classes that fits the static definition is found, we record it as a candidate instance. Eventually, the output lists all combinations of classes that fits the design pattern static structure. The output may contain false positives, since the static structure of many design patterns contains a small number of nodes and edges in a combination that is likely to be found in software systems that do not contain the particular design pattern.

We also propose a reverse engineering tool called DPVK, which is used to detect/verify patterns in Eiffel systems. DPVK operates in four stages. The first three stages are static fact extraction, candidate instance discovery and false positive elimination. Finally, the fourth stage lets developers manually evaluate and justify the output of previous stages.

As stated earlier, an Eiffel Development Tool for Eclipse is under devel- opment in York University. Once it is ready, DPVK can use it to replace EiffelStudio and EC which are currently used to extract static and dynamic facts about the software system under examination. In the long run, DPVK will be extended to detect design patterns in other popular object-oriented language such as Java, C++ etc.

