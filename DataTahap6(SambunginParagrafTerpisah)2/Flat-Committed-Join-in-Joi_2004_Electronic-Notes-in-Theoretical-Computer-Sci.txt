Crucial points about the implementation of cJoin are: (1) the commit of interacting negotiations as a global decision, and (2) the number of parti- cipants and their identities are not known statically. We show that, for a significant fragment of cJoin, global decisions can be implemented in a fully distributed way by using the distributed two phase commit protocol (d2pc) proposed in [4] for implementing zero-safe nets [6] (a transactional extension of Petri nets). Note that the Join code written for the d2pc in the case of zero-safe nets can be imported and reused with minor modifications in the encoding of cJoin, giving evidence of its generality.

Although we show that Join is expressive enough to encode flat cJoin, i.e. that the new primitives for flat negotiations do not increase the expressivity of the language, we argue that the syntax of cJoin yields a separation of concerns that is difficult to achieve at the level of Join, thus cJoin facilitates programming and reasoning about distributed contracts. We conjecture that by further elaborating the encoding of flat processes one should be able to implement full cJoin in Join.

It is worth noting that these conditions match with the basic shapes of zs nets. By (Open), a reaction that creates a new negotiation consumes exactly one message and produces only one agent inside the new negotiation. Rule (Ord-Join) assures that a synchronization consumes two messages and produces exactly a new agent. Differently, rule (Merge-Join) allows to join several negotiations simultaneously. Moreover, a join cannot spawn directly a new negotiation (a task left to (Open)). Finally, rules (Ord-Mov) and (Merge-Mov) are instances of transitions calc, fork, and close (with drop as a particular case) of zs nets.

Note that S and B are updated when encoding a top-level process with local definitions, i.e. to S' and B' when defining def D in P )S,B. In this case, both D and P are encoded by taking into account dn(D). We use  to denote the union of disjoint sets. (Note that defined names can always be renamed with fresh ones.)

Finally, when a merge name x is defined more than once in a conjunction, redundant definitions for xk are introduced. However, redundant definitions do not change the behavior of a process. Additionally, merge definitions are useless when appearing inside negotiations, because no sub-negotiations exist that can be merged. Hence, we omit their translation (the special symbol T denotes this fact).

By Proposition 3.12, the encoding of zs nets in cJoin produces processes in canonical form, which can therefore be encoded in Join by exploiting the implementation described in Section 4. We conjecture that the resulting en- coding def D)cJ in P )cJ) is just a slightly redundant version of the direct translation in [4], but we leave as future work to spell out the formal details and proofs.

