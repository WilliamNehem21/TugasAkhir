We have used the meta-modelling tool AToM3 [7] for the implementation of these ideas. AToM3 was built in collaboration with Hans Vangheluwe from McGill University in Montreal. The tool allows describing the syntax of Visual Languages by means of meta-modelling, and define and execute graph trans- formation rules. From these high-level descriptions, customized modelling environments are automatically generated. We have created a modelling envi- ronment for DEGs and extended it with a code generator that produces stand alone applications. In this way, applications are first visually modelled and analyzed in AToM3, and then code can be generated from them.

host graph (via a non-injective morphism), then both should be preserved. In the SPO approach, a production is represented as a single (partial) mapping from LHS to RHS. If applied, dangling edges and nodes or edges in conflict due to the identification condition are deleted. Thus, in the SPO approach rules may have secondary effects. This is the approach we follow in this article.

In the graph grammars approach [3] for the definition of Visual Languages, these are defined by either a generating or a parsing grammar. The first kind of grammars are able to generate all the valid models of the language. The second kind of grammars can reduce the valid models of the language into an initial symbol.

In both approaches, one must ensure consistency in models at each level (intra-level consistency) and between the specification and the instance levels (inter-level consistency). In the latter case for example, we have to ensure that for a certain process at the instance level, all its pins are instances of the appropriate ports at the specification level. Additionally, we have to check that the pin connections at the instance level are permitted at the specifica- tion level. Whereas with two separate meta-levels, consistency between both levels is guaranteed by construction, with one meta-level, consistency has to be ensured by using textual (in the form of OCL for example) or graphical constraints (in the form of graph transformation rules) that are evaluated while the user builds the model. For intra-level consistency at the specifica- tion level, we have to check that input ports cannot receive connections from output ports that generate events that the input port cannot handle.

The second rule searches all the outgoing transitions departing from the event that was last executed. If the transition condition is true, then a new event is scheduled and placed in the event queue. The transition specifies the pin from which the event should be generated. The newly scheduled event points to the process receiving it. In case there are several processes connected to the output pin of the process producing the event, the rule selects one randomly. This is a design decision when defining the language. Other choice could have been to generate one event for each connected process. A similar rule to this one was defined in order to discard events sent through unconnected pins.

Rule 3 is similar to the previous one, but is executed when no port is specified in the transition. In this case, the event is directed to the process that generated it. This is a notation convenience, as one could have a process with one of its output pins connected to one of its input pins and use rule 2 for internal event generation.

Rule 4 handles the event for changing the behaviour of a process. The rule schedules (at the current time) the initial event of the behaviour. A similar rule was defined for the case in which the behaviour does not have an initial event. Finally rule 5 deletes the execution pointer. The rule makes use of

DEGEventType actions that are executed when the event occurs. In this way, the DEGs formalism can be used to visually model applications in the style of (textual) event-driven progamming environments such as Visual Basic. This permits, for example, building (by hand) a user interface for each component in the initial event and to modify it in other events. In this way, the user interface of the model is driven by the simulator, inside AToM3.

With respect to the formalism, there have been some approaches for extend- ing event graphs. In [4] two extensions are reported: cancelling edges, and parameter passing. In [5], event graphs are used to describe behaviour of sin- gle components, but there is no mechanism to express event passing between components via specific ports. To the author knowledge no extension has been proposed to adapt event graphs to component-based simulation.

The defined framework is somewhat similar to DEVS (Discrete Event Sys- tem Specification) [13]. In DEVS, atomic models are specified by defining transition functions for internal and external events, as well as output func- tions and a time advance function that sets the amount of time to be spent at each state (if no external event occurs). Atomic DEVS can be coupled via ports to form composite DEVS. In this case there are functions to trans- late event names from output to input ports. This allows an easier reuse of

The combination of a formal definition of a language (by means of meta- modelling and graph transformation) and code generation allows the analysis of the model before the application is generated. In our case, we have only implemented a simulator with graph transformation, but further model prop- erties could be investigated using the theoretical results of graph transforma- tion. These include the analysis of parallelism, deadlock, non-determinism, functional behaviour, etc.

