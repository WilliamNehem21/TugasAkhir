The compilation of Handel-C programs into net-list descriptions of hardware components has been exten- sively used in commercial tools but never formally verified. In this paper, we first introduce a variation of the existing semantic model for Handel-C compilation that is amenable for mechanical proofs and detailed enough to analyse properties about the generated hardware. We use this model to prove the correctness of the wiring schema used to interconnect the components at the hardware level and propagate control signals among them. Finally, we present the most interesting aspects of the mechanisation of the model and the correctness proofs in the HOL theorem prover.

As our hardware model captures the semantics of circuits with loop-back connec- tions by replicating the appropriate behaviour (i.e., by means of successive syntactic approximations), we also need to account for the possibility of having an infinite set of traces. This feature clearly preempts any form of explicit description of the semantic set, especially if we consider that we are also aiming at mechanically ver- ifying our approach.

For the remainder of the paper, we will use  and  as short-hands for the Mixed and Combin constructors respectively. In these terms, the semantics of the delay construct state that its combinatoric prelude only includes a verification for the start wire, while its combinatoric prologue just sets its finish wire to the high value. The behavioural part of the circuit just states that it delays its execution for a single clock cycle (definition 3.2).

The semantics for the while construct needs to provide rules for handling the two possible outcomes of the evaluation of the condition. The first rule accounts for the case when the condition is false and the while terminates immediately (definition 3.7).

Finally, the base case for the output construct is similar to the one for input, but it inverts the roles in the combinatoric prelude (it establishes the presence of the writer and asserts the readiness of the reader). Its behavioural part is also different as it has to assign the value being transmitted to the appropriate channel (definition 3.12).

As we are dealing with sets of actions and assertions on each node of our se- quences, we need to define the collective effect of this heterogeneous set of actions over the environment. The first difficulty we face when defining how a set of actions is going to be executed is that the initial order between actions and conditions has been lost. This is, however, not a problem if we consider that assertions and con- trol flow conditions refer only to the present value of the memory and all variables preserve their values during the whole clock cycle. This fact makes the evaluation of assertions and control flow decisions independent of the combinatoric actions performed in parallel with them and they can be evaluated at any time.

