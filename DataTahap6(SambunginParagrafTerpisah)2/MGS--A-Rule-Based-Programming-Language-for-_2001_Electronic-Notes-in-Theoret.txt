We present the rst results in the development of a new declarative program- ming language called MGS. This language is devoted to the simulation of biological processes, especially those whose state space must be computed jointly with the current state of the system. MGS proposes a uni ed view on several computational mechanisms initially inspired by biological or chemical processes (Gamma and the CHAM, Lindenmayer systems, Paun systems and cellular automata). The basic computation step in MGS replaces in a collection A of elements, some subcollection B, by another collection C. The collection C only depends on B and its adjacent elements in A. The pasting of C into A B depends on the shape of the involved collections. This step is called a transformation. The speci cation of the collection to be substituted can be done in many ways. We propose here a pattern language based on the neighborhood relationship induced by the topology of the collection. Several features to control the transformation applications are then presented.

The three curves correspond to the cyclic evolution of the system starting from three di erent initial conditions. A point in this plot corresponds to a state (x; y). A curve corresponds to the evolution (x; y)(t). The periodicity of the trajectories of x and y gives a closed curve. There is a fourth curve reduced to a xed point. The image by the evolution function of this point is itself. This point is characterized by dx=dt = dy=dt = 0 (no change).

The a priori determination of the phase space cannot always be done. This is a common situation in biology [9,7,8]. Such DS can be found in the modeling of plant growing, in developmental biology, integrative cell models, protein transport and compartment simulation, etc. This accounts for the fact that the structure of the phase space must be computed jointly with the current state of the system. In this case, we say that the DS has a dynamical structure. The description of DS with a dynamical structure are especially hard.

One of our additional motivations is the ability to describe generically the basic features of four models of computation: and the CHAM, P systems, L systems and cellular automata (CA). They have been developed with various goals in mind, e.g. parallel programming for , semantic modeling of nonde- terministic processes for the CHAM, calculability and complexity issues for P systems, formal language theory and biological modeling for L systems, paral- lel distributed model of computation for CA (this list is not exhaustive). We assume that the reader is familiar with the main features of these formalisms but a short description of these computational models is given in section 5 for the readers convenience.

There is a priori no constraint in the case of : one element or many elements are replaced by zero, one or many elements. In the case of P sys- tems, the evolution of a membrane may a ect only the immediate enclosing membrane (by expelling some tokens or by dissolution): there is a localization of the changes. This is also the case for L systems: the new collection B is inserted at the place of A and not spread out over C. For CA, the changes are not only localized, but also A and B are constrained to have the same shape: usually A is restricted to be just one cell in the array and B is also one cell to maintain the array structure.

Now, we come back to our initial goal of specifying the dynamical structure of a DS. A collection is used to represent the state of a DS. The elements in the collection represent either entities (a subsystem or an atomic part of the DS) or messages (signal, command, information, action, etc.) addressed to an entity. A subcollection represents a subset of interacting entities and messages in the system. The evolution of the system is achieved through transformations, where the left hand side of a rule typically matches an entity and a message addressed to it, and where the right and side speci es the entity's updated state, and possibly other messages addressed to other entities. If one uses a multiset organization for the collection, the entities interact in a rather unstructured way, in the sense that an interaction between two objects is enabled simply by virtue of their both being present in the multiset. More organized topological collections are used for more sophisticated spatial organization.

The MGS language is presented informally in section 3 through some exam- ples. We review rst the notions of collections and then their transformations. Simple examples of MGS programs are given in section 4. All examples are pro- cessed using the current version of the MGS interpreter. Then, in section 5, we sketch how the previous formalisms can be emulated in MGS.

MGS embeds the idea of topological collections and their transformations into the framework of a simple dynamically typed functional language. Collec- tions are just new kinds of values and transformations are functions acting on collections and de ned by a speci c syntax using rules. MGS is an applicative programming language: operators acting on values combine values to give new values, they do not act by side-e ect.

A type introduced by a type declaration can later be used in pattern- matching (Cf. section 3.3) or as a predicate to test if a value is of a given type. A monoidal collection type can also be used in the building of a collection by is an expression evaluating to the set of four integers: 1, 2, 3 and 4. The collection kind is a set, and its type is MySet. Actually, expression \Myset : ()" denotes the empty MySet and \;" is the overloaded join operator: x; X creates a new collection with element x merged with the elements of collection X; and expression X, Y creates a new collection with elements of both collections	X and Y .

The type of a collection is taken into account for several collection op- erations. For instance, the join of two collections of type A and B gives a collection with type C corresponding to the common ancestor of A and B (with the previous example, set is the common ancestor of MySet and An- otherSet ). Other example, MySet is the common ancestor of AnotherMySet ) and itself.

An MGS record is a special kind of collection. An MGS record is a map that associates a value to a name called eld. The value can be of any type, including records or other collections. Accessing the value of a eld in a record is achieved with the dot notation: expression fa = 1; b = "red"g:b evaluates to the string "red".

Records can be merged with the overloaded + operator. Expression r1 +r2 computes a new record r having the elds of both r1 and r2. Then r:a has the value of r2:a if the eld a belongs to r2, else the value of r1:a (asymmetric merge [18]).

c. The + operator between record types emulates a kind of inheritance. The de nition T specializes type S by constraining the eld a to the value 1 and saying that an additional eld d must be present and be a string.

where pattern in the left hand side (lhs) of the rule matches a subcollection A of the collection C on which the transformation is applied. The subcollection A is substituted in C by the collection B computed by the expression in the right hand side (rhs) of the rule. There are also several kinds of rules, as detailed below.

binding: a binding p as x gives the name x to the collection matched by p. This name can be used anywhere in the rest of the rule. E.g., the pattern x; x matches two connected elements with the same value (each occurrence of x in a rule denotes the same value).

A transformation is a set of rules. When a transformation is applied to a collection, the strategy is to apply as many rules as possible in parallel. A rule can be applied if its pattern matches a subcollection. Several features are used to have a ner control over the choice of the rules applied within a transformation.

MGS is a functional language with some imperative features. Imperative local variables can be attached to a transformation and updated by side e ects in the rhs of the rules. These variables can be used in a rule guard allowing the conditional use of a rule. For instance, the transformation

In addition to the standard transformation step strategy, two other appli- cation modes exist. In the stochastic mode, the choice of the exclusive rule to apply is made randomly. The priorities of the exclusive rules are then considered as the relative probability of their e ective application (when they can apply). In asynchronous mode, only one exclusive rule is applied in one transformation step.

(the result of applying function A to m). Several reactions happen at the same time. No assumption is made on the order on which the reactions occurs. The only constraint is that if the reaction condition R holds for at least one subset of elements, at least one reaction occurs (the computation does not stop until the reaction condition does not hold for any subset of the multiset).

P systems [17,16] are a new distributed parallel computing model based on the notion of a membrane structure. A membrane structure is a nesting of cells represented, e.g, by a Venn diagram without intersection and with a unique superset: the skin. Objects are placed in the regions de ned by the membranes and evolve following various transformations: an object can evolve into another object, can pass trough a membrane or dissolve its enclosing membrane. As for , the computation is nished when no object can further evolve.

A cruder and simpler approach just associates a multiset M to the region associated with the skin of a P system. The di erence with  is that the elements of M can be multiset themselves, associated to the inner membranes. In this approach, P systems are viewed as a theory of nested (opposed to at) multiset rewriting. We can handle also this approach, because MGS values can be arbitrary combinations of other values.

L systems are a formalism introduced by A. Lindenmayer in 1968 for simulat- ing the development of multicellular organism. Related to abstract automata and formal language, this formalism has been widely used for the modeling of plants. A L system can be roughly described as a grammar with an axiom and a set of derivation rules. The productions are applied in parallel in a non deterministic manner. 0L systems are context-free grammars. D0L systems are deterministic context-free grammars: given a letter A there is at most one production rule that can be applied. Parametric L systems deal with modules instead of letters: a module is a letter associated with a list of parameters. The production rules are extended with side-conditions on the parameters. For example,

Cellular automata (CA) have been invented many times under di erent names: tessalation automata, cell spaces, iterative arrays, etc. However, a fair fraction of the computer research on two-dimensional cellular automata has its ultimate origins in the work of J. Von Neumann to provide a more realistic model for the behavior of complex systems in biology [19].

The organization of the cells of an array is the natural one (Von Neuman or Moore neighborhood). A rule of a cellular automata is an MGS rule applying on only one cell. The conditions on the neighbor cells can be expressed using guards and the speci c neighbors accessors.

The comments of the anonymous referees have greatly improved this paper. The authors would like to thanks the members of the \Simulation and Epigenesis" group at Genopole for stimulating discussions and biological motivations. They are also grateful to F. Delaplace and J. Cohen for many questions and encourage- ments. This research is supported in part by the CNRS, the GDR ALP, IMPG and Genopole/Evry.

[9] Fontana, W., Algorithmic chemistry. In Christopher G. Langton, Charles Taylor, J. Doyne Farmer, and Steen Rasmussen, editors, \Proceedings of the Workshop on Arti cial Life (ALIFE '90)", volume 5 of Santa Fe Institute Studies in the Sciences of Complexity, pages 159{210, Redwood City, CA, USA, February 1992. Addison-Wesley.

[10] Giavitto, J.-L., and O. Michel, Declarative de nition of group indexed data structures and approximation of their domains,  In \Proceedings of the 3nd International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming (PPDP-01)". ACM Press, September 2001.

