In this paper, we take a direct approach to proving soundness of CSL. We define the meaning of CSL judgments directly in terms of a standard concrete operational semantics for the programming language. Our definition is concise and results in a relatively simple soundness proof, which we have formalised in Isabelle/HOL. 1 Our soundness statement has three important benefits:

It does not insist on resource invariants being precise. Similar to Gotsman et al. [10], we prove (a) that CSL with possibly imprecise resource invariants and without the conjunction rule is sound, and (b) that the conjunction rule is sound provided that the resource invariants in scope are precise. Both proofs use the same semantics for CSL judgments.

Discussion. A nice aspect of Definition 3.1 is that the straightforward lemmas about safety of compound commands are usually already inductive, thereby ren- dering the otherwise most challenging part of soundness proofs trivial. The only exception is Lemma 5.3 about the resource declaration rule (for an extension of Definition 3.1 to handle multiple named CCRs), which was arguably the most in- tellectually challenging part of the proof.

Naturally, one would expect to prove this implication by induction on n with an induction hypothesis quantifying over all C and h. The base case is trivial; so consider the n + 1 case. The first two subcases are easy; so consider subcase (iii ). From the first assumption, we know that there exist h1 and h1 such that hj = h1 h1

The first declares a new mutual exclusion lock, r, known as a resource or a resource bundle in CSL terminology. The second construct denotes a conditional critical region (CCR) which runs in isolation with respect to any other CCRs with the same lock. Executing a CCR blocks until the resource is available and the condition B is true, and then executes the body C in isolation to other CCRs acting on the same resource. This is achieved by holding a lock for the duration of testing whether B is satisfied and the execution of its body. Finally, within r do C represents a partially executed CCR: one that has acquired the lock, tested the condition, and still has to execute C. We define locked(C) to be the set of regions syntactically locked by C: those r for which C contains a within r do Cj subterm.

To show absence of data races, we have added a rule (RaceDetect) that aborts whenever a data race is observed. Here, the functions accesses(C, s) and writes(C, s) return the set of heap locations accessed or modified by C respectively. Their formal definitions can be found in [18].

