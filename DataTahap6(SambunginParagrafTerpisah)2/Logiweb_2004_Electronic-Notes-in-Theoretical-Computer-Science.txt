Logiweb is a web-like system that allows logicians to web-publish papers with high typographic quality and high human readability which are also machine verifiable. Among other, Logiweb allows papers to contain definitions of formal theories, definitions of new constructs, programs, lemmas, conjectures, and proofs. Furthermore, Logiweb allows papers to refer to each other across the Internet, and allows proof checking of proofs that span several papers that reside different places in the world. As an example, a lemma in one paper may refer to a construct which is defined in another paper situated elsewhere, in which case the proof checker must access both papers to establish the correctness of the proof.

Among other, Logiweb provides a medium for archived mathematics. It may be used as it is, or it may run silently and transparently underneath other systems like Mizar [12,16]. In contrast, the World Wide Web, which supports mathematics through MathML and OMDoc [10,11], is a medium suited for information in flux.

Section 4 describes the main data structures in Logiweb: (1) Parsetrees that describe the structure of pages and are the entities stored by Logiweb. (2) Codices which are extracted from parsetrees and represent pages in a more machine understandable, data-base like format. (3) Symbols that represent concepts. (4) Aspects, which allow symbols to have different meanings in different contexts.

The pages are correct according to the Logiweb default criterion. A page may override the default be specifying an alternative criterion. As an example, one may put a Mizar [12,16] paper on Logiweb and specify that it is correct according to the Mizar criterion. Details on correctness criteria are given later.

As mentioned in the abstract, Logiweb is a medium for archived mathe- matics. In other words, Logiweb is accumulative in the sense that once a page is put on Logiweb, it is impossible to change it. This accumulative nature is enforced by RIPEMD-160.

Codices represent the mathematical contents of a page in a more database- like structure which interfaces well with the Logiweb checking machinery and programming language. Logiweb codices contain mathematical semantics in a rather clean form as opposed to the more syntactical database-like structures of OMDoc ([10], p.65).

Like most other proof systems, Logiweb includes a programming language. The programming language of Logiweb allows to express side conditions, proof tactics, complicated macros, complex rendering schemes, and many other things. Like e.g. Nuprl [4] and Isabelle [13,14], Logiweb uses a programming language that is based on lambda calculus. Logiweb uses a very simple, un- typed version of lambda calculus. Simplicity was chosen to make it easy to reason about Logiweb and easy to implement it at the (minor) expense that programming has to start at a quite low level.

If a page contains more than one definition of the same aspect of the same symbol, then the browser collects a list of all the definitions and then syn- thesizes a single definition from all the definitions. By default, a definition is synthesized from a list as follows: If all the definitions are identical, then one of them is used and otherwise the codex stores a value that indicates that the definition is in error. The claim aspect is treated differently, however, in that all the definitions are joined into a conjunction. For that reason it is possible to make more than one claim on a page.

If a page makes an overall claim using a definition like the one above, then the page is considered correct if apply(T , Self) evaluates to nil. If T imple- ments e.g. Mizar [12,16], then the page is claimed to be Mizar-correct. Such a term T is likely to be defined using a substantial number of definition, possibly scattered over many pages, and have to be expressed in the programming lan- guage of Logiweb. Including other systems like Mizar in Logiweb in this way has the benefit, among other, that each version of the system becomes frozen and correctness of a page will always be relative to one, particular version of the system. Hence, each correctness claim will be constant even if the system in question is under development.

As mentioned, Logiweb offers complete notational freedom to its user. While this is very convenient, it complicates the problem of getting started. Logiweb offers great flexibility in defining new constructs from already known ones, but how can one introduce the first construct out of nothing? The present section deals with this bootstrapping problem.

Hence, the procedure for bootstrapping on Logiweb is as follows: Publish a base page. Use the proclamation construct of the base page to associate symbols to all the other predefined constructs. Then use these symbols to make definitions, tests, rules, theories, lemmas, proofs, and so on.

The Logiweb protocol has three layers. Layer 0 is concerned with the storage, retrieval, and transmission of bytes. Layer 0 defines the behavior of Logiweb servers. Layer 1 is concerned with the unpacking of pages into codices, and the checking and rendering of pages. Layer 1 defines the minimal functionality of Logiweb browsers. Layers above layer 1 are user defined and outside the scope of the Logiweb protocol. This chapter describes layer 0 of the protocol.

Within a byte, we refer to the bit that has weight 2i as bit number i. Hence, the least and most significant bits are bits number 0 and 7, respectively. In TCP/IP, bit number 0 is transmitted first and bit 7 is transmitted last.

Every server must have at least one name (e.g. "yoa.dk:65535", which is ex- pected to be the address of the first Logiweb server, c.f. http://yoa.dk/) and every page on each server must also have at least one name (e.g. "aux/base"). The syntax of names is

Two servers or a server and a browser may communicate with each other via TCP or UDP or some other protocol. When they do so, they send messages to each other. If they use a connection based protocol like TCP, they commu- nicate using a continuous stream of messages that are put back-to-back on the stream. If they communicate using a datagram protocol like UDP, they may send each messages in a separate package, or they may pack several messages into a single package, but they cannot break a message into several packages.

When a server receives a node message it computes A as above and returns a branch, page, or pointer message if its node at address A is a branch, page, or pointer node, respectively. In each case the server indicates the length of the sibling list of the node. For page and pointer nodes it also indicates the length of the name list of the node. For page nodes, it indicates the length of the stored page measured in bytes, and for pointer nodes it provides a pseudorandom entry from its name list.

Two additional messages allow to translate local file names to references which is mainly of interest for authors who publish pages on the server. When a server receives a translate message, it looks up the given file and returns a translate2 message with the associated reference. Whenever a user creates or deletes a page in the servers file system, the user should send the server a translate message to make the server notice the change.

When loading a page, the reference of the page is regarded as entry number zero in the bibliography of the page. In this perspective, every bibliography has at least one entry, and a page is a base page (c.f. Section 9.3) if its bibliography merely has one entry.

When the browser does transitive loading, it translates all cardinals in the linear parsetree P from Section B.10 to symbols and loads the home pages of all the symbols. During this process the browser may need to find the bibliographies of pages that it does not need to load. Such bibliographies are stored in the codex in the same way as bibliographies of loaded pages, but the browser does not otherwise load such auxiliary pages.

The browser stores the arities from Section B.10 in the codex as mentioned in Section 9.4. Then it converts the linear parsetree from Section B.10 from Polish prefix notation to a tree using the arities in the codex and at the same time converts each cardinal c in the linear parsetree to the symbol s(c, p).

The browser enters the system supplied aspects mentioned in Section 9.4 into the codex attaching mode 0 (c.f. Section B.6) to each of them. Then the browser scans the parsetree for proclamations and enters them into the codex attaching mode 0 to each of them.

During macroreduction, if the browser has to macroreduce a symbol whose macro aspect has mode 2, then the browser synthesizes that macro aspect first. If the browser has to macroreduce a symbol whose macro aspect has mode 1 or 3 (i.e. is in error or is being synthesized) then the definition the symbol occurs in gets mode 1 to indicate error.

