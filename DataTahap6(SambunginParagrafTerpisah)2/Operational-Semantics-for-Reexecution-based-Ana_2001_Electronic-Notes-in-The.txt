We draw concrete and abstract operational semantics towards the analysis of logic programs with delay declarations. This is the basis to generalize the abstract in- terpreter GAIA to deal with logic programs employing dynamic scheduling. The concrete and abstract semantics are introduced explicitly and express both deadlock information and qualified answers. Sure deadlock and sure no deadlock information might be eventually inferred by the resulting analysis.

Most of the logic programming languages in use (e.g., SICStus Prolog [10], Prolog-III, CHIP, SEPIA, etc.) do not force the user to follow the Prolog left-to-right scheduling rule; instead, in order to gain efficiency, they provide dynamic scheduling: atom calls are delayed until their arguments are suffi- ciently instantiated, and procedures are augmented with delay declarations. The analysis of logic programs with dynamic scheduling was first investigated by Marriott et al. in [15,9]. A more general (denotational) semantics of this class of programs, extended to the general case of CLP, has been presented by Falaschi et al. in [8], while verification and termination issues have been investigated by Apt and Luitjes in [2] and by Marchiori and Teusink in [14], respectively.

The rest of the paper is organized as follows. Section 2 recalls basic notions about logic programs with delay declarations. Section 3 depicts the concrete semantics transition rules. Section 4 sketches the main features of the col- lecting and abstract semantics, and discusses our generic fixpoint algorithm. Section 5 concludes the paper.

We assume the existence of two disjoint and infinite sets of variables, de- noted by PV and SV . Elements of PV are called program variables and are denoted by x1, x2, ..., xi, .... The set PV is totally ordered; xi is the i-th element of PV . Elements of SV are called standard variables and are denoted

The notion of concrete behavior provides a mathematical model for the in- put/output behavior of programs. To simplify the presentation, we do not parameterize the semantics with respect to programs. Instead, we assume given a fixed underlying program P augmented with delay declarations.

RETRG is used when a literal l occurring in the body of a clause is analyzed. Let {xi1 ,..., xin} be the set of variables occurring in l. This operation expresses a substitution in terms of the formal parameters x1,..., xn.

Rules R3 and R4 specify the execution of built-ins: the usual unification operations are applied. Notice that built-ins can only occur in the g part of the goal, i.e., the subset of literals in the current goal that have not been considered yet.

Any domain abstracting substitutions can be used to describe abstract ac- tivation states. Similarly to the concrete case, we distinguish among input states and output states. Clearly, the accuracy of deadlock analysis will depend on the matching between delay declarations and the information represented by the abstract domains.

goal is reached, then the interpretation stops and returns an abstraction of the corresponding concrete qualified answers together with no deadlock infor- mation. Otherwise, a goal of the form (g, g) is reached, where for all atoms a occurring in g, the activation substitutions (possibly) does not satisfy its de- lay declaration, and for all atoms a occurring in g, a reexecution process may not refine the corresponding activation substitution. If the abstract domain is accurate enough to infer that a definite deadlock occurs, then the execu- tion ends and returns an abstraction of concrete qualified answers together with definite deadlock information. If this is not the case, then the abstract computation continues by disregarding the deadlock information. In particu- lar, atoms whose activation substitution may satisfy the corresponding delay declaration are selected. In this way we improve the computed abstraction of the corresponding concrete qualified answers while we return the information that the concrete computation may deadlock.

The semantics that has been discussed in these pages belongs to the foundation part of a project aimed at integrating most of the work (both theoretical and practical) on abstract interpretation of logic programs developed by the authors in the last years. The goal is to get a practical tool that tackles a variety of problems raised by the recent research and development directions in declarative programming. Dynamic scheduling is an interesting example in that respect. In the next future, we plan to adapt the existing implementations of GAIA systems in order to practically evaluate the accuracy and efficiency of these seminal ideas.

