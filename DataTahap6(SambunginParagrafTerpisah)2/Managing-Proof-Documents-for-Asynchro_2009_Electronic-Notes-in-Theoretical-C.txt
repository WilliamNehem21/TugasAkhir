The communication with an interactive prover has traditionally been struc- tured linearly [6,1]: the commands of a proof script are stepped through one- by-one, and the region that has been sent becomes locked to prevent further editing by the user. An undo mechanism built into the prover is used to revert the steps and unlock parts of the region on demand. In this model, the user interface serves as a script buffer that tracks the commands that have been processed by the prover, such that they can be saved to a file for later replay.

The linear processing model is very much centered on the mechanics of proving and it is not flexible enough for greatly improving the usability of future user interfaces. One approach to usability is the direct manipulation of familiar objects [14]. Aspinall et al. [5] have developed a document-centered view in which the user edits a proof document just as a mathematician would edit a pen-and-paper proof. The prover is used only to verify the consistency of the document. The actual processing of proof commands, however, remains linear in their proposal.

[20] language, for example, proofs do not influence any of the references to the proven fact. It is therefore possible to postpone the execution of proofs until processing resources become unused, and different proofs can be executed by different processors in parallel. Since proofs take 95% of the overall processing time, the document structure itself can be re-checked almost immediately in response to edits by the user. The second improvement concerns usability. The goal is to provide a behaviour that is similar to that of the Mizar system [12]. There, the prover runs in batch mode and annotates the input proof document with error messages where processing fails. However, it continues processing at the first command that does not depend on the erroneous command. In this way, the user can work in terms of the metaphor of a proof document. Wenzel proposes to make this kind of response available for interactive proving sessions. The linear processing model is dropped in favor of asynchronous processing of proof documents, where the prover decides when it will process which command.

proof processing poses on the user interface component and the software de- sign of both interface and prover. Our main contribution is a new state model for commands that enables asynchronous processing and a corresponding pro- tocol for the communication between interface and prover. Since the protocol allows the prover to choose the processing order, it can be also be supported by existing, linear-processing provers during a migration phase. We present a concrete implementation of a user interface that works with the current development version Isabelle.

The remainder of the paper describes our solution to this challenge. Sec- tion 2 proposes a state model for commands that delegates the decision about the order of processing entirely to the prover. Section 3 describes a software architecture for the user interface that supports asynchronous proof process- ing. Section 4 compares our proposal to related work. Section 5 concludes.

Isabelle is currently being extended to support asynchronous processing of commands [19]. To place as few constraints as possible on the software struc- ture of Isabelle, we abstract over the concrete implementation and base our architecture on an abstract model of asynchronous processing. This approach has the additional advantage that the infrastructure and user interface that we develop in Section 3 will work with other provers as well.

izing accesses to shared resources which occurs in any form of asynchronous or concurrent processing. In the present application, the commands are con- ceptually shared between the prover and the interface and each component needs to manipulate them according to internal considerations. The conven- tional model of mutexes to prevent interference is not sufficient, since prover and interface run in separate processes. We therefore introduce an ownership semantics [11]: instead of sharing some memory object between two threads, each process manipulates those commands that it owns, and there exists a protocol for transferring ownership.

The state sent indicates that the command has been received successfully by the prover. The state has four substates which reflect the general execution model from Section 2.1. They are introduced for the benefit of the user who will want to be informed about the progress of proving. The user interface may, for instance, highlight the commands according to the substate. The transitions are labelled with informational messages sent by the prover. If a command ends in state error, then the interface may decide revoke the command automatically for further editing.

There is no event interrupt which the interface could send to interrupt a particular command. Interruption occurs automatically if the prover re- ceives a revoke message for a command that it happens to be processing. In the model of Section 2.1, the scheduler will abort the corresponding working thread.

The second group addresses the maintenance of the document structure. Since a batch run must be guaranteed to produce the same results as the inter- active work, the textual order of commands in the proof document needs to be known to the prover. The interface therefore sends message create(id,prev ) whenever it creates a new command with ID id whose textual predecessor has ID prev. It sends destroy(id ) when the user edits have destroyed the command with ID id. The interface must own the command that it reports as destroyed.

It is important to point out that the editor does not have to be written in Java. It is also possible to write an adapter that implements the interface but translates the method calls to messages that are sent over some communication channel. The callbacks to the observers take place when the editor process sends a change message.

The editor may also generate events send and revoke (Section 2.2) that change the state of individual commands, and induce the command executor to send them to the prover or have the prover release them. Whether the events are triggered explicitly by the user or a special logic generates them automatically is not specified by the IAPP. We see it as a distinct advantage to be able to experiment with different strategies and evaluate their effect on

We have also considered using a general incremental parsing algorithm (see [10]) to delineate the commands. However, the specialized solution makes it much easier to guarantee that no unnecessary changes to the document structure take place. Also the interaction with the command state cannot be reconciled with existing parsing technology.

The logic of the command executor itself is minimal. The command objects from Section 3.2 implement the state model from Section 2.2, i.e. they trigger the appropriate state changes according to the occurring events. The com- mand executor merely handles commands in states to be send and to be revoked by dispatching messages send and revoke, respectively, to the AsyncProver.

The middle pane shows the text of the proof document. The highlights indicate the processing status of individual commands. Since the emulator (Section 2.4) implements a linear processing strategy, they resemble the locked region in conventional interfaces [1,6]. The left pane shows an outline view that is created in a straightforward manner by observing the document structure and the information attached to commands by the splitter (Section 3.2). The outline reflects edits by the user immediately: when a new keyword is entered, a new item appears in the outline; when a keyword is destroyed, one item disappears.

The right pane resembles the standard output windows of the ProofGen- eral [1]. However, its function is very much different. The standard windows follow the command processing by the prover, i.e. they contain the results of the last processed command. Wenzel has pointed out [18,19] that in the con- text of asynchronous proof processing, this behaviour is not sensible. Instead, the output widgets display the results attached to the command that the caret is currently in. If that command has not been processed, the preceding command is used.

The lower part allows the user to observe the communication between interface and prover. Summaries of the counts of message types are shown on the right. It is also possible to limit the number of handled messages, for instance to avoid flooding the interface with an excessive number of tracing outputs.

Other strategies for sending commands are possible. In continuous proof processing [18], for instance, the interface sends all commands that the user is not currently editing. When the user hits a key within a sent command, the command is revoked and will not be sent again until the caret leaves it. If a command is found to contain an error, it is revoked and left idle until the user has edited it again. Although some commands are executed only speculatively, with multi-core processors the user does not notice an increased response time of the interface.

by the display components; the broker sends unparsed text fragments to the prover and receives the structure in a parse command in return. Parsing is expected to be efficient and to occur after a brief delay. The user can induce the broker to send a parsed command to the prover, in which case the command enters state being processed. When the prover sends the acknowledgement that the command has been processed successfully, the state changes to processed. If an error occurs, the command reverts to state parsed. The state outdated is used to model undo/redo mechanisms.

