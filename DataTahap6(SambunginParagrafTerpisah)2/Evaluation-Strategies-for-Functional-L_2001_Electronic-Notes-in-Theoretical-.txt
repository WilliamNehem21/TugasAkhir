Recent advances in the foundations and the development of functional logic pro- gramming languages originate from far-reaching results on narrowing evaluation strategies. Narrowing is a computation similar to rewriting which yields substitu- tions in addition to normal forms. In functional logic programming, the classes of rewrite systems to which narrowing is applied are, for the most part, subclasses of the constructor-based, possibly conditional, rewrite systems. Many interesting narrowing strategies, particularly for the smallest subclasses of the constructor- based rewrite systems, are generalizations of well-known rewrite strategies. How- ever, some strategies for larger non-con uents subclasses have been developed just for functional logic computations. In this paper, I will discuss the elements that play a relevant role in evaluation strategies for functional logic programming, describe some important classes of rewrite systems that model functional logic programs, show examples of the di erences in expressiveness provided by these classes, and review the characteristics of narrowing strategies proposed for each class of rewrite systems.

Functional logic programming studies programming languages that join in a single paradigm the features of functional programming and logic program- ming. For the most part, a functional logic program can be seen as a construc- tor-based conditional rewrite system (TRS). In the examples, I take several liberties with the notation.

The pure logic version [21, pages 132{135] is complicated by the need to generate potential solutions incrementally and test them before generating the next increment. This prevents the use of library predicates, e.g., to compute permutations, and makes the code of this program speci c to this problem and non-reusable. The pure functional version [10, pages 161{165] is complicated both by the presence of data structures, such as a list of lists that (lazily) holds the entire set of permutations, or a list of pairs that eases the test of the safety of a placement, and by the presence of functions that construct and take apart these structures.

The functional logic version is textually shorter and conceptually simpler. For example, generator and tester are functionally nested and lazily executed and there are no bookkeeping and control data structures. Key factors that contribute to this simplicity and are unavailable in either the functional or the logic program are: (1) non-determinism, e.g., operation permute computes one of the many permutations of its argument, (2) semantic uni cation, e.g., the variables in the constraint U++V=permute Xs  are instantiated, if possible, to

A rewrite system is a pair, R = h ; Ri, where  is a signature and R is a set of rewrite rules. Signature  is many-sorted and is partitioned into a set C of constructor symbols and a set F of de ned operations or functions. Term( [ X ) is the set of terms constructed over  and a countably in nite set X of variables. Term(C [ X ) is the set of values, i.e., the set of terms constructed over C and X . Var(t) is the set of the variables occurring in a term t.

Identi ers true and false are the familiar Boolean constants. [] (empty list) and [ | ] (non-empty list) are the constructors of the polymorphic type list. Identi er a is a type variable ranging over all types. A value or data term is a well-formed expression containing variables, constants and data constructors, e.g., [x,y] which stands for [x|[y|[]]].

A narrowing strategy is a crucial component of the foundations and the im- plementation of a functional logic programming language. Its task is the computation of the step, or steps, that must be applied to a term. In a constructor-based TRS, a narrowing step of a term t is identi ed by a non variable position p of t, a rewrite rule l ! r, and an idempotent constructor substitution such that t ;p;l!r; s i s = (t[r]p). Formally, a narrowing strategy is a mapping that takes a term t and yields a set of triples of the form hp; l ! r; i interpreted as narrowing steps as de ned earlier.

Example 2.3 Continuing Example 2.2, a good narrowing strategy applied to the constraint U++V=[2,3,4] computes the following two steps: h1; R1; fU 7! []gi and h1; R2; fU 7! [U1 |Us ]gi. The rst step yields a solution with answer U=[] and V=[2,3,4]. The second step was shown earlier.

sense that the value computed by the derivation, if it exists, cannot be reached unless the step is executed. Needed narrowing [6] is a conservative extensions of this strategy, i.e., rewrite derivations executed by needed narrowing are call- by-need derivations. In addition, needed narrowing o ers a second optimality result concerning computed answers. Narrowing is non-deterministic, thus a term may have several distinct derivations each computing a substitution and a value. The substitutions computed by these derivations are pair-wise disjoint [6, Def. 15]. This implies that every needed narrowing derivation computing a value is needed in the sense that the substitution computed by one derivation cannot be obtained by any other derivation.

The de nitional trees of operation ++ de ned in Example 2.2 and operation take just de ned are shown below. Lines join patterns in the parent-child relation. The inductive variable of a parent is boxed. The leaves are variants of the rules' left-hand sides.

To make all this more concrete, suppose that t = take N ([1]++[2]), where N is a free variable. Term t uni es with both take 0 X, which is a leaf, and take (s N1 ) X, which is a branch. Therefore, needed narrowing computes the two steps shown below. Each steps is shown with its substitution.

| one out of possibly many. Another relevant issue is the step of a derivation in which a value is eventually bound to a variable. This is a subtle point, since the value bound to the variable needs not be computed at that step. Two practical examples clarify the issue.

Operation queens, de ned in the introduction, has a rule with three oc- currences of variable Y. Variable Y is initially bound to permute X, which may eventually be reduced to one of many values. Replacing each occurrence of Y with permute X and evaluating each occurrence independently would be clearly incorrect. The value of the occurrence returned by operation queens could di er from that tested for safety using operation capture. In this case, the intended behavior, called call-time choice semantics, is to bind the same value to all the occurrences of Y.

Operation regexp, de ned in this section, has rules with two occurrences of variable X. Variable X is initially bound to a term, e.g., digit, which may eventually be reduced to a one-character string of a given alphabet. In this case, however, the intended meaning is opposite. Unless the occurrences of X bound to digit are evaluated independently of each other, some regular expressions would not be generated. In this case, the intended behavior, called need-time choice semantics, is not to bind the same value to all the occurrences of X.

In each case, the intended behavior depends on the program. A functional logic language should allow the programmer to encode in a program the ap- propriate semantics. A strategy for non-deterministic computations should have useful properties, e.g., soundness and completeness, for both semantics.

The constructor-based TRSs are the largest class that has been proposed for modeling functional logic programs. They are a proper superclass of all the other classes discussed previously. Overlapping of rules's left-hand sides is unrestricted, though in constructor-based TRSs it may occur only at the root. No speci c restrictions are imposed on the right-hand sides of overlapping rules.

The classes of TRSs discussed earlier are all unconditional. The well-known outermost-fair rewrite strategy, which is normalizing for almost orthogonal TRSs [20], is also normalizing for conditional almost orthogonal TRSs [9]. For the constructor-based TRSs, the results presented earlier about evalua- tion strategies are extended to the conditional case with little e ort. The strategies discussed in Section 3 are based, either directly or indirectly, on de nitional trees. De nitional trees are concerned with the left-hand sides of rewrite rules only. Therefore, strategies de ned through de nitional trees are somewhat independent of whether TRSs are conditional. An approach that takes advantage of this consideration transforms an original conditional TRS into a target unconditional one without altering the left-hand sides of rewrite rules. In this way, results proved for the target TRS are transferred to the original TRS. This transformational approach is formalized in [4]. In short, the condition of a conditional rewrite rule is moved into the right-hand side by introducing a conditional operation. More precisely, a conditional rewrite rule of the form:

where, as expected, the if then binary operation returns its second argu- ment when its rst argument succeeds. The introduction of this new operation generally creates new steps and new normal forms, but not new values. The computations to a value with the transformed rewrite rules remain essentially the same.

A second relevant issue about functional logic programming concerns high- order computations, a cornerstone of functional programming. Higher-order functions, i.e., functions that take other functions as arguments, contribute to the expressive power of a language by parameterizing computations over other computations. A typical example is the function map, which applies some function to all the elements of list.

As in other situations, and for the same reasons, transformational ap- proaches have been proposed for higher-order computations as well. In short, terms with partially applied symbols are transformed into terms built with new symbols introduced for this purpose. Every symbol in a transformed term is fully applied. The original idea [24] is formulated for functional evalu- ation in logic programming, [12] generalizes it to narrowing, and [7] re nes it by preserving type information which may dramatically reduce the size of the narrowing space. These approaches are interesting because they extend non- trivial results proved for rst-order strategies to the higher-order case with a modest conceptual e ort.

This paper contains an overview of evaluation strategies for functional logic programs. A program is (seen as) a constructor-based TRSs and an evalu- ation or computation is a rewriting or narrowing derivation to a value | a constructor normal form. Constructor-based TRSs are good models for pro- grams because they compute with functions de ned over algebraic data types. Non constructor-based TRSs are seldom used as programs.

are important for programming: conditional and higher-order rewrite rules. Evaluation strategies for these extensions are not as well developed as for the ordinary case. Transformations from extended TRSs to ordinary TRSs make it possible to use the strategies presented earlier while preserving many of their most desirable properties.

