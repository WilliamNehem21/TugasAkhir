dependencies define where and when certain completions can be woven into the model. The execution order of the completions may affect the result model in a way that the following completions are not applicable anymore or that the analysis results are altered. Therefore, the order of completions must be unambiguously specified. Furthermore, we have to clarify responsibilities if additional informa- tion to reduce conflicts is necessary. For this purpose, we specify the roles in the development process responsible for specific completions.

In our approach for a component-based systems, we understand a completion as model refinement. For example a component A could be refined by a locking strat- egy, a monitor or a state manager. These completions provide additional details about the components functionality. They also include so called performance com- pletions which integrate parametrised resource demands [8] (for example middleware properties) into the model. Such detailed information about a software system is a basis for the analysis of non-functional properties. In the following we will introduce the concept of completions formally.

Even though it might be known that a certain pattern affects the quality of a system [19,6], the extend of the effect in a certain scenario is unknown. Fur- thermore, a design pattern may affect several quality attributes. For example, replication increases the availability of a service, but decreases its performance. If multiple patterns are combined to enhance QoS, synchronise components, or ensure data consistency, their overall effect cannot be assessed manually. Therefore, we use model-driven performance and reliability prediction techniques to evaluate the influence of concurrency patterns on the QoS of a software architecture. In the following, we apply our approach for completion conflict reduction to concurrency design patterns.

As a result of the discussion of connector completions, we can conclude that we need at least two types of annotations. The first annotation class determines the connector kind and defines the exact implementation semantics of 1:1, 1:n, and n:1 connectors, e.g., whether voting or replication is used for a 1:n connector. The second class of annotations defines the pre- and post-processing details of the messages used by the connector for remote communication. Here, the annotation gives details about marshaling, encryption, compression, etc. A clear definition of the order in which such completions are added to the performance model is necessary to get accurate performance predictions from the refined performance model. The

The approach introduced in this paper provides the basis for easy completion in- tegration reducing potential conflicts. For the purpose of avoiding and minimising conflicts we map patterns to the roles and responsibilities involved in the software development process. Based on the meta-model elements affected, we determine those elements that are in potential conflict. After this analysis the complexity of the remaining conflicts on a model instance level is decreased, location of the con- flict is identified and conflict resolution can focus on the small set of specific model elements (mostly one element). When is a new completion introduced it should be integrated in one of the categories and this way could be the relation to the other completions easily identified and conflicts minimised.

The idea of using patterns as basic concept for predicting extra-functional properties has been discussed in the context of special components called adapter. Adapters are used to bridge any kind of interoperability problems when composing components. Initial work has been done by compiling a classification of adaptation patterns and defining a process to incorporate the patterns in a prediction process for extra- functional properties by Becker et al. [3]. Besides performance, there is also work looking at reliability prediction in the context of adaptation patterns by Reussner et al.[18].

are desirable for such systems. Several approaches exist addressing these issues partially. Lee proposed to use modelling constructs for concurrency patterns [14] to increase understandability of concurrency, communication, and synchronisation within a software architecture. Similarly, Spitznagel and Garlan [20] used connec- tors to extract communication aspects from components. However, both approaches focus on qualitative attributes, like deadlock-freedom, neglecting quantitative at- tributes, such as performance and reliability.

