Freely available experimental transformation languages have begun to stimulate practical usage of textual transformation notations. The forthcoming QVT transformation languages may provide standardisation or at least interchange capabilities for these experimental languages. Graphical transformation notations are proving rather less successful. We identify many disadvantages of the graphical approach, consider how they can be circumvented and describe changes in the UMLX notation and tool support to improve usability and QVT compatibility.

Model transformations are becoming steadily more practical and rigorous with the advent of better meta-model based tools such as ATL [7] or Tefkat [6]. The trans- formation language for each of these tools is proprietary and so inhibits the wider exploitation of these transformations. The increasingly imminent QVT standard [8] for a suite of three languages may avoid incompatibility problems, possibly by ren- dering the existing languages obsolete, more likely by defining an interchange point so that transformations for language A may be transformed to a QVT language and from there to language B.

In this paper we try to understand why graphical transformation notations are proving less successful and consider when and how this lack of success should be remedied. We first consider the generic advantages and disadvantages of textual and graphical notations, before examining the reasons why some graphical notations have proved successful and others have not. In Section 2 we examine a variety of graphical transformation notations in greater detail, noting their similarities with respect to the use of declarative patterns in principle, but significant differences in practice and even greater differences with respect to transformation rules. Then in Section 3 we outline the tool support for UMLX and notational enhancements to improve alignment with QVT.

A textual notation does not suffer particularly from scalability issues. The use of multiple source files and hierarchical language constructs enables very large overall line counts to be managed. Unduly long lines are readily avoided at the expense of a slightly increased line count.

of languages such as C or Java. A critical weakness in textual languages arises when a more declarative perspective is taken. It is difficult to identify all uses of a particular concept such as a variable, so it is necessary to search the code for all occurrences of a name.

The lack of an inherent layout makes graphics well suited to a declarative ex- position of many interrelated concepts. Each concept is a graph node denoted by a symbol, and each interrelationship is a graph edge denoted by a line. The lines between symbols are easy to identify and so all relationships involving a particular node are easily determined.

In the revised merged QVT submission [8], the class name underlines and the line decorations are omitted. Omission of the underline is a minor stylistic deviation from UML. Omission of the line decorations deprives the reader of the distinction be- tween composition and association and the disambiguation of multiple associations involving the same classes. AGG [3] uses a more conventional Graph Transforma- tion notation and so underlines and line decorations are again omitted, and instance names are replaced by instance numbers.

GRE showed multiplicity in the style of UML but did not exploit it. Its succes- sor, GReAT, recognised that non-unit multiplicity could support patterns involving sets of objects rather than just objects. The corollaries of this interpretation are discussed in [1]; a pattern could now specify that its rule was applicable only to each book containing two or more chapters, rather than just to each book (that might contain some chapters). However, in GReAT, the multiplicity was shown as an instance stereotype thereby identifying the absolute size of the set of matched objects for each free variable, rather than the relative size of the set of matched objects between the ends of the decorated relationship.

UMLX was inspired by GRE but replaced the creation relationship by declara- tive preservation and evolution relationships. A preservation relationship keeps the input element for re-use on as an output element. An evolution relationship may add an output element or elements with respect to an input element or elements, and may also delete an input element or elements with respect to an output ele- ment or elements. Preservation extends the Keep operation of Graph Theory [5], to support keeping not just a node, but also all its composed descendants. Evolution combines Add and Delete operations in a multi-directional relationship that always defines a traceability relationship.

The editor supports partitioning a design into sheets using three different di- agram types. Meta-Model Diagrams support maintenance of Ecore meta-models, that are instantiated within Transformation Rule Diagrams where the UMLX trans- formations are drawn. A further Transformation Context Diagram supports aggre- gating many UMLX-defined or QVT-defined rules as part of a QVT compatible Transformation.

