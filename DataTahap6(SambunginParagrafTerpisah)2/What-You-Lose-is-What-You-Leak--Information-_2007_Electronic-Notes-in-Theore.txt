security type systems, program logics, etc. (See the survey by Sabelfeld and My- ers [23] and references therein). The correctness of such analyses is governed by noninterference (NI) [13]: for any two runs of a program, L indistinguishable input states yield L indistinguishable output states, where two program states are said to be L indistinguishable iff they agree on the values of the L variables.

To answer, we consider WlpP (l = a), where a is some generic output value. Why Wlp? Because then we can statically simulate the kind of analysis an attacker would do for obtaining initial values of (or initial relations among) secret information. Why l = a? Because this gives us the most general Wlp, parametric on the output value.

Example 5.5 Consider the Oblivious Transfer Protocol [21], with principals Alice and Bob. Alice has two messages. Bob knows the messages by name but not by content. Bob asks for a message by name. But Alice does not know which message

The following example [16] shows that this approach provides a weakening of noninterference which corresponds to relaxed noninterference. Both approaches provide a method for characterizing the information that flows and that have to be declassified, indeed they both give the same result since they are driven by (para- metric on) the particular output observation. However, let us underline that the abstract interpretation-based approach allows also to derive the maximal informa- tion disclosed independently from the observed public output [17].

The method described for checking and refining a security policy is parametric on public observations, but one could carry out the same process on properties. If some information about the execution context of the program is present then we can restrict (abstract) the possible observations. These restrictions can be modeled as abstract domains, and therefore by means of abstract noninterference policies. In particular, it has been proved [10] that the more we observe about public infor- mation, the less private information can be kept secret. This means that a security policy, unsafe in a general context, can become safe if we consider a weaker obser- vation of the public output.

AMC techniques are usually applied to Kripke structures. A Kripke structure consists of a set of states, a set of transitions between states, and a function that labels each state with a set of properties that are true in the state. The Kripke model for a program corresponds to the standard transition system associated with the program where states are labelled with the values of the variables. The connec- tion between declassification and AMC suggests the use of existing algorithms for each possible public observation the exact secret released. Moreover, the strong connection between completeness and declassification, together with the connection between completeness and abstract model checking, allows the use of standard tech- niques in abstract model checking for checking and refining declassification policies. In particular, model checking can be applied to generic finite state systems, and abstractions allow to consider even infinite state systems. As future work, we are studying the practical use of these techniques applied to more complex systems.

In a recent paper, Unno et al. [27] have proposed a method for automatically finding counterexamples of secure information flow, which combines security type- based analysis for standard NI and model checking. Our context is more general, since standard NI is a particular case of DNI. Nevertheless, as future work, we plan to investigate whether their approach can be directly derived from ours.

In other future work, we plan to further exploit the strong relation of NI with AMC and stability. One direction is to implement algorithms for deriving the maximal amount of information disclosed and for refining declassification policies, by erasing counterexamples. Moreover, the example above shows that it is possible to combine both abstract noninterference and declassification. So existing abstract model checking techniques can be used not only to derive the amount of information disclosed, but also to characterize the strongest harmless attacker. Finally, we plan to extend the framework in this paper to handle heap-manipulating programs.

