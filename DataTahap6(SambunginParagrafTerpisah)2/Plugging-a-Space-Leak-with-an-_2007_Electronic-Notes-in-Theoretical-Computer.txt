The implementation of conceptually continuous signals in functional reactive programming (FRP) is studied in detail. We show that recursive signals in standard implementations using streams and continuations lead to potentially serious time and space leaks under conventional call-by-need evaluation. However, by moving to the level of signal functions, and structuring the design around arrows, this class of time and space leaks can be avoided. We further show that the use of optimal reduction can also avoid the problem, at the expense of a much more complex evaluator.

In this paper we focus on the continuous nature of FRP, and ignore its reactive component. Since the continuous nature of FRP is only an ideal, it must be approximated in a real implementation. The original implementations of FRP used time-ordered streams of values for this approximation [9,10].

In the remainder of this paper we first describe two standard non-arrow- based implementations of FRP, and show that they are both susceptible to serious space leaks. We then describe arrows in Section 3, and use them to design a new implementation of FRP in Section 4 that is similar to that of Yampa. We show in Section 5 that this new implementation does not suf- fer from the same space leak problem as the standard implementation. In Section 6 we discuss some alternative approaches to solving the space leak problem. We assume familiarity with Haskell [26] and basic functional pro- gramming concepts [14].

Our intuition tells us that unfolding e should be linear in time and constant in space. Yet in reality, the time complexity of computing the nth value of e is O(n2) and the space complexity is O(n). Thus evaluating successive values of e will soon blow up in any standard Haskell compiler, eating up memory and taking successively longer and longer to compute each value. (The same problem arises if we use integralS instead of integralC.)

Note that the data structures SF and C are similar: both are continuation based, and both consist of a value and a function. Both e and eSF are the fixed point of some higher-order function since the integral functions are al- ready recursively defined. Having to compute the fixed point of recursively defined higher-order functions, and the inability of the standard call-by-need evaluation to properly detect emerging vertical sharing, are the reasons for the time and space leak in the first two FRP implementations.

Trying to generalize this kind of clever transformation as rewrite rules, however, is difficult. The reason it works for FRP is that the structure of such recursively defined signals all share a common characteristic, namely that their future values retain the same kind of structure. But this is not necessarily the case in general.

On the other hand, being optimal does not necessarily imply being the most efficient. The extra book-keeping of sharing analysis during optimal evalua- tion incurs a large operational overhead of both time and space. Compared to the relatively well-developed call-by-need compilation techniques, optimal evaluation is far less explored, and no truly practical implementations yet exist.

We have described two standard (albeit simplified) implementations of con- tinuous signals in FRP, one based on streams, the other on continuations. Unfortunately, recursive signals expressed using both of these implementa- tions have serious space and time leaks when using conventional call-by-need evaluation. The source of the problem is the failure to recognize sharing that arises inside of a recursive lambda expression.

This research was supported in part by a subcontract from Galois Connections under DARPA STTR contract 06ST1-0016, and by Yale University under a Kempner Fund Fellowship. Thanks also to the IFIP WG2.8 Working Group on Functional Programming (especially Simon Peyton Jones) for comments received during a preliminary presentation of the research.

