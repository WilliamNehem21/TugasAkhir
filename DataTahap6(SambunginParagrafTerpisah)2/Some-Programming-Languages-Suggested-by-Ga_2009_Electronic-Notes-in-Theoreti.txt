As explained e.g. in [8], one can broadly distinguish two approaches to this enterprise: either we take a language as given and look for a mathematical model to fit it, or we take the model as given and look for a corresponding programming language. A possible motivation for the latter approach is that it offers the prospect intuitionistic linear logic. Each of these in turn gives rise to a cartesian closed category in the usual way, so including the underlying category itself we have a total of seven models of interest. We summarize the construction and basic properties of these models in Section 2.

The mere existence of all these structures on G is in itself an indication of the mathematical fecundity of this model. However, the above definitions may appear rather mysterious, and the precise computational power embodied by the respective exponentials may not be very evident at this stage. The programming language characterizations to be given below will shed more light on this.

One final jigsaw piece is needed. We have seen how the encaps operators provide means to construct non-trivial strategies at types !2G, !3G (that is, strategies that are not merely promotions of strategies for G), but we do not yet possess a way to do this for !1G. The following operator fills this gap.

The grammar for terms may be taken to be identical to that of FPC, but the typing rules differ in three ways. First, the type constructors x, -> are replaced by *, -o respectively throughout the rules for pairing, unpairing, abstraction and application. (The overloading of term constructs here should cause little confusion given that we are keeping the type constructors syntactically distinct.) Secondly, as usual in linear type systems, the treatment of contexts in multi-premise rules is

We shall present extensions of the above languages that are complete for each of our models (whence, by the discussion at the end of Section 2, the models are also fully abstract for these languages). We give here only a high-level route map of the proofs, omitting many interesting details. A source file containing Lingay implementations for most of the programs here claimed to exist is available online [21].

The methodology of obtaining definability results via universal types has led us to a selection of primitive operators which shed light on the computational power of some natural mathematical models. As we have seen, this approach leads us to a choice of programming primitives related to, but not the same as, those usually encountered in existing languages: we are led to favour data encapsulation rather than store cells as the basic mechanism for stateful behaviour, and coroutining rather than first-class continuations as the basis for a flexible approach to control. Moreover, our operators exploit the potentialities of a linear type system to advan- tage, e.g. offering the programmer valuable runtime security guarantees in the case of lincatchcont. Finally, our semantic approach highlights certain combinations of these operators which may coexist safely (for instance, we can combine powerful control operators with certain higher order store constructs without losing runtime safety). We suggest that the primitives we have discussed might serve as a basis for the design of practically useful language constructs (we are pursuing this possibility in our ongoing work on Eriskay).

