It has become fairly standard within almost all formal specification languages to provide at least static invariants. On the one hand this allows to describe the semantics of a system in a sufficent way, but the other side of the coin is the task to guarantee consistency. For a program specification S and an invariant I this means that every execution of S starting in a state that satisfies I should always lead to a state satisfying I, too. However, we can

In order to shift the GCS approach from a somehow purely theoretical framework to an applicable theory we have to investigate computability of GCSs and decidability of preconditions that must be built. For these purposes it is preferable to obtain a tight connection with classical recursion theory [1]. This will be done in this paper.

The charaterization of GCSs according to Theorem 4.7 makes it formally possible to reduce consistency enforcement to a simple syntactical replacement (the forming of S' ) and to an investigation of a guard, namely P (S, I, x'). The following results from section 5 will heavily depend on this reduction and will support the theorys practical relevance.

Taking the general form of the GCS in Theorem 4.7 we may now ask, whether we can find an algorithm to compute the GCS. We may further ask, whether the result is effective. The answer to both questions is negative in general, but we will identify subcases, for which effective GCSs can be computed.

Even, if the GCS SI can be computed from the given command S and the invariant I, the result still contains the preconditions P(S, I, x'). If such a precondition is undecidable, then the GCS will not be effective. In the proof of the next proposition we exploit the arithmetic hierarchy [1, Ch.8].

with an underlying state space X = {x1, x2} and consider a decidable I such that S is I-reduced. Then we use Proposition 4.3 in order to compute the GCS SI. After a complex calculation and some simplifying steps we receive

Then we could show that the existence and uniqueness of GCSs, the com- mutativity result from [8] and the fundamental compositionality result carry over to the new logic. This allows to study computability and decidability issues. We could show that both properties do not hold in general, but for reasonable subclasses of program specifications.

