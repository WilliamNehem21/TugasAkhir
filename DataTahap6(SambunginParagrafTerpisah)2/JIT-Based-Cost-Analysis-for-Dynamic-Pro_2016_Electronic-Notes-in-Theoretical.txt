This paper presents the design and implementation of a system for extracting JIT trace information from the Pycket JIT compiler. We define three increasingly parametric cost models for Pycket traces. We determine the best weights for the cost model parameters using linear regression. We evaluate the effectiveness of the cost models for predicting the relative costs of transformed programs.

The main contributions in this paper are as follows. We have designed and imple- mented a system for extracting JIT trace information from the Pycket JIT compiler (Section 3). We have defined 3 cost models for JIT traces, ranging from very simple to parametric, and we have used an regression analysis over the Pycket benchmark suite to automatically tune the architecture-specific cost model parameters (Sec- tion 4). We have shown that the tuned cost model can be used to accurately predict the relative execution times of transformed programs (Section 5).

JIT compilation is a technology that allows interpreted languages to significantly increase their performance, by dynamically compiling well-used parts of the pro- gram to machine code. This enables interpreters or virtual machine languages to approach performance levels reached by statically compiled programs without sac- rificing portability. Dynamic compilation also allows optimisations to be performed which might not be available statically.

A range of analysis techniques are used to estimate the resources used by pro- grams. High level cost analysis can be performed on the syntactic structure of the source code of a program, e.g. using a mathematical function of C syntactic constructs to estimate execution time [15]. Low-level representations of code and bytecode can be used as source for static resource analysis [3,4,26,7,6]. For example the COSTA tool [4] for Java which allows the analysis of various resources using parameterized cost models, and the CHAMELEON tool [7] which builds on this approach and uses it to adapt programs.

There are many other approaches in cost analysis including amortized resource analysis [23,6], incremental resource analysis [5], and attempting to enforce resource guarantees using proof-carrying code [6,9] (the MOBIUS project is a prime example). Control flow is a key element of many resource analyses [41,20]. However, as JIT traces do not contain any control flow, these types of analysis are redundant and a far simpler approach will suffice. This is fortunate as the static analysis must run

Other important concepts in Pycket traces include guards: assertions which cause execution to leave the trace when they fail; bridges: that are traces starting at a guard that fails often enough; and trace graphs: representing sets of traces. The nodes of a trace graph are entry points (of loops or bridges), labels, guards, and jump instructions. The edges of a trace graph are directed and indicate control flow. Note that control flow can diverge only at guards and merge only at labels or entry points. A trace fragment is a part of a trace starting at a label and ending at a jump, at a guard with a bridge attached, or at another label, with no label in between.

The trace graph is a convenient representation to read off the trace fragments. In this example, there are the following four fragments: l1 to l2, l2 to g2, l2 to j1, and l3 to j2. Trace fragments can overlap: for instance, l2 to j1 overlaps l2 to g2.

The RPython tool chain provides language developers with a rich set of APIs to interact with their generic JIT engine. Among these APIs are a number of call- backs that can intercept intermediate representations of a trace, either straight after recording, or after optimisation. We use the latter callback to obtain the optimised trace for cost analysis.

For the purpose of calibrating weights we use 41 programs from the standard Pycket benchmark suite pycket-bench [31] and the Racket Programming Languages Bench- mark Game suite [18]. The programs used are a subset of the full suite, as programs that result in failing benchmark runs or which contain calls to foreign functions are omitted. Foreign function calls are removed as it is unlikely that any two foreign function calls are doing the same thing or take the same time.

The Pycket version used for these experiments is revision e56ba66d71 of the trace-analysis branch of our custom fork [29], built with Racket version 6.1 and revision 79009 of the RPython toolchain. The experiments are run on a 16 core 2.0 GHz Xeon server with 64 GB of RAM running Ubuntu 14.04.

A number of different skeleton types are used in AJITPar. The basic types of skeletons are parallel map, parallel reduce and divide and conquer. The actual versions of the skeletons in AJITPar are tuneable, in that they are parameterised with a number that specifies the granularity of the parallelism in some way. The definitions of some of these tuneable skeletons, parMapChunk, parMapStride and

We have designed and implemented a system for extracting JIT trace information from the Pycket JIT compiler (Section 3). We have defined three lightweight cost models for JIT traces, ranging from the extremely simple loop counting model CM0 to the relatively simple instruction counting model CMC to the architecture-specific weighted model CMW . To automatically determine appropriate weights for CMW we have run a linear regression over the Pycket benchmark suite (Section 4). We have used all three cost models to compare the relative cost of tasks generated by six skeleton-based benchmarks pre- and post-transformation, where the skeleton transformations are induced by changing a skeleton-specific tuning parameter. We have found that the effect of these transformations on task runtime can be predicted accurately using our cost models, once the task granularity rises above a threshold (Section 5).

We have demonstrated that even the simplest, architecture-independent cost model described in this paper allows us to accurately predict the effect of simple transformations on task runtime. We expect that the architecture-specific model CMW will be more accurate when predicting the task runtime of more complex transformations, e.g. chains of transformations (as arise naturally when transform- ing complex skeleton expressions by rewriting). We further speculate that similar techniques can be used to identify lightweight cost models based on the traces pro- duced by the JIT compilers for other languages, e.g. Python, Javascript, etc.

