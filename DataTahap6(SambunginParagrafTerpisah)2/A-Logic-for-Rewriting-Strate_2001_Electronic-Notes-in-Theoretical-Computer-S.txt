Rewriting strategies can become quite complex and are not easy to comprehend or reason about when they are expressed in operational terms. This paper develops a weakest precondition logic for reasoning about strategies programmed in the stra- tegy language Stratego. This logic embeds the modal mu-calculus, allowing it to express properties of terms of arbitrary depth. Its use is illustrated by characteri- zing properties of several reduction strategies for the lambda calculus with explicit substitutions.

Strategies for term rewriting are widely used to implement syntactic theories in systems for automated deduction, including theorem-proving and program transformation. Strategies evaluate conditions for the application of rewrite rules, determine the order in which subterms are explored, and prescribe bin- dings and scope of pattern variables. Formulating strategies is a programming task that can be as complex as any other that we know. It can be made ea- sier with appropriate programming language support and better understood through logical characterization.

This paper is a rst step towards de ning a programming logic for strate- gies. Stragegies are understood as programs over a domain of terms. Control of strategies is accomplished with recursion and nondeterministic choice. A weakest-precondition logic furnishes a natural formalism for reasoning about such programs. However, predicates in this logic are interpreted over a domain of term structures. As a logic for terms, we have adopted the -calculus [7], enriched with modalities that express path quanti cation in terms.

Rules have been developed in this logic for the constructions of Stratego [12,13,15,14], a domain-speci c language designed speci cally for program- ming strategies. Stratego provides a compositional semantics with explicit recursion, allowing strategies to be applied at sites deep within terms. Stra- tegies, and therefore patterns, are rst-class constructs of Stratego. As in a logic programming language, conditional control in Stratego is based upon the success or nite failure of strategies, rather than if-then-else expressions that test conditions coded as boolean values. Although essentially a rst-order language, Stratego also supports a particular form of higher-order strategies, namely term congruences, which lift term constructors into strategy construc- tors.

Section 2 introduces a weakest-precondition (wp) logic for strategies. In Section 3, several strategies for reducing terms in the lambda-calculus are proposed and properties of reduction strategies are characterized in the wp logic. Section 4 discusses related work and Section 5 presents conclusions.

Rewriting strategies are designed to produce terms that exhibit particular forms, by a directed series of rewriting steps. To reason about strategic re- writing, we'd like to know a set of input terms from which a given rewriting strategy is assured to produce an output term in a speci ed form. A predicate characterizing the largest set of such input terms is a weakest precondition for the strategy to produce a speci ed form of output.

The universe we have in mind is a Herbrand universe of terms generated by a nite signature, . Call this universe T ( ). Predicates are interpreted as subsets of this universe, by an interpretation function, I : Pred ! T ( ). The distinguished predicates True and False have the interpretations I(True) = T ( ) and I(False) = ;. Term variables in the logic range over the universe.

A weakest precondition is intended to characterize the largest set from which a given strategy can be assured to produce a term satisfying a speci ed postcondition. However, this is a constructive interpretation. If t 2 wps(P ), then the strategy application hsit is accepted as constructive evidence of a term that satis es P . Thus it should come as no surprise that the characterization

Thus far, we have discussed strategies as if only ground terms were transfor- med. However, the real power of rewriting strategies is only realized when we consider terms with variables. Term variables range over the ground terms in a universe. A term with variables may be valued as a ground term by provi- ding an environment in which its variables are bound. A strategy can have the e ect of binding variables in an environment, as well as transforming the term to which it is applied into a new form.

Formally, an environment is a list of binding pairs, [(x1; t1); (x2; t2);::: ; (xn; tn)], in which x1; x2;::: ; xn designate variables and t1; t2;::: ; tn are ground terms. We shall write [(x; t) j e] to designate an environment in which the pair (x; t) occurs at the head of the list. Environments are represented as lists rather than sets because a variable binding may be shadowed by the addition of new bindings of the same variable.

The term-building rule does not introduce new bindings. It characterizes those environments in which the form given in the term-building strategy can satisfy the asserted postcondition. Since the result of a term-building strategy does not depend upon the initial term, the weakest precondition imposes no restriction on initial terms.

Many complex strategies can be de ned in terms of these basic binding and building strategies. For instance, a strategy that applies a given strategy, s to a speci c term is !t; s. This strategy can be written in a function-application style with the syntax hsi t.

Another example is a rule in Stratego, which has the (sugared) syntax n p ! t where r n . A rule is de ned in terms of the compound strategy fx1;::: ; xng : ?p; r; !t, with the side condition that FV (p) [ FV (r) [ FV (t) fx1;::: ; xng, i.e. the rule contains no free occurrences of term variables. The weakest-precondition transformer for such a rule is the composition of the weakest-precondition transformers of its components.

A logic capable of characterizing strategies must be able to express properties of the substructure of terms. For such a capability we turn to Computa- tional Tree Logic (CTL)[3,6]. CTL is a modal logic conceived originally as a branching-time temporal logic. Nodes of a tree can be interpreted as the possible future states of a system as time progresses. The root of the tree represents the current state. Each path from the root represents a possible trajectory of the system being modeled.

Path quanti cation can also be made more explicit by referring to paths di- rected through speci c arguments of constructed terms. For example, a Let constructor (see Sec. 3) takes a triple of arguments, each of which is given a di erent interpretation in a language that embeds Let expressions. One might wish to quantify with respect to the last two arguments, omitting quanti ca- tion over the rst argument.

A bottom-up strategy construction applies a strategy, s, to all subterms of a given term in bottom-up order. Thus an intermediate form might consist of a term, each of whose children had already been transformed by an application of bottom-up(s). A bottom-up strategy succeeds if and only if the argument strategy succeeds at every subterm. Its de nition in Stratego is

The rules Alpha and Beta are conversion/reduction rules of the lambda calculus. These rules suspend substitutions in the form of Let constructions. The Stratego library strategy new is a term-builder that upon each invocation, generates a new identi er not previously occurring in any term.

By recursively eliminating Let-terms nested within a Let construction, we avoid the need for an explicit LetLet rule to handle nested Let terms. The recursion is e ective only in the matrix of a Let term. This strategy is consistent with outermost reduction of Beta redexes, but would not be consistent with innermost reduction. Thus the strategy is a bit subtle.

ELAN is formally de ned by a denotational semantics [1] which provides a reference model for implementation. In principle, the semantics also furnishes a basis for reasoning about transformation strategies. However, reasoning directly in terms of a semantics model can be tedious, as it is encumbered by details of the model.

[5] X. Du, K McDonnell, E. Nanos, Y. S. Ramakrishan, and Scott A. Smolka. Software design, speci cation and veri cation: Lessons learned from the Rether case study. In Proc. of Sixth International Conference on Algebraic Methods and Software Technology, volume 1349 of Lecture Notes in Computer Science, pages 185{198. Springer Verlag, 1997.

