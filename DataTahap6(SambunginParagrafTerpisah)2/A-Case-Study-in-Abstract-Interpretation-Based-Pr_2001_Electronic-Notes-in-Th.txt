Static program analysis is closely related to program transformation since a preliminary program analysis is necessary in order to collect information about the program runtime behaviors which is then used to decide which offline trans- formations are applicable [12,14]. Abstract interpretation [4,6,8,9] has been used as a formal basis for static program analysis. Abstract interpretation can also be used to define a semantics-based program transformation framework. This is a new approach to the formal design of program transformations and a new application of the abstract interpretation theory. The idea is to formally design syntactic (that is source level) program transformations by abstrac- tion of transformations of the program semantics. Abstract interpretation is used to formalize the correspondence between semantic and syntactic transfor- mations. This yields the necessary formal basis for (hopefully mechanically) constructing correct program transformation tools and may be to systematize their design.

In the following, we consider the blocking code elimination, which consists in eliminating blocking commands other than stop commands. The final iterative algorithm is trivial but this case study is simple enough to exemplify the design of correct program transformations by abstract interpretation. In particular the iterative nature of the blocking code elimination algorithm follows from the fixpoint definition (10) of the trace semantics.

puter screen). The use of such undesirable semantically blocking commands may be considered as bad program design, and a removal function (prefer- ably an algorithm) tb[P] would be useful to eliminate blocking commands or to check that a program P = tb[P] is well designed according to this criterion. Non-terminating program behaviors should be left unchanged. Because of

Obviously a preliminary static program analysis could also be used to determine a larger subset of the semantically blocking actions by taking values of variables into account (e.g. by using the constant propagation static analysis [15]). We do not consider this more refined offline transformation because infinitely many such variants of b can be designed and we choose the simplest one to illustrate our purpose.

