We study and improve the OBF technique [1], which was used in distributed algorithms for the decomposi- tion of a partitioned graph into its strongly connected components. In particular, we introduce a recursive variant of OBF and experimentally evaluate several different implementations of it that vary in the degree of parallelism. For the evaluation we used synthetic graphs with a few large components and graphs with many small components. We also experimented with graphs that arise as state spaces in real model check- ing applications. The experimental results are compared with that of other successful SCC decomposition techniques [6,5].

Several distributed algorithms for SCC decomposition have already been pro- posed. They all exploit the fact that we can efficiently compute the set of vertices reachable from a certain vertex or set of vertices. The first distributed algorithm [5], known as FB, is based on the simple observation that the SCC to which a given vertex v belongs, is the intersection of the set of vertices reachable from v and the set of vertices reachable from v in the transposed graph.

We focus on the OBF technique introduced in [1]. OBF is essentially a procedure that divides a rooted graph into independent sub-graphs, possibly eliminating some trivial SCCs in the process. No SCC crosses a boundary of an independent sub- graph so we can use whichever algorithm we like to decompose the sub-graphs. The original paper used the FB algorithm for the sub-graphs. We improve the OBF technique so that it can be applied recursively.

Having a number of independent sub-graphs we can run SCC decomposition on them in parallel, thus increasing the degree of parallelism. Note that in a distributed environment, a single reachability analysis itself runs in parallel already. It is not clear a priori whether the gain of decomposing all sub-graphs in parallel outweighs the overhead and complexity, compared to decomposing the sub-graphs one by one, as was done in [1].

The rest of the paper is organised as follows. Necessary definitions from graph theory and existing distributed algorithms are presented in Section 2. The new algorithm based on recursive application of OBF is described in Section 3. Results of experiments are in Section 4. In particular, we compare our new algorithm with the algorithms from [6,5,1], and we measure the effect of decomposing sub-graphs one by one, or in parallel. Contributions of the paper are summarised and future work is outlined in Section 5.

All algorithms below have an optimisation routine in common, which removes all initial trivial SCCs (called elim-atomic in [6], OWCTY [4] in [1]). It repeatedly removes vertices whose indegree is (or becomes) zero, because these must be trivial components. Note that this procedure cannot detect trivial components that lie in between strongly connected components. This procedure is implemented as a until eventually all edges are increasing. Note that a vertex can be recoloured several times. Also note that after colouring, all vertices in a single SCC have the same colour. So all edges between vertices of different colours can be removed.

In the second step, one takes as roots those vertices that kept their initial colour. The SCCs of those roots consist of the vertices that are backward reachable (within the same colour). These SCCs are removed (heads-off) and the algorithm proceeds with the remaining sub-graph.

As shown in [1], OBF performs better than FB in a number of experiments. Note that in OBF the graph is split in slices in linear time. On each slice, algorithm FB is applied. But, as OBF is better than FB, we now propose to recursively apply OBF to the slices.

We observed that Recursive OBF suffers from the amount of synchronization points among individual procedures. However, the amount of synchronization points may be significantly reduced if independent procedures are started as soon as all data they depend on are ready. Starting independent procedures can be viewed as an implementation detail, however, it has proven to have significant impact on the performance. The three different versions presented in the previous section are recapitulated in the following.

Our experiments show that indeed the total running time of the algorithm de- creases by adding more parallelism, despite the extra overhead (e.g., running vari- ous termination detection procedures in parallel), and despite the fact that a single reachability computation is already parallel.

+ FB [1] and CH (Colouring [6]). Like Recursive OBF, FB and OBF + FB can be implemented with different degrees of parallelism. For the comparisons we im- plemented only the most parallel versions of these algorithms, which give the best results. These implementations are denoted by FB-P and OBF-FB-P. CH processes SCCs inherently in parallel; we reused the code from [6] and all experiments are carried out in the same software/hardware environment.

Although the maximum depth of recursion can be as high as n, in our experi- ments the algorithm we are mainly interested in, Recursive OBF, reached maximum depth of 15. This makes us believe that space complexity is not a problem of Re- cursive OBF. However, the FB algorithm exceeded depth 200 in our experiments. It did not prevent the algorithm from successful computation of SCCs, because our graphs are relatively small. Nevertheless, this high recursion depth kills the benefit of having accumulated memory of a cluster of workstations. If we add that FB is much slower if independent subgraphs are not processed in parallel, we can con- winners. Their runtimes are practically the same because most of the decomposition was done by the first OBF which is the same for both algorithms. The slices identified by the OBF were then processed in parallel. It did not matter if OBF or FB was used for them because of the structure of the slices.

The previous paragraph suggests aims for future work: To improve Recursive OBF to work better on graphs with many unconnected islands. We have reasons to believe that such an improvement is possible. More thorough experiments should also be carried out to confirm our appealing results of Recursive OBF.

