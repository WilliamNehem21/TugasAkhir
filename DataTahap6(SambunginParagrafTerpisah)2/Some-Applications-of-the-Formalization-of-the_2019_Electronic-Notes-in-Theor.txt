Context-free languages are highly important in computer language processing technology as well as in formal language theory. The Pumping Lemma for Context-Free Languages states a property that is valid for all context-free languages, which makes it a tool for showing the existence of non-context-free languages. This paper presents a formalization, extending the previously formalized Lemma, of the fact that several well- known languages are not context-free. Moreover, we build on those results to construct a formal proof of the well-known property that context-free languages are not closed under intersection. All the formalization has been mechanized in the Coq proof assistant.

The results presented here are important for various reasons. First, they are ap- plications of the previous formalization of the Pumping Lemma. Second, they are the first ever languages to be proved not to be context-free using a computerized theorem prover. As far as the authors are aware of, all proofs of any language claimed to be non-context-free published until now are text (pen and paper) ones, as can be found in textbooks, papers and lectures on the subject. Thus, the present work brings mathematical formalization into a new area of application. Third, they give rise to interesting considerations about building formal proofs from text proofs. Fourth, they can be very useful in teaching the theory of context-free languages within a logic and formal background, with the help of interactive theorem provers and Coq

The work presented here is part of a long-term project aimed at the formalization of context-free languages and grammars. It started with the formalization of clo- sure properties for context-free grammars [9], evolved later into the formalization of context-free grammar simplification [10] and then into the Chomsky normalization of context-free grammars. Formalization of simplification enabled Chomsky normal- ization, which in turn enabled the formalization of the Pumping Lemma and then the results presented here. The whole work is described in detail in [5], and more information can be found in [8]. Previous results will not be discussed here and can be retrieved from the references.

The statement and applications of the Pumping Lemma for CFLs are presented in Section 2. The approach that we have adopted towards the formalization of languages in general is discussed in Section 3. Then, in Sections 3.1, 3.2 and 3.3, respectively, we present formalizations of three different and well-known languages using the approach discussed before. Besides that, each of these sections contains a text proof of the fact that the language is not context-free, a discussion about the formalization of such a proof and considerations about the complexity of the text and formal proofs. In Section 4 we describe our formalization of the non- closure of context-free languages under intersection, a result that is built on top of formalization described in 3.3. Final conclusions are presented in Section 5.

The type terminal has a single constructor a, which corresponds to the single element of the alphabet. Definition square is a predicate on lists of terminals, expressing the property that the length of the list is a square of some number. It embeds the property that all words of the language must satisfy, namely that the length of the word must be the square of some number.

While the text proof is less than 10 lines long, the formal proof script is approx- imately 200 lines long. Despite the expansion factor being significant, the proof is simple and very readable. The size, in this case, can be justified by the style adopted in the writing of the script (with only one tactic per line, for example) and the de- tails that are inherent to the proof. The elegance of this formalization stimulated the authors to pursue the formalization of the next section.

As in the previous case, the type terminal has a single constructor a. Definition prime is a predicate on lists of terminals, expressing the property that the length of the list is a prime number. It embeds the property that all words of the language must satisfy, namely that the length of the word must be a prime number.

symbol, while the number of the other two remain unchanged. Thus, the new word can not belong to anbncn. If it contains two different kinds of symbols, then v and x might contain one or two different kinds of symbols each. If both contain only

The type terminal has three constructors a, b and c. Definition anbncn is a predicate on lists of terminals, expressing the property that the list is built by the same number of each of the symbols a, b and c, in this order. It embeds the property that all words of the language must satisfy, as described above.

As an example, consider case (1) and take i = 2 (corresponding to uvvwxxy). The pumping of v and x increases the number of symbols a but surely does not change the number of symbols b c. Thus, uvvwxxy necessarily has more symbols a than symbols b and c and can not belong to anbncn. Consider now case (12) and take i =2 again. The pumping of v and x increases the number of symbols a and b but surely does not change the number of symbols c. Thus, uvvwxxy necessarily has more symbols a than symbols c and can not belong to anbncn. The same happens if the number of symbols b is compared to the number of symbols c. The conclusions are similar for all 22 cases, and show that the new word uvvwxxy can not belong to anbncn in any situation.

It is interesting to note that the size of the text proof of anbncn (15 lines) does not differ much from the size of the text proofs of previous cases (10 lines each). However, the size of the formal proof is bigger (more than 10 times bigger) than the corresponding ones, which means that the formal proof of anbncn is more than 100 times longer than the corresponding text proof. This is probably due to the nature of our third language, which introduced many combinatorial problems in the way to the final solution. These combinatorial problems have simple and intuitive statements which, however, led to many different cases to be considered, many lines of script to be written and many different lemmas with similar statements and proofs.

While most of the lemmas used in this proof are short and repetitive (which can surely be grouped and reduced in number by using proper parametrization), the three lemmas stated above comprise almost 800 lines corresponding to approximately 40% of the whole formalization. This means that most of the effort put in this formalization was used to prove results about the structure of a given substring in comparison to the structure of another string. Since the authors are not aware of any Coq libraries that could handle this in more efficient way, or simply handle it at all, we consider that the lack of such a library increases considerably the complexity of some formalizations (such as the present one). Also, that it might be the case that a new library developed with this specific purpose be benefitial for similar applications. The convenience of having such a library could be an opportunity and an important outcome of our present work.

Another reason that may help understand the size and complexity of the formal proof in comparison to the text proof is the fact that the later is, in a certain sense, oversimplified. Informal statements may hide a number of different cases that must be considered explicitly when developing a formal proof. This is the case, for example, for most of the text proof presented before for language anbncn. Some examples of it are:

To prove that the class of the context-free languages is not closed under intersection, it is sufficient to present two context-free languages whose intersection is not a context-free language. For that purpose we use the language anbncn, previously proved not to be context-free in Section 3.3.

With the previous results (including lemma not_cfl_anbncn from Section 3.3), the proof is straigtfoward and only a few lines long. It is obtained by contradiction, since we have both a prove that anbncn is context-free (from the hypotheses) and that anbncn is not context-free (from Section 3.3) 9 .

While the text proof is very straightforward and only a few lines long, the formal proof is longer and plenty of details that range from the proof that a simple language is context-free to the proof that a given language can result from the combination of other simpler languages by means of the use of the appropriate operations. The proofs are generally not short and use inductive arguments. The proof scripts for this part of the formalization are approximately 1,500 lines long (for intersection.v) and 500 lines long (for bijection.v).

We tried to formalize a proof for anbnanbn based on the first attempt described above, but the results were not encouraging. The proof script grew very fast and had more than 4,000 lines when it was interrupted, still incomplete. The size and complexity of the script became so big, with so many cases to be considered and lemmas yet to be proved, that we decided not to go on for the time being. We did not try to formalize the second sketch, which has a smaller number of cases to be considered (22 versus 28).

It is worth to note that, for all five languages considered so far (square, prime, anbncn, anbnanbn and ww ), their definition and the text proofs that they are not context-free are concise and elegant (the text proofs for anbnanbn and ww, although not presented here, are also straightforward). For languages square and prime, it is also possible to state that the corresponding formal proofs are straighforward to build and are easy to read. For languages anbncn, anbnanbn and ww, however, the situation is completely different. So, what explains the difference between these two groups of languages? As mentioned in the case of language anbncn, explanations may come both from the classical text proofs and the need to reason about the

The results obtained so far are interesting in their own. They correspond to im- portant applications of an important property of context-free languages which can be used for different purposes. These include to guarantee the correctness of text proofs that may hide too much information, and thus escape from the full under- standing of the reader, and to better understand the nature of the corresponding proofs. Also, these formal proofs are original and valuable material for courses in formal language theory and/or formal reasoning using interactive proof assistants.

