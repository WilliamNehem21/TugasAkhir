Abstract Model Checker. The transition system generated from an abstrac- tion represents a double approximation of the original. We use a 3-valued logic in order to infer the satisfaction or refutation of properties. The 3- valued model checking problem can be transformed to two standard 2-valued problems. Hence one can use the existing model-checking tools.

The tool allows the use of two mainstream techniques to relate concrete and abstract domains: homomorphisms and Galois Connections. In the homomor- phic approach a concrete data value is related to a single abstract value, via a mapping function H. In the Galois Connection approach a concrete data value might be related to several abstract values. Typically, the abstract do-

The Abstractor supports the use of both approaches and also the combi- nation of them that consists of the lifting of an homomorphism to a Galois Connection. In practice, this possibility is very fruitful because it permits the user just to provide the mapping between the concrete and the abstract data domain and the definition of the abstract functions. The tool automat- ically lifts the structure to a Galois Connection. For further details, please consult [30].

The Abstractor returns the skeleton of the abstraction, i.e, an incomplete Modal -LPE. In order to generate the corresponding Modal -LTS, the user has to complete the Modal -LPE by providing the abstract domains and the definition of the abstract functions. The Abstraction Loader assists the user to manage abstract domains by providing import/export mechanisms and an automatic abstraction generator.

The mode export of the Loader lists the functions needed to complete the specification, we remember that the functions needed to manipulate sets are automatically generated by the tool. The mode load is used to import the definitions. The mode auto automatically performs the pointwise abstraction of the sorts and functions.

(step iii) Following [20], an abstract formula is interpreted dually over an Modal -LTS, i.e. there will be two sets of states that satisfy it. A set of states that necessarily satisfy the formula and a set of states that possibly satisfy it. From the practical point of view, an interesting fact is that the 3-valued model checking problem can be easily transformed in two standard 2-valued problems. This allows the use of existing model checking tools such as the evaluator of the CADP toolset [13].

These transformations are done in linear time. The difference between this approach and the one used by Godefroid and al. [14] is that instead of gener- ating two different models and use one single formula, we use a single model and two versions of the formula. In general formulas are much smaller than the systems and their duplication is less expensive.

The tool has been applied within the verification process of several case stud- ies, as for example, to the study of JavaSpaces applications [11,33]. JavaS- paces is a coordination architecture that implements a shared repository that external agents can use to communicate by sharing objects. It provides extra support for implementing reliable applications. Systems may use transactions, a notification mechanism and timeouts on resource allocation. By abstracting the contents of the shared space to some significant values and the state of the external agents, we could prove some safety and liveness properties for more than 100 parallel processes, of a characteristic sort of JavaSpaces application. The characteristic application consists of a computationally intensive problem that is accomplished by breaking it into a number of smaller tasks that can be executed in parallel.

The protocol has a number of parameters, such as the length of the lists, the maximum number of retransmissions and the contents of the data, that cause the state space of the system to be infinite and limit the application of automatic verification techniques such as model checking. By abstracting some of these parameters, model checking could be successfully applied (see [31]). In a different context, the tool has been applied to perform simple abstractions to many different systems (see [26]).

FeaVer [19] and abC [10] abstract C programs by hiding variables. The first one translates the code to PROMELA, furthermore it also allows the user to define his own abstractions, the latter abstracts directly the C code by implementing an extension of the GCC compiler. Java PathFinder [18], BeBop [2] and SLAM [1] use predicate abstraction. We refer to [9] for an extended overview of tools and techniques for abstract model checking.

