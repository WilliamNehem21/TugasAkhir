This paper presents a non-intrusive method for Objective Caml code coverage analysis. While classic methods rewrite the source code to an instrumented version that will produce traces at runtime, our approach chooses not to rewrite the source code. Instead, we use a virtual machine to monitor instructions execution and produce traces. These low-level traces are used to create a machine code coverage report. Combined with control-flow debug information, they can be analyzed to produce a source code coverage report. The purpose of this approach is to make available a method to generate code coverage analysis with the same binary for testing and for production. Our customized virtual machine respects the same semantics as the original virtual machine; one of its original aspects is that it is implemented in the Objective Caml, the very language we build the tool for.

This paper is organized as follows: section 2 describes a past experiment on using Objective Caml in the safety-critical software domain; section 3 details the project in which our work takes part; section 4 presents the Zam machine and our implementation, first step in non-intrusive code coverage process; section 5 shows non-intrusive code coverage process at the machine code level and how to go from machine code coverage to source code coverage with our tool available at http://www.algo-prog.info/zamcov and section 6 describes related work and announces our future work in this project.

4 This project is supported in part by the SYSTEM@TIC PARIS-REGION Cluster in the Free and Open Source Software thematic group ( http://www.projet-couverture.com/). Two companies are involved in the development: AdaCore and OpenWide, together with two academic partners: Telecom ParisTech and University Pierre et Marie Curie (Paris 6).

The French company Esterel Technologies 6 decided in 2006 to base its new SCADE SUITE 6TM 7 [4,5] certifiable code generator on Objective Caml. Esterel Technolo- gies markets SCADE SUITE 6TM, a model-based development environment dedi- cated to safety-critical embedded software. The code generator (KCG 8 ) of this suite that translates models into embedded C code is DO-178B compliant and al- lows to shorten the certification process of avionics projects which use it.

The DO-178B standard applies to embedded code development tools with the same criteria as the code itself. This means that the tool development must follow its own coding standard. The certification standard originally targeted only embedded software, so its application for a development tool must be adapted. For instance, for a code generator it is accepted to use dynamic allocation and have recursive functions. The specificity of the certification process for tools is under discussion to be explicitly addressed by the forthcoming DO-178C standard that should be effective soon.

Among the numerous testing activities, one is making reports on code coverage. This activity has a set of constraints other than just showing whether some code is alive or dead: for instance, if a result is a complex Boolean expression, it is not enough to show that it has been evaluated (to any value). Neither is it enough to show it has taken both true and false values. Indeed, a complex Boolean expression is composed with sub Boolean expressions, and these also have to have taken both true and false values. Plus, if two subexpressions always return the same value, it is suspicious: are they duplicated?

MLcov [1] is an open source code coverage measurement tool for Objective Caml developed by Esterel Technologies. MLcov only treats the functional and imperative features of Objective Caml, which correspond to the subset allowed by the coding rules of the Scade-to-C compiler. This subset remains quite large, for instance, it is sufficient to compile the standard library of the Objective Caml distribution.

Coverage is measured by instrumenting the source code of the program. With respect to Objective Caml, we state that an expression is covered as soon as its evaluation ends. The main idea of the instrumentation algorithm is to replace each expression expr with (let aux = expr in mark(); aux), where variable aux is not free in expr, and mark() is a side-effect allowing to record that this point of the program has been reached.

The new developed-in-Objective-Caml KCG is certified with respect to IEC 61508 and EN 50128 norms. It is used in several civil avionics DO-178B projects (e.g., for the A380 Airbus plane) and will be qualified simultaneously to the project qualifications (with DO-178B, the tools are not qualified by themselves, but by their usage in a project).

For common traditional processors, Qemu [2] is used as a free-software emulator (Power-PC, . . . ) which can generate traces. This allows non-intrusive analysis on final target code with emulators running on development hosts. In this part, the Adacore 9 company develops tools which are independent from the language, like Ada or C, and from the compiler, by using source DWARF [3] debug info. This independance implies additional yet several restrictions for MC/DC.

compiler in the debug mode. This information, called events, indicates the begin- ning or the end of an expression. With these events, the control flow graph of a program can be rebuilt during or after an execution. For MC/DC analysis more information is needed, so the original Objective Caml compiler has to be modified. This will be discussed in section 6.

Zam is a stack-based virtual machine for a functional-based multiparadigm pro- gramming language. It only uses 7 registers: an accumulator to store a value, a code pointer (next instruction to interpret), a stack pointer, another stack pointer for the highest exception handler, an extra arguments counter, an environment (a value array) and a global data (a value array). Zam interprets 146 different instruc- tions, about 60% of which are shortcuts for several instructions combinations. 18 instructions are for arithmetic and Boolean operations.

In Java code: The Java implementation, called Cadmium [7], allows an Ob- jective Caml program to be executed on any machine that has a Java Virtual Machine, without having to install the whole Objective Caml system. For in- stance, this can be used to easily run Objective Caml programs on a web page. Parts of its runtime library rely on Java runtime library such as garbage collection, the other part is in Java.

It is important to note that whereas Objective Caml is strongly statically typed, its virtual machine is untyped. This design was motivated by the guarantee that static type checking process frees the runtime process from making any type checks. Writing an Objective Caml virtual machine in Objective Caml implies writing an untyped virtual machine for a strongly typed programming language in a strongly typed programming language. It is analog with the runtime library: Objective Caml runtime library has two parts: the low-level part is a set of C functions that may access low-level data representations, and the high-level part is a set of Objective Caml functions that may use functions implemented in C code.

The first case is not trivial with an alternative bytecode interpreter. In our case, with Zamcov, C_CALL instructions will be interpreted by an Objective Caml function, and will mean calling an Objective Caml function. Thus, for instance, when calling a I/O operation (or any operation that cannot be directly represented by some bytecode instructions), an indirection is added. The source code in Objective Caml is compiled to bytecode, which is then interpreted by an Objective Caml program. For instance, to call a C function foo from the original virtual machine, the C_CALL instruction is used with "foo" as first argument and it will call the C function. This C function cannot be called directly at the interpretation of a C_CALL

Zamcov uses debug events and execution traces to check which expressions in the source code are covered or non-covered. Debug events contain information to associate bytecode instructions addresses to their corresponding source code. So, to report source code coverage, for each debug event, if its associated bytecode in- structions have been activated according to the execution traces, then its associated source code is covered. If a debug event cannot be related with the execution trace, it means that the associated expression is non-covered.

Objective Caml program (factorial). This report shows the source code files list of the coverage-measured program. Each file has a expression coverage rate which shows the dif- ference between the number of non-covered debug events and the total number of de- bug events. For each file, there is a link to its source code coverage. There is also an HTML link to the machine code coverage of the program.

x = 0 is never executed when calling fact 5, that is why the first 1 is non- covered. The structural coverage of this ex- ample is not complete. For function fact to be fully covered (expression coverage), we need to add more tests as shown in the screenshot on the left.

For more classical virtual machines, as the Java Virtual Machine (JVM) or the Common Language Runtime (CLR) of the .NET environment, we find a lot of li- braries to build debug tools. They offer a set of services which exposes runtime events that occur during the execution. In Java, JVMTI (Java Virtual Machine Tool Interface) 11 allows to write agents which can be notified of interesting occur- rences through events. In .NET, the CLR Profiling API can provide notification of many activities within the CLR and managed code.

A good overview describing different ways to instrument Java code is presented in [8]. This bibliographical study compares different static and dynamic instru- mentation techniques at source or bytecode level, including hybrid combinations, for Java. Examples using a specialized virtual machine are scarce, mainly for porta- bility and efficiency criteria which can be important for monitoring or optimizing tools.

This work takes place in the Coverage Project which studies non-intrusive cov- erage tools for Ada (to Power-PC) and Objective Caml (to Zam). In the first case the Qemu emulator is used and in the second the Zam virtual machine. But the compiler information needed by the modified runtime environment for the MC/DC measurement are similar for both languages.

