We describe a first proposal for a strategy language for Maude, to control the rewriting process and to be used at the object level instead of at the metalevel. We also describe a prototype implementation built over Full Maude using the metalevel and the metalanguage facilities provided by Maude. Finally, we include a series of examples that illustrate the main features of the proposed language.

In the Maude system, this need for providing strategies for controlling the rewriting process has been satisfied by developing strategies at the met- alevel. Taking advantage of the reflective properties of rewriting logic, the META-LEVEL module in Maude provides basic operations (also called descent functions) that reflect at the metalevel the processes of rule application and rewriting. Using these operations as basic building blocks, it is possible to de- fine at the metalevel a whole variety of internal strategy languages [5,3], that is, the strategy language is defined inside the same rewriting logic framework, instead of being defined as an add-on extralogical feature. Although reflection allows a complete control of the rewriting of a given term using the rewrite rules in a theory, for users unfamiliar with the metalevel there is a price to be paid both conceptually and notationally.

for the development of our language, including both ideas and examples, our design is quite different since, unlike ELAN, it is based on a strict separation between the rewrite rules and the strategy expressions, that are provided in separate modules. Thus, in our proposal it is not possible to use strategy expressions in the rewrite rules of a system module. In fact, this separation makes possible defining different strategy modules to control in different ways the rewrites of a single system module.

As also mentioned above, a key modularity principle followed in our lan- guage design is the strict separation between strategies and rules. The lan- guage allows defining strategy modules that associate specific strategies with system modules. In a system module (at the object level) there are no strat- egy expressions at all. Moreover, as already mentioned, we can have different strategy modules associated with the same system module.

A strategy expression of the form L[S]{B1 ... Bn} denotes a basic strat- egy that applies anywhere in a given state term the rule L with variables instantiated by means of the substitution S and using B1, ..., Bn as search expressions to check the rewrites in the condition of L. The number of rewrites appearing in the condition must be n for the expression to be meaningful.

With the previous combinators, we cannot force the application of a strategy to a specific subterm of the given initial term. In particular the scope of the substitution in the (x)match combinators is only the corresponding condition. We can have more control over the way different subterms of a given state are rewritten by means of the (x)matchrew combinators.

The version matchrew works in the same way, but performing matching only at the top. In both versions, when the condition is true it can be omitted. In ELAN and Stratego there is a strategy combination mechanism called congruence operators [2,13]. For each syntax constructor C there is a corre- sponding congruence operator, also denoted by C. If C is an n-ary construc- tor, then the corresponding congruence operator allows defining the strategy

Recursion is achieved by giving a name to a strategy expression and using this name in the strategy expression itself or in other related strategies. This is done in strategy+search modules (see Section 2.3). Concrete examples will be shown in Section 5.

A strategy expression denotes a function from terms (as states) to (pos- sibly infinite) sets of terms, denoting the successful states. More specifically, the resulting set of terms is a subset of the set of nodes of the computation tree in module M whose root is the given initial term for the strategy. If the result set is empty, then the strategy has failed on the initial term. In particular, independently of the term t, for the constants idle and fail we have idle(t)= {t}, and fail(t)= {}, the empty set.

whole strategy E also fails. The strategy expression E = matchrew t s.t. C by t1 using E1, ..., tn using En is the special case in which matching can only happen at the top, that is, the context c' is empty.

The function first receives a system module, a strategy+search module, and a path (initially this path is formed only by the root of the tree), and it returns the first successful path obtained from the given path. The func- tion next receives initially a successful path and returns the path to the next solution in the tree (or fail if there are no more solutions). They are im- plemented in a mutually recursive way, distinguishing cases on the strategy expression in the last node of the given path, and with the help of the met- alevel descent functions metaApply, metaXapply, metaMatch, and metaXmatch [4, Section 10.4].

Input/output of strategy+search modules and of commands for execution is accomplished by the predefined module LOOP-MODE, that provides a generic read-eval-print loop [4, Section 11.1]. This module has an operator [_,_,_] that can be seen as a persistent object with an input and output channel (the first and third arguments, respectively), and a state (given by its second ar- gument). Our prototype user interface has been implemented as an extension of Full Maude [4]. Full Maude maintains as the state of the loop object a database of modules entered into the system [6]. We have extended this state to maintain values of sort Path to remember the last result found. Then, we defined rewrite rules that describe the behaviour associated with the new com-

The first example is a simple game. You have a blackboard on which several natural numbers have been written. A legal move consists in selecting two numbers in the blackboard, removing them, and writing their arithmetic mean. The objective of the game is to get the greatest possible number written on the blackboard at the end. The specification of the game in Maude is also quite simple.

A player can choose the numbers randomly, or can follow some strategy. Possible strategies consist in taking always the two greatest numbers, or the two smallest, or taking the greatest and the smallest. The following module extends the BLACKBOARD module with operations to get the maximum or mini- mum number in a blackboard, and for removing an element in the blackboard.

This example illustrates how a strategy map(S), that applies a strategy S once to every element in a list, can be defined in our language. First we define a system module declaring lists of elements and a conditional rewrite rule that decomposes a list in its head and tail and whose conditions rewrite these components. This rule has been defined only for the purpose of defining the strategy and, as we shall see below, can be avoided.

The first possible implementation of map(S) (strategy map1 below) uses an if-then-else to distinguish between the empty and nonempty lists. If the state list matches the nil constructor then the constant idle strategy is used. If the list is nonempty, then the rule list is used and the strategy says how: it has to be applied at the top and its first rewrite condition has to be solved using the strategy S to rewrite the head of the list, and the second rewrite condition has to be solved using recursively the list strategy map(S).

The problem with this kind of implementation is that a rewrite rule has to be included for the only purpose of separating the components of the state term that have to be rewritten in a controlled way. The matchrew constructor can be used to solve this problem. It is used in the second implementation (strategy map2 below). In this case the orelse constructor is used to dis- tinguish cases (only for illustrating different possibilities). If the state list matches the nil constructor, then it is trivially successful. Otherwise, the list is decomposed with the pattern E L, and then E is rewritten using S and L is

The module CCS-SEMANTICS below contains the CCS semantics representa- tion without these tricks. 5 In this kind of representation, semantic transitions are represented as rewrites, and semantic rules are represented as conditional rewrite rules, where the main rewrite corresponds to the transition in the con- clusion of the semantic rule, and the condition rewrites correspond to tran- sitions in the premises. In CCS transitions are labelled with actions; in our Maude representation this label is part of the righthand side term, built with the {_}_ operator.

This strategy first checks if it has already obtained a solution. If this is the case, it finishes. Otherwise, it applies at the top the expand rule, using rules next to solve the condition; then, it checks if the extension is right, and continues recursively.

Strategy Sconf describes the correct protocol. The rules Mcom, McomNS, LinkListLoad, and PortNode (in the NETWORK module) describe the behaviour of the network [9,8]. Strategy Smediator controls the mediator. First, it tries to apply rule ChDemand-ok ensuring that Sconf is used to rewrite the condition. If this is not possible, then there is an error. Strategy checkNoConn checks that the rules Mcom or McomNS cannot be applied to the controlled network. This means that the desired connection does not exist, and the rule ChDemand-NoConn is applied. Otherwise, the problem is the lack of capacity, and the rule ChDemand-NoCap is applied.

The algorithm keeps two indices, one pointing to the next element to be inserted between the already sorted elements, and another pointing to the element which is being inserted. So in this case the memory needed by the strategy consists of two natural numbers. The following module defines the memory and the needed operations to change it as rewrite rules.

We have described and illustrated by means of examples a first proposal for a strategy+search language for Maude, to be used at the object level (as opposed to the metalevel) to control the rewriting process. We have also presented a prototype implementation built over Full Maude using the metalevel and the metalanguage facilities provided by Maude. There is however much more work to do. To begin with, the current prototype has to be extended in order to implement the missing capabilities, such as breadth-first search and depth bounds. Also, more examples need to be developed in order to validate the current proposal. Since this is still work in progress, it is at present difficult to do a full comparison with other languages such as ELAN and Stratego; this will be addressed in the future.

The current design of the strategy language could be extended by including new combinators; for example, congruence operators could be made available to the user, instead of having to simulate them by means of the matchrew com- binator. Stratego also provides combinators for composing generic traversals. The operator all(E) applies the strategy E to each of the direct subterms Ti of a constructor application C(T1,...,Tn). By using the all combinator generic traversals can be easily defined [13]:

Another extension we are studying is to consider strategy identifiers with parameters that can then be used in the corresponding strategy expressions. For example, using this idea we could rewrite the insertion sort strategy in Section 5.6 as follows, where there is no need to use a memory structure.

