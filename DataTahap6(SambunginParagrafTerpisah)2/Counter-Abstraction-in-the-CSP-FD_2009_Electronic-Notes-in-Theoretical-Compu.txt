It has been shown by Apt and Kozen [1] that this problem is in general undecidable. The best we can do is to restrict the verification to a particular class of systems and provide a method that is sound (but not necessarily complete) for this class. The systems that we are going to consider consist of a number of identical node processes. Given N , the number of node processes present in the system, the general form of such systems is

In most practical situations we can expect the context F to describe some con- troller process that is put in parallel with the nodes. The uniform verification of the family of problems with such a context has been proven by German and Sistla to be decidable [7]. However, the algorithm provided is double exponential and therefore the verification is only possible for very small instances of a problem.

The work that is probably the closest to ours is [18]. It considers systems of a similar structure to the one we use, and uses a model with synchronous communica- tion between processes. The verification algorithm consists of two parts. The first creates a finite abstraction, which is independent of the number of processes present in the concrete system. This is similar to our method, but instead of using a fixed threshold z (introduced in Section 4), it determines appropriate thresholds on-the- fly (at the expense of compilation complexity). The second part of the algorithm evaluates the CTL-X specification on the abstract state machine.

failures are used in system analysis in order to allow verification of specifications that talk not only about safety of the implementation (i.e. what the system can do), but also about the availability of events (i.e. what the system cannot refuse to do); and

It is important to note that here we have presented only a subset of the CSP syntax. However, since all our results are derived using operational semantics, they all apply to the full CSP language provided the processes are non-divergent and contain no termination events. The syntax presented in this section is only used for our running example.

In this section we present a transformation method, which generates a system that is bisimilar to N odes(N ). Each state in the new system is a tuple of integer counters, each counting how many node processes are in a given concrete state. We start by introducing our running example, and then describe the transformation itself.

The task of the scheduler is to divide the CPU time between the different pro- cesses. Let cores be the number of processors present in the system. Then the scheduler, below, consists of cores interleaved processes Core, each representing a single processor resource. We abstract away the details of the algorithm that the scheduler uses to decide which process should be given access to the CPU next (letting it pick any available process nondeterministically), and hence our analysis

The process Core, below, models a single CPU resource. When Core is idle it can run and become busy; and when busy, any of the events that imply that a process no longer needs CPU time (i.e. deschedule, block or terminate) brings it back to the idle state.

To create our implementation, we interleave all the node processes and put them in parallel with the scheduler process, synchronising on the common events. Finally we rename all the events that imply that a process no longer needs CPU time (i.e. deschedule, block or terminate) to a single event stopRun since, for specifica- tion verification purposes, we need not to distinguish why a process no longer needs a CPU.

Finally we would like our specification to say that we never have more than cores processes in the running state, i.e. the number of run events minus the number of stopRun events is never more than cores. Further, if there is at least one process running, then it can stop running, so the event stopRun is not refused. Finally, the events load and interrupt may or may not be available. Hence we define

In the previous section we showed how to create an abstraction of a concurrent system by using unbounded integer counters. Even though such an abstraction offers a dramatic decrease in the number of states by factoring the states with respect to bisimulation, it is likely that the state space will still be unbounded in size. More importantly, its size will still depend on N . In this section we present an improved abstraction method, where we introduce a threshold z for the values each of the counters can take.

We can easily generate CANodesz for our running example. The counter ab- straction will contain five counters, one for each of the states that a single node process can be in. Below are the first two branches of the definition; the other branches are similar and can be found in Appendix A.

of the counter-abstracted process CANodesz. Most of the parsing work is done by FDR: given a CSP script, it produces the concrete state machine of a single node process. Then the tool produces an output CSP script identical to the original one with the exception that the original definition of the process N odes is replaced by its counter-abstracted version.

The CSP script produced by TomCAT for the running example is below. Here States and Transitions define the set of states and transitions of the abstract state machine, respectively. Given a state s, incoming(s), self loops(s) and outgoing(s) are sets of transitions for which s is the end state only, both the start and the end state and the start state only, respectively. Each member of these sets is defined

Another possible area of improvement is the family of systems allowed for the application of our method. At the moment we do not allow the node processes to use the node identifiers inside their definitions, for otherwise the state space of the node processes would be dependent on N . This limits the number of systems that could be analysed using counter abstraction and FDR. We intend to address this problem using techniques from data independence [11,16] to collapse, within each node process, the type [0..N ) of node identifiers to some fixed finite type T , and then to proceed using the methods described in this paper.

