The soaring complexity in hardware and software systems has increased the demand for reliability and correctness, most noticeably in the high-integrity and safety- critical domains [1]. One effective way of achieving this goal is through the use of formal specification and verification. Nevertheless, no matter how useful those techniques might be, due to the sheer number of possible scenarios to investigate resulting from the concurrent interaction of different components, tool support is an imperative. For instance, the number of distinct behaviours to analyse can reach 107 distinct states on a parallel network of 1020 dinning philosophers and beyond [13]. In this paper, we are particularly interested in providing further tool support for refinement model checking the process algebra CSP [15] using its automatic tool FDR [7], hence we assume previous knowledge of both. CSP is a successful tech- nology with industrial-strength tool support that has been used for two decades. In this scenario, all observable behaviours are characterised by a Labelled Transition System (LTS) representing the (operational) semantics of CSP specifications [17, Chapter 4]. FDR is then used to exhaustively analyse those LTSs for various pur- poses, mainly refinement checking, determinism, and deadlock and livelock freedom. Due to the high-level of automation of model checking when compared with other formal verification techniques, such as theorem proving [2], the use of CSP and FDR became very attractive in both academia and industry.

Nevertheless, this kind of push-button technology, which enables automatic for- mal verification for correctness and refinement. This incurs quite some effort from the user in writing the appropriate CSP for FDR, which usually implies abstrac- tions towards bounded models. The problem is there is no thorough and definite guidance source, to the extent of our knowledge. Instead, one needs to sift through many different (and unrelated) sources. Assuming the user has good knowledge of CSP, our tool can help the FDR user to generate more efficient CSP code, as well as to find the cause of some obscure execution errors, such as communication outside a channel data type. Perhaps it can be better exploited as bridge between FDR and more high-level tools which write CSP code.

From the GUI, the user loads a specification, adds/performs refinement checks, and investigates debugging information visually. From the batch interface, the user could perform the same operations, but with textual feedback logged to the standard output. The batch interface can be useful for noninteractive checks, or checks over a network.

most compact LTS due to the structure of the process being described. Neverthe- less, bearing such structuring in mind proves very useful when checking complex or data intensive specifications [16,10]. This information might be interesting not only for the experienced CSP user handling complex specifications, but also for other tools that automatically generate CSP code, such as security analysis tools that use CSP for test-case generation [10,18]. By inspecting the object-model methods that are hidden in both top level interfaces available, we are able to tell exactly how, and under which circumstances, one can improve the compactness or efficiency of compiled CSP LTSs.

They represent a compiled state machine, and are the core functionality of FDR: refinement checks of LTSs compiled via a session object, usually from a CSP specification. That is, the underlying FDR server is generic enough to represent and model check not only CSP, but a particular category of LTSs. Obviously, the operational semantics of CSP fits into this category. Each ISM implements three functionalities: (i) LTS description; (ii) LTS structure; and (iii) LTS analysis. The LTS description is a database containing the process name, its original ASCII script, and the calculated alphabet of events used by the process it describes. More interest- ing is the LTS structure, which contains a detailed characterisation of the LTS, such as the refinement search root node, the initial events of each LTS node representing outgoing transitions, the next nodes reached through particular events, (minimal)

Once one model checking algorithm has been selected for a compiled ISM, the FDR server returns a hypothesis object. It represents an assertion about an ISM. A hypothesis object generates debugging information (or success reports) allowing the investigation of the cause of a refinement failure (or successful check). It also contains simple state defining whether the check has been performed or not, what the checking status is, and which parts of the LTS structure will affect the check.

It has detailed descriptions of witness(es) for a refinement failure. This information is separated in three functionalities: (i) debug context; (ii) debug tree; and (iii) behaviour of LTS nodes and their children. A debug context is the re- sult of testing the assertion a hypothesis object represents, and is present in the FDR GUI as a separate debugging window. It contains three kinds of information: (i) par- ticipant processes; (ii) debug trees of each participant; and (iii) witness(es) contain- ing the flawed behaviour of each participant. A debug tree represents the LTS of the flaw (or correct) process together with its characteristic behaviour. It is repre- sented in the FDR GUI as tree views of the participant processes. Although debug contexts can represent successful checks, behaviour objects are always related to refinement failures, and they contain detailed information about the acceptances (and refusals) of a particular LTS after some trace has taken place. They represent the allowed behaviours a debug tree characterises. This appears in the FDR GUI as small windows with contrasting information regarding acceptances (or refusals) at particular debug tree nodes. For successful checks, no debugging information is available to the user.

It represents a compiled CSP process as an LTS. They are based on the automata theory described in [3]. Apart from the trivial methods about the textual script this object represents, there are three sets of methods related to structure [17, Chapters 4, 8], algorithms [14,12], and compression [13]. The structural methods are given below: transitions: returns the LTS transitions. Each transition is represented by three numbers between braces (e.g., {10 3}), where the source node index (1) reaches the target node index (3) through an event number (0) placed between the two node indexes. This event number can be used in the event method to retrieve

divergences: returns the divergences of each node index as a list of boolean values. Thus, if the LTS contains four nodes, all of which are not divergent, the method returns a list of 4 boolean values set to false (or 0). For checks outside the failures-divergences (FD) model, this list is not calculated and every node index is assumed as not divergent.

afters(int, Str): returns a list of target node indexes reached from the source node index through the event name in the process alphabet. As LTSs are not complete, this is a partial method because not every node has transitions through every event. Thus, in such (partial) cases, the method returns an empty set of nodes. The same empty result is returned for terminal nodes as well, such as those representing deadlock (e.g., STOP), or successful termination (e.g., SKIP).

The inspection methods are the main methods one usually calls at the beginning of a refinement session. Firstly, the current session details, such as known processes and assertions, is logged. Next, a given list of processes (with actual parameters if needed) is compiled into ISMs, and detailed information about their structure are logged. After that, three hypotheses for determinism, and deadlock and live- lock freedom are automatically generated and checked. Finally, if these hypotheses are false, then information about the debug context they contain is logged. This includes not only the debugging context, but also all behaviours and debug trees in case of a refinement failure. If the script contains assertions about refinement checks, or if the user wants to perform any specific refinement, then the created hypothesis objects can be inspected in the same way. Alternatively, if the script has no parameterised process that demands actual parameters instantiation, no process list is needed and all processes from the current session are inspected automatically.

compileProcInModel(File,Session,Str,M): compiles the given process in the given model from a FDR Session object printing the results on the given file handle. Parameterised processes must be instantiated, otherwise the FDR server crashes. It returns the created ISM object to the user.

As a result of executing the inspection methods, four files are created and named skipX.csp.exp, where X will be either A, B, C, or D. They contain detailed infor- mation about each process ISM, as well as the 3 default hypothesis about determin- ism, and deadlock and livelock freedom already checked. If any of those checks fail, additional information about debug contexts, debug trees, and behaviours are also logged. Finally, if one wants to perform operations over the FDR objects returned, it can be done directly by manually calling methods. The object name to use is the one FDR returns. Thus, we could type a command, such as

In this paper we present a new interface to the CSP [15] refinement model checker FDR [7], which extends one of the available user interface APIs. It allows extended control over debugging information, as well as investigation of hidden features of the LTS data structure used to represent compiled CSP specifications for refinement model checking. With this tool it was possible to carefully study the operational semantics of CSP, hence develop an operational semantics for a concurrent language similar to CSP [4]. It has also been used by other people in test case generation using CSP and FDR, and Java code generation tools for this new concurrent language.

The main contribution of the FDR Explorer API is that it enables better inte- gration between CSP script generation tools [18], as well as improved information to the user. This appears as the ability to investigate witness information at dif- ferent points of the LTS, or reasoning about more space-efficient representations of CSP processes. These functionalities are not available from the original FDR interfaces. This also follows the trend of tool integration set out by one of the UK Grand Challenges in Computer Research [1].

Finally, we explain how we transformed the available CSP LTS transitions into a graph notation format with visualisation tool support [8]. This is the first step towards integration with a visualisation tool for CSP. Going further, one could provide the translation the other way round, hence enabling drawing graphs that would formally represent CSP specifications and could be directly passed to FDR for refinement checks.

