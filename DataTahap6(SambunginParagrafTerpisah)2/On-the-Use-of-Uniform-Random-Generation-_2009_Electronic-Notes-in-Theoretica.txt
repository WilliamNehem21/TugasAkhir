Developing efficient and automatic testing techniques is one of the major challenges facing software vali- dation community. In this paper, we show how a uniform random generation process of finite automata, developed in a recent work by Bassino and Nicaud, is relevant for many faces of automatic testing. The main contribution is to show how to combine two major testing approaches: model-based testing and ran- dom testing. This leads to a new testing technique successfully experimented on a realistic case study. We also illustrate how the power of random testing, applied on a Chinese Postman Problem implementation, points out an error in a well-known algorithm. Finally, we provide some statistics on model-based testing algorithms.

Producing secure, safe and bug-free programs is one of most challenging problem of modern computer science. In this context, two complementary approaches ad- dress this problem: verification and testing. On one hand, verification techniques mathematically prove that a code or a model of an application is safe. However, complexity bound makes verification difficult to apply on large-sized systems. On the other hand, testing techniques do not provide any proof but are relevant, in provide (in Section 4) some statistics on test suites generated in a pure model based testing approach based on FSM coverage. Such statistics may be relevant in order to help the validation engineer to choose among different existing testing techniques. We think such statistics can be also useful in order to have a better understanding of coverage criteria.

given automaton and a given coverage criterion implemented into an test generation algorithm, a given number of tests. This approach reuses the results of previous section on the statistics of test suites. Notice that this approach can not be used to reduce a test suite; its goal is to increase the number of tests that would have been obtained using the selected test generation algorithm on the original automaton.

From previous research and teaching experiments we had designed a formal model of the system, written as a B abstract machine [2] anda Java implementation, along with a number of mutants of this implementation. Each mutant is a variation of the original implementation, in which a mistake has been introduced on purpose. This technique is used to evaluate the quality of a test suite: the more mutants are killed, the more efficient is the test suite.

When running the tests, we are looking for a non-conformance between the results obtained by the implementation, and the expected results given by the model. This conformance relationship is based on observing the outputs of the different commands, that are supposed to return a status code indicating if the command succeeded or failed, and why, depending on the value of the error code. A test fails if the codes do not correspond at a given step of the execution of the test.

These results shows that the average length of the tests suites is relatively similar for a given number of final states. The computation time decreases with the increase of the number of final states. Intuitively, this is due to the fact that adding final states add backward transitions that simplify the search for the optimal path in the Chinese Postman algorithm. However, the resulting test cases are longer, and

The main idea of random testing is that randomness is not influenced by the tester. In this context, a crucial issue is to perform uniform generation, i.e. every element has the same chance to be selected by the algorithm. Otherwise, selected values are related to the chosen algorithms, what is precisely opposed to the main idea. The result presented in [5] is therefore interesting, opening many possibilities to test algorithms that manipulate labeled graphs (e.g. the traveling salesman algorithm).

We randomly generate strongly connected finite automata and we ask the tested program to provide a minimal path starting from the initial state and using all transitions. Generating 30 deterministic automata with 8 states on a 20 letters alphabet, we point out an automaton making the program fail (a smaller automaton causing the program failure and obtained with a larger test suite is provided in appendix A). It is not the purpose of the paper to discuss why there is a problem in the code, just notice that it is the indexing of an array out of its bounds. We fixed this bug and we did several random tests on both the implementations, that did not reveal other errors on the original program nor side-effects introduced when fixing the bug.

First, we have explored an original combination of random and model based testing, through a technique that makes it possible to augment the size of a test suite. Second, we have illustrated how random testing can be employed to detect bugs, even on a well-known and widely-spread algorithm. Third and finally, we have provided some experimental data and statistics on several test generation algorithms based on automata.

The work proposed in this paper is based on a random approach [9,16]. Even if such an approach is usually presented as one of the poorest way of generating data, it has been experienced as an efficient way for finding errors, confidence into the software [15]. Random testing can be employed for generating test data, such as in DART [13]. The DART approach consists in combining static and dynamic program analysis in order to test software.

Recently, random path generation has been explored in several testing works. In [10], Dwyer and al. expose how to include a random process in Depth-First Search algorithms in order to get better test suites. The work [12] show how perform random walks in a model is deeply influenced by the topology of the model. To tackle this problem, an algorithm to generate uniformly a path of a given length is provided and successfully experimented on very large models.

The test generation technique that we propose differs by proposing a test se- quence length-guided approach. It can be seen as the automated test generation of test purposes for the TGV tool, motivated by the goal of providing a user-defined number of tests (increasing the number of tests that would have been obtained) when the test generation process is applied. To the best of our knowledge, this approach has never been targeted before.

