where P is a program, h, hj are heaps and ts, tsj are states of the threads. The semantic domains of these values are defined in the following way. First, we provide the description of programs: Prog = [Cnames ~fin CDesc]. Programs are partial functions with finite domain that associate class descriptions from CDesc with class names from Cnames. The class names are just appropriately defined identifiers, the class descriptions are defined as CDesc = [Mnames ~fin MDesc] i.e. partial functions with finite domains that associate method descriptions MDesc with the method names. Again the method names are just appropriate identifiers while the method descriptions are somewhat more complicated and defined as

Note that the value written by put does not have to be accessible by other threads immediately. In fact, any part of heap may be synchronized with the thread cache at any point of program execution, with Java Memory Model constraints preserved. In particular, the two halfs of a category-2 value may be synchronized independently.

This instruction can modify the state of threads by trying to acquire or release a monitor. The operation itself is done by modifying an object on the heap. The monitor instruction expects one location on the operand stack: the object with which the monitor in question is associated. The general form of the instruction is monitor (op), where op is either enter or exit .

This instruction returns from the current method. It reads the operand stack and modifies the method frame stack by removing the current frame and updating the previous frame: moving the pc to the next instructions (usually over an invoke instruction) and updating the operand stack by pushing the return value, after the floating-point value set conversion [12, Section 3.8.3]. The general form of the instruction is return(l) where l is a list of kinds of length at most 1.

This instruction takes no parameters, it reads and removes the location of the exception form the stack and changes the evaluation state of the current thread (the rule ex-throw ). The way the exceptions are handled in our semantics is the following. The evaluation state (est) component of each thread says if the execution is in the normal state, when est = null, or in exception handling state otherwise.

Note that the switch to the latter state can be done not only by executing the throw instruction but also by throwing an exception (e.g. NullPointerException) by other semantic rules. If est = e is a location of a valid exception, the remaining rules ex-in-handle, ex-out-handle or ex-term-handle can be fired, depending on the fact whether the exception is handled inside the current method or provokes its abrupt termination. In the latter case, the ex-term-handle rule handles the special case where the current method is the last on the method frame stack. This rule does not have a direct correspondence in [12], just like the rule n-term-return.

The feature which is not handled is the release of monitor when a synchronized method is abruptly terminated by an exception. Note however that this can be sim- ulated by adding a catch-all exception handler which would execute the instruction monitor(exit) and then rethrow the exception. See also the discussion at the end of Section 3.9.

The functionality of a few instructions cannot be expressed by semantical transfor- mation of the runtime structures as their meaning is not described in JVM speci- fication [12]. These are breakpoint, impdep1, impdep2, and the instruction with the opcode 186. 7 Therefore, they are omitted from the paper. The opcode wide is taken into account along with the non-wide operations.

We have presented a concise formalisation of JVML which turns out to be factoris- able into 12 instruction mnemonics. This was possible because we separated generic operation of many instructions and tabularised particular behaviours of individual opcodes. In this way we rigorously reduced the overall complexity of the whole language without significantly sacrificing its features.

