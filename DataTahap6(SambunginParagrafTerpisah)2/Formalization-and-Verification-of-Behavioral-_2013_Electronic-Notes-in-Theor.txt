Dynamic Software Updating (DSU) is a technique of updating running software systems on-the-fly. Whereas there are some studies on the correctness of dynamic updating, they focus on how to deploy updates correctly at the code level, e.g., if procedures refer to the data of correct types. However, little attention has been paid to the correctness of the dynamic updating at the behavior level, e.g., if systems after being updated behave as expected, and if unexpected behaviors can never occur. We present an algebraic methodology of specifying dynamic updates and verifying their behavioral correctness by using off-the-shelf theorem proving and model checking tools. By theorem proving we can show that systems after being updated indeed satisfy their desired properties, and by model checking we can detect potential errors. Our methodology is general in that: (1) it can be applied to three updating models that are mainly used in current DSU systems; and

Dynamic software updating (DSU) is a promising software maintenance technique for updating running software systems on the fly without incurring downtime. Like repairing a machine that is operating at full speed, dynamic updates must be highly reliable to guarantee the systems after being updated must behave as expected. That is because target systems that need dynamic updating are usually mission- critical. They need to provide 24x7 services, such as traffic control systems and financial transaction systems. Therefore, it is important to guarantee a dynamic update is correct and it can be correctly performed to the target system.

Our method is general from the following two perspectives. Firstly, it can be used to formalize three main dynamic updating models, i.e., interrupt model, in- voke model, and relaxed consistency model (see Section 2.1 for details), which are widely used in current dynamic software updating systems. We can formalize in the methodology the dynamic updates that conform to one of the three models. Secondly, we formalize the design of dynamic updates instead of the codes, which is different from other existing approaches e.g., the formalizations of dynamic updates in C-like programs in [12] and [13]. Hence, our formalism is not restricted to the dynamic updates that are developed in certain program models.

Dynamic software updating is different from static updating. The latter is a tra- ditional approach to evolving software into newer versions by stopping running systems, applying updates and then restarting systems again. However, dynamic updating supports on-the-fly updates to the running systems without shutting them down.

A number of systems have been designed and implemented to support dynami- cally updating software systems, such as Podus [10], OPUS [1], Ginseng [17], POLUS [6]. They are specific to dynamic updates to certain class of software systems. For instance, Ginseng supports dynamic updates to single-threaded systems, and PO- LUS supports those to multi-threaded ones. Both only support dynamic updates to the systems developed in the C language.

updates to active code until they are inactive [21]. However, the evolution to the new system always occurs immediately upon the resumption of systems. A number of dynamic updating systems are based on interrupt model, such as Podus [10], Ginseng [17], and those in [5,21,20].

Behavioral correctness means that the behavior of the systems after being updated must be correct. Formally, a dynamic update is behaviorally correct if the system after being updated by it satisfies its desired properties. Such properties depend on concrete systems, and usually describe the differences between the old and new systems. For instance, version 1.1.2 of the vsftpd FTP server introduced a feature that limits the number of connections from a single host. If we update a running vsftpd server of an earlier version to version 1.1.2, one of the desired properties of the server after being updated is that the number of connections from a single host will never exceed the maximal connection number.

The basic idea of protocol A and B is that there is a shared Boolean variable locked indicating whether critical section is available. Each process waits at the pre-critical section (ps) to enter the critical section (cs) until locked becomes false. It sets locked true, and enters the critical section. It sets locked false when it is leaving the critical section. The difference is that in protocol A checking the value of locked and setting locked true are two separate operations, while in protocol B they are treated as an atomic one. It is well-known that protocol A does not satisfy the mutual exclusion property.

We can specify OTSs and verify their desired properties by existing algebraic lan- guages and verification systems. CafeOBJ is such a language in which OTSs are tailored to be specified [19]. CafeOBJ is also a powerful rewrite system which is often used as a proof assistant [8]. We can also translate CafeOBJ specifications of OTSs into Maude [23], a sibling algebraic language of CafeOBJ but supporting model checking [7]. we can model check the desired properties of OTSs with the generated Maude specifications.

In CafeOBJ, objects are classified by sorts. A sort denotes a kind of objects. For instance, sort Bool denotes a class of Boolean values true and false, which are represented by two constants true and false of Bool. In this paper, we use sorts Sys, Pid and Label to denote the classes of system states, processes, and program counters such as rs, ps, and cs (which are represented by constants rs, ps, and cs respectively).

We successfully proved by CafeOBJ that the system after being updated indeed satisfies the mutual exclusion property. The proof is based on structural induction. Three lemmas are needed in the proof. We omit the details of the proof due to the limit of space.

However, some properties may fail to be satisfied by an updated system. In that situation, counterexamples of the properties are desired to refute the properties being verified. We can specify OTSs in Maude as rewrite theories and model check them with desired properties.

possible solutions to redesign the updates. For instance, the above counterexample shows the reason why deadlock occurs is that the value of lockedB is set true when update takes place. There are two possible solutions. One is to set an update point where lockedA is false and perform the update in the invoke model. The other choice is to force lockB to be false, regardless of the value of lockA when the update takes place in the interrupt model.

In an earlier study, Gupta et al. introduced the notion of validity to dynamic updates [12]. Informally, an update is called valid if a reachable state in a new system can be eventually reached from the state where the update takes place in the old system. However, the definition of validity, as being observed by Hayden et al., is both too restrictive and too permissive [13]. They proposed to define the correctness of dynamic updates by the properties that are specific to concrete dynamic updates [13]. In our work, we explicitly call the properties behavioral properties, to differentiate them from the code-level properties.

[4] are only applicable to the updates of single-threaded systems, but not to the updates of distributed systems. Anderson has provided a definition of safe dynamic updates for behavioral properties of concurrent programs [2]. However, only type safety property is considered in the definition. In our approach, we focus on the design of the old and new systems and updates, which makes our formalization approach more general but not restricted to certain programming models.

We have introduced a notion of behavioral correctness of dynamic updates, and motivated the need of it with a concrete example. A dynamic update is called behaviorally correct if expected behavior must happen after it is performed. We proposed an algebraic methodology of specifying dynamic updates and verifying their behavioral properties. The methodology can be applied to the formaliza- tions of three dynamic updating models, which are widely implemented in dynamic software updating systems. Unlike most of the existing formalizations of dynamic updates, our methodology is not restricted to the dynamic updates developed in certain program models. With our formalization methodology, we can verify the

In ongoing work, we plan to apply our approach to the verification of more com- plicated dynamic updates. One candidate is the update from a flawed authentica- tion protocol NSPK (Needham-Schroeder Public Key Protocol) [18] to its modified version NSLPK [15] (which has been verified to satisfy the mutual authentication property). The property of interest is that after being updated, the system should satisfy the mutual authentication property.

