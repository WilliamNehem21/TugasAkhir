Graphical diagrams are the main modelling constructs offered by the popular modelling language UML. Because textual representations of models also have their benefits, we investigated the integration of textual and graphical modelling languages, by comparing two approaches. One approach uses grammarware and the other uses modelware. As a case study, we implemented two versions of a textual alternative for Activity Diagrams, which is an example of a surface language. This paper describes our surface language, the two approaches, and the two implementations that follow these approaches.

The popular modelling language UML offers graphical diagrams for the con- struction of models. Research has shown, however, that graphical languages are not inherently superior to textual languages [16] and that both types of languages have their benefits. Therefore, we investigate the integration of textual and graphical languages, to be able to exploit the benefits of both types of languages.

The remainder of this paper is organized as follows: Section 2 introduces a num- ber of relevant concepts. A specification of the surface language we implemented, and a description of its embedding in the UML and the transformation from surface language to Activities is given in Section 3. The approach based on grammars is de- scribed in Section 4, and the approach based on models and metamodels is described in Section 5. A number of other applications involving the integration of textual and graphical languages, and the transformation of models constructed using multiple languages are discussed in Section 6. Section 7 discusses how our work relates to earlier work. We draw conclusions and discuss future work in Section 8.

which Actions are executed is based on the flow of tokens. There are two kinds of to- kens: control tokens and object tokens. ControlFlows, which are depicted by arrows connecting ActivityNodes, show how control tokens flow from one ActivityNode to the other. ObjectFlows, which are depicted by arrows connecting OutputPins and InputPins, show how object tokens flow from one Action producing an object to another Action that uses this object.

Every model conforms to a metamodel, which defines the elements that play a role in the model. If a model conforms to a certain metamodel, each element of the model is an instance of an element in that metamodel. The UML defines a number of diagrams, which can be used to depict certain parts of a model. There are diagrams that depict the structure of a model, diagrams that depict the behaviour of parts of the model, etc. These diagrams offer a graphical representation for instances of elements in the metamodel.

A surface language offers an alternative notation for these diagrams. In our case, instead of a graphical representation, a textual representation is given for instances of elements of the metamodel. Other names for surface languages are surface action languages or action languages.

OpaqueBehavior uses a list of text fragments and a list of language names to specify behaviour. The first list specifies the behaviour in one or more textual languages and the second list specifies which languages are used in the first list. OpaqueBehavior can be used to specify behaviour using, for instance, fragments of Java code or natural language. In our case, the first list contains a specification of behaviour using our surface language and the second list indicates that we use this surface language.

In this section, we describe the implementation of our surface language that uses a tool for text-to-text transformations. Tools for text-to-text transformations are often referred to as grammarware. We start by describing our approach in Section 4.1. Section 4.2 describes the tools we used for the implementation and some important aspects of the implementation.

The first step of the transformation makes it possible to retrieve the identifier of an element in the second step. Each element in the XMI representation of a UML model has a unique identifier. Actions that refer to other elements, such as AddVari- ableValueActions and CreateObjectActions, refer to these other elements using their identifiers. An AddVariableValueAction refers to a Variable using the identifier of that Variable; a CreateObjectAction refers to a Classifier using the identifier of that Classifier.

We implemented the transformation described in Section 3.3 following the approach described in Section 4.1 in the language ASF+SDF [21], using an IDE for that language, called the Meta-Environment. We give a short description of this language and discuss some of the details of our implementation below.

The language ASF+SDF is a combination of the two formalisms ASF and SDF. SDF stands for Syntax Definition Formalism. It is a formalism for the definition of the syntax of context-free languages. ASF stands for Algebraic Specification Formalism. It is a formalism for the definition of conditional rewrite rules. Given a syntax definition in SDF of the source and target language, ASF can be used to define a transformation from the source language to the target language.

Both SDF and ASF specifications can be exported by the Meta-Environment. The exported SDF specification can then be used by command line tools to produce parse trees and transform parse trees to text. The exported ASF specification can be compiled to a fast command line tool suited for the transformation of such parse trees.

A disadvantage of the current implementation is that it can only parse one vari- ant of XMI. Most tools that import or export files in the XMI format use their own interpretation of the format. These vendor specific interpretations are often incom- patible with other interpretations. Because of this, our implementation is limited

This section describes the implementation of our surface language using tools for model-to-text, text-to-model and model-to-model transformations. Tools that can perform transformations related to models are often referred to as modelware. Sec- tion 5.1 describes our approach. Section 5.2 describes the tools we used for the implementation and some important aspects of the implementation.

An advantage of this approach is that all transformations can be performed from within one and the same modelling environment. In contrast to the approach de- scribed in Section 4.1, no models have to be imported or exported during the trans- formation process.

The openArchitectureWare platform offers a number of tools related to model trans- formation: Xpand is used for model-to-text transformations, Xtext [3] is used for text-to-model transformations and Xtend is used for model-to-model transforma- tions. Xpand and Xtend are based on the same type system and expression lan- guage. The type system offers simple types, such as string, Boolean and integer, collection types, such as list and set, and the possibility to import metamodels. The expression language offers a number of basic constructs that can be used to create expressions, such as literals, operators, quantifiers and switch expressions.

We use Xtext to parse and convert the extracted fragments of surface language to a format that is readable by Xtend. Because Xtext uses ANTLR, the class of textual representations that can be parsed is restricted to those that can be described by an LL(k) grammar. A disadvantage of using Xtext is that we had to modify our grammar for this reason.

Dinh-Trong, Ghosh and France propose an Action Language based on the syntax of Java [2]. We decided not to implement their Action Language because their defini- tion of the language contains a number of primitive types and Java constructs whose relation to the UML is not specified. Other important features of their language are that parameters that serve as input or output of an Activity and attributes with multiplicity greater than one are not taken into account.

Haustein and Pleumann propose a surface language that is an extension of the OCL [4,10]. They embed OCL expressions in their language by adding an Action to the UML that evaluates an OCL expression and returns the resulting value. We took a different approach, because we wanted to design and implement a simple alternative for activity diagrams that did not rely on or incorporate other languages. Incorporating an expression language like the OCL in our language would introduce a large number of language constructs that have no relation to our primary interest, which is the specification of behaviour.

SDF is based on SGLR, a scannerless generalized LR parser [22]. As an alternative to using SDF, SGLR can be used to parse textual representations of models. Since SGLR can parse arbitrary languages with a context-free syntax and context-free languages are closed under union, multiple syntax definitions can be combined into one without any modifications to the original syntax definitions, as is the case for SDF.

After parsing the textual representations of models, the resulting parse trees have to be transformed. Besides using special purpose transformation tools, generic programming languages can be used to manipulate the parse trees. The source transformation language TXL [1] is an example of a special purpose language. Paige and Radjenovic [14], and Liang and Dingel [9] have experimented with TXL in the context of model transformation. Although their research also deals with using grammarware for transformations related to models, it differs from ours because it does not focus on the integration of text-based and metamodel-based languages.

TCS [7] is an alternative for Xtext. It is suited for both text-to-model and model- to-text transformations, and uses one specification to define the transformations in both directions. In the case of TCS, the main constructs are called templates. These templates are similar to the rules of Xtext; each template specifies the textual representation of an instance of an element of the metamodel.

The approach using grammarware transforms models containing fragments of surface language to plain models by rewriting the XMI representations of these models. A downside of this approach is that dealing with the XMI representation of models lowers the level of abstraction of these transformations. The current implementation can only parse one variant of XMI, but a future extension that introduces an intermediate language poses a solution for this shortcoming.

