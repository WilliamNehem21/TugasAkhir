We describe ongoing work in which we aim to formally specify a correctness condition for transactional memory (TM) called Weakest Reasonable Condition (WRC ), and to facilitate fully formal and machine- checked proofs that TM implementations satisfy the condition. To precisely define the WRC condition, we express it using an I/O automaton. We similarly present another condition, called PRAG, which is more restrictive, but more closely reflects intuition about common TM implementation techniques. We sketch a simulation proof that PRAG implements WRC, allowing ourselves and others to focus more pragmatically on proofs of such implementations. We are working on modeling these conditions in the PVS language so that we can construct and check such proofs precisely and mechanically. We are also working towards proving that some popular TM implementations satisfy the PRAG condition, starting with simple coarse- grained versions and refining them to model realistic implementations.

Because TM implementations aim to hide some of the complexity of concur- rent programming in system software, it is important that they be correct. We are therefore pursuing a long-term goal of developing formal and machine-checked correctness proofs for TM implementations. We hope to follow an approach that we have already used to verify a range of concurrent algorithms [2,3,5], specify- ing both the permitted behaviour and the behaviour of the algorithm using I/O automata (IOAs) [11], and using simulation proof techniques [12] to show that an algorithm implements a given specification. We construct these proofs using the PVS verification system [13], so our proofs can be entirely machine-checked.

In defining a correctness condition for TM, we have several goals beyond provid- ing an unambiguous and precise definition that supports formal machine-checkable proofs: The condition must make sufficient semantic guarantees to be useful to pro- grammers using TM. It should be easy to understand and reason about, so that researchers and implementors can prove that TM implementations satisfy the con- dition. And it should be as permissive as possible to avoid arbitrarily excluding implementation techniques, including ones not yet invented.

In Section 2 we describe I/O automata, proof techniques, TM interfaces, and notation used in the rest of the paper. Sections 3 and 4 introduce the WRC cor- rectness condition and relate it to two previous conditions. We present the PRAG condition in Section 5, and then sketch a simulation proof that it implies the WRC condition in Section 6. We briefly discuss our ongoing and future work in Section 7.

Most TM implementations assume a specific type of object called a read-write memory. For this reason, our PRAG automaton is specialised for a read-write memory. A read-write memory maps a set L of locations to a set V of values. When used by a set T of transactions, its interface is:

These actions, together with actions of internal(TM(O)), determine the behaviour of a TM system modeled this way. In Sections 3 and 5, we use such models to specify two notions of correct behaviour for a TM system. In our ongoing work, we also use such automata to model TM implementations. We can then use simulation proofs to prove that one correctness condition implements another (see Section 6 for a sketch of one such proof), or that a TM implementation implements a condition.

We were working towards our WRC condition to overcome what we saw as shortcomings of opacity (see below) before we became aware of VWC. At first we thought that our condition would be strictly weaker than both opacity and VWC. However, as it turns out, WRC excludes behaviours exhibited by both opacity and VWC, while capturing the best features of both. We explain below.

Finally, an interesting subtlety of opacity is that it is not prefix-closed. For example, a read executed by one transaction may not be justified until later when another transaction writes the value it read. In this case, the prefix of the execution up to the read does not satisfy opacity, whereas later, when the write has occurred in a transaction that has invoked its commit operation, it can.

The interfaces and assumptions used to define VWC differ in several ways from those of WRC and opacity, which leads to significant differences in what conditions can be expressed, and what executions are allowed. VWC is defined only for the limited case of a read-write memory in which no two writes ever write the same value. Furthermore, unlike the interfaces of opacity and WRC, VWC does not model transaction commit as an interval with an invocation and a response, which prevents it from allowing the flexibility of opacity and of WRC to allow executions in which a read is justified by a write of a transaction that ultimately does not commit. Finally, VWC allows aborted transactions to ignore committed transactions that precede them in real time. This appears to derive from an assumption that transactions are the only means of communication, which we do not assume.

Because t2 reads 0 from x, t2 must be ordered before t1, which opacity allows. However, the PRAG automaton must commit t1 before OK1, and therefore before t2 invokes commit. Thus, when t2 executes its doCommitWriter action, its validation will fail, as its read set is not consistent with the last state installed by t1. Thus, PRAG does not allow this execution.

We believe that every execution allowed by PRAG is also allowed by opacity, but we have not formally proved this. It may be interesting or useful to express opacity (restricted to executions whose prefixes all satisfy opacity, of course) as an automa- ton, and to formally prove these relationships. However, we are more interested in identifying conditions that are useful in practice than in precise characterisations of relationships to previous conditions.

We now describe the proof. The correspondence between initial states is im- mediate. For the inductive part of the proof, the choice of WRC action(s) for a given action of PRAG is fairly straightforward. For an internal action, the prestate and the poststate of PRAG map to the same state of WRC, so no step is taken by WRC. For external actions other than respt(v) and respt(ok), we take the same action in WRC. For respt(v) and respt(ok), we choose a snapt action followed by the respt action itself. (Although PRAG does not exploit the flexibility afforded by having a separate snapt action, we need a snapshot to satisfy the preconditions of the respt action, so we take one immediately before such actions.)

That the validation conditions hold for commitOkt and abortedt follows from observation a) above. Because the commit-index order is consistent with extOrder, there is some serialisation that is consistent with both orders. Furthermore, because a transaction executing the commitOk action is in ECT, and one executing the aborted action is not in ECT, such a serialisation satisfies the appropriate validation condition for each of these actions.

We are starting with a simple version of the popular TL2 TM algorithm [4]. This simple version, called TL2-CG, uses coarser-grained synchronisation than is consistent with current multiprocessor architectures, but allows us to illustrate some key ideas in our approach. Future work includes refining TL2-CG to successively more realistic implementations, ultimately proving a realistic model of the TL2 implementation correct. We aim to make it easy to reuse parts of the proof, for example to prove variants on the algorithm, of which there are many.

One important aspect of our work is to eliminate the need to prove backward simulations [12], which are particularly challenging, and are necessary for many TM implementations. To this end, as in our previous work [3,5], we plan to identify one or more general intermediate automata that we can prove (using backward simulation proofs) implement PRAG. The idea is that we and others can then prove the correctness of a TM implementation by proving that it implements one of these intermediate automata using only forward simulation.

