Total correctness and partial correctness are obviously intimately linked. The difference between them is the issue of whether or not the program will terminate and so deliver any result at all. But partial correctness cannot simply be extracted from total correctness just by setting aside the question of termination. Nor can total correctness be reconstructed purely from partial correctness.

Q , i.e. establish Q if it terminates at all. Although the predicate trans- formers wlp(A, ) and wp(A, ) are both positively conjunctive, which is to say they distribute across non-empty conjunctions, only wlp(A, ) is univer- sally conjunctive, which is to say in addition it maps the empty conjunction, true, to itself. The necessary logical relationship between the two predicate- transformers is expressed by the law of our abstract command language with the completely chaotic program we call anarchy which is our refinement bottom. But, operationally speaking at least, our infinite loop is completely deterministic since it can never terminate. General correctness must faithfully reflect its guaranteed non-termination. The standard way to achieve this, as Nelson explains in [22], is to use an- other ordering and define recursions as least fixed-points with respect to this instead. The ordering in question is the so-called Egli-Milner approximation ordering: when A and B are programs, we say A approximates B if for every postcondition Q

In fact later we will define abstract command iteration constructively using natural induction, as did Dijkstra originally in [3] for the do ... od of his guarded command language. Thus we avoid any appeal to the Egli-Milner ordering and fixed-point theory. Nevertheless, to introduce a more complete notion of recursion into our abstract command language we would have to employ Egli-Milner.

We call the collection within the alphabet of variables on which an ab- stract command acts its frame. Our operational intuition is that these are the variables to which the command may assign values. We denote the frame of an abstract command A by frame(A). An abstract command may make passive reference to variables in the alphabet outside its frame. For example, the frame of x := y is just x although it makes passive reference to y too. The frame may be empty as in skip, or as in x < 7 | skip which makes only passive reference to x . We distinguish between skip and x := x since they have different frames.

unbounded choice: takes the form @z . A where A is an abstract command, and z is fresh with respect to the current alphabet. The alphabet of A is understood as the current alphabet augmented by z . The unbounded choice @z . A represents A attenuated by a demonic choice of any value for variable

We have already encountered one fundamental predicate of an abstract com- mand A: its termination predicate, trm(A), which characterises from where execution of A is guaranteed to terminate, and is therefore safe from the risk of non-termination. Several other important characteristic predicates are as- sociated with A. The names of most of them are adopted like trm from [1] where they are used for corresponding predicates defined for generalised sub- stitutions.

parallel composition: takes the form A || B where A and B are abstract commands. Execution proceeds until A and B have both terminated, and the result, if any, is the composite effect of A and B . Here, rather than specify wlp(A || B, ) directly, it is convenient to specify prd (A || B ). As usual the frames are merged, so we have

In our case this merge is the straightforward feasible fusion [2] of the two sets of results. Where the respective effects of A and B on a common variable are wholly irreconcilable A || B is infeasible. We defined a similar parallel composition in [6] for generalised substitutions. Our definition here is actually simpler than that one, since total correctness induces a dependency between the trm and prd of a generalised substitution which is not mirrored in general correctness, where trm and prd are independent of each other.

concert: takes the form A#B , where A and B are abstract commands. It represents parallel execution of A and B on disjoint copies of their respective frames in a termination pact. These concerted executions proceed until either terminates. The overall result, if any, is determined entirely by whichever has terminated. Their frames are merged, so we have

We might imagine concert being concretely implemented in, say, a Unix/C en- vironment by the parent process forking two subsidiary processes, then waiting for either to terminate, upon which it just kills off the other one. Thus concert offers us the means of refining a decidable specification into a concurrently ex- ecuting pair of semi-decidable programs. We illustrate this in the next section with a domestic allegory.

