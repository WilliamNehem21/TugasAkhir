CCS with Communication Keys (CCSK) [8] is a reversible version of CCS which can be used to model and analyse bidirectional behaviour of systems, for example the binding and unbinding of molecules in biochemical reactions. The definition of CCSK is given in the Structural Operational Semantics (SOS) style, and the SOS approach is also employed to give a procedure for converting operators of other pro- cess algebras into reversible operators [8]. The main idea is that dynamic operators (which can be destroyed in the course of a transition) are converted by the proce- dure into static operators (which are preserved), using new auxiliary operators. For instance, both sides of a choice P + Q are retained. As a result process terms in the new reversible language do not change their overall structure during computation. A crucial component of the procedure is the notion of communication keys. These are unique identifiers that are assigned to, and are recorded in the syntax of, past actions and are vital for the communication mechanism to work correctly in the forward and reverse directions. In contrast, in RCCS [2] past behaviour, including communication, is stored on external devices such as memories.

In the literature, a labelled transition system, or lts for short, may or may not have an initial state. Let us deem an ltr to be a structure that specifies a transition relation with no initial state and an lts to be an ltr with an initial state. Thus an lts can be seen as a rooted ltr.

Example 3.4 Consider the parallel switch of [10, Example 1.1.7], where the bulb will light if either of two switches is closed. This is an example of so-called or- causation where a disjunction of events causes an event. We have event b (bulb) respectively. They are clearly FR bisimilar, and they have auto-concurrency and auto-causation, respectively. Note that CCSK processes a | a and a.a are not FR bisimilar: using the notation from [8] we have that after performing a, a we get to

If one performs a and then b with the a | b component on the left, then these must be matched by the a and then the b of the ((a + c) | b) summand on the right. (Matching it with the a of (a | (b + c)) is wrong as after this a action is performed, no c is possible after a in a | b.) The right hand side can now reverse a and do a c (still using the same summand as all other summands are disabled). The left hand side cannot match this: the component a[m] | b[n] can regress by a[m] to a | b[n] but it cannot perform any c.

It remains to prove that is is order-preserving. We shall show a <C b if and only if a <D b for all appropriate events (identified by their labels) a, b. Assume for contradiction that a <C b and not a <D b. The last means that there is a path involving transitions for all events of D such that it contains no a before b. Hence, this path has a after b. We reverse the transitions in this path and, since S(C, D), we match them with the corresponding transitions from C. Therefore, we get a path in C with a after b. Since a <C b implies that every path that has b contains also a, we have that a path in C has two occurrences of a: contradiction.

