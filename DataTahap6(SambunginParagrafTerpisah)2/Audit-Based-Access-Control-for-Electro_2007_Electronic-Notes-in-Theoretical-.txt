Increasingly often, sensitive data needs to be accessed and exchanged across com- plex and distributed computer systems. To protect data confidentiality, numerous distributed access control mechanisms have been developed. Typically, these sys- tems try to prevent illegitimate actions before their occurrence, by deciding on the fly if access should be granted or not.

In this paper we show how the Audit Logic [4,7], an a-posteriori access control framework, can be used in the EHR setting. In the Audit Logic framework, a-priori access control is minimized to the mere authentication of users and objects, and their basic authorizations. More complex security procedures are performed in an a-posteriori auditing mechanism. Here we formalize a scenario involving medical personnel and health records to show how this access control mechanism works in practice. Finally we discuss the main advantages and drawbacks of using an a-posteriori access control mechanism rather than a preventive one in the specific EHR scenario.

Rissanen et al. [11] address the issue of how to override safely the decisions of a preventive access control system called the Privilege Calculus. At each override a procedure starts to find the appropriate authority which is notified to audit the override. In our approach there is only a minimal preventive access control mecha- nism, which can not be overriden. Moreover, in our approach it is up to the auditors to decide when and which users to audit.

not be nested inside another says predicate, to keep the language decidable. This restriction is absent in the Audit Logic, and it was shown that the corresponding logic is semi-decidable [5]. Halpern and Weissman [8] also use first-order logic to model security policies. Their setting is centralized and they do not consider a special connective to express delegations.

In the context of DRM, a type of a-posteriori access control was proposed by Shmatikov and Talcott [14]. There, a reputation-based trust management (TM) model is presented, in which the reputation of individual agents is determined by the fulfilment or violation of (DRM) licenses. We believe that Trust Management [10], coupled with auditing, may be an interesting solution, especially in large distributed EHR systems.

giveDrug(a, b, c), expressing that a administers b a drug c. Policies are built using a set of atomic predicates, which can be either permissions, or conditions. The basic permission is owns(a, d) expressing that a owns d. Additionally, one may have scenario-specific predicates such as mayRead(a, d), expressing the permission that a may execute the reads action on d, or the condition isNurse(a), expressing that agent a is a nurse. Complex policies are built from permissions and conditions using logical connectives. The grammar of the policy language is [4]:

is executed at the session layer, where it may be caught in an audit trail. At the same time the logging device must create a tuple containing the logged action, its time-stamp and possibly other parameters, which can be used as evidence in an audit later on [4]. To prevent that users forge their logs, some secure device is needed that takes care of this logging.

