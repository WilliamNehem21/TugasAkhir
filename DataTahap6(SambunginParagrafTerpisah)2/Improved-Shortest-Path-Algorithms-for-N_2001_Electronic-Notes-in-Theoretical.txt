The Fibonacci heap [3], 2-3 heap [5], and trinomial heap [6] support insert and decrease key in O(1) time, and delete min in O(log n) time. Since every vertex is visited there are n insert and n delete min operations. The number of decrease key operations is O(m) since this corresponds to the number of edges in the graph. Thus, the overall time complexity when a Fibonacci heap, 2-3 heap, or trinomial heap, is used for F is O(m + n log n).

The distance updates in Algorithm 3 are restricted from propagating between trees. Even though this is not strictly necessary for the algorithm to work, for now it makes the explanation simpler. A more efficient version of this algorithm, which is not presented, allows the distance updates to be less re- strictive, which can reduce the number of distance updates during the second updating pass.

For the second updating pass, only trigger vertices are involved in the frontier set, F , and solution set, S. At lines 5 and 6, the trigger vertex, u, which has minimum d[u], is selected and removed from F . Call this the minimum trigger vertex. This vertex is then added to the solution set, S.

As was mentioned, the updates for shortest path distances in the new algo- rithm were deliberately limited to make the description simpler. An improved version of the algorithm can allow distance updates to propagate between trig- ger vertices during the first updating pass, without changing the correctness of the algorithm. Then, if during the second updating pass, the distance to a vertex, v, does not update, the algorithm does not need to continue distance updates past v. By terminating the search at vertices which do not update, on average there may be a slight gain in time efficiency, even though the worst case time complexity will not change.

Further work for possible improvements to this algorithm includes general- ising from tree decomposition to a special form of acyclic decompositions. For an acyclic part A resulting from decomposition of the graph, there must be only one trigger vertex ancestor, u, of vertices in A. Thus, now a trigger vertex u triggers updates into its acyclic part instead of a tree structure. This allows the selection of trigger vertices to be less restrictive, reducing the number of trigger vertices, and number of delete min operations that must occur.

The new all-pairs algorithm consists of two stages. Algorithm 5 shows the first stage, and Algorithm 6 shows the second stage. The algorithm uses a two dimensional array, D, to hold shortest path distances as the computation proceeds. At the end of the algorithm, array D holds the shortest path dis- tance between any pair of vertices. In the algorithm, the reference array, d, is used for referring to a row in D. Updating the shortest path calculation through vertices in T , can be done efficiently, since the graph induced by T is acyclic. The algorithm uses a topological ordering of vertices in T , stored in an ordered set, L, which can be obtained in O(m + n) time. A graph, P , whose vertices correspond to triggers, is constructed by the first stage of the algorithm, and used by GSS for calculating shortest path distances through vertices in T .

If for a given graph, k is large and v is small, the new algorithm can give significant improvement over the previous shortest path algorithms [4]. Other implementations of this algorithm are possible which are more efficient by a constant factor. More efficient implementations can avoid distance updates from a vertex, v, when d[v] is still infinite. One such algorithm uses two sep- arate depth first search (DFS) like functions, where one of the DFS functions only traverses edges and does not update shortest path distances.

For nearly acyclic graphs, it is possible to solve the generalised single source problem in O(m + v log v) time, where v is the number of trigger vertices, with trigger vertices defined as roots of trees that result when the graph is decomposed into trees. This gives an improvement on existing shortest path algorithms for nearly acyclic graphs from Abuaiadh and Kingston [1] and Takaoka [4]. It is possible to combine this new algorithm and the previous algorithms into a hybrid algorithm which incorporates the properties of each. Future work involves generalising from tree decomposition to an acyclic de- composition, in order to allow a reduced number of trigger vertices.

