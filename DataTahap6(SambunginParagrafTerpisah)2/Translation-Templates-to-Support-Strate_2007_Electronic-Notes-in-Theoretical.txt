The task of developing strategies for proving classes of properties in a theorem prover divides naturally into at least two phases. The first phase is the formulation for the prover of problem specifications, i.e., of settings and assertions to be proved

In the formulation phase, a tension arises between convenience for the formulator and the ultimate convenience for the theorem prover. In particular, the specification formulation most natural to a user may not be the ideal formulation for reasoning about properties of the specification in a theorem prover. One way to alleviate the tension is to provide an intermediate layer between the specifier and the prover that translates specifications expressed in a form natural to the user into a form more convenient for the prover.

In this paper, we focus on the integration of the theorem prover PVS [27] into the TIOA (Timed Input/Output Automata) [9] system development framework. A combination of PVS features make PVS a good choice for theorem proving support in TIOA. First, the higher order nature of PVS allows the use of function-valued state variables in representing the state of an automaton. This is useful, for ex- ample, when there are state variables parameterized by a parameter whose type is uninterpreted (e.g., in a concurrent or distributed system, a parameter of type process). As will be seen below, the higher order constructs in PVS also provide a convenient method of treating periods of continuous state evolution in an automaton analogously to atomic state transitions. Second, as described in [2,1], the fact that PVS saves rerunnable proof scripts and supports automated assertion labeling and proof comments facilitates the implementation, as PVS strategies, of proof steps using which users can create PVS proof scripts of properties visibly, if roughly, iso- morphic to high level hand proofs. This paper describes how the translation scheme central to our integration of PVS into TIOA produces PVS specifications structured by templates to support the creation of PVS strategies of this nature implement- ing reasoning steps suited to proving invariant and simulation properties of TIOA specifications.

The paper is organized as follows: Section 2 discusses how the work described in this paper relates to other work. Section 3 provides some background on the TIOA toolkit and on the PVS interface TAME used to integrate PVS into the toolkit. Section 4 describes the TIOA framework and its specification language. Section 5 describes a set of templates we designed for use in the TAME representations of TIOA specifications, and explains how they facilitate reusing old and developing new PVS strategies for TAME for reasoning about specification properties. Section 6 discusses how the TIOA-to-PVS translator in the toolkit has evolved from producing nearly literal translations of TIOA specifications to producing translations that

Various tools have been previously developed for translating specifications in the IOA (Input/Output Automata) language [8,10], the predecessor of the TIOA language, into the language of different theorem provers, including the Larch Prover [6,11], Isabelle [28,24,22,23], and PVS [7]. A previous translator from TIOA (and hence IOA) to PVS is described in [18]. The translator described in this pa- per, which is derived from the translator in [18], is the first TIOA-to-PVS translator designed especially to support strategy development.

mechanized proof steps that correspond to reasoning steps typical in high level hand proofs of automaton properties including invariant and simulation properties. The proof steps are implemented as PVS strategies. Through building automatic translators of specifications to PVS specifications that instantiate TAME templates and implementing additional, setting-specific TAME proof steps as PVS strategies, TAME has been adapted to provide theorem proving support in several settings [3].

for the specification, analysis, and refinement of distributed and concurrent sys- tems. TIOA specifications model a system as an automaton with a set of states, one or more initial states, actions that cause state transitions, and trajectories. The TIOA specification language extends the IOA (Input/Output Automata or I/O Au- tomata) language [8,10], which has been in use (initially informally) for nearly two decades (see, e.g., [19,12,22,26]), by adding constructs for defining trajectories that describe how a system state can evolve as the result of time passage. Complex systems can be modeled as a composition of automata; like I/O Automata, Timed I/O Automata can be composed by joining output actions to input actions.

A TIOA specification consists of the definition of one or more automaton models, together with the definition of properties of interest of these automata and, if needed, a vocabulary in which types, constants, and operators referred to in the automaton definitions are declared. With some exceptions (such as enumerated types), the semantics of the declarations in a specification vocabulary used in analysis of the specification is provided by way of the analysis tool being used. Thus, when PVS is applied to proving that certain properties of interest hold for automata specified in TIOA, the vocabulary takes its semantics from some appropriate PVS theory.

declaration of each variable of fischer specifies its name, type, and initial value. Specifying the initial value of a variable is optional; the TIOA language also allows initially clause to constrain, or further constrain, the variable values in a start state. No initially clause is needed in the specification of fischer.

This section begins with an overview of the current translation scheme employed by the TIOA-to-PVS translator. It then discusses the issues involved with previously used (or considered) translation schemes and, for each issue, discusses how it was solved by updating the translation scheme to follow templates updated to improve strategy support (including those discussed in Section 5). An important goal of the TIOA-to-PVS translator is to avoid forcing the user to change the form of a TIOA specification to support adherence of its PVS translation to a particular template. As will be seen below, with some minor exceptions, we have achieved this goal. For a more complete description of the translator and the translation scheme, we refer the reader to [18].

This scheme asserts the start state condition using a conjunction of clauses, and asserts the initial values of function (i.e., array) valued state variables in terms of assertions universally quantified over their arguments (indices). Thus, when (as is often the case) there are state variables of function type, reasoning about the start state at the state variable level is not supported, and automated support for the reasoning about the start state is complicated by the presence of quantifiers.

Initial solution; new issue. To solve this problem, we embed the trajectory as a functional parameter of the time passage action. This approach allows us to use the functional parameter F to assert properties throughout the duration of the trajectory using a FORALL quantifier.

This translation scheme, however, poses problems in proofs and strategies when we only want to reason about a specific component of the trajectory definition. For example, when we only want to reason about how the evolve clause of the trajectory affects the state variables, we still have to deal with the entire universally quantified expression covering all three clauses. In addition, we have to identify the evolve clause component of the expression under the quantifier, which may not be straightforward to do, as this expression is not guaranteed to be a conjunction of three subexpressions.

The issue. In an earlier version of the TIOA to TAME translation scheme, the where clause stating the relationship among the automaton parameters was trans- lated as an additional clause conjoined to the start predicate. Then, an invariant duplicating the where clause is specified, proved, and used in other invariants re- quiring the use of the assertion about the automaton parameters. This invariant is trivially proved 5 , because it is by definition true in the start state, and because the values of the automaton parameters are never modified by any transitions. In par- ticular, applied to the automaton fischer, the earlier translation scheme produces the following form of the start predicate, which has an additional clause conjoined:

Solution. To relieve the user from having to prove the additional invariant lemma for every parameterized automaton and to apply the invariant to introduce the constraints in other proofs, the translation scheme has been modified to translate the where clause as a separate axiom named const facts. This decision allows the user to invoke the axiom directly with a standard TAME proof step (also called const facts 6 ) rather than introducing the information by applying an invariant lemma. It also allows separation of concerns between constraints on the start state and the parameters.

The use of explicit substitution tends to be more efficient in terms of theorem proving, because the translator has done the work of computing the final value of each variable, allowing reasoning about individual variables to be performed easily. For short programs, the explicit substitution method also produces more compact code. On the other hand, for longer programs which might have deep levels of dependencies among variables, the explicit substitution method may yield more complicated expressions. In such cases, translation using the LET keyword may produce a simpler translation which corresponds more clearly to the original program.

The issue. In our current translation scheme, the preconditions and transitions are defined separately, in the enabled predicate and the trans function respectively. This is done first, because it is a natural separation of concerns, and second, because it allows proofs of properties to reflect which preconditions, if any, are actually used. But a side effect of this separation is that some unprovable Type Correctness Conditions (TCCs) may be generated by PVS as a result of the translation. As an illustration, consider the following TIOA transition, where z is some state variable:

The issue. When an invariant of a TIOA specification contains two or more consecutive universal quantifiers, a direct translation of these quantifiers into PVS can complicate automatic reasoning in PVS. For example, it makes it difficult for the TAME strategy auto induct to coordinate the skolemization of the inductive conclusion with the instantiation of the inductive hypothesis in the induction step.

The TAME strategy base case is not normally invoked directly by the user; rather, it is invoked by the strategy auto induct (see Section 5) that does the initial steps of the induction proof of an automaton state invariant. In opera- tion, base case first computes the assertion representing the base case of the in- duction. The hypothesis of this assertion is that the start state predicate start holds for some state s. The template form of start is a conjunction whose first component associates explicit values with some state variables and whose second component provides additional constraints on the values of the variables (see Sec- tion 6.2). Using standard PVS steps for decomposing conjunctions and labeling the new formulas that are produced, base case breaks the hypothesis into two parts labeled start-state and start-constraints. This allows auto induct to con- tinue by substituting for s based on the formula start-state and then attempting to complete the proof by applying simplifications. This discharges the base case automatically in many cases.

with traj substituted for a and prestate (the pre-state of the trajectory action) substituted for s. The strategy apply traj evolve is then able to compute the value of F(T) (representing the state after time T) by instantiating the above for- mula with T and then using the PVS definition expansion command to expand traj evolve. Finally, apply traj evolve uses a PVS command to replace F(T) by its value wherever it occurs.

The strategy deadline reason, when given an absolute time deadline D as a parameter, tries to prove that, on the current trajectory traj, absolute time cannot pass beyond time D. It does this by first applying apply traj stop to time T = D - now, and then using apply traj evolve to compute F(T) so that traj stop(traj)(F(T)) can be evaluated. (If it evaluates to true, the trajectory traj must stop after time T, i.e., at absolute time D.)

In this paper we have considered a particular case of a general problem: How to provide efficient theorem proving support in an interactive, higher order logic prover for establishing properties of a model of some given class, without forcing the user of the theorem prover to specify the model for the convenience of the prover rather than in a form natural to the user. In the case of automata models of systems, we have shown that this can be done by translating specifications written in a language designed for specifying automata (TIOA) into the language of a theorem prover (PVS) while adhering to a set of templates governing how various aspects of the automaton model are represented in the theorem prover. We have discussed how both the structural and naming conventions captured in these templates can be used to advantage in developing efficient domain specific proof steps aimed at interactive reasoning about the aspects of an automaton model for which there are templates.

