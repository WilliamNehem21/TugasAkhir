Structured documents are usually processed by tree-based document transformers, which transform the document tree representing the structure of the input docu- ment into another tree structure. Event-based document transformers, by contrast, recognize the input as a stream of parsing events, i. e. lexical tokens, and process the events one by one in an event-driven manner. Event-based document trans- formers have advantages that they need less memory space and that they are more tolerant of large inputs, compared to tree-based transformers, which construct the intermediate tree representation.

This paper proposes an algorithm which derives an event-based transformer from a given specification of a document transformation over a tree structure. The deriva- tion of an event-based transformer is carried out in the framework of attribute gram- mars. We first obtain an attribute grammar which processes a stream of parsing events, by applying a deforestation method; We then derive an attribute evaluation scheme relevant to the event-based transformation. Using this algorithm, one can develop event-based document transformers in a more declarative style than directly programming over the stream of parsing events.

ment formats, e. g., HTML for Web presentation, LATEX for typesetting, and most notably the XML (Extensible Markup Language) standard [1], which is intended to serve as a common data representation for seamless data ex- change among multiple platforms. Due to the increasing amount of data being exchanged in structured document formats, the technology for transforming structured documents is getting more significant.

A conventional scheme for document transformation is a tree-based scheme, where a transformation is defined as an operation over document trees, which model the hierarchical structure of structured documents. A tree-based trans- formation first constructs a document tree of the input document on the memory, manipulates the document tree, and translates back the transformed document tree into the result document. Due to its high expressiveness for describing document transformations, the tree-based transformation scheme is widely used in practice (e. g., an XML transformation language XSLT [2] and Document Object Model (DOM) [3]).

The tree-based transformations, however, have a drawback that they must once load the entire document on the memory before starting tree manipula- tions. This indicates that the size of documents to be processed by a tree-based transformation must fit into the actual memory size. This could be a sever problem, when the size of the input document is very large, or when the size of the memory is relatively small.

Here we are faced with a tension between efficiency and expressiveness. An event-based document transformer may dramatically reduce the memory us- age, especially that for simple document transformations. On the other hand, event-based transformers have less expressive power than tree-based transfor- mations. Due to the poor structure awareness, event-based transformations are harder to program than tree-based ones and therefore they are usually used only for those relatively simple transformations. In addition, the event- based transformations have another drawback that it is difficult to maintain:

An event-based document transformer should be a one-pass interactive program. A document transformer is called one-pass if it traverses the stream of the input parsing events only once; An event-based document transformer is called interactive, if it writes to an output stream simultaneously as it reads from the input stream, responding to each parsing event. To obtain such a one-pass interactive transformer, we need to find a method for deriving an appropriate attribute evaluator from the deforested AG specification.

In this paper, we propose an algorithm which systematically derives a one- pass interactive event-based program from an AG specification. We solve the above mentioned difficulty by separating each semantic rule into two parts: attribute dependency and value construction. The former can be computed by looking into the input event stream statically, and it turns out that de- pendency patterns range over a finite domain. We can therefore model an evaluation scheme by a finite state transition machine, where the state space is the set of dependency patterns and state transitions are incurred by parsing events. We need not care about forward dependencies any more, since the state transition is subject to the dependency pattern, but not to individual attribute dependencies. The remaining part of attribute evaluation, i. e. the value construction, is dynamically computed for each transition, by letting each attribute hold the partially determined attribute value. The finite state machine incrementally outputs the result of transformation, by writing out

The rest of the paper is organized as follows: Section 2 defines the present problem in a more formal setting. In Section 3, we present our algorithm through a simple example. Section 4 discusses what document transformations are definable in our framework and discusses extension to the present work. Finally, Section 5 concludes the paper.

Each <tagname> represents a start tag named tagname, and </> an end tag, which has no tag name. A document is well-formed, if start tags and end tags are balanced in the usual sense. (Unlike XML, tag names are omitted from end tags for simplicity. They are redundant information in a well-formed document indeed.) The depth of a well-formed document is the maximum level of nesting, with the outermost level being 1. The above document has the depth 3, for example.

presentation such as HTML and LATEX do not have a bounded depth in gen- eral. However, a sufficiently large number would serve as a bound for practical uses. In the present paper, we do not discuss transformations for documents of an arbitrary depth, leaving it to a future investigation.

ing error. Unbalanced tags are detected in a similar manner, by the other fi- nite stack represented by the set of inherited attributes stack h1, . . . , stack hd. Each parsing event of a start tag pushes an empty node onto the stack, and it will be later popped and used as the end of the child nodes when the matching end tag appears.

We notice that the choice of the running example is only for explanatory purpose. Even the simple example is enough for demonstrating what are the difficulties of the present problem and how we can solve the problems. Our algorithm can be applied to any transformation specified by an AG which satisfies the conditions in Section 2.2. We will discuss in Section 4 what transformations can be expressed under the restriction.

In the first phase of the derivation, we obtain a single deforested AG, which does not produce any intermediate data, from the composite specification of a document transformation. For this purpose, we simply apply the existing descriptional composition method to the present problem. This section is not intended to be formal but to give a short summary of the descriptional composition method through the running example. For a detailed, formal definition of the algorithm, readers are deferred to [10,11,8,9].

Projection. The first step is projection, which derives an intermediate repre- sentation of the composed AG, where the intermediate data constructions be- tween the two AGs are not eliminated yet. In the intermediate representation, we temporarily write e.a to denote an attribute occurrence on an arbitrary expression e.

Forward dependencies are troublesome for one-pass attribute evaluation. In the present example, suppose the current event be Begin A. To complete the process of the current event, a one-pass attribute evaluator would need the values of h2 and h1 , which are to be passed for processing the next coming event. However, the values of h2 and h1 are dependent to s2 and s3 , resp., whose values are obtained only after the next event is processed. Therefore the one-pass evaluator gets stuck here.

Though the state transition rule can be statically determined by an anal- ysis on attribute dependencies, it remains unsolved how to compute attribute values during transitions. The solution in this paper is to let each attribute carry a partially evaluated value. A partially evaluated value is expressed by a unary function, which returns the fully evaluated value when it is applied to a value of the not-yet evaluated attribute.

The state transition machine changes the syntactic representation of par- tially evaluated values for every state transition, and only the partially eval- uated values for inherited attributes are passed during state transitions. We use meta-variables Xinh1 ,..., Xinhh to denote those partially evaluated val- ues of inherited attributes, and the meta-variables may occur in a symbolic representation to refer to the partially evaluated attributes of the inherited attributes passed from the preceding parsing state.

An event-based interactive program, which uses the list representation of attribute values, is derived by the following translation algorithm. We assume that flush is a primitive command which takes a concatenation list of parsing events and write out the events to the output stream. If the argument is [Undef], the command aborts the execution with a notification of an error to the other end of the output stream. We also assume a primitive command exit terminates the execution successfully.

The proposed algorithm can automatically derive an event-based document transformation program, but it only applies to those AG specifications which satisfy the quasi-SSUR condition (Section 2.2). This section shows how several significant transformations can be defined under the restriction and suggests an extension of the present framework for relaxing the restriction.

First, simple filters such as tag renaming, elimination of unnecessary tags, replacement of particular nodes, etc. are easily defined in a quasi-SSUR AG. Our algorithm works for those simple filters and the resulting transformer does not construct any extra intermediate data. Furthermore, we can compose these simple filters together to construct a more complicated transformation. The composition of filters can be processed by a repeated application of the descriptional composition, due to the SSUR closure property [11, Soundness Theorem]. This provides a more modular way for constructing event-based transformers than directly programming with SAX API.

The other class of typical document transformations, context-dependent transformations, are more difficult to define in quasi-SSUR AGs. Consider a context-dependent transformation which eliminates every B node whose im- mediate parent is an A node. One might define this transformation as follows.

The idea in this definition is to let every node compute two attributes val and elim, which hold the result of transformation for the two possible different contexts respectively, and to let parent nodes select either of them appropriately. However, this AG is not quasi-SSUR, since it has duplicated uses of T1.elim in the second production rule.

Remark. The degree of the reduction in the memory usage achieved by the derived event-based program varies, depending on each transformation. Our algorithm is not intended to achieve a reduction in the memory usage for all the transformations but only tries to minimize the memory usage for each transformation.

earlier events later. This indicates that it is inherently difficult to avoid the buffering of events this transformation. The problem resides in the transfor- mation itself, and hence no event-based transformer would be able to achieve a reasonable reduction in the memory usage. Therefore, when our algorithm is applied to this transformation, the derived event-based transformer, instead of constructing a document tree, would need to buffer all the parsing events into a list. We thus would not gain a remarkable improvement on the the memory usage for this transformation.

As we have seen above, our algorithm can derive event-based document trans- formers for a class of simple document filters and their combinations effectively and also a context-dependent transformation. We believe that a certain class of context-dependent transformations can be likewise expressed as above in quasi-SSUR AGs. However, the method used above for expressing the context- dependent transformation would not scale up: the result of transformation is carried around by a set of attributes representing varying results for different contexts. The semantic rules must be carefully coded so that they respect the complicated context-dependency.

We have given an algorithm which derives a one-pass event-based document transformation program from a tree-based specification of a document trans- formation. We have formalized the problem in the framework of attribute grammars (AGs) and have solved it by an application of the descriptional com- position followed by a derivation of an interactive attribute evaluator based on an analysis of attribute dependency graphs. The contribution of the present paper is the algorithm for deriving the evaluator. The algorithm generates a

The authors implemented the algorithm in a prototype program which gen- erates event-based transformers over the simple XML-like markup language given in Section 2.1. They are currently working for the extension mentioned in Section 4.2. The extension would bring a great increase in the expressive- ness of document tree transformation. The extension would be also useful for enriching document structure with embedded plain texts and unordered labeled data (i. e., character data and attributes, resp., in XML jargon). We hope that we will be able to report the result of the extension in a foreseeable future.

