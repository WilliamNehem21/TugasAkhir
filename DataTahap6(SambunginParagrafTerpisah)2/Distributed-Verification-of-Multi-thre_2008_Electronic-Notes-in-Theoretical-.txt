The applicability of model checking algorithms is limited by the main mem- ory resources due to the so-called state explosion problem. Several memory-limited model checking algorithms have been developed, e.g., [16,20,24], but still the mem- ory remains the core problem in dealing with large programs. Though with the advent of 64-bit machines, the theoretical limit of RAM has increased to 16 Ex- ibytes, the limitations imposed by the hardware and the operating systems hardly allow to use more than 64 Gigabytes of RAM. The use of virtual memory as a remedy to the state space explosion in model checking can instead slow down the performance significantly.

The model checker offers different blind and directed search algorithms, includ- ing depth-first search, breadth-first search, best-first search, IDA*, and A* [26]. The types of safety errors addressed by the model checker include: deadlocks, segmen- tation faults, assertion violations, etc. The model checker branches the execution on threads (either derived from a base class or in form of POSIX pthreads) or on variable ranges. For search guidance, it offers a range of state-to-error estimates including the active process heuristics to accelerate the search for deadlocks.

A state in StEAM consists of registers, stack frames, global variables and mem- ory pool. The state size grows with every memory allocation in the program and can easily reach several megabytes. Hence, one of the most important challenges for program model checking on the object code level is the tremendous size of the state vector.

predecessor information to reconstruct the solution path, and the transition used to generate the mini-state. Additional information include its depth and heuristic estimate to the target state that are used to order the states for expansion. All in all, a mini-state has a constant size in contrast to a state that can change its size due to dynamic memory allocation.

We implemented separate caches, one for the data section, one for the binary section, one for the stack contents, and one for the rest of the system state. All of the components can be individually flushed to and read from disk. We will refer this method as external collapse compression. For the data and binary section, we incrementally check at construction time, whether a change has occurred; for the stack, we check for redundancies at insertion time. In all three cases, the cache is realized by using an AVL tree sorted by the individual hash values.

In order to avoid an infinite behavior while reading the MPI queue [Line 8], we set a limit on the number of mini-states that are extracted in one scan. The limit is set in the MAX MSG input parameter that is compared against the variable counter [Line 20]. Similarly, the flag idle reported is used to avoid repeatedly sending the IDLE messages to the root.

We tried a hash-based distribution as proposed by Stern and Dill [30] with a linear hash function defined on the full state vector. Such a distribution is effective if, with high probability, the successors of a state expanded at a particular com- puting node are also mapped to the same node. This results in low communication overhead. In our case, with states of huge sizes, such a partitioning can be costly as computing the hash function is expensive. As one solution to the problem, StEAM offers the option for incremental hashing that relies on the hash difference between the state and its successor only [27].

We implemented external exploration on top of our tool StEAM. The distributed exploration is realized through MPI. The experiments are performed on a Cluster- Vision cluster of workstations. The cluster consists of 224 computing nodes with a total of 464 processors running OpenSuSe 10. We used the set of nodes consisting of two AMD Opteron DP 250 (2.4 GHz) processors each, connected by infiniband. Maximum number of parallel processes was 32.

For the 200 dining philosophers problem, each state was 32KB long. 4 nodes solved the problem with 90GB of external memory consumption in transfer files. A total of 2,256,037 states were generated till a deadlock was found. The states were almost uniformly distributed over the 4 nodes. That implies that for 0.51 million states per node, a total of 16GB is needed in the RAM. But due to externaliza- tion and collapse compression each node consumed a maximum of 1.5GB of RAM including the 500MB MPI overhead.

We have also solved the dinning philosophers instance for 600 philosophers with a state size of 97KB. For 6 computing nodes it took 74 minutes, while con- suming 60 GB of hard disk space for transfer files and generating a total of 761K states. Parallel depth-first search with a depth-slicing of 100 layers was used. The deadlock was found at layer 2193. For a smaller number of computing nodes, the time exceeded the bounds on the cluster queue.

recent extension contributes an external memory variant of the same algorithm [4]. Recently, with the advent of multi-core machines, the trend is directed towards verification on multi-core machines. Multi-core machines offer the advantage of having negligible overhead for state transfers due to shared memory. Holzmann and Bosnacki [21] presented a method for multi-core extension of Spin where the safety analysis is applicable to N-core systems but the fair cycle detection to verify

With this work, we have contributed an integrated design for distributed and large- scale verification of C++ programs. As the analysis is on the object code no ab- straction takes place and the expressivity of concurrent C++ is preserved. The novelty and the algorithmic challenge lies in tackling the states of large sizes. We employed a dual-channel communication that combines MPI and NFS media. In- stead of the full state, only a signature is sent over MPI. The full state vector is flushed to disk in transfer files.

The experimental results are promising. We observe an almost linear speed up in all examples. Future work includes the integration of dynamic load balancing and the evaluation of larger C++ models. Even though we could report the full exploration of sample instances, for infinite state systems, the algorithm can run forever. In future, we also plan to accelerate the I/O operations by a more efficient block flushing of transfer states or using databases [8].

