In this paper, we discuss examples of reasoning rules for augmented constraint diagrams which exhibit interesting properties or difficulties that can arise when developing rules for such a dia- grammatic system. We do not present a complete set of rules, but investigate the generic problems arising, providing solutions. One problem corresponds to the nesting of quantifiers and another relates to the domain of universal quantification. These issues may be an important considera- tion in the definition of other logical reasoning systems which explicitly represent quantification diagrammatically.

Of course, reasoning could take place at the level of diagram semantics by writing proofs in first order predicate logic (FOPL). Some diagrammatic transformation rules correspond to simple FOPL transformations. However, some FOPL rules translate into complicated diagrammatic rules and some di- agrammatic transformations correspond to non-trivial FOPL transformations. To maintain the advantage gained by providing a formal diagrammatic nota- tion, we would like to reason between diagrams rather than between diagram semantics.

In sections 3 and 4, we describe rules which have strong preconditions and are designed to make small changes to the diagram syntax. Giving strong preconditions makes it easier to assess whether the rules are valid (assists reasoning about the system). This makes it easier to describe the changes that take place when the rule is applied, and simple rules are useful for automatic proof-writing algorithms. However, simple rules are applicable in fewer cases (hindering reasoning with the system).

In section 5 we show how to combine simple rules to make derived rules which are more widely applicable. These derived rules may have complex effects upon a diagram, and an algorithm is followed to determine the outcome. Such algorithms for rules could be implemented in a software tool. We imagine a user presented with a diagram would be able to select a syntactic element in a diagram and be offered applicable rules. While the effects of derived rules may be rather complex to describe, the burden of work falls upon the tool developers and not with the users.

Constraint diagrams as described above can be ambiguous [3]. Augmenting the diagrams with a reading tree (essentially a partial order on the spiders in the diagrams) ensures a unique semantic interpretation: a reading which is a sentence in FOPL. In this paper, when we refer to a constraint diagram, we really refer to an augmented constraint diagram, which is a constraint diagram accompanied by a reading tree, as defined in [3].

Informally, we describe the semantics of these pieces of syntax. Given con- tours represent sets and derived contours represent the image of a relation. Topological properties, such as disjointness and containment of contours are respected by the corresponding sets. Existential spiders represent existential quantification, universal spiders represent universal quantification and arrows represent relations. Shading in a zone places an upper bound on the cardi- nality of the corresponding set. Distinct spiders represent distinct elements.

In the reading tree of d1 the nodes x and y are unordered and so the quantifiers x and y are not nested in the reading. In d2, x is ordered before y and so the quantifiers are nested: y is in the scope of x. Therefore, the reading of d2 is true whenever the set corresponding to A is empty, whatever the relationship between y, g and D, but this is not the case for the reading of d1.

Dependence between spiders in a diagram is a syntactic condition which en- capsulates the need of the corresponding quantifiers to reference each other in the semantic interpretation. An ordering of nodes in a reading tree for a diagram places one of the corresponding quantifiers in the scope of the other. Say that a reading tree is valid for a diagram if it provides ordering between the nodes of dependent spiders. It may or may not provide ordering between independent spiders.

Rules discussed in this section are purely diagrammatic, transforming a uni- tary diagram into another unitary diagram. These simple rules have strong preconditions and are designed to make small changes to the diagram syntax. We have, in some cases, written preconditions that are stronger than they need to be, in order to be able to describe the rule simply in a limited amount of space.

A universal spider x cannot be deleted if there are any arrows sourced at x or targeted on x. A second precondition asserts that no spider can be ordered after x in the reading tree. This is because in the absence of any contextual information, the universal quantification could have an empty domain. If a universal spider x has another spider s ordered after x in the reading tree,

It is a non-trivial task to determine which syntactic elements need to be edited or deleted, and in which order, to prepare a diagram for a rule applica- tion. We do not expect this task to be undertaken by the users of the notation. It is intended to be implemented as part of a software tool for reasoning with constraint diagrams. The burden of work is with the tool-builders, and the users can simply apply rules using the tool which invokes algorithms behind the scenes.

There are conflicting pressures concerning the simplicity of the rules. One group of users, those who are reasoning about the system (e.g. proving sound- ness, or generating automatic proof-writers) would like to use rules which make minimal changes to diagram syntax. However, such rules need to have stringent preconditions and can rarely be applied to a diagram.

A second group of users reason with diagrams to formulate software spec- ifications. A practical software tool would allow such users to apply rules easily. The software should be responsible for offering rules only when pre- conditions apply, and be able to provide conclusion diagrams which conform to post-conditions. For these users, the most useful kinds of rules have weak preconditions and complex postconditions. To balance these conflicting re- quirements, we developed two classes of rules: simple and iterative.

