secure (the most famous one has been exposed by G. Lowe in [18], some of them are listed in [10]). The good news about this approach is that a rich collection of automatic verification methods and tools have been developed [21,8,7,2].

In the computational approach, cryptographic primitives operate on strings of bits and their security is defined in terms of high complexity and weak probability of success (e.g. [16] for encryption) of any attacker. Protocols as well as attackers are randomized polynomial-time Turing machines. This computational approach is recognized as more realistic than the formal approach, however, its complexity makes it very difficult to design automatic verification tools.

In the last years, several works have focussed on bridging the gap that separates these two approaches. In their seminal paper [1], Abadi and Rogaway prove that a notion of message indistinguishability in the symbolic model is valid in the com- putational model provided that the encryption scheme used to implement messages satisfies semantic security. This means that if two messages are not distinguishable in the symbolic model, then their computational implementations cannot be sep- arated by a Turing machine in a reasonable (polynomial) time. This paper deals with passive attackers that can only eavesdrop but not alter or block messages.

Soundness of symbolic analysis has been proven in the black-box reactive sim- ulatability (BRSIM) framework by Backes, Pfitzmann and Waidner [3]. Recently this result has been extended [4] to include hash functions in the random oracle model, it has also been proven that such an extension is not possible in the stan- dard model. Given the strength of the BRSIM model, this impossibility result does not automatically carry over to the Dolev-Yao model used in [11].

In this section, we consider protocols that allow parties to exchange messages built from identities and randomly generated numbers using public key encryption and a hash function. We assume that the same hash key is used by every participant using the protocol hence we do not represent this key in the syntax of the protocol. Three types of instructions can be performed during protocol execution: receiving a message, sending a message or testing a hash. To describe a specific instruction, we use terms in the free algebra with the following sorts:

Protocols are specified using terms in this algebra and typed variables. That is, we allow disjoint sets of variables that range over the different sorts. A term is called atomic, if it is a key, a nonce or a variable. Grounds terms, i.e. variable free terms, are called messages.

where t is a term and x a variable. Instruction Rec(t) denotes the reception of a message (and its pattern matching using prototype t, which should not contain hash), Snd(t) denotes the emission of t and finally, [h(t)= x] checks that the value of x is the hash of the value of t. A role R is a finite list of instructions, the set atoms(R) contains every atom that appears in R or whose inverse (for keys) appears in R.

We consider two different protocol semantics: one in the symbolic model and one in the computational model. Both define the behavior of the protocol confronted to an adversary. This adversary has total control of the network. Moreover the ad- versary impersonates the dishonest participants. In the symbolic case, the protocol and the adversary exchange symbolic messages. Deductions that can be made by the adversary are defined by a deduction relation. In the computational case, they exchange strings of bits. The adversary is a polynomial random Turing machine and can therefore perform any operation it wants.

We now define another property corresponding to the strong secrecy of nonces SecNonce [12]. This property states that it is hard for an adversary to distinguish the nonce that is used in the execution of the protocol from a random nonce. In the SecNonceb experiment, after execution of the protocol, the adversary is given two nonce values bs0 and bs1 and has to decide which was used in the execution.

Another approach to ensure security of hash functions is to use probabilistic hash functions citecanetti-hash. Whilst the security notion described in citecanetti-hash ensure that any hash preserves any partial information over the hashed message, it does not ensure that given a hash containing a secret nonce, it is impossible to forge a new hash containing the secret nonce. Moreover the hash functions considered are probabilistic.

Hence we define a new criterion for hash functions. We want to ensure that hash functions satisfy a form of semantic security. However it is not possible to directly adapt classical definitions as hash functions are deterministic. The adversary cannot have full access to a left-right hash oracle. Therefore we introduce a new security game where first some challenge nonces are randomly sampled. The adversary has access to a left-right oracle but his queries are not directly hashed: the challenge nonces are inserted in these queries before applying the hash function.

Proof. The proof is very similar to the proofs found in [19,17,12]. The idea is to build an adversary against N -PAH which executes A by simulating Exec. The adversary B also build the symbolic execution corresponding to the computational execution observed. Whenever A is able to produces an execution that does not correspond to a valid symbolic execution, then B is able to win against one of her challenge. Hence the probability that A produces such an execution is bounded by the advantage of B, which is negligible by assumption.

The following proposition is a preservation result for faithful trace properties. It states that if the symbolic property is a faithful abstraction of the computational property and it is satisfied in the symbolic model then the concrete property is satisfied in the computational model. It has been applied to mutual authentication in [19] in which there is also a longer discussion about symbolic/computational properties.

We remark that we cannot deal with computational secrecy of nonces sent in hashes. It is because we do not assume with our HASH criterion that hash functions ensure indistinguishability. We only assume that a hash does not leak enough information to obtain the entire hashed message. A definition for secrecy of nonce that may be sent in hashes is given in [11].

The main contributions of this paper are the following: a formal definition of a correctness criterion for hash functions (that is easily met in the random oracle model). A proof of correctness of the Dolev-Yao model for protocols that may combine an asymmetric scheme and a hash function. The proof of our theorem makes some restrictions on the protocols that are in practice easily met. As future work, it would be of interest to investigate whether correctness of Dolev-Yao can be proved under weaker assumptions on the cryptographic primitives. Moreover, it would be significant to extend this result to other security properties.

