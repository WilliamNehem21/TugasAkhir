In this paper, we study the problem of inconsistency handling for object- oriented behavioral models, following our general methodology for consistency management developed in [3]. First, we briefly report on existing work on consistency checking, introducing an example consistency problem. Then, we elaborate on the concept of inconsistency handling. Finally, we focus on using graph transformation during inconsistency handling for reconstructing UML models from outputs generated by model checkers.

In previous work, we have reported on the details of such a consistency concept. As a running example, we have chosen the formal method CSP [8] and the model checker FDR [4] to evaluate consistency conditions. To sup- port the software engineer in the complex task of translating submodels and defining consistency checks, we have developed the consistency workbench [2]. Briefly, this workbench allows the definition of rule-based translations of UML models into semantic domains and the definition of consistency checks as work- flows, composing activities for translation and triggering external model check- ers. Currently, the consistency workbench contains pre-defined translations of statecharts and collaborations to CSP and allows the execution of consistency checks for the previously described consistency problem.

Inconsistency handling [14] is a notion for activities and techniques that aim at dealing with inconsistencies in multi-view sofware development. Depending on the types of languages and abstractions used within model-based develop- ment, quite different inconsistency handling techniques have been developed. In general, one can distinguish between changing actions and non-changing actions and the general decision of either tolerating or resolving an inconsis- tency. Inconsistency handling comprises the identification of these actions as well as the evaluation of their costs and the evaluation of risks of not resolving an inconsistency. Concerning inconsistency handling of object-oriented mod- els, we will restrict ourselves to the discussion of actions for handling them, leaving the evaluation of risks and costs to future work.

In order to enable inconsistency management, it is important that the inconsistency is detected. This is performed by a consistency check. However, the result of such a consistency check is given in terms of the language in the semantic domain. In case of an inconsistency, this will usually be a trace to an

Using the technique of back-annotation, it is possible to display a UML model illustrating the inconsistency found. In order to enable the software engineer to resolve the inconsistency, often further support is needed. This support usually depends on the type of underlying consistency concept i. e. for the wide range of inconsistencies quite different types of supports could be needed.

The goal of back-annotation is to construct from such a trace given in CSP a UML model helping the software engineer to handle the inconsistency in the UML model. One problem associated with back-annotation is that we must be able to express information compatible with the source UML model: in the process of translation and abstraction to the semantic domain CSP, we may have renamed concepts from UML to CSP and left out details of the UML model. For example, in the concrete example AB itsB pout .send b corresponds to a sending of SC2 via the port p2, the information out .send is something added during translation into CSP. Further, the details of the receiver of the message b have been left out and are not visible in the CSP trace.

What is needed here is an approach that allows us to reconstruct the abstraction level needed when translating the CSP error trace back into a UML model. This approach must be intertwined with the translation from UML into CSP at the first place. There, the information needed for back- annotation must be determined and stored.

Our concept for tackling this problem is as follows: When designing the translation from UML to CSP (i. e. when abstracting), one has to determine which aspects will be necessary to reconstruct a UML model from the more abstract CSP model. These aspects have to be mapped into a so-called re- construction model which can then be used for generating/back-annotating a UML model in the process of inconsistency handling.

In the second part of this paper, we have elaborated on the problem of back-annotation. The concept of a reconstruction model has been introduced which serves the purpose of saving the information necessary within back- annotation during the translation into a semantic domain. We have further elaborated how an existing approach of graph transformation using a rule for- mat of compound rules which has already been successfully used for translating UML models into a semantic domain can also be used for back-annotation.

Future work can be performed in the following directions: Firstly, the prob- lem of back-annotation must be studied in depth for different consistency prob- lems, possibly leading to a richer set of transformations for back-annotation. A first idea would be to also include negative traces and make use of the rich set of model elements provided by the UML. Furthermore, a distinction between mandatory and potential behavior could be useful (see e.g. Haugen et al. [5]). Secondly, we aim at including our techniques of back-annotation into the Consistency Workbench. Further, techniques such as specialized al- gorithms for user-directed inconsistency resolution should be developed.

