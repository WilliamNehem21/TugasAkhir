In the present paper, we propose our development strategy which differs from that of the cookbook in some key aspects (see Sect. 5). We start in Sect. 2 by offering a summary of the Event-B notation; in Sect. 3, we explain our strategy and apply it to a control problem in Sect. 4. Finally, we discuss our results in Sect. 5.

Event-B is supported by a specialized notation for abstract machines, the central object of the development method. It supports both the formulation of formal specifications and their refinement. We give a brief overview of some essential aspects of Event-B in this Section. For a full details of Event-B, we refer our readers to [2].

Consistency has to be proved between a concrete machine and its abstract ma- chine. In practice, this is done on a per event basis. An event of the concrete machine is a refinement of an abstract event if the guard is strengthened and the action of the concrete event can be simulated by the action of the abstract event.

The Trains. In the last refinement of the environment model, we introduce the trains into the system. The safety properties concerning the trains all concern their position so this is a good candidate for a new variable. POS is thus introduced to map each train to the only block where it is located (as stated by inv3 0), consistently with ENV1. To rule out the possibility of collisions, i.e. to enforce SAF5, we can now introduce inv3 1 which states that each train is alone on its block 6 . Finally, for the sake of consistency with the variable OCC , we introduce inv3 2 so that only trains can occupy a block 7 .

a specific platform (ENV13). We focus on the actuator of the in-switch. Two new variables act in sw and act in sw plf are used to model the actuator: the former is a boolean to indicate whether there is a pending command for the device, the latter specifies which platform the switch should change to.

Event TURN IN SW is refined accordingly using the command from the actua- tor. The concrete guard specifies that there is a command from the controller for changing the in-switch. As a result, the in-switch is set to the specific platform as commanded. The actuator is reset after the switch changes.

Event ctrl trigger in sw specifies that the actuator act in sw can be set to instruct the switch to change to any platform p, when the entry signal is RED and both ac- tuators act in sw and act ent sgn are unset. Event ctr chg ent sgn models the fact that the actuator act ent sgn can be set to command the entry signal to change to GRN , when the in-switch point to unoccupied platform and both actuators act in sw and act ent sgn are unset. Notice that the guards of these events guar- antee that the newly introduced invariants are maintained.

Finally, since IN SW is used in the guard of ctr chg ent sgn, the controller needs to know the status of the in-switch when sending the command for changing the entry signal. The controller keeps a copy of status of the in-switch with its variable ctrl in sw. Note that variable ctrl in sw does not necessarily reflect the current value of IN SW . Indeed, we only need them to be the same when there is no actuator command for the in-switch. ctrl in sw is updated when the controller commands the corresponding switch to change with event ctrl trigger in sw.

We have presented our development strategy for developing control systems together with a model of their environment. Our strategy starts with the modelling of the environment, followed by the introduction of the actuators, before the controller and sensors are modelled. Finally, further scheduling details are imposed on the controller as an optimisation step for the system. Applying our development strat- egy reduces the difficulty in modelling this type of systems, results in models which are easy to understand and verify. We illustrate our approach by developing a sim- plified signal control system. Even though there are not yet any code generators for Event-B, the controller variables and events in our final model are concrete and clear enough, and can be used as a software low level design.

The validation of control systems have been studied using other formal methods. Hansen validated a railway interlocking model using VDM [5]. However, the paper only establishes a model of the environment without the controller. Haxthausen and Peleska presented an approach using RAISE for developing a distributed railway control system [6]. Their approach consists of two stages. In their first stage, the model of the environment and controllers are developed globally together. Their second stage focuses on the design of a distributed controller corresponding to the model in the first stage. Our development strategy can be seen as a guideline for developing the model in their first stage.

