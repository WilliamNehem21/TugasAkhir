This paper describes a model-driven approach in which transformation can be used to automatically generate Java stress tests whose scale and complexity resist man- ual construction. The approach consists of a framework where a variety of Java entities can be modelled at various levels of abstraction. The models presented have structural properties that naturally lend themselves to transformation-based manipulation. In this setting, transformation-based analysis is performed on the most abstract form of a model and the goal of transformation-based generation is to derive a corresponding concrete model (i.e., a set of Java classes). All analysis and generation transformations discussed in this paper have been implemented in the higher-order transformation language TL [8] using the HATS system [7]. The resulting stress tests are being used to help validate that the SSP [6], a hardware implementation of a significant JVM subset, conforms to the specification of the Java Virtual Machine (JVM).

The <clinit> method for a given class may be invoked at most once during the execution of a Java program. The internal structure of a <clinit> method (i.e., its body) is important to this discussion only to the extent that the body may contain an active use of another class.

The execution of the body of a <clinit> method for a class B should be suspended if the <clinit> method for the superclass of B has not been invoked 3 . The execution of a <clinit> method body should also be suspended if an attempt is made, in the method body, to evaluate an active use of a class whose <clinit> method has not yet been invoked. The execution of a suspended method must resume immediately after completion of the <clinit> method belonging to the class that triggered the suspension.

The clinit dependencies between classes can be seen as having a directed graph- like structure. These dependencies can be modelled by a class hierarchy model M. Given a clinit dependency description M, we are interested in creating, in concrete form, a hierarchy of classes {B1, B2, ..., Bn} whose clinit dependencies correspond to M.

A pattern is a notation for describing the parse tree structures that are being manipulated. This notation includes typed variables that are quantified over specific tree structure domains; E.g., stmt id1 = 5 ) is a tree with root stmt and leaves id1, =, and 5. In this context, the subscripted variable id1 denotes a typed variable quantified over the domain of all trees having id as their root node. In general, a

TL supports a variety of standard generic traversals such as top-down left-to- right, which in TL is denoted by the keyword TDL. TL also supports the definition and use of higher-order generic traversals. Informally, one can think of a higher- order traversal as mechanism for dynamically collecting a number of strategies and combining them to form a new strategy. A common higher-order traversal is one that traverses a tree in a TDL fashion, applies a higher-order strategy sn+1, and composes the resulting order-n strategies using the <+ combinator. In TL, this traversal is denoted by the keyword lcond tdl.

When generating a stress test the problem surrounding the consistent use of names is an instance of the distributed data problem (DDP) [8]. The DDP arises when a semantic relationship exists between terms that are syntactically unrelated. In practice, this means that information (e.g., identifier names to be referenced) must be explicitly transported between terms using a mechanism other than an encom- passing match or unification. The parameterization of transformations is a standard approach that is often used to address the DDP. Other approaches include (1) the dynamic creation of rewrite rules and strategies in either a first-order [4] or higher- order setting [8], and (2) the fusion of term structures in which data and compu- tations can be combined [2]. In the transformations described in this paper, most instances of the DDP have been avoided through (1) appropriate choice of identifier names, and (2) consistent use of a single model to derive various components of the stress test. For example, in the class observe, a monitoring identifier of type integer is declared corresponding to each class whose clinit behavior we want to observe. These monitoring variables are then referenced within the method check

A generator such as special new could be used to generate method declarations in observe and corresponding method invocations in set and check. Note that there is nothing remarkable about the function special new other than its ability to produce an identifier token from the concatenation of two other identifiers. In TL, such a function can be easily defined, placed within a user-defined library, and made accessible within a transformation. Similar functions can be created to generate instances of the classes observe and set and check (e.g., the identifier observe is concatenated with the first class identifer occurring within a class hierarchy model to create a unique instance of the class observe).

Stress tests can provide a significant contribution to the assurance argument for a system. Oftentimes stress tests have size and complexity attributes that make their manual generation impractical. Two major challenges that one faces when automat- ically generating stress test are: (1) developing a systematic approach for selecting test cases, and (2) constructing certificates that can be used to automatically check the results of test cases. In this paper we have presented an approach for clinit test generation where the selection of test cases and the generation of certificates takes place on the abstract form of a model and the results are then transformed into concrete tests.

