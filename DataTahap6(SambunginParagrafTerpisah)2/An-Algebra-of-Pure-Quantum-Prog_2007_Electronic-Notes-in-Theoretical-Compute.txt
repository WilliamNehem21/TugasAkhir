is the conditional-not operation, which behaves as follows: if the control qubit c is true it negates the second qubit x ; otherwise it leaves it unchanged. When the control qubit is in some superposition of true and false, the result is a superposition of the two pairs resulting from the evaluation of each branch of the conditional. For example, evaluating cnot (false + true) false produces the entangled pair (false, false)+ (true, true).

As the formal semantics of QML clarifies, this expression does not actually clone quantum data; rather it shares one copy of the quantum data. In other words the expression does not evaluate to (false + true, false + true) which would make it impossible to realise. Rather the expression evaluates to (false, false)+ (true, true) which is realisable (and easily so). With this inter- pretation, one can freely duplicate variables bound to quantum data. When translated to the type system, this means that the type system imposes no restrictions on the use of the structural rule of contraction.

where the quantum data bound to y is discarded. According to both the phys- ical interpretations of quantum computation and the semantics of QML, this corresponds to a measurement of y . Since measurement is semantically quite complicated to deal with, we insist that it should be represented explicitly. The language we consider in this paper lacks the explicit constructs for mea- surement so we reject the expression above. This means that the structural rule of weakening is never allowed in situations where information may be lost. More precisely the only value to which weakening applies is the unit value () as it carries no information.

where Q1 is the type of (), and Q2 is the type of qubits. As apparent from the grammar, QML types are first-order and finite; there are no higher-order types and no recursive types. The only types we can represent are the types of collections of qubits.

As explained in the typing rules, the operator allows us to share variables appearing in a given context. This operation is partial: it is only well-defined if the two contexts do not assign different types to the same variable. Whenever we use this operator we implicitly assume that it is well-defined.

