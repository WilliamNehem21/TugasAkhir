A distinctive feature of modern functional logic languages like Toy or Curry is the possibility of programming non-strict and non-deterministic functions with call-time choice semantics. For almost ten years the CRWL framework [6,7] has been the only formal setting covering all these semantic aspects. But recently [1] an alternative proposal has appeared, focusing more on operational aspects. In this work we investigate the relation between both approaches, which is far from being obvious due to the wide gap between both descriptions, even at syntactical level.

The rest of the paper is organized as follows. Sections 2 and 3 present the essentials of CRWL and FLC needed to relate them. Section 4 sets some restrictions assumed in our work and gives an overview of the structure of our results. Section 5 relates CRWL to CRWLF LC, a new intermediate formal description introduced as a bridge between CRWL and FLC. Section 6 is the main part of the work and studies the relation between CRWLF LC and FLC. Section 7 gives some conclusions.

The following algorithm performs it. It proceeds with each function f defined in the program, and works on a set of program rules (initially Pf , the whole set of rules for f ) and a linear call-pattern f (t1,..., tn) (initially the pattern f (X1,..., Xn)) which is compatible with the rules, i.e., the call-pattern subsumes the left-hand side of all the rules.

As we have pointed out in Section 4 one mayor difference of FLC with respect to CRWL it that the first one only provides head normal forms for the expressions to reduce, while CRWL allows to obtain any approximation to the denotation of such expressions. Nevertheless FLC can be enforced to provide a normal form for an expression by introducing an auxiliary function in the program. This is better seen with an example. Consider again the program of Example 2 and the expression heads(repeat(coin)). For checking if this expression (the corresponding normalized one) is reducible to the normal form (0, 0) in FLC, we can enlarge the program with the following predicate (i.e, true-valued function):

We did not expect proofs to be easy. Despite of that, we are a bit surprised by the great difficulties we have encountered, even with the imposed restrictions over expressions and programs. This suggests to look for new insights, not only at the level of the proofs but also in the sense of finding new alternative semantical descriptions of functional logic programs.

Proof. [For Lemma 8.4](Sketch) Using Lemma 8.3 we know that there must be a binding for x, all that is left is ensuring that this binding never changes. The only way a binding for a variable changes is through the rule VarExp, but this rule cannot be applied if e is constructor-rooted, and that is the case because e = c(y), so the binding for x remains the same.

