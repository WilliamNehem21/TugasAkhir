Action systems were first defined by Back and Kurkio-Suonio [7] as a modelling for- malism for distributed systems. We have chosen this formalism as it can effectively be used for modelling reactive systems [8] and because recently, it has also been used for model-based mutation testing [5]. There exist several variations of it like object-oriented action systems [9] and it also served as an inspiration for Event-B [1]. However, the action system formalism used here is more restricted than other variations. In some aspects it is similar to the Event-B language, but for instance it does not support set-theoretic constructs like Event-B.

Informally, the execution of an action system starts in an initial state which is manipulated by repeatedly executing actions. During this process one action is chosen at each step in a non-deterministic fashion from the set of enabled actions. An action is enabled iff its guard is satisfiable in the current state. The execution terminates when the set of enabled actions is empty.

[14] . This approach was taken, because action systems can easily be translated to initialised Input Output Symbolic Transition Systems (IOSTSs). This way it is pos- sible to use the symbolic framework given in [14] with some adaptations. Moreover, we will use the same concepts and notation for first-order formulae as follows.

The concept of symbolic execution trees of action systems is inspired by execu- tion trees created for programs [11]. A symbolic execution tree shall, starting from an initial state, encode the effects of symbolically executing arbitrary actions. We chose a tree-based rather than a trace-based description of the symbolic execution of action systems to highlight the effects of actions on symbolic states.

Note that the indexes of states directly correspond to the execution depth, at which they have been detected. By convention, we consider states reached by ex- ecuting internal actions to be at the same depth label as the pre state, so we do not increase the index value for such states. This is allowed by our definition of indexed symbolic states, as internal actions do not have parameters and thereby do not introduce new indexed parameter variables. Although this is also true for the quiescence observation, we increase the symbolic state index as it is observable.

Since the angelic completion adds self-loops for undefined inputs to states of LTSs, execneg must not perform a state update. As implementations in the context of sioco are considered to be weakly input-enabled, execneg should take into ac- count, that it is not necessary to add self-loops for inputs i if a state may be reached by executing internal actions, in which i is enabled. For this reason, the function expects the disjunction over the guards of all internal actions as third parameter.

As noted before, action systems may behave non-deterministically. The sioco conformance relation, takes non-determinism into account as well. Therefore, the conformance check is able to handle action systems containing internal actions and does not produce spurious counterexamples, i.e. it does not identify action systems to be non-conforming, which are actually conforming.

Furthermore, the product graph allows actions to be executed only if the path condition of the target product state, which contains both implementation and specification states, is satisfiable, while ioco is defined for suspension traces of the specification. This restriction is used, as the non-conformance condition given below would not be satisfiable anyway for product states with unsatisfiable path conditions. The non-conformance condition corresponds to the negation of the condition for sioco-conformance given in [14].

The implementation of the test case generator performs a depth-first search for unsafe states in the product graph. Following the definition given in [5], unsafe states are states in which non-conforming behaviour may be observed. In our case, these are product states which fulfil the condition given in Definition 3.5. If such an unsafe state is found, a symbolic test case is returned, which is a pair formed of:

We developed several optimisations to decrease the run-time of the search in the product graph, which will be discussed in the following. Some of them specifically target model-based mutation using first-order mutants. As such, they make use of an efficient syntactical mutation analysis inspired by [5], which detects the location of mutations. We distinguish mutations of the init block, the state update of an action and the guard of an action. In general, an algorithm applying the given opti- misations will not detect fewer conformance violations. One optimisation, however, breaks this rule in order to generate a more comprehensive test suite.

As long as the mutated action has not been executed, at most two non- conformance checks need to be performed at each step. The actual number depends on whether the mutation affects the guard of an internal or output action. If it is not possible to reach the mutation along the search path, the search may be stopped before hitting the maximum search depth.

The model used for the comparison specifies the behaviour of a device measuring particle counts in exhaust gas and contains 69 input and 20 output actions. It was derived from the model used in [6], which was defined using a different action system language. Since this language allows for nested guarded commands in actions, the original model contains a lower number of actions.

We presented an approach to use symbolic input output conformance checking for test case generation and gave guidelines on how to implement the conformance check efficiently. The optimisations are targeted towards model-based mutation testing, which creates test cases covering faults corresponding to model mutations. Applying angelic completion to the mutant, we implicitly cover another class of faults: as the angelic completion essentially ignores non-specified inputs, our test case generation strategy covers faults corresponding to ignored inputs as well.

To our knowledge, we have implemented the first fully symbolic ioco- conformance checker. However, the sioco-conformance relation has already been used as a conformance relation for model-based online testing [13]. In contrast to their work, we rather focus on test case generation than on execution, which is performed randomly and on-the-fly in [13]. An adapted version of ioco is also used in conjunction with symbolic specifications in [16]. Gaston et al. present an algo- rithm for testing SUTs based on finite behaviours of the specification selected by test purposes. Their notion of test purposes can be related to our test case selection strategy. However, while the test cases generated by our approach are specified

In our current applications, we can safely assume a synchronous communication between test driver and SUT. However, this assumption may not hold in general [19]. To circumvent this problem, we could compose our models with action systems modelling message queues prior to the conformance check. Such an approach would be able to faithfully model asynchronous communication performed during testing and would not result in state space explosion, as we check conformance symbolically. Hence, it would be interesting to study the composition of action systems.

