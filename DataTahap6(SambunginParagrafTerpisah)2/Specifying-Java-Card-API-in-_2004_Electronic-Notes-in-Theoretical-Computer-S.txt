We discuss the development of an OCL specification for the JAVA CARD API. The main purpose of this specification is to support and aid the verification of JAVA CARD programs in the KeY system. The main goal of the KeY system is to integrate object oriented design and formal methods. The already existing specification written in JML (JAVA Modelling Language) has been used as a starting point for the development of the OCL specification. In this paper we report on the problems that we encountered when writing the specification and their solutions, we present the most interesting parts of the specification, we report on successful verification attempts and finally we evaluate OCL and compare it to JML in the context of JAVA CARD program specification and verification.

This paper reports on the development of an OCL specification for the JAVA CARD API [19]. JAVA CARD [9] is a subset of the JAVA programming language and is used to program smart cards. The JAVA CARD API (Application Pro- gramming Interface) is a set of library classes used in JAVA CARD programs. JAVA CARD API is a much smaller version of the standard JAVA API and is specifically designed for smart card programming. The OCL specification is necessary to perform formal verification of such programs when the implemen- tation of the API classes is not available. Even if the API implementation is available, having the OCL specification helps to avoid repetitive work of prov- ing the API implementation each time API method is used in a JAVA CARD program. The secondary purpose of writing the specification is to document the behaviour of the JAVA CARD API in a formal way. We discuss the problems we encountered when writing the specification in OCL and their solutions. We present some of the most interesting parts of the specification and report on successful verification attempts of the reference implementation of JAVA CARD API w.r.t. our specification. Finally, we evaluate OCL and compare it to JML in the context of this work. This paper summarises results from [11].

One of the purposes of the KeY system is the possibility to formally verify JAVA CARD applications. To successfully verify a program that uses the JAVA CARD API one has to have access to either the implementation of the API or its formal specification. Since the implementation of the API is usually not available (especially when the methods are native), the latter is the solution we are aiming for. Let us look at an example to illustrate how the JAVA CARD API specification is used in the verification process. Suppose we have implemented a method aMethod in our JAVA CARD program. We now want to verify that the implementation satisfies the formal specification (the pair of main difference is the specification language used. The LOOP tool presented in [20] uses JML and PVS as the means to formally verify JAVA CARD pro- grams, thus the necessity for the API specification written in JML. As we use the industry standard OCL as a specification language in the KeY project we need to have the JAVA CARD API specification formulated in OCL. We also made an effort to have more complete coverage of the JAVA CARD API in our specification.

When comparing objects other than class attributes (e.g. method argu- ments) to the null value things are a bit more difficult. If such an object is an array or a collection type, one can use the same technique as described above. Otherwise there is no way to specify that an object should (or should not) have the null value.

This still does not solve the problem of proper interpretation of overflow be- haviour in OCL. Luckily, the KeY system comes to the rescue again. When the OCL specification is translated to a JAVA Dynamic Logic formula, the user can choose how the integer types are interpreted by the prover: either as finite JAVA types short and byte, or as infinite arithmetic types arithShort and arithByte. In both cases the issue of overflow is treated appropriately. More about handling arithmetics in the KeY system can be found in [5,17]. Also,

This is not a good solution, though. Suppose we have a class with 20 attributes and we want to express the fact that only one attribute is assignable. That means we have to write 19 expressions like the one above for all the remaining attributes. There is ongoing work that aims at solving this problem in the KeY system [6]. The work is about how to properly specify attribute modification behaviour and how such specification can be used in proofs. In the current version of our work we left out the parts of the specification corresponding to the @assignable clause in JML.

The present work resulted in an OCL specification for all classes and interfaces of the JAVA CARD API 2.2. This specification expresses, with a few exceptions (some of the signals clauses and the assignable clauses were not possible to be fully expressed in OCL), as much as the JML specification for JAVA CARD API 2.1.1. In some cases the OCL specification expresses more than the JML specification. In the following we illustrate by example how our OCL specification was created and how it was improved (compared to JML).

Compares pin against the PIN value. If they match and the PIN is not blocked, it sets the validated flag and resets the try counter to its maximum. If it does not match, it decrements the try counter and, if the counter has reached zero, blocks the PIN. Even if a transaction is in progress, the internal state such as the try counter, the validated flag and the blocking state must not be conditionally updated.

In the next example we show how the specification of method setKey in class DESKey has been enriched compared to JML specification. The method setKey copies the data (an array of bytes) that is passed as an argument and constitutes the actual key to the internal attribute data. Under certain circumstances, this data is not passed to the method in plain text but as a cipher and the method must then decrypt the data before it is copied into the internal representation. Here is the JML specification for this method:

What we added in this specification is the following. If this particular instance of DESKey is not an instance of javacardx.crypto.KeyEncryption or if this instance is not associated with a Cipher object (the circumstances under which the input keyData have to be decrypted), then the input data is to be copied directly into the internal attribute data.

the version we used. Since the arrays are present almost everywhere in the JAVA CARD API this was a major obstacle. We can however report that a number of simple getReason/setReason methods in the exception classes of javacard.framework package have been verified. A more complicated suc- cessful proof attempt was the verification of the reset method in the OwnerPIN class. The specification is the following:

In this paper we presented our experience from the development of an OCL specification for the JAVA CARD API 2.2. Despite the mentioned problems with OCL we managed to specify the whole JAVA CARD API to a reasonable extent. The specification is available on-line at:

The two main purposes of this work were to aid and support formal verification of JAVA CARD programs in the KeY system and to document the JAVA CARD API in a formal way. We tested our specification by formally verifying the reference implementation of the JAVA CARD API with the KeY system, however, due to technical limitations, this was not done to the desirable extent. Still, the proofs we attempted were successful and were performed automatically by the KeY system. In the near future the KeY system will cover the full JAVA CARD standard. Then we plan to continue in this direction and also, based on our specification, perform formal verification of real life JAVA CARD case studies.

