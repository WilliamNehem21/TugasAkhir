The intersection of relational databases, logic, and artificial intelligence was the melting pot of deductive databases. A deductive database system includes procedures for inferring information from the so-called intensional database (deductive rules) in addition to the so-called extensional database (deductive rules without body, i.e., facts following the logic programming nomenclature). Deductive database languages are related to the Prolog language, and Datalog has become the de-facto standard deductive database query language. Datalog allows to write queries as normal logic programs (without function symbols), and they are ensured to be terminating upon some conditions (e.g., avoiding infinite relations as arithmetical predicates).

This language has been extensively studied and is gaining a renowned interest thanks to their application to ontologies [10], semantic web [6], social networks [16], policy languages [2], and even for optimization [11]. In addition, companies as LogicBlox, Exeura, Semmle, and Lixto embody Datalog-based deductive database technologies in the solutions they develop. The high-level expressivity of Datalog and its extensions has therefore been acknowledged as a powerful feature to deal with knowledge-based information.

Compared to the widely-used relational database language SQL, Datalog adds two main advantages. First, its clean semantics allows to better reason about problem specifications. Its more compact formulations, notably when using recursive predicates, allow better understanding and program mainte- nance. Second, it provides more expressivity because the linear recursion limitation in SQL is not imposed. In fact, multiple recursive calls can be found in a deductive rule body.

Several deductive systems have emerged along time, mostly born from aca- demic efforts. See, for instance DLV [14], XSB [19], bddbddb [13], LDL++ [1], ConceptBase [12], and .QL [15]. Translating these outcomes to experiment with and to widen the dissemination of state-of-the-art features of such de- ductive systems is hard since no one meets the following desired properties: multi-platform, interactiveness, multi-language support, freeness, and open- sourcing, among others.

Organization of this paper is as follows. Section 2 summarizes the main features of the current version of the system. Section 3 describes the Datalog and SQL query languages as they can be used from DES. Section 4 explains our proposal to the management of null values and outer join operators in Datalog, which in turn are used in the compilation of SQL statements to Datalog programs. Also, a novel approach to aggregates is described in Section 4, including both aggregate functions and predicates. Finally, Section 6 draws some conclusions.

DES ensures that negative information can be gathered from a program with negated goals provided that a restricted form of negation is used: strat- ified negation [23]. This broadly means that negation is not involved in a recursive computation path, although it can use recursive rules. The system can correctly compute a query Q in the context of a program that is restricted to the dependency graph (which shows the computation dependencies among predicates) built for Q so that a stratification can be found. The user can ask the system for displaying the predicate dependency graph as well as for the stratification via commands.

Automatic temporary views, autoviews for short, are temporary views which do not need a head. When submitting a conjunctive query, a new temporary relation, named answer, is built with as many arguments as rel- evant variables occur in the conjunctive query. answer is a reserved word and cannot be used for defining other relations. The conjunctive query a(X), b(Y) is an example of an autoview, which computes the Cartesian product of a and b.

In [4], an approach to debug Datalog programs anchored to the semantic level instead of the computation level is proposed. This approach has been implemented in DES as a novel way of applying declarative debugging, also called algorithmic debugging, to Datalog programs. It is possible to debug queries and diagnose missing answers (an expected tuple is not computed) as well as wrong answers (a given computed tuple should not be computed). The system uses a question-answering procedure which the user starts when

The command process filename allows to process the file filename as a batch of user inputs. In addition, if the file des.ini is located at the instal- lation directory, its contents are interpreted as input prompts and executed before giving control to the user. Therefore, automation is possible as, for instance, to set the DES application as a component of more complex systems of as a delegate for tasks sent from other systems. In this case, inter-process communication is via files. Batch files can contain remarks because prompt input lines starting with the symbol % are interpreted as such, which imply no computations. In addition, the command /log allows to write the system output to a file, which can be used by another application.

The system has been implemented following ISO Prolog, its binaries uses an efficient Prolog engine (SICStus Prolog) and moreover implements memo- ization techniques [21,9] for upgraded efficiency. The computation is guided by the query, instead of following a bottom-up approach. However, focus was not set on performance, but on rapid prototyping of useful features, so that this system cannot be seen as a practical deductive database for large amounts of data since it is developed from an in-memory database point of view. In addition, neither indexing is provided nor concurrent accesses are allowed.

Since DES is ported to several Prolog systems (including Ciao Prolog [3], GNU Prolog [8], SICStus Prolog [20] and SWI-Prolog [24]), it can be used from any of these environments running on any platform they support (e.g., Windows, Linux glibc 2.x, Mac OS X 10.x, Solaris 10, AIX 5.1L, ... ).

Unknownness has been handled in relational databases long time ago because its ubiquitous presence in real-world applications. Despite its claimed dangers due to unclean semantics (see, for instance, the discussion in [7]), null values to represent unknowns have been widely used. Including nulls in a Datalog system implies to also provide built-ins to handle them, as the outer join operations. DES includes the common outer join operations in relational databases, providing the very same semantics for operators ranging over nulls.

This predicate encloses a query for which a given list of variables builds answer sets (groups) for all possible values of these variables. If we consider the relation employee(Name, Department, Salary), the num- ber of employees for each department can be counted with the query group by(employee(N,D,S),[D],R=count). If employees are not yet as- signed to a department (i.e., a null value in Department), then this query behaves as a SQL user would expect:  excluding those em- ployees from the count outcome.  If we rather want to count ac- tive employees (those with assigned salaries), we can use the query group by(employee(N,D,S),[D],R=count(S)).

An aggregate predicate returns its result in its last argument position, as in sum(p(X),X,R), which binds R to the cumulative sum of values for X, provided by the input relation p. These aggregate predicates simply allow another way of expressing aggregates, in addition to the way explained just above. For instance, the following query is allowed: count(employee(N,D,S),S,T).

A group by operation is simply specified by including the grouping variable(s) in the head of a clause, as in the following view, which computes the number of active employees by department: c(D,C) :- count(employee(N,D,S),S,C). Having conditions are also allowed, including them as another goal of the first argument of the aggregate predicate as, for instance, in the following view, which computes the number of employees that earn more than the average: count((employee(N,D,S),avg(employee(N1, D1,S1),S1,A),S>A),C). Note that this query uses different variables in the same argument positions for the two occurrences of the relation employee. Compare this to the following query, which computes the number of employ- ees so that each one of them earns more than the average salary of his cor- responding department. Here, the same variable name D has been used to refer to the department for which the counting and average are computed: count((employee(N,D,S),avg(employee(N1, D,S1),S1,A),S>A),C).

This paper has listed the main features of the deductive database educational system DES and described some of the most relevant ones that distinguish it as a unique system. Following such features, intended users who can benefit from this system include students, teachers, practitioners and researchers, since it can be used to, first, learn and teach both SQL and Datalog languages in a single, database-shared environment. Second, to experiment with its features since it is free, open-source and furthermore is completely implemented with Prolog, a high-abstraction-level programming language. On the one hand, this allows to change its behaviour and add new features much more easily than either using a lower-abstraction-level language or using several languages.

