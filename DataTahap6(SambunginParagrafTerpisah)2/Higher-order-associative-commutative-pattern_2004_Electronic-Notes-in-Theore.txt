Syntactic matching techniques [16,5] are based on pattern matching or unification. The advantage of these techniques is that they are generally quite efficient and can be fully automated. Furthermore unification and pattern matching can be applied to higher-order logics, and are therefore compati- ble with our aim of supporting adaptation of components through the use of higher-order parameters. The main disadvantage of unification based ap-

In Section 2 we summarise existing approaches to pattern matching and unification of higher-order logics, including existing approaches to associative commutative matching of first order logics. In Section 4 we define our expres- sion language, give a description of parameter instantiation, and describe a purely syntactic pattern matching algorithm for the expression language. In Section 5 we give a specification for associative commutative matching. In Section 6 we define an (incomplete) associative commutative pattern match- ing algorithm for higher-order expressions. In Section 7 we discuss how this matching technique can be used to support component retrieval.

Higher-order unification has also been utilised in programming languages. As an example lambda-Prolog extends standard Prolog, by allowing parame- ters to range over functions and relations. As a result reasoning in lambda- Prolog relies on higher-order unification rather than standard unification.

This problem can be solved by doing case analysis on the whether or not e is a member of the list s. This can be achieved using a case analysis li- brary component. The specification of the top-level function in this library component is shown below, where P and Q are parameters.

z . Function names are represented by lower case identifiers f , g and h for functions of arity 1 and greater, and the identifiers c, d and e for constants. Function parameters are represented by the upper case identifiers F , G , and H .

Parameter instantiations are often defined using placeholders. The instan- tiation F ~ ph(1) + ph(2) indicates that applications of F with at least two arguments are replaced by the application of + to the first and second argu- ments of F . More concretely, F (x , y ) would be replaced by x + y using this instantiation.

We now give an informal description of an algorithm for matching mathe- matical expressions that works on structural induction on the pattern. The algorithm for matching terms follows the structure of the abstract syntax for terms given in Section 4.1. Note that while placeholders only occur in expres- sions used in instantiations, they are considered here for completeness.

in its subterms). An example is matching the pattern (G (x , y ) + z ) + h(c) and the query (x + h(c)) + (z + y ). One possible match can be achieved by instantiating G ~ ph(1) + ph(2). We describe how this match is generated

Example 6.1 Given the pattern p = (G (x , y )+ z )+ h(c) where + is an AC- function and G is a parametric function, and query q = (x + h(c)) + (z + y ) from Ex. 5.7. Then the algorithm for generating matches for p and q proceeds

The second extension that we consider is for queries of the form g (b1,. ., bm), where g is an AC function, and patterns of the form F (as), where F is a parameter, and as is a argument list of the form a1,. ., an, and at least one of the arguments is a function application involving the AC function g .

For queries of the form g (b1,. ., bm), where g is an AC function (it is as- sumed that the query has been flattened with respect to g ), and patterns of the form F (as), where F is a parameter, and as is a argument list of the form a1,. ., an , the algorithm proceeds as follows: for bags of the form [u1,. ., uk ]], where k > 1, generate the set of matches between the expression g (as(u1),. ., as(uk )), and the query g (b1,. ., bm), merging each result with the instantiation F ~ g (ph(u1),. ., ph(uk )).

has been flattened with respect to +. The first step then is to generate the set of multisets satisfying the conditions from Step 1 above. We note that the weight with respect to + of the first and second arguments of the pattern is 2, while the weight of the other two arguments is 1. Therefore the set of possible multisets is:

and one instance of the third argument. For each multiset an instantiation of the parameter G is also created; for the multiset [[1, 3]] the instantiation G ~ ph(1) + ph(3) is formed. Each new term is then matched against the query and any instantiations representing successful matches are merged with the corresponding new created instantiation of G .

There does not appear to be any published decidability or complexity results for higher-order AC matching, however several results have been pub- lished for first order AC matching [7,3]. These papers prove that first order AC matching is decidable, however there are pathological cases which take exponential time to compute. Eker [3], shows that for cases where there is only a single AC function, solutions can be calculated in polynomial time.

The algorithm described in this paper has been used as part of the CARE library retrieval tool [5]. The algorithm (as with other parts of the retrieval tool), has been implemented in Prolog. Because Prolog is a high-level lan- guage, the implemented algorithm is quite similar to the algorithm described in this paper. The algorithm uses backtracking to calculate all solutions.

A further enhancement that could be made to the retrieval tool is to com- bine theorem prover based matching with our existing pattern based matching. This could be achieved in two ways. The first approach would be to imple- ment separate matching algorithms, i.e., theorem prover based and pattern matching based, then make a decision on which one to use based on the form of the pattern and query. An alternative is to use a theorem prover that sup- ports higher-order logic [14,4]. Such provers provide support for higher-order unification, however they could be enhanced by adding support for associative commutative matching, as described in this paper.

