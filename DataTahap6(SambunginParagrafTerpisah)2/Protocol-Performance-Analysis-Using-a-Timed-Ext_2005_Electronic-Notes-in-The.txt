In this paper we propose a timed extension for RPOO, a Petri-net based object-oriented modeling language. The timing strategy of the proposed extension, called RPOOt, is based on the timing strategy from the Timed Coloured Petri nets formalism. A simple stop-and-wait protocol RPOO model was developed in order to demostrate the proposed extension. We also show some per- formance measures for the model. RPOOt showed to be easily integrated with Timed Coloured Petri Nets, providing means for modeling time consuming activities inside objects as well as among objects.

1 This is an extended version of the article published at the Brazilian Symposium on Formal Methods (2004) under the title Timed Extension for an Object Oriented Petri Net Language. This work is supported by CNPq Brazilian Research Council, MOBILE Project, process 552190/2002-0. First author supported by CAPES.

RPOO [8] is a Petri-net based object-oriented modeling language. It can be seen either as an object-oriented extension for high-level Petri nets or as a way to give formal concurrent semantics for object-oriented models. In practice, it allows object-oriented decomposition of complex high-level Petri nets models. The main difference between RPOO and other object-oriented extensions for Petri nets is that RPOO stresses semantic composition instead of syntactical integration. Based on this idea, composition of smaller Petri nets is achieved by means of object-oriented semantic mechanisms, instead of the conventional hierarchical ones [8]. These characteristics make RPOO easier to use in object- oriented real world projects.

RPOO has been successfully applied to the modeling of several systems. Some of these applications had academic purposes [8,15] whereas others aimed at testing the formalism by using it to model, simulate and/or verify real world systems [4,5]. A comprehensive case study was conducted in order to model and analyze the Mobile IP protocol [13], a standard that provides mechanisms for keeping connectivity of mobile hosts that migrate through different networks.

Moreover, in such a sort of protocols like the Mobile IP, there is a lot of in- terest in measuring performance considering different scenarios. For instance, it would be necessary to evaluate data loss during migration. Since it is not possible to explicitly express timing aspects in the RPOO models, it is not straightforward to perform time constrained functionalities analysis.

Most of the timed OO models were conceived for the modeling of real-time systems, which present a considerable degree of concurrency and parallelism. It seems that a lot of effort was focused on giving OO models a semantic for coping with such features. That justifies the creation of elements like capsules, bindings and ports in languages like ROOM and UML-RT. As a result, time treatment, in most of the models, is reduced to the association of fixed delays between states in statecharts that describe objects internal activities (this is not a good strategy to model time consuming interactions between objects).

The main objective of this work is to present an RPOO timing extension to explicitly cope with time in RPOO models. In practice, it means that the RPOO formalism can be used to model real-time systems as well as to make performance evaluation. The central idea is to define a timing OO-level strategy that can be used with the accurate timed models that are already defined for Petri nets. In this way, the OO models can inherit some of the clever temporization aspects from the Petri nets world. As a gain, already suggested by practical experiments [5], a RPOO extension is able to provide time constrained functionality modeling and performance measure/analysis.

Currently, RPOO uses Coloured Petri nets (CP-nets [9]) for describing its classes. The proposed extension aims at integrating the formalism with the TCP-nets, in which tokens are timestamped and the models have a global clock. For that purpose, a global clock was added to RPOO models, all the messages exchanged between objects were timestamped and some transition rules redefined, taking both clock and timestamps under consideration. Thus, the proposed timed extension to RPOO may also be seen as an OO extension to TCP-nets.

The rest of this paper is organized as follows: In Section 2 both RPOO and RPOOt are informally introduced. A case study is presented in Section 3. The analysis results from simulation of the case study models are shown in Section 4. In Section 5 RPOO is formally defined together with its main semantics. The proposed timing extension is defined in Section 6. Section 7 concludes the paper.

In RPOO each object is a thread and interaction between two objects may be asynchronous. This means that when an object a calls a method of (sends a message to) object b in asynchronous mode, the system moves to a state where the data passed as parameter will be pending and may be consumed in a further action by object b. RPOO actions also include synchronous calls, where messages are sent and consumed atomically.

A set of interconnected objects and its pending messages form a structure of an Object System. Besides this structure, an Object System also knows what we call imminent actions, that is, actions that may be executed in the current structure. Briefly, an RPOO Simulator keeps track of an Object Sys- tem, executing actions and deciding which action will be executed, in case of concurrency.

passing the concerned data packet as a parameter. The network then in- voke client.receivePkt(), delivering the packet to its destination (again, the packet is passed as a parameter to the considered method). A similar proce- dure occurs in order for the client to send an acknowledgment message to the server.

When the SendPacket transition fires, it takes a token from the Data- ToSend place. This token is used as parameter to the RPOOt message network.transmitPkt(sender, dest, Data(n,d));@+Tsp. The @+Tsp means that the packet is sent to the network with a delay of Tsp time units. The transition also returns the packet to its incoming place, DataToSend.

It is important to observe that time was modeled at both the OO level (sending packets to the network) and the internal level (waiting to resend). It is also remarkable that different messages, possibly attached to the same transition, may have different time delays and these time delays may be the result of any valid expression. This allows the modeling of activities with delays that follow statistical distributions like Exponential, Normal, Poisson, etc.

Since the Veritas checker implements property specification design pat- terns [7], it is not mandatory to know a lot about CTL (logic commonly used to express desirable properties of systems) to verify the models. For example: from the property listed above, it is necessary an atomic proposition (packet number n arrives) to universally occur before another one (packet number n+1 arrives). ML functions are written for each atomic proposition and is asked the checker to apply the property pattern universally-before. The functions for the atomic propositions take an RPOO occurrence graph node as parameter and return true or false. The checker also gives a truth-value after it evaluates the whole property. The protocol property previously defined went true.

For simplicity, we write only the structure, as in general the other parts can be easily determined from the context. In particular, it is important to note that, as nets are used to specify the behavior of objects, reachable markings of the nets can be used as internal states. The internal states function maps objects to markings of the correct type nets, as allowed by the type relation. Structures can be expressed in an algebraic notation. The following gram- where E is any structure, x:y.m denotes an action performed by object x that consists of sending an asynchronous message m to object y; and y:x?m denotes an action performed by object y that consists of receiving message m sent by x. Other rules cope with the remaining possible actions and their composition.

In Section 5, it was presented how the structure of an object system in RPOO can be expressed as a formal sum. In what follows, the definition of structures is presented in details. Consider O a (potentially infinite) set of all objects and D a domain of data.

It is not part of this proposition the modeling of timed synchronous messages. This is due to the fact that the semantics of this kind of message does not in- volve the creation of new messages in the timed structure of the object system. This way, defining timed synchronous messages may imply in considering the internal state of the objects, and this can be done by choosing a timed Petri net model to describe the classes.

We presented the main characteristics of a definition for a formal timed OO Petri net based model, named RPOOt. The formalism was applied to the modeling of a simple network protocol, which was simulated and formally validated. Furthermore, some performance measures were taken as result from the simulation process.

Our proposition differs from other timed OO models in different ways. RPOOt is formally defined and supports model checking, differently from the models presented by Selic[16] and Kruger [11]. It allows temporization inside objects and also at OO level, unlike the models from Bichler[2] and Shu[17]. We can also model time delays in a variety of statistical distributions (Normal, Exponential, Poisson, etc), which is not the case in all of these models.

RPOOt is independent of the Petri net model adopted to describe the classes. There is no restriction to the use of untimed nets to describe them. A closer look at the Network Petri net in Section 3 allows to see that it is not a TCP-net model, since it has no timed internal types (it has no places, in fact). This is a concrete example of a working model integrating a non-timed net/class with timed ones (Server and Client nets) via RPOOt formalism.

