Product line engineering represents in an intensive way all valid products be- longing to a PL by means of product line models. In this sense, the feature models (FMs) is one of the available notations to represent product line models. FMs are designed during the early stages of the PL development, and they are a key input to identify common and variable elements of the PL [12]. In a FM, each feature is a prominent or distinctive user-visible aspect of a software system. Thus, FMs are useful to communicate effectively with customers and other stakeholders such as marketing representatives, managers, production engineers, system architects, etc. [12].

The general goal of our research is to find a generic technique that will point out the cause of various kinds of defects in product line models specified with different notations. In this paper, we propose a step towards this goal. Particularly, we present a new method that identifies defects in FMs, and detects possible corrections for each defect.

We suggest to exploit Minimal Correction Subsets (MCSes) to detect correc- tions of defects in FMs. The concept of MCSes comes from the constraint programming area. To the best of our knowledge, it has never been used be- fore for identifying corrections of defects in FMs.

Section 3 explains our method to identify potential corrections of defects in FMs. Section 4, presents implementation details, and Section 5 shows the preliminary evaluation results. Section 6, provides a summary of related works, and Section 7 presents the conclusions and suggests future research directions.

Redundancies: they are dependencies that do not change the semantics of the FM. Redundancies take place when FM has the same information modeled in different ways [35,43]. Although there may be cases where the designer intention- ally introduces redundancy in the FM. In this paper, all identified redundancies

The original model was intentionally simplified, and ten dead features (i.e. ASP, Database, Searches, Dynamic, Statistics, HTTPS, JSP, Minutes, PHP, Seconds ), seven false optional features (i.e. File, Flash, FTP, Milliseconds, Protocols, Ad- ditional services, Logging ), three redundancies (i.e. dependencies D25q, D26 and D28 ) were added to the model. The model was also turned into a false product line (no product can be derived from it). For the sake of simplification we only refer to the dead feature ASP in the rest of the paper.

no solution is found the CSP is unsatisfiable [33]. Constraint Satisfaction Problems could be resolved with constraint solvers 4 such as GNU Prolog [7] or SWI Pro- log [46]. Constraint programming has been used in the product line engineering to represent the semantics of FM in order to reason about them [19, 21, 35].

A MCS is an irreducible subset of constraints whose removal makes solvable an unsolvable constraint program. This term comes from the constraint programming area, and it is usually used for detecting corrections of unsolvable constraint pro- grams [3,15,24,28]. For example, MCSes have been successfully applied in hardware design verification task [1] and circuit diagnosis [34].

If there is more than one subset of corrections, then there are multiple MC- Ses [15]. Each MCS is minimal because it must be completely removed from the unsolvable constraint program in order to turn the program solvable. This ensures that each MCS has only relevant constraints to fix the unsolvable constraint pro- gram [15].

In this section, we describe our method to identify all types of defects presented in 2.2 and their respective corrections. Those corrections are minimal subsets of dependencies that should be removed from the FM in order to correct at least one defect (MCSes). To achieve that, the method receives a FM as input and carries out three steps: it transforms the FM (Subsection 3.1), identifies the defects of the transformed FM (Subsection 3.2), and finally identifies corrections for each detected defect (Subsection 3.3). This last step is our main contribution. At the end, the method presents the defects found and their related corrections.

The graphical representation of FMs does not allow to automatically reason about them. Therefore, the input FM are transformed into a new model named Trans- formed model. This Transformed model is useful, in the next steps of our proposal to create constraint programs on which we can automatically reason about the FM.

(iii) a representation with constraints of each dependency of the FM. We get each constraint using the transformation rules proposed by Mazo et al. [21]. In this way, when in the next steps we create constraint programs, each feature is represented like a boolean variable, and each dependency is represented like a constraint [21].

In this step, we transform the input FM into a constraint program using the Transformed model. Then, our method analyzes the resulting constraint program with the algorithms proposed by Salinesi and Mazo [35]. In this way, when this step ends the method has identified the defects of the analyzed FM and it is ready to identify the possible corrections of each defect.

The method proposed in this paper uses MCSes to identify potential corrections of defects in FMs. Thus, identifying corrections of defects in FMs corresponds to identify the MCSes of an unsolvable constraint program. In terms of FMs, every MCS is a minimal subset of dependencies that should be removed from the FM in order to correct a defect.

To detect the MCSes, our method considers as input a transformed FM and the defect to analyze. Then, the method creates an unsolvable constraint program that is analyzed to identify the MCSes; i.e., the corrections. This step should be repeated for each defect in the FM.

This paper proposes an original algorithm to identify the MCSes of an unsolvable constraint program (cf. Algorithm 1). This algorithm identifies the MCSes by systematically removing the constraints of the model from an unsolvable constraint program until the resulting constraint program has at least one solution. Each constraint that makes solvable the resulting constraint program, belongs to a MCS once it is eliminated. To find all the MCSes, it is necessary to remove the constraints of the model, one by one, then two by two and so on.

Once Algorithm 1 identifies the MCSes of each defect, these MCSes are expressed as constraints, which is not easy to understand for end users. The idea in our method is that designers would be able to understand the corrections identified by the method, even without knowing about constraint programming. For this reason, once the method identifies all MCSes for a defect, it searches the dependencies of the FM corresponding to each constraint of the MCSes. Then, the method searches, for each constraint of the MCS in the Transformed model, its correspondence in natural language. Finally, the method replaces each MCS by its corresponding natural language expression.

All steps of the proposed method are systematic; therefore, they could be imple- mented in a computational tool. In particular, the three steps presented in Section 3 were implemented in a Java tool. The functionality of this tool will be integrated, in a near future, to VariaMos [20], our suite for variability models.

The tool that implements our method uses Java libraries to execute constraint programs in GNU-Prolog [7] or SWI-Prolog [46] ina way to guarantee termination and exhaustive search. Analyzed FMs should be expressed in the SXFM format (Simple XML Feature Model). The results of the analysis are exported into a XLS file. This file contains, in the first sheet, the defects identified for the FM at hand, and in the second sheet, the possible corrections identified for each defect. The tool and its installation manual are available on Internet 5 .

The method proposed in this paper was evaluated preliminarily using 78 models with different features, with up to 120 dependencies. The models were analyzed with the tool that implements the proposed method. Preliminary evaluation focused on two aspects: accuracy and performance. The following subsections presents details of developed experiments and discusses the results.

Falses positives: correspond to correction subsets that were identified by the algorithm are not actual corrections. A correction is a false positive if: (i) the defect for which the correction was identified does not disappear. (ii) it is applied and it is not minimal.

Semi-controlled: at this level, we evaluated the accuracy of the method using a case study where defects and some corrections were known (see Section 2.3). Defects were intentionally introduced into the model, so we knew in advance the expected corrections. However, since the method identified more correction than expected, the results were manually inspected too.

Overall, the method detected 187 corrections out of which 20 were common to more than one defect. This result is interesting, because it indicates that eliminating certain subset of dependencies could resolve more than one defect at the same time. For example, eliminating the cross-dependency between Static and Flash features fixes 3 defects: (i) dead features such as ASP, Database, Dynamic, HTTPS, JSP, Minutes, PHP and Seconds, (ii) false optional features such as File, Flash, FTP, milliseconds, Additional services and Logs ; and (iii) redundancies such as the cross-tree dependencies between File and FTP, and between Content and Protocols.

Randomized: at this level, we evaluated the accuracy of the method on 25 FMs for which we did not know the corrections beforehand. On the one hand side, three of the 25 FM were proposed in product lines literature and are available in the SPLOT repository [23]. On the other hand, the remaining 22 FM were created with BeTTy [36] an automatic FM generator. In order to facilitate the manual inspection of the results, all FMs had less than 35 dependencies. In addition, each model had at least one of the defects presented in Section 3.2, and we consider at least one model for each type of defect.

The scientific literature provides several approaches to automate the identification of semantic defects in FMs [4, 26, 35, 43, 45, 47]. Nevertheless, none of them is able to automatically explain how to correct the identified defects. The originality of our proposal is that it identifies not only the defects to be fixed, but also how they could be repaired.

solve a constraint satisfaction program to identify the smaller size corrections for each defect identified. In this approach, the defects addresed are: void models, dead features, and false optional features. This proposal was automatized in FaMa [41], a framework developed in Java for automatic analysis of FMs. Nevertheless, this work does not identify other subsets of dependencies (not necessarily the smallest), that could be also eliminated to fix some defects. For instance, by considering the dead feature ASP, our proposal identifies corrections with one, two an three elements, whereas the proposal of Trinidad et et al. [40] only identifies corrections with one single element.

and causes. If the model has defects that do not correspond to any defined rules, then these defects will not be detected. This work focuses on identifying some causes of defective FMs, while the method proposed in this paper deals with identifying their corrections. Thus, both proposals are complementary and we could integrate them in order to identify defects, causes and corrections.

To operationalize our proposal, we identify minimal corrections subsets (MC- Ses). In our specific case, these are the minimal subset of dependencies that should be removed from a FM to correct at least one of their defects. MCSes are identified using constraint programs. However, our method automatically traduces the iden- tified MCSes into natural language, in order to provide understandable results. In this way, we use constraint programming as an intermediate language for reason- ing on FM, but this is completely transparent for the FM designer. As indicated in [12, 13, 27, 38, 40], all information supporting the correction process help to save time and cost in the development of the product line. Therefore, we believe that to know the corrections of each defect as soon as possible, would allow designers to focus on creating good representations of the product line domain, rather than finding how to correct FMs defects.

