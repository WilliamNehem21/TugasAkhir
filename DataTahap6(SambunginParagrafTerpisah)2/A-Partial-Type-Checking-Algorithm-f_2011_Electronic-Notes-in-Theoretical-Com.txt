Our main contribution is that we show soundness and partial completeness. By partial completeness we mean that if the algorithm diverges, it will do only be- cause the program or its type, or their combination, contains some loop; divergence because of an error in the algorithm is excluded. Hence, for a given PTS it is suf- ficient to establish termination to show that the algorithm is complete and does indeed decide the typing relation. We believe that this is a promising approach, because it means we can establish basic syntactic properties of the typing algorithm independently of termination.

We start by presenting Type:Type and verifying some basic properties. Next we specify the type checking algorithm in relational form and show soundness of the inductive type checking relation. The completeness of the coinductive relation is then established using coinduction. Finally we present an implementation of the algorithm in Haskell and discuss further extensions of the present work.

Evaluation is lazy, so values are closures Clos t rho, pairs of an expression t and an environment rho. When type checking the body of an Abstraction, the free variable is mapped a unique Id , called a generic value Gen by Coquand [6]. Thus, the environment component rho may map variable names either to generic values or to closures in turn. The (Haskell) type e of environments is passed as a

The weak head normal form (whnf) of a closure might either be an introduction, WType, WPi , or WAbs, or an elimination of a generic value, WNe, i.e., an identifier applied to several closures. Evaluation does not step under binders, thus, the whnf of a function closure Clos (Abs x t ) rho is simply WAbs x t rho.

which has to be evaluated recursively. Or, it might be a generic value, in case x has become free by stepping under its binder. Applications are the source of redexes, which are resolved lazily (cbn), using function app. Expressions of the other shapes, Abs, Pi , and Type, are already whnfs.

We hide the context in a monad of class MonadCxt . The context provides both a type and a value for each name. bind extends the context with both type and value. new extends it with the given type, creating a new generic value. newj creates just a generic value, in situations where its type does not matter.

Input to the type checker are declarations of the form x : A = t meaning name x has type A and definition t . The type checker will first ensure that A is a well- formed type, evaluate it (lazily), then check t against the value of A, and finally bind x to type value of A and the value of t in the current environment. Then it will go on to the next declaration.

We implement contexts as finite maps from names to their type and value. They also handle the generation of fresh identifiers. To this end, the next unused generic value is store in field nextFree. cxtLookup just retrieves the type of a name, cxtExt just binds a type to a name, and cxtBind binds both type and value to a name.

During type checking, we need to query the context and we need to raise er- rors. The type checking monad wraps a reader monad ReaderT Cxt (see module Control.Monad.Reader ) around an error monad Either String . The implementation of the MonadCxt operations access the context through the MonadReader opera- tion ask and modify it through local . The Reader Monad here is only used to hide the plumbing used in a standard implementation of static binding. In particular shadowing of variables is implemented by replacing the previous definition.

