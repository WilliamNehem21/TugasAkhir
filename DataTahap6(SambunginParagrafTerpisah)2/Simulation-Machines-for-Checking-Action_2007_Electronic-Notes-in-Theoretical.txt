Action systems provide a formal approach to modelling parallel and reactive systems. They have a well established theory of refinement supported by simulation-based proof rules. This paper introduces an automatic approach for verifying action system refinements utilising standard CTL model checking. To do this, we encode each of the simulation conditions as a simulation machine, a Kripke structure on which the proof obligation can be discharged by checking that an associated CTL property holds. This procedure transforms each simulation condition into a model checking problem. Each simulation condition can then be model checked in isolation, or, if desired, together with the other simulation conditions by combining the simulation machines and the CTL properties.

The need for tools to support refinement is well recognised. Without such sup- port, refinement is impractical for all but the most critical systems. Traditionally, such tool support has been based on interactive theorem provers. This includes explicit support for action systems [14], as well as the refinement calculus [7]. More recently, advances in automatic verification technologies, including decision proce- dures and model checking, has seen steps towards fully automatic approaches to verifying refinements [11,6,12]. In particular, Smith and Derrick [12] show how the simulation proof obligations for Z refinement can be encoded in a standard model checker.

In this paper, we adopt a similar approach for the more general action system refinement: Rather than encoding the abstract and concrete systems directly into the model checker, we encode each simulation condition as a Kripke structure, or total state transition system, referred to as a simulation machine together with a property formalised in the branching-time temporal logic CTL [10]. This is done in such a way that the proof obligation holds exactly when the CTL property holds for the simulation machine. The latter can be automatically verified using a CTL model checker. This approach avoids the need to build the entire state space of both systems in most cases, and simplifies the properties that need to be checked. The paper is organised as follows: In Section 2 we provide as preliminaries an overview of action systems and action system refinement as well as a brief intro- duction to the temporal logic CTL. In Section 3 we discuss ways of representing the action system simulation conditions as a model checking problem and present our approach. In Section 4 we illustrate our approach through a case study and its encoding in the input notation of the SAL model checking tools [9]. We conclude

Action systems [2] are a formalism for modelling parallel and reactive systems. An action system model describes a machine consisting of an initialisation and a set of actions, each of which is a guarded command (comprising a guard, which enables the action when satisfied, and a statement). The actions are repeatedly executed until none of the actions are enabled and the machine terminates.

CTL [10] is a branching time temporal logic which is defined with respect to Kripke structures. A Kripke structure is a state transition system with a total transition relation. Let M be a Kripke structure and V a set of atomic propositions. A labelling function L maps each state in M to the set of atomic proposition that is satisfied in the state. A valid CTL formula is related to a state s in M , i.e., it is a state formula which is built from state and path formulas:

That is, the actions of A and C are interleaved in the combined system and only affect the part of the state corresponding to that of their original system. Where necessary local variables are systematically renamed to avoid name clashes. Also, skip transitions, i.e., transitions that do not change the state, are added to any states in which no actions are enabled, making the system a Kripke structure with a total transition relation (a necessary precondition for model checking).

To capture such properties in CTL, we first add an additional action to our combined system that enables us to reinitialise the abstract state. This action is always enabled. We then add an auxiliary variable act with values cstutt , astutt , cchange, achange, ainit and none to record that the last action that took place was a concrete stuttering action, an abstract stuttering action, a concrete change action, an abstract change action, the abstract state initialisation action, or no action (only true on initialisation), respectively. Simulation condition (1) can then be expressed as follows: tialised). Both values would be updated by actions in AC corresponding to their intended meaning. In particular, both values would be set to false if any change action occurred. Additionally, the auxiliary variables become part of the guards of actions in AC. That is, we restrict the behaviour of AC to those behaviours that allow us to prove simulation condition (1).

systems AC (it captures only a controlled subset of this behaviour), yet still al- lows us to discharge the proof obligation of the simulation condition. We refer to such a simplified transition system for checking a simulation proof obligation as a simulation machine. In the rest of this section, we provide a more precise descrip- tion of simulation machines and present the simulation machines for checking each condition of forward simulation to verify action system refinements.

They include skip transitions in all phases that can only be exited by the occurrence of actions of the abstract and concrete systems. This ensures the machine is a Kripke structure: in any state it can either exit the state or skip. The CTL properties must cater for these skip actions.

The simulation machine is initialised to states in which R holds. To check whether infinite concrete stuttering is possible, we only allow concrete stuttering steps in the initial phase and have a skip transition to a second phase to ensure totality. If it is possible to stay in the first phase, infinite concrete stuttering is possible.

The second phase is used to test for infinite abstract stuttering. It only allows abstract stuttering steps and can be exited by a skip transition back to the first phase. If it is possible to stay in the second phase, infinite abstract stuttering is possible. The simulation machine is shown below.

That is, if (R holds and) it is possible to always stay in phase p = 5, i.e., perform an infinite number of concrete stuttering actions, then either the abstract part of the state is an aborting state, or it is possible to enter and stay in phase p = 6, i.e., perform an infinite number of abstract stuttering actions.

The encoded actions of the abstract and concrete systems are then combined using the SAL choice operator []. Refinement relation R as well as all predicates used in the CTL properties (i.e., Aaborting , Aterminating , CInit , Caborting , and Cterminating) are encoded as definitions over the state variables of the system. At any phase of the simulation machine they can be evaluated to either true or false, e.g.,

The property associated with the simulation machine for the complete forward simulation refinement check for this case study could be checked to be valid. The checking process terminated in 3.55 seconds on a PC with a 3GHz Intel Pentium 4 processor and 512MB of RAM.

We are interested in extending the applicability of this work in two ways. Firstly, we have only considered forward simulation. This is by far the most common form of refinement, but for completeness we would like to extend our work to also cover backward simulation. Secondly, we are restricted to systems whose types are finite and not too large; otherwise model checking becomes infeasible. These limitations can be lifted, however, by utilising recent advances in the model checking field, e.g., automatic predicate abstraction [8] or bounded model checking [9]. We are particularly interested in looking at the former, and using the fact that the system structure (in terms of phases) and property we wish to prove are fixed, to simplify the abstraction process.

