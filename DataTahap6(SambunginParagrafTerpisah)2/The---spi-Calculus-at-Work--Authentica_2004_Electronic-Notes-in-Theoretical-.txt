In [10], we introduce a process calculus for describing security protocols and we propose a static and compo- sitional analysis of entity authentication. In this paper we apply such a technique on well-known shared key authentication protocols. The analysis helps clarifying the protocol logics, suggests simplifications and reveals some attacks. Moreover we discuss how our analysis scales up to multi-protocol systems.

In this paper, we apply the above mentioned technique to some well-known protocols: Iso Symmetric Key Two Pass Unilateral Authentication Protocol [21], the nonce-based version of the Wide Mouthed Frog Protocol [4], the Woo and Lam Authentication Protocols [29] and the Amended Needham Schroeder Shared-Key Protocol [28]. Our aim is to show that the analysis is applicable to a wide set of authentication protocols. Based on our analysis, we prove the safety of correct protocols for an unbounded number of sessions and, in some cases, we propose simplifications. On the other side, our analysis fails in validating flawed protocols suggesting possible attacks. Moreover, we show that our analysis helps clarifying and formalizing the logics behind the protocols. We give also an example of a multi-protocol system, where entities run multiple sessions of different protocols. We analyze the interleavings among different sessions and discuss how our analysis guarantees their safety.

The reading of the process forms is as follows. Process 0 is the null process that does nothing, as usual. Process new(n).S generates a fresh name n local to S. The constructs for input, output, new and decryption are essentially the same as in the calculus Lysa. In particular, as in Lysa, we presuppose a unique (anonymous) pub- lic channel from/to which messages are read/sent, a technique that models well the worst-case situation of an intruder with a complete control of the network. Sim- ilarly to Lysa, our input and decryption constructs may test part of the message a message composed of m parts matching the respective Di and continues as S, where all the variables instantiated by the pattern-matching are replaced by their actual values. Process out(D1,..., Dm).S outputs a messages composed of m parts and then continues as S. The pattern-matching mechanism is so defined as to en-

receiving x, it signals the start of a new authentication run with B, encrypts x and m with the long term key kAB, and then sends out the encrypted message. Similarly, Responder generates a fresh nonce nB and sends it out. Then, it reads y from the net and decrypts it with the long term key kAB, checking the nonce nB (through the pattern-matching mechanism of decryption). If the match is successful, the variable z gets bound to a message (from A) and the principal commits through

Notice that this trace represents only one of the possible interleavings of Ini- tiator and Responder actions. In this particular trace, commit(B, A) is preceded by run(A, B). According to the Woo and Lam idea of correspondence assertions [30], this trace is safe, since B is convinced to communicate with A (action commit(B, A)) and A is indeed running the protocol with B (action run(A, B) ).

We conclude this section by formalizing the definition of safety based on corre- spondence assertions. As in [16], we say that a trace is safe if every commit(B, A) is preceded by a distinct run(A, B). A protocol guarantees entity authentication if all of its traces are safe.

technique, is to suitably tag it: nB is used for checking the freshness of a message where the identity label B specifies the intended verifier. Thus B is tagged as Id and nB by Verif. Notice that tags makes clearer the role of message components.

is the intended verifier of the current authentication session. Rule (Verifier) can be also used by A to inform a TTP T that B is the intended verifier. In that case the ciphertext is encrypted with a long-term key shared between A and T (see Sections 4.2 and 4.3).

Finally, the protocol uses no session keys and long term keys are neither sent on the net nor encrypted. Thus both the initiator and responder code are key safe and, hence, can be judged correct. By Theorem 3.3, we directly obtain that every trace of Protocoliso is safe, thus no authentication attack is possible. This example clarifies how direct authentication protocols are analyzed by our proof system: the been previously decrypted. That ciphertext must have been encrypted by following one of the principles, in this case (Verifier). This guarantees that a run(A, B) has been previously asserted. Since nonces can be checked only once, in every trace generated by the protocol, every commit(B, A) is preceded by a distinct run(A, B).

kij represents a long term key shared between entities Ii and Ij. We assume that kij = k ji (and correspondingly define the key assignment only for keys kij with i < j). Initiatoriso and Responderiso are arbitrarily replicated for every pair of entities Ii, Ij, using the appropriate long-term key. The proofs of correctness of

= key(kAB, A, B). A d Initiatoriso(kAB, A, B) and for let kAB = key (kAB, A, B). B d Responderiso(kAB, B, A), up to a renaming of identities and keys. As specified by Definition 3.2, replicated identical processes do not need to be re-proved correct.

(Authenticate Verif). (Authenticate Claim) states that A may legally commit (hence authenticate) B only if A has previously generated a nonce n and decrypted a message {B : Id, n : Claim .. .}k (with the same nonce) with k shared either with B,

latter part consists of the parallel composition of principals and trusted servers. Every principal is parameterized by a specific session partner. Also, every trusted server is parameterized by a specific pair composed of a claimant and a verifier (with the respective keys).

Notice that the attack is possible only on the untagged version of the protocol: when messages are tagged, the ciphertext sent in (3.b) differs from the one that B expects to receive in (6.b) because of the different tag. This shows how tag- ging solves message ambiguities. Indeed, we assume that protocol messages are nonce received with her own identity (here is the problem: A wants to authenticate herself with B, but in the ciphertext there is no information regarding B) and sends the ciphertext to C. The ciphertext is captured by the attacker and routed to B, (3.b).

the identity label A. By this ciphertext, B communicates to T he is willing to authenticate himself with A. In (3), A sends to T the ciphertext received by B and, as cleartext, also a fresh nonce nA and the two identity labels A and B. The server distributes, by means of two ciphertexts, a session key kAB to A and B, (4). The identity label B is inserted in the ciphertext encrypted by kAT for communicating to

A that B is the owner of the session key kAB. Similarly the identity label A, in the ciphertext encrypted by kBT , informs B that A is the owner of kAB. Thus nA and nB are tagged by Owner and kAB by Key. In (6), A receives a ciphertext encrypted with kAB. By the nonce-check performed on the ciphertext received in (4), A knows that kAB is fresh. Since A has not generated any ciphertext encrypted with kAB before, that ciphertext has been originated by B. Thus B is alive and A can authenticate him. Similarly, in (7), B receives a ciphertext encrypted with kAB, different from the one encrypted in (6). Thus that ciphertext has been originated by A and B is (Ttp Distribute) is used for checking the safety of the server. The rule allows a TTP T to declare new session keys through messages of the form {I : Id, x : Owner, ks : Key .. .}k. (Ttp Distribute) is trivially satisfied since it has no side conditions.

(Owner) is used for checking the safety of both the initiator and the responder. The rule allows A to send a message {D1,..., Dm}y for confirming to have received the fresh session key y, provided that she has previously decrypted a message

{B : Id, n : Owner, y : Key .. .}kAT , declaring that y is a fresh key shared with B, and she has previously performed a run with B. Both the conditions are satisfied in InitiatorNS(ki, Ii, Ij) and ResponderNS(kj, Ij, Ii).

sage {B : Id, n : Owner, y : Key .. .}kAT , encrypted by a TTP, including a fresh ses- sion key y owned by B and a nonce n that A previously generated; and (ii) at least one message {D1,..., Dm}y that she did not generate 6 . (Authenticate Owner) is satisfied in InitiatorNS(ki, Ii, Ij) as well as in ResponderNS(kj, Ij, Ii).

A is running as initiator in the Wide Mouthed Frog Protocol, while B as responder in the Woo and Lam. B intercepts the message sent by A to T and exploits it for completing the authentication session. The interleaving arises since the second message of the two protocols has the same structure: an identity label, a payload and a nonce. Also the tags are the same. The corresponding trace is (Authenticate Owner) After receiving {B : Id, n : Owner, y : Key .. .}kAT and checking the nonce n, A authenticates y as a fresh session key owned by B. The reception of {D1,..., Dm}y authenticates B. See section 4.4.

cation protocols, e.g., protocols based on public-key encryption and other kinds of nonce-challenges [18,19]. We are basing such an extension on a type and effect system. This should allow us to formally compare our approach with the type and effect systems proposed by Gordon and Jeffrey in [16,17].

