In ADR, an architectural style is an algebra where the values (i.e. the archi- tectures) are usually graph structures representing components and their intercon- nections, typed by an interface which expresses the external connection capabilities for composing larger architectures. The operators are themselves graph structures with holes (referenced via variables), and the application step consists of replac- ing variables with values by respecting the connection capabilities and by possibly simplifying (i.e. reducing to normal form) the resulting graph structure. ADR can exploit different kinds of graph structures, depending on the applicative domain. For example, in one of its more general forms, such graph structures can contain special nodes representing some parameters of the system taking values over a finite domain, special edges representing constraints over the admissible assignments to certain groups of nodes and the simplification phase can involve performing con- sistency checks, merging nodes, and solving adjacent constraints. Other examples are given by taking relational structures over nodes as edges, or by taking algebraic theories as nodes and theory morphisms as edges.

Contribution. In this paper we introduce a flavour of the ADR approach, called Hierarchical Design Rewriting (HDR) which has hierarchical graphs as the underlying algebra of designs. While in previous ADR papers only flat graphs were considered, in HDR the idea is to allow also the insertion of nested graphs within the edges of the base graph model, taking advantage of the presence of symbolic operators (whose application is modelled as an explicit substitution, i.e. without the simplification phase) besides ordinary interpreted operators. This allows the representation of partial architectural information and also provides a neat visual representation of designs. However, in this paper we propose for the first time the role of derived operators as a disciplined and efficient way to deal with partial architectural information.

Structure of the paper. Section 2 gives the basic background on ADR and discussed the issue of partial architectural information. Section 3 presents our im- plementation of the graph structures underlying HDR. Section 4 shows how to write HDR specifications. Section 5 illustrates how to analyse HDR prototypes with ad- hoc and built-in mechanisms such as rewriting strategies or the LTL model checker. Section 6 draws some conclusion and sketches our future research programme on ADR. We assume the reader has some familiarity with the Maude syntax.

We distinguish two kinds of edges in the type graph: terminals T and non- terminals NT . Likewise string grammars, terminal edges represent basic, non- refinable, concrete components of the architecture, while non-terminal edges, rep- resent complex, refinable, abstract components. From now on we assume that all our graphs are T -typed and omit to mention it explicitly (the type graph will be always clear from the context).

A design d is partial (resp. concrete) if Rd contains (resp. does not contain) non-terminal edges. In service-oriented applications dealing with partial designs is natural and essential: the architecture of services is only instantiated when needed after a proper discovery, selection and binding.

However, it should be evident that ADR modelling has at least two options regarding the level of abstraction: the purely symbolic initial algebra associated with productions, where the non-terminals become sorts and each p becomes an operator of the signature, or the fully evaluated algebra of concrete designs, where the construction proof is abandoned and the only additional information retained concerns the sort of the design, i.e. its interface.

for the design and analysis of software systems. For this purpose we will travel through our implementation from the low level of graphs to the algebra of designs to the design of a simple scenario. Due to obvious space restrictions we shall include flashes of Maude code, only. However the complete specification of our prototypical implementation can be downloaded [6]. In particular, we neglect the declaration of variables which are identified since all of them are suffixed with a natural number and their type is clear from the context.

Sort Graph is intended to represent well-formed graphs, while its kind [Graph] might also include bad-formed graphs. Below we see the operation to construct graphs. It sticks to our formal model, i.e. it constructs a graph from a set of nodes, a set of edges and a map from edges to lists of nodes.

Note that also other graph operators could (but should not) produce bad-formed graphs. This mechanism serves also for debugging purposes, i.e. obtaining a bad- shaped graph is a sign of possible bugs. This technique is applied in almost all our modules. Thus we will not explain it again. It suffices to note that kinds are used to refer to possibly bad-formed structures and for each of them there is a membership axiom to determine well-formedness.

The main operation over hierarchical designs consists of flattening the first non- terminal edge, i.e. substituting the non-terminal edge by the corresponding hierar- chical design. The operation is called apply (in honour of the analogy of making effective the symbolic application) and it basically implements the concept of type- consistent hyper-edge replacement [16].

We now return to the issue of considering partial architectural information. As we already stated, one way to deal with it is to just evaluate some parts of a design term. In order to have design terms that mix evaluated and symbolic parts we need to declare the sorts of our style algebra to be subsorts of hDesign. For instance, a term like

Following the analogy of the design, where we have an abstract view and an interpreted one, we have can also implement specification mechanisms tailored to the symbolic level. A possible approach is to follow the same principles as standard spatial logics (e.g. [8]) where each operation of the algebra has modal operator as counterpart. A more ad-hoc approach consists of defining ad-hoc properties directly (and thus more efficiently).

For instance, we can implement a binary predicate !> to be used as proposition in the built-in LTL model checker. Predicate f1!>f2 holds whenever f2 does not precede f1. It is based on predicate appears. The predicate appears(f1) holds if the filter f1 is used. Below, we see the implementation of the satisfaction relation i.e. to look for models violating or satisfying some properties in order to better understand and eventually correct the kind of architectures (e.g. the style) under consideration. As we have already mentioned, model finding is supported in our implementation of ADR by rewrite theories simulating the design-by-refinement process.

We believe that the presentation of our prototypical implementation offers sev- eral contributions. First, we show that ADR is not only a well-founded theoretical approach but also a tool-supported framework for the design and analysis of soft- ware architectures. Second, for the sake of this presentation, even if we concentrate on one particular algebra of designs and one particular scenario, we trace a method- ology for developing other ADR-suited algebras and scenarios. Last but not least, we offer a further validation of the suitability of rewriting logic as a formalism for the development and analysis of software systems.

Maude has already been used in approaches to software architectures. For in- stance, in [19] Maude is used to model and verify software architectures given in Lf P, a system description language with hierarchical behaviour. Another example is [26] where a rewriting semantics of the CBabel architecture description language is defined.

