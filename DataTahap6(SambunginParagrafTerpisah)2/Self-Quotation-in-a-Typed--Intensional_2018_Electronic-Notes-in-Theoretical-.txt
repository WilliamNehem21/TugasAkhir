Intensional lambda-calculus adds intensional combinators to lambda-calculus to facilitate analysis. In par- ticular, they are used to factorise data structures and programs into their components, which can be used to convert abstractions into combinators. This paper shows how to type an intensional lambda-calculus using no more than the types of System F. Even the quotation function used to access program syntax can be defined and typed, as can its inverse: the calculus supports typed self-quotation. Thus, one may freely alternate between program analysis and program execution. Proofs of all results have been verified in Coq.

Third, the calculus should be typed. This provides a sanity check on the whole approach. In particular, it is common to model each stage of interpretation by rising one level in a type hierarchy. This is inherently difficult, and often limits the nature of the analyses that are possible. To put it another way, if the analysis is to be done in the source language, all of the usual arguments for typed programming languages also apply here.

where P| and [P are the left and right components of P . If P is, say, SP1P2 then its components are SP1 and P2. The complete account of factorable forms is made more complicated by the need to factor abstractions. The term M in the rule must be sufficiently polymorphic to handle the components of P , no matter what their types prove to be. Hence the principal type of G is

This is a closed normal form, since the application of A blocks the reduction of the fixpoint operator Y until an argument has been supplied. E is used to check if p is an operator. If not then G is used to factorise p and recurse. Further, it has type where abs left = I is used as the left component of an abstraction. The key point about abs left is that if it is the left component of an application IN then the application is a redex, and so will not prove to be a compound. In general, words in sans-serif, such as abs left may be used to name particular terms of the calculus, as well as the meta-variables M and N , etc. Perhaps surprisingly, the components of an operator O are defined to be KO and O. It will follow that GMO reduces to M (KO)O. If, as is usual, this is not desirable, then operators must be excluded by first using E to identify them, as in the example of quote introduced earlier.

The status of an operator is one of Ternary op, Binary op0, Binary op2, Binary op1 or Ternary op1. Now a term is a compound if its status is one of Lazy2, Lazy1, Eager2 or Eager. It is factorable if it is a compound or an operator.

First consider the restriction to closed terms. This restriction will not be very controversial, but if open terms are of interest they can be handled by analyzing the closed terms obtained by abstracting with respect to the free variables. This reduces to the problem discussed above.

It follows that the solution is to add intensionality from the beginning, starting with a factorisation operator, say G, so that programs can be analysed through a general divide-and-conquer approach. Typing introduces a delicate challenge: how to exploit type information obtained during analysis. Following the database approach, we restrict our attention to two sorts of analysis, queries and updates.

