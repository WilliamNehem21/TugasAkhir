structuring are possible through the fundamental notion of random bag preservation. Random bag preserv- ing operations enable the constructive tracking of the data and the distribution of the data states during a MOQA computation. This in turn enables the (semi-)automated derivation of the average cost of the operations. Two fundamental MOQA operations enable the creation and destruction of data structures: the MOQA product operation, which is the subject of this paper, and the MOQA delete operation, which forms the subject of [3]. The introduction of the entire MOQA language is well beyond the scope of this

paper and will be reported in a book [2]. The language has been implemented at CEOL and automated derivations of average-cost of data structuring are under way. Here we report on a (simplified) version of the fundamental notion of random bag preservation and demonstrate that the central MOQA product operation possesses this crucial property.

MOQA is a domain specific high-level language. The language has extensive pro- gramming capacity in the sense that it includes for-loops, (terminating) recursion and conditionals. This approach enables the programming of a wide variety of data restructuring algorithms, including most sorting and searching algorithms.

It is easy to see that random structures allow one to incorporate traditional labeled data structures, such as heaps, unordered lists and sorted lists, as long as the labelings respect the underlying order. We illustrate this in the next example, where for each data structure, i.e. partial order, all possible data states are represented.

Example 2.5 In each part of the example, we display the Hasse Diagram of the given partial order on the left and the states on the right. In each case the underlying set consists of elements {x1,..., xn}, while the labels are the set of indices {1,..., n}. Part a) illustrates that random structures incorporate the case of lists in a natural way.

Finally, we remark that heaps can be represented as random structures over a partial order which has a tree as Hasse Diagram. Heaps of size n are denoted by Hn. For instance, the random structure H3 determined by the following Hasse Diagram and label set {1, 2, 3, 4} consists exactly of the states H4[1], H4[2] and H4[3] displayed below.

Remark 4.2 In case n = 1 and K = 1 we identify the random bag with the random structure R1. i.e. we interpret a random structure in the context of random bags as a random bag of size one and multiplicity one.

The random product is a fundamental MOQA data structuring operation which enables the joining of two data structures into a larger data structure. Here our aim is to illustrate that a random bag preserving product operation can be obtained and we present a proof of this result. Research is ongoing at CEOL on alternative versions of the product and efficiency comparisons. The techniques for verifying ran- dom bag preservation as outlined below are however standard approaches and serve to illustrate that the most common version of the product satisfies this property.

In order to define the random product, we first define the product of two finite partial orders. The definition is similar to the one given in [1]. Then we define the product of two labelings and we extend this definition to sets of labelings. Finally,

Example 5.2 If we consider the sets X1 = {x1, x2, x3} and X2 = {x4, x5, x6, x7} then X1  X2 = {x1, x2, x3, x4, x5, x6, x7}. We indicate the new pairs added via the operation  via dashed lines.

We indicated the selection of labels of extremal elements by full circles and these elements occur swapped in the following picture. For each while loop execution, initiated by an original swap of labels of two extremal elements, the other pairs of elements to be swapped are linked in the picture via a double arrow (in dashed line display). These elements occur swapped in the picture. The final picture illustrates the end result of the computation, i.e. F1  F2.

We remark that this fact does not alter, even after the first two push operations in the algorithm have been run through a number of times. Inductively one can show that Ra(F1) = Ra(F') remains true. Indeed, in case a < b no swaps will occur and the result holds trivially. Otherwise, after the first series of swaps has happened for the first two while loops, we obtain that in Ra(F1), the label a simply

We remark that we can extend the unary random product to operate on random sub-structures of a given random structure as outlined in [2]. The details are tech- nical and are omitted here. Suffices it to say that in case the unary random product is applied to a so-called isolated subset of a partial order, the operation is still guar- anteed to be RS-preserving. This is illustrated in the example below. Again, we do not provide the formal definition of an isolated subset due to space restrictions. The increased generality of the application of the operations greatly increases its use in the MOQA language. The reader is referred to [2] for a comprehensive discussion.

