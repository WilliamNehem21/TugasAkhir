Such situations have precarious impacts to the maintainability of software sys- tems. In december 2004 a dangerous security hole was detected in the GDI+ com- ponent, which renders JPEG files on Windows platforms (see [4]). As multiple applications deployed the component as a Dynamic Linked Library (DLL) locally, so that it was installed in parallel in many cases, the security hole could not be fixed by simply substituting one centrally installed component.

One real-world example of such situations is the so called DLL-Hell (cf. [5,14]). The setup procedure of different applications on Windows platforms overwrote com- monly used components by their own, not necessarily newer versions. Accordingly, the new applications worked as expected, but some of the already installed programs behaved unexpected, if operating at all.

There are a couple of approaches, which are able to check the conformity between different evolutionary states of a component and automatically detect incompatible changes. The most promising systems in this area have been compared by us in [17]. Depending on the system, more or less contract levels (syntax, behavior, synchronization, quality) are included in the analysis, if a certain component is in the position to replace another completely. The upgrade is allowed, if the conformance check yields the substitutability for all components, the administrator wants to replace.

Both systems and their tools rest upon different heuristics that are pragmatic but minimize the solution space for finding compatible systems. In case of an update, tools like apt or rpm will always try to install newest packages only. If a well-defined system state could only be achieved by moving some packages back to an older version, these tools are not the best choice. Furthermore it is accepted that deb- or rpm-packages are always backward compatible to older versions. Packages that would violate this rule are simply renamed (e.g. with the new major-revision- number in the package name) and from then on exist in parallel with older version in the package-repositories.

components. Especially against the background of the objective function defined above, we have to punish the usage of otherwise unnecessary components in a system which increases the version sum. Therefore, we have to define another objective function for ensuring a minimal system regarding the count of used components by accumulating the sum over all decision variables xRi . For the example this leads to:

We now have multiple objective functions against which we want to optimize our solution. It is provable that solutions for the linear relaxation of single objective functions are always located on a vertex of the n-polyhedron, given by the con- straints of an optimization problem (cf. section 3.2). In a best case, the relaxation is also an integer solution. Otherwise we found a good upper bound for a search (see section 4.1). In case of multiple objective functions, the optimal solution is located on the edge of the n-polyhedron between the vertices of the single optimal solutions.

In our example, we would first solve the problem against T1(xi) where we derive a maximum sum for the version-numbers of 5. Now we can solve the problem against T2(xi) but additionally trying to minimize the difference between the version sum and the resulting version sum of the result of T2(xi). By changing the order of applied objective functions and weighting the detected differences to prior calculated results, we can influence the optimization process in a smooth way.

Hence we need a mechanism that cuts non valuable branches off the search space, reducing the search complexity to a minimum. Branch-and-Bound (see [20]) is one representative of such mechanisms. The core idea of Branch-and-Bound is to calculate an upper bound z (in case of a maximization problem) for an objective function to restrict the search to interesting branches. Such an upper bound is calculated in each search state. In combination with a measurement for unexpanded branches, we can reduce the search space to a minimum.

In our case this bound could be the sum of maximum version numbers of a valid system. During the search for valid combinations, only those branches are expanded that have a sum of at least the upper bound calculated so far. If we find a solution with a greater version sum, we found a new upper bound. So we can remove other branches from the list.

If the model has a feasible solution, the constraints of the model can be inter- preted as the border of an n-polyhedron with non empty volume. Thus the search for an optimal solution can be reasoned by a geometric perception. In principle, an optimal solution can be found on vertices of that polyhedron. Simplex algorithms (cf. [19]) move from vertex to vertex via the edges of the polyhedron to find the optimal solution while interior point algorithms (cf. [13]) also use interior points of the polyhedron to find an optimal solution. Both methods guarantee to compute an optimal solution after a finite number of calculation steps.

From a theoretical point of view interior point algorithms are superior to simplex algorithms. There are interior point algorithms (e.g. [9]) that solve the linear optimization problem in worst-case polynomial time while the existence of a worst- case polynomial running simplex algorithm remains an unsolved problem 6 . In practice simplex algorithm perform very well and are successfully used in lots of optimization tools. Furthermore, simplex algorithms are better suited for Branch- and-Bound. Through the relaxation of the 0/1 constraints, we derive continuous values for the decision variables and an upper-bounds estimation. If the calculated bound in a certain search state is less than a bound calculated before, then we do not have to expand this branch.

In section 3.1 we assumed that the current system consists of the versions A1, B1 and C2. The mission is now to update component A1 by a newer, bugfixed version A2. The described mechanisms solve this problem and generate a system that downgrades component C2 to C1 as the only possible solution. We know of no other approach that would be able to generate such a solution.

tutability of an old version against a new one. If substitution is not possible, we can use Componentor, to analyze the reasons of this conflict and try to find valid combinations using the sketched optimization mechanisms. If all this fails, the tool is able to generate advices, how different components could be changed in order to ensure compatibility again.

To apply our methods, the components have to form direct dependencies. The more generic software becomes, the less applicable are our methods. Dependencies that arise from dynamic instantiation and the use of reflection are not seizable by static code analysis. Such dependencies could only be discovered by dynamic analysis, e.g. during unit testing.

