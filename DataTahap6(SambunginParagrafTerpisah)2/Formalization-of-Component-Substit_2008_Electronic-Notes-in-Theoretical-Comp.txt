Component based software has gained recognition as the key technology for building high quality and large software. In this setting, sharing collections of components has become common practice for component oriented appli- cations. These components are independently produced and developed by different providers and reused as black boxes making it necessary to identify component dependencies to guarantee interoperability.

Several techniques exist to ensure substitutability between components, see for example [12,13]. All these approaches are built upon the substitution principle of Liskov introduced in [1] in the context of object oriented pro- gramming. They use the interface type to define a subtyping relation between components and then authorize Cnew to replace Cold only if Cnew is a subtype of Cold. Various forms of those types exist, starting with the classical interface type [10] and enhancing them with behavioral description such as automata for example [6]. Some related research [12,13] show that the resulting condi- tion of pure subtyping ensures safety of the replacement but is too restrictive. Recent work [5] has shown the limits of this approach and proposes a less restrictive notion of substitutability depending on the context. In this setting, Cnew may safely replace Cold in certain systems. In fact, all interfaces not used in the context are ignored when ensuring the subtyping.

The paper is organized as follows. Section 2 introduces our dependencies description and illustrates it with the example of a mail server in Linux GNU. In Section 3, we present our substitutability approach with a progressive re- finement of substitutability definitions. Section 5 describes the substitutability checking algorithm. Section 4 illustrates some substitutability examples. Sec- tion 6 discusses related work. Finally, Section 7 concludes and discusses future work.

Intra-dependencies are defined by the producer of the component and used to perform installation. Inter-dependencies result from installation and are used to perform deinstallation and replacement. The two notions are briefly presented below, more details on these concepts are given in [2].

Contextual substitutability is related to the context which represents the resources and the architecture of the target system. Ideally, it could be the union of the dependencies of all components (part of the system). The result- ing description of the context would be a huge logical term. Its manipulation when deciding whether to authorize a deployment operation would be difficult and expensive (in calculation). Thus, we have chosen instead a safe approxi- mation of the context description. The context definition is presented in [2]. It is summarized as follows:

Compared to existing substitutability approaches, the condition (NC) is orig- inal because it enables to take into account various form of component effects on the context (potential conflicts that can occur due to the new compo- nent) and maintaining the safety of the system. In an extension of our system not presented here, we have the specification of non-functional properties. Re- placing a component by another may have an impact on the system properties and therefore may be forbidden. An example of a such substitution is further discussed in Section 6.

