Control operators come in bewildering variety. Sometimes the same term is used for distinct constructs, as with catch in early Scheme or throw in Standard ML of New Jersey, which are very unlike the catch and throw in Lisp whose names they borrow. On the other hand, this Lisp catch is fundamentally similar to exceptions despite their dissimilar and much more ornate appearance.

manipulation accounts for the labelling and jumping. This is done symmet- rically: here makes the jump continuation the same as the current one k, whereas go sets the current continuation of its argument to the jump contin- uation q. The clauses for variables and applications do not interact with the additional jump continuation: the former ignores it, while the latter merely distributes it into the operator, the operand and the function call.

In the typing of call/cc, a go is (at least potentially, depending on f ) exported from its enclosing here. Conversely, in the derivation of right ex- change, a go is imported into a here from without. What makes everything work is static binding.

In both of these cases, the dynamic jump continuation d is fed to each function call, but never needed. Each function definition must expect this argument to be of certain type. Because different calls of the same function may have dynamically enclosing here operators with different types, the type ascribed to d should be polymorphic.

In this paper, control constructs were compared by cps transforms and typing of the source. A different, but related approach compares them by typing in the target of the cps [1]. On the source, we have the dichotomy between intuitionistic and classical typing, whereas on the target, the distinction is between linear and intuitionistic. We hope to relate these in further work.

