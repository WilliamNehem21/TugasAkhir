Research approaches to safe substitution aim to ensure reliable substitutability by employing formal methods. However, the models used in these approaches tend to be too complicated to be usable by average software developers and the meth- ods often suffer from prohibitive algorithmic or space complexity (cf. for example [15,16]).

Industrial systems on the other hand almost exclusively use rather simple meta- data, most often version identifiers (e.g. [18]), to manually tag components as being compatible with their previous versions. The key disadvantage of this approach is fragility caused by the reliance on human effort to provide correct meta-data.

On a very high abstraction level, Georgas et al. [12] use a model of application architecture at run-time to manage its evolution. Constraints can be specified on the policies governing the evolution (adaptation) in order to preserve chosen archi- tectural properties. The work however does not provide concrete details about the model, the constraints and ways to check them.

Many research approaches have addressed this need using holistic approaches with global integrity properties [21,11]. Chaki et al. [9] for example use composi- tional reasoning and dynamic assume-guarantee checks to provide formally sound evaluation of substitutability with similar practical properties as our contextual one. Most of these methods are however based on advanced formal systems (e.g. model checking, behavioural subtyping) often supported by specialized specifica- tion notations. These methods tend to suffer from prohibitive algorithmic or state complexity [16,9] and the notations tend to be too complicated to be usable by

Few research works have been concerned with use in industrial component frameworks. Polakovic et al. [20] implement architectural consistency checks for a resource-constrained component model, using a combination of compile-time type conformance verification and error handling code. Our approach would be hardly feasible in such cases due to the resource demands.

We noted in the introduction that it is useful to capture the deployment environ- ment of a particular component for evaluating substitutability. This component deployment context contains the other components and architectural connections within the environment in which the component is employed. The environment can be a component cluster (a closely coupled part of a component application), the component-based application or the whole run-time environment surrounding a deployed component in the run-time framework.

In the approach presented here we concentrate on the first area, which is a deliberate simplification of the issue. The rationale for this decision is based on the challenges faced when working with industrial component frameworks. There, specifications of advanced aspects are not available or cannot be reconstructed from implementation in most cases; therefore, especially semantic compatibility is hard to verify.

There are several fundamental issues that an implementation of contextual sub- stitutability needs to address in general. Firstly it has to implement the element subtype relation at run-time, and choose appropriate type representation on which to perform it. Secondly there needs to be a means of extracting this component types and contextual complement representation from various sources. In the folow- ing paragraphs we will discuss our approach to addressing these issues for the OSGi case.

The foundational issue is the means of obtaining and representing the types of el- ements contained in the component specification. Normally this issue is delegated to the relevant language compiler; however, in our case a run-time component type representation is needed together with mechanisms to obtain it from both the in- stalled and replacement components. Additional complication is that in OSGi, the specification data is scattered in several places (the manifest file as the pivotal point, XML and other additional meta-data e.g. for the declarative services, and the bytecode of bundle implementation).

Apart from the reasons given in preceding sections, this design can be defended for the following fundamental reason: the method does not place any limitations on the kinds of component interface elements it is applied to. Therefore it can incorporate any semantic or behavioural specification compatible with our model of component type. An example of an advanced kind of component interface element for which our method could be applied is the behaviour protocol [19] originated in the SOFA component model. In its case, the protocol compliance relation plays the

Concerning further research, the formal definitions of the method should be extended to clusters of components (e.g. to support safe substitution of larger sub- sets of applications) and applied more specifically to inter-component relations in dynamic architectures. The practical implementation for OSGi will need to supply the missing aspects of the component model, and overcome the issues of tighter integration in the frameworks.

