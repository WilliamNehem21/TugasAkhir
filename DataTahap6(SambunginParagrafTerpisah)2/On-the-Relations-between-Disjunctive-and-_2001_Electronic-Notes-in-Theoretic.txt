Disjunctive Logic Programming (DLP) [13] and Linear Logic Programming (LLP) [11] are among the more interesting extensions of the classical theory of Horn logic, underlying languages like Prolog. The motivations behind the introduction of these two paradigms look quite different. On the one hand, disjunctive logic programming has been introduced in order to represent uncer- tain beliefs. On the other hand, linear logic programming has been introduced in order to add state-based computations to pure Prolog programs. A closer at the operational semantics of the two languages. In DLP, a resolution step is extended so as to work over positive clauses (sets/disjunctions of atoms). Implicit contraction steps are applied over the selected clause. In contrast, being in a sub-structural logic in which contraction is forbidden, LO resolu- tion has the same effect as multiset rewriting (applied to collections of atomic formulas).

The view of DLP as an abstraction of LO is appealing for several reasons. First of all, it opens the possibility of using techniques developed for DLP for the analysis of LO programs. Furthermore, it shows that the paradigm of DLP could have unexpected applications as a framework to reason about properties of Petri Nets, a well-known formalism for concurrent computations [10], as discussed in [5].

containing positive clauses in the body. Following [13], we will deal with first- order programs by considering the set of ground instances of program clauses. Given a program P , we will use the notation Gnd (P ) to indicate the set of ground instances of clauses in P . Moreover, we will identify positive clauses with sets of atoms.

Let us now go back to disjunctive logic programming. In Section 3, we have shown that the operational (top-down) semantics of DLP can be presented in terms of a proof system with an explicit contraction rule. Furthermore, the weakening rule is admissible in DLP. A natural question arises: what happens

In our recent work [4,5], we have shown that LO programs are amenable of a fixpoint semantics that characterizes the set of provable LO goals. As the corresponding semantics for Horn and disjunctive programs, in the proposi- tional case the fixpoint semantics for LO can be computed in a finite number of steps. The fixpoint semantics of LO allows us to investigate in more depth the relationship between LO and DLP. For this purpose, we can employ the mathematical tools provided by abstract interpretation [6], and in particular the notion of completeness that can be used to estimate the precision of an abstraction.

Abstract Interpretation [6,7] is a classical framework for semantics approxima- tion which is used for the construction of semantics-based program analysis algorithms. Given a semantics and an abstraction ofthe language constructors and standard data, abstract interpretation determines an abstract represen- tation of the language which is, by construction, sound with respect to the standard semantics. This new representation enables the calculation of the abstract semantics in finite time, although it implies some loss of precision. We recall here some key concepts in abstract interpretation, which the reader can find in [6,7,8].

In [5] we have proved a preliminary result, namely that the abstraction is complete for the subclass of LO programs whose clauses contain at most one conjunct in the body (i.e. conjunction is forbidden). This subclass is particularly interesting, as discussed in [5] and briefly mentioned in Section 7.2, because it can be used to encode Petri Nets. We address now the problem of proving completeness of the abstraction for the entire class of LO programs (we remind the reader that we are actually considering the subclass of LO programs corresponding to DLP programs as defined in [13], i.e. without nesting of connectives). We will give an indirect proof of this fact based on the connection between the notion of completeness and proof theory. The proof will be presented in Section 7.1.

In this section we discuss the relations between the notion of completeness of the abstraction and the proof-theoretic notion of permutability of rules, thus creating a bridge between Sections 3.1 and 5, on the one hand, and Section 6.2, on the other hand.

which are preceded in the proof tree by at least an application of ctrr (i.e. there is a path from a leaf to that application of bc which includes at least one application of ctrr) and reduced the remaining applications of bc. The

For simplicity of illustration, let us assume for the moment that all ctrr appli- cations in this fragment are performed over atoms in C1,... ,Cm. Contractions over the context A are much simpler to address, as we will describe later on. Now, we can safely assume that our proof fragment has the form

Finally, we note that contractions performed over the multiset A which is not directly involved in the backchaining step are even simpler to address. In fact, A is simply passed unchanged to every sub-branch, therefore we can transfer these contraction steps below the original bc application. It is suffi- cient to perform, for every element in A, as many ctrr steps as the maximum number of such steps performed over that element, where the maximum is taken among the original m bunches of contractions.

other hand. We hope that our research will also give rise to new ideas for the analysis of LO programs. As an example, it could be interesting to study weak notions of negation for LO that are based on the negation of DLP. Also, we have mentioned another possible application of DLP operational and fixpoint semantics, namely Petri Nets analysis. Finally, there is still some on-going work concerning the relation between DLP and LO in the setting of abstract interpretation. In particular, we are studying a direct proof of completeness of the abstraction and its relationship with the indirect proof presented in this paper. Also, formally studying the complexity of the transformation between generic DLP proofs and restricted DLP proofs (as shown in the proof of completeness) could be worth in order to quantify the gain obtained by proving properties on the abstract domain rather than on the concrete one.

