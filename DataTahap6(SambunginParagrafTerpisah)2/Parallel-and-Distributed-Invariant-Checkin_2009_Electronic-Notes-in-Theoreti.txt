In the last step, a counterexample is generated and also optimized. That is, loops and other unneeded parts are removed to ease its comprehension. The counterexample is presented in the assembly code, the C code, the control flow graph of the assembly code, and as a state space graph.

The algorithms described in the remainder of this section differ in the im- plementation of the functions used to access the state space. In our algorithms, two different approaches to load balancing and one partitioning function are used. Moreover, communication between threads is implemented using differ- ent data structures and synchronization primitives.

For static load balancing, only the structure of the processed state has an influence on the assignment of a state to a thread. Stern and Dill [22] propose using an evenly distributed hash function. The static load balancing function implemented in [mc]square is the static partitioning function described in Sect. 3.1.1.

A different approach to static load balancing is described by Lerda and Sisto [19]. In their approach, the load balancing function is not based on the complete state but only on small parts. The idea behind this approach is that only small parts of a successor state are changed in a single transition. This approach increases the probability that successors of a state s are processed by the same thread as s. Developing an evenly distributed balancing function for this approach is challenging and sometimes impossible.

This section describes the implementation of four different parallel algo- rithms. For the implementation, we have evaluated the performance of the following Java containers for storing states: HashMap and TreeMap, ac- cessed using explicit synchronization, as well as ConcurrentHashMap and ConcurrentSkipListMap. We observed results similar to the experiments of Goetz et al. [11], that is, ConcurrentHashMap being the fastest solution for parallel access.

balancing. This structure corresponds to a bidirectional producer-consumer pattern. Successor states are generated by n threads, which are consumed by the master thread and stored in the state space. The master thread uses the partitioning function part(s) to determine the thread that processes state s. That is, the master thread fills the queues of the invariant checkers.

This section describes an algorithm for distributed state space generation, which is based on the approaches of Stern and Dill [22], Lerda and Sisto [19], and Holzmann and Bosnacki [14]. We use the term node for each process in the distributed network. One master node is used, which starts the other nodes and detects termination of the distributed algorithm. It performs a different task than the master thread for parallel invariant checking.

In the distributed algorithm, each node runs three threads. The main thread executes invariant checking, that is, it has exclusive access to the state space, and performs load balancing. In our distributed approach, static load balanc- ing and static partitioning are used as in the parallel case. Two threads, a sender and a receiver, are used for communication of states between nodes,

We used two programs for the ATMEL ATmega16 microcontroller to evaluate the performance of the presented algorithms. The program adc.elf imple- ments a distance measurement using an infrared controller. It consists of 467 lines of assembly code, which result in 434,756,686 states with all opti- mizations such as delayed nondetermism or dead variable reduction enabled in [mc]square. The program window lift.elf implements a controller for a powered window lift used in a car and consists of 288 lines of assembly code. Without any optimizations, this program leads to creation of 2,589,681 states. We have chosen different abstraction techniques to uncover a potential influence on the performance of the parallel and distributed algorithms.

We identified two reasons for these results. First of all, we believe it stems from the inefficient synchronization primitives in Java as it can be ob- served in all implemented parallel algorithms. Similar results were observed by Inggs [15] and Goetz et al. [11]. Another problem is the structure of our multi-core system. Although the server has a shared-memory architecture, existing libraries. In the end, we only kept the implementation of the best parallel algorithm, namely static load balancing and local access to the state space, and the distributed algorithm. Both algorithms can be tuned by users by adjusting the number of threads or nodes used.

more than 5 processors barely paid off and sometimes even caused a slow- down due to the synchronization overhead. Comparable numbers were also observed by others such as Inggs [15] or Goetz et al. [11] when dealing with parallel Java programs. It could be the case that this observation is caused by the communication between the data structures used in Java. There are two possible solutions to this problem. First, we could implement the important methods in C or C++ and then use the Java Native Interface to use these methods. Another solution could be to use the new Java 7 version as it will include several performance improvements.

State spaces for invariant checking can also be used for model checking. For model checking, we plan to extend our global CTL model checking algorithm. We expect that this allows to use more than a single search front for state space building. In the local model checking algorithm, this is not efficient as it contradicts the local character of the algorithm.

