In this paper, we describe a system, written in Haskell, for the ontology-based approximate filtering of XML data. Basically, it allows one to extract relevant data as well as to exclude useless and misleading contents from an XML document. The system provides a declarative language one can use to define XML patterns and ontology queries to express syntactic as well as semantic filtering criteria. The system can be used through a Web application which is endowed with a user-friendly graphical interface. Finally, we provide some meaningful examples which show the usefulness of the implemented filtering methodology.

To face up such an information overload, in the last years a lot of efforts have been invested to develop query and filtering languages as means to consult XML documents. The W3C has defined some standard languages to query XML contents, such as XQuery[22] and XPath[21]. However, a large variety of proposals have been developed independently, e.g. [10,17,14]. All these solutions are characterized by an

Some programming languages supporting XML processing have also been devel- oped, such as XCentric [13] which is a logic language, extending Prolog with a richer form of unification and regular types, designed specifically for XML processing in logic programming. XCentric is also employed as part of VeriFLog [12] which is a tool for verification of web sites content and data inference. CDuce and XDuce ([8], [16]) are typed functional programming languages, based on pattern matching, designed to support XML applications. Such languages can be used to consult and query XML documents but provide basically an exact matching behavior and the semantic information is not considered.

In [6] is presented a rewriting-like methodology to filter information from XML documents where the positive and negative filtering concepts are introduced. The work proposed in [4] extends the ideas in [6] introducing approximate pattern- matching and presents a declarative pattern-based language for XML filtering, en- dowed with an approximate pattern-matching engine. A further improvement is proposed in [5] where we have integrated the approximate pattern-matching engine with ontology reasoning capabilities in order to enable semantic data filtering.

The already mentioned XQuery language, which uses XPath to describe path expressions, provide a minimal degree of flexibility. For example, element insertions in path expressions are only allowed by the explicit use of the \\ operator, while no element deletion or renaming is allowed. Furthermore, no semantic based filtering facilities are provided.

In our framework, the connection between the filtering engine and the ontology reasoner is realized by means of (an extended version of) the DIG interface [7], which is a standard API for description logic systems supported by a number of ontology reasoners (e.g. Pellet, RacerPro).

tion and many new approaches have been proposed. One of them, quite similar to ours, is DIGXcerpt[15], which presents a language that extends the XML query language Xcerpt[11] enhancing structural querying of XML data with ontology rea- soning. Similarly to our framework, they employ DIG to interface the XML query engine with the ontology reasoner. Although DIGXcerpt allows a powerful search and manipulation of XML data, it only performs exact query matching, while our methodology is able to perform a more flexible matching which ranks the query results w.r.t. computed similarity degree.

The Resource Description Framework (RDF)[24] has been designed to comple- ment XML data with semantic annotations. A large number of prototype systems able to read and reason about such annotations have been developed, for example [2], which describes a logical framework in which XQuery programs are enriched with RDF metadata. This approach enables a limited form of data inference from RDF documents, which is not as powerful as the reasoning capabilities of more complex description logic formalisms like the one supported by the DIG interface.

Plan of the paper. The rest of the paper is organized as follows. Section 2 introduces the DIG interface languages, by means of which we model ontologies and ontology queries; then, we provide an extension of the standard DIG query language which is employed to define ontology query templates. Section 3 presents our filtering language which combines an approximate pattern-matching engine with an ontology reasoning mechanism. In Section 4, we describe the XPhil system architecture and the way it works in order to answer user queries. In Section 5, we briefly describe the Web interface by means of which the system can be tested. Finally, Section 6 concludes.

the name univ. Such ontology can be easily defined by using the DIG formalism, more precisely by means of the DIG tell language which is devoted to ontology description. The univ ontology models people and courses as individuals. Each person has a position inside the structure, like associate professor, researcher, PhD student and so on. Positions are represented by means of hierarchically organized concepts.

The DIG interface, whose complete formalization is available at [5], includes an ask language whose constructs are used to query ontologies loaded into ontol- ogy reasoners. Ask statements allow us to infer information regarding concepts, roles and individuals of a given ontology. Moreover, they can model boolean as well as non-boolean ontology queries. More precisely, a boolean (respectively, non- boolean) ontology query is an ask statement that returns a boolean (respectively, non-boolean) value.

letting ask statements denote non-boolean queries to reference XML tags of a given XML document via the tag:self notation. As we will show in Section 3, a non-boolean ontology query Q is typically bound to an XML tag t. By using the tag:self construct, we can automatically reference t inside Q without citing it explicitly.

Moreover, we provide four filtering operators filterop which can model both exact and approximative filtering w.r.t. a universal as well as existential semantics (i.e. filter{One,All}Exact, filter{One,All}Best). Finally, note that, when no conditions are specified, the <conditions> tag of a filtering rule can be omitted.

Moreover, tag selectors can contain three different attributes. The first two attributes ont and query enable tag flexible matching (i.e. matching modulo tag renaming). The ont attribute specifies an ontology file name, while the query attribute specifies the file name of an extended DIG ask statement modeling a non-boolean ontology query. More precisely, given a tag selector t, by the syntax selector t by querying the ontology ontName via the query queryName. Such syn- onyms are then used by the pattern-matching algorithm to find approximate results. As we have seen in Section 2, the tag selector t can be referenced inside the query queryName using the tag:self notation. During the query execution tag:self occurrences are replaced by t.

Conditions. Conditions are employed to further refine the search of a given pattern inside an XML document. When some instances of the XML pattern have been detected inside the XML document and variables have been bounded to some values, the associated instance of the condition list is evaluated and the pattern instance is then delivered to the user if and only if the condition list instance evaluates to true.

Example 3.3 Assume that an XML document modeling university courses is given. For each professor we know both the name and the surname. For each course, the professor giving the course is identified by the concatenation of his/her surname and the initial of his/her first name. Using three variables X, Y, and Z, we can model such property by means of the following functional constraint X++first(Y)=Z. Following the RuleML syntax, such condition will be expressed by means of the following XML code.

Example 3.5 Consider an XML repository containing academic information along with the ontology univ. Suppose we want to search for busy associate professors, that are, associate professors who are titular of at least one six month course and have more than three PhD students. Then, a possible rule searching for this property might be

Example 3.6 Consider the same XML repository and the univ ontology. Suppose we have an XML document containing personal information about professors and we want to query it in order to obtain all contacts information for young professors (that is, professors whose age is less than 40). A query formalizing this property might be as follows.

