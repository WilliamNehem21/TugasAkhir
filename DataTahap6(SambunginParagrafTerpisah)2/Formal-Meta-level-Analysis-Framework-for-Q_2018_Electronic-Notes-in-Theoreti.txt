The design and development of quantum programming languages (QPLs) is an important and active area of quantum computing. This paper addresses the problem of developing a standard methodology for verifying a QPL against major quantum computing concepts. We propose a framework dedicated to the meta-level analysis of QPLs, in particular, functional quantum languages. To this aim, we choose the Hybrid system as the tool in which to build our framework. Hybrid is a logical framework that supports higher-order abstract syntax, on top of which we develop an intuitionistic linear specification logic used for reasoning about QPLs. We provide a formal proof of some important meta-theoretic properties of this logic, and in addition, showcase a number of examples that can be tackled under the proposed framework.

The middle block defines the syntax and basic properties of the types supported by an OL. Of course, this block is not included in the case of untyped quantum lambda calculi. QPL designers often choose to define untyped calculi to capture the maximum amount of quantum features (i.e., to build a quantum Turing complete language), which could be sacrificed by adding certain type systems. Nevertheless, the proposed framework supports both Turing complete and incomplete QPLs. The formalized syntax and semantics are then used to reason about the OL, e.g., proving subject reduction (type soundness) or Turing completeness.

In this paper, we use the version of Hybrid that is implemented as a Coq library. The purpose of the first file in this library (Hybrid.v) is to provide support for expressing the syntax of OLs. At the core is a type expr that encodes a de Bruijn representation of lambda terms. It is defined inductively in Coq as follows:

One more way in which this language differs from the regular lambda calculus is the inclusion of quantum variables q. Q is a countably infinite set of all possible quantum variables. These variables are linear by definition and their type is im- plicitly known (i.e., qubit), and thus it is not specified explicitly in Proto-Quipper programs.

In contrast to Proto-Quipper, the definition of con for Q will include two distinct constants for the two abstractions, namely LABS and IABS. It also has constants qPROD and Qvar as before. The third type of abstraction does not have a dedicated constant as we decided to encode it using the let-statement (i.e., qLET). Linear and intuitionistic abstraction are defined using an HOAS representation as follows: in Coq. The main purpose of these formalizations is handling the meta-analysis of different fragments of linear logic. In contrast, we use linear logic as an intermediate logic in which to study object languages such as QPLs. Our objective is broader since it includes both. In particular, we prove meta-level theorems about linear logic and gear our choice of theorems toward those that are useful in analyzing any QPL. Our formalization is inspired by the work in [9], which implements ordered intu- itionistic linear logic as a specification logic in the Isabelle/HOL version of Hybrid, where it is used to study a continuation-machine presentation of the operational se- mantics of a functional language, which is much simpler than the QPLs considered here.

where the atom constructor accepts an atomic formula of type atm and casts it into an SL formula. The type atm is defined for each object language and typically in- cludes predicates such as typeof and is exp, where the former is a binary predicate relating a QPL expression and its type and the latter is a unary well-formedness predicate. The constructor T corresponds to the universal consumer, Conj corre- sponds to multiplicative conjunction, and And to additive conjunction. The type constructors Imp and lImp corresponds to intuitionistic and linear implication, re- spectively, where in both cases, the formula on the left must be an atom. The All constructor takes a function as an argument, and thus the bound variable in the quantified formula is encoded using lambda abstraction in Coq.

The backchaing rule also depends on the inductive predicate prog of type atm -> list oo -> list oo -> Prop, which encodes the inference rules of an OL (such as its operational semantics). The formula (prog A IL L) reads as follows: an atom A (the conclusion of an inference rule of the OL) is true in an OL if we can prove each member of the list of intuitionistic subgoals IL and of the linear subgoals LL (together representing the premises of an OL rule). Examples will be given later for our two QPLs.

It important to highlight that our version of linear logic is not ordered, i.e., the order in which the resources appear inside the linear context does not affect provabilty. This is a significant difference with respect to the linear logic SL defined in [9]. To insure that the formalized logic does respect this condition, we have proved the exchange property of the linear context (i.e., the linear context behaves as a multiset), stated as follows:

Here, the type qtp encodes Proto-Quipper types (whose definition was omitted from Example 1), and validT checks for certain well-formedness conditions of elements of this type, such as ruling out two consecutive occurrences of bang. The typeof predicate is a constructor of the inductively defined type atm, which associates an expression with its type, and is qexp is a constructor of atm used to annotate well- formed expressions. As mentioned earlier, the abstr predicate rules out functions of type qexp -> qexp that do not encode OL syntax. In this clause, lImp is used to ensure that the bound variable x is linear in the body of the function E, i.e., this assumption will go into the linear context. Note also the use of Imp; well-formedness assumptions are always part of the intuitionistic context in our formalization. Fi- nally, note that the subgoal occurs in the list of linear subgoals. This is because the type of the whole expression Fun (fun x => E x) is linear; it may also con- tain quantum variables, which can each only occur once. The list of intuitionistic subgoals is empty.

C. Note that the rule ifr is only applicable if b is not a value; otherwise this rule could be applied an infinite number of times without achieving any progress. One of the other two rules is applied when b is a value, i.e., it represents the boolean True or False.

We have proposed a meta-level analysis framework for functional QPLs implemented using the Hybrid system with a linear specification logic. The framework provides a standard way to tackle common components and concepts of QPLs, e.g., opera- tional semantics and type safety. Formalization examples of the Proto-Quipper and Q languages have been presented to show the practical potential of the proposed system.

