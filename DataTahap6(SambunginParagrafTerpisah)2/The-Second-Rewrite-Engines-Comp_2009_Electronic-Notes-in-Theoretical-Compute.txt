The Second Rewrite Engines Competition (REC) was celebrated as part of the 7th Workshop on Rewriting Logic and its Applications (WRLA 2008). In this edition of the competition participated five systems, namely ASF+SDF, Maude, Stratego/XT, TermWare, and Tom. We explain here how the competition was organized and conducted, and present its main results and conclusions.

The main goal of the First Rewrite Engines Competition was to explore the viability of such competition, and to evaluate the interest from the community in it. They started rolling the ball, and given the interest shown we decided to go on. In the second edition we have gathered more systems and a bigger set of problems. We will present in this paper its main results, some conclusions and future challenges. The first competition focused on efficiency, specifically speed, memory manage- ment and built-ins use. There were only two participants, ASF+SDF, represented by Mark van den Brand, and Maude, represented by Steven Eker. For the competi- tion, a number of test examples were compiled, all of them using features supported by both systems. The examples were written in a mathematical and intuitive no- tation, and then translated, by hand, by an independent researcher (the developers helped and revised the specifications to make sure that the best code was written

Once we had settled on the selection of engines, we opened a discussion on the way the competition should take place. As in the first edition, the participating systems were hard to compare. We had compilers and interpreters, we had general purpose engines and others more specific, ... ASF+SDF is very good at parsing; ASF+SDF, Stratego, and Tom are very good at program transformation; Maude is good at rewriting modulo and has a powerful formal environment; Tom is an extension of Java, and TermWare is a rule processing engine intended for embedding into Java applications; etc.

We selected a bunch of tiny and small problems, organized in four categories (un- conditional rewriting, conditional rewriting, rewriting modulo, and context-sensitive rewriting/rewriting with local strategies). The various categories include many clas- sical rewriting problems for their class of rewriting systems, e.g.: the trs category includes computation of fibonacci and factorial numbers; the crts category includes Towers of Hanoi and merge/quick/bubblesort; the modulo category includes spec- ifications of a 3-value logic and a permutations calculation; and the cs category includes the Sieve of Eratosthenes. Most of these tests were used in the first com- petition.

One suggested approach was to use non-trivial examples. Small programs or even complex problems, like a small theorem prover, an exploration of a search space, a transformation of XML (or a tree), etc. It was not clear though whether this would evaluate the systems or the application developers. Time was also a major concern.

Given the capabilities of some of the engines involved in the definition of lan- guages and transformations, we came up with the idea to define a very simple rewriting language, which we called REC, in which all the problems were written. Then, as an additional, mid-size problem in the competition, we proposed writing programs transforming the problems in this REC syntax to the syntax of the cor- responding tools. Once we have this program running, handling the other small programs should be simple. For those systems in which this was not easily doable, we still have the possibility of writing scripts or programs in other languages to get the codes to execute. Of course, we always have the option of doing it by hand. In fact, we wanted to have the option of providing alternative versions of the specifica- tions for those cases in which an optimized version was possible. The REC language and the problems proposed are relatively simple, and do not assume any built-in or other features that could improve the specifications, like fancy syntactic facil- ities, memoization, default rules for handling untreated cases, etc. An optimized version of the problems, using any advanced feature provided by a system, could additionally be provided.

Each of the participants was asked to build a program transforming the problems in this REC syntax to the language of their corresponding tools. However, not all of them were able to make it. Only the Maude, Stratego/XT and Tom representatives provided the translators for their systems. The lack of time was with no doubt responsible for not having translators for the others. We are sure that it can be done, and that with some more time it would have been. Next time perhaps.

We thought that by comparing the translators provided, we could draw con- clusions about their complexity, development time, and efficiency doing the trans- formations. However, the approaches followed in Maude, Stratego/XT and Tom to implement the REC translators were very different. While in Maude a programming environment was built, able to read REC programs and commands and give outputs, Stratego/XT and Tom representatives built programs that transformed the original programs and commands, and were later loaded and executed. As such, we were not able to draw such conclusions from the translators themselves: the translators were implemented by experts in each of the systems, in separated locations, and without a clear previous criterion. However, we must say that the facilities provided by the three systems, for this kind of applications, is quite good, and that the de- velopment times were small. Regarding parsing, we must say that ASF+SDF and Stratego/XT are very good at defining syntax of languages, and Stratego/XT did a very good job in the competition. Tom and Maude also, although they presented a few limitations at the lexical level: tems, general-purpose systems and specific systems, etc. It is commonly accepted that the performance difference between a compiler and an interpreter may be in an order of magnitude, but it is not easy to measure the other circumstances. More- over, although we have tried to consider problems not handled by all the systems, so that some of the capabilities not in the intersection could be shown, much more needs to be done. We have shown some of the capabilities for defining programming languages, and for transforming their programs. We cannot give any conclusion on this other than what has already been said in Section 3.

In [5], some remarks were given by S. Eker and M. van den Brand explaining the results of Maude and ASF+SDF in the first engines competition. Taking into consideration the increased scope of the current edition of the competition, and the heterogeneity of the systems involved, we cannot offer an in-depth analysis of all the results. Instead, we limit ourselves to highlight some of the them.

Since we do not have ASF+SDF versions of the mergesort and quicksort prob- lems, and the Stratego/XT developers did not optimize their codes, no conclusion can be given from the results for these problems, but notice how the optimizations introduced in the Maude code allows it to outperform the other systems. This was not the case when considering the automatically generated ones, were the Tom compiler is much faster. The Stratego/XT system seems to have some problems handling these tests.

