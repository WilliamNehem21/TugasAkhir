contributions of this paper are: (i) a tool oriented description of the distributed architecture of our system and the modifications needed to the DPOR and sleep set algorithms to make them usable in this architecture, and (ii) a new experimental evaluation of the distributed nature of our tool on multithreaded programs. In par- ticular, the new experiments concentrate on cases where most of the test executions are generated due to different schedules that need to be explored. We show that even in this case the testing can be distributed as efficiently as with single threaded programs. The rest of the paper is structured as follows. Section 2 briefly describes concolic testing and dynamic partial order reduction algorithms, Section 3 gives an overview of LCT together with our modifications to the used algorithms, Section 4 covers the related work and Section 5 provides an experimental evaluation of the distributed architecture in the context of multithreaded programs.

A path constraint is a conjunction of symbolic constraints that correspond to each branch decision made in a given execution.To force a test execution to follow an unexplored execution path, a prefix of a previously explored path constraint is chosen and the last symbolic constraint in it is negated. To obtain concrete input values, path constraints are typically solved with SMT-solvers. The symbolic constraints form a symbolic execution tree and each test explores one path in this tree. As any two distinct subtrees of the symbolic execution tree can be explored independently, it is possible to parallelize the testing process efficiently. For more details on concolic testing, see e.g., [9].

For multithreaded programs the schedule affects the execution path as well. The nondeterminism caused by the thread interleavings can be handled in concolic test- ing by taking control of the scheduler and considering the schedule as an input to the system. To limit the number of thread interleavings that need to be explored, con- colic testing can be combined with dynamic partial order reduction algorithms [5]. The basic idea behind these algorithms is to find transitions that are in race in the current execution and then introduce backtracking points to the execution tree such that the different interleavings of the transitions in race will eventually be explored.

The communication between the server and clients is implemented using TCP sockets that makes it easy to distribute the testing to multiple workstations. The constraints generated during test executions are expressed in bitvector theory and Boolector [2] is used as the constraint solver. To avoid exploring unnecessary inter- leavings when testing multithreaded programs, the tool uses dynamic partial-order reduction and sleep set algorithms. In order to use these algorithms in our dis-

DPOR is stateless in the sense that previously visited states are not needed for identifying races. However, for backtracking there does need to be a way to reach previous states. There are several ways to achieve this [5]. LCT uses re-execution of the program, as it is a natural fit for combining with concolic testing. This is because the path constraints in concolic testing encode sets of concrete states and even though a new path constraint shares a prefix with an old one, the inputs solved from the new constraint may not drive the program to any previously visited concrete state. Re-execution is a convenient way reach a concrete state that satisfies the new path constraint.

Sleep sets can be combined with DPOR to provide additional reduction when DPOR fails to identify accurate sets of operations to explore from backtracking states. The sleep set algorithm is based on the observation that after an operation t has been explored from some state s, then after other operations independent with t are explored from s it is not necessary to explore t again. To this end we associate with each reached state a sleep set, which is a set of operations that are not executed from that state.

To compute sleep sets, when a state sj is explored from s, the candidate sleep set for sj is the union of the sleep set of s and the set of operations already explored from s. This candidate sleep set is then filtered to only include operations that are independent with the operation that was executed to reach sj. The sleep set of the initial state is empty.

The results show that the architecture scales well at least up to 20 clients. This is because the time to run a single test execution, which consists of restarting JVM to initialize global state, solving paths constraints and running the program both concretely and symbolically takes significantly more time than the operations the server needs to do in a synchronized way. Furthermore, most of the time the number of open paths in the symbolic execution tree is large enough so that each client has work to do.

