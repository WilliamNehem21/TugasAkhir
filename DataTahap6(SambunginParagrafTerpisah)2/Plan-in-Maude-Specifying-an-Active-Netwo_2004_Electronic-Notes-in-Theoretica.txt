PLAN is a language designed for programming active networks, and can more generally be regarded as a model of mobile computation. PLAN generalizes the paradigm of imperative functional programming in an elegant way that allows for recursive, remote function calls, and it provides a clear mechanism for the interaction between host and mobile code. Tech- niques for specifying and reasoning about such languages are of growing importance. In this paper we describe our specification of PLAN in the rewriting logic language Maude. We show how techniques for specifying the operational semantics of imperative functional programs (syntax-based semantics) and for formalizing variable binding constructs and mo- bile environments (CINNI calculus) are used in combination with the natural representation of concurrency and distribution provided by rewriting logic to develop a faithful descrip- tion of the informal PLAN semantics. We also illustrate the wide-spectrum approach to formal modeling supported by Maude: executing PLAN programs; analyzing PLAN pro- grams using search and model-checking; proving properties of particular PLAN programs; and proving general properties of the PLAN language.

programming language. In this paper we present the second application in greater depth and with a particular emphasis on the following two aspects: (1) the use of operational semantics techniques from programming language theory augmented with the CINNI explicit substitution calculus; and (2) the wide-spectrum approach to formal modeling supported by Maude. We begin with a brief introduction to active networks and PLAN.

Active networks are networks with nodes that do not operate according to a fixed scheme (e.g. as conventional routers) but are instead fully programmable and pro- vide execution environments for programs that can be received from other nodes via the network. Active networks can be wired, wireless or hybrid networks. One may think of active networks as a generalization of conventional networks and as a step toward greater flexibility: Packets, which are interpreted by routers in conventional networks following rigid schemes, become programs, which are executed in active networks in a universal fashion. See [31] for a survey of active network research and the recent DARPA conferences on this subject [3,4].

PLAN [13,12,25,14,19], is an imperative functional language similar to ML, but has a number of additional features, such as remote function execution and re- source awareness. Remote function execution, means that functions can be invoked in such a way that the execution does not take place locally but in the execution en- vironment of a different network node. To this end, the function call is treated as a so-called chunk, i.e. as a piece of data, which is transmitted to the destination node by means of a packet. Resource awareness refers to a mechanism which keeps track of computational resources and ensures that all PLAN programs are terminating. In addition, PLAN programs interact with their host nodes through service package interfaces. Basic services include provision of information about local network

Our specification is organized in three main parts: syntax; network; and semantics. The syntax part is a fairly direct formalization in Maude of the syntax of xPLAN as an algebraic data type. The network part models basic network concepts such as locations, addresses, connections, and routing, with the minimal detail needed for the PLAN specification. The semantic part is the heart of the matter. The mul- tilevel concurrency of active networks is very directly reflected in the computation state which is structured to provide clear boundaries for the scope of effects and information access.

The abstract syntax of xPLAN uses CINNI notation for bound variables. Defining (binding) occurrences of variables are represented as identifiers. A referencing occurrence of a variable is written X{n} and refers to the n-th defining occurrence of X (counting from the inside and starting with 0). Presupposing a sort Nat of natural numbers, and a sort of identifiers Id, this is formalized by the declarations:

Foldr and Foldl provide the ability to iterate over a list. In contrast to gen- eral recursion using LetRec (see below), these two functions provide a form of bounded recursion that is always terminating and hence not charged against the computational resources available to the program. The basic data types of PLAN are modeled by injecting the corresponding Maude sort into the Const sort. Thus they are isomorphic to, but not confused with, the Maude sorts. Apart from the standard Maude sorts we presuppose a sort Addr of host addresses. The host ad- dress is not necessarily unique for a given host, because each host can have several network devices and each of these has an associated host addresss.

its resource units for sending the packet containing the chunk and for its execu- tion on the remote node. OnRemote is similar but allows execution on arbitrary nodes and hence may involve packet routing by means of a routing function that has to be passed as an additional argument. Finally, Exists(str, i), Get(str, i), and Put(str, i, val, exp) provide access to a resident data dictionary local to the current node, (str, i) being a composite access key, val the value to be stored, and exp the time till expiration.

For sake of brevity we have omitted the declarations of the sort PlanType of type annotations and the obvious declarations of the sorts IdList, ExList, ValList, and PlanTypeList. They denote lists over Id, Ex, Val, and Plan Type, respectively, with inclusions Id < IdList, Ex < ExList, Val < ValList, PlanType < PlanTypeList. We always use a constructor _,_ for list concatenation. Furthermore, we use a constant empty-exl for the empty list over Ex, and we extend the inclusion Val < Ex to ValList < ExList.

To specify the semantics of xPLAN we first explain how the global active network state is represented. We then discuss the reduction machine which is the basis for the operational semantics for the functional programming primitives. Finally, we discuss the transition rules and give representative examples for the main types of transitions.

A process has the form Process(l, orign, ardev, ssn, rb, rs). The process was created when a packet with node l as its final destination arrived. The address ardev refers to the device at which the packet entered the node, orign, ssn, are the same as in the packet, rb is the remaining amount of computational resources, and rs is the reduction machine state (see below).

For the resident data services each node Node(l,.. .) has an associated data object Data(l, dil) where dil is a list of data items. Data items have the form DataItem(id, k, val, ttl), where (id, k) constitutes a composite key under which the value val is stored. The last argument ttl determines the time until expiration of the data item (present for future compatibility, since time advance is currently not modeled).

When a packet arrives at its destination node a process is created to execute the invocation encapsulated by the chunk. The local execution of a process is specified by an abstract reduction machine. A simple and concise formalization of the reduc- tion machine is crucial for the semantics to be useful for mathematical reasoning. We have used an approach called syntax-based semantics [8,20,30] to simplify the reduction machine and to obtain a very direct connection between the (partially ings are value expressions. Mathematical descriptions of deterministic evaluation using reduction contexts are based on a key lemma that says that an expression ex is either a value or it decomposes uniquely into a reduction context R and a redex r such that ex is the result of filling the hole in R with r (written R[r]) [8]. The inductive definition of the set of reduction contexts corresponds to peeling off basic reduction contexts one layer at a time until a redex is reached: ex = R0[  Rn[r]].

These basic reduction contexts correspond to a control stack with Rn at the top. For example, the first layer of a PLAN application ex = val(vall, nval, exl), where vall is a value list and nval is a non-value expression, is the reduction context R = val(vall, ?, exl) expressing the left to right evaluation order semantics. Most of the action occurs at the inner basic reduction context (top of the stack). For ex- ample, suppose the above application fills the hole of an outer reduction context R' so that ex' = R'[ex] = R'[R[nval]]. When the evaluation of nval leads to a value val' the hole is filled with that value, and the resulting expression is rede- composed if it still contains a redex. The new decomposition is parametric in the outer reduction context, that is, it has the form R'[R''[r']] where R''[r'] is the unique decomposition of R[val'].

In the following we use variables ex, ex', etc. to range over expressions (sort Ex) and variables cx, cx', etc. to range over contexts (sort Cx). The operation of hole filling is a special case of metavariable substitution (the hole being the only metavariable) and is generalized to allow filling of holes with contexts (context composition) and to apply to context lists (sort CxList), contexts being a special case. The process of hole filling is formalized by the following operation.

Apart from the metavariable substitution used for hole filling, a second notion of substitution is needed in the rules of our specification for object variables. This substitution cannot be reduced to a simple textual substitution, because it must re- spect the binding structure of the object language. Therefore, we use the CINNI family of explicit substitution calculi [28] instantiated to the syntax of xPLAN. We have slightly generalized the original CINNI substitutions to simultaneous sub- stitutions by simply lifting all operators from Id to IdList (which represents a simultaneous binding). There is a basic explicit substitution constructor [_:=_], two auxiliary constructors shift and lift, for relocation (by changing the vari- able indices), and an operation    for application of a substitution to an expression list (expressions being a special case).

Packet rules include rules for emitting, delivering, and routing packets in transit. The PLAN construct OnNeighbor is one of the two possibilities to initiate a remote function call which is given by a chunk Chunk(val, vall). As we can see below, the execution of OnNeighbor leads to the emission of a packet which encapsulates this chunk.

creased by the amount given to the emitted packet, and that amount is then de- creased by one corresponding to the use of one unit for the first hop. The routing function component of the packet is set to an irrelevant constant NoRoute above, because OnNeighbor can only send packets to immediate neigbors. The more general OnRemote service allows remote invocation on arbitrary locations and allows the user to specify a routing function which is passed along in the packet.

service), by generating a fresh key for labeling data (using the GenerateKey service), and by an initial call of the find function with this information. The network is then flooded with packets which propagate themselves from nodes that have not been previously visited. To this end, the find function first uses the resident data service Exists to check if an entry associated with the current key exists in the local dictionary of the current node. If this is not the case, the node has not been previously visited. Hence a new entry in the local dictionary under the same key is created using Put to store the backpointer. Next it is checked using

i222e4 is a constant defined to be the above initial state. The infix=>+ says to search for states reachable after one or more rewrites, and the term on the righthand side is a pattern to be matched. A solution is found with two processes executing on node l3, one coming from address c1 and the other coming from address d2.

We emphasize that testing a specification as we did is an extremely important part of the process of developing a formal model. In fact, the specification pre- sented here is the second major version. The first version we developed served to clarify many issues and to fill in many gaps. However, it was too low-level, mak- ing mathematical analysis overly complex. For example, the reduction machine was based on a state representation similar to the SECD machine used in the paper specification. This involved defining a number of new state constructors and spe- cial purpose transition rules just to manipulate these. Also the network model is slightly more abstract compared with the previous version, where network devices were clearly distinguished from their addresses.

