In this paper we explore reasoning techniques for programs that manipulate data structures spec- ified using set-valued abstract fields associated with container objects. We compare the expressive power and the complexity of specification languages based on 1) decidable prefix vocabulary classes of first-order logic, 2) two-variable logic with counting, and 3) Nelson-Oppen combinations of mul- tisorted theories. Such specification logics can be used for verification of object-oriented programs with supplied invariants. Moreover, by selecting an appropriate subset of properties expressible in such logic, the decision procedures for these logics enable automated computation of lattice opera- tions in an abstract interpretation domain, as well as automated computation of abstract program semantics.

abstract data types, and create an unbounded number of instances of these data types during program execution. Particular difficulties arise when each data type instance is itself implemented using multiple dynamically allocated objects that form a linked data structure. Our approach for analyzing such programs is to use abstract set-valued fields as specification variables that de- scribe operations of an abstract data type. We separate the analysis of the program into 1) verifying the correctness of the implementation of the abstract data type with respect to the set specification, and 2) verifying the correct- ness of the rest of the program where the linked data structure is replaced by abstract set-valued fields.

Hob project.  One of the main design principles behind the Hob project [17, 32] is that reasoning about programs with complex data structures be- comes simpler if data structure operations are specified in terms of abstract sets of objects associated with each data structure. For example, an inser- tion into a data structure in this approach becomes simply an insertion into a dynamically changing sets of objects, as opposed to a manipulation of a dynamically linked data structure. Hob splits the verification of programs with such data structures into two tasks: 1) using shape analysis (or some other analysis or verification technique, including techniques as powerful and heavyweight as interactive theorem proving) to verify that the data structure implementation conforms to the specification given in terms of the abstract set variables, and 2) using only the abstract set variables in the rest of the program to reason about the behavior of the data structure. So far, we have used Hob to verify implementations of global data structures, which are in- stantiated at compile time into a finite number of instances (that may store and manipulate a statically unbounded number of objects). The focus on global data structures allowed us to use a static module mechanism to encap- sulate object fields and prevent representation exposure, as well as to use the decidable theory of Boolean algebras [13] to reason about the finite number of abstract sets that specify data structures. One goal of this research is to extend this approach for dynamically instantiated data structures as well.

Dynamic instantiation of linked data structures. Dynamic instantiation of abstract data types is one of the central features of current object-oriented programming languages. Dynamic instantiation is typically achieved by asso- ciating each abstract data type instance with an object, using a field to attach the underlying linked data structure to the object. This research explores one way to extend Hob to verify programs that use linked data structures that can be dynamically instantiated. In this approach, we specify a linked data structure attached to an object using a finite number of set-valued object fields. The result of abstracting the content using this technique is a program

The topic of this paper is the second problem: verification of programs that manipulate objects with set-valued fields. Like [26], we are concerned with verification of clients of abstract data types, but we focus on specifications ex- pressed in terms of set-valued fields and derive a complete decision procedure for the constraints in our class. Our approach uses assume/guarantee reason- ing with user-supplied annotations to completely separate the analysis of the implementation of the class from the analysis of the context; other approaches attempt to automatically infer both the approximation of the context and the approximation of class implementation [18], potentially using a global fixpoint analysis.

Decision procedures for set-valued fields. To study the automation of reasoning about programs with set-valued fields, we explore decision proce- dures for constraints on such fields. Our constraints can express relationships between sets associated with the same object, the aliasing between object ref- erences, as well as the relationships between sets associated with different ob- jects. By annotating programs with such constraints and using a verification- condition generator [32], developers can verify a range of invariants of object- oriented programs. By selecting an appropriate subset of properties express- ible using such constraints, a decision procedure for these constraints enables an analysis to automatically derive the lattice operations in the abstract in- terpretation domain, and to compute abstract program semantics (transfer functions).

