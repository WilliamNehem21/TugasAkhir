The contribution of this paper is to introduce the common approach that we have defined to build various evolutionary transaction services. This common approach is based on the use of microcomponents and design patterns, whose flexibility properties allow transaction services to be adapted to various execution contexts. This approach is applied in our GoTM framework that supports the construction of transaction services implementing several transaction standards and commit protocols. We argue that using fine-grained components and design patterns to build transaction services is an efficient solution to the evolution problem and our past experiences confirm that this approach does not impact the transaction service efficiency.

Current transaction services do not support evolution well. Among the possible evolutions of a transaction service (e.g., Commit Protocol, Transaction Model), this paper details our approach to address the evolution of the transaction standards and commit protocols supported by a transaction service.

The evolutionary transaction services described in [21,22] are built using a com- mon approach. The contribution of this paper is to introduce this common approach that we have defined. In particular, we combine the use of microcomponents and design patterns to increase the adaptability of our approach. The notion of micro- component can represent a pool of components, a policy of message propagation, or a command to execute. The microcomponents are implemented with the Fractal component model [5] and integrated in the GoTM framework. We argue that us- ing fine-grained components and design patterns to build transaction services is an efficient solution to the evolution problem and our past experiences have confirmed that our approach does not impact the transaction service efficiency.

The paper is organized as follows. Section 2 introduces the Fractal component model and the concept of microcomponent. Section 3 illustrates the construction of design patterns using microcomponents. Section 4 discusses the benefits of our approach. Section 5 presents some related work. Section 6 concludes and gives some future work.

A microcomponent communicates with others via its microinterfaces. A micro- interface identifies a function provided by a microcomponent. Microinterfaces are interfaces defining a very small set of operations (the empirical statistics performed on the code base show that GoTM microinterfaces define no more than 4 opera- tions) where the operation signature is uncoupled from the operation semantics. If the interface contains too many operations, then it is split into several micro- interfaces. The semantics of the microinterface depends on the semantics of the microcomponent that provides it. This approach makes easier the factorization and the reuse of microinterface operations. The definition of microinterfaces offers

This composition is achieved using an ADL. The composition concern has an important place in the concept of microcomponent. Indeed, microcomponents are not only defined by their microinterface but also by their composition with the other microcomponents. Microcomponents are identified to split a coarse-grained compo- nent into several fine-grained components. When composing them, the developer can provide various component semantics by changing only some of the microcom- ponents. Moreover, it appears that the architecture patterns used to compose the microcomponents can be identified. The remainder of this paper describes the design patterns that are used in the GoTM framework to build evolutionary transaction services. The ADL definitions provide the architectural definition of the design pat- terns. We show that by modifying the ADL definition, it is possible to make the design patterns evolve to handle different kinds of execution contexts.

The component Logging uses the sharing capability of the Fractal component model. The microcomponent LoggingProviderImpl is shared between three compo- nents: ForceLogging Policy that provides the microinterface force write, NonForce- Logging Policy that provides the microinterface non-force write and Logging pro- viding the microinterface read. The microinterfaces write provided by the micro- components ForceLogging Policy and NonForceLogging Policy are exported via the collection interface write.

The Facade design pattern provides a high-level unified interface to a set of interfaces in a subsystem to make it easier to use [12]. In GoTM, the Facade design pattern is used to conform to a particular transaction standard (e.g., JTS, OTS, WS-AT). The Facade design pattern converts the interfaces defined by the transaction standard to the microinterfaces provided by GoTM. Given that a transaction service is composed of a static and a dynamic part (see Section 3.1), the Facade design pattern is applied to the two parts using two components.

The evolutionary dimension of this design pattern deals with the ability to handle crosscutting concerns, such as the caching and the pooling of the instances created by the Factory. Depending on the TX Model definition, the transaction service is able to create flat or nested transactions. In [22], the transaction factory evolves to provide self-adaptability and choose the Two-Phase Commit protocol that would complete faster depending on the current execution context.

stored in the component Cache Pool to be recycled by the Cache Factory. The Pool Factory registers the instances of transaction components created by the component Cache Factory. These instances are stored in the component Instance Pool and can be listed using the microinterface pool provided by the component Factory. This encapsulation of the components Factory forms a delegation chain [12].

Separation of Concerns. The definition of microinterfaces makes the composi- tion of components more flexible. Microinterfaces factorize the definition of available operations and enforce their reuse by different microcomponents. The definition of microcomponents provides a better separation of concerns. This allows the devel- oper to compose technical concerns, such as Caching or Pooling, independently.

Performance of Transaction Services. Finally, considering the performance issue, our past experiences with GoTM have shown that using microcomponents and design patterns introduces no performance overhead to the transaction ser- vices [21,22]. Even better, it has shown that evolutionary transaction services built on top of GoTM can perform better than legacy transaction services [21].

Mixin-based approaches. Mixins [4] and Traits [10] provide a way of structuring object-oriented programs. Mixins are composed by inheritance to build an object that combine different concerns, each concern being implemented as a mixin. A trait is essentially a parameterized set of methods; it serves as a behavioral building block for classes and is the primitive unit of code reuse. Nevertheless, once mixed the object does not keep a trace of the mixins that compose it. This means that the object can not evolve to handle other concerns once it is mixed. In GoTM, we consider microcomponents as mixins that can be composed to build larger compo- nents. Once composed, the microcomponents are reified in a composite component to keep a clear view of the resulting architecture.

Model-Driven Engineering. We also intend to reify the software architecture design patterns identified in GoTM as template components to enforce and con- trol their reuse. For example, we can define a software architecture pattern as an abstract component and use the extension mechanism of Fractal ADL to specify concrete components used to implement the design pattern. The concrete compo- nents could be generated using a Model-Driven Engineering (MDE) approach to complete the software architecture design patterns already defined in GoTM [19].

