affects simple goals or constrained goals. In the so-called intensional negation (cf. [2]) for the LP approach, universal quantification prevents from achieving a complete goal computation mechanism. Afterwards, constructive negation was introduced in [4,5] and extended in [8,16] to a complete and sound op- erational semantics for the whole class of normal logic programs in the CLP framework. Intensional negation was also extended to CLP in [3] where a complete operational semantics is provided. The computational mechanisms proposed in [3,8,16] deal with universally quantified (constrained) goals that, in general, are not easy to compute in an efficient manner. Besides, the nega- tion technique is introduced in [14] and local variable absence is claimed as a sufficient condition for the completeness of the technique.

Outline of the paper. In the next section, we give some preliminary defi- nitions. Program normalization is presented in Section 3. The fourth section introduces the notion of mode specification. In Section 5, we show how to eliminate the local variables from a definite program in several phases. Fi-

We would like to remark that mode specifications are about positions, but not about terms being their actual holders. Notice that the same term (in particular, variable) could occur in distinct atoms (or, even, in the same atom) in positions with different modes. Moreover, the mode specification does not restrict the goals and has nothing to do with the dataflow that is assumed by the programmer.

That is, as well as the standard condition of recursion in the rightmost atom, we also demand that, in the recursive clauses (2), the same tuple of pairwise distinct variables (namely z) occurs in output arguments of both the head and the rightmost body atom. Notice that only direct recursion is considered in our definition. These restrictions will be useful during the auxiliary variable elimination process.

The second subtask is to eliminate the auxiliary variables that are located in the leftmost atom where some auxiliary variables occur in. With this aim, we have to infer the mode specification in the above mentioned atom and the next one. The Definition 4.4 already fixes the mode specification in the argument positions where auxiliary variables occur in. In the remaining ones, the mode specification that is inferred by Definition 4.5 is subject to the mode specification in the clause head atom, that is undefined for the time being. Therefore, the mode specification in these positions is inferred as follows.

A method for eliminating local (there called unnecessary) variables from definite logic programs was introduced in [13]. Their main aim was to eliminate the redundant computations that are made by means of local variables. Hence, the target program yields more efficient SLD-computations. This motivation is essentially different from ours. They present different strategies for guiding the application of unfold/fold transformations in order to achieve local variable elimination. The strategies are syntactically based and only guarantee the complete elimination of local variables for a very restricted subclass of definite logic programs. To the best of our knowledge, there is no other published result on the elimination of this kind of variables in logic programs.

We plan to extend our results to normal logic programs. By now, we think that full generality could not be achieved in this case. However, we believe that the method can be easily adapted for a wide subclass of normal logic programs. Future work also includes the extension to constraint logic programming.

