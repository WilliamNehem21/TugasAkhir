The syntax is user-definable to a great extent, which allows to choose the more appropriate one for each problem. In particular, operators declared by the user can have attributes like associativity and commutativity, which makes multiset rewriting trivial. All the specifications in this paper make essential use of this feature.

The motivation for this section is not to provide a crash course on rewriting logic and Maude. On the contrary, we only intend to give the flavor of the underlying theory and provide enough information so that the specifications of the examples in the next sections can be understood. For a thorough treatment we refer the interested reader to the paper in which rewriting logic was first presented [11], to the Maude manual [3], and to [9], where many more papers on rewriting logic are referenced.

To illustrate both these ideas and Maude syntax consider the following example. We have some natural numbers written on a blackboard and we are allowed, at any given time, to replace any two of them by their arith- metic mean. In this case the static part corresponds to the representation of the blackboard and the numbers themselves. To represent the numbers we have first to declare their sort (or type) and then write the well-known Peano constructors. Comments are introduced with ---.

The subsort declaration tells Maude that a single natural number constitutes a valid representation for the blackboard. Multiset union is represented with empty syntax . Note that this operator has two attributes, assoc and comm, so that terms of sort Blackboard are considered modulo associativity and commutativity (e.g., s(0) 0 and 0 s(0) become indistinguishable).

As related in [12], Flavius Josephus was a famous Jewish historian who, during the Jewish-Roman war in the first century, was trapped in a cave with a group of 40 Jewish soldiers surrounded by Romans. Legend has it that, preferring death to being captured, the Jews decided to gather in a circle and rotate a dagger around it so that every third remaining person would commit suicide. Apparently, Josephus was too keen to live and quickly found out the safe position.

The following is a classic puzzle with a recent cameo in the 1995 Hollywood hit Die Hard: With a Vengeance. In the movie, McClane and Zeus have to deactivate a bomb by placing 4 gallons of water on a balance. The supply of water is unlimited, but they only have three basins with capacities of 3, 5, and 8 gallons, respectively.

At any given time we can either empty one of the basins, or fill it com- pletely; the rules empty and fill below take care of this. When there is enough space in one of the basins to hold the current content of another, we can transfer all the water from this second one by using rule transfer1. Note that this is a conditional rule (introduced with keyword crl), with the con- dition at the end, after keyword if. The case when, after pouring one basin over another, there is still some water left is dealt with by the conditional rule transfer2 (where the operator sd denotes the subtraction operation over nat- ural numbers, specified in the predefined Maude module NAT). These last two rules could be combined into a single one, but the result would not be so clear.

The traversing of the bridge is modeled by two rewrite rules: the first one for the case in which a single person crosses it, and the second one for when there are two. Note that for somebody to be allowed to cross, their position relative to the bridge must be the same as for the flashlight, which is represented by having the same variable P twice on the lefthand side of the rules. Also, since   is commutative, the condition in the second rule amounts to no loss of generality.

After sorting out the information, it becomes clear that Bono and Edge have to be the first to cross. Then Bono returns with the flashlight, which gives to Adam and Larry. Finally, Edge takes the flashlight back to Bono and they cross the bridge together for the last time.

The state of the board is also represented as a multiset of pieces with the operator  . There is a different constructor for each piece, bigsq, hrect, vrect, and smallsq, and another one, empty, to indicate an empty space (that is considered to be just a special kind of piece). These constructors take two natural numbers as arguments that correspond to the coordinates of the upper left corner of the piece; the origin (1, 1) is located at the upper left corner of the board.

The representation of the moves as rewrite rules is then immediate: each involves a piece and at least one empty space. For each kind of piece there are four rules, corresponding to the four possible directions. For example, moving the big square one position to the right is captured by the rule Sqr below.

A shepherd needs to transport to the other side of a river a wolf, a goat, and a cabbage. He has only a boat with room for the shepherd himself and another item. The problem is that in the absence of the shepherd the wolf would eat the goat, and the goat would eat the cabbage.

We represent with constants left and right the two sides of the river. The shepherd and his belongings are represented as objects with an attribute indicating the side of the river in which each is located; the constant initial denotes the initial situation in which we assume that all the objects are located in the left riverbank. The rules represent the ways of crossing the river that are allowed by the capacity of the boat; an auxiliary operation change is used to modify the corresponding attributes.

square has three arguments: the first two are its coordinates (column/row) and the last one indicates whether it is already covered or still empty. Since the position of the squares in the board is fixed, the attribute comm for  could be thought to be unnecessary. This, however, allows a more homogeneous and simple presentation of the rules taking care of positioning the dominoes both horizontally and vertically, by focusing only on those two squares involved in placing the domino. Having the board represented as a list by removing the attribute comm would force us to represent all the squares in between them in one of the rules.

should return the answer. This time, however, a state explosion problem occurs and in our computer the program runs out of memory before producing any result. To solve it, we are forced to use some ingenuity after all. Note that instead of placing the dominoes in an arbitrary order we could do it starting either from the top of the board towards the bottom, or from the left towards the right, or even in a diagonal manner beginning at the upper left corner. The first two approaches still do not return an answer, but the third does. To implement it, we need an auxiliary operator cDiag that checks whether all positions in the board that come before a given square according to the diagonal order have been already covered. Also, as we did in Section 4, we need to have full control of all the elements in the board and for that we enclose it inside the constructor {_}.

The first one is the possibility of using membership axioms [3, Chapter 4] to refine the representation of the state. For example, the multiset constructor allows repetition of elements, but this should be forbidden in some situations; as another example, in the Khun Phan puzzle a piece cannot be stacked on top of another. In the puzzles above we have not made use of this, but memberships are the right tool to make sure all the elements are different.

