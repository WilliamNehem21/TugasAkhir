Given a formula D of LC, the procedure proceeds in three steps at the end of which one obtains a counter-model (in case D is not provable. 2 ) The first step which is described in full details in section 3 consists in building a particular bi-colored graph GD based on the decomposition tree of D. The arrows of this graph may be indexed with boolean conditions. The second step consists in searching for an instantiation of the boolean conditions on arrows so that the instance graph has no remaining r-cycle. 3 This step is first described informally in section 3.3; then we provide a decision algorithm for this problem based on conditional matrix computation in section 4. For the third step, described in section 5, given a particular instance Gv with no r- cycle, we can extract a counter-model of D from this instance Gv by computing a bi-height for it.

In [13], we have described a procedure to decide the formulae of LC and to build a counter-model when a formula is not valid. The first step of this procedure is to build a graph with two kinds of arrows. Then the decision problem is reduced to the detection of particular cycles in this graph.

Then, the edges of GD are obtained as follows: we describe the set of green and red arrows linking those nodes together and the boolean expressions indexing those arrows. We begin by unconditional arrows (i.e. arrows implicitly indexed with the tautology 1) introduced independently of the internal structure of the formula D:

Theorem 3.5 Let D be a formula of LC and G be its associated conditional bi-colored graph, built from the previously described procedure. Then D is provable in LC if and only if every instance graph Gv of G contains at least one r-cycle.

We now have to find a valuation vx, vy and vz in {0, 1} such that the corre- sponding instance graph has no r-cycle. For this we identify all the r-cycles and we try to find a valuation that simultaneously breaks each of the r-cycles. We consider only basic r-cycles that do not repeat nodes because any r-cycle contains at least a basic one. We find four of them:

The naive procedure we have described for computing a valuation with no r-cycles consists of searching all the possible r-cycles (without repeating nodes) and solving a boolean constraint system associated with these cycles. Unfor- tunately, such a procedure would be highly inefficient because there might be exponentially many r-cycles for a given formula. 8 This problem has also been addressed in [13]. In the next section, we give a description of one possible solution to the elimination of r-cycles.

For the prototype implementation, we have chosen to represent conditional matrices by sparse arrays. The boolean functions which compose them are rep- resented by the nodes of a shared BDD [5] for efficient boolean computations and extraction of boolean counter-models. The algorithm for the computation of bi-heights is a slightly modified version of a depth first search procedure.

