In this module, negation of a structure is represented with -_. We use the syntax {_,_} for conjunction instead of (_,_). This way, we avoid ambigui- ties, because brackets are often used in meta-level programming and elsewhere in Maude. The information about the associativity and commutativity of the struc- tures and their units are expressed simply by means of the operator attributes, e.g., [assoc comm id: ff] for the disjunction.

This module uses the module KSg-Signature above. It is important to observe that the rules of system KSg are expressed as bottom-up proof search term rewriting rules. In the calculus of structures inference rules can be applied only inside the contexts that are not under the scope of negation. Thus, in order to avoid the ap- plication of the rule weakening to negative atoms, in the module above, we have two rules for weakening. This way, by exploiting pattern matching, we avoid unsound op o  : -> Unit .  op -_ : Structure -> Structure [prec 50]. op [_,_] : Structure Structure -> Structure [assoc comm id: o] . op {_,_} : Structure Structure -> Structure [assoc comm id: o] . op <_;_> : Structure Structure -> Structure [assoc id: o] .

this rule, which copy arbitrary substructures, cause the search space to grow rather quickly. In order to get over this, the application of this rule must be controlled. In the following, we will address this issue in conjunction with some proof theoretical ideas that aim at reducing nondeterminism in proof search.

In the implementation above, the different phases of the proof, where different sets of inference rules are used, are represented by functional modules which are called by the operator prove of the functional module KSg-Strat. Seen procedu- rally, by means of the operation upTerm, this operator first converts the object level representation of the input query term to a Maude meta-level representation of the same term with respect to the module KSg-Signature. Then the meta-level term corresponding to the negation normal form of the input term is computed by means of the operation metaReduce which takes the meta-representation of the functional module KSg-UNF as argument. Then the computed meta-level terms are passed similarly to the meta-level representations of the functional modules distribute, interaction and weakening, respectively, which reduce these meta-level terms with respect to their rules.

