formalized in a proof theoretic manner by means of an inference system rather than just by a rewriting relation. The corresponding termination notions can also differ from the standard ones. During the last years we have introduced and implemented different notions and transformation techniques which have been proved useful for proving and disproving termination of such programs by using existing tools for proving termination of (variants of) rewriting. In this paper we provide an overview of our main contributions.

This program (where list concatenation is expressed with empty syntax and satisfies associativity (assoc) and identity (id for nil) axioms) is terminating, that is, given a list of quoted identifiers the specification can always be used to compute in a finite number of steps whether it is a palindrome, i.e., has sort Pal, or not. But note that no rewriting at all is involved.

provides an interesting example of a nonterminating program involving no rewrite rule (borrowed from [11, Introduction]). Here, a conditional membership establishes that terms s(N) (for terms N of sort Nat) have sort Inf provided that s(s(N)) has sort Inf too. Again, no rewritings are specified here.

and also the association of a sort discipline to the arguments of symbols and terms built from them), context-sensitivity, etc., can play a crucial role in the termination behavior and hence in any attempt to provide an automatic proof of it. For instance, LengthOfFiniteListsAndTake is terminating. However,

What these examples show, most strikingly the PALINDROME, INF, and INF2 specifications, is that termination of a declarative program may not involve rewriting at all, or, as in the case of INF2, may involve both rewriting and other computational relations. Thus, the standard (rewriting-based) termination notions that have been developed for rewriting-based programming languages, including those for CTRSs, are insufficient for dealing with termination of MEL or rewriting logic programs. For this reason, we use in this paper a proof-theoretic termination notion, called operational termination [25]. This notion is parametric on the logic: it can be defined not just for MEL, but for many other logics, that may or may not involve rewriting in their computations. Intuitively, a program is operationally terminating if all its well-formed proof trees are finite. For example, the nontermination of the

We consider a logic L defined by inference rules, parameterized by a theory S. That is, we focus on provability, and assume the axiomatic framework of general logics [28], in which what we call a logic becomes a particular style of presenting an entailment system. We refer to [4] for a more detailed account of the axiomatic metalogical background that we assume in what follows. The notion of operational termination [25] is parametric on the inference system. We briefly recall the notions we need for our purpose.

memberships may be intrinsically needed to determine whether a term has that sort. All other sorts are called order-sorted sorts. While membership of a term in an order-sorted sort can be determined syntactically by the exclusive use of an order-sorted parsing algorithm, membership of a term in a membership sort cannot be so determined; it is instead axiomatized in the transformed theory by adding to its signature new Truth-valued predicates for each membership sort that return tt when applied to a term in the transformed theory if and only if that term has that sort in the original theory.

