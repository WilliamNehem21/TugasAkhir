This paper introduces an approach to dynamic software composition in the context of scientific computing where high demands performance seem to prevent such flexible solutions. In our concrete however, dynamic software composition is rather a way to high-performance than an obstacle to it. We achieve this by combining dynamic architectures and task graph scheduling.

In the world of scientific computing a common problem is the mapping of one or more computations onto a grid of interconnected machines. The efficiency of the application or even the feasibility of running the computation is very much dependant on this mapping. Unfortunately, finding an optimal mapping is an NP-hard problem.

This paper presents a dynamic service infrastructure for high-performance applications solving problems like those discussed above. It is originally de- veloped for the LOIS space antenna IT-infrastructure. Our solution is influ- enced by a number of different fields within computer science, for instance optimization of parallel programs, dynamic software architectures and soft- ware composition.

On this IT infrastructure, we execute the "experiments", i.e. applica- tions processing data from the sensors. These applications are data parallel programs. Their input are either sensor input values or the output of other applications. If the input of an application a is the output of an application

For components we assume a High Performance Fortran (HPF)-like program- ming model, with data parallel synchronous program but without any data distribution. For simplicity, we further assume that the programs operate on a single composite data structure which is an array, a. The size of an input a, denoted by |a|, is the length of the input array a.

Array a is either the array of input values or the output of another com- ponent. Note that in our scenarios, the number of input values is fixed. We may assume that the output size of an application is a function of the input size. By induction, it follows that the input size is fixed for all applications in our systems.

x. In many cases of practical relevance it only depends on the problem size n. We call these program oblivious and denote its task graphs by Gn. We write G instead of Gn if n is arbitrary but fixed. The height of a task v, denoted by h(v), is the length of the longest path from a task with in-degree 0 to v.

The computation of a optimal LogP-schedule is known to be NP-hard. However, good approximations and heuristics, c.f. our own contributions in task scheduling, e.g. [9,8,7], guarantee a small constant factor in delay. In practice, the results are even closer to the optimum. The techniques can be

So far, we defined the components as data-parallel applications, translated to task graphs and scheduled to the IT infrastructure. For each component, we can determine an upper time bound for its execution. Each component implements a function mapping an input array ai to an output array ao.

these task graphs. Adding a new application e' is still specified by calling its corresponding function with the result of an existing application e. However, only the new application e' is translated into a new task graph. The input tasks of this task graph are connected with the output nodes of the task graph of e and then handed over to the scheduling unit. Inversely, removing e' leads to disconnecting the corresponding task graphs and deleting transitively

While reusing task graphs is straight forward, reusing schedules is not since a optimum schedule (or its approximation) does not necessarily keep the schedules for the different task graphs distinct. Instead, it might merge task of different task graphs into one process. Moreover, optimum schedules of individual task graphs (or their approximations) are, in general, not part of the optimal schedule for a composed system (or its approximation).

So far our components are modelled as malleable tasks. These tasks are composed to systems modelled by malleable task graphs. The systems are mapped to the IT infrastructure by reusing the pre-computed mapping of the individual malleable task graphs. It remains to show how the schedules

The second assigned task is event management. Events generated extern- ally (e.g a new schedule arrives) and internally (e.g increased sample rate) will be responded to proper actions taken. This is governed by a coordinator application. This coordinator is also responsible for feeding information back to the conceptual coordinator, for instance forwarding events that initiates a new lookahead schedule.

For system level initiation, coordination is supported on different levels. Co- ordinator components present in different applications connect to Coordinator entities on the system level. The network of Probe and Actuator instances also work on this level. Making these entities available for both on-line and off-line

The main contribution of the paper is the introduction of a dynamic ser- vice infrastructure for data-parallel applications, cf. Section 5. We built on a static composition and optimization model of data-parallel programs, we in- troduced a system infrastructure allowing both high performance computing and dynamic change of the systems architecture. Key to our solution are pre- computations of possible changes in the architecture based on run-time events. These evolved system architectures are translated, optimized in parallel to the execution of the actual system. On occurrence of a change triggered by any of those events, the new optimized system can be deployed without further preparations. Additionally, such an event triggers the translation and optim- ization of the new generation of systems the currently running will possibly evolve to.

