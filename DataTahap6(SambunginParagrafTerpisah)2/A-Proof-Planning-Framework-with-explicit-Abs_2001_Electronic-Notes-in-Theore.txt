Secondly, we de ne in Sect. 3 vertical structuring mechanisms to relate di erent reasoning levels. This includes on the one hand the explicit de nition of abstractions, which de ne how reasoning objects of a higher reasoning level are related to those of a lower level. On the other hand, we introduce the notion of re nements, which determine how higher-level reasoning procedure can be implemented by some lower-level reasoning procedures. This subsumes e.g. the notion of re nement encoded in a method of a proof-planner like [10,2], where the tactic wrapped inside a method determines the re nement of the abstract rule described by the pre- and postcondition of the method. Based on the general notion of re nement, the re nement of an abstract proof can be de ned in a uniform manner.

Finally, we present in Sect. 6 the basic programming language to de ne reasoning and re nement procedures and how to combine those in order to organise the overall proof search. These build upon the intuitive reasoning rules provided by window inference reasoning and have an explicit failure and success semantics.

A reasoning level consists on the one hand of the objects we want to reason about as well as the basic reasoning rules, and on the other hand of the reasoning procedures organising the proof search within one reasoning level. The former are de ned by a signature and a set of formulas wrt. some logic. Thus, the reasoning objects and rules of a reasoning level are given by a pair ( ; ), where  is the signature and  is a set of \axioms", and we denote such a pair as a representation. This is similar to the notion of a speci cation in formal speci cation languages [8], which are e.g. used to de ne abstract datatypes and functions about abstract datatypes. For a reasoning level, the signature determines the syntax of the reasoning objects and the available basic reasoning rules are determined by the \axioms" from .

3x = 0), we use as abstraction a representation consisting of states and state transitions. This representation is called TLA-States&Transitions and consists of states hni representing the state, where x has the value n, and state transitions represented by 8n : hni ) hn 1i. This is an abstraction of the transition made by the program, i.e. x 0 ^ x0 = x 1. Finding a proof-plan for 3x = 0, consists in nding a proof for h0i on the (abstract) representation TLA-States&Transitions.	2

The second component of a reasoning level are the reasoning procedures, which organise the proof search within the reasoning level. We adopt a ge- neral notion for a reasoning procedure, by de ning it to be an algorithm in some programming language, which interacts with the proof by applying ba- sic inference rules. Additionally a reasoning procedure comes with a notion of success and failure to re ect about its own behaviour. E.g. in case of failure a reasoning procedure might invoke backtracking to some previous proof state. This notion of a reasoning procedure is general enough to sub- sume various kinds of speci c reasoning procedures developed in automated theorem proving, like, e.g., a tactic in a tactical theorem prover, the various algorithms in an automated theorem prover, or a proof-planning algorithm in some proof-planner.

of a high-level reasoning procedure some planning algorithm, which computes a proof-plan from methods. This proof-plan is a \proof" on the reasoning level of the proof-planning procedure, and consists of the application of basic rewriting rules de ned by the pre- and postconditions of the methods. We can associate to this planning procedure a re nement procedure, which takes generated proof-plan and re nes it by calling the tactics wrapped inside the di erent methods. In this scenario the re nement information is associated

to each basic reasoning rule of the higher reasoning level via the methods. A method describes that an abstract proof step satisfying a certain pattern (described by the pre- and postcondition of the method) could be re ned by the tactic wrapped inside the method. The re nement procedure exploits this knowledge in order to re ne a proof plan. In general it is not possible to describe this re nement information by patterns. In order to deal with the general case, we allow to associate a re nement procedure to some reasoning procedure. Such a re nement procedure takes the proof generated by the re- asoning procedure as a proof-plan to compute a proof on the lower reasoning level (using the lower-level reasoning procedures). Similarly to reasoning pro- cedures, re nement procedures come with an explicit success and failure semantics to re ect about their own behaviour. This allows for example to backtrack the re nement process and to try alternative re nements.

Note that a re nement procedure for some reasoning procedure P can dually be interpreted as some kind of abstraction, where all the (lower-level) reasoning procedures used by the re nement procedure are abstracted to the reasoning procedure P. This notion of abstraction is di erent from the notion presented above, since it is an abstraction of reasoning procedures while the former is an abstraction of objects and axioms. Furthermore do re nement procedures exploit knowledge about object abstractions during the re nement. Hence, an object abstraction also gives rise to some notion of re nement. The reason why we introduced abstractions mainly for objects and re nement mainly for reasoning procedures is because this is the usual way those are used.

For the design of reasoning and re nement procedures we support an intui- tive reasoning style. To this end we aim to focus the reasoning process on arbitrary sub-expressions of some actual expression and to have a strong sup- port of contextual reasoning inside a focus. Window inference [11,6] has been introduced as a formalisation of an intuitive and hierarchical reasoning style.

In order to ensure the soundness of the case analysis 2 the condition h[H] ` A _ Bi+ is generated as an additional goal. In order to allow for an intui- tive design of reasoning procedures, we integrated window inference reasoning with indexed formula trees (cf. Sec. 4) by annotating positions in the indexed formula trees with windows. As focusing on subexpressions is along the tree structure, opening a sub-window corresponds to adding a window on the re- spective position. Similarly, leaving a focus means removing the window from a position and returning to the previous position.

Instantiable Variables: The instantiable variables of some window are sim- ply all variables that are bounded on some -type position in the formula tree. In order to check the admissibility of the instantiation of a variable, we check the L-admissibility of the substitution (i.e. the irre exivity of the new induced ordering  , cf. Sec. 4).

The overall proof search inside the framework is organised by the reasoning and re nement procedures, and some additional language constructs to combine them. The reasoning procedures are based on windows and interact with the proof in two manners: rst, the content of a window can be modi ed by applying a replacement rule from the context of the window. Second, they can introduce a case analysis over some arbitrary formulas A1 _ ::: _ An at any stage of the reasoning process. Following the intuitive reasoning paradigm, reasoning procedures can focus the proof search on some sub-window by calling another reasoning procedure on the sub-window. Finally, they can invoke the reasoning on some higher reasoning level by calling a reasoning procedure on some abstraction of the actual window. To this end they indicate the abstraction to be used and the reasoning procedure of the higher reasoning level to call. In case the abstract reasoning procedure succeeds, the re nement of the (abstract) proof is achieved by calling the re nement procedure of the abstract reasoning procedure. Only if the re nement procedure succeeds, the proof planning attempt is successful.

[10] Julian D.C. Richardson, Alan Smaill, and Ian M. Green. System description: proof planning in higher-order logic with  -clam.  In Claude Kirchner and H el ene Kirchner, editors, Proceedings of the 15th International Conference on Automated Deduction (CADE-98), LNAI 1421. Springer, 1998.

