It is well-known that adding reflective reasoning can tremendously increase the power of a proof assistant. In order for this theoretical increase of power to become accessible to users in practice, the proof assistant needs to provide a great deal of infrastructure to support reflective reasoning. In this paper we explore the problem of creating a practical implementation of such a support layer.

substitution functions, and are implicitly universally quantified for each rule in which they appear [19]. For example, a second-order variable z[] represents all closed terms (we will normally omit empty bracket, writing simply z). The second-order variable z[x] represents all terms with zero-or-more occurrences of the variable x (that is, any term where x is the only free variable).

for quoted terms, and more importantly there is an inductively-defined type that contains all quoted terms. The specific details of the encoding have been published previously [21]. For our current purposes it simply matters that there is a type, so that meta-properties can be expressed.

At this point, we now have a representation function where rules are reflected into statements of provability, and in addition we have a proof-checking predicate for establishing proof correctness. The next step is to prove that the reflected rules are valid using the definition of provability. For example, consider the substitu- tion lemma example. From the proof-checking predicate (4.II), we must prove the reflected rule (3.I).

For clarity, we have written explicit universal quantifiers for the meta-variables to emphasize that meta-variables are quantified for each clause/rule. Again, these do not exist explicitly in the meta-logic, and we will omit them in the remaining rules. As usual, it is assumed that the schema language of the teleportation contexts would alpha-rename the bound variables as needed to avoid capture.

However, this rule is not quite right. The issue is that the terms tij will in general contain meta-variables, and the meta-variables must be separately universally quan- tified for each induction case. As we explained in Section 5, explicit quantification of meta-variables is not expressible in our meta-logic.

In some ways, the result seems startlingly simple. When a logic is reflected, its presentation changes only slightly, and the existing reasoning methods and proof procedures continue to work. The difference is, of course, that reasoning about meta-properties of the logic becomes possible.

It was important to us that the development of the theory of reflection be ac- companied by its implementation. This makes it more useful of course, but an additional reason is that the theory of reflection is rife with paradoxes, and it is easy to fall into false thinking. While we have tried to simplify the account in this paper, the actual formalization was demanding. In particular, the formalization of

We are currently using reflection to develop an account of F<:type theory, which has acted both as a challenge and a guide [15]. For work in the near future, we are considering alternate ways to pose the proof induction principle. Induction is, by nature, not modular. However, we believe that significant practical advances can be made through improved automation and hierarchical decomposition.

