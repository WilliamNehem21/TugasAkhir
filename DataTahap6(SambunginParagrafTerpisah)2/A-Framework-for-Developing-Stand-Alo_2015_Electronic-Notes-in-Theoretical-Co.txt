Current tools for automated deduction are often powerful and complex. Due to their complexity there is a risk that they contain bugs and thus deliver wrong results. To ensure reliability of these tools, one possibility is to develop certifiers which check the results of tools with the help of a trusted proof assistant. We present a framework which illustrates the essential steps to develop stand-alone certifiers which efficiently check generated proofs outside the employed proof assistant. Our framework has already been used to develop certifiers for various properties, including termination, confluence, completion, and tree automata related properties.

Due to their increased power, automated provers like SAT-solvers, SMT-solvers, au- tomated first-order theorem provers, model checkers, termination provers, etc., are becoming increasingly popular for software verification. However, the complexity of these provers comes with the risk of bugs that cause wrong answers (e.g., a termi- nation claim for a nonterminating program). Hence, the reliability of the generated answer is usually reduced whenever the complexity of the prover is increased.

All components of the framework have been made available in the archive of for- mal proofs [21,23,24], and the sources of the running example are freely available un- der http://cl-informatik.uibk.ac.at/software/ceta/framework. Some parts of this work have already been presented earlier [26], but in a much less complete and detailed form.

It is well-known that solvability of PCP instances is undecidable in general. We want to validate certificates for solvable PCP instances. This is a trivial certification task, but can be used to illustrate various design choices and challenges in the process of developing a certifier. We assume that the certificate numbers each pair of words in p and provides the solution as a list of numbers.

To increase reliability, we can make use of LCF-style [10,11,19] proof assistants, i.e., proof assistants whose soundness relies on a small trusted kernel and where definitional packages allow us to write more high-level proofs which are then broken down into kernel-primitives without adding new axioms.

where errors are indicated by Inl and proper results by Inr. Booleans are now replaced by type je check which is an abbreviation for je + unit. Then Inr () corresponds to True and Inl e to False enriched by the error message e.

Here, shows is the type of functions from strings to strings, which allows for constant time concatenation. For each instance ja of the show -class, there is a function shows-prec that takes a precedence (which may influence parenthesization) and a value of type ja. The given value is turned into a string, wrapped inside the shows type. To display lists in a special form, shows-list can be used, e.g., to allow special treatment of strings, which in Haskell and Isabelle are just lists of characters. The show-law which should be satisfied according to the Haskell documentation (and more or less states that a show-function is not allowed to modify an incoming string) is enforced in the Isabelle class definition.

This implication clearly lacks any connection between s and pcp, i.e., if the certifier accepts s, one only knows that some pcp is solvable, which is not necessarily the PCP instance that is encoded in s. And indeed, if the parser would be written in a way that it always returns the trivial PCP instance {(A, A)} with solution [0], then the certifier will never reject any proof.

where at least the returned message m is related to the semantic object, pcp, via the show function show. Then the user of the certifier can inspect whether the string obtained from pcp corresponds to the intended input that is given in s. Clearly, here one has to trust the show function, but usually this is less complex than the parser and hence, also more reliable.

Instead of a human inspection we also integrated a way for an automatic com- parison that the parsed input corresponds to the given input string. To this end, we make use of an XML show function to-xml which outputs the semantic object pcp as an XML-string. Then one can also easily check whether the string obtained from the parsed input is contained in the original input s, i.e., in (4) and (5) one gets the additional guarantee:

Of course, if one enforces such a strict comparison via strings, then the input XML string has to be normalized in some way, e.g., it must not contain comments, since the show function to-xml will not be able to invent the right comments. More- over, there must be consensus about the input XML string and the show function, whether to print <foo></foo> or <foo/>, etc.

We presented a framework to develop stand-alone certifiers, with a simple certifier for PCP as an example. To adapt it to other certification problems, of course one has to adapt the major soundness proofs, but the method of integrating error messages, and the theories on parsing, show functions, etc. should all be easily reusable.

