This paper is about testability analysis for data-flow software. We describe an application of the SATAN method, which allows testability of data-flow designs to be measured, to analyze testability of the source code of critical data-flow software, such as avionics software. We first propose the transformation of the source code generated from data-flow designs into the Static Single Assignment (SSA) form; then we describe the algorithm to automatically translate the SSA form into a testability model. Thus, analyzing the testability model can allow the detection of the software parts which induce a testability weakness.

In the software development process, the validation and verification phases play an important role, in which testing is a crucial task. During this task, faults must be revealed. However, testing increases the reliability of the soft- ware, it never can ensure that there are no faults in the software. In addition, when the software is rather complex, the testing task is time consuming and highly costly. This is why some testability metrics have been studied these last years in order to help in appraising the ease/difficulty for testing software.

The paper is organized as follows. Section 2 is about some related work. Section 3 briefly presents the principles of the SATAN tool which allows the testability analysis of data-flow designs. Section 4 presents the extension of the SATAN tool to analyze code testability. An algorithm is described in Section 5 to automatically compute testability measures. Section 6 presents a case study. Finally, we give our conclusion in Section 7.

input and output domains. Voas and Miller [13] also proposed testability met- rics based on the input and output domains of a software component. Both these methods allow the measurement of testability at component level by an- alyzing functional specifications; they can be used to rank components with respect to testability.

In the SATAN tool, testability of software is based on the controllability and the observability of the software components. Controllability is defined as the ease to forward data from the inputs of the software to the inputs of a component. Observability is defined as the ease to propagate data from the outputs of a component to the observable outputs of the software.

The principle of modeling the information transfers through software consists of representing the control and data-flow aspects on a same graph that is called the Information Transfer Graph (ITG). It is a bipartite directed graph without cycles. This model is defined by places, transitions and edges. The places are:

The ITG is used to identify information paths, which are called flows, through- out the software. A flow is an information path from some inputs to one or some outputs. It contains a set of places, transitions, and edges. Thus, a flow can be considered as a sub-graph; it is an elementary function that can be independently exercised from the remainder of the software, since it computes the output variables from the inputs variables.

Once the set of flows is identified, it is used to determine the set of test objectives according to a test strategy. A test strategy is an ordered set of flows which must be exercised through the software. A test strategy corresponds to a test data selection criterion. The selection criterion is to cover every module in the model at least once by executing the selected flows.

Two test strategies are used in SATAN: progressive structural strategy (Start-Small ) and cross-checking strategy (Multiple-Clue). The cross-checking strategy is based on choosing a subset of flows that satisfy coverage of all the modules: all chosen flows are exercised, possible information of fault is collected, and diagnostic is analyzed on this information. This strategy is effective in the case of simple faults (only one module is defective). The progressive structural strategy is based on a gradual coverage of the modules by choosing flows with an increasing complexity in terms of the number of covered modules, and a new flow is tested only if faults detected in previous flow are corrected; a minimum subset of flows is chosen so that all the modules are covered. This strategy is effective in the case of multiple faults (several modules are defective). Moreover, we recently proposed an improvement of the effectiveness of both these strategies by using some accessibility measures in [9].

As our goal is to apply the SATAN tool for analyzing the testability of the code source, we use the SSA form (Static Single Assignment) [2] to translate code into a data-flow representation. This SSA form has been principally used as a platform for various classical code optimization algorithms in compilation techniques. The testability analysis is based on the SSA form.

From a SSA form we can construct the corresponding ITG. Then, to use the SATAN tool to compute testability measures, i.e. controllability and observ- ability measures, we must associate each module of ITG with a capacity. This module capacity allows appraising the information loss through the module. An ITG with module capacities is called Information Transfer Net (ITN).

In this process, a C program is first translated into the SSA form by the GCC compiler. Then, the SSA form is translated into the ITG. Each module of ITG is associated with its capacity to produce the ITN. Finally, the SATAN tool computes testability measures from the ITN.

Once we obtain an ITG from the SSA form, we need to transform the ITG into an ITN by adding all module capacities. As we told above, a module capacity is the information quantity that is available on the module outputs from its inputs. So, we first determine the types of the inputs and outputs of each module in ITG. Then, capacities will be evaluated for all the modules. Finally, the ITN is constructed from the ITG and the module capacities. This translator is given as follows:

In this diagram, BARY C is a computation component; COPYi is to as- sign a value to an output; COMPi is a comparison component; OR is a logical component; SUBi and MU LTj are respectively the subtraction and multipli- cation components; SWIT CH is a selection component; and PRECi is a memorization component. The diagram has several inputs and outputs. In particular, two outputs btgyrononv and tgyrononv form a couple: the boolean value of btgyrononv determines whether the value of tgyro nonv is valid. This diagram is designed for a piece of the avionics software used at THALES Avionics.

In this ITG, the SATAN tool identifies 12 flows. Then it also computes testability measures of each module in each flow. One module can have dif- ferent values of testability in different flows. So, a fine analysis can be done by examining testability of each module in each flow, then all modules with low testability will be identified. The testability of such the modules should be improved, or they must be carefully tested.

We now analyze the code generated by the GALA tool from diagram sub-THT. As the code contains more details than the diagram, so the ITG obtained from the code contains more elements (modules, transitions, edges) than the one obtained from the diagram. Here, we do not present the ITG because of limited presentation space. The SATAN tool identifies 42 flows in the ITG. The number of flows from code analysis is increased with respect to the number

Relating to measures, among 42 flows, 20 flows have the testability (1.0, 1.0), and 22 others have the testability (1.0, 0.0833). Comparing the measures ob- tained from two levels of analysis, we state that they are very similar. Hence, we can say the coding process does not have impact on the testability. How- ever, some modules should be reviewed to improve the observability measures.

