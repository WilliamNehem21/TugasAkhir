The development of computer languages or software artefacts from basic concepts to the final product is usually a process starting with an abstract model of a key concept and extending this by adding more detailed functionality for extended structural definitions. We will present a refinement approach for the stepwise development of algebraic models. In each step we either add new elements to a model or refine the properties of existing ones. The process of refining elements such that properties of the original element are preserved is called superposition. We will present a categorical framework for refining algebraic structures. Algebras can be used to model a variety of concepts and objects. Language semantics and formal methods are two application areas which use models represented in terms of algebras.

The development of computer languages or software artefacts from basic con- cepts to the final product is usually a process of starting with an abstract model of a key concept and extending this by adding more detailed func- tionality for extended structural definitions. We propose a layered, stepwise development method for algebraic models. Each new layer either adds new elements to a model or refines the properties of existing ones. Since addition of new elements is a straightforward operation, we address the refinement or redefinition of elements here. The process of redefining elements such that properties for the original element are preserved, shall be called superposition. We present a categorical framework for refining algebraic structures. Alge- bras are used to model a variety of concepts and objects. Language semantics [11,12] and formal methods [10] are two application areas which use mod- els represented in terms of algebras. Our approach generalises other extension and refinement techniques such as the VDM refinement notion, see [5,6]. Soft- ware component technology in another possible application area, where our framework can be used as an adaptation technique in order to re-use a library component in a slightly different context. Our main objective is to obtain a framework for superposition which can be used in the definition of development methodologies for language design or software development. Our framework supports the idea of modularity in design by introducing concepts for a step- wise development in layers. Applying the superposition operator discharges automatically all proof obligations concering property preservation. We will present a framework which allows a language or software designer to create a library of superposition operators for various applications.

It should be noted here that T is not generally a functor. The lifting triple can not expected to be a monad - a confusion might occur since some authors use the name triple for monads. Triples are different from monads here.

A domain can be constrained by a type predicate. We consider types as explicit objects, we also consider the predicate as a truth-valued map which includes or excludes elements from the domain. Our approach to representing types will use slice categories, see [1] p.35. However, we also look at monoid actions and types in Section 3.2 in order to introduce an alternative.

The combination of both forms of preservation, type and function preservation, shall result in a function lifting which respects types. The main problem is that the representation is introduced on the original domain, not on its constrained forms, the types. We carry out two investigations. Firstly, we consider the integration of the representation into the characteristic function definition. Secondly, we integrate types into function preservation.

Based on the category E, which comprises all elements needed in our approach, we define two major subcategories of E which will capture function preservation, viz. Ef , and type preservation, viz. Et, in isolation. Additionally, two functors expressing the extensions will be defined on these subcategories.

functor involving truth-value objects is not relevant. These constructs only constrain one particular step. Quotients, for instance, are a means to capture which behaviour has to be preserved for a single step; it is not relevant for a second lifting. Subject to composition are only mappings on types, e.g. from A to T1A and from T1A to T2T1A, and on functions, e.g. f to T1f and T1f to T2T1f . A result about the compositionality of extensions shall be formulated.

Applying our superposition operator results in a model presented in layers, each superimposing the layer below. The layers are specified using superpo- sition and (possibly) augmentation. Redefinition with property preservation is captured by superposition. In order to provide a useful tool kit, so-called superposition schemes need to be introduced - essentially a library of common superpositions which have been obtained by applying our concepts to language semantics. Details about this in an earlier work can be found in [12].

