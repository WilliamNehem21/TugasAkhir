The remainder of this paper is organized as follows. Section 2 introduces the background of this work. Section 3 presents our motivating case along with an illustrative example which we use as a running example throughout the following sections. Section 4 details our formal model, including the necessary definitions and specifications. Section 5 describes the automated reasoning that we currently provide. Section 6 discusses related work. Finally, Section 7 sets out conclusions and outlines future work.

In [11], IBM researchers Kephart and Chess introduced an architectural approach to realize autonomic computing based on independent elements capable of managing both external resources and their internal behavior. In light of this, autonomic systems are compositions of these autonomic elements, constantly interacting in accordance with high-level policies. Each autonomic element is composed of an autonomic manager, an implementation of the generic control feedback loop from control theory, and a managed element, a hardware or software resource, such as a server, a service or a set of interconnected software components.

A great variety of combinatorial problems can be expressed as searching for one or several elements in a vast space of possibilities. In general, the search space is defined as all combinations of possible values for a predefined set of variables. Elements to be searched for are particular values of these variables. In most cases the desired values of the elements are implicitly specified by properties they should satisfy. These properties are known as constraints, which are usually expressed as predicates over some set of variables. Roughly speaking, a problem formulated in this frame is known as a Constraint Satisfaction Problem (CSP) [16].

Solving a CSP consists of two steps: modeling the problem (logical specification) and finding its solutions through a form of search (in this paper we perform a basic backtracking). Modeling involves basically the specification of the variables, their domains and the constraints among them. Solving the CSP through backtracking is an attempt at trying to incrementally build resolution candidates by assigning possible values to the variables. Partial candidates that cannot become a valid solution are discarded. If all variables are bound, a resolution candidate has been found. If, after exploring all possibilities no resolution candidate has been found, then the problem does not have a solution.

To illustrate the problem of adapting an EA, while at runtime, when the set of quality agreements (captured as quality scenarios as explained by Bass et al. in [20]) changes, we use the case of a large-scale e-commerce application. We use this case as a running example throughout the following sections. The following sections give the details regarding how the Planner element of the SHIFT Framework captures adaptation constraints and reasons upon them to determine possible adaptation plans to satisfy changing context conditions.

The previous e-commerce application provides an interesting example of the deci- sions that need to be taken when planning an adaptation to satisfy changing quality scenarios. Manually evaluating all component compositions, their relationships to quality scenarios and quality scenario interactions are costly, time consuming and error-prone; even more when the software system is already operational. In this section we propose an approach addressing dynamic adaptation planning built on the principles of constraint satisfaction.

This section presents how automated reasoning is provided in the Planner element. Due to interactions between quality scenarios, and since different component com- positions may be available; conflicts between componentsets may arise. Automated reasoning seeks to cope with this issue by providing additional information to get the best possible selection of componentsets when determining an adaptation plan. The proposed approach is able to answer the following questions.

Flexible componentsets. A flexible componentset is a componentset that can be applied in self-adaptation plans for the same quality scenario with different combinations of other componentsets. Given a set of possible resolution models, there should be a way to find the componentsets appearing more than once in such set.

matches the criteria of an objective function. Two objective functions were taken into account. On the one hand, the function that outputs the resolution model with the greater number of applicable componentsets to self-adapt an enterprise application; namely max. On the other hand, the function that outputs the res- olution model with the least number of applicable componentsets to self-adapt an enterprise application; namely min.

As future work, we will extend the model for reasoning on the process of bind- ing components while they are redeployed on system infrastructures. We will also implement a support tool for the model and integrate it into a self-adaptation in- frastructure. Other challenges to face in the near future are to perform a validations of our implementation with a case study.

