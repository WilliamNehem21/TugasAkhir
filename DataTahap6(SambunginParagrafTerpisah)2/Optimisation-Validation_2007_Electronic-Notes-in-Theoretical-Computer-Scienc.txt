We introduce the idea of optimisation validation, which is to formally establish that an instance of an optimising transformation indeed improves with respect to some resource measure. This is related to, but in contrast with, translation validation, which aims to establish that a particular instance of a transformation undertaken by an optimising compiler is semantics preserving. Our main setting is a program logic for a subset of Java bytecode, which is sound and complete for a resource-annotated operational semantics. The latter employs resource algebras for measuring dynamic costs such as time, space and more elaborate examples. We describe examples of optimisation validation that we have formally verified in Isabelle/HOL using the logic. We also introduce a type and effect system for measuring static costs such as code size, which is proved consistent with the operational semantics.

In this paper we investigate a significant extension of this framework and a particular application. First, we generalise the form of resources so that a wider range of notions is covered, in an uniform fashion. Second, we consider orderings on resources, which allow us to talk about optimisation validation, in the sense that we can establish when one program consumes fewer resources than another.

Static costs such as code size are commonly used as metrics for optimisation and some dynamic costs can be usefully approximated with static measurements. We cover both possibilities by introducing a notion of static resource algebra S. To measure static costs, we use a type system with effects. For two function bodies e1 and e2 we must find a type t and effects s1 and s2 such that:

This paper is organized as follows. In Sect. 2 we present the dynamic semantics of our language, introduce resource algebras, and describe some typical instanti- ations. In Sect. 3, we present a program logic that generalizes the logic presented in [1] to arbitrary resource algebras. Sect. 4 gives example optimisation validations, including standard compiler optimisation steps, tail-call optimisation and an ap- plication specific one. Sect. 5 examines the static system, while Sect. 6 concludes with a summary and discussion of related work.

algebras such as this that depend on runtime values can collect traces along the path of computation. The resulting word may be constrained by further policies, specified for example by security automata [27] or by formulae from logics over linear structures. These can be encoded in the higher-order assertion language of our program logic, introduced next.

The program logic presented in the previous section can be used to justify program transformations that are routinely applied in optimising compilers [20], provided they are in fact improving. In this section we give some example optimisations and sketch the proofs of their validation. While the transformations and the examples we consider in this paper are fairly simple, they serve the purpose of demonstrating our methodology.

The first line defines the specification of R.calc0 in terms of the auxiliary function costf , while the entries for call f and call h ensure that the auxiliary functions correctly model the costs of the executing the local functions. In both cases, the specifications depend on the value of the variable i; intuitively, the universally quantified variable J represents the number of loop iterations that have already been performed.

Numerous optimisations are possible in this example to increase the rate of testing the sensor level. For example, we might sum up the section sizes only until we find out that the critical level has been safely exceeded. Or (supposing the dimensions of the tank are fixed during the run of the process), we may calculate the sums for the container sections in advance to avoid looping over the section array each time we test the sensor level. We have not yet undertaken the formal verification of this example, as it goes slightly beyond our formal presentation of the logic as it makes use of arrays; however, the extension is straightforward.

Weakening is admissible as is a specialised form of substitution, in which ar- guments play the role of variables and the effect is increased accordingly. This generalises value substitution in type and effects systems, which holds because val- ues are pure (i.e. have zero effect).

We have presented a framework and methodology for optimisation validation, based on generic forms of dynamic and static resource costs. We have formalised most of the setting in Isabelle/HOL, particularly including the soundness and completeness of the program logic, which was applied to validate the specific optimisations in Sect. 4.

By now there is an extensive literature on verifying compiler correctness and op- timisations (e.g. [10,11,20]), but as far as we know, no previous work on formal and static methods for verifying that optimisations in fact improve resource usage. The closest are an early formal approach to performance estimation and monitoring for space and time complexity w.r.t. OO programs [26] and, at the other end of the spectrum, a framework for predicting the impact of optimizations, via models for the latter as well for code and resources [31]. This is empirically tested and used to select the right combination and application strategy of given optimizations.

GNU C compiler intermediate language. Similarly to Rinard, he uses simulation of execution paths, but instead of compiler annotation, a constraint-based algorithm heuristically tries to infer a simulation. The system is robust enough to allow the author to verify structure preserving optimisations in gcc itself.

Elsewhere, forms of cost algebras (monads) and partial orders similar to ours have been investigated for analysis of resource consumptions, e.g., [19,14] and op- timisation [21]. General static analysis techniques having similarities with the setup of our type and effect system include [16,29]. There is also considerable work on specific static analysis for different notions of resource usage: to name one, the use of abstract interpretation for certification of bound memory usage in Java byte code [9], but a more complete survey would lead us well beyond the scope of this overview.

There are several avenues for pursuing this work. First, by considering finer-grained transformations individually, perhaps by generalising Improvement Theory to re- source algebras. Second, it would be noteworthy if our static analysis was able to validate optimisations directly and avoid the need for the program logic: this is in fact possible in restricted (e.g. boolean) domains, but further assumptions are needed in the general case. To scale our techniques to routine application we would need either an automatic technique based on the type system or better automatic assistance for using the program logic. Endowing relational Hoare logics with a notion of resource algebra seems also a swift way to combine semantics preservation with optimisation validation.

