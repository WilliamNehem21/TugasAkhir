Model checking [3], as opposed to theorem proving, is a fully automatic technique for determining whether a specified system satisfies a given property. A model checker exhaustively checks the state space of a system to determine whether or not the property holds. In the latter case, a model checker will usually provide a counter-example, or witness, providing insight into why the property does not hold.

Model checkers were originally restricted to finite systems, and to simple notations suited to modelling systems where the complexity lay in the control structure, rather than the data, e.g., hardware systems and communication protocols. Recent advances mean that these restrictions are no longer abso- lute. Automatic techniques for property-preserving abstraction [10,16,2] and bounded model checking [5] are two means of allowing systems with infinite state spaces to be checked. Powerful automatic decision procedures allow model-checker languages to support high-level specification constructs such as lambda expressions, set comprehensions and universal and existential quanti- fiers [6]. Hence, it is possible to model check specifications written in high-level languages [18].

We have found that the branching time temporal logic CTL [8] is par- ticularly suited to modelling simulation rules. In this paper, we show how CTL model checkers, e.g., NuSMV [1] or SAL [5], can be used to check the standard conditions for downward simulation. We do this both for systems with a blocking, or guarded, interpretation of operations, as well as those with the more common non-blocking interpretation [7]. We plan to extend the approach to upward simulation in future work. In Section 2, we introduce the temporal logic CTL. In Section 3, we describe how downward simulation can be checked under a blocking semantics, and in Section 4 extend these ideas to a non-blocking semantics. Our approach is not specific to a particu- lar state-based specification language nor a particular CTL model checker. In Section 5, we discuss our experience with instantiating our approach with Z specifications [20] in SAL. We conclude in Section 6.

one path of the Kripke structure M starting from s0. For example, EX f1, where f1 is a CTL formula, states that for at least one path starting from the state s0, f1 holds in the next state. Similarly, E[f1 U f2] states that for at least one path starting from s0, f1 holds until some state where f2 holds. Also, EF f1 states that for at least one path starting from s0, f1 eventually holds, and EG f1 states that for at least one path starting from s0, f1 always holds.

The formulae in category (iii) express properties which are true on all paths of M starting from s0. For example, AX f1, where f1 is a CTL formula, states that for all paths starting from the state s0, f1 holds in the next state. Similarly, A[f1 U f2] states that for all paths starting from s0, f1 holds until some state where f2 holds. Also, AF f1 states that for all paths starting from s0, f1 eventually holds, and AG f1 states that for all paths starting from s0, f1 always holds.

In this section, we discuss a general approach to checking downward simula- tions under a blocking semantics with a CTL model checker. We first provide systems for checking each of the downward simulation conditions individually. We then combine these systems into one in which all the conditions can be checked simultaneously. This latter system can also be used to check the con- ditions individually; something which is useful for finding problems when a refinement does not hold.

As mentioned in the introduction, we need to combine these systems in order to check the simulation conditions. As would be expected, the conditions of Definition 3.1 refer to both the abstract and concrete states. Hence, a combined system must have access to both. We will assume the state variables of the abstract and concrete systems are disjoint as in the example above. If

That is, there exists a next state such that x = y . Note that the CTL operator EX allows us to determine whether it is possible to perform an operation and reach a particular state. This ability to existentially quantify over next states is what makes CTL particularly useful for capturing simulation conditions. If there were more than one abstract initial state, then the use of EX above means that only one of these need be related to the concrete initial state.

Since, in general, there will not be an operation enabled in all states, e.g., for the example, neither AOpapp nor COpapp are enabled when x = 10 and y = 10, we need to introduce a further operation to ensure the transition relation is total. This operation Choose is always enabled and simply chooses

So far our experiments have not utilised the full power of the SAL tools. We have therefore been restricted to specifications with a finite and relatively small state space. SAL supports many optimisations features, as well as a variable abstraction facility which can effectively be used to ignore variables not influencing a property we wish to prove. These features need to be investi- gated as a means of extending the size of the specifications we can handle. In addition, future versions of SAL are expected to support predicate abstraction [10,16,2]; we view this as essential for using our approach with much larger examples.

ifications using the SAL CTL model checker. The approach, however, is gen- eral enough to use with any state-based specification language, and any CTL model checker in which the language can be encoded. We envisage the ap- proach becoming more applicable as it takes advantage of the current efforts in the temporal logic model checking community to extend model checking to systems with larger, and even infinite, state spaces.

