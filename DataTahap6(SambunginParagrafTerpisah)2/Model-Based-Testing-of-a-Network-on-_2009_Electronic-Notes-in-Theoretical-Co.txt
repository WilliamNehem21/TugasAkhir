We discuss the problem of model based test case generation and that of automatic testing of a component of an asynchronous Network-on-Chip (NoC). We start with a model of the component in B Action System, which is a state based formalism based on Action Systems and the B Method. We construct a finite state space graph by executing the model, and next, generate a test driver from the abstract test cases. This test driver can be used to test a matching implementation automatically. The important contribution of our work is that we consider hierarchical models for test case generation and automatic testing, whereas the previous approaches considered flat models. In addition, we also highlight the issue due to non-determinism in hierarchical models.

along with operations which modify the state. B Action Systems [7,31], the modeling notation of this paper, is a state based formalism based on Action Systems and the B Method [1]. Note that a model in B Action Systems is a valid model within the B Method; therefore, tool support for the B Method [9,5,18] can be used to analyze models in B Action Systems. The existing model based testing approaches [4,24] to handle B models consider only flat models; i.e. models without any hierarchy. Hierarchy plays an important role in modular design and modular implementations. Hierarchy also provides a natural mechanism for parallel and distributed design. In addition, refinements in B Method may also introduce hierarchy.

The organization of this article is as follows. Section 2 discusses the related work. In Section 3, we present a short introduction to the B Action Systems and then discuss the model of a NoC component. Section 4 presents the problem that we address in this paper. Section 5 discusses the test generation procedure. In Section 6, we outline a solution to the problem of non-determinism. In Section 7, we present an analysis of our approach. Finally, Section 8 concludes this paper.

operation instances are created as the number of valid disjuncts in the DNF. An attempt is then made to create a Finite State Automaton (FSA) in which each node represents a possible machine state and an edge represents an application of an operation instance. Test cases are then generated by traversing the FSA.

The BZ Testing Tool (BZ-TT) [4] and the ProTest approach [24] also partition the operation input space in a manner similar to the method of Dick and Faivre. Both methods also use variants of the Dick and Faivre technique to generate test cases. In addition, both consider flat B models.

Hamon et al. [16] have used model checking to generate test cases from models in the SAL [23] formal language. Keeping a coverage criterion in mind, the SAL model is so instrumented with trap variables [16] that reachability of a trap variable implies reachability of a model element; reachable traces then become the test cases. Although there is considerable amount of work on formal methods applied to NoC system design [32,26,29], to the best of our knowledge, there is hardly any if its guard evaluates to true. As regards to the behaviour of the Action System [3,19], the initialization statement is executed first, and thereafter as long as there are enabled actions, one of the enabled actions is selected non-deterministically for execution. When there are no enabled actions, the system terminates.

B Action Systems can be composed to model parallel systems [7,20]. Structuring mechanisms such as SEES, INCLUDES and PROMOTES can be used to express B Action Systems as a composition of subsystems [1]. The SEES-mechanism allows read access to the seeing system. The INCLUDES-mechanism allows write access to the variables of the included system. Actions of the included system can also be made available by promoting them into the including system within a PROMOTES-clause. The structuring mechanisms provide an efficient way to model system hierarchy.

Finally, four instances of this router (a.Router, b.Router, c.Router and d.Router) were composed into a controlling system named M odule abcd which con- trolled the data distribution between the routers. In order to do so, some of the global interface procedures of PushChannel were promoted to the interface of the

Refer to the test driver shown in Appendix A. This Java program has a manual part and an automatic part. The automatic part is generated automatically by the test driver generator. Everything cannot be generated automatically because in that case, we must have knowledge of the signatures of the class constructors even before the code is written. In the manual part essentially the global objects are created. These issues have been discussed in [25]. Here, we have considered automatic testing of a single test case. The same can be repeated for the remaining test cases.

The BAS model of the Router component has altogether 23 operations. All such operations were covered by the eight test cases. Note here that, we have considered a simple testing criterion. For a complex test criterion, achieving full coverage could be a challenging task.

In this paper, we have considered models in BAS which can be hierarchical. Previous works [4,24] considered only flat B models. For our testing approach to succeed, we expect that the implementer must not deviate from the structure of the test template derived from the BAS. This means the implementer must preserve the hierarchy and the action (and procedure) signatures; in addition, the recommendations associated with a promoted operation must also be preserved. Furthermore, the implementation must have the probe operations with matching signatures. Note that the implementation is treated as a black box.

Following the principle of the B Method, one would expect that the development process is completely formal and then no testing will be necessary. However, it is not the case that a formal refinement process is always followed. In many cases, the specification and possibly the first few refinements undergo the formal refine- ment process and for the rest, model based testing is recommended. Moreover, sometimes model based testing is recommended before performing any refinement proof between the abstract and refined models. For testing purposes, we can view the refined model as the implementation. This activity can potentially cut down the time for performing proofs considerably.

Functional test cases can also be generated by using model checking [16]. ProB tool can generate a finite state space of the hierarchical B model. A test criterion like state or transition coverage can mean reachability of the state or transition; trap variables can be attached to the state or transition, and reachability of the trap variables means satisfying a LTL formula. Next LTL model checking [8] can be used to find an appropriate trace which can be used as a test case.

