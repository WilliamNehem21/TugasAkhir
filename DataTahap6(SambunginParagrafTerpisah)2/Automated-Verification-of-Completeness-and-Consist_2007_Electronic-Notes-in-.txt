Consistency and completeness were identified as useful properties of specifications in [8] and in [9]. In the context of specification of embedded systems, completeness of the specification is defined as the specification having a response for every possi- ble class of inputs. In the same context, consistency is defined as the specification being free of contradictory behavior, including unintentional non-determinism [9]. Formal definitions of these properties, in the context of Abstract State Machine (ASM) specifications, are given in Section 3. Traditionally, verifying these proper- ties was accomplished manually by system specifiers, through inspection of specifi- cations. Because a specification is likely to evolve during the engineering lifecycle, the ability to verify these properties automatically can ease and shorten the analysis process [9]. Language specific verification algorithms have been proposed in [8] and in [9]. In contrast, the approach proposed in this paper is not language specific and can be reused for other languages. The proposed approach achieves verification by translating specifications to formulas in propositional logic, formulating complete- ness and consistency as a boolean satisfiability problem (SAT ) [20], and automating the verification procedure by using a generally available solver.

In the ASM community, various derivatives of the ASM language have been developed, including the ASM Workbench [3] and the Abstract State Machine Lan- guage (AsmL) [7]. A mapping between the ASM Workbench language (ASM-SL) and finite state machines, for the purpose of model checking, was proposed in [21]. A mapping between the AsmL language and finite state machines was proposed in [5]. The mapping to finite state machines was used for automated test case gen- eration [6]. The mapping proposed in this paper resembles the mappings proposed in these two approaches except that it ignores the effect of rule applications and does not need to generate a global reachability graph. The proposed mapping con- cerns itself only with relationships between rule guards inside a single machine and hence produces a smaller state space than might be generated through a complete reachability graph.

SAT solvers have been used for a variety of automated analysis, including test case generation [10], [18]. Although the SAT problem is known to be NP-Complete, the use of SAT solvers has been shown to be useful in a wide range of cases. SAT solvers and model checkers show similarities in their benefits, namely automation of the verification procedure and automation of the counterexample generation. SAT solvers and model checkers also show similarities in their drawbacks, namely the potential for state space explosion and the resulting intractability of large state space exploration.

rule, Ei, to be applied to the environment. The effect of the rule is grouped into an update set, which is applied atomically to the environment at each computation step of the machine. For a complete description of the theory of abstract state machines, the reader is referred to [2].

The Timed Abstract State Machine (TASM) language [16] is an extension of the ASM language for the specification and analysis of real-time systems. The TASM language extends the specification of rules by enabling the specification non- functional properties, namely time and resource consumption. The semantics of rule execution extend the update set concept by including the duration of the rule execution and a set of resource consumptions during the rule execution.

Informally, completeness is defined as the specification having a response for every possible input combination. In the TASM world, for a given machine, this criteria means that a rule will be enabled for every possible combination of its monitored variables. The monitored variables are the variables in the environment which affect the machine execution. Formally, the disjunction of the rule guards of a given machine must form a tautology. The letter S is used to denote an instance of the SAT problem. The completeness problem can be expressed as a SAT problem in the following way:

The completeness problem is casted as the negation of the disjunction so that counterexamples can be generated by the SAT solver. If S is satisfiable, all the assignments that make S satisfiable can be automatically generated by the SAT solver. If S is not satisfiable, the specification is complete.

Informally, for a state-based specification, consistency is defined as no state hav- ing more than one transition enabled at the same time [8]. The definition given in [9] is similar but extended to include other properties of the specification such as syntactical correctness and type checking. The definition of consistency adopted in this approach is the same as in [8]. In terms of TASM specifications, this definition states that no two rules can be enabled at the same time. This definition will lead to a set of SAT problems to define consistency: lems can also be composed into a single SAT problem. As for completeness, the SAT problem is defined in such a way that if the specification is not consistent, a counterexample is automatically generated. If S is satisfiable, all the assignments that make S satisfiable can be automatically generated by the SAT solver.

The TASM language is a typed language that includes integer datatypes, boolean datatypes, and user-defined types. User-defined types are analogous to enumeration types in programming languages. The TASM language is a subset of the ASM language and does not include all of the constructs of the ASM language. For example, the choose construct is not part of TASM. The concepts from the ASM language included in the TASM language are the same as defined in [21]. The translation from TASM to SAT involves mapping the rule guards, Gi, to boolean propositions, bi, in Conjunctive Normal Form (CNF). The following subsections explain how this translation is performed.

In the TASM language, user-defined datatypes and boolean datatypes are simple types that can take values for a finite set. Boolean variables can take one of two values (true or false). User-defined types can take one of multiple values, as defined by the user. In typical specifications, user-defined types rarely exceed five or six members.

following type is introduced: type1 := {val1, val2, .. ., valn}. A variable of type To illustrate the generation of the at least one and at most one clauses, the boolean can be viewed as a variable of type type1 where n = 2. First, the set of

<  com pop  > < expr >, where < var > is an integer variable <  comp op  > is a comparison operator and < expr > is an arbitrary arithmetic expression that can contain constants, variable references, function machine calls, and operators. The restriction is that the left hand side of constraints can contain only a variable, with no arithmetic expressions allowed. The translation proposed in this section, deals only with linear constraints whose right hand sides are constants. Arbitrary symbolic right hand sides will be handled in future work, as explained in section 6. The key idea behind the translation is to convert each integer variable to a user- defined type. This is achieved by collecting all of the constraints on a given integer variable and extracting the intervals that are of interest. These intervals become the members of the user-defined types. Once the integer type has been converted to a user-defined type in this fashion, it can then be converted to a boolean formula using the approach from Section 4.1. The algorithm to reduce integer variable to user-defined types consists of 4 steps. For each monitored variable of type integer:

one and the at least one clauses, in the same fashion as explained in Section 4.1. For a specifications where there is significant use of integer constraints, the use of Mixed Integer Programming (MIP) solvers could be better suited for completeness and consistency analysis. This option is investigated in Section 6.

erties automatically, using a widely available and optimized tool, a SAT solver, is provided. This approach contrasts previous attempts using other languages, which have used special purpose verification algorithms. Previous attempts have moti- vated the use of special purpose algorithms to remove the need to generate a global reachability graph, as would be done in approaches based on model checkers. The translation proposed in this work also removes the need to generate a global reach- ability graph by constraining the analysis to a single machine and by considering only the structural properties of the specification. The big open question in this work is whether the use of a SAT solver to verify consistency and completeness is feasible for archetypical real-time system specifications. The number of propositions can grow exponentially, depending on the nature of the specification. Preliminary results indicate that the translation algorithm could undergo further optimization since it appears to be a bottleneck, compared to the time spent in the SAT solver. The translation algorithm will be analyzed in detail for time complexity and will be optimized accordingly.

