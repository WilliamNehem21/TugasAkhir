The Unifying Theories of Programming (UTP) [5] provide a framework that al- lows for the integration of a variety of programming languages with different com- putational paradigms within a unified relational model. It captures the meaning of imperative, functional, declarative and concurrent languages, for example, and identifies common features. It also provides a uniform semantic presentation of programming theories, and shows how links between them can be formulated and reasoned about. The semantics of a variety of integrated programming and mod- elling languages are based on the UTP [7,12,2].

With the existing semantic encoding, there are a few subtle complications related to reasoning about refinement statements as the above. They mostly arise from the fact that neither a dynamic notion of UTP theory nor of instantiation of a theory are provided. Instead, that encoding introduces a global universe of variable names with no restrictions imposed on their types. Concretely, a type of bindings (records) that associate names to values is introduced and predicates of all theories are modelled as sets of bindings.

We identify two problems with this approach. Firstly, such axioms would not merely restrict the predicates of a singular UTP theory but in fact all UTP theories in the current ProofPower theory scope. This is partly due to UTP theories being organised in a static hierarchical manner, and ultimately each theory being charac- terised by further restrictions on the general theory of relations whose underlying predicates would be constrained by axioms such as the above. For this reason it would not be possible for two predicates in which variable x has different types to coexist within the same ProofPower theory scope, a crucial limitation that we over- come in this work. The hierarchical presentation of UTP theories, which is explored in [11], has crucial benefits in terms of reusing definitions and laws, hence our aim is not to abandon it but rephrase it in a dynamic way.

Section 2 further details the main principles and ideas of the UTP; the following Section 3 then presents the relevant parts of our semantic encoding defining the notion of alphabetised predicate, UTP theory and instantiation. Section 4 surveys how we reason about UTP theories in general, Section 5 is concerned with refinement laws and reasoning about particular specifications, and Section 6 addresses the formulation and proof of properties about theory links. Section 7 discusses a few relevant design issues and revisits the introductory refinement conjecture, and in Section 8 we finally draw our conclusions.

The alphabet of a theory defines the variables that correspond to a relevant observable property. In programming theories these could be, for example, state variables, but also auxiliary variables that may record termination of the program (okay), traces of events while the program executes (tr ), for example. Healthiness conditions identify the set of predicates with the right alphabet that belong to the theory.

Operators include Skip (IIA), the assignment x :=A e and the conditional P a b d Q . The subscript A of these operators is an alphabet that needs to be given as a parameter. Any construct in the UTP must specify the alphabet of the corresponding predicate; where the alphabet cannot be determined from the operand(s), it has to be explicitly provided.

As already said, the semantic model for an alphabetised predicate is a set of bindings describing the valuations that render it true. The potential bindings that can be used in representing predicates are, however, subject to type restrictions. The formal characterisation of an alphabetised predicate is a tuple defined as follows.

ensures that the universe of a predicate does not contain information that is not relevant to its meaning. This could result in anomalies when combining predicates of different theories that have incompatible universes. The second constraint ensures that the bindings of a predicate respect the type constraints imposed by the universe.

The type UTP THEORY allows us to represent arbitrary instantiations of UTP theories within the same ProofPower reasoning scope. To make the process of con- structing theories more convenient, we provide functions for generic instantiation, instantiation through strengthening existing theories, or specific instantiation of common UTP theories. The inherent hierarchy of various types of UTP theories is directly reflected by the ProofPower definitions which provide their instantiation means.

One of the motivations for instantiation is to permit reasoning about the predi- cates of particular UTP theories, and construct verification arguments based on refinement. Although UTP THEORY has the ingredients to distinguish various theories, we have to provide further means to characterise the predicates of these theories. The predicates of a given UTP theory object are determined by the func- tion TheoryPredicates.

ALPHAPREDICATE : the argument has to be a predicate of the respective theory. Similarly, the range may be specified to be predicates of specific theories. An example is the definition of the Skip operator for designs, which is different from the relational Skip IIR.

To express this law more concisely, we provide an alternative definition which pa- rameterises TrueP with a UTP theory. Conceptually, this allows us to speak of predicates such as true, x := 1, y' = 2, II, and so on within specific theories. The following illustrates how this results in a more compact rendition of the above law.

An alternative approach is to formulate and prove a collection of algebraic (re- finement) laws specific to particular UTP theories. This is achieved by explicitly stating the family of theories within which it holds. In the case of nondeterministic choice we can formulate the following law that allows us to easily prove the above refinement.

use of a posteriori constraints being imposed on existing variables as they are not checked; this has been taken into considerations when recasting the existing defi- nitions and encoding. For example, to handle the restrictions on the type of okay and okay' in a theory of designs, we do not impose any constraints on a previously introduced set, as in [11]. Instead, we define a set DES UNIVERSE which explic- itly specifies the domain of the instantiation function InstDesTheory presented in Section 3.1. To apply InstDesTheory to some universe u, we have to prove that u introduces the correct type restrictions on the auxiliary variables. If this is not the case, the result of the function application is undefined, and this can be detected as soon as we attempt to prove properties about InstDesTheory u because of the absence of knowledge about its value. This is not, however, an inconsistency and does not raise the possibility of vacuous proofs.

We have presented a semantic encoding of the UTP in ProofPower-Z that provides facilities for theory instantiation and thus allows us to mechanically reason about UTP theories in a specific as well as general manner. Previous work on mechanised reasoning in the UTP was geared towards proving laws valid in families of theories rather than properties of particular models. In contrast, our approach supports reasoning about (elements of) specific instances of theories, and as almost a side effect, about theories in general.

