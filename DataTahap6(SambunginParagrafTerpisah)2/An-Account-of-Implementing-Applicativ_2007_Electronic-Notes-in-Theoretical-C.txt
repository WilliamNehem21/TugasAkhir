Generation of labelled transition systems from system specifications is highly dependent on efficient rewriting (or related techniques). We give an account of the implementation of two rewriters of the mCRL2 toolset. These rewriters work on open terms and use nonlinear match trees. A comparison is made with other commonly used efficient rewriters.

First, we introduce the part of the mCRL2 data language that is relevant for rewrit- ing and the general architecture of our implementations in Sect. 2. In Sect. 3 we discuss the matching algorithm used and Sect. 4 and Sect. 5 contain the descriptions of the innermost and JITty rewriters, respectively. We conclude with an analysis of some benchmarks in Sect. 6.

Match trees determine the way a term is matched; each node of a tree represents a basic instruction and guides the path through the tree. We start at the root and walk up the tree, choosing branches based on the result of matching so far. For example, one node could be to check whether a (sub)term has a specific head symbol. Matching continues with one branch if the symbol was found and with the other branch otherwise.

The first rule indicates that as soon as there is a tree indicating a positive match, we can just return that match and ignore the other trees. In the rule for S we introduce a fresh variable to avoid conflicts with variables in other trees. When applying the F rule for a symbol f , we consider all trees that have such a root node. This is done as the first subtree of an F processes arguments of the matched function symbol and this can only be done once (due to the matching function). Also, during matching of the arguments (of the subterm), the other trees that do not participate need to be ignored until f and its arguments are completely matched. For this reason we add the necessary N nodes to these trees.

There are several optimisations to the above. For example, between two N nodes, we can ensure that matching a variable occurs only once and we can combine all S nodes into one, as they all store the same term. In case both subtrees of an M or C node are the same, we can replace it with the subtree itself. Also, S nodes that bind a value to a variable that is never used in the subtree can be replaced by the subtree.

A specialised function for a function symbol f uses the match tree for f to see if any rule can be applied. If this is the case, the right-hand side of that rule is built and the generic rewrite function is called on this term. If no rule matches, then the original term is built and returned. An example of the code that would be generated of a function with rewrite rule f (c, x)= g(h(x), x) is as follows.

One important optimisation is that of avoiding needless traversal of normal forms. The main observation here is that one can assume that the arguments of a specific rewrite function are already in normal form. This is the case when called from the main rewrite function, as it first explicitly rewrites these arguments, and also needs to be the case when called from a specific rewrite function.

In our case we also have to consider applicative terms. This means that a function of arity n has at most n arguments (instead of exactly n). This is solved by generating specific rewrite functions for each function symbol and number of arguments allowed. So, for f we would have two additional rewrite functions (i.e. one for one argument and another for no arguments at all).

Because we do not want to burden our users with supplying strategies themselves, we need to generate reasonable strategies from a given set of rewrite rules (i.e. one strategy per function symbol). This is done by observing which arguments need to be rewritten to be able to match a given rule. An argument that is needed for matching by most of the rules is added to the strategy, indicating it needs to be rewritten first. In the case that all arguments of a rule that are essential for matching are rewritten, this rule is added to the strategy. This process continues until all rules and arguments are in the strategy.

This translation adds the annotated function symbols and annotated copies of the rewrite rules. It makes sure that the right-hand side of rules correctly uses the annotations based on the annotation of the head symbol of the left-hand side and which arguments will be rewritten before application. It also adds rules to remove the annotations.

For these latter rules the code generation has to be adapted such that these are only applied in case no other rule matches. This way we make sure that normal forms are always without annotations, which ensures that matching does not have to consider annotations at all. The function symbols with an annotation indicat- ing that none of the arguments are in normal form can be safely replaced by the unannotated version.

very expensive in our implementation. The memory extensive evaltree benchmarks, where JITty is about twelve times slower than our innermost rewriter, seems to support this. Also note that the evalsym benchmark, meant to test pure calculation speed, favors those that use a lazy implementation (ASF+SDF and the mCRL2 innermost rewriter are the only strict innermost rewriters).

Benchmarks are given to illustrate the improvement this JITty rewriter is over the innermost rewriters used for LTS generation. For closed term rewriting we have shown that our innermost rewriter can compete with the best rewriters currently available (ignoring the effects of lazy rewriting) and that JITty is a bit slower. The latter is likely due to the fact that in this implementation more intermediate terms have to be constructed, which is quite expensive.

The fact that the rewriters used for LTS generation can clearly compete with the fastest rewriters for functional languages seems to suggest that adapting the latter to support open term rewriting (which is essential for LTS generation) should not be a problem. That is, unless these functional languages support additional features with respect to the more basic languages used in process specifications that are fundamentally in conflict with efficient open term rewriting. In any case, such an adaptation would allow developers and users of tools centered around process behaviour and theorem proving (and most likely other fields as well) to have direct access to the functionality offered by the expertise of the functional programming community.

