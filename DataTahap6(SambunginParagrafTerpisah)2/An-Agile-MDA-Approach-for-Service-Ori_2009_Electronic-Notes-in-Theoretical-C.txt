Another important aspect of component models and frameworks refers to the development approach. Approaches in which modeling is at the core of the develop- ment activities also simplify the component construction process [1]. Well-known such approaches are based on UML and MDA.

UML 2 [21] established itself as the standard for modeling software systems. However, most commonly, UML models are used as blueprints that are fill in with code, and the current agile development processes (e.g. agile model-driven develop- ment, test-driven development) tend to minimize the modeling phase and the usage of UML models.

MDA framework [19] provides an approach for specifying systems independently of a particular platform and for transforming the system specification into one for a particular platform. MDA is considered the OMG approach to Model Driven Engineering (MDE). MDE approaches cand be based either on MDA, or on Domain Specific Modelling. MDE appeared as a solution to applications that have to deal with increased platform complexity and domain concepts. MDE aims to raise the level of abstraction in program specification and increase automation in program development [1,2]. The system can be developed based on models at different levels of abstractions, and then model transformations partially automate some steps of program development. But development processes based on MDA are not widely used today because they are viewed as heavy-weight processes - they cannot deliver (incrementally) partial implementations to be executed as soon as possible.

Composite components. UML 2.0 offers two ways of modeling subcompo- nents: subcomponents as parts and subcomponents as nested elements. The com- posites in iComponent use UML composite structures in order to indicate their internal structure. In this context, subcomponents modeled as parts are shared components which may be referenced by many composite components.

Service registries. The execution environment offers a global service registry in which component instances publish their provided interfaces. Other component instances may acquire references to these global services automatically through their wrapper containers. But, in order to isolate the component instances and services of an application, the instances of a composite are not published globally by default.

The services model, typically defined by the system analyst, describes the services that will be provided by the system. The modules that refer to services model may include any data type, such as classes, interfaces, or components. The interfaces contain the operations provided by the services.

The structural model, typically defined by the system architect, indicates com- ponent instances that will implement the services. At this stage, the system is decomposed into a set of components, simple or composite. Composite compo- nents help the architect to decompose the system functionality in an hierarchical way. Each composite component has attached a composite structure diagram, de- scribing its internal structure, using component parts (simple or composite) and connectors between ports, and specifying which components will be instantiated. The rules for the construction of the diagram are:

Add a test. Developers write the tests using either graphical or textual nota- tions. Both are compiled into the same UML repository model. During the activity construction process, the framework allows the use of inline expressions, represented and evaluated according to the pull model for actions.

