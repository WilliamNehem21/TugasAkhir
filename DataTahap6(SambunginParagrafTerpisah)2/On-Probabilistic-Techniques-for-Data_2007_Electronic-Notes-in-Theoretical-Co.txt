As shown in [10] any classical abstract interpretation can be seen as a prob- abilistic abstract interpretation by lifting the classical domains into probabilistic domains (Hilbert spaces). Another approach to the analysis of probabilistic pro- grams applies classical Abstract Interpretation techniques to probabilistic semantics [15]. This approach corresponds to a special case of classical abstract interpretation and it therefore results in safe, i.e. worst case analyses. As shown in [9], the more general PAI approach allows us to construct additionally statistical information which is more in the spirit of an average case analysis.

The first example of an analysis based on the LOS of pWhile concerns the parity of variables. Although, it is arguable whether this analysis by itself is of any practical use it is certainly a quite useful example in order to illustrate the basic methodology. The purpose of the Parity Analysis is to determine at every program point whether a variable is even or odd. It is a simple forward analysis where the concrete i.e. exactly in the same way as the concrete one. The difference is exhibited by only few of the operators (and the fact that the identities have a much reduced dimension). The control-flow steps are not changed at all as we are interested here only in a data-flow analysis. Each of the operators is constructed using the parity

It is rather straightforward to implement the finite approximations of the con- crete as well as the abstract semantics using a numerical program like octave [12]. As to be expected the size, even using sparse matrix representations, is prohibitively large; while for N = 5 things still work out it is effectively impossible to deal with case that N = 10. The abstract semantics creates no such problem.

A more interesting static program analysis is the classical Live Variable (LV) Analysis, see e.g. [16]. It is an example of a backward analysis, i.e. the control flow has to be reversed. In order to do this we use the transposes of the original control-transfer matrices.

The information we record about every variable is just if it is alive or not, i.e. we need to consider for every variable an abstract state in V({live, dead}). The update can be specified in a very similar way as in the case of the classical analysis (following e.g. [16]), where the local transfer function is usually defined by means i.e. when several (backward) control-flows come together as at a test in an if- or while-statement. To do this we need additional information about the branching probabilities. This could be obtained (i) experimentally from profiling or (ii) from the concrete semantics, by not abstracting at least those variables which determine

As with all probabilistic versions of classical analyses we could (re)construct the classical result from the probabilistic version by just recording the possibilities instead of probabilities. For this we only have to define a forgetful map from V(X) to P(X) which just considers the support of a probability distribution, i.e. those elements in X which are associated with a non-zero probability.

A formal estimation of the branching probabilities for if-statements (and similarly for while-loops) follows the following scheme: Perform a first phase analysis (e.g. a parity analysis) to determine the branching probabilities, then use these estimates to perform the actual analysis. This means in effect that we replace tests b with ways to construct abstractions of in particular control variables in order to obtain optimal estimates for these branching probabilities. Alternatively, for sub-optimal abstractions, we are also interested in determining the error margins of these esti- mates. Finally, we plan to extend this approach also to higher order, e.g. functional, languages and to implement a prototype of an automatic analyser.

