Abstract Many programming languages utilize annotations to add useful information to the pro- gram but they still result in more tokens to be compiled and hence slower compilation time. Any current distributed compiler breaks the program into scattered disjoint pieces to speed up the com- pilation. However, these pieces cooperate synchronously and depend highly on each other. This causes massive overhead since messages, symbols, or codes must be roamed throughout the net- work. This paper presents two promising compilers named annotation-based C# (Blue+) and dis- tributed annotation-based C# (DisBlue+). The proposed Blue+ annotation is based on axiomatic semantics to replace the if/loop constructs. As the developer tends to use many (complex) condi- tions and repeat them in the program, such annotations reduce the compilation scanning time and increases the whole code readability. Built on the top of Blue+, DisBlue+ presents its pro- posed distributed concept which is to divide each program class to its prototype and definition, as disjoint distributed pieces, such that each class definition is compiled with only its related com- piled prototypes (interfaces). Such concept reduces the amount of code transferred over the net- work, minimizes the dependencies among the disjoint pieces, and removes any possible synchronization between them. To test their efficiencies, Blue+ and DisBlue+ were verified with large-size codes against some existing compilers namely Javac, DJavac, and CDjava.

To undertake all above mentioned flaws, a C# compiler, named Blue [32], was first selected as the research baseline. Sec- ond, Blue+ was implemented to handle the proposed annota- tion. Third, DisBlue+ was built over Blue+ to achieve all above contributions. Finally, many applications were applied to validate the proposed ideas. To test Blue+ and DisBlue+ efficiencies, Java/Blue and DJavac/CDJavac compilers [21,23] were used, respectively.

The remainder of this paper is as follows. The main re- search contributions and goals are divulged in the following section. Section 3 covers some related works. Section 4 illus- trates by examples Blue+ aspects. Section 5 demonstrates by examples DisBlue+ features. Section 6 shows some implemen- tation issues for the two proposed compilers. In Section 7, experimental results are presented. To end the paper, conclu- sions are drawn in Section 8.

Axiomatic semantics, annotations, and compiled interfaces concepts are existing current programming issues (Section 3). However, this research novelty is how to utilize these notions to acquire the research goal. Besides code readability and reus- ability, the research goal is to overcome the overhead because of annotation tagging and/or the distributed compilation. The proposed utilization could be summarized as follows:

All program conditions could be replaced by axiomatic semantics as precompiled annotations. These annota- tions are created and compiled by the developer at devel- opment time before the compilation takes place. In addition, they are reusable and more readable than any current conditional (compound) statements. Hence, the total produced tokens are reduced and the updates of them are easier than ever.

Many distributed/parallel compilers have been constructed to reduce the compilation time. A parser may decompose the grammar into small disjoint parts and make each processor responsible for one part [8,16,17,25,26,28,29]. Partitioning the parse tree into sub-trees and distributing them on a set of processors is proposed in which each processor performs the semantic analysis and code generation, then, the result is finally gathered.

comes a leaf node in the matrix. Once a ready file is compiled, it will be removed from the matrix. This makes all files depend- ing only on it be leaf nodes and then are nominated to be the next selection. The process continues until all files are com- piled. The major DJavac drawback is the extensive use of file transfer. Additional overhead is added in transferring a class file(s). For example, if class A depends on class B and the scheduler decides to compile class A, so either A.java or class B is transferred since A cannot be compiled separately without the existence of B .java/.class file(s).

While designing Blue+ compiler, the three main decisions are taken. First, axiomatic semantics [2] is decided to be the anno- tations to replace the program conditions/loops. This is be- cause of its simplicity, readability, and declarative natures. Second, C# [33,35,36] is selected as a good OOP language. In comparison to Java and C++, Ref. [38] presented good reasons to nominate C# for this selection. Finally, as C# com- piler, Blue [32] is selected to be the research baseline. It is a managed compiler that follows all OOP compiler principles

Blue+ basic idea is to utilize the pre-parsing operations in its compilation phases. That is to parse some source code be- fore parsing time. Blue+ does pre-parsing to parse axiomatic semantics at development time. Then the generated tree is merged (injected)1 into the parse tree of non-axiomatic state- ments during the parsing phase. The pre-parsing is surely de- signed to reduce compilation time. Example 1 illustrates this idea by showing the Abstract Syntax Tree (AST) before and after using if-statement to enclose the expression. The if-state- ment sub-AST is marked by surrounded thick closed line.

Built on the top of Blue+, DisBlue+ inherits all its features (Section 4). Moreover, DisBlue+ has own distributed features that totally depend on compiled interface concept. The Dis- Blue+ idea is based on OOP features coupled with software engineering principles. With support of polymorphism and interface features, the application software engineer forms the application as a set of correlated interfaces in the applica- tion server. The compiled interface (CI) coupled with its com- piled relevant interface(s) is sent to one of the application client. In that client, the compiled interfaces are extracted to get their specifications via reverse engineering module and then the body of CI is written. These steps are rendered as follows:

In spite of the fact that the compiled interface is not a novel idea, the manner of its utilization in the above steps is a distrib- uted compiler novel idea and it reveals many potential points. First, the divided tasks could be asynchronously coded without any synchronous collaboration among the project developers. Second, no conflict or possible programming miscommunica- tions may be arisen because all interfaces and related bodies are well defined by the software engineer. Third, all tasks are automatically assembled which gives better software manage- ment activities than any today distributed compilers. Finally, since most DisBlue+ transferred files are compiled interfaces, the total transferred bytes of DisBlue+ application is small. That is in contrast to similar nowadays compilers which each of them makes its clients exchange the whole (compiled) class(s) among each other because of their dependencies.

However, the DisBlue+ software engineer should consider the removal of all application dependencies via interfaces. It is intended to build a new C#/C++ compiler having the above features such that they may affect all compilation phases espe- cially parsing and semantic phases. More types of annotations should be investigated to enhance such compiler.

