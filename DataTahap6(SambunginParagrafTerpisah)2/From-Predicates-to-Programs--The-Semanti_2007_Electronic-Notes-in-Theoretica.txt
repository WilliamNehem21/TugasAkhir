Each method is declared as a triple: a precondition that must be satisfied before the method can be called; a change list of attributes that may be updated; a postcondition that describes the intended effect. The first of these is a predicate upon attribute values and inputs. The last is a predicate upon inputs, outputs, and values before and after the operation.

To ensure the correctness of a generated implementation, we may add addi- tional constraints to the postcondition, asserting that the value of each expression lies properly within the range allowed. In the above example, we would add the constraint integer(a), asserting that the after value of a is an integer. These con- straints make no direct contribution to the program semantics or the generated code.

There are several options for the further development of the basic method language. We are exploring its use as an action language within UML class diagrams, as an alternative to the Object Constraint Language OCL [17]. We are considering the removal of the change list: in most situations (see below) the information this contains can be inferred from the postcondition. We wish to allow nested universal and existential quantifications in the postcondition.

The greatest potential for further development, however, is in the design of other aspects of the modelling language. Here, we are aiming to provide theoretical and practical support for a wider range of global invariants. We are also considering the use of state diagrams to describe intended workflow, and the automatic incorpora- tion of the information they contain, in the style of [15].

