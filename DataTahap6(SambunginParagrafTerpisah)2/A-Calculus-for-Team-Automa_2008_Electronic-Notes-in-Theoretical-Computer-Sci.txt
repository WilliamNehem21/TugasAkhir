Team automata are a formalism for the component-based specification of reactive, distributed systems. Their main feature is a flexible technique for specifying coordination patterns among systems, thus extending I/O automata. Furthermore, for some patterns the language recognized by a team automaton can be specified via those languages recognized by its components.

We introduce a process calculus tailored over team automata. Each automaton is described by a process, such that its associated (fragment of a) labeled transition system is bisimilar to the original automaton. The mapping is moreover denotational, since the operators defined on processes are in a bijective correspondence with a chosen family of coordination patterns and that correspondence is preserved by the mapping.

One of our results is thus the extension to team automata of some classical re- sults on I/O automata and their representation by process calculi. Another result concerns the compositionality of team automata. In [2,4] it was shown that certain team automata that are defined by a coordination pattern are compositional, in the sense that their languages can be obtained from the languages of their constituting automata. Besides proving that this characterization does not hold for all coordi- nation patterns devised so far (even in the presence of acyclic automata: See the already mentioned Proposition 2.8), we use our calculus to provide some preliminary results on how to nevertheless obtain the language of a team automaton defined by a coordination pattern directly from its components. Hence, a compositionality result does exist, even if the manipulation of the languages of the components does so that they induce a rewriting system, modulo the so-called AC (associativity and commutativity) axioms for the choice operator +. So, two finite processes are bisimilar if they have the same (modulo AC) normal form (i.e., a process obtained from the original one and such that no further rewrite can be performed from it).

In this paper we introduced a process calculus for team automata, extending some classical results on I/O automata. As a side-effect, we widened the family of team automata that guarantee a degree of compositionality by providing a way to obtain the language of a (finite) Rsi -team automaton from its components. While this language cannot be obtained through a direct manipulation of the languages of the component automata, the resulting degree of modularity favors the use of team automata in component-based system design.

Future work in this direction should lead to compositionality results also for other types of team automata. A first step in this direction could be to extend our calculus with parallel composition operators that mimic the various peer-to- peer and master-slave patterns of synchronization for team automata as introduced in [3], as well as mixtures of the synchronizations defined for team automata. As a matter of fact, [2,4] contain compositionality results not only for Rfree - and Rai - team automata, but also for team automata constructed according to a mixture of the free and ai synchronizations. It is important to recall, however, that the various peer-to-peer and master-slave patterns of synchronization make use of the distinction of the set of actions of team automata into input, output and internal actions. This means that in order to tackle the above issues, our calculus should first be extended to take this distinction into account.

Lastly, in order to be really useful in practical applications of team automata, it would be worthwhile to study the complexity of the algorithms introduced in this paper, e.g., what is the cost of checking the bimisimilarity between two automata, or of obtaining the language of a team automaton via its translation into a process.

