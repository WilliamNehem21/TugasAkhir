Graph transformation systems (GTSs) are recognised as a powerful specifica- tion formalism for concurrent and distributed systems [12], generalising Petri nets. Their truly concurrent behaviour has been deeply studied and a consol- idated theory of concurrency is now available. In particular, several seman- tics of Petri nets, like process and unfolding semantics, have been extended to GTSs (see, e.g., [8,26,1,2]). However, concerning automated verification, while several approaches exist for Petri nets, ranging from the calculus of in- variants [25] to model checking based on finite complete prefixes [23], the rich literature on GTSs does not contain many contributions to the static analysis of such systems (see [20,21,14]). Interestingly, several formalisms for concur- rency and mobility can be encoded as graph transformation systems, in a way that verification techniques for graph transformation systems potentially carry over such formalisms.

The proposed type system can be shown easily to be correct, but it is not complete. In fact, it is possible to show that the set of closed first-order formulae which are preserved (resp. reflected) by edge-bijective morphisms is undecidable. Therefore, a fortiori, not all L2-formulae which are preserved or reflected are captured by the above type system.

We have presented a logic for specifying graph properties, useful for the veri- fication of graph transformation systems. A type system allows us to identify formulae of this logic reflected by edge-bijective morphisms, which can there- fore be verified on the covering, i.e., on the finite Petri graph approximation of a GTS. Moreover, fixed an approximation of the original system, we can perform quantifier-elimination and encode these formulae into boolean com- bination of atomic predicates on multisets. Combined with the approximated unfolding algorithm of [5], this gives a method for the verification and analysis of graph transformation systems. This form of abstraction is different from the usual forms of abstract interpretation since it abstracts the structure of a system rather than its data. Maybe the closest relation is shape analysis, abstracting the data structures of a program [24,27].

