The approach that we propose is general and independent of the details of the particular formalism chosen for modeling the protocols (e.g. multiset rewriting, distributed temporal logic, strand spaces, process algebras, trace- based models, and so on) and of the details of the intruder model (which could be the standard Dolev-Yao model or the model of an intruder with different capabilities). Therefore, our results can be used to provide a formal footing for using Alice&Bob-notation in security protocol analysis tools even for protocols that explicitly rely on message forwarding and conditional abortion. Moreover, although we do not explore this possibility here, our work provides a good basis for generating protocol implementations from Alice&Bob-style descriptions that explicitly carry out necessary executability and abortion tests.

information to be stored. However, when receiving n1, b should hash it and abort the protocol execution if it does not coincide with the opaque submessage previously stored. In this case, he should not even execute the last sending action of the run. This kind of problem is standard for protocols involving commitments to values by principals.

It is quite straightforward to show that if one does not allow encryption using composed messages as keys, i.e. if one considers only atomic keys, then close(S) = synth(analyz(S)). Below, we will also identify another situa- tion where this is true. In general, however, synth(analyz(S)) close(S), that is, the inclusion is proper. For instance, if S contains just the mes-

The construction of the sets Di completely neglects the messages that x sends during his run. This is justified: x does not learn anything by sending a message, as reflected in Definition 3.3. However, it must be the case that x can build the messages that he sends using the data currently available to him. This assumption, which is often left implicit in protocol analysis approaches, can be formalized in the present setting.

Note that, by definition, atomic messages are always transparent. Hence, if S is a set of atomic messages then sub(S) = S does not contain opaque elements. Therefore, Proposition 3.10 implies that also sub(close(S)) does not contain opaque elements. Finally, Proposition 3.8 guarantees that close(S) is transparent.

Note that in this case only message forwarding may be necessary. The precise meaning of forwarding can also be clarified with the help of Proposi- tions 3.9, 3.10, and 3.13, as explained in the proof of Proposition 3.17: if a sent message contains an opaque submessage M then M must also occur, and be opaque, in some previously received message.

