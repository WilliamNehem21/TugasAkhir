Service integration is widely recognized to be one of the crucial problems in Component- Based Software Engineering [8]. Available component-oriented platforms address software interoperability at the signature level via Interface Description Languages (IDLs) that are designed for specifying the functionality offered by heterogeneous components. Unfortunately, while IDLs permit to overcome signature mismatches, they do not guarantee that the components will interoperate correctly, as undesired deadlocks may occur because of mismatches in the interaction behaviour of the components involved [12].

amount of research has been hence devoted to advocate the application of formal methods to describe the interactive behaviour of software systems in order to sup- port system analysis and verification in general, and behavioural mismatching de- tection in particular. Different formalisms have been proposed for extending IDLs with behavioural information, in particular finite state machines (e.g., [14]) and process calculi (e.g., [1]).

In this perspective, [7] puts forward the development of behavioural types, rig- orous typing disciplines aiming at synthesizing the essential aspects of the interac- tion behaviour of services, while retaining efficient automatic verification of crucial properties of composed systems, such as lock-freedom. Differently from contract languages, such as BPEL4WS and WSCI that are computationally complete, the expressive power of these type systems is below Turing-completeness. The devel- opment of behavioural types has been receiving increasing attention, as witnessed by the recently proposed session types [3], action types [16], usage types [5], and process types [4].

The objective of this paper is to provide an insightful synthesis of the current state-of-the-art in the development of behavioural types for service integration. In order to help the reader get an intuitive understanding of behavioural types, we first introduce a simple motivating example of service integration (Sect. 2) and illustrate how it can be modelled by means of finite state machines, process algebras, and behavioural types, respectively. We then analyse different proposals of behavioural types that have been put forward in the literature (Sect. 3). We then single out (Sect. 4) a list of relevant properties that we use to analyse and assess the above considered proposals. Finally, we will draw some conclusions (Sect. 5) and try to highlight some important challenges to be faced before behavioural types can have an effective impact in the software world.

too detailed, and too complex for analysis (and notice that same can be said of other computationally complete proposals of interface languages like BPEL4WS or WSCI). On the other hand, formalisms based on finite-automata are not enough expressive and tend to simplify too much protocol descriptions, as can be found also in more recent works. An approach that is somehow in the middle of process algebras and finite automaton is that of behavioural types, which have been proposed for typing concurrent systems (similarly as signature IDLs are used for typing objects or components).

Under this approach, a program is considered as a collection of sessions, each one being a chain of diadic interactions. Each session is designated by a private channel, through which interactions belonging to that session are performed. The use of diadic sessions for the specification of software interaction allows a modular specification of complex systems. The objective is to provide a basic means to describe complex interaction behaviour with clarity and discipline at a high-level of abstraction, together with a formal basis for analysis and verification.

The name of usage types comes from the fact that in this proposal channel types are augmented with tags that contain information about the order in which each channel is used for input or output. This information can be used to guarantee that a process will perform a particular action in a given number of reduction steps, once the action has become available. Hence, it can be determined how long will take a given communication action to succeed.

Expressiveness of the source protocol language. It is important to observe that different type systems may differ also with respect to the source language they refer to. In the case of behavioural types, different systems may differ in the source protocol languages they are aimed at modelling. Such differences obviously affect the applicability of the type system, cutting out protocols that cannot be expressed in the considered source protocol language(s).

Provable protocol properties.  Obviously, the set of protocol properties that can be proved by means of a type system is of primary importance to assess the usefulness of the type system itself. Such properties may range from simple connectivity issues (as ensured by available IDLs) to interoperability issues, such as safety or liveness properties. Intuitively speaking, the lower the abstraction of the type-inference mechanisms, the stronger the properties that can be proved on the types associated with protocols. A crucial aspect here is whether the verification of protocol properties can be automated, and which is the complexity of such verification. A further interesting aspect of a type system is whether (and how easily) it allows to state and verify new, user-defined properties.

In the previous sections we have tried to provide an insightful synthesis of the current state-of-the-art in the development of behavioural types for service integration. The various emerging proposals discussed in Section 3, beyond witnessing the increasing attention devoted to behavioural types, illustrate the application interest of the technical results that have already been achieved in the area. However, much still remains to be done in order to achieve a broad adoption of this technology in the world of software development.

Type-checking tools. As pointed out also in [7], the inclusion of behavioural in- formation in service contracts paves the way for the development of powerful mechanisms of service match-making. Namely, service look-up may go beyond simple connectivity issues, and take into account also the effective interoperability of services. Once service behaviour is expressed by means of behavioural types, interoperability can be checked by means of type-checking mechanisms. As for the case of type-inference, the availability of automatic type-checking tools will be a must to enable the development of behaviour-aware service look-up tools.

Behavioural conformance and security issues. An orthogonal, but crucial issue, is the so-called issue of behavioural conformance. Namely, how is it guaranteed that a service or client will effectively behave as per the behaviour declared in its exposed interface? While different solutions to this issue have been already proposed in different contexts, such as wrappers or proof-carrying code, solid and certified guarantees will be needed for a massive employment of this technology for industrial applications.

Other aspects. While behavioural information is necessary to ensure the correct interoperability of services, other aspects are of no less importance, such Service- Level Agreement (SLA) information. The integration of behavioural information with non-functional information will be a further need step to achieve high-quality service aggregations.

