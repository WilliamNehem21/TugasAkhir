In this paper we face the problem of specifying and verifying security protocols where temporal aspects explicitly appear in the description. For these kinds of protocols we have designed a spec- ification formalism, which consists of a state-transition graph for each participant of the protocol, with edges labelled by trigger/action clauses. The specification of a protocol is translated into a Timed Automaton on which standard techniques of model checking can be exploited (properties to be checked can be expressed in a linear/branching untimed/timed temporal logic). Along all the presentation we use, as running example, a two parties non-repudiation protocol for which we show how our framework applies in the verification of the fairness property for the protocol (establishing whether there is a step of the protocol in which one of the two participants can take any advantage over the other).

and analysis of cryptographic protocols, leading to a number of different ap- proaches and encouraging results (e.g. see [8]). However, most of the proposed techniques consider cryptographic protocols where concrete information about timing of events is not crucial (e.g. delay, timeout, timed disclosure or expi- ration of information do not determine the correctness of the protocol) and details on some low level timing aspects of the protocol are abstracted (e.g. timestamps, duration of channel delivery etc).

The idea of using Timed Automata for specifying real time systems and proving security properties is not new (e.g. see [3,6]). Our approach differs in that Timed Automata are not the specification language itself but the front- end of a new specification language specialized for security protocols. From this perspective, our work is closer to [5], where the specification language is a timed process algebra. The two approaches differ in the treatment of time (discrete versus continuous) and in the verification techniques.

To support our formalism, we provide an application to a very well-known non-repudiation protocol, see [9]. In this protocol Alice sends a message to Bob and at the end no one of them can claim not having sent or received the message. More precisely at the end of the protocol Bob has collected enough information to prove that Alice is the source of the message, and Alice has enough information as well to prove that Bob has indeed received her message. Thus no one can claim the false (not having sent that message and not having received it), as the other will provide evidences of the contrary. Based on this

The rest of the paper is organized as follows: in the next section we re- call the non-repudiation protocol of Zhou and Gollmann [9]. In section 3.1 we present the specification language along with the resulting MTAs for the example protocol and in section 4 we show the translation into Timed Au- tomata. Finally we conclude with the verification of the fairness property for the example protocol in section 5 and some conclusions in the last section.

ment of the receipt of the message. Fairness can be broken for two reasons: either the communication channel is faulty and a transmitted message is never delivered or a party does not play fair by not adhering to the protocol rules. We will assume that the channel is resilient, that is, it is never faulty and always delivers the message transmitted in a finite unknown amount of time. By paraphrasing [9], the main idea of the protocol is to split the message into two parts, a commitment and a key K, which is sent both to B and to the TTP . If a dispute occurs, both the parties have the ability to retrieve the key from the TTP . Let us first give some notation necessary to describe the protocol: M is the message sent from A to B, T is the timeout, K is the key

Evidences. If the protocol stops legally, then A and B get the non-repudiation evidences (EOR and EOR K for A, and EOO and EOO K for B). Otherwise, if something goes wrong, A starts the recovery phase and both get the evi- dences with the help of the TTP (EOO and con K for A, and EOR and con K, for B). Let us note that the parameter L is needed to specify a protocol run (it is chosen by Alice at the very beginning along with T ). For a more detailed presentation of the protocol the reader is referred to [9].

We start by defining the algebra allowing to express structured messages used in the communication among participants to a protocol section. The algebra has operations corresponding to the most widely used cryptografic primitives (e.g. encryption, decryption, hashing, signature etc.) and operations for as- sociating temporal constraints to messages (e.g. timed disclosure, expiration etc.).

The parameter T in the unification relation is the set of private keys which are supposed to be known when the messages are unified. For instance, a message {X}K can be unified with a message {m}K only if either K is a public key or K is a known private key. (Notice that this restriction prevents from disclosing an encrypted message by unification.) For the same reason, a message h(X) cannot be unified with a message h(m). The condition for the unification of a pair of messages ensures that two different actual values are

In this paper we have introduced a simple, graphical specification formalism to specify security protocols. There are two main advantages of this approach. First, the specification language is very close to the specification style of the protocol designer and allows the explicit representations of protocol parties and communication among parties. Moreover, a protocol specified with this formalism can be automatically translated into a Timed Automaton, in such a way that a security property, expressed by formulas in a temporal logic, can be checked using standard model checking techniques.

