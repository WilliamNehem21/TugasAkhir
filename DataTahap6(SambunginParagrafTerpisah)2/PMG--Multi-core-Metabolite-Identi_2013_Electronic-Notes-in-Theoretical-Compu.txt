Distributed computing has been considered for decades as a promising way of speeding up software execution, resulting in a valuable collection of safe and efficient concurrent algorithms. With the pervasion of multi-core processors, parallelization has moved to the center of attention with new challenges, especially regarding scalability to tens or even hundreds of parallel cores. In this paper, we present a scalable multi-core tool for the metabolomics community. This tool addresses the problem of metabolite identification which is currently a bottleneck in metabolomics pipeline.

In this paper, we describe the Java-based implementation of a multi-core Com- puter Assisted Structure Elucidation (CASE) tool, called Parallel Molecule Gener- ator (PMG), for automatic molecular structure generation. PMG is an evolution of the open-source CASE tool, called Open Molecule Generator (OMG) [8]. A pop- ular approach to implementing CASE tools is to view the molecular structure as a graph. The problem of structure elucidation can then be mapped to isomorph-free exhaustive graph generation [5, Section 4]. In Section 2, we explain the main idea behind the algorithms involved. In Section 3, we describe two parallel implemen- tations of PMG using contemporary concurrency tools from Java. These high-level concurrency tools both make programming less error-prone, and have efficient and optimized implementations. Based on experimental evidence, we then discuss their scalability and the resulting speedup in Section 4.

The contribution of the paper has two sides. To metabolomics, we provide a parallel, scalable, open-source CASE tool. The open-source nature of the tool allows for further optimizations and addition of many other relevant features. Our contribution to computer science is an evaluation and comparison of concurrency tools in Java. We have not seen similar studies before, particularly on the possible merits of the fork/join framework [7]. Additionally, PMG can be seen as a success story in developing scalable parallel programs for the multi-core era.

search tree in n parts (assuming n parallel cores). This approach has very low overhead and is used mainly on grids of multiple computers. It is, however, not optimal on a multi-core and in particular for this problem because the search tree is not balanced: some of the parts may be small, leaving the corresponding cores underutilized. Another approach is to break down the work into millions of small tasks, avoiding the risk of underutilization. However, if tasks are too small, the overhead of managing tasks outweighs the actual computation. In our case, the computation in each node is a proper task size.

At startup on a machine with n cores, PMGFS creates a basic thread pool executor service with n worker threads. Fixing the number of worker threads to the number of cores enables the utilization of all available cores while eliminating the overhead of dynamically adjusting the size of the thread pool. (Having more than n worker threads results in context switching overhead.)

The contribution of this work can be seen from two sides: Computer Science and Metabolomics. Firstly, we provide the metabolomics community a multi-core, scal- able, open-source metabolite identification tool. We explained the workings of the main algorithm involved and described two implementations using different concur- rency frameworks from Java. Such scalable tools are necessary in the multi-core era enabling faster execution of the programs by buying newer hardware, just as in the old times before processor speeds stopped increasing.

work outperforms older Java technology (as expected). As future work, we are mak- ing a library that hides the complexity of handling dynamically-sized tasks from the programmer, thus keeping the simplicity of fork/join programming. Nonetheless, if this approach is taken up in the default implementation of fork/join, one can benefit from under-the-hood optimizations.

Already in its early days, Java had basic support for thread-based concurrency. However, programming directly with threads is difficult. To ease this, Java 5 ex- tended this support with new higher-level concurrency utilities in the form of the java.util.concurrent package: classes and interfaces aimed at simplifying concurrent (multi-core) programming in Java. This library includes a framework for executor services, which add a form of asynchronous message passing to Java.

worker threads. As long as no one has submitted a task to the executor service, the worker threads in the thread pool are idle. As soon as a task becomes available, the executor service selects one of the idle worker threads for executing that task. Once the selected thread completes the task, it becomes idle again and available for executing the next task.

The number of submitted tasks can exceed the number of worker threads in the thread pool. To handle those situations, executor services have an internal task queue. Every submitted task first gets offered to the task queue. Worker threads in the thread pool obtain new tasks by polling the queue.

