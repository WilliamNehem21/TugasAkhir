

Electronic Notes in Theoretical Computer Science 229 (2009) 37–58
www.elsevier.com/locate/entcs

On Symbolic Semantics for Name-decorated Contexts1
Andrea Bracciali, Roberto Bruni, Alberto Lluch Lafuente2
Department of Computer Science, University of Pisa, Italy

Abstract
Under several regards, various of the recently proposed computational paradigms are open-ended, i.e. they may comprise components whose behaviour is not or cannot be fully specified. For instance, applications can be distributed across different administration domains that do not fully disclose their internal business processes to each other, or the dynamics of the system may allow reconfigurations and dynamic bindings whose specification is not available at design time. While a large set of mature design and analysis tech- niques for closed systems have been developed, their lifting to the open case is not always straightforward. Some existing approaches in the process calculi community are based on the need of proving properties for components that may hold in any, or significantly many, execution environments. Dually, frameworks describing the dynamics of systems with unspecified components have also been presented. In this paper we lay some preliminary ideas on how to extend a symbolic semantics model for open systems in order to deal with name-based calculi. Moreover, we also discuss how the use of a simple type system based on name-decoration for unknown components can improve the expressiveness of the framework. The ap- proach is illustrated on a simple, paradigmatic calculus of web crawlers, which can be understood as a term representation of a simple class of graphs.
Keywords: Open Systems, Abstract Semantics, Nominal Calculi, Type Systems.


Introduction
Concurrent and distributed systems are more and more becoming open environ- ments where components, agents or services interact one with another by dynami- cally establishing connections. For instance, in service oriented architectures, com- putational resources may be accessed through temporary interactive sessions. Such open-interaction environments, subject to the dynamical binding of their compo- nents, may result into systems being partially defined even at run-time. Describing and analysing the behaviour of such systems in presence of incomplete information

1 This work has been partly supported by the EU within the FETPI Global Computing, project IST-2005- 016004 SENSORIA (Software Engineering for Service-Oriented Overlay Computers) and by the Italian FIRB Project Tocai.it.
2 Email: {braccia,bruni,lafuente}@di.unipi.it

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.038

clearly appears more difficult than the analysis of closed interactive systems, already recognised as a challenging problem in its own.
Open computational environments have been first addressed in terms of execu- tion contexts, for instance in order to determine the (minimal) execution context where the computation of a component may exhibit some desired properties. In the semantical approach of [19], the possible transitions of a component are labelled with information characterising those contexts in which behavioural equivalence enjoys congruence properties (relevant to allow modular reasoning). Then, several other authors have proposed different symbolic semantics [15,16,17,18,14,5,11] so as not considering all the possible contexts, because universal quantification can seriously impair verification techniques. These semantics carry abstract represen- tations of the minimal contexts necessary for components to evolve. Here the term “symbolic” reminds the attempt of defining suitably abstract representations that can finitely represent universal classes of components and contexts. The issue of avoiding universal closure of contexts finds its dual formulation in avoiding universal closure with respect to pluggable components.
In [3], jointly with Paolo Baldan, a general methodology for analysing the be- haviour of open systems modelled as contexts C[X1, ..., Xn], i.e. open terms of suitable process calculi have been proposed. Variables of open terms represent holes where other contexts and components p, i.e. closed terms, can be dynamically plugged in. The operational semantics of contexts is given by means of a symbolic transition system (sts), where states are contexts and transitions are labelled by modal formulae characterising the structure that a component must possess or the actions it must be able to perform in order to enable a symbolic transition. Symbolic transitions are of the form:
ϕ1,..,ϕn
C[X1, ..., Xn]−−−−−−−→aD[Y1,... , Ym]
The corresponding closed system C[p1, ..., pn] can perform a transition labelled with a, whenever each component pi satisfies the corresponding formula ϕi. The target state will be a suitable instance of D[Y1,... , Ym], where process variables Y1,... , Ym appear in formulae ϕ1, .., ϕn. The logic where the formulae ϕi live and the notion of satisfaction are targeted to the process calculus under study. Starting from the rules defining a calculus, a constructive procedure based on unification distills a (sound and complete) standard sts.
Given an sts, several behavioural equivalences can be defined directly over con- texts, amongst which we mention strict and loose bisimilarities. The former is a straight extension of the ordinary bisimilarity with exact matching of transition labels, while the latter is obtained by relaxing the requirements when comparing formulas during the bisimulation game. In order to abstract from internal compu- tations, symbolic counterparts of weak bisimilarity have been defined. They are called strict and loose weak symbolic bisimilarity (denoted ≈s and ≈l, respectively). All these equivalences are correct approximations of their universal counterparts. Differently from other approaches the sts semantics preserves the openness of the system during its evolution, thus allowing dynamic instantiation to be accounted for in the semantics.

By integrating ideas from [1,3] and [8,6,7], we are interested in the development of a flexible semantic framework for open systems that admits a graphical counter- part. In this extended abstract we report on an ongoing development of the sts theory aimed at accounting for calculi with an explicit treatment of names, a` la π-calculus. Names broadly represent references of a possibly reconfigurable inter- connection network amongst components. Consequently, the extended theory may be adapted also to other representation formalisms, such as the hierarchical graphs considered in [6], where names can be used to account for the hierarchy.
In order to make the framework more flexible, drawing inspiration from [8], we introduce a type discipline for open systems which prescribes how processes, contexts and variables can be composed together. Types fix a basic interface, al- lowing or disallowing the use of certain names within the corresponding well-typed processes.
We present our type framework with the help of a web crawling scenario, mod- elled with a simple nominal calculi, where names stand for references to web pages and processes offer an abstract representation for web crawlers and pages. In this first exploration the use of names is limited (for instance we do not deal with restric- tion operators), but we believe it is still sufficient to illustrate the relevance of the proposed approach. We define crawlers with different policies and confront them with a non-fully specified network. By adopting a suitable symbolic equivalence we can test the different behaviours over a symbolic semantics. The needed extensions to the theory of sts are discussed. For the sake of readability and generality, the actors of our scenario are also illustrated as graphs, where processes and names play the role of edges and connections, and operational rules that of graph trans- formations. A further advantage of this graphical presentation is to make evident that interfaces can dynamically evolve, e.g. crawlers expose the web addresses they know and such knowledge is increased during their exploration activity.
We show how global properties of the network can be enforced by imposing type restrictions to unknown network components. Types constrain the pages that the unknown part of the network is enforced to contain and the list of links that the network can point to. In particular, we shall concentrate on valid networks, where no broken link is allowed. Such type restrictions have to be updated according to the symbolic transitions that make the overall system evolve. Consequently, standard subject reduction results have to be rethought in this dynamical open context. One of the benefits of considering type restrictions in our example is that, while crawlers can be distinguished in arbitrary networks, their behaviour is equivalent in networks of type valid.
Summarising, the main objective of this extended abstract is twofold: (i) to define typed extensions of the sts symbolic semantics for nominal calculi, and (ii) to use a type discipline for unknown components to derive suitable abstract equiva- lences. We remark that our types are inspired by graphical models of process calculi and that, for the first time, it is shown a significant abstract equivalence based on loose weak symbolic bisimilarity.
This paper is structured as follows. Section 2 overviews the basics of sts. Sec-

p ::= 0 | l. p | (a) p
(pref )		p →a  q	 (hide )	  p →l q	 (lift )	l /= a

l. p →l p
(a) p →r  (a) q
(a) p →l (a) q


Figure 1. Tick calculus.

tion 3 describes our simple web crawling scenario: a simple nominal calculus over which we apply the sts theory. Section 4 introduces name-decorated types in the sts approach. Section 5 draws some conclusions and outlines future developments.

Background
The main concepts about sts and associated symbolic behavioural equivalences are briefly recalled. A detailed presentation can be found in [3].
For mere illustration purposes, we introduce for this section a simple process calculus, called Tick. The processes of the Tick calculus are defined by the syn- tax and operational rules in Figure 1, where l ranges over a fixed set of labels Λ, τ ∈ Λ is a distinguished label and a ranges over Λ − {τ }. Tick processes con- sist of lists of actions which can be performed sequentially. The hiding operator
(a) allows to hide action a, which then shows up as silent action τ at the top level. For example, the Tick process (a) (b) c. a. 0 can perform a series of two steps:
(a) (b) c. a. 0 →c (a) (b) a. 0 →r (a) (b) 0. Note that to avoid confusion with the po- sitioning of labels in symbolic transitions, we put the action label on the lower-right of the arrow and not above it.

Processes, Contexts and Formulas
We distinguish between processes (ranged over by p, q, ...), i.e. closed terms of a process calculus, and contexts (ranged by C[X1, ..., Xn], D[X1, ..., Xn], ...), i.e. terms of the calculus that may contain variables. For the sake of readability, we consider only single-holed contexts C[X], where X is the variable occurring in the context. Processes are often considered up to some suitable structural congruence ≡ but in our example we will not.
An operational and abstract semantics of contexts, can be defined as a symbolic transition system, whose states are contexts and whose labels encode the structural and behavioural conditions that components should fulfil to enable the move, ac- cording to the following principles: (1) abstracting from components not playing an active role in the transition; (2) specifying the active components as less as pos- sible; and (3) making assumptions both on the structure and on the behaviour of the active components.
Labels consist of formulae of a suitable logic, φ, ψ, ... comprising both temporal and spatial modalities in the style of [9,10] and depend on the specific calculus considered. Each formula represents the set of processes that fulfil it. A possible temporal formula is ⬦a φ, satisfied by the processes that can fulfil φ after having

performed an a labelled transition (p |= ⬦aφ if ∃q. p →a q ∧ q |= φ). Spatial formulae are about the algebraic structure of a term, so that, for instance, p |= f (φ) if ∃q.p ≡ f (q) and q |= φ, where f is one of the operators of the calculus. Thus, each component p can also be regarded as a (purely spatial) formula.
To gain some insights regarding the choice of the logic, note that an instance C[p] of a given context C[X], in order to perform a transition, must match the left-hand side of the conclusion of a semantical rule. This might impose the component p to have a certain structure, hence the need of inserting the spatial operators f ∈ Σ in the logic, where Σ denotes the signature of the calculus under consideration. Furthermore, the premises of the matched rule must be satisfiable. Such premises may require component p to be able to exhibit some behaviour, i.e. to perform a certain transition. Hence the logic includes also temporal operators ⬦a expressing the capability of performing action a.
Labels must also be able to express no constraints over unspecified components of contexts, for instance when they do not take active part in the transition or in order to avoid unnecessarily tight constraints over components. This is achieved by including variables as formulas of the logic which are fulfilled by any process. For instance, the formula ⬦aX is satisfied by any process which is able to perform an action a, i.e. by any process p such that p →a q for some q. Variables in formulae will be used to identify the continuation, or residual, of a process after it has exhibited the capabilities and structure imposed by the formula. For instance, whenever p |= ⬦aX and thus p →a q, the variable X in the formula ⬦aX, identifies the continuation q. We say that p satisfies φ with residual q, written p |= φ; q, when p |= φ[q/X ], for X being the only process variable of φ. Symbol ; is also used for formulae composition such that φ; ψ is an alias for φ[ψ/X ].
Symbolic Transition Systems
An sts S is a set of symbolic transitions
φ
C[X]−→aD[Y ]
The variable names in contexts are not relevant, while the correspondence be- tween each variable X in the source and its residual Y in the target, as expressed by the formula φ in which the residual may occur, is relevant.
For S to provide an abstract view of a given process calculus we require some additional properties enforcing the correspondence with the ground transitions over
φ
components.  Intuitively, whenever C[X]−→aD[Y ], the context C, if instantiated
with any component satisfying φ, must be able to perform action a and become a suitable instance of D. More precisely, for any component q such that p |= φ; q, the component C[p] can perform a becoming D[q] (soundness). Analogously, any ground transition on components C[p] →a q should have a suitable symbolic counterpart with source C[X] (completeness).
A constructive procedure for determining a correct and complete sts has been defined (see [3]). It relies on unification for defining the constraints over unknown

components of a coordinator according to the structure of semantical rules. It can be straightforward implemented in Prolog for a large class of calculi. An overview of the construction will be given in Section 3.1.
Example 2.1 Let C[X] denote an arbitrary context in Tick. Then the sts con- sisting of the following (schema of) symbolic transitions is sound and complete:

У	оаУ 
(a1) ... (an) a. C[X]−−→r (a1) ... (an) C[Y ]	(a1) ... (an) X−−−−→r (a1) ... (an) Y
У	оlУ 
(a1) ... (an) l. C[X]−−→l(a1) ... (an) C[Y ]	(a1) ... (an) X−−−−→l(a1) ... (an) Y
where n ≥ 0, a ∈ {a1,... , an} and l /∈ {a1,... , an}. Intuitively, either the hole does nothing and the rest of the context is able to execute an action according to (hide) or (lift) (leftmost transitions), or the hole itself is able to perform an action (rightmost transitions).
For example, the contexts (a) (b) a. X and (a) (b) X have the transitions
У	оαУ	оlУ 
(a) (b) a. X−−→r (a) (b) Y  and  (a) (b) X−−−−→r (a) (b) Y  (a) (b) X−−−−→l(a) (b) Y
for l /∈ {a, b} and α ∈ {a, b}.
Strong Symbolic Bisimilarities
Given a process calculus, several observational equivalences can be defined on top of its operational semantics given in terms of a labelled transition system (lts). We focus on bisimilarity, by far the most popular equivalence due to its suitability to support modular reasoning and efficient model checking techniques. We start recalling ground bisimilarity.
Definition 2.2 [∼]A strong bisimulation is a symmetric relation ÷ over processes such that if p ÷ q, then for any transition p →а p' a component q' and a transition q →а q' exist such that p' ÷ q'. We denote by ∼ the largest bisimulation, called strong bisimilarity or just bisimilarity.
A natural way of lifting equivalences from ground processes to contexts consists of considering all possible closed instances of the contexts, so that C[X] ÷u D[X] if and only if ∀p, C[p] ÷ D[p]. However, universal quantification makes verification hard when not unfeasible. Moreover, such a bisimilarity works with a complete, although potentially infinite, specification of the system future behaviour, i.e. all its possible instantiations. This may not be appropriate when dealing with open systems. Informally speaking, the instant in which information becomes available seems to have a role in distinguishing the behaviour of different contexts.
Definition 2.3 [∼s] A symmetric relation ÷ over the set of contexts C is a strict symbolic bisimulation if for any two contexts C[X] and D[X] such that C[X]÷D[X], for any transition
φ	'
C[X]−→аC [Y ]
φ	'	'	'
there exists a transition D[X]−→аD [Y ] such that C [Y ] ÷ D [Y ]. The largest strict

symbolic bisimulation is an equivalence relation ∼s called strict symbolic bisimilar- ity.
For instance, referring to the calculus Tick, we can show that (a) (b) X ∼s
(b) (a) X, since the symbolic moves for the contexts (see Example 2.1) are of the kind
оαУ	оαУ 
(a) (b) X−−−−→l(a) (b) Y	(b) (a) X−−−−→l(b) (a) Y
where l = α if α /∈ {a, b} and l = τ , otherwise.
For a sound and complete sts we have ∼s ⇒ ∼u, but the converse does not hold in general. As mentioned, open processes that are equivalent under strict symbolic bisimilarity are ensured to be equivalent under universal closure but the vice-versa may not hold.
A non-trivial relaxation in the presence of spatial formulae regards the require- ment of exact matching between the formulae labels: a transition can be simulated by another transition with weaker spatial constraints on the residuals.
.
Definition 2.4 [∼l] A symmetric relation ÷ over the set of contexts C is a loose
symbolic bisimulation if for any pair of contexts C[X] and D[X] such that C[X] ÷
D[X], for any transition
φ	'
C[X]−→aC [Y ]
ψ	'	'	'
a transition D[X]−→aD [Z] and a spatial formula ψ  exists such that φ = ψ; ψ
and C'[Y ] ÷ D'[ψ'].  The greatest loose bisimulation .	is called loose symbolic

bisimilarity.
For sound and complete sts it holds ∼s ⇒


.
∼l ⇒ ∼u. We note that

.
∼l is

not guaranteed to be an equivalence relation, since it may fail to be transitive in some “pathological” situations (see the example in [2]). In such cases, its transitive

.
closure (∼l
)∗ should be considered as the relevant equivalence.

Weak Symbolic Bisimilarities
Many calculi, in particular those representing distributed systems, present silent actions (τ ) that model internal (non-observable) computations. In such cases, strong bisimilarity is too fine, and weak bisimilarity ≈, which abstracts away non- observable transitions during the simulation game, provides a more meaningful equivalence. We denote by ≈u its counterpart over contexts defined by universal closure, and we present a straight weak extension of symbolic bisimilarities.
φ	φ
The relations =⇒a and =⇒ represent in a single transition, called weak (sym-
bolic) transition, a sequence of symbolic transitions with at most one observable action or none, respectively. Formula φ, labelling the weak transitions, arises as
φ
the composition of the formulae labelling each single step. Then C[X] =⇒ D[Y ]
φ1	φ2	φh
if C[X]−−→r −−→r ··· −−→r D[Y ], with φ = φ1; ... ; φh and h ≥ 0.	Analogously,

φ	φ1
φk−1	φk
φk+1	φh

C[X] =⇒a D[Y ] stands for C[X]−−→r ··· −−−−→r −−→a−−−−→r ··· −−→r D[Y ]. In the
φ	φ	φ
following we let =⇒lˆ denote =⇒ if l = τ and =⇒l otherwise.

Definition 2.5 [≈s] A symmetric relation ÷ on contexts is a strict weak symbolic bisimulation if for all contexts C[X], D[X] with C[X] ÷ D[X] we have

if C[X]	'
φ	D'[Y ] and C'[Y ] ÷ D'[Y ].

−→lC [Y ] then D[X] =⇒lˆ
The largest strict weak symbolic bisimulation ≈s is an equivalence relation called
strict weak symbolic bisimilarity (it holds ∼s⇒≈s⇒≈u).
The contexts (a) a. X and (a) X of the Tick calculus are not strict bisimilar, but they are weak strict bisimilar. Roughly, this happens because the symbolic move
(a) a. X−−→r (a) X can be weakly simulated by (a) X by remaining idle.
Finally, a loose weak symbolic bisimilarity can be defined, abstracting on silent actions and releasing constraints over formula correspondence.
Definition 2.6 [≈l] A symmetric relation ÷ on contexts is a loose weak symbolic bisimulation if for all contexts C[X], D[X] with C[X] ÷ D[X]

if C[X]	'
ψ	D'[Z] and a spatial formula ψ' exists such that

−→lC [Y ] then D[X] =⇒lˆ
φ = ψ; ψ' and C'[Y ] ÷ D'[ψ'].
The largest loose weak symbolic bisimulation ≈l is called loose weak symbolic bisim- ilarity.

Scenario: Web Crawlers
Web crawlers (also known as bots, spiders or scutters) are programs that systemat- ically browse the web to gather (and even produce) data. Prominent examples in- clude useful applications such as those used to feed search engines (e.g. Googlebot), and spambots that collect email addresses or post forums with malicious purposes (e.g. spamming or phishing).
Crawlers start their search with a seed of pages and maintain a list of visited pages. Known pages are examined to extract their links and add them to the list of pages to visit (the crawling frontier ). Crawlers follow certain policies that regard page selection or if and how frequently pages are revisited. Such policies have an impact on the performance of a site and in particular on its performance: a non polite crawler with a high frequency of page request can overload the web server.
Some protocols exist that aim at harmonising the collaboration between crawlers and sites. For instance, robot exclusion and inclusion protocols (e.g. the de-facto standards robots.txt and sitemaps, respectively) are used by web sites to inform crawlers of links to be excluded and included in their spidering activity. Crawlers are free to respect or not such protocols but web servers can sometimes distinguish crawlers from human browsers (e.g. based on navigation speed or patterns) and thus control whether protocols are being respected or violated.
We consider a scenario in which crawlers adhere to different policies that depend on the level of trust in the information available from the net, viz. their propensity to check the validity of links. A scrupulous crawler checks the existence (e.g. requesting the page header only) of a page before deciding to examine it (i.e. downloading it

completely) and before communicating the page to its (possibly remote) database. A cautious crawler moves (i.e. changes target page) in a similar way, but does not check the page existence when communicating the url of a page to its database. A rash crawler checks nothing, i.e. it assumes the existence of pages that it communicates or tries to examine. All three kinds of crawler are able to examine an existing page. For the sake of simplicity we restrict to static networks: no page is added or removed during crawling activities.
Each kind of crawler has a different impact on a web server performance: a scrupulous crawler performs more page requests than the the cautious one, which, in his turn, performs more requests than the rash one.
We model such scenario with a simple name-based calculus where crawler agents c operate on a web of links link(x, y). We assume denumerable sets of channel names (ranged by a, b, ...) and of site addresses (ranged by x, y, z, w, ...) are available. The web system s may be empty or comprise crawlers, links and their composition:
s  ::= 0  |  c  |  link(x, y) |  s|s
Pages are seen just as collections of links with the same origin. If the collection is empty we say the page is missing, it is valid otherwise. If the target of a link is a missing page, then the link is called broken.
A crawler is an autonomous agent that can visit sites, learn new site addresses and communicate them to its database on a given channel. We distinguish three kinds of crawlers
c ::= rash(a, x, y˜) | cautious(a, x, y˜) | scrupulous(a, x, y˜)
where a is the channel for communicating site addresses, x is the current site address of the crawler and y˜ is the set of site addresses the crawler has already learnt (but not necessarily valid or visited). We let y˜ denote the set {y1, ..., yn} and write y˜+ x for the set {y1, ..., yn, x} and y˜ − yi for the set {y1, ..., yi−1, yi+1, ..., yn}.
The operational semantics is given by few (unconditional) rewrite rules, see Figures 2–4, assuming that parallel composition is associative, commutative and with identity 0. The rules are parametric w.r.t. a generic system s and w.r.t. suitable site addresses x, y˜, z, w and reference channel a for the crawler.
The rules are accompanied by a self-explanatory visual notation that is remi- niscent of a graphical interpretation of process calculi (see e.g. [13,12]): names are represented as nodes of type ◦ and • for channels and pages, respectively, crawlers and links as hyper-edges (rounded boxes) and their arguments (names used) are in- dicated by tentacles of various types. More precisely, the first argument of a crawler (e.g. the address of its database) is indicated by an upwards concave tentacle, the second one (the current site) by a bar-ended tentacle and the set of visited sites by arrowed tentacles. For links the arrowed tentacle indicates the target and the plain one represents the source. In our intuitive notation, items in the left- and right-hand side are identified by their position and we remark that a graph rewriting reading of the rules should be understood with matchings not being injective, i.e. two different rule nodes can be matched with the same actual node (e.g. learning of known pages is allowed).


c(a, x, y˜) | link(x, z) | s	→r	c(a, x, y˜ + z) | link(x, z) | s
(i)



, link ,
z• ,
→τ
z˛• ,,



(ii)
Figure 2. Textual (i) and graphical (ii) representation of Learn rules where c ∈ {rash, cautious, scrupulous}.


rash(a, x, y˜ + z) | s	→r	rash(a, z, y˜ + x) | s
c(a, x, y˜ + z) | link(z, w) | s	→r	c(a, z, y˜ + x) | link(z, w) | s
(i)



 •	→τ

,◦r

,  ,		→


˛r

...
r• 	
z• ,

(ii)



Figure 3.	Textual (i) and graphical (ii) representation of
c ∈ {cautious, scrupulous}.
Move rules where c' = rash and

Any crawler can learn new site addresses by looking at the links departing from its current site. The corresponding rules are identical for the three different kind of crawlers and abstract away the actual interaction that would take place in con- crete crawlers (rules Learn). The graphical representation makes evident that the interface of the crawler agent may be enlarged by the acquisition of a new site address.
Any crawler can move to new sites (rules Move). In particular, rash crawlers move eagerly around the web, to any target they have learnt; cautious and


c(a, x, y˜) | s	→az	c(a, x, y˜) | s	with z ∈ y˜ + x
scrupulous(a, x, y˜) | s	→ax	scrupulous(a, x, y˜) | s
(i)

a	a

→az







a	a

→ax


(ii)


Figure 4. Textual (i) and graphical (ii) representation of
c’=scrupulous.
Obs rules where c ∈ {rash, cautious} and

scrupulous crawlers move only to valid sites. The graphical representations show the two different policies used by the crawlers and make evident the swap of names in the interface of the crawler.
A second difference in the considered policies lies in the observations crawlers can make (rules Obs): rash and cautious communicate any site addresses they know; scrupulous crawlers communicate only site addresses they are currently examining.
Symbolic Transitions
A (sound and complete) symbolic transition system for our calculus is simply ob- tained by taking as symbolic transitions for each context C[X] all the transitions resulting from the possible (most general) unifications with the left hand sides of each rewrite rule, where s, x, y˜, z, w, a are seen as (fresh) variables. More precisely, if L[s] →α R[s] is a rewrite rule (for a suitable label α, possibly the silent one), and θ is a most general unifier between L[s] and C[X], then we have the transition
θ(X)
C[X]−−−−→αθ(R[s])
where θ(X) denotes the term substituted for X by the substitution θ (which with a slight abuse of notation can be directly interpreted as a spatial formula) and θ(R[s]) inductively applies the substitution θ to the variables in R[s] (recall that θ(L[s]) = θ(C[X])).
For instance, considering the context rash(a, x, y˜) | X and the Learn rule of



R[X]
R[X]
R[X]
R[X]
K[X]
K[X]
K[X]
K[X]
S[X]
S[X]
S[X]
link(x,z)|У
−−−−−−−−−→r  rash(a, x, y˜ + z) | link(x, z) | Y	(for any z)
−−→r	rash(a, yi, y˜ + x − yi) | Y
−−→ax	R[Y ]
−−→ayi	R[Y ]
link(x,z)|У
−−−−−−−−−→r  cautious(a, x, y˜ + z) | link(x, z) | Y	(for any z)
link(yi,z)|У
−−−−−−−−−→r  cautious(a, yi, y˜ + x − yi) | link(yi, z) | Y	(for any z)
−−→ax	K[Y ]
−−→ayi	K[Y ]
link(x,z)|У
−−−−−−−−−→r  scrupulous(a, x, y˜ + z) | link(x, z) | Y	(for any z)
link(yi,z)|У
−−−−−−−−−→r  scrupulous(a, yi, y˜ + x − yi) | link(yi, z) | Y	(for any z)
−−→ax	S[Y ]

Figure 5. Some examples of symbolic transitions.

Fig. 2, we obtain a unifier θ that unifies X with link(x, z)|s. The resulting symbolic transition is the topmost of Fig. 5.
Unification is considered up to associativity, commutativity and identity of par- allel composition (see [3]). We also require an exact matching for non-process vari- ables x, y˜, z, w, a appearing in the rules, i.e. θ must substitute them with actual values.
In the following we shall often focus on the three open processes R[X], K[X] and
S[X] defined below:
R[X] = rash(a, x, y˜) | X
K[X] = cautious(a, x, y˜) | X
S[X] = scrupulous(a, x, y˜) | X
Some of the symbolic transitions for R[X], K[X] and S[X] obtained with this technique can be found in Fig. 5. In particular, the first transition is obtained from rule Learn for rash contexts, the second one from rule Move, the next two from rule Obs, and so on. Other transitions, needed for determining a complete sts regard the presence of crawlers in holes and are not considered here for brevity.

Abstract Semantics
A natural question that emerges is: under which situation can the different crawlers exhibit essentially the same abstract behaviour? If we consider weak bisimilarities then it is evident that rash(a, x, y˜)|s and cautious(a, x, y˜)|s are equivalent for any

given system s. Indeed even if they follow different movement policies both commu- nicate all the addresses they gather (valid or not). Instead, it is possible to find suit- able networks that distinguish scrupulous crawlers from rash and cautious crawlers with the same knowledge. For instance, consider the processes rash(a, x, ∅)|link(x, y) and scrupulous(a, x, ∅)|link(x, y). The latter will be able to communicate only the valid site x, while the former can communicate also the missing site y. It follows from the considerations above that R[X] ≈u K[X], whilst R[X] /≈u S[X] /≈u K[X].
When we consider symbolic semantics, the situation is slightly different. In fact, it might be the case that certain silent moves for K[X] require the presence of some links as hypothesis, while this is not the case for R[X]. This is evident when comparing the two transitions relative to the Move rules for R[X] and K[X] (from Fig. 5):

R[X]
K[X]
−−→r	rash(a, yi, y˜ + x — yi) | Y
link(yi,z)|У
−−−−−−−−−→r cautious(a, yi, y˜ + x — yi) | link(yi, z) | Y	(for any z)

It follows that R[X] /≈s K[X] but this is not a desirable result, when considering that both contexts behave bisimilarly in terms of pages observed. Indeed, we know that R[X] and K[X] are equivalent under universal closure weak bisimilarity.
However, the situation changes when we consider the coarser equivalence ≈l, according to which the symbolic move of K[X] can be simulated by the less con- straining (more abstract) move of R[X]. But can K[X] loosely simulate R[X]? The answer is yes, because even if K[X] has no transition that can be used to simulate the silent step
R[X] −−→r rash(a, yi, y˜ + x — yi) | Y
still, K[X] can just stay idle. Thus while R[X] /≈s K[X] we have R[X] ≈l K[X]. In words, the loose bisimilarity approximates universal closure weak bisimilarity, better than strict bisimilarity.
The situation is slightly different when considering K[X] and S[X], because S[X] cannot observe yi without first moving to yi, thus requiring the site to be valid, while K[X] can observe it anyway. S[X] can only communicate yi as:

link(yi,z)|У
S[X] −−−−−−−−−→r scrupulous(a, yi, y˜ + x — yi) | link(yi, z) | Y
−−→ayi ...

Hence, we have that cautious and scrupulous are not equivalent under loose weak bisimilarity but neither they are under universal weak bisimilarity. Indeed, it can be shown that the behaviour of a cautious crawler subsumes that of a scrupulous crawler by showing that K[X] loosely simulates S[K[X]]. In words a context with a cautious crawler behaves like a context with both a cautious and a scrupulous crawler.

Typed Symbolic Transition Systems
In the previous section we saw that some crawlers can exhibit different behaviours depending on the network of pages they operate on. Now suppose that we are given some guarantees about the holes that appear in a context, like the fact that R[X],

K[X] and S[X] represent valid networks, in the sense that they contain valid site addresses only. Then, we would expect that R[X], K[X] and S[X] are all equivalent as they are all able to observe the same pages in the same order. Indeed, we would like to consider them to be equivalent under a variant of universal weak bisimilarity that takes into account the set of valid holes, rather than any possible system. Unfortunately, we saw in the previous section that our loose equivalence
≈l distinguishes cautious and rash from scrupulous in the general case.
In this section we propose a technique for stipulating some guarantees over the holes and for manipulating the symbolic transitions under such guarantees in order to account for an equivalence coarser than ≈l. We show the technique at work on our case study and then try to distill some general guidelines for making it applicable in general.
Typing
First, we define a suitable type system for terms. Here we consider a type system based on the page addresses with particular types for valid networks. Types take the form Td˜,p˜, where d˜ is the set of addresses that must correspond to valid sites,
i.e. defined within the system, and p˜ is the set of addresses that can be pointed by
the system without being necessarily valid within the system itself.
Definition 4.1 [Typed Systems] A system s has type Td˜,p˜, written s : Td˜,p˜, iff
for any x ∈ d˜ there exists y, s' such that s ≡ s'|link(x, y);

for any link link(x, y) in s such that y /∈
s'|link(y, z).
p˜ there exists z, s' such that s ≡

Let def (s) = { x|∃y, s' such that s ≡ link(x, y)|s' } denote the set of deﬁned pages of a system s, and ref (s)= { y|∃x, s' such that s ≡ link(x, y)|s' } denote the set of pointed pages of a system s. Then, in the definition above, d˜ ⊆ def (s) is
the set of pages that the typed system explicitly guarantees to exist, while p˜ ⊇ ref (s) — def (s) are the pages that the system is allowed to point even if they might not be defined within the system itself. Any pointed page y /∈ ref (s) that is not in p˜ must necessarily be provided by the system itself, i.e. it must be in def (s).
Summing up, a system s is allowed to point to pages in d˜, p˜ — d˜ (possibly outside
and even not in p˜, provided that they are in def (s). Note that d˜ and p˜ are not
necessarily disjoint, although, according to the definition, their intersection can be excluded from p˜, as stated by the following lemma.
Lemma 4.2 Given a system s such that s : Td˜,p˜, for some d˜ and p˜, then s : Td˜,p˜−d˜.
As underlined by the lemma, it is easy to see that a site can have different types. More importantly, any system can be typed, i.e. for any s there exist d˜ and p˜ such that s : Td˜,p˜ (e.g. T∅,ref (s)−def (s)). The following lemma expresses how the requirements imposed by a type can be relaxed: if a system fulfils a type then it also fulfils a type that requires less page definitions than the original one, or allows a larger set of pointed pages.

Lemma 4.3 If s : Td˜,p˜, then for any x, y it holds
s : Td˜−x,p˜, and
s : Td˜,p˜+y.
The above lemma induces a partial order over types, i.e. Td˜,p˜ ≤ Te˜,q˜ when d˜⊆ e˜ and q˜ ⊆ p˜. It is easy to see that the maximal type amongst those fulfilled by a system s is Tdef (s),ref (s)−def (s), i.e. the one that exposes all the defined pages and permits only the needed ones to be pointed outside the system. Such type represents
the most precise type we can assign to a system and it is called the characteristic type of s.
Example 4.4 Let s ≡ link(x, y)|link(x, z)|link(y, w). Then the characteristic type of s is T{x,y},{z,w}. By Lemma 4.3 we also know that s : T{x},{z,w,x} and s : T∅,{z,w,x,u}. On the contrary, it is not the case that s : T{y},{z}, because s points to w /∈ def (s) and w is not mentioned in the type. Similarly, it is not the case that s : T{x,y,w},{z,w}, because w is not a defined name of s.
Clearly, the presence of crawlers does not influence the typing of a system, which depends just on links. Moreover, as the rewrite rules cannot change the set of links in the system, it follows that the typing enjoys subject reduction.
Lemma 4.5 (Subject Reduction) If s : Td˜,p˜ and s →α s', then s' : Td˜,p˜.
Finally, a type-based characterisation of valid systems can be expressed by the fact that the system has a type requiring that all the pointed pages are defined in the system.
Definition 4.6 [Valid System] A system s is called valid if s : Td˜,p˜ and p˜ ⊆ d˜.
From Lemma 4.2 and Lemma 4.3, an alternative characterisation of valid systems as those s such that s : T∅,∅ easily follows. Quite naturally, compositional properties of types and systems can be determined, as for instance stated by the next lemma and its trivial corollary.
Lemma 4.7 Let s : Td˜,p˜ and s' : Td˜' ,p˜' be two typed systems, then s|s' : Td˜+d˜',p˜+p˜' .
It is immediate from from Lemma 4.2 to see that s|s' : Td˜+d˜' ,p˜+p˜'−(d˜+d˜') and from Lemma 4.3 that s|s' : T∅,p˜+p˜'−(d˜+d˜').
Corollary 4.8 Let s : Td˜,p˜ and s' : Tp˜,d˜ be two typed systems, then s|s' is valid.
More relevant for the application of our technique is the following theorem. It characterises the structure of a typed site with respect to the links and other typed components occurring in it.
Theorem 4.9 For any site s, site addresses d˜, p˜ and x ∈ d˜, the typing s : Td˜,p˜
holds iff
y ∈ p˜ and s' exist such that s ≡ link(x, y)|s' and s' : Td˜−x,p˜+x , or



Td˜,p˜
z• ,˛˛¸¸˛z•¸p˜˛,¸











...
t,

, s':T ˜	 ,
,¸	d−x,p˜+x ,,






  z• ,
t,


, link ,





...	•
t,
...
z• ,˛˛¸˛¸z•¸p˜i,=y
...
z• ,˛˛¸˛¸z•¸p˜|,p˜|

 t,	t,	t,	

t,	t,
• ˜	...	•d˜ =x
t,
...	•d˜
|d|


Figure 6. First item of theorem 4.9.
z /∈ p˜ and s' exist such that s ≡ link(x, z)|s' and s' : Td˜−x+z,p˜+x .
The theorem states that given a typing s : Td˜,p˜ we know that s can be decom- posed in two forms: (i) the site has a link from a guaranteed page x to a page y in p˜, hence the rest of the site does not need to guarantee x and is allowed to point
to x, or (ii) the site has a link from a guaranteed page x to page z not in p˜. By definition such page must necessarily be part of the site. Hence, the rest of the site has a type requiring to guarantee z. The converse implication follows from the type definition.
We observe that Theorem 4.9 establishes a logical equivalence between the type predicate  : Td˜,p˜ and the disjunction of spatial formulas with typed holes, namely:

   link(x, y)| : T ˜
y∈p˜
∨   link(x, z)| : T ˜
z/∈p˜

Figures 6 and 7 illustrate the two items of theorem 4.9. A site is denoted by enclosing it in a dotted box. Pages are replicated and connected with waved arrows and lines to emphasise the interface of a site (its type). The type of the site is written at the top left corner of the enclosing box. The remaining part of the site (i.e. s') is represented as an edge labelled with its name and type.
Decorated Variables
The second step towards our typed sts is the decoration of process variables with typing information, so to consider well-typed contexts only.
A decorated variable takes the form X : Td˜,p˜. It represents a hole that can be filled only with systems s of the corresponding type, i.e. such that s : Td˜,p˜.
Definition 4.10 [Typed Contexts] We say that C[X : Td˜,p˜] has type Te˜,q˜, written C[X : Td˜,p˜]: Te˜,q˜ iff for any s : Td˜,p˜ then C[s]: Te˜,q˜. A context C[X : Td˜,p˜] is called valid if C[X : Td˜,p˜]: Te˜,q˜ and q˜ ⊆ e˜.
Lemma 4.11 For any C[X : Td˜,p˜], there exist e˜ and q˜ such that C[X : Td˜,p˜]: Te˜,q˜.



Td˜,p˜
	z• ,˛˛¸˛¸z•¸p˜1,

, s':T ˜	 ,

...

,¸


, link ,
d+z−x,p˜+x ,,

•
˛,

z• ,˛˛¸˛¸z•¸p˜|,p˜|

...	• ˛r

...	•

t,	t,	t,
 t,	t,	t,	

t,	t,
• ˜	...	•d˜ =x
t,
...	•d˜
|d|


Figure 7. Second item of theorem 4.9.


T{x,y,u},{z,v}

x , 
t, 
t,
t,
t,

,	 ,
,¸	,,

,	 ,
z•z,˛z•¸, r 

t,•u
,¸ X:T{y,u},{x,v} ,,
•v ˛z•¸,

t, t,	
t, t,		

t, t,
t, t,
t, t,
t, t,
,	 ,
,¸	,,
y ˛r

	t, t,	
t, t,	t,
•	•	•

Figure 8. Untyped and typed contexts.

Note that any C[X] takes the form s|X for some s, so that Lemma 4.7 can be exploited to type C[X : Td˜,p˜] by combining the characteristic type of s and the typing information attached to X. Moreover the type of X can be restricted while preserving the type of its context as stated by the following lemma.
Lemma 4.12 For any z and y if C[X : Td˜,p˜]: Te˜,q˜ then:
C[X : Td˜,p˜−y]: Te˜,q˜, and
C[X : Td˜+z,p˜+z ]: Te˜,q˜.
Example 4.13 Figure 8 depicts a context C[X] ≡ link(x, z) | link(y, y) | X in un- typed form (left) and with a typing C[X : T{y,u},{x,v}]: T{x,y,u},{z,v} that constraints X to define pages y and u and allows X to point to x, v.
As far as the contexts R[X], K[X] and S[X] are concerned, we are interested in considering valid systems w.r.t. the names initially known by the crawlers, hence we can restrict to R[X : Ty˜+x,∅], K[X : Ty˜+x,∅] and S[X : Ty˜+x,∅], which are all of type Ty˜+x,∅, i.e. valid.

Typed Universal Equivalence
The third step is to refine the universal weak bisimilarity ≈u according to the type decoration of the variables: we say that C[X : Td˜,p˜] is universally weak bisimilar to D[X : Td˜,p˜], written C[X : Td˜,p˜] ≈u D[X : Td˜,p˜], if for any s : Td˜,p˜ we have C[s] ≈ D[s].

Lemma 4.14 For any type Td˜,p˜
and any contexts C[X] and D[X] such that

C[X] ≈u D[X] we have C[X : Td˜,p˜] ≈u D[X : Td˜,p˜].
Note that the overall types of C[X : Td˜,p˜] and D[X : Td˜,p˜] are not considered and might be even different. From the above lemma, it follows that R[X : Ty˜+x,∅] ≈u K[X : Ty˜+x,∅]. Moreover, from the notion of typed systems we can expect that K[X : Ty˜+x,∅] ≈u S[X : Ty˜+x,∅], but the proof of K[X : Ty˜+x,∅] ≈u S[X : Ty˜+x,∅] re- quires universal closure w.r.t. all systems s : Ty˜+x,∅.
Decorated Symbolic Transitions
The last and fourth step is to exploit symbolic equivalences to conclude that K[X : Ty˜+x,∅] ≈u S[X : Ty˜+x,∅], i.e. that all three crawlers are equivalent in valid networks that contain the initial knowledge of the crawlers. Unfortunately, we have already seen that K[X] /≈l S[X]. However, our idea is to exploit the logical equivalence exposed by Theorem 4.9 to give S[X] the possibility of simulating the unmatched transition (see Section 3.2)
K[X] −−→ayi K[Y ]
We notice that all symbolic transitions carry as formula just some spatial infor- mation. In general, given the kind of rewrite rules under consideration, such spatial labels can take one of the following forms (where c stands for the presence of a suitable crawler):
У	c | У
(a)	C[X] −−→α D[Y ]	(b)	C[X] −−−−→α D[Y ]
link(x,y) | У	c | link(x,y) | У
(c)	C[X] −−−−−−−−−−→α D[Y ]	(d)	C[X] −−−−−−−−−−−−→α D[Y ]
For the forms (a) and (b) (observations Y and c | Y , respectively) we just keep the decoration assigned in the source, resulting in the decorated transitions:
У	c | У
(a’)	C[X : Td˜,p˜] −−→α D[Y : Td˜,p˜]	(b’)	C[X : Td˜,p˜] −−−−→α D[Y : Td˜,p˜]
For the forms (c) and (d) (observations link(x, y) | Y and c | link(x, y) | Y ) we exploit Theorem 4.9 to derive a proper decoration for Y . We show what happens for link(x, y) | Y , but the other case is entirely analogous.
link(x,y) | У
(c1)	C[X : Td˜,p˜] −−−−−−−−−−→α D[Y : Td˜−x,p˜+x] if y ∈ p˜
link(x,y) | У
(c2)	C[X : Td˜,p˜] −−−−−−−−−−→α D[Y : Td˜−x+y,p˜+x] if y /∈ p˜
The decorated symbolic transitions for K[X : Ty˜+x,∅] are in Fig. 9, where z /∈ y˜ + x. Note that it is not important to decorate Y also in the labels, because they are matched exactly, and given that the decoration of X is known, that of Y follows unambiguously.



K[X : Ty˜+x,∅]
K[X : Ty˜+x,∅]
K[X : Ty˜+x,∅]
K[X : Ty˜+x,∅]
K[X : Ty˜+x,∅]
K[X : Ty˜+x,∅]
link(x,x)|У
−−−−−−−−−→r	cautious(a, x, y˜ + z) | link(x, z) | Y : Ty˜,x
link(x,yi)|У
−−−−−−−−−→r  cautious(a, x, y˜ + z) | link(x, yi) | Y : Ty˜,x
link(x,z)|У
−−−−−−−−−→r	cautious(a, x, y˜ + z) | link(x, z) | Y : Ty˜+z,x
link(yi,z)|У
−−−−−−−−−→r  cautious(a, yi, y˜ + x — yi) | link(yi, z) | Y : Ty˜+x−yi,x
link(yi,yj )|У
−−−−−−−−−−→r cautious(a, yi, y˜ + x — yi) | link(yi, yj) | Y : Ty˜+x−yi,x
link(yi,z)|У
−−−−−−−−−→r  cautious(a, yi, y˜ + x — yi) | link(yi, z) | Y : Ty˜+x−yi+z,x



K[X : Ty˜+x,∅]
K[X : Ty˜+x,∅]
−−→ax	K[Y : Ty˜+x,∅]
−−→ayi	K[Y : Ty˜+x,∅]


Figure 9. Some examples of decorated symbolic transitions (z /∈ y˜ + x).

We define a new notion of bisimilarity, called decorated loose weak bisimilarity
≈d.
Definition 4.15 [≈d.] Two contexts C[X : Td˜,p˜] and C'[X : Td˜,p˜] are decorated loose weak bisimilar if there is a symmetric relation ÷ s. t. whenever C[X : Td˜,p˜] ÷
'	φ
C [X : Td˜,p˜] we have that for each transition C[X : Td˜,p˜] −→α D[Y : Te˜,q˜] the following
holds:
φ	/=	Y	and  there  exists  a  (weak)  decorated  symbolic  transition

C'[X : T
ψ	D'[Z : T
] and a spatial formula ψ' such that φ = ψ; ψ'

d˜,p˜]
=⇒αˆ
f˜,r˜

and D[Y : Te˜,q˜] ÷ D'[ψ'],
φ = Y (and hence d˜= e˜, p˜ = q˜) and

either C'[X : T ˜
У⇒α D'[Y : T ˜
] and D[Y : T ˜
] ÷ D'[Y : T ˜ ],

d,p˜] =
d,p˜
d,p˜
d,p˜

or for any x ∈ d˜, y ∈ p˜ and z /∈ p˜ it holds that:

C'[X : T
link(x,y) | У
]
D'[Y : T
] with D[link(x, y) | Y : T	] ÷

d˜,p˜
=⇒	α
d˜−x,p˜+x
d˜−x,p˜

D'[Y : Td˜−x,p˜+x], and

C'[X : T
link(x,z) | У
]
D''[Y  : T
] with D[link(x, z) | Y  :

d˜,p˜
=⇒	α
d˜−x+z,p˜+x

Td˜−x+z,p˜+z ] ÷ D''[Y : Td˜−x+z,p˜+x]
where αˆ stands for label α if α /= τ and no label otherwise.
Note that we give the possibility of simulating the formula Y when the hole has type Td˜,p˜ by considering all the possible cases exposed by Theorem 4.9. That is, not only a step could be simulated by one with a more general label as it was possible
also in ≈l, but here a Y labelled step can be simulated by the collection of more specific steps performed by the instances compatible with the type of Y .
Let us now return to our goal of showing the equivalence of crawlers in valid networks. This result is obtained by showing that S[X : Ty˜+x,∅] ≈d K[X : Ty˜+x,∅].

Indeed, we now can show that the symbolic move
K[X : Ty˜+x,∅] −−→ayi K[Y : Ty˜+x,∅] can be simulated by the symbolic moves

S[X : Ty˜+x,∅
link(yi,z)|У
]	=⇒	ayi scrupulous(a, yi, y˜ + x — yi) | link(yi, z) | Y : Ty˜+x−yi,yi

for z ∈ y˜ + x, and

S[X : Ty˜+x,y˜+x
link(yi,z)|У
]	=⇒	ayi	scrupulous(a, yi, y˜ + x — yi) | link(yi, z) | Y  :

Ty˜+x−yi+z,yi for z /∈ y˜ + x.
In fact, we have also:
K[link(yi, z) | Y : Ty˜+x−yi,yi ] ≈d scrupulous(a, yi, y˜ + x — yi) | link(yi, z) | Y :
Ty˜+x−yi,yi , and
K[link(yi, z) | Y : Ty˜+x−yi+z,yi ] ≈d scrupulous(a, yi, y˜ + x — yi) | link(yi, z) | Y :
Ty˜+x−yi+z,yi for z /∈ y˜ + x.
In conclusion all three crawlers are equivalent in valid networks according to the decorated bisimilarity introduced in this paper and this is a nice result in the illustrating scenario because we know that in a valid network one can freely chose the desired policy with the guarantee of obtaining the same (observable) behaviour.


Scenario Implementation
For the convenience of the reader we have implemented our scenario and made it available at http://www.di.unipi.it/~lafuente/ice08. The web page proposes a simple game where players should find out the crawling policy according to obser- vations only. While deduction is possible in missing sites, in valid sites (as shown in this paper) it is all a matter of guessing and having luck on one’s side.
We remark that the site types Td˜,p˜ we use are related to typical inclusion and exclusion protocols. For instance, the sitemap index can be seen as d˜, i.e. the list of pages whose existence a site guarantees, while the robots.txt file would be pages in p˜ — d˜ that reside on the site, i.e. the list of pages that a site asks not to visit.
In our scenario the motivation under the site asking crawlers not to visit cer- tain pages is that they are not guaranteed to exist and not because they contain information the site would prefer not to be crawled, which is the typical intention of robots.txt.
Thus, in our implementation we call this file mightmiss.txt. The polite crawler offered there behaves like the scrupulous one, but exploits the information in that file to perform less page existence checks, thus lowering the server’s load.
We believe that one could apply our technique to establish new crawling pro- tocols or enrich existing ones. For instance, web sites can exhibit their type and, based on it and desired behaviour, crawlers can decide the most convenient policy.

Final remarks
We have performed a first step towards the treatment of names and types in sts, our approach to the specification and reasoning of open systems. Our work has been illustrated with a simple nominal calculus, inspired by a web crawling scenario. We have shown how the usual equivalence notion of sts is too fine grained, in the sense that it does distinguish between web crawlers one expects to be equivalent in some networks. We have thus defined a suitable (name-decorated) type system, that allows us, e.g. to constrain an unknown network to be valid, i.e. to not contain any broken link. Based on such types, a new variant of bisimilarity have been defined. According to this notion, all three considered crawlers are equivalent for valid networks.
The presented work should be understood as a first step towards the quite am- bitious goal of having more general equivalences, e.g. based on types defined by structural induction.
As future work we plan to generalise our technique to prominent nominal calculi (e.g. the π-calculus) and to deepen in the relationship with graph transformation approaches dealing with types and unspecified graph parts (e.g. [8]). More precisely, we would like to focus on service oriented calculi (e.g. [4]) where the notion of hole and type naturally resemble services and their specifications.

References
P. Baldan, A. Bracciali, and R. Bruni. Bisimulation by unification. In H. Kirchner and C. Ringeissen, editors, Proceedings of the 9th International Conference on Algebraic Methodology And Software Technology (AMAST ’02), volume 2422 of Lecture Notes in Computer Science, pages 254–270. Springer, 2002.
P. Baldan, A. Bracciali, and R. Bruni. Symbolic equivalences for open systems. In C. Priami and
P. Quaglia, editors, Proceedings of the International Workshop on Global Computing 2004 (GC 2004), volume 3267 of Lecture Notes in Computer Science, pages 1–17. Springer, 2005.
P. Baldan, A. Bracciali, and R. Bruni. A semantic framework for open processes. Theoretical Computer Science, 389(3):446–483, 2007.
M. Boreale, R. Bruni, R. D. Nicola, and M. Loreti. Sessions and pipelines for structured service programming. In 10th IFIP International Conference on Formal Methods for Open Object-based Distributed Systems (FMOODS’08), pages 19–38, 2008.
R. Bruni, F. Gadducci, U. Montanari, and P. Sobocinski. Deriving weak bisimulation congruences from reduction systems. In M. Abadi and L. de Alfaro, editors, Proceedings of the 16th International Conference on Concurrency Theory (CONCUR’05), volume 3653 of Lecture Notes in Computer Science, pages 293–307. Springer, 2005.
R. Bruni, A. Lluch Lafuente, and U. Montanari. Hierarchical Design Rewriting with Maude. In Proceedings of the 7th International Workshop on Rewriting Logic and its Applications (WRLA’08), Electronic Notes in Theoretical Computer Science. Elsevier, 2008.
R. Bruni, A. Lluch Lafuente, U. Montanari, and E. Tuosto. Service Oriented Architectural Design. In Proceedings of the 3rd International Symposium on Trustworthy Global Computing (TGC’07), volume 4912 of Lecture Notes in Computer Science, pages 186–203. Springer, 2007.
R. Bruni, A. Lluch Lafuente, U. Montanari, and E. Tuosto. Style Based Architectural Reconfigurations. In Bulletin of the European Association for Theoretical Computer Science, volume 94, pages 161–180. EATCS, February 2008.
L. Caires and L. Cardelli. A spatial logic for concurrency (part I). In N. Kobayashi and B. Pierce, editors, Proceedings of the 4th International Symposium on Theoretical Aspects of Computer Software (TACS’01),, volume 2215 of Lecture Notes in Computer Science, pages 1–37. Springer, 2001.


L. Cardelli and A. Gordon. Anytime, Anywhere: Modal Logics for Mobile Ambients. In Proceedings of 27th ACM Symposium on Principles of Programming Languages (POPL’00), pages 365–377. ACM, 2000.
H. Ehrig and B. K¨onig. Deriving bisimulation congruences in the dpo approach to graph rewriting with borrowed contexts. Mathematical Structures in Computer Science, 16(6):1133–1163, 2006.
G. Ferrari, D. Hirsch, I. Lanese, U. Montanari, and E. Tuosto. Synchronised hyperedge replacement as a model for service oriented computing. In F. S. de Boer, M. M. Bonsangue, S. Graf, and W. P. de Roever, editors, 4th International Symposium on Formal Methods for Components and Objects (FMCO’05), volume 4111 of Lecture Notes in Computer Science, pages 22–43. Springer, 2005.
F. Gadducci. Graph rewriting for the π-calculus. Mathematical Structures in Computer Science, 17(3):407–437, 2007.
B. Klin, V. Sassone, and P. Sobocinski. Labels from reductions: towards a general theory. In J. Fiadeiro and J. Rutten, editors, Proceedings of the 1st Conference on Algebra and Coalgebra in Computer Science (CALCO’05), volume 3629 of Lecture Notes in Computer Science, pages 30–50, 2005.
J. Leifer and R. Milner. Deriving bisimulation congruences for reactive systems. In C. Palamidessi, editor, Proceedings of the 11th International Conference on Concurrency Theory (CONCUR’00), volume 1877 of Lecture Notes in Computer Science, pages 243–258. Springer, 2000.
V. Sassone and P. Sobocinski. Deriving bisimulation congruences using 2-categories. Nordic Journal of Computing, 10(2):163–183, 2003.
V. Sassone and P. Sobocinski. Locating reaction with 2-categories. Theoretical Computer Science, 333(1-2):297–327, 2005.
V. Sassone and P. Sobocinski. Reactive systems over cospans. In Proceedings of 20th IEEE Symposium on Logic in Computer Science (LICS’05), pages 311–320. IEEE, 2005.
P. Sewell. From rewrite rules to bisimulation congruences. In D. Sangiorgi and R. de Simone, editors, Proceedings of the 9th International Conference on Concurrency Theory (CONCUR’98), volume 1466 of Lecture Notes in Computer Science, pages 269–284. Springer, 1998.
