Electronic Notes in Theoretical Computer Science 44 No. 1 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 24 pages


A Calculus of Terms for Coalgebras of Polynomial Functors

Robert Goldblatt 1
Centre for Logic, Language and Computation School of Mathematical and Computing Sciences Victoria University of Wellington, New Zealand
Rob.Goldblatt@vuw.ac.nz	http://www.mcs.vuw.ac.nz/~rob


Abstract
A syntax and semantics of types, terms and formulas for coalgebras of polyno- mial functors is developed, extending earlier work [4] on monomial coalgebras to include functors constructed using coproducts. A modified ultrapower construction for polynomial coalgebras is introduced, adapting the conventional ultrapower to retain only those states that evaluate observable terms in a standard way.
A special role is played by terms that take observable values and are “rigid”: their free variables do not occur in any state-valued subterm. The following “co-Birkhoff” theorem is proved: a class of polynomial coalgebras is definable by Boolean combi- nations of equations between rigid terms iff the class is closed under disjoint unions, images of bisimulations, and observable ultrapowers.


Introduction
A coalgebra of a functor T : Set → Set is a pair (A, α) with α a function of the form A → T A. This notion has proven useful in modelling transition systems, such as automata, as well as classes in object-oriented programming languages [14,7,16,17]. α is viewed as a transition structure on a state set A. Relational models of propositional modal logic can be viewed as coalgebras
[16] and this has lead to a number of proposals of languages with modalities for describing coalgebras [12,11,15,10]. An alternative method used here is to develop a syntax of equations between terms for coalgebraic operations that is similar to the standard equational logic of algebras, but subject to the principle that a coalgebraic term should have a single state-valued variable or parameter.

1 Paul Taylor’s diagrams package was used in preparing this document.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


In a previous article [4] the author developed such a calculus of terms and equations for coalgebras of certain monomial functors. These are constructed from constant functors and the identity functor by forming products and ex- ponential functors with constant exponent (which we will call power functors). It was shown that Boolean combinations of equations between terms of “ob- servable” type form a suitable language of formulas for specifying properties of coalgebras and characterising bisimulation relations between them. A struc- tural description was given of classes of coalgebras definable by such formulas, using the notion of the ultraﬁlter enlargement of a monomial coalgebra.
Now many of the more significant examples in the above references involve also coproducts in their construction, and so are coalgebras for polynomial functors. The aim of this article is to explain how the theory of [4] can be extended to the case of polynomial functors. The presence of coproducts introduces considerable complexity, associated with the partiality of certain “path functions” that express the dynamics of the transition structure α.
The approach taken here is to use type theory [8] to describe the construc- tion of sets-as-types from some base types by forming products, powers and coproducts, and to provide rules of syntax for terms that take values in these types. Among the base types is the type St of states: this symbol St denotes the state set of a given coalgebra. The symbol s is reserved as the special state-valued parameter that appears in terms, and may be thought of as de- noting the “current” state. The symbol tr denotes the transition structure, so that we are able to form the term tr(s), or more generally tr(M ) for any state-valued term M . But the situation is far more subtle than previously, because we now allow state variables distinct from s in coalgebraic specifi- cations, provided that they are not free. In the syntax of [4] all variables of a term are free, but here we have variable-binding operations on terms (lambda-abstraction, case-formation). A given term M may contain free state variables. More generally it may have a number of free variables of various types that occur in state-valued subterms, and hence provide a number of ways of referring to states by varying the values of those variables. M is rigid if this does not hold, i.e. if any variable occurring in a state-valued subterm is bound in M itself (an example will be given shortly). Rigidity is imposed on M by requiring that the type of any free variable of M does not involve St. Our main result (Theorem 7.1) is about the specification of coalgebras by combinations of equations between rigid terms.
Following established practice in categorical logic, the “case” operation is used to introduce terms associated with coproducts. The coproduct A1 +A2 of sets A1, A2 is their disjoint union, and comes equipped with injective insertion functions ιj : Aj → A1 + A2 for j = 1, 2. Each element of A1 + A2 is equal to
ιj(a) for a unique j and a unique a ∈ Aj. Our syntax generates terms of the form
case N of [ι1v1 '→ M1 | ι2v2 '→ M2],
where N is a term taking values in A1 + A2, M1 and M2 take values in some


other set B, and the vj’s are variables that take values in Aj and are bound in the overall case term. The latter is evaluated by first obtaining the value d of N in A1 + A2 and then, if d is equal to ιj(a), evaluating Mj with vj assigned value a. Another notation for this term [8, Section 2.3] is
unpack N as [ι1v1 in M1 , ι2v2 in M2].
Example. To illustrate the use of rigid terms and case-formation in coalge- braic specification, here is an example adapted from [9, Section 4]. Let A be a set of (possibly infinite) binary trees. Each tree x either is a single node with no children, or has exactly two children obtained by deleting the top node of
x. This gives an operation
children : A −→ 1+ (A × A),
where 1 = {∗}; children(x) = ι1∗ when x has no children, and children(x) = ι2(x1, x2) when x1 and x2 are the left and right children of x. There is a size (number of nodes) operation
size : A −→ 1+ N,
where N is the set of positive integers and size(x) = ι1∗ when x is infinite. The two operations can be “tupled” into a single function
A	α✲ (1 + (A × A)) × (1 + N)
which is a coalgebra for the functor T (X) = (1 + (X × X)) × (1 + N). The operations can be recovered from α as children = π1 ◦ α and size = π2 ◦ α, where π1 and π2 are the left and right projections.
Now the size of a tree is 1 if it has no children, is infinite if at least one child is infinite, and otherwise is the sum of the sizes of the children plus 1. Thus our example validates the equation of Figure 1, in which the right-hand term M is obtained by iteration of case-formation. Validity means that the equation is satisfied no matter what member of A is denoted by the state parameter
s. The variable v takes values in A × A, so π1v and π2v take values in A. Although v is free in these subterms, and indeed in the subterms beginning case size(πjv)..., v is bound in M itself. M is rigid.
A significant departure from [4] is to replace the notion of ultrafilter en- largement by a modified ultrapower. There is an obstacle to using the con- ventional ultrapower construction in that it produces states that assign “non- standard” values to terms of observable type. Our modification is to retain only those states that are observable in the sense that they assign only stan- dard observable values (see Section 6). One advantage of ultrapowers over ultrafilter enlargements is that lifting the operations of a coalgebra to an ul- trapower is a more familiar exercise, and is less cumbersome in that it works



Fig. 1. case terms
with elements rather than collections of sets. Also the proof that ultrapowers preserve satisfaction of observable formulas is more accessible, and follows the pattern of LB o´s’s Theorem for regular ultrapowers. On the other hand there is considerable intricacy in defining the transition structure of an observable ultrapower. This is carried out with the help of the notion from [10] of a path from a functor to one of its component functors.

This article is in the nature of a research announcement, giving a survey of all the relevant concepts and explaining the results, but leaving out the more technical proofs, which would take up much more space than is available here (these proofs will appear elsewhere). To summarize, the main features of the work are:
The formulation of syntax and semantics of types and terms for coalgebras of any polynomial functor (Sections 3 and 4).
The definition of observable formulas as Boolean combinations of equations between terms of observable type, and their use in logically characterising bisimilarity of states: two states are bisimilar when they assign the same values to all ground observable terms, or equivalently when they satisfy the same rigid observable formulas (Theorem 5.8).
The construction of observable ultrapowers of polynomial coalgebras and derivation of a version of LB o´s’s Theorem (Section 6).
A proof that a class of polynomial coalgebras is definable by a set of ob- servable formulas if, and only if, it is closed under disjoint unions, images of bisimulations, and observable ultrapowers (Theorem 7.1).
This last result may be viewed as an analogue for polynomial coalgebras of


Birkhoff’s famous characterisation of varieties of classical algebras. For dis- cussion of the nature of such “co-Birkhoff” theorems and references to other proposals for them, see the Introduction to [4].

Polynomial Functors
Standard notation for products, powers and coproducts of sets will be used. The coproduct A1 + A2 and associated insertions ιj : Aj → A1 + A2 have already been described. πj : A1 ×A2 → Aj is the projection function from the product set A1 × A2 onto Aj. The D-th power of set A is the set AD of all functions from set D to A. For each d ∈ D there is the evaluation function evd : AD → A having evd(f ) = f (d). The identity function on a set A is denoted idA : A → A.
The symbol ◦ ✲ will be used for partial functions. Thus f : A ◦ ✲ B means that f is a function with codomain B and domain Dom f ⊆ A. We may write f (x)↓ to mean that f (x) is defined, i.e. x ∈ Dom f . Associated with each insertion ιj : Aj → A1 + A2 is its partial inverse, the extraction function εj : A1 + A2 ◦  ✲ Aj having εj(y) = x iff ιj(x) = y. Thus y ∈ Dom εj iff y ∈ ιjAj, i.e. y = ιj(x) for some x ∈ Aj. Extraction functions play a vital role in the analysis of coalgebras built out of coproducts, as will be seen below.
Consider the following constructions of endofunctors T : Set → Set.
For a fixed set D /= ∅, the constant functor D¯ has D¯ (A) = D on sets A and
D¯ (f ) = idD on functions f .
The identity functor Id has IdA = A and Idf = f .
The product T1 × T2 of two functors has T1 × T2(A) = T1A × T2A, and, for a function f : A → B, has T1 × T2(f ) being the function
T1(f ) × T2(f ) : T1A × T2A → T1B × T2B
that acts by (a1, a2) '→ (T1(f )(a1), T2(f )(a2)).
The coproduct T1 + T2 of two functors has T1 + T2(A) = T1A + T2A, and for f : A → B, has T1 + T2(f ) being the function
T1(f )+ T2(f ) : T1A + T2A → T1B + T2B
that acts by ιj(a) '→ ιj(Tj(f )(a)).
The D-th power functor TD of a functor T has TDA = (T A)D, and TD(f ) : (T A)D → (TB)D being the function g '→ T (f ) ◦ g.
A functor T is polynomial if it is constructed from constant functors and Id by finitely many applications of products, coproducts and powers. Note that any polynomial functor constructed without the use of Id is constant.

A T -coalgebra is a pair (A, α) comprising a set A and a function A
−→α

T A. A is the set of states and α is the transition structure of the coalgebra.


Note that A is determined as the domain Dom α of α, so we can identify the coalgebra with its transition structure, i.e. a T -coalgebra is any function of the form α : Dom α → T (Dom α). A morphism from T -coalgebra α to T - coalgebra β is a function f : Dom α → Dom β between their state sets which commutes with their transition structures in the sense that β ◦ f = Tf ◦ α,
i.e. the following diagram commutes:
Dom α	f ✲ Dom β

α	β
❄	T f✲	❄
T (Dom α)	T (Dom β)
If Dom α ⊆ Dom β, then α is a subcoalgebra of β iff the inclusion function Dom α ‹→ Dom β is a morphism from α to β.
Every set {αi : i ∈ I} of T -coalgebras has a disjoint union  I αi, which is a T -coalgebra whose domain is the disjoint union of the Dom αi’s and whose transition structure acts as αj on the summand ιjDom αj of Dom   I αi. More
precisely, this transition is given by ιj(a) '→ T (ιj)(αj(a)), with the insertion
ιj : Dom αj → Dom I αi being an injective morphism making αj isomorphic to a subcoalgebra of the disjoint union (see [17, Section 4]).

Syntax of Types, Terms and Formulas
Types
Fix a set O of symbols called observable types, and a collection {[[ o ]] : o ∈ O} of sets indexed by O. Members of [ o ]] are observable elements, or constants, of type o.
Example: O = {num, bool, 1, 0}, with [num]] = {0, 1,.. .},
[[bool]] = {true, false}, [[1]] = {0}, [[0]] = ∅.
The set of types over O, or O-types, is the smallest set T such that O ⊆ T,
St ∈ T and
if σ1, σ2 ∈ T then σ1 × σ2, σ1 + σ2 ∈ T;
if σ ∈ T and o ∈ O, then o ⇒ σ ∈ T.
A subtype of an O-type τ is any type that occurs in the formation of τ .
St is a type symbol that will denote the state set of a given coalgebra. A type is rigid if it does not have St as a subtype. The set of rigid types is thus the smallest set that includes O and satisfies (1) and (2).
The symbol “o” will always be reserved for members of O. o ⇒ σ is a power type: such types will always have an observable exponent.


Given any set A, we associate a set [ σ ]]A with each O-type by putting [[ o ]]A = [[ o ]], [[ St ]]A = A, and inductively

[[ σ1 × σ2 ]]A = [[ σ1 ]]A × [[ σ2 ]]A
[[ σ1 + σ2 ]]A = [[ σ1 ]]A + [[ σ2 ]]A
[[ o ⇒ σ ]]A = [[ σ ]]A[[ o ]].

If σ is a rigid type, then [ σ ]]A is a fixed set whose definition does not depend on A, so it may be written [[ σ ]].

Terms
To define terms we fix a denumerable set Var of variables and define a context
to be a finite (possible empty) list

Γ = (v1 : σ1,..., vn : σn)

of assignments of O-types σi to variables vi, with the proviso that v1,..., vn are all distinct. Γ is a rigid context if all of the σi’s are rigid types. Concatenation of lists Γ and Γ' with disjoint sets of variables is written Γ, Γ'. A term-in- context is an expression of the form

Γ ✄ M : σ,

which signifies that M is a “raw” term of type σ in context Γ. This may be abbreviated to Γ ✄ M if the type of the term is understood.
Figure 2 gives axioms that legislate terms into existence, and rules for generating new terms from given ones. The rules for products, coproducts and powers are the standard ones for introduction and elimination of terms of those types. Axiom (Con) states that an observable element is a constant term of its type, while the raw term s in axiom (St) is a special parameter which will be interpreted as the “current” state in a coalgebra.
Bindings of variables in raw terms occur in lambda-abstractions and case terms: the v in the consequent of rule (Abs) and the vj’s in the consequent of (Case) are bound in those terms. It is readily shown that in any term Γ ✄ ϕ, all free variables of M appear in the list Γ. A ground term is one of the form
∅ ✄ M : σ, which may be abbreviated to the raw term M . Thus a ground term has no free variables. Note that a ground term may contain the state parameter s, which behaves as a variable taking values in Dom α.
A term is defined to be rigid if its context is rigid. This entails that every free variable of M is assigned a rigid type in Γ, and prevents any free variable of M from occurring in a subterm of type St. Of course all ground terms are rigid.









































Fig. 2. Axioms and Rules for Generating Terms


τ-Terms
For a given O-type τ , a τ-term is any term that can be generated by the axioms and rules of Figure 2 together with the additional rule


(Tr)
Γ ✄ M : St
Γ ✄ tr(M ) : τ .




















Fig. 3. Formation Rules for Formulas
Note that from this rule and the axiom (St) we can derive the τ -term
∅ ✄ tr(s) : τ.
The symbol tr will denote the transition structure of coalgebras of the form A α✲ [[ τ ]] . If M is interpreted as the state x of α, then tr(M ) is interpreted as α(x).

τ-Formulas
An equation-in-context has the form Γ ✄ M1 ≈ M2 where Γ ✄ M1 and Γ ✄ M2 are terms of the same type. A formula-in-context has the form Γ ✄ ϕ, with the expression ϕ being constructed from equations M1 ≈ M2 by propositional connectives. Formation rules for formulas are given in Figure 3, using the connectives ¬ and ∧. The other standard connectives ∨, →, and ↔ can be introduced as definitional abbreviations in the usual way. A formula ∅ ✄ ϕ with empty context is ground, and may be abbreviated to the expression ϕ. A rigid formula is one whose context is rigid.
A τ -formula is one that is generated by using only τ -terms as premisses in the rule (Eq). An observable formula is one that uses only terms of observable type in forming its component equations.

Semantics of Terms and Formulas
Each O-type σ determines a polynomial functor |σ| : Set → Set. For o ∈ O,

|o| is the constant functor D¯
where D = [[ o ]]; |St| is the identity functor Id;


and inductively
|σ1 × σ2| = |σ1|× |σ2|,	|σ1 + σ2| = |σ1| + |σ2|,	|o ⇒ σ| = |σ|[[ o ]].
Then in general, |σ|A = [[ σ ]]A as defined earlier in Section 3. If σ is a rigid type, then |σ| is the constant functor |σ|A = [[ σ ]].
A τ-coalgebra is a coalgebra for the functor |τ|. A given τ -coalgebra α : A → |τ |A interprets types σ and contexts Γ = (v1 : σ1,..., vn : σn) by putting [[ σ ]]α = |σ|(Dom α) = [[ σ ]]A, and
[[ Γ ]α = [[ σ1 ]]α ×· · ·× [[ σn ]]α
(so [ ∅ ]]α is the empty product 1). Hence α itself is a function of the form A → [[ τ ]]α. The denotation of each τ -term Γ ✄M : σ, relative to the coalgebra α, is a function
[[ Γ ✄ M : σ ]]α : A × [[ Γ ]α −→ [[ σ ]]α,
defined by induction on the formation of terms. For empty contexts,
A × [[ ∅ ]]α = A × 1 ∼= A,
so we replace A × [[ ∅ ]]α by A itself and interpret a ground term ∅ ✄ M : σ as a function A → [[ σ ]]α.
Var:
[[ v : σ ✄ v : σ ]]α : A × [[ σ ]]α → [[ σ ]]α is the right projection function.
Con:
[[ ∅ ✄ c : o ]]α : A → [[ o ] is the constant function with value c.

St:
Tr:
[[ ∅ ✄ s : St ]]α : A → [[ St ]]α is the identity function A → A.

[[ Γ ✄ tr(M ) : τ ]]α : A × [[ Γ ]α → [[ τ ]]α is the composition of the functions



A × [[ Γ ]	[[ Γ ✄ M : St ]]✲α
A	α✲ [[ τ ]] .

Weak:
[[ Γ,v : σ', Γ' ✄ M : σ ]]α is the composition of [ Γ, Γ' ✄ M : σ ]]α with the projection
A × [[ Γ ]α × [[ σ' ]]α × [[ Γ' ]]α −→ A × [[ Γ ]α × [[ Γ' ]]α.


Pair:
[[ Γ ✄ ⟨M1, M2⟩ : σ1 × σ2 ]]α is the product map
A × [[ Γ ]	⟨ [[ Γ ✄ M1 : σ1 ]]α, [[ Γ ✄ M2 : σ2 ]]α✲⟩



[[ σ1 ]]α × [[ σ2 ]]α.


Projj:
[[ Γ ✄ πjM : σj ]]α is the composition of


A × [[ Γ ]	[[ Γ ✄ M : σ1 × σ2 ]]✲α
[[ σ ]] × [[ σ ]]	πj✲ [[ σ ]] .

Injj:
[[ Γ ✄ ιjM : σ1 + σ2 ]]α is the composition of


A × [[ Γ ]	[[ Γ ✄ M : σj ]]✲α
[[ σ ]]	ιj✲ [[ σ ]] + [[ σ ]] .

Case:
This is most readily described at the level of function values. For x ∈ A
and γ ∈ [[ Γ ]α, let
[[ Γ ✄ N : σ1 + σ2 ]]α(x, γ) = ιj(a) ∈ [[ σ1 ]]α + [[ σ2 ]]α (which holds for a unique j and a ∈ [[ σj ]]α). Then the element [[ Γ ✄ case N of [ι1v1 '→ M1 | ι2v2 '→ M2] : σ ]]α(x, γ)
of [ σ ]]α is defined to be
[[ Γ, vj : σj ✄ Mj : σ ]]α(x, γ, a).
Abs:
[[ Γ ✄ (λv.M ) : o ⇒ σ ]]α(x, γ) is the function [ o ]] → [[ σ ]]α given by
a '→ [[ Γ,v : o ✄ M : σ ]]α(x, γ, a).
App:
[[ Γ ✄ M · N : σ ]]α(x, γ) is the element of [ σ ]]α obtained by evaluating the function
[[ Γ ✄ M : o ⇒ σ ]]α(x, γ) : [[ o ]] −→ [[ σ ]]α
at [ Γ ✄ N : o ]]α(x, γ) ∈ [[ o ]].
This completes the inductive definition of [ Γ ✄ M : σ ]]α.

Semantics of Formulas
A τ -equation Γ ✄ M1 ≈ M2 is said to be valid in coalgebra α if the α- denotations [ Γ ✄ M1 ]]α and [ Γ ✄ M2 ]]α of the terms Γ ✄ Mj are identical.
More generally we introduce a satisfaction relation
α, x, γ |= Γ ✄ ϕ,
for τ -formulas in τ -coalgebras, which expresses that Γ ✄ ϕ is satisﬁed, or true, in α at state x under the value-assigment γ to the variables of context Γ. This


is defined inductively by
α, x, γ |= Γ ✄ M1 ≈ M2 iff [ Γ ✄ M1 ]]α(x, γ) = [[ Γ ✄ M2 ]]α(x, γ), α, x, γ |= Γ ✄ ¬ϕ	iff not α, x, γ |= Γ ✄ ϕ,
α, x, γ |= Γ ✄ ϕ1 ∧ ϕ2	iff α, x, γ |= Γ ✄ ϕ1 and α, x, γ |= Γ ✄ ϕ2.
Γ ✄ ϕ is true at x, written α, x |= Γ ✄ ϕ, if α, x, γ |= Γ ✄ ϕ for all γ ∈ Γ. α is a model of Γ ✄ ϕ, written α |= Γ ✄ ϕ, if α, x, |= Γ ✄ ϕ for all states x ∈ Dom α. In that case we also say that Γ ✄ ϕ is valid in the coalgebra α.
Substitution
In working with this system it becomes essential to have available the operation N [M/v] of substituting the raw term M for the variable v in N . The following rule is derivable:
Γ ✄ M : σ	Γ,v : σ ✄ N : σ'
Γ ✄ N [M/v] : σ'
The semantics of terms obeys the basic principle that substitution is inter- preted as composition of denotations [13, 2.2]. Because of the special role of the state set A, this takes the form
[[ Γ ✄ N [M/v] ]]α = [[ Γ,v : σ ✄ N ]]α ◦ ⟨π1, π2, [[ Γ ✄ M ]]α⟩, so that the diagram

A × [[ Γ ]α
⟨π1, π2, [[ M ]]α✲⟩
◗
◗
◗
A × [[ Γ ]α
× [[ σ ]]α

[[ N ]]α

[[ N [M/v] ]]α ◗
◗
◗ 

❄
[[ σ' ]]α

commutes.	It is also possible to make substitutions N [M/s] for the state parameter s according to the rule
Γ ✄ M : St	Γ ✄ N : σ'
Γ ✄ N [M/s] : σ'
with the semantics [ Γ ✄ N [M/s] ]]α = [[ Γ ✄ N ]]α ◦⟨ [[ Γ ✄ M ]]α, π2⟩ :


A × [[ Γ ]α
⟨ [[ Γ ✄ M ]]α, π2✲⟩
◗
◗
◗
◗
◗
A × [[ Γ ]α

[[ N ]]α

[[ N [M/s] ]]α
◗
◗
◗
◗ 
[[ σ' ]]α

Paths and Bisimulations
If (A, α) and (B, β) are coalgebras for a functor T , then a relation R ⊆ A×B is a T-bisimulation from α to β if there exists a transition structure ρ : R → TR on R such that the projections from R to A and B are coalgebraic morphisms from ρ to α and β, i.e. the following diagram commutes:
A ✛	π1	R	π2	✲ B

α	ρ	β
❄	❄	❄
TA ✛	 TR 	✲ TB 
Tπ1	Tπ2
A function f : A → B is a morphism from α to β iff its graph {(a, f (a)) : a ∈ A} is a bisimulation from α to β [17, Theorem 2.5]: a morphism is essential a functional bisimulation. When Dom α ⊆ Dom β, α is a subcoalgebra of β iff the identity relation on Dom α is a bisimulation from α to β.
The above categorial definition of bisimulation appeared in [1]. It has a characterisation in terms of “liftings” of relations [5,6]. For R ⊆ A×B, define a relation RT ⊆ TA × TB by induction on the formation of the polynomial functor T :
RD¯ = id
RId = R
RT1×T2 = {(x, y) : π1xRT1 π1y and π2xRT2 π2y} RT1+T2 = {(ι1x, ι1y) : xRT1 y} {(ι2x, ι2y) : xRT2 y}
RTD = {(f, g) : ∀d ∈ D f(d)RT g(d)}.

These liftings preserve many basic properties of relations. Thus if R is total (Dom R = A) or surjective (onto B) or injective or functional, then RT will also have the corresponding property.
Theorem 5.1 (Folklore)
If R ⊆ Dom α × Dom β, where α and β are T-coalgebras, then R is a bisimu- lation from α to β if, and only if,
xRy implies α(x)RT β(y)
for all states x in α and y in β.	✷
The inverse of a bisimulation is a bisimulation, and the union of any collec- tion of bisimulations from α to β is a bisimulation [17, Section 5]. Hence there is a largest bisimulation from α to β, which is a symmetric relation called bisimilarity. We denote this by ∼. States x and y are bisimilar, x ∼ y, when


xRy for some bisimulation R between α and β. This is intended to capture the notion that x and y are observationally indistinguishable.
Theorem 5.1 can be used to show that bisimulations preserve the values of terms, and in particular that related states assign the same values to ob- servable terms. To explain this we need some more notation. Let (A, α) and (B, β) be τ -coalgebras, and R ⊆ A × B. Then for each O-type σ we have the lifted relation R|σ| ⊆ [[ σ ]]A × [[ σ ]]B, where |σ| is the functor defined by σ. For observable σ, R|σ| is just the identity relation on [ σ ]]. The same is true whenever σ is a rigid type. For any context Γ = (v1 : σ1,..., vn : σn) we define a relation RΓ ⊆ [[ Γ ]A × [[ Γ ]B as the direct product of the R|σi|’s, i.e.
(γ1,..., γn) RΓ (γ' ,..., γ' ) iff γi R|σi| γ' for all i ≤ n.
1	n	i
For rigid Γ, RΓ is just the identity relation on [ Γ ] = [ σ1 ]] ×· · ·× [[ σn ]].
Theorem 5.2 (Value-Preservation)
Let R be a |τ|-bisimulation from α to β.
For any τ-term Γ ✄ M : σ, if γ ∈ [[ Γ ]α and γ' ∈ [[ Γ ]β have γRΓγ', then
xRy implies [[ Γ ✄ M ]]α(x, γ) R|σ| [[ Γ ✄ M ]]β(y, γ').
If Γ ✄ M is a term of observable type, and γRΓγ', then
xRy implies [[ Γ ✄ M ]]α(x, γ) = [[ Γ ✄ M ]]β(y, γ').
If Γ ✄ M is a rigid term of observable type, and γ ∈ [[ Γ ], then
xRy implies [[ Γ ✄ M ]]α(x, γ) = [[ Γ ✄ M ]]β(y, γ).	✷
¿From part (2) of this result it follows, by induction on the formation of formulas, that if Γ ✄ ϕ is an observable formula, then
α, x, γ |= Γ ✄ ϕ iff β, y, γ' |= Γ ✄ ϕ
whenever xRy and γRΓγ'. Thus if Γ✄ϕ is valid in α and R is surjective, so that RΓ is also surjective, Γ ✄ ϕ will be valid in β. On the other hand if β |= Γ ✄ ϕ and R is total, so that RΓ is also total, then α |= Γ✄ϕ. In other words, validity is preserved in passing from α to β if β is the image of a bisimulation from α, and is preserved in passing from β to α if α is the domain of a bisimulation to β. If Γ ✄ ϕ is also rigid, then its validity is preserved by disjoint unions: given any element ιj(a) of  I αi and any γ ∈ [ Γ ]], if αj |= Γ ✄ ϕ we get
I αi, ιj(a),γ |= Γ ✄ ϕ, because αj, a,γ |= Γ ✄ ϕ, γRΓγ, and the insertion morphism ιj is a bisimulation. To sum up:
Theorem 5.3 The class {α : α |= Γ ✄ ϕ} of all models of an observable formula is closed under domains and images of bisimulations, including do- mains and images of morphisms as well as subcoalgebras. If Γ ✄ ϕ is rigid and observable, then its class of models is also closed under disjoint unions.✷
The main purpose of this Section is to strengthen Theorem 5.2 to a logical characterisation of bisimilarity: states are bisimilar when they assign the same


values to all ground terms of observable type, or equivalently when they satisfy the same rigid observable formulas (see Theorem 5.8). The key to this is the relation ≡αβ defined by
x ≡αβ y iff  [ M ]]α(x) = [[ M ]]β(y) for all ground terms M : o
of observable type.
≡αβ is a bisimulation from α to β, and turns out to be the largest one. The proof of this requires the development of another characterisation of bisimu- lation, using the notion of “paths” between functors [10, Section 6].
A path is a finite list of symbols of the kinds πj, εj, evd. Write p.q for
p
concatenation of lists p and q. The notation T −~S means that p is a path
from functor T to functor S, and is defined by the following conditions
⟨⟩
T −~T , where ⟨⟩ is the empty path.
πj.p	p
T1 × T2−~S whenever Tj−~S, for j = 1, 2.
εj.p	p
T1 + T2−~S whenever Tj−~S, for j = 1, 2.
D evd.p	p
T	−~S for all d ∈ D whenever T −~S.
It is evident that for any path T −~S, S is one of the functors involved in the formation of T .

p
A path T −~S
induces a partial function pA
: TA ◦ ✲ SA for each set A,

defined by induction on the length of p as follows.
⟨⟩A : TA ◦ ✲ TA is the identity function idTA, so is totally defined.
(π .p)	= p ◦ π , the composition of	T A × T A	πj✲  TA ◦pA✲ SA. Thus x ∈ Dom (πj.p)A iff πj(x) ∈ Dom pA.
(ε .p)	= p ◦ ε , the composition of	T A + T A ◦ εj✲ TA ◦pA✲ SA. Thus x ∈ Dom (εj.p)A iff x ∈ ιjT Aj and εj(x) ∈ Dom pA.

(ev .p)	= p ◦ ev , the composition of	(T A)D ev✲d
Thus f ∈ Dom (evd.p)A iff f (d) ∈ Dom pA.
TA ◦pA✲ SA.

A path T −~S is a state path if S = Id, and an observation path if S = D¯ for some set D. A T -bisimulation can be characterised as a relation that is “preserved” by the partial functions induced by state and observation paths from T . To explain this we adopt the convention that whenever we write “f (x) Q g(y)” for some relation Q and some partial functions f and g we mean that
f (x) is defined iff g(y) is defined, and (f (x), g(y)) ∈ Q when they are both defined.

Theorem 5.4 Let R ⊆ A×B, x ∈ T A, and y ∈ TB, where T is a polynomial

functor. Then the following are equivalent.
xRT y.
p
For all paths T −~S, pA(x)RSpB(y).
p
• For all state paths T −~Id, pA(x) R pB(y); and
p	¯
for all observation paths T −~D, pA(x) = pB(y).	✷
Combining this result with Theorem 5.1 gives the desired “dynamic” charac- terisation of bisimulations:
Theorem 5.5 If A  α✲ TA and B  β✲ TB are coalgebras for a polynomial functor T, then a relation R ⊆ A× B is a T-bisimulation if, and only if, xRy implies
p
for all state paths T −~Id, pA(α(x)) R pB(β(y)); and
p	¯
for all observation paths T −~D, pA(α(x)) = pB(β(y)).
Corollary 5.6 If C ⊆ Dom α, then C is a subcoalgebra of α iff x ∈ C implies
p
pA(α(x)) ∈ C for all state paths T −~Id such that pA(α(x))↓.
Proof. To say that C is a subcoalgebra of α means that there is some T - transition structure on C that is a subcoalgebra of α. Such a structure is unique, and exists iff the identity relation ∆C = {(x, x) : x ∈ C} on C is a bisimulation relation on α [17, Proposition 6.2]. Now apply the Theorem with R = ∆C and α = β, and use the fact that pA(α(x)) ∆C pA(α(x)) iff pA(α(x)) ∈ C.	✷
This characterisation makes it easy to see that if R is a bisimulation from α to β, then Dom R is a subcoalgebra of α. For if x ∈ Dom R and pA(α(x))↓, then xRy for some y, so pA(α(x)) R pB(β(y)) by 5.5 and hence pA(α(x)) ∈ Dom R. Similarly, the image of R is seen to be a subcoalgebra of β.
Path functions are thus an effective tool in the structural analysis of poly- nomial coalgebras. Their use in logical characterisations derives from the fact that the action of a path function is definable by a (ground) term.
Lemma 5.7 (Path Lemma)
p
For any path |τ|−~|σ| there exists a term of the form
v : τ ✄ p¯ : σ
such that for any τ-coalgebra (A, α) and any x ∈ A, if α(x) ∈ Dom pA then
pA(α(x)) = [ p¯[tr(s)/v] ]]α(x).	✷
Note that since ∅ ✄ tr(s) : τ is a τ -theorem, so too is ∅ ✄ p¯[tr(s)/v] : σ by the rule of Substitution. Hence p¯[tr(s)/v] is a ground term of type σ.


In proving the Path Lemma (by induction on the length of p) it must be shown that the action of an extraction function εj is term-definable. In fact it can be shown that for any term Γ ✄ M : σ1 + σ2 of coproduct type there exist terms Γ ✄ εjM : σj for j = 1, 2 such that
[[ Γ ✄ εjM ]]α(x, γ) = εj [[ Γ ✄ M ]]α(x, γ) ∈ [[ σj ]]A
whenever [ Γ ✄ M ]]α(x, γ) ∈ ιj[[ σj ]]A. Indeed, taking v1, v2 as new variables not in M , put
ε1M := case M of [ι1v1 '→ v1 | ι2v2 '→ N1],
where N1 is any ground term of type σ1 (the existence of ground terms of every type follows by induction on term and type formation from axioms (Con) and (St) of Figure 2). ε2 is defined similarly.
The term function [ p¯[tr(s)/v] ]]α has domain A, and so may not be identical to pA ◦ α if pA is partial. This is only an issue when the path p includes an extraction symbol εj (for otherwise pA is total), but further use of case allows the construction of terms that “discriminate” between the two summands of a coproduct [ σ1 ]]A + [[ σ2 ]]A and determine whether pA(α(x)) is defined. For this to work we need the (reasonable) assumption that τ has at least one observable subtype o that is non-trivial in the sense that [ o ] has at least two distinct members, say c1 and c2. Then we form the term v : σ1 + σ2 ✄ P : o, where
P := case v of [ι1v1 '→ c1 | ι2v2 '→ c2],
and find, when α is a σ1 + σ2-coalgebra, that the ground term P [tr(s)/v] : o is a discriminator:
[[ P [tr(s)/v] ]]α(x) = cj iff α(x) ∈ ιj[[ σj ]]A = Dom εj.
An inductive argument that repeats this construction for each extraction sym-
p
bol in a path |τ|−~|σ| produces a finite set Tp of ground observable terms
such that
if (A, α) and (B, β) are τ-coalgebras, and x ∈ A and y ∈ B have [[ M ]]α(x) = [[ M ]]β(y) for all M ∈ Tp, then α(x) ∈ Dom pA iff β(y) ∈ Dom pB.
Combining this observation with the Path Lemma 5.7, the path-characterisation of bisimulations of Theorem 5.5, and application of Substitution rules, leads ultimately to a proof that the relation ≡αβ is a bisimulation. This in turn leads to the logical characterisation of bisimilarity of states:
Theorem 5.8 Let (A, α) and (B, β) be τ-coalgebras, where τ has at least one non-trivial observable subtype. Then for any x ∈ A and y ∈ B, the following are equivalent:
x and y are bisimilar: x ∼ y.

α, x |= Γ ✄ ϕ iff β, y |= Γ ✄ ϕ for all rigid observable formulas Γ ✄ ϕ.
α, x |= M ≈ N implies β, y |= M ≈ N for all ground observable terms M
and N.
[ M ]]α(x) = [[ M ]]β(y) for all ground observable terms M, i.e. x ≡αβ y.

Observable Ultrapowers
Let U be an ultrafilter on a set I. For each set A, the relation
f =U g iff {i ∈ I : f (i) = g(i)}∈ U
is an equivalence relation on the I-th power AI of A. Each f ∈ AI has the equivalence class f U = {g ∈ AI : f =U g}. The quotient set
AU = {f U : f ∈ AI}
is called the ultrapower of A with respect to U . 2 There is a natural injection eA : A > AU given by eA(a) = a¯U , where a¯ ∈ AI is the constant function with value a. The distinction between a and a¯U is sometimes blurred, allowing A to be identified with the subset eA(A) of AU .
A notation that will be useful below is to write f U ∈U C, for C ⊆ A, when
{i ∈ I : f (i) ∈ C}∈ U .
A map θ : A1 ×· · ·× An → B has a U -lifting θU : AU ×· · ·× AU → BU ,

given by
1	n

θU (f U ,...,fU ) = ⟨θ(f1(i),..., fn(i)) : i ∈ I⟩U .

1	n
In the case n = 1, any θ : A → B lifts to θU : AU → BU where θU (f U ) = (θ ◦ f )U . This works also for a partial θ : A ◦ ✲ B, providing a U -lifting θU : AU ◦ ✲ BU in the same way, with the proviso that θU (f U ) is defined only when f U ∈ Dom θ, i.e. when {i ∈ I : f (i) ∈ Dom θ}∈ U .
Now let α : A → [[ τ ]]A be a τ -coalgebra which will remain fixed throughout Section 6. The transition structure α lifts to a function αU : AU → [[ τ ]]U , and

each term denotation [ Γ ✄ M : σ ]]α lifts to a function
[[ Γ ✄ M : σ ]]U : AU × [[ σ1 ]]U ×· · ·× [[ σn ]]U −→ [[ σ ]]U

(‡)

α	A	A	A


where σ1,..., σn is the list of types of Γ.
αU is not a τ -coalgebra on AU since its codomain is [ τ ]]U

= (|τ|(A))U

rather than [ τ ]]AU = |τ|(AU
). We wish to define a coalgebraic structure on

AU that interprets terms in a manner related to the functions [ Γ ✄ M : σ ]]U . To achieve this it is necessary to retain only some of the points of AU , and the key to understanding which ones is provided by considering the U -lifting of the α-denotation of a ground observable term M : o. This is the function

2 For the standard theory of ultrafilters and ultrapowers see [2,3].


[[ M ]]U : AU → [[ o ]]U . To act as a denotation for M it should assign values in [[ o ]], viewed as a subset of [ o ]]U . In other words we should have

[[ M ]]U (x) ∈ e[[ o ]] = {c¯U : c ∈ [[ o ]]}⊆ [[ o ]]U .
We are thus led to define an element x of AU to be observable if [ M ]]U (x) ∈ e[[ o ] for every ground observable τ -term M : o. If x = f U , this means that for each such M there exists an observable element cM ∈ [[ o ]] such that
{i ∈ I : [[ M ]]α(f (i)) = cM }∈ U.	(†)
Put A+ = {x ∈ AU : x is observable}. For each a ∈ A and any ground M : o,


[[ M ]]U (e

(a)) = [ M ]]U (a¯U ) = ( [ M ]]

a¯)U = [[ M ]]
(a) U ∈ e[[ o ]],


so eA(a) is observable. Thus eA embeds A into A+, allowing us to view A+ as an extension of A.
p
Theorem 6.1 For any path |τ|−~|σ| beginning at |τ| there exist partial func-

+	+  ✲
U	 ✲

tions (pA ◦ α)	: A	◦
[[ σ ]]A+ and θσ : [[ σ ]]A ◦
[[ σ ]]A+ ,

A✲		eA	✲          A+            ⊂ 	✲ AU

◦
pA ◦ α
◦
(pA ◦ α)+
◦
(pA ◦ α)U

❄
[[ σ ]]A
|σ|eA ✲
❄
[[ σ ]]A+
✛✛θσ
❄
[[ σ ]]U

such that
Dom (pA ◦ α)+ = A+ ∩ Dom (pA ◦ α)U ;
x ∈ Dom (pA ◦ α)+ implies (pA ◦ α)U (x) ∈ Dom θσ;
a ∈ Dom pA ◦ α implies eA(a) ∈ Dom (pA ◦ α)+;
b ∈ [[ σ ]]A implies ¯bU ∈ Dom θσ;
θσ is surjective (onto [[ σ ]]A+ ),
and the above diagram commutes wherever deﬁned.	✷
The proof of this theorem proceeds by induction on the formation of the end-type σ, and is too long and complex to be described here. But some comments are in order, particularly since the function θσ seems to be pointing in the “wrong” direction. When σ is observable, θσ is just the inverse of the embedding [ σ ]] > [[ σ ]]U , and when σ = St, θσ is the inverse of the inclusion A+ ‹→ AU . The inductive cases for products and coproducts appeal to the fact that the ultrapower operation commutes with these constructions, in the


sense that there exist isomorphisms

(B × D)U ∼= BU × DU ,	(B + D)U ∼= BU + DU

for any sets B, D. However there is no corresponding commutation for powers: there is only a surjection χ : (BD)U → (BU )D, given by the formula χ(x)(d) = ev U (x), which may not be injective (this uses the U -lifting of evd : BD → D). χ is used in the definition of θσ when σ is a power type, and this dictates the direction of θσ.
Now applying Theorem 6.1 in the case that σ = τ and p is the empty

path, so that pA = idA, gives a function α+
: A+
 )
[[ τ ]]A+ whose domain

is A+ ∩ Dom αU = A+, so that α+ is total, such that the diagram

A)	eA ) A+ ⊂	) AU


α
v	|τ|e)A
α+	αU

v  ((θτ

[[ τ ]]A
[[ τ ]]A+
[[ τ ]]A

commutes. α+ is thus a τ -coalgebra, which will be called the observable ultra- power of α with respect to U .
The use we make of α+ derives ultimately from that fact that for a ground observable term M : o, the denotation [ M ]]α+ agrees with [ M ]]α in the sense
U	U
that [ M ]]α+ = θo ◦ [[ M ]]α TA+ , or equivalently [ M ]]α TA+ = e ◦ [[ M ]]α+ :

[[ o ]]U
/’	◦ ˆ
[[ M ]]U /
α/	θo	e
/
/	v
A+ 	) [[ o ]]
[[ M ]]α+
But to prove that takes an induction on the derivation of the ground term ∅✄ M , which may involve more complex types and non-empty contexts. Therefore we have to prove a more elaborate result. To formulate this, given a context Γ
with types σ1,..., σn, let θΓ = θσ1 ×· · ·× θσn be the product of the functions
U	 ))
θσi : [[ σi ]]A ◦	[[ σi ]]A+ . Then Dom θΓ is the product of the Dom θσi ’s, and so

A+ × Dom θΓ is a subset of the domain of [ Γ ✄ M ]]U
Γ (see (‡) earlier in this section for Dom [ Γ ✄ M ]]U ).
for any term in context

We can now state the result that explains the sense in which [ Γ ✄ M ]]α+
can be viewed as a restriction of [ Γ ✄ M ]]U . The proof is a lengthy induction
on term formation.

Theorem 6.2 For any τ-term Γ ✄ M : σ, any x ∈ A+, and any γ ∈ Dom θΓ,
[[ Γ ✄ M ]]U
A+ × Dom θΓ	)α	[[ σ ]]U

◦
id × θΓ
v
+
◦
θσ

[[ Γ ✄ M ]]α)+	v

A × [[ Γ ]A+	[[ σ ]]A+
[ Γ ✄ M ]]U (x, γ) ∈ Dom θσ,  and
θσ ◦ [[ Γ ✄ M ]]α (x, γ) = [[ Γ ✄ M ]]α+ (x, θΓ(γ)).	✷
The main use of this theorem is in deriving the following fundamental rela- tionship between satisfaction in a coalgebra and in its observable ultrapowers.

Theorem 6.3 (LB o´s-type theorem for observable ultrapowers)
If Γ ✄ ϕ is an observable τ-formula, x ∈ A	and (z1,..., zn) ∈ [[ Γ ]A+ , then
α+, x, z1,..., zn |= Γ ✄ ϕ	if, and only if,
{i ∈ I : α, f (i), g1(i),..., gn(i) |= Γ ✄ ϕ}∈ U
whenever x = f U and (z1,..., zn) = θΓ(gU ,..., gU ).	✷
1	n
¿From this we can conclude that the class of all models of an observable formula is closed under observable ultrapowers:
Corollary 6.4 If Γ ✄ ϕ is observable, then
α |= Γ ✄ ϕ if, and only if, α+ |= Γ ✄ ϕ.
✷

Intrinsic Ultrapowers
A set Φ of ground formulas is satisﬁable in coalgebra α if there is some state of α at which all members of Φ are true, i.e. some x ∈ A such that α, x |= ϕ for all ϕ ∈ Φ. Φ is ﬁnitely satisﬁable if each finite subset of Φ is satisfiable in α. Putting ϕα = {x ∈ A : α, x |= ϕ}, we see that Φ is finitely satisfiable in α iff the collection Φα = {ϕα : ϕ ∈ Φ} of subsets of A has the finite intersection property.
There is a well-known construction in the theory of ultrapowers that will enable us to force certain finitely α-satisfiable Φ’s become satisfiable in α+. By choosing a suitable ultrafilter U it can be arranged that any collection S of subsets of A with the finite intersection property has a “nonstandard element” in its intersection. This element is an f U ∈ AU such that for each C ∈ S, f U ∈U C, i.e. {i : f (i) ∈ C}∈ U .


To see how this is done, let IA be the set of all finite subsets of the powerset of A. A typical element of IA is of the form i = {C1,..., Cn} with the Cj’s being subsets of A. For each k ∈ IA, let Ik = {i ∈ IA : k ⊆ i}. The collection UA = {Ik : k ∈ IA} has the finite intersection property, since Ik1 ∩ · · ·∩ Ikn contains the element i = k1 ∪· · · ∪ kn. Any ultrafilter U on IA that extends UA will be called intrinsic to A, and the associated AU and α+ will be called intrinsic ultrapowers.
Now if S is a collection of subsets of A with the finite intersection property, let f : IA → A be any function such that f (i) ∈  (i ∩ S) whene ver i ∩ S /= ∅.
so such an f does exist. Then for any C ∈ S, put k = {C} ∈ IA: if i ∈ I{C} then C ∈ i ∩ S, so f (i) ∈ C. This shows that I{C} ⊆ {i : f (i) ∈ C}, and so f U ∈U C as desired.

Theorem 6.5 Let τ be a type that has at least one non-trivial observable subtype. Suppose that every ground observable τ-formula valid in α is valid also in a τ-coalgebra β. Let α+ be any intrinsic observable ultrapower of α. Then each state of β is bisimilar to a state of α+.
Proof. Let y be a state of β. If M : o is any ground observable term, let cM = [ M ]]β(y) ∈ [[ o ]]. Let Φy be the set of equations M ≈ cM for all ground observable M . By definition, Φy is satisfied by y in β. Each finite
{ϕ1,..., ϕn}⊆ Φy is satisifiable in α, for otherwise the formula

¬(ϕ1 ∧· · ·∧ ϕn)

would be valid in α, hence valid in β by hypothesis, contrary to the fact that this formula is false at y.

Thus the collection Φα
has the finite intersection property.  If U is the

intrinsic ultrafilter that gives rise to α+, then by the above construction there is some f U ∈ AU such that for each M , f U ∈U (M ≈ cM )α, which means that the set

IM = {i ∈ I : α, f (i) |= M ≈ cM }
= {i ∈ I : [[ M ]]α(f (i)) = cM }

belongs to U . Since this holds for all ground observable M , f U is observable by (†), so f U ∈ A+. Also, since IM ∈ U , Theorem 6.3 gives α+,fU |= M ≈ cM , so
[[ M ]]α+ (f U ) = cM = [[ M ]]β(y).
Therefore f U and y assign the same values to all ground observable terms, and so are bisimilar by Theorem 5.8(4).	✷

Definable Classes of Coalgebras
The tools needed to give a structural characterisation of logically definable classes of coalgebras are now all in place. The following result is the analogue for polynomial functors of Theorem 9.2 of [4] for monomial functors, and the underlying reasoning is the same.
Theorem 7.1 If τ has at least one non-trivial observable subtype, then for any class K of τ-coalgebras, the following are equivalent.
K is the class of all models of some set of rigid observable formulas.
K is the class of all models of some set of ground observable formulas.
K is closed under disjoint unions, images of bisimulations, and observable ultrapowers.
K is closed under disjoint unions, images of bisimilarity relations, and intrinsic observable ultrapowers.
Proof. We explain why (4) implies (2), the proofs that (2) implies (1) which implies (3) which implies (4) being either evident or already discussed (The- orem 5.3, Corollary 6.4).
Let Φ be the set of all ground observable formulas that are valid in all members of K. By definition all members of K are models of Φ, so it suffices to prove the converse. Let β be a model of Φ. For each ground observable ϕ such that β |= ϕ there must be some αϕ ∈ K such that αϕ |= ϕ (or else ϕ belongs to Φ hence β |= ϕ). Let α be the disjoint union of all these αϕ’s. Then any ground observable formula valid in α is valid in every αϕ, hence valid in β. Therefore if α+ is an intrinsic observable ultrapower of β, then by Theorem 6.5 the bisimilarity relation from α+ to β is surjective.
In other words, β is the image under bisimilarity of an intrinsic ultrapower of a disjoint union of coalgebras from K. The closure conditions listed in (4) thus ensure that β ∈ K.	✷

References
Aczel, P. and N. Mendler, A Final Coalgebra Theorem, in: D. H. Pitt et al., editors, Category Theory and Computer Science. Proceedings 1989, Lecture Notes in Computer Science 389, Springer-Verlag, 1989 pp. 357–365.
Bell, J. L. and A. B. Slomson, “Models and Ultraproducts,” North-Holland, Amsterdam, 1969.
Chang, C. C. and H. J. Keisler, “Model Theory,” North-Holland, Amsterdam, 1973.
Goldblatt, R., What is the Coalgebraic Analogue of Birkhoff’s Variety Theorem?, Theoretical Computer Science, to appear. Manuscript available at http://www.mcs.vuw.ac.nz/~rob/papers/what.ps.


Hermida, C., “Fibrations, Logical Predicates and Indeterminates,” Ph.D. thesis, University of Edinburgh (1993), techn. rep. LFCS-93-277. Also available as Aarhus Univ. DAIMI Techn. rep. PB-462.
Hermida, C. and B. Jacobs, Structural induction and coinduction in a ﬁbrational setting, Information and Computation 145 (1998), pp. 107–152.
Jacobs, B., Objects and Classes, Coalgebraically, in: B. Freitag, C. B. Jones,
C. Lengauer and H.-J. Schek, editors, Object-Orientation with Parallelism and Persistence, Kluwer Academic Publishers, 1996 pp. 83–103.
Jacobs, B., “Categorical Logic and Type Theory,” Elsevier, 1999.
Jacobs, B., Exercises in Coalgebraic Speciﬁcation, manuscript for the proceedings of the Mathematics for Information Technology summer school, Oxford, 2000. Available at http://www.cs.kun.nl/~bart/PAPERS/.
Jacobs, B., Towards a Duality Result in Coalgebraic Modal Logic, Electronic Notes in Theoretical Computer Science 33 (2000), http://www.elsevier.nl/ locate/entcs.
Kurz, A., Specifying Coalgebras with Modal Logic, Electronic Notes in Theoretical Computer Science 11 (1998), http://www.elsevier.nl/locate/ entcs.
Moss, L. S., Coalgebraic Logic, Annals of Pure and Applied Logic 96 (1999),
pp. 277–317.
Pitts, A. M., Categorical Logic, in: S. Abramsky, D. M. Gabbay and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, Volume 5: Algebraic and Logical Structures, Oxford University Press, 2000 .
Reichel, H., An Approach to Object Semantics Based on Terminal Co-Algebras, Mathematical Structures in Computer Science 5 (1995), pp. 129–152.
R¨oßiger, M., From Modal Logic to Terminal Coalgebras, Preprint MATH-AL-3- 1998, Technische Universit¨at Dresden (1998), to appear in Theoretical Computer Science.
Rutten, J., A Calculus of Transition Systems (towards Universal Coalgebra), in: A. Ponse, M. de Rijke and Y. Venema, editors, Modal Logic and Process Algebra, CSLI Lecture Notes No. 53, CSLI Publications, Stanford, California, 1995 pp. 231–256.
Rutten, J., Universal Coalgebra: a Theory of Systems, Theoretical Computer Science 249 (2000), pp. 3–80.
