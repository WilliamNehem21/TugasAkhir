Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 129–146
www.elsevier.com/locate/entcs
Total Maps of Turing Categories
J.R.B. Cockett 1,2
Department of Computer Science University of Calgary
Calgary, Alberta, Canada, T2N 1N4
P.J.W. Hofstra3
Department of Mathematics and Statistics University of Ottawa
Ottawa, Ontario, Canada, K1N 6N5
P. Hrubeˇs4
Department of Computer Science and Engineering University of Washington
Seattle, WA, USA

Abstract
We give a complete characterization of those categories which can arise as the subcategory of total maps of a Turing category. A Turing category provides an abstract categorical setting for studying computability: its (partial) maps may be described, equivalently, as the computable maps of a partial combinatory algebra. The characterization, thus, tells one what categories can be the total functions for partial combinatory algebras. It also provides a particularly easy criterion for determining whether functions, belonging to a given complexity class, can be viewed as the class of total computable functions for some abstract notion of computability.
Keywords: Computability theory, Partial Combinatory Algebra, Turing Category, Complexity Theory.

Introduction
Turing categories [1,2,6], provide an abstract categorical setting for computability theory which, unlike partial combinatory algebras (PCAs) and related structures, are presentation-independent and purely formulated in terms of categorical proper- ties. The standard example of a Turing category has objects powers of the natural

1 This work was partial supported by NSERC Canada
2 Email: robin@ucalgary.ca
3 Email: phofstra@uottawa.ca
4 Email: pahrubes@gmail.com

http://dx.doi.org/10.1016/j.entcs.2014.10.008
1571-0661/© 2014 Elsevier B.V. All rights reserved.

numbers and maps all the partial recursive functions. However, there are many other less well-known examples deriving from the “computable maps” of PCAs (or more generally relative PCAs) or from syntactical methods. Of special relevance for the purposes of the present work are the Turing categories described in [3] which have as total maps the programs belonging to various complexity classes (PTIME, LOGSPACE, etc.). These examples naturally lead to the question of exactly what categories can be the total maps of a Turing category. Intuitively, as in any Turing category one can simulate all computable functions, it would seem reasonable to suppose that the total maps would have to satisfy some fairly demanding closure properties.
The question is of significance for various reasons. To start with, it is one way to determine the limits of the applicability of Turing categories in studying computability. If it where impossible for the total maps of a Turing category to be exactly, say, the linear time functions, then one cannot hope to use Turing categories as a basis for investigating feasible computation at very low complexity levels. On the other hand, if one knows that the total maps of a Turing category can be of such low complexity then Turing categories can be a tool for formally unifying computability and complexity theory and allowing a fluid flow of ideas between the subjects.
A second reason for considering this question in the abstract categorical setting is that it leads to an interesting comparison with the more traditional view on these matters, namely via logic. Given a logical theory, one may ask which functional relations are provably total: the weaker the theory, the smaller the class of provably total maps. One may also wish for the system to be strong enough to allow for the representation of partial computable maps. It is well known that even relatively weak fragments of arithmetic ensure this. For example, Robinson’s Arithmetic Q is enough to ensure all the partial recursive functions are represented. The study of complexity, using bounded and two sorted logics [5] for example, has further pushed the limits of these methods. It is, thus, in its own right, an interesting question to know exactly what an absolutely minimal logic for generating these settings really is. Although, this paper does not attempt to answer this question directly, the categorical framework we describe can certainly be backward engineered into a logical form: even a brief perusal indicates that there is a significant difference between these approaches, not least because a Turing category is not a priori based on arithmetic.
The third point of interest lies not so much in the question itself as in the methods used here to provide the answer. The proof that a cartesian category satisfying certain conditions can be embedded as a category of total maps in a Turing category makes use of two ideas: first, it uses the Yoneda embedding to create a canonical category of partial maps into which the original category embeds. Next, we use the concept of a stack machine in the presheaf category to create a partial combinatory algebra which in turn will generate the desired Turing category. A stack machine can be thought of as a categorical implementation of the canonical rewrite system in combinatory logic (but augmented with additional data). As

such, this concept helps clarify the connection between syntactical approaches to generating models of computation and categorical methods.
Below we develop necessary and sufficient conditions for a Cartesian category to be the total maps of a Turing category. The conditions are perhaps a little surprising as apparently very little is actually required: there must be a universal object, U , which has a pair of “disjoint” elements, and which has an “abstract retract” structure which allows coding of maps. A universal object is an object into which every other object can be embedded as a subobject: to have such an object is already a somewhat non-trivial requirement as this, in particular, implies there is an embedding U × U −→ U showing that U must be an infinite object. The remaining conditions are somewhat more technical: they are explained in section 3 below. However, it should be noted that in most of the standard applications, as described in section 5, these technical conditions can be by-passed.
We start the exposition by considering the much more general question of how a category can arise as the subcategory of total maps of an arbitrary restriction category. (For background on restriction categories we refer to [4].) This leads to the notion of a totalizing extension of the given category, and we show that the category of totalizing extensions of a particular category has a final object which is naturally a restriction category. This insight allows us to transfer the general question of finding a Turing category which extends a given cartesian category into finding a partial combinatory algebra in this final extension whose total maps include the given maps. This perspective allows us to propose necessary conditions for a Cartesian category to be the total maps of a Turing category, see section 3. To show that these are sufficient we demonstrate that one can build, using a simple abstract machine, a combinatory algebra in the final totalizing extension (actually of a slightly modified category) which has elements representing all the total maps: this suffices in view of Theorem 4.12 of [2]. Finally we provide simpler sufficient conditions to show the wide applicability of the theorem.
Totalizing map subcategories
When X is a restriction category, the inclusion of the subcategory of total maps Total(X) −→ X satisfies various properties. This leads to the following definition:
Definition 2.1 [Totalizing functor] A functor T : Xj −→ X is totalizing when it satisfies the following three conditions:
T on objects, TObj : Obj(Xj) −→ Obj(X), is an isomorphism,
T is faithful,
T is left factor 5 closed, meaning that when Th = gf then there is a (neces- sarily unique) k such that Tk = f .
The following observation indicates that this class of functors is reasonably well- behaved.

5	Th	f	g
Note that “left” factor refers to the diagrammatic order of composition: A ———→ B = A ——→ B ——→ C.

Lemma 2.2 In the category of categories and functors, the class of totalizing func- tors, T , form a stable system of monics:
Every T ∈T is monic,
T is closed to composition,
T contain all isomorphisms,
T is closed to pulling back along any functor.
Proof. Routine.	2
Recall that given any (small) category X the Yoneda embedding, y : X −→ SetXop , gives a full and faithful embedding of X into presheaves on X. This category of presheaves is finitely complete and therefore one can form the partial map category on all monics Par(SetXop ). Notice that the total maps in this category are exactly the morphisms of SetXop . Restricting this category to the representables gives a full subcategory which we shall denote X. While this is in general no longer a partial map category, it certainly is a restriction category. We then have the following pullback:
X	 X¸
y	y˜

JXop 	 ¸
JX op

Set	Par(Set	)
This exhibits X as a subcategory of total maps of the restriction category X, whence
η is totalizing.
While there may be many other categories Y into which X embeds via a totalizing functor, we shall now make precise the sense in which η : X −→ X is the universal such functor.
Consider the category of totalizing extensions of X, denoted Extf (X), whose objects are totalizing functors T : X −→ Y and whose morphisms are commuting triangles below X
X ¸¸	X	X

T cccc
ccc
¸¸T ′
¸¸	T	T ′

c	zz	J 
Y	 Y¸	Y
F	F
J 
 Y¸

which reflect total maps in the sense that the square on the right is a pullback.
Proposition 2.3 Extf (X) is a (ﬁnitely) complete category in which η : X −→ X is the ﬁnal object.
Proof. The verification that pullback exist (and are constructed as in Cat is routine.
We shall show that η : X −→ X˜ is the final object in this category. To this end,
suppose T : X −→ Y is totalizing. Without loss of generality we may assume that Y
has the same collection of objects as X. It is then obvious how the functor E : Y
−→ X˜ should act on objects. For a morphism g : X −→ Xj in Y, we need to define a

partial map y(X) −→ y(Xj). First consider the following sieve on X:
Sg = {h : Z −→ X|gh ∈ X}.
This sieve corresponds to a subobject of the representable y(X). Next, define a natural transformation τ (g): Sg −→ y(Xj) by
τ (g)Z : Sg(Z) −→ X(Z, Xj);	τ (g)Z(h)= gh.
This data defines a partial map E(g): y(X) −→ Y(Xj), which is total if and only if g ∈ Xj. This in particular shows that E reflects total maps. The verification that E is functorial is straightforward and left to the reader.
To show that E is unique suppose we are given an extension Ej : Y −→ X. Since Ej must respect maps from X, we verify its action on a map g : X −→ Xj which is not in X. Then Ej(g) isa span y(X) ⊇ S −−σ→ y(Xj). Now if h ∈ Sg, the composite gh is in X, and therefore h ∈ S, whence Ej(gh) = Ej(g)Ej(h) = σ(h) must equal y(gh). This means that Ej(g) ≥ E(g). To show the converse, assume that h ∈ S but h /∈ Sg. Then gh /∈ X. But then Ej(gh) is a total map, contradicting the reflection of total maps.	2
We also note that in case Y is a restriction category and T : X −→ Y the inclusion of total maps, then in fact E : Y −→ X is a restriction functor. In addition, we have the following result, which states that if X has products, then E preserves the induced restriction products.
Lemma 2.4 Suppose that X has ﬁnite products. Then X also has ﬁnite restriction products, and η preserves them.
Proof. Finite products in a split restriction category are completely determined by their counterparts in the total map subcategory. Thus, as the inclusion SetXop
−→ Par(SetXop ) preserves products and y : X −→ SetXop preserves products cutting
down to X˜ preserves products.	2
With a view towards our aim of characterizing those categories which arise as the total map subcategory of a Turing category, we can now observe the following. When X −→ T is a totalizing extension with T a Turing category, then we have the following situation:

X ¸¸¸¸
¸¸¸¸¸
 T¸
E

η ¸¸¸¸ J 
zX 
Then by the above lemma, E is a Cartesian restriction functor; since any such functor preserves partial combinatory algebras, we find that there is a PCA E(U ), the image of the Turing object U ∈ T. Thus we obtain:
Proposition 2.5 X is the total map category of a Turing category if and only if there is a combinatory algebra in X whose total computable maps include the maps of X.

Thus we may see our original problem as one of finding a suitable PCA in X for which all the maps in X are computable. Indeed, if such a PCA exists, then we may let T be the subcategory of X on the computable maps. Notice one rather nice aspect of this reformulation of the problem: since the maps of X already account for all the total maps in X, the total maps represented by a PCA in X necessarily lie in X already; thus we don’t have to worry about having too many total maps represented. Therefore, the only thing to verify when constructing a candidate PCA is that it represents all the maps in X.

Properties of the total maps of a Turing category
We are now in a position to collect the necessary conditions for being the total maps of a Turing category. Clearly the total map category has to be Cartesian (i.e. has finite products), as Turing categories are Cartesian by definition. The remaining conditions are somewhat more technical. However, it should be stressed that in many cases of interest these conditions greatly simplify.
The purpose of the section is to prove:
Proposition 3.1 Every total map category of a Turing category has a universal object which has a pair of disjoint elements and is equipped with an abstract retract structure for which there exist codings.
Below we introduce the required notions of having a universal object , disjoint elements, abstract retract structure, and codes, showing each is present in the total map category of a Turing category.

A universal object
One of the properties of the Turing object U in a Turing category is that every object is a retract of it. More explicitly, given any object A, there are morphisms ιA : A −→ U and ρA : U −→ A for which ρAιA = 1A. This forces ιA to be a total map (in fact, a monomorphism), but ρA can still be partial. We will typically denote the situation by A ≺ U , or by (ιA, ρA): A ≺ U if necessary.
We call an object U in a category universal if for every object A there exists a monomorphism ιA : A −→ U . (Thus we don’t ask that every object is a retract of U ; this is stronger, and will be analyzed in the section on abstract retract structures below.)
Lemma 3.2 In any Cartesian category X with a universal object U:
There is always an element ι1 :1 −→ U of the universal object;
There is always an embedding ιU×U : U × U −→ U;
The homset X(U, U ) either has one element, in which case X is trivial, or is inﬁnite.

A pair of disjoint elements
A Turing object U in a Turing category admits the interpretation of all combinatory logic terms. In particular, U has two global elements t = λ∗xy.x and f = λ∗xy.y. We shall prove that these two elements have the property of being disjoint in the sense that whenever th = fh for a map h, the domain h of h must be a strict initial object in the idempotent splitting. For the subcategory of total maps, this simply means that for any h with th = fh the domain of h is a strict initial object.
Proposition 3.3 In every Turing category the total maps have a universal object
U with a disjoint pair of elements.
Notice first that when the Turing category is trivial (in the sense that it is equivalent to the terminal category) all objects are strict initial objects, and hence all elements are disjoint. In general, in a Turing category, an element will be disjoint from itself only when the category is trivial as this forces the initial and final object to be the same.
We start by observing:
Lemma 3.4 Let X be a Cartesian category. A map h : H −→ 1 makes


h × 1
π1	f

H × A −−−−→ 1 × A −−→ A −−→ B
g
commute for all f, g : A −→ B if and only if H is a strict preinitial object.
Recall that an object H is called preinitial if there is at most one map from that object to any other object. It is strict preinitial if any object with a map to H is itself (strict) preinitial. Preinitial objects are quite common: for example in the category of (commutative) rings Z is the initial object, while Zn is preinitial for each n. However, neither Z nor Zn are strict preinitial.
Proof. Suppose x, y : H −→ A. Then:
x = xπ1⟨h, 1⟩ = xπ1(h × 1)Δ = yπ1(h × 1)Δ = yπ1⟨h, 1⟩ = y.
So H is preinitial. To show that it is strict, suppose that q : Q −→ H; then the above reasoning applies to qh, making Q preinitial.	2

Notice that if H is strict preinitial then, as H × Y
π
−−→ H, it follows that

H × Y is always strict preinitial. This means in a Cartesian category once one has one strict preinitial there must, for each object, be a preinitial with a map to that object. This does not imply there will be an initial object, but it does force that an initial object, if it exists, is automatically strict.
We are now ready to prove that the elements t and f in a Turing category are disjoint.

Lemma 3.5 In any Turing category, if h : H −→ 1 is a total map which equalizes t and f (as chosen above) then H is a strict initial object in the total map category. Thus the elements t and f are disjoint.
Proof. Suppose f, g : A −→ B are total maps. Without loss of generality we may assume A = B = U . Note that the diagram
1 × U 	π	 U¸

t×⟨f,g⟩
f×⟨f,g⟩
( z)
f	g
( z)

U × U × U 	 U¸
•(•×1)
commutes serially. But then precomposing with h × 1: H × U −→ 1 × U shows that h satisfies the conditions of the lemma above and so is a strict preinitial object. It remains only to show that there is a total map H −→ B for each object B. Each B is a retract of the Turing object and so the composite ιBρB : U −→ U is a split idempotent. As with any map in a Turing category, there is a code kB : 1 −→ U such that •⟨kB, 1⟩ = ιBρB, as in

•⟨kB,1⟩
While ρB may be partial, we argue that ρBh is total:
•⟨kB, 1⟩h = •⟨kBh, h⟩ = •⟨kh, h⟩ = •(k × 1)Δh = π0Δh = h
so that ιBρBh is total, whence ρBh is total.	2
It may be useful at this stage to provide an example of a total map category which has a universal object and yet cannot be the total maps of a Turing category. The simplest example, which also shows that such a category cannot consist entirely of preinitial objects, is when the category is a meet-semilattice. Then the only element is the identity on the top and this must be disjoint from itself, forcing the top to also be the bottom thereby collapsing the lattice.

An abstract retract structure
Recall that each object A in a Turing category comes equipped with (ιA, ρA): A ≺ U exhibiting it as a retract of the (chosen) Turing object. There may be many choices for this family of retractions although we shall assume that (ιU , ρU ) = (1U , 1U ). Below we describe how this structure introduces an analogous structure on the total map category.
First, consider a span between representable objects y(X) and y(Xj) in SetXop :


y(X) →−s− A −→t
y(Xj).

The apex A need not be representable, but we may consider the family of spans in
X arising by covering A by representables as follows:
£(s, t)= {X →s—h— B ——th→ y(Xj)|h : Y(B) —→ A}.

This family is then clearly closed under precomposition with maps in X. In fact, we may regard £(s, t) as a category whose objects are the spans in X factoring through (s, t), and whose morphisms are morphisms of spans.
Conversely, consider a family Y of spans in X from X to Xj which is closed under precomposition. For the present purposes, we shall call such a family an abstract span. Regarding Y as a category, we may consider the functor


j	Apex
Xop

Y —→ Span(y(X), y(X )) ————→ Set
p	q	j
which sends a span X →—— B ——→ X to the y(B). The colimit of this diagram gives
a span y(X) →— Yˆ —→ y(Xj) in SetXop . The proof of the following is now routine:

Lemma 3.6 The assignments (s, t) '→ £(s, t) and Y '→ Yˆ
(up to isomorphism of spans).
are mutually inverse

Next, we wish to characterize when the left leg of a span between representables is monic (so that it is a partial map). Call an abstract span Y deterministic when (p, q), (p, qj) ∈Y implies q = qj.
Lemma 3.7 Given an abstract span Y corresponding to a span y(X) →—s— Yˆ —→t
y(Xj) between representables, s is monic if and only if the spans in Y are deter- ministic.
Of course, in this situation Yˆ may be regarded as a sieve on X: it is precisely the sieve
Yˆ(Z)= {h : Z —→ X|(h, k) ∈Y for some k : Z —→ Xj}.
So far, we have described partial maps between representables in terms of abstract spans. Next, we wish to characterize when such a partial map is in fact a retraction

of a morphism ιA
: A —→ U . So suppose that in SetXop , we have a span y(X) ≥ S

—→t
y(Xj) which is a retraction of a map ι : Xj —→ X. This of course means that

ι ∈ S and t(ι) = 1X′ . In terms of the corresponding abstract span £, this means that (ι, 1) ∈£ and that for each (h, f ) ∈£ and each diagram
Xj ¸k,  P
ι	z
J	J	j
X ¸,  M 	 X¸
h	f

with the square commuting, we have fz = k. We shall refer to this condition by saying that the abstract span £ is retracting on ι. To summarize:

Lemma 3.8 Given a morphism ι : Xj —→ X in X and a span y(X) ≥ S —→t
y(Xj),

the span is a retraction of ι in Par(SetXop ) if and only if the corresponding abstract span contains (ι, 1) and is retracting on ι.
We are now ready for the main definition of this section:
Definition 3.9 An abstract retract structure on a Cartesian category with a universal object U consists of a choice of embeddings ιA : A —→ U (with ιU = 1U ) and, in addition, for each object A an abstract retraction of ιA, meaninga family of spans YA from U to A satisfying:
[RS.1] Each YA is closed under precomposition;
[RS.2] Each YA is deterministic;
ιA	1A
[RS.3] U →—— A ———→ A ∈ YA;
[RS.4] Each YA is retracting on ιA.
We shall indicate an abstract retraction pair by (ιA, YA): A ≺ U .
Here are some examples abstract retractions for a fixed morphism ιA : A —→ U .
Examples 3.1 (1) If Y is an abstract retraction, then YU is always just the family

U →—x— X
——x→ U. Indeed suppose U
→—h— Y
f
——→ U ∈ YU then by [RS.4]

h1Y = ιU h, so f = f 1X = h. Similarly, if ιA is an isomorphism then YA is
ιAx	x
always just the family U →——— X ——→ A.
The smallest retraction structure for each A is the one generated by the span
ιAx	x
(ιA, 1A). Each span in the abstract retraction is of the form U →——— X ——→ A;
this means the set is deterministic and retracting on ιA.
Suppose that ιA has a (total) retraction ρA. Then we may generate a retraction structure {(x, xρA)|x : X —→ U}. Note that when x = ιA we obtain the span
ιA	1A
U →—— A ———→ A. As all the spans have their right leg determined by the left
leg post-composed with ρA the set is deterministic.
Finally, consider a totalizing extension T : X —→ Y, in which U is a universal object. If, in Y, each object A is equipped with a retraction (ιA, ρA) : A ≺ U,
then we may consider the abstract span in X given by Y	h	f
A = {U →—— A ——→
A|ρAh = f}. This is readily seen to be an abstract retraction on ιA.
The last example shows in particular that whenever T is a Turing category with total map subcategory X, there is an induced abstract retract structure on X. For the record:
Lemma 3.10 Every Turing category induces, for any Turing object U and chosen retractions (ιA, ρA): A ≺ U, an abstract retract structure on its total map category.
Codes
A Turing object U in T is not only universal, but it also acts as a weak exponential for every pair of objects in the category. In particular, given f : A —→ B, there

exists a code c[f ]:1 —→ U making
U ×,U,
⟨c[f ],1⟩


 U,¸,
ιB

U	ρA	 A¸ f B¸

commute. Here, ρA and ιB are part of the chosen retractions A ≺ U and B ≺ U , and the morphism U × U ——•→ U is the universal application map. The code c[f ] is required to be total, but not unique. Choosing a code c[f ] for each f amounts to giving a family of mappings
c = cA,B : T(A, B) —→ T(1,U ).	(1)
Since the inclusion ιB is total, it in fact suffices to specify codes only for the case
B = U , that is, for maps A —→ U .
We will now translate this existence of codes to structure on the total maps. Since codes are formulated in terms of the retractions ρA, this involves dealing with the abstract retract structure on the total maps. We may cut down the mapping (1) to the total maps to obtain a mapping c = cA : X(A, U ) —→ X(1,U ), where X = Total(T).
To motivate the coming definition, first we need a bit of notation. Given a span

h	k	∗
hπX
kπX

U →—— X ——→ A we denote by Z (h, k) the span U →———— Z × X ————→ A, obtained
by precomposing each leg with the projection Z × X —→ X. When Y is a family of spans from U to A we will write Z∗Y = {(Z∗(h, k)|(h, k) ∈ Y}. Similarly, given f : A —→ U , we write f∗Y = {(h, fk)|(h, k) ∈ Y}.
Now consider two maps f : A —→ U and g : B —→ U with codes c[f ], c[g], and

suppose we have an object Z for which the unique total map Z —→!
1 equalizes c[f ]

and c[g]. Then as per example 3.1 (4), the a typical span in YA is of the form
U →—h— X ——k→ A satisfying k = ρAh. Given such (h, k), we may then consider the span
Z × X
πX

U ¸,	 J 
 ¸	 ¸

h	X	k
A	f	U

In the above notation, this is Z∗(fh, k) ∈ Z∗f∗Y. Under the given condition on Z, the composite fkπX factors as g ◦ (ρBhπX ), as shown by the following calculation:
fkπX = fρAhπX = f ρAπU (z × h)= •(cA[f ] × U )(z × h)
= •(cA[f ]z × h)= •(cB[g]z × h)= •(cB[g] × U )(z × h)
= gρBπU (z × h)= gρBhπX
Note that the statement that fkπX factors as indicated implies that Z∗(h, kf ) ∈ Z∗f∗YA can be regarded as a span of the form Z∗(h, gq) for (h, q) ∈ YB. By symmetry, this implies that Z∗f∗YA = Z∗g∗YB. Thus, informally speaking, when

restricting the abstract retractions to Z, the operations of composing with f and with g become equal.
This leads to the following:
Definition 3.11 A Cartesian category X with universal object U and retract struc- ture (ιA, YA) : A ≺ U has codes when there are maps cA : X(A, U ) —→ X(1,U )

such that whenever Z —→!
Z∗f∗YA = Z∗g∗YB.
1 satisfies c[f ]z = c[g]z for f : A —→ U, g : B —→ U then

The preceding discussion shows:
Lemma 3.12 The total map subcategory of a Turing category always has codes.

Building a Turing category from total maps
We shall now construct a PCA in X˜ which has all the total maps computable.
We use the notion of a “stack object”, which is an object satisfying two domain
equations which allow for the implementation of a rewriting system. Using the fact that X admits a trace, we may then define a universal application morphism which will equip the stack object with a PCA structure. From now on, assume X is a Cartesian category satisfying the conditions explained in the previous section.
Before we start, however, it is convenient to modify X a little. Recall that the Yoneda embedding does not preserve initial objects (if these happen to be present), but that there is always a subcanonical topology J on the category X which corrects this. (Simply take the smallest topology containing the empty cover on each initial
y
object of X.) This gives an embedding X ——→ Sh(X,J ) preserving any existing
initial object. For the rest of the paper, we will let X denote the full subcategory
of the partial map category on Sh(X,J ) on the representables. It will also be useful to assume that we have access to the splittings of restriction idempotents and to finite coproducts, thus it will be more convenient to work in Par(Sh(X,J )),

and to restricting to X representable objects.
by observing that the structures we build are always on

Another important property of a partial map category of a (pre)sheaf category (and hence also of X) is that it is traced on the coproduct: given f : X —→ X + Y there is a map f† : X —→ Y which is the joint of all the finite partial iterates: f† = i∈N f (i), where
f (1) = σ(—1)f : X —→ Y
f (2) = σ(—1)fσ(—1)f : X —→ Y
1	0
... 
f (n+1) = σ(—1)f (σ(—1)f )n : X —→ Y
1	0
where σ(—1) is the partial inverse of the ith coproduct injection. Intuitively, f† takes an input x ∈ X, and computes the iterates fi(x) for as long as the output lies in
X. Once the output lies in Y , this is the value of f†(x).

Stack objects
An object A in a distributive restriction category is said to be a stack object in case there are maps

put :1 + A × A —→ A	get : A —→ 1+ A × A	with put get = 11+A×A. Thus, a stack object can be indicated by (put, get):1 + A × A ≺ A.
Lemma 4.1 In any distributive restriction category the following are equivalent conditions for an object:
1 + 1 ≺ A and A × A ≺ A;
1 + A × A ≺ A (it is a stack object)
For any polynomial functor P, we have P (A)= n0.1+ n1.A + ... + nr.Ar ≺ A


The point is that in the universal extension X˜ of a category X satisfying the
requirements discussed above, we know the first condition for a stack object is
satisfied by the universal object U : indeed, U × U ≺ U because U × U is an object of X, and 1 + 1 ≺ U because U has two disjoint elements t, f : 1 —→ U , giving [t, f] : 1 + 1 —→ U . A partial retraction may be defined by letting S be the sieve on U generated by {t, f}, and by defining a natural transformation S ——σ→ 1+1 by σX (m) = inL(∗) whenever m factors through t, and inR(∗) otherwise. Note that this is well-defined precisely because t, f are disjoint, so that m factors through both t and f only when its domain is 0; but then (1 + 1)(0) is a singleton since 1 + 1 is assumed to be a sheaf.



A stack machine for partial combinatory algebras
We shall now use this trace to define a partial application A × A ——•→ A making A into a PCA. To this end, we will define a partial map step : A × A × A —→ A × A × A + A whose trace then is of the desired type. More precisely, we will define x • y := step†(x, y, []). The intuition that should be kept in mind is that the map step executes one step of a program/rewrite system, and that its trace runs the entire computation/rewriting sequence. The components of A × A × A will be regarded as a code stack, a value, and a dump stack, respectively. Only when the code is end and the dump stack is empty does the computation halt.
To define step, we use the domain equations for A to fix three different repre-

sentations of our stack object:

end, k, s :1 —→ A	k0, s0 : A —→ A	s1 : A × A —→ A	nam : A —→ A
(⟨end|k|s|k0|s0|s1|nam⟩, g0) : 1+1+1+ A + A + A × A + A ≺ A
c0 : A —→ A	c1 : A × A —→ A
(⟨c0|c1⟩, g1): A + A × A ≺ A nil :1 —→ A	cons : A × A —→ A (⟨nil|cons⟩, g2):1 + A × A ≺ A
Now we define step by the following case distinction:

The one aspect which needs explanation concerns how we use the names of maps. The aim is to implement them as the composite of a retraction to the idempotent and the map itself. (Recall that cA[f ] is a name for f relative to the embedding-retraction pair A ≺ U for which ρA : U —→ A is a retraction, as detailed in Section 3.4.) Without these names, the stack machine can be thought of as an implementation of the usual rewriting system on combinatory logic; adding the names of maps from X together with the given rule essentially amounts to adding rewrites cA[f ] • a —→ f (a) to the system.
The step partial function is the join of all its individual components. For step to be well-defined all these components must be compatible, in the sense that they agree on overlaps of domains. Those which are in separate components of the stack object by design are disjoint and so compatible. However, the names of maps are all in the same component and, thus, we must establish compatibility of the implementation of names.
Lemma 4.2 step is a well-deﬁned partial map in X˜ on the stack object U.

Proof. A typical span corresponding to a partial map U × U × U —→ U × U × U in the component of step which is defined on a tuple of the form (nam(cA[f ]), h, S) (for f : A —→ U , h : X —→ U ) looks like


⟨nam(cA[f ])!X , h,S⟩
⟨end,fk,S⟩

U × U × U →————————————— X ————————→ U × U × U
Here, (h, k) ∈ Y(A). Given another such span


⟨nam(cB[g])!X' , h′,S′⟩
U × U × U →——————————————— X
⟨end, gk′,S′⟩
—————————→ U × U × U


with g : B —→ U and (hj, kj) ∈ YB, we must show that these two spans are com- patible. This is done by considering generalized elements of z : Z —→ X and zj : Z
—→ Xj; we must verify that if ⟨nam(cA[f ]!X, h, S⟩z = ⟨nam(cB[g])!X′ , hj, Sj⟩zj, then also ⟨end!X,fk, S⟩z = ⟨end!X′ , gkj, Sj⟩zj It is clear that this holds for the last com- ponent. Thus we must show that if cA[f ]!Xz = cB[g]!X′ zj and hz = hjzj then fkz = gkjzj.
The first condition means cA[f ]!Z = cB[g]!Z which, by the requirement on codes, implies (hz, fkz) is in YBg. This implies (hz, fkz) = (hz, gv). But hz = hjzj, as YB is deterministic, now gives v = kjzj and so fkz = gv = gkjzj as required.  2
We are now ready for the main result:
Theorem 4.3 Given a Cartesian category X with a universal object, a pair of dis- joint elements and a retract structure with codes then the above deﬁnition of • in X gives a partial combinatory algebra; the subcategory of X on the computable maps is then a Turing category whose total maps are exactly the maps of X.
The proof consists of a verification that the combinators k and s indeed perform as required.
Proof. We first verify that k • x • y = x (where •, as usual, associates to the left). Here step(k, x, []) = σ0(end, k(x), []) has step(end, k0(x), []) = σ1(k0(x)) so that (k • x)= k0(x). But now
k0(x) • y = step†(k0(x), y, [])
⎧⎨ σ0(c, v, d) '→ step†(c, v, d) ⎫⎬

=
⎩ σ1(x)	'→ x
step(k0(x), y, [])
⎭

⎧⎨ σ0(c, v, d) '→ step†(c, v, d) ⎫⎬

σ1(x)

σ1(x)	'→ x
= x
which verifies that (k • x) • y = x.
Next, we need s • x • y to be as defined as x and y. But clearly s • x = s0(x) and
s0(x) • y = s1(x, y) so, as s1 is total this requirement of the combinator is met.
Next, we calculate

((s • x) • y) • z = s1(x, y) • z
= step†(s1(x, y), z, [])
⎧⎨ σ0(c, v, d) '→ step†(c, v, d) ⎫⎬




step(s1(x, y), z, [])

⎩ σ1(x)	'→ x	⎭
= step†(x, z, cons(c1(y, z), []))
= step†(end,x • z, cons(c1(y, z), []))
= step†(y, z, cons(c0(x • z), []))
= step†(end,y • z, cons(c0(x • z), []))
= step†(x • z, y • z, [])
= (x • z) • (y • z) Here we use repeatedly the identity:
step†(x, y, S)= step†(end, step†(x, y, []), S)= step†(end,x • y, S)
which is true by virtue of the fact that the trace is defined inductively. More precisely, we have

step(n)(x, y, s)=	.
i+j=n+1
step(i)(end, step(j)(x, y, []), s).

The left hand expression is empty unless the iteration terminates in that number of steps. If there is a (first) stage j at which the left hand iteration returns the stack to its original state and the first coordinate is end then j + 1 can be used to terminate the inner loop on the right hand side to bring the two iterations to the same state. Subsequently the result will be the same. If there is no such j both sides will be the empty map.	2
Applications
For many of the obvious applications we have proven much more than is actually needed. Here are two corollaries of our main theorem:
Proposition 5.1 Given a Cartesian category X in which
Every object has at least one element;
There is a universal object U;
There is a monic (set) map c :  A∈X X(A, U ) —→ X(1,U );
There is a faithful product preserving functor into U : X —→ Set.
Then X occurs as the total maps of a Turing category.
These conditions include the PTIME maps between binary natural numbers:
Corollary 5.2 The PTIME maps between binary numbers occur as the total maps of a Turing category.

In fact, one may use a linear time pairing operation on binary numbers by setting, for example, the pairing of b1 ··· bk and c1 ··· cn to be b1b1 ··· bkbk01c1c1 ··· cncn. This means we also have:
Corollary 5.3 The linear time maps between binary numbers occur as the total maps of a Turing category.
Another class of examples is contained in the following:
Proposition 5.4 Any countable Cartesian category with a universal object and a pair of disjoint elements is the total maps of a Turing category.
Here we observe that once one has two distinct elements the fact that one has a stack object allows one to easily obtain countably many distinct and disjoint elements. This means that there is a monic assignment of maps to elements and one can use the smallest abstract retractions.
Conclusion
To unify the abstract notion of computability embodied in Turing categories with the study of feasible computation (e.g. LINEAR, LOGSPACE, PTIME, ...) min- imally one must know whether these functional complexity classes can form the total maps of a Turing category. In [3] it was shown that both LOGSPACE and PTIME functions had a natural description as the total maps of Turing categories. However, in order to obtain those results, it was necessary to use the well-known facts from complexity theory that transducers and Turing machines can universally simulate themselves with an overhead which can be accommodated within (respec- tively) LOGSPACE and PTIME. This meant the argument that these complexity classes could be modelled by Turing categories relied heavily on the details of the machine models and the way in which resources were measured. In particular, as there is no widely accepted machine model which can simulate itself with a lin- ear time overhead, the linear time maps could not be so readily included in this approach.
The power of the results outlined in this paper is, precisely, that they are ab- stract. That is, they do not depend on the peculiarities of machine models or on the way resources are counted.
By describing necessary and sufficient conditions for a Cartesian category to be the total maps of a Turing category we have demonstrated that, perhaps somewhat counterintuitively, Turing categories are applicable beyond the traditional confines of combinatorial completeness into feasible computation and the domain of complex- ity theory. In this regard Turing categories, therefore, provide – by more than mere analogy – a medium for the transfer of ideas between computability and complexity theory and thus for a potential economy of presentation which may be beneficial to the further development of the subject. Finally, we believe the methods employed in establishing the results in this paper are yet another strong indication that a complete understanding of the categorical aspects of computability and complexity

necessarily involves the study of partial combinatory algebras in categories other than Set.

References
J.R.B. Cockett, Categories and computability. Lecture notes available at http://pages.cpsc.ucalgary.ca/ robin.
J.R.B. Cockett and P.J.W. Hofstra, Introduction to Turing categories Annals of Pure and Applied Logic, Volume 156, Issues 2-3, December 2008, Pages 183-209.
J.R.B. Cockett, J. Diaz-Bo¨ıls, J. Gallagher and Pavel Hrubeˇs Timed Sets, Functional Complexity, and Computability . Electronic Notes in Theoretical Computer Science, Volume 286, September 2012, Pages 117137.
J. R. B. Cockett and S. Lack, Restriction categories I: categories of partial maps. Theoretical Computer Science 270(1-2): 223-259, 2002.
S. Cook and P. Nguyen, Logical Foundations of Proof Complexity. In: Perspectives in Logic, Cambridge University Press, 2010.
R. Di Paola and A. Heller, Dominical categories: recursion theory without elements. Journal of Symbolic Logic, Volume 56,1987.
