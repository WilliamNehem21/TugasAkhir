	Electronic Notes in Theoretical Computer Science 203 (2008) 123–133	
www.elsevier.com/locate/entcs
Sub-λ-calculi, Classified
Fran¸cois-R´egis Sinot
Universidade do Porto (DCC & LIACC) Rua do Campo Alegre 1021–1055 4169–007 Porto, Portugal

Abstract
When sharing is studied in the λ-calculus, some sub-calculi often pop up, for instance λI or the linear λ-calculus. In this paper, we generalise these to a large class of sub-calculi, parametrised by an arbitrary predicate on the number of occurrences of bound variables. Such a definition only makes sense when the sub- calculi are stable by β-reduction. Surprisingly, we are able to give a complete description and classification of such stable sub-calculi, in a rather algebraic way; and surprisingly again, we discover some unexpected such subcalculi. This could lead to a better understanding of the structure of the λ-calculus.
Keywords: λ-calculus, sharing, linearity

1	Introduction
Sharing is an important but difficult issue, in particular in the λ-calculus. Some- times, in order to simplify the problem or tackle it in a more focused way, attention is restricted to a particular subsystem of the λ-calculus. Such subsystems include λI, where erasing is forbidden, or the linear λ-calculus, where each bound variable occurs exactly once [1]. These subsystems are defined by imposing some uniform restrictions on the number of occurrences of bound variables.
In this paper, we propose to generalise this idea and study in a systematic way such sub-calculi. Motivation for doing this is to try to understand better the structure of the λ-calculus, which is always useful and may have unexpected applications. At present however, it is essentially a nice exercise in pure λ-calculus. More precisely, we will define the notion of sub-calculus in a generic setting, and argue that, in order for this definition to make sense, such a system has to verify a certain property, namely stability by β-reduction (Section 3). We will then focus our attention on a concrete class of sub-calculi, parametrised by arbitrary predicates on the usage of resources (number of occurrences of bound variables), and study stability in this setting (Sections 4 and 5). This will lead us to a complete
classification of these subcalculi in Section 7.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.038

For self-containment, we recall here some of the few prerequisites of the technical part of this paper. We will be concerned with the λ-calculus, so it makes sense to recall first some general notions on reduction systems (see [4] for a good reference). An abstract reduction system (ARS) is just a pair (A, →) where A is a set (called the set of objects) and → is a binary relation on A (called the reduction). We write t → u if (t, u) ∈ →. The reflexive transitive closure of → is →∗, and ← is the inverse relation of →. A normal form is a t ∈ A such that there exists no u such that t → u.
The λ-calculus is then an ARS (Λ, →β), where the set of λ-terms Λ is defined by the following grammar (quotiented by α-conversion i.e. renaming of bound vari- ables, avoiding captures):


and β-reduction is defined by:
t, u ::= x | λx.t | t u 


(λx.t) u →β t{x := u}


where t{x := u} denotes t where all occurrences of x are replaced by u, without name capture. We refer the reader to [1] for more details.

General Sub-calculi
We will very soon (in Section 4) turn to the study of a certain concrete family of sub-λ-calculi, but there are also a few general observations that we can make first in a general setting.
In the framework of abstract reduction systems, the most general definition of a sub-system is to restrict both the set of objects and the reduction. But it also makes sense to adopt a more constrained definition and restrict only the set of terms, without touching the reduction (see [4, Def. 1.1.6]). In this paper, focused on the λ-calculus, this last choice is better-suited: we do not want to mess up with β-reduction, and, for instance, have β-redexes which are not redexes in the subsystem. We view the restriction of reduction as an orthogonal aspect, related to strategies, which could be interesting to combine with our approach, but that we do not deal with in this paper for the sake of clarity.
But there is another issue. Let Σ ⊆ Λ be an arbitrary set of λ-terms. Does it always make sense to say that (Σ, →β) is a sub-calculus ? Imagine there is a t ∈ Σ such that t →β u: clearly, we must require also that u ∈ Σ. In other words, a sub-λ-calculus must be closed under β-reduction. Equivalently, we will say in this
paper that it must be stable (by β-reduction). Be careful: there are many other
meanings to stability in the literature.
Definition 3.1 A set of λ-terms Σ is said to be stable if it is closed under β- reduction, i.e. if whenever t ∈ Σ and t →β u, then u ∈ Σ.

Definition 3.2 Let Σ ⊆ Λ be a stable set of λ-terms. The λΣ-calculus is defined as the ARS (Σ, →β).
Every λΣ-calculus is a sub-λ-calculus, and conversely every sub-λ-calculus is a λΣ-calculus for some stable Σ ⊆ Λ. A set of λ-terms thus defines a sub-λ-calculus if and only if it is stable. In other words, the study of sub-λ-calculi is essentially a study of stability of sets of λ-terms.
Starting from Section 4, we will focus our attention on a certain family of sub-λ- calculi, but we may still notice that there are some interesting sub-λ-calculi outside of this family.

Example 3.3 Let I = λx.x and Σ = {I} 

t,u∈Σ
(t u) the set of terms built from

the identity and the application, then Σ is stable.
Proof. Consider t ∈ Σ. If there is a redex in t, it is of the form I u →β u with u in Σ, and it is clear that the reduct is in Σ.	 
Example 3.4 The set of simply typable λ-terms [2] is stable. More precisely, let
A be a simple type, then the set of λ-terms of type A is stable.
Proof. This is just a paraphrase of subject reduction.	 Example 3.5 Let SN ⊆ Λ be the set of strongly normalising terms, SN is stable. Proof. If t ∈ SN and t →β u, then clearly u ∈ SN.	 
It is well-known that, with the definition we have chosen, sub-calculi inherit properties from the full system [4], for instance:
Theorem 3.6 If Σ ⊆ Λ is stable, the λΣ-calculus is confluent.
Proof. Assume u1 ∗ ← t →∗ u2 in the λΣ-calculus. Then there exists a λ-term v
β	β
such that u1 →∗ v ∗ ← u2, by confluence of the λ-calculus, and v is a λΣ-term by
β	β
stability of Σ.	 
In this general setting, we do not have any tool to decide if a given Σ ⊆ Λ is stable or not, but we can combine stable subsets:
Proposition 3.7 If Σ1 and Σ2 are stable, then Σ1 ∩ Σ2 and Σ1 ∪ Σ2 are stable.
Proof. For the intersection, assume t →β u with t ∈ Σ1 ∩ Σ2, then u ∈ Σ1 and u ∈ Σ2, hence u ∈ Σ1 ∩ Σ2. For the union, assume t →β u with t ∈ Σ1 ∪ Σ2, then either t ∈ Σ1 and u ∈ Σ1 ⊆ Σ1 ∪ Σ2, or t ∈ Σ2 and u ∈ Σ2 ⊆ Σ1 ∪ Σ2.	 
We also introduce a last way to build a stable set, by “stabilising” an arbitrary set. The notion of stable closure is quite folklore. It will be used mainly in Section 8.

Definition 3.8 Let Σ ⊆ Λ, we define the stable closure of Σ, written Σ, as the smallest stable set of terms such that Σ ⊆ Σ.

Resourced Sub-calculi
Our purpose is to study subsystems of the λ-calculus. The most general way to define them has been mentioned in the previous section, but this representation is too general to be interesting: for instance, there is little hope to obtain a nice characterisation theorem in such a general setting. We thus focus our attention on the following, more restricted class of subsystems, which is parametrised by an arbitrary predicate on the number of occurrences of bound variables. We start with a definition.
Definition 4.1 We define the number of free occurrences of a variable x in a λ-term t, written |t|x, as follows:
|x|x = 1 
|y|x = 0 
|t u|x = |t|x + |u|x
|λx.t|x = 0 
|λy.t|x = |t|x

Remark that, for a given variable x, |·|x is well-defined on α-equivalence classes (i.e. if t =α u then |t|x = |u|x).
We may now define the following, more restricted class of sub-λ-calculi.
Definition 4.2 If P is a predicate on natural numbers, we define the set of λP - terms as follows:

t, u ::= x | tu 
| λx.t	if P(|t|x)
We also define the λP -calculus as the set of λP -terms equipped with β-reduction
→β (when this set is stable, we will discuss this further in Section 5). We also simply say that P is stable whenever the set of λP -terms is stable. Following usual conventions, λP alone means either the set of terms or the calculus (which justifies apparent pleonasms of the form “λP is stable”).
It makes sense to impose that P(|t|x) holds for every free variable x of an open term t (we will call this the strict convention). However, this entails some unpleasant syntactic accidents, as will be shown later. These accidents would disappear if we added (unconstrained) constants. However, the pure λ-calculus view of constants is exactly as free variables, which should thus be unconstrained. Consequently, we always assume the relaxed convention, unless otherwise stated: we do not impose that P(|t|x) holds if x is a free variable of an open term t.
¿From now on, operations on propositions are always implicitly lifted to pred- icates, which means that, for instance, if P and Q are predicates, P ∧ Q is the predicate defined by, for all n, (P∧Q)(n) = P(n) ∧ Q(n). In the same spirit, ⊥ and T denote the predicates which are constantly false and true, respectively. Moreover,

P, Q, implicitly denote predicates on natural numbers. We also allow the definition of predicates by partial application of infix binary predicates, in a Haskell-like style,
e.g. (≥ 3) is the predicate defined by, for all n, (≥ 3)(n) = (n ≥ 3). It is natural to wonder how well P characterises λP .
Proposition 4.3 (λP ⊆ λQ) ⇐⇒ (P ⇒ Q).
Proof.
⇒ Assume n ≥ 1 and P(n). We can build the term t = λx. `x .˛.¸. xx ∈ λP ⊆ λQ.
Then t ∈ λQ, hence Q(n), by definition of λQ. For the case n = 0, we use instead t = λx.z where z is a free variable (remember that we assume the relaxed convention).
⇐ Assume t ∈ λP and let λx.u be a subterm of t. By definition of λP , P(|u|x) holds, and so does Q(|u|x). Since this holds for every sub-abstraction of t, we may conclude t ∈ λQ.
 
Remark 4.4 The left-to-right implication is false under the strict convention with- out constants, for instance λ⊥ = λ(=0) = ∅.
In particular, an immediate corollary of Proposition 4.3 is that λP = λQ if and only if P ⇔ Q. In other words, P exactly characterises λP .
In this framework, it is worth stating the following syntactic properties.
Theorem 4.5 If P is stable, the λP -calculus is confluent.
Proof. Consequence of Theorem 3.6.	 
Theorem 4.6 If P is stable, the λP -calculus is strongly normalising if and only if
P(n) does not hold for any n ≥ 2.
Proof. If P(n) does not hold for any n ≥ 2, the λP -calculus is a subsystem of λ(≤1), i.e. the affine λ-calculus, which is strongly normalising. Conversely, assume that P(n) holds for some n ≥ 2. Then we can build the non-normalising λP -term (λx. x . . . x) (λx. x . . . x).	 
`˛n¸ x	`˛n¸ x
Characterising Stability
The notion of λP -calculus only makes sense when the set of λP -terms is stable, hence stability is an important notion. Let us test on an example if it also easy to handle.
Example 5.1 The linear λ-calculus λ(=1) is stable.
Proof. Consider an arbitrary β-reduction starting from a linear λ-term:
t0 = C[(λx.t) u] →β C[t{x := u}] = t1

Consider a subterm λy.v1 of t1. It is the residual of a subterm λy.v0 of t0. There are three cases:
it is a subterm of u: then v1 = v0, and |v1|x = 1;
it is a subterm of t: then v1 = v0{x := u}, but y is not free in u (otherwise it would be captured), and |v1|y = |v0{x := u}|y = |v0|y = 1;
it is a superterm of the whole redex, then there are three subcases: if the unique occurrence of y is outside the redex; if it is in t; or if it is in u. The two first cases are easy; for the last one we use |t|x = 1. In each case, we conclude |v1|y = 1.
 
The proof is not difficult, but it is tedious. Fortunately, we can characterise stability in a slightly more practical way.
Lemma 5.2 P is stable if and only if
∀m ≥ 0,n ≥ 0, 0 ≤ k ≤ n. (P(m) ∧ P(n) =⇒ P(n + k · m − k)) .

Proof. First remark that, with the notations of the lemma, n + k · m − k ≥ 0, because n − k ≥ 0 and k · m ≥ 0. Let’s consider an arbitrary β-reduction under an arbitrary binder (if the reduction is not under a binder, this is irrelevant to the kind of conditions we have or easy to deal with):

λy.C[(λx.t) u] →β λy.C[t{x := u}].

Let us write m = |t|x, n = |C[(λx.t) u]|y and k = |u|y . We thus have |C[t]|y = n − k and |C[t{x := u}]|y = n + k · m − k. The reduct thus belongs to λP if and only if P(n + k · m − k) holds for all n and k (corresponding to every choice of outer binder λy). Indeed, P is stable if and only if P(n + k · m − k) holds whenever P(m) and P(n) hold.	 
Theorem 5.3 P is stable (i.e. the λP -calculus is well-deﬁned) if and only if
∀m ≥ 0,n ≥ 1. (P(m) ∧ P(n) =⇒ P(m + n − 1)) .

Proof. Using Lemma 5.2 and the fact that the other implication is trivial, we assume that ∀m ≥ 0,n ≥ 1. (P(m) ∧ P(n) =⇒ P(m + n − 1)) and we only have to show that P(n + k · m − k) holds if m ≥ 0, n ≥ 0, 0 ≤ k ≤ n, P(m) and
P(n). If n = 0, this is trivially true, because k = 0, thus n + k · m − k = 0, and P(0) = P(n) holds by hypothesis. We may thus assume n ≥ 1, and we prove the statement by induction on k. If k = 0, it is true because n + k · m − k = n and P(n) holds by hypothesis. Let 0 ≤ k ≤ n − 1 and assume P(n + k · m − k) holds. Then, P(n + (k + 1) · m − (k + 1)) = P(m + (n + k · m − k) − 1) holds using the assumption, the induction hypothesis, and the fact that n + k · m − k ≥ 1 because k ≤ n − 1 and k · m ≥ 0. We indeed conclude that the statement holds for all k such that 0 ≤ k ≤ n.	 

Examples
Example 6.1 We use Theorem 5.3 to recover some well-known stability results.
λT (aka. the λ-calculus) is stable;
λ(=1) (aka. the linear λ-calculus) is stable;
λ(≥1) (aka. λI) is stable;
λ(≤1) (aka. the affine λ-calculus) is stable.
Proof. We only show the proof for λ(≥1). Assume m ≥ 1 and n ≥ 1, then m + n − 1 ≥ 1+1 − 1 = 1. Using Theorem 5.3, we conclude that (≥ 1) is stable. The proof shows that 1 plays a special role in this framework.	 
Example 6.2 There are also some less usual sub-calculi, with a more questionable computational content.
λ⊥ (where there is no λ-abstraction) is stable (under the strict convention, this calculus is empty);
λ(=0) (where there is no occurrence of bound variables) is stable (under the strict convention, this calculus is empty);
λ(≥2) is stable;
more generally, if b ≥ 1, λ(≥b) is stable;
however, if b ≥ 2, λ(≤b) is not stable.
Proof. The first two sub-calculi are degenerated, which is evidenced by the fact that the condition in Theorem 5.3 is true because the premises of the implication can never be satisfied. Let b ≥ 1, we verify that λ(≥b) is stable. Let m ≥ b and n ≥ b, then m + n − 1 ≥ 2 · b − 1 ≥ b, since b − 1 ≥ 0. Thus λ(≥b) is stable.	 
Using Theorem 5.3, we give some non-trivial sub-calculi (or non-sub-calculi) of the λ-calculus (of course only those of the form λP for some P).
Example 6.3 Let odd(n) = (∃k ≥ 0.n = 1 + 2 · k), then odd is stable. The “odd calculus” λodd is a simple, non-trivial sub-λ-calculus.
Proof. Assume odd(m) and odd(n). Then, there exist k, k' ≥ 0 such that m = 1+2 · k and n = 1+2 · k'. Then m + n− 1 = (1+2 · k)+(1+2 · k') − 1 = 1+2 · (k + k') with k + k' ≥ 0, and indeed odd(m + n − 1) holds.	 
Remark 6.4 The “even calculus” λeven defined by even(n) = (∃k.n = 2 · k) is not stable (we are therefore reluctant to call it a calculus). This can be seen as a consequence of Theorem 5.3 or directly: λy.((λx.x x) y y) →β λy.y y y.
In fact, the previous example can be generalised to the following large class of sub-λ-calculi.
Example 6.5 Let q ≥ 1 and multq(n) = (∃k ≥ 0.n = 1+k· q), then λmultq is stable.

Proof. Similarly, using (1 + k · q)+ (1+ k' · q) − 1 = 1+ (k + k') · q.	 
We will see in Sections 7 and 8 that essentially all λP -calculi can be decomposed in calculi of this form.

Classification
With Theorem 5.3 in hand, we characterise further the sub-calculi of the λ-calculus (of the form λP for some stable P).
Proposition 7.1 If P and Q are stable, then P∧ Q is stable.
Proof. Consequence of Proposition 3.7 and of the fact that λP∧Q = λP ∩ λQ, or using Theorem 5.3.	 
Remark 7.2 If P and Q are stable, P∨ Q is not necessarily stable.
Proof. First, we notice that we cannot use Proposition 3.7, because in general λP ∪λQ Ç λP∨Q. Let P(n) = (∃k ≥ 0.n = 1+2·k) and Q(n) = (∃k ≥ 0.n = 1+3·k). According to Example 6.5, P and Q are stable. (P∨ Q)(3) holds since P(3) holds, (P∨Q)(4) holds since Q(4) holds, but (P∨Q)(3 +4 − 1) = (P∨Q)(6) does not hold since neither P(6) or Q(6) holds. In other words, P ∨ Q is not stable. A concrete witness illustrating this is λy.((λx.x x x) yyy y) →β λy.y yyyy y.	 
Proposition 7.3 If P is stable and P(2) holds then P(n) holds for all n ≥ 2.
Proof. By induction on n ≥ 2. P(2) holds by hypothesis. Assume P(n) holds, then using Theorem 5.3, P(n + 1) = P(n +2 − 1) also holds.	 
Proposition 7.4 If P is stable and if P(0) and P(n) hold for some n ≥ 2, then
P(n) holds for all n ≥ 0. In other words, we get the full λ-calculus.
Proof. We show that P(k) holds for 0 ≤ k ≤ n by reverse induction on k. P(n) holds by hypothesis. Let 1 ≤ k ≤ n and assume that P(k) holds. Then P(k − 1) = P(0 + k − 1) holds using Theorem 5.3, stability of P, the induction hypothesis, and the facts that k ≥ 1 and P(0) holds. In particular, P(2) holds and we use Proposition 7.3.	 
The two previous propositions are somehow analogous to the decomposition in combinators of interaction nets [3], a popular sharing-sensitive framework, well- suited to implement the λ-calculus. Although we do not learn anything new or surprising here, this shows that our framework is adapted to formalise that kind of folklore, but otherwise informal, theorems about sharing issues.
As evidenced in Remark 7.2, disjunction is not a well-behaved operation with respect to stability. However, the following proposition exhibits the particular be- haviour of 1, and tends to show that, to some extent, the choice of P(1) is not relevant for the stability of P.
Proposition 7.5	(i) If P is stable, then P∨ (=1) is stable;

(ii) if P∨ (=1) is stable and not everywhere true, then P is stable.
Proof.
Assume P is stable, (P∨(=1))(m) and (P∨(=1))(n). If m = 1, then m+n−1 = n and (P ∨ (=1))(m + n − 1) holds; and similarly if n = 1. Otherwise, both P(m) and P(n) hold, and (P∨ (=1))(m + n − 1) indeed holds.
Assume P∨ (=1) is stable, P(m) and P(n) hold. Then (P∨ (=1))(m + n − 1) holds. Either P(m + n − 1) holds and we are done, or m + n − 1 = 1, hence m = n = 1 and P(1) holds, because the case m = 0 and n = 2 is excluded by Proposition 7.4.
 
Lemma 7.6 If P is stable and there exists n ≥ 2 such that P(n) holds, then there exists q ≥ 1 such that P(1 + k · q) holds for every k ≥ 1.
Proof. With the notations of the lemma, let q = n − 1. We prove by induction on k ≥ 1 that P(1 + k · q) holds. This is true for k = 1. Assume P(1 + k · q) holds, n + (1+ k · q) − 1 = 1+ (k + 1) · q and P(1 + (k + 1) · q) holds, using Theorem 5.3. 
We now have everything in hand to exhibit a complete classification of the λP - calculi.
Theorem 7.7 P is stable if and only if one of the following holds for all n:
P(n) ⇔ ⊥;
P(n) ⇔ T;
P(n) ⇔ (n = 0);
P(n) ⇔ (n = 0 ∨ n = 1);
there exist 0 ≤ p ≤ ω and 1 ≤ q1 < . . . < qp pairwise non divisible such that:
P(n) ⇔ (∃k1,..., kp ≥ 0.n = 1 + Σ1≤i≤p ki · qi);
there exist 1 ≤ p ≤ ω and 1 ≤ q1 < . . . < qp pairwise non divisible such that:
P(n) ⇔ (∃k1,..., kp ≥ 0, 1 ≤ j ≤ p.kj ≥ 1 ∧ n = 1 + Σ1≤i≤p ki · qi).
Moreover, this decomposition is unique.
Proof. If one of the cases (i–iv) holds, it has already been noted in Section 6 that P is stable. If (v) or (vi) holds, this is a consequence of Theorem 5.3, similar to Example 6.5. Conversely, suppose P is stable. We distinguish cases according to whether or not P(0) holds.
If P(0) holds, does there exist n ≥ 2 such that P(n) holds ?
If there is such a n, we are in case (ii), thanks to Proposition 7.4.
Otherwise, we are indeed in case (iii) or (iv).
If P(0) does not hold, we look at P(1).
If P(1) holds, we prove by induction on p ≥ 0 that there exist 1 ≤ q1 < . . . < qp
pairwise non divisible such that (∃k1,..., kp ≥ 0.n = 1+Σ1≤i≤p ki · qi) ⇒ P(n).
This is true for p = 0.  Assume this is true for some p, and consider the

smallest n not equal to (1 + Σ1≤i≤p ki · qi) for some k1,..., kp ≥ 0 such that P(n) holds. There are two cases. If there is no such n, that means that the condition is verified and P is fully described. Otherwise, let qp+1 = n − 1. Indeed, by construction, qp+1 > qp and none of q1,..., qp is a divisor of qp+1. Thanks to Theorem 5.3 and in a similar way to Lemma 7.6, for all kp+1 ≥ 0, P(1 + kp+1 · qp+1).  Then, using again Theorem 5.3, the statement holds for
p + 1. If the process stops, the equivalence is clear. If it does not, let’s write
Pp(n) = (∃k1,..., kp ≥ 0.n = 1 + Σ1≤i≤p ki · qi). For all p, Pp ⇒ Pp+1 ⇒ P 
where the first implication is strict. The sequence (Pp)p is strictly increasing
and bounded, it thus has a limit Pω. There is no n such that P(n) but not
Pω(n), because this would contradict the construction. We conclude P ⇔ Pω.
· If P(1) does not hold, let’s consider the smallest n ≥ 2 such that P(n) holds. If there is no such n, we are in case (i). Otherwise, we can proceed as in the previous case, starting at p = 1, with q1 = n − 1, and obtain case (vi).
Unicity is clear: the different cases do not overlap, and in cases (v) or (vi), the non-pairwise divisibility of q1,..., qp ensures that there is no redundancy.	 
Remark 7.8 Theorem 7.7 gives a complete classification of the λP -calculi in terms of equality, but this is not necessarily the “best” description. For instance, we have seen that (≥ 3) is stable, but its description using Theorem 7.7 is case (vi) with p = ω and qi is the i-th prime number. In particular, it is not a finite description.

Alternative Presentation
Theorem 7.7 gives a complete description of the λP -calculi. It also incites us to look more closely at the apparently more interesting cases, namely cases (v) and (vi). Let us focus on case (v), which means that we restrict our attention to predicates P such that P(1) holds but P(0) does not. All results in this section hold only for this restricted class.
As we have seen, disjunction is not well-behaved with respect to stability. Let us then introduce a well-behaved notion.

Definition 8.1 We define the sum of two predicates: P⊕ Q = P∨ Q.
Definition 8.2 We say that P is irreducible if there are no Q1, Q2 such that
P = Q1 ⊕ Q2.
Definition 8.3 We define the qth elementary predicate q by for all n ≥ 0, q(n) = (∃k ≥ 0.n = 1 + k · q). It is just a new name for multq.
Lemma 8.4 (p ⊕ q)(n) = (∃k1, k2 ≥ 0.n = 1 + k1 · p + k2 · q)
Corollary 8.5 k · p ⊕ p = p. In particular 1 ⊕ p = 1 and 0 ⊕ p = p.
Notice that, in general, we do not have p ⊕ q = gcd(p, q), where gcd(p, q) is the greatest common divisor of p and q. This is because everything is positive, and we cannot “go backwards”.

We can then reformulate Theorem 7.7 for the specific class under study in this section, in the following way:
Theorem 8.6 The irreducibles are exactly the q’s for q ≥ 0.
Theorem 8.7 Every P can be decomposed in a sum of irreducibles, and there is a canonical such representation.
We may also complete the structure with the corresponding product ⊗ = ∧. Then p ⊗ q = lcm(p, q), where lcm(p, q) is the least common multiple of p and q, hence there is no duality between ⊗ and ⊕.
In brief, we have essentially paraphrased previously stated results, in a less gen- eral way. Yet, this paraphrase exhibits an intriguing structure, which does not seem to be directly related to well-known algebraic structures. This should probably be taken as a hint that either this structure is interesting and deserves a thorough study, or there is an interesting structure on top of it that should suggest an interesting generalisation of the notion of subcalculus.
Conclusion
We have defined and given a complete characterisation of a class of subsystems of the λ-calculus taking into consideration the number of occurrences of variables, which is a crucial issue for sharing. We recover well-known calculi such as λI or the linear λ-calculus, but we also discover unconventional calculi whose interest as a computational model remains to study. Moreover, our characterisation is very algebraic and we hope that it will lead to a better understanding of the λ-calculus and its subsystems.
Acknowledgement
This article has benefited from comments by several anonymous referees.

References
Barendregt, H. P., “The Lambda Calculus: Its Syntax and Semantics,” Studies in Logic and the Foundations of Mathematics 103, North-Holland Publishing Company, 1984, second, revised edition.
Barendregt, H. P., “Lambda Calculi With Types,” Handbook of Logic in Computer Science 2, Oxford University Press, 1992, 117–309 pp.
Lafont, Y., Interaction combinators, Information and Computation 137 (1997), pp. 69–101.
Terese, “Term Rewriting Systems,” Cambridge Tracts in Theoretical Computer Science 55, Cambridge University Press, 2003.
