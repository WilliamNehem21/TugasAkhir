	Electronic Notes in Theoretical Computer Science 202 (2008) 255–265	
www.elsevier.com/locate/entcs
Finitely Bounded Effective Computability
Xizhong Zheng1,2
Department of Computer Science, Jiangsu University Zhenjiang 212013, P.R.China.
Theoretische Informatik, BTU Cottbus D-03044 Cottbus, Germany

Abstract
One of the most important property of the computability is the certainty. For example a set of natural numbers is computable if there is a Turing machine which decides certainly if a given natural number belongs to the set or not, and no wrong answers are tolerant. On the other hand, the finitely bounded computability discussed in this paper allows finitely many mistakes which can be eventually corrected during an effective procedure. We will show especially that the class of finitely bounded computable real numbers has very interesting properties, and it is a real closed field containing even properly in the class of d-c.e. real numbers.
Keywords: Computable real numbers, D-c.e. real numbers, Bounded computability, Hierarchy.


1	Introduction
In computability theory, computable objects are described by effective procedures like Turing machines. These effective procedures do not make mistakes. For ex- ample, a set A of natural numbers is computable means that there is a Turing machine which decides, for any given natural number n, if n ∈ A holds or not. And a real number x is computable if there is a Turing machine which, for any given natural number n, computes a rational approximation xn to x within the given error bound 2−n. In all these cases, the individual results produced by the effec- tive procedure cannot be corrected anymore after they have been achieved. In this sense the computability requires certainty. In practice, however, this ideal prop- erty is very difficult to be guaranteed. A more common and reasonable scenario in real world is that mistakes may occur, but the numbers of possible mistakes can be bounded somehow. This observation motivates the investigation of finitely bounded computability.

1 The author is supported by DFG (446 CHV 113/240/0-1) and NSFC (10420130638).
2 Email: zheng@informatik.tu-cottbus.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.019

Actually, the well-known k-c.e. (k-computably enumerable) sets of natural num- bers for constant k are good examples of finitely bounded computable objects men- tioned above. By definition a set A is c.e. if it has a computable enumeration which enumerates all its elements one after another. In other words, there is an effective procedure which puts all its elements into A. “Try and correct” is not allowed in this case. On the other hand, if there is an effective procedure which enumerates all elements of a set A in which up to k corrections for each element are allowed, then A is k-c.e. This can be more precisely called k-bounded computably enumer- able. Analogously, if the characteristic function χA of a set A can be computed by a Turing machine in which up to k-corrections of the outputs are allowed for any input, then we can achieve naturally the notion of k-bounded computable sets.
Similarly, for any computable real number x, we have a computable sequence (xs) of rational numbers which approximates x effectively in the sense that the distance between the s-th approximation xs and x is bounded by 2−s for all s. Namely, there is an effective procedure which, for any input s, outputs a rational approximation to x within the error bound 2−s. If, for any error bound 2−s, up to k exceptions to this condition are allowed, then the limit is called k-bounded effectively computable or simply k-effectively computable (k-e.c.), and x is called bounded effectively computable (bec) if it is k-e.c. for some constant k. We will see that, for different constant k we have a proper hierarchy of k-c.e. real numbers. More interestingly, the class of bounded effectively computable reals forms a very interesting class of real numbers. It is closed under arithmetical operations and total computable real functions.
Our paper is organized as follows. In section 2 we discuss the sets of natural numbers of bounded effective computability. The bounded effective computable real numbers are introduced and investigated in section 3. The last section 4 discusses the Turing degrees related to the effective bounded computable real numbers.

2	Bounded Computable Sets
The first version of finitely bounded computability comes from the k-computable enumerability for the constants k. By definition, a set A of natural numbers is computably enumerable (c.e., for short) if it has a computable enumeration (As) which is a computable sequence of finite sets such that A0 = ∅, As ⊆ As+1 for all s and lims→∞ As = A. Intuitively, A is c.e. if there is an effective procedure which enumerates all elements of A. The computable enumerability has been generalized by Putnam [5], Gold [3] and Ershov [2] to the k-computable enumerability as follows: A set A is k-computably enumerable (k-c.e., for short) if there exists a k-computable enumeration of A which is a computable sequence (As) of finite sets such that and

​
​
As = ∅ & lim As = A, and
s→∞
(∀n) (|{s : As(n) /= As+1(n)}| ≤ k) .

Here and also in the following we identify a set with its characteristic function. Thus we have A(n)=1 iff n ∈ A and A(n)=0 iff n ∈/ A. Roughly speaking, a set

A is k-c.e. if there is an effective procedure which enumerates all elements of A in which up to k corrections for any natural numbers are allowed.
If we are interested more in the computability instead of the enumerability, we can change the definition of k-c.e. sets slightly and achieve naturally the following.
Definition 2.1 For any constant k ∈ N, a set A is called k-b.c. (for k-bounded computable), if there is a computable sequence (As) of finite sets which converges k-bounded effectively (k-b.e., for short) to A in the sense that
(∀n) (|{s ≥ n : As(n) /= As+1(n)}| ≤ k) .
Notice that, the definition of k-b.c. sets differs from that of k-c.e. in the following
two points. Firstly, the condition A0 = ∅ is deleted. The reason is simple. The k- computable enumerability interests in how an element be enumerated into the set by an effective procedure and hence we have to begin with an empty set. However, for the k-bounded computability, we are interested only in how the value A(n) can be eventually determined, and the initial value A(n) at the beginning does not play a role. Secondly, only the stages s ≥ n are counted in (3). This ignores the inessential changes of As(n) before the stage n which can be effectively determined in advance. As a result of this slight change, any infinite computable sets are 0-b.c. Otherwise, if a computable sequence (As) of finite sets converges to an infinite computable set A, then there is at least one s such that As(n) /= As+1(n) for any n ∈ A/A0
. Simply letting such kind of changes occur before the stage s := n guarantees
that any computable sets are 0-b.c. Furthermore, the stage n can be equivalently replaced by g(n) for any increasing computable function g.
Instead of the sequences of finite sets, we can also consider the computable functions of two arguments which corresponds to a computable sequence of (not necessarily finite) sets. This leads to another equivalent definition of k-b.c. sets in the following proposition. In this case the condition s ≥ n is not necessary anymore. Some other simple properties of k-b.c. sets are also included in the proposition.
Proposition 2.2 Let k be a constant, and let A be a set of natural numbers.
A is k-b.c. if and only if there is a computable function f such that, for all n,
lim f (n, s)= A(n) & |{s : f (n, s) /= f (n, s + 1)}| ≤ k;
s→∞
If A is k-c.e. or co-k-c.e., then A is k-b.c.
If A is k-b.c., the A is (k + 1)-c.e.

If A is k-b.c., then so is the complement A.
A is k-b.c. if and only if there is an increasing computable function g and a computable sequence (As) of ﬁnite sets which converges to A such that
(∀n)(|{s ≥ g(n): As+1(n) /= As(n)}| ≤ k).
Analogous to the well known fact that a set A is computable if and only if A as well as its complement A are c.e., we have the following result.
Theorem 2.3 For any constant k, a set A is k-b.c. if and only if both A and its complement A are (k + 1)-c.e.

Proof. By Proposition 2.2.(iii), we need only to prove the “ if ” part. Suppose that (As) and (Bs) are (k +1)-enumerations of A and A, respectively. Since lims As(n)= A(n) /= A(n) = lims Bs(n) for all n, we can define a computable increasing total function v : N → N by
⎧⎨	v(0) := min{s : As(0) /= Bs(0)};
v(n + 1) := min{s > v(n): As(n + 1) /= Bs(n + 1)}.
Then we define a computable function f by



f (s, n
⎪⎨ As(n)	if Av(n)(n)=1 & s > v(n);

): 
1 —·
⎪⎪⎩ 1 —·
Bv(n)(n)	if Av(n)(n)=0 & s ≤ v(n);
Bs(n)	if Av(n)(n)=0 & s > v(n).

Obviously, we have lims f (s, n) = A(n). Suppose that Av(n)(n) = 1 for a given
n. If s ≥ v(n) such that f (s, n) /= f (s + 1, n), then As(n) /= As+1(n). Since Av(n)(n)=1 /=0= A0(n) and (As) is an (k + 1)-enumeration, there are at most k such stages s ≥ v(n). The same holds if Av(n)(n) = 0. This implies that there are at most k different s ≥ v(n) such that f (s, n) /= f (s + 1, n). For s < v(n) we have f (s, n) = f (s + 1, n) by the definition of f . Thus there are at most k different s totally such that f (s, n) /= f (s + 1, n) for all n, and hence A is k-b.c. by Proposition 2.2.(iii).	 
Denote by k-BC the class of all k-b.c. sets and let BC :  k∈N k-BC be the class of bounded computable sets. The class BC is closed under the set-operations of union, intersection, difference, complement and join, where A join B is the set A ⊕ B : {2n : n ∈ A}∪ {2n +1 : n ∈ B}. From the Ershov’s hierarchy theorem and Proposition 2.2, we have also a hierarchy theorem for BC that k-BC Ç (k + 1)-BC for all k. In addition, the following theorem shows that the class of k-BC is not simply the union of the classes of k-c.e. and co-k-c.e. sets which can be easily proved by a simple diagonalization.
Theorem 2.4 For any constant k, there is a k-b.c. set which is neither k-c.e. nor co-k-c.e.
3  Bounded Effectively Computable Real Numbers
In this section we discuss the finitely bounded computability of real numbers. A straightforward way to introduce the notion of finitely bounded computable real numbers is to consider the real numbers of k-b.c. binary expansion. Namely, we can call x “k-bounded computable” if x = xA := i∈A 2−(i+1) for a k-b.c. set A. Unfortunately, the “bounded computable reals” defined in this way do not have good mathematical properties. For example, there are c.e. sets B and C such that binary expansion A of xA := xB — xC is not even have an ω-c.e. Turing degree (see [7,9]).

Instead of binary expansion we consider the Cauchy representation of real num- bers, and define the bounded computability of real numbers as follows which is the special case of h-effective computability of real numbers for functions h discussed in [8].
Definition 3.1 A real x is k-effectively computable (k-e.c., for short) if there is a computable sequence (xs) of rational numbers which converges to x k-effectively in the sense that there are at most k non-overlapping index-pairs (s, t) such that
s, t ≥ n & |xs — xt|≥ 2−n.
The class of all k-e.c. real numbers is denoted by k-EC. In addition, we call a
real x bounded effectively computable (bec, for short) if it is k-e.c. for a constant k
and the class of all bec real numbers is denoted by BEC.
Lemma 3.2 Let i, j be any natural numbers.
If x and y are i-e.c. and j-e.c., respectively, then x + y, x × y and x/y (for
y /= 0) are all (i + j)-e.c.
If k > 0, then the class k-EC is not closed under addition.
Proof. (i). Let (xs) and (ys) be computable sequences of rational numbers which converge i-effectively and j-effectively to x and y, respectively. We consider here only the product xy. The situations for other operations are similar. Choose a constant c such that |xs|, |ys| ≤ 2c for all s. For any natural numbers s, t and n, if
|xs — xt|≤ 2−n and |ys — yt|≤ 2−n, then we have
|xsys — xtyt|≤ |xs||ys — yt| + |yt||xs — xt|≤ 2−(n−(c+1)).
Define a computable sequence (zs) of rational numbers by zs := xs' ys' for s' := s + c + 1. The sequence (zs) converges obviously to xy. We show now that this sequence converges (i + j)-effectively.
For any n and s, t ≥ n, if the inequality |zs — zt| > 2−n holds, then, we have either |xs' — xt' | ≥ 2−(n+c+1) or |ys' — yt' | ≥ 2−(n+c+1) by (5) where s' := s + c +1 and t' := t + c + 1. Since (xs) and (ys) converge i-effectively and j-effectively, respectively, the number of non-overlapping index-pairs (s, t) of these properties is bounded by i + j. That is, the sequence (zs) converges (i + j)-effectively, and hence xy is (i + j)-effectively computable.
(ii). It suffices to show that, for any k ≥ 0, there are k-e.c. real x and 1-e.c. real y such that x + y is not k-c.e. We can construct two computable sequences (xs) and (ys) of rational numbers which converge k-effectively and 1-effectively to x and y, respectively such that their sum x + y is different from any k-effectively computable real numbers. That is, x + y satisfies the following conditions:
Re :  (ϕe(s))s converges k-effectively to ze =⇒ x + y /= ze.
The construction of the sequences (xs) and (ys) applies the standard jump technique. To satisfy a single requirement Re, we choose two rational intervals I1 and I2 such that the distance between them is 2−n for some natural number n. As default, let x0 be the middle point of I1 and y0 := 0. We change xs to be the middle point of

I2 whenever the sequence (ϕe(t)) enters the interval I1 after stage n while the ys remains being unchanged. Redefine xt to be the middle point of interval I1 if the sequence (ϕe(s))s enters the interval I2 at a later stage t. This kind jumps of xs are allowed at most k times. After k jumps of xs, we can increase or decrease ys by 2−n once to force the sum xs + ys leaves the interval I1 or I2 depending on the sequence (ϕe(t)) enters I1 or I2. In this way, the sequences (xs) and (ys) converge k-effectively and 1-effectively, respectively, but the limit x + y is different from the possible limit of the sequence (ϕe(t)) if it converges k effectively.
To satisfy all requirements simultaneously, a finite injury priority construction suffices.	 
¿From Lemma 3.2 the following corollary follows immediately.
Corollary 3.3 The class BEC of bounded effectively computable real numbers is closed under arithmetical operations and hence is a ﬁeld.
Now we are going to show that the class BEC is also closed under the total computable real functions. To this end, we prove a technical lemma at first.
Lemma 3.4 If (xs) is a computable sequence of real numbers which converges k- effectively to x, then x is k-e.c.
Proof. By definition, a sequence (xs) of real numbers is computable means that there is a computable double sequence (xs,t) of rational numbers such that, for all s, t, |xs — xs,t|≤ 2−t. Suppose that the computable sequence (xs) of reals converges k-effectively to x. That is, for any n, there are at most k non-overlapping index- pairs s, t ≥ n such that |xs — xt| ≥ 2−n. Let ys := xs+1,s+2 for all s. Then (ys) is a computable sequence of rational numbers which converges to x. If s, t ≥ n are two indices such that |ys — yt| ≥ 2−n, then |xs+1 — xt+1| ≥ 2−(n+1) because of the following inequality
|ys — yt|≤ |xs+1,s+2 — xs+1| + |xs+1 — xt+1| + |xt+1 — xt+1,t+2|
≤ 2−(n+1) + |xs+1 — xt+1|.
This implies that the sequence (ys) converges also k-effectively and hence x is k-e.c. 
Theorem 3.5 The class BEC of bounded effectively computable real numbers is closed under the computable total real functions.
Proof. Suppose that x ∈ [0, 1] is a bounded effectively computable real number and f : [0, 1] → R be a total computable real function. The function f has a computable modulus function e : N → N (see e.g., [4]) such that
|x — y|≤ 2−e(n) =⇒ |f (x) — f (y)|≤ 2−n.
for any n and x, y ∈ [0, 1]. Let (xs) be a computable sequence of rational num- bers which converges k-effectively to x for some constant k. By the sequential computability of f , the sequence (f (xs)) is a computable sequence of real numbers which converges to f (x). From (6) it is not difficult to see that the sequence (f (xs)) converges k-effectively too. By Lemma 3.4, f (x) is a k-e.c. real and hence BEC is closed under total computable real functions.	 

We have seen that the class BEC has very nice mathematical as well as very interesting computability theoretical properties. Now we will show that this is actually a proper subset of weakly computable real numbers discussed in [1]. In addition, the k-e.c. real numbers firstly lead also to an interesting hierarchy of
c.e. reals. According to [1], a real x is weakly computable or d-c.e. (difference of c.e.) if there are c.e. reals y, z such that x = y — z, where c.e. reals are the limits of increasing computable sequences of rational numbers. It is shown in [1] that x is d-c.e. iff there is a computable sequence (xs) of rational numbers which converges to x weakly effectively in the sense that the sum  n∈N |xn — xn+1| is finite and the class WC of all d-c.e. reals is actually the arithmetical closure of c.e. reals. The next theorem implies that the classes BEC is different from WC.
Theorem 3.6 There is a c.e. real number x which is not k-e.c. for any natural number k. Therefore we have SC ¢ BEC.
Proof. We construct an increasing computable sequence (xs) of rational numbers converging to a real x which satisfies, for all e = ⟨i, j⟩, the requirements
Re : (ϕi(s))s converges j-effectively to ye =⇒ x /= ye.
To satisfy a single requirement Re for e = ⟨i, j⟩, we choose a rational interval Ie−1 which is divided into 2j + 1 equidistant subintervals Jt for t = 1, 2, ··· , 2j +1 of the length 2−ne for some natural number ne. As default define Ie := J2 and let x0 to be the middle point of the interval Ie. As long as the sequence (ϕi(s))s does not enter the interval Ie, we define xs equal to x0. Otherwise, if the sequence (ϕi(s))s enters the interval Ie after the stage ne, then we redefine Ie := J4 and define the new xs as the middle point of this new interval Ie. That is, xs is increased by 2−ne+1. If, at a late stage, the sequence (ϕi(s))s enters the new interval Ie, then we redefine Ie := J6, J8 ··· , and so on until Ie : J2j. Each time we define xs as the middle point of the actual interval Ie. This guarantees that the limit of the sequence (xs) is different from lims→∞ ϕi(s) if the sequence (ϕi(s)) converges j-effectively.
By the standard priority construction we can achieve an increasing computable sequence (xs) whose limit satisfies all requirements Re and hence it is not k-e.c. for any constant k.	 
Corollary 3.7 The class BEC is a proper subset of the class of weakly computable real numbers, i.e., BEC Ç WC.
Proof. It suffices to prove the inclusion BEC ⊆ WC. Let x be a k-e.c. real and let (xs) be a computable sequence of rational numbers which converges k-effectively
to x. We want to show that the sum Σ∞ |xs — xs+1| is finite.
By the k-effective convergence of (xs), there are at most k indices s ∈ [n — k, n] such that |xs —xs+1| > 2−(n−k), for any natural number n. This means that, there is at least one s ∈ [n—k, n] such that |xs—xs+1|≤ 2−(n−k). In general, for any i ≤ n—k, there are at least i + 1 indices s ∈ [n — k — i, n] such that |xs — xs+1| ≤ 2−(n−k−i). This implies that, there are n — k different indices s0, s1, ··· , sn−k ≤ n such that
|xsi — xs +1|≤ 2	for all i ≤ n — k. Choose a constant c such that |xs — xs+1|≤ c
−i
for all s ∈ N. Then we have

n	n−k	n−k
Σ |xs — xs+1|≤ Σ |xsi — ss +1| + ck ≤ Σ 2	+ ck ≤ 2+ ck.
−i



s=0
i=0
i=0

Therefore Σ∞  |xs — xs+1|≤ 2+ ck, i.e., (xs) converges weakly effectively to x and
hence x is weakly computable. Thus, BEC ⊆ WC.	 
In the computable analysis, c.e. reals are regarded as the first weaken version of the computable real numbers. Theorem 3.6 shows that not every c.e. real is bounded effectively computable. Of course, this does not mean that the bounded effective computability is weaker than the computable enumerability of real num- bers. Actually, as it is shown in [8], there is a bounded effectively computable real which is not c.e. That is, the classes SC and BEC are incomparable. However, if we consider the c.e. real numbers which fall into the classes k-EC for different constant k, then we achieve a Ershov-style hierarchy of c.e. reals as shown in the next theorem.
Theorem 3.8 For any constant k, there is a c.e. real which is (k + 1)-e.c. but not
k-e.c., and there is a c.e. set which is not k-e.c. for any constant k.
Proof. We prove only the first assertion. The second part can be proved in an analogous way.
For any constant k, we construct a computable sequence (xs) of rational numbers which converges (k + 1)-effectively to a c.e. real x and x is not k-e.c. The limit x has to satisfy the following requirements
Re : (ϕe(s))s converges k-effectively to ye =⇒ x /= ye.
The strategy to satisfy a single requirement Re is as follows. Choose a rational interval I and divide it into 2k + 3 equidistance subintervals Ii for i = 0, 1, 2k. Suppose that the lengths of Ii are 2−n0 . Choose I1 as default and define xs as the middle point of I1. If the sequence (ϕe(s)) enters an interval I2i+1 for some s ≥ n0, then we move to the interval I3 and define xs as the middle of this new interval. If it is necessary, we can move to the intervals I5, I7, ··· and so on. However, at most k + 1 moves are allowed and this suffices to guarantee that the limit x := lims xs is different from the possible limit ye := lims ϕe(s) if it converges k-effectively.
By a standard finite injury priority construction we can construct a computable sequence (xs) which converges (k + 1)-effectively to x and x satisfies all require- ments.	 
4	The Turing Degrees
In this section we investigate the Turing degrees which contain bounded effectively computable real numbers.
Theorem 4.1 There is a 1-e.c. real which is not of an ω-c.e. Turing degree.
Proof. We will construct a computable sequence (As) of finite sets such that the computable sequence (xAs ) of rational numbers converges 1-effectively to xA whose binary expansion A is not Turing equivalent to any ω-c.e. set.

Let (Ve,s) be an uniformly computable enumeration of all sequences of finite sets. If B is an ω-c.e. set, then there is an index e and a computable total function ϕi such that the sequence (Ve,s)s is a ϕi-enumeration of B, i.e.,
|{s : Ve,s(n) /= Ve,s+1(n)}| ≤ ϕi(n)
for all n. In order to guarantee that the set A is not Turing equivalent to any
ω-c.e. set, it suffices to satisfy the following requirements
RV,ϕ,Γ,Δ : (Vs) is a ϕ-enumeration of V =⇒ A /= ΓV or V /= ΔA
for all computable sequence (Vs) converging to V , all computable functions ϕ and all computable functionals Γ and Δ. Let (Re) be a computable enumeration of all requirements RV,ϕ,Γ,Δ. We assign Ri a higher priority than Rj if i < j. In the following, the use function of the computations ΓV and ΔA are denoted by the corresponding small cases γ and δ, respectively.
Let’s explain the idea how to satisfy a single requirement Re := RV,ϕ,Γ,Δ. Choose a natural number ne which is not yet in A. Our goal is to guarantee that the following condition holds only for at most finite many s
As(ne)= ΓV (ne)[s] & V T γ(ne)[s]= ΔA T γ(ne)[s].
To this end, we firstly wait for a stage s1 ≥ ne such that condition (7) holds for s := s1. If such kind of stage s1 does not exist, then we are done because ne witnesses that the requirement is satisfied. Otherwise, at stage s1 + 1, we destroy condition (7) by putting ne into A (i.e., define As1+1 := As1 ∪ {ne}). Notice that

we have in increment xA

s+1
= xAs
+ 2−ne in this case.

Then we wait for a new stage s2 > s1 such that condition (7) holds for s := s2. Similarly we are done if no such kind s2 exists. Otherwise, we destroy the condition at stage s2 + 1 by deleting ne from As2 . Because the sequence (xs) has already a jump of size 2−ne at stage s1+1 ≥ ne, we cannot simply delete ne from A. Otherwise the sequence does not converges 1-effectively. In order to delete ne with a smaller size of jump, we put all natural numbers n ∈ (ne, s2] in to As2+1. That is, we define
As2+1 := (As2 \{ne}) ∪ {ne + 1, n2 + 2, ··· , s2}.

In this way, we have only a relatively small decrement xA

s2+1
xAs2
— 2−s2 .

Finally, we wait again for a new stage s3 > s2 such that condition (7) holds for s := s3. If such s3 exists, then we destroy condition (7) again by put ne newly into A, and at the same time all natural numbers n ∈ (ne, s2] are deleted from As2 . In other words, we have
As3+1 := (As3 \{ne + 1, n2 + 2, ··· , s2}) ∪ {ne}.

In this case, we have an increment xA

s3+1
= xAs
+ 2−s2 . Especially, the set As is

recovered to that of stage s1, that is, As3 = As1 . Accordingly we have γ(ne)[s3]= 
γ(ne)[s1] and V T γ(ne)[s3] = V T γ(ne)[s1]. This implies that the initial segment
V T γ(ne) is changed between the stages s1 and s3. If ϕ is a total computable function and (Vs) isa ϕ-enumeration of V , then this kind of changes can happen at most Σγ(ne) ϕ(i) times. Thus we can repeat the above process at most Σγ(ne) ϕ(i)

times to satisfy the requirement Re while the sequence (xAs ) converges still 1- effectively.
To satisfy all requirements simultaneously, we need a finite injury priority con- struction. Two important points should be mentioned here. Firstly, in order to carry out the strategy for Re, the initial segment A T δγ(ne) should be preserved. Namely, the membership A(n) cannot be changed by the strategy of any require- ments of a priority lower than Re for any elements less than δγ(ne). This guarantees that at the stage s3, the initial segment V T γ(ne) can be recovered to that of the stage s1. Secondly, for the 1-effective convergence of (xAs ), the strategy for Ri should be initialized — i.e., choose a new witness ni and wait newly for properly s1, s2, s3 and so on, if a requirement Re of higher priority takes some actions. The further details are omitted here.	 
In the next we show a hierarchy theorem of k-c.e. Turing degrees which extended the result of Theorem 3.8. To simplify the notation we identify a real number x with its characteristic binary sequence. By definition, two real numbers x and y are Turing equivalent means that there are indices i and j such that x(n)= Φy(n) and y(n) = Φx(n) for all n, where (Φe) is an effective enumeration of computable partial functionals. This implies immediately that there are (maybe different) i and j such that x T n = Φy(n) & y T Φx(n) for all n. In this case, we say that x and y
i	j
are (i, j)-Turing equivalent (denote by x ≡(i,j) y). In other words, we have
x ≡(i,j) y : ⇐⇒ (∀n) x T n = Φy(n) & y T Φx(n) 
For the (i, j)-Turing equivalence we have the following important lemma.
Lemma 4.2 (Rettinger and Zheng [6]) For any rational interval I0 and any natural numbers i, j, t there are two open rational intervals I ⊆ I0 and J such that
(∀x, y) x ≡(i,j) y =⇒ (x ∈ I =⇒ y ∈ J) & (y ∈ J =⇒ x ∈ I0) .
We say that an intervals I is (i, j)-reducible to another interval J (denoted by
I ≤(i,j) J) if they satisfy the following condition
(∀x, y) x ∈ I & x ≡(i,j) y =⇒ y ∈ J .
By Lemma 4.2, there are I ⊆ I0 and J such that I ≤(i,j) J for any given interval I0. If all elements of I0 are not (i, j)-Turing equivalent to some element, then this holds trivially. Actually, the Lemma 4.2 holds even in an more effective sense. Namely, if there exists x ∈ I0 which is (i, j)-Turing equivalent to some y, then the intervals I and J which satisfy condition (8) can be effectively found. This fact will be used in the proof of the following theorem.
Theorem 4.3 For any constant k, there is a (k + 1)-e.c. real number which is not Turing equivalent to any k-e.c. reals.
Proof. We construct a computable sequence (xs) of rational numbers which con- verges (k + 1)-effectively to a non-k-e.c. real x. The limit x has to satisfy all the following requirements

R⟨i,j,k⟩
:	(ϕk(s)) converges k-effectively to yk =⇒ x /≡(i,j) yk.

To satisfy a single requirement Re, we are going to find a rational interval Ie such that all x ∈ Ie satisfy Re. This interval is called a witness interval of Re. We can choose arbitrarily an interval I and three disjoint subintervals I1,I2,I3 ⊆ I. If one of these subintervals satisfies the following condition: it does not contain an element which is (i, j)-Turing equivalent to some real y, then we can simply let this subinterval as witness interval and we are done. Otherwise, by Lemma 4.2, we can effectively find three intervals J1,J2 and J3 such that It ≤(i,j) Jt for t = 1, 2, 3.
W.l.o.g. we can assume that the intervals J1,J2 and J3 are disjoint (Otherwise we can consider the subintervals of It, if it is necessary). Then, at least two of them are separated by a positive distance. Suppose that J1 and J2 are separated by, say, 2−b for a natural number b. Accordingly, the maximal distance between the intervals I1 and I2 is bounded by 2−a for a natural number a. Now we can choose I1 as candidate of witness interval. If ϕk(s) enters J1 for s ≥ b, then we change the witness interval to be I2. If ϕk(s) enters J2 later on, then choose I1 as witness interval again, and so on. At most k changes suffice to satisfy the requirement Re. We need only a standard finite injury priority construction to construct the com- putable sequence (xs) and xs is chosen from the actually smallest witness intervals defined at the stage s. The details are omitted here.	 

References
Ambos-Spies, K.; K. Weihrauch, and X. Zheng.	Weakly computable real numbers.	Journal of Complexity, 16(4):676–690, 2000.
Ershov, Y. L. A certain hierarchy of sets. i. (Russian). Algebra i Logika, 7(1):47–73, 1968.
Gold, E. M. Limiting recursion. J. Symbolic Logic, 30:28–48, 1965.
Pour-El, M. B. and J. I. Richards. Computability in Analysis and Physics. Perspectives in Mathematical Logic. Springer-Verlag, Berlin, 1989.
Putnam, H. Trial and error predicates and the solution to a problem of Mostowski. J. Symbolic Logic, 30:49–57, 1965.
Rettinger, R. and X. Zheng. A hierarchy of turing degrees of divergence bounded computable real numbers. J. Complex., 22(6):818–826, 2006.
Zheng, X. On the Turing degrees of weakly computable real numbers. Journal of Logic and Computation, 13(2):159–172, 2003.
Zheng, X. Classification of the computable approximations by divergence boundings. Electron. Notes Theor. Comput. Sci., 167:325–344, 2007.
Zheng, X. and R. Rettinger. Weak computability and representation of reals. Mathematical Logic Quarterly, 50(4/5):431–442, 2004.
