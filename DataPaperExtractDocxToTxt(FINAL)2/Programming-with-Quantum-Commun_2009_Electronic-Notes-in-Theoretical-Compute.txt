

Electronic Notes in Theoretical Computer Science 253 (2009) 99–118
www.elsevier.com/locate/entcs

Programming with Quantum Communication
Anya Tafliovich1 ,2	Eric C. R. Hehner3
Computer Science University of Toronto Toronto, Canada

Abstract
This work develops a formal framework for specifying, implementing, and analysing quantum communication protocols. We provide tools for developing simple proofs and analysing programs which involve communi- cation, both via quantum channels and exhibiting the LOCC (local operations, classical communication) paradigm.
Keywords: Quantum Computing, Quantum Communication Protocol, Formal Verification, Formal Methods of Program Design


Introduction
The term quantum communication refers to the process of transferring a quantum state between distinct physical locations. There are two ways of accomplishing this task. The first one is analogous to classical communication and involves sending a quantum bit over a quantum communication channel (just as classical communica- tion is associated with sending classical bits over a classical communication chan- nel). The second one has no classical analogue. In a quantum world it is possible to transfer a quantum bit without utilising a quantum channel, by using a classi- cal communication channel and a pair of entangled states and applying quantum operations locally.
This work develops a formal framework for specifying, implementing, and analysing quantum communication protocols. We provide tools for developing sim- ple proofs and analysing programs which involve communication, both via quan- tum channels and exhibiting the LOCC (local operations, classical communication) paradigm. We look at quantum communication in the context of formal methods of

1 This work is in part supported by NSERC.
2 Email: anya@cs.toronto.edu
3 Email: hehner@cs.toronto.edu

1571-0661 © 2009 Elsevier B.V.Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.008

program development, or programming methodology. This is the field of computer science concerned with applications of mathematics and logic to software engineering tasks. In particular, the formal methods provide tools to formally express specifica- tions, prove correctness of implementations, and reason about various properties of specifications (e.g. implementability) and of implementations (e.g. time and space complexity).
In this work the analysis of quantum communication protocols is based on quantum predicative programming ([23,24,22]), a recent generalisation of the well- established predicative programming ([14,15]). It supports the style of program development in which each programming step is proved correct as it is made. We inherit the advantages of the theory, such as its generality, simple treatment of recursive programs, and of time and space complexity. The theory of quantum pro- gramming provides tools to write both classical and quantum specifications, develop quantum programs that implement these specifications, and reason about their com- parative time, space, and communication complexity, all in the same framework.
There has been a number of proposals for formal approaches to quantum pro- gramming, including the language qGCL [20,28], process algebraic approaches of [4,18,17], tools developed in the field of category theory [1,2,3,10,21], functional languages of [6,7,5,25], as well as work of [12], [11], and [13]. A detailed discussion of the work related to quantum predicative programming is presented in [23].
The contribution of this work is twofold. Firstly, we present a framework for im- plementing quantum communication protocols, specifying desired properties of the protocols, and formally proving whether these properties hold. The properties are not restricted to reasoning about the data sent or received by the parties involved. We provide tools to prove properties which deal with the complexity of the pro- tocol, such as the number of classical and quantum bits sent during its execution. Secondly, the reasoning about quantum communication fits nicely in the general framework of quantum predicative programming, and thus inherits all of its advan- tages. The definitions of specification and program are simple: a specification is a boolean (or probabilistic) expression and a program is a specification. The treat- ment of recursion is simple: there is no need for additional semantics of loops. The treatment of termination simply follows from the introduction of a time variable; if the final value of the time variable is ∞, then the program is a non-terminating one. There is a uniform method for proving correctness and time, space, and commu- nication complexity; moreover, after proving them separately, we naturally obtain the conjunction. The use of Dirac-like notation makes it easy to write down specifi- cations and develop algorithms. Finally, the treatment of computation with mixed states does not require any additional mechanisms.
The rest of this work is organised as follows. Section 2 is a brief introduction to quantum predicative programming. The contribution of this work is Section 3 which introduces a formal framework for specifying, implementing, and analysing quantum communication protocols and presents the analysis of two such protocols: quantum teleportation and quantum dense coding. Section 4 states conclusions and outlines directions for future research. A short introduction to quantum computing

is presented in the Appendix A.

Quantum Predicative Programming
This section introduces the programming theory of our choice — quantum predica- tive programming. We briefly introduce parts of the theory necessary for under- standing Section 3 of this work. For a course in predicative programming the reader is referred to [14]. An introduction to probabilistic predicative programming can be found in [15,16]. Quantum predicative programming is developed in [23,24,22].

Predicative programming
In predicative programming a specification is a boolean expression. The variables in a specification represent the quantities of interest, such as prestate (inputs), poststate (outputs), and computation time and space. We use primed variables to describe outputs and unprimed variables to describe inputs. For example, speci- fication x' = x + 1 states that the final value of x is its initial value plus 1. A computation satisﬁes a specification if, given a prestate, it produces a poststate, such that the pair makes the specification true. A specification is implementable if for each input state there is at least one output state that satisfies the specification. We use standard logical notation for writing specifications: ∧ (conjunction), ∨ (disjunction), ⇒ (logical implication), = (equality, boolean equivalence), /= (non- equality, non-equivalence), and if then else. The larger operators == , ≤ , and
=⇒ are the same as =, ≤, and ⇒, but with lower precedence. We use standard
mathematical notation, such as + − × / mod div. We use lowercase letters for
variables of interest and uppercase letters for specifications.
In addition to the above, we use the following notations: σ (prestate), σ' (post- state), ok (σ' = σ), and x := e (x' = e ∧ y' = y ∧ .. .). The notation ok specifies that the values of all variables are unchanged. In the assignment x := e, x is a state variable (unprimed) and e is an expression (in unprimed variables) in the domain of x.
If R and S are specifications in variables x, y,... , then the sequential composition
of R and S is defined by
R ; S == ∃x'', y'',... · R'' ∧ S''	(1)
where R'' is obtained from R by substituting all occurrences of primed variables x', y',... with double-primed variables x'', y'',... , and S'' is obtained from S by substituting all occurrences of unprimed variables x, y,... with double-primed vari- ables x'', y'',... .
Various laws can be proved about sequential composition. One of the most important ones is the substitution law, which states that for any expression e of the prestate, state variable x, and specification P ,
x := e ; P == (for x substitute e in P )	(2)

Specification S is reﬁned by specification P if and only if S is satisfied whenever P is satisfied, that is ∀σ, σ' · S ⇐ P . Given a specification, we are allowed to implement an equivalent specification or a stronger one.
A program is an implemented specification. A good basis for classical (non- quantum) programming is provided by: ok, assignment, if then else, sequential composition, booleans, numbers, bunches, and functions. Given a specification S, we proceed as follows. If S is a program, there is no work to be done. If it is not, we build a program P , such that P refines S, i.e. S ⇐ P . The refinement can proceed in steps: S ⇐ ... ⇐ R ⇐ Q ⇐ P .
In S ⇐ P it is possible for S to appear in P . No additional rules are required to prove the refinement. For example, it is trivial to prove that
x ≥ 0 ⇒ x' =0 ⇐= if x =0 then ok else (x := x − 1; x ≥ 0 ⇒ x' = 0)
The specification says that if the initial value of x is non-negative, its final value must be 0. The solution is: if the value of x is zero, do nothing, otherwise decrement x and repeat.
Probabilistic predicative programming
A probability is a real number between 0 and 1, inclusive. A distribution is an expression whose value is a probability and whose sum over all values of variables is 1. Given a distribution of several variables, we can sum out some of the variables to obtain a distribution of the rest of the variables.
To generalise boolean specifications to probabilistic specifications, we use 1 and 0 both as numbers and as boolean true and false, respectively. If R and S are specifications in variables x, y,... , then the definition (1) of sequential composition of R and S is generalised to
R ; S == Σ x'', y'',... · R'' × S''
where R'' and S'' are defined as before.
If p is a probability and R and S are distributions, then
if p then R else S == p × R + (1 − p) × S
If S is an implementable deterministic specification and p is a distribution of the initial state x, y, ..., then the distribution of the final state is
p' ; S
Various laws can be proved about sequential composition. One of the most important ones, the substitution law, introduced earlier, applies to probabilistic specifications as well.
To implement a boolean specification S, we need to provide a program P which is either equivalent to or is stronger than S, that is S ⇐ P . In developing probabilistic

programs, the analog of ⇒ is ≤. However, one must be careful when using it. Consider, for example, the following probabilistic expression:
(x' = 0)/2+ (x' /= 0)/2
which is intended to capture the specification that says that the final value of x is 0 half of the time and non-zero half of the time. We can refine this expression with the following program (in one variable x):
if 1/2 then x := 0 else x := 1
== (x' = 0)/2+ (x' = 1)/2
≤ (x' = 0)/2+ (x' /= 0)/2 However, it is also the case that
if 1/2 then x := 1 else x := 2
== (x' = 1)/2+ (x' = 2)/2
≤ 1/2
== (x' = 0)/2+ (x' /= 0)/2
which does not correspond to the intended meaning of the specification. There is an intrinsic problem with formulating probabilistic specifications as super- distributions, known as a convex closure problem. We avoid this problem in this work by only allowing the following uses of super-distributions in probabilistic re- finement: if P0 is a probabilistic specification (a distribution) in variables σ' and P1

is a distribution in variables σ'
then we allow a probabilistic analog of weakening :
P0 × P1 ≤ P0 and
P0 × P1 ≤ P1


Quantum Predicative Programming
Let C be the set of all complex numbers with the absolute value operator |·| and the complex conjugate operator . Then a state of an n-qubit system is a function ψ : 0, ..2n → C, such that x : 0, ..2n · |ψx|2 == 1. Here notation i, ..j means from (and including) i to (and excluding) j.
If ψ and φ are two states of an n-qubit system, then their inner product, denoted by ⟨ψ|φ⟩, is defined by:
⟨ψ|φ⟩ = Σ x : 0, ..2n · (ψx)∗ × (φx)
A basis of an n-qubit system is a collection of 2n quantum states b0,..2n , such that ∀i, j : 0, ..2n · ⟨bi|bj⟩ = (i = j). We adopt the following Dirac-like notation for the computational basis: if x is from the domain 0, ..2 , then x denotes the

corresponding n-bit binary encoding of x and |x⟩ : 0, ..2n → C is the following quantum state:
|x⟩ = λi : 0, ..2 · (i = x)
where λx : D · b is a function of a variable x with domain D and body b. If ψ is a state of an m-qubit system and φ is a state of an n-qubit system, then ψ ⊗ φ, the tensor product of ψ and φ, is the following state of a composite m + n-qubit system:
ψ ⊗ φ = λi : 0, ..2m+n · ψ(i div 2n) × φ(i mod 2n)
We write φ⊗n to mean “φ tensored with itself n times”. An operation defined on an n-qubit quantum system is a higher-order function, whose domain and range are maps from 0, ..2n to the complex numbers. An identity operation on a state of an n-qubit system is defined by
In = λψ : 0, ..2n → C · ψ

Fora linear operation A, the adjoint of A, written A†, is the (unique) operation, such that for any two states ψ and φ, ⟨ψ|Aφ⟩ = ⟨A†ψ|φ⟩.
The unitary transformations that describe the evolution of an n-qubit quantum system are operations U defined on the system, such that U †U = In.
In this setting, the tensor product of operators is defined in the usual way. If ψ is a state of an m-qubit system, φ is a state of an n-qubit system, and U and V are operations defined on m and n-qubit systems, respectively, then the tensor product of U and V is defined on an m + n qubit system by
(U ⊗ V )(ψ ⊗ φ)= (Uψ) ⊗ (V φ)
To apply an operation U defined on a 1-qubit system to qubit i in a composite
n-qubit system, we apply the operation Un to the entire system, where Un is defined

by:
i	i

Un = I ⊗ ... ⊗ I ⊗ U ⊗ I ⊗ ... ⊗ I

i	n−i−1
Suppose we have a system of n qubits in state ψ and we measure (observe) it. Suppose also that we have a variable r from the domain 0, ..2n, which we use to record the result of the measurement, and variables x, y,.. ., which are not affected by the measurement. Then the measurement corresponds to a probabilistic specifi- cation that gives the probability distribution of ψ' and r' (these depend on ψ and on the type of measurement) and states that the variables x, y,... are unchanged. For a general quantum measurement described by a collection M = M0,..2n of measurement operators, which satisfy the completeness equation (see Appendix A),
the specification is measureM ψ r, where
†		Mr' ψ	 ⎞

measureM ψr == ⟨ψ|Mr' Mr' ψ⟩× ⎝ψ
=
⟨ψ|Mr' Mr' ψ⟩
⎠ × (σ
= σ)

where σ' = σ is an abbreviation of (x' = x) × (y' = y) × ... and means “all other variables are unchanged”.
Given an arbitrary orthonormal basis B = b0,..2n , measurement of ψ in basis B

is:
measureB ψr == |⟨br' |ψ⟩|
× (ψ
= br' ) × (σ
= σ)

The simplest and the most commonly used measurement in the computational basis is:
measure ψr == |ψr'|2 × (ψ' = |r'⟩) × (σ' = σ)
In this case the distribution of r' is |ψr'|2 and the distribution of the quantum state is:
Σ r' · |ψr'|2 × (ψ' = |r'⟩)
which is precisely the mixed quantum state that results from the measurement.
In order to develop quantum programs we need to add to our list of implemented things. We add variables of type quantum state as above and we allow the following three kinds of operations on these variables. If ψ is a state of an n-qubit quantum system, r is a natural variable, and M is a collection of measurement operators that satisfy the completeness equation, then:
ψ := |0⟩⊗n is a program
ψ := Uψ, where U is a unitary transformation on an n-qubit system, is a program
measureM ψr is a program
where the superscript ⊗n means “tensored with itself n times”. The special cases of measurements are therefore also allowed.
Some unitary operations that we will use in the later sections are (here x, c : 0, 1):
I|x⟩ = |x⟩	identity
X|x⟩ = |1 − x⟩	X - Pauli matrix
Y |x⟩ = (−1)x × i × |1 − x⟩	Y - Pauli matrix
Z|x⟩ = (−1)x × |x⟩	Z - Pauli matrix H|x⟩ = (|0⟩ + (−1)x × |1⟩)/ 2			Hadamard CNOT |cx⟩ = (I ⊗ Xc)|cx⟩		controlled-not
Distributed Quantum Systems and Communication
In predicative programming, to reason about distributed computation we (dis- jointly) partition the variables between the processes involved in a computation. Parallel composition is then simply boolean conjunction. For example, consider two processes P and Q. P owns integer variables x and y and Q owns an integer variable z. Suppose P == x := x +1 ; y := x and Q == z := −z. Parallel composition of P with Q is then simply
P ||Q == P ∧ Q == x' = x +1 ∧ y' = x +1 ∧ z' = −z

In quantum predicative programming, one needs to reason about distributed quantum systems. Recall that if ψ is a state of an m-qubit system and φ is a state of an n-qubit system, then ψ ⊗ φ, the tensor product of ψ and φ, is the state of a composite m + n-qubit system. On the other hand, given a composite m + n-qubit system, it is not always possible to describe it in terms of the tensor product of the component m- and n-qubit systems. Such a composed system is entangled. Entanglement is one of the most non-classical, most poorly understood, and most interesting quantum phenomena. An entangled system is in some sense both distributed and shared. It is distributed in the sense that each party can apply operations and measurements to only its qubits. It is shared in the sense that the actions of one party affect the outcome of the actions of another party. Simple partitioning of qubits is therefore insufficient to reason about distributed quantum computation.
The formalism we introduce fully reflects the physical properties of a distributed quantum system. We start by partitioning the qubits between the parties involved. For example, consider two parties P an√d Q. P ow√ns the first qubit of the composite
entangled quantum system ψ = |00⟩/  2+ |11⟩/  2 and Q owns the second qubit.
A specification is a program only if each party computes with its own qubits. In our example,
P == ψ0 := Hψ0 ; measure ψ0 p	and	Q == measure ψ1 q
are programs, if p and q are integer variables owned by P and Q, respectively.
Sometimes we want to explicitly include partitioning of variables as part of a specification. For this purpose, we introduce notation varP to mean the bunch of variables that belong to process P . In the above example we can make the partitioning of variables explicit with the specification
ψ0,p : varP ∧ ψ1,q : varQ
We define parallel composition of P and Q which share an n+m quantum system in state ψ with the first n qubits belonging to P and the other m qubits belonging to Q as follows. If
P == ψ0,..n := UP ψ0,..n	and	Q == ψn,..n+m := UQψn,..n+m

where UP is a unitary operation on an n-qubit system and UQ is a unitary operation on an m-qubit system, then
P ||ψ Q == ψ := (UP ⊗ UQ)ψ
Performing ok is equivalent to performing the identity unitary operation, and therefore if

then
P == ψ0,..n := UP ψ0,..n	and	Q == ok

P ||ψ Q == ψ := (UP ⊗ I⊗m)ψ

Similarly, if
P == measureMP ψ0,..n p	and	Q ==  measureMQ ψn,..n+m q
where MP and MQ are a collection of proper measurement operators for n- and
m-qubit systems, respectively, then
P ||ψ Q == measureMP ⊗MQψ p×q
In our example,
ψ := |00⟩/√2+ |11⟩/√2; P ||ψQ	expand, substitute
== ψ := |00⟩/√2+ |11⟩/√2; 
measure (Hψ0) p  ψ measure ψ1 q	compose on ψ
== ψ := |00⟩/√2+ |11⟩/√2; measure (H ⊗ I)ψ pq	substitute
== measure (H ⊗ I)(|00⟩/√2+ |11⟩/√2) pq	apply H ⊗ I
== measure (|00⟩ + |01⟩ + |10⟩− |11⟩)/2 pq	measure
== |(|00⟩ + |01⟩ + |10⟩− |11⟩)/2 pq|2 × (ψ' = |p'q'⟩)	application
== (ψ' = |p'q'⟩)/4
When explicitly specifying partitioning of variables in a parallel composition, it is convenient to allow the variables to appear as subscripts on the corresponding processes. For example, the specification Pψ0 ,p ||ψ Qψ1 ,q denotes a parallel compo- sition of processes P and Q that share an entangled state ψ, such that ψ0 and p
belong to P and ψ1 and q belong to Q.
To reason about communication between processes we use the framework of Hehner’s calculus([14]). A named, one-way communication channel c is described by an infinite message script Mc, an infinite time script Tc, and read and write cursors rc and wc. The message and time scripts are the list of all messages that appear on the channel and the list of corresponding times. The read and write cursors specify how many messages have been read from and written to a channel. To specify two-way communication, we use two channels. The input and output on channel c are defined by the following operations (here t is the time variable):
c!e	== Mcwc = e ∧ Tcwc = t ∧ wc := wc +1	c output e c?	== rc := rc +1		c input
c	== Mc(rc − 1)
A channel declaration chan c : T ·P defines a new channel c with communication of type T ; the declaration applies to the specification P (here xnat stands for naturals extended with ∞):
chan c : T · P == ∃Mc : [∞∗ T ] · ∃Tc : [∞∗ real] · var rc, wc : xnat := 0 · P

where [∞∗ T ] is an infinite sequence of elements of type T . One useful theorem that we use in later examples is the equivalence of communication on a local channel with assignment:
chan c : T · c!e || (c?; x := c) == x := e
The reader is referred to [14] for a detailed description of formal treatment of clas- sical communication in Hehner’s calculus.
When defining a quantum communication channel one must be careful not to introduce any unwanted behaviour, such as violation of the no-cloning principle (i.e. creation of identical copies of an unknown arbitrary quantum state). For this purpose we make the change of ownership of the transported qubit explicit in the definition:
c!ψ	== Mcwc = ψ ∧ Tcwc = t ∧ w' = wc +1 ∧ var' = varP \ψ ∧ σ' = σ
c	P
c?ψ	== r' = rc +1 ∧ ψ' = Mcrc ∧ var' = varQ,ψ ∧ σ' = σ
where c is a quantum communication channel from process P to process Q and
σ' = σ is shorthand for “the rest of the variables are unchanged”.
Now that we allow changing of ownership of the variables, the specification
'  = σP , “the rest of the variables of process P are unchanged” is defined by
∀v : var' · v' = v.
The declaration of a quantum channel qchan c : qbit · P is similar to the decla- ration of a local classical channel:
qchan q : T · P == ∃Mq : [∞∗ T ] · ∃Tq : [∞∗ real] · var rq, wq : xnat := 0 · P
Similarly to the above-mentioned theorem, we can prove the equivalence of com- munication on a local quantum channel with the change of ownership. If P == c!ψ and Q == c?ψ, then (leaving out time)
qchan c : qbit · P || Q	def. qchan
== ∃M : [∞∗ qbit] · var r, w : xnat := 0 · P || Q	expand
== ∃M : [∞∗ qbit] · var r, w : xnat := 0·
Mw = ψ ∧ w' = w +1 ∧ var' = varP \ψ
∧ varQ = varQ,ψ ∧ r = r +1 ∧ ψ = Mr	initialisation
== ∃M : [∞∗ qbit] · var r, w : xnat·
M 0= ψ ∧ w' =1 ∧ var' = varP \ψ
∧ varQ = varQ,ψ ∧ r =1 ∧ ψ = M 0	simplify
== var' = varP \ψ ∧ var' = varQ,ψ ∧ σ' = σ

Quantum teleportation
Quantum teleportation is the most famous quantum communication protocol. Its description first appeared in a seminal article by Bennett et al in 1993 ([9]), it

has since been extensively used as part of more complex quantum communication protocols, and has received much attention in experimental research. The protocol achieves transmission of quantum information by utilising only a classical commu- nication channel and an entangled pair of qubits: no qubits are sent in the process. The prot√ocol: Alice and Bob share an entangled pair of qubits in the state
(|00⟩ + |11⟩)/  2. Alice has some qubit ψ in her possession (she may not know the
state of the qubit) that she wishes to transfer to Bob. Alice starts by interacting the qubit she wishes to teleport with her half of the entangled pair (she applies a controlled-not followed by a Hadamard transform) and measuring her two qubits. She then sends the results of her measurements to Bob (two classical bits). Bob receives the two classical bits and, depending of their values, applies one of the three Pauli operators or the identity to his qubit. Surprisingly, he has recovered the state Alice wished to teleport.
The protocol is usually described informally, by using a diagram as in Figure 1 4 . Such a description is insufficient, in part since it only describes the evolution of the quantum system and does not specify the distribution of the system nor the communication. Alternatively, the description of the protocol is given informally, in English. Our goal is to formally define and prove correctness of the quantum teleportation protocol. Some approaches proposed in the literature (e.g. [27]) define teleportation as a program that implements a specification of the form φ' = ψ. We point out that this specification may as well be implemented by a program that involves sending a qubit on a quantum channel, which is not teleportation. Furthermore, the specification does not mention that two classical bits are sent on a classical channel, which is an important part of the specification of teleportation. Similarly, it is important to specify that a pair of maximally entangled qubits is required.
To formalise the quantum teleportation protocol we let c be the number of classical bits sent on a communication channel and q be the number of quantum bits sent. The formal specification of quantum teleportation is:

S ==	φ01 : varAlice ∧ φ2 : varBob ∧	√
φ0,..3 = (α × |0⟩ + β × |1⟩) ⊗ (|00⟩ + |11⟩)/  2
'	'	'
⇒ φ2 = α × |0⟩ + β × |1⟩∧ c = c +2 ∧ q = q

The specification says that if the computation starts with a qubit (specified in the most general form) in Alic√e’s possession and if Alice and Bob share a maximally
entangled state (|00⟩ + |11⟩)/  2, then at the end of the computation the qubit is
teleported to Bob at a cost of 2 classical bits of communication and 0 qubits of communication. The specification does not restrict the quantum system to three qubits, so that teleportation can be a part of a bigger computation.


4 The figure is generated with qasm2pdf

|φ0⟩

|φ1⟩
|φ2⟩
Fig. 1. Quantum teleportation protocol
The well-known solution is the following parallel program:
P == chan ch : bit · Alicea0 ,a1 ,φ01 ||φ Bobb0 ,b1,φ2
where Alice ==  φ01 := CNOTφ01 ; φ0 := Hφ0 ; measure φ01 a0a1 ;
c := c +1 ; ch!a0 ; c := c +1 ; ch!a1
and Bob == ch?; b0 := ch ; ch?; b1 := ch ; φ2 := Zb0 Xb1 φ2
That is, two processes, Alice and Bob, partition a 3-qubit quantum system φ, so that Alice owns the first qubit (the one she wants to teleport) and the second qubit and Bob owns the third qubit. Alice can write to a local classical communication channel ch and Bob can read from it. Finally, a0 and a1 are two bits that belong to Alice, and b0 and b1 are two bits that belong to Bob. The process Alice performs local operations and measurements and sends two classical bits on the channel. The process Bob reads from the channel and performs local operations.
Our goal is to prove that the program P implements the specification S. We first note the following equivalence:
P ⇒ S	def. S
==	P ∧ φ01 : varAlice ∧ φ2 : varBob ∧	√
φ0,..3 = (α × |0⟩ + β × |1⟩) ⊗ (|00⟩ + |11⟩)/  2
'	'	'

⇒ φ2 = α × |0⟩ + β × |1⟩∧ c = c +2 ∧ q = q √
simplification

==	P ∧ φ = (α × |0⟩ + β × |1⟩) ⊗ (|00⟩ + |11⟩)/  2
'	'	'
⇒ φ2 = α × |0⟩ + β × |1⟩∧ c = c +2 ∧ q = q

Next, we simplify P to prove the above implication. With implicit partitioning of variables (as it does not change):
chan ch : bit ·	((φ01 := CNOTφ01 ; φ0 := Hφ0 ; measure φ01 a0a1 ;
c := c +1 ; ch!a0 ; c := c +1 ; ch!a1)

||φ (ch?; b0 := ch ; ch?; b1 := ch ; φ2 := Z
Xb1
φ2))

==	substitute, H on first qubit
chan ch : bit ·	((measure H ⊗ I(CNOTφ01) a0a1 ;
c := c +1 ; ch!a0 ; c := c +1 ; ch!a1)

||φ (ch?; b0 := ch ; ch?; b1 := ch ; φ2 := Z
Xb1
φ2))

==	parallel composition, simplification

chan ch : bit·
measure01 H ⊗ I ⊗ I(CNOT ⊗ Iφ) a0a1 ;
((c := c +1 ; ch!a0 ; c := c +1 ; ch!a1) || (ch?; b0 := ch ; ch?; b1 := ch)) ;
φ := I ⊗ I ⊗ Zb0 (I ⊗ I ⊗ Xb1 φ)
==	classical channel
measure01 H ⊗ I ⊗ I(CNOT ⊗ Iφ) a0a1 ;
c' = c +2 ∧ b' = a0 ∧ b' = a1 ∧ σ' = σ ;
φ := I ⊗ I ⊗ Zb0 (I ⊗ I ⊗ Xb1 φ)
Next we notice that the first line in the above specification (which is, in fact, the effect of Alice’s actions) conjoined with the specification of the initial state of the quantum system, result in the following distribution over the states of the computation:

'	'  '

'	a'	'

φ = |a0a1⟩⊗ (α × |a1⟩ + (−1) 0 × β × |1 − a1⟩)/4
That is, with probability 1/4 the quantum system is in state |00⟩⊗ (α × |0⟩ + β × |1⟩) and the values of Alice’s bits are a0 =0 and a1 = 0; with probability 1/4 the quantum system is in state |01⟩⊗ (α × |1⟩ + β × |0⟩) and the values of Alice’s bits are a0 =0 and a1 = 1; etc.
To prove this formally, we first note that:
H ⊗ I ⊗ I(CNOT ⊗ I((α × |0⟩ + β × |1⟩) ⊗ (|00⟩ + |11⟩)/√2))
==	apply CNOT
H ⊗ I ⊗ I(α × |000⟩ + β × |110⟩ + α × |011⟩ + β × |101⟩)/√2
==	apply H
α × (|0⟩ + |1⟩) ⊗ |00⟩/2+ β × (|0⟩− |1⟩) ⊗ |10⟩/2+
α × (|0⟩ + |1⟩) ⊗ |11⟩/2+ β × (|0⟩− |1⟩) ⊗ |01⟩/2
==	rearrange terms
|00⟩⊗ (α × |0⟩ + β × |1⟩)/2+ |01⟩⊗ (α × |1⟩ + β × |0⟩)/2+
|10⟩⊗ (α × |0⟩− β × |1⟩)/2+ |11⟩⊗ (α × |1⟩− β × |0⟩)/2
Therefore, measurement of the first two qubits of the above state in the compu- tational basis gives:
measure01 (|00⟩⊗ (α × |0⟩ + β × |1⟩)/2+ |01⟩⊗ (α × |1⟩ + β × |0⟩)/2+
|10⟩⊗ (α × |0⟩− β × |1⟩)/2+ |11⟩⊗ (α × |1⟩− β × |0⟩)/2)
a0a1

'	'  '
'	a'	'

== φ
= |a0a1⟩⊗ (α × |a1⟩ + (−1) 0 × β × |1 − a1⟩)/4

Let Q be the specification of the initial state of the quantum system:
Q == φ = (α × |0⟩ + β × |1⟩) ⊗ (|00⟩ + |11⟩)/√2

Putting it all together, we get:

Q ∧ P
== Q × (measure01 H ⊗ I ⊗ I(CNOT ⊗ Iφ) a0a1 ;
c' = c +2 ∧ b' = a0 ∧ b' = a1 ∧ σ' = σ ;	one point law,
φ := I ⊗ I ⊗ Zb0 (I ⊗ I ⊗ Xb1 φ))	as above

'	'  '
'	a'	'

== Q × φ = |a0a1⟩⊗ (α × |a1⟩ + (−1) 0 × β × |1 − a1⟩)/4;	sequential
c' = c +2 ∧ b' = a0 ∧ b' = a1 ∧ σ' = σ ;	composition,
φ := I ⊗ I ⊗ Zb0 (I ⊗ I ⊗ Xb1 φ)	one point law
== Q × (c' = c + 2) × (b' = a' ) × (b' = a' ) × (σ' = σ)×

'	b'
0	0	1	1
b'

φ = I ⊗ I ⊗ Z 0 (I ⊗ I ⊗ X 1
' '	'	b'	'	b'
(|b0b1⟩⊗ (α × |b1⟩ + (−1) 0 × β × |1 − b1⟩)/4))	apply X 1
== Q × (c' = c + 2) × (b' = a' ) × (b' = a' ) × (σ' = σ)×
0	0	1	1
'	b'	' '	b'	b'
φ = I ⊗ I ⊗ Z 0 (|b0b1⟩⊗ (α × |0⟩ + (−1) 0 × β × |1⟩)/4	apply Z 0
== Q × (c' = c + 2) × (b' = a' ) × (b' = a' ) × (σ' = σ)×
(φ' = |b' b' ⟩⊗ (α × |0⟩ + β × |1⟩)/4)
≤ (c' = c + 2) × (q' = q) × (φ' = α × |0⟩ + β × |1⟩)
== S

This example shows formalisation and analysis of an LOCC (local operations, classical communication) quantum communication protocol. We now turn to our attention to a protocol which involves a quantum communication channel.

Quantum dense coding
The quantum dense coding (sometimes called super-dense coding) protocol is less famous than the quantum teleportation protocol, but it is no less important. It achieves the transfer of 2 bits of classical information by sending 1 bit of quantum information and utilising 1 entangled pair of qubits. That is, its goal is the opposite of that of the quantum teleportation protocol.
Just as with teleportation, the protocol is usually described informally: either with a diagram or in English. We formalise the specification of the protocol by using the same variables as in section 3.1:
S ==	a0, a1, φ0 : varAlice ∧ b0, b1, φ1 : varBob ∧ φ01 = (|00⟩ + |11⟩)/√2
'	'	'	'

⇒ b0 = a0 ∧ b1 = a1 ∧ c = c ∧ q
= q +1 

The specification says that if the computation starts with Alice and Bob sharing a maximally entangled state, with classical bits a0 and a1 in Alice’s possession and b0 and b1 in Bob’s possession, then at the end of the computation Bob has the values of Alice’s classical bits, at a cost of sending no bits on a classical channel and one

qubit on a quantum channel. The program for the protocol is:
P == qchan qch : qbit · Alicea0 ,a1 ,φ0 ||φ Bobb0,b1,φ1
where Alice == if a0 = a1 =0 then ok
else if a0 =0 ∧ a1 =1 then φ0 := Xφ0 else if a0 =1 ∧ a1 =0 then φ0 := Zφ0 else φ0 := Y φ0 ;
q := q +1 ; qch!φ0
and Bob == qch?φ0 ; φ := CNOTφ ; φ0 := Hφ0 ; measure φ b0b1
That is, Alice applies one of the three Pauli operators or an identity to her half of the entangled pair, depending on the values of her classical bits, and sends her qubit to Bob. Bob receives the qubit, applies a controlled-not followed by a Hadamard, and measures the two qubits in his possession. We now show that the program P implements the specification S. First, we simplify the processes Alice and Bob:
Alice == φ0 := (−i)a0 ×a1 × Za0 (Xa1 φ0); q := q +1 ; qch!φ0	(math)
Bob == qch?φ0 ; measure H ⊗ I(CNOTφ) b0b1	(substitutions) We now look at their parallel composition:
P == qchan qch : qbit · Alicea0 ,a1 ,φ0 ||φ Bobb0,b1,φ1
== qchan qch : qbit·
((φ0 := (−i)	× Z  (X  φ0); q := q +1 ; qch!φ0)a ,a ,φ

||φ (qch?φ0; measure H ⊗ I(CNOTφ) b0b1)b0 ,b1,φ1 ) quantum channel
== φ := (−i)a0 ×a1 × Za0 ⊗ I(Xa1 ⊗ Iφ); 
0  1  0

q' = q +1 ∧ var'	= varAlice\φ0 ∧ var'	= varBob, φ0 ∧ σ' = σ ;
measure H ⊗ I(CNOT φ) b0b1
sequential composition
== (measure (−i)a0 ×a1 × H ⊗ I(CNOT (Za0 ⊗ I(Xa1 ⊗ Iφ))) b0b1)×
(q' = q + 1) × (var'	= a0, a1) × (var'	= b0, b1, ψ0, ψ1) × (σ' = σ)
Next, we note that the quantum state being measured is: (−i)a0 ×a1 × H ⊗ I(CNOT (Za0 ⊗ I(Xa1 ⊗ I(|00⟩ + |11⟩)/√2)))
== (a0 = 0) × (a1 = 0) × H ⊗ I(CNOT (|00⟩ + |11⟩)/√2)+ √
(a0 = 0) × (a1 = 1) × H ⊗ I(CNOT (X ⊗ I(|00⟩ + |11⟩)/  2))+
(a0 = 1) × (a1 = 0) × H ⊗ I(CNOT (Z ⊗ I(|00⟩ + |11⟩)/√2))+	√

(a0 = 1) × (a1 = 1) × (−i) × H ⊗ I(CNOT (Z ⊗ I(X ⊗ I(|00⟩ + |11⟩)/
apply X
2)))

== (a0 = 0) × (a1 = 0) × H ⊗ I(CNOT (|00⟩ + |11⟩)/√2)+ (a0 = 0) × (a1 = 1) × H ⊗ I(CNOT (|10⟩ + |01⟩)/√2)+ √ (a0 = 1) × (a1 = 0) × H ⊗ I(CNOT (Z ⊗ I(|00⟩ + |11⟩)/



2))+
√

(a0 = 1) × (a1 = 1) × (−i) × H ⊗ I(CNOT (Z ⊗ I(|10⟩ + |01⟩)/
apply Z
== (a0 = 0) × (a1 = 0) × H ⊗ I(CNOT (|00⟩ + |11⟩)/√2)+
(a0 = 0) × (a1 = 1) × H ⊗ I(CNOT (|10⟩ + |01⟩)/√2)+
2))

(a0 = 1) × (a1 = 0) × H ⊗ I(CNOT (|00⟩− |11⟩)/√2)+	√
(a0 = 1) × (a1 = 1) × (−i) × H ⊗ I(CNOT (−|10⟩ + |01⟩)/  2)
apply CNOT
== (a0 = 0) × (a1 = 0) × H ⊗ I(|00⟩ + |10⟩)/√2+
(a0 = 0) × (a1 = 1) × H ⊗ I(|11⟩ + |01⟩)/√2+
(a0 = 1) × (a1 = 0) × H ⊗ I(|00⟩− |10⟩)/√2+	√
(a0 = 1) × (a1 = 1) × (−i) × H ⊗ I(−|11⟩ + |01⟩)/  2
apply H
== (a0 = 0) × (a1 = 0) × |00⟩+ (a0 = 0) × (a1 = 1) × |01⟩+
(a0 = 1) × (a1 = 0) × |10⟩)+
(a0 = 1) × (a1 = 1) × (−i) × |11⟩
== (−i)a0 ×a1 × |a0a1⟩
Putting it all together, we get:
(φ01 = (|00⟩ + |11⟩)/√2) ∧ P	as above
== (measure (−i)a0 ×a1 × |a0a1⟩ b0b1) × (q' = q + 1)×

'
Alice
= a0, a1) × (var'
= b0, b1, ψ0, ψ1) × (σ' = σ)	measure

== (φ' = |b' b' ⟩) × (b'
= a0) × (b'
= a1) × (q' = q + 1)×

'
Alice
= a0, a1) × (var'
= b0, b1, ψ0, ψ1) × (σ' = σ)

≤ S
This example shows formalisation and analysis of a quantum communication protocol which involves a quantum communication channel.

Conclusion and Future Work
We have presented a formal framework for specifying, implementing, and analysing quantum communication protocols. The analysis is not limited to reasoning about the data sent or received during the execution of the protocol. We provide tools to formally prove complexity of the communication protocols, such as the number of classical and quantum bits sent during the execution. We have applied our approach

to two important quantum communication protocols: quantum teleportation and quantum dense coding. The resulting formal proofs are short: in fact, the proofs in Sections 3.1 and 3.2 are only slightly longer than the informal reasoning and calculations in [19]. The proofs are easy to read, the use of Dirac-like notation makes the expressions of quantum states look familiar, while providing a formal treatment that fits in the overall framework. Finally, the formal proofs are checkable by a computer (although we currently do not have suitable software implemented), thus providing a measure of confidence in the analysis of correctness and complexity of the protocols.
Current research focuses on formal reasoning about complexity of distributed quantum algorithms (e.g. [26]). Future work involves formalising quantum crypto- graphic protocols, such as BB84 [8], in our framework and providing formal analysis of these protocols.

References
Abramsky, S., High-level methods for quantum computation and information, in: Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science (2004), pp. 410–414.
Abramsky, S. and B. Coecke, A categorical semantics of quantum protocols, in: Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science (2004), pp. 415–425.
Abramsky, S. and R. Duncan, A categorical quantum logic, Mathematical Structures in Computer Science 16 (2006), pp. 469–489.
Ad˜ao, P. and P. Mateus, A process algebra for reasoning about quantum security, in: Proceedings of the 3rd International Workshop on Quantum Programming Languages, 2007, pp. 3–21.
Altenkirch, T. and J. Grattage, A functional quantum programming language, in: Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science (2005), pp. 249–258.
Arrighi, P. and G. Dowek, Operational semantics for formal tensorial calculus, in: Proceedings of the 2nd International Workshop on Quantum Programming Languages, 2004, pp. 21–38.
Arrighi, P. and G. Dowek, Linear-algebraic λ-calculus, arXiv:quant-ph/0501150 (2005).
Bennett, C. H. and G. Brassard, Quantum cryptography: Public-key distribution and coin tossing, in:
Proceedings of IEEE International Conference on Computers, Systems and Signal Processing.
Bennett, C. H., G. Brassard, C. Cr´epeau, R. Jozsa, A. Peres and W. K. Wootters, Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels, Phys. Rev. Lett. 70 (1993), pp. 1895–1899.
Coecke, B., The logic of entanglement, arXiv:quant-ph/0402014 (2004).
Danos, V., E. Kashefi and P. Panangaden, The measurement calculus, Journal of the ACM 54.
D’Hondt, E. and P. Panangaden, Quantum weakest preconditions, Mathematical Structures in Computer Science 16 (2006), pp. 429–451.
Gay, S. J. and R. Nagarajan, Communicating quantum processes, in: Proceedings of the 32nd ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (2005), pp. 145–157.
Hehner, E. C., “a Practical Theory of Programming,” Springer, New York, 1993, first edition, current edn. (2009) Available free at www.cs.utoronto.ca/~hehner/aPToP.
Hehner, E. C., Probabilistic predicative programming, in: Proceedings of the 7th International Conference on Mathematics of Program Construction, Lecture Notes in Computer Science 3125 (2004),
pp. 169–185.
Hehner, E. C., A probability perspective, Formal Aspects of Computing (2009), to appear.

Jorrand, P. and M. Lalire, Toward a quantum process algebra, in: Proceedings of the 1st ACM Conference on Computing Frontiers (2004), pp. 111–119.
Lalire, M. and P. Jorrand, A process algebraic approach to concurrent and distributed computation: operational semantics, in: Proceedings of the 2nd International Workshop on Quantum Programming Languages, 2004, pp. 109–126.
Nielsen, M. A. and I. L. Chuang, “Quantum Computation and Quantum Information,” Cambridge University Press, 2000.
Sanders, J. W. and P. Zuliani, Quantum programming, in: Mathematics of Program Construction, Lecture Notes in Computer Science 1837 (2000).
Selinger, P., Towards a quantum programming language, Mathematical Structures in Computer Science
14 (2004), pp. 527–586.
Tafliovich, A., “Quantum Programming,” Master’s thesis, University of Toronto (2004).
Tafliovich, A. and E. C. Hehner, Quantum predicative programming, in: Proceedings of the 8th International Conference on Mathematics of Program Construction, Lecture Notes in Computer Science 4014 (2006), pp. 433–454.
Tafliovich, A. and E. C. Hehner, Programming telepathy: Implementing quantum non-locality games, in: Proceedings of the 10th Brazilian Symposium on Formal Methods (2007), pp. 70–86.
Valiron, B., Quantum typing, in: Proceedings of the 2nd International Workshop on Quantum Programming Languages, 2004, pp. 163–178.
Yimsiriwattana, A. and S. J. L. Jr, Distributed quantum computing: A distributed Shor algorithm, arXiv:quant-ph/0403146 (2004).
Zuliani, P., “Quantum Programming,” DPhil thesis, University of Oxford (2001).
Zuliani, P., Non-deterministic quantum programming, in: Proceedings of the 2nd International Workshop on Quantum Programming Languages, 2004, pp. 179–195.

A  Quantum Computation
In this section we introduce the basic concepts of quantum mechanics, as they pertain to the quantum systems that we consider for quantum computation. The discussion of the underlying physical processes, spin- 1 -particles, etc. is not our interest. We are concerned with the model for quantum computation only. A reader not familiar with quantum computing can consult [19] for a comprehensive introduction to the field.
The Dirac notation, invented by Paul Dirac, is often used in quantum mechanics. In this notation a vector v (a column vector by convention) is written inside a ket :
|v⟩. The dual vector of |v⟩ is ⟨v|, written inside a bra. The inner products are
bra-kets ⟨v|w⟩. For n-dimensional vectors |u⟩ and |v⟩ and m-dimensional vector
|w⟩, the value of the inner product ⟨u|v⟩ is a scalar and the outer product operator
|v⟩⟨w| corresponds to an m by n matrix. The Dirac notation clearly distinguishes vectors from operators and scalars, and makes it possible to write operators directly as combinations of bras and kets.
In quantum mechanics, the vector spaces of interest are the Hilbert spaces of dimension 2n for some n N. A convenient orthonormal basis is what is called a computational basis, in which we label 2n basis vectors using binary strings of length n as follows: if s is an n-bit string which corresponds to the number xs, then |s⟩ is a 2 -bit (column) vector with 1 in position xs and 0 everywhere else. The tensor product |i⟩⊗ |j⟩ can be written simply as |ij⟩. An arbitrary vector in a Hilbert space can be written as a weighted sum of the computational basis vectors.

Postulate 1 (state space) Associated to any isolated physical system is a Hilbert space, known as the state space of the system. The system is completely described by its state vector, which is a unit vector in the system’s state space.
Postulate 2 (evolution) The evolution of a closed quantum system is described by a unitary transformation.
Postulate 3 (measurement) Quantum measurements are described by a collec- tion {Mm} of measurement operators, which act on the state space of the system being measured. The index m refers to the possible measurement outcomes. If the state of the system immediately prior to the measurement is described by a
vector |ψ⟩, then the probability of obtaining result m is ⟨ψ|M † M |ψ⟩, in which
case the state of the system immediately after the measurement is described by

the vector
  Mm|ψ⟩	 . The measurement operators satisfy the completeness
⟨ψ|M † Mm|ψ⟩

equation Σ m · M † M
== I.

An important special class of measurements is projective measurements, which are equivalent to general measurements provided that we also have the ability to perform unitary transformations.
A projective measurement is described by an observable M , which is a Hermitian
operator on the state space of the system being measured. This observable has a spectral decomposition M = Σ m · λm × Pm, where Pm is the projector onto
the eigenspace of M with eigenvalue λm, which corresponds to the outcome of
the measurement.  The probability of measuring m is ⟨ψ|Pm|ψ⟩, in which case
immediately after the measurement the system is found in the state	Pm|ψ⟩	.
⟨ψ|Pm|ψ⟩
Given an orthonormal basis |vm⟩, 0 ≤ m < 2n, measurement with respect to this basis is the corresponding projective measurement given by the observable
M = Σ m · λm × Pm, where the projectors are Pm = |vm⟩⟨vm|.
Measurement with respect to the computational basis is the simplest and the most commonly used class of measurements. In terms of the basis |m⟩,0 ≤ m < 2n, the projectors are Pm = |m⟩⟨m| and ⟨ψ|Pm|ψ⟩ = |ψm|2. The state of the system immediately after measuring m is |m⟩.
For example, measuring a single qubit in the state α × |0⟩ + β × |1⟩ results in the outcome 0 with probability |α|2 and outcome 1 with probability |β|2. The state of the system immediately after the measurement is |0⟩ or |1⟩, respectively.
Suppose the result of the measurement is ignored and we continue the com- putation. In this case the system is said to be in a mixed state. A mixed state is not the actual physical state of the system. Rather it describes our knowl- edge of the state the system is in. In the above example, the mixed state is expressed by the equation |ψ⟩ = |α|2 × {|0⟩} + |β|2 × {|1⟩}. The equation is meant to say that |ψ⟩ is |0⟩ with probability |α|2 and it is |1⟩ with probability
|β| . An application of operation U to the mixed state results in another mixed state, U (|α|2 × {|0⟩} + |β|2 × {|1⟩})= |α|2 × {U |0⟩} + |β|2 × {U |1⟩}.
Postulate 4 (composite systems) The state space of a composite physical sys- tem is the tensor product of the state spaces of the component systems. If we

have systems numbered 0 up to and excluding n, and each system i, 0 ≤ i < n, is prepared in the state |ψi⟩, then the joint state of the composite system is
|ψ0⟩⊗ |ψ1⟩⊗ ... ⊗ |ψn−1⟩.
While we can always describe a composite system given descriptions of the com- ponent systems, the reverse is not true. Indeed, given a state vector that describes a composite system, it may not be possible to factor it to obtain the st√ate vector√s of

the component systems. A well-known example is the state |ψ⟩ = |00⟩/
Such a state is called an entangled state.
2+|11⟩/  2.

Just as it may not be possible to represent the state of a multi-qubit system as tensor product of its component systems, it may not be possible to represent an operation on a composite system as a tensor product of single-qubit operations on the component systems. Consider, for example, “controlled-NOT” (CNOT) operation on two qubits defined by
CNOT (|0⟩⊗ |x⟩)= |0⟩⊗ |x⟩
CNOT (|1⟩⊗ |x⟩)= |1⟩⊗ |1 − x⟩
where x ∈ 0, 1. It can be shown that there are no two single-qubit operations U0
and U1, such that CNOT = U0 ⊗ U1.
