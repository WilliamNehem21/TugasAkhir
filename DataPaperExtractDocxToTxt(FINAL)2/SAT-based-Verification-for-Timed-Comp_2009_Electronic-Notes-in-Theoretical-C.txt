

Electronic Notes in Theoretical Computer Science 255 (2009) 103–118
www.elsevier.com/locate/entcs

SAT-based Verification for Timed Component Connectors
Stephanie Kemper1
Centrum Wiskunde & Informatica, Amsterdam, The Netherlands, s.kemper@cwi.nl


Abstract
Component-based software construction relies on suitable models underlying components, and in particular the coordinators which orchestrate component behaviour. Verifying correctness and safety of such systems amounts to model checking the underlying system model, where model checking techniques not only need to be correct but—since system sizes increase—also scalable and efficient.
In this paper, we present a SAT-based approach for bounded model checking of Timed Constraint Automata. We present an embedding of bounded model checking into propositional logic with linear arithmetic, which overcomes the state explosion problem to deal with large systems by defining a product that is linear in the size of the system. To further improve model checking performance, we show how to embed our approach into an extension of counterexample guided abstraction refinement with Craig interpolants.
Keywords: Timed Constraint Automata, Abstraction Refinement, Model Checking, SAT, Component-based Software Engineering


Introduction
Component-based software engineering amounts to constructing large systems by composing individual components. The correctness and safety of these concurrent systems depend on actions that happen at the right time, i.e., before or after a certain deadline, or within a certain time interval. As components are often available as black boxes only, timed coordination has to be done by the time-aware component connectors. Timed Constraint Automata [4] (TCA) have been originally defined as a semantical model for the coordination language Reo [3]. They offer a powerful stand-alone coordination mechanism for implementing coordinating connectors in networks of timed components exchanging data through multiple channels.
The computational complexity introduced by the infinite state space of these real-time systems leads to severe limitations in scalability even within very well- established model checkers like Uppaal (http://www.uppaal.com). Aside from the

1 Part of this research has been funded by the Dutch BSIK/BRICKS project.

1571-0661© 2009 Elsevier B.V.Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.027

omnipresent state explosion problem [9] already present in finite state model check- ing, current model checking techniques for real-time systems are still limited in the number of concurrent quantitative temporal observations (measured by clocks). A particularly dramatic cause of the state explosion problem is the exponential blow-up obtained by forming the cross product for parallel composition of TCA. To avoid this, we define a linear-size parallel composition for the logical representation of TCA. Typically, only a reduced part of the full parallel composition has to be expanded from our representation during satisfiability checking (SAT solving).
Very sophisticated and well-optimised techniques (e.g., [17]) guide high-end SAT solvers to explore only a comparably narrow fragment around the part of the state space relevant for the particular safety property. We build upon this development by choosing a linear arithmetic/propositional encoding, a philosophy that has suc- cessfully proven its great potential in finite state systems [8]. With this basis, we exploit the particularities of transition systems induced by TCA using abstraction refinement to deal with the challenges of infinite states.

Timed Constraint Automata.
TCA are a combination of constraint automata [5] (CA) and timed automata (TA) with location invariants [2,1], offering a powerful coordination mechanism to model coordinators in dynamically reconfiguring networks of a static number of components. Rather than having direct static connections between the compo- nents, communication is orchestrated by connectors “in the middle”, which impose a certain communication pattern—for example delays—on associated components. Moreover, the coordinator can dynamically reconfigure the network (connections), by sending data values received from an input component to different output com- ponents (and vice versa). Still, from the component’s perspective, communication happens via the same connection in all cases. The major conceptual difference to other timed models like TA is that a positive amount of time is required to elapse before every visible data flow. This reflects the idea that actions which happen at the same time are truly atomic and thus collapse to a single transition.

Abstraction Refinement.
Abstraction refinement [9,12] is a promising direction of research to overcome the challenges of the state explosion problem and infinite state model checking, while preserving correctness of verification results. Abstraction techniques over- approximate system behaviour by removing constraints that are considered irrele- vant for verifying a particular specification. If the abstract system is safe (no error state is reachable) then, by conservative over-approximation, so is the original.
Based on the representation of TCA in propositional logic with linear arithmetic, the iterative abstraction refinement loop consists of the following steps: applying the abstraction function to the representation, we automatically produce a simpler
abstract version of it. After unfolding the resulting transition formula k times, a
satisﬁability check solves the bounded reachability question in the abstract system. Depending on the outcome, the system has either been proven safe (error state is

unreachable) within bound k, or needs to be analysed with respect to an abstract counterexample (concretised ), again using SAT solving. If the abstract counterex- ample has a counterpart in the non-abstracted system, then the real-time system is unsafe. Otherwise, the counterexample is spurious and results from an inappropri- ate choice of abstraction. Analysing the counterexample (with Craig interpolants derived by the SAT solver, e.g. FOCI (based on [16]) or MathSAT [15]) then helps to reﬁne the abstraction and start over until the system is proven safe (within bound k) or unsafe.

Implementation
We have extended the CA editor in the Eclipse Coordination Tools [10] to support generation and editing of TCA (including various syntactical checks, e.g. well-formedness of clock constraints). Within this platform, we have implemented the translation of TCA to propositional formulas with linear arithmetic constraints (front end), as described in this paper. Further, we have implemented the generation of input files for the MathSAT solver (back end), allowing us to analyse the under- lying TCA in detail. Having split the formula generation in two parts, it is very easy to switch to another solver, by just exchanging the back end. This implementation is scheduled to be part of the next release of the Eclipse Coordination Tools.

Organisation of the Paper.
In the next section, we discuss some related work. After introducing TCA and bounded model checking (BMC) in Section 3, we present a faithful representation of TCA in propositional logic with linear arithmetic for BMC in Section 4, and give some soundness results. In Section 5, we introduce a uniform abstraction, extend the algebraic perspective on soundness from Section 4 to correspondence results about abstraction, and briefly recall how to exploit spurious counterexamples for refining abstractions. Section 6 concludes the paper and discusses some future work.

Related Work
Blechmann and Baier [7] present a purely propositional symbolic encoding of CA, tailored for finite-state bisimulation checking using ordered binary decision dia- grams. While it is not clear how to integrate timing information into their approach (and how to handle the induced infinite state space), our approach in addition is specifically fitted for abstraction refinement.
Jhala and McMillan [13] present an abstraction refinement approach for predi- cate abstraction. Using interpolants, they generate refinements which take into ac- count specific characteristics of the property. A limitation, however, is the fact that their approach relies on an appropriate choice of predicates for predicate abstrac- tion. Our approach can be considered as a quick (hence, scalable) approximation of predicate abstraction, where predicate discovery is evident by exploiting the nature of TCA.

The abstraction refinement framework presented by Clarke et al. [9] works with Kripke structures originating from finite state programs. In contrast, our approach deals with the challenges of infinite state model checking, as introduced by the notion of real-time clocks. Further, we directly use a formula representation which is tailored for SAT-based bounded model checking.
In this paper, we build on the SAT-based approach for TA presented by Kemper and Platzer [14], but take into account the special transition characteristics of TCA (namely that a positive amount of time has to elapse before every visible transition), and include data and data constraints. We define an abstraction function that is simple, yet powerful, and is able to preserve more information in the abstract case than the corresponding abstraction function in [14], which reduces the number of spurious counterexamples.
The model checker Vereofy (http://www.vereofy.de) provides tools for model checking (untimed) CA, but to the best of our knowledge, the framework presented in this work is the first approach for model checking TCA.

Timed Constraint Automata
In this section, we introduce the standard notations for TCA [4] in the dense time domain Time=R≥0, and for BMC [8], and we present our running example.

Syntax
In the sequel, let N be a finite, nonempty set of ports, through which TCA exchange data values, and let Data be a finite data domain of possible data values which can be sent or received via ports. For simplicity of representation, we assume Data contains a special element ⊥ representing “no data”.
Definition 3.1 [Data Constraint, Clock Constraint] A data assignment δ∈DA(N ) over (data domain Data and) port set N is a mapping δ:N→Data, assigning to each port A∈N the data value which is (currently) pending at A. 2 We use the shorthand notation dA for the value δ(A). A clock valuation ν∈V(X ) over a ﬁnite set of clocks X is a mapping ν:X →Time assigning to each clock x∈X an element from the time domain Time, its current value.
Data constraints dc∈DC(N ) over (data domain Data and) port set N , and clock constraints cc∈CC(X ) over X are defined as follows:
dc ::= true | dA =d | dc1 ∧ dc2 | ¬dc, with A∈N and d∈Data
cc ::= true | x∼n | cc1 ∧ cc2, with x∈X , n∈N and ∼ ∈{<, ≤, =, ≥, >}.

We use the symbol |= for the standard satisfaction relation on data and clock constraints. To ensure that clock constraints hold among subsequent steps, we assume them to be convex, i.e., they do not contain ∨, ¬ [1]. This property is used

2 If no data is pending at port A, δ(A) evaluates to the special value “no data”.

for efficient representation. Non-convex clock constraints however can be simulated by splitting locations (for invariants) respectively transitions (for guards).
Definition 3.2 [Timed Constraint Automaton] A TCA (over data domain Data) is a tuple T =(S, X, N, E, s0,I), with S a finite set of locations, s0∈S the initial loca- tion, X a finite set of clocks, N a finite set of ports, I:S→CC(X ) a function assigning a clock constraint (location invariant ) to every location, and the finite set of transi- tions E⊆S×2N ×DC(N )×CC(X )×2X ×S. For a transition t=(s, N, dc, cc, X, s')∈E, we require dc∈DC(N ) (data guard of t) and cc∈CC(N ) (clock guard of t), and both to be satisfiable. X is called clock set of t, and N is called port set of t; if N =∅, transition t is called invisible, otherwise, it is called visible.
The idea of visible and invisible transitions is that the latter do not represent observable data flow (as no ports are involved), but just serve for internal syn- chronisation purposes, for example by resetting clocks. The former correspond to observable behaviour, namely data flow through all ports contained in the port set of the transition.
Remark 3.3 [Notation of TCA] If not stated otherwise, below we shall always assume the constituents of a TCA T to be denoted as T =(S, X, N, E, s0,I).

Within a system of TCA, two automata synchronise if the port sets of the involved transitions coincide on common ports. This gives rise to the following definition.
Definition 3.4 [TCA Product] Let Ti=(Si, Xi, Ni, Ei, s0,i, Ii), i=1, 2, be TCA, with X1∩X2=∅ and S1∩S2=∅ (can be achieved by renaming). The product of T1 and T2, denoted T1daT2, is a new TCA T1daT2=(S1×S2, X1∪X2, N1∪N2, E, (s0,1, s0,2),I), with I:S1×S2→CC(N1∪N2) such that I(s1, s2)=I1(s1) ∧ I2(s2), and E is defined by


(s1, N1, dc1, cc1, X1, s' )∈E1
(s2, N2, dc2, cc2, X2, s' )∈E2
	N1∩N2 = N2∩N1, N1/=∅, N2/=∅, dc1∧dc2/=false	
(⟨s1, s2⟩, N1∪N2, dc1∧dc2, cc1∧cc2, X1∪X2, ⟨s' , s' ⟩)∈E



(1)

1  2


 (s1, N1, dc1, cc1, X1, s' )∈E1, N1∩N2 = ∅, s2∈S2
(⟨s1, s2⟩, N1, dc1, cc1, X1, ⟨s' , s2⟩)∈E

(2)

and the symmetric rule of the latter.
Rule (1) captures the synchronisation of visible transitions: the nonempty port sets have to coincide on common ports, i.e. data flows through the same set of shared ports on both transitions. The case where N1∩N2=N2∩N1=∅ (i.e., the set of shared ports is empty) represents a system step where each automaton performs a local visible transition. Rule (2) describes the execution of a local transition (visible or invisible) in one automaton, while the other automaton remains in its current location. Note that in case this local transition is preceded by a time delay, the other automaton actually performs a delay transition.

Semantics
In TCA, a positive amount of time has to elapse before every visible transition, while invisible transitions may be instantaneous. The underlying idea is that all actions which happen at the same time atomically collapse to a single transition. Other timed models, like e.g. TA, allow to execute a sequence of visible transitions without delays in between, such that a sequential order is imposed on actions which conceptually happen at the same time. Such behaviour is ruled out in the semantics of TCA, which is defined as the set of runs of the associated labelled transition system (LTS) ST [4].
Configurations ⟨s, ν⟩ of ST consist of a location s and a clock valuation ν, such that ν satisfies the invariant I(s) of s. A delayed transition ⟨s, ν⟩−N−,−δ→,t ⟨s', ν+t[X:=0]⟩ in ST , with t>0, results from a transition (s, N, dc, cc, X, s') in T . It increases all clocks by the same amount of time t (delay), such that the guard cc is satisfied
afterwards, data flows through all ports in N , while the data assignment δ satisfies the data constraint dc, and all clocks in X are reset to zero. In addition, an in- visible transition (s, ∅, true, cc, X, s') in T gives rise to an instantaneous transition
⟨s, ν⟩−∅−,∅→,0 ⟨s', ν[X:=0]⟩ in ST , where ν satisfies the guard cc, and all clocks in X
are set to zero. A run of ST starting in conﬁguration q, denoted q, is a sequence

of transitions q=q N,δ,t q
N',δ',t'
... which is either time divergent (i.e. infinite, and

−−−→ 1−−−−→
t+t'+ ... =∞) or finite and ends in a terminal conﬁguration ⟨s, ν⟩ (i.e.  without
outgoing transitions, allowing for infinite passage of time: ∀t>0:ν+t|=I(s)). The trace semantics of T is given by the set RunT of initial runs (i.e., starting in the initial configuration) of ST . With RunT,k, we denote the set of finite prefixes of elements of RunT of (at most) length k.

Example
An example for a TCA network with dynamic reconfiguration is shown in Figure 1. We assume Data={1, 2} (thus, actually Data={1, 2, ⊥}, and we omit constraints equal to true as well as empty sets on transitions.

CO:


{C}, x<3, dC =1	{C}, x<3, dC =2


C1:

{A}, dA=1
C2:

{B}, dB=2
C3:

{C}, v>2, v:=0





⟨i, x=0⟩ {A},δ(A)=1,2 ⟨c1, x=0⟩ {C},δ(C)=1,1 ⟨i, x=1⟩ {B},δ(B)=2,1 ⟨c2, x=0⟩ ∅,∅,3 ⟨i, x=3⟩ ... 

−−−−−−−−−→
−−−−−−−−−→
−−−−−−−−−→
−−−→


Fig. 1. Dynamic Reconfiguration of a Network

The automata represent a network of three simple components (C1, C2 and C3, in the middle), together with a coordinator (CO, at the top) which orchestrates data flow between the components. The general idea of the coordinator is to repeatedly receive input from either component C1 (through port A) or C2 (through port B), and to send the received data value to component C3 (through port C), which delays for at least 2 time units between the receiving of subsequent data items. Further, the connector only accepts data value 1 from C1, and data value 2 from C2. The reconfiguration of connecting either C1 or C2 to C3 is done purely by the coordinator; from the perspective of C3, nothing changes, since data always arrives through the same port C. In addition, the coordinator has a timeout constraint: if the received data item is not accepted by C3 within 3 time units, it is lost, which is represented by the invisible transitions with guard x=3. An example run of the coordinator is shown at the bottom of Figure 1.

Bounded Model Checking
Bounded model checking (BMC) has turned out to be amongst the most promising approaches for verification of safety properties [8]. The principle is to examine prefix fragments of the transition system, and successively increase the exploration bound until it reaches (a computable indicator of) the diameter of the system—in which case the system has been proven safe—or an unsafe run has been discovered.
Definition 3.5 [Bounded safety] Let T be a TCA, let s∈S be an error location. T is safe with respect to s within bound k, denoted by T |=k¬∃ s, if there is no run in RunT,k ending in s. Otherwise, T is called unsafe with respect to s.
The lifting of ¬∃ s to reason about configurations rather than locations is straightforward. On the basis of these reachability properties, other bounded LTL specifications can be verified as well, using the encoding in [6].

Representation of Timed Constraint Automata
In this section, we construct a formula ϕ(T ) in propositional logic with linear arith- metic that represents the behaviour of a TCA T (given by the runs of ST , cf. Sec- tion 3.2), by defining transition characteristics from step t-1 to step t. For BMC, we unfold ϕ(T ) k times (for k steps), which yields a formula ϕ(T )k representing all (prefixes of) runs of ST for k steps. This formula, together with a representation of the safety property, is unsatisfiable iff T is safe within bound k.

Basic Components
The possible behaviour of a TCA depends on the values of its constituents (clocks, locations, data pending at ports), and changes over time. Therefore, we “parame- terise” the variables representing these constituents by the step t they are evaluated in, and we call this localisation: the localisation ψt of a formula ψ is obtained by

adding index t to all variable symbols occurring in ψ. Thus, if ψ is of vocabulary
x, s, d, ψt is of vocabulary xt, st, dt instead. In particular, we use:
Locations For every location s∈S, the Boolean variable st represents whether the TCA is in location s in step t.
Data Values, Ports The injective mapping Δ:Data→N assigns a natural number
def
ti to each element di of Data, with 1≤ti≤|Data|, and t|Data| = t⊥ representing ⊥.
For every port A∈N , the Boolean activity variable At of A represents whether
data flows through A in step t, and the natural data variable DAt of A represent which data occurs at A in step t (in case of no data flow, DAt evaluates to t⊥).
Data Constraints For a data constraint dA =di, with Δ(di)=ti, the formula
At ∧(DAt =ti) evaluates to true iff δ(A)=di in step t.
Clocks For every clock x∈X , the rational variable xt (clock reference) represents the absolute point in time where x was last reset prior to step t. An additional rational variable zt (absolute time reference) represents the absolute amount of time that has passed until step t. The clock value of x at step t is thus obtained by zt −xt. Note that linear arithmetic is equisatisfiable for rational and real variables [14].
Clock Constraints For a clock constraint cc=x∼n (cf. Definition 3.1), the formula zt−xt∼n, denoted cct, evaluates to true iff cc holds in step t, and the formula zt −xt 1∼n, denoted cctΔ and called inter-step representation, evaluates to true iff cc holds in step t and x has not been reset since step t-1.
The representation of other constraints is straightforward, by using conjunctions (and negations, in case of data constraints) of the aforementioned representations. The inter-step representation is needed for correct representation of delayed transitions in ST , cf. Section 3.2: the invariant of the target location s' is evaluated
under the valuation ν+t[X:=0], that means after the time delay and after the
execution of the transition. In contrast, the invariant of the source location s and the clock guard of the transition are evaluated under the valuation ν+t, that means after the passage of time, but before the execution of the transition. The inter-step
representation is used to access the clock value at this particular point in time “in the middle” of the execution step.
Transition Relation
The representation of the transition relation needs to take care of the special be- haviour of TCA, namely, that every visible transition has to be preceded by a pos- itive time delay, whereas invisible transitions may be instantaneous. It constrains the possible valuations of variables representing the configuration at subsequent step t depending on those at step t-1. Conceptually, the delay is represented by evolving from t-1 to t, while the (instantaneous) location change takes place at t.
Definition 4.1 [Timed Constraint Automaton Representation] Let T be a TCA, let e=(s, N, dc, cc, X, s') and e' =(s, ∅, true, cc, X, s') be a visible respectively invisi- ble transition in T . The formula representation ϕ(T ) of the transition relation of T

is defined in (10) in Figure 2.


qi(T )= ¯s0 ∧ I(¯s)0 ∧	V
¬s0 ∧ V
(¬A0 ∧(DA0=t⊥)) ∧ V (x0=0) ∧(z0=0)	(3)

qv(e)= st 1 ∧
A∈N
s∈S,s/=s¯
At ∧
A/∈N
A∈N
¬At ∧ dct ∧	(xt=zt) ∧
x∈X
x∈X
(4)

(xt=xt 1) ∧(zt 1<zt) ∧ cctΔ ∧ I(s)tΔ
x/∈X
∧ s't

qτ (e)= st 1 ∧ V
¬At ∧ V (xt=zt) ∧ V (xt=xt 1) ∧(zt 1≤zt) ∧ cctΔ ∧ I(s)tΔ
∧ s't	(5)

A∈N
x∈X
x/∈X

qE (T )=	qv(e) ∨
e∈E,N/=∅	e∈E,N =∅
qτ (e)	(6)

qS (T )= V `¬st ∨ I(s)t´ ∧	V
¬(st ∧ s' )	(7)

s∈S
qD(T )= 
A∈N
s' ∈S,s≺s'
¬At ⇔ DAt=t⊥ ∧
A∈N
`(DAt≥t1) ∧(DAt≤t⊥)´	(8)

qd(s)= st 1 ∧ st ∧(zt 1≤zt) ∧
A∈N
¬A ∧	(xt=xt 1)	(9)
x∈X

q(T )= qi(T ) ∧ qE (T ) ∧ qS (T ) ∧ qD(T )	(10)
q(T1daT2)= q(T1) ∧ q(T2)	(12)

q(T )k =
1≤j≤k
q(T )j/t	(11)
q(T1daT2)k =
1≤j≤k
q(T1daT2)j/t	(13)

Fig. 2. Transition relation representation
The automaton starts in its initial location s¯ (3) in step 0, 3 the invariant of which has to be satisfied, all clocks are set to zero, and data must not flow through any port. Before executing a visible transition (4) in step t, T is in location s. After the elapse of a positive amount of time (zt 1<zt), after which the invariant I(s)tΔ of s and the clock guard cctΔ of the transition hold, T switches to location s'. All clocks referenced in the clock set X are set to the actual point in time, while the values of the other clocks do not change. Data flows through all ports A contained in the port set N , while the other ports are inactive, and the data constraint dct is satisfied. Due to convexity, the invariant needs to be checked at the end of the time delay only, as it inductively holds at the beginning (3), (7). The execution of an invisible transition (5) is similar, except that the amount of time elapsed may be zero, and data must not flow through any port. The disjunction of all visible and invisible transitions expresses nondeterministic transition choice (6).
In any step, the current location is unique, and its invariant holds (7) (≺ denotes an arbitrary but fixed order on the location set S). For ports without data flow, the pending data value has to be the special value “no data”, and only values from the domain Data may be pending at the ports (8).

Unfolding for Bounded Model Checking
In order to represent the reachability problem of BMC for a TCA T in logic, the formula representation ϕ(T ) (10) is unfolded, i.e., instantiated for all steps up to bound k. The resulting formula ϕ(T )k is called k-unfolding of T , and is defined in (11), where ψj/t denotes the localisation of ψ, with index t replaced by j.

3 To avoid confusion with localisation indices, in (3) we denote the initial location as s¯ rather than s0, so its representation is ¯s0 rather than the odd-looking (s0)0.

Intuitively, a satisfying interpretation (model) of ϕ(T )k corresponds to a run of ST of length k, i.e., to one possible behaviour of T for the first k steps. Check- ing the reachability of an error location s amounts to conjoining ϕ(T )k with the
representation ρ d=ef s ∨s ∨ ... ∨s of the reachability property, such that T |= ¬∃ s
0	1	k	k
holds iff the conjunction ϕ(T )k∧ρ is unsatisfiable. Lifting ρ to reason about con- figurations or even execution sequences is straightforward. For example, an LTL property s→◯ s' can be represented as ρ=(s0∧s'1)∨(s1∧s'2)∨ ... (sk 1∧s'k).

Example
Consider again the TCA C3 in Figure 1. With Data={1, 2, ⊥}, and Δ such that Δ(1)=1, Δ(2)=2, and Δ(⊥)=3, the representation of C3 according to Definition 4.1 is shown in Figure 3 (we omit constraints equal to true).

qi(C3)=s30∧¬C0∧(DC0=3)∧(v0=0)∧(z0=0)	qD(C3)=(¬s3t⇔(DCt=3))∧(DCt≥1)∧(DCt≤3)
qE (C3)=s3t 1∧Ct∧(vt=zt)∧(zt 1<zt)∧(zt−vt 1>2)∧s3t  q(C3)= qi(C3)∧qE (C3)∧qD(C3)

Fig. 3. TCA Representation Example


Product of Timed Constraint Automata
The cross product of TCA, as defined in Definition 3.4, is exponential in the worst case, which is a severe limitation to the size of systems that can be verified. We define a logical representation of systems of TCA which is linear in the number of automata. The basic idea is to retain the representations of the individual automata, and model check them “in parallel”. We require variables representing common ports to have the same name in both representations, such that constraints involving these ports are automatically satisfied simultaneously in both representation.
To model single local transitions, as described by (1) in Definition 3.4, we in- troduce explicit delay transitions (cf. Section 3.1): the representation of a delay transition ϕd(s) in location s is defined in (9). Note that these delay transitions are in accordance with Definition 3.2, as they correspond to invisible loops of the form (s, ∅, true, true, ∅, s). Therefore, in particular, (9) permits zero-delays. For two TCA T1 and T2, with X1∩X2=∅ and S1∩S2=∅ (can be achieved by renaming), the representation of T1daT2, denoted ϕ(T1daT2), is given in (12), where (6) is un- derstood to be the disjunction of (4), (5) and (9). The k-unfolding of the product is defined in the same way as for individual automata, it is shown in (13).
Note that the existence of such a linear product is not immediately clear, but in fact is a result of our design decision of explicitly mentioning all ports on each transition (cf. (4), (5) and (9)). This decision—though seeming unnecessary at first glance—together with the assumption that common ports have the same name, en- sures that transitions in different TCA may only be executed in parallel if they fulfil the conditions described in Definition 3.4. In this way, we do not need to mention all possible synchronisations explicitly, and thus avoid the exponential blow-up.

Theorem 4.2 (Correctness of representation) The formula representation of TCA, as deﬁned in Deﬁnition 4.1, is correct, that means it exhibits the same be- haviour as T .
We have proven this by showing that every model of ϕ(T )k corresponds to a run of length k of T , and vice versa. The results directly carry over to the product representation. For a detailed discussion and proof, we refer to the extended version of this paper, available at www.cwi.nl/~kemper.
Discussion
Using propositional formulas as intermediate representation (“front end”), we may fall back on the abstraction refinement framework of [14] (“back end”), and, more importantly, we can take advantage of existing high-performance SAT solving tech- nologies. Our representation is specifically tailored for SAT solving: in addition to providing conjunctive normal form (CNF) whenever possible, (7) and (8) are binary clauses, while (3) even consists of unit clauses. With respect to speed of verification, binary clauses are very efficient: the 2-SAT problem is polynomial. Though—due to the disjunctive nature of transition choices—(6) is not in CNF, it can easily be transformed to short CNF (see e.g. [11]) when introducing new symbols.
The restriction to convex clock constraints does not reduce the expressiveness of our model (cf. Section 3.1), but on the contrary significantly simplifies the rep- resentation formulas, since clock constraints need to be checked at the beginning and at the end of a time delay only, rather than at all intermediate points (cf. (7)). We further simplify verification by defining a product representation which is linear in the number of automata (12). In this way, we also avoid the exponential state space blow-up when forming the cross product.
Though communication is often regarded as a one-to-one relation, our represen- tation is already suited for general n-ary communication: by having ports carrying the same name in more than two automata, our approach naturally generalises to one-to-many or even many-to-many communication models.
Abstraction
In this section, we show how to adapt the abstraction technique of abstraction by merging omission (MO) [14] to our representation. MO is a simple and fast but nevertheless powerful abstraction technique specifically tailored to work on logical formulas. The removal of constraints considered irrelevant to the particular safety property yields an over-approximation.

Abstraction by Merging Omission
The basic idea of MO is to reduce the system complexity by decreasing the num- ber of symbols in ϕ(T ), while retaining as much information about the transition characteristics as possible (the abstract formula is weaker than ϕ(T ), though). It is defined for formulas in negation normal form (NNF), to which ϕ(T ) can be easily

transformed. MO uniformly works on the different syntactical categories: it merges location and port variables, by mapping them to the same image according to a map of merging, and it removes rational variables and arithmetic constraints according to a set of omission.
Definition 5.1 [Abstraction by merging omission] Let T be a TCA, let ϕ(T ) be in NNF. Let S, X, NA and NDA be the variable sets representing locations, clocks, port activity variables and port data variables, respectively, all without indices, let ϑ:NDA→NA be a mapping such that v∈NDA and ϑ(v)=v'∈NA are data and activity variable of the same port. Let AS ⊆ X∪CC(X)∪DC(NDA) be a set not containing compound formulas, let γ:S∪NA→S'∪˙ NA' be a mapping to some fresh sets of propo- sitional variables S' and NA'.
The abstraction by merging omission of ϕ(T ) with respect to AS and γ is defined by applying transformation α, as depicted in Figure 4.



8>	L	L neg., cont(L) ∩(S ∪ NA) /= ∅,γ(cont(L))=id	(14a)


α(L)= 
><

>>:
L	L neg., cont(L) ∩(AS ∪ S ∪ NA)= ∅,
∀v∈cont(L)∩NDA:γ(ϑ(v))=id γ(L)	L pos.,cont(L) ∩ AS = ∅,
∀v∈cont(L)∩NDA:γ(ϑ(v))=id
(14b)

(14c)



α(F ∧ G)=	α(F ) ∧ α(G)
α(F ∨ G)=	α(F ) ∨ α(G)
Here, F and G are formulas in NNF, L a literal, cont(L) the set of atomic formulas and variables occurring in L. We understand γ to be applied recursively to elements v∈cont(L) if v∈S∪NA: for example, γ(¬s)= 
¬γ(s), γ((z−x)∼c)= ((z−x)∼c), and γ(DA=t)= (DA=t).
Fig. 4. Abstraction by merging omission

MO uniformly captures abstraction on all syntactic categories contained in ϕ(T ): negative propositional variables not meant to be abstracted are kept un- changed (14a), the map γ is applied to positive propositional variables only ((14c), γ is the identity for symbols not meant to be abstracted). Clock constraints not con- tained in AS are retained unchanged, for both positive (14c) and negative (14b) constraints. Data constraints are treated in a similar way as clock constraints. However, to guarantee α yields an over-approximation, we may retain only those data constraints that reason about ports not merged by γ, ensured by the constraint
∀v∈cont(L)∩NDA:γ(ϑ(v))=id in (14b) and (14c). In all other cases, α maps the literal to true (14d), in this way performing a quick variant of existential abstraction [9], while exploiting the structural relationships of clocks and TCA. This gives rise to the following lemma.
Lemma 5.2 (Abstraction by weakening) The abstraction MO yields a conser- vative approximation, that means α(F ) is weaker than F in the sense that the im- plication F→α(F ) is valid (true in all models).
Lifting α to the presence of localisations is straightforward: γ and AS are under- stood oblivious to indices in the NNF of ϕ(T ), such that indices directly carry over

to ϕ(T )k unchanged (defining different abstractions for different steps is possible using the same definition of α but we consider it to be less useful). Note that α is homomorphic with respect to {∧, ∨}, which proves the equality of α(ϕ(T )k) and α(ϕ(T ))k (except for speed of computing the abstraction, where α(ϕ(T ))k is superior).
The major difference between our abstraction function and the one presented in [14] is the fact that we do not in general map negative propositional variables to true (14a). Such abstraction is of course necessary for symbols meant to be abstracted, as ¬s does not allow to conclude ¬u in case of a merge γ(r)=γ(s)=u. However, in case γ(s)=s, i.e. when s is kept unchanged, it is safe to keep ¬s in the abstract formula α(ϕ(T )). Furthermore, with respect to meaningful results, we even consider it necessary to retain ¬s, as otherwise the abstraction becomes too coarse: mapping all negative propositional symbols to true, the abstraction effectively deletes the consistency constraint ϕS(T ) on locations (7) as well as part of the consistency constraint ϕD(T ) on data values (8), such that the rest becomes meaningless. In particular, the existence of a TCA T˜, as claimed in the correctness proof of the abstraction, cannot be guaranteed any more. See the extended version of this paper, available at www.cwi.nl/~kemper, for further details.

Example
Consider the example in Section 4.4. To abstract from timing information, we choose AS={v}, and γ=id. The resulting formulas of applying α with respect to γ and AS to the formulas in Figure 3 are shown in Figure 5.

α(qi(C3)) = s30 ∧ ¬C0 ∧(DC0=3) ∧(z0=0)	α(qE (C3)) = s3t 1 ∧ Ct ∧(zt 1<zt) ∧ s3t
α(qD(C3)) = qD(C3)	α(q(C3)) = α(qi(C3)) ∧ α(qE (C3)) ∧ α(qD(C3))

Fig. 5. TCA Abstraction Example


Theorem 5.3 (Correctness of abstraction) The abstraction α yields a correct over-approximation on runs.
This result is already captured by Lemma 5.2. Here, we have proven an even stronger correctness result, by showing the existence of a homomorphism between concrete and abstract sets of runs. For a detailed discussion and proof, we again refer to the extended version of this paper, available at www.cwi.nl/~kemper.

Abstraction Reﬁnement
In this section, we give a brief overview of our abstraction refinement methodology. The general abstraction refinement paradigm [9] consists of three steps: (1) generate the initial abstraction, (2) model check the abstract system, and, if required, (3) refine the abstraction.

Generate the initial abstraction If there is no additional knowledge about the system, the initial abstraction simply removes all symbols in CC(X)∪DC(NDA) from ϕ(T ), and merges all symbols in S to a single one (we refer to [9] for improved techniques), thereby collapsing to a single trivial location (accordingly for ports). Yet, the next refinement iterations will quickly discover more relevant parameters.
Model checking the abstract system If α(ϕ(T ))k, together with a representa- tion ρ of the safety property (cf. Section 4.3), is unsatisfiable, the system is safe within bound k (cf. Definition 3.5, Theorem 4.2 and Theorem 5.3). Otherwise, the counterexample needs to be concretised, which amounts to checking ϕ(T )k∧ρ, in conjunction with the variable valuations π representing the abstract counterex- ample, and concretising constraints of the form u→s∨r for all locations and ports s and r with γ(s)=γ(r)=u. This check can be done very quickly, since the single abstract counterexample is highly restrictive. If the conjunction is satisfiable, a counterexample to the property is found. Otherwise, the counterexample is spurious, and the abstraction needs to be refined.
Refining the abstraction To identify ill-abstracted parameters, we stratify the formulas ϕ(T )k, ρ and π (i.e., align them along their unfolding depth k), and derive a sequence of Craig interpolants (e.g. [16]), 4 one for every bisection into prefix and suffix. By definition, both the prefix of the first interpolant G≡false and the suffix of the last interpolant G˜≡true are unsatisfiable, and, for P be- ing the set of symbols subject to abstraction, at least one of the symbols in
IA = cont(G)∩P has been wrongly abstracted.
The difficulty—in particular in automatic abstraction refinement—is then to define heuristics describing the application of the two refinement strategies (a)
refine a symbol from IA, and (b) rule out the subtrace represented by the common parts of the prefix of G and the suffix of G˜. The former quickly collapses to the concrete system if applied too frequently, while the latter cannot yield results as
long as essential parameters are inadequately abstracted. Thus, it is necessary to define heuristics that strike a suitable balance between (a) and (b).
The fully automatic heuristic presented in [14] (together with its optimisations)
is a compromise between the drawbacks of the two alternatives: after refining a parameter (a), a fixed number of traces (fractions of the unfolding depth k have turned out to be most promising) is ruled out (b) before refining the next symbol according to (a).

Discussion
We do not have to distinguish between abstraction of different constituents of TCA, since α works uniformly depending just on the different syntactical cate- gories (propositional, natural, real variables), which happen to represent different concepts of TCA. Yet, in contrast to [14], our abstraction function does not remove negative propositional variables from the formula in case the map of merging γ is

4 A Craig interpolant for an inconsistent pair of formulas (A, B) is a formula C that is implied by prefix A, inconsistent with suffix B and contains only common symbols of A and B; it is thus an over-approximation of A and an under-approximation of ¬B.

the identity for these. This speeds up the verification process, since we preserve a bigger part of the formula structure of ϕ(T ), which not only provides more mean- ingful results, but therefore also results in less cycles in the abstraction refinement loop.
Proving a strong correctness result for the abstraction permits to conclude the existence of a corresponding effective abstraction technique on TCA, which produces the abstract automaton T˜. Yet, the formalisation of the direct construction will be much less uniform than what has been presented here.
As a second major result of the strong correctness proof, we get that every abstraction satisfying Lemma 5.2 is already proven correct in our framework. The existence of the abstract TCA T˜, however, is not a general consequence, but a particular result of our strong correctness. This makes α a very powerful and universal technique, yet it remains efficient due to its purely syntactical definition.
Conclusion and Future Work
In this paper, we have presented a SAT-based approach for bounded model checking of TCA. We have defined an embedding of bounded model checking for systems of TCA into propositional logic with linear arithmetic, and introduced a uniform logic- based abstraction for clocks, locations, port names and data values. This logical representation directly benefits from state-of-the-art SAT solving techniques, and allows a linear-size representation of parallel composition. We expect the structural relationships underlying the abstraction to provide the basis for a framework to generalise our work to other scenarios.
Besides this, future work includes performance comparisons when using a log- arithmic encoding for locations and ports (though automatic abstraction is more involved in that case), and the application and comparison of both variants on case studies. After having defined an abstraction that is tailored towards TCA in this pa- per, naturally the next step is to define tailor-made reﬁnement heuristics for TCA, by exploiting the algebraical and logical principles underlying them. As a first step, we plan to add isomorphy inference reasoning to strategy (b) (cf. Section 5.3).
We believe our framework provides means to better understand the functioning of TCA, Reo coordinators and Reo networks [3] (for which TCA serve as formal model). To further improve this, we plan to integrate a back translation from formulas to TCA into the Eclipse Coordination Tools, such that e.g. the result of abstraction can be viewed as a TCA in the editor. Our framework further facilitates verification of these connectors, for example whether an implementation meets its specification. We intend to use the framework within a testing environment of Reo networks, which will enables us to perform black and white box testing, for example check the feasibility of a certain interaction behaviour.

References
Rajeev Alur. Timed automata. In N. Halbwachs and D. Peled, editors, CAV, volume 1633 of LNCS, pages 8–22. Springer, 1999.


Rajeev Alur and David L. Dill. A theory of timed automata. Theoretical Computer Science, 126(2):183– 235, 1994.
Farhad Arbab. Reo: a channel-based coordination model for component composition. Mathematical. Structures in Comp. Sci., 14(3):329–366, 2004.
Farhad Arbab, Christel Baier, Frank S. de Boer, and Jan J. M. M. Rutten. Models and temporal logics for timed component connectors. In SEFM, pages 198–207. IEEE Computer Society, 2004.
Farhad Arbab, Christel Baier, Jan J. M. M. Rutten, and Marjan Sirjani. Modeling component connectors in Reo by constraint automata (extended abstract). Electr. Notes Theor. Comput. Sci., 97:25–46, 2004.
Gilles Audemard, Alessandro Cimatti, A. Kornilowicz, and R. Sebastiani. Bounded model checking for timed systems. In Doron Peled and Moshe Y. Vardi, editors, International Conference on Formal Techniques for Networked and Distributed Systems (FORTE), volume 2529 of LNCS, pages 243–259. Springer, November 2002.
Tobias Blechmann and Christel Baier. Checking equivalence for Reo networks. Electr. Notes Theor. Comput. Sci., 215:209–226, 2008.
Edmund M. Clarke, Armin Biere, R. Raimi, and Y. Zhu. Bounded model checking using satisfiability solving. Formal Methods in System Design, 19(1):7–34, 2001.
Edmund M. Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, and Helmut Veith. Counterexample-guided abstraction refinement for symbolic model checking. Journal of the ACM, 50(5):752–794, 2003.
Eclipse Coordination Tools. http://reo.project.cwi.nl/.
Reiner H¨ahnle. Short CNF in finitely-valued logics. In Henryk Jan Komorowski and Zbigniew W. Ras, editors, ISMIS, volume 689 of Lecture Notes in Computer Science, pages 49–58. Springer, 1993.
Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and Kenneth L. McMillan. Abstractions from proofs. In Neil D. Jones and Xavier Leroy, editors, POPL, pages 232–244. ACM, 2004.
Ranjit Jhala and Kenneth L. McMillan. Interpolant-based transition relation approximation. In Kousha Etessami and Sriram K. Rajamani, editors, CAV, volume 3576 of Lecture Notes in Computer Science, pages 39–51. Springer, 2005.
Stephanie Kemper and Andr´e Platzer. SAT-based abstraction refinement for real-time systems. Electr. Notes Theor. Comput. Sci., 182:107–122, 2007.
The MathSAT 4 SMT solver. http://mathsat4.disi.unitn.it/index.html.
Kenneth L. McMillan. An interpolating theorem prover. In Kurt Jensen and Andreas Podelski, editors,
TACAS, volume 2988 of Lecture Notes in Computer Science, pages 16–30. Springer, 2004.
Matthew W. Moskewicz, Conor F. Madigan, Ying Zhao, Lintao Zhang, and Sharad Malik. Chaff: Engineering an efficient SAT solver. In DAC, pages 530–535. ACM, 2001.
