	Electronic Notes in Theoretical Computer Science 141 (2005) 107–121	
www.elsevier.com/locate/entcs

An Event Algebra Extension of the Triggering Mechanism in a Component Model for Embedded Systems
Jan Carlson1 ,2 and Mikael ˚Akerholm1
Department of Computer Science and Electronics M¨alardalen University, Sweden

Abstract
In this article we present how the component triggering in SaveCCM, a component model intended for embedded vehicular systems, can be extended by means of an event algebra. The extension allows components to be triggered by complex event patterns, and not only by clock signals or single external events.
Separating the detection of triggering conditions from the definition of the triggered services permits more general components and thus improves component reusability. Providing event detection mechanisms within the component model means that triggering conditions are explicitly available for system analysis at design time.
An event algebra is used to define the complex triggering conditions. This algebra has a relatively simple declarative semantics and well documented algebraic properties, which facilitates formal and informal reasoning about the system. The algebra also ensures that detection of triggering conditions can be efficiently implemented with limited resources, which is critical in embedded applications.
Keywords: Component-based software architecture, event detection, embedded systems.


Introduction
SaveCCM [1] is a component model intended for development of software for vehicular systems. The model is restrictive compared to most general component models, due to the high demands of predictability and run-time

1 Email: {jan.carlson,mikael.akerholm}@mdh.se
2 Funded by CUGS (the national graduate school in computer science).



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.02.049

efficiency in the intended domain. We have extended the triggering mechanism of SaveCCM with an event algebra, which allows components to be triggered by complex event patterns, rather than just a clock signal or a single external event.
As a running example, we consider a system with external events including a button B, and internal warning events P and T generated by components monitoring pressure and temperature, respectively. The system is supposed to perform a service provided by a third component whenever the button is pressed twice within two seconds, unless either of the alarm components signal in between.
One way to achieve this is to design a new component that is responsible for detecting this particular situation, and to trigger the component under the right circumstances. This means that the triggering condition is not visible on a system design level, and thus not easily available for analysis.
The alternative outlined in this paper is to provide detection of complex event patterns as a part of the component model. Complex triggering condi- tions are specified on a high level, with well-defined formal semantics, which supports formal analysis at design-time when the access to component source code is limited. At compile-time, code that detects the specified situations is automatically generated.
Triggering conditions are specified by expressions from an event algebra. For example, the situation described above could be defined by the expression (B;B)2−(P∨T). The algebra is designed to be as intuitive as possible, under the restriction that it should be effectively implementable with limited resources,
since we primarily target embedded applications. The operators have intuitive, declarative semantics, and we present a number of algebraic laws that facilitate formal and informal reasoning.
The rest of the paper is organised as follows: Section 2 surveys related work and Section 3 gives an overview of SaveCCM. A description of the proposed extension, including an informal introduction to the event algebra, is given in Section 4. In Section 5 the event algebra is presented more formally, and we outline how the properties of this particular algebra impact on the extended component model. Finally, Section 6 concludes the paper.

Related Work
Recently component technologies for different classes of embedded systems have been developed both in academia and industry. In relation to our pro- posal some of them support different triggering types, specification of advanced real-time constrains, and run-time flexibility. In this section we will briefly de-

scribe a sample from the automotive, consumer electronics, and automation domains.
The Rubus Component technology [10] is a commercial technology that is used in the automotive industry. It is shipped, and tightly integrated, with the Rubus operating system. Rubus components are statically scheduled, and sophisticated timing requirements can be specified, e.g., release-time, deadline, worst case execution time and period time. The main limitation is that only periodic activation of components is possible.
Koala [14] is a component technology developed and used internally by Philips. Component binding flexibility can be achieved with switches, as in SaveCCM. Switches choose between interfaces offered by different components at run time, with possible static reduction at compile-time. ROBOCOP [5] is a continuation to enhance the Koala model with, e.g., support for real-time constrains and analysis.
Port Based Objects (PBO) [13] is a component technology specialised on reconfigurable robotics applications, from the Advanced Manipulators Labora- tory at Carnegie Mellon University. The technology has support for modelling output response from given inputs of closed or open loop systems by applying transfer functions. Real-Time analysis is also supported.
PECOS [15] is a collaborative project between ABB and academia, with the aim to develop a technology adjusted for field-devices. Pecos support dif- ferent trigger-types associated with components; they can be of passive, active or event-type. Passive components do not have their own execution thread, and have to be triggered by other types of components. Active components have their own thread that is periodically triggered. Event components are components that are triggered by an external event and have a thread of control.
Outside the domain of component-based architecture, event detection mech- anisms of various kinds are used in a wide range of areas. For example, some large distributed systems have an architecture based on event subscribers and publishers. In such a system, rather than having subscribers register their interest in simple event types, and perform their own filtering and pattern de- tection, this functionality can be provided by the publisher. The subscribers register event patterns, specified for example in an event algebra. The pub- lisher performs the event detection and notifies the individual subscribers when their pattern is detected. Many systems of this type has been proposed, e.g., the READY event notification service by Gruber et al. that contains a simple event algebra for registering event patterns [9].
In middleware platforms, event detection techniques are used to handle high volumes of event occurrences by allowing consumers to subscribe to cer-

tain event patterns rather than to single event types. For example, S´anchez et al. present an event correlation language where event expressions are trans- lated into nested Petri net like automata [12].
The operators of the event algebra we use, as well as the interval-based se- mantics and the concept of restricted detection, are influenced by work in the area of active databases. Snoop [4], Ode [8] and SAMOS [7] are examples of active database systems where an event algebra is used to specify the reactive behaviour. These systems differ primarily in the choice of detection mecha- nism. SAMOS is based on Petri nets, while Snoop uses event graphs. In Ode, event definitions are equivalent to regular expressions and can be detected by state automata.
Galton and Augusto have shown that associating occurrences of complex event patterns with a single time instant results in unintended semantics for some operation compositions [6]. They also present the core of an alternative, interval-based, semantics to handle the problem. We use a similar semantic base for our algebra, but extend it with a restriction policy to allow the al- gebra to be implemented with limited resources while retaining the desired algebraic properties. To the best of our knowledge, no existing event alge- bra provides assistance to the developer in terms of algebraic properties or an event expression equivalence theory, while at the same time ensuring that detection can be correctly performed with limited resources.

The SaveComp component model
SaveCCM is based on a textual syntax, but a somewhat modified subset of the component diagrams of UML2 is used as a graphical notation. In this paper, we present only the graphical notation, and refer the reader to [1] for details on the textual syntax.

Architectural elements
Systems are built from interconnected components, i.e., units of encapsulated behaviour with well defined interfaces defined in terms of input- and output ports, which are points of interaction between the component and its external environment. The model distinguishes between two aspects of ports: the data flow and the control flow. The former is captured by data ports, i.e., one element buffers where data of a given type can be written and read. Control flow is defined in terms of triggering ports that control the activation of components. Finally, a port can have both triggering and data functionality. The notation for these port types is shown in Fig. 1.



Fig. 1. The graphical notation of SaveCCM.
Basic components are associated with an executable through an entry func- tion. Optionally, quality attributes can be given to specify particular proper- ties of the component, e.g., worst case execution time. In addition to basic components, the model contains two more component types: Assemblies are encapsulated subsystems. The internal interconnections and components are hidden from the rest of the system, and can be accessed only through the ports of the assembly. Switches are lightweight components used to dynam- ically change the component interconnection structure. The switch specifies a number of connection patterns, i.e., partial mappings from input to output ports. Each connection pattern is guarded by a logical expression, possibly over the data available at the input ports, that defines the condition under which that pattern is used. Switches perform no computation other than the evaluation of connection pattern guards.
Execution model and run-time framework
On a system level, execution can be triggered by clocks or external events. Then, the control propagates through the system according to the triggering port connections. A component is triggered once all of its input triggering ports have been activated. If more than one output triggering port is con- nected to the same input triggering port, this input port is activated as soon as one of the connected output ports are activated.

When a component is activated, it first reads from all its input ports and then performs the associated computation. Then, output is written to output ports, which includes activating all output triggering ports of the component. Finally, all input triggering ports are reset to a non-active state.
The application domain of embedded systems requires a small runtime- framework that fits the current practice of this field. E.g., the prototype generates code for the RTXC real-time operating system [11], where a system is implemented as a set of periodic tasks with known worst case execution times, deadlines, and priorities governing the execution order.
At compile time, the components are allocated to tasks in such a way that triggering conditions, precedence relations and component communica- tion are preserved. An analysis phase derives task properties from component attributes and from the system architecture, and performs further analysis based on these, e.g., response time and schedulability analysis. Finally, tar- get specific code is generated for each task, where calls to the component entry function are interleaved with code that handles data exchange between components within the task and with other tasks.


Extended triggering
We propose an extension to the triggering mechanism that allows more elabo- rate triggering conditions to be specified. This functionality is provided in the form of an event algebra, i.e., a number of operators from which expressions can be constructed that represent complex triggering conditions.
First, we give an informal description of the algebra operators, and show how the event algebra is incorporated into SaveCCM. The formal semantics and a number of important properties of the algebra is discussed in Section 5. For a detailed description of the algebra, including implementation details, the reader is referred to [2] or [3].

Operators
Expressions are built recursively from primitive events, represented by input port names, and the operators of the algebra. Fig. 2 lists the operators, together with an informal description of their meaning.
As an example, the triggering condition from in the introductory example, that B occurs twice within two time units and neither P nor T occurs in between, would be defined by the expression (B;B)2−(P∨T).



Fig. 2. Informal description of the algebra operators.
Extended notation
To incorporate the algebra into the component model, the SaveCCM notation is extended with a new element called event. An example of a this construct is shown in Fig. 3. An event element has a number of named input ports and one output port. To illustrate that the semantics of these ports differ from the ordinary ports, they are not represented graphically. The event element is also associated with an algebraic expression defining the event pattern it is responsible for detecting.

Button ((Assembly⟩⟩
  >	)
)
Pressure sensor	)
  >) o  >Pressure	z


Temp. sensor
  >) o  >
,
Temp	z
vo  >Response
,	C,ontrol

z	z


Fig. 3. An example of a system design that includes an event element.

Currently, the semantics of the event element is defined in terms of the original notation. The main motivation for this is that the extension can be included in the prototype tool with minimal effort. In the future, we intend to develop a more direct semantics for the event element, and handle them explicitly in the analysis and code generation phases to avoid unnecessary overhead.

Definition 4.1 An event element with n input ports is viewed as syntactic sugar for a collection of a basic component B,a switch S and n auxiliary basic components, as outlined in Fig. 4.



.	.	,  
>,o  ((Switch⟩⟩	,

.	.	zo  > B



z,	> S	> z z



Fig. 4. An event element (left), and its counterpart in the original notation (right).

The basic component B is responsible for the computation and state infor- mation needed to detect the event pattern correctly. Code for this component is automatically generated from the expression of the event element, following the algebra implementation presented in [2].
The switch S determines, based on the output of B, if the triggering should be forwarded or not. The connection pattern condition is independent of the expression to be detected.
Additionally, an auxiliary component Ai is generated for each of the n input ports of the event element. These components are very small, and only serve to tag the data with a timestamp and the corresponding port name before relaying them to B. To ensure that an activation of one of the input ports is processed by B before it is overwritten by an activation of another port, we require that B is given a higher priority than the auxiliary components.
We believe that the overhead introduced by the auxiliary components is reasonably low. They will typically be allocated at the end of existing tasks, and the component code can be inlined by the compiler since it is only accessed from a single point. Explicit handling of event elements in the code generation phase would remove the need for these auxiliary components.

Event algebra details
From the perspective of the algebra, the input ports of the event element are viewed as event sources. Conversely, to the rest of the system the output port acts as an event source, emitting a triggering signal whenever the incom- ing event sequence matches the pattern defined by the algebraic expression. Note that the SaveCCM triggering signals are instantaneous, but the alge- bra associates event instances, i.e., both port activations and detections of subexpressions, with time intervals to ensure the desired algebraic properties.

Before we consider the algebra semantics, a few basic concepts have to be defined that connects the algebra with concepts in the component model.
Definition 5.1 Let the temporal domain T be the set of all natural numbers, and let P be a set containing the names of the input ports of the event element. For each p ∈ P, let type(p) denote the data type of p.

Input ports
An activation of an input port is characterised by the port name, occurrence time and the associated data. Formally, we represent each activation as a singleton set to allow uniform treatment of primitive and complex event in- stances. Together, all activations of a certain port during the system lifetime form an event stream.
Definition 5.2 If p ∈ P, υ ∈ type(p) and τ ∈ T , then the singleton set
{⟨p, υ, τ ⟩} is a primitive event instance. A primitive event stream is a set of primitive event instances all of which are labelled with the same port name and with different timestamps.
An interpretation is a formal representation of a single execution scenario, as it defines one of the possible ways in which the input ports of the event component can be activated.
Definition 5.3 An interpretation is a function mapping each input port p ∈P 
to a primitive event stream with instances labelled with p.
As an example, let P = {T, P}, type(T)= N and type(P)= {high, low}. Now S = {{⟨T, 12, 2⟩}, {⟨T, 14, 3⟩}, {⟨T, 8, 5⟩}} and S' = {{⟨P, low, 4⟩}} are examples of primitive event streams. The interpretation I such that I(T)= S and I(P)= S' represents a scenario where T is activated at times 2, 3 and 5, and P at time 4.

Event expressions
Event expressions are built from input port names and the operators of the algebra, as outlined in Section 4. As a first step of defining the meaning of an expression, we extend the concepts of instances and streams, defined for input ports above, to event expressions.
Definition 5.4 An event instance is a union of n primitive event instances, where 0 < n, and an event stream is a set of event instances. For an event

instance a we define:
start(a) = min( {τ | ⟨p, υ, τ ⟩∈ a} ) end(a) = max( {τ | ⟨p, υ, τ ⟩∈ a} )
Informally, an event instance represents a number of input port activations that together match the event pattern described by the expression. We asso- ciate with each instance a an interval [start(a), end(a)] that can be thought of as the smallest interval which contains all input port activations that caused a.
Note that a primitive event instance is an event instance, and if a is a primitive instance then start(a)= end(a). Similarly, a primitive event stream is an event stream, just as the names suggest.
As an example, let a = { ⟨T, 12, 2⟩, ⟨P, low, 4⟩, ⟨T, 8, 5⟩ }. Then a is an event instance, with start(a)=2 and end(a)= 5.
Operator semantics and the restriction policy
The interpretation represents input port activations by mapping each port name to an event stream, and the role of the algebra semantics is to extend this mapping so that a given event expression is mapped onto an event stream with exactly those instances that match the pattern described by the expression.
Definition 5.5 The meaning of an event expression for a given interpretation
I is defined as follows:
[[A]]I	= I(A) if A ∈P 
[[A∨B]]I = [[A]]I ∪ [[B]]I
[[A+B]]I = {a ∪ b | a ∈ [[A]]I ∧ b ∈ [[B]]I }
[[A−B]]I = {a | a ∈ [[A]]I ∧ ¬∃b(b ∈ [[B]]I ∧ start(a) ≤ start(b)∧
end(b) ≤ end(a))}
[[A;B]]I	= {a ∪ b | a ∈ [[A]]I ∧ b ∈ [[B]]I ∧ end(a) < start(b)}
[[Aτ ]]I	= {a | a ∈ [[A]]I ∧ end(a) − start(a) ≤ τ }
These definitions result in an algebra with simple semantics and intuitive algebraic properties. However, it can not be implemented with limited re- sources since the conjunction and sequence operators require that instances are stored throughout the system lifetime. To deal with resource limitations, we define a formal restriction policy, and require only that an implementation

should compute a valid restriction of the event stream specified by the algebra semantics above.
The restriction policy is defined as a binary relation rem over event streams, where rem(S, S') means that S' is a valid restriction of S. For reasons of repeatability, it is typically desirable that an implementation of the algebra is deterministic. From a theoretical point of view, however, we prefer to leave as many detailed design decisions as possible open, and guarantee that any implementation which is consistent with the restriction policy relation have the properties described in the paper.
Definition 5.6 For event streams S and S', rem(S, S') holds if the following conditions hold:
S' ⊆ S
For any s ∈ S there exists a s' ∈ S' such that start(s) ≤ start(s') and end(s) = end(s').
No instances in S' have the same end time.
Rather than computing [A]]I for a given event expression A, an implemen- tation of the algebra should result in an event stream S for which rem([[A]]I, S) holds. For the user of the algebra, this means that at any time when there is one or more occurrences of A, according to the [A]]I semantics, one of them will be detected.

Properties
In order to investigate the properties of the event algebra, we need a well- defined concept of expression equivalence.
Definition 5.7 For event expressions A and B we define A ≡ B to hold if [[A]]I = [[B]]I for any interpretation I.
Trivially, ≡ is an equivalence relation. Moreover, it satisfies the substi- tutive condition, meaning that if a subexpression is changed into something equivalent, the result is equivalent to the original expression.
The following laws describe a number of important expression equivalences that facilitate reasoning, both formally and informally, about the triggering condition defined by an event element. They also show to what extent the algebra operators behave according to intuition. For a more extensive set of laws, and formal proofs, the reader is referred to [2].

Theorem 5.8 These laws hold for event expressions A, B and C, and τ ∈T .

The laws identify expressions that are semantically equivalent, but in order to handle resource limitations we expect an implementation of the algebra to compute an event stream S such that rem([[A]]I, S), rather than computing [[A]]I. As a result, detecting A might yield a different stream than detecting
A', even when A ≡ A'. Consequently, it should be clarified to what extent the laws presented above are still applicable when restriction is applied.
Theorem 5.9 If A ≡ A' and rem([[A]]I, S) holds, then rem([[A']]I, S) holds.
Proof. This follows trivially from Definition 5.7, since A ≡ A' implies that [[A]]I = [[A']]I.	 
Thus, A ≡ A' ensures that the result of an implementation detecting A is always a valid result for A'. Any reasoning based on the algebra semantics and the restriction policy, and not on the details of a particular detection algorithm, will be equally valid for equivalent expressions.
Analysis
An argument for extending the component model with an event algebra is that it facilitates analysis on a system design level, compared to developing a new component for each triggering condition. The algebraic laws presented above can be used to rewrite expressions into a form that can be more efficiently detected, e.g., as illustrated by the transformation algorithm presented in earlier work [2]. From the component model point of view, we want to be able

to infer a number of properties of an event element based on the expression and properties of the components connected to it.
Memory requirement
The memory requirements of an event element can be directly determined from the expression and the types of the input ports. Unlike earlier work on the event algebra, the current implementation can detect any expression with limited memory.
Worst case execution time
The code generated for the detection component is characterised by a very simple control flow. For example, there are no nested loops and no function calls. Once the memory analysis derives the required storage structure sizes, all loops are trivially bounded. This means that the code could be analysed with standard worst case execution time techniques.
Alternatively, it should be fairly straightforward to determine, directly from the expression, an abstract worst case execution time in terms of the number of assignments, comparisons, arithmetical operations, etc.
Triggering frequencies
In order to guarantee timely responses when parts of the system activities are non-periodic, it is essential to have information about how often a given component is triggered. In real-time scheduling theory, the term sporadic is used for activities for which a lower bound on the time between two consecutive triggerings (minimum interarrival time) is known.
If the minimum interarrival time is known for the ports connected to the event element, this property can be derived for the output port as well. How- ever, operators like disjunction and conjunction result in expressions with zero minimum interarrival time. We have defined a more general notion of max- imum occurrences, computed by a function occ that guarantees that during any interval of length τ , there are at most occ(A, τ ) detections of the expres- sion A. This can be computed for an arbitrary expression and interval length if minimum interarrival times, or occ values, are known for the input ports of the event element [2].

Conclusions and future work
We have presented how the component triggering in SaveCCM, a component model intended for embedded vehicular systems, can be extended by means of an event algebra. Using the algebra operators, complex patterns of trigger-

ing port activations can be defined, and whenever the activations match this pattern, the associated components are triggered.
Separating the detection of triggering conditions from the definition of the triggered service permits more general components and thus improves component reusability. Providing event detection as a part of the component model, rather than implementing it within an ordinary component, means that it is available for analysis at design-time.
The event algebra has been developed with two main considerations in mind: It should comply with laws that intuitively ought to hold for the algebra operators, and there should be an implementation that correctly detects any expression with limited memory. The simple operator semantics, and the expression equivalence laws, facilitates formal and informal reasoning about the triggering conditions in a system.
Our ongoing work includes defining a more direct semantics for the event element, rather than defining it in terms of other architectural elements. The compile-time phases of the prototype tool should be modified accordingly, so that the event detection activities are implemented as efficiently as possible. Then, case studies should be carried out to evaluate the usefulness of the method and to identify possible improvements.

References
˚Akerholm, M., A software component technology for vehicle control systems, Licentiate thesis No. 44 (2005), M¨alardalen University, Sweden.
Carlson, J., An intuitive and resource-efficient event detection algebra, Licentiate thesis No. 29 (2004), M¨alardalen University, Sweden.
Carlson, J. and B. Lisper, An event detection algebra for reactive systems, in: Proc. 4th ACM Int Conference on Embedded Software (EMSOFT) (2004).
Chakravarthy, S. and D. Mishra, Snoop: An expressive event speciﬁcation language for active databases, Data Knowledge Engineering 14 (1994), pp. 1–26.
de Jonge, M., J. Muskens and M. Chaudron, Scenario-based prediction of run-time resource consumption in component-based software systems, in: Proc. 6th Int. Workshop on Component- Based Software Engineering: Automated Reasoning and Prediction (2003).
Galton, A. and J. C. Augusto, Two approaches to event deﬁnition, in: Proc. 13th Int. Conference on Database and Expert Systems Applications, Lecture Notes in Computer Science 2453 (2002).
Gatziu, S. and K. R. Dittrich, Events in an active object-oriented database system, in: Proc. 1st Int. Workshop on Rules in Database Systems (1993).
Gehani, N., H. V. Jagadish and O. Shmueli, COMPOSE: A system for composite speciﬁcation and detection, in: Advanced Database Systems, Lecture Notes in Computer Science 759 (1993).
Gruber, R., B. Krishnamurthy and E. Panagos, The architecture of the READY event notiﬁcation service, in: Proc. 19th IEEE Int. Conference on Distributed Computing Systems, Middleware Workshop, Austin, TX, USA, 1999.


Lundb¨ack, K.-L., J. Lundb¨ack and M. Lindberg, Development of dependable real-time applications (2004). URL http://www.arcticus.se
Quadros Systems Inc, RTXC kernel users guide (2004). URL http://www.quadros.com
S´anchez, C., S. Sankaranarayanan, H. Sipma, T. Zhang, D. Dill and Z. Manna, Event correlation: Language and semantics, in: Proc. 3rd Int. Conference on Embedded Software, Lecture Notes in Computer Science 2855 (2003).
Stewart, D. B., R. A. Volpe and K. Khosla, Design of dynamically reconﬁgurable real-time software using port-based objects, IEEE Transactions on Software Engineering 23 (1997),
pp. 759–776.
van Ommering, R., F. van der Linden, K. Kramer and J. Magee, The Koala component model for consumer electronics software, Computer 33 (2000), pp. 78–85.
Winter, M., T. Genßler, C. Christoph, O. Nierstrasz, S. Ducasse, R. Wuyts, G. Ar´evalo,
M. Mueller, C. Stich and S. Schoenhage, Components for embedded software — the PECOS approach, in: Proc. 2nd Int. Workshop on Composition Languages, 2002.
