

Electronic Notes in Theoretical Computer Science 257 (2009) 3–18
www.elsevier.com/locate/entcs

Closures in Binary Partial Algebras
Guo-Qiang Zhang1
Department of Electrical Engineering and Computer Science Case Western Reserve University
Cleveland, Ohio 44022, USA

Abstract
Two procedures for computing closures in binary partial algebras (BPA) are introduced: a Fibonacci-style procedure for closures in associative BPAs, and a multistage procedure for clo- sures in associative, commutative and idempotent BPAs. Ramifications in areas such as resolution theorem proving, graph-theoretic algorithms, formal languages and formal concept analysis are dis- cussed. In particular, the multistage procedure, when applied to formal concept analysis, results in a new algorithm outperforming leading algorithms for computing concept sets.
Keywords: Partial algebra, algorithm, closure, formal concept analysis, resolution principle


Introduction
In computer science, algebraic structures play an essential role in the founda- tion and subsequent development of several areas, most notably formal lan- guages (e.g. Kleene Algebra [2,7,15]), domain theory (see, e.g. [1,9,18,23]) and programming languages (see, e.g. [11,12]). In this paper, we study closures for a specific class of algebraic structures called binary partial algebras (BPA) and demonstrate that constructs from a number of areas in computer science, such as resolution theorem proving [19,20], graph-theoretic algorithms [6], formal languages [2,7,15,16] and formal concept analysis [8,24] can be formulated as closures in BPA, with interesting algorithmic consequences.
There is an extensive literature on partial algebras (see [3,4,5,10] and the references included therein). This paper differs from the existing body of work

1 Email: gq@case.edu





1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.023

in that we focus on the the interactions of a set of binary partial operators in the construction of the closures of a subset of a BPA, and on general algorith- mic properties of closure and their applications in several areas of computer science. More specifically, topics studied in this paper include:
rank and closure in binary partial algebras;
BPA-based formulation of resolution principle in logic programming and theorem proving, shortest path in graph theory, Kleene closure and Post Correspondence Problem in formal languages and closure systems in for- mal concept analysis;
two procedures for computing closures in BPA, one of the Fibonacci style and the other called multistage.
We point out that the notion of rank is distinct from the standard notion of index for semigroups [5]. In semigroup theory, the index of an element refers to the least integer that does not produce a power of past values. In BPA, on the other hand, the rank of an element has nothing to do with power: it is the minimal number of elements from a given set that can produce the element using the given set of partial operators. Therefore, the rank of an element in BPA is relative to a chosen subset of a BPA and it represents the notion of “minimal decomposition.”
We also note that multistage is a surprisingly intuitive, but non-trivial procedure. As the name suggests, the procedure computes closure in non- cumulative steps, resulting in a partition of the closure in the end. Each stage generates elements whose ranks lie within a specific range. This reduces a potentially large number of redundant operations using a trivial brute-force approach suggested by the definition. When applied to formal concept anal- ysis [8], the multistage approach resulted in a new algorithm which outper- formed all leading algorithms for computing formal concept sets [17,21]. The correctness of the multistage approach rests in the assumption of three prop- erties of the underlying BPA: associativity, commutativity and idempotency. Without commutativity and idempotentncy, a Fibonacci-style approach pro- vides a general approach for computing closures in associative BPAs. Neither the Fibonacci-style approach nor the multistage approach is applicable to the resolution procedure, however. This is because the BPA arising from resolu- tion is not associative (see Section 5), a property worth being highlighted as a key reason for its computational complexity.
The rest of the paper is organized as follows. In Section 2 we review the notion of binary partial algebra, and present the notions of rank, closure and the interplay between the two. Elements in the closure are precisely those with finite ranks with respect to the starting set. In finite associative BPAs, the value of finite ranks are bounded by the size of the carrier set. In Sec-

tion 3 we formulate, as samplers, problems in resolution theorem proving, graph-theoretic algorithms, formal languages and formal concept analysis in BPAs. In Section 4 we introduce two basic approaches for computing closures in BPAs. A Fibonacci-style approach is introduced for computing closures in associative BPAs. A multistage approach is introduced for computing closures of associative, commutative and idempotent BPAs. We show that not only can these approaches be translated directly to algorithms, the algorithms can be more efficient than known ones. We then instantiate the multistage algo- rithm for formal concept analysis. In Section 5 we briefly revisit the topic of resolution using BPA. Concluding remarks are given at the end of the paper.
Binary Partial Algebras
In universal algebra [10,13], an algebra is defined as a set with a collection of operators. The operators can be of any arity, but they must be total. In binary partial algebra, as the name suggests, the operators can be partial [3,4], in the sense that the values for some arguments can be undefined.
Definition 2.1 [see [10]] A binary partial algebra is a set K and a set O of binary partial operators of the form K × K → K. A binary operator is called partial when it may have undefined values.
We recall some basic terminologies for binary partial algebras: associativ- ity, commutativity, idempotency, closure. We also treat the syntactic part of an algebra by employing the associated formal language. These will be used for the development in the rest of the paper.
Definition 2.2 A binary partial algebra (K, O) is called associative if for any elements a, b, c in K,
◦2(◦1(a, b), c)= ◦1(a, ◦2(b, c))
for any ◦1, ◦2 ∈ O, whenever one side of the equality is defined. (K, O) is called idempotent if for each a ∈ K, for each ◦ ∈ O, a ◦ a = a. It is called commutative if ◦(a, b) = ◦(b, a) for all ◦ ∈ O and a, b ∈ K, whenever one of the values is defined.
Observation. Clearly, if O consists of a single binary operator, then the properties of associativity, commutativity and idempotency transform from the operator level to the algebra level. Also, weaker notions of associativity and communtativity are possible, by requiring the equality to hold only when both sides are defined.
Subsequently, for clarity and conciseness, we sometimes use finite partial

binary algebras with a single associative operator ◦ for illustrative purposes. We will be using the infix notation and assume left-association by default. A BPA is called ﬁnite if the underlying sets K and O are finite.
Definition 2.3 [Language and Equivalence] Let (K,{◦}) be a finite, associa- tive binary partial algebra with a single operator (written (K, ◦) from now on). The set of strings over K is called the language of the partial algebra and is denoted as L(K). For s, t ∈ L(K), we call s, t equivalent and write s ≡ t if
s = x1x2 ··· xm,
t = y1y2 ··· yn, and
x1 ◦ x2 ◦· · ·◦ xm = y1 ◦ y2 ◦· · ·◦ yn, where xi, yj are elements of K for
i = 1,... m, j = 1,... n. In this case, both sides are defined and equal.
For lack of a better name, for a string s = x1x2 ··· xm such as above, we call the result x1 ◦ x2 ◦· · ·◦ xm, if deﬁned, an internalization of s in the given BPA. Thus, two strings are equivalent if they have the same internalizations with respect to a BPA. Of course, some strings may not internalize – such is the case when the indicated values are undefined in the corresponding BPA.
In order to avoid confusion in some contexts, we call strings in L(K) formal strings. Clearly, Definition 2.3 has a straightforward generalization in the multi-operator setting.
Definition 2.4 [Closure] Let (K, O) be a binary partial algebra. For a subset X ⊆ K, the closure of X with respect to O is a set X∗ ⊆ K with the following properties:
X ⊆ X∗,
∀a, b ∈ X∗, ∀◦ ∈ O, ◦(a, b) ∈ X∗ whenever the value ◦(a, b) is deﬁned,
X∗ is the smallest set with the above two properties.
Proposition 2.5 For any binary partial algebra (K, O) and any subset X ⊆
K, the closure X∗ always exists and is unique.
This can be seen from the fact that the intersection of any collection of candidate closures (i.e. those that satisfy the first two items in Def. 2.4) is again a candidate closure.
We next introduce the notion of rank, which will be an important device for subsequent developments.
Definition 2.6 [Rank] Let (K, O) be a finite binary partial algebra. The rank of an element x ∈ K with respect to a given set T ⊆ K, denoted as #T x, is defined as
#T x := min{ i | x = x0 ◦1 x1 ◦2 ··· xi−1 ◦i xi }

where xj are from T (0 ≤ j ≤ i) and ◦j are from O (1 ≤ j ≤ i).
Without assuming associativity, the meaning of an expression such as x0 ◦1 x1◦2x2◦3x3 is ambiguous. To avoid notational burden, we use such an abstract syntax to denote any one of a number of possibilities, such (((x0 ◦1 x1) ◦2 x2) ◦3 x3) or (x0 ◦1 x1) ◦2 (x2 ◦3 x3). But the definition of rank is precise, because the choices of elements and operations are selected among all possibilities.
Intuitively, with respect to a given BPA, the rank of an element x with respect to a set T is the length of the shortest string over T with x a possible “internalization” (note that internalization has only been defined on single- operator BPA, but can easily be generalized to multiple operators). When x ∈ T , we have #T x = 0; when x /∈ T∗, we let #T x = ∞. Even though the shortest strings with x as their internalization may not be unique, the rank #T x is always defined and unique.
Remark. The notion of rank is distinct from the standard notion of index for semigroups [5]. In semigroups, the index of an element a refers to the least integer q that does not produce a power aq of past values {ai | 0 ≤ i < q}. In BPA, on the other hand, the rank of an element has nothing to do with power; it is the minimal number of elements from a given set that can produce the element using the given set of partial operators.

The following result relates the finiteness of rank to membership in a clo- sure. An element has finite rank with respect to a given set exactly when it belongs to the closure of the set. The proof is straightforward.
Proposition 2.7 With respect to a binary partial algebra (K, O), for any
x ∈ K and T ⊆ K, we have
#T x < ∞ iff x ∈ T∗.

The next theorem gives an upper bound on finite rank with respect to the size of an associative algebra.
Theorem 2.8 With respect to a ﬁnite, associative binary partial algebra (K, O), for any x ∈ K and T ⊆ K, if #T x < ∞ then we have
#T x ≤ |K|− |T |.

Proof. Let #T x = n < ∞. Assume #T x > 0, i.e. x /∈ T . Then
x = x0 ◦1 x1 ◦2 x2 ··· xn−1 ◦n xn

for some xj ∈ T (0 ≤ j ≤ n) and ◦j ∈ O (1 ≤ j ≤ n). Let
R := {x0 ◦1 x1 ◦2 x2 ··· xi−1 ◦i xi | 0 ≤ i ≤ n}.

We have |R| = n + 1 (note that x /= x0), since otherwise for some 0 ≤ α < β ≤ n, we have


Therefore,
x0 ◦1 x1 ··· ◦α xα = x0 ◦1 x1 ··· ◦β xβ.

x = x0 ◦1 x1 ··· ◦α xα ◦β+1 xβ+1 ··· xn−1 ◦n xn,

and this implies, By Def. 2.6, #T x < n – a contradiction.
By similar reasoning, T ∩R = {x0}. Since T ∪R ⊆ K, we have |T | + |R|− 
1 ≤ |K|. It follows that n ≤ |K|− |T |.	 

Examples
In this section we provide several examples in computer science to show that a variety of concepts can be rephrased in the framework of BPA. We demonstrate that the common notions of equivalence and rank have specific conceptual and algorithmic relevance across the subject areas. Note that the purpose here is to demonstrate the modeling capability of BPA and hence our treatments are necessarily brief. It is beyond the scope of the current paper to dive much further into the respective subject areas.

Graph Theory
We first discuss the most familiar example of graphs (see [6]). Let K = V ×V , where V is a finite set of vertices. Define ◦((a, b), (x, y)) = (a, y) if b = x, and otherwise undefined. Let O = {◦}. Then (K, O) is a BPA and the closure R∗ of a relation R ⊆ V × V is the standard transitive closure of R.
Two strings s and t are equivalent (s ≡ t) if and only if they represent paths with the same source and same sink with respect to the directed graph determined by R.
Proposition 3.1 For (a, b) ∈ K and R ⊆ K, the rank #R(a, b) is the length of the shortest path from a to b with edges from R.
Note that the operator ◦ here is associative but not idempotent. Note also that this BPA formulation lifts the edges of a graph to first-class citizens, as they ought to be.

Formal Languages
There are different possibilities in formulating concepts in formal languages under BPA. The simplest one is to take K to be the set of all strings over an alphabet Σ and O to consist of the single operator of string concatenation. Then for any L ⊆ K, L∗ is the Kleene closure in formal language theory [16]. Two formal strings s, t ∈ L(K) (see Def. 2.3) are equivalent if the con- catenation of the respective string sequences give the same result. The rank of a string x with respect to a set T of strings is the shortest number of strings from T whose concatenation gives the result x. This is a form of string
decomposition. The operator ◦ is associative but not idempotent.
A more interesting instantiation is possible. Consider K = L(Σ) × L(Σ), and for any (x, y), (u, v) ∈ K, define ◦((x, y), (u, v)) = (xu, yv), where xu, yv denote the underlying string concatenation. In this case, two elements (x, y), (u, v) are equivalent if they are actually equal as string pairs.
Proposition 3.2 The Post Correspondence Problem (see [14]) is equivalent to this problem: given P ⊆ K, is there a diagonal element (x, x) ∈ K such that
#P (x, x) < ∞?
Resolution Theorem-Proving
The resolution principle (see [19,20]) can be formulated as a BPA with multiple operators. Let K be the set of clauses over a finite set V of boolean variables. For each x ∈ V , define ◦x(c1, c2)= (c1 ∪ c2) \ {x, ¬x} if x ∈ c1 and ¬x ∈ c2 or else x ∈ c2 and ¬x ∈ c1. Otherwise ox(c1, c2) is undefined. Note that ◦x(c1, c2) is simply the resolvant [19] of c1 and c2 with respect to x. The closure of a set of clauses C ⊆ K is the standard Robinson resolution closure [20] of C.
Proposition 3.3 (Completeness of Resolution [19]) For any set of clauses
C ⊆ K,
#C∅ < ∞
iff C is unsatisﬁable, where ∅ represents the empty clause.
Note that in this case O = {◦x | x ∈ V }, and the BPA is commutative but neither associative nor idempotent (see Section 5).
Formal Concept Analysis
We follow the notation of [8] in this subsection. Readers are referred to [8] and [24] for further details. For any set A, let P(A) denote the powerset of A. A subset C of the powerset P(A) is called a closure system if C is closed under

arbitrary intersections, i.e., for every X ⊆ C,  X ∈ C. By convention, the whole space A is always a member of a closure system C. A closure operator on A is a self-map ϕ : P(A) → P(A) which is inflationary (X ⊆ ϕ(X)), monotonic (X ⊆ Y ⇒ ϕ(X) ⊆ ϕ(Y )), and idempotent (ϕ(ϕ(X)) = ϕ(X)).
Definition 3.4 Let K = (G, M, I) be a formal context where I ⊆ G × M . Then its concept lattice BK is defined to be the closure system generated by the set {{g}' | g ∈ G}, where {g}' := {m | (g, m) ∈ I}. Dually, BK is inverse- isomorphic to the closure system generated by the set {{m}' | m ∈ M}.
We can formulate the notion of closure system under BPA. Let K be the powerset of a finite set G and let O = {∩}. Then for each C ⊆ K, C∗ is the standard closure system generated by C.
Two formal strings s, t ∈ L(K) are equivalent iff  s =  t, i.e., s and t determines the same (formal) concept. For x ∈ K, #Cx is the minimal number of elements from C whose intersection is x.
Procedures for Closure
As illustrated in the precious section, closures in BPAs are of particular in- terest since they are intimately related to algorithmic and decision-theoreic topics. In this section we provide two basic algorithms for computing closures in BPAs that are improvements from the brute-force one. The first algorithm is of Fibonacci-style (to be explained later), and the second, more efficient one is called a multistage algorithm which improves upon the Fibonacci-style algorithm but is applicable only to commutative, associative and idempotent BPAs.
Since the BPA arising from formal concept analysis (see Section 3.4) is commutative, associative and idempotent, the multistage algorithm is appli- cable for computing concept sets. This results in a new algorithm whose ef- ficiency has outperformed all other leading algorithms for computing concept sets, based on an experimental study [21].
In the rest of the section we fix a finite background BPA (K, O). For notational preparation, define
S ⊙ T := {s ◦ t | s ∈ S, t ∈ T, ◦∈ O},
where S and T are subsets of K.
To understand the proposed new procedures, it would be helpful to briefly discuss the brute-force procedure first. To compute the closure G∗ for G ⊆ K, the brute-force procedure amounts to cumulatively collecting elements obtained from applying an operator to pairs of elements and performing such

an operation repeatedly. Formally, the brute-force procedure can be defined as:

B0 := G
Bi := Bi−1 ∪ (Bi−1 ⊙ Bi−1) for i ≥ 1.
Proposition 4.1 With respect to a ﬁnite binary partial algebra (K, O) and
G ⊆ K, we have
G∗ =  Bi.
i≥0
This can be shown using induction on the syntactic size of expressions for elements in G∗, with the stronger conclusion that for all n ≥ 0, all expressions of the form x0 ◦1 x1 ◦2 x2 ··· xj−1 ◦j xj belongs to Bn, with 0 ≤ j ≤ n.

Fibonacci-Style Procedure
The Fibonacci-style approach computes the closure by an iterative procedure that uses the results obtained from the two immediately previous rounds. This is captured more formally as follows.
With respect to a given subset G ⊆ K, define
L0 := G L1 := G
Li := (Li−1 ⊙ Li−1) ∪ (Li−1 ⊙ Li−2) for i > 1.


Let

L :=	 
|K|>i≥0

Li.

Figure 1 illustrates the idea. For example, when computing L2, L0 and L1 are used and operations are performed both within two elements of L1 and between elements of L1 and L0. Similarly, L3 involves intra-operations within L2 and inter-operations between L2 and L1.
Theorem 4.2 (Correctness of Fibonacci Procedure) With respect to an associative, ﬁnite, binary partial algebra (K, O) and any G ⊆ K, we have L = G∗, i.e.,
G∗ =		Li.
|K|>i≥0




Fig. 1. Fibonacci-style procedure for computing G∗.
Proof. From the definition of closure (Def. 2.4) it is clear that G∗ contains
L.
We show the containment G∗ ⊆ L by induction on the ranks of elements in G∗, since all elements in G∗ have finite rank (see Prop. 2.7). Clearly, every element in G∗ with rank 0 is in L because such an element belongs to G = L1. Every element in G∗ with rank 1 is in L because such an element belongs to L2.
Now suppose all elements in G∗ with rank less than k are in L. Let x be an element such that #Gx = k. Then x = x0 ◦1 x1 ◦2 ··· xk−1 ◦k xk for some x0, x1, ··· xk ∈ G and ◦1, ◦2, ··· ◦k ∈ O. If k is even, then by associativity we have
x = (x0 ◦1 x1 ◦2 ··· ◦k/2 xk/2) ◦(k/2)+1 (x(k/2)+1 ◦(k/2)+2 ··· ◦ xk),


with and
x0 ◦1 x1 ◦2 ··· ◦k/2 xk/2 ∈ L(k/2)+1 x(k/2)+1 ◦(k/2)+2 ··· ◦ xk ∈ Lk/2.

Therefore x ∈ L(k/2)+1 ⊙ Lk/2 ⊆ L. Similarly, if k is odd then x ∈ L(k+1)/2) ⊙
L(k+1)/2 ⊆ L and this completes the inductive step. Note that by Theorem 2.8, we have #Gx = k < |K|.
Therefore by induction we have G∗ ⊆ L.	 

Two remarks are in order.
Remark 1. The above proof using induction goes through without using rank; it can be based on syntactic form, i.e., the length of an expression. Also, induction based on rank will be needed for the next corollary, the idea of which is explained in the second remark.
Remark 2. There may be redundancies in the unions involved in construct- ing L. Typically, the sets Li and Li+1 may have overlapping elements, and this is one source of redundancy for constructing Li+2. Another redundancy is that the end result L is the union of Li for |K| > i ≥ 0, and as long as an element is found in Li+1, we do not need it in Li. This results in the following slightly modified, but potentially more efficient way of computing the closure:




   Sk
1≤k≤i

for i ≥ 1. The key distinction lies in the removal of all existing elements
Sk when forming Si+1. This way, only newly generated (and necessary)
1≤k≤i
elements are kept for the next iteration.
Corollary 4.3 With respect to an associative, ﬁnite, binary partial algebra
(K, O) and any G ⊆ K, we have


G∗ =	 
0≤i≤1+[log2 |K||

Si,


where [ | : R→R denotes the ceiling function from reals to reals, that is, for any x ∈ R, [x| is the least integer not less than x.
We omit the proof for Corollary 4.3 since it amounts to combining those for Theorem 4.2 and Theorem 4.4 in the next section.


Non-overlapping Multistage Procedure
An even more concise and effective algorithm is possible for computing closures in an associative, commutative and idempotent BPA (K, O). We call this

procedure a multistage one:


M0	:=	G, and
Mi+1	:=	(Mi ⊙ Mi) − 

Mk for i ≥ 0.

1≤k≤i
The key distinction lies in the replacement of the previous union (Si ⊙Si) ∪
(Si ⊙ Si−1) by a single term Mi ⊙ Mi.


Fig. 2. Multistage procedure; areas of different grades of shade represent non-overlapping elements.
The multistage approach (see Fig. 2) computes the closure G∗ in a sequence of stages. Each stage involves the collection of all elements satisfying two criteria: (1) it must be obtained by a single operation of two elements from the immediate previous stage; (2) it must be an element not found in any previous stages. Because of these, distinct stages contain no common elements. The non-cumulative character is a key distinction from the brute-force approach, and the dependance on the immediate previous stage, instead of previous two consecutive stages, is a key distinction from the “Fibonacci” idea.
Theorem 4.4 (Correctness of Multistage Procedure) With respect to an idempotent, associative, commutative, ﬁnite, binary partial algebra (K, O) and any G ⊆ K, we have
G∗ =		Mi.
0≤i≤1+[log2 |K||
Proof. By Theorem 2.8, the rank of any element in G∗ cannot be greater than |K|. So it suffices to show by induction that every element in G∗ with rank k belongs to Mt, where t = 1 + [log2 k| (we fix t = 0 for k = 0 and t = 1 for k = 1). For conciseness, define τ (k) := 1 + [log2 k|. Note that τ (k)=1 + [log2(k)| =2 + [log2(k/2)| =1 + τ (k/2).
To further alleviate notational burden, we denote the rank of x with respect to G simply as #x without the subscript G in the rest of the proof.
The base cases (#x = 0, 1) follow directly from the definition of M0 and

M1.
For the induction step, assume that any element x ∈ G∗ with rank #x ≤ k belongs to Mτ(#x). Now let x ∈ G∗ be an element with #x = k+1. Then by the definition of rank, there exist x0, x1, ··· , xk, xk+1 ∈ G and ◦1, ◦2 ··· , ◦k+1 ∈ O such that
x = x0 ◦ x1 ◦ x2 ··· xk ◦ xk+1.
To improve readability, here we dropped subscripts for ◦ with the under- standing that they are not necessarily the same operators from O. Such an abbreviation will not lead to technical oversimplification. Therefore, the or- dering (or positions) of the operators remain the same despite the fact that associativity is freely applied.
Since the rank of each element in Mi is bounded by 2i−1 for all i ≥ 1, x
does not belong to  1≤i≤τ ((k+1)/2) Mi.
Now if k is even, decompose x, by associativity, as
x = (x0 ◦ x1 ◦ ··· ◦ xk/2) ◦ (x1+k/2 ◦ ··· ◦ xk+1).
Note that the ranks of both x0 ◦ x1 ◦ ··· ◦ xk/2 and x1+k/2 ◦ ··· ◦ xk+1 are equal to k/2 (≤ k). By the induction hypothesis, the decomposed elements belong to Mτ(k/2). Thus x belongs to Mτ(k/2) ⊙ Mτ(k/2). Note that with k even, we have τ (k + 1)=1 + τ (k/2). Therefore x ∈ Mτ(k+1).
If k is odd, decompose x, by both idempotency and associativity, as
x = (x0 ◦ x1 ◦ ··· ◦ x(k+1)/2) ◦ (x(k+1)/2 ◦ ··· ◦ xk+1).
Here, we used idempotency to rewrite x(k+1)/2 as x(k+1)/2 ◦ x(k+1)/2. Clearly, the rank of the element y := x0 ◦x1 ◦· · · ◦x(k+1)/2 is (k +1)/2. More important, the rank of the element z := x(k+1)/2 ◦· · ·◦ xk+1 is also (k + 1)/2. Suppose a shorter expression for z exists using elements from G. If x(k+1)/2 is not part of the expression, then we achieve a shorter expression for x = y ◦ z than permitted by the rank of x, which is impossible. On the other hand, if x(k+1)/2 is part of the shorter expression, we can also achieve a shorter expression for x than permitted by the rank of x, by using commutativity to move x(k+1)/2 to the front of the expression for z and then applying idempotency. Therefore, #z = (k + 1)/2.
By induction hypothesis, y and z both belong to Mτ((k+1)/2). Thus x belongs to Mτ((k+1)/2) ⊙ Mτ((k+1)/2). Therefore x ∈ Mτ(k+1). This completes the proof.	 
As corollaries, the next two observations highlight the key non-redundant and non-overlapping characteristics of the multistage procedure.

Corollary 4.5 With respect to an idempotent, associative, commutative, ﬁ- nite, BPA (K, O) and G ⊆ K, {Mi | 0 ≤ i ≤ τ (|K|)} is a partition of G∗.
Corollary 4.6 For any x ∈ M0, #x =0 and for any x ∈ M1, #x = 1. For any i ≥ 2 and any x ∈ Mi, we have 2i−1 ≤ #x < 2i.

Resolution Revisited
Since associativity is a property affecting the available methods for computing closures, one might be curious why the BPA induced by the resolution proce- dure (see Subsection 3.3) is not associative (although it is commutative).
Here is a simple example illustrating non-associativity. With three clauses
{a, ¬b, ¬c}, {b}, {c}, we have
({a, ¬b, ¬c} ◦b {b}) ◦c {c} = {a},
but we cannot perform {b} ◦c {c} because it is undefined.
There is a simple example to show directly why “multistage” does not work for resolution. Let G = {{a, b}, {¬a}, {¬b}}. Then M1 = {{a}, {b}}, and M2 is empty. However, clearly the empty clause { } belongs to G∗.
In these examples, the non-associativity seems to be caused by the inter- action of distinct operators such as ◦b and ◦c. By removing trivial clauses in which both a literal and its negation appear, one can check that by fixing a single operator, we do get an associative operator. This begs the question of achieving an overall closure by obtaining closures with respect to one operators at a time, making room for possible use of efficient algorithmic methods for individual closures with respect to single operators. This is indeed possible, and is proved, for example, in [22] for resolution.
We state without proof a general result with a stronger condition than desired. This allows for the computation of an overall closure by computing the individual closures in any sequence.
Proposition 5.1 Let (K, O) be a ﬁnite, associative binary partial algebra with O = {◦i | 1 ≤ i ≤ n}. For X ⊆ K, let (X)i∗ be the closure of X with respect to (K, ◦i). We have, for any G ⊆ K,
G∗ = (··· ((G)∗)∗ ··· )∗ .
1 2	n
This result does not yet fully explain why “literal resolution” [22] is com- plete, and we leave the issue of a generic result in the BPA framework that explicates Literal Resolution as a topic for future investigation.

Conclusion
We have made a case for using binary partial algebras as a possible unify- ing framework for studying a group of algorithmic problems from computer science. We have illustrated how the notions of rank and closure interact with each other, and introduced two algorithms for computing closures in bi- nary partial algebras. The multistage procedure is a more efficient method for computing closures, with the algebraic properties of the underlying BPA supporting its algorithmic validity.
Further developments in BPA could take two broad flavors. One is the development of properties for BPA, including those for computing closures, so they can be applied to specific topics such as graph algorithms. Second and in return, algorithms underlying many existing efficient procedures known in special cases such as resolution theorem provers may be seen under BPA in a new light, making it possible to reapply the ideas to a different setting.

References
S. Abramsky and A. Jung. Domain Theory. In S. Abramsky, D. M. Gabbay, T. S. E. Maibaum (editors), Handbook of Logic in Computer Science Vol III. Oxford University Press, 1994.
S. Bloom and Z. E´sik. The equational theory of regular words. Inf. Comput. 197:55-89, 2005.
P. Burmeister. Partial algebras – survey of a unifying approach towards a two-valued model theory for partial algebras. Algebra Universalis, 15:306-358, 1982.
P. Burmeister. A Model Theoretic Oriented Approach to Partial Algebras (Introduction to Theory and Application of Partial Algebras). Mathematical Research Vol. 32, Akademie-Verlag, Berlin, 1986.
A.H. Clifford. The Algebraic Theory of Semigroups, Volume II (Mathematical Survey, No 7), American Mathematical Society, 2nd edition, 1967.
T. Cormen, C. Leiserson, R. Rivest, C. Stein. Introduction to Algorithms. MIT Press and McGraw-Hill, 2001.
M. Droste and P. Gastin. The Kleene-Schu¨tzenberger theorem for formal power series in partially commuting variables. Information and Computation 153:47-80, 1999.
B. Ganter and R. Wille. Formal Concept Analysis. Springer-Verlag, 1999.
G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislove, D. S. Scott. Continuous Lattices and Domains. In Series: Encyclopedia of Mathematics and its Applications (No. 93), Cambridge University Press, 2003.
G. Gr¨atzer: Universal Algebra, 2nd Edition, Springer, New York, 1978.
J. Goguen, J. Thatcher, E. Wagner, J. Wright. Initial algebra semantics and continuous algebras. J. ACM, 24:68-95, 1977.
J. Goguen and G. Malcolm. Algebraic Semantics of Imperative Programs. MIT Press, 1996.
M. Goldstein, V. Kudryavtsev, I. Rosenberg (eds.). Structural Theory of Automata, Semigroups, and Universal Algebra: Proc. NATO Advanced Study Institute on Structural Theory of Automata, Semigroups and Universal Algebra (NATO Science Series II: Mathematics, Physics and Chemistry, Vol. 207). Springer, 2005.

J. Hopcroft and J. Ullman. Introduction to Automata Theory, Languages, and Computation. Addison-Wesley, 1979.
D. Kozen. A completeness theorem for Kleene algebras and the algebra of regular events. Infor. and Comput., 110:366-390, 1994.
D. Kozen. Automata and Computability. Springer, 1997.
S. Kuznetsov and S. Obiedkov. Comparing performance of algorithms for generating concept lattices. J. Exp. Theor. Artif. Intell. 14:189-216, 2002.
M. Mislove. Nondeterminism and probabilistic choice: obeying the laws. CONCUR 2000: 350- 364.
A. Nerode and R. Shore. Logic for Applications. Springer, 1997.
Z. Stachniak. Resolution Proof Systems: An Algebraic Theory. Springer, 1996.
A. Troy, G.-Q. Zhang, Y. Tian. Faster concept analysis. Proc. 15th International Conference on Conceptual Structures, Lecture Notes in Artificial Intelligence, 4604:206-219, 2007.
G.-Q. Zhang. Literal resolution: A simple proof of resolution completeness. DAIMI-Report, Aarhus University. Computer Science Department, 11 pages, 1989.
G.-Q. Zhang. Logic of Domains. Birkh¨auser, Boston, 1991.
G.-Q. Zhang. Chu spaces, concept lattices, and domains. 19th Conference on the Mathematical Foundations of Programming Semantics, Montreal, Canada, March 19-22, 2003, Electronic Notes in Theoretical Computer Science, Vol. 83, 17 pages, 2004.
