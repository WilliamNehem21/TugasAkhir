Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 325–348
www.elsevier.com/locate/entcs

Automata-Theoretic Semantics of Idealized Algol with Passive Expressions
Uday S. Reddy1
School of Computer Science University of Birmingham Birmingham, U.K

Abstract
Passive expressions in Algol-like languages represent computations that read the state but do not modify it. The need for such read-only computations arises in programming logics as well as in concurrent pro- gramming. It is also a central facet in Reynolds’s Syntactic Control of Interference. Despite its importance and essentially basic character, capturing the notion of passivity in semantic models has proved to be diffi- cult. In this paper, we provide a new model of passive expressions using an automata-theoretic framework recently proposed by the author. The central idea is that the store of a program is viewed as an abstract form of an automaton, with a representation of its states as well as state transitions. The framework allows us to combine the strengths of conventional state-based models and the more recent event-based models to synthesize new ”automata-based” models. Once this basic framework is set up, relational parametricity does the job of identifying passive computations.
Keywords: Idealized Algol, Relational parametricity, Functor categories, Reflexive graphs, Algebraic automata theory.


Introduction
We expect that denotational semantic models of programming languages provide a rigorous conceptual foundation for reasoning about programs. In devising such models, one is faced with the challenge of how best to capture the intuitions the programmers possess in understanding computations and incorporate them in a rigorous theoretical framework.
The traditional models for imperative programming languages, dating back to those of Scott and Strachey, are state-based. These models envisage that programs operate on a store which goes through states. Commands are interpreted as func- tions from states to states, factoring out all the internal state manipulation details carried out by them. Thus, these models may be regarded as being extensional

1 Email: u.s.reddy@bham.ac.uk

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.020

in their treatment of the store. Examples of such models include the original models due to Scott and Strachey [42], the functor category models initiated by Reynolds [30,38,45] and their refinements using relational parametricity [26,27].
In more recent developments, an alternative event-based approach for modeling computations has come to the fore. These models eschew any notion of store or state. They view commands as processes that interact with the individual storage variables via interaction events. The process-based view of commands exposes all their internal state manipulation details and makes the models intensional. On balance, however, the data abstraction and information hiding aspects of stor- age variables are captured more directly in these models. They are also able to model the intensional aspects of the computations such as the idea of “irreversible state change,” leading to strong full abstraction results. Examples of such event- based models include the process calculus models due to Milner and Hoare [14,21], Brookes’s trace models [7], the author’s object-based models [20,25,33,34] and the games models [1].
The difference between extensional and intensional models becomes manifest in reasoning about program equivalences such as:
gv(x) =⇒ (x := x + 1; x := x + 1) ≡ (x := x + 2)	(1)
where gv(x) represents the condition that x is a “good variable” obtained by variable allocation. Extensional models satisfy such equivalences because they capture the net effect of commands on the state, whereas intensional models do not. 2 However, the treatment of data abstraction (local variables) and irreversibility of state change is problematic in extensional models.
In an effort to combine the advantages of state-based and event-based mod- els, we recently initiated a new approach using an automata-theoretic view of the store [35,36]. The store is viewed as an automaton with an explicit representation of the states as well as the state transitions. The use of states allows an extensional treatment of commands and the use of state transitions captures some aspects of the modelling available in event-based models. We showed that several program equiv- alences of third-order types that could not be validated in the pure state-based models are valid in this setting.
In this paper, we take a further step in the development of the automata- theoretic model by modelling passive expressions, as per Reynolds’s original Ide- alized Algol [38]. Passive expressions read the storage variables to compute values, but they do not alter the store. Typical programming languages allow side-effects in expressions for practical reasons, leaving it to the programmer to use them judi- ciously. 3 However, passive expressions form an integral part of program reasoning. For instance, in Hoare Logic, expressions can be embedded in logical assertions,

2 One might find it surprising that the intensional models, e.g., games models, fail to be “extensional” despite being fully abstract. The explanation is that full abstraction only guarantees the satisfaction of unconditional equivalences which seem inadequate to capture the extensionality of state-manipulation. The equivalence (1) is conditional.
3 The evaluation order of expressions is often left unspecified or under-specified, so that an uncontrolled use of expression side effects is not a practical proposition in any case.

where any side effects can lead to an entirely incoherent formalism. In concur- rent programming, passive expressions form an important tool for sharing resources across processes. Various program reasoning systems, ownership type systems etc. incorporate explicit annotation for “read-only” or “immutable” variables, which depend on notions of passive usage [18,22]. In particular, the use of “fractional per- missions” is an advanced mechanism to capture the passive use of storage, currently an active area of research [5,6,37].
Modeling passivity in extensional models is a significant challenge because pas- sivity appears to be an intensional phenomenon: what a computation does in- ternally in order to produce its results. If we think of modelling expressions as extensional functions of type State → Value, we have no handle on what such a computation might do. It might internally calculate a new state (which means a state change in computational terms), and do further computations within the new state to deliver the result. The new state is eventually discarded, and the expres- sion would have had a “temporary side effect.” This kind of a phenomenon can be captured syntactically by a “snap back” combinator of the form:
do C result E
which means “execute the command C and return the value of expression E, dis- carding the effects of C.” The presence of such a snap back combinator in the semantic models breaks intuitive program equivalences. For instance, consider the equivalence: 4


if (deref x = 0) then f (deref x) else 2 ≡
if (deref x = 0) then f (0) else 2
(2)

where f is a function procedure taking an expression argument. Since f is called only in the case where x is 0, giving it 0 as the argument instead of (deref x) should give equivalent results. However, in a semantic model that contains the snap back operator, there are functions f that break this reasoning, for example:
f = λe. do x := x +1 result e
With this function f , the LHS of (2) evaluates to 1 whereas the RHS evaluates to 0. Virtually all extensional models in the literature, with the exception of the Tennent’s model [45], have such snap back combinators.
We get around the difficulty by viewing the store as an automaton, which has an explicit representation of its states QX as well as its allowed state transfor- mations TX. The expression type may then be thought of as a type constructor parameterized by both the components of the automaton:
Exp(QX , TX)= [QX → Value]

4 Imperative programming languages usually involve an implicit coercion that allows a storage variable to be treated as an expression that reads its contents. We represent this coercion as “deref” for clarity of exposition. Recall also that Idealized Algol is a call-by-name typed lambda calculus. So, the argument is passed by name in f(deref x).

All computations are expected to be parametric [10,27,32,40], i.e., they are inter- preted by parametrically polymorphic families of the form:
∀QX , TX . F (QX , TX) → Exp(QX , TX)
where F (QX , TX) represents the semantic type of the free identifiers. Since the result type Exp(QX , TX) is independent of the TX components, parametricity says that the family should behave the “same way,” no matter what type TX is employed (subject to some constraints). In particular, it should produce the same results if TX is replaced by a trivial collection of state transformations, such as the one with just the identity transformation and its possibly diverging approximations. It then follows that the expression computation cannot cause any state changes, not even temporary ones. Thus passivity is captured in an intuitively satisfactory form.
The definition of this model builds on two technical innovations from our past work (joint with B. P. Dunphy). The first is the categorical axiomatization of relational parametricity presented in [10]. Since the overall structure is that of a category-theoretic possible world model, as pioneered by Reynolds [38], a categorical treatment of parametricity is needed to build the model we seek. O’Hearn and Tennent [27] initiated the building-in of relational parametricity into categories. However, their model does not have the requisite axioms, and snap back operators are present in their model. Our axiomatization is based on the notion of ﬁbrations, well-studied in category theory [13,16], using which strong representation results were obtained in [10]. Its employment here gives further evidence of its power. The second innovation is the automata-theoretic modeling of the store presented in [35,36]. In retrospect, this view of the store was already implicit in Reynolds’s first functor category model [38]. However, the automata-theoretic intuitions behind his model were not recognized and subsequently ignored in all further work on functor category models. Our model seems to have been the first work that builds on Reynolds’s ideas. In the present work, we generalize the automata-theoretic model in a significant way, which parallels Tennent’s generalization of the Oles model [45], in order to capture the seemingly intensional phenomenon of passivity. In doing such a generalization, it is easy to go too far to the other way, i.e., to make the model so intensional that the equivalence (1) fails. Tennent’s model, in fact, breaks this equivalence. (Contrary to expectation, the equivalence cannot be derived in Specification Logic.) We aim to achieve a delicate balance of intensional effects and extensionality in the present paper.

Results
The main contribution of this paper is to provide a denotational model of Idealized Algol that satisfactorily models passivity while being extensional. In particular, this means that passive expressions do not have side effects, not even temporary ones. In the main body of the paper, we do this for a language without divergence, but treat it in such a way that it generalizes to divergence. The issues of divergence are then briefly mentioned in Sec. 5. The treatment without divergence is also novel in

that it is the first model of passivity that is able to deal with a language without divergence. All the previous models [1,34,45] depend on the presence of divergence for modeling passivity. However, intuitively, passivity is independent of the issues of divergence. Our treatment is able to decouple the two issues.
We can explain the contribution in terms of the accuracy gained at first-order types [25,34]. In the absence of divergence:
Morphisms of type com → com should be isomorphic to natural numbers. They are all expressible by closed terms of the form λc. cn where cn means an n-fold sequential composition c; ... ; c. The model of [36] has this property.
Morphisms of type com → exp[δ] should be constant functions. They are ex- pressible by closed terms of the form λc. E for closed expression terms E. The present model has this property.

Semantic Framework
The semantic framework used in this paper is that of a category-theoretic possible worlds model, as advocated by Reynolds [38]. That means that the types of the programming language are interpreted as type constructors parameterized by “store
shapes” (formally functors).  For example, Exp(X) represents the collection of
expression meanings appropriate for stores of shape X, Com(X) represents the
collection of command meanings appropriate for stores of shape X etc. The store shapes must form a category where morphisms f : X → Y represent ways in which a store Y may be regarded as a “future world” of X (typically by allocating additional storage locations). It might in fact be helpful to think of such a morphism as a “function” going in the reverse direction, f : Y → X, capturing a way of “extracting” an X-typed store from a Y -typed one. The type functors, naturally, must map such morphisms to functions. For example, Exp(f : X → Y ) denotes a function that allows us to convert an expression on X-typed stores to one on Y -typed stores, which is possible because X-typed stores can be extracted from Y -typed stores.
In addition to morphisms, we consider abstract logical relations between stores, used for formulating the uniformity conditions of relational parametricity. For every pair of stores X and Xj, we have a notion of logical relations R : X ↔ Xj and a notion of morphisms preserving such relations, which is written diagrammatically as a “square”:
f
X 	> Y 

ˆ	ˆ
R	S
fj	v
(3)

Xj 	> Y j
and textually as f R → S fj. (The textual notation depends on the fact that all the structures we consider in this paper are relational, i.e., given f , f , R and S, there is at most one square of the above shape. Therefore R → S may be regarded as a normal set-theoretic relation between hom-sets X → Y and Xj → Y j.) The type

functors also map such logical relations between stores to relations between values and “squares” of the form (3) to relation-preservation squares between functions, e.g.,
Exp(f )
Exp(X) 	> Exp(Y )

ˆ
Exp(R) v

Exp(fj)
ˆ
Exp(S)
v

Exp(Xj) 	> Exp(Y j)
Formally, the four components: store shapes, morphisms between store shapes, logical relations between store shapes and squares between them, form a reflexive graph of categories. Further, they satisfy additional axioms laid out in [10] to form a parametricity graph. Formal definitions describing the structure may be found in the Appendix.
In addition to the reflexive graph of store shapes, which will be described in the remainder of this section, we also make use of the reflexive graph Set, whose objects and morphisms are sets and functions, “logical relations” are set-theoretic relations R ⊆ A × Aj and “squ ar es” f  R → S  fj represent relation-preservation
additional requirements of parametricity graphs.

Reader monoids
We choose to model stores as an abstract form of automata similar to those studied in algebraic automata theory [11,15]. Each such automaton has: 5
a set of states QX,
a monoid of allowed state transformations TX ⊆ [QX → QX] (containing the identity transformation, written as 1X, and closed under sequential composition a · b), and
an operation readX : (QX → TX) → TX defined by readX p = λx. p x x.
A structure of this form X = (QX , TX , readX) is called a reader monoid. It would also be appropriate to call it a Reynolds monoid. The readX operation was proposed by Reynolds [38], who called it “diagonalization.” To see the motivation for it, consider interpreting a command of the form if p then c1 else c2. The command reads the state to compute the expression p and, depending on the result, executes either c1 or c2, which are both expected to denote allowed transformations. The if-then-else operator thus converts a state-dependent state transformation of type (QX → TX) to a state transformation of type TX. It is definable using the readX combinator as condX e a1 a2 = readX (λx. readX (es) a1 a2). If a given automaton (QX , TX) does not have a readX operation, additional transformations can be added to TX to obtain a reader monoid. We call it the “read-closure” of the original automaton.

5 For reasons of exposition, we will ignore the issues of divergence in the main body of the paper. However, see Sec. 5 for the extensions needed for divergence.

As examples of reader monoids, consider a store Z with
QZ = Int	TZ = { a : Int → Int | a(z) ≥ z }
This store contains a single integer variable and allows it to be increased during computations (but not decreased).
A “passive” store W has some state set, but only the do-nothing transformation TW = {1W }. For every store X, there is a corresponding passive store of X, denoted X0, which has the same state set as that of X and the trivial set of state transformations TX = {1X }.
The automata used in [35,36,38], called Reynolds transformation monoids, have an additional element of structure:
a monoid action of type αX : TX → (QX → QX) which represents a way of “running” a transformation on the states.
Here, we drop this operation, obtaining generality in the structures as well as the corresponding morphisms and logical relations. The justification for the generaliza- tion is that states in imperative programs are “abstract,” available for inspection only by other commands but not by external interfaces. By requiring that logical relations only preserve the read operation, and not the monoid action, we obtain more relations, which gives a stronger parametricity criterion. Recall the intuitive argument given in the Introduction, where we replace a state transformation com- ponent of TX by a trivial one. Note that the new transformation will have different on the state from the one we replace. So, this generalization is crucial for modelling passivity.
A logical relation of reader monoids R : X ↔ Xj is a pair (Rq, Rt) where
Rq : QX ↔ QX′ is a normal relation of sets, and
Rt : TX ↔ TX′ is a monoid relation (compatible with identity transformation and composition),
such that readX (Rq → Rt) → Rt readX′ . The identity logical relation of a reader monoid X is IX = (ΔQX , ΔfX ) consisting of the diagonal relations on both the state sets and the transformations.
A morphism of reader monoids f : X → Y , representing a way of expanding a “current world” X to a “future world” Y , is a pair (fq, ft): where
fq : QY → QX is a surjective function (note the reversal of direction), and
ft : TX → TY is an injective monoid morphism,
satisfying ft(readX(p)) = readY (ft ◦ p ◦ fq).
The condition on read can also be written using relational notation as readX ⟨fq → ft⟩→ ⟨ft⟩ readY , where the notation ⟨−⟩ denotes the graph of a function. The bidirectional information flow of fq and ft, similar to that in inten- sional models [1,34], may be understood by thinking of the morphism f as extracting X-typed stores from Y -typed stores in the reverse direction. To do such extraction, it should be possible to interpret all Y -typed states as X-typed states, which is

done by the function fq. The transformations of the stores, on the other hand, are invoked by the computational environment in which the store is embedded. If the environment requests a transformation a on the X-typed store, the extraction must simulate it as a transformation ft(a) on the Y -typed store.
A square of reader monoids is defined as a pair of relation-preservation squares (for sets and monoids, respectively):


f
X 	> Y 
fq
QY 	> QX
f
X 	> TY

ˆ
R
v	fj
ˆ
S v⇐⇒
ˆ
Sq
v	fj
ˆ
Rq	∧
v
ˆ	ˆ
Rt	St
v	fj	v

j 		j	q	t

X	> Y 
QY ′ 	> QX′
TX′ 	> TY ′

Note that the squares on the right (in Set and Mon) have their standard meaning:
∀y ∈ QY , yj ∈ QY ′ . y Sq yj =⇒ fq(y) Rq fj(yj)
∀a ∈ TY , aj ∈ TY ′ . a Rt aj =⇒ ft(a) St fj(aj)
This data constitutes a reflexive graph category RM of Reynolds monoids.
Parametricity graphs
The so-called “parametricity graphs” are reflexive graphs of categories satisfying certain axioms, proposed in [10] for modelling relational parametricity. A para- metricity graph is a reflexive graph that is:
relational, i.e., there is at most one square of a given shape,
ﬁbred with chosen cleavage, and
satisfies the identity condition, i.e., whenever f  IA → IB  g, we have f = g.
The “relational” condition essentially simplifies the theory. The “identity condi- tion” gives semantics to the identity logical relations. The “fibred” condition is a categorical treatment of inverse images of relations. (See Appendix for full defi- nitions.) Given f , fj and S as in the square on the left below, there must be a pre-image ⟨f, fj⟩∗ S that can fill the dotted line in a universal way:


f
A 	> B 
.
f
A 	> B 
.

j ∗	.ˆ	ˆ	ˆ	.ˆ	j

⟨f, f ⟩	.
.v
S
fj	v
R	. ⟨f, f ⟩! R
fj	.v

Aj 	> Bj	Aj 	> Bj
Squares of this form are called cartesian squares. The dual form of squares, co- cartesian squares, give “direct images” ⟨f, fj⟩! R. The reflexive graph Set has both pre-images and direct images, given by:
⟨f, fj⟩∗ S = { (x, xj) | f (x) S fj(xj) }
⟨f, fj⟩! R = { (f (x),fj(xj)) | x  R  xj }





Com(X)= TX
Expδ(X)= [QX → [[δ]]]
Com(R)= Rt
Expδ(R)= [Rq → Δ[[δ]]]

Varδ(X)= Expδ(X) × [[[δ]] → Com(X)] Varδ(R)= Expδ(R) × [Δ[[δ]] → Com(R)] (F × G)(X)= F (X) × G(X)	(F × G)(R)= F (R) × G(R)
(F ⇒ G)(X)= ∀h:Z→X [F (Z) → G(Z)]	(F ⇒ G)(R)= ∀S→R [F (S) → G(S)]


Fig. 1. Interpretation of Idealized Algol types
The reflexive graph RM is a also parametricity graph, in contrast to the one used by O’Hearn and Tennent [27] . It satisfies the identity condition because it is obtained by putting together Set and Mon, both of which satisfy the identity condition. It is fibred with chosen cleavage:
⟨f, fj⟩∗ S = (⟨fq,fj⟩! Sq, ⟨ft,fj⟩∗ St)
q	t
This implies in particular that there is a “subsumption map” that maps each mor- phism f : X → Y to a logical relation ⟨f⟩ : X ↔ Y , given by ⟨f⟩ = (⟨fq⟩×, ⟨ft⟩), such that commutative squares of morphism are sent to relation-preservation square [10]. Diagrammatically:


fq
QX <	 QY
.
f
X 	> TY
.

j	.ˆ	ˆ	j ∗	.ˆ	ˆ

⟨fq, fq ⟩! Sq .
.v
QX′ <	j
q
Sq
v
QY ′
⟨ft, ft ⟩
St .
.v
TX′
St
v
j> TY ′
t

In addition to these facts, we note that the vertex category of RM satisfies the right Ore condition [17], allowing us to treat it as an atomic Grothendieck site.
RM is not cofibred in general, but it does have some useful co-cartesian squares which will be put to use in the next section.
Type functors
To interpret the types of Idealized Algol we use functors of appropriate kind from RM to Set, as shown in Fig. 1. This formalizes the intuition mentioned in In- troduction that types are interpreted as “type constructors” parameterized by the store automaton.
A reflexive graph-functor (RG-functor) F : G → H between reflexive graphs maps all four components of the reflexive graph (objects, morphisms, logical rela- tions and squares) preserving their structure. A PG-functor is a reflexive graph- functor that also preserves the cartesian squares and, in particular, the chosen cleavage:
F (⟨f, fj⟩∗S)= ⟨Ff, Ffj⟩∗(FS)

We also insist that the functors used for interpreting Idealized Algol preserve all the co-cartesian squares that exist in RM. The category of PG-functors RM → Set of this kind is denoted P(RM), for “presheaves over RM.”
The morphisms in P(RM) are transformations that preserve all morphisms (naturality) as well as all relations (parametricity). However, under the conditions of parametricity graphs, parametricity implies naturality [10,32]. So, we simply call them parametric transformations.
Next, we restrict to (atomic) sheaves over RM [17,19]. Intuitively, the idea of sheaves is that the functor actions Ff on morphisms f : X → Y do not lose any information. Given an element Ff (a) ∈ FY , we can recover a ∈ FX from it. The definition is as follows:
Given a morphism f : X → Y , a pair of morphisms (g1, g2) : (Y, Y ) → (Z, Z) such that f ; g1 = f ; g2 is called a “match point” for f .
An element b ∈ FY is called a matching element for f if, for all match points (g1, g2), we have Fg1(b)= Fg2(b).
A presheaf F in P(RM) satisfies the sheaf axiom for f : X → Y if, for all matching elements b ∈ FY , there is a unique a ∈ FX such that Ff (a)= b.
A presheaf F is a sheaf if it satisfies the sheaf axiom for all morphisms.
It is easy to see that every image Ff (a) ∈ FY is a matching element. The sheaf axiom says that these are the only matching elements. This being the standard definition of sheaves, there is a more elementary characterization:
Lemma 2.1 [17, 2.1.11(h)] A presheaf in F in P(C) is an atomic sheaf iff, for every f : X → Y in C,
Ff is an injective function.
The image of Ff is precisely the set of matching elements for f.
The full subcategory of sheaves in P(RM) is denoted S(RM). The move from presheaves to sheaves is necessitated by the construction of exponentials for fibred reflexive-graphs. Their use in the semantics of state was prioneered by O’Hearn and Stark [23,43]. They also underlie framework of nominal sets [31] and, possibly, Separation Logic.
Theorem 2.2 If C is a parametricity graph satisfying the right Ore condition, the category S(C) of atomic sheaves over C preserving co-cartesian squares is cartesian closed.
Products are given pointwise: (F × G)(X)= F (X) × G(X) and (F × G)(R)= 
F (R) × G(R).	Exponents are given as in presheaf categories: (F ⇒ G)(X) =
∀h:Z→X[F (Z) → G(Z)], where ∀ denotes the “parametric limit” (in Set) indexed by morphisms h originating from X [10]. Explicitly, the parametric limit consists of families of the form
⟨th ∈ [F (Z) → G(Z)]⟩h:X→Z

that are parametric in the sense that
h IX → S hj ⇒ th F (S) → G(S) th′
Since F and G are PG-functors, such families are automatically natural [10]. The relation (F → G)(R) = ∀S→R[F (S) → G(S)] relates two families ⟨th⟩h:X→Z and
⟨tj ′ ⟩h′:X′→Z′ iff, for all logical relations S : Z ↔ Zj and all h, hj of appropriate
types:
h R → S hj =⇒ th F (S) → G(S) tj ′

Modeling Passivity
Intuitively, a computation is passive if it reads the state but carries out no state changes. Since our stores X = (QX , TX) have a state set component and a state transformation component, this means that passive computations should only de- pend on the QX components and be independent of the TX components.
We use relational parametricity to formalize these concepts. Call a logical rela- tion R : X ↔ Xj a transformer relation if its state set component is the diagonal relation: Rq = ΔQX . There are no constraints on the transformation component of the logical relation (except those imposed by reader monoids).
Definition 3.1 Given a PG-functor F in S(RM) anda store X, a value d ∈ FX is said to be passive if, for all transformer relations R : X ↔ X, d is related to itself by FR, i.e., d FR d.
This accords with our intuition. Since transformer relations keep the state set components of worlds fixed but allow the transformation components to vary, if a value is related to itself under all such variations, it must be independent of the transformation components. It is easy to see that all values e ∈ Exp(X) are passive, as one would expect. On the other hand, in Com(X), a value a is passive if and only if a Rt  a for all transformer relations R. This is only possible if a = 1X, the do-nothing state transformation. (When we consider divergence, the passive command values include all approximations of 1X.)
A PG-functor itself may be regarded as a passive functor if all its values are passive (for all stores X). We require this uniformly for all stores X.
Definition 3.2 A PG-functor F is said to be passive if, for all transformer rela- tions R : X ↔ X, FR = ΔFX .
Note that Exp is a passive functor, and Com is not. However, Com has a
passive subfunctor, denoted ℘Com, which includes 1X at every store shape X. We examine how to characterize the passive subfunctors.
Passivity monomorphism
Recall that, for every store X, there is a corresponding passive store X0, which has the same state set as X but has only trivial state transformations TX0 = {1X }.

Since X0 allows no state changes, we expect that all values d ∈ FX0 are passive (for all PG-functors F ).
There is a passivity monomorphism pX : X0 > X given by the identity on state sets and the injection TX0 ‹→ TX for state transformations. By Lemma 2.1, a PG-functor in S(RM) sends it to an injection F pX, making F X0 a subobject of FX. Under the assumption that F preserves co-cartesian squares in addition to cartesian squares, we can show that all passive values of FX are contained within the image of FX0 under FpX.
Lemma 3.3 If F is a PG-functor in S(RM) that preserves co-cartesian squares, then a value d ∈ FX is passive if and only if there exists d0 ∈ F X0 such that FpX(d0)= d.
The “only if” direction is based on the fact that every transformer relation R
has the square shown on the left below:


X	pX> X 
FX0
FpX> FX

ˆ	ˆ
IX0	R
v pX	v
ˆ
IF X0
v
ˆ
FR 
FpX	v

X0 	> X	FX0 	> FX
As the PG-functor F maps it to the square on the right, all the values in the image under F pX : FX0 → FX are related to themselves by FR. Hence all such values are passive. For the “if” direction, we use the co-cartesian square shown on the left below:

X	pX> X 
.
F X0
F pX> FX
.

ˆ	.ˆ	ˆ
I	. Q	I
.ˆ
. FQ 

X0	. X	F X0	.	X
v p	.v	v  Fp	.v

X0	X> X 
FX0
X> FX

where QX : X ↔ X is given by (QX)q = ΔQX and (QX)t = {(1X , 1X)}. Since F preserves co-cartesian squares, this implies that all passive values of FX are contained within the image of F pX.

Passivity retraction relationss
In the category of worlds used by Tennent [24,45], the passivity monomorphisms have retractions rX : X → X0 such that pX; rX = idX, making the reverse compos- ite aX = rX; pX an idempotent. O’Hearn et al. defined passive values of a functor F as those satisfying FaX(d)= d.
In contrast, our category of worlds RM does not have such retractions because their state transformation components τrX would need to send all transformations in TX to 1X ∈ TX0 and, so, fail to be injective. Nevertheless, we can simulate the effect of the retractions via logical relations. The passivity retraction relation ξX : X ↔ X is given by (ξX)q = ΔQX and (ξX)t = { (a, 1X) | a ∈ TX }. This relation satisfies an important property:

Lemma 3.4 For all Algol type functors F, the relation FξX : FX ↔ FX has, as its domain, the entire set FX, and, as its range, the passive subset of FX.
Passive subfunctors
If F is a PG-functor in S(RM), there is a passive PG-functor ℘F in S(RM) defined by
(℘F )X = the range of FpX
(℘F )f = the restriction of Ff to (℘F )X
This definition is based on the following property.
Lemma 3.5 If F is a PG-functor in S(RM) and f : X → Y a morphism in RM
then Ff : FX → FY sends passive values in FX to passive values in FY .
Using Lemma 3.4, we can show the following result, establishing that passive functors form what might be called a “sub-reflective” subcategory.
Theorem 3.6 If F and P are Algol functors in S(RM) where P is passive, there is a natural injection from parametric transformations F → P to parametric trans- formations ℘F → P.
Par(F, P ) > Par(℘F, P )
Proof. If t : F → P is a parametric transformation, the corresponding t0 : ℘F → P has components (t0)X that are just the restriction of components tX to passive values. We show that t0 uniquely determines t. Since t preserves all logical relations, in particular the transformer relation ξX : X ↔ X, we have a relation-preservation square (in Set):
FX	tX  > PX

ˆ
FξX
v	tX
ˆ
PξX
v

FX 	> PX
Since ξX is a transformer relation, P ξX = ΔPX. So, the above square means:
∀d, d0 ∈ FX. d FξX d0 =⇒ tX(d)= tX(d0)
Since the range of FξX consists of only passive values (by Lemma 3.4), this means that tX is uniquely determined by its action on passive values.	2
Using this result, we can give a semantic interpretation to the “Passification” or “Co-promotion” rule as used in the “SCI Revisited” and “ILC Revisited” type systems [24,44]:

Π | i : θ, Γ ▶ M : φ
Π, i : θ | Γ ▶ M : φ
Passification

Here, the free identifiers to the left of “|” are in the “passive zone” and those to the right are in the “active zone.” The type rule says that a free identifier can be moved from the active zone to the passive zone, when used in a term M of a passive type. This is precisely the effect of the natural injection Par(F, P ) > Par(℘F, P ). A

rule such as this would be needed to accommodate the “block expression” construct proposed by Tennent [46].
Theorem 3.7 The passive subfunctor operator ℘ is in turn a functor ℘ : S(RM) → S(RM). It enjoys the following isomorphisms and embedding:
℘P ∼= P	for passive functors P

℘Com
∼= 1

℘(F × G) ∼= ℘F × ℘G
F ⇒ P > ℘F ⇒ P	for passive functors P

Proof. If t : F → G is a parametric transformation, ℘t : ℘F → ℘G is just the restriction t0 of t that acts on passive values. The first isomorphism is, in fact, an equality ℘P = P , and follows from the fact that the passive subset of PX is the entire PX. For Com, 1X is the only passive value in Com(X). So, ℘Com(X) is a singleton. For F ×G, note that (F ×G)pX = F pX ×GpX : F X0×GX0 → FX×GX. So, (d, e) is in the range of (F × G)pX iff d is in the range of F pX and e is in the range of GpX. The last embedding follows from the definition (F ⇒ P )(X) =
∀h:Z→X [FZ → PZ], since [FZ → PZ] embeds into [(℘F )Z → PZ].	2

Applications
In this section, we examine the consequences of the theory developed in the previous sections.

Interpretation of Idealized Algol
Idealized Algol [38] is a simply typed lambda calculus (with call-by-name parameter passing) with basic types that support imperative computations.
The interpretation of types exp[δ], com, var[δ], θ1 × θ2 and θ1 → θ2 is as PG- functors in S(RM), shown in Figure 1. For readability, we have used notation such as Expδ for [exp[δ]]] etc.
The interpretation of a term M with typing:
x1 : θ1,..., xn : θn ▶ M : θ

is a parametric transformation of type
[[M ]]: ( xi [[θi]]) → [[θ]]
This means that, for each store shape X, [[M ]]X is a function of type (  xi [[θi]](X)) →
[[θ]](X) such that all relations are preserved, i.e., for any relation R : X ↔ Xj, we
have [M ]]X ( xi [[θi]](R)) → [[θ]](R) [[M ]]X′ . To the extent that Idealized Algol is



equal : Expδ × Expδ → Expbool	equalX (e1, e2)= λs. e1(s)= e2(s)
condE : Expbool × Expδ × Expδ → Expδ condE (e, e1, e2)= λs. e(s) → e1(s); e2(s)

skip : 1 → Com
seq : Com × Com → Com
condC : Expbool × Com × Com → Com
for : Expint × Com → Com
skipX (∗)= 1X seqX (a, b)= a · b
condC (e, a, b)= readX λs. e(s) → a; b
forX (e, a)= readX λs. ae(s)

deref : Varδ → Expδ	derefX (d, a)= d

assign : Varδ × Expδ → Com
newvar : (Varδ ⇒ Com) → Com
assignX ((d, a), e)= readX λs. a(e(s))
newvarX (p)= (λs. (s, initδ)) · p[ι1](mkvar↑XsV ) · (λ(s, n). s)
where V = ( [δ]],T ([[δ]])) mkvar = (λn. n, λk. λn. k)




Fig. 2. Primitive operators of Idealized Algol
a simply typed lambda calculus, this interpretation is standard [10,27]. [[x]]X(u)= u(x)
[[λx : θ. M ]]X(u)= Λh : Z → X. λd : [[θ]](Z). [[M ]]Z(u↑Z [x '→ d])
[[MN ]]X(u)= [[M ]]X(u)[idX : X → X]([[N ]]X(u))

The parameter u may be thought of as an “environment” that provides values for the free identifiers, specifically in the given world X. The meaning of a lambda abstraction of type θ → θj is in ([[θ]] ⇒ [[θj]])(X), which consists of families of the form ⟨th⟩h:Z→X. Here, we are using notation “Λh : Z → X” borrowed from the polymorphic lambda calculus to express the parameterization by h. Note that the body of the abstraction λx : θ. M is interpreted in the future world Z and the environment u is “upgraded” to this world. We use the mnemonic short-hand

notation a↑Z
for the value [θ]](f )(a) when f : X → Z is the morphism available in

the context and θ is the type of a. Parametricity in Z is crucial for capturing the fact that [M ]]Z does not directly access any information of the future world. In the interpretation of function application terms, we are again using the polymorphic lambda calculus notation to pass in the h argument, which is idX : X → X.
The imperative operations can be defined as a set of primitive constants, a sample of which are shown in Fig. 2. Their interpretations should be mostly self- explanatory. We are using the notation p → v1; v2 to denote conditional expressions in semantic meta-language. Note that Reynolds’s read operation is used in inter- preting conditional commands as well as assignment, both of which use the current state information to construct a state transformation. Variable are represented as pairs of operations: an expression-typed operation that dereferences the variable and an “acceptor” that, given a value, stores it in the variable. The “newvar” prim- itive allocates a new variable in the context of a store X. It defines a new piece of store V with the state set [δ ] and all state-transformations on it, denoted T ([[δ]]). The “mkvar” construction provides the dereference-acceptor pair on this store. To add the store V to the existing store X, we use a tensor product on stores denoted

 [36]. The store X  Y is defined as the reader monoid:
QX٨Y = QX × QY
TX٨Y = read-closure of { a × b | a ∈ TX , b ∈ TY }
This store has evident injections ι1 : X → X  Y and ι2 : Y → X  Y .
Examples
In the first place, let us note that the snap back combinator (do C result E) is ruled out. To interpret it we would need a parametric transformation of the form:
do : Com × Exp → Exp
doX(a, e)= λs. e(a(s))
We can see that it is not parametric. For example, the preservation of the relation
ξX : X ↔ X requires
Com(X) × Exp(X) doX> Exp(X)
ˆ	ˆ	ˆ

Com(ξX) v Exp(ξX) v
 doX 
Exp(ξX)
v

Com(X) × Exp(X)	> Exp(X)
which says e(a(s)) = e(1X(s)) for all a ∈ Com(X), e ∈ Exp(X) and states s ∈ QX. (Note that a Com(ξX) 1X and e Exp(ξX) e.) Since 1X(s)= s, we are requiring e(a(s)) = e(s). The condition would be violated, for example, if X has at least two states, say {0, 1}, and a causes a state change, perhaps by sending 0 to 1, and e returns the integer in the current state.
Consider the equivalence stated in the Introduction:
if (deref x = 0) then f (deref x) else 2 ≡ if (deref x = 0) then f (0) else 2


This requires that, for all worlds X, values (e, a) ∈
Exp)(X):
Var(X) and f ∈ (Exp ⇒



 λs. (e s)=0 −→ f [idX] e s; 2  =  λs. (e s)=0 −→ f [idX] 0 s; 2 Consider a relation given by
Rq = { (s, s) | es = 0 }	Rt = {(1X , 1X)}

Since e Exp(R) 0, we must have, for all states s such that es = 0,

f [idX] es ΔInt f [idX] 0 s
Noting that ΔInt is nothing but the equality relation, we have a proof of the equiv- alence.

A more interesting variant of the above equivalence is:
if (deref x = deref y) then f (x) else 2 ≡
if (deref x = deref y) then f (y) else 2
where f : var → exp. The difference from the previous example is that we are passing the function procedure f the entire variable (x or y) rather than just an expression dereferencing it. So, one might wonder if there is a possibility of f changing the given variable. We argue abstractly, using the results of Theorem 3.7.
Var ⇒ Exp > ℘Var ⇒ Exp
= ℘(Exp × (Int → Com)) ⇒ Exp
∼= ℘Exp × ℘(Int → Com)) ⇒ Exp
∼= Exp × (Int → ℘Com) ⇒ Exp
∼= Exp × (Int → 1) ⇒ Exp
∼= Exp × 1 ⇒ Exp
∼= Exp ⇒ Exp
For the fourth step, regard Int → Com as a product i∈Int Com and use an in- finitary version of the product isomorphism. The calculation shows that a function procedure that receives a variable argument only has the ability to use its deref operation.
Handling divergence
For modeling divergence, we use a strict function model similar to that described in [26, Sec. 6]. Define a parametricity graph of Reynolds monoids with divergence, denoted RM⊥, where
“state sets” QX are flat cpo’s, and
transformations are complete ordered submonoids of the strict function space [QX −◦ QX], equipped with a readX operation.
The functions involved in morphisms are required to be strict and continuous, and the relations are required to be complete (pointed and directed-complete). In effect, this is the construction of RM duplicated internal to CPO⊥, the parametric graph of pointed cpo’s, strict continuous functions and complete relations, a structure studied in [10, Ch. 7] The semantic category is that of functors (RM⊥)op → DCPO that factor through CPO⊥. It is a result of Oles [29,25] that such a category is cartesian closed.
The passive store X0 of a store X has the same cpo of states as X but, as transformations, all approximations of the do-nothing transformation:
TX0 = { a | a ± 1X }
(The intermediate approximations are included by read-closure.) The passivity monomorphism pX : X0 > X involves the obvious injection of the complete ordered

monoid fX0 ‹→ fX.
The passivity retraction relation ξX : X x X mentioned in Sec. 3 can be adapted to deal with divergence as follows:
(ξX)q = ΔQX
(ξX)t = { (a, aj) | a H 1X ± aj }
It may be verified that (ξX)t is a monoid relation and ξX itself is a reader monoid relation. Lemma 3.4 continues to hold for this relation ξX and we can duplicate Theorem 3.6 as follows:
Theorem 5.1 If F and P are Algol functors in £(RM⊥) where P is passive, every parametric transformation t : F → P is uniquely determined by its restriction t0 : ℘F → P, giving a natural injection:
Par(F, P ) > Par(℘F, P )
The proof is the same as that of Theorem 3.6. This means that computations of type F → P are uniquely determined by their restrictions to ℘F → P . Hence, they cannot have side effects, not even temporary ones.
Related work
The model of Specification Logic, due to Tennent [45], was the first one to model passivity. The passivity aspects were further studied in [12,24]. Tennent’s model does not employ relational parametricity, relying on morphisms instead of relations to capture the uniformity conditions. Passivity and other intensional properties are modelled through a form of “what if” modeling. Morphisms in the category of stores include, not only those needed for interpreting the programming language, but additional ones that are used in the logical analysis (including the retractions of passivity monomorphisms). One decides whether a computation is passive by asking the question what would happen to it under a morphism that prohibits all state changes. If it remains the same, then it is regarded as passive; otherwise not. While intuitively appealing, this model has the unfortunate effect of becoming intensional (despite working in an extensional framework). Two program terms are equivalent only if they behave identically under all possible state change constraints. For example, the equivalence (1) is not valid in the model, for the reason that the left hand side of the equivalence would be undefined if state changes were constrained to those that preserve the even-ness of x, whereas the right hand side would continue to be defined.
The possibility of commands becoming less defined when we move to a future world is prohibited in our model because the transformation components ft of mor- phisms are required to be injective. This has consequences for the programming language. For instance, if we were to add a “block expression” construct that pre- cludes non-local state changes [46], Tennent’s model would allow the execution of the block expression to diverge (or give an error) if it attempts non-local state changes.

In contrast, our model allows block expressions to be constructed only from com- mands that can be guaranteed not to cause non-local changes, for instance via a type system like that of “SCI Revisited” or “ILC Revisited” [24,44].
O’Hearn and Reynolds [26] provide an account of irreversible state change for the command type and active expressions via a syntactic translation to the polymorphic linear lambda calculus. While the explanation of state change via a linearly used state object is intuitively appealing, it does not have an interpretation for passive expressions. O’Hearn and Reynolds do not provide any treatment of passive expres- sions in their paper, and it is generally believed that it is not possible to do so in a purely linear setting. See, for example, Wadler [48] where an extension of linear lambda calculus is proposed for modeling “read-only” uses. At a semantic level, O’Hearn and Reynolds use strict functions on pointed cpo’s to model state change, as previously recommended by the present author. This modeling eliminates snap back effects at the command type in the presence of divergence. It is adopted here in the same manner. However, our modeling of irreversible state change works even in the absence of divergence and, so, linearity and strictness are not central to it.
As remarked in Introduction, event-based models are able to model passivity with relative ease. However, all such models are intensional and do not satisfy extensional equivalences like (1). The “Passivity and Independence” model of the author [33] was historically the first one where the reflective subcategory structure of passive types was discovered. These ideas were later incorporated in the coherent space model [34] and the games model [1]. These models represent passivity by “fiat.” Out of all possible events, certain event are designated as “passive,” and the reflective subcategory structure is imposed via an axiom. In other words, these models state what is passive (rather correctly, it turns out), but do not explain what it means for a computation to be passive. The criticism that such a treatment lacks explanatory force, offered to the author by P. W. O’Hearn, P. Panangaden and others, formed the main driver for further investigation, culminating in the present results.
The Yoneda embedding of the coherent space model in a functor category shown in [25] bears a close intuitive resemblance to the present model. In that work, “object spaces,” a form of comonoids of coherent spaces, were used for modelling stores. This was the first instance of sophisticated mathematical objects being used to model stores and provided inspiration for other models such as the one proposed here. Beyond this, it is hard to draw any firm conclusions about a correspondence between the two because the model of [25] is event-based and stateless, whereas representing states is an important objective of the present model.
In recent work, Ahmed, Dreyer and colleagues [2,9] have applied the ideas of possible worlds (similar to functor categories) and automata-theoretic reasoning in the setting of operational reasoning. While the ideas seem intuitively similar, it is difficult to make a formal comparison at the present stage because the starting points of denotational and operational approaches are quite different. Some remarks regarding the comparison may be found in [36]. It is also worth remarking that these researchers have not yet tackled the issues of passivity in their approaches.

In another line of work, Benton et al. [4] have proposed a semantic characteriza- tion of effect systems in a global store model using relation-preservation properties. They were led to analyze “observable read-only effects” (i.e., observable passivity) as well as its dual “observable write-only effects,” and their characterization turns out to be quite similar to ours, viz., passive computations are those that preserve the identity relations on states. These ideas have been extended to dynamic alloca- tion of stores using Kripke logical relations (similar to our functor category models) in subsequent work [3,47]. The key difference between their work and ours is that they model effect systems, which may be thought of as Curry-style properties of computations, whereas we model type systems in the Church-style using semantic structures. The delicate balance of intensional and extensional effects does not seem to arise in this line of work.

Conclusion
We have defined a conceptually-based semantic model for imperative programs that captures the notion of “passivity”. This is done using a recently developed automata-theoretic denotational framework, where stores are modelled as an ab- stract form of automata, with explicit representation of states as well as state tran- sitions. Relational parametricity of the type and term interpretations then ensures that the properties of passive expressions are respected.
This approach contrasts with the intensional models such as the event-based and games models [1,34] where passivity is modelled by “fiat,” by designating certain events or moves as passive ones. While such models have strong definability and full abstraction properties, they however lack an explanation of what it means for a computation to be passive. In our extensional framework, on the other hand, a computation is passive if it is independent of the state transformations that might be possible in the store. We believe this gives a clear answer to the semantic question of what passivity means.
One might wonder if the model presented here is fully abstract. We have not investigated the question in detail and it will perhaps involve considerable work to settle the question because functor categories are quite extensive and not enough is not known about what is definable in them. However, we are able to calculate explicit representation results for simple first order types such as Com ⇒ Com and Com ⇒ Exp, which are accurate. We leave a full exploration of the full abstraction question to future work.
Other questions that this work might enable is a semantic understanding of the various notions of passivity present in specification and verification frameworks, e.g., program specification systems [18], ownership type systems [22] and fractional permission-based methods [6,37]. Secondly, the successful modeling of passivity takes us one step closer to modeling program logics such as Syntactic Control of Interference [24], Specification Logic [39,45] and Separation Logic [37,41]. We en- visage that the model presented here will be helpful to streamline the semantic treatment of such programming logics.

Acknowledgements
We are grateful to anonymous referees whose comments led to various improvements in the paper. Discussions with Claudio Hermida, Neil Ghani and Patricia Johann are warmly acknowledged.

References
S. Abramsky and G. McCusker.	Full abstraction for Idealized Algol with passive expressions.
Theoretical Comput. Sci., 227(1-2):3–42, 1999.
A. Ahmed, D. Dreyer, and A. Rossberg. State-dependent representation independence. In Thirty Sixth Ann. ACM Symp. on Princ. of Program. Lang. ACM, 2009.
N. Benton, A. Kennedy, L. Beringer, and M. Hofmann. Relational semantics for effect-based program transformations with dynamic allocation. In 9th ACM SIGPLAN Intl. Conf. on Princ. and Practice of Declarative Program., pages 87–96. ACM, 2007.
N. Benton, A. Kennedy, M. Hofmann, and L. Beringer. Reading, writing and relations. In N. Kobayashi, editor, APLAS ’06, pages 114–130. Springer, 2006.
R. Bornat, C. Calcagno, P.W. O’Hearn, and M. Parkinson. Permission accounting in Separation Logic. In ACM Symp. on Princ. of Program. Lang., pages 59–70. ACM Press, 2005.
J. Boyland. Checking interference with fractional permissions. In R. Cousot, editor, Static Analysis: 10th Intern. Symp., volume 2694 of LNCS, pages 55–72. Springer, 2003.
S. D. Brookes. A semantics for Concurrent Separation Logic. Theoretical Comput. Sci., 375(1-3):227– 270, Apr 2007.
S. D. Brookes, M. Main, A. Melton, and M. Mislove, editors. Math. Found. of Programm. Semantics: Eleventh Ann. Conference, volume 1 of Elect. Notes in Theor. Comput. Sci. Elsevier, 1995.
D. Dreyer, G. Neis, and L. Birkedal. The impact of higher-order state and control effects on local relational reasoning. In ICFP, 2010.
B. P. Dunphy and U. S. Reddy. Parametric limits. In Proc. 19th Ann. IEEE Symp. on Logic in Comp. Sci., pages 242–253. IEEE, July 2004.
S. Eilenberg. Automata, Languages, and Machines. Academic Press, 1974. (Volumes A and B).
P. J. Freyd, P. W. O’Hearn, A. J. Power, M. Takeyama, and R. D. Tennent. Bireflectivity. In Brookes et al. [8], pages 199–213.
C. Hermida. Fibrations, logical predicates and indeterminantes. Ph.D. thesis and Technical Report ECS-LFCS-93-277, University of Edinburgh, 1993.
C. A. R. Hoare. Communicating Sequential Processes. Prentice-Hall International, London, 1985.
W. M. L. Holcombe. Algebraic Automata Theory. Cambridge Studies in Advanced Mathematics. Cambridge Univ. Press, Cambridge, 1982.
B. Jacobs. Categorical Logic and Type Theory, volume 141 of Studies in Logic and the Foundations of Mathematics. Elsevier, 1999.
P. T. Johnstone. Sketches of an Elephant: A Topos Theory Compendium (two volumes). Clarendon Press, 2002.
K. R. M. Leino. Dafny: An automatic program verifier for functional correctness. In LPAR-16, volume 6355 of LNCS, pages 348–370. Springer-Verlag, 2010.
S. Mac Lane and I. Moerdijk. Sheaves in Geometry and Logic: A First Introduction to Topos Theory. Springer-Verlag, 1992.
G. McCusker. A fully abstract relational model of syntactic control of interference. In Computer Science Logic (CSL) 2002, volume 2471 of LNCS, pages 247–261. Springer-Verlag, 2002.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
J. Noble, J. Vitek, and J. Potter. Flexible alias protection. In E. Jul, editor, ECOOP’98 - Object- oriented Programming, volume 1445 of LNCS, pages 158–185. Springer-Verlag, 1988.


P. W. O’Hearn. A model for syntactic control of interference. Math. Struct. Comput. Sci., 3:435–465, 1993.
P. W. O’Hearn, A. J. Power, M. Takeyama, and R. D. Tennent. Syntactic control of interference revisited. In Brookes et al. [8], pages 447–486. (Reprinted as Chapter 18 of [28]).
P. W. O’Hearn and U. S. Reddy. Objects, interference and the Yoneda embedding. Theoretical Computer Science, 228(1):211–252, 1999.
P. W. O’Hearn and J. C. Reynolds. From Algol to polymorphic linear lambda-calculus. J. ACM, 47(1):167–223, Jan 2000.
P. W. O’Hearn and R. D. Tennent. Parametricity and local variables. J. ACM, 42(3):658–709, 1995. (Reprinted as Chapter 16 of [28]).
P. W. O’Hearn and R. D. Tennent. Algol-like Languages (Two volumes). Birkh¨auser, Boston, 1997.
F. J. Oles. A Category-Theoretic Approach to the Semantics of Programming Languages. PhD thesis, Syracuse University, 1982.
F. J. Oles. Functor categories and store shapes. In Algol-like Languages [28], chapter 11, pages 3–12.
A. M. Pitts. Nominal Sets: Names and Symmetry in Computer Science. Cambridge Univ. Press, 2013.
G. Plotkin and M. Abadi. A logic for parametric polymorphism. In Typed Lambda Calculi and Applications - TLCA ’93, LNCS, pages 361–375. Springer-Verlag, 1993.
U. S. Reddy. Passivity and independence. In Proc. Ninth Ann. IEEE Symp. on Logic in Comp. Sci., pages 342–352. IEEE, July 1994.
U. S. Reddy. Global state considered unnecessary: An introduction to object-based semantics. J. Lisp and Symbolic Computation, 9:7–76, 1996. (Reprinted as Chapter 19 of [28]).
U. S. Reddy and B. P. Dunphy. An automata-theoretic model of objects. In E. Zucca, editor, 2011 Intl. Workshop on Foundations of Object-Oriented Languages, pages 1–15. electronic proceedings at http://www.disi.unige.it/person/ZuccaE/FOOL2011/, 2011.
U. S. Reddy and B. P. Dunphy. An automata-theoretic model of Idealized Algol. In Automata, Languages and Programming (ICALP 2012), volume 7392 of LNCS, pages 337–350. Springer-Verlag, 2012.
U. S. Reddy and J. C. Reynolds. Syntactic control of interference for Separation Logic. In Thirty Ninth Ann. ACM Symp. on Princ. of Program. Lang., pages 323–336. ACM, 2012. (ACM SIGPLAN Notices, 47:1:323-336).
J. C. Reynolds. The essence of Algol. In J. W. de Bakker and J. C. van Vliet, editors, Algorithmic Languages, pages 345–372. North-Holland, 1981. (Reprinted as Chapter 3 of [28]).
J. C. Reynolds. Idealized Algol and its specification logic. In D. Neel, editor, Tools and Notions for Program Construction, pages 121–161. Cambridge Univ. Press, 1982. (Reprinted as Chapter 6 of [28]).
J. C. Reynolds.  Types, abstraction and parametric polymorphism.  In R. E. A. Mason, editor,
Information Processing ’83, pages 513–523. North-Holland, Amsterdam, 1983.
J.C. Reynolds. Separation Logic: A logic for shared mutable data structures. In LICS, pages 55–74, 2002.
D. S. Scott and C. Strachey. Towards a mathematical semantics for computer languages. In J. Fox, editor, Proc. of Symp. on Computers and Automata, pages 19–46. Polytech Institute of Brooklyn Press, 1971. (original Tech. Report Oxford PRG-6.).
Ian Stark. Categorical models for local names. Lisp and Symbolic Computation, 9(1):77–107, February 1996.
V. Swarup, U. S. Reddy, and E. Ireland. Assignments for applicative languages. In Algol-like Languages
[28], chapter 9, pages 235–272.
R. D. Tennent. Semantical analysis of specification logic. Inf. Comput., 85(2):135–162, 1990. (Reprinted as Chapter 13 of [28]).
R. D. Tennent. Denotational semantics. In S. Abramsky, D. M. Gabbay, and T. S. E Maibaum, editors,
Handbook of Logic in Computer Science, volume 3, pages 169–322. Oxford University Press, 1994.
J. Thamsborg and L. Birkedal. A Kripke logical relation for effect-based program transformations.
SIGPLAN Not., 46(9):445–456, September 2011.
P. Wadler. Linear types can change the world! In M. Broy and C. B. Jones, editors, Program. Concepts and Methods. North-Holland, Amsterdam, 1990. (Proc. IFIP TC 2 Working Conf., Sea of Galilee, Israel).

Appendix
Deﬁnitions
In this section, we give a brief overview of the framework of reflexive graphs [27, Sec. 7] and parametricity graphs [10].
Formally, we are considering reflexive graph objects in CAT, the category of all (small) categories.
Unpacking the definition, we note that a reflexive graph G consists of two cat- egories Gv and Ge (the “vertex” category and the “edge” category, respectively), and three functors between them ∂9, ∂1 : Ge → Gv and I : Gv → Ge such that
∂i ◦ I = IdGv . The functors ∂0 and ∂1 pick out the “source” and the “target” for the edges and their morphisms, whereas I assigns to each vertex X an “identity” edge IX. The notation R : X x Xj is used to denote the situation that ∂0(R)= X and ∂1(R)= Xj. The definition also generalize to edges of arbitrary arity in place of binary edges.
Reflexive graphs represent a special case of indexed categories. Hence, they form a 2-category with 1-cells being called “RG-functors” and 2-cells being called “parametric natural transformations”.
Intuitively, this data means that we use two-dimensional categorical structures, where morphisms occupy one dimension and edges (modelling “relations”) between categorical objects occupy the second dimension, as in the diagram below:

f
X 	> Y 
ˆ	ˆ
R	S
fj	v
Xj 	> Y j

A diagram of this form, called a square, is the shape of a morphism in Ge (of type R → S with its “source” and “target” being f and fj). It represents the property that the morphisms f and fj map R-related arguments to S-related results. The textual notation for the property is f R → S fj.
A reflexive graph is called relational if there is at most one edge morphism of any given shape. In that case, the hom-set Ge[R, S] is a set-theoretic relation between Gv[X, Y ] and Gv[Xj,Y j].
The reflexive graphs we work with are called parametricity graphs [10]. They incorporate additional axioms to capture the idea that relations in the vertical dimension indeed behave like “relations” in the intuitive sense. A parametricity graph is a reflexive graph that (i) is relational (ii) satisfies the identity condition: f IX → IY fj =⇒ f = fj and (iii) has a cloven fibration ⟨∂0, ∂1⟩ : Ge → Gv × Gv. The last of these conditions, which is an established part of category theory [16], means the following. The right square f R → S fj in the diagram below is called a cartesian square if every square of the form of the outer square uniquely factors

through it:
g	f
X 	> A 	> B 
.

ˆ
P
v gj
.ˆ	ˆ
.	S
.v fj	v

X 	> Aj 	> Bj
The reflexive graph is ﬁbred if, for all f , fj and S of matching types, there is an edge R that fills the dotted arrow making it a cartesian square. The edge R is unique up to isomorphism. A particular choice of such edges ⟨f, fj⟩∗ S = R is called a cleavage and the fibration is said to be cloven. Parametricity graphs are given with a chosen cleavage (even though in most of our examples, the cleavage is unique).
A parametricity graph-functor (PG-functor) is an RG-functor that preserves the chosen cleavage. A 2-cell between such functors (a parametric natural transfor- mation) only needs to satisfy the parametricity condition; naturality follows from parametricity [10]. This is because parametricity graphs have a subsumption map
⟨−⟩ that sends morphisms g : X → Xj to edges ⟨g⟩ : X x Xj with the property that a square of shape on the left below exists iff the square of morphisms on the right commutes:


f
X 	> Y 
f
X 	> Y 

ˆ
⟨g⟩
fj
ˆ
⟨h⟩	⇐⇒
v
g	h
∨	fj	∨

Xj 	> Y j	Xj 	> Y j
The subsumption map is given by ⟨g⟩ = ⟨g, idX′ ⟩∗ IX′ .
Dually, co-cartesian squares are of the form of the left inner square in the dia- gram:
f	g
A 	> B 	> X 
.

ˆ
R
v fj
.ˆ	ˆ
.	T
.v gj	v

A 	> Bj 	> Xj
so that all outer squares factor through them. An RG-functor is coﬁbred if it maps all co-cartesian squares that exist in its source graph to co-cartesian squares in the target graph. We make use of PG-functors that are cofibred. However, we do not require that the source graph itself should be cofibred, i.e., not all R, f and fj are required to have corresponding S relations.
