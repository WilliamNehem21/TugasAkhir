	Electronic Notes in Theoretical Computer Science 167 (2007) 203–223	
www.elsevier.com/locate/entcs

Medvedev Degrees of Generalized
R.E. separating Classes

Douglas Cenzer 1 ,2
Department of Mathematics University of Florida Gainesville, Florida, USA
Peter G. Hinman3
Department of Mathematics University of Michigan
Ann Arbor, Michigan, USA

Abstract
Important examples of Π0 classes of functions f ∈ ωω are the classes of sets (elements of ω2) which

1
separate a given pair of disjoint r.e. sets: S2 (A0, A1) := { f ∈
ω2: (6i < 2)(6x ∈ Ai)f (x) /= i }.

A wider class consists of the classes of functions f ∈ ωk which in a generalized sense separate a k-tuple of r.e. sets (not necessarily pairwise disjoint) for each k ∈ ω: Sk(A0,. .., Ak−1) :=
{ f ∈ ωk : (6i < k)(6x ∈ Ai)f (x) /= i }. We study the structure of the Medvedev degrees of such classes and show that the set of degrees realized depends strongly on both k and the extent to
which the r.e. sets intersect. Let £m denote the Medvedev degrees of those Sk(A0,. .., Ak−1) such
k	m
that no m + 1 sets among A0,.. ., Ak−1 have a nonempty intersection. It is shown that each £k
is an upper semi-lattice but not a lattice. The degree of the set of k-ary diagonally nonrecursive
functions DNRk is the greatest element of £1. If 2 ≤ l < k, then 0M is the only degree in £1 which
k	l
is below a member of £1. Each £m is densely ordered and has the splitting property and the same
k	k
holds for the lattice Lm it generates. The elements of £m are exactly the joins of elements of £1
k	k	i
for )  k  ≤ i ≤ k.
Keywords: Medvedev reducibility,degrees,separating class


1 Supported by National Science Foundation grants DMS 0554841 and DMS 0532644
2 Email: cenzer@math.ufl.edu
3 Email: pgh@umich.edu





1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.014

Background and summary
Turing reducibility is a way of comparing the complexity of functions f, g ∈ ωω, where ω := {0, 1,.. .} is the set of natural numbers and ωω is the set of total functions from ω into ω. f ≤T g means that there exists an algorithm which using information about g computes arbitrary values of f and is interpreted as signifying that f is no more complex than g. This algorithm may also be viewed as a partial recursive functional Φ such that f = Φ(g). Medvedev reducibility is an analogous way of comparing the complexity of two sets of functions: for P, Q ⊆ ωω, P ≤M Q iff there exists a partial recursive functional Φ such that Φ : Q → P . In particular, f ≤T g ⇐⇒ {f } ≤M { g }. The notion arises from viewing P and Q as the sets of solutions to “problems” P and Q, for example, the set of functions Colk(G) ⊆ ωk (k := {0, 1,... ,k − 1}) which serve as k-colorings of an infinite graph G with node set ω or the set CplExt(T ) ⊆ ω2 of characteristic functions of sets of Go¨del numbers of the complete extensions of a first-order theory T . Then P ≤M Q means that there is a partial recursive functional Φ which maps any solution to problem Q to a solution to problem P and thus signifies that P is no more difficult than Q.
Medvedev reducibility was introduced in [7] in 1955 and has been studied continuously ever since, albeit at a much lower level of intensity than its Turing counterpart. Recent surveys of the state of the theory are [12] and [9]; we discuss here only a few points that are essential background for the present work. Since ≤M , like ≤T , is reflexive and transitive, there is a natural notion of equivalence
P ≡M Q ⇐⇒ P ≤M Q	and	Q ≤M P.
The equivalence classes are called Medvedev degrees:
dgM (P ) := { Q : P ≡M Q };
they inherit a partial ordering: dgM (P ) ≤ dgM (Q) ⇐⇒ P ≤M Q. Recall that the Turing degrees form an upper semi-lattice with join (least upper bound) operation
dgT (f ) ⊕ dgT (g) := dgT (f ⊕ g),
where  (f ⊕ g)(2x)= f (x) and (f ⊕ g)(2x + 1) = g(x), but they do not form a lattice. The Medvedev degrees, on the other hand, do form a distributive lattice with join and meet operations
dgM (P ) ∨ dgM (Q)= dgM (P ∨ Q),

where  P ∨ Q := { f ⊕ g : f ∈ P and g ∈ Q }, and
dgM (P ) ∧ dgM (Q)= dgM (P ∧ Q),
where P ∧ Q := { (0)-f : f ∈ P }∪ { (1)-g : g ∈ Q }, ((i)-f )(0) = i and ((i)-f )(x + 1) = f (x). There is a largest degree dgM (∅) and a smallest degree 0M := dgM (P ) for any set P that has a recursive element.
Although it will not concern us directly here, the reader should be aware that there is another natural and closely related notion of reducibility for sets of functions, known as weak or Muˇcnik reducibility: P ≤w Q iff (∀g ∈ Q)(∃f ∈ P )f ≤T g and there are corresponding notions ≡w and dgw(P ). It is immediate that P ≤M Q =⇒ P ≤w Q, and ≤M is sometimes viewed as the uniform version of ≤w.
In studying Turing degrees, one often restricts attention to a subset of all degrees, most notably the r.e. degrees dgT (χA) for χA the characteristic function of a recursively enumerable (r.e.) set A ⊆ ω. In 1999 Simpson suggested that the natural analog of the r.e. Turing degrees are the classes
Dw := { dgw(P ): P ⊆ ωk is a Π0 class }
k	1
for k ≥ 2. We consider here the related classes

for k ≥ 2.
Dk := { dgM (P ): P ⊆ ωk is a Π0 class }

One aspect of this analogy is the close connection between r.e. sets and Π0 “problems”. For example, if the graph G mentioned in the first paragraph is r.e., then Colk(G) is a Π0 class, and if the first-order theory T is r.e. (recursively axiomatizable), then CplExt(T ) isa Π0 class. Most relevant to the present work
S(A, B) :=  f ∈ ω2: A ⊆ { x : f (x)= 1 }⊆ B },
the class of separating sets of A, B ⊆ ω; if these are r.e. sets, then S(A, B) is a Π0 class.
It is immediate that the join and meet operations described above are well- defined for each Dk, so these structures are also distributive lattices. Several recent papers have studied the structure of D2; a few results most relevant to the current study are:
([10]) D2 has a largest element dgM (DNR2), where
DNRk := { f ∈ ωk : ∀af (a) /  {a}(a) }
is the set of k-ary diagonally non-recursive functions.

([4]; Theorem 14) D2 is densely ordered; in fact
([1]; Theorem 8) D2 has the splitting property : for any p < q in D2, there exist q+, q− ∈ D2 such that p < q+, q− < q and q+ ∨ q− = q.
Although these were formulated explicitly for D2, they are equally valid for all Dk since
Proposition 1.1 For all k ≥ 2, Dk = D2.
Proof. Since ωk ⊆ ω(k + 1) it follows that Dk ⊆ Dk+1. For the converse it suffices to show that for all n, D2n ⊆ D2. For each f ∈ (2 ), let f ∈ 2 be the function such that for each x the sequence values f (nx),... ,f (nx + n − 1) is the binary representation of f (x) (with leading 0’s to make it of length n), and for P ⊆ ω(2n), P ∗ := { f ∗ : f ∈ P }. Then easily P ∗ is a Π0 class iff P is and P ≡M P ∗.	 
The theme of this paper is that despite this fact, there are interesting and subtle differences among subclasses of the classes Dk. This was already suggested by a result obtained in a different context long before the classes Dk were defined; in the current terminology it reads
Proposition 1.2 ([5]; Theorem 6)
dgM (DNR2) > dgM (DNR3) > ··· > dgM (DNRk) > ··· .


Note that generally
S(A, B)= { f ∈ ω2: (∀x ∈ ω) [x ∈ A =⇒ f (x) /=0 ∧ x ∈ B =⇒ f (x) /= 1] },
and thus with Ki := { a : {a}(a)  i }, DNR2 = S(K0, K1). This suggests the following generalization.
Definition 1.3 For all k ≥ 2, m < k and A0,... , Ak−1 ⊆ ω,
Sk(A0,... , Ak−1) := { f ∈ ωk : (∀i < k)(∀x ∈ ω) [x ∈ Ai =⇒ f (x) /= i] };
A0,... , Ak−1 is at most m-intersecting iff
for any i0 < i1 < ··· < im < k,	Aij = ∅;
j≤m
P is an (m, k)-separating class iff P = Sk(A0,... , Ak−1) for some sequence
A0,... , Ak−1 of r.e. sets which is at most m-intersecting;
Sm := { dgM (P ): P is an (m, k)-separating class }, the set of (m, k)-
separating degrees;

k−1
Sk := S	.
Some immediate consequences of this definition are the following.
Proposition 1.4 For all k ≥ 2 and m < k,
dgM (DNRk) ∈ S1;
{0M } = S0 ⊆ S1 ⊆ ··· ⊆ Sk−1 = S ;
k	k	k	k
Sm is a set of Π0 Medvedev degrees.
k	1
Proof. For (i), DNRk = Sk(K0,... , Kk−1) and these are clearly pairwise dis- joint. The first equality of (ii) follows from the fact that if A0,... , Ak−1 is at most 0-intersecting, then each Ai = ∅ and Sk(∅,... , ∅) = ωk. The other clauses are immediate.	 
Some of the most quotable of our results are the following, for all k ≥ 2 and 1 ≤ m < k.
Sm is an upper semi-lattice but not a lattice.
dgM (DNRk) is the greatest element of S1, so for k /= l, S1 /= S1.
k	k	l
If [ k | ≤ l ≤ k, then S1 ⊆ Sm, but if l < [ k |, then for all n < l, the
m	l	k	m
only element of Sn which is even ≤ any element of Sm is 0M .
l	k
For q = [ k |, the elements of  Sm are exactly those of the form pq ∨
m	k
pq+1 ∨ ··· ∨ pk, where each pi ∈ S1.

Each Sm
is densely ordered and has the splitting property; this holds

also for the sublattice Lm of Dk generated by Sm.
k	k
There is a large literature on Π0 classes; a good survey is [3] and we recall here only a few most relevant facts. Any Π0 class may be represented as the set P = [T ] of infinite paths through a recursive tree T ⊆ <ωk: f ∈ P  ⇐⇒
∀y (f T y) ∈ T , where f T y := (f (0),... ,f (y − 1)). Associated with P is also a canonical tree TP := { f T y : f ∈ P and y ∈ ω }. Clearly also P = [TP ]; TP is generally not recursive but only co-r.e. (Π0) and has the advantage of having no dead ends or leaves, elements σ which have no proper extensions in T . It is sometimes convenient to represent TP as the result of iterated pruning of leaves from T :
TP,0 := T ;	TP,s+1 := { σ ∈ TP,s : (∃i < k) σ-(i) ∈ Ts }.
Since by hypothesis T is finite branching, the Ko¨nig Infinity Lemma gives immediately that TP =  s∈ω TP,s. We shall also make use of the finite subtrees
	
notation for recursion theory will generally follow [11].

Basic structure
We begin with some simple observations.
Proposition 2.1 For all k ≥ 2, dgM (DNRk) is the greatest element of S1.
Proof. For any k-tuple (A0,... , Ak−1) of r.e. sets which is at most 1- intersecting — that is, pairwise disjoint — let a be an index of a partial recursive function F such that F (x, y)  i  ⇐⇒ x ∈ Ai. Then using the
standard Sm functions, x ∈ Ai iff S1(a, x) ∈ Ki, and the recursive functional
n	1
Φ defined by Φ(f )(x) = f (S1(a, x)) maps DNRk into Sk(A0,... , Ak−1) and
hence witnesses that Sk(A0,... , Ak−1) ≤M DNRk.	 
Definition 2.2 For any sets D and E of Medvedev degrees,
E := { d ∈ D2 : (∃e ∈ E) d ≤ e };
D ∨ E := { d ∨ e : d ∈D ∧ e ∈E }.
1
Corollary 2.3 D2 = Dk = S2.
Proof. By (1) of Section 1 and the preceding proposition.	 
However, it does not follow that S1 = D2 and we shall see that this is far

from the case. For example, we show that S1 ∩S1 = {0
} and more generally

all of the classes S1 are almost pairwise disjoint in this sense. First a simple
result in the other direction. As usual, [ k | is the ceiling of  k , the smallest
m	m
integer p such that k ≤ mp.
Proposition 2.4 For all k, l ≥ 2 and 1 ≤ m < k, if [ k | ≤ l ≤ k, then
S1 ⊆ Sm.
k
Proof. With k, l and m as in the hypothesis, fix a pairwise disjoint sequence (A0,... , Al−1). Since k ≤ ml there exist m' ≤ m and l' < l, with l' = 0 if m' = m, such that k = m'l + l'. Then
Sl(A0,... , Al−1) ≡M Sk(A0,... , Al−1,... , A0,... , Al−1, A0,... , Al'−1),
where there are m'-many repetitions of A0,... , Al−1. The list on the right side is clearly at most m-intersecting. The inequality ≥M follows from the fact that the left side is a subset of the right. For ≤M , the recursive functional Φ defined by Φ(f )(x)= x  (mod l) clearly maps the right side into the left. 
Proposition 2.5 For all k ≥ 2 and m < k, Sm is closed under ∨ and hence forms an upper semi-lattice. However, it is not closed under ∧ and is not a sublattice of Dk.

Proof. Given m < k, let (A0,... , Ak−1) and (B0,... , Bk−1) be sequences of
r.e. sets which are at most m-intersecting. Then easily
Sk(A0,... , Ak−1) ∨ Sk(B0,... , Bk−1)= Sk(A0 ⊕ B0,... , Ak−1 ⊕ Bk−1),
where A ⊕ B := { 2x : x ∈ A }∪ { 2x +1 : x ∈ B }, and the sequence on the right side is also at most m-intersecting. On the other hand, a simple modifi-
cation of Proposition 7 of [4] establishes that for p, q ∈ Sm, p ∧ q ∈ Sm only
k	k
in the trivial cases p ∧ q = p or p ∧ q = q.	 
Next we establish the following representation theorem.
Theorem 2.6 For all k ≥ 2, 1 ≤ m < k and q = [ k |,
Sm = S1 ∨ S1	∨ ··· ∨ S1.
k	q	q+1	k
Proof. This is trivial for m = 1, so we assume m ≥ 2. The inclusion ⊇ is immediate from Propositions 2.4 and 2.5. For the converse inclusion, we introduce a refinement of the notion of m-intersecting: for 1 ≤ m < k and n ≤ k, a sequence (A0,... , Ak−1) is of type (m, n) iff there exists a set G ⊆ k of cardinality n such that
(∀i ∈ G)(∀j < k) i /= j =⇒ Ai ∩ Aj = ∅;
(Ai : i ∈ k \ G) is at most m-intersecting.

Let Sm, n
denote the set of joins of finitely many degrees of the form

dgM (Sk(A0,... , Ak−1)) such that  A0,... , Ak−1 are r.e. and (A0,... , Ak−1) is of type (m, n). Some easy consequences of the definition which we leave to the reader are
Sm, 0 = Sm;
k	k
S1,n = S1 for all n ≤ k;
k	k
Sm, n+1 ⊆ Sm, n.
k	k
For fixed k, 1 ≤ m < k and n ≤ k − m, let
l :=	k − m − n,	if n < k − m; 1,	otherwise.
We shall establish that for all n ≤ k − m,
Sm, n ⊆ Smin { l,m}, n+1 ∨ Sm−1,n.
k	k−m+1	k
Fix a sequence (A0,... , Ak−1) of type (m, n) and a witnessing set
G := {j0,... , jn−1 } ⊆ k.

Suppose first that n < k − m. For each F ⊆ k \ G of cardinality m, let
 iF ,... , iF  } be the elements of k \ (F ∪ G). Set

0	l−1

SF (A0,... , Ak−1) := Sk−m+1 AiF ,... , AiF  , Aj ,... , Aj

,  Ai .


Because (A0,... , Ak−1) is at most m-intersecting,  i∈F Ai is disjoint from each
0	l−1
Hence the sequence on the right side is of type (min {l, m }, n+1) and therefore

dg (SF (A ,... ,A 
)) ∈ Smin { l,m}, n+1.

M	k	0
k−1
k−m+1

If n = k − m, there is a unique set F = k \ G of cardinality m and we set
SF (A0,... , Ak−1) := Sk−m+1 Aj ,... , Aj	,  Ai .

This sequence is pairwise disjoint, so by (4) again


dg (SF (A ,... ,A 
)) ∈ S1
Smin { l,m}, n+1.

M	k	0
k−1
n+1
k−m+1



We next define a sequence A∗,... , A∗
as follows. Fix a simultaneous

0	k−1
enumeration ⟨ Ai,s : i < k, s ∈ ω ⟩ of A0,... , Ak−1. Set
A∗ :=  x : ∃s  x ∈ Ai,s ∧ (∃<(m−1)j < k) ∃t[((t, j) ≺ (s, i) ∧ x ∈ Aj,t)] ,,


where ≺ is the lexicographical ordering.	Each A∗
is r.e., A∗
⊆ Ai and

(A∗,... , A∗	) is of type (m − 1, n). Thus it will suffice to show that
0	k−1
Sk(A0,... , Ak−1) ≡M		SF (A0,... , Ak−1) ∨ Sk(A∗,... , A∗	).

k
F ⊆ k \ G
|F | = m
0	k−1

For the inequality ≥M it suffices to show that Sk(A0,... , Ak−1) is sep- arately above each component of the right side.	Sk(A0,... , Ak−1)  ≥M

Sk(A∗,... , A∗	) because Sk(A0,... , Ak−1) ⊆ Sk(A∗,... , A∗
). Fix F ⊆ k \G

0	k−1	0	k−1
of cardinality m. Then if n < k − m it is easy to check that the following
functional Φ maps Sk(A0,... , Ak−1) into SF (A0,... , Ak−1):
⎧⎪⎨ p,	if f (x)= iF	(p < l);
Φ(f )(x)=	l + p,	if f (x)= jp	(p < n);
⎪ k − m,	if f (x) ∈ F .
If n = k − m, we omit the first clause of the definition of Φ.

We address now the inequality ≤M of (7). An element of the right side of
is (essentially) a finite set of functions
{ fF : F ⊆ k \ G ∧ |F | = m }∪ {g },


with each fF ∈ SF (A0,... , Ak−1) and g ∈ Sk(A∗,... , A∗
). We describe

k	0	k−1
a recursive mapping from such a set to a function h ∈ Sk(A0,... , Ak−1) as
follows. Given x, and assuming n < k − m,
if for some (least) F , fF (x)= p < l, then h(x) := iF ;
otherwise, if for some (least) F , fF (x)= l + p for p < n, then h(x) := jp;
otherwise, h(x) := g(x).

We need to show that x ∈/
Ah(x). If h(x) = iF
because fF (x) = p, then

x ∈/ AiF  because fF ∈ SF (A0,... , Ak−1). The argument in case (9) is similar.
Suppose now that h(x) is defined by case (10). This means that for all F ,
fF (x) = k − m and therefore x ∈/	Ai.	Since g ∈ Sk(A∗,... , A∗	),

∗
g(x)
∗
h(x)
. Suppose, towards a contradiction, that x ∈ Ah(x). By the

construction of A∗	this happens only if for some distinct i0,... , im−2 different
from h(x), x ∈ Aij (j ≤ m − 2). But then for F := {i0,... , im−2, h(x)},

x ∈	i∈F Ai, contrary to the case hypothesis. Hence x ∈/
this establishes (7) and therefore (6).
Ah(x) as required;

To complete the proof we show by induction on k ≥ 2 that for all 1 ≤ m < k and all n ≤ k − m,


Sm, n ⊆ S1 ∨ S1

∨ ··· ∨ S1
for q =  k − n  + n.


This gives the desired result by (3). For k = 2, the only cases are S1, 0 and S1, 1 which are immediate by Proposition 2.5 and (4). Assume as induction hypothesis that the result holds for all k' < k. For m = 1, q = k and the result follows by (4). Assume as secondary induction hypothesis that (11) holds for k and all m' < m. In particular, for k' = k − m +1 and m' = m − 1,

min { l,m}, n+1	1	1
 k' − (n + 1) 





Sm',n ⊆ S1

∨ ··· ∨ S1

for q
:=  k − n  + n.


Note that the hypothesis is satisfied since n ≤ k − m < k − m' and if l > 1, then k' − l = n +1 so n +1 ≤ k' − min {l, m }. Hence by (6), it suffices to show that both q0, q1 ≥ q. This is immediate for q1 and for q0 we compute

k' − (n + 1)
min {l, m }
+ (n + 1) ≥
 k' − (n + 1) 


+ (n + 1)

=  k − m − n  + (n + 1) =  k − n  + n = q.
m	m


The following examples illustrate the content of this result.
Corollary 2.7	(i) S2 = S1 ∨ S1;
3	2	3
S2 = S3 = S1 ∨ S1 ∨ S1;
4	4	2	3	4
S2 = S1 ∨ S1 ∨ S1;
5	3	4	5
S3 = S4 = S1 ∨ S1 ∨ S1 ∨ S1;
5	5	2	3	4	5
S2 = S1 ∨ S1 ∨ S1 ∨ S1.
7	4	5	6	7
We show next that in a strong sense the representation of the Theorem is unique.
Definition 2.8 For any k, l ≥ 2, n > 0 and p ≥ 1,
a tree T ⊆ nk is p-fat iff for each τ ∈ T there exist i0 < ··· < ip−1 < k 
such that for all q < p, τ-(iq) ∈ T ;
for any F : nk → l and E ⊆ l, let
TF := { τ : (∃σ ∈ nk)F (σ) ∈ E ∧ τ ⊆ σ };
E is p-dense (with respect to F ) iff there exists a p-fat tree T ⊆ TF .
Proposition 2.9 For any k, l ≥ 2, n > 0, 1 ≤ m < k and F : nk → l, if
k > lm, then
for some j < l, { j } is (m + 1)-dense;
for each j < l, if l \{j } is (k − m)-dense, then {j } is not (m + 1)-dense.
Proof. For (i) we proceed by induction on n. For n = 1 this is just the pigeon-hole principle. Given F : n+1k → l, define G : nk → l by
G(τ )= least j < l (∃i0 < ··· < im < k)(∀q ≤ m) F (τ-(iq)) = j;
such a j must exist again by the pigeon-hole principle.	By the induction

hypothesis there is a j < l and an (m + 1)-fat tree T ⊆ Tt
.	Then by

construction
{ τ-(i): τ ∈ T ∧ F (τ-(i)) = j }

is an (m + 1)-fat subtree of TF .

For (ii), suppose towards a contradiction that for some j < l there exist

both a (k − m)-fat tree T ⊆ TF
and an (m + 1)-fat tree U ⊆ TF
. Recur-

sively, again just by the pigeon-hole principle, there exist, τ0 ⊆ τ1 ⊆ ··· ⊆ τn such that for each q ≤ n, |τq| = q and τq ∈ T ∩ U . But then both F (τn) /= j and F (τn)= j, a contradiction.	 

Theorem 2.10 For all k, l ≥ 2 and 1 ≤ m < k, if l < [ k |, then S
m
∩ S	=

{0M }.
l	k

Proof. With k, l, and m as in the hypothesis, suppose that p  ∈ Sl,
q ∈ Sm and p ≤ q; we show that p = 0M .	Fix sequences of r.e. sets
(A0,... , Ak−1), which is at most m-intersecting, and (B0,... , Bl−1) such that q = dgM (Sk(A0,... , Ak−1)) and p = dgM (Sl(B0,... , Bl−1)), and a recursive functional
Φ: Sk(A0,... , Ak−1) → Sl(B0,... , Bl−1).
To show that p = 0M we show that Sl(B0,... , Bl−1) has a recursive element f . For each x ∈ ω, there exists nx such that for all σ ∈ nx k, Fx(σ) := Φ(σ)(x) ↓. Set
f (x) := least j < l [{j } is (m + 1)-dense with respect to Fx];
this value is well-defined by (i) of the proposition and clearly f defined in this way is recursive. To see that f ∈ Sl(B0,... , Bl−1), let
T (x)= { σ ∈ nx k : (∀y < nx)(∀i < k)[y ∈ Ai =⇒ σ(y) /= i] }.
Since (A0,... , Ak−1) is at most m-intersecting, T (x) is (k − m)-fat and for all
x and j < l,
x ∈ Bj =⇒ T (x) ⊆ { σ ∈ nx k : Φ(σ)(x) /= j }
=⇒ l \ { j } is (k − m)-dense with respect to Fx
=⇒ {j } is not (m + 1)-dense with respect to Fx
=⇒ f (x) /= j.

Corollary 2.11 For all 2 ≤ l < k, S1 ∩ S1 = {0	}.
l	k	M
Note that this provides a new proof of Proposition 1.2, since dgM (DNRk)
is a non-0 element of S1 and hence is not a member of S1	.

k
Corollary 2.12
S1 ⊂ S2 = S ;
k+1

3	3	3
S1 ⊂ S2 = S3 = S ;
4	4	4	4
S1 ⊂ S2 ⊂ S3 = S4 = S ;
5	5	5	5	5

S1 ⊂ S2 ⊂ S3 = S4 = S5 = S ;
6	6	6	6	6	6
S1 ⊂ S2 ⊂ S3 ⊂ S4 = S5 = S6 = S .
7	7	7	7	7	7	7


Proof. For example, since [5 | = 3, S2 = S1 ∨ S1 ∨ S1
and in particular

2	5	3	4	5
S1 ⊆ S2, but S1 /⊆ S1 since S1 ∩ S1 = {0	}.	 

3	5	3	5
3	5	M

Since, for example, S2 = S ∨ S1 it is natural to ask if S2 really contains
4	3	4	4

new degrees or whether simply S2
= S3
∪ S1. To see that that this latter

equality does not hold, we give first a generalization of Theorem 2.10.
Proposition 2.13 For any k, l ≥ 2 and 1 ≤ m < k, if l < [ k |, then
for any p ∈ Sl, s ∈ Sm and r, if p ≤ r ∨ s, then p ≤ r;

for any class E of Π0 Medvedev degrees, S ∩ E ∨ Sm = S
∩ E.

1	l	k	l
Proof. With notation as in the proof of Theorem 2.10 and R any Π0 class,
suppose that Φ is a recursive functional such that
Φ: R ⊕ Sk(A0,... , Ak−1) → Sl(B0,... , Bl−1).
We shall define a recursive functional Ψ : R → Sl(B0,... , Bl−1). For each x ∈ ω and h ∈ R, there exists nx,h such that for all σ ∈ nx,hk, Fx,h(σ) := Φ(σ, h)(x) ↓. Set
Ψ(h)(x) := least j < l [{j } is (m + 1)-dense with respect to Fx,h].
To see that Ψ(h) ∈ Sl(B0,... , Bl−1), let
T (x, h)= { σ ∈ nx,hk : (∀y < nx,h)(∀i < k)[y ∈ Ai =⇒ σ(y) /= i] }.
Since (A0,... , Ak−1) is at most m-intersecting, T (x, h) is (k − m)-fat and as before for all x and j < l,
x ∈ Bj =⇒ f (x) /= j.
This establishes (i); (ii) is then immediate.	 
Proposition 2.14 For any r.e. Turing degree c > 0 and any q ≥ 2, there exist pairwise disjoint r.e. sets A0,... , Aq−1 of degree c such that dgM (Sq(A0,... , Aq−1)) > 0M .
Proof. We adapt the proof of Shoenfield for the case q = 2 as given in Proposition III.6.22 of [8]. Fix an r.e. set C of degree c and a stage enumeration

⟨ Cs : s ∈ ω ⟩ of C. For each i < q set
Ai := {⟨ a, x ⟩ : ∃s (x ∈ Cs+1 \ Cs ∧ { a}s(⟨ a, x ⟩)  i) }.
Clearly each Ai ≤T C. To see that C ≤T Ai, let ai be an index for the function with constant value i and gi(x) := least s [{ai }s(⟨ ai,x ⟩)  i]. Then x ∈ C ⇐⇒ ⟨ ai,x ⟩∈ Ai ∨ x ∈ Cgi(x).
Finally, suppose towards a contradiction that Sq(A0,... , Aq−1) has a recur- sive member f . Let a be an index for f and g(x) := least s [{ a}s(⟨ a, x ⟩) ↓]. Then x ∈ C ⇐⇒ x ∈ Cg(x), since if x ∈ C \ Cg(x), then for each i < q,
f (⟨ a, x ⟩)= i =⇒ {a}(⟨ a, x ⟩)  i =⇒ ⟨ a, x ⟩∈ Ai  =⇒ f (⟨ a, x ⟩) /= i.
But then C is recursive, contrary to hypothesis.	 
Proposition 2.15 For any Π0 Medvedev degree r > 0M and any q ≥ 2, there exists s ∈ S1 \ {0M } such that r /≤ s.
Proof. Fix a Π0 class R of Medevedev degree r. By a result of Jockusch and Soare, Theorem 2 of [6], there is a non-0 r.e. Turing degree c such that no member of R has Turing degree ≤ c. Let S := Sq(A0,... , Aq−1) be as in the preceding proposition. Then R /≤M S, since if some recursive Φ : S → R, then in particular for f the characteristic function of A0, Φ(f ) would be a member of R recursive in C. Hence r /≤ s := dgM (S).	 
Theorem 2.16 For all 2 ≤ q < k,
S1 ∨ ··· ∨ S1 /⊆S	∪ (S1	∨ ··· ∨ S1).
q	k	k−1	q+1	k


Proof. Given 2 ≤ q < k, let r be any non-0M member of	S1
and s ∈

S1 \ { 0M } as in the preceding proposition such that r /≤ s. Then p := r ∨ s
belongs to the left side of the displayed formula. Suppose first, towards a contradiction, that p ∈ Sk−1. Then by Proposition 2.13, p ≤ s, whence r ≤ s,
contrary to hypothesis. On the other hand, if p ∈ S1	∨ ··· ∨ S1, then in
particular s ∈ S1	∨ ··· ∨ S1, whence by repeated application of Proposition
2.13 followed by Proposition 2.10, s = 0M , contrary to hypothesis.	 

Density and splitting
In [4] we established that the structure (D2, ≤) is a dense partial ordering. That proof can be modified to establish the density of each (Sm, ≤), but here we shall get a strengthened version of this result in a different and easier way.

Definition 3.1	(i) For each k ≥ 2 and 1 ≤ m < k, Lm is the sublattice of
Ð2 generated by £m.
(ii) An upper semi-lattice (L, V , < ) has the splitting property iff for all p, q ∈ L, if p < q, then there exist q+, q− ∈L such that p < q+, q− < q and q+ V q− = q.
Remark 3.2 Because Ð2 is a distributive lattice and £m is an upper semi- lattice, the members of Lm are exactly the finite meets of elements of £m.
k	k

In Theorem 8 of [1] Binns proved that Ð2 has the splitting property. Of
course, this provides also an independent proof of density. His argument shows directly that £1 has the splitting property; below we extend this to to all £m

2
and Lm. The main work lies in establishing the following technical
Proposition 3.3 For each k ≥ 2 and 1 ≤ m < k, any q ∈ £m
k


and any

m
p, r ∈ Ð2 such that p < q, r ≤ q but r /≤ p, there exist q0,... , q2 −1 ∈ £m
such that for all i < 2m, p < qi < q, r /≤ qi and q0 V ··· V q2m−1 = q.
Proof. To reduce indexical clutter, we do the proof first for m =2 and k =3 and afterwards indicate how to extend to the general case.  Let P and R
be Π0 classes of Medvedev degree p and r, respectively, TP the canonical
(co-r.e.) tree for P = [TP ] described in Section 1, and U a recursive tree
such that R = [U ]. Let (A, B, C) be an at most 2-intersecting sequence of r.e. sets such that q = dgM (S3(A, B, C)). We shall construct r.e. sets Ai and Bj (i, j < 2) which partition A and B respectively such that with qij := p V dgM (S3(Ai, Bj, C)),
r /≤ qij < q;

 


i,j<2
qij = q.

We have p ≤ qij by construction, but we do not claim that always p < qij. However, it follows that this must hold for at least two pairs (i, j), and any

qij = p make no contribution to the join
i,j<2
qij so may be replaced by

copies of one of the qij > p to produce q0,... , q3 satisfying the conclusion of
the proposition.
The construction of Ai and Bj is in the style of the Sacks Splitting The- orem, Theorem VII.3.2 of [11]. For i, j < 2, let gij be the functions defined by

gij(x) :=
0,	if x ∈/ Ai;
1,	if x ∈ Ai but x ∈/ Bj;
⎩ 2,	otherwise.

For any Ai ⊆ A and Bi ⊆ B, (Ai, Bj, C) is at most 2-intersecting and thus gij ∈ S3(Ai, Bj, C) — if x ∈ Ai ∩ Bj, then x ∈/ C. The construction is designed to satisfy the following requirements.
Px :  x ∈ A =⇒ x ∈ A0  or  x ∈ A1  but not both;
Qx :  x ∈ B  =⇒ x ∈ B0  or  x ∈ B1  but not both;
Nb,i,j :	not	{b} : P V {gij}→ R.

Conditions Px and Qx ensure that Ai and Bj partition A and B respec- tively. Conditions Nb,i,j ensure that R /≤M P V {gij} and hence that r /≤ qij so also q /≤ qij. That qij ≤ q is immediate, so (i) is satisfied. For (ii), we describe an algorithm which from any four functions f ij ∈ S3(Ai, Bj, C) (i, j < 2) computes a function f ∈ S3(A, B, C):



f (x) :=
1,	else if (∃i < 2)(∀j < 2) f ij(x)= 1;
⎪⎩ 0,	otherwise.

Towards the construction, we define the following length and restraint functions.

l(b, i, j) :=
∞,	if {b} : P V {gij}→ R;
least y[(∃f ∈ P ){b}f⊕gij T (y + 1) ∈/ U ],	otherwise;

l(b, i, j, s) := least y[(∃σ ∈ T s
ij
){ b}	s T (y + 1) ∈/ U ];

P,s	s
r(b, i, j, s) := max u(gij; σ ⊕ gij, b, z, s): z < l(b, i, j, s) ∧ σ ∈ T s }.

Here a condition of the form F T (y + 1) ∈/ U is true if either F (z) is un-
defined for some z ≤ y or F T (y + 1) is defined but not in U . The use
u(h; ... ) is 1 + the largest value of h used in the indicated computation. Since the sequence ⟨ TP,s : s ∈ ω ⟩ is recursive, so are the functions l(b, i, j, s) and r(b, i, j, s). Readers familiar with similar arguments in r.e. degree theory should note that because U is a fixed recursive tree we can simplify the argu- ment below by using z < l(b, i, j, s) instead of z ≤ l(b, i, j, s) in the definition of r(b, i, j, s).
Choose recursive enumerations of A and B such that exactly one new element of A appears at each even stage, but none at odd stages and exactly one new element of B appears at each odd stage but none at even stages. Now at an even stage s, let xs be the unique element of As+1 \ As. Let (as, is, js) be minimal (in the lexicographic ordering) such that xs < r(as, is, js, s) if there

is such a triple, and set, for j < 2,
A1−is := A1−is ∪ {xs };	Ais


:= Ais ;	Bj


:= Bj.

s+1	s
s+1	s
s+1	s

Otherwise, do the same with is = 0. At an odd stage s do the same with the roles of A and B reversed. This completes the construction.
σ⊕gij
s	ij
A computation {b}s	(z) ↓ is called correct if the values of g	used are
correct — that is, gij T u = gij T u for u = u(gij; σ ⊕ gij, b, z, s). We say
s	s	s
that l(b, i, j, s) ≥ y correctly iff l(b, i, j, s) ≥ y and all of the computations
σ⊕gij
s	s
{b}s	(z) for σ ∈ T	and z < y are correct. We say that a stage t is
(b, i, j)-safe iff for all (a, i', j') which precede (b, i, j) lexicographically and all
s ≥ t,
r(a, i', j', s) has the same value denoted r(a, i', j');
As T r(a, i', j')= A T r(a, i', j')	and	Bs T r(a, i', j')= B T r(a, i', j'). We now establish that for all b, i, j, s and y,
if l(b, i, j, s) ≥ y correctly, then for all t ≥ s, l(b, i, j, t) ≥ y and l(b, i, j) ≥
y;
if l(b, i, j) ≥ y, then ∃t (∀s ≥ t) l(b, i, j, s) ≥ y;
if s is (b, i, j)-safe and l(b, i, j, s) ≥ y, then l(b, i, j, s) ≥ y correctly;
l(b, i, j) < ∞ and lims→∞ r(b, i, j, s) exists and is finite.
From (4) it follows that all requirements Nb,i,j are satisfied, so this will complete the proof. (1) is immediate just because Ai and Bj are r.e. sets. For (2), assume that l(b, i, j) ≥ y. Then
(∀f ∈ P )∃s {b}f†s⊕gij T y ∈ U	and	gij T u  = gij T u  ,


where
uf := max  u(gij; f ⊕ gij, b, z): z < y }.

By K¨onig’s Lemma (compactness),
∃s (∀f ∈ P ) {b}f†s⊕gij T y ∈ U .
s
Fix such an s¯. Since TP has no leaves, also
(∀σ ∈ T s¯) {b}σ⊕gij T y ∈ U ,
P	s¯
so for s ≥ s¯ large enough such that T s¯ = T s¯ we have l(b, i, j, s) ≥ y.

For (3), suppose that t is (b, i, j)-safe and l(b, i, j, t) ≥ y. Then for any s ≥ t, if xs < r(b, i, j, s), then (b, i, j) = (as, is, js), so xs is enumerated into either A1−i or B1−j and thus does not affect the value of gij(xs). Hence
gij T r(b, i, j, s)= gij T r(b, i, j, s),

so in particular for all z < l(b, i, j, s) and all σ ∈ T s
, {b}

σ⊕gij s

Finally we establish (4) by induction on the lexicographic ordering of the
tuples (b, i, j). Assume as induction hypothesis that (4) holds for all (a, i', j') preceding (b, i, j). It follows that there exists a (least) (b, i, j)-safe stage t¯. Suppose, towards a contradiction, that l(b, i, j) = ∞.  By (2), for all y

(∃s ≥
t¯) l(b, i, j, s) ≥ y, and by (3), for such s, l(b, i, j, s) ≥ y correctly,

so in particular,

(∀σ ∈ Ts



ij	ij
) {b}	s  T y  {b}	T y ∈ U.

P,s	s	s
Let h(y)  least s ≥ t¯[l(b, i, j, s) ≥ y + 1] and


Φ(f )(y)  {b}
ij h(y)
h(y)

Then Φ is a partial recursive functional, and for all f ∈ P , ∀y [Φ(f ) T y ∈ U ]
— that is, Φ : P → R contrary to the hypothesis that R /≤M P . We conclude that l(b, i, j) < ∞. By (2) and (3),
∃s (∀t ≥ s) l(b, i, j, t) ≥ l(b, i, j),


but by (1) and (3),

¬ (∃t ≥ t¯) l(b, i, j, t) ≥ l(b, i, j)+ 1.

Hence for all sufficiently large t ≥ t¯, l(b, i, j, t) = l(b, i, j) with correct com- putations and r(b, i, j, t) has as its common value the maximum of the uses of all of these computations.
This completes the proof of the special case m = 2, k = 3 and we turn to the general case with
q = dgM (Sk(A0,... , Am−1, Am,... , Ak−1)),
where (A0,... , Am−1, Am,... , Ak−1) is a sequence of at most m-intersecting
r.e. sets. Here we need to construct r.e. sets Ai for n < m and i < 2 such that
(A0 , A1 ) partitions An and for each ε ∈ m2, if
n
qε := p V dg  (Sk(Aε(0),... , Aε(m−1), Am,... , Ak	)),
−1
M	0	m−1

then
r /≤ qε;
ε∈m2


qε = q.

To achieve (v), we use functions
ε	 least i < m,	x ∈/ Aε(0) ∩ ··· ∩ Aε(i) if any;

g (x) :=
0	i
m,	otherwise.

Easily each gε ∈ Sk(Aε(0),... , Aε(m−1), Am,... , Ak−1), and for (v) it will suffice
0	m−1
to construct the sets Ai to satisfy conditions

Pn,x :	x ∈ An =⇒ x ∈ A0
or	x ∈ A1
but not both;

Nb,ε :	not	{b} : P V {gε }→ R.

This construction is a straightforward extension of the one above and is omit- ted. Finally, for (vi) we describe an algorithm that from functions fε for each ε ∈ m2 such that
fε ∈ Sk(Aε(0),... , Aε(m−1), Am,... , Ak)
0	m−1
computes a function f ∈ Sk(A0,... , Am−1, Am,... , Ak). For any x and i < l, let
(∃ε ∈ m2) fε(x)= i,	if m ≤ i < k; φ(x, i) be	(∃δ ∈ i2)(∃σ, τ ∈ m−i−12)

⎪

Easily φ(x, i) =⇒ x
[fδ-(0)- σ (x)= i = fδ- (1)- τ (x)],	otherwise.
∈/ Ai, so it suffices to prove that ∀x ∃i φ(x, i) and set

f (x) := least i φ(x, i). For i ≤ m, let
ψ(x, i)	be	(∀δ ∈ i2)(∃σ ∈ m−i2) fδσ(x) < i.
We claim then that for all x,
(∀i ≥ m) ¬ φ(x, i) =⇒ ψ(x, m);
for 0 < i ≤ m,	ψ(x, i) =⇒ φ(x, i − 1) V ψ(x, i − 1);
¬ ψ(x, 0).
Parts (vii) and (ix) are obvious. For (viii), assume ψ(x, i) and ¬ φ(x, i − 1)
— that is,
(∀δ ∈ i−12)(∀σ, τ ∈ m−i2) fδ-(0)- σ (x) /= i V fδ-(1)- τ (x) /= i .

By ψ(x, i),
(∀δ ∈ i−12)(∃σ, τ ∈ m−i2) fδ-(0)- σ(x) < i V fδ-(1)- τ (x) < i .


Hence,
(∀δ ∈ i−12)(∃υ ∈ m−(i−1)2) fδυ(x) < i,

which is exactly ψ(x, i − 1).	 
Theorem 3.4 For each k ≥ 2 and 1 ≤ m < k, £m and Lm have the splitting
k	k
property; in particular, they are densely ordered.

Proof. Consider first	£m
Proposition for r = q. Let
and for p < q, let q0,... , q2m−1 be as in the

s := q0 V ··· V q2m−1 −1	and	s := q2m−1 V ··· V q2m−1.
If both s0 < q and s1 < q, then we may use them as q+ and q− to witness the splitting property. Otherwise, if (say) s0 = q, let
t := q0 V ··· V q2m−2 −1	and	t := q2m−2 V ··· V q2m−1 −1,
and make the same argument. After at most m such steps we must produce appropriate q+ and q−.
Now suppose that p < q in Lm. As noted above, q may be represented in the form q = s0 ∧ ··· ∧ sn−1 for some si ∈ £m. Apply the proposition to each
si to find sj for i < n and j < 2m such that
p < sj < s ,	q /≤ sj	and	s0 V ··· V s2m−1 = s .

i	i	i
By distributivity,
i	i	i

q =
i<n



j< 2m

j i
ε∈n(2m)
ε	ε	ε(i)
i
i<n

Clearly p ≤ sε < q and we may now proceed first as in the proof of the proposition to replace any sε = p by others which satisfy sε < p and then as in the first part of this proof to subdivide this sequence of 2mn degrees to find after at most mn steps a pair q+ and q− which witness the splitting of q. 
In [2] Binns and Simpson prove that every finite distributive lattice can be embedded in Ð2 and hence in each Ðk. The proof does not seem to be easily adaptable to yield embeddings into the sublattices Lm, and we only pose this as a question. However, it is easy to adapt the mechanism for embedding partial orderings in the r.e. Turing degrees to show

Theorem 3.5 For each k ≥ 2 and 1 ≤ m < k, every countable partial order- ing is embeddable in (£m, ≤).
Proof. We first observe that for any k ≥ 2 and 1 ≤ m < k, there ex- ists a u.r.e. sequence of r.e. sets	⟨ An : i < k ∧ n ∈ ω ⟩ such that for all n,
An,... , An	is at most m-intersecting and any sequence ⟨ fn : n ∈ ω ⟩ such
0	k—1

that for all n, fn ∈ Pn := Sk(An,... , An
) is recursively independent. Hence

0	k—1
⟨ Pn : n ∈ ω ⟩ is Medvedev independent. The first assertion is a simple exten-
sion of [6], Theorem 4.1, and the second follows immediately.
As in the case of r.e. Turing degrees it suffices to embed an arbitrary recursive partial ordering ≤ of ω. With Pn as above, set
Rm :=	P i.
i≤m

Then easily m ≤ n =⇒ Rm ≤M Rn. Suppose, towards a contradiction that

m /≤ n but Rm ≤M Rn. Then if Qm :=
i/=m
P i we have Rn ≤M Qm and

thus
Pm ≤M Rm ≤M Rn ≤M Qm,

contrary to the Medvedev independence of ⟨ Pn : n ∈ ω ⟩.	 

References
Binns, S.,A splitting theorem for the Medvedev and Muchnik lattices, Math.Log.Quarterly 49
No. 4 (2003) 327–335
Binns, S. and S.G. Simpson,Embeddings in the Medvedev and Muchnik lattices of Π0 classes,
Arch. Math. Logic 43 No. 3 (2004) 399–414
Cenzer, D., Π0 classes in computability theory, “Handbook of Computability Theory”, Ed.
E. Griffor, Studies in Logic and the Foundations of Mathematics 140, Elsevier Science B.V.,
Amsterdam (1999) 37–85 ISBN 0-444-89882-4
Cenzer, D. and P.G. Hinman, Density of the Medvedev lattice of Π0 classes, Arch Math Logic
42 (2003) 583–600
Jockusch, C.G. and R.I. Soare, Π0 classes and degrees of theories, Trans. Amer. Math. Soc.
173 (1972) 33–56
Jockusch, C.G. and R.I. Soare, Degrees of members of Π0 classes, Pacific Journal of
Mathematics 40 No. 3 (1972) 605–616
Medvedev, Yu., Degrees of difficulty of the mass problem, Dokl. Akad. Nauk SSSR, 104 (1955) 501–504
Odifreddi, P., “Classical Recursion Theory”, Studies in Logic and the Foundations of Mathematics 125, Elsevier Science B.V., Amsterdam (1989) 668+vvii pp. ISBN 0-444-87295-7
Simpson, S.G., Mass problems and randomness, Bull. Symbolic Logic, 11, no. 1 (2005) 1–27

Simpson, S.G., Sets and models of WKL0, “Reverse mathematics 2001”, Lect. Notes Log.,
Assoc. Symbolic Logic, La Jolla, CA (2005) 352–378
Soare, R.I., “Recursively enumerable sets and degrees”, Springer-Verlag, Berlin (1987) 427+ xviii pp. ISBN 3-540-15299-7, 0-387-15299-7
Sorbi, A., The Medvedev lattice of degrees of difficulty, “Computability, Enumerability, Unsolvability: Directions in Recursion Theory”, Ed. S.B. Cooper et.al., London Mathematical Society Lecture Notes 224, Cambridge University Press (1996) 289–312
