	Electronic Notes in Theoretical Computer Science 214 (2008) 103–129	
www.elsevier.com/locate/entcs


Observational Refinement Process
Alexandre Madeira1
Department of Mathematics University of Aveiro Aveiro, Portugal

Abstract
In the algebraic specification of software systems, it is desirable to have freedom in the implemen- tation process, namely for the software reuse. In this paper we will discuss two issues in order to achieve this freedom: we study the observational stepwise reﬁnement process and we propose an alternative formalization of the refinement concept based on the logical translation from the abstract algebraic logic. In the first topic, we go beyond the traditional assumption of maintaining the set of observable sorts during the refinement process by the possibility of changing it between the process steps, i.e., we analise the stepwise refinement with encapsulation and desencapsulation of sorts during the process. In the second topic, we suggest a formalization of the refinement con- cept where an equation may be mapped into a set of equations, against the refinements based on signature morphisms, where an equation is mapped into another one.
Keywords: Algebraic specification, observational equality, observational refinement, refinement via translation.


Introduction
The use of mathematical formalisms in the development and verification of software systems has been widely research over the times, being the algebraic specification an important topic of this study. In this context, software ob- jects are viewed as algebras and the computations executed over them seen as terms. The algebraic specification of a software object consists of a sig- nature together with a class of algebras that satisfy the requirements of the system. Algebras in this class are called correct realizations of the specifica- tion, and they model the possible programs that satisfy the requirements of

1 Email: madeira@ua.pt


1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.006

the intended system. In the implementation process of a software component, we start with an initial specification of the system, and then we enrich it with implementation decisions in order to get a complete description of the desired program (desired algebra). This gradual process of successive refinements is known as stepwise refinement process (cf. [24,23,17,22]). Clearly, the size of the model class of the initial specification decreases as it is being enriched with new requirements since we progress from a more abstract case to a more concrete one. In this work, we use the modeling concept defined according to the standard satisfaction relation, with the equational logic as the under- lying logic. However, software designed according to the object orientation paradigm requires other tools, more appropriate for this process. In these software systems the data are split in the internal data (or encapsulated) and external data (or desencapsulated): the user has access to encapsulated data only via computations and has direct access to the other ones. On the user’s point of view, two elements are considered indistinguishable if they produce the same output over the same computations, and two implementations may be considered as equivalents if they return the same observable result over the same computations. Therefore, this partition induces an adaptation of the modeling concept, in which, a program only needs to satisfy the specification requirements from the outside of the system’s point of view, i.e., in its ob- servable behavior. To adequate this paradigm to the algebraic approach to software development, we split the sorts of signature specification: we con- sider the observable sorts to represent the data which we have direct access, and the non observable sorts, to represent the encapsulated sorts. A compu- tation of observable result is seen as an observable term. In order to achieve a precise semantics for programs with encapsulated data, this approach, named observational approach, suggests replacing the strict equality relation by the observational equality relation, in which two non observable elements are con- sidered indistinguishable if they have the same observational behavior when executed over the same program of observable result. The study of methods for observational verification of properties can be found, for example, in works of M. Bidoit and R. Hennicker, of J. Goguen, G. Malcolm and G. Ro¸su, of
A. Bouhoula, of R. Diaconescu, of K. Futatsugi, of P. Padawitz among others
(cf. [1,15,13,12,21,7,9,20]).
The adjustment of the stepwise refinement process to this new perspective has been studied by several authors (cf. [17,14,3]). In all the above mentioned works, it is presumed the observational preservation of sorts between refine- ment steps, in the sense that, encapsulated data in one determined refinement step, are still encapsulated in the pursuing of the process. However, the change of non observable into observable sorts and vice-versa, can be useful in various

situations. Specifically, on the one hand, for security and efficiency reasons in upgrades of protected software, can be necessary, sometimes during the implementation process, to encapsulate some data sorts. On the other hand, to desencapsulate sorts during the refinement process, can be advantageous in the application of proof methods (for example, when we are able to des- encapsulate all sorts the observational equality relation can be interpreted by the strict equality relation). An important issue of this topic is how to control the vertical composition of observational refinements made by different obser- vational equality relations, i.e., how to guarantee that the composition of two observational refinements made by different observational equality relations continues being an observational refinement. In the first part of this paper we study the stepwise refinement process, in which changes over the observable sorts are allowed, i.e., the observational stepwise refinement process with the variation of the set of observable sorts. Initially, is examined the data desen- capsulation in the refinement process. It is characterized a class of morphisms that desencapsulate data and preserve the property of vertical composition. Let SP ' be an observational refinement of SP with respect to a set of observ-
able sorts Obs. Clearly, SP ' is an observational refinement with respect to all
subsets of Obs. However, the converse it is not true. We present a result that
allows build from SP ' a specification which is an observable refinement of SP with respect to a smaller relation, namely with respect to the set Obs ∪ {v}. Part of this study is done exclusively for the equational specifications case.
Following the recent works which apply some tools and results of the ab- stract algebraic logic to the specification of software systems (cf.[19]), in the second part of the paper, we suggest an alternative formalization of the re- finement concept called reﬁnement via translation. This concept is based on the logical translation concept, a central entity of the abstract algebraic logic (see [5,4,6]). The definition of translation appears in [4] formulated for the k-logical systems.  In this context, the translations are defined as (k − l)-
mappings, which translate a k-dimensional logical into another l-dimensional
one, over the same signature. A paradigmatic example of a translation of this kind is the translation of the classical propositional calculus into the equational theory of boolean algebras (cf. [4, Example 4.1.2]). An interesting aspect of the reﬁnements via translation, with respect to the implementation freedom, is the fact that in this formalization, a formula may be mapped into a set of formulas, against the formalizations based on the signature morphisms, where a formula is mapped into another one.
We formalize the reﬁnement via translation exclusively at the non observ- able case, i.e., to the case where Obs = S. However, the generalization of the concept to the observable case may be done in the natural way.

Preliminaries
Universal (sorted) Algebra
In this Section, we recall some notions of universal sorted algebra. A pre- sentation of these concepts may be found in [24] (or in [8] for the one-sorted case).

Deﬁnitions
Let S be a non empty set whose elements are called sorts. An S-sorted set is a S-indexed family of sets A = (As)s∈S. We say that a S-sorted set A is locally ﬁnite if, for any s ∈ S, As is a finite set, and we say that A is a globally ﬁnite if A is locally finite and As = ∅ except for a finite number of sorts. Observe that if S is finite, then local implies global finiteness.
Definition 1.1 [Multi-sorted binary relation] Let A = (As)s∈S be a S-sorted set. A binary S-relation R ⊆ A × A consists of a S-family of relations Rs ⊆ As × As.
Given an element a ∈ As and an equivalence relation R, we define the equivalence class of a modulo R as the set a/Rs = {b ∈ As|aRsb}. The quociente A by R is the S-sorted set A/R = (A/R)s∈S such that (A/R)s =
{a/Rs|a ∈ As}.
Definition 1.2 [Signature] A signature Σ is a pair (S, Ω), where:
S is a set (of sorts names);
Ω is a (S∗ × S)-sorted set (of operation names); where S∗ is the set of the finite sequences of S elements.
Example 1.3 [21] Consider a cell of a computer memory where we may write and read values. This software system may be specified using the signature ΣCELL = (S, Ω) with S = {elt, cell}, where elt represents a sort of the val- ues to write and cell the sort of the cell representation, and Ω = {put, get}, where put and get are used to represent write and read functions of a value in a cell:
[GEN]
elt; cell;
[OP]
put: elt,cell -> cell; get:cell -> elt;

Definition 1.4 [Σ-algebra] Let Σ = (S, Ω) be a signature. A Σ-algebra A
consists of
an S-sorted set A = (As)s∈S, where for all s ∈ S, As denotes the carrier set of s.
for any f ∈ Ωs ...s ,s, a function f A : As × ··· × As  → As;
Example 1.5 [21] Consider an S-sorted set B such that Belt = N, Bcell =
N∗ and the functions:
getB(ϵ)= 0;
getB(nω)= n;
putB(m, ω)= mω,
where ϵ represents the empty list and ω ∈ N∗ a list of natural numbers. We have that B is a ΣCELL-algebra.
Definition 1.6 [Congruence relation] Let Σ = (S, Ω) be a signature and A be a Σ-algebra. A Σ-congruence in A is an S-family of symmetric, transitive and reflexive non empty relations ≈A= (≈A)s∈S, such that, for any function f ∈
Ωs ...s ,s and for all ai, bi ∈ As ,1 ≤ i ≤ n if ai ≈A bi, then f A(a1,... , an) ≈A
1	n	i	si	s
f A(b1,... , bn).
Definition 1.7 [Quociente Σ-algebra] Let A be a Σ-algebra and ≈A a Σ- congruence in A. The quociente of A by ≈A is the Σ-algebra A/ ≈A defined as follows:
(A/ ≈A)s = As/ ≈A, for all s ∈ S;
for any f : s1,..., sn → s ∈ Σ, and for all a1 ∈ As /  ≈A ,... , an ∈
1	s1
A / ≈A , f A/≈A (a / ≈A ,... ,a / ≈A )= f (a ,... ,a )/ ≈A.

sn	sn
1	s1
n	sn
1	n	s

Given a signature Σ = (S, Ω), we assume that there is an associate S- family V = Vs∈S of pairwise disjoint infinite sets. An element of Vs is called variable of sort s, and a S-family X ⊆ V is called a set of variables for Σ. It is required that the elements of V and the elements of Ω have different denotations.
Definition 1.8 [TΣ(X)] Let Σ be a signature and X a set of variables for Σ. For each s ∈ S, we define (TΣ(X))s, the set of Σ-terms of sort s, as the smaller set TΣ(X) such that:
For any s ∈ S and x ∈ Xs we have x ∈ (TΣ(X))s
If there is a f :→ s, then f ∈ (TΣ(X))s;
For any f : s1,... , sn → s ∈ Σ, and for all term ti ∈ TΣ(X)si, 1 ≤ i ≤ n, we have f (t1,... , tn) ∈ TΣ(X)s;

It is well know that TΣ(X) is a Σ-algebra with the operations defined in the usual way [24].
Definition 1.9 [Valuations and interpretations] Let Σ = (S, Ω) be a sig- nature, X be a set of variables for Σ and A be a Σ-algebra. A valuation α : X → A is a S-family of mappings (αs : Xs → As)s∈S. Any valuation α uniquely extends to a Σ-homomorphism Iα : TΣ(X) → A as follows:
Iαs (x) =def αs(x),x ∈ Xs;
for any f : s1,..., sn → s ∈ Σ, for all ti ∈ TΣ(X)si , Iαs (f (t1,... , tn)) =def

f A(Iα
(t1),... , Iαsn
(tn)).

The mapping Iα is called the interpretation induced by α.
An endomorphism σ : X → TΣ(X) is called a substitution. A Σ-equation is a triple (X, t, t') where X is a set of variables for Σ, and t, t' ∈ TΣ(X)s for some s ∈ S. Usually, we represent a Σ-equation (X, t, t') by (∀X).t ≈ t'. A

Σ-conditional equation has the form (∀X).t1 ≈ t'
∧ ··· ∧ tn ≈ t'
→ t ≈ t',

where t, t', ti, t' ∈ TΣ(X), 1 ≤ i ≤ n. Observe that any Σ-equation may be
seen as a Σ-conditional equation without premisses. We denote the set of the
Σ-equations by Eq(Σ) and the set of the Σ-conditional equations by CEq(Σ). We define the set of formulas over a signature Σ, in symbols F m(Σ), as the set of the Σ-equations and Σ-conditional equations.
Definition 1.10 [Satisfaction relation] Let Σ be a signature, A be a Σ-
algebra, (∀X).t ≈ t' be a Σ-equation and (∀X).t1 ≈ t' ∧ ··· ∧ tn ≈ t'  →
t ≈ t' be a Σ-conditional equation. The Σ-algebra A satisﬁes the Σ- equation (∀X).t ≈ t', in symbols, A |= (∀X).t ≈ t' if for all valuations α : X → A we have that Iα(t) = Iα(t'). The Σ-algebra A satisﬁes the Σ-

conditional equation (∀X).t1 ≈ t'
∧ ··· ∧ tn ≈ t'
→ t ≈ t', in symbols,

A |= t1 ≈ t'
∧ ··· ∧ tn ≈ t'
→ t ≈ t', if for any α : X → A, Iα(ti) = Iα(t'),

1 ≤ i ≤ n implies Iα(t)= Iα(t').
Given a class of Σ-algebras C, a set of Σ-equations {ti ≈ t'|i ∈ I} and a Σ-equation t ≈ t', we write C |= t ≈ t' when for all A ∈ C, A |= t ≈ t' and we write {ti ≈ t'|i ∈ I} |=A t ≈ t' when for all valuations α : X → A,
{Iα(ti) = Iα(t')|i ∈ I} implies Iα(t) = Iα(t'). When I is finite, we have that
{ti ≈ t'|i ∈ I} |=C t ≈ t' if and only if |=C t1 ≈ t' ∧··· ∧ tn ≈ t' → t ≈ t'. The
i	1	n
relation |=C is ﬁnitary if {ti ≈ t'|i ∈ I} |= t ≈ t' implies {ti ≈ t'|i ∈ J} |= t ≈
i	i
t' for some finite J ⊆ I.
The following proposition states some properties of the relation |=C which are well known for the one-sorted case (cf. [6]):
Proposition 1.11 Let Σ be a signature and C be a class of Σ-algebras. Then,

|=C t ≈ t for any t ≈ t ∈ Eq(Σ);
|=C t ≈ t' → t' ≈ t for any t ≈ t' ∈ Eq(Σ);
|=C t ≈ t' ∧ t' ≈ t'' → t ≈ t'' for all t ≈ t', t' ≈ t'' ∈ Eq(Σ);
|=C t1 ≈ t' ∧ ··· ∧ tn ≈ t'  → f (t1,... , tn) ≈ f (t' ,... , t' ) for every
1	n	1	n
appropriated f ∈ Ω;
Moreover, it can be proved that, if C is the class of Σ-algebras axiomatized by the set of Σ-equations and Σ-conditional equations Φ, then the relation
|=C is finitary (cf.[6] for the one-sorted case). This relation can be seen as the consequence relation over the set of Σ-equations (in sense of [5]) considering by the set of Σ-equations of Φ as the axioms in |=C, and considering the Σ-conditional equations in Φ as the inference rules of |=C.
Proposition 1.12 [6] Let Φ be a set of Σ-equations and Σ-conditional equa- tions, and C be the class of Σ-algebras axiomatized by Φ. We have that Φ |=C
t ≈ t' if and only if, there is a ﬁnite sequence of equations t1 ≈ t' ,..., tn ≈ t'
1	n
such that tn ≈ t' is t ≈ t' and for every i = 1,...,n one of the following
conditions holds:
ti ≈ t' ∈ Φ;
there is a φ ≈ φ' ∈ Φ and a substitution σ such that σ(φ ≈ φ') is ti ≈ t';

there is a conditional equation φ1 ≈ φ'
∧ ··· ∧ φn ≈ φ'
→ φ ≈ φ' ∈ Φ,

and a substitution σ such that ti ≈ t' is σ(φ ≈ φ') and {σ(φi ≈ φ')|i < 
n} ⊆ {tj ≈ t' |j < i}.
Definition 1.13 [Signature morphism] Let Σ = (S, Ω) and Σ' = (S', Ω') be signatures. A signature morphism σ : Σ → Σ', is a pair σ = (σsort, σop), where σsorts : S → S' and σop : Ω → Ω', is a family of functions respecting the sorts of operations names in Ω, that is, σop  = (σω,s  :

Ωω,s → Ω' ∗
sorts
(ω),σsorts(s))ω∈S∗ ,s∈S (where for ω = s1 ... sn ∈ S
∗, σ∗	(ω) =

σsorts(s1) ... σsorts(sn)).
Definition 1.14 [Reduct Algebra] Let A' be a Σ'-algebra, and σ : Σ → Σ' be a signature morphism. The σ-reduct of A' is the Σ-algebra A' Tσ defined as follows:

for any s ∈ S, (A' Tσ)s = A'
for all f : s1,... , sn → s ∈ Σ,
, and


'
f A †σ : A' Tσ

× ··· × A' Tσ
n
→ A' Tσ


'
= σop(f )A

'
σgen (s1 )
× ··· × A'
σgen (sn )

→  '
σgen(s)

Let σ :Σ → Σ' be a signature morphism where Σ = (S, Ω), Σ' = (S', Ω'). Let V and V ' be the families of sets of variables associated with Σ and Σ'

respectively. It is assumed that for any s ∈ S, Vs ⊆ V '
. Hence, if X =

(Xs)s∈S is a set of variables to Σ, then X' is defined to be the following set of

variables to Σ': for any s' ∈ S', X'' = 

σ(s)=s
' Xs (cf. [24,17]). By this way, we
'

define in the natural way an extension of σ from TΣ(X) into TΣ' (X ) (see [24]).
Given a equation t ≈ t', we write σ(t ≈ t') for σ(t) ≈ σ(t'). For each valuation α' : X' → A', the reduct valuation of α is the valuation (α' Tσ) : X → A' Tσ, defined by (α Tσ)s(x : s)= ασ(s)(x : σ(s)) (see [24,16]).
Lemma 1.15 (Satisfaction Lemma [11]) Let Σ, Σ' be signatures, A' be a
Σ'-algebra and φ be a Σ-equation. Then,
A' |= σ(φ) iff A' Tσ|= φ.
Lemma 1.16 [16] Let Σ and Σ' be signatures, σ : Σ → Σ' be a signature morphism, X be a set of variables for Σ and X' a set of variables for Σ' constructed as bellow. For any valuations β : X' → A' e α : X → A' Tσ such that β Tσ= α, we have α(t)= β(σ(t)).

Algebraic speciﬁcation
When we want to specify a software system, we should define an adequate signature, taking account the sorts and functions of the intended system, and we should express the desired functional behaviour of the signature operations, in a given logical system by axioms.
An algebraic speciﬁcation SP is a pair (Σ,Mod(SP )) where Σ is a signa- ture, denoted by Sig(SP ) and Mod(SP ) is a class of Σ-algebras. This class of Σ-algebras is called model class of SP , and a Sig(SP )-algebra of Mod(SP ) by model of SP . When a formula φ is satisfied by all the models of SP , we say
that SP satisfies φ, and we write SP |= φ. The specifications SP and SP ' are semantically equivalents, if Sig(SP )= Sig(SP ') and Mod(SP )= Mod(SP '). When Mod(SP ) is axiomatized by a set Φ of Σ-equations and Σ-conditional equations, we represent the specification SP = (Σ,Mod(SP )) by the pair SP  = ⟨Σ, Φ⟩, where Mod(SP ) = {A ∈ Alg(Σ)|A |= Φ}.  When Φ is a set of equations, the specification SP = ⟨Σ, Φ⟩ is called an equational speciﬁcation.  Given two specifications SP and SP ' we define SP + SP ' as the specification such that Sig(SP + SP ') = Sig(SP ) ∪ Sig(SP ') and Mod(SP + SP ')= Mod(SP ) ∩ Mod(SP ').
Example 1.17 [Adapted from [21]] The following expression specifies the memory cell system of Example 1.3:

Spec Cell = [SORT]
elt; cell;

[OP]

[AX]
put: elt,cell -> cell; get:cell -> elt;

(∀e:elt)(∀c:cell)get(put(e,c)) ≈ e;
It is not difficult to see that the Σcell-algebra defined in Example 1.5 is a model of CELL.
Observational equality
The strict equality relation is often showed as too strong for algebraic spec- ification of software with encapsulated data (Section 1). It is presented, in this section an adaptation of the usual concepts of validity satisfaction, etc., which are more appropriate to the semantic treatment of this kind of systems. As stated, the sorts of a signature are split into observable sorts and non observable sorts. This division is at the base of observational equality. The observable sorts are also known as visible sorts and non observable sorts as hidden sorts.
As suggested in Section 1, in the observational approach, two elements are considered as observational equal if they are indistinguishable when ex- ecuted over the same computational experiments. In our framework, these experiments are formalized by observable contexts:
Definition 1.18 [Contexts and observable contexts] Let Σ = (S, Ω) be a signature, Obs ⊆ S be a set of observable sorts, X be a set of variables for Σ and Z = ({zs})s∈S be a S-sorted set of singular sets. An s-context over Σ is a term c ∈ TΣ(X ∪ {zs})s' , where the variable zs is called contextual variable of
c. When s' ∈ Obs, an s-context is called an observable s-context over Σ (with respect to Obs). CΣ(s) denotes the set of s-contexts over Σ and o CObs denotes
the set of observable contexts over Σ.
Given a context c, a set of non contextual variables of c is denoted by V ar(c), and c[t] denotes the term obtained by replacing zs by a term t ∈ TΣ(X)s.
Definition 1.19 [Contextual equality, Observational equality and Behaviour] Let Σ = (S, Ω)be a signature, Obs ⊆ S be a set of observable sorts, C be an arbitrary set of contexts over Σ and A be a Σ-algebra. Two elements a, b ∈ As

are contextually equal with respect to C, denoted by a ≈A b, if for any context c ∈ C(s), for all valuation α, β : X ∪ {Zs} → A such that α(x)= β(x) for all x ∈ X, and α(zs) = a and β(zs) = b, we have Iα(c) = Iβ(c). The contextual equality in A with respect to the set CObs is called observational equality and

is denoted by ≈A
. The Σ-algebra A/ ≈A
is called the behaviour of A with

respect to ≈Obs.
Given a class C of Σ-algebras, C/ ≈Obs denotes the class of Σ-algebras
{A/ ≈A	|A ∈ C}, and given a specification SP , SP/ ≈Obs denotes the class
Mod(SP )/ ≈Obs.
Definition 1.20 [Observational satisfaction relation] Let Σ be a signature,
Obs  ⊆  S a set of observable sorts, (∀X).t  ≈ t' be a Σ-equation and

(∀X).t0 ≈ t'
∧ ··· ∧ tn ≈ t'
→ t ≈ t' be a Σ-conditional equation.	A

Σ-algebra A observationally satisﬁes the equation (∀X).t ≈ t' with respect

to Obs, in symbols, A |=≈
Obs
(∀X).t ≈ t', if for any valuation α : X → A,

Iα(t) ≈A	Iα(t'). A Σ-algebra A observationally satisﬁes the conditional equa-

tion (∀X).t0 ≈ t'
∧ ··· ∧ tn ≈ t'
→ t ≈ t' with respect to Obs, in symbols,

A |=≈
(∀X).t0 ≈ t' ∧ ··· ∧ tn ≈ t'
→ t ≈ t', if for any valuation α : X → A,

Obs	0	n

Iα(ti) ≈A	Iα(t'), 1 ≤ i ≤ n, implies Iα(t) ≈A
Iα(t').

Obs	i	Obs
Remark 1.21 The previous adaptation (generalization) of the satisfaction relation, is made by replacing the strict equality by the observational equality. However, there are some other works in the literature where this generalization is made at a more abstract level, obtained by replacing the strict equality by an arbitrary parcial congruence relation, called such a context by behavioural equality (cf. [15,1]). Observe that this approach includes the one presented here, since the observational equality is a congruence relation (cf. [15, Fact 3.1.8]).
Example 1.22 Let CELL1 the following specification:
Spec CELL1= enrich CELL by [AX]
(∀e,e’:elt)(∀c:cell).put(e,put(e’,c))) ≈ put(e,c);
We have that the ΣCELL-algebra B (example 1.5) that is not a strict model of CELL1, since, given a ω ∈ N∗ and e,e’ ∈ N we have that
putB(e,putB(e’, ω)) ≈ ee’ω
and eω ≈ putB(e,ω). However, it is not difficult to see that B |=≈Obs put(e,put(e’,x)) ≈ put(e’,x), and hence, we have that B is an observable model of CELL not being in the strict sense.

Theorem 1.23 [1] Let Σ be a signature and Obs ⊆ S a set of observable sorts, A be a Σ-algebra and C a class of Σ-algebras. Then:

A |=≈

Obs
φ iff A/ ≈A
|= φ;

C |=≈Obs φ iff C/ ≈Obs|= φ;
where C / ≈= {A/ ≈A	|A ∈ C}.
The observational behaviour operator
Definition 1.24 [Observational behaviour class] Let Σ = (S, Ω) be a signa- ture, Obs ⊆ S be a set of observable sorts and C be a class of Σ-algebras. The observational behaviour class of C with respect to Obs is the class


Beh≈

Obs
(C) =def {A ∈ Alg(Σ)|A/ ≈A
∈ C}.

This definition give rise the definition of an important specifications oper- ator: the operator behaviour.wrt.. Let BehEq be the class of observational equalities:
Sintax:

Semantics:
behaviour.wrt. : Spec, BehEq → Spec

Sig(behaviour SP wrt ≈obs) =def Sig(SP )

Mod(behaviour SP wrt ≈Obs ) =def Beh≈Obs (Mod(SP ))
Hence, the model class of Mod(behaviour SP wrt ≈ ) is the class of all the Σ-algebras which observable behaviours belongs to Mod(SP ), i.e., the op- erator behaviour SP wrt ≈ specifies the class of Σ-algebras of the “desired observational behaviours”, that is, the “observational correct realizations” of SP .
Theorem 1.25 Let SP = ⟨Σ, Φ⟩ be a speciﬁcation and Obs a set of observable sorts to Σ. Then:
Mod(behaviour SP wrt ≈obs )= {A ∈ Alg(Σ)|A |=≈	Φ}.
Proof. By definition of behaviour, we have that for any Σ-algebra A, A ∈
Mod(behaviour SP wrt ≈ ) if and only if A/ ≈A ∈ Mod(SP ). Since SP =

⟨Σ, Φ⟩, we have that A/ ≈A
∈ Mod(SP ) if and only if A/ ≈A
|= Φ, and

therefore, by Theorem 1.23 A |=≈

Obs
Φ.	 

A specification SP is observationally closed with respect to Obs when
Mod(SP ) ⊆ Mod(behaviour SP wrt ≈Obs). Given a signature Σ = (S, Ω)

and a set of observable sorts Obs ⊆ S, the specification SP = ⟨Σ, Φ⟩ is ob-
servationally closed with respect to Obs if for any t1 : s1 ≈ t' : s1 ∧ ··· ∧ tn :
sn ≈ t' : sn → t : s ≈ t' : s ∈ Φ, si ∈ Obs for all 1 ≤ i ≤ n. In particular, an
equational specification is observationally closed with respect to any Obs ⊆ S
(cf. [15]).

The Observational Stepwise Refinement Methodol- ogy
Strict reﬁnements
Given a specification SP of a software system, the implementation process consists in constructing a correct realization (a program) of SP , i.e., of con- structing an algebra P such that P ∈ Mod(SP ), or at least a class of Sig(SP )- algebras SP ' such that Mod(SP ') ⊆ Mod(SP ), small enough for the desired work. Hence, in this process, we enrich SP with implementation decisions, in order to obtain a complete description of the intended program (desired algebra).
The stepwise reﬁnement process (see [24,23,17]) is the systematic process by which, from an initial specification SP0 are successively built more restric- tive specifications by introducing of new requisites:
SP0 ~ SP1 ~ SP2 ~ ··· ~ SPn−1 ~ SPn,
where for all 1 ≤ i ≤ n, SPi−1 ~ SPi is a refinement.
Note that if SP ~ SP ' and SP ' ~ SP '' then SP ~ SP '', since Sig(SP )= Sig(SP ')= Sig(SP '') and Mod(SP '') ⊆ Mod(SP ') ⊆ Mod(SP ). This transitivity, named vertical composition, assure that SP0 ~ SPn.
Example 2.1 Consider the specifications CELL and CELL1 of Examples 1.17 and 1.22. We have CELL ~ CELL1.
As it was mentioned, during the refinement process, the specification to refine is enriched with new requirements, being natural the need to modify the signature of the initial specification, by the introduction of new sorts and functions, renaming, etc.. This can be done by a signature morphism. Based on Satisfaction Lemma (Lemma 1.15), we have the following generalization of refinement concept:
Definition 2.2 [σ-Refinement] Let σ be a signature morphism. The specifi- cation SP ' is a σ-refinement of SP , in symbols SP ~σ SP ', if:
Sig(SP ')= σ(Sig(SP )) and

Mod( SP ') Tσ ⊆Mod( SP),
where Mod( SP ') Tσ={A Tσ |A ∈ Mod( SP ')}.
Note that when we consider the identity morphism id, the concept of id- refinement coincide with the refinement concept. Since the composition of two signature morphisms is a signature morphism, we have directly by the Satisfaction Lemma (Lemma 1.15), that the vertical composition of this kind of refinements holds. Hence, if SP0 ~σ1 SP1 and SP1 ~σ2 SP2 we have SP0 ~σ2 ◦σ1 SP2, and for the case of stepwise refinement with n steps, we have SP0 ~σn◦···◦σ1 SPn.
Example 2.3 Suppose that we need to implement a CELL1 system to use with natural numbers. Firstly, we may translate the CELL1 specification in this new signature (by the morphism σ):
σ :	Sig(CELL1)	→	Sig(CELLNAT)
elt	→	nat
cell	→	cell
get	→	get
put	→	put
→	s
→	zero
and then, introduce the axiomatic of the natural numbers set in this new specification. Now, we have that

CELL1 ~σ CELLNAT
It follows an important characterization of the σ-refinement concept:
Theorem 2.4 Let SP = ⟨Σ, Φ⟩ and SP ' = ⟨Σ', Φ'⟩ speciﬁcations and σ : Σ → Σ' a signature morphism. Then, SP ~σ SP ' iff SP ' |= σ(Φ).
Proof. Suppose that SP ~σ SP '. Then, for any A' ∈ Mod(SP '), A' Tσ∈ Mod(SP ), i.e., A' Tσ|= Φ. Hence, by Lemma 1.15, A' |= σ(Φ). On the other hand, we have that SP ' |= σ(Φ), and therefore, for any A' ∈ Mod(SP '), A' |= σ(Φ). By Lemma 1.15 A' Tσ|= Φ, and hence, A' Tσ∈ Mod(SP ). Therefore SP ~σ SP '.	 

Observational reﬁnements
The relevance of the adjustment of the concepts of refinement and σ-refinement to the observational approach, is evident, since according to this view, the preservation of requirements to refinement, is no longer strict, but just obser- vational. Hence, a refinement is observationally correct when their observa- tional behaviour preserves the requirements of the refined specification:
Definition 2.5 [Observational Refinement] Let SP and SP ' be two speci- fications, Obs a set of observable sorts of Sig(SP ) and σ a signature mor- phism. SP ' is an observational σ-reﬁnement with respect to Obs, in symbols SP ~≈Obs SP ', if
behaviour SP wrt  ≈Obs~σ SP ',
that is, if:
Sig(SP ')= σ(Sig(behaviour SP wrt ≈Obs)) and
Mod( SP ') Tσ ⊆Mod( behaviour SP wrt ≈Obs).
The adaptation of the stepwise refinement process to the observational case requires some attention, since different observational equalities can be consid- ered in different refinement steps. The main question is how to control the conservation of the vertical composition during the process. Some important steps in this study are already given as, for example, the characterization of sufficient conditions for this conservation.
Given an algebra A and two congruences θA, θ'A in A, we write θA ≤ θ'A if for any s ∈ S, (θA)s ⊆ (θ'A)s. The relevance of this relation between congruences when we work with observational refinements is quite intuitive. For example, given the observational equalities ≈Obs and ≈Obs' , such that
≈Obs≤≈Obs' , if SP ~≈Obs SP ' then SP ~≈Obs' SP ', since the second relation distinguishes fewer elements than the first one. The following theorem, charac-
terizes the sufficient conditions, to the preservation of the vertical composition in the observational refinements:
Theorem 2.6 [15] Let SP, SP ' and SP '' be speciﬁcations with Sig(SP ') = σ(Sig(SP )) and Sig(SP '')= τ (Sig(SP ')) and Obs, Obs' be sets of observable sorts to Sig(SP ) and Sig(SP ') such that, for any Sig(SP ')-algebra A', (≈'A'
) T ≤≈(A'†σ ). If SP ~≈Obs SP ' and SP ' ~≈Obs' SP '', then SP ~≈Obs SP ''.

σ	Obs	σ	φ
φ◦σ

This result is presented in [15] at the context of the behavioural equalities
(see Remark 1.21).
We study in this paper the observational case of stepwise refinement pro- cess, with special attention to the case where it is possible to vary the set of

observable sorts between process steps. The characterization of the observa- tional stepwise refinement process present in literature, supposes the “preser- vation of observability” of the specifications between refinement steps, in the sense that, given two specifications SP , SP ' with Obs ⊆ S and Obs' ⊆ S'
sets of observable sorts to Sig(SP ) and Sig(SP ') such that SP ~≈Obs SP '
then, for any s ∈ Obs we have σ(s) ∈ Obs' and for any s ∈ S \ Obs we have σ(s) ∈ S' \ Obs', or at least σ(Obs) ⊆ Obs' (see [17]). However, changing observable sorts into non observable and vice-versa, can be useful in several situations. For example, according to the object oriented paradigm, only in- put/output data must be desencapsulated, and by security reasons (data and code) can be necessary encapsulate some types of data in a determined phase of the implementation process. On the other hand, desencapsulate data dur-
ing the refinement process, can be advantageous in the verification tasks (for example, if it is possible to desencapsulate all the sorts, we may interpret the observational equality relation by the strict equality relation).
Let Σ = (S, Ω) a signature and Obs ⊆ S and Obs' ⊆ S sets of observable sorts such that Obs ⊆ Obs . Observe that the relation ≈Obs' is more restrictive

than the relation ≈	since CObs ⊆ CObs'
and hence, in the definition of the

Obs	Σ	Σ
first relation we considere less contexts than the seconde one. By Definition
1.20, all the models of an equational specification SP by the relation |=≈Obs'
also they are by relation |=≈Obs , i.e.,
Mod(behaviour SP wrt ≈Obs' ) ⊆ Mod(behaviour SP wrt ≈Obs).

The progressive sort desencapsulation Obs1 ⊆ ··· ⊆ Obsn, induce a relations chain ≈Obs1 ≥≈Obs2 ≥ ··· ≥≈Obsn  where for any i, j ≤ n such that i ≤ j, if a ≈Obsj b then a ≈Obsi b. It is understood of this form that the data desencapsulation “preserve” the formation of contexts, arriving thus at a first characterization of the vertical composition of the observational refinement
steps with data desencapsulation: by Theorem 2.6, if we have SP ~≈	SP '

and SP ~≈
' SP ' with Obs ⊆ Obs', then SP ~≈
SP ''.  Now, we will

analise this preservation to the general case of the σ-refinements. The next
definition characterizes a class of morphisms that assure this preservation:
Definition 2.7 [Observational morphism] Let Σ = (S, Ω) and Σ' = (S', Ω') be signatures, Obs ⊆ S and Obs' ⊆ S' be sets of observable sorts for Σ and Σ', and σ : Σ → Σ' be a signature morphism. The morphism σ is said to be an Obs − Obs'−observational morphism if for all s ∈ S, s ∈ Obs implies σ(s) ∈ Obs'.
Theorem 2.8 Let σ :Σ → Σ' be an Obs − Obs'-observational morphism and

A' be a Σ'-algebra. Then,




A'
Obs'

) Tσ



(A'†σ )
Obs



Proof.
Let a, b ∈ A' Tσ

such that a(≈A'
)Tσ

b.	Since a(≈A'
)b, we have that

for any c' ∈ CObs' , for any valuations α' , α'
: X' ∪ {Z
} → A', such that

Σ'	1	2
σ(s)

α' (x')= α' (x') for all x' ∈ X' and α' (zσ(s))= a and α' (zσ(s))= b,
1	2	1	2
'	'
(1)	Iα' (c )= Iα' (c ).
1	2
Since σ is an Obs − Obs'-observational morphism, we have that all the con-
texts of CObs are mapped by σ into contexts of CObs' , and hence, all the con-

Σ
texts considered in ≈A'†σ , also they are in ≈A'
Σ'
(by reduct algebra defini-

Obs	Obs'
tion cA'†σ  = σ(c)A' ).	By 1, we have in particular that for any c ∈ CObs,
Iα' (c) = Iα' (c).Consider now the reduct valuations α' Tσ: X → A' Tσ and
1	2	1
α' Tσ: X → A' Tσ. By Lemma 1.16 we have that
2
α' Tσ (xs)= α' (σ(xs)) = α' (xσ(s)),
1	1	1
α' Tσ (xs)= α' (σ(xs)) = α' (xσ(s)),
2	2	2
α' Tσ (zs)= α' (σ(zs)) = α' (zσ(s))

and
1	1	1

α' Tσ (zs)= α' (σ(zs)) = α' (zσ(s)).
2	2	2
We have also that α' (zσ(s))= a and α' (zσ(s))= b, and therefore, by unicity of
1	2
I, we have that for all c ∈ CObs, Iα' † (c) = Iα' (c) and Iα' † (c) = Iα' (c), i.e.,

Σ	1 σ	1
2 σ	2

for all valuations α' , α' : X' → A', for any context c ∈ CObs,
1	2	Σ
(2)	I(α' †σ )(c)= I(α' †σ )(c).
1	2
On the other hand, for any valuation α : X → A' Tσ, there is an valuation

α' : X' → A' such that α = α' Tσ (all valuations αs = α'
), and therefore, we

have by 2 that for all valuations α1, α2 : X' → A' Tσ, such that α1(x')= α2(x'), if x' ∈ X', α1(zσ(s)) = a, α2(zσ(s)) = b, then, for any c ∈ CObs, we have

Iα1
(c) = Iα2
(c), i.e., a(≈A'†σ )b.	 

Thus, we arrive at the following characterization of vertical composition of observational refinements:
Corollary 2.9 Let SP, SP ' and SP '' be three speciﬁcations, σ be an Obs −
Obs'-observable morphism and φ be an Obs' − Obs''-observable morphism. If
SP ~≈Obs SP ' and SP ' ~≈Obs' SP '', then SP ~≈Obs SP ''.
σ	φ	φ◦σ
Proof. Immediate by Theorems 2.6 and 2.8.	 

The introduction of the concepts presented here was made in such a way as to finding sufficiency conditions for the preservation of the vertical composition property between refinement steps. However, this composition is only assured when processed via the observational equality relation considered in the first refinement step, and that be such that ≈Obs1 ≥ ··· ≥≈Obsn  (i.e., such that
Obs1 ⊆ ··· ⊆ Obsn). Hence, in the refinement process
SP ~≈Obs1 SP  ~≈Obs2 ··· ~Obsn SP ,

0	σ1
1	σ2
σn	n



such that ≈Obs1
≥ ··· ≥≈Obsn
, we have that SP0
≈Obs1
σn◦···◦σ1
SPn.

The study of other characterizations of vertical composition can be in-
teresting as, for example, according to the presented characterization, all desencapsulated sorts during the refinement steps become encapsulated at the end of the process. By the reasons mentioned above, the possibility of vertically composed observational refinements, according to the relation with more observable sorts appears often as a desirable situation. This is the characterization that we want to do next. Observe that for any equa- tional specification SP = ⟨Σ, Φ⟩, and for any s ∈ Obs, the relation ≈Obs is
more restrictive than the relation ≈Obs\{s}, i.e., ≈Obs≤≈Obs\{s}. Hence, since
A |=≈Obs Φ ⇒ A |=≈Obs\{s} Φ, we have that
Mod(behaviour SP wrt ≈Obs) ⊆ Mod(behaviour SP wrt ≈Obs\{s}).
However, it is obvious that the reciprocal does not holds.  To guaran- tee some kind of reciprocal we have to impose some conditions about Φ. For example, if Φs  = ∅ for some s ∈ S and ΦS\Obs  = ∅, we have A |=≈Obs  Φ ⇔ A |=≈Obs\{s}  Φ, and hence Mod(behaviour SP wrt  ≈Obs
) = Mod(behaviour SP wrt  ≈Obs\{s}). In these conditions, if we have

two observational refinements SP ~≈Obs\{s}
SP ' and SP ' ~≈Obs
SP '' with

SP = ⟨Σ, Φ⟩, we can compose them obtaining the observational refinement
SP ~≈Obs SP ''.
Consider now the following result:
Lemma 2.10 Let Σ = (S, Ω) be a signature, Obs a set of observable sorts for Σ and Φ be a set of Σ-equations. Then, for any Σ-algebra A and for any s ∈ Obs,


where
A |=≈	Φ iff (A |= Φ' and A |=≈	Φ)

Φ' = Φv ∪ {c(t)= c(t') | t ≈ t' ∈ Φh,h ∈ S \ (Obs ∪ {v}),c ∈ C{v}(h)}.

Proof. Suppose that A |=≈Obs∪{v} Φ. Since A |=≈Obs∪{v} ΦObs∪{v} implies A |= ΦObs∪{v} we have that

(3)
(4)


From (4) A |=≈
A |=≈Obs ΦObs
A |= Φv.
Φv. Since for any h ∈ S \ (Obs ∪ {v}) CObs(h) ⊆ CObs∪v

Obs	Σ	Σ
we have that A |=≈Obs Φh for all h ∈ S \ (Obs ∪ {v}). Therefore, A |=≈Obs Φ.
Let now t ≈ t' ∈ Φh, h ∈ S \ (Obs ∪ {v}). Then, by hypothesis A |= c(t) ≈

c(t') for any c ∈ CObs∪v
(since Cv
⊆ CObs∪{v}). From this together with (4) , 

A |=≈
Obs
Φ'.

Now, suppose that A |=≈Obs∪{v} Φ and A |= Φ'. Let t ≈ t ∈ Φs. We split the proof in three cases: (i) s ∈ Obs, (ii) s = v and (iii) s ∈ S\Obs∪{v}. In the

first case it is obvious, since A |=≈
Obs
t ≈ t' implies that A |= t ≈ t' and hence

A |=≈
Obs∪{v}
t ≈ t'. In case (ii), A |=≈
Obs∪{v}
t ≈ t' since by hypothesis A |= t ≈

t'. In the latter case we have just to see that CObs∪{v}(s)= CObs(s) ∪ C{v}(s).
Σ	Σ	Σ
In fact, from A |= Φ' we have A |= c(t) ≈ c(t') for any c ∈ C{v}(s), and

A |= c(t) ≈ c(t') for any c ∈ CObs(s) because A |=≈
Obs
t ≈ t'. Therefore

A |=≈
Obs∪{v}
t ≈ t'.	 

Given an equational specification SP = ⟨Σ, Φ⟩ we define the specifications SPv as the equational specification ⟨Σ, Φ'⟩ with Φ' defined as in Lemma 2.10. From the previous Lemma we have
Mod(behaviour SP wrt ≈Obs∪{v})= Mod(behaviour SP wrt ≈Obs +SPv)
By the following Theorem, from an observational refinement with respect to ≈Obs of an equational specification SP , we can build an observational re- finement with respect to ≈Obs∪s of the same SP . This result can be worth in the reuse perspective: suppose that we have an observational refinement of SP with respect to a relation ≈Obs and, by some reason, we need to output the data of sort v which at this moment it is not an observable sort. On the other hand, the result may be useful when, during the specification process, we have not decided yet if a sort whether or not it is an encapsulated sort. This idea is stated in the following Theorem:
Theorem 2.11 Let Φ be a set of Σ-equations and SP = ⟨Σ, Φ⟩ and SP ' be two speciﬁcations such that SP ~≈Obs SP '. Then
SP ~≈Obs∪{s} SP ' + SPs.
Proof.  By	assumption	we	have	that	Mod(SP )	⊆
Mod(behaviour SP  wrt	≈Obs) and hence Mod(SP ) ∩ Mod(SPs)	⊆

Mod(behaviour SP wrt  ≈Obs) ∩ Mod(SPs).   By Theorem 2.10 we have that Mod(behaviour SP wrt ≈Obs) ∩ Mod(SPs) = Mod(behaviour SP wrt ≈Obs∪{s}) and therefore SP ~≈Obs∪{s} SP '+SPs. 
Remark 2.12 Note that the definition of Φ' does not depend of the observ- able equations of Φ. Hence, we may extend this result to another sets of formulas. For example, this result holds for all the specifications SP = ⟨Σ, Φ⟩ where Φ is a set of Σ-equations and observable Σ-conditional equations with observable premisses.
Example 2.13 Consider the specification CELL1 of Example 1.22 and the following specification:
Spec CELLcell= [GEN]
elt;
cell;

[OP]

[Ax]
put: elt,cell -> cell; get:cell -> elt;

(∀e,e’:elt)(∀c:cell).put(e,put(e’,c))) ≈ put(e,c);
Now, for any refinement CELL1 ~≈{elt} SP , we have that CELL1 ~≈{elt,cell}
SP + CEll1cell.
Example 2.14 [NatCell] Consider the specification CELLNAT from Example
with NAT axiomatized by (∀x:nat).s(p(x)) ≈ x. Consider too the fol- lowing specification:
Spec CELLNATBOOL = enrich CELLNAT by BOOL
Spec CELLNATEQ = enrich CELLNATBOOL by [OP]
eq:nat,nat ->bool;
[AX]
(∀x:nat).eq(x,x) ≈ true;
(∀x,y:nat).eq(x,y) ≈ true ⇒  eq(y,x) ≈ true;
(∀x,y,z:nat).eq(x,y) ≈ true ∧	eq(y,z) ≈ true  ⇒	eq(x,z)  ≈
true;
(∀x:nat).eq(s(p(x)),x) ≈ true;
where BOOL represents the classical specification of the boolean algebras. Sup- pose that we have an observational refinement CELLNATEQ ~≈{bool}  SP and

we need an observational refinement of CELLNATEQ with respect to ≈{bool,nat}. Then, we define the specification CELLNATEQnat with the set of axioms
(∀x:nat).s(p(x)) ≈ x; (∀e,e’:nat)(∀c:cell).get(put(e,put(e’,c))) ≈ get(put(e,c));
(∀e,e’,e’’:nat)(∀c:cell).get(put(e’’,put(e,put(e’’,c))))
≈ get(put(e’’,put(e,c)));
.
and we build the desirable refinement by SP + CELLNATEQnat (cf. Remark 2.12).
Observe that this technic sometimes has to be followed with some comple- mentary methods, since that in the general case, the set C{c}(h) is infinite and consequently SPs is infinitary (such as in Example above). However, in most
of the cases it is possible to consider only a finite set of contexts CΣ ⊆ C{s}
instead of the set C{s}, inducing this way the formation of finite specifications
SPs (cf. [1,12,19]).

Refinements via translation
In this Section, we look over the refinement process in a new perspective greatly influenced by abstract algebraic logic. We believe that the study of this formalization may be important, for example, from the point of view of software reuse. This approach is based on the notion of logical translation, which is a central concept considered in the abstract algebraic theory of de- ductive systems (see [5,4,6]). Since the presentation of this topic requires a strong notation, we formalize the reﬁnement via translation concept exclu- sively in the non observable case, i.e., in the case where Obs = S. The concept generalization to the observable case can be done in the natural way.
In the sequel we formalize the notion of logical translation for the sorted case. Intuitively, a translation is a mapping from the set of equations into their power set: given the signatures Σ = (S, Ω) and Σ' = (S', Ω') such that Σ ⊆ Σ', a Σ − Σ'-translation τ is a family indexed by S (τs(x : s, y : s))s∈S where for each s ∈ S, τs(x : s, y : s) = (τs,s' (x : s, y : x))s'∈S' is a globally finite S'-sorted set of Σ'-equations φ(x, y) ≈ ψ(x, y) of sort s' in two variables of sort s. Given a Σ − Σ'-translation τ , we define the τ -translation of a Σ-equation t ≈ t' of sort s, denoted by τ (t ≈ t'), as the S'-sorted set of Σ -equations (τs,s' (t, t ))s'∈S' , and a τ -translation of a conditional equation

t1 : s1 ≈ t'
: s'
∧ ··· ∧ tn : sn ≈ t'
: s'
→ t : s ≈ t' : s as the S'-

sorted set of conditional Σ'-equations defined for each s' ∈ S' and for each
φ(t, t ) ≈ ψ(t, t ) ∈ τs,s'(t : s ≈ t : s) as follows:
  (   τs ,s(ti : si ≈ t' : si)) → φ(t, t') ≈ ψ(t, t').
i	i
i≤n s∈S'
In the sequel, we identify a S-sorted set (τs(t : s, t' : s'))s∈S with the disjoint union  s∈S τs(t : s, t' : s).
Observe that a formula φ is translated by a signature morphism σ in an-
other formula σ(φ); however, a logical translation maps a formula into a set of formulas. An useful tool in the sequel is given by the following Lemma:
Lemma 3.1 Let σ : F m(Σ) → F m(Σ) be a substitution, τ be a Σ − Σ'- translation and ξ be a Σ-equation. We have that τ (σ(ξ)) = σ(τ (ξ)).
Proof. Given a Σ-equation t ≈ t' of sort s and a Σ−Σ'-translation τ , we have that for any s' ∈ S', τs,s' (t ≈ t') is defined as a set of equations φ(t, t') ≈ ψ(t, t') of sort s'. Hence, for any substitution σ : F m(Σ) → F m(Σ), σ(φ(t, t') ≈ ψ(t, t')) = σ(φ(t, t')) ≈ σ(ψ(t, t')) = φ(σ(t), σ(t')) ≈ ψ(σ(t), σ(t')). On the other hand, we have that σ(t ≈ t')= σ(t) ≈ σ(t'), and therefore, for any s' ∈ S', τs,s' (σ(t ≈ t')) is defined as a set of equations φ(σ(t), σ(t')) ≈ ψ(σ(t), σ(t')) of sort s'. Therefore, for any equation ξ, τ (σ(ξ)) = σ(τ ((ξ)). The case of the Σ-conditional equations follows directly to the previous case.	 
Definition 3.2 [Interpretation] Let SP be a specification and τ be a Sig(SP ) − Σ'-translation. We say that τ interprets SP if there is a speci- fication SP ' with signature Σ' such that, for any ξ ∈ F m(Σ), SP |= ξ if and only if SP ' |= τ (ξ). In this case we say that the SP ' is a τ-interpretation of SP .
Definition 3.3 [τ -model] Let SP be a specification, Σ' be a signature and τ be a Sig(SP ) − Σ'-translation. A Σ'-algebra A' is a τ -model of SP if for any ξ ∈ F m(Σ), SP |= ξ implies A' |= τ (ξ). We define the τ-model class of SP , denoted by Modτ (SP ), as the class of all τ -models of SP .
Given a specification SP and a Sig(SP ) − Σ'-translation τ , we define SPτ
as the specification such that Sig(SPτ )= Σ' and Mod(SPτ )= Modτ (SP ).
Theorem 3.4 Let SP be a speciﬁcation and τ be a Sig(SP ) −Σ'-translation. If τ interprets SP, then the speciﬁcation SPτ is the τ-interpretation of SP with the largest class of models.
Proof. Since τ interprets SP then, there is a specification SP ' such that for any ξ ∈ F m(Sig(SP )), SP |= ξ if and only if SP ' |= τ (ξ). on the one hand, we

have that SP |= ξ implies that SPτ |= τ (ξ), since by definition, Mod(SPτ )= 
{A|A is a τ -model of SP }. On the other hand, if SPτ |= τ (ξ) then SP ' |= τ (ξ) (since Mod(SP ') ⊆ Mod(SP ')) and hence SP |= ξ. Therefore, SPτ is a τ - interpretation of SP . Obviously, it is the largest one, since they include all the τ -models of SP .
 
Theorem 3.5 Let SP = ⟨Σ, Φ⟩ be a speciﬁcation and τ be a Σ − Σ'- translation. Then, if τ interprets SP, we have that the speciﬁcation SPτ is axiomatized by the set of axioms τ (Φ), i.e, SPτ = ⟨Σ',τ (Φ)⟩. Moreover, if Φ is ﬁnite then SPτ is ﬁnitely axiomatized.
Proof. On the one hand, we have that for any A' ∈ Mod(SPτ ) and for any Σ-formula ξ , SP |= ξ implies SPτ |= τ (ξ). In particular, since SP |= Φ, we have that SPτ |= τ (Φ) and hence, Mod(SPτ ) ⊆ Mod(⟨Σ',τ (Φ)⟩).
On the other hand, consider a Σ-algebra A' ∈ ⟨Σ',τ (Φ)⟩, i.e., such that
A' |= τ (Φ), and a equation ξ such that SP |= ξ, i.e., Φ |=SP ξ. Then, there is

a finite sequence of equations t1 ≈ t' ,..., tn ≈ t' , such that tn ≈ t'
is ξ and

1	n	n

that, for all i = 1,... , n, ti ≈ t'
satisfies one of the three conditions of the

Proposition 1.12. If ξ ∈ Φ, then, τ (ξ) ∈ τ (Φ) and therefore τ (Φ) |=A' τ (ξ) (by
(i) of Proposition 1.12)). If ξ is σ(φ ≈ φ') for some substitution σ and some φ ≈ φ' ∈ Φ, we have that τ (φ ≈ φ') ∈ τ (Φ), by Lemma 3.1, we have that τ (ξ) is σ(τ (φ ≈ φ )) and therefore τ (Φ) |=A' τ (ξ) (by (ii) of Proposition 1.12)). Consider now the case where there is a conditional equation φ1 ≈ φ' ∧·· ·∧φn ≈
' → φ ≈ φ' ∈ Φ, and a substitution σ such that t ≈ t' is σ(φ ≈ φ') and
{σ(φi ≈ φ')|i < n} ⊆ {tj ≈ t' |j < i}. Hence, we have that {τ (σ(φi ≈ φ'))|i < 
i	j	i
n} ⊆ {τ (tj ≈ t' )|j < i}, and by Lemma 3.1, {σ(τ (φi ≈ φ'))|i < n} ⊆ {τ (tj ≈
j	i
t' )|j < i}. We have too that τ (φ1 ≈ φ' ∧ ··· ∧ φn ≈ φ' → φ ≈ φ') ⊆ τ (Φ),
j	1	n
'	'	'	'

i.e., for any ψ(φ : s, φ : s) ≈ ψ (φ : s, φ : s) ∈ τs,s' (φ : s ≈ φ
: s),

(  (   τs ,s(φi : si ≈ φ' : si)) → ψ(φ : s, φ' : s) ≈ ψ'(φ : s, φ' : s))s'∈S' ⊆ τ (Φ).

i
i≤n s∈S'
Let	( 
i


' τs ,s(φi : si ≈ φ'

: si)) → ψ(φ : s, φ' : s) ≈ ψ'(φ : s, φ' : s) ∈

τ (Φ) be one of these conditional equations. Since, by hypotheses t ≈ t' is σ(φ ≈ φ') we have that τ (t ≈ t') is τ (σ(φ ≈ φ')), and therefore, τ (t ≈ t') is σ(τ (φ ≈ φ')). Hence, there is an equation μ(t, t') ≈ μ'(t, t') ∈ τ (t ≈ t')
such that μ(t, t') ≈ μ'(t, t') is σ(ψ(φ : s, φ' : s) ≈ ψ'(φ : s, φ' : s)), and hence,
A' |=	(	' τs ,s(φi : si ≈ φ' : si)) → ψ(φ : s, φ' : s) ≈ ψ'(φ : s, φ' : s)

i≤n
s∈S	i	i
'	'

(by (ii) of Proposition 1.12).	Therefore τ (Φ) |=A'  τ (t ≈ t ).	Since A is
arbitrary, we have that any A' ∈ ⟨Σ',τ (Φ)⟩ is a τ -model of SP and, therefore,
Mod(⟨Σ',τ (Φ)⟩) ⊆ SPτ . Hence ⟨Σ',τ (Φ)⟩ = SPτ .

Since τ maps each φ ∈ Φ in a finite set τ (φ) (by hypotheses, τ is globally finite), we have that, if Φ is finite, then τ (Φ) is finite too, and therefore, under these conditions, SPτ is finitely axiomatized.	 
Definition 3.6 [Refinement via translation] Let SP and SP ' be two speci- fications and τ be a translation such that τ interprets SP . We say that the specification SP ' reﬁnes via the translation τ the speciﬁcation SP , in symbols SP zτ SP ', if SPτ ~ SP '.
Lemma 2.4 motivates the next characterization of the refinements via translation concept in the specifications axiomatized by a set of equations and conditional equations:
Theorem 3.7 Let SP = ⟨Σ, Φ⟩ and τ be a Σ − Σ'-translation. If τ interprets SP, then, for any speciﬁcation SP ' with Sig(SP ')= Σ', we have that SP zτ SP ' iff SP ' |= τ (Φ).
Proof. By Theorem 3.5 we have that SPτ = ⟨Σ',τ (Φ)⟩, and by Lemma 2.4,
SPτ ~ SP ' if and only if SP ' |= τ (Φ).	 
Corollary 3.8 Let SP = ⟨Σ, Φ⟩ be a speciﬁcation and τ be a Σ − Σ'- translation. A Σ'-algebra A' is a τ-model of SP if A' |= τ (Φ).
Example 3.9 Consider the following specification of the natural numbers set:
Spec NAT = [SORT]
nat;

[OP]
[AX]
s:nat ->nat;

(∀x,y:nat).s(x) ≈ s(y) ⇒  x ≈ y;
and consider the following specification NATEQ:
Spec NATEQ =enrich BOOL by [SORT]
nat;
s:nat->nat; eq:nat,nat->bool;

[OP]

[AX]
s:nat ->nat; eq:nat,nat ->bool;

(∀x:nat).eq(x,x) ≈ true;

(∀x,y:nat).eq(x,y) ≈ true ⇒  eq(y,x) ≈ true;
(∀x,y,z:nat).eq(x,y) ≈ true ∧  eq(y,z) ≈ true ⇒	eq(x,z) ≈
true;
(∀x,y:nat).eq(x,y) ≈ true ⇒ eq(s(x),s(y)) ≈ true;
(∀x,y:nat).eq(s(x),s(y)) ≈ true ⇒  eq(x,y) ≈ true;
Consider the translation τ such that
τnat,bool(x:nat ≈ y:nat)= {eq(x:nat,y:nat) ≈ true}
and τs,s' = ∅ in another cases. It is not difficult to see that NATEQ interprets NAT by τ : first note that for any equation t ≈ t’ such that NAT |= t ≈ t’, we have that NATEQ |= eq(t,t’) ≈ true, since the translation of the proof of NAT |= t ≈ t’ (in sense of Theorem 1.12) is a proof of NATEQ |= eq(t,t’) ≈ true. The converse may be verified by induction on the length of the proof of NATEQ |= eq(t,t’) ≈ true.
For example, if eq(t,t’) ≈ true is obtained by the conditional equation
(ii) then, supposing that NATEQ |= eq(t’,t) ≈ true implies NAT |= t’ ≈ t, we have that NAT |= t ≈ t’. Therefore, we have that NAT zτ NATEQ, since NATEQ |= eq(s(x),s(y)) ≈ true ⇒ eq(x,y) ≈ true.
Note that we can translate a specification of the natural numbers into
another one, axiomatized exclusively by equations of sort bool. This fact may be important, for example, if we would like to encapsulate the sort nat.
As stated, in order to use the stepwise refinement methodology in the spec- ification process, is needed that the vertical composition is present. Bellow, we will characterize the composition of translations:
Definition 3.10 Let τ be a Σ−Σ'-translation and ρ be a Σ' −Σ''-translation. We define ρ.τ as the follows S-family: for each s ∈ S,

ρ.τs,s'' (x : s, y : s)= 
s'∈S'
ρs',s'' (τs,s' (x : s, y : s)).

It is not difficult to see that ρ.τ is a translation, since it is a S-family of globally finite S''-sorted sets of Σ''-equations with two variables (since by hypotheses ρ and τ are also globally finite).
Theorem 3.11 Let τ be a Sig(SP ) − Σ-translation that interprets SP and ρ be a Σ−Σ'-translation that interprets SPτ . Then, the translation ρ.τ interprets SP.
Proof. On the one hand, since τ interprets SP , there is a specification SP '
such that, for any ξ ∈ F m(Sig(SP )) SP |= ξ iff SP ' |= τ (ξ), and by Theorem

3.4, we have that SP |= ξ iff SPτ |= τ (ξ). On the other hand, since ρ interprets SPτ , then there is a specification SP '' such that for any ψ ∈ F m(Σ), SPτ |= ψ iff SP '' |= ρ(ψ). In particular, for any ξ ∈ F m(Sig(SP )) SPτ |= τ (ξ) iff SP '' |= ρ(τ (ξ)), i.e., SP '' |= ρ.τ (ξ). Therefore, the Sig(SP ) − Σ''-translation ρ.τ interprets SP .	 

Conclusions and future works
In this paper we presented, some formalizations of the stepwise refinement process, namely the case where it is required the preservation of the signature during the process, the case where the specifications of the refinements may differ via signature morphisms and the generalization of this process to the observational paradigm. In the latter case, we characterized the vertical com- position of refinements using possibly different observational equalities, i.e., we allowed the encapsulation and desencapsulation of data sorts during the refinement process (Section 2.2). In this context may be worth to extend a re- finement calculus like the system presented in [2] with rules for encapsulation and desencapsulation of sorts in the refinement steps.
In Section 3 we introduced the concept of reﬁnement by translation and we used some tools from abstract algebraic logic to develop an introductory theory of these kind of refinements. We intend to develop these results and analise how they can be generalized to the observational case. An interesting topic in this research is the integration of this kind of refinements in stepwise refinement process present in the Sections 2.1 and 2.2. A first step in this study can be done by the generalization of the reﬁnement via translation in the “mixed” case. Here, given a signature morphism σ :Σ → Σ' and a Σ−Σ'-
translation τ that interprets SP , SP zτdσ SP ' iff SPτ ~σ SP '. Another interesting topic in this study is the equivalence between speciﬁcations in the
perspective of the logical translations. We believe that this work can be done based on the equivalence of deductive systems, more precisely via interpreta- tions in the sense of [4]. There is another notion of logical translation, called conservative translation introduced by H. Feitosa and I. D’Ottaviano in [10]. It will be interesting to investigate this notion within the refinement process.

Acknowledgement
I would like to thank Manuel Ant´onio Martins and Enrique Hernandez Man- fredini for the fruitful discussions concerning this work. I am also grateful to my colleagues Jacinta Po¸cas and Nilde Barreto for their careful reading of the paper manuscript.

References
Bidoit, M., and Hennicker, R. Behavioural theories and the proof of behavioural properties.
Theor. Comput. Sci. 165, 1 (1996), 3–55.
Bidoit, M., and Hennicker, R. Proving behavioral refinements of col-specifications. In Essays Dedicated to Joseph A. Goguen (2006), pp. 333–354.
Bidoit, M., Hennicker, R., and Kurz, A. Observational logic, constructor-based logic, and their duality. Theor. Comput. Sci. 298, 3 (2003), 471–510.
Blok, W., and Pigozzi, D. Abstract algebraic logic and the deduction theorem. Preprint. To appear in the Bulletin of Symbolic Logic. Available at http://www.math.iastate.edu/dpigozzi/ papers/aaldedth.pdf.
Blok, W., and Pigozzi, D. Algebraizable logics. Memoirs of the American Mathematical Society 396, Amer. Math. Soc., Providence (1989).
Blok, W. J., and Rebagliato, J. Algebraic semantics for deductive systems. Studia Logica 74, 1-2 (2003), 153–180.
Bouhoula, A., and Rusinowitch, M. Observational proofs by rewriting. Theor. Comput. Sci. 275, 1-2 (2002), 675–698.
Burris, S., and Sankappanavar, H. P. A course in universal algebra. Graduate Texts in Mathematics, Vol. 78. New York - Heidelberg Berlin: Springer-Verlag., 1981.
Diaconescu, R., and Futatsugi, K. Behavioural coherence in object-oriented algebraic specification. J. UCS 6, 1 (2000), 74–96.
Feitosa, H. A., and D’Ottaviano, I. M. L. Conservative translations. Ann. Pure Appl. Logic 108, 1-3 (2001), 205–227.
Goguen, J., and Burstall, R. Institutions: abstract model theory for specification and programming. J. ACM 39, 1 (1992), 95–146.
Goguen, J., and Malcolm, G. Hidden coinduction: Behavioural correctness proofs for objects.
Math. Struct. Comput. Sci. 9, 3 (1999), 287–319.
Goguen, J., and Malcolm, G. A hidden agenda. Theor. Comput. Sci. 245, 1 (2000), 55–101.
Goguen, J., and Ro¸su, G. Hiding more of hidden algebra. In Wing, Jeannette M. et al. (ed.), FM ’99. Formal methods. World congress on Formal methods in the development of computing systems. Toulouse, France, September 20-24. Proceedings. 1999.
Hennicker, R. Structural specifications with behavioural operators: semantics, proof methods and applications, 1997. Habilitationsschrift.
Loeckx, J., Ehrich, H.-D., and Wolf, M. Algebraic specification of abstract data types. In Handbook of logic in computer science, Vol. 5, Oxford Sci. Publ. Oxford Univ. Press, New York, 2000, pp. 217–316.
Martins, M. A. Behavioral institutions and refinements in generalized hidden logics. Journal of Universal Computer Science 12, 8 (2006), 1020–1049.
Martins, M. A. Closure properties for the class of behavioral models. Theor. Comput. Sci. 379, 1-2 (2007), 53–83.
Martins, M. A., and Pigozzi, D.	Behavioural reasoning for conditional equations.
Mathematical. Structures in Comp. Sci. 17, 5 (2007), 1075–1113.
Padawitz, P. Swinging types=functions+relations+transition systems. Theor. Comput. Sci. 243, 1-2 (2000), 93–165.
Ro¸su, G. Hidden Logic. PhD thesis, University of California, San Diego, 2000.

Sannella, D. Algebraic specification and program development by stepwise refinement. (Extended abstract). In Bossi, Annalisa (ed.), Logic-based program synthesis and transformation. 9th international workshop, LOPSTR ’99. Venice, Italy, September 22-24, 1999. Selected papers. Berlin: Springer. Lect. Notes Comput. Sci. 1817. 2000, pp. 1–9.
Sannella, D., and Tarlecki, A. Essential concepts of algebraic specification and program development. Formal Asp. Comput. 9, 3 (1997), 229–269.
Sannella, D., and Tarlecki, A. Foundations of Algebraic Speciﬁcations and Formal Program Development. Cambridge University Press, To appear.
