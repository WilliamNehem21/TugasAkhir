Electronic Notes in Theoretical Computer Science 136 (2005) 133–152 
www.elsevier.com/locate/entcs


Intersection Types for Light Affine Lambda Calculus
Daniel de Carvalho 1 ,2
Institut de Math´ematiques de Luminy, UMR 6206 163, avenue de Luminy, case 907
13288 Marseille Cedex 9, France

Abstract
Light Affine Lambda Calculus is a term calculus for polynomial time computation ([12]). Some of the terms of Light Affine Lambda Calculus must however be regarded as errors. Intuitionistic Light Affine Logic (ILAL) types only terms without errors, but not all of them. We introduce two type assignment systems with intersection types : in the first one, typable pseudo-terms are exactly the terms without errors ; in the second one, they are exactly those that reduce to normal terms without errors.
Keywords: Implicit Computational Complexity, Intersection Types, Lambda Calculus, Linear Logic


Introduction
One approach to provide languages corresponding to polynomial time com- putation is that of the proofs-as-programs paradigm and Linear Logic ([7]). In particular, two variants of Linear Logic with a polynomial cut-elimination have been proposed : Light Linear Logic ([8]) and Soft Linear Logic ([10]). They can be seen as refinements of System F allowing to characterize poly- nomial time functions : by the Curry-Howard correspondence, these systems allow to write programs which can be evaluated in polynomial time.

1 Work partially supported by GEOCAL Project and the LIPN of the University Paris 13.
2 Email: carvalho@iml.univ-mrs.fr



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.011


Two new type free term calculi based on their essential ideas appeared too : Light Aﬃne Lambda Calculus ([12]) and Soft Lambda Calculus ([3]). K. Terui introduced Light Aﬃne Lambda Calculus as a refinement of the type free lambda calculus for which Intuitionistic Light Aﬃne Logic (ILAL) ([1]),
a variant of Light Linear Logic, provides a type assignment system and he proved that it satisfies the polystep strong normalizability : an (untyped) term is normalizable in a polynomial number of steps by any reduction. This seems to suggest that ILAL types are useless. However this is not the case, because if types are not needed to ensure the complexity bound on reduction, they are actually useful to ensure the term does reduce to a sensible result. Indeed light lambda-terms carry more information than ordinary lambda-terms and there is a forgetful map (erasure) from these terms to ordinary lambda- terms. Some light lambda-terms might be in normal form but correspond to ordinary lambda-term with redexes. Indeed some light lambda terms show configura- tions which can be naturally seen as errors (in particular pattern-matching
errors) or deadlocks. So one would like to be able to account for all usable
light lambda- terms, those for which normalization can be performed without reaching an error. This is all the more natural as light lambda-calculus can be used in other settings than second order ILAL : in particular, in [13], K. Terui uses it to extract programs from light affine set theory proofs. Finally, extensions of ILAL using recursive types like in [3], can also be considered . In the present work, we tackle the problem of characterizing light lambda- terms without errors. In section 3, we give a formal definition of the terms which we can reasonably regard as terms without errors : we name them
reasonable terms. First, we note that, in ILAL, even if every typable pseudo-
term is a reasonable term (Theorem 3.8) and every normal reasonable term is typable (Theorem 3.9), this system doesn’t capture all the reasonable terms (Remark 3.10). Therefore we introduce a new type assignment system, called
Light Intersection Type Assignment System (LI), a system with intersection
types. Intersection types were introduced in [5] to overcome the limitations of Curry’s type discipline and have been used, for instance, to characterize strongly normalizable terms, solvable terms and normalizable terms (see, e.g., [9]). We overcome the limitations of ILAL : we show that typable pseudo- terms in LI are exactly the reasonable terms (Theorem 4.17).
Lastly, we introduce a Relaxed Light Intersection Type Assignment System (RLI) in which typable pseudo-terms are exactly the terms that reduce in terms without errors : the possible errors that the typable pseudo-term con-
tained will be erased during the reduction. So, this sytem, unlike the previous one, has the following property : given two equivalent terms t and t', which amounts to saying that they reduce to the same normal form, t is typable if,


and only if, t' is typable.
With another point of view, all this obviously shows that the problems of typability in LI and in RLI, unlike in the intersection type assignment systems for the Lambda Calculus, are decidable. As far as we know, this problem for ILAL is an open question.
In other respects, Soft Lambda Calculus has the same particularities as Light Aﬃne Lambda Calculus ; so, we conjecture that a similar work could be done for it. With regard to semantics, P. Baillot gave a model for Light
Linear Logic in [2] : the present work gives us hope that, inspired by it, we will give a semantics of Light Aﬃne Lambda Calculus in the near future.

Notation
If S is a set, then Pf (S) denotes the set of the finite subsets of S and P∗(S)
denotes Pf (S) \ {∅}.

Light Affine Lambda Calculus
For the requisite materials about Lambda Calculus, the reader can refer to [4] and [9]. Here we recall only the requisite materials about Light Aﬃne Lambda Calculus ; see [12] for a full exposition.
The definition of the terms is done in two steps : first, we define the pseudo-terms ; second, the terms are defined by imposing certain conditions on the pseudo-terms.
Definition 1.1 The set PT of pseudo-terms is defined by the following gram- mar :
PT ::= V | (PT )PT |λV.PT | !PT | let PT be !V in PT
| §PT | let PT be §V in PT
In the sequel, the symbol † stands for either ! or § ; moreover one identifies α-congruent pseudo-terms (the occurrences of x in v are bound in let u be † x in v) : that’s why in our proofs, we can always assume that free variables
are different from bound variables. For all pseudo-terms t, FV (t) denotes the set of free variables in t, FO(x, t) denotes the number of free occurrences of x in t and FO(t) denotes the number of free occurrences of all variables in t.
The size of a pseudo-term is the number of nodes in its term tree. Given a pseudo-term t and an adress w, the depth of w in t is the number of !-boxes and §-boxes enclosing the subexpression at w. The depth of t is the maximum depth of all adresses in it.


Fig. 1. Reduction rules
Definition 1.2 Let X, Y, Z ∈ Pf (V) mutually disjoint. Then TX,Y,Z is the set of pseudo-terms defined as follows :
x ∈ TX,Y,Z ⇔ x ∈ X ;
λx.t ∈ TX,Y,Z ⇔ t ∈ TX∪{x},Y,Z,x ∈/ X, FO(x, t) ≤ 1 ; 
(t)u ∈ TX,Y,Z ⇔ t, u ∈ TX,Y,Z ;
!t ∈ TX,Y,Z ⇔ t ∈ TY,∅,∅, FO(t) ≤ 1 ; 
§t ∈ TX,Y,Z ⇔ t ∈ TY ∪Z,∅,∅ ;
let t be !x in u ∈ TX,Y,Z ⇔ t ∈ TX,Y,Z,u ∈ TX,Y ∪{x},Z,x ∈/ Y ;
let t be §x in u ∈ TX,Y,Z ⇔ t ∈ TX,Y,Z,u ∈ TX,Y,Z∪{x},x ∈/ Z, FO(x, u) ≤ 1.
Finally, t is a term (t ∈ T ) if t ∈ TX,Y,Z for some X, Y and Z.
Lemma 1.3 Let t ∈ TX,Y,Z. If x ∈/ FV (t), then t ∈ TX\{x},Y \{x},Z\{x}.
Examples :
λx.let x be !y in y, λx.let x be !y in !!y ∈/ T ;
λx.let x be !z in §λy.(z) ... (z)y ∈ T .
K. Terui provided a quadratic time algorithm checking whether a given pseudo-term is a term.
The reduction rules are those given in Figure 1 with the following restric- tion : in the rule (com), x ∈/ FV (v). −→0 denotes the one step reduction and
−→ denotes the transitive reflexive closure of −→0.
K. Terui proved the following proposition and theorem :
Proposition 1.4 If t ∈ TX,Y,Z and t −→ u, then u ∈ TX,Y,Z.
Theorem 1.5 For every term t0 of size s and depth d, the following hold :
every reduction sequence from t0 has a length bounded by O(s2d+1 ) ;
every term to which t0 reduces has a size bounded by O(s2d ).


So, by Ko¨nig’s Lemma, for all terms t, we can define N (t) as the sum of the lengths of all possible reduction sequences. Moreover, applying New- man’s Lemma, we obtain, as a corollary, that −→ satisfies the Church-Rosser property.
Another corollary is the polytime strong normalization (see [12]).
The erasure of a term t is defined, by induction on t, to be a lambda-term :
if t = †u, then erasure(t) = erasure(u) ; 
if t = let u be † x in v, then erasure(t) = erasure(v)[erasure(u)/x] ; 
erasure commutes to other constructions.
For all terms t and t', if t −→ t', then erasure(t) β erasure(t'). But here is an example of a normal term, of which the erasure is a non normalizable lambda-term : let λx.let x be !y in §(y)y be !y in §(y)y. This is an example of a term that can be seen as an error.


Type Assignment System ILALN
We present Intuitionistic Light Aﬃne Logic as a type assignment system for Light Aﬃne Lambda Calculus. ILALN is a second order type assignment system in natural deduction style.

Definition 2.1 The types of ILALN are given by the following grammar :
F ::= P | (F   F) | ∀P F |!F | §F.

∃, ⊗, 1, &, ⊗ and 0 are definable from  and ∀. In particular, 0 ≡ ∀α α. A †-discharged type is an expression of the form [A]†, where A is an (undis-
charged) type. A declaration is an expression of the form x : A or x : [A]†. A 
context is a finite set of declarations.
If Γ is the context x1 : A1,... , xn : An where all the types in it are undis- charged, then [Γ]† denotes the context x1 : [A1]†,... , xn : [An]†. If Γ contains a declaration with a discharged type, then [Γ]† is undefined.
Definition 2.2 The type assignment rules of ILALN are those given in Fig- ure 2.

The following theorems hold :
Theorem 2.3 Every typable pseudo-term is a term.
Theorem 2.4 ([8], [11]) Every function f : {0, 1}∗ −→ {0, 1}∗ which is computable in time O(nd) is represented by a term of type bint  §d+6bint.



Fig. 2. Type Assignment System ILALN

Fig. 3. New reduction rules
True terms, safe terms and reasonable terms
We already encountered an example of term that can be seen as an error. In this section, we clarify this notion.
We begin by giving a formal definition of the normal terms without errors : we name them true terms.
Definition 3.1 We define the set T T of true terms and the set WT of wise terms as follows :
T T = T PT ∩ T and WT = WPT ∩ T , where RPT and WPT are the sets defined by the following grammar :
WPT ::= V | (WPT )T PT
T PT ::= WPT | λV.T PT | !T PT | let WPT be !V in T PT
|§T PT | let WPT be §V in T PT
Note that we have : {wise terms} ; {true terms} ; {normal terms}.
In order to justify this definition, it can be showed that if we add a new term error and the reduction rules given in Figure 3, then the new reduction relation has the Church-Rosser property (using Hindley-Rosen’s Lemma) and every term reduces either to a true term, or to a term of which error is a subterm.


Definition 3.2 A term is said to be safe whenever it reduces to a true term ; it is said to be reasonable whenever every normal subterm of every term to which it reduces is true.
Note that we have : {true terms} ; {reasonable terms} ; {safe terms}.
Moreover, the erasure of any true term is normal and the erasure of any safe term is normalizable ; we will prove that the erasure of any reasonable term is strongly normalizable in Section 4.
Definition 3.3 One says that a formula is open if it doesn’t begin by ∀.
Fact 3.4 For all contexts Γ, for all open formulae A, for all variables x, for all terms u, if Γ ▶ λx.u : A, then A is written (C  B).
Fact 3.5 For all contexts Γ, for all open formulae A, for all terms u, if Γ ▶
!u : A, then A is written !C.
Fact 3.6 For all contexts Γ, for all open formulae A, for all terms u, if Γ ▶
§u : A, then A is written §C.
Lemma 3.7 Every typable normal term is true.
Proof. We prove, by induction on π, that for all derivations π, for all formulae A, for all contexts Γ, for all normal terms t, if π is a derivation of Γ ▶ t : A, then t is true :

π is
x : A, Γ' ▶ x : A Ax
: t is a variable ;

Γ ▶ v : (C   A)	Γ ▶ u : C
π ends in		  E
Γ ▶ (v)u : A
: v is wise, because :

as (v)u is normal, v is normal and isn’t written λx.v1, nor let v1 be †
x in v2 ;
moreover, by the Facts 3.5 and 3.6, v isn’t written †v1 ;
finally, by the induction hypothesis, v is true ;
moreover, as (v)u is normal, u is normal, therefore, by the induction hy- pothesis, u is true ;

π ends in	x : C, Γ ▶ u : B FO(x, u) ≤ 1 
Γ ▶ λx.u : (C   B)
: as λx.u is normal, u is

normal, therefore, by the induction hypothesis, u is true ;

π ends in  Γ ▶ t : ∀α C	 ∀E
Γ ▶ t : C[B/α]
: apply the induction hypothesis ;

π ends in	Γ ▶ t : C α ∈/ FV (Γ) ∀I
Γ ▶ t : ∀αC 
: apply the induction hypothesis ;

π ends in	 Γ ▶ u : !C	x : [C]!, Γ ▶ v : A 
Γ ▶ let u be !x in v : A
: u is wise, because :


as let u be !x in v is normal, u is normal and isn’t written !u1, nor let u1 be †
x in u2 ;
moreover, by the Facts 3.4 and 3.6, u isn’t written λy.u1, nor §u1 ;
finally, by the induction hypothesis, u is true ;
moreover, as let u be !x in v is normal, v is normal, therefore, by the induc- tion hypothesis, v is true ;

π ends in	Γ' ▶ u : C	!I
[Γ']!, ∆ ▶ !u : !C
: as !u is normal, u is normal, therefore, by

the induction hypothesis, u is true ;
Γ ▶ u : §C	x : [C]§, Γ ▶ v : A FO(x, v) ≤ 1
π ends in	§E
Γ ▶ let u be §x in v : A

: u is wise,

because :
as let u be !x in v is normal, u is normal and isn’t written §u1, nor let u1 be †
x in u2 ;
moreover, by the Facts 3.4 and 3.5, u isn’t written λy.u1, nor !u1 ;
finally, by the induction hypothesis, u is true ;
moreover, as let u be !x in v is normal, v is normal, therefore, by the induc- tion hypothesis, v is true ;
Γ, Σ ▶ u : C

π ends in
§I
[Γ]!, [Σ]§, ∆ ▶ §u : §C
: as §u is normal, u is normal, therefore,

by the induction hypothesis, u is true.

Theorem 3.8 Every typable pseudo-term is a reasonable term.
Proof. The theorem follows from the Theorem 2.3, the Subject Reduction Theorem for ILALN, the subterm typability and the Lemma 3.7.	 
For all x1,... , xk1 , y1,... , yk2 , z1,... , zk3 ∈ V, Γ{x1,...,xk },{y1,...,yk },{z1,...,zk }

denotes the following context :
1	2	3

x1 : 0,... , xk1 : 0, y1 : [0]!,... , yk2 : [0]!, z1 : [0]§,... , zk3 : [0]§.
Theorem 3.9 Every true term is typable.
Proof. We prove, by induction on t, that for all true (respectively wise) terms t, for all X, Y, Z ⊆ V, if t ∈ TX,Y,Z, then there exists a formula T such that (respectively for all formulae T , we have) ΓX,Y,Z ▶ t : T :
t ∈ WT : let T be a formula :

Case 1 : t is a variable : t ∈ X, therefore we have
 ΓX,Y,Z ▶ t : 0  Ax	;

ΓX,Y,Z ▶ t : T  ∀E
Case 2 : t = (w)r, w ∈ WT and r ∈ T T : w, r ∈ TX,Y,Z, therefore, by


the hypothesis induction, ΓX,Y,Z ▶ r : R and ΓX,Y,Z ▶ w : (R  T ) ; so ΓX,Y,Z ▶ t : T ;
t = !u and u ∈ T T : u ∈ TY,∅,∅ ; therefore, by the induction hypothesis, ΓY,∅,∅ ▶ u : U ; so ΓX,Y,Z ▶ t : !U ;
t = let u be !x in v, u ∈ WT and v ∈ T T : u ∈ TX,Y,Z and v ∈ TX,Y,Z ; therefore, by the induction hypothesis, ΓX,Y,Z ▶ u : !0 and ΓX,Y ∪{x},Z ▶ v :
V ; so ΓX,Y,Z ▶ t : V ;
t = §u and u ∈ T T : u ∈ TY ∪Z,∅,∅ ; therefore, by the induction hypothesis, ΓY ∪Z,∅,∅ ▶ u : U ; so ΓX,Y,Z ▶ t : §U ;
t = let u be §x in v, u ∈ WT and v ∈ T T : u ∈ TX,Y,Z and v ∈ TX,Y,Z∪{x} ; therefore, by the induction hypothesis, ΓX,Y,Z ▶ u : §0 and ΓX,Y,Z∪{x} ▶ v :
V ; so ΓX,Y,Z ▶ t : V .

Remark 3.10 Nevertheless, there exist untypable reasonable terms. Example :
G = let !λx.let x be !x' in §(x')x' be !x' in §λy.((y)(x')!λx.x)(x')!λx.λy.x.
Although its erasure is typable in System F, G is a reasonable term, that isn’t typable in ILALN. Indeed, we can deﬁne a new translation into the lambda- calculus : the crossing out ; cross(t) denotes the crossing out of a term t, that is deﬁned by induction on t :
if t = †u, then cross(t) = cross(u) ;
if t = let u be † x in v, then cross(t) = (λx.cross(v))cross(u) ;
cross commutes to other constructions ;
and we can show that if a term is typable in ILALN, then its crossing out is typable in System F. And the crossing out of G, i.e.
(λx'.λy.((y)(x')λx.x)(x')λx.λy.x)λx.(λx'.(x')x')x,
isn’t typable in System F (see [6]).

Light Intersection Type Assignment System
ILALN allowed us to give a sufficient condition for a term to be reasonable. Now, we want to define a system that types more reasonable terms. For that, we use the approach of intersection types.
Definition 4.1 The set F∩ of types is defined by the following grammar :
F∩ ::= P | (F∩   F∩) | !P∗(F∩) | §{F∩}.
The set !-DF∩ is {[α]! ; α ∈ F∩}. The set §-DF∩ is {[α]§ ; α ∈ F∩}.



Fig. 4. Light Intersection Type Assignment System
A context is a map from a finite subset of V to P∗(F∩) ∪P∗(!-DF∩) ∪P∗(§-

DF∩).
f	f	f

For all X, Y, Z ⊆ V, CX,Y,Z is the set of the contexts Γ such that ∀x ∈
X ∩ dom(Γ), Γ(x) ∈ P∗(F∩), ∀y ∈ Y ∩ dom(Γ), Γ(y) ∈ P∗(!-DF∩) and ∀z ∈
f	f
Z ∩ dom(Γ), Γ(z) ∈ P∗(§-DF∩).
From now on, we use Greek letters to denote types and Latin ones to denote their finite sets.
An element of P∗(F∩) can be thought of as the intersection of its elements. For all a ∈ P∗(F∩), [a]† denotes {[α]† ; α ∈ a} and Γ ▶∩ t : a denotes
∀α ∈ a Γ ▶∩ t : α.
Definition 4.2 The type assignment rules are those given in Figure 4.
Note that the rule !I has Card(a) premises.
Remark 4.3 This system satisﬁes the subterm typability.
Definition 4.4 We define a binary relation ≤ on the set of the contexts as follows : Γ ≤ Γ' if, and only if, dom(Γ) ⊆ dom(Γ') and ∀x ∈ dom(Γ) Γ(x) ⊆ Γ'(x).
Fact 4.5 For all t ∈ TX,Y,Z, for all types α, for all contexts Γ and Γ' such that Γ ≤ Γ', if Γ ▶∩ t : α, then Γ' ▶∩ t : α.
For all contexts Γ, for all terms t, Γt denotes {(x, ) ∈ Γ ; x is free in t}.
Fact 4.6 For all contexts Γ, for all terms t, for all types α, Γ ▶∩ t : α if, and only if, Γt ▶∩ t : α.
Subject Reduction
Lemma 4.7 Let Γ be a context and let x1,... , xk1 , y1,... , yk2 , z1,... , zk3 be
variables such that x1,... , xk1 , y1,... , yk2 , z1,... , zk3 ∈/ dom(Γ). If Γ, x1 :
{α1},... , xk1 : {αk1 }, y1 : [b1]!,... , yk2 : [bk2 ]!, z1 : [{γ1}]§,... , zk3 : [{γk3 }]§ ▶∩

t : α, for all i ∈ {1,... , k1}, Γ ▶∩ ui : αi, for all i ∈ {1,... , k2}, Γ ▶∩ !vi : !bi, and for all i ∈ {1,... , k3}, Γ ▶∩ §wi : §{γi}, then
Γ ▶∩ t[u1/x1,... , uk1 /xk1 , v1/y1,... , vk2 /yk2 , w1/z1,... , wk3 /zk3 ] : α.
Proof. By induction on t.	 
Lemma 4.8 For all term t, if Γ ▶∩ t : α and t −→0 t', then Γ ▶∩ t' : α.
Proof. First, note that, by the Proposition 1.4, t' is a term. Now, we prove the lemma by induction on t : the critical cases are the following :
t = (λx.v1)u et t' = v1[u/x] ; 
t = let !u1 be !x in v and t' = v[u1/x] ; 
t = let §u1 be §x in v and t' = v[u1/x].
In all this cases, assume that x ∈/ dom(Γ) and apply the Lemma 4.7.	 Proposition 4.9 For all terms t, if Γ ▶∩ t : α and t −→ t', then Γ ▶∩ t' : α. Proof. Follows from the Lemma 4.8.	 
Typable pseudo-terms are reasonable terms
Proposition 4.10 For all pseudo-terms t, if
x1 : a1,... , xk1 : ak1 , y1 : [b1]!,... , yk2 : [bk2 ]!, z1 : [{γ1}]§,... , zk3 : [{γk3 }]§ ▶∩ t : α
is derivable, then t ∈ T{x1 ,...,xk },{y1,...,yk },{z1 ,...,zk }.
Proof. By induction on the pseudo-term.	 
Lemma 4.11 Every typable normal term is true.
Proof. By induction on the term.	 
Proposition 4.12 Every typable pseudo-term is a reasonable term.
Proof. Let t be a typable pseudo-term. First, by the Proposition 4.10, t is a term. Now, let t' such that t −→ t'. By the Proposition 4.9, t' is typable ; so, every normal subterm of t' is typable and, by the Lemma 4.11, is true. 

Reasonable terms are typable
For all contexts Γ1 and Γ2, Γ1 +Γ2 denotes {(x, Γ1(x) ∪Γ2(x)); x ∈ dom(Γ1) ∩ dom(Γ2)}∪ {(x, Γ1(x)) ; x ∈ dom(Γ1) \ dom(Γ2)}∪ {(x, Γ2(x)) ; x ∈ dom(Γ2) \ dom(Γ1)}.


Lemma 4.13 For all true (respectively wise) terms t, for all X, Y , Z ⊆ V, if t ∈ TX,Y,Z and for all z ∈ Z, FO(z, t) ≤ 1, then there exists α ∈ F∩ (respectively for all α ∈ F∩), there exists Γ ∈ CX,Y,Z such that :
Γ ▶∩ t : α ;
and for all w ∈ dom(Γ), if FO(w, t) ≤ 1, then Card(Γ(w)) = 1.
Proof. By the Lemma 1.3 and the Fact 4.6, we can assume that FV (t) = 
X ∪ Y ∪ Z. Now, we prove the lemma by induction on t :
t is a wise term : let α ∈ F∩ :

Case 1 : t is a variable : we have
t : {α} ▶∩ t : α Ax	;

Case 2 : t = (v)r, v is a wise term and r is a true term : by the induction hypothesis, there exists β ∈ F∩ and Γr ∈ CX,Y,Z such that :
Γr ▶∩ r : β ;
and for all w ∈ dom(Γr), if FO(w, r) ≤ 1, then Card(Γr(w)) = 1 ;
again by the induction hypothesis, there exists Γv ∈ CX,Y,Z such that :
Γv ▶∩ v : (β   α) ; 
and for all w ∈ dom(Γv), if FO(w, v) ≤ 1, then Card(Γv(w)) = 1 ;
by the Facts 4.6 and 4.5 and by   E, we have Γv + Γr ▶ t : α ; hence we
v	r
can let Γt = Γv + Γr ;
v	r
t = λx.u, t = !u, or t = §u : it is straightforward ;
t = let u be !x in v, u ∈ WT and v ∈ T T : by the induction hypothesis, there exists α ∈ F∩ and Γv,x : [b]! ∈ CX,Y ∪{x},Z such that :
Γv,x : [b]! ▶∩ v : α ;
and for all w ∈ dom(Γv) ∪ {x}, if FO(w, v) ≤ 1, then Card(Γv(w)) = 1 ;
again by the induction hypothesis, there exists Γu ∈ CX,Y,Z such that :
Γu ▶∩ u : !b ;
and for all w ∈ dom(Γu), if FO(w, u) ≤ 1, then Card(Γu(w)) = 1 ;
by the Facts 4.6 and 4.5 and by !E, we have Γu + Γv ▶ t : α ; hence we can
u	v
let Γt = Γu + Γv ;
u	v
t = let u be §x in v, u ∈ WT and v ∈ T T : by the induction hypothesis, there exists α ∈ F∩ and Γv,x : [{β}]§ ∈ CX,Y,Z∪{x} such that :
Γv,x : [{β}]§ ▶∩ v : α ;
and for all w ∈ dom(Γv), if FO(w, v) ≤ 1, then Card(Γv(w)) = 1 ;
again by the induction hypothesis, there exists Γu ∈ CX,Y,Z such that :
Γu ▶∩ u : §{β} ;
and for all w ∈ dom(Γu), if FO(w, u) ≤ 1, then Card(Γu(w)) = 1 ;
by the Facts 4.6 and 4.5 and by §E, we have Γu + Γv ▶ t : α ; hence we can
u	v
let Γt = Γu + Γv.
u	v


Lemma 4.14 For all X, Y, Z ⊆ V, for all terms u and v such that v ∈ TX,Y,Z, for all contexts Γ such that x ∈/ dom(Γ), if Γ ▶∩ v[u/x] : α, then :
if x ∈ X and u is typable in the context Γ, then there exists a ∈ P∗(F∩)
such that Γ,x : a ▶∩ v : α and Γ ▶∩ u : a ;
if x ∈ Y and !u is typable in the context Γ, then there exists a ∈ P∗(F∩)
such that Γ,x : [a]! ▶∩ v : α and Γ ▶∩ !u : !a ;
if x ∈ Z, FO(x, v) ≤ 1 and §u is typable in the context Γ, then there exists γ ∈ F∩ such that Γ,x : [{γ}]§ ▶∩ v : α and Γ ▶∩ §u : §{γ}.
Proof. By induction on v :
if v is a variable, then we have the following cases :
v = x : x ∈ X and we can let γ = α ;
v /= x : in all the cases, just apply the Fact 4.6 ;
if v = (v2)v1, then we have Γ ▶∩ v2[u/x] : (β   α) and Γ ▶∩ v1[u/x] : β :
by the hypothesis induction, we have Γ,x : a2 ▶∩ v2 : (β   α) and Γ ▶∩ u : a2 ; again by the hypothesis induction, we have Γ,x : a1 ▶∩ v1 : β and Γ ▶∩ u : a1 ; by the Fact 4.5, we have Γ,x : a1 ∪ a2 ▶∩ v2 : (β  α) and Γ,x : a1 ∪ a2 ▶∩ v1 : β ; by  E, we have Γ,x : a1 ∪ a2 ▶∩ v : α ;
by the hypothesis induction, we have Γ,x : [a2]! ▶∩ v2 : (β  α) and Γ ▶∩
!u : !a2 ; again by the hypothesis induction, we have Γ,x : [a1]! ▶∩ v1 : β and Γ ▶∩ !u : !a1 ; by the Fact 4.5, we have Γ,x : [a1 ∪ a2]! ▶∩ v2 : (β  α) and Γ,x : [a1 ∪ a2]! ▶∩ v1 : β ; by  E, we have Γ,x : [a1 ∪ a2]! ▶∩ v : α ;
we have the following cases :
v2[u/x] = v2 : by the hypothesis induction, we have Γ,x : [{γ}]§ ▶∩ v1 : β and Γ ▶∩ §u : §{γ} ; by the Fact 4.5, we have Γ,x : [{γ}]§ ▶∩ v2 : (β α) ; by  E, we have Γ,x : [{γ}]§ ▶∩ v : α ;
v2[u/x] /= v2 : FO(x, v) ≤ 1, therefore we have v1[u/x] = v1 ; by the hypothesis induction, we have Γ,x : [{γ}]§ ▶ v2 : (β  α) and Γ ▶∩ §u :
§{γ} ; by the Fact 4.5, we have Γ,x : [{γ}]§ ▶∩ v1 : β ; by   E, we have
Γ,x : [{γ}]§ ▶∩ α ;
if v = !v1, then : 
in the cases (i) and (iii), just apply the Fact 4.5 ;
in the case (ii), apply the case (i) of the hypothesis induction ;
the other cases are similar.
 
Proposition 4.15 For all X, Y , Z ⊆ V, for all reasonable terms t ∈ TX,Y,Z, for all Γ ∈ CX,Y,Z, for all terms t' such that t −→ t', if for all z ∈ Z, FO(z, t) ≤ 1, Γ ▶∩ t' : α and for all w ∈ dom(Γ) such that FO(w, t') ≤ 1, Card(Γ(w)) = 1, then there exists Γ' ∈ CX,Y,Z such that :

Γ ≤ Γ' ;
Γ' ▶∩ t : α ;
and for all w ∈ dom(Γ') such that FO(w, t) ≤ 1, Card(Γ'(w)) = 1.
Proof. By well-founded induction on (N (t), size(t)).
If t is normal, then there is nothing to do. Else, if t' /= t, then there exists a term t1 such that t −→0 t1 and t1 −→ t'. t1 is a reasonable term, so, by the hypothesis induction, there exists Γ1 ∈ CX,Y,Z such that Γ ≤ Γ1, Γ1 ▶∩ t1 : α and for all w ∈ dom(Γ1) such that FO(w, t) ≤ 1, Card(Γ1(w)) = 1 ; we have
the following cases :
t = (v)u, t1 = (v1)u and v −→0 v1 : apply the hypothesis induction ;
t = (v)u, t1 = (v)u1 and u −→0 u1 : apply the hypothesis induction ;
t = (λx.v)u and t1 = v[u/x] : apply the Lemma 4.13, the hypothesis induction and the Lemma 4.14 (i) ;
t = (let u1 be † x1 in v1)u, t1 = let u1 be † x1 in (v1)u and x1 ∈/ FV (u) : we have Γ1 ▶∩ t : α ;
t = λx.u, t1 = λx.u1 and u −→0 u1 : apply the hypothesis induction ;
t = †u, t1 = †u1 and u −→0 u1 : apply the hypothesis induction ;
t = let u be † x in v, t1 = let u1 be † x in v and u −→0 u1 : apply the hypothesis induction ;
t = let !u be !x in v, t1 = v[u/x] : apply the hypothesis induction and the Lemma 4.14 (ii) ;
t = let §u be §x in v, t1 = v[u/x] : apply the hypothesis induction and the Lemma 4.14 (iii) ;
t = let !u be !x in v, t1 = let !u be !x in v1, v −→0 v1 and !u is normal : it reduces to the case h) : apply Church-Rosser, the Proposition 4.9 and the hypothesis induction ;
t = let §u be §x in v, t1 = let §u be §x in v1, v −→0 v1 and §u is normal : it reduces to the case i) : apply Church-Rosser, the Proposition 4.9 and the hypothesis induction ;
t = let u be † x in v, t1 = let u be † x in v1, v −→0 v1 and u ∈ WT : apply the hypothesis induction and the Lemma 4.13 ;
t = let u be † x in v, t1 = let u be † x in v1, v −→0 v1 and u isn’t normal : it reduces to the case g) : apply Church-Rosser, the Proposition 4.9 and the hypothesis induction ;
t = let let u1 be †1 x1 in v1 be † x in v, t1 = let u1 be †1 x1 in let v1 be †
x in v and x1 ∈/ FV (v) : we have Γ1 ▶∩ t : α.



Fig. 5. System D

Corollary 4.16 Every reasonable term is typable.
Proof. Let t ∈ TX,Y,Z a reasonable term. First, note that t ∈ TX,Y ∪Z,∅. Now, there exists a true term t' ∈ TX,Y ∪Z,∅ such that t −→ t'. Apply the Propositions 4.13 and 4.15.	 
Theorem 4.17 A pseudo-term is typable if, and only if, it is a reasonable term.
Proof. Follows from the Proposition 4.12 and the Corollary 4.16.	 

The erasure of any reasonable term is strongly normalizable
In order to prove that the erasure of any reasonable term is strongly normal- izable, we recall what is the System D (see [9] for a full exposition) :
Definition 4.18 The set FD of the types of the System D is defined by the following grammar :
FD ::= P | (FD → FD) | (FD ∧ FD).
Definition 4.19 The type assignment rules are those given in Figure 5.
The following fact, theorem and proposition hold :
Fact 4.20 If Γ ▶D t : α, then Γ, ∆ ▶D t : α.
Theorem 4.21 Every typable lambda-term in the System D is strongly nor- malizable.
Proposition 4.22 Let Γ be a context and x1,... , xk variables non declared in Γ. If Γ, x1 : A1,... , xk : Ak ▶D u : B and for all i such that 1 ≤ i ≤ k and xi is free in u, Γ ▶D ti : Ai, then Γ ▶D u[t1/x1,... , tk/xk] : B.
Now, we need some definitions :
Definition 4.23 For all n ≥ 1, for all  ∈ Fn,   is defined by induction on
n :
if  = (α), then   = α ;


(α1,... , αn+1) = (  (α1,... , αn) ∧ αn+1).
Fact 4.24 If Γ ▶D  (α1,... , αn), then Γ ▶D α1, ..., Γ ▶D αn.

Let  D
be any function from P∗(FD
) to F(N) such that

  D({A1,... , An}) = (A1,... , An).
The erasureF∩ of a type α of LI is defined, by induction on α, to be a type of the System D :
if α ∈ P, then erasureF∩ (α) = α ;
if α = (β   γ), then erasureF∩ (α) = (erasureF∩ (β) → erasureF∩ (γ)) ;
if α = !a, then erasureF∩ (α) =   D{erasureF (β); β ∈ a} ;
if α = §{γ}, then erasureF∩ (α) = erasureF∩ (γ).
For any [α]† ∈ † − DF∩, erasureDF∩ ([α]†) = erasureF∩ (α).
For any context Γ, erasurec(Γ) is a map from a finite subset of V to FD defined as follows : the domain is the same as those of Γ and for all x ∈ dom(Γ), we
have the following cases :
if Γ(x) ∈ P∗(F∩), then erasurec(Γ)(x) =   D{erasureF (α); α ∈ Γ(x)} ;
f	∩

if Γ(x) ∈ P∗(†− DF∩), then erasurec(Γ)(x) =   D{erasureDF
(α); α ∈

Γ(x)}.
Proposition 4.25 If Γ ▶LI t : α is derivable, then erasurec(Γ) ▶D erasure(t) : 
erasureF∩ (α) is derivable.
Proof. By induction on t :
if t is a variable, then apply the Fact 4.24 ;
if t = (v)u or t = λx.u, then it is straightforward ;
if t = let u be !x in v, then apply the Fact 4.24 and the Proposition 4.22 ;
if t = let u be §x in v, then apply the Proposition 4.22 ;
if t = †u, then apply the Fact 4.20.

Theorem 4.26 The erasure of any reasonable term is strongly normalizable.
Proof. Follows from the Corollary 4.16 and 4.25 and the Theorem 4.21. 

Relaxed Light Intersection Type Assignment System
LI allowed us to give a sufficient and necessary condition for a term to be reasonable. Now, we slightly modify this system to obtain a new system that types exactly the safe terms.



Fig. 6. Relaxed Light Intersection Type Assignment System

Definition 5.1 The set FΩ of types is defined by the following grammar :
FΩ ::= P | (FΩ   FΩ) | !P∗(FΩ) | §{FΩ}| Ω.
The set !-DFΩ is {[α]! ; α ∈ FΩ}. The set §-DFΩ is {[α]§ ; α ∈ FΩ}.
A context is a map from a finite subset of V to P∗(FΩ) ∪ P∗(!-DFΩ) ∪ P∗(§-

DFΩ).
f	f	f

For all a ∈ P∗(FΩ), [a]† denotes {[α]† ; α ∈ a} and Γ ▶Ω t : a denotes
∀α ∈ a Γ ▶Ω t : α.

Definition 5.2 The type assignment rules are those given in Figure 6.

The unique difference between the type assignment rules of LI and those of RLI is the rule ΩI : every term has type Ω. Note that in order to apply this rule with a pseudo-term you must check that it is a term ; it is not a problem, because, as noted in Section 1, there is a quadratic algorithm to do
it. But be careful with the definition of typable :
Definition 5.3 For all sequents x1 : a1,... , xk1 : ak1 , y1 : [b1]†1 ,... , yk2 :

[bk2 ]†k  ▶ t : α, types(x1 : a1,... , xk1 : ak1 , y1 : [b1]†1 ,... , yk2 : [bk2 ]†k
▶ t : α)

2
denotes (
  {ai ; 1 ≤ i ≤ k1}) ∪ (
2
{bi ; 1 ≤ i ≤ k2}) ∪ {α}.


Definition 5.4 A term t is said to be typable whenever there exists a sequent Γ ▶Ω t : α such that there exists a derivation of Γ ▶Ω t : α and types(Γ ▶Ω t :
α) ⊆ F∩.

Subject Reduction
Proposition 5.5 For all terms t, if Γ ▶Ω t : α and t −→ t', then Γ ▶Ω t' : α.
Proof. Similar to the proof of the Proposition 4.9.	 


Subformula Property
Definition 5.6 For all α ∈ FΩ, we define, by induction on α, the set S(α) of the subformulas of α :
if α ∈ P, then S(α) = {α} ;
if α = (β   γ), then S(α) = S(β) ∪ S(γ) ∪ {α} ;
if α = †a, then S(α) = (  {S(µ); µ ∈ a}) ∪ {α} ;
if α = Ω, then S(α) = {Ω}.
Remark 5.7 If α ∈ F∩, then S(α) ⊆ F∩.
Proposition 5.8 Let t be a normal term and let π be a derivation of Γ ▶Ω t : α. Then for all sequents Θ of π, for all µ ∈ types(Θ), there exists β ∈ types(Γ ▶Ω t : α) such that µ ∈ S(β) ; moreover if t is written (v)u, then α ∈ S(Γ).
Proof. By induction on t.	 
Corollary 5.9 Every typable normal term in RLI is typable in LI.
Typable pseudo-terms are safe terms
Proposition 5.10 If x1 : a1,... , xk1 : ak1 , y1 : [b1]!,... , yk2 : [bk2 ]!, z1 : [c1]§,... , zk3 : [ck3 ]§ ▶ t : α is derivable, then t ∈ T{x1 ,...,xk },{y1 ,...,yk },{z1 ,...,zk }.
Proof. Similar to the proof of the Proposition 4.10.	 
Proposition 5.11 Every typable pseudo-term is a safe term.
Proof. Let t be a typable pseudo-term. By the Proposition 5.10, t is a term. By the Theorem 1.5, t reduces to a normal term t'. By the Proposition 5.5, t' is a typable term. Now, by the Corollary 5.9, t' is typable in LI. So, by the
Lemma 4.11, t' is a true term.	 
Safe terms are typable terms
Lemma 5.12 For all X, Y, Z ⊆ V, for all terms u and v such that v ∈ TX,Y,Z, for all contexts Γ such that x ∈/ dom(Γ), if Γ ▶Ω v[u/x] : α, then :
if x ∈ X, then there exists a ∈ P∗(FΩ) such that Γ,x : a ▶Ω v : α and
Γ ▶Ω u : a ;
if x ∈ Y , then there exists a ∈ P∗(FΩ) such that Γ,x : [a]! ▶Ω v : α and
Γ ▶Ω !u : !a ;
if x ∈ Z and FO(x, v) ≤ 1, then there exists γ ∈ FΩ such that Γ,x : [{γ}]§ ▶Ω v : α and Γ ▶Ω §u : §{γ}.


Proof. We can assume that α /= Ω. Now, we prove the lemma by induction on v :
if v is a variable, then we have the following cases :
v = x : x ∈ X and we can let γ = α ;
v /= x :
since Γ ▶Ω v : α, by the Fact 4.6, Γ,x : {Ω} ▶Ω v : α ; and we have Γ ▶Ω u : Ω ;
since Γ ▶Ω v : α, by the Fact 4.6, Γ,x : [{Ω}]! ▶Ω v : α ; and we have Γ ▶Ω !u : !{Ω} ;
since Γ ▶Ω v : α, by the Fact 4.6, Γ,x : [{Ω}]§ ▶Ω v : α ; and we have Γ ▶Ω §u : §{Ω} ;
the other cases are similar to the proof of the Lemma 4.14.


Proposition 5.13 For all terms t and t' such that t −→0 t', if Γ ▶Ω t' : α, then Γ ▶Ω t : α.
Proof. We can assume that α /= Ω. Now, the proposition is proved by induc- tion on t : the critical cases are the following :
t = (λx.v1)u et t' = v1[u/x] : apply the Lemma 5.12 (i) ;
t = let !u1 be !x in v and t' = v[u1/x] : apply the Lemma 5.12 (ii) ;
t = let §u1 be §x in v and t' = v[u1/x] : apply the Lemma 5.12 (iii).

Theorem 5.14 For all terms t and t' such that t −→ t', if Γ ▶Ω t' : α, then
Γ ▶Ω t : α.
Proof. Follows from the Proposition 5.13.	 
Theorem 5.15 Every pseudo-term is typable if, and only if, it is a safe term.
Proof. Let t be a safe term : it reduces to a true term, which, by the Propo- sition 5.5, is typable ; so, by the Theorem 5.14, t is typable. The converse is the Proposition 5.11.	 


Acknowledgement
We have to thank Patrick Baillot for all his comments, remarks and sugges- tions ; we do it here warmly.

References
A. Asperti. Light affine logic. In Proceedings of LICS’98, pages 300–308, 1998.
Patrick Baillot. Stratified coherent spaces : a denotational semantics for light linear logic.
Theoretical Computer Science, 318(1-2):29–55, June 2004.
Patrick Baillot and Virgile Mogbil. Soft lambda-calculus : a language for polynomial time computation. In Proceedings of FOSSACS, volume 2987 of LNCS, pages 27–41. Springer, 2004.
H. P. Barendregt. The Lambda Calculus. Noth-Holland, 1984.
M. Coppo and M. Dezani-Ciancaglini. An extension of the basic functionality theory for the lambda-calculus. Notre Dame J. Formal Logic, 21(4):685–693, 1980.
P. Giannini and S. Ronchi della Rocca. Characterization of typings in polymorphic type discipline. In Proceedings of LICS’88, pages 61–70, 1988.
J.-Y. Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
J.-Y. Girard. Light linear logic. Information and Computation, 143(2):175–204, 1998.
J.L. Krivine. Lambda-calcul types et mod`eles. Masson, 1990.
Y. Lafont. Soft linear logic and polynomial time. Theoretical Computer Science, 318(1-2):163– 180, 2004.
L. Roversi. A P-Time Completeness Proof for Light Logics. In Ninth Annual Conference of the EACSL (CSL’99), volume 1683 of Lecture Notes in Computer Science, pages 469 – 483, Madrid (Spain), September 1999. Springer-Verlag.
K. Terui. Light affine lambda calculus and polytime strong normalization. In Proceedings of LICS’01, pages 209–220, 2001.
K. Terui. Light affine set theory : a naive set theory of polynomial time. Studia Logica, 77:9–40, 2004.
