	Electronic Notes in Theoretical Computer Science 206 (2008) 111–131	
www.elsevier.com/locate/entcs

Architectural Connectors for Sequence Diagrams
Fernando Orejas
Departament de LSI Universitat Polit`ecnica de Catalunya
Barcelona, Spain
Sonia P´erez
Inst. Sup. Polit´ecnico J. A. Echevarr´ıa Havana, Cuba

Abstract
The notion of architectural connector was developed by Allen and Garland as an important concept for the design of software architectures. In this paper, based on previous work introducing a generic approach for the definition of component-based concepts, we study how architectural connectors and components can be defined for UML2 sequence diagrams as a first step for applying this approach to full UML. A case-study of a small lift system is used to illustrate these ideas.

Introduction
The development of component-based systems and service oriented systems is cur- rently an important area in software engineering. Unfortunately, little work has been dedicated to the modelling and specification phase of this kind of systems. As a consequence most modelling techniques or formalisms lack adequate notions to support the architectural development of component-based systems. See, for instance, [7] for a discussion on how to extend UML with adequate component concepts.
A modelling approach that we consider very interesting is based on the use of architectural connectors [1,13]. In this approach, architectures are built in terms of two kinds of units: components and connectors. Components are not connected directly, but through connectors. Components implement some functionality while connectors describe policies of interaction of the connected components. Originally, the language used in [1,13] for the specification and modelling of components and


1571-0661 © 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.078

connectors was CSP [8]. The work using this approach was followed by Fiadeiro (e.g. see [6]), who (in some sense) generalized the approach by putting it into a categorical context In this case, the modelling language used was the coordination language COMMUNITY.
In [3], we developed a very generic approach for the modelling of component- based systems whose aim was to allow the definition of component concepts asso- ciated to arbitrary formal or semiformal specification methods. The idea was that one could instantiate this generic approach to any arbitrary method, as long as one could prove that it satisfied certain properties. In particular, different instantia- tions were sketched in terms of Petri Nets, graph transformation systems or algebra transformation systems. Later, we generalized this approach by allowing, for in- stance, that components could have several interfaces and adapted it to deal with architectural connectors. The approach is described in detail in [5], but preliminary results were presented in [4].
In the case of UML [12], a de facto standard for many industrial applications, the notion of component in UML 1.4 [2] has a very limited nature, being essentially a kind of syntactic package. In the case of UML 2.0 the situation has improved considerably, however the construction has stil limitations [9]. In this paper, we present the instantiation of our approach to the case of the sequence diagrams of UML2 overcoming these limitations. More precisely, we study how the notions of embedding and transformation (which are key notions in our approach) can be defined. And we show that these notions satisfy the required properties. Especially, the so-called extension and parallel properties.
Based on these results we have defined stereotypes in UML for our components and connectors and, to provide some tool support, we have implemented a plugin for the tool Visual Paradigm. This work is not presented in this paper, but can be found in [11]
A preliminary version of the work presented here was presented in [10]. However, there are important differences between these two versions. On one hand, in [10] only the case of basic sequence diagrams was covered. On the other, in that paper we imposed an important restriction on connectors. In particular, the roles of a connector had to be disjoint. This restriction may be reasonable for many modelling techniques, but it is too severe when dealing with sequence diagrams. Actually, the example that we use to illustrate our approach does not satisfy it: a lifeline is shared by the roles of the given connector. In this sense, eliminating this restriction implied a significant reformulation of the main concept and results, including the introduction of the parallel consistency property.
The paper is organized as follows. In the next section we review our generic approach to components and architectural connectors. The third section describes the instantiation of our approach to the case of basic sequence diagrams in some detail, i.e. diagrams that are not built using the composition operators provided by UML2. In section 4, we extend the instantiation to cover also these operators. In section 5, we present a small case study, a lift system, to show how these concepts can be applied in practice. Finally, in the last section, we draw some conclusions.

A generic framework for architectural components and connectors
In this section we will describe the basic ingredients of our generic framework. More specifically, following the approach introduced in [1], we consider two kinds of constructions: components and connectors. Components are units that provide some kind of services. Informally, a component is a unit consisting of a body and n interfaces, which we call ports following [1]. In the body the services provided by the component are fully described or implemented. On the other hand, a port provides an abstract view of the body i.e. of its behavior and of the services provided. Conversely, we may see the body of a component as a refinement of its interfaces. These refinement relations will be called transformations.
Definition 2.1 (Components) A component COMP  = (B, p1 : P1 =⇒ B, ..., pn : Pn =⇒ B) for n ≥ 0 is given by the body B and a family of ports Pi with port transformations pi : Pi =⇒ B for i ∈ {1, ..., n}. A component is represented by the diagram in Fig. 1.

P1	...	Pn
¸

¸¸¸p1
¸¸¸
pn 
 
z ,j
B

Fig. 1. Diagram of a component


Components are connected through architectural connectors. In particular, a connector is a unit consisting of two or more interfaces, called roles, and a body (defined in terms of the glue in [1]). Each role describes the expected behavior and services provided by the component to which it will be connected, while the body describes the interaction of the components that will be connected through the given roles. In this sense, the body of a connector extends the specifications included in the roles by defining over them an interaction policy. We will say that in a connector the roles are embedded in the body.
Definition 2.2 (Connectors) A connector CON = (B, r1 : R1 → B, ..., rn : Rn → B) for n ≥ 2 is given by the body B and a family of roles Ri with role embeddings ri : Ri → B for i ∈ {1, ..., n}. A connector is graphically represented by the diagram in Fig. 2.

 ¸B,,¸ ¸¸

r1 
    
R1
¸¸¸rn
¸¸¸
...	Rn

Fig. 2. Diagram of a connector

To be able to link a role to a given port, they must be compatible. In particular, to be compatible, the port should be some kind of refinement of the role. Now, be- fore defining the semantics of this kind of composition, we must first specify in detail what are the basic elements (or parameters) that a concrete modelling or specifica- tion framework must provide to allow us to instantiate our generic framework for defining concrete notions of architectural components and connectors.
First of all, the given concrete framework must include a class of specifications or models. In particular, the bodies and the interfaces of connectors and compo- nents are assumed to be models in this class. The given framework should also provide a class of transformations and a subclass of embeddings between models, since embeddings can be seen as a special kind of refinements. However, to define an adequate semantics for the constructions of our generic framework, ensuring the compositionality of the interconnection operations, we must impose some require- ments on the kinds of embeddings and transformations considered for the given specification or modelling formalism.
Embeddings and transformations are assumed to be closed under composition, where this composition is associative and there is a special identity which is neutral with respect to embedding and transformation composition. In addition, we may expect to apply (local) transformations in a larger context. In particular, if we
know that t1 : M1 =⇒ M ' is a transformation of a given model M1 yielding another model M ' , then when M1 is embedded in a larger model M2, it seems reasonable to consider that we should be able to apply locally t1 in the context of M2 yielding
a model M ' which embeds M ' and is a transformation of M2. However, there may
2	1
be some kind of incompatibility between the t1 and the embedding e : M1 → M2:
for instance, t1 may add some new names to M1 but these names may have already a meaning in M2 which is incompatible with their expected role in M ' . As a consequence, we consider that our framework must include a consistency relation
between embeddings and transformations such that the following extension property holds:
Definition 2.3 (Extension Property) For each transformation t1 : M1 =⇒ M ' , and each embedding e : M1 → M2 , such that e and t1 are consistent, there is a
selected transformation t2 : M2 =⇒ M ' , with embedding e' : M ' → M ' , called the
2	1	2
extension of t1 with respect to e, leading to the following extension diagram:

M1	e
) M2

t1	t2
7	7
'	e'
1	)	2
Fig. 3. Extension

It must be pointed out that, in a framework F, given t1 and e as above, there may be several t2 and e', satisfying this extension property. Our assumption means that only one such t2 and e' are chosen, in some well-defined way, as the extension

of t1 with respect to e.
This extension property should be generalized in the following sense. If a given model M embeds a family of models M1,... , Mn and we know that each of these
submodels can be transformed into the models M ' ,... ,M ' , respectively, and if these
1	n
transformations are consistent with each other then we should be able to transform
in parallel all these submodels in the context of M yielding a model M ', which

embeds M ' ... ,M '
and is a transformation of M . More precisely, our framework

1	n
must include a parallel consistency relation defined on families of transformations
with respect to corresponding families of embeddings such that the parallel exten- sion property stated below holds. This notion of parallel consistency of a family of transformations with respect to a family of embeddings is also generic and can be instantiated differently for different specification or modelling techniques. The intuition of parallel consistency should be clear: if two submodels Mi and Mj share a common part, then this part should be refined in a consistent way in the corre-
sponding models M ' and M '. In particular, this means that if the roles are disjoint
i	j
(which will probably happen in many cases) then parallel consistency will probably
hold in a trivial way.
Definition 2.4 (Parallel  Extension  Property)  Given  transformations
{tj : Mj =⇒ M '}j ∈J and embeddings {ej : Mj → M }j ∈J for some finite set J , such that each embedding ej is consistent with the corresponding transformation tj for every j ∈ J and the family of transformations {tj : Mj =⇒ M '}j ∈J is parallel
consistent with respect to the family of embeddings {ej : Mj → M }j ∈J , then there is
a selected transformation t : M =⇒ M ', with embeddings {e' : M ' → M '}j ∈J , called
j	j
the parallel extension of {tj : Mj =⇒ M '}j ∈J with respect to {ej : Mj → M }j ∈J , leading to the parallel extension diagram in Fig. 4, such that parallel extension coincides with extension in the case where J consists just of one index.
M1¸	...	Mn

¸¸¸e1
t1	¸¸¸
en    t
	n

c' z
¸z , s 
c' z

M1 ¸	M	Mn
¸¸¸¸	t
e'  ¸¸¸	  e'
1	zc ,zsn 
M '
Fig. 4. Parallel Extension


Moreover, it should be possible to compose parallel extension diagrams vertically. This means that if t : M =⇒ M ' is the parallel extension of {tj : Mj =⇒ M '}j ∈J with respect to {ij : Mj → M }j ∈J and t' : M ' =⇒ M '' is the parallel extension of
{t ' : M ' =⇒ M ''}j ∈J with respect to {i ' : M ' → M '}j ∈J , as in Fig. 5, then t' ◦
j	j	j	j
t : M =⇒ M '' is the parallel extension of {t ' ◦ tj : Mj =⇒ M ''}j ∈J with respect to
j	j
{ij : Mj → M }j ∈J .
Again, we assume that parallel extension is uniquely defined by the given {tj }j ∈J
and {ej }j ∈J . Now, using parallel composition we are able to define the composition

M1¸	...	Mn

¸¸¸i1
t1	¸¸¸
in    t
	n

c' z	¸z , s 
c' z

M1 ¸	M
¸¸¸i'
Mn
i' 

'	1
1	¸¸¸
'
t	n

c'' z
¸zc ',z s 
c'' z

M1 ¸	M
¸¸¸¸	'
Mn
    

i'' ¸¸¸ t   i''
1	zc ,zsn 
M ''
Fig. 5. Vertical composition of parallel extensions

of components through an architectural connector.
Given a connector CON  = (B, r1, ..., rn), and components COMPi  = (Bi, pi1 , ..., pimi ) with connector transformations coni : Ri =⇒ Pik with 1 ≤ k ≤ mi for i ∈ {1, ..., n} we obtain the connection diagram in Figure 6. Then, the com- position of the connection diagram in Figure 6, is defined in terms of the parallel
extension diagram (1) in Figure 7, where, for every i, ti = pik  ◦ coni. In particular,
the result of the composition of the components COMP1, ..., COMPn by the con-
nector CON with the connection transformations con1, ..., conn is the component
whose body is B' and that includes all the ports r' ◦ pi : Bi =⇒ B' in each
j	j
component COMPi which is not connected to the role ri in the above diagram.
 B,¸,¸ ¸

r1 
    
R1
¸¸¸rn
¸¸¸
...	Rn

con1
cz
P1k1
p1
k1
cz
conn
cz
Pnkn
pnkn
cz	

P 1j1	1
j1
zB 1	...	Bn ¸pc
n
Pnjn

Fig. 6. Connector Diagram

R1 ¸	...	Rn

¸¸¸r1
t1	¸¸¸
rn    t
	n

cz
B1 ¸¸
¸¸¸
¸z , s  cz
B	Bn
t

r'  ¸¸¸	 r'
1	zc ,zsn 
B'
Fig. 7. Composition

Based on this kind of connection diagrams, we can define a notion of architecture as a diagram involving several components and connectors interconnecting them

in a non-circular manner. In [5] we proved that such architectures denote, after the evaluation of all the composition operations involved, a component which is independent on the order of evaluation of these operations.
Definition 2.5 (Component Framework) A component framework F consists of:
A class of models M, including bodies and ports of components and bodies and roles of connectors.
A class of transformations T and a class of embeddings E, with E ⊆ T , such that they are closed under composition. Moreover, this composition is associative, and for every model M there is a special identity which is neutral with respect to embedding and transformation composition.
A consistency relation between transformations and embeddings.
An extension construction for consistent transformations and embeddings accord- ing to definition 2.3.
An extension construction transformations and embeddings according to defini- tion 2.3.
A parallel consistency relation for J -indexed families of transformations with respect to J -indexed families of embeddings.
A parallel extension construction for every J -indexed family of transformations which is parallel consistent with respect to a J -indexed family of embeddings satisfying the properties in definition 2.4.

Components and connectors for basic sequence dia- grams
In this section we will study how to instantiate our generic framework for the case of basic sequence diagrams, i.e. diagrams that are built using just lifelines and interactions between the objects involved. Then defining the instantiation means to define notions of embedding and transformation and showing that they satisfy the required properties.
In the case of sequence diagrams, specifications typically consist of several dia- grams, and not just of a single one, describing different scenarios. As a consequence, the notions of embedding and transformation should be defined on sets of diagrams. However, for simplicity, in this paper we will just define these notions on single dia- grams. It should be clear that the pointwise generalization of these notions to deal with sets is straightforward
Definition 3.1 A sequence diagram S over a set of messages M is a triple (L, LocL,I), where L is the set of lifelines corresponding to the objects that are shown in the diagram; for each l ∈ L Locl is the partially ordered set of locations corresponding to the lifeline l; and I is a set of interactions, where an interaction ε is a triple (loc1, loc2, m) where loc1 and loc2 are locations associated to some lifelines

in L and m is a message in M and such that two interactions never occur simultane- ously, i.e. if (loc1, loc2, m), (loc3, loc4, m') ∈ I, with (loc1, loc2, m) /= (loc3, loc4, m') and loci, locj ∈ Locl, i ∈ [1, 2], j ∈ [3, 4] then i /= j.
Moreover, we assume that sequence diagrams must satisfy that the precedence relation defined over the set of interactions of the diagram, precI , is a partial order, where precS is the reflexive and transitive closure of the least relation satisfying
that given (loc1, loc2, m), (loc' , loc' , m') ∈ I if loci, loc' (i, j ∈ [1, 2]) are in the same
2	j
lifeline and loci < loc' then (loc1, loc2, m), (loc' , loc' , m') ∈ precI .
j	1	2
We have considered that the locations on a lifeline are just partially ordered and not totally ordered. The reason is that in UML 2 one may have co-regions within lifelines, i.e. parts of lifelines whose locations are not considered ordered. A sequence diagram may involve any number of “useless” locations, i.e. locations that do not take part in any interaction.
Definition 3.2 A sequence diagram S = (L, LocL,I) is minimal if for every loca- tion loc ∈ LocL there is an interaction (loc1, loc2, m) ∈ I such that loc = loc1 or, loc = loc2
In what follows, we will assume that all diagrams are minimal.
We will consider that a sequence diagram is embedded into another one if the latter describes the same set of interactions (up to renaming) in the same partial order, perhaps intertwined with some other additional interactions. To be more precise:
Definition 3.3 A message renaming h : M → M ' is an injective mapping on the sets of messages.
Let S be a sequence diagram over M , the renaming of S = (L, LocL,I) through h : M → M ', denoted h(S) is the sequence diagram (L, LocL,I'), where I' is the set of interactions:
{(loc1, loc2, h(m))/(loc1, loc2, m) ∈ I}

Let S = (L, LocL,I) be a sequence diagram over M , S' = (L', Loc' ' ,I') a sequence diagram over M ' and h : M → M ' a message renaming such that L ⊆ L'. An h-based embedding i : S → S' is an L-indexed family of injective mappings t = {il : Locl → Loc' ' }l∈L preserving the order relations (i.e., they must be poset monomorphisms), such that:
For every (loc1, loc2, m) ∈ I, with loc1 ∈ Locl1 and loc2 ∈ Locl2 , we have that
i((loc1, loc2, m)) = (il (loc1), il (loc2), h(m)) ∈ I'.
If m' ∈ h(M ) then for every (loc' , loc' , m') ∈ I' there is (loc1, loc2, m) ∈ I such
1	2
that (il (loc1), il (loc2), h(m)) = (loc' , loc' , m') ∈ I.
1	2	1	2
Note that, according to this definition, all the interactions in the diagram S must be present in the diagram S' exactly in the same order (up to message renaming, but S' may include additional interactions. However, we consider that these additional

interactions should be new, i.e. should not be in h(M ). The intuition is that the embeddings should preservethe behavior. In particular, let us suppose that a diagram describes that, after sending the message a, an object sends a message b and then a message c. We think that this behavior would not be preserved by a diagram describing that the same object sends first the message a, then c, then b and then c. However, we could consider this behavior preserved if in between the sequence a,b,c, another message d is sent which could be considered not visible in S.
It should be obvious that the requirements for embeddings are satisfied. In par- ticular, embeddings are closed under composition and the identity is an embedding. Now, we will define our notion of diagram transformation. In our opinion, when considering refinement relations between sequence diagrams we may consider two different kinds of intuitions. A straightforward one is to consider a refinement relation as an implementation relation, i.e. a sequence diagram is refined by another one if the latter can be seen as an implementation of the former. In particular, if we consider that single interactions (sending messages) are refined or implemented by other sequence diagrams, then we could define that a sequence diagram D1 is refined by another sequence diagram D2 if D2 is the composition of diagrams implementing the interactions in D1. However, this is not the only intuition in our context. In particular, if D2 is a refinement of D1, the latter diagram may be just an abstraction of D2, in the sense that some of the interactions described in the body are hidden in D1 because they are considered irrelevant detail. In particular, this means just that D1 is embedded in D2. Putting these two intuitions together, we have that a transformation is a combination of an “implementation” and an embedding as we will see below. But, first, we need to define an operation for the composition of basic sequence diagrams. In particular, this operation will be used for defining the implementation of sequence diagram by composing the implementations of each
interaction.
Definition 3.4 Given two diagrams S = (L, LocL,I) and S' = (L', Loc' ' ,I') over

a set of messages M, we define the composition S + S'
L
as the diagram over M

(L ∪ L', Loc''	' ,I ∪ I') where for each l ∈ L ∪ L', Loc'' is the poset Locl + Loc' 1 ,
L∪L	l	l
where + denotes disjoint union and all the elements in Locl are considered smaller
than all the elements in Loc'
It may be noted that this composition operation is associative, but not commu- tative.
Definition 3.5 Let L and L' be sets of lifelines such that L ⊆ L', M and M ' sets of messages and S a set of sequence diagrams whose sets of lifelines are included in
L'. Let T be a set of L-typed interactions over M , i.e. a subset of L × L × M . An

implementation I of T by (L', S) is a pair of mappings (I
T → S), such that:
Lines
: L →
2L' ,
IMess :



1 if l is not in L we assume Locl to be the empty set and, similarly, if l is not in L' we assume Loc'' to be
empty

For every lifeline l in L, l ∈ ILines(l)
If l0 /= l1 then ILines(l0) ∩ ILines(l1)= ∅.
If IMess(l0, l1, m)= (L1, Loc1 , I1) then L1= ILines(l0) ∪ ILines(l1)
If I is an implementation and ε = (loc0, loc1, m) is an interaction in the dia- gram S = (L, LocL,I), we define I(ε) as follows: if loc0 ∈ l0 and loc1 ∈ l1 and IMess(l0, l1, m)= S' then I(ε)= S'; otherwise, I(ε) is the diagram consisting only
of the interaction ε.
Let S = (L, LocL,I) be a diagram over M and I an implementation by (L', S) of a set T of L''- typed interactions over M , where L ⊆ L'' then the application of I to S, denoted I(S) is defined as follows. Let ⟨ε1,... , εn⟩ be a sequence of
interactions, with I = {ε1,... , εn}, such that (εj, εk) ∈ precI then j < k; then
I(S)= I(ε1)+ ... + I(εn).
Finally, if S is a set of diagrams over M and I an implementation by (L', S') of T , then the application of I to S, denoted I(S), is the set of all diagrams I(S) such that S ∈ S.
The intuition is, on one hand, that in the refinement of each lifeline other lifelines may be involved which are considered hidden at a higher abstraction level. In this sense, the first condition states that each lifeline is part of its own refinement. The second condition states that a lifeline cannot be involved in the implementation of two different lifelines. On the other hand, the third condition, states that if a (typed) interaction is implemented by a certain diagram, then this diagram includes only the lifelines which implement the lifelines occurring in the interaction. Then, applying an implementation to a diagram means replacing all the interactions by the corresponding diagrams defined by the implementation. Note that we allow to apply an implementation to diagrams whose sets of lifelines do not coincide, but are included, in the set of lifelines implemented by I. Note also that a message renaming h : M → M ', can be seen as a special case of an implementation.
It may be proved that the definition of I(S) is independent of the specific se-
quence of interactions chosen. In particular if ε and ε' are independent interactions then I(ε)+ I(ε') = I(ε')+ I(ε). The reason is that, if the two interactions are independent then the lifelines involved in the interactions are disjoint and, as a
consequence, the sets of lifelines involved in the diagrams I(ε) and I(ε') are also disjoint. In this context, we can define a notion of transformation or refinement over sequence diagrams.
Definition 3.6 Let S = (L, LocL,I) and S' = (L', Loc' ' ,I') be sequence diagrams
'	L	'
over M and M , respectively. A transformation t : S =⇒ S is a pair (I, i), where
I is an implementation by (L', S') of a set T of L-typed interactions over M and i
is an embedding of I(S) into S'.
It should be clear that this notion of transformation satisfies that the identity is a transformation and that embeddings are special cases of transformations. The proof that transformations are closed under composition is also easy. Given trans- formations t1 : S1 =⇒ S2 and t2 : S2 =⇒ S3, with t1 = (I1, i1) and t2 = (I2, i2),

first, we have to define, in an obvious way, the composition of implementations I2 ◦ I1. Then, it is easy to see that there is an embedding from I2 ◦ I1(S1) to S3. Therefore, we just have to prove that extensions and parallel extensions exist for adequate notions of consistency and parallel consistency. We will, first, prove the existence of extensions in three steps. First, we will show that, under adequate conditions, if i1 : S0 → S1 and i2 : S0 → S2 are embeddings then we can define a diagram S3 that embeds S1 and S2. Actually, the construction is a pushout in a category of embeddings, although we will not prove it. The second step will be to show that if i1 : S0 → S1 is an embedding and I2 is an implementation such that of I2(S0)= S2 then we can define an implementation I1 such that I1(S1) embeds S2. From these two properties, we can easily conclude the extension property for basic sequence diagrams.
Definition 3.7 Two embeddings i1 : S0 → S1 and i2 : S0 → S2 are consistent if for all interactions int, int' ∈ I0, if we have that i1(int) ≤ i1(int') and i2(int') ≤ i2(int), then int = int'.
Proposition 3.8 Given two consistent embeddings i1 : S0 → S1 and i2 : S0 → S2
we can deﬁne an extension according to Fig. 8, where i' and i' are also embeddings.
S   i1  S 

i2	'
J i'	J 
S   2  S 
Fig. 8. Extension for embeddings


The proof is quite simple. It is enough to define the diagram S3 = (L3, Loc3
, I3)

by putting together (by means of pushouts) the corresponding components of S0, S1 and S2. The condition in the proposition ensures that the resulting set of interac- tions I3 is a poset.
Definition 3.9 Let h1 : M0 → M1 be a message renaming, let L0 and L1 be sets of lifelines, such that L0 ⊆ L1, let T be a set of L0-typed interactions over M0, and let I be an implementation of T by (L, S) for some given sets of lifelines L and of diagrams S over a set of messages M . Then, we define T ' and I', called
the extensions of T and I with respect to h1 and L1, as follows. T ' is the set of
L1-typed interactions over M1:
T ' = {(l1, l' , h1(m))/(l1, l' , m) ∈ T0
1	1
and I' is the implementation of T ' by (L' + (L1 \ L0), S) be defined as follows:

For every l ∈ L0, I'
(l) = ILines(l) and for every l ∈ (L1 \ L0), I'
= {l}

For every (l1, l' , h1(m)) ∈ T ', I'	(l1, l' , h1(m)) = IMess(l1, l' , m)
1	Mess	1	1

Proposition 3.10 Let Sj = (Lj, Locj
, Ij) be sequence diagrams over Mj, for j =

0, 1, respectively. Let h1 : M0 → M1 be a message renaming, i1 : S0 → S1 an

h1-based embedding, I an implementation of a set T of L0-typed interactions over M0 by (L, S), and let T ' and I' be the extensions of T and I with respect to h1. Then, the diagram I(S0) is embedded into I'(S1).
Proof. [Sketch] According to the definition of I', we have that if ⟨ε' ,... , ε' ⟩ is
1	n
an ordered sequence of the interactions in I1 then I'(S1)= I'(ε1)+ ... + I'(εn).
On the other hand, by definition, we know that for every interaction (l0, l' , m0) ∈
S0, I(l0, l' , m0) = I'(i1(l0), i1(l' ), h1(m0)).  This means that I(S0) is the sum,
0	0
I'(S1) = I'(εj )+ ... + I'(εjm), of a subset of {I'(ε1),... , I'(εn)}. This directly implies the embedding.	 
Before stating the extension property for sequence diagrams, which is a direct consequence of the previous two propositions, we must first define our notion of consistency:
Definition 3.11 An embedding i1 : S0 → S1 and a transformation t2 : S0 =⇒ S' ,
with t2 = (I2, i2), are consistent if i' and i2 are consistent, where i' is the embedding
2	2
whose existence is proved in the previous proposition.
Theorem 3.12 (Extension for basic sequence diagrams)

Let Sj = (Lj, Locj
, Ij), be sequence diagrams over Mj, for j = 0, 1, 2, respec-

tively. Let h1 : M0 → M1 be a message renaming, i1 : S0 → S1 an h1-based embedding, and t2 : S0 =⇒ S2, t2 = (I2, i2) a transformation which is consistent with i1.
Then, there is a diagram S3, such that S2 is embedded into S3 and S3 is a transformation of S1, according to Fig. 9).
S   i1  S 
I	I'
czi'	cz
S   2  S' 

i2	'
J i''	J 
S'   2  S 
2	3
Fig. 9. Extension of diagram transformations

Then, S3 embeds S2 via i'' ◦ i' and reﬁnes S1 via t1 = (I', i' )
2	3
Now, to define parallel extension we first have to define our notion of parallel consistency. A very simple, but restrictive notion which works in many cases would be to ask the roles involved to be disjoint (e.g. [10]). Unfortunately, this restriction would be too strong here, as shown in the example in section 5. In our case, we will require that the implementations underlying the given transformations coincide on the shared elements.
Definition 3.13 (Parallel  consistency)  Given  a  family  of  transformations
{tk : Sk =⇒ S ' }k∈K , with tk = (Ik, ik) for each k, and a family of embeddings

{ik : Sk → S }k∈K for some finite set K We say that the family of transformations tj is parallel consistent with respect to this family of embeddings if for every k1, k2, the following conditions hold:
If lk1 ∈ Lk1 and lk2 ∈ Lk2 and ik1(lk1)= ik2(lk2), then Ik1(lk1)= Ik2(lk2).
Given interactions intk1 ∈ Ik1 and (intk2 ∈ Ik2. If ik1(intk1)= ik2(intk2), then
Ik1(intk1)= Ik2(intk2).

Given interactions intk1, int1'
∈ Ik1 and intk2, int'
∈ Ik2 where i'' (intk1)= 

''	''	'
k1	k2	k1
''	'	'

ik2(intk2) and ik1(intk1)  =  ik2(intk2).	If jk1(intk1)  ≤  jk1(intk1) and
jk2(int' ) ≤ jk2(intk2) then i'' (intk1) = i'' (int' ), where i''  and i''  are

k2	k1
k1	k1
k1	k2

the embeddings defined in Fig. 10
Theorem 3.14 (Parallel extension for basic sequence diagrams) Given a family of transformations {tk : Sk =⇒ S ' }k∈K , with tk = (Ik, jk) for each k, and a family of embeddings {ik : Sk → S }k∈K for some ﬁnite set K, such that they are paralled
consistent and each tk is consistent with respect to each ik, we can deﬁne their
parallel extension t' : S ⇒ S' with embeddings i' : Sk → S' for each k ∈ K, according

to Fig. 10.

S1 ¸	...	Sn

I ¸¸¸i1	in    I
1	¸¸¸	n

c'' z
¸z , s 
c'' z

S1 ¸	S
¸¸¸i''
Sn
i''

1	n 
j1	¸¸¸ I	jn
J'	¸zc'' zj  J'
S1	S	Sn
¸¸i'	i'

1
¸¸¸
j  n 
  

¸zJ' , s 
S
Fig. 10. Parallel extension


Proof. [Sketch] The construction of the parallel extension is similar to the con- struction of the extensions, but slightly more complicated. First, we have to build the implementation I as the union of the implementations Ik. Conditions 1. and
2. of parallel consistency ensure that such a union exist. Then, we have to check that the diagram S'' built by applying the implementation I to S embeds all the diagrams S''. This is straightforward. Finally, we have to ensure that we can build
a parallel extension in the special case that the transformations involved are just
embeddings. In this case, the key property needed to ensure that the resulting set of interactions is partially ordered is condition 3. from parallel consistency. 
To end, we have to prove that our notion of parallel extension satisfies the vertical composition property.
Proposition 3.15 If t : S =⇒ S' is the parallel extension of tk : Sk =⇒ S' , with
1 ≤ k ≤ n, with respect to ik : Sk → S and t' : S' =⇒ S'' is the parallel extension

of t'
: S'
=⇒ S'', with 1 ≤ k ≤ n, with respect to i'
: S'
→ S', as in Fig. 11,

k  '  k
''
'  k	k	''

then t ◦ t : S =⇒ S
is the parallel extension of tk ◦ tk : Sk ⇒ Sk with respect to

' ◦ ek : Sk → S.

S1 ¸	...	Sn

¸¸¸i1
t1	¸¸¸
in    t
	n

c' z
¸z , s 
c' z

S1 ¸	S	Sn
¸¸¸i'	i'

1
1	¸¸¸
'
t	n

c'' z
¸zc' zj 
c'' z

S1 ¸	S
¸¸¸i''
Sn
i''

1	'  n 

¸¸¸¸
t 

zc'' ,zs 
S
Fig. 11. Vertical composition of parallel extensions

Proof. [Sketch] The proof is just routine, using the construction of the parallel extensions.	 
As a consequence, we have shown that basic sequence diagrams are a component framework:
Theorem 3.16 The class of basic sequence diagrams together with the notions in- troduced above of embedding, transformation, consistency, and parallel consistency, and together with the extension and parallel extension constructions form a compo- nent framework.

Components and connectors for sequence diagrams
In this section we will extend the previous instantiation of our generic framework to cover most of UML2 sequence diagrams. In particular, UML2 sequence diagrams are combinations of basic sequence diagrams using a given family of operators. Here we will not cover all the possible operators, but just the ones that we consider more important, for two reasons. On one hand,because of space limitations. On the other hand because we think that considering all kinds of details and variations associated to the given class of diagrams will make the paper too boring and would not add any interesting insights to the problem. Actually, as we will see, our definitions of embedding and transformation are extended in a uniform manner to all the operations considered. In this sense, the reader could easily imagine how to provide similar extensions to other operators.
More precisely,the operators that we will consider in the paper are seq, alt, par and loop. Informally, one may describe the meaning of this operators in terms of the “execution” of the diagrams involved. In particular, seq(S1, S2) specifies the (weak) sequencing of diagrams S1 and S2. Executing alt(S1, S2) means that either S1 or S2 are executed. par(S1, S2) specifies the parallel execution of S1 and

S2. Finally, loop(S) specifies that the interactions defined in S may be repeatedly executed.
UML2 provides a graphical notation for these operators that we will not use. Instead, we will use the simple textual notation presented in the paragraph above. More precisely, we can define general sequence diagrams as follows:
S → B | seq(S1, S2) | alt(S1, S2)
| par(S1, S2) | loop(S)
where S, S1, S2 are metavariables to denote sequence diagrams and B is a metavari- able to denote a basic sequence diagram.
We have defined the notions of embedding and transformation for general se- quence diagrams as the simplest extensions of the corresponding notions for basic sequence diagrams. In particular, embedding and transformation relations will only be defined between diagrams sharing the same structure. This means, for instance, that a diagram S1 will be considered embedded in S2 if, on one hand, S1 and S2 are defined in terms of exactly the same combination of operators and, on the other hand, each basic subdiagram in S1 is embedded in the corresponding subdiagram of S2. Actually, as we will see below, we will keep this structure for denoting the embeddings. The case of transformations is similar. We could have considered a more general definition. For instance, it may seem quite reasonable that S1 is em- bedded in seq(S1, S2). However, according to our definitions presented below S1 is not embedded in seq(S1, S2). There are several reasons for this. The first one is that, if we want that our definitions of embedding and transformation take into account this kind of situations, we would need to provide the formal semantics of sequence diagrams beforehand. Unfortunately, there is no such semantics for UML2 sequence diagrams and is not the aim of this paper to provide such a formal defini- tion. Conversely, it is the aim of this paper to show that our approach can be also applied to semiformal modelling techniques. In addition, we consider that, from a methodological standpoint, it is adequate to require that the interfaces and the body of a component or a connector share the same structure.
Definition 4.1 Given two sequence diagrams S and S' we say that i : S → S' is an embedding if one of the following conditions hold:
S and S' are basic sequence diagrams and i : S → S' is an embedding of basic sequence diagrams.
S = op(S1, S2), S' = op(S' , S' ) and i = op(i1, i2), where op = seq or
1	2
op = alt or op = par, and we have that i1 : S1 → S' and i2 : S2 → S'
are embeddings.
S = loop(S1), S' = loop(S' ) and i = loop(i1), and we have that i1 : S1 → S'
1	1
is an embedding.
There are no other embeddings between sequence diagrams The definition of transformations is similar:

Definition 4.2 Given two sequence diagrams S and S' we say that t : S =⇒ S' is a transformation if one of the following conditions hold:
S and S' are basic sequence diagrams and t : S =⇒ S' is a transformation of basic sequence diagrams.
S = op(S1, S2), S' = op(S' , S' ) and t = op(t1, t2), where op = seq or
1	2

op = alt or op = par, and we have that t1 : S1 =⇒ S'
and t2 : S2 =⇒ S'
are

transformations.
S = loop(S1), S' = loop(S' ) and t = loop(t1), and we have that t1 : S1 =⇒ S'
1	1
is a transformation.
There are no other transformations between sequence diagrams
It should be obvious that the requirements for embeddings and transformations are satisfied. In particular, both embeddings and transformations are closed under composition, embeddings are special cases of transformations, and the identity is an embedding.
We can define in a similarly the properties of consistency and parallel consis- tency:
Definition 4.3 An embedding i : S → S' and a transformation t : S =⇒ S'' are consistent if and only if the following conditions hold:
If S, S' and S'' are basic sequence diagrams then i and t must satisfy the consistency condition for basic sequence diagrams.
If i = op(i1, i2) and t = op(t1, t2), where op = seq or op = alt or op = par, then i1 and t1, and i1 and t1 must be consistent.
If i = loop(i1) and t = loop(t1), then i1 and t1 must be consistent.
Definition 4.4 A family of embeddings {ik : Sk → S}k∈K and a family of trans- formations {tk : Sk =⇒ S' }k∈K are parallel consistent if and only if the following

conditions hold:
If each Sk, S'
and S are basic sequence diagrams then {ik}k∈K and {tk}k∈K

must satisfy the parallel consistency condition for basic sequence diagrams.
If each ik = op(i1k, i2k) and t = op(t1k, t2k), where op = seq or op = alt or op = par, then {i1k}k∈K and {t1k}k∈K, and {i2k}k∈K and {t2k}k∈K must be parallel consistent.
If each ik = loop(i1k) and tk = loop(t1k), then {t1k}k∈K , and {i2k}k∈K must be parallel consistent.
To finish proving that sequence diagrams are a component framework we have to prove that they satisfy the extension and parallel extension properties:
Theorem 4.5 The class of sequence diagrams satisfy the extension and paralle extension properties
Proof. [Sketch] Let us show the existence of extensions. We proceed by induction. Given consistent i : S → S' and t : S =⇒ S'', the case where S, S' and S'' are

basic diagrams has already be proven in Theorem 3.12.  If i = seq(i1, i2) and t = seq(t1, t2) then, by induction, we know that we can define the extensions of S1, S2 of i1 with respect to t1 and i2 with respect to t2, respectively.  Then
S'' = seq(S1, S2) is the extension of i with respect to t. The case of the other operators is similar. The construction of parallel extension is also similar. 
Moreover, the vertical composition property for parallel extensions for basic diagrams trivially implies this property for sequence diagrams. As a consequence, we have:
Theorem 4.6 The class of sequence diagrams together with the notions introduced above of embedding, transformation, consistency, and parallel consistency, and to- gether with the extension and parallel extension constructions form a component framework.
An example
In this section we will present a small example of the use of this kind of component system. For brevity we will only use sequence diagrams, which means that the corresponding class diagrams will remain implicit. The example describes a lift system including just one lift. However, a system including several lifts would not be difficult to describe using the same components, but a more complex connector. We consider that a lift system can be built (at a certain level of abstraction) out of three kinds of components: the elevators themselves, including the doors and the engines to move the lift; the buttons that are located inside the lift; and the set of buttons which are located in each floor (for simplicity we will consider that there is only one button per floor and not two, as it usually happens). Also for simplicity, will only describe the normal scenario describing the system, i.e. we will
not consider abnormal situations. Now, let us model these components. The body of the elevator can be described by the diagram in figure 12
Scheduler	Elevator	Doors	Engine






{elevator at floor X}







Fig. 12. Elevator Body

This diagram describes the following scenario. Someone, which we have called the scheduler, tells the elevator to move to floor X. This causes the doors to close

and when they are closed (an ack is received), the elevator sends a message to the engine to move to floor X. When the elevator is at floor X, the doors open and the scheduler is acknowledged that the operation has been completed. Now for the interface there are details that can be abstracted from this diagram. In particular, for the use (as a component) of the elevator, we do not need to know about how doors are opened or how the engine works. So, the elevator interface is just the diagram in figure 13.
Scheduler	Elevator



{elevator at floor X }

Fig. 13. Elevator Interface

Obviously, this interface is refined by the body of the component (actually the transformation is just an embedding). Now, the body of the component describing the buttons inside the lift is presented in figure 14.
User	Button	Lights	Elevator






{elevator at floor X}






Fig. 14. Buttons Body

In particular, when a user presses the button to go to floor X, the light associated to that button is switched on and a message is sent to the elevator to move to floor X. When the elevator is at that floor the light will be switched off. We have considered that it is the elevator who sends the message to switch off the light. Instead, we may have considered that when elevator is at floor X, it will send an acknowledgement to the button object who, then, will switch off the light. Now, according to this body diagram, the interface describing the connection to the interacting components can be seen in figure 14.
Again, the refinement between this interface and the body of the component is just an embedding. The component associated to the set of buttons which are located in each floor could be described exactly in the same way as the previous one. Note that this would not have been true if there would be two buttons per floor.
Now, if we want to build a lift system, including just one lift, we need to connect these three components. The body of this connector would consist of three diagrams,

Button	Lights	Elevator






{elevator at floor X}





Fig. 15. Buttons Interface

where two of them would be almost identical. In particular the first diagram (see figure 16) describe that, when a request is received from some set of buttons (for instance the cabin buttons located inside the elevator, C-buttons), this request is received by a scheduler (which will probably store the request in some queue). A similar diagram would be needed to describe the situation when the request is received from the buttons located in the floors. We have not shown this diagram. The third diagram (see figure 17) describes that, when the first request to serve refers to floor X, the scheduler sends a message to the elevator to go to that floor. When the elevator acknowledges that the elevator is at floor X, then the scheduler asks the two sets of buttons to switch off the lights corresponding to that floor.
C_buttons	Scheduler

Fig. 16. Connector Body 1


C_buttons	F_buttons	Scheduler	Elevator





{elevator at floor X}







Fig. 17. Connector Body 2

Now, the connector would have three interfaces, the first two which are again almost identical would consist of two diagrams. The first one would coincide with the first body diagram (figure 16). The second one, see figure 18, describes the interaction for switching off the lights upon arrival at a given floor. The third interface describes the interaction with the elevator and would be identical to the elevator interface (figure 13).

C_buttons	Scheduler

{elevator at floor X}



Fig. 18. Connector Interface 2

The composition of the connector with the three components would provide the expected global specification of the lift system. The connection of the elevator interface with the corresponding connector’s interface is trivial, since both inter- faces are equal. In the case of the buttons, the connection must be made via a transformation. In particular, we would need to say that the C-buttons lifeline in the connector’s interface is implemented in terms of the lifelines Button and Lights from the button component; and, similarly, the lightOff(X) message is implemented by a diagram that includes only one interaction, consisting of sending the message lightOff(X) from the Scheduler to the Lights lifeline.
Conclusion
In this paper, using the generic framework presented in previous work (e.g., [3,4,5], we have shown how to define architectural connectors and components, as intro- duced in [1], for UML2 sequence diagrams.
In particular, first we studied how we can define connectors and components in the case of basic sequence diagrams, defining and studying the notions of embedding and transformation, which are needed for the application of our generic approach. Then we extended the constructions to the class of general sequence diagrams.
This work may be considered a first step in the definition of these concepts for full UML. In this sense, we think that the ideas presented in this paper could be useful when dealing with the rest of UML diagrams. Actually, as said in the introduction, based on our results we have defined stereotypes in UML for our components and connectors and, to provide some tool support, we have implemented a plugin for the tool Visual Paradigm. Unfortunately, due to lack of space, it was impossible to present this work in this paper, but can be found in [11]
Acknowledgement
This work is partially supported by the Spanish project GRAMMARS (TIN2004- 07925-C03-01). The stay of Sonia P´erez Lovelle in Barcelona was supported by the European Alfa Net CORDIAL II (AML/B7-311-97/0666/II-0021-FA).

References
R. Allen, D. Garlan. A Formal Basis for Architectural Connection. In ACM TOSEM ’97, pp. 213–249.
J. Cheesman, J. Daniels. UML Components. Addison-Wesley, 2001.

H. Ehrig, F. Orejas, B. Braatz, M. Klein, M. Piirainen. A Generic Component Framework for System Modeling. In Proc. FASE 2002, Springer LNCS 2306 (2002), pp. 33–48.
H. Ehrig, J.Padberg, B. Braatz, M. Klein, M. Piirainen, F. Orejas, S. Perez, E. Pino. A Generic Framework for Connector Architectures based on Components and Transformations. Proc. FESCA 2004, Barcelona.
H. Ehrig, M. Klein, F. Orejas J.Padberg, S. Perez, E. Pino. A Generic Approach to Connector Architectures. Barcelona and Berlin (2007). Submitted for publication.
J.L. Fiadero, A. Lopes Semantics of Architectural Connectors. Proc TAPSOFT ’97, Springer LNCS 1214 (1997), pp. 505–519.
David Garlan, Shang-Wen Cheng, Andrew Kompanek: Reconciling the needs of architectural description with object-modeling notations. Sci. Comput. Program. 44(1): 23-49 (2002)
C. A. R. Hoare: Communicating Sequential Processes Prentice-Hall 1985
James ivers, Paul Clements, David Garlan, Robert Nord, Bradley Schmerl, Jaime Rodrigo Oviedo Silva: Documenting Component and Connector Views with UML 2.0. Carnegie-Mellon Univ. Tech. Report CMU/SEI-2004-TR-008, 2004.
Fernando Orejas, Sonia Perez: Towards Architectural Connectors for UML, in Formal Methods in Software and Systems Modeling, Springer Lecture Notes in Computer Science 3393 (2005) pp. 352–369
Sonia P´erez Lovelle. Uso y extensin de UML para la especificacin y chequeo de consistencia en el empleo de la arquitectura de componentes genricos. PhD Thesis, La Habana 2007.
J. Rumbaugh, I. Jacobson, G. Booch. The Unified Modeling Language Reference Manual. Addison Wesley (1999).
Mary Shaw and David Garlan Software Architecture: Perspectives on an Emerging Discipline Prentice Hall, 1996
A.M. Zaremski, J.M. Wing. Specification Matching of Software Components. In ACM TOSEM ’97, pp. 333–369.
