	Electronic Notes in Theoretical Computer Science 174 (2007) 113–133	
www.elsevier.com/locate/entcs

Decidability of a Hybrid Duration Calculus
Thomas Bolander1
Dep. Informatics and Mathematical Modelling Technical University of Denmark
Jens Ulrik Hansen2
Dep. Mathematics University of Copenhagen, Denmark
Michael R. Hansen3
Dep. Informatics and Mathematical Modelling Technical University of Denmark

Abstract
We present a logic which we call Hybrid Duration Calculus (HDC). HDC is obtained by adding the following hybrid logical machinery to the Restricted Duration Calculus (RDC): nominals, satisfaction operators, down-arrow binder, and the global modality. RDC is known to be decidable, and in this paper we show that decidability is retained when adding the hybrid logical machinery. Decidability of HDC is shown by reducing the satisfiability problem to satisfiability of Monadic Second-Order Theory of Order. We illustrate the increased expressive power obtained in hybridizing RDC by showing that HDC, in contrast to RDC, can express all of the 13 possible relations between intervals.
Keywords: Duration calculus, hybrid logic, decision methods, monadic second order theory of order.


Introduction
In this paper, we consider a hybrid propositional interval logic and a decision pro- cedure for it.
Propositional interval logics are rather expressible, and often undecidable, and they appear in various forms in different scientific branches, e.g. computer science,

1 Email: tb@imm.dtu.dk. The work is partially funded by the Danish Natural Science Research Council in connection with the HyLoMOL project.
2 Email: m00juh@math.ku.dk
3 Email: mrh@imm.dtu.dk. This work is partially funded by The Danish Council for Strategic Research under project MoDES.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.029

artificial intelligence, philosophy, and natural language understanding. We refer to
[14] for a road map over interval logics.
As an illustration of the expressiveness, the propositional interval logic HS [16] with unary modalities begins, ends and their inverses has been shown highly unde- cidable for a collection of classes of interval models. Aiming at decidability results either the formulas or the models or both should be restricted, and in the work on Propositional Neighborhood Logic [4], for example, modalities for left and right neighborhoods only are considered, and a decidability result is shown for a subset with one of the neighborhood modalities only.
A starting point of our work is Duration Calculus (abbreviated DC), which is an interval logic introduced by Zhou, Hoare and Ravn [28] as an extension of Interval Temporal Logic (ITL) by Halpern, Moszkowski and Manna [15]. The introduction of DC is motivated by case studies of real-time systems, e.g. [24], and DC can be used to reason about models of such systems at a high level of abstraction, see
e.g. [26]. A distinctive feature of DC is that one can express and reason about the duration of a state in a system, where the duration of a state in an interval is the accumulated presence time of the state in that interval. Unfortunately, even simple propositional subsets of DC formulas are undecidable [27]. Decidable subsets of DC are considered for example in [27,11,12,13,17,20].
In DC, the underlying time domain is continuous, modelled by the set of non- negative real numbers R≥0. The atomic formulas concern state variables, which are functions of the form:
P : R≥0 → {0, 1}.
The intuition is that P (t) = 1 if and only if, the system is in state P at time t.
In this paper, we consider the decidable subset RDC from [27], having only atomic formulas of the form [[S||, where S is a Boolean combination of state variables modelling a combined state of the system. The formula holds on an non-point interval if S(t) = 1 through the interval, except for isolated points.  Hence in
DC, a rather restricted form of model classes is considered, and RDC has a rather restricted collection of atomic formulas. For example, if [[S|| holds on an interval, then it holds on all non-point sub-intervals as well.
Furthermore, DC is based on the chop modality of ITL only. The formula ϕ-ψ holds for an interval [s, t] iff, there is a point u ∈ [s, t], such that ϕ holds on [s, u] and ψ holds on [u, t], as illustrated in the following figure:
ϕ-ψ
s¸	x`u	˛t
`	˛ϕ¸	x`	˛ψ¸	x

These restrictions on models and formulas suffice to guarantee decidability, and in [27], this is shown by reducing the satisfiability problem to the emptiness problem for regular languages. The decidability results are obtained for both a continuous- time domain and a discrete-time domain. Unfortunately, seemingly insignificant

extensions of RDC yield undecidable subsets, which is also shown in [27].
The main idea of the present work is to consider a hybrid logical version of RDC achieving more expressiveness while preserving decidability. In particular, we add nominals to RDC, where a nominal in our case names a specific interval and we add a down-arrow binder, which provides a reference to the current interval in a formula. Furthermore, we add the global modality which makes any interval reachable from any other interval. In this paper, we establish decidability results for RDC extended by these hybrid elements.
When adding nominals to the logic it becomes difficult to extend the original framework based on regular languages to achieve decidability in this new setting. Instead we follow the technique used in [23], where decidability of RDC is shown by a translation of RDC formulas to Monadic Second-Order Theory of Order. A similar technique is used in DCVALID [20] and in [21]. In DCVALID discrete-time RDC with suitable extensions, e.g. quantification over state variables, is translated to monadic second-order logic over finite strings, which is a slight variant of the weak monadic second-order theory of one successor (WS1S) [5,9]. This second- order theory is decidable and used for instance in the MONA system [19].
In this paper we establish a decidability result for both discrete and continuous time hybrid RDC, by establishing translations to monadic second order theory of order. For discrete time, we exploit that it is decidable whether a sentence in this second-order theory is satisfiable in a natural number structure [5], and for continu- ous time we exploit that it is decidable whether a second-order sentence is satisfiable in a signal-structure [23]. Furthermore, we illustrate the extra expressiveness of the hybrid version of RDC.

Restricted Duration Calculus
In this section we define the syntax and semantics of Restricted Duration Calcu- lus (RDC). RDC is a well-known decidable fragment of duration calculus, see e.g. [27,17,20]. In this paper we consider RDC both with a continuous-time semantics and with a discrete-time semantics.

Syntax of RDC
The syntax for RDC is constructed on the basis of a countable collection of state variables denoted by P, Q,.   The syntactical categories for states expressions, de-
noted by S, S1, S2,... and formulas, denoted by ϕ, ψ,.  are defined by the following
abstract syntax:
S ::= 0 | 1 | P | ¬S1 | S1 ∨ S2 ϕ ::= [[S|| | ¬ϕ | ϕ ∨ ψ | ϕ-ψ.
In state expressions as well as in formulas we will assume the standard abbreviations for the propositional connectives.

Continuous-time semantics of RDC
An interpretation I associates a function
PI : R≥0 → {0, 1}
with every state variable P . We impose the ﬁnite variability restriction that P has at most a finite number of discontinuity points in any interval [s, t] ⊆ R≥0.
The semantics of a state expression S, given an interpretation I, is a function:
I[[S]] : R≥0 → {0, 1} ,
defined inductively on the structure of state expressions by:
I[[0]](t)	= 0	I[[1]](t)	= 1
I[[P ]](t)	= PI(t)

⎧⎨ 0 if I[[S]](t)=1 
⎧⎪⎪⎨ 1 if I[[S1]](t)=1 or

⎩ 1 if I[[S]](t)=0 
⎪⎪⎩ 0 otherwise.


The semantic relation I, [t, u] |= ϕ is defined recursively, where I is an interpreta- tion, [t, u] is an interval, and ϕ is a formula.

I, [t, u] |= [[S||	iff	u > t and I[[S]](s)= 1 almost everywhere on [t, u]
I, [t, u] |= ¬ϕ	iff	I, [t, u] |= ϕ
I, [t, u] |= ϕ ∨ ψ  iff	I, [t, u] |= ϕ or I, [t, u] |= ψ
I, [t, u] |= ϕ- ψ iff	for some v ∈ [t, u]: I, [t, v] |= ϕ and I, [v, u] |= ψ.
The term “almost everywhere” in this context means except in a finite number of points. Whenever I, [t, u] |= ϕ holds we say that ϕ is true in [t, u] wrt. I. A formula ϕ is said to be valid if I, [t, u] |= ϕ holds for all interpretations I and all intervals [t, u]. Furthermore, a formula ϕ is satisfiable if I, [u, v] |= ϕ, for some interpretation I and interval [t, u].
Discrete-time semantics of RDC
The discrete-time semantics of RDC is defined as in [27,26]. It only differs from the continuous-time semantics defined above by the addition of the following restric- tions:
We only consider intervals [t, u] ⊆ R≥0 with natural number end points, that is, with t, u ∈ N.
We only consider interpretations I such that the discontinuity points of PI are in N.

We only allow natural number chop points, i.e. the semantic relation for chop is:
I, [t, u] |= ϕ- ψ iff for some v ∈ [t, u] ∩ N: I, [t, v] |= ϕ and I, [v, u] |= ψ.
Apart from this everything is as in the continuous-time case. In the following, we will refer to RDC with the continuous-time semantics as continuous-time RDC and RDC with the discrete-time semantics as discrete-time RDC. An interpretation in continuous-time RDC will be referred to as a continuous time interpretation and an interpretation in discrete-time RDC will be referred to as a discrete-time interpretation.

RDC ∗: A simpliﬁcation of RDC
Before hybridizing duration calculus we will make a couple of simplifications to the language of RDC. The formulas of this simplified language, called RDC∗, has the following syntax:
ϕ ::= P | π | ¬ϕ | ϕ ∨ ψ | ϕ- ψ , 
where P is a state variable. As for RDC, we will define both continuous-time and discrete-time semantics for RDC∗. We consider the continuous-time case first.
Continuous-time semantics of RDC∗
A continuous-time interpretation I of RDC∗ is as for RDC. The semantic relation for continuous-time RDC∗ is defined recursively below, where I is an interpretation, [t, u] ⊆ R≥0 is an interval, and ϕ is a formula of RDC∗. We use the same symbol
|= for the semantic relation of RDC∗ as we did for RDC.

We will use the following abbreviations for formulas in RDC∗:

df
T	= π ∨ ¬π	T is a tautology
ϕ =df T -(ϕ- T)	means: ϕ holds on some subinterval.
The dual modalities are defined in the usual manner.
Embedding continuous-time RDC in continuous-time RDC ∗
We will now show that continuous-time RDC∗ has the same expressive power as continuous-time RDC. First we define a mapping ·∗ from the formulas of RDC into

formulas of RDC∗ recursively by:

We then have the following result.
Lemma 2.1 For all RDC formulas ϕ, all continuous-time interpretations I, and all intervals [t, u] ⊆ R≥0:
I, [t, u] |= ϕ∗	iff	I, [t, u] |= ϕ.

Proof. The proof is by induction on the structure of ϕ. We will only consider the case where ϕ has the form [[¬S||. The case where ϕ has the form [[S1 ∨ S2|| can be treated in a similar manner and the rest of the cases are trivial. For the case [[¬S|| of ϕ we get that I, [t, u] |= [[¬S||∗ holds iff I, [t, u] |= ¬π∧ ¬[[S||∗. This again holds
iff t < u and I, [t, u] |= ¬(T -[[S||∗ - T). By the semantics, this holds iff t < u and there is no subinterval [t', u'] of [t, u] s.t. I, [t', u'] |= [[S||∗. By induction hypothesis we can now replace [[S||∗ by [[S|| in this last formula. Thus I, [t, u] |= [[¬S||∗ holds iff t < u and there is no subinterval [t', u'] of [t, u] s.t. I, [t', u'] |= [[S||. Using the semantics again, the latter condition holds iff I[[S||(x) is equal to 0 almost everywhere on [t, u]. This in turn holds iff t < u and I, [t, u] |= [[¬S||. This proves the required equivalence in the case where ϕ has the form [[¬S||.	 
The lemma shows that truth is preserved under the translation ·∗ from RDC into RDC∗. Since the translation replaces Boolean connectives occurring in state expressions by modalities, we can conclude that such Boolean connectives semanti- cally actually behave like modalities.
The lemma proves the simpler language RDC∗ to have the same expressive power as RDC in the continuous-time case.

Discrete-time semantics of RDC∗
The semantics for discrete-time RDC∗ is given in a similar manner to the discrete- time semantics of RDC. It is not difficult to see that Lemma 2.1 must hold for discrete time as well. Thus RDC∗ also has the same expressive power as RDC in the discrete-time case. Since RDC∗ is in both the discrete-time and the continuous-time case a simpler language with the same expressive power as RDC, we can without loosing anything choose to work within RDC∗ rather than RDC. This is what we will do in the following.
Even in a seemingly simple fragment of duration calculus such as discrete-time RDC∗, some real-time properties are expressible. Observe first that the formula l = 1, denoting that the length of the current interval is 1, can be represented as

follows:

df
l =1	=

¬π ∧ ¬(¬π - ¬π) .

Furthermore, the simple notions of durations are expressible in discrete-time RDC
and hence also in discrete-time RDC∗, e.g. let S = 1 be the formula which is true on [s, t] of a given interpretation I if
∫ t


This formula is expressible in discrete-time RDC as follows:
(π ∨ [[¬S||) -([[S||∧ l = 1) -(π ∨ [[¬S||) .
Thus it can also be expressed in RDC∗ by using the ·∗ translation and the definition of the formula l = 1. Notice that the above two formulas are not expressible in continuous-time RDC, see for example [27,26]. For further discussion about the expressibility of RDC we refer to [26].
Hybrid Duration Calculus (HDC)
In this section we give syntax and semantics for a hybrid version of RDC∗. We will call this logic hybrid duration calculus, abbreviated HDC.
Syntax of HDC
The language of HDC is an extension of the language of RDC∗. First of all, we extend the language of RDC∗ with a countable collection of symbols called nominals. We use a, b,... to range over nominals. In the semantics, a nominal will name one and only one interval. Furthermore, we extend the language with a satisfaction operator a : for each nominal a, with the global modality E and with the down- arrow binder ↓.
The grammar of HDC is as follows:
ϕ ::= P | π | ¬ϕ | ϕ ∨ ψ | ϕ- ψ | a | a : ϕ | Eϕ | ↓a.ϕ .
The intuition concerning the added formulas are: The formula a holds at the specific interval named by a only; the formula a : ϕ holds if ϕ holds on the interval named by a; Eϕ holds if there is some interval where ϕ holds; and ↓a.ϕ holds if ϕ holds under the assumption that a names the current interval. To limit the number of required
parentheses, we will use the following precedence relation on the connectives: the down-arrow binders ↓a have the lowest precedence; -, ∨ and ∧ have the next lowest precedence; ¬, E and the satisfaction operators a : have the highest precedence.
Continuous-time semantics of HDC
In order to give continuous-time semantics for HDC, we introduce the notion of an
assignment G that associates a unique interval [ta, ua] ⊆ R≥0 with each nominal a.

An interpretation I for continuous-time HDC is simply as for continuous-time RDC. For interpretations I, assignments G, intervals [t, u] ⊆ R≥0, and HDC formulas ϕ we can then define the semantic relation I, G, [t, u] |= ϕ for continuous-time HDC recursively by:

I, G, [t, u] |= π	iff	u = t
I, G, [t, u] |= P	iff	u > t and PI(t)=1 almost everywhere on [t, u]
I, G, [t, u] |= ¬ϕ	iff	I, G, [t, u] |= ϕ
I, G, [t, u] |= ϕ ∨ ψ  iff	I, G, [t, u] |= ϕ or I, G, [t, u] |= ψ
I, G, [t, u] |= ϕ- ψ iff	for some v ∈ [t, u]: I, G, [t, v] |= ϕ and I, G, [v, u] |= ψ
I, G, [t, u] |= a	iff	G(a)= [t, u]
I, G, [t, u] |= a : ϕ	iff	I, G, G(a) |= ϕ
I, G, [t, u] |= Eϕ	iff	for some interval [v, w]: I, G, [v, w] |= ϕ
I, G, [t, u] |=↓a.ϕ	iff	I, G[ a := [t, u] ], [t, u] |= ϕ , 
where G[ a := [t, u] ] is the assignment that assigns [t, u] to a and agrees with G on all other nominals. Note that the first five clauses above are simply the semantic clauses for continuous-time RDC∗ with the assignment G added on the left-hand side of |=.
Expressivity of HDC
We will give a couple of examples showing the added expressivity gained from hybridizing RDC. First of all, the hybridization of RDC allows us to define the basic neighborhood modalities in the logic, as shown in the following.
Propositional neighborhood logic
The basic neighborhood modalities are ♦L and ♦r with the following semantic clauses:
I, [t, u] |= ♦Lϕ iff  I, [s, t] |= ϕ for some s ≤ t
I, [t, u] |= ♦rϕ iff  I, [u, v] |= ϕ for some v ≥ u.
L and ♦r are the modalities of the first-order neighborhood logic NL [25]. Here we will only consider the propositional fragment PNL of NL, which is exactly like RDC except that the chop operator has been replaced by ♦L and ♦r. We will show that HDC contains PNL, that is, PNL can be embedded in HDC. The embedding τ of PNL in HDC translates the neighborhood modalities in the following way

τ (♦Lϕ) = ↓a.E(ϕ - a)
τ (♦rϕ) = ↓a.E(a - ϕ) .
The defining clauses for τ on all other formulas of PNL are identical to the clauses for the definition of the translation ·∗. It is easy to check that τ must preserve validity, and thus that it provides us with an embedding of PNL in HDC. This proves









Fig. 1. The 13 possible relations between two intervals a and b.




HDC to be more expressive than standard RDC, since RDC can not express the neighborhood modalities [26]. There is a simple intuitive reason why standard RDC can not express the neighborhood modalities: The chop operator is a contracting modality, that is, it provides only access to inside parts (subintervals) of a given interval. The neighborhood modalities are however expanding modalities, that is, modalities that give access to outside parts of a given interval. Of course expanding modalities such as in PNL can not be encoded in a logic such as RDC that only contains contracting modalities.


Allen’s interval relations
We will now show that all 13 possible relations between a pair of intervals can actu- ally be expressed in HDC. These 13 relations—known as Allen’s interval relations after [1]—are presented in Figure 1. We have already shown that the relations meets and met by can be expressed in HDC: These are the right and left neighborhood modalities, respectively, introduced above (a : ♦rb means a meets b and a : ♦Lb means a is met by b). In Figure 2 we show how each of the 13 relations can be expressed in HDC. In the representing formulas, a and b are nominals denoting the two intervals in question.
It is a simple exercise to check that the translations into HDC given in Figure 2 are all correct. Let us demonstrate the case of the relation a overlaps b as an example (the most complex one). We need to show the following equivalence:


I, G, [t, u] |= E(↓c.¬π ∧ a : (¬π - c) ∧ b : (c - ¬π)) ⇔ G(a) overlaps G(b)	(1)


Fig. 2. Representation in HDC of the 13 possible relations between intervals.
Using the semantics of HDC we get:
I, G, [t, u] |= E(↓c.¬π ∧ a : (¬π - c) ∧ b : (c - ¬π))
⇔ ∃ proper interval [v, w]: I, G[c := [v, w]], [v, w] |= a : (¬π - c) ∧ b : (c - ¬π)
⇔ ∃ proper interval [v, w]: I, G[c := [v, w]], G(a) |= ¬π - c and
I, G[c := [v, w]], G(b) |= c - ¬π . 
Thus, the left hand side of (1) holds if and only if there exists a non-point interval G(c) such that the interval G(a) can be chopped into a non-point interval followed by G(c), and G(b) can be chopped into G(c) followed by a non-point interval. This is of course equivalent to saying that G(a) overlaps G(b), where G(c) denotes the intersection between G(a) and G(b).
Of the 13 Allen relations, RDC can only capture 4 (finished by, contains, equals, started by), since these are the only ones that give rise to contracting modalities, which, as noted in the previous section, are the only ones that RDC can express.
Example 3.1 Let us a give a simple example of what can be expressed in HDC using the Allen relations. First note that since HDC contains both the down-arrow binder ↓ and the global modality E, we can define both existential and universal quantifiers in HDC. In the case of the existential quantifier, we simply define an
expression of the from ∃aϕ to be an abbreviation for the HDC formula ↓b.E(↓a.b : ϕ). It is easy to check that by this definition, the formula ∃aϕ receives its intended interpretation. In the following we will use the expression a⟨O⟩b as an abbreviation

for the formula defining the property a overlapped by b as given in Figure 2. Now consider a touch sensitive lamp. Let Off and On be state variables expressing whether the lamp is turned off or on, and let Touched be a state variable expressing that the lamp is touched. Then we can express that if the lamp turns on at some instant t, then there must be a neighborhood time interval around t in which the lamp is touched:
(Off -(a ∧ On)) → ∃b(a⟨O⟩b ∧ b : Touched) .
Note that named reference to the time instant at which the lamp turns on is ob- tained by the occurrence of the nominal a in the antecedent of the formula. The neighborhood interval in which the lamp is touched is named by the nominal b existentially quantified in the consequent.

Discrete-time semantics of HDC
The discrete-time semantics of HDC is easily defined along the line of Sect. 2.3. It suffices to note that a discrete-time assignment of HDC must map all nominals into intervals with natural number end points. HDC with discrete-time semantics will be referred to as discrete-time HDC.

Monadic second-order theory of order
The following presentation of monadic second-order theory of order, named L<, is
based on [23].

Syntax of L<
The formulas are constructed from the following collection of symbols:
First-order variables ranged over by x, y, z,.. ..
Second-order variables ranged over by P, Q, X,.. .. The formulas are generated from the following grammar:
ϕ ::= x < y | x ∈ P | ϕ ∨ ψ | ¬ϕ | ∃xϕ | ∃Pϕ .

Semantics of L<
A structure K = (A, B, <) for L< consists of a set A partially ordered by < and a set B of Boolean-valued functions from A. An element b ∈ B can also be considered a, possibly infinite, subset of A: {a ∈ A : b(a)= true}.
An interpretation I associates a member PI of B to every second-order variable
P . A valuation ν is a function assigning a member ν(x) of A to every first-order
variable x.

The semantic relation I,ν |= ϕ is then defined by:
I,ν |= x < y iff ν(x) < ν(y)
I,ν |= x ∈ P iff ν(x) ∈ PI
I,ν |= ¬ϕ	iff I,ν |= ϕ
I,ν |= ϕ ∨ ψ iff I,ν |= ϕ or I,ν |= ψ
I,ν |= ∃xϕ	iff for some a ∈ A: I, ν[x := a] |= ϕ
I,ν |= ∃Pϕ iff for some b ∈ B: I[P := b],ν |= ϕ . 
In the following we will assume that we have standard abbreviations for derived relations, propositional connectives and quantifiers. In particular, as we will just consider sets A with a linear order, we use the following abbreviations:

df	df
x ≥ y = ¬(x < y)	and	x = y = x ≥ y ∧ y ≥ x . 

Decidability results for L<
We shall exploit the following two decidability results for L< to obtain our decid- ability results for HDC. The first result is a classical result by Buchi, while the second is a result by Rabinovich [23] for so-called signal structures corresponding to interpretations of continuous-time RDC.
Let ω denote the L< structure (N, 2N, <), where 2N denotes the set of Boolean- valued functions on natural numbers. The logic L< interpreted over the structure
ω will be denoted L<(ω).
Theorem 4.1 ([5]) L<(ω) is decidable.
A Boolean-valued function h from R≥0 is called a signal [23] if there exists an unbounded increasing sequence τ0 = 0 < τ1 < τ2 < ··· < τn < ··· such that h is constant on every open interval ]τi, τi+1[,i ≥ 0. Notice that a signal corre- sponds to a continuous-time interpretation of a state variable in duration calculus. Let SIGNAL denote the set of all signals, and let Sig denote the signal structure (R≥0, SIGNAL, <). The logic L< interpreted over the structure Sig will be denoted
L<(Sig).
Theorem 4.2 ([23]) L<(Sig) is decidable.

Translation of HDC to L<: Discrete time
In this section we show how to translate discrete time HDC to L<(ω).
Our translation is strongly inspired by the translation of Quantified Discrete- Time Duration Calculus to Monadic Logic over Finite Words, a slight variant of WS1S (weak second-order logic of one successor), which is used in the tool DC- VALID [20]. This logic is known to be decidable, with a non-elementary decision procedure, which for example is used in the MONA tool [19].

Tx,y(π)	= x = y
Tx,y(P )	= x < y ∧ ∀z(x ≤ z < y → z ∈ P )
Tx,y(¬ϕ)	= ¬Tx,y(ϕ)
Tx,y(ϕ ∨ ψ) = Tx,y(ϕ) ∨ Tx,y(ψ)
Tx,y(ϕ- ψ) = ∃z(Tx,z(ϕ) ∧ Tz,y(ϕ) ∧ x ≤ z ∧ z ≤ y)
Tx,y(a)	= x = xa ∧ y = ya
Tx,y(a : ϕ) = Txa,ya (ϕ)
Tx,y(Eϕ)	= ∃x∃y(x ≤ y ∧ Tx,y(ϕ))
Tx,y(↓a.ϕ)	= ∃xa∃ya(x = xa ∧ y = ya ∧ Tx,y(ϕ)) .
Fig. 3. Translation of HDC into L<.


The relationship between WS1S and L< can be explained as follows. The lan- guage of second order theory of one successor (called S1S) is L< extended by the successor function. For the structure ω, the successor function is definable in L<, while for continuous structures S1S is more expressive—e.g. the validity of S1S is undecidable for signal structures [23]. In WS1S the interpretations of the second order variables are restricted to finite sets. Since we have the global modality E where intervals of arbitrary size can be reached from any given interval we base our results on L<.

The translation
We will now describe how to translate formulas of HDC to formulas of L<.
In the translation, each state variable P will correspond to a second-order vari- able denoted by P also, where the intuition with the formula i ∈ P is that in the HDC interpretation P (t)=1 in the interval ]i, i+ 1[. Furthermore, for each nominal a we associate two unique first-order variables xa and ya, where the intuition is that
a names the interval [xa, ya]. The translation is defined recursively with respect to two first-order variables x and y. These must be distinct from all the variables of the form xa and ya, where a is a nominal. The intuition is that [x, y] names the current interval.
The translation is given in Figure 3. In the translation for chop we assume that
z is a “fresh” variable and distinct from xa and ya for all nominals a.

Translation of HDC to L<: Continuous time
In the continuous-time case, the formulas of L< are interpreted in signal structures. Reference [23] contains a translation from RDC to L< in the continuous-time case. We can adapt the translation above for discrete-time HDC to a translation for continuous-time HDC by changing the translation of P only, and for this case we

provide the same translation as in [23]. The translation Tx,y(P ) of P is:
x < y
∧ ∀z(x < z < y → ∃v(x < v < z ∧ ∀t(v < t < z → t ∈ P )))
∧ ∀z(x < z < y → ∃v(z < v < y ∧ ∀t(z < t < v → t ∈ P ))) .
The intuition about this translation is that P is 1 almost everywhere in [x, y], where x < y, iff for every z ∈]x, y[ there are left and right neighborhoods of z where P is constant and equal to 1.

Decidability of discrete-time HDC
We will prove decidability of discrete-time HDC by proving that an HDC formula ϕ is satisfiable in discrete-time HDC if and only if the following formula is satisfiable in L<(ω):

2
Tx,y(ϕ) ∧ x ≤ y ∧

a in ϕ
xa ≤ ya ,

where the term “a in ϕ” means that a is a nominal occurring in ϕ. To prove this, we need a couple of new conventions and lemmata.
First note that to any discrete-time HDC interpretation I we can associate an L<(ω) interpretation I' by putting i ∈ PI' if PI(t) = 1 for all t ∈]i, i + 1[. In the following we will identify any discrete-time HDC interpretation I with its associated L<(ω) interpretation I', that is, we will use the symbol I both for the HDC interpretation and its associated L<(ω) interpretation. Conversely, for any
L<(ω) interpretation I' we can associate a discrete-time HDC interpretation I by putting
P (t)=	1	if [t♩ ∈ PI'
0	otherwise.
We will also identify any L<(ω) interpretation with its associated discrete-time HDC
interpretation.
From any discrete-time HDC assignment G we can define an L<(ω) valuation νG such that [νG(xa), νG(ya)] = G(a) for all nominals a. The values νG assign to the other first-order variables do not matter. We now have the following results.
Lemma 7.1 Let I be a discrete-time HDC interpretation and G a discrete-time HDC assignment. Then for all natural numbers t and u such that t ≤ u and all HDC formulas ϕ:
I, G, [t, u] |= ϕ iff I, νG[x := t, y := u] |= Tx,y(ϕ) .
Proof. Goes by induction on the syntactic structure of ϕ. The case ϕ = π. Then
Tx,y(ϕ)= x = y, so
I, G, [t, u] |= ϕ iff t = u
iff I, νG[x := t, y := u] |= x = y . 

The case ϕ = P . Then Tx,y(ϕ) = x < y ∧ ∀z(x ≤ z < y → z ∈ P ). Now I, G, [t, u] |= P iff u > t and PI(v)=1 almost everywhere on [t, u]. But this is the case iff u > t and PI(t) = 1 on all intervals of the form ]i, i + 1[ for all i ∈ [t, u[∩N. This is the case iff u > t and i ∈ PI for all i ∈ [t, u[∩N, by the definition of PI. Then by the definition of the semantic relation for L<(ω), this is the case iff
I, νG[x := t, y := u] |= x < y ∧ ∀z(x ≤ z < y → z ∈ P ) .
The cases ϕ = ¬ψ and ϕ = ψ ∨ χ are trivial. The case ϕ = ψ - χ. Then Tx,y(ψ - χ) = ∃z(Tx,z(ψ) ∧ Tz,y(χ) ∧ x ≤ z ∧ z ≤ y). Now I, G, [t, u] |= ψ - χ iff there is a v ∈ [t, u] ∩ N such that I, G, [t, v] |= ψ and I, G, [v, u] |= χ. But by the induction hypothesis this is the case iff there exists v ∈ [t, u] ∩ N s.t.
I, νG[x := t, y := v] |= Tx,y(ψ) and I, νG[x := v, y := u] |= Tx,y(χ) .
This is true iff there exists v ∈ [t, u] ∩ N s.t.
I, νG[x := t, y := u, z := v] |= Tx,z(ψ) ∧ Tz,y(χ) ,
i.e. iff
I, νG[x := t, y := u] |= ∃z(Tx,z(ψ) ∧ Tz,y(χ) ∧ x ≤ z ∧ z ≤ y) .
The case ϕ = a. Then Tx,y(ϕ) = x = xa ∧ y = ya. We have I, G, [t, u] |= a iff G(a)= [t, u]. But by definition this is the case iff t = νG(xa) and u = νG(ya). Now since
t = νG(xa)	iff	I, νG[x := t, y := u] |= x = xa
u = νG(ya)	iff	I, νG[x := t, y := u] |= y = ya ,
it follows that G(a)= [t, u] iff
I, νG[x := t, y := u] |= x = xa ∧ y = ya .
Now consider the case where ϕ = a : ψ. Then Tx,y(ϕ) = Txa,ya (ψ). Now I, G, [t, u] |= a : ψ iff I, G, G(a) |= ψ. Since G(a)= [νG(xa), νG(ya)], this is the case iff I, G, [νG(xa), νG(ya)] |= ψ. By induction hypothesis this happens iff
I, νG[xa := νG(xa), ya := νG(ya)] |= Txa,ya (ψ) .
This, of course, is just the same as I, νG |= Txa,ya (ψ), and since x, y, xa and ya are mutually distinct variables, it is the case iff I, νG[x := t, y := u] |= Txa,ya (ψ) (since x and y does not occur free in Txa,ya (ψ)).
The case ϕ = Eψ. Then Tx,y(ϕ)= ∃x∃y(x ≤ y∧Tx,y(ψ)). I, G, [t, u] |= Eψ iff for some interval [v, w]: I, G, [v, w] |= ψ. By the induction hypothesis this is equivalent to the existence of v, w ∈ N s.t. v ≤ w and I, νG[x := v, y := w] |= Tx,y(ψ). This, by the definition of the semantic relation for L<(ω), is again true iff
I, νG |= ∃x∃y(x ≤ y ∧ Tx,y(ψ)) .

Since x and y are bound in ∃x∃y(x ≤ y ∧ Tx,y(ψ)), this is equivalent to
I, νG[x := t, y := u] |= ∃x∃y(x ≤ y ∧ Tx,y(ψ)) .
In the last case ϕ =↓a.ψ. Then Tx,y(ϕ)= ∃xa∃ya(x = xa ∧ y = ya ∧ Tx,y(ψ)). Now I, G, [t, u] |=↓a.ψ iff I, G[ a := [t, u] ], [t, u] |= ψ, and by induction hypothesis, iff I, νG[ a:=[t,u]][x := t, y := u] |= Tx,y(ψ). Note that
νG[ a:=[t,u]][x := t, y := u](xa)= t and νG[ a:=[t,u]][x := t, y := u](ya)= u , 
so I, νG[ a:=[t,u]][x := t, y := u] |= Tx,y(ψ) iff
I, νG[ a:=[t,u]][x := t, y := u] |= x = xa ∧ y = ya ∧ Tx,y(ψ) .	(2) So by the semantics of L<(ω), it follows from (2) that
I, νG[x := t, y := u] |= ∃xa∃ya(x = xa ∧ y = ya ∧ Tx,y(ψ)) .	(3) On the other hand if (3) holds, then there are natural numbers t' and u' such that
I, νG[xa := t', ya := u',x := t, y := u] |= x = xa ∧ y = ya ∧ Tx,y(ψ) .
But then of course t' = t and u' = u, so
I, νG[xa := t, ya := u, x := t, y := u] |= x = xa ∧ y = ya ∧ Tx,y(ψ) ,
and since G(a)= [νG(xa), νG(ya)] this implies (2).
This concludes the proof.	 
Lemma 7.2 Let I be a discrete-time HDC interpretation and G a discrete-time HDC assignment. Then for all natural numbers t and u such that t ≤ u and all HDC formulas ϕ:


I, G, [t, u] |= ϕ iff I, νG[x := t, y := u] |= Tx,y(ϕ) ∧ x ≤ y ∧
a in ϕ
xa ≤ ya .


Proof. Let I, G, t, u, and ϕ be given as described above. Since t ≤ u we must have
I, νG[x := t, y := u] |= x ≤ y . 
Furthermore, by definition of νG we have G(a) = [νG(xa), νG(ya)] for all nominals
a. This implies νG(xa) ≤ νG(ya) for all nominals a and thus we must also have


I, νG[x := t, y := u] |=
a in ϕ
xa ≤ ya .



Thus, in total,

I, νG[x := t, y := u] |= x ≤ y ∧
a in ϕ


xa ≤ ya .

This of course implies


I, νG[x := t, y := u] |= Tx,y(ϕ) iff
I, νG[x := t, y := u] |= Tx,y(ϕ) ∧ x ≤ y ∧
a in ϕ

xa ≤ ya .

The left hand side of this equivalence can be replaced by I, G, [t, u] |= ϕ, using Lemma 7.1, thus giving us the required equivalence.	 
Lemma 7.3 Let ϕ be a HDC formula and let I be an L<(ω) interpretation and ν
an L<(ω) valuation such that


I,ν |= Tx,y(ϕ) ∧ x ≤ y ∧
a in ϕ
xa ≤ ya .	(4)

Then there exists a discrete-time HDC assignment G, and natural numbers t and u
with t ≤ u such that


I, νG[x := t, y := u] |= Tx,y(ϕ) ∧ x ≤ y ∧
a in ϕ
xa ≤ ya .	(5)

Proof. Let I and ν be given such that (4) holds. By (4) the formula xa ≤ ya holds under the assignment ν for all nominals a in ϕ. This implies that ν(xa) ≤ ν(ya) for all nominals a in ϕ. Thus we can define a discrete-time HDC assignment G from ν by letting
G(a)= [ν(xa), ν(ya)], for each nominal a in ϕ.
On all nominals not in ϕ, the value of G can be defined arbitrarily. This definition of G implies that νG(z)= ν(z) whenever z is one of the variables xa or ya where a is a nominal in ϕ. Now let t = ν(x) and u = ν(y). Then we get
νG[x := t, y := u](z)= ν(z), for all z in {x, y}∪ {xa, ya | a in ϕ} .
We have assumed that (4) holds, that is, the formula Tx,y(ϕ)∧x ≤ y∧  a in ϕ xa ≤ ya is assumed to hold in I, ν. It is easy to see by the definition of the translation Tx,y that the free variables of this formula must all be in the set {x, y}∪{xa, ya | a in ϕ}. Now, since we have just shown that νG[x := t, y := u] and ν are identical valuations with respect to these variables, we can replace ν in (4) by νG[x := t, y := u]. This gives (5), as required.	 
Now we are finally ready for the promised result concerning preservation of satisfiability of the translation from discrete-time HDC into L<(ω).
Theorem 7.4 Let ϕ be a formula in the language of HDC. The formula ϕ is sat- isﬁable in discrete-time HDC if and only if Tx,y(ϕ) ∧ x ≤ y ∧ a in ϕ xa ≤ ya is satisﬁable in L<(ω).
Proof. The implication from left to right is a direct consequence of Lemma 7.2. To prove the implication from right to left, let I be an L<(ω) interpretation and let ν

be a valuation such that
I,ν |= Tx,y(ϕ) ∧ x ≤ y ∧
a in ϕ


xa ≤ ya .

Then by Lemma 7.3 there exists a discrete-time HDC interpretation G and natural numbers t and u such that


I, νG[x := t, y := u] |= Tx,y(ϕ) ∧ x ≤ y ∧
a in ϕ
xa ≤ ya .

By Lemma 7.2 this implies
I, G, [t, u] |= ϕ
showing that ϕ is satisfiable in discrete-time HDC.	 
The theorem above immediately implies decidability of HDC since we already know L<(ω) to be decidable.
Corollary 7.5 Discrete-time HDC is decidable.
Proof. Follows immediately from Theorem 7.4 and 4.1.	 

Decidability of continuous-time HDC
The proof of decidability of continuous-time HDC can be obtained by making only very minor changes to the proof of the discrete-time case. In the translation from HDC to L< the only difference between discrete time and continuous time is the translation of state variables. So the only significant change that has to be made to the proof above is ensuring that the translation of state variables also preserves satisfiability in the continuous-time case. This amounts to making a change to one of the cases of the induction proof of Lemma 7.1. Apart from this we only have
to replace all references to L<(ω) by references to L<(Sig) and replace the term
2	2
“discrete-time HDC” by “continuous-time HDC” everywhere. In [23] the satisfia-
bility preservation of the translation of state variables in the continuous-time case is proved. Thus we can now conclude the following.
Corollary 8.1 Continuous-time HDC is decidable.

Complexity and tableau calculi
Rabinovich [22] has shown that the satisfiability problem for RDC has a non- elementary complexity. He just gives the proof for the continuous-time interpre- tation of RDC, but mentions that Peter Sestoft has given a corresponding proof for the discrete-time interpretation. These results of course imply that satisfiability of HDC must be of non-elementary complexity as well. Thus we can probably not hope for a more efficient decision procedure for HDC than the one given in this paper. This is in contrast to the common situation where proving decidability of

a propositional modal logic by a reduction to a monadic second-order logic tends to be “using a sledgehammer to crack a nut”, to use the words of Blackburn, de Rijke and Venema [2]. This is because modal logics often have a satisfiability prob- lem of much lower complexity than monadic second-order logics, which are usually non-elementary. However, in our case the modal logic (HDC) does in fact have non- elementary complexity, so nothing smaller than a sledgehammer should be expected to crack this particular nut.
Recently, Bolander and Brau¨ner [3] succeeded in giving a tableau-based decision procedure for hybrid logic. Is it possible to give a similar tableau-based decision procedure for HDC? The answer, unfortunately, is no. The reason for this is that the tableau method of [3] uses a kind of loop-check and model construction which only works for logics having the 2n-size property : Every satisfiable formula ϕ is satisfiable in a model containing at most 2|ϕ| worlds, where |ϕ| denotes the size
of ϕ. Let us first explain why the method only works for logics having the 2n-size
property. The tableau-based decision procedure works in the following way. It takes a formula ϕ as input and builds a tableau with this formula as root. Termination of the tableau construction is ensured by a certain loop-check condition. If the constructed tableau contains an open branch then we know that we can build a model of ϕ from this branch, so the decision method will return the answer “true” corresponding to the fact that ϕ is satisfiable. Otherwise it will return the answer “false”. Now, the loop-check condition is made in such a way that if ϕ is satisfiable then the model constructed from an open tableau branch with root ϕ can never contain two distinct worlds w and v making the exact same sub-formulas of ϕ true. In other words, such a model will contain at most one world for each possible set of sub-formulas of ϕ. Thus any model of ϕ build in the decision procedure will contain at most 2|ϕ| worlds. Therefore the correctness of the decision procedure relies on having a logic with the 2n-size property. Now, any logic having the 2n-size property must have a nexptime decidability problem (to check whether ϕ is satisfiable we guess a model of size at most 2|ϕ| and check whether ϕ is satisfiable in that model). Thus we can conclude that the loop-check method of [3] can only be used for logics having a nexptime decidability problem, and thus not for hybrid RDC for which the decidability problem is non-elementary.
How about tableau-based decision methods for RDC, then? The answer is more or less as above. We need some kind of loop-check in a tableau construction al- gorithm to ensure that an interval is not subdivided ad inﬁnitum. However, the standard loop-check methods for modal logics [18,10] still only work for logics hav- ing the 2n-size property: We recognize a loop in a tableau branch by seeing that two worlds make the same set of formulas true—and then we terminate the tableau construction and identify the two worlds in the model constructed from the branch. This again gives a model of size at most 2|ϕ|, and thus such a method can not both be sound and complete with respect a non-elementary logic such as RDC. Intuitively, it is actually not particularly surprising that the standard loop-check methods do not work for RDC: We can of course not identify two real-line intervals in a model just because we know the two intervals make the same formulas true. Two real-line

intervals might be disjoint and still make the exact same RDC formulas true. This obviously also implies that we cannot prove decidability of RDC and HDC through filtration methods, which is another standard technique in modal logics (see [2]).
The discussion above does not prove that it is impossible to make sensible tableau-based decision procedures for RDC or HDC. It just proves that the standard methods for modal logic, and the known methods for hybrid logic, do not suffice. This also explains why attempts at providing tableau calculi for RDC have so far not been particularly successful. Two articles by Nathalie Chetcuti-Sperandio and Luis Farin˜as del Cerro [7,8] contain a terminating tableau procedure for a fragment of duration calculus—but the fragment is negation-free, and thus of a much lower complexity. In [6] a tableau-based decision method is provided which, given a num- ber k and a formula ϕ, can decide whether ϕ is satisfiable in a discrete-time model of RDC of size k (the size of a discrete-time model is the number of unit intervals it contains). However, this only gives a semi-decidability procedure: To check whether ϕ is satisfiable we must run the algorithm for k = 1, 2, 3,... until we reach a value of k for which the constructed tableau of ϕ does not close. Otherwise, if ϕ is not satisfiable, the algorithm will not terminate. Given a formula ϕ, we could of course try to give an upper bound f (|ϕ|) on the number of values of k needed to decide
satisfiability of ϕ by this method, but given the complexity of RDC, the function f
would need to be non-elementary.

Summary
In this work we have considered a decidable fragment of Duration Calculus called Restricted Duration Calculus (RDC). The satisfiability problem for RDC has a non-elementary complexity for both discrete-time and continuous-time domains.
We have developed a hybrid logical version of RDC, called Hybrid Duration Calculus (HDC). HDC includes nominals, the down-arrow binder and the global modality, by which arbitrary intervals can be reached. We have shown the decid- ability of HDC wrt. to discrete-time and continuous-time domains. These results were achieved by translations (preserving satisfiability) to decidable fragments of monadic second order theory of order.
Examples of the extra expressiveness were given. For example, we showed that the neighborhood modalities of interval logic are definable in HDC even though they are not definable in RDC.

References
Allen, J. F., Towards a general theory of action and time, Artifical Intelligence 23 (1984), pp. 123–154.
Blackburn, P., M. de Rijke and Y. Venema, “Modal Logic,” Cambridge Tracts in Theoretical Computer Science 53, Cambridge University Press, 2001.
Bolander, T. and T. Brau¨ner, Two tableau-based decision procedures for hybrid logic, in: H. Schlingloff, editor, Proceedings of the 4th Methods for Modalities (M4M) workshop (2005), pp. 79–96.
Bresolin, D. and A. Montanari, A tableau-based decision procedure for right propositional neighbourhood logic, in: TABLEAUX 2005, LNAI 3702, 2005, pp. 63–77.

Buchi, J., Weak second-order arithmetic and finite automata, Z. Math. Logik Grundl. Math 6 (1960),
pp. 66–92.
Chetcuti-Sperandio, N., Tableau-based automated deduction for duration calculus, in: TABLEAUX 2002, Lecture Notes in Computer Science 2381 (2002), pp. 53–69.
Chetcuti-Sperandio, N. and L. F. del Cerro, A decision method for duration calculus, Journal of Universal Computer Science 5 (1999), pp. 743–764.
Chetcuti-Sperandio, N. and L. F. del Cerro, A mixed decision method for duration calculus, Journal of Logic and Computation 10 (2000), pp. 877–895.
Elgot, C., Decision problems of finite automata design and related arithmetics, Transactions of the American Mathematical Society 98 (1961), pp. 21–52.
Fitting, M., “Proof methods for modal and intuitionistic logics,” Synthese Library 169, D. Reidel Publishing Co., Dordrecht, 1983, viii+555 pp.
Fra¨nzle, M., “Controller Design from Temporal Logic: Undecidability Need Not Matter,” Ph.D. thesis, Institut fu¨r Informatik und Praktische Mathematik der Christian-Albrechts-Universit¨at Kiel. (1997).
Fra¨nzle, M., Take it np-easy: Bounded model construction for duration calculus, in: W. Damm and E.-R. Olderog, editors, Formal Techniques in Real-Time and Fault-Tolerant Systems, Lecture Notes in Computer Science 2469 (2002), pp. 245–264.
Fra¨nzle, M., Model-checking dense-time duration calculus, Formal Aspects of Computing 16 (2004),
pp. 121–139.
Goranko, V., A. Montanari and G. Sciavicco, A road map of interval temporal logics and duration calculi., Journal of Applied Non-Classical Logics 14 (2004), pp. 9–54.
Halpern, J., B. Moskowski and Z. Manna, A hardware semantics based on temporal intervals, in:
ICALP’83, Lecture Notes in Computer Science 154 (1983), pp. 278–291.
Halpern J.Y., S. Y., A propositional modal logic of time intervals, Journal of the ACM 33 (1991),
pp. 935–962.
Hansen, M. R. and Z. Chaochen, Duration calculus: Logical foundations, Formal Aspects of Computing
9 (1997), pp. 283–330.
Hughes, G. E. and M. J. Cresswell, “A new introduction to modal logic,” Routledge, London, 1996, x+421 pp.
Klarlund, N. and A. Møller, Mona version 1.4: User manual, BRICS, Department of Computer Science, University of Aarhus, Denmark, URL: http://www.brics.dk/mona.
Pandya, P. K., Specifying and deciding quantified discrete-time duration calculus formulae using DCVALID, Technical report TCS00-PKP-1, Tata Institute of Fundamental Research, India (2000).
Quesel, J.-D. and A. Sch¨afer, Spatio-temporal model checking for mobile real-time systems, in:
ICTAC’06, Lecture Notes in Computer Science 4281 (2006), pp. 347–361.
Rabinovich, A. M., Non-elementary lower bound for propositional duration calculus, Information Processing Letters 66 (1998), pp. 7–11.
URL citeseer.ist.psu.edu/4239.html
Rabinovich, A. M., On the decidability of continuous time specification formalisms, Journal of Logic and Computation 8 (1998), pp. 669–678.
URL citeseer.ist.psu.edu/rabinovich98decidability.html
Ravn, A., H. Rischel and K. Hansen, Specifying and verifying requirements of real-time systems, IEEE Trans. Softw. Eng. 19(1) (1993), pp. 41–55.
Zhou, C. and M. R. Hansen, An adequate first order interval logic, Lecture Notes in Computer Science
1536 (1998), pp. 584–608.
URL citeseer.ist.psu.edu/article/chaochen96adequate.html

Zhou, C. and M. R. Hansen, “Duration Calculus: A Formal Approach to Real-Time Systems,” EATCS: Monographs in Theoretical Computer Science, Springer, 2004, 257 pp.
Zhou, C., M. R. Hansen and P. Sestoft, Decidability and undecidability results for duration calculus, in: P. Enjalbert, A. Finkel and K. W. Wagner, editors, STACS’93, Lecture Notes in Computer Science 665 (1993), pp. 58–68.
Zhou, C., C. A. R. Hoare and A. P. Ravn, A calculus of durations, Information Processing Letters 40
(91), pp. 269–276.
