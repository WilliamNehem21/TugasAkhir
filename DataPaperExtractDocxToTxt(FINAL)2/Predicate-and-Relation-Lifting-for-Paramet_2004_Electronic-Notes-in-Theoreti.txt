Electronic Notes in Theoretical Computer Science 106 (2004) 335–353 
www.elsevier.com/locate/entcs


Predicate and Relation Lifting for Parametric Algebraic Specifications
Hendrik Tews1
TU Dresden, Institut fu¨r Theoretische Informatik, D-01062 Dresden, Germany.

Abstract
Relation lifting [6] extends an endofunctor F : C  C to a functor Rel(F ) : Rel(C)  Rel(C), where Rel(C) is a suitable category of relations over C. The relation lifting for the functor F can be used to define the notion of bisimulation for coalgebras X  F (X). The related notion of
predicate lifting can be used to define invariants for F –coalgebras. Predicate and relation lifting can be directly defined for a rich class of polynomial functors [5,6,19]. In this paper I investigate the case where the functor F is defined as the initial semantics of a (single sorted) parametric algebraic specification.
Keywords: Endofunctor, relation lifting, bisimulation, coalgebra, polynomial functor, algebraic specification.


Introduction
The notion of bisimulation captures the concept of behavioural equivalence. For a system described as a coalgebra X F (X) the definition of bisimula- tion is usually derived in a more or less direct way from the functor F that describes the interface of the system.
In this paper I investigate the question how to define the notion of bisim- ulation for functors that arise from (single sorted) parametric algebraic speci- fications with initial semantics. Such functors are important for specification environments such as CCSL [20] or CoCASL [10]. In these specification lan- guages one can construct functors in an iterated way by nesting algebraic and

1 Email: tews@tcs.inf.tu-dresden.de



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.040


coalgebraic specifications. One can, for instance, first define sequences on a set A as the final coalgebra for the functor F Seq(X)= A × X + 1 and obtain a functor Seq : SetSet that maps any set A to the possibly non-terminating sequences over A. One can then define trees of finite depth and infinite width with labels drawn from B as the initial algebra of F Tree(X)= Seq(X × B) [5].
This defines a functor Tree : Set  Set.
Consider a functor F that has been constructed in such a way from iter- ating algebraic specifications with initial semantics and coalgebraic specifica- tions with final semantics. In [5] Hensel and Jacobs investigate the case of iterated data types, that is, where all these specification do not contain any axioms. Their approach also extends to the case in which the last step in the construction of F is a proper coalgebraic specification (i.e., contains axioms). Assume now that the last step in the construction of F is a proper para- metric algebraic specification S. For simplicity I assume that S has only one parameter in the following. If this parameter is a type parameter, that is, if there are no operations (not even equality) used on the parameter, then F can be considered as a functor SetSet. In this case one can use the approach
of Aczel and Mendler [1] to define bisimulations on F –coalgebras.
This paper concentrates on the case where the specification S uses ad- ditional operations, for instance equality, on its parameter. In this case the parameter stands for a model of a parameter specification T (with usually loose semantics). Consequently F is then only a functor Mod(T )  Set, where Mod(T ) denotes the category of models of T . I show in the sequel that in general for such functors the known approaches to define bisimulations fail. Consider for example Figure 1. It contains an algebraic specification of finite sets. There are two important points: Firstly, the specification FSet is parametric in T , which stands for an arbitrary model of the specification Elem. Secondly, FSet specifies finite sets with an additional delete operation.
The specification of this delete operation relies on the operation equal that comes along with every model of Elem.
Admittedly, the preferred approach is to specify finite sets without the delete operation and to define it as a definitional extension. This way one could make the specification parametric in a type only (that is, without an equality operation) and avoid all the problems that result from the use of the equality relation of the parameter T .
However, as the specification FSet stands in Figure 1 it represents an in- teresting border case. It is interesting because the semantics and the relevant notions of predicate and relation lifting are well known—namely the finite powerset functor with its liftings [7]. Still, for technical reasons one cannot use the familiar approaches to define bisimulations for FSet)–coalgebras. The


Elem : Loose Specification Operation
equal	: Elem × Elem  bool
End Elem
FSet[T : Elem] : Initial Specification Operations
empty : FSet
add	: FSet × T FSet del	: FSet × T FSet
Variables
x : FSet;  t, t1, t2 : T
Axioms
add comm	: add(add(x, t1), t2) = add(add(x, t2), t1)
add idem	: add(add(x, t), t) = add(x, t)
del empty	: del(empty, t)= empty
del add eq	: equal(t1, t2) = true ⇒ del(add(x, t1), t2)= del(x, t2)
del add neq : equal(t1, t2)= false ⇒ del(add(x, t1), t2) = add(del(x, t2), t1)
End FSet

Fig. 1. Algebraic specification of finite sets with a delete operation
reason is that in general the projections π1 and π2 do not reflect the equality relation on the parameter. Thus FSet)(π1/2) is not even well-defined!
The following section on technicalities introduces some more special cate- gorical notions. In the second subsection it describes the semantics of algebraic specifications. This subsection contains only standard material but introduces the notation and assumptions necessary for the rest of the paper. The assump- tions are summarised at the end of the subsection on page 9. Section 3 contains the definition and Section 4 investigates its properties.
Acknowledgements. I thank Horst Reichel for many discussions and his explanations of the subtleties of algebraic specifications.

Technicalities
Category Theory
The category of sets and total functions is denoted by Set. I use the standard notation for products (×) and coproducts or disjoint unions (+) with projec- tions π1/2, tupleing ⟨f, g⟩, injections κ1/2, and cotupleing [f, g]. I write X ⇒ Y for the exponent (the function space between X and Y ). A n-ary polynomial

functor is a functor Setn  Set generated from the following grammar:
F (X1 ,... , Xn) = A | Xi | F1(··· ) × F2 (··· ) | F1(··· )+ F2 (··· ) | A ⇒ F1(··· )
The grammar for iterated polynomial functors [5,14] contains additional clauses for least and greatest fixed points:
F (X1,... , Xn) =  ... | µX . F (... , X,.. .) | νX . F (... , X,.. .)
Here µX . F (... , X,.. .) denotes the initial algebra for the functor F (... , −,.. .) : SetSet (where all up to one argument positions of F are fixed) and νX . F (··· ) its final coalgebra. When used in an iterated polynomial functor µX . F (··· ) and νX . F (··· ) denote the carrier set of the initial and final coalgebra, respectively. The mapping on morphisms is defined as follows (I show only the case n = 2): Let b : F (V, B)  B be the initial F (V, −) algebra and f : U V be an arbitrary function. Then b ◦ F (f, idB) has the form of an F (U, −) algebra, so there is an unique algebra homomorphism with a : F (U, A)A, the initial F (U, −) algebra, as domain. The underlying function of this algebra morphism gives µX . F (f, X). To define νX . F (f, X) one takes the unique coalgebra morphism for F (f, id) ◦ c, where c is the final F (V, −) coalgebra.
A few notions of fibred category theory are relevant for this paper. I just define them here as operations on sets or predicates, disregarding their fibred nature. See [12,8] for an introduction into fibration. The material used in this paper is also covered in [4, Chapter 3] or [20, Chapter 2].
A predicate on a set X is written as P ⊆ X = {x | x ∈ P }. The truth predicate on X is TX = X ⊆ X. Predicates form the category Pred (in fact they are fibred over Set). A morphism P ⊆ X Q ⊆ Y is a function f : X Y such that f x ∈ Q for all x ∈ P . A binary relation between X and Y is written as R ⊆ X × Y = {(x : X, y : Y ) | R(x, y)}. The equality relation on an arbitrary set A is Eq(A) = {(a, a) | a ∈ A}. Relations form the category Rel (which is fibred over Set × Set). Morphisms are pairs of functions that preserve the domain relation (∀ (x, y) ∈ R. (f x, g y) ∈ S). The inverse image of a function f : X Y with respect to a predicate Q ⊆ Y
is denoted with f ∗ (Q) ⊆ X = {x ∈ X | f (x) ∈ Q}. The image of f with
respect to a predicate P ⊆ X is   (P ) ⊆ Y = {f (x) | x ∈ P }.
For an arbitrary relation R ⊆ X × X the quotient X/R is the set of equivalence classes of X with respect to the least equivalence relation contain- ing R. There is a quotient map qR : X X/R that sends every x to its equivalence class [x]R. In a suitable setting quotients are functorial [8, Sec- tion 4.8]. The morphism component of the quotient is also important here. For two relations R1 ⊆ X × X, R2 ⊆ Y × Y and a function f : X Y such


that x R1 y ⇒ (f x) R2 (f y) the morphism component of the quotient functor is denoted as Q(f ) : X/R1  Y/R2 . It sends an equivalence class [x]R1 to [f x]R2 . The equation Q(f ) ◦ qR1 = qR2 ◦ f holds in general (it follows from the adjunction Q E Eq).
For predicates and relations there exists a special Cartesian closed struc- ture. For predicates P ⊆ X, Q ⊆ Y and relations S ⊆ U × V , R ⊆ X × Y it can be defined as follows:
P ×P Q ⊆ X × Y	=	 (x, y) | x ∈ P ∧ y ∈ Q}
P +P Q ⊆ X + Y	=	{κ1 x | x ∈ P } ∪ κ2 y | y ∈ Q} P ⇒P Q ⊆ X ⇒ Y	=	 f | x ∈ P =⇒ (f x) ∈ Q}
S ×R R  ⊆  (U × X) × (V × Y )	=	 ((u, x), (v, y)) | uS v ∧ xR y}
S +R R  ⊆  (U + X) × (V + Y )	=	 (κ1 u, κ1 v) | uS v}
∪	 (κ2 x, κ2 y) | xR y}
S ⇒R R  ⊆  (U ⇒ X) × (V ⇒ Y )	=	 (f, g) | uS v =⇒ (f u) R (g y)}
Predicate lifting [6] lifts a polynomial functor F on Set to a functor Pred(F ) on Pred, such that Pred(F )(P ) ⊆ F (X) for P ⊆ X. The predicate lifting for F can be used to define the notion of invariant for F –coalgebras. Relation lifting lifts F to a functor on Rel with Rel(F )(R) ⊆ F (X)×F (Y ) for R ⊆ X × Y . It can be used to define bisimulations on F –coalgebras. One ob- tains these liftings by substituting the cartesian closed structure of predicates or relations for the cartesian closed structure of Set in F . More precisely, for a polynomial functor F : Set × SetSet and two relations R1, R2 the relation lifting Rel(F )(R1, R2) is inductively defined as follows:

The precise definition for predicate lifting is very similar: predicate lifting employs the cartesian closed structure of predicates and uses TA for the case F (··· )= A.
Hensel and Jacobs extend in [5] predicate and relation lifting to iterated polynomial functors. The liftings for µX . F and νX . F are defined as least and greatest fixed points in the following way: Consider a relation R ⊆ X × Y and let α : F (X, A)A and β : F (Y, B)B be the initial algebras for

F (X, −) and F (Y, −), respectively. The relation lifting Rel(µX . F (−,X))(R)

is defined as the least fixed point of S  

α×β
Rel(F )(R, S).	For the

predicate lifting Pred(µX . F (−,X))(P ) one takes the least fixed point of
Q   Pred(F )(P, Q).	Similarly for νX . F :	For suitable final coal-
gebras ρ and γ the greatest fixed points of Q  ρ∗ Pred(F )(P, Q) and S  (ρ × γ)∗ Rel(F )(R, S) define predicate lifting and relation lifting, respec- tively. These fixed points exist for all iterated polynomial functors.
The following two technical results have been proved in PVS [11].
Lemma 2.1 The relation lifting of an equivalence relation is an equivalence relation for all polynomial functors.
Lemma 2.2 Let F be a polynomial functor. There is an isomorphism be- tween F (X1,... , Xn)/Rel(F )(R1,... , Rn) and F (X1/R1,... , Xn/Rn) for all relations Ri ⊆ Xi × Xi. The isomorphism is given by the function that maps [x]Rel(F )(··· ) to F (qR1 ,... , qRn )(x).
Speciﬁcations and their Semantics
The following sections rely on several assumptions on the form and especially the semantics of algebraic specifications. This section explains these assump- tions and introduces the needed notions. The assumptions are summarised at the end of this subsection on page 9.
In this paper I only consider single sorted specifications with at most one parameter. The restriction to one sort is somewhat essential because I use morphisms F (X)X as semantics of algebraic specifications. Moreover, the proposed liftings for specifications rely on the liftings of Hensel and Jacobs for data types [5]. The restriction to one sort is also present in their work.
The restriction to one parameter is for convenience only. For more pa- rameters one only has to add more arguments to the involved functors and liftings.
Throughout this paper I consider two specifications T and S like in Fig- ure 1. The specification T is the parameter specification. The specification S is a single sorted algebraic specification with initial semantics. It is parametric in T . Therefore the notions of signature, signature model, and model for S are also parametrised.
The parameter specification can be an arbitrary specification (not neces- sarily algebraic) with loose semantics, like the Elem specification in Figure 1. I neglect all syntactic issues and assume that the semantics of the parameter specification T is given as a category Mod(T ) of models of T . Objects in this category are tuples T = ⟨|T |, (fi)⟩ consisting of a carrier set |T | and a family of functions (fi) for the operations declared in T . Morphisms are functions


between the carriers that are compatible with the operations. There is an obvious forgetful functor U : Mod(T )  Set.
Example 2.3 Let bool be the set {true, false} of boolean values. Models of the Elem specification in Figure 1 are pairs ⟨E, eq⟩, where E is a set and eq is a function E × E  bool.  A function f : E1  E2 is a morphism
⟨E1, eq1⟩⟨E2, eq2⟩ if it is compatible with the operation equal, that is, if eq2 (f e1,f e2) = eq1(e1, e2) for all e1, e2 ∈ E1. Note that f is required to preserve and reflect the equal’s predicate. This forms the category Mod(Elem) of models of Elem.
For the algebraic specification S, I would also like to ignore syntactic issues. I assume that the signature of S is given as an iterated polynomial functor Sig : Set × SetSet. This functor combines all operations of S into one. The first argument reflects the dependency on the parameter T . A first argument from Set (in contrast to Mod(T )) is sufficient, because (the semantics of) the signature depends only on the carrier of the parameter. A signature model is an interpretation of all operations in S, which does not necessarily fulfil the axioms of S. It can be given as an algebra Sig(U, X)X , where U is an arbitrary set, possibly forming the carrier of a model of T .
The algebras Sig(U, X)X (for arbitrary U ) are the objects of the category SigMod(S).  A Morphism in this category between an algebra a : Sig(U, X)X and an algebra b : Sig(V, Y )Y consists of a pair of functions (f : U V , g : X Y ) such that g ◦ a = b ◦ Sig (f, g). There is an obvious forgetful functor U : SigMod(S)  Set that sends the algebra a to U and the morphism (f, g) to f . The functor µX . Sig(−,X) that maps a set T to the initial algebra of the functor Sig(T, −) is left adjoint to U. There is a second forgetful functor, denoted by |− |, that sends every algebra Sig(U, X)X to its carrier set X.
In order to deal with the axioms of the specification S I assume that for every model T of T and every signature model a : Sig (|T |,X)X it is possible to check if the axioms of S hold on a. If the axioms do hold the pair
⟨T, a⟩ is called a model of S for T .
The category Mod(S) has all models of S (for all possible T ) as ob- jects. Morphisms are pairs (f, g) of functions such that f is a morphism in Mod(T ) and (f, g) is a morphism between the underlying signature models in SigMod(S). For every model T of T there is the subcategory ModT (S) of Mod(S) that contains just the models for T . Morphisms in ModT (S) are those that have the form (id|T |, g). Again, there are two forgetful functors U : Mod(S)Mod(T ) and |−| : Mod(S)Set.
There are two important assumptions on the specification S: First, the


forgetful functor U must have a left adjoint, denoted as S), such that U ◦ S) is the identity on Mod(T ). As one might guess from the notation, the left adjoint S) is called the semantics of S. It maps any model T to the initial object in ModT (S). The requirement that U( S)(T )) = T amounts to the fact that the axioms of S place no restrictions on the parameter specification.
The second important assumption is that the semantics S) can be con- structed as quotients of the initial algebras µX . Sig(−,X). This quotient construction works as follows (consider also the diagram below): Let T be an arbitrary parameter model and let α = µX . Sig(|T |,X). The axioms of S determine a congruence relation (with respect to α) QT ⊆ A×A on the carrier of α such that the quotient A/QT is the carrier of b = S)(T ). Because QT is a congruence relation α is a morphism Rel(Sig )(Eq(|T |), QT )QT between relations, so Q(α) is as depicted in the diagram below. The operations on A/QT are defined via the composite b = Q(α) ◦ i−1, where i is the isomor- phism from Lemma 2.2. The following diagram illustrates this construction (in the diagram I write Rel(Sig) for Rel(Sig)(Eq(|T |), QT )):
Sig(|T |, A)	α	A

A/QT

Sig(|T |, A/QT )
The morphism component of S) must also be constructed as a quo- tient: Consider a morphism f : T V in Mod(T ). Then µX . Sig(f, X) is an algebra morphism αµX . Sig(|V |,X) and we can set S)(f ) = Q(µX . Sig(f, X)).
The assumption about the construction of S) is not too restrictive: The initial model of S can be obtained in the depicted way if the axioms of S are equational Horn formulas [9]. The origin of the relation QT is not relevant for this paper (only its existence). Meinke and Tucker construct QT as the intersection of the kernels of all algebra morphisms from α to ModT (S). If the axioms of S are positive Horn formulas one can construct Q directly from the axioms, as the following example suggests.
Example 2.4 The signature functor for the specification FSet from Figure 1 is F (T, X)= 1+(X ×T )+(X ×T ). From a signature model γ : F (T, X)X one obtains the single operations by precomposing an injection, for instance addγ = γ ◦ κ2. The lists over bool × |T | form the initial signature model for
T . The additional boolean in the cons cells is used to distinguish add’s and


del’s. The equations of S have a simple structure. Therefore one can define the semantics of each axiom as a relation on X. For the last axiom this is for instance:
x del add neq) y	⇐⇒
∃t1, t2 ∈ |T |,z ∈ X . ¬eqT (t1, t2)	∧
x = delγ(addγ(z, t1), t2)	∧	y = addγ(delγ(z, t2), t1)


One obtains the semantics Qγ
⊆ X × X as the union of the semantics of all

axioms. The algebra γ is in ModT (FSel) if Qγ
⊆ Eq(|T |).

The relation QT that can be used for factoring the initial F –algebra α is the least congruence relation that contains Qα . The last two axioms of S are rewrite rules. For any list of add and del operations they permit to compute an equivalent list without del’s. The relation QT relates two list, precisely if there del-free equivalents contain the same elements of T (disregarding order and multiple occurrences). So every equivalence class of QT describes a finite set of elements of |T | (with respect to the equality eqT ). Finally, the initial algebra in ModT (FSet) is isomorphic to the finite sets with the obvious interpretation of the operations empty, add, and del.
To summarise, there are the following assumptions for this paper:
T is a single sorted parameter specification with loose semantics
S is a single sorted algebraic specification that is parametric in T with initial semantics.
the semantics  S) of S is a functor Mod(T )Mod(S) from the category of models of T to the one of models of S. In particular, S) maps any function f : U V that is compatible with the operations of the parameter specification to a function between the initial models of S for U and V .
The functor S) is left adjoint to the forgetful functor U and U ◦ S) = IdMod(T ). Further, S) is constructed as quotient of the initial algebras for the signature of S.
These assumptions are true if the axioms of S are equational Horn formulas [9] and if they do not place any restrictions on the parameter T .
S)–Coalgebras
In general one could extend the definition of polynomial functors to admit ingredient functors of the form S) for parametric algebraic specifications S with initial semantics (and also for parametric coalgebraic specifications with

final semantics). There are, however, two technical complications: Firstly, S)
takes models of the parameter specification as arguments. So before applying
 S) to a set X one has to equip X with suitable operations (fi). Of course in general the result of S)(⟨X, (fi)⟩) depends on the choice of the operations. The second complication is that one has to use | S)(⟨X, (fi)⟩)| to extract the carrier set of the model of S. In this paper I would like to ignore these technical issues. I write S)(X) to denote, depending on the context, both the model of S and its carrier set. The operations on X will be clear from the context. In summary, the definition of a coalgebra X  S)(X) is a four stage process: One has to define the carrier set X, equip it with suitable operations (fi), form the application S)(X), and finally define the coalgebra itself. Note that for such a coalgebra the notion of coalgebra morphisms is only meaningful for functions g that are actually morphisms in Mod(T ) (thus preserving the operations (fi)) because otherwise the application S)(g) is not well formed. In this paper I consider only coalgebras of the form X  S)(X), where the signature functor of S does not contain an ingredient derived from an
algebraic specification.

Bisimulations for Coalgebras
There are at least three approaches to define the bisimulations between two coalgebras c : X F (X) and d : Y F (Y ): 
Aczel and Mendler suggest the following diagram as defining property [1]:


X	π1
R	π2	Y



c

F (X)

F (π1)

F (R)	F (π2)
d

F (Y )

Hermida and Jacobs [6] suggest to use the relation lifting Rel(F ) for F
and define bisimulations as relations R that fulfil
∀x, y . x R y	=⇒	(c x)Rel(F )(R)(d y)
One can also define bisimulations as those relations whose elements are made equal by a pair of coalgebra morphisms. More precisely, R is a bisimulation if there exists a coalgebra z : Z F (Z) and coalgebra morphisms f : X Z, g : Y Z such that xR y ⇔ f x = g y.
For functors that preserve weak pullbacks all three approaches are equiva- lent [18].


Consider now FSet–coalgebras. Note that neither the first nor the second approach can be used to define bisimulations for FSet–coalgebras. The first approach fails because it is usually impossible to turn a relation R intoa model of Elem such that the projections are morphism in Mod(Elem). The problem with the second approach is that relation lifting must be explicitly defined for
each functor. The generic property that links the relation lifting of F with

F itself, namely the equation Rel(F )(R) = 
F (R), appearing in

[17,2], cannot be used for FSet, again because of the projections.
The third approach can be used for FSet–coalgebras, but in general it yields an unsatisfactory notion of bisimulation as the following example shows.
Example 2.5 Consider the specification of finite sets from Figure 1 with the following changes: Add a new operation color : Elem  bool to the parameter specification Elem together with the axiom ∀t1, t2 : Elem . color(t1)= color(t2). This implies that all elements of one model have the same colour. However, models of Elem can be coloured either with true or false.
Consider now the following two coalgebras (I omit the operation equal
because it is not relevant):

c(x)	=	empty	d(y)	=	empty
Intuitively both states x and y show the same behaviour (with respect to the coalgebra), so there should be a bisimulation relating them. However, as a morphism of Elem, every coalgebra morphism has to preserve the colour of the state. There is no model of the changed Elem specification with two different colours. Therefore it is impossible to find a pair of morphisms that map x and y to the same element.

Definition of Predicate and Relation Lifting
This section presents a solution for the problem of defining bisimulations for FSet–coalgebras: A definition of predicate and relation lifting that relies on the liftings for µX . Sig(−,X) of Hensel and Jacobs [5]. The straightforward approach, namely to factor the liftings of the iterated polynomial signature functor by the congruence relation QT (which provides the semantics of the axioms) does not work, see Example 3.2 below.
Definition 3.1 Let S be an algebraic specification that is parametrised by


a specification T . Assume that the semantics S) : Mod(T )  Mod(S) is constructed as described in Section 2.2.
A set of canonical forms is an indexed set (CT ⊆ µX . Sig(|T |,X))T ∈|Mod(T )|
such that for all x ∈ µX . Sig(|T |,X) we have [x] ∩ CT /= ∅.
Let T and V be models of T . Assume sets of canonical forms CT and CV . For a predicate P ⊆ |T | and a relation R ⊆ |T |× |V | the predicate and relation lifting of S) is defined as

Pred( S))(P )	=	 
Rel( S))(R)	=	 


qQT
 Pred(µX . Sig(−,X))(P ) ∩ CT 
 Rel(µX . Sig(−,X))(R) ∩ CT × CV )

qQT ×qQV

Here, Sig is the signature functor of S, µX . Sig(−,X) denotes the functor that maps any set A to the initial Sig(A, −)–algebra, Pred(−) and Rel(−) are the predicate and relation lifting for this functor as described by Hensel and Jacobs [5], and qQT is the quotient map for the quotient with respect to QT , the relation that is used in the construction of S)(T ).
The condition on the canonical forms ensures that in each equivalence class of terms there is at least one canonical term. Let me first show an example before I further elaborate on the canonical forms.
Example 3.2 Consider again the specification of Figure 1 (without changes). Example 2.4 describes the signature functor F and the semantics of FSet.
Let T and V be models of Elem and consider a predicate P ⊆ |T | and a relation R ⊆ |T |× |V |. Hensel and Jacobs define predicate and relation lifting of µx . F (−,X) as the least fixed points of the following equations:
Pred(µX . F (−,X))(P )	=	{empty} ∪ 
{add(l, t) | t ∈ P ∧ l ∈ Pred(µX . F (−,X))(P )}∪ 
{del(l, t) | t ∈ P ∧ l ∈ Pred(µX . F (−,X))(P )}
Rel(µX . F (−,X))(R)  =  {(empty, empty)}∪ 
{(add(l1, t1), add(l2, t2)) | t1 R t2 ∧ (l1, l2) ∈ Rel(µX . F (−,X))(R)}∪ 
{(del(l1, t1), del(l2, t2)) | t1 R t2 ∧ (l1, l2) ∈ Rel(µX . F (−,X))(R)}
The lifted predicate Pred(µX . F (−,X))(P ) holds for a list l if all elements from T that occur in l are in P . The relation Rel(µX . F (−,X))(R) relates two lists l1 and l2 if they contain the same sequence of add’s and del’s (in the same order) such that the elements of T and V at corresponding positions are related by R.
The equivalence classes with respect to QT correspond to finite sets over


|T | (with respect to the equality eqT ). The predicate lifting Pred( FSet))(P ) holds for such a set s, precisely if there exists a representation of this set as a canonical form l ∈ CT of add and del operations such that l ∈ Pred(µX . F (−,X))(P ). The canonical forms are mainly important for rela- tion lifting. Here we see that, in case CT contains enough terms (for instance if CT = |µX . Sig(|T |,X)|), one easily derives s ∈ Pred( FSet))(P ) ⇔ s ⊆ P . Turn now to relation lifting. Consider a set s over |T | and a set p over |V |.
They are related by Rel( FSet))(R) if there exist canonical representations ls ∈ CT and lp ∈ CV such that ls and lp are related by Rel(µX . F (−,X))(R). The problem here is (and that is where the canonical forms are needed) that completely different sets might have representations that are related by Rel(µX . F (−,X)). Consider for instance the terms t1 = del(add(empty, a), a) and t2 = del(add(empty, b), c) (for arbitrary a ∈ T, b, c ∈ V ). From the axioms of FSet we know that t1 = empty and that t2 = add(empty, b). Thus t1 is a representation for the empty set, while t2 represents the set {b}. Nevertheless, if R contains both (a, b) and (a, c) then (t1, t2) ∈ Rel(µX . F (−,X))(R). In case both terms are canonical (t1 ∈ CT and t2 ∈ CV ), the relation lifting for
 FSet) relates the empty set with the set {b}, which is highly undesirable.
To avoid this problem one defines the set of canonical terms to be those terms that contain no del-operation. With this choice it is easy to see that the relation lifting for FSet) relates two sets s and p precisely if for every t ∈ s there is a v ∈ p such that tRv and vice versa.
Remark 3.3 The set of canonical forms has to be defined during the de- velopment of the specification. The liftings depend in a crucial way on the canonical forms. So they should be chosen with care. If the specification pro- vides normal forms then one can take the singleton sets of normal forms as canonical forms. However, the preceding example shows that normal forms are not necessary.
The canonical forms are needed because the axioms of the specification S (when read as rewrite rules) might introduce or delete elements of the pa- rameter specification (like del empty in the specification FSet). If there are no such axioms one can use the set of all terms as canonical forms.
The impression that arises from the FSet-example, that the canonical forms can be generated by a subsignature is misleading. It merely indicates that the FSet-example is somewhat contrived: The operation del should be specified as a definitional extension.
Remark 3.4 The liftings of the preceding definition are almost functors on Pred and Rel, respectively. To be precise, the liftings are endofunctors on the categories PredT and RelT of predicates and relations over models of T .


These categories are fibred over Mod(T ) and Mod(T ) × Mod(T ), respectively. Objects of PredT are pairs (P, T ) where T is a model of T and P ⊆ |T |. Similarly for RelT .
The following proposition shows that Definition 3.1 is reasonable: The definition yields the expected liftings for the specification FSet.
Proposition 3.5 The liftings for FSet as described in Deﬁnition 3.1 coincide with the liftings for the ﬁnite powerset functor deﬁned in [7] if one takes the del–free terms as canonical forms.
More precisely, let Pfin (T ) denote the initial model in ModT (S) that con- sists of the ﬁnitary powerset of |T | with the obvious interpretation of the three operations of S. Let i be the algebra isomorphism between Pfin (P ) and S)(T ). Then i∗ (Pred( S))(P )) = Pred(Pfin )(P ) for all suitable P. A similar equa- tion holds for the relation lifting.
Proof. Obvious, after the considerations of Example 3.2. Nevertheless, this proof has been formalised in PVS [11]. In PVS the proof is surprisingly diffi- cult, because it proceeds by induction and involves the construction of suitable sets and lists.

Properties of the new Liftings
In this section I investigate some properties of the proposed liftings. There is often a tight connection between these properties and the ones of bisim- ulations and invariants. For instance, if the relation lifting for F commutes with intersection then one immediately has that the intersection of two F – bisimulations is a F bisimulation again (see [19] or [20, Section 2.6] for a collection of interesting properties).
Obviously, the properties of the liftings for S) depend in a crucial way on the properties of the liftings of the iterated polynomial functor µX . Sig(−,X). Unfortunately there are only few results available for the liftings of iterated polynomial functors. Hensel and Jacobs prove that these liftings are fibred and preserve truth and equality [5]. Surprisingly there are a number of results for which the choice of canonical forms is not relevant.
Throughout this section I assume that S is an algebraic specification with a parameter specification T such that Definition 3.1.ii is applicable to S.
Lemma 4.1 (Monotonicity) The liftings for  S) are monotone: Assume
P1 ⊆ P2 and R1 ⊆ R2 for suitable predicates P1, P2 and relations R1, R2.

Then:

Proof. Predicate and relation lifting for iterated polynomial functors is mono-
tone [5]. Further, the coproduct	along an arbitrary function is a functor
between fibre categories, thus it also monotone.
The result about monotonicity ensures that Pred( £)) and Rel( £)) are func- tors on PredT and RelT , respectively.
Remark 4.2 Monotonicity also ensures that one can apply the definition of Hensel and Jacobs to get liftings for the (constant) functors µX . £)(X) and νX . £)(X). These are not iterated polynomial functors, so next to nothing is known about these functors and their liftings.
Proposition 4.3 (Truth and Equality) Predicate and relation lifting of £
commute with truth and equality in the following sense:

Proof. The liftings of iterated polynomial functors commute with truth and equality [5]. Further, the Definition 3.1.i ensures that CT contains terms from

every equivalence class, so 
CT = T S)(X).

The preceding result about truth and equality ensures that the truth predicate is an invariant for £)–coalgebras and that the equality relation is a bisimula- tion. The next result can be used to prove that bisimulations are closed under union.
Proposition 4.4 (Unions) Consider the models T and V of 7 and let (Pi ⊆
|T |)i∈I and (Ri ⊆ |T |× |V |)i∈I be collections of predicates and relations over an arbitrary index set I. Assume that the liftings for µX . Sig(—,X) preserve the unions of these collections in the following sense:
   Pred(µX . Sig(—,X))(Pi)	⊆	Pred(µX . Sig(—,X))(   Pi)
i	i
   Rel(µX . Sig(—,X))(Ri)	⊆	Rel(µX . Sig(—,X))(   Ri)
i	i
Then, the liftings of £) do also preserve unions of arbitrary collections:
  Pred( £))(Pi)	⊆	Pred( £))(  Pi)
  Rel( £))(Ri)	⊆	Rel( £))(  Ri)
i	i


T : Loose Specification Operation
k	: T
End T
S[T : T] : Initial Specification Operations
nil	: S
cons : S × T S
m	: S × T S
Variables	l : S; t : T
Axioms
a	: m(l, t)= cons(l, k)
End S

Fig. 2. Specification for Example 4.5
The assumption about the liftings of µX . Sig(—,X) is necessary, because there is (up to my knowledge) no general result available. Further, it only makes sense to assume an inclusion, because equality does not hold in general.
Proof. The coproduct along every function f commutes with arbitrary unions

of collections: 
  Pi = 
f Pi.

As next property I consider fibredness. The predicate lifting for a functor F is fibred if the equation F (f )∗ Pred(F )(P ) = Pred(F )(f ∗ P ) holds for all suitable functions f and predicates P . Similarly the relation lifting for F is fibred if (F (f ) × F (g))∗ Rel(F )(R)= Rel(F )((f × g)∗ R). At first fibredness is the technical property that ensure that Pred(F ) and Rel(F ) are fibred functors (i.e., functors between fibrations) over F . However, fibredness of relation lifting admits an elegant proof for the proposition that says that a function f is a coalgebra homomorphism precisely if its graph is a bisimulation.
The following example shows that fibredness can fail if the canonical forms are not carefully chosen.
Example 4.5 Consider the specification S from Figure 2. It specifies lists with an additional (nonsensical) Operation m such that m(l, t) equals cons(l, k) for an identified constant k of the parameter.
Let T be a model of the parameter T such that |T | = {t1, t2} is a two element set and kT = t1. Then the function f that maps both t1 and t2 to t1 is a morphism T T . The initial semantics of S are the finite lists containing just t1 or t2 with an additional operation m that conses t1 to its argument list.

Let the set of canonical forms CT be the set of all terms.
Consider now the predicate P = {t2}. Note that f ∗ P = ∅. Let [—]Q denote the equivalence class with respect to the relation Q that is used for factoring the initial µX . Sig S(T, X) algebra. We have that [cons(nil, t1)]Q ∈ ( S)(f ))∗ Pred( S))(P ) (because m(nil, t2) ∈ Pred(µX . SigS (—,X))(P ) and Q(µX . SigS (f, X)) maps [cons(nil, t1)]Q to [cons(nil, t1)]Q). However Pred( S))(f ∗ P )= {[nil]Q}.
One obtains a counterexample for fibredness of the relation lifting when considering the relation {(t2, t2)} ⊆ |T |× |T |. Both, predicate and relation lifting are fibred if one restricts the set of canonical forms to those terms that do not contain m.
The last two examples demonstrate that, depending on the canonical forms, the liftings for £) might not commute with intersection and com- position of relations.
Example 4.6 For polynomial functors one has Pred(F )(P ) ∩ Pred(F )(Q)= Pred(F )(P ∩ Q). To obtain a counterexample for this equation for the lifting of £) consider a specification similar to that in Figure 2. This time assume two special elements k and l in T with the axiom cons(nil, k)= cons(nil, l) in S (and ignore the operation m). Let the canonical forms be the set of all terms and consider two predicates P = {k} and Q = {l}. Obviously t = [cons(nil, k)] is in both Pred( £))(P ) and Pred( £))(Q). However, t ∈/ Pred( £))(P ∩ Q). One obtains a counterexample for the intersection of relations from relations that contain (k, k) and (l, l), respectively.
Example 4.7 Again for polynomial functor it holds that Rel(F )(R) ◦ Rel(F )(S)= Rel(F )(R ◦ S). Here is a counterexample for the relation lifting of  £): Consider again the specification of Figure 2 without the operation
m. Assume an axiom cons(nil, k) = nil and let all terms be canonical. Let R be a relation that contains the pair (a, k) for a /= k. Let S be the empty relation. We have that the pair (cons(nil, a), nil) is in the lifting of R and of course (nil, nil) is in the lifting of S. However, R ◦ S is the empty relation, so (cons(nil, a), nil) ∈/ Rel( £))(R ◦ S).

Conclusion
This paper presents a definition of predicate and relation lifting for functors obtained as initial semantics of parametric algebraic specifications. This makes it possible to defined the notion of bisimulation and invariant for coalgebras of such functors. The paper contains examples that show that alternative approaches to define bisimulations for such functors are not satisfactory.


There is an obvious approach to obtain liftings for algebraic specifications: One takes the image of the liftings of Hensel and Jacobs [5] for the initial algebra of the signature along the quotient map that factors the carrier of the initial algebra into a model of the specification. However, this approach does not yield satisfactory notions. Therefore I propose a modified definition that employs sets of canonical forms, which must be developed together with the specification.
The paper investigates some interesting properties of the new liftings. Some of them hold trivially (for instance preserving truth, equality, and unions), other essential properties fail (fibredness, preservation of intersection and relational composition) for a particularly chosen set of canonical forms (the properties might hold for a different choice). So the proposed definition is not completely satisfactory, however, it provides the only means to define bisimulations for functors stemming from algebraic specification.
This work has been inspired by possible extensions of the coalgebraic spec- ification language CCSL [16]. The design of CoCASL [10] also permits nested algebraic and coalgebraic specifications. However, Mossakowski and colleagues do not discuss how to define bisimulations. Several incarnations of the OBJ– Family [3,15] do also permit nested algebraic and coalgebraic (behavioural—in OBJ terms) specifications. In OBJ the notion of behavioural equivalence is not derived in a general way from the signature. Instead the user must specify ob- servers in the subsignature of congruent operations. Behavioural equivalence is then defined via the visible contexts [13] of the congruent operations.
Future work includes the investigation of more properties and a better understanding of the role of the canonical forms. In particular, I would like to derive conditions on the set of canonical forms that ensure for instance that the liftings commute with intersection. It would also be interesting to implement algebraic specifications and their liftings in the CCSL compiler to permit larger case studies.

References
Aczel, P. and P. F. Mendler, A ﬁnal coalgebra theorem, in: D. H. Pitt, D. E. Rydeheard,
P. Dybjer, A. M. Pitts and A. Poign´e, editors, Proceedings of the Conference on Category Theory and Computer Science, LNCS 389 (1989), pp. 357–365.
Carboni, A., G. M. Kelly and R. J. Wood, A 2–categorical approach to change of base and geometric morphisms i., Technical Report 90–1, Department of Pure Mathematics, University of Sydney (1990), iSSN 1033–2359.
Goguen, J. and G. Malcolm, A hidden agenda, Theoretical Computer Science 245 (2000),
pp. 55–101.
Hensel, U., “Definition and Proof Principles for Data and Processes,” Ph.D. thesis, Univ. of Dresden, Germany (1999).


Hensel, U. and B. Jacobs, Proof principles for datatypes with iterated recursion, in: E. Moggi and G. Rosolini, editors, Category Theory and Computer Science, LNCS 1290 (1997), pp. 220–241.
Hermida, C. and B. Jacobs, Structural induction and coinduction in a ﬁbrational setting, Information and Computation 145 (1998), pp. 107–152.
Jacobs, B., Mongruences and cofree coalgebras, in: V. Alagar and M. Nivat, editors, Algebraic Methodology and Software Technology, LNCS 936 (1995), pp. 245–260.
Jacobs, B., “Categorical Logic and Type Theory,” Studies in Logic and the Foundations of Mathematics 141, North Holland, Elsevier, 1999.
Meinke, K. and J. V. Tucker, Universal algebra, in: S. Abramsky, D. M. Gabbay and
T. S. E. Maibaum, editors, Handbook of Logic in Computer Science. Volume 1. Background: Mathematical Structures, Oxford University Press, 1992 pp. 189–409.
Mossakowski, T., H. Reichel, M. Roggenbach and L. Schr¨oder, Algebraic–coalgebraic speciﬁcation in cocasl, to appear in the proceedings of the 16th WADT.
Owre, S., S. Rajan, J. Rushby, N. Shankar and M. Srivas, PVS: Combining speciﬁcation, proof checking, and model checking, in: R. Alur and T. Henzinger, editors, Computer Aided Veriﬁcation, LNCS 1102 (1996), pp. 411–414.
Phoa, W., An introduction to ﬁbrations, topos theory, the effective topos and modest sets, Research report ECS-LFCS-92-208, Lab. for Foundations of Computer Science, University of Edinburgh (1992).
Reichel, H., Behavioural validity of conditional equations in abstract data types, in: Contributions to General Algebra 3, Teubner, 1985 Proceedings of the Vienna Conference, June 21-24, 1984.
R¨oßiger, M., “Coalgebras, Clone Theory and Modal Logic,” Ph.D. thesis, Univ. of Dresden, Germany (2000).
Ro¸su, G., “Hidden Logic,” Ph.D. thesis, University of California at San Diego (2000).
Rothe, J., H. Tews and B. Jacobs, The coalgebraic class speciﬁcation language CCSL, Journal of Universal Computer Science 7 (2001), pp. 175–193.
Rutten, J. J. M. M., Relators and metric bisimulations (extended abstract),  in:
B. Jacobs, L. Moss, H. Reichel and J. Rutten, editors, Workshop on Coalgebraic Methods in Computer Science ’98, ENTCS 11 (1998), pp. 257–263, available at URL http://www.elsevier.nl/locate/entcs.
Rutten, J. J. M. M., Universal coalgebra: A theory of systems, Theoretical Computer Science
249 (2000), pp. 3–80.
Tews, H., Coalgebras for binary methods: Properties of bisimulations and invariants, Theoretical informatics and applications 35 (2001), pp. 83–111.
Tews, H., “Coalgebraic Methods for Object-Oriented Specification,” Ph.D. thesis, University of Dresden (2002), available via http://wwwtcs.inf.tu-dresden.de/~tews .
