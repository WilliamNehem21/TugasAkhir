	Electronic Notes in Theoretical Computer Science 96 (2004) 73–89	
www.elsevier.com/locate/entcs




On the Representation of McCarthy’s amb
in the π-calculus
Arnaud Carayol
IRISA - Rennes and LIP - ENS Lyon, France
Daniel Hirschkoff
LIP - ENS Lyon, France
Davide Sangiorgi
University of Bologna, Italy

Abstract
We study the encoding of λ[], the call by name λ-calculus enriched with McCarthy’s amb operator, into the π-calculus. Semantically, amb is a challenging operator, for the fairness constraints that it expresses. We prove that, under a certain interpretation of divergence in the λ-calculus (weak divergence), a faithful encoding is impossible. However, with a different interpretation of divergence (strong divergence), the encoding is possible, and for this case we derive results and coinductive
proof methods to reason about λ[] that are similar to those for the encoding of pure λ-calculi. We then use these methods to derive the most important laws concerning amb. We take bisimilarity as behavioural equivalence on the π-calculus, which sheds some light on the relationship between fairness and bisimilarity. As a spin-off result, we show that there is no small-step operational
semantics for λ[] that preserves the branching structure of terms and yields the correct predicates of convergence and (weak) divergence.
Keywords: Fairness, McCarhty’s amb, Lambda-Calculus, Pi-Calculus, Behavioural equivalence.

Introduction
The operator of ambiguous choice, amb, was first introduced in [11], to describe a form of composition of (partial) functions that is liable to return one among several results. [11] describes amb by giving its main properties. The two

1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.022

most important properties have to do with fairness. One property says that amb is bottom-avoiding, meaning that the composition of a function with a function that is undefined should return the result of the former function. The other important property says that amb behaves as a non-deterministic choice whenever the results computed by the functions being composed are both defined: either of them may be returned, in an unpredictable way. The usefulness for an operator having the properties of amb has come to light for the specification of systems, in particular operating systems, essentially because a form of fair non-determinism is required to merge incoming messages (see [6,20], and also [8], that studies amb and other nondeterministic operators with respect to this issue). The main reason, however, for our interest in amb is that, semantically, 40 years later, amb remains a very challenging operator [9,13,10,17,5].
The difficulties introduced by amb are clear in λ[], the call-by-name λ- calculus enriched with the binary operator ▢ that is a ‘realisation’ of Mc- Carthy’s amb. The two standard approaches to obtaining semantics and anal- ysis techniques for λ-calculi are the denotational and the operational ones. The former is based on domain theory; in the latter, applicative bisimilarity is exploited to reason about contextual equivalence. The problem for denota- tional analyses is that amb is not continuous (see [13] for a discussion). The operational approach has been followed by Moran, Lassen and Pitcher, in a series of works [9,13,10,17]. The problem of proving congruence of applicative bisimilarity (or a similar coinductively defined relation, that coincides with or at least gives a good approximation of contextual equivalence) is however still open for λ[]. The usual technique for proving congruence of applicative bisim- ilarity in λ-calculi is Howe’s [7], but this technique does not seem to work in presence of amb [10]. Therefore, to prove a set of characteristic laws of amb, some ‘partial’ proof techniques have been developed, in particular in [13,10] (these techniques are partial in the sense that, taken separately, none of them can be used to derive all the laws – see also Section 5). It would be very hard and tedious to prove the laws following the definition of contextual equiva- lence, due to its heavy quantification on contexts.
In the present paper, we explore an alternative way to give the semantics of λ[], via an encoding into the (asynchronous) π-calculus. There were various reasons for carrying out this study. The first reason is the quest for proof methods to reason about languages like λ[] that contain operators express- ing fairness constraints. The problem of encoding the λ-calculus (as well as parallel and nondeterministic extensions of it) into the π-calculus has been extensively studied – see e.g. [12,18,2,19]. In the case of the call-by-name λ-calculus, for example, the π-calculus semantics induces an equivalence on λ-

terms that coincides with the classical L´evy-Longo Tree semantics [19], which shows an agreement between the π-calculus semantics and standard denota- tional analyses of the call-by-name λ-calculus. Moreover, bisimulation is the canonical equivalence in the π-calculus, and comes with a well-developed the- ory, as well as powerful proof techniques that alleviate the task of building bisimulation proofs. One can therefore hope that working in the π-calculus can help in defining useful bisimulation-based techniques for λ[].
A second motivation for this study is expressiveness. The π-calculus has been shown to be a very powerful formalism. We want to understand whether, and under which conditions, the π-calculus can encode an operator as sophis- ticated as amb. We are not aware of other attempts at encoding into the π-calculus operators that express fairness constraints.
Another motivation is the question of fairness in the π-calculus. While the standard SOS rules of the π-calculus make no reference to fairness, the use of bisimulation or of similar semantical equivalences introduces this kind of property. The definition of a semantics for a fair operator like amb is a way to gain a better understanding of this issue. To illustrate this point, consider the π-calculus term τω | a, where τω represents a process that can perform infinitely many internal actions, a is an output at a without value exchange, and “|” is the operator of parallel composition. Under bisimulation equivalence, as opposed to, say, testing equivalence, this process is deemed the same as the process a. One way of interpreting this equality is to say that bisimilarity ignores divergence. However, another way of looking at the equality is to say that bisimilarity encompasses some fairness: under a fair implementation of parallel composition, the left component τω cannot always prevail, hence eventually the action a on the right-hand side will be executed. It is precisely this second – and usually neglected – interpretation of bisimilarity that we are addressing, trying to understand its significance on a non-trivial concrete example.
When studying non-deterministic operators like amb, contextual equiva- lence is defined by observing the ability for two terms, in any context, to exhibit convergences and divergences. Two kinds of divergences can be dis- tinguished (see e.g. [14]): a computation in which convergence is impossible is a strong divergence, while a weak divergence corresponds to an infinite com- putation along which the possibility to converge to a value is never lost. Both forms of divergence arise in λ[]: first notice that Ω, the usual always diverging term, is strongly divergent. To give an example of a weak divergence, we use the operator of internal choice, ⊕, that can be encoded in λ[] as follows:
def
M ⊕ N	=	(K M ▢ K N ) I , 
K and I being the usual combinators for selection and identity. By definition

of λ[], M ⊕ N can nondeterministically evolve to M or N . Now consider the term

T	d=ef
(where Fix is defined as A A, with A
Fix λx. (x ⊕ I)
def
= λxy. y (xx y)). Because of the ‘erratic’

nature of internal choice, T exhibits a weak divergence, along which conver- gence to I is repeatedly discarded. In the operational studies of amb in the literature, strong and weak divergences are not distinguished. In this paper, in contrast, we separate the case in which both strong and weak divergences count from the case in which only strong divergences count. Interestingly, the difference between strong and weak divergence does not affect the character- istic laws of amb: we refer here to a set of laws that capture amb’s essential properties (these laws are studied for example in [13]) – as mentioned above, the original specification of amb [11] is given at a very high level by describing its behavioural properties.
The semantics of amb is very challenging also in the π-calculus. Indeed we prove that, under the usual (i.e., weak) interpretation of divergence in λ[], a faithful encoding into the π-calculus is impossible. By ‘faithful’ we mean that the encoding should be sound and should mimic the behaviour of λ[] terms, at least as far as divergence and reduction to values are concerned. This result holds for the π-calculus, as well as any extension of π-calculus with ﬁnitary operators.
However, we also show that with the strong interpretation of divergence, the encoding of λ[] into the π-calculus is possible, and we derive results and coinductive proof methods to reason about λ[] that are similar to those that have been developed for the encodings of pure λ-calculi (see [19]). We then use these methods to derive the characteristic laws of McCarthy’s amb. Us- ing the π-calculus proof techniques, the proof of some of these laws is very simple, in particular that of the two key laws of amb, the bottom-avoidance

law M ▢ Ω ∼=M
M , and the law V ▢ V ' ∼=M
V ⊕ V ' (where V and V ' are

λ-abstractions). We also study the extension of λ[] with local call-by-value,
again showing an encoding into the π-calculus and then using the encoding for deriving algebraic laws of the source calculus.
We have mentioned above that a characterisation of operational equiva- lence in λ[] as a form of applicative bisimilarity is still an open problem. As a spin-off result of our study suggests that it might indeed be very hard to ob- tain such a bisimilarity. The result says that there is no small-step operational semantics for λ[] that preserves the branching structure of terms and yields the correct predicates of convergence and divergence. An operational semantics having these properties is important for defining bisimilarity in languages with non-determinism like λ[], for bisimulation is based on the branching structure

of terms and to be really useful in practice, in the bisimulation game between two non-deterministic terms, the challenge should use the small-step seman- tics.
Outline. After recalling the necessary definitions and results we need about λ[] and the π-calculus (Section 2), Section 3 presents our semantic framework for McCarthy’s amb, as well as some results for it that motivate the study in the following sections. In Sections 4 to 6, we introduce our π-calculus encoding of λ[], and present a number of applications and developments of it. We conclude and discuss further research directions in Section 7. Detailed proofs can be found in [3].

Background
This section contains background material. (However it also contains some novel results: a new semantics for λ[] and some new up-to proof techniques for coupled simulation.)
The λ-calculus with Ambiguous Choice
We suppose we have an infinite set of variables, ranged over with x, y,... .
Terms of λ[], ranged over with M, N,... , are given by the following grammar:


M	d=ef
x | λx.M | M1 M2 | M1 ▢ M2 .

Bound and free variables are defined as usual. A closed term is a term that contains no free variable. Substitution (written M [N/x]) and α-conversion are defined as usual. We will work up-to α-conversion. Closed values, ranged over with V, V ',... , are abstractions. A context, ranged over with C, C',... is a term containing occurrences of a hole, written [ · ], in it. Given a context C, C[M ] denotes the term obtained by replacing the hole with a term M in
C. Given M , C is closing if C[M ] is closed, this terminology being extended to the case where C ‘closes’ several terms.
Here are some λ[] terms, that will be useful below:

def	def
I = λx. x	Ω = (λx. x x) (λx. x x)

def
def
def

K = λx y. x	Fix = AA where A
= λx y. y (xx y) .

We introduce some notations for relations:
Definition 2.1 (Relations) If R is a binary relation over elements of a set
S, R−1 denotes the inverse of R, while R+ and R∗ denote the transitive (resp.

Beta (λx. M ) N → M [N/x]


Lazy
M → M '


M N → M ' N

Trans
M → M '	M ' → M ''


M → M ''


Par
M → M '	N → N '


M ▢ N → M ' ▢ N '

ValL
M → V	or	M = V M ▢ N → V


Fig. 1. Operational semantics for closed terms of λ[]


transitive and reflexive) closures of R. Composition of two relations R and SS is written RSS, and T Rω stands for the existence of an inﬁnite sequence of elements of S, T = T0, T1,... such that for all i, Ti R Ti+1.
Following [10], we present an operational semantics for closed λ[]-terms.
Definition 2.2 (→) Relation → is deﬁned on closed terms by the rules of

Figure 2.1, where the symmetrical version of
ValL is omitted.

In defining →, we capture the transitive, non-reflexive closure of the underly- ing reduction relation. In rule Par both components of an amb are allowed to evolve. Rules ValL, ValR make the choice between components of an amb, when one of the branches converges.
The λ[]-term I ▢ Ω can only reduce to I (using ValL); it cannot diverge because Par does not apply (remember that → is non-reflexive). If we set
def
W  = Fix λx. x ⊕ I, then the term W ▢ W can reduce to itself by Par and
therefore diverges; it can also converge to I by either ValL or ValR.
Remark 2.3 The semantics → of Figure 2.1 is new. It coincides with the semantics ~ introduced in [13] (see [3]) but is deﬁned directly on λ[]-terms whereas the deﬁnition of ~ requires the use of decorated terms.
Definition 2.4 (⇓ and ⇑) A term M is convergent, written M ⇓, if there exists a value V s.t. M → V or M = V . M is divergent, written M ⇑, if M →ω.
We can remark that by definition of →, a term of the form M ▢ I, for any
M , cannot diverge: this observation will be useful in several proofs below.
Definition 2.5 (Observational equivalence, using divergence) M and N are observationally equivalent, written M ∼=M N, iff for any closing context C:
(C[M ] ⇓  ⇐⇒ C[N ] ⇓)	and	(C[M ] ⇑  ⇐⇒ C[N ] ⇑) .

The Asynchronous π-calculus
We suppose that we have an infinite set of names, also called channels, over which we range with small letters: a, b,... , x, y,.  For the sake of the Asyn-
chronous π-calculus (in short, Aπ) encoding of Section 4, we shall translate a λ[] variable using a π-calculus name, and we suppose that there is an injection from variables to names so that we can keep letter x to refer to the encoding of a variable x. (Possibly empty) name tuples are ranged over with x˜, y˜,... . Aπ terms, to which we shall refer simply as processes, are ranged over using P, Q,.  , and are defined as follows:
=	0 | P1|P2 | !P | νx P | x(y˜).P | x¯⟨y˜⟩ .

Our calculus has the inactive process (0), parallel composition, replication, restriction, the input prefix and asynchronous output. Bound names in pro- cesses are defined by saying that the input and restriction operators are bind- ing. Contexts in Aπ are defined along the lines of λ[] contexts.
Late operational semantics for Aπ is introduced as usual. It defines judge-

ments of the form P
µ
−→ P
', where µ is either an input action of the form a(x˜),

a (bound) output action of the form νx˜ a¯⟨y˜⟩, in which x˜ has a set (instead of a tuple) structure and all names of x˜ occur in y˜, or τ , which denotes internal

def
computation. We introduce the following notations: ⇒ = (
−→τ )∗, −µˆ
def
=
−→τ

µˆ	def	µ	µˆ	def	µˆ
or = if µ = τ , −→	=	−→ otherwise, and =⇒	=	⇒−→⇒.
Structural congruence, ≡, is also defined as usual, to capture some basic structural properties of processes. It is needed in the statement of the following result, which will be useful for a proof below:

Proposition 2.6 (−→τ
/≡ is finitely branching) Given a process P, there is,

up to structural congruence, a ﬁnite number of processes P ' such that P
We shall use the following behavioural relations on processes:
−→τ
P '.

Definition 2.7 (Behavioural equivalences and preorders, ≈,  )
A binary relation R on processes is a weak simulation if P R Q and
µ	'	'	µˆ	'	'	'
P −→ P  imply that there exists Q such that Q =⇒ Q and P R Q .
A weak bisimulation is a symmetric weak simulation. Weak bisimilarity, written ≈, is the greatest weak bisimulation.
A coupled bisimulation is a pair of simulations (SS1, SS−1) such that:
if P SS1 Q then there exists Q' s.t. Q ⇒ Q' and P SS2 Q';
if P SS2 Q then there exists P ' s.t. P ⇒ P ' and P ' SS1 Q.
Two processes P and Q are coupled bisimilar, written P   Q, if there exists

V1 ⊕ (V2 ⊕ V3)


V2	V3

(V1 ⊕ (V2 ⊕ V3)) ▢ V4

V1  V2  V3  V4

Fig. 2. Derivations trees of V1 ⊕ (V2 ⊕ V3) and V1 ⊕ (V2 ⊕ V3 ) ▢ V4 for →

a coupled bisimulation (SS1, SS−1) such that P SS1 Q and P SS2 Q.
Coupled bisimulation has been used for the π-calculus e.g. in [15].

Definition 2.8 (∼=π
) Given a name p, P ⇓p
stands for
νxe p¯⟨y˜⟩
P ⇒−−−−→
for some

x˜ and y˜.	P and Q are observationally equivalent, written P  ∼=π  Q, iff
(for all C and p,  C[P ] ⇓p  ⇔ C[Q] ⇓p)  and  (P ⇒≈ 0 ⇔ Q ⇒≈ 0) .
The definition of ∼=π follows the pattern of ∼=M in λ[] (Definition 2.5, see also Definition 3.7 below). In Aπ, observables are output particles, and visible (strong) divergences, arising from terms that are compelled to diverge, equate such terms with 0.
Proposition 2.9 (Congruence properties) ≈ and   are congruences in
Aπ.
We have ≈⊆  . Moreover, ≈⊆ ∼=π and   ⊆ =∼ , and we shall use both
≈ and  to establish properties of ∼=π. This task will be made easy by the use of up-to techniques, essentially up to context and up to expansion. Such techniques are well-known for ≈ ([19]). We have proved that they can be adapted to  (we omit the details for lack of space, see [3]).

Equivalence in λ[] Revisited
We now present our semantic framework for McCarthy’s amb operator, includ- ing the distinction between strong and weak divergence. We study operational accounts of λ[], and introduce an equivalence based on strong divergences. We also show that if also weak divergences are taken into account in the notion of divergence, then a faithful encoding into the π-calculus is impossible.

Operational descriptions of amb
Let us examine how amb is described by →. If we consider the terms given on Figure 3.1 (where the Vis are values), we see that according to →, amb

composition makes trees degenerate and loose their branching structure. Thus,
→ misses some choices along λ[] computations. This lack of precision can be seen as a drawback for defining a bisimulation-based equivalence for λ[], since such an equivalence usually exploits an accurate analysis of the decisions that are made along computation. Indeed, bisimulation equivalences are known to be more discriminating than trace equivalence, intuitively because they are based on trees and not on single executions (traces). In fact, on all terms of the form M ▢ V , → defines a big step semantics: such a term can only converge (immediately) to a value. → thus appears to be too imprecise to allow one to derive a suitable notion of bisimulation. One could then ask whether this could be improved, by providing a branching preserving presentation of a fair operational semantics for λ[], in the following sense:
Definition 3.1 (Branching preserving semantics) We say that a rela- tion  on λ[] is a branching preserving semantics if for any reduction se- quence M0  ...  Mn  V and any λ[]-term P0, there exists a sequence (Pi)i∈[0,n] such that M0▢P0  + ...  + Mn▢Pn.
This definition expresses the fact that the reduction tree of a term is pre- served when this term is put in parallel with an other term. Standard small step semantics for a language that can express a form of parallel composition and nondeterministic choice usually have this property, as a consequence of their compositional nature. It turns out in this case that imposing this condi- tion to a sufficiently accurate semantics of λ[] prevents it to rule out forbidden divergences (according to amb’s specification).
Theorem 3.2 (No small step semantics preserving branching for λ[]) There exists no branching preserving semantics for λ[] that validates rules Beta and Lazy and induces the same notions of convergence and divergence as →.
Proof (sketch) Let  be a branching preserving semantics for λ[]. We de- fine:
M d=ef Fix (λx. V ' ⊕ (x ⊕ V ))	M ' d=ef M ⊕ V , 
where V and V ' are values. We have:
M   + M '   + V	and	M '   + M   + V ' .
This leads to a contradiction, since we may then infer M ▢ I  + M ' ▢ I  +
M ▢ I, which authorises a divergence that should be ruled out.
This impossibility results therefore suggests that, even if some form of applicative bisimilarity for λ[] were possible (i.e., definable, and provably a congruence), it might be of limited practical usefulness.

Strong vs Weak Divergences
We now study how working within the π-calculus affects the description of λ[]. By reasoning abstractly about ‘reasonable’ translations, we show that we cannot encode amb into the π-calculus if we demand to respect divergences (as defined in Definition 2.4):
Theorem 3.3 (No divergence-faithful encoding) Let be an equivalence relation on π-calculus terms containing structural congruence. There does not exist an encoding [[·]] of λ[] in Aπ such that, for any closed term M:

[M ]]  [[N ]] ⇒ M
=∼M N (soundness w.r.t. ∼=M);

[M ]] −→τ ω
⇔ M →
ω	(divergence faithfulness);

M → V ⇒ [[M ]] −→τ +
[[V ]] (value preservation).

Proof (sketch) We reason on terms such as


Z d=ef
Fix λz. (I ▢ (λx. z (λy. x))

The term ZI can converge to λx1 ... xn. xn, for any n ≥ 1, and cannot diverge. This entails, using clauses (i) and (iii), that the execution tree (mod- ulo ≡) of [Z ] has infinitely many nodes. Using Proposition 2.6, we prove that this implies that this tree has an infinite branch. By clause (ii), this is in contradiction with the fact that Z cannot diverge.
Remark 3.4 The previous result holds in any finitary (i.e. preserving Propo- sition 2.6) extension of Aπ. To our knowledge, all extensions of the π-calculus considered in the literature are ﬁnitary, except for those including the operator of inﬁnite sum.
As illustrated in Section 1, working with bisimulation in Aπ leads us to distinguish between strong and weak divergences, that are defined as follows:

Definition 3.5 (Strong and weak divergences) Let M be a λ[] term.
M is strongly divergent, written M ², if M can evolve into a term that cannot converge;
M is weakly divergent if M exhibits an inﬁnite computation along which it never loses the possibility to converge.
A divergent term (Definition 2.4) is either strongly or weakly divergent, or both, as is T ⊕ Ω (T is defined in Section 1).
Remark 3.6 The difference between strong and weak divergences already ap- pears in [14]. The authors give a topological argument to show that the set



[[λx.M ]]p
def
=
νl (p¯⟨l⟩ | l(x, q).[[M ]]
q )	[x]]p
def
=
νp' (x¯⟨p'⟩ | p' d p)

[[M N ]]p
def
=
νq  [[M ]]q
| q(l). νx ¯l⟨x, p⟩ | !x(r).[[N ]]r

[[M ▢N ]]	d=ef
νp' ([[M ]] ' | [[N ]] ' | p' d p)	where q d p d=ef
q(x).p¯⟨x⟩



Fig. 3. Encoding of λ[] in the π-calculus

of weakly divergent computations is ‘small’ in the set of all computations and therefore can be neglected. It is actually possible to introduce a reasonable op- erational semantics for λ[] such that the set of convergent computations and the set of strongly divergent computations have a non null measure, while the set of weakly divergent computations has a null measure.
A divergent term (Definition 2.4) is either strongly or weakly divergent, or both, as is T ⊕ Ω (T is defined in Section 1).
We now adapt Definition 2.5 to focus on strong divergences.
Definition 3.7 (∼=λ) For any M, N, M ∼=λ N if for any closing context C:
(C[M ] ⇓  ⇔ C[N ] ⇓)	and	(C[M ] ²  ⇔ C[N ] ²) .
Relations ∼=λ and =∼ (Definition 2.5) are incomparable: as ∼=M is sensitive
to weak divergences, it separates terms that are equated by ∼=λ, hence ∼=λ/⊆ ∼=M.

Conversely, =∼ /⊇ ∼=M
have for instance:
because ∼=M

~
λ
identifies weak and strong divergences. We

/∼=λ

I
/∼=M
Fix λx. (x ⊕ I)
~
M
Ω ⊕ I . 

Theorem 3.2 does not hold if only strong divergence counts, see [3].

Encoding and soundness
Our encoding, written [ ], is defined on Figure 4, and follows the usual en- codings of the λ-calculus for the operators of application and abstraction. A λ[]-term M is mapped to a process [M ]]p, p being a channel where the value of (the encoding of) M will be passed (cf. the clause for abstraction).
To take ▢ into account, we run the encodings of M and N in parallel at a freshly created location q, and let the (ephemeral) link process q d p


M ▢ N ∼=λ N ▢ M	(M ▢ N ) ▢ P ∼=λ M ▢ (N ▢ P )
(λx. M ) N ∼=λ M [N/x]	M ▢ Ω ∼=λ M	V ⊕ V ' =∼	V ▢ V '
(M ⊕ N ) ⊕ P ∼=λ M ⊕ (N ⊕ P )	M ▢ M ∼=λ M for M closed

Fig. 4. Some properties of amb



forward any successfully terminated evaluation on p. Once q d p has been triggered by one of the components, the other component is isolated from the context, either because it tries to interact on the private channel q, or because it diverges. Modulo ∼=π, this corresponds to what we expect from amb.
Note the extra indirection p' d p in the encoding of variables. A similar indirection is needed in the encoding of call-by-value into (untyped) π-calculus, and can be removed using capability types [19]. We do not know how to avoid the indirection in the encoding of Figure 4 using types or other means.
Below is the soundness result for [ ]. To prove it, we first establish op- erational correspondence, where each ‹→ reduction in λ[] is associated (up to expansion, a behavioural preorder related to weak bisimilarity) to a (non-
empty) sequence of −→τ  reduction steps in the encoding π-calculus terms.
Theorem 4.1 (Soundness) For any M, N in λ[] and name p, [[M ]]p  ∼=π
[[N ]]p implies M ∼ N.


Deriving characteristic properties of amb
Figure 4 presents a set of characteristic laws of amb we have been able to establish. The proofs of these results are all based on the same method: we compute the Aπ encoding of the two λ[]-terms being compared, construct a (weak or coupled) bisimulation to show (possibly using up-to techniques and

algebraic laws for Aπ) that these processes are related by =∼
, and conclude

using Theorem 4.1.
We give an illustration of this method for the bottom avoidance property

M ▢ Ω ∼=λ
M , one of the key fairness properties of amb. We first need a

technical result:
Lemma 5.1 For any term M of λ[] and name p, [[M ]]p ≈ νq ([[M ]]q | q d p).

This is now how we show that for any term M , M ▢Ω ∼=λ M :


[[M ▢Ω]]p
def
=	q ([[M ]]q | [[Ω]]q | q d p)
≈ νq ([[M ]]q | q d p)	because [[Ω]]q ≈ 0
≈ [[M ]]p	using Lemma 5.1

Along these lines, we prove associativity and commutativity of amb, and that ∼=λ validates the β rule. We also establish associativity of internal choice (⊕): it has to be stressed that for this proof, we are compelled to reason with
  (and not ≈), because of the presence of ‘partially committed states’ in the execution of choices.
We have also established equations like I ∼=λ Fix (λx. (I ⊕ x)), that holds because we consider only strong divergences (this law is not valid in the setting of [13,10]).

Derived techniques.
We can also use the π-calculus encoding to derive proof techniques similar to those used in the literature to proof the laws of λ[] [13,10]. For instance, below we derive a technique that is similar to the “Kleene equivalence” tech- nique.
Definition 5.2 (=) For two λ[] terms M and N, M = N iff

if M ‹→+ V , there exists V ' s.t. N ‹→+ V ' and, for any p, [[V ]]p   [[V ']]p;
M ² iff N ².
Proposition 5.3 (Soundness of =) =⊆ ∼=λ.
Aside the use of π-calculus, the main difference with “Kleene equivalence” is that, in clause (i), the latter uses syntactic equality to compare V and V ', while we can rely on behavioural equivalences (since ≈⊆ , we can also use ≈ to compare [V ]]p and [V ']]p when treating clause (i) above). As an example of consequence of this difference, Proposition 5.3 allows us to show that λx. (x ▢ Ω) ∼=λ I, which cannot be proved using the “Kleene equivalence” technique.

Full abstraction.
As expected, our method is not fully-abstract with respect to ∼=λ (because
we use bisimilarity in the π-calculus whereas ∼=λ is purely contextual; this situation is standard for encodings of λ-calculi into the π-calculus). We can



[[λx.M ]]p
[[let x = M in N ]]p
def
=	l (p¯⟨l⟩ | !l(x, q).[[M ]]q )
def
=	q ([[M ]]q | q(v).([[N ]]p | !x(r).r¯⟨v⟩))


Fig. 5. π-calculus encoding of λ[] with local call-by-value

however derive a partial full-abstraction result (partial in the sense that we only compare pure λ-terms), for the ‘open’ version of applicative bisimilarity (see [19, Part VI]). This relation, written ∼=op, is defined by extending relation
→ to open terms, and saying that a term having a free variable in head
position is stuck. In the following definition, we keep the same notation → for the extended version of the operational semantics.

Definition 5.4 (Open applicative bisimilarity) ∼=op
is the largest sym-

metric relation on λ[] such that, whenever M ∼=op N,

M → λx. M ' implies N → λx. N ' with M ' ∼=op
N ';

M → x M1 ... Mn with n ≥ 0 implies N → x N1 ... Nn and Mi
for all 1 ≤ i ≤ n.
∼op
λ	i

Theorem 5.5 (Partial full abstraction) Let M, N be two pure λ-terms, and p a name. Then
[[M ]]p ≈ [[N ]]p	iff	M ∼=op N . 
It can be noted that for the λ-calculus extended with internal choice, the problem of full abstraction on the whole calculus (whether the π-calculus encoding is fully abstract wrt open applicative bisimilarity) is still open. The same question in λ[] seems at least as difficult.

Local call by value
An important enrichment of λ[] is that with the familiar let... in construction, that introduces a form of local call by value in the language. The corresponding additional reduction rule is:


Let
M ‹→ V


let x = M in N ‹→ N [V/x]

The encoding of the resulting calculus is obtained by a modification of the encoding presented above, as shown on Figure 6 (clauses that are left un- changed are not mentioned). The translation of a let... in construct consists

in the evaluation of the locally declared term, followed by the evaluation of the term after the “in” in which the bound variable is replaced by the com- puted value. We also add persistence, using replication, in the encoding of abstractions, since in presence of let... in, several copies of a function may be triggered along a computation.
The results presented in previous sections also holds on λ[] with let. For instance, soundness becomes:
Theorem 6.1 For any terms M, N of λ[] enriched with local call-by-value,

and for any name p, [[M ]]p ∼=π
[[N ]]p
implies M ∼=λ N.

Again, using simple bisimulation reasoning, we have derived these example laws for λ[] with let:
let x = V in M  ∼=λ (λx. M ) V	let x = M in x ▢ x ∼=λ M  for M closed
let x =Ω in M ∼=λ Ω   let x = M in N ∼=λ N  if M ⇓ and x /∈ fn(N ) .

Further results and remarks
In the paper we have distinguished strong and weak divergences, and showed that only strong divergences should count in order to obtain a semantics to λ[] using the π-calculus. We think that both resulting semantics – the one where both strong and weak divergences count, and the one where only strong divergences count – are interesting. However, one may argue that in languages with operators like amb, a general fairness requirement that a computation should not “always miss a reachable value” – obtained by counting only the strong divergences – appears more reasonable (for instance, a computation starting from the term T in Section 1 should not always miss the value I).
Parallel operators that have similarities with amb and that have been stud- ied in λ-calculi are those in [4] and [1]. These are “parallel”, rather than “choice” operators, and do not give rise to the issues of fairness that amb does. Indeed, semantically, these operators are much simpler than amb. (The encoding into the π-calculus is straightforward, see [19].)
In the full paper [3] we discuss a few variants of the π-calculus encoding of Section 4. For instance, we discuss why certain simplifications of the encoding would not allow us to obtain some of the results in Sections 4-6.
Some of the laws we have established express amb’s fairness in Aπ, and in our setting are derived exploiting bisimulation. It would be interesting to go further in this direction in order to gain a better understanding of the fairness brought by bisimulation. A way to do this is to study π-calculus semantics of other fair operators, like e.g. fair merge, which is more expressive than

amb [16,5]. This operator computes the merge of two (finite or infinite) lists in a fair fashion, also in the case when the lists contain divergences. We have adapted an argument of [16] and proved that it is impossible to represent fair merge into the π-calculus at an operational level; see the full paper [3]. An interesting question is the definability of fair merge modulo bisimulation, i.e. at a behavioural level.

Acknowledgement
We would like to thank Mariangiola Dezani for insightful discussions, as well as the anonymous referees for useful remarks.
This work has been supported by the european FET - Global Computing project Profundis.

References
G. Boudol. Lambda-calculi for (strict) parallel functions. In Information and Computation, volume 108, pages 51–127, 1994.
G. Boudol and C. Laneve. Lambda-calculus, multiplicities and the pi-calculus. In Proof, Language, and Interaction, Essays in Honour of Robin Milner. MIT Press, 2000.
A. Carayol, D. Hirschkoff, and D. Sangiorgi. A π-calculus view on McCarthy’s amb. full version, in preparation – available at
http://www.irisa.fr/galion/acarayol/RR.ps, 2003.
M. Dezani-Ciancaglini, U. de’Liguoro, and A. Piperno. A filter model for concurrent λ-calculus.
SIAM J. Comput., 27(5):1376–1419, 1998.
Maribel Fernandez and Lionel Khalil.	Interaction nets with mccarthy’s amb.	In
Electronic Notes in Theoretical Computer Science, volume 68. Elsevier, 2002, URL:
http://www.elsevier.nl/locate/entcs/volume68.html

P. Henderson. Purely functional operating systems. In Functional Programming and its Applications, pages 177–192. Cambridge Univ. Press, 1982.
D. J. Howe.  Proving congruence of bisimulation in functional program-ming languages.
Information and Computation, 124(2):103–112, 1996.
J. Hughes and J. O’Donnell. Expressing and reasoning about non-deterministic functional programs. In Proc. Glasgow 1989 Workshop on Functional Programming, Workshops in Computing. Springer Verlag, 1990.
S. Lassen. Relational reasoning about functions and nondeterminism. PhD thesis, Aarhus University, 1998.
S. Lassen and A. Moran. Unique fixed point induction for McCarthy’s Amb. In Proc. of MFCS’99, volume 1672 of LNCS, pages 198–208. Springer Verlag, 1999.
J. McCarthy. A basis for a mathematical theory of computation. In Computer Programming and Formal Systems, pages 33–70. North-Holland, 1963.
R. Milner. Functions as processes. Technical Report 1154, INRIA Sophia Antipolis, 1990.


A. Moran. Call-by-name, Call-by-need, and McCarthy’s Amb. PhD thesis, Chalmers Univ. of Technology and Univ. of Gothenburg, 1998.
V. Natarajan and R. Cleaveland. Divergence and fair testing. In Proc. ICALP 95, volume 944 of LNCS, pages 648–659. Springer Verlag, 1995.
U. Nestmann and B. Pierce. Decoding choice encodings. In International Conference on Concurrency Theory, pages 179–194, 1996.
P. Panangaden and V. Shanbhogue. McCarthy’s amb cannot implement fair merge. In Proc. of FST-TCS, volume 338 of LNCS, pages 348–363. Springer Verlag, 1988.
C. Pitcher. Functional programming and erratic non-determinism. PhD thesis, Oxford University, 2001.
D. Sangiorgi. The lazy lambda calculus in a concurrency scenario. In Proc. 7th LICS Conf., pages 102–109. IEEE Computer Society Press, 1992.
D. Sangiorgi and D. Walker. The π-calculus: a Theory of Mobile Processes. Cambridge University Press, 2001.
D. Turner. An approach to functional operating systems. In Research Topics in Functional Programming. Addison Wesley, 1990.
