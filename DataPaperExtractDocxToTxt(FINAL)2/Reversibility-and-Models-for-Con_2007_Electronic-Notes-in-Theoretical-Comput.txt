	Electronic Notes in Theoretical Computer Science 192 (2007) 93–108	
www.elsevier.com/locate/entcs

Reversibility and Models for Concurrency
Iain Phillips1
Department of Computing Imperial College London
180 Queen’s Gate, London, SW7 2AZ, United Kingdom
Irek Ulidowski2
Department of Computer Science University of Leicester
University Road, Leicester, LE1 7RH, United Kingdom

Abstract
There is a growing interest in models of reversible computation driven by exciting application areas such as bio-systems and quantum computing. Reversible process algebras RCCS [2] and CCSK [8] were developed and general techniques for reversing other process operators were proposed. The paper shows that the notion of reversibility can bridge the gap between some interleaving models and non-interleaving models of concurrency, and makes them interchangeable. We prove that transition systems associated with reversible process algebras are equivalent as models to labelled prime event structures. Furthermore, we show that forward-reverse bisimulation corresponds to hereditary history-preserving bisimulation in the setting with no auto-concurrency and no auto-causation.
Keywords: Reversible computation, labelled transition systems, prime event structures, hereditary history-preserving bisimulation


Introduction
CCS with Communication Keys (CCSK) [8] is a reversible version of CCS which can be used to model and analyse bidirectional behaviour of systems, for example the binding and unbinding of molecules in biochemical reactions. The definition of CCSK is given in the Structural Operational Semantics (SOS) style, and the SOS approach is also employed to give a procedure for converting operators of other pro- cess algebras into reversible operators [8]. The main idea is that dynamic operators (which can be destroyed in the course of a transition) are converted by the proce- dure into static operators (which are preserved), using new auxiliary operators. For

1 Email: iccp@doc.ic.ac.uk
2 Email: iu3@mcs.le.ac.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.018

instance, both sides of a choice P + Q are retained. As a result process terms in the new reversible language do not change their overall structure during computation. A crucial component of the procedure is the notion of communication keys. These are unique identifiers that are assigned to, and are recorded in the syntax of, past actions and are vital for the communication mechanism to work correctly in the forward and reverse directions. In contrast, in RCCS [2] past behaviour, including communication, is stored on external devices such as memories.
A process algebra of reversible operators produced by the procedure from [8] gives rise to a forward labelled transition relation (ltr) → and a reverse ltr ~, which is the inverse of →. These ltrs enjoy a number of intuitive properties that arise directly in the presence of reversibility. Some of the properties, for example the Reverse Diamond property (see Definition 2.3), can be thought of as intrin- sic properties of reversible transition systems. Other properties, for example the Non-repeating property (see Section 2.1), are more specific and a consequence of using the communication keys mechanism. In this paper we investigate properties of this sort and propose an abstract definition of reversible transition systems by identifying several properties that must be satisfied. We find that reversible tran- sition systems are rich enough to express such true concurrency (non-interleaving) notions as events, concurrency, causality and conflict. Consequently, we show that reversible transition systems are equivalent as models to prime event structures. Hence, we can study and work with true concurrency semantics within the purely interleaving setting of reversible transition systems.
This result leads naturally to questions regarding the distinguishing power of the standard interleaving equivalences defined over reversible transition systems. For instance: What true concurrency bisimulation is the forward-reverse (FR) bisimu- lation relation [8] “closest” to? FR bisimulation, a natural notion of bisimulation over reversible transition systems, is clearly finer than the standard bisimulation as it distinguishes between a | b and ab + ba. It is also finer than the two versions of history-preserving bisimulation as given in [5] since it does not satisfy the absorp- tion law: (a | (b + c)) + (a | b)+ ((a + c) | b)= (a | (b + c)) + ((a + c) | b). We show that FR bisimulation coincides with hereditary history-preserving (HHP) bisimula- tion, which is regarded as the canonical true concurrency equivalence [1,5,7,3]. The result holds for reversible transition systems with no auto-concurrency and with no auto-causation, and since CCSK gives rise to such transition systems the result holds for CCSK.

Prime ltrs and prime graphs
We propose a class of transition systems that are equivalent to labelled prime event structures. Previously, Sassone, Nielsen and Winskel [9] introduced occurrence tran- sition systems with independence relation (oTSI). The independence relation is de- fined on transitions by giving the conditions it satisfies; it says which transitions are concurrent. It is rich enough to express the causality and conflict relations of event structures. Sassone et al. show that prime event structures with binary con-

flict are equivalent to oTSIs which satisfy an extra property (E) [9]. Independently, van Glabbeek defines history-preserving process graphs [4] by setting a number of properties relating to concurrent history of processes that must be satisfied. These graphs are as expressive as event structures. In this work we follow van Glabbeek’s approach and do not use independence relations.
In the literature, a labelled transition system, or lts for short, may or may not have an initial state. Let us deem an ltr to be a structure that specifies a transition relation with no initial state and an lts to be an ltr with an initial state. Thus an lts can be seen as a rooted ltr.
Definition 2.1 A labelled transition relation is a structure (Proc, Lab, →), where Proc is the set of processes, Lab is the set of action labels and → ⊆ Proc×Lab×Proc is a transition relation. Given →, a reverse transition relation ~ is the inverse of
→. A labelled transition system is a structure (Proc, Lab, →,I) where I ∈ Proc is the initial state.
We let P, Q, S,T,... be typical processes and a, b, c, d be typical action labels.
We shall keep Lab fixed throughout the paper.
Definition 2.2 [6] Let (Proc, Lab, →) be an ltr. Let ∼ be the smallest equivalence

relation satisfying: if P →a
Q →b
S and P →b
R →a
S and Q /= R then (P, a, Q) ∼

(R, a, S). The equivalence classes, written [P, a, Q], are the events. Define a labelling function l from → / ∼ to Lab by setting l([P, a, Q]) = a.
Definition 2.3 A prime ltr is an ltr (Proc, Lab, →) satisfying the following:
WF (well-founded) there is no infinite reverse computation;

UT (unique transition) if P →a
Q and P →b
Q then a = b;

ED (event-deterministic [9,4]) if P →a
then Q = R;
Q and P →a
R, and (P, a, Q) ∼ (P, a, R),

RD (reverse diamond) if Q →a
P , R →b
P and Q /= R, then there is S such that

S →a R, S →b Q;

FD (forward diamond) if P →a
Q →∗ T , P →b
R →∗ T , and Q /= R, then there is

S such that Q →b
S, R →a
S and S →∗ T .

It can be checked that all five properties are independent of each other. The most interesting cases are showing that ED and FD are not derivable from the others: see Figures 1 and 2 respectively. Note that the transitions in all figures ought to be read from left to right when the arrowheads are not displayed. In Figure 1 we
see that in each graph P →a Q, P →a R and the two transitions represent the same
event. Note that reverse ED can be derived from RD and (forward) ED.
We now show that the ltr of [8] which we briefly outlined in the introduction is an example of a prime ltr. Unfortunately space does not permit us to give the fairly lengthy definition of the ltr here.
Proposition 2.4 The ltr of [8] is a prime ltr.

b	Q
a	b	a
P a	Q
a
b	c  R

I
a	c  b
b	R	I
P	a	a
Fig. 1.
c
c		a  c
b



c
Fig. 2.

Proof. This is shown in [8] for RD and FD. WF is clear. For UT: it is clear that

if P →a
Q and P →b
Q then the transitions have the same key.

For ED, note that terms do not change structure during a computation, except that some static operators f become auxiliary operators fr. So any fr[m] must have been created in exactly the same position by two transitions on opposite sides of a diamond. This must also hold for ∼. Hence the result.	 
Next, we give several definitions and results that will be crucial in proving our main results.
Definition 2.5 Let (Proc, Lab, →) be an ltr. A path from P to Q is a finite forward computation from P to Q.
Definition 2.6 [4, Definition 3.1] Say that two paths in a ltr are adjacent if one

can be got from the other by replacing some segment P →a
R →b
Q by P →b
S →a Q.

Say that two paths are homotopic if they are related by the reflexive and transitive closure of adjacency.
Note that we can assume that R /= S in the definition of adjacency when dealing with prime ltrs, by UT. So homotopic paths have the same events.
Let (Proc, Lab, →) be a prime ltr. Then the irreversible processes are Irr = {P ∈
Proc : P /~}; let der(P )= {Q ∈ Proc : P →∗ Q}.
Lemma 2.7 Suppose that (Proc, Lab, →) is a prime ltr. Suppose that P ∈ Proc,
Q, R ∈ Irr and s, t are paths from Q, R to P. Then Q = R and s, t are homotopic.
Proof. By RD and UT.	 

P	a	Q



T





P	a	Q
c	b	b
R	a
Fig. 3.
S


P	a	Q

a	c	a
V	W T	U	T
b	c
b	c

R	a	S



Fig. 4.
R	a	S

Proposition 2.8 Any two paths in a prime ltr with the same endpoints are homo- topic.
Proof. ¿From Lemma 2.7 by extending backwards to an irreversible process, using WF.	 
Proposition 2.8 tells us that any two paths with the same endpoints have the same multiset of events. We want to show that any path cannot have repeated events. If this is the case then any P ∈ Proc is associated with a well-defined set of events, namely the set of events in any path from some Q ∈ Irr to P .
Lemma 2.9 Let (Proc, Lab, →) be a prime ltr. If (P, a, Q) ∼ (R, a, S) then there are T, U as in Figure 3 such that the processes on opposite sides of each diamond are unequal, and the events in the paths from T to P, R and from U to Q, S are all different from [P, a, Q].
Proof. The essence of the proof is to show that if one has P, Q, R, S, T, U as in the first graph in Figure 4, with the transitions from P, R to T and from Q, S to U , then there exist V, W and the appropriate dotted transitions (for example from V to P, R). We use reverse ED and RD.	 
Proposition 2.10 Let (Proc, Lab, →) be a prime ltr. In any path there are no repeated events.
Proof. Suppose we have a path from P to S via Q, R as in the second graph in Figure 4, with (P, a, Q) ∼ (R, a, S). Then by Lemma 2.9 we have T, U as in Figure 3. But now there are two different paths from T to R, one containing [P, a, Q] and one

not. This contradicts Proposition 2.8.	 

A rooted path is a forward computation P
a1 P  a2
an P
where P
∈ Irr.

0 →	1 → ··· →	n	0
Define e < e' if and only if e /= e' and all rooted paths that contain a representative of e' also contain a representative of e. (Note that we are generalising the [6] definition to ltrs rather than process graphs with a single initial state.)

Lemma 2.11 (Sideways diamond) In a prime ltr, if P →a
Q →b
R and [P, a, Q] /<

[Q, b, R] then there is S such that P →b S →a R.
Proof. (Sketch, with abuse of notation between events and labels of events) Since [P, a, Q] /< [Q, b, R] there is a rooted path that contains b but no a before b. Using Lemma 2.9, we connect the two instances of b back to their common earliest b. On the path back from R via the earliest b there must be an occurrence of a (extend back to the coomon root and use Proposition 2.8). Hence, there is a path π with b

before a. Now we apply RD to P →a
Q →b
R and the transitions of the top segment

of π starting with the a transition. Then we use FD to promote the a along π
towards R, eventually obtaining the result.	 
Definition 2.12 A process graph, or graph, is an lts where every process is reach- able via the transition relation from the initial state.
Proposition 2.13 Suppose that (Proc, Lab, →) is a prime ltr. If P ∈ Irr then
der(P ) is closed under ~.
Proof. By Lemma 2.7.	 
Finally, we are ready to define the central structure of the paper.
Definition 2.14 A prime (process) graph is a graph G = (G, Lab, →,I) such that (G, Lab, →) is a prime ltr.
The components of a prime graph G will be denoted by GG , →G , and IG . We shall omit the subscript G when it is clear from the context, and we shall use this naming convention with other structures given as tuples.
The property WF guarantees that prime graphs are acyclic.
Proposition 2.15 Let (G, Lab, →) be a prime ltr, and let I  ∈  Irr.  Then
(der(I), Lab, (→∩ der(I)2),I) is a prime graph.
Proof. We use Proposition 2.13. It is easy to check that the properties of prime ltrs hold for der(I).	 

Process graphs for CCSK
We proved in Proposition 2.4 that the process graphs that we get for CCSK are prime graphs. Moreover, CCSK process graphs satisfy an additional property:
NR (non-repeating) there are no repeated labels in forward computations.

NR and WF imply what is called the nonrepetitive property in [4]. CCSK graphs satisfy NR as a consequence of using the keys mechanism mentioned in the intro- duction:
Proposition 2.16 The ltr of [8] satisﬁes NR.
Prime graphs that satisfy NR are called non-repeating prime graphs. We shall show in Section 4 that prime event structures that correspond to non-repeating prime graphs enjoy the properties of no auto-concurrency [1] and no auto-causation.

Local characterisation of prime graphs
Several of the properties of prime graphs, notably ED and FD, are global in char- acter: in order to verify them one may need to inspect an arbitrarily large portion of a graph. The global character, however, makes them very useful in proving other properties and results for prime graphs. An open question was posed by Sassone et al. in [9]: Can one find a set of properties that involve only local information that characterise a form of transition systems that are equivalent to prime event struc- tures (with binary conflict)? We answer this question for prime event structures with general (not necessarily binary) conflict by proposing local versions of the ED and FD properties:
ED2 (event-deterministic 2)


if	P	Q
then P=Q



FD2 (forward diamond 2)




c	c
if	then	c




Note that ED2 could be seen as a form of a forward diamond property: if

S →a →b
P and S →b →a
P is a forward diamond and there is another ab diamond from

S to Q, then P = Q. In other words, if there a forward diamond from S to P , then such P is unique.
Definition 2.17 A prime2 graph is defined as a prime graph except that its ltr component satisfies ED2 and FD2 instead of ED and FD, respectively.

Note that the graph in the definition of ED2 is isomorphic to the first graph in Figure 1. Looking back at RD, the state S is the unique such S for prime2 graphs. This can be proved using RD three times and then ED2. We shall denote RD with unique S by RD2. We also have that P in FD2 is the unique such P , as can be proved using FD2 and ED2. We can define reverse Event Determinism (reverse ED2) property by reversing the arrows in ED2. Then reverse ED2 follows easily from RD2.
Proposition 2.18 Prime graphs are prime2 graphs and vice versa.
Proof. Omitted.	 

Prime event structures
We would like to map prime graphs into prime event structures, and vice versa, so that we can then compare our FR bisimulation with HHP bisimulation.
The definition below of a prime event structure is taken from [6] and is consistent with the original definition by Winskel [10]. It generalises prime event structures with binary conflict relation.
Definition 3.1 A labelled prime event structure is a tuple E = (E, <, , l), where E is the set of events, < ⊆ E × E is a partial order, called the causality relation, satisfying the principle of finite causes: {e' ∈ E | e' < e} is finite for each e ∈ E, and ⊆ P(E) is a set of finite, nonempty, non-singleton subsets of E, called the conflict relation, satisfying the principles of extension:
 X and Y ⊆fin E implies (X ∪ Y )
and conflict heredity :
 (X ∪ {e}) and e < e' implies (X ∪ {e'}),
and l : E → Lab is a labelling function.
A set of events X is conflict-free if X ∈/ . A prime event structure has a binary conflict if for every X such that X there is Y with only two elements, Y ⊆ X and
 Y .
Given a set of events X of E, the set of events below X, written as X↓, is defined as {e' ∈ E | ∃e ∈ X. e' ≤ e}. X is downwards-closed if X = X↓.
Two prime event structures are isomorphic if and only if there exists a bijection between their sets of events which preserves and reflects the causality relation, the conflict relation and the labelling.
Example 3.2 Consider the event structure with events {a, b, c} and where {a, b, c}, with no other conflict and no causation. This event structure is equivalent to no prime event structure with binary conflict.

The behaviour of a prime event structure is represented in terms of conﬁgura- tions: finite subsets of events which are conflict-free and downwards-closed. Given a prime event structure E, cfs(EE ) is the set of its configurations. The conﬁguration graph for E, written as cg(E), has configurations of EE as its states and is got by taking ∅ as the initial state and setting X →a cg(E) Y if Y \ X = {e} with l(e)= a. Such configuration graphs are ranged over by C, D and have the sets of configu- rations CC, DD; the associated transition relations are →C, →D, respectively. The reverse transition relations are ~C, ~D, respectively.
Proposition 3.3 The conﬁguration graph of a prime event structure is a prime graph.
Proof. Let C be the configuration graph of a prime event structure. It suffices to check all the properties of prime graphs hold for C.
WF follows from the fact that configurations are finite subsets of events, and when we compute in reverse we decrease the size of configurations.

UT follows from the definition of →C: X
event and its label is a.
→a C Y implies Y \ X has just one

ED follows by the definition of configurations and →C.
RD is due to the fact that intersection of two configurations is also a config- uration for prime event structures [4]. For configurations P, Q, R and S we have P = Q ∪ {a}, P = R ∪ {b}, so there is S such that Q = S ∪ {b} and R = S ∪ {a}. The intersection of Q and R is a configuration, meaning that S is a configuration.
FD follows from a reachability property of configurations [4], namely that if X, Y, Z are configurations and X ∪ Y ⊆ Z then X ∪ Y is a configuration. For configurations P, Q, R and T we have Q = P ∪{a}, R = P ∪{b} and Q∪R ⊆ T , so Q ∪ R is a configuration and S = Q ∪ R.

The configuration graph of the event structure in Example 3.2 forms three faces of a cube. It is a prime graph.
The configuration graph corresponding to an event structure in full generality (i.e. not necessarily prime) may not satisfy some of the properties of prime graphs:

Example 3.4 Consider the parallel switch of [10, Example 1.1.7], where the bulb will light if either of two switches is closed. This is an example of so-called or- causation where a disjunction of events causes an event. We have event b (bulb)

caused by either of the switch events 0 or 1, and {0, b} →1
{0, 1, b}, {1, b} →0
{0, 1, b}.

But {b} is not a configuration, so that we cannot complete the reverse diamond and, hence, RD does not hold.
A “non-repeating” condition for prime event structures concerns events:

Definition 3.5 A labelled prime event structure is non-repeating if for any events
e, e', if l(e)= l(e') then e = e' or {e, e'}.
The reason for the name is that no two events that occur in a configuration can have the same label. Another way to look at this is that a configuration gives rise to a set of labels, rather than a multiset of labels, as would otherwise be the case in general. It is equivalent to no auto-concurrency [1] and no auto-causation: if e < e' then l(e) /= l(e').
Proposition 3.6 No two events of a conﬁguration of a non-repeating prime event structure have the same label.

Correspondence of prime graphs and prime event structures
Van Glabbeek and Vaandrager [6] give a method for assigning to a process graph G (with initial state) a labelled prime event structure es(G). The method is as follows. Take any process graph G = (G, Lab, →,I). The relation ∼ and the events [P, a, Q] are defined as in Section 2. Let E = →/∼. Define a labelling function l : E → Lab by setting l([P, a, Q]) = a. A rooted path is a forward computation
a1	a2	an
I = P0 → P  → ··· → P  starting at the root. Define e < e' if and only if e /= e'
and all rooted paths that contain a representative of e' also contain a representative of e. Let X ⊆ E be finite. We define X if and only if G does not have a rooted path containing representatives of all events in X. Then E = (E, <, , l) is a prime event structure.
Van Glabbeek and Vaandrager show in [6] that if E is a prime event structure then es(cg(E)) = E. Here we do not distinguish isomorphic process graphs. This shows that prime event structures are embeddable in process graphs.
Proposition 4.1 Given a prime event structure E , es(cg(E)) = E .
We shall show that any prime graph is the configuration graph of the event structure got from the prime graph by the procedure described above, namely:
Theorem 4.2 Given a prime graph G, cg(es(G)) = G.
The rest of this section is devoted to proving the theorem.
Consider es(G). Clearly the configuration corresponding to P ∈ G is just the

set of events executed up to P . Let I = P
a1 P	a2
an P
= P be a path

0 →	1
→ ··· →	n

with endpoint P . So we define the configuration associated with P as cf(P ) =
{[Pi, ai+1, Pi+1] : i < n}. Clearly cf(P ) ∈ cfs(es(G)). We have that cf(P ) is well- defined: since any two paths between I and P are homotopic they contain the same sets of events. We must show that cf( ) is a bijection from G to cfs(es(G)), and then
P →a Q if and only if cf(P ) →a	cf(Q).
cg(es(G))
Proposition 4.3 Let (G, Lab, →,I) be a prime graph. Suppose that cf(P )= cf(Q). Then P = Q.

Proof. (Sketch, with abuse of notation between events and labels of events) Sup-

pose we have I
→a  P
' →s  P .  Then we must have I
→t  Q
' →a  Q
''  t'
Q with

(I, a, P ') ∼ (Q', a, Q''). Clearly any events in t cannot be below a, and so by repeated use of SD (Lemma 2.11) we can “promote” a to the front of t to get

I →a Q
''' →t  Q
'' t'	'
Q. Now we use ED to deduce that P
= Q'''
. Continuing this

process along s we deduce that P = Q.	 
Proposition 4.4 Let G = (G, Lab, →,I) be a prime graph. If X ∈ cfs(es(G)) then there is P such that cf(P )= X
Proof. (Sketch, with abuse of notation between events and labels of events) Let
X ∈ cfs(es(G)). We show that if I →s Q and X ⊆ cf(Q) with X downwards-closed
under < then there exist t, P such that cf(P ) = X and I →t  P →∗ Q. Suppose
that a comes immediately before b in s, and a ∈/ X, b ∈ X. Then a /< b since X is downwards-closed. We can swap a and b by SD (Lemma 2.11). Continue this until all events in X occur before all events not in X. We have the desired t, P . 

Proposition 4.5 Let G = (G, Lab, →,I) be a prime graph. Then P →a
only if cf(P ) →a cg(es(G)) cf(Q).
Q if and

Proof. (Sketch, with abuse of notation between events and labels of events) (⇒) Clearly cf(Q) = cf(P ) ∪ {[P, a, Q]}.  Here we use the result that events cannot

be repeated along any path (Proposition 2.10). Then cf(P ) definition.
→a cg(es(G)) cf(Q) by

(⇐) We have cf(Q)= cf(P ) ∪ {e} where l(e)= a. Suppose I →s  P and I
tat'
→ Q.

Then for each b ∈ t' we have a /< b since b ∈ s and a ∈/ s. So by SD (Lemma 2.11),
'	tt'	a
a can be permuted with each successive member of t and we have I → R → Q for
some R. But then R = P by Proposition 4.3.	 
Finally, we show that if we add a condition on prime graphs that no path can include repeated labels, then we have a correspondence with event structures where events with the same label must be the same or in conflict.
Proposition 4.6 Let G be a non-repeating prime graph. Then es(G) is a non- repeating prime event structure.
Proof. Assume for contradiction that es(G) is not non-repeating: there are differ- ent events e, e' with l(e)= l(e') and {e, e'} ∈/ . The last implies, by the definition of , that e, e' appear on a path. Hence, this path has repeated labels l(e): contra- diction.	 
Proposition 4.7 Let E be a non-repeating prime event structure. Then cg(E) is a non-repeating prime graph.
Proof. A straightforward proof by contradiction using the fact that no path of a prime graph has repeated events (Proposition 2.10).	 

Correspondence of bisimulations
We recall a definition of a bisimulation relation for process graphs that takes both forward and reverse transitions into account [8]:
Definition 5.1 Let G and H be process graphs. A symmetric relation S ⊆ GG ×HH is a forward-reverse (FR) bisimulation between G and H if S(IG , IH) and whenever S(P, Q) then

if P  μ G	'
'	μ		'	'	' H

μ	'
'	μ	'	'	'

if P ~G P
then there is Q
such that Q ~H Q and S(P ,Q ).

We define G ∼FR H if and only if there is an FR bisimulation between G and H.
By abuse of notation we shall write P ∼FR Q if P, Q are states of G, H, respec- tively, and there exists an FR bisimulation S between G and H such that S(P, Q). A similar relation, called back-and-forth bisimulation was proposed by Bednar- czyk [1]. It uses forward transitions to mimic the effect of reverse transitions. Since in this paper ~ is the inverse of →, the two bisimulations coincide. However, this does not hold for general transition systems where some transitions are irreversible.
Example 5.2 FR bisimulation satisfies an intuitive equation a = a + a. Note that the graph of a + a is a non-repeating prime graph.
FR bisimulation is insensitive to auto-concurrency: Let I →a P →a R, I →a Q →a
R with P /= Q, and I' →a P ' →a R'. Consider the graphs with initial states I and I',
respectively. They are clearly FR bisimilar, and they have auto-concurrency and auto-causation, respectively. Note that CCSK processes a | a and a.a are not FR bisimilar: using the notation from [8] we have that after performing a, a we get to
a[m]	a[m]
a[m] | a[n] and a[m].a[n]. Now, a[m] | a[n] ~ and a[m].a[n] / ~ .
Finally, FR bisimulation does not satisfy the absorption law:
(a | (b + c)) + (a | b)+ ((a + c) | b)= (a | (b + c)) + ((a + c) | b)
If one performs a and then b with the a | b component on the left, then these must be matched by the a and then the b of the ((a + c) | b) summand on the right. (Matching it with the a of (a | (b + c)) is wrong as after this a action is performed, no c is possible after a in a | b.) The right hand side can now reverse a and do a c (still using the same summand as all other summands are disabled). The left hand side cannot match this: the component a[m] | b[n] can regress by a[m] to a | b[n] but it cannot perform any c.
We have shown that the configuration graphs associated with prime graphs are prime graphs themselves (Theorem 4.2), and that the configuration graphs for prime event structures are prime graphs (Proposition 3.3). Hence, in the setting of prime graphs and prime event structures the definition of FR bisimulation generalises trivially to configuration graphs.
Hereditary history-preserving bisimulation was proposed by Bednarczyk [1], and also appeared under a different name in an earlier version of [5] and in [7]. Here, we

present a reformulation of the original definition due to van Glabbeek and Goltz [5] (but without termination). This particular bisimulation is defined over configura- tion graphs and, in addition to matching configurations and the transitions between configurations, it also keeps a history of the matched events along matching com- putations. This is achieved by means of a label-preserving and order-preserving isomorphism between the events of the two configuration graphs.
Given two prime event structures E and F, their configuration graphs are cg(E) and cg(F). Let these graphs be called C and D, respectively, with C = cfs(E) and D = cfs(F ). In order to define the so-called “history” isomorphisms we need to consider the full sub-event structures determined by configurations. We shall write such event structures as (X, <X , X ,l T X) for a configuration X of E where
<X = <E ∩ (X × X) and l T X is the restriction of the domain of l to X. Since each X is conflict-free the restriction of the conflict relation  to X is empty, i.e.
 X = ∅. Hence, it suffices to define the required isomorphisms over the structures (X, <X ,l T X).
Definition 5.3 Let C and D be configuration graphs. A relation R ⊆ C × D × P(EC × ED) is a hereditary history-preserving (HHP) bisimulation between C and D if R(∅, ∅, ∅), and whenever R(X, Y, f ) then
f is an isomorphism between (X, <X ,l T X) and (Y, <Y ,l T Y );

if X μ C	'	'	'
μ		'	'	'	'	' D

if Y  μ D	'	'	'
μ		'	'	'	'	' C

μ	'	'	'
μ	'	'	'	'	'	'

if X ~C X then ∃ Y ,f 
such that Y
~D Y , R(X ,Y ,f ) and f T X = f ;

μ	'	'	'
μ	'	'	'	'	'	'

if Y ~D Y  then ∃ X ,f 
such that X ~C X , R(X ,Y ,f ) and f T X = f .

We define C ∼HHP D if and only if there is an HHP bisimulation between C and D.
The main result of this section is that FR bisimulation coincides with HHP bisimulation on configuration graphs for non-repeating prime event structures. A similar result was proved by Bednarczyk [1]. He considered configuration structures which arise from a smaller family of prime event structure with binary conflict. But instead of the non-repeating property his result holds under a less restrictive no auto-concurrency condition.
Theorem 5.4 Let E and F be non-repeating prime event structures, and let C and
D be their conﬁguration graphs. Then, C ∼HHP D if and only if C ∼FR D.
Example 5.5 The graphs for a and a + a are HHP bisimilar. Consider the graphs with initial states I and I' from Example 5.2. Although they are FR bisimilar
they are not HHP bisimilar: If we match the two a transitions I →a  P →a  R
with the respective transitions in I' →a  P ' →a  R', we obtain an order isomorphism
{([(I, →a ,P )], [(I', →a ,P ')]), ([(P, →a , R)], [(P ', →a , R')]).  Then, reversing a from R to Q cannot be matched by reversing the isomorphic transition from R' since [(Q, →a , R)] = [(I, →a ,P )].
The proof of Theorem 5.4 from left to right is by definition of FR bisimulation.

The other direction requires first some auxiliary results.
Since configurations of non-repeating prime event structures have no repeated events (Proposition 2.10) and no two events share the same label, the events in a configuration can be identified uniquely by their labels. And, the causality order on the events in a configuration reduces to the corresponding order on events’ labels. Hence, in the remainder the isomorphisms required in Definition 5.3 shall be called simply order isomorphisms.
Proposition 5.6 Let C and D be conﬁgurations graphs of non-repeating prime event structures E and F. Let S be an FR bisimulation between C and D, and let S(C, D) for C ∈ C and D ∈ D. Then a map is(C, D), deﬁned by is (C, D)(e) = e' if l(e)= l(e') and e ∈ C, e' ∈ D, is an order isomorphism between C and D.
Proof. The map is is clearly well-defined. since configurations of non-repeating prime event structures have no repeated events (Proposition 2.10) and no two events have the same label. One shows that the map is injective by using the above mentioned results. To show that is is surjective, namely for every e' ∈ D there is e ∈ C such that is(C, D)(e) = e', we consider S(C, D). A reverse computation D ~t D ~a D D', where l(e') = a and t is some sequence of labels for events in D, implies C ~t C ~a C C' by S(C, D). Because of the non-repeating property, there is a unique event e ∈ C with the label a, so is(C, D)(e)= e'.
It remains to prove that is is order-preserving. We shall show a <C b if and only if a <D b for all appropriate events (identified by their labels) a, b. Assume for contradiction that a <C b and not a <D b. The last means that there is a path involving transitions for all events of D such that it contains no a before b. Hence, this path has a after b. We reverse the transitions in this path and, since S(C, D), we match them with the corresponding transitions from C. Therefore, we get a path in C with a after b. Since a <C b implies that every path that has b contains also a, we have that a path in C has two occurrences of a: contradiction. 
The following result is a consequence of the non-repeating property for both prime event structures and prime graphs. It is proved similarly as the previous proposition.
Proposition 5.7 Let C and D be conﬁguration graphs of non-repeating prime event structures E and F. Let S be an FR bisimulation between C and D, and let S(C, D) for C ∈ C and D ∈ D.
If C →a C C' with C' \C = {e} and l(e)= a then there is D' such that D →a D D' with D' \ D = {e'} and l(e') = a, and S(C', D') and is (C', D') is an order isomorphism between C' and D';
If D →a D D' with D' \ D = {e'} and l(e') = a then there is C' such that
C →a C C' with C' \ C = {e} and l(e)= a, and S(C', D') and is(C', D') is an order isomorphism between C' and D'.
Proof of Theorem 5.4. Let E and F be non-repeating prime event structures, and let C and D be their configuration graphs. We show C ∼FR D implies C ∼HHP D.

Let S be an FR bisimulation that relates the configurations of C and D. Define a relation R ⊆ CC × DD ×P(EC × ED) as follows: for all configurations C, D we let R(C, D, f ) if S(C, D) and f = is(C, D). It remains to show that R is a hereditary history-preserving bisimulation between C and D.
Clearly, R(∅, ∅, ∅). Assume R(C, D, is (C, D)). Then is(C, D) is an order iso- morphism, and the two conditions for the forward transitions follow from Proposi- tion 5.7. For the reverse transition conditions we consider the last one from Def-
μ	'	'	μ	'

inition 5.3. Let D ~D D . Then by S(C, D) there is C such that C ~C C
and

S(C', D'). Clearly, C' \ C = {e} with l(e) = μ and D' \ D = {e'} with l(e') = μ.
Since is(C', D')(e)= is(C, D)(e) if e ∈ C and is(C', D')(e)= e' if e ∈ C' \ C, we de- duce that is(C', D') is an order isomorphism. And we obtain R(C', D', is(C', D')). 

Conclusions and future directions
We have proposed prime graphs as an alternative and equivalent model to labelled prime event structures (with general conflict). Prime graphs are a subclass of re- versible transition systems that satisfy several properties relating to concurrency and reversibility. A concrete example of prime graphs are process graphs for CCSK processes. The communication mechanism of CCSK works correctly in both direc- tions thanks to the use of communications keys, and the keys, in turn, force an additional property of non-repeating on prime graphs for CCSK processes.
The non-repeating property does not seem to be intrinsic to reversible transition systems. However, it seems to guarantee compositionality and it deals with auto- concurrency. It raises the question of whether non-repeating is necessary or not for concrete formulations.
In the second part of the paper we have investigated the distinguishing power of FR bisimulation and have shown that for non-repeating models, either prime graphs or prime event structures, FR bisimulation coincides with HHP bisimulation. Since CCSK gives rise naturally to such models, HHP bisimulation, and hopefully other true concurrency equivalences, can be verified by standard interleaving-based techniques. In future it would be interesting to study trace-based equivalences in reversible transition systems and identify the corresponding equivalences in true concurrency models.

Acknowledgements
We would like to thank Daniele Varacca, Sibylle Fr¨oschle, Reiko Heckel and the anonymous referees for helpful comments and suggestions. The second author wishes to acknowledge support from EPSRC grant EP/D001307/1.

References
Bednarczyk, M., Hereditary history preserving bisimulations or what is the power of the future perfect in program logics, Technical Report ICS PAS, Polish Academy of Sciences (1991).


Danos, V. and J. Krivine, Reversible communicating systems, in: P. Gardner and N. Yoshida, editors, Proceedings of the 15th International Conference on Concurrency Theory CONCUR 2004, LNCS 3170 (2004), pp. 292–307.
Fiore, M. P., G. L. Cattani and G. Winskel, Weak bisimulation and open maps, in: Proceedings of the 14th Annual IEEE Symposium on Logic in Computer Science, IEEE (1999), pp. 67–76.
van Glabbeek, R.J., History preserving process graphs (1996),
http://boole.stanford.edu/~ rvg/pub/history.draft.dvi .
van Glabbeek, R.J. and U. Goltz, Refinement of actions and equivalence notions for concurrent systems, Acta Informatica 37 (2001), pp. 229–327.
van Glabbeek, R.J. and F. Vaandrager, The difference between splitting in n and n + 1, Information and Computation 136 (1997), pp. 109–142.
Joyal, A., M. Nielsen and G. Winskel, Bisimulation from open maps, Information and Computation
127 (1996), pp. 164–185.
Phillips, I.C.C. and I. Ulidowski, Reversing algebraic process calculi, in: Proceedings of 9th International Conference on Foundations of Software Science and Computation Structures, FOSSACS 2006, LNCS 3921 (2006), pp. 246–260. Extended version accepted by Journal of Logic and Algebraic Programming.
Sassone, V., M. Nielsen and G. Winskel, Models of concurrency: Towards a classification, Theoretical Computer Science 170 (1996), pp. 297–348.
Winskel, G., Event structures, in: Advances in Petri Nets 86, LNCS 255 (1987), pp. 325–392.
