Electronic Notes in Theoretical Computer Science 126 (2005) 93–114 
www.elsevier.com/locate/entcs


Bounded Model Checking for Deontic Interpreted Systems
Boz˙ena Wo´zna a,1 ,2	Alessio Lomuscioa,1 ,3	Wojciech Penczekb,4
a
Department of Computer Science
University College London
Gower Street, London WC1E 6BT, United Kingdom
b Institute of Computer Science, PAS Ordona 21, 01-237 Warsaw, Poland

Abstract
We propose a framework for the verification of multi-agent systems’ specification by symbolic model checking. The language CTLKD (an extension of CTL) allows for the representation of the temporal evolution of epistemic states of the agents, as well as their correct and incorrect functioning behaviour. We ground our analysis on the semantics of deontic interpreted systems. The verification approach is based on an adaption of the technique of bounded model checking, a mainstream approach in verification of reactive systems. We test our results on a typical communication scenario: the bit transmission problem with faults.
Keywords: Bounded model checking, epistemic logic.


Introduction
The task of software engineers is to design and deploy a computer system that meets a particular set of specifications. This is by no means a trivial task. Only in the past few months the problems with nasa’s and esa’s Mars exploration missions have made news showing how many unforeseen problems

1 The authors acknowledge support from EPSRC (grant GR/S49353), and the Nuffield Foundation (grant NAL/690/G).
2 Email: bozena@dcs.kcl.ac.uk
3 Email: A.Lomuscio@ucl.ac.uk
4 Email: penczek@ipipan.waw.pl



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.11.015


even a thoroughly-designed distributed system may encounter. In mission- critical software as well as in particularly sensitive applications such as Internet protocols, the worldwide electronic banking system, etc., software engineers are interested in analysing the properties of software, and in particular in checking whether particular conditions, from the basic ones of deadlock to more complex ones, hold for a particular system.
The area of multi-agent systems is also interested in a similar set of prob- lems. Multi-agent systems [17] are distributed systems in which the individual processes, or agents, are autonomous entities that engage in social activities such as coordination, negotiation, cooperation, etc. Since multi-agent systems are autonomous and social, their range of possible behaviours is even greater than the one of traditional distributed systems. It follows from this that the issue of verification of the properties a system satisfies is just as important in multi-agent systems.
Software validation, i.e., the process of checking that a piece of software satisfies certain characteristics, is currently conducted by means of three main techniques: testing, theorem proving, and model checking. Testing involves searching the state-space of the possible inputs of a program looking for po- tentially problematic outputs. Theorem proving techniques are based on the representation of a program by means of a system of formal logic; in its sim- plest instance, checking whether a property is satisfied amounts to checking whether a formula is a theorem of the logic that represents the program. Model checking in its mainstream approach involves representing all possible com- putational traces of a program by means of a temporal model (appropriately represented) and checking whether or not a temporal formula, representing the property to be verified, holds in this model.
Software validation has in other words an intrinsic “deontic connotation”. It amounts to checking whether the system under consideration behaves as it is prescribed by its specification. But it should be noted that, in this approach, this is a property that is external from the logical system. One could say, the correct functioning behaviour of the system is a metalogical property of the logic system representing the program. Differently from what happens in deontic logic, deontic concepts here are not explicitly used in the logic to represent the system, but they are built into the procedures that operate on the logic used to check the system.
Although a range of systems have been verified by means of standard verification techniques, multi-agent systems applications call for a refined ap- proach. Consider for example a number of automatic agents bidding for goods on an electronic auction. There may be rules as to how these agents may con- duct their bidding, but it is often unfeasible and/or counterproductive to have


many of these rules hard-wired in the auction protocol itself. As designers of the auction we may consider it beneficial that agents do not bid several times a second on the same good not to have resulting denial-of-service problems at server-level, but it seems difficult to enforce this when the agents are pro- grammed by a variety of software houses on which we have no control. Other examples from traditional federated databases to more recent fault-control modules in mission-critical software point to similar conclusions: it is impor- tant to reason about the properties that hold in a system when the programs are functioning following their speciﬁcation but also (and occasionally even more importantly) even they do not. In other words, not only we would like to check whether a system satisfies its specification, but also we would like to derive the consequences resulting from the system not behaving as intended. Different deontic logics have been used to bring to the logical object level the distinction between correct (or ideal, normative, etc.) and incorrect states. In this paper we would like to take these ideas one step further and provide a technique by means of which we can not not specify but also automatically verify properties expressing compliance of a multi-agent system with respect to specifications.
To carry out this analysis we use the formal machinery of verification by model checking [4], and in particular the one of Bounded Model Checking via SAT translation [3]. In verification by model checking one typically describes a system S by means of a program in a language such as smv [12]. This descrip- tion is then supplied to the model checker which produces the (appropriately encoded) temporal model MS representing all the possible executions of sys- tem S. To check whether a property P is satisfied in S one checks whether the temporal model MS satisfies a formula φP representing P , i.e., MS |= φP . The key problem in this approach is to manage the representation of the resulting model MS. One of the techniques available to keep the approach feasible is bounded model checking. This technique focuses on the attempt to discover faults in the specification of the system. Rather than checking the whole state space for the verification of the property, in bounded model checking one checks whether the negation of the property is actually satisfied on a fraction of the model, thereby producing a counterexample. Furthermore, the actual check is translated into a standard propositional satisfiability problem by com- puting appropriate translations into propositional formulas representing both the truncated model, and the formula to be checked. By means of this ap- proach subtle bugs in protocols for reactive systems have been discovered. We refer to [1,3,5,14] for more details.
While in reactive systems it is enough to model a system by means of a purely temporal language, multi-agent systems are defined following what is


often referred to as the “intentional stance” [6]. In other words it is useful to describe autonomous agents in terms of their knowledge, belief, intentions, so- cial context, etc. This implies that the model checking problem for multi-agent systems cannot simply be stated as one on temporal logic but that richer for- malisms need being used. In past research we have provided a model checking algorithm for a branching time temporal-epistemic logic (CTLK) [13]. In this paper we extend this work by providing a bounded model checking algorithm for a logic that comprises knowledge and a deontic component representing correct functioning behaviour of the system.
The paper is organised as follows. In Section 2, we fix the notation on the semantics of deontic interpreted systems. In Section 3 we present the language of CTLKD, an extension of CTLK, representing correct/incorrect function- ing behaviour of the agents. In Section 4 we present a bounded semantics definition for satisfaction that we use in Section 5 to define the algorithm of bounded model checking. In Section 6 we apply the formalism to an example close to the multi-agent systems literature: the bit transmission problem with faults.

Deontic Interpreted Systems
In this section we introduce deontic interpreted systems. These were defined in [10] to represent and reason about correct functioning behaviour of multi- agent systems. They provide a semantics based on the computation states of the agents, on which it is possible to interpret a modality Oiφ, representing the fact “in all correct functioning executions of agent i, φ holds”, as well as a traditional epistemic modality Kiφ representing knowledge of φ by agent i, and standard branching time temporal operators 5 . An axiomatisation of deontic interpreted systems has been provided for the non-temporal fragment of the language; we refer the interested reader to [11] for more details.
The following is reported to fix the notation only; more details can be found in [10,13]. Let PV be a set of propositional variables and A = {1,..., n} be a set of agents. Consider n non-empty sets L1,... , Ln of local states, one for each agent of the system, and a set Le of local states for the environment. For each agent i ∈ A, consider a set of possible actions Acti, and n protocols Pi : Li → 2Acti representing the functioning behaviour of every agent, and Pe : Le → 2Acte for the environment.
Further assume that for every agent, its set of local states can be parti- tioned into allowed and disallowed states. We call these states green and red respectively. For n agents and n + 1 mutually disjoint and non-empty sets

5 Temporal operators were not actually used in [10] but this is a straightforward extension.


G1,... , Gn, Ge we define the set S of all possible global states as the Cartesian product L1 × ... × Ln × Le, such that L1 ⊇ G1,... , Ln ⊇ Gn, Le ⊇ Ge. Ge is called the set of green states for the environment, and for any agent i, Gi is called the set of green states for agent i. The complement of Ge with respect to Le (denoted by Re) is called the set of red states for the environment, and similarly the complement Gi with respect to Li (denoted by Ri) is called the set of red states for the agent i.
We can model the computation taking place in the system by means of a transition function t : S × Act → S, where Act ⊆ Act1 × ... × Actn × Acte is the set of joint actions. Intuitively, given an initial state ι ∈ S, the sets of protocols, and the transition function, we can build a (possibly infinite) structure that represents all the possible computations of the system. Indeed, we will deal with systems, in which the state space consists of reachable global states only. A state s ∈ S is reachable if there is a sequence of states (s0,... , sn) such that s0,... , sn ∈ S, s0 = ι, sn = s, and for all i ∈ {0,...,n − 1} there exists an action acti ∈ Act such that t(si, acti) = si+1, i.e., si+1 is the result of applying the transition function t to the global state si, and a joint action acti. If each of the components of acti is prescribed by the corresponding protocol Pj at agent j’s local state at si, then the resulting state will only contain green local states, otherwise it may contain some red local states. For further considerations on this see [10]. In the following we abstract from the transition function, the actions, and the protocols, and simply use the relation T , but it should be clear that this is uniquely determined by the interpreted system under consideration.
Let li : S → Li be a function which returns the local state of agent i from a global state. A deontic interperted system is defined as follows:
Definition 2.1 [Deontic Interperted System]
Given a set of agents A = {1,... , n}, a set of global states S, protocols, and a transition function, a deontic interperted system (or simply a model) is a tuple
M = (DS, ι,T, RO,..., RO, RK,... , RK, V) where
1	n	1	n
DS ⊆ S is a finite set of reachable global states for A,
ι ∈ DS is an initial state,
T ⊆ DS × DS is a serial 6 binary relation on DS,
O ⊆ DS × DS is a relation for each agent i ∈ A defined by: sROs' iff
li(s') ∈ Gi 7 ,

6 A relation R ⊆ X × X is serial if for all x ∈ X there exists y ∈ X such that xRy.
7 Since each RO only depends on the target state, for what pertains this component we could have equally defined a model by means of green local states for agent i.

K ⊆ DS × DS is a relation for each agent i ∈ A defined by: sRKs' iff
li(s')= li(s),
V : DS −→ 2PV is a valuation function such that true ∈ V(s) for all s ∈ DS. V assigns to each state a set of proposition variables that are assumed to be true at that state.
By |M| we denote the number of states of M, whereas N = {0, 1, 2,.. .} indicates the set of natural numbers, and N+ = {1, 2,.. .} the set of positive natural numbers.
A computation in M is an infinite sequence π = (s0, s1,.. .) of states such that (si, si+1) ∈ T for each i ∈ N. For a computation π = (s0, s1,.. .), let π(k) = sk, and πk = (s0,... , sk), for each k ∈ N. In the rest of the paper we shall call πk a k-computation. Moreover, a k−computation πk is a (k,l)-loop if (πk(k), πk(l)) ∈ T for some 0 ≤ l ≤ k. We call πk simply a loop if there is an l ∈ N with l ≤ k for which πk is a (k,l)-loop. By Π(s) we denote the set of all the infinite computations starting at state s, whereas by Πk(s) the set of all the k−computations starting at s.
The logic CTLKD
Here we fix syntax and semantics for CTLKD, an extension of CTL [7], in- troduced by Emerson and Clarke, enriched with modal operators representing correct functioning behaviour [11], and standard epistemic operators [8]. The bounded model checking problem of the temporal epistemic fragment of the language was analysed in [13].
Definition 3.1 [Syntax of CTLKD]
Let PV be a set of propositional variables also containing the symbol true. The set of CTLKD formulas FORM is defined inductively as follows:
every member p of PV is a formula,
if α and β are formulas, then so are ¬α, α ∧ β and α ∨ β,
if α is formula, then so are EXα, EGα and EU(α, β),

if α is formula, then so are Oiα, and Kiα, for i ∈ A.
Intuitively, E means there exists a computation, Xα is true in a computa- tion if α is true at the second state of the computation, U(α, β) is true in a computation if β is true at some state on the computation and always earlier α holds, and Gα is true in a computation if α is true at all the states of the computation. We use the indexed modal operator Oi to represent the correctly functioning circumstances of agent i. The formula Oiα stands for “there is a state where agent i is functioning correctly, and in which α holds”. We


refer to [10,11] for a discussion of this notion 8 . Moreover we use the indexed modality Ki to represent the diamond of an epistemic operator for agent i [8]: Kiα stands for “agent i considers possible that α”.

The derived basic modalities are defined as follows: EFα
def
= EU(true, α),

AXα
def
= ¬EX¬α, AFα
def	
def
= ¬EG¬α, AR(α, β)
def
def
= ¬EU(¬α, ¬β), AGα
def
=

¬EF¬α, Oiα = ¬Oi¬α for i ∈ A, Kiα
def
= ¬Ki¬α for i ∈ A. Moreover,

α → β = ¬α ∨ β.
The logic ECTLKD is the restriction of CTLKD such that the negation can be applied only to elements of PV, i.e., ¬α is replaced by ¬p in Definition 3.1. The logic ACTLKD is the restriction of CTLKD such that its language is defined as {¬ϕ | ϕ ∈ ECTLKD}. It is easy to see that ACTLKD consists of
the temporal formulas of the form: AXα, AR(α, β), AFα, Kiα and Oiα.
Definition 3.2 [Semantics of CTLKD]
Let M be a model, s be a state, and α, β be formulas of CTLKD. M, s |= α denotes that α is true at the state s in the model M. M is omitted, if it is implicitly understood. The relation |= is defined inductively as follows:



Definition 3.3 [Validity] A CTLKD formula ϕ is valid in a model
M = (DS, ι,T, RO,... , RO, RK,... , RK, V) (denoted M |= ϕ) iff M, ι |= ϕ,
1	n	1	n
i.e., ϕ is true at the initial state of the model M.

8 Note that the operator Oi is there referred to as Pi.

Bounded Semantics for ECTLKD

In this section we give a bounded semantics for ECTLKD in order to define the bounded model checking problem for ECTLKD, and to translate it subse- quently into a satisfiability problem. This formalism is an extension of the one presented in [14].


Definition 4.1 [k−model]
Let M = (DS, ι,T, RO,... , RO, RK,... , RK, V) be a model and k ∈ N+. A tu-
1	n	1	n
ple Mk = (DS, ι, Pk, RO,... , RO, RK,..., RK, V) is a k−model for M, where
1	n	1	n
	


Satisfaction for the temporal operators in the bounded case depends on whether or not the computation π defines a loop, i.e., whether loop(π) /= ∅, where loop is defined below.


Definition 4.2 [loop]
Let M = (DS, ι,T, RO,... , RO, RK,... , RK, V) be a model, k ∈ N+ be a bound,

1	n	1	n
{0,...,k}

as follows:


loop(π) = {l | 0 ≤ l ≤ k and (π(k), π(l)) ∈ T }


Note that the interpretation of the temporal modalities on bounded se- mantics is different from the one of Definition 3.2.


Definition 4.3 [Bounded semantics]
Let Mk be a k−model and α, β be ECTLKD formulas. Mk,s |= α denotes that α is true at the state s of Mk. Mk is omitted if it is clear from the context. The relation |= is defined inductively as follows:


The above extends to deontic modalities the bounded semantics of [13,14]. As in [13] we note that the given Definition 2.1, the relations for the operator Oi used above are constructed on the basis of the internal structure of the global states of the system (i.e., they are defined on the basis of the local states of the agents), and not by means of an ad-hoc construction by the modeller of the system. Note also that while the conditions for the temporal components require the states to be reachable from the state in consideration, this is not the case for operators Oi and Ki, where we consider whether or not there is a computation from the initial state that results in a state that is related for agent i from the global state under consideration. This guarantees reachability of such a state and corresponds to the usual interpretation of the modalities in the non-bounded model.
The theoretical results proved in [13] for CTLK can easily be extended for CTLKD.
Definition 4.4 [Validity for Bounded Semantics] An ECTLKD formula ϕ is valid in a k-model Mk (denoted M |=k ϕ) iff Mk,ι |= ϕ.
Next, we describe how the model checking problem (M |= ϕ) can be re- duced to the bounded model checking problem (M |=k ϕ).
Lemma 4.5 Let M be a model, s be a state of M, and ϕ be an ECTLKD
formula. Then, the following two conditions hold:
Mk,s |= ϕ implies Ml,s |= ϕ, for l ≥ k,
Mk,s |= ϕ implies M, s |= ϕ.
Proof. Straightforward by induction on the length of ϕ.	 


Lemma 4.6 Let M be a model, ϕ be an ECTLKD formula, s be a state of
M, and k = |M|. If M, s |= ϕ, then Mk,s |= ϕ.
Proof. By induction on the length of ϕ. The lemma follows directly for the propositional variables and their negations.
Next, assume that the hypothesis holds for all the proper sub-formulas of ϕ. If ϕ is equal to either α ∧ β or α ∨ β, then it is easy to check that the lemma holds. Consider ϕ to be of the following forms:
ϕ = EXα | EGα | EU(α, β). By induction hypothesis — see [14] page 139.

ϕ = Oiα. By definition, there is a state s' in M such that li(s') ∈ Gi and M, s' |= α. By the inductive assumption, we have that Mk, s' |= α. Since s' is reachable, it is reachable from ι in at most k steps as k = |M|. Thus, there is a k−computation π ∈ Pk such that π(0) = ι and π(i)= s' for some i ≤ k. So, we have Mk,s |= Oiα.

ϕ = Kiα. By definition, there is a state s' in M such that li(s) = li(s') and M, s' |= α. By the inductive assumption, we have that Mk, s' |= α. Since s' is reachable, it is reachable from ι in at most k steps as k = |M|. Thus, there is a k−computation π ∈ Pk such that π(0) = ι and π(i)= s' for some i ≤ k. So, we have Mk,s |= Kiα.

In this setting we can prove that in some circumstances satisfiability in the
|M|-bounded semantics is equivalent to the unbounded one.
Theorem 4.7 Let M = (DS, ι,T, RO,... , RO, RK,... , RK, V) be a model, ϕ
1	n	1	n
be an ECTLKD formula and k = |M|. Then, M |= ϕ iff M |=k ϕ.
Proof. Straightforward from Lemma 4.5 and Lemma 4.6 above.	 
Given that we reasoned on a bounded model of size |M| there is nothing surprising about the results above. The rationale behind the method is that for particular examples checking satisfiability of a formula can be done on a small fragment of the model.

The BMC algorithm for ECTLKD
In this section we present a Bounded Model Checking (BMC) method for ECTLKD. This is an extension of the method appearing in [13,14]. This construction first appeared in [14], and was then extended in [13] for the CTLK case.

Definition 5.1 Let Mk = (DS, ι, Pk, RO,... , RO, RK,... , RK, V) bea k-model
1	n	1	n
of M. We say that a structure M' = (DS', ι, Pk', R'O,... , R'O, R'K,... , R'K, V')
k	1	n	1	n
is a submodel of Mk if Pk' ⊆ Pk, States(Pk') ⊆ DS' ⊆ DS, R'O = RO ∩(DS' ×
i	i
DS'), for i ∈ A, R'K = RK ∩ (DS' × DS'), for i ∈ A, and V' = V|DS' , where
i	i
States(Pk') defines the set of states reached in all computations in Pk', and V|DS' denotes the restriction of the interpretation function V to DS', a subset of DS (upon which V is defined).
For technical reasons we allow for having states in DS', which may not be reached in Pk', but obviously all the states of DS' are reachable in Mk

as DS' ⊆ DS. The bounded semantics of ECTLKD over submodels M'
can

still be defined as for Mk (see Def. 4.3). Our present aim is give a bound
for the number of k-computations in M' such that the validity of ϕ in Mk is
equivalent to the validity of ϕ in M' .
Definition 5.2 Define a function fk : FORM → N as follows:
fk(p)= fk(¬p)= 0, where p ∈ PV,
fk(α ∨ β)= max{fk(α), fk(β)},
fk(α ∧ β)= fk(α)+ fk(β),
fk(EGα)= (k + 1) · fk(α)+ 1,
fk(EU(α, β)) = k · fk(α)+ fk(β)+ 1,

fk(Y α)= fk(α)+ 1, for Y ∈ {EX, Ki, Oi}.
The function fk determines the number of k-computations of a submodel
' sufficient for checking an ECTLKD formula. Here we take this bound as
given, but we provide a proof of the adequacy of this in the next section.
The main idea of the BMC method is that we can check ϕ over Mk by checking the satisfiability of a propositional formula [M, ϕ]k = [Mϕ,ι]k ∧[ϕ]Mk , where the first conjunct represents (part of) the model under consideration, and the second a number of constraints that must be satisfied on Mk for ϕ to be satisfied. Once this translation is defined, checking satisfiability of an ECTLKD formula can be done by means of a SAT-checker. Although from a theoretical point of view the complexity of this operation is no easier, in practice the efficiency of modern SAT-checkers makes the process worthwhile in many instances. In this process, an important decision to take is the size k of the truncation; there are heuristics that can be developed for particular classes of examples [2]. A trivial mechanism, for instance, would be to start with k := 1, test satisfiability for the translation, and increase k by one either until [Mϕ,ι]k ∧ [ϕ]Mk becomes satisfiable or k reaches |M|.
Definition 5.3 BMC algorithm for ECTLKD:

Let ϕ := ¬ψ (where ψ is an ACTLKD formula).
Set k := 1.
Select the k−model Mk.

Select the submodels M'
of Mk with |Pk'| ≤ fk(ϕ).

Translate the transition relation of all the submodels M' of Mk into a
propositional formula [Mϕ,ι]k.
Translate ϕ over all M' into a propositional formula [ϕ]Mk .
Check the satisfiability of [M, ϕ]k := [Mϕ,ι]k ∧ [ϕ]Mk .
If [M, ϕ]k is satisfiable, then return M |= ϕ (i.e., M |= ψ ), else set
k := k + 1.
If k = |M| + 1, then return M |= ϕ (i.e., M |= ψ) else go to 3.
Now, we give details of this translation. We begin with an encoding of the transitions in the interpreted system under consideration. Recall that
the set of reachable global states is DS ⊆  n	Li × Le, where Li ⊇ Gi
for each agent i ∈ A, and Le ⊇ Ge for the environment. We assume that Li = Gi∪Ri ⊆ {0, 1}gi ×{0, 1}ri , where gi = [log2(|Gi|)|, ri = [log2(|Ri|)|, and Le = Ge ∪ Re ⊆ {0, 1}ge × {0, 1}re , where ge = [log2(|Ge|)|, re = [log2(|Re|)|. Let g1 + r1 + ... + gn + rn + ge + re = m. Then, each global state s = (l1,... , ln, le) = (s[1],... , s[m]) can be represented by w = (w[1],..., w[m]) (which we shall call a global state variable), where each w[i] for i = 1,...,m is a propositional variable. Notice that we distinguish between global states being sequences of binary digits and their representations in terms of propo- sitional variables w[i]. A finite sequence (w0,... , wk) of global state variables is called a symbolic k−path. In general we shall need to consider not just one but a number of symbolic k−paths. This number depends on the formula ϕ under investigation, and it is returned as the value fk(ϕ) of the function fk. We refer to [14] for more details. To construct [M, ϕ]k, we first define a propositional formula [Mϕ,ι]k that defines the fk(ϕ) symbolic k-paths to be valid k-computations of Mk. For j ∈ {1,..., fk(ϕ)}, the j-th symbolic k−computation is denoted as w0,j,... , wk,j, where wi,j for i ∈ {0,..., k} are global state variables.
Let SV be a set of state variables, SF be a set of propositional formulas over SV, and let lit : {0, 1} × SV → SF be a function defined as follows: lit(0, p) = ¬p and lit(1, p) = p. Moreover, let greeni : SV m → SV gi , for i = 1,... , n,e be a function which returns the sequence of state variables encoding the green states of the i-th agent or environment, and let Idxi and Idxe be sets of the indexes of the bits of the local states of each agent i and environment in the global states. Furthermore, let w, v be global state

variables. We define the following propositional formulas:
Is(w) :=  m  lit(s[i], w[i]).
This formula encodes the state s of the model, i.e., s[i]= 1 is encoded by
w[i], and s[i]=0 is encoded by ¬w[i].
p(w) isa formula over w[1],... , w[m], which is true for a valuation (s1,... , sm)
∈ {0, 1}m of (w[1],..., w[m]) iff p ∈ V((s1,... , sm)), where p ∈ PV. This formula encodes a proposition p ∈ PV.
H(w, v) :=  m  w[i] ⇔ v[i].
This formula represents logical equivalence between global state encod- ings, representing the fact that they represent the same state.

HO(w) := 

l∈Gi
gi j=1
lit(l[j], greeni(w)[j])).

This formula encodes an accessibility of a global state in which agent i is
running correctly.

HK(w, v) := 

i∈Idxl
w[i] ⇔ v[i].

This formula represents logical equivalence between l-local state encod-
ings, representing the fact that they represent the same local state, i.e., the local state in the two states is the same.
TR(w, v) is a formula over the propositions w[1],..., w[m], v[1],... , v[m] that is true for a valuation (s1,... , sm) of (w[1],..., w[m]) and a valuation

(s' ,... , s' ) of (v[1],... , v[m]) iff ((s1,..., sm), (s' ,..., s'
)) ∈ T .

1	m	1	m
Lk,j(l) := TR(wk,j, wl,j).
This formula encodes a backward loop connecting the k-th state to the
l-th state in the symbolic k−computation j, for 0 ≤ l ≤ k.
The propositional formula [Mϕ,ι]k, representing the transitions in the k-model, is given by the following definition.
Definition 5.4 [Unfolding of Transition Relation]
Let M = (DS, ι,T, RO,... , RO, RK,..., RK, V) be a model, k ∈ N+ be a
1	n	1	n
bound, and ϕ be an ECTLKD formula. The propositional formula [Mϕ,ι]k is
defined as follows:
fk(ϕ) k−1

[Mϕ,ι]k := Iι(w0,0) ∧
 

j=1
 

i=0
TR(wi,j, wi+1,j )

where w0,0, and wi,j for 0 ≤ i ≤ k, and 1 ≤ j ≤ fk(ϕ) are global state variables. [Mϕ,ι]k encodes the initial state ι by w0,0 and constrains the fk(ϕ) symbolic k-paths to be valid k-computations in Mk.
The next step of the algorithm consists in translating an ECTLKD formula
ϕ into a propositional formula.


Definition 5.5 [Translation of ECTLKD formulas] Let a model Mk with ini- tial state ι, and an ECTLKD formula ϕ be given. We inductively define the translation of ϕ at state wm,n into the propositional formula [ϕ][m,n] as follows:


[p][m,n]
[¬p][m,n]
[α ∧ β][m,n]
:=	p(wm,n),
:=	¬p(wm,n),
:=	[α][m,n] ∧ [β][m,n],

k	k	k
[α ∨ β][m,n]	:=	[α][m,n] ∨ [β][m,n],

k
[EXα][m,n]
k
fk(ϕ) i=1
k

m,n

, w0,i
) ∧ [α][1,i] ,

[EGα][m,n]
:=	  fk(ϕ)  H(w

m,n
, w0,i
) ∧ (  k
Lk,i
(l)) ∧ k
[α][j,i] ,

[EU(α, β)][m,n]
:=	  fk(ϕ) H(wm,n, w0,i) ∧  k
([β][j,i]
∧  j−1[α][t,i]) ,

k
	[m,n]
[O α
i=1
:=	  fk(ϕ)  I (w
) ∧  k
j=0
([α][j,i]
k
∧ HO(w
t=0	k
)) ,

	[m,n]
[K α
:=	  fk(ϕ)  I (w
) ∧  k
([α][j,i]
∧ HK(w
,w  )) .


The meaning of the translations above can be intuitively reconstructed from the definition of propositional formulas presented earlier. For example,

the formula [EXα][m,n]
expresses the condition that there exists a sub-path

starting from wm,n in which the first point w0,i in this computation satisfies
	[m,n]
α. For [Olα]k	we insist on the existence of a point wj,i in which agent l is
in a green local state, and that it is accessible from the initial state by some
	[m,n]
computation. For [Klα]k	we insist on the existence of a point wj,i in which
agent l is in the same local state, and that it is accessible from the initial state by some computation.
Given the translations above, we can now check ϕ over Mk by checking the

satisfiability of the propositional formula [Mϕ,ι]k∧[ϕ]Mk , where [ϕ]Mk
= [ϕ][0,0].

The translation presented above is shown to be correct and complete in the
next section.

Correctness of the translation
In this section we prove the correctness of the translation of the model checking problem into the SAT-problem as given by Definition 5.4.
Lemma 6.1 Mk,s |= ϕ iff there is a submodel M' of Mk with |Pk'| ≤ fk(ϕ)
such that M' ,s |= ϕ.


Proof. (=>) By structural induction on ϕ. The lemma follows directly for the propositional variables and their negations.
Assume that the hypothesis holds for all the proper sub-formulas of ϕ.
ϕ = α ∨ β | α ∧ β. Straightforward.
ϕ = EXα | EGα | EU(α, β). By induction hypothesis — see [14] page 143.

Let ϕ = Oiα. If Mk,s |= Oiα, then by definition: (∃π ∈ Pk)(π(0) = ι and
∃0≤j≤k(sROπ(j)) and π(j) |= α)). By the inductive assumption there is a submodel M' = (DS', ι, Pk', R'O,... , R'O, R'K,... , R'K, V') of Mk such
k	1	n	1	n
that |Pk'| ≤ fk(α) and M' , π(j) |= α.
Consider a submodel M'' = (DS'', Pk'', R''O,... , R''O, R''K,..., R''K, ι, V'')
k	1	n	1	n
of Mk, where Pk'' = Pk' ∪ {π} and DS'' = States(Pk'') ∪ {s}. Since π be- longs to Pk'', by the construction o f M'' and the definition of the bounded semantics, we have that M'',s |= Oiα and |Pk''| ≤ fk(ϕ)= fk(α)+ 1.

Let ϕ = Kiα. If Mk,s |= Kiα, then by definition:
(∃π ∈ Pk)(π(0) = ι and ∃0≤j≤k(sRKπ(j)) and π(j) |= α)). By induction
there is a submodel M' = (DS', ι, Pk', R'O,... , R'O, R'K,... , R'K, V') of
k	1	n	1	n
Mk such that |Pk'| ≤ fk(α) and M' , π(j) |= α.
Consider a submodel M'' = (DS'', ι, Pk'', R''O,... , R''O, R''K,... , R''K, V'')
k	1	n	1	n
of Mk, where Pk'' = Pk' ∪ {π} and DS'' = States(Pk'') ∪ {s}. Since π be- longs to Pk'', by the construction o f M'' and the definition of the bounded semantics, we have that M'',s |= Kiα and |Pk''| ≤ fk(ϕ)= fk(α)+ 1.
(<=) The proof is straightforward.	 
From Lemma 6.1 we can now derive the following.
Corollary 6.2 M |=k ϕ iff there is a submodel M' of Mk with |Pk'| ≤ fk(ϕ)
such that M' ,ι |= ϕ.
Proof. It follows from Definition 4.4, and Lemma 6.1, by using s = ι.	 
Lemma 6.3 For each state s of M, the following condition holds: [Mϕ,s]k ∧

[ϕ]Mk
is satisﬁable iff there is a submodel M'
of Mk with |Pk'| ≤ fk(ϕ) such

that M' ,s |= ϕ.
Proof. (=>) Let [Mϕ,s]k ∧[ϕ]Mk be satisfiable. By the definition of the trans- lation, the propositional formula [ϕ]Mk encodes all the sets of k−computations of size fk(ϕ) which satisfy the formula ϕ. By the definition of the unfolding of the transition relation, the propositional formula [Mϕ,s]k encodes fk(ϕ) symbolic k-paths to be valid k−computations of Mk. Hence, there is a set of k−computations in Mk, which satisfies the formula ϕ, of size smaller or
equal to fk(ϕ). Thus, we conclude that there is a submodel M' of Mk with

|Pk'| ≤ fk(ϕ) and M' ,s |= ϕ. The actual definition of M' can be reconstructed
k	k
from Definition 5.5 and Definition 5.4.
(<=) The proof is by induction on the length of ϕ. The lemma follows directly for the propositional variables and their negations. Consider the fol- lowing cases:
For ϕ = α ∨ β, α ∧ β or the temporal operators the proof is like in [14].
Let ϕ = Olα. If M' ,s |= Olα with |Pk'| ≤ fk(Olα), then by Defini- tion 4.3 we have that there is a k−computation π such that π(0) = ι and (∃j ≤ k) sROπ(j) and M' , π(j) |= α. Hence, by induction we obtain that
l	k
for some j ≤ k the propositional formula [α][0,0] ∧ [Mα,π(j)]k is satisfiable.
Let ii = fk(α) + 1 be the index of a new symbolic k−path which satisfies the formula Iι(w0,ii). Therefore, by the construction above, it follows that
the propositional formula Iι(w0,ii) ∧  k	([α][	] ∧HO(wj,ii)) ∧[MOlα,s]k
j,ii
is satisfiable. Therefore, the following propositional formula is satisfiable:

 Iι(w0,i) ∧  k	([α][ ] ∧ HO(wj,i)) ∧ [MOlα,s]k .
j,i
			
Hence, by the definition of the translation of an ECTLKD formula, the above formula is equal to the propositional formula [Olα][0,0] ∧ [MOlα,s]k.
Let ϕ = Klα. If M' ,s |= Klα with |Pk'| ≤ fk(Klα), then by Defini- tion 4.3 we have that there is a k−computation π such that π(0) = ι and (∃j ≤ k) sRKπ(j) and M' , π(j) |= α. Hence, by induction we obtain that
l	k
for some j ≤ k the propositional formula [α][0,0] ∧ [Mα,π(j)]k is satisfiable.
Let ii = fk(α) + 1 be the index of a new symbolic k−path which satis- fies the formula Iι(w0,ii). Therefore, by the construction above, it follows
that the propositional formula Iι(w0,ii) ∧  k	([α][	]∧HK(w	, w	)) ∧
j,ii
0,0	j,ii
[MKlα,s]k is satisfiable. Therefore, the following propositional formula is

satisfiable:
1≤i≤fk(Klα)
 Iι(w0,i) ∧

k j=0
([α][j,i]
∧ HK(w0,0, wj,i)) ∧ [MKlα,s]k .

Hence, by the definition of the translation of an ECTLKD formula, the
above formula is equal to the propositional formula [Klα][0,0] ∧ [MKlα,s]k.

Theorem 6.4 Let M be a model, Mk be a k−model of M, and ϕ be an
ECTLKD formula. Then, M |=k ϕ iff [ϕ]Mk ∧ [Mϕ,ι]k is satisﬁable.
Proof. Follows from Lemmas 6.1 and 6.3.	 
Corollary 6.5 M |=k ¬ϕ iff [ϕ]Mk ∧ [Mϕ,ι]k is unsatisﬁable for k = |M|.
This concludes our analysis of the translation technique. We now give an example to demonstrate how it can be put into practice.

Model checking the bit transmission problem with faults
The bit-transmission problem [8] involves two agents, a sender S, and a re- ceiver R, communicating over a possibly faulty communication channel. S wants to communicate some information—the value of a bit for the sake of the example—to R. One protocol to achieve this is as follows [8]. S imme- diately starts sending the bit to R, and continues to do so until it receives an acknowledgement from R. R does nothing until it receives the bit; from then on it sends acknowledgements of receipt to S. S stops sending the bit to R when it receives an acknowledgement. Note that R will continue sending acknowledgements even after S has received its acknowledgement. Intuitively, S will know for sure that R received the bit when it gets an acknowledgement from R. R, on the other hand, will never be able to know whether its acknowl- edgement has been received since S does not answer the acknowledgement. We refer to [9] for further discussion.
In this section we are interested in applying the machinery of bounded model checking to verify a version of the scenario above where one agent does not operate as it is supposed to. This version of the scenario was first described in [10]. In particular we examine in detail only the possibility that R is faulty 9 . Specifically, we shall consider in this section the possibility that R may send acknowledgements without having received the bit. This is a simple example of an agent not following its specification. This scenario can be analysed by means of deontic interpreted systems. We report here briefly part of the analysis that was conducted in [10], and then proceed to model check the example.
There are three active components in the scenario: a sender, a receiver, and a communication channel. In line with the spirit of the formalism of (deontic) interpreted systems, it is convenient to see sender and receiver as agents, and the communication channel as the environment. Each of these can be modelled by considering their local states 10 . For the sender S, it is enough to consider four possible local states and since we are not admitting the possibility of faults, its local states are all green. They represent the value of the bit that S is attempting to transmit, and whether or not S has received an acknowl- edgement from R. We thus have: LS = GS = {0, 1, 0-ack, 1-ack},  RS = ∅. For the environment it is enough to consider a singleton: LE = {·}. More-

9 The possibility that S is faulty, and other combinations of faulty R, S and E, can be treated in similar fashion.
10 Recall that, in order to apply the machinery of deontic interpreted systems we have
to split the set of local states of agent i into two disjoint sets: green (Gi) and red (Ri), representing correct and incorrect functioning behaviour respectively.


over, we assume that all local states of the environment are green, so we have: LE = GE,  RE = ∅. It remains to model the local states of the receiver R. Six different local states are enough to capture the state of R: the value of the received bit, the circumstance in which no bit has been received yet (represented by ϵ), the circumstance in which R has sent an acknowledge- ment without having received the value of the bit (denoted by ϵ-ack), and the circumstance in which R has sent an acknowledgement having received the value of the bit (represented by 0-ack and 1-ack). It remains to deter- mine which local states of R should be classified as red, and which as a green. This depends on how we interpret the ack component. We can view the ack as a proof that one faulty acknowledgement was sent before the value of the bit was received. On this reading we obtain the following partition of the set LR = {0, 1, ϵ, 0-ack, 1-ack, ϵ-ack} of R’s local states: GR = {0, 1, ϵ}, and RR = {ϵ-ack,0-ack,1-ack}.
The set of actions available to the agents are as follows: ActS ={sendbit, λ}, ActR = {sendack, λ}, where λ stands for no action (‘no-op’). The actions ActE for the environment correspond to the transmission of messages between S and R on the unreliable communication channel. We will assume that the communication channel can transmit messages in both directions simultane- ously, and that a message travelling in one direction can get through while a message travelling in the opposite direction is lost. The set of actions for the environment is ActE = {↔, →, ←, −}, where ↔ represents the action in which the channel transmits any message successfully in both directions, → that it transmits successfully from S to R but loses any message from R to S, ← that it transmits successfully from R to S but loses any message from S to R, and − that it loses any messages sent in either direction.
The protocols the agents are running are as follows:
PS(0) = PS(1) = {sendbit}, PS(0-ack)= PS(1-ack)= {λ},
PR(0) = PR(1) = {sendack }, PR(ϵ)= {λ},
PR(0-ack)= PR(1-ack)= {sendack }, PR(ϵ-ack)= {λ, sendack }.
PE(·)= ActE = {↔, →, ←, −}.
Note that if R performs a faulty action there is no possibility of recovery. It should be straightforward to infer the transition system that is induced by the informal description of the scenario we considered above together with the local states and protocols defined above. We refer to [10] for further discussion. We now encode the local states in binary form in order to use them in the model checking technique. Since the sender S can be in 4 different local green states we shall need 2 bits to encode its state; we take: (0, 0) = 0, (0, 1) = 1, (1, 0) = 0-ack, (1, 1) = 1-ack. Since the receiver R can be in 3 different


local green states and in 3 different local red states, we shall need 2 + 2 bits to encode its state; we take: (1, 0; 0, 0) = 0, (0, 1; 0, 0) = 1, (0, 0; 0, 0) = ϵ,
(0, 0; 1, 0) = 0-ack, (1, 1; 0, 0) = 1-ack, (1, 1; 1, 0) = ϵ-ack. The modelling of the environment E requires only one bit: (0) = ·
In view of this, a global state is modelled by a byte: s = (s[1], s[2], s[3], s[4], s[5], s[6], s[7]). For instance the initial state ι = (0, ϵ, ·) is represented as a tuple of seven 0’s. If we want to represent it in terms of propositional
variables, we shall have to insist on the propositions encoding the state to be in the state of false. In other words, we would encode the initial state as
follows: Iι(w0,0)=  7	¬w0,0[i].
Let PV = {bit = 0, bit = 1, recbit, recack}. We use the following inter- pretation for the proposition variables in PV:
(M, s) |= bit = 0 if lS(s)= 0 or lS(s)= 0-ack, (M, s) |= bit = 1 if lS(s)= 1 or lS(s)= 1-ack,
(M, s) |= recbit if lR(s)= 1 or lR(s)= 0 or lR(s)= 0-ack or lR(s)= 1-ack, (M, s) |= recack if lS(s)= 1-ack or lS(s)= 0-ack.
Some properties we may be interested in checking for the example above are the following:
AG ¬recack ∨ KS(OR(KR(bit = 0) ∨ KR(bit = 1))) 
OR(recack ∧ ¬(KR(bit = 0) ∨ KR(bit = 1)))
AG OR(KS(KR(bit = 0) ∨ KR(bit = 1))) 
AU OR(KR(bit = 0) ∨ KR(bit = 1)), recack 
Property (i) says that forever in the future if an ack is received by S, then S knows that in all the states where R is functioning correctly, R knows the value of the bit. Property (ii) states that in all the states where R is functioning correctly S has received an acknowledgement and R does not know the value of the bit. Property (iii) says that forever in the future in all the states where R is functioning correctly, S knows that R knows the value of the bit. Property (iv) says that at one point at the future an ack is received by S and at all the preceding points in time in all states where R was operating as intended R knew the value of the bit.
The property (i) is true on the interpreted system in consideration, but the properties (ii), (iii) and (iv) are not. The formula (i) is an ACTLKD formula, so in order to check it we shall have to encode the whole model. We can do this in the BMC technique reported above, but, as mentioned already,


the benefits of BMC are most apparent when only a fraction of the model is generated. For example this happens in formulas (ii), (iii) and (iv) where we need to check validity of an ECTLKD formula in the model. For the purposes of this paper we check validity of the formula (iii). The negated formula is:

ϕ := EF OR(KS(KR¬(bit = 0) ∧ KR¬(bit = 1))) 
The translation for the propositions used in ϕ is as follows: (bit = 0)(w)
:= (¬w[1] ∧ ¬w[2]) ∨ (w[1] ∧ ¬w[2]), which means that (bit = 0) holds at all the global states with the first local state equal to (0, 0) or (1, 0). (bit = 1)(w)
:= (¬w[1] ∧ w[2]) ∨ (w[1] ∧ w[2]), which means that (bit = 1) holds at all the global states with the first local state equal to (0, 1) or (1, 1).
The translation for the equality of the R-local states is as follows:
HK(w, v)=  6	w[i] ⇔ v[i], and the translation of an accessibility of a global
state in which R is running correctly is as follows: HO(v) = (v[3] ∧ ¬v[4]) ∨
(¬v[3] ∧ v[4]) ∨ (¬v[3] ∧ ¬v[4]) ∨ (¬v[3] ∧ ¬v[4]) ∨ (v[3] ∧ v[4]). The translation
of the equality of the S-local states is as follows: HK(w, v)=  2	w[i] ⇔ v[i].
We calculate that fk(ϕ) = 5 for all k ∈ N+ (see Definition 5.2), so we need to exploit five symbolic k−paths. To proceed with the translation, the first thing we need to translate is the initial state ι = (0, ϵ, ·), where ι is binary
represented by (0,... , 0). With the representation above this will be encoded
by the propositional formula Iι(w0,j) :=  7	¬w0,j[i], for 0 ≤ j ≤ 5.
The next step is to translate the transitions T (wi,j, wi+1,j); for simplic- ity we report only on one transition for the case k = 1, and in particular only on the formula T (w0,1, w1,1) representing the first transition of the first path. The remaining formulas are T (w0,2, w1,2), T (w0,3, w1,3), T (w0,4, w1,4) and T (w0,5, w1,5).
To encode the whole example we should model all the transitions for all the k’s starting from k := 1. We do not do it here. Let us now encode the formula ϕ we would like to check.
[ϕ][0,0] :=
 	 	   	   	   

5
i=1
Next:
H(wm,n, w0,i) ∧
k j=0
[OR(KS(KR¬(bit = 0) ∧ KR¬(bit = 1)))][j,i]

[OR(KS(KR¬(bit = 0) ∧ KR¬(bit = 1)))][j,i] :=  5	 Iι(w  ) ∧
0,i
  k	(HO(wj,i) ∧ [KS(KR¬(bit = 0) ∧ KR¬(bit = 1))][j,i]) 
j=0	R	k
Next:
[KS(KR¬(bit = 0) ∧ KR¬(bit = 1))][j,i] :=  5	 Iι(w  ) ∧
0,i


k j=0
k

([(KR¬(bit = 0) ∧ KR¬(bit = 1))][j,i]
i=1
K
S


Next:
[(KR¬(bit = 0)∧KR¬(bit = 1))][j,i] = [KR¬(bit = 0)][j,i]∧[KR¬(bit = 1)][j,i]

Next:
k	k	k

[KR¬(bit = 0)][j,i]:=  5
 Iι(w0,i) ∧  k	([¬(bit = 0)][ ] ∧ HK(wm,n, wj,i)) 
j,i

[KR¬(bit = 1)][j,i]:=  5
 Iι(w0,i) ∧  k	([¬(bit = 1)][ ] ∧ HK(wm,n, wj,i)) 
j,i

Next:
k	i=1
j=0	k	R

[¬(bit = 0)][j,i]:= ¬(bit = 0)(wj,i) and [¬(bit = 1)][j,i]:= ¬(bit = 1)(wj,i).
k	k
Checking that the bit transmission protocol satisfies the temporal deontic
formula above can now be done by feeding a SAT solver with the propositional formula generated in this method. This would produce a solution, thereby proving that the propositional formula is satisfiable.

Conclusions
In this paper we extended the methodology of bounded model checking for CTLK, presented in [13] by adding the deontic notion of correct functioning behaviours of the agents. This notion was explored in [11,10].
Model checking of deontic interpreted system may also be performed by means of Ordered Binary Diagrams (OBDD). This was explored in [15,16].
Future work include an implementation of the algorithm presented here, a careful evaluation of experimental results to be obtained, and a comparison of the OBDD and SAT based model checking method for deontic interpreted systems.

References
N. Amla, R. Kurshan, K. McMillan, and R. Medel. Experimental analysis of different techniques for bounded model checking. In Proc. of TACAS’03, volume 2619 of LNCS, pages 34–48. Springer-Verlag, 2003.
A. Biere, A. Cimatti, E. M. Clarke, O. Strichman, and Y. Zhu. Bounded Model Checking. In
Advances in Computers, volume 58. Academic Press, 2003. pre-print.
E. Clarke, A. Biere, R. Raimi, and Y. Zhu. Bounded model checking using satisfiability solving.
Formal Methods in System Design, 19(1):7–34, 2001.
E. M. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT Press, 1999.
F. Copty, L. Fix, R. Fraer, E. Giunchiglia, G. Kamhi, A. Tacchella, and M. Vardi. Benefits of bounded model checking at an industrial setting. In Proc. of CAV’01, volume 2102 of LNCS, pages 436–453. Springer-Verlag, 2001.
D. Dennett. The Intentional Stance. MIT Press, 1987.
E. A. Emerson and E. M. Clarke. Using branching-time temporal logic to synthesize synchronization skeletons. Science of Computer Programming, 2(3):241–266, 1982.


R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi. Reasoning about Knowledge. MIT Press, Cambridge, 1995.
J. Y. Halpern and L. D. Zuck. A little knowledge goes a long way: Knowledge-based derivations and correctness proofs for a family of protocols. Journal of the ACM, 39(3):449–478, 1992.
A. Lomuscio and M. Sergot. Violation, error recovery, and enforcement in the bit transmission problem. In Proceedings of DEON’02, London, May 2002. Journal of Applied Logic, 2:93-116, Elsevier, 2004.
A. Lomuscio and M. Sergot. Deontic interpreted systems. Studia Logica, 75, 2003.
K. McMillan. The SMV system. Technical Report CMU-CS-92-131, Carnegie-Mellon University, February 1992.
W. Penczek and A. Lomuscio. Verifying epistemic properties of multi-agent systems via bounded model checking. Fundamenta Informaticae, 55(2):167–185, 2003.
W. Penczek, B. Wo´zna, and A. Zbrzezny. Bounded model checking for the universal fragment of CTL. Fundamenta Informaticae, 51(1-2):135–156, 2002.
F. Raimondi and A. Lomuscio. Automatic verification of deontic interpreted systems by model checking via OBDD’s. In Proceedings of the Sixteenth European Conference on Artiﬁcial Intelligence (ECAI04), August 2004.
F. Raimondi and A. Lomuscio. Symbolic model checking of multi-agent systems via OBDD’s: an algorithm and its implementation. In Proc. of the 3rd Int. Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS’04), LNCS. Spinger Verlag, 2004. to appear.
M. Wooldridge. An introduction to multi-agent systems. John Wiley, England, 2002.
