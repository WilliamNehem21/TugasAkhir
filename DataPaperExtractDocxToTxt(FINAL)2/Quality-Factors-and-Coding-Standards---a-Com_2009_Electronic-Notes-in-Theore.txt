

Electronic Notes in Theoretical Computer Science 233 (2009) 89–103
www.elsevier.com/locate/entcs

Quality Factors and Coding Standards – a Comparison Between Open Source Forges
Andrea Capiluppi, Cornelia Boldyreff, Karl Beecher
Centre of Research on Open Source Software – CROSS Department of Computer Science
University of Lincoln, UK
Email: {acapiluppi,cboldyreff,kbeecher}@lincoln.ac.uk
Paul J. Adams
Research and Development, Sirius Corporation Ltd., Weybridge, UK
Email: paul.adams@siriusit.co.uk

Abstract
Enforcing adherence to standards in software development in order to produce high quality software artefacts has long been recognised as best practice in traditional software engineering. In a distributed heterogeneous development environment such those found within the Open Source paradigm, coding standards are infor- mally shared and adhered to by communities of loosely coupled developers. Following these standards could potentially lead to higher quality software.
This paper reports on the empirical analysis of two major forges where OSS projects are hosted. The first one, the KDE forge, provides a set of guidelines and coding standards in the form of a coding style that developers may conform to when producing the code source artefacts. The second studied forge, SourceForge, imposes no formal coding standards on developers. A sample of projects from these two forges has been analysed to detect whether the SourceForge sample, where no coding standards are reinforced, has a lower quality than the sample from KDE.
Results from this analysis form a complex picture; visually, all the selected metrics show a clear divide between the two forges, but from the statistical standpoint, clear distinctions cannot be drawn amongst these quality related measures in the two forge samples.
Keywords: Coding Standards, Open Source Software, Complexity.

Introduction
Programming styles and coding standards form a set of formal rules which are inter- nally shared among programmers, and enforced by software managers [29]. These rules reflect different concerns and affect areas of source code writing, with the aim of improving both the readability of source code and the maintainability of the underlying software system. They range from language-independent typographic styles, as the rules affecting how both the source code and comments are visually

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.063

structured and displayed [26,28], to general programming practices relative to spe- cific programming languages (as C++ [16]), paradigms (such as the object-oriented paradigm [21]) or development approaches (such as the Agile methodologies [31]). Research evidence has confirmed the presence of coding standards and pro- gramming styles in a wide spectrum of approaches: in commercial, proprietary, software [29], in Agile-driven systems [31] as well as in Open Source software [14]. Past empirical research also suggested that programming styles, applied in both creating new code or maintaining existing programs, have an impact on the quality
of the resulting software [28].
In this paper it is argued that, in the presence of coding standards and program- ming guidelines, the resulting software will display a higher quality than software produced without such a coding framework. Specifically, a study of whether soft- ware produced within the Open Source paradigm has higher quality as long as they implement and enforce coding practices is provided. In order to detect the quality of the resulting software, three metrics were collected, both at the granular level of functions (or OO methods), the fan-in, the fan-out (both termed as “coupling”) and the relative cyclomatic complexity. A null hypothesis was formulated: software projects from the sample implementing coding styles and standards will display lower values of complexity and coupling than counterparts from a sample not en- forcing the same standards. The first sample (“with treatment”) was randomly extracted from the KDE forge, already known for enforcing these standards and guidelines [14]. The other sample (“without treatment”) was extracted from the SourceForge repository 1 . A statistical test [32] was used to evaluate the signifi- cance of the differences in the two samples.
This paper is structured as follows:Section 2 provides a description of past and current research works which can be related to the present paper, and describes how it completes or enhances previous approaches. Section 3 presents the definitions and the attributes used in this work. It also introduces and instantiates the GQM approach [2], tailoring a research question for the current study.Section 4 produces an empirical hypothesis based on the presented research question, illustrating the null and the alternative hypotheses, as well as the complexity and coupling metrics used to evaluate them. In the same section, an overview of the samples from the two forges is also given. Section 5 presents the results of the statistical tests linked to the hypothesis, and evaluates whether the null hypothesis should be rejected or not.Section 6 illustrates both internal and external threats to validity to this empirical study, whileSections 7 and 8 conclude this paper.

Related work and Background
The research areas related to this work can be divided into three main sections: met- rics for software quality, literature on coding standards and styles and related prac- tice including tool support. Regarding the first research area, there is an extensive

1 Even if not clearly stated, it may very well the case that particular projects within SourceForge adhere to coding standards anyway. In the following, it is assumed that this effect is negligible.

software literature dealing with the measurement of software quality and associated characteristics such as complexity, comprehensibility, reusability and maintainabil- ity. Measurements have been traditionally divided into development and design quality metrics (early in the product lifecycle), e.g. [20], and post-release metrics which can be applied to a finished software product. One of the most famous ef- fort in the later area presented the results of the impact of coupling, cohesion and complexity on the development cost of object-oriented systems [4].
Quality measurement has also matured to the point at which a standard has been defined for this activity. The ISO standard for software quality measurement
[1] defines the characteristics of software quality as: functionality, reliability, usabil- ity, efficiency, maintainability and portability. In the past, there have been other attempts to determine quality numbers based on source code metrics: the most well- known is the Maintainability Index [27], which is a composite metric to assess, at the system level, the relative maintainability. The Halstead Effort [15], the McCabe cyclomatic complexity, the lines of code and comments are averaged into a single number to represent a global index of maintainability and quality. As reported in other studies [6], the McCabe values typically follow a Power-law distribution for methods or procedures in a system: using the average for such distributions will hinder some of the characteristics of the distribution, such as its skewness. The Halstead Effort metric has been evaluated as highly correlated with the McCabe index [17], but also heavily criticized as an unreliable metric [19]. In this work, the McCabe indexes are evaluated both as distribution in each project, and considering the fraction of highly complex functions (i.e., whose index is larger than 10 [23]). The Halstead Effort as a metric is not considered in this work.
Works focusing on open source quality or success often measure endogenous met- rics (often “people” or “process” metrics) such as the amount of developer activity, the number of developers, forum activity, version control etc. [8,10,12,25]. A re- lated work examining product metrics by Stamelos et al [30] undertook an analysis of 100 open source programs written for Linux and took a variety of basic static measurements (such as program length, unconditional jumps etc.). These results were compared to “industrial standards” suggested by the measurement tool.
The use of coding standards is also well covered in the literature and can be par- tially enforced through automated checkers, such as the UNIX-based lint, developed for the C programming language in the late 1970s [18]. Similar tools were later made commercially available for other programming languages, like the C++ [24]. Within the FLOSS community, there are lint-like tools available and the tool CQual++ is available for both C and C++. The use of CQual++ on Debian packages to im- prove their code quality has been recently reported [7] although it should be noted that this application has taken place after the fact, rather than as a regular practice by the project’s developer community. Also, this tool is mainly focused on code improvement through the elimination of format string vulnerabilities. Within the KDE community, there is an explicit KDE Quality Team 2 and on its webpages, de- velopers are guided towards information regarding Trolltech’s Qt application frame-

2 http://quality.kde.org/

work which is widely the core widget set within development of KDE applications. Coding standards can be automatically enforced by using Parasoft’s Insure++ in conjunction with Qt 3 .
Each KDE project has the freedom to develop its own specific Coding Style; projects are recommended to follow the kdelibs coding style 4 . There is a cod- ing style for kdelibs that is supported by a vim script in kdesdk/scripts/kde-devel- vim.vim that helps developers to keep the coding style correct. In addition to defaulting to the kdelibs coding style it will automatically use the correct style for Solid and kdepim code. Developers can add rules for other projects via the SetCodingStyle function.
In addition to these quality-related policies in KDE, there is also an automated quality assurance tool called the English Breakfast Network (EBN) 5 . The EBN is a tool for detecting and measuring aspects of quality within KDE as a whole. For example, the EBN measures code defects and errors in source documentation, such as spelling errors.

Definitions and GQM approach
The following concepts and attributes have been used to extract data from the two OSS forges, and to define the complexity and quality attributes (i.e. coupling) used to compare the samples. These metrics have been evaluated at the finest granularity level (i.e., source functions or methods); in order to compare them on the system level, they should be elevated to system level [5]. Since the McCabe complexity [22] was evaluated, and the aggregation of this metric at the system level is complicated by its own definition (i.e., the number of independent paths of an executable function, plus one), the rest of this study will analyze the software quality at the function level.
Data points: the selected KDE and SourceForge samples contain 50 projects each. The code of each project was downloaded from their respective Config- uration Management System (either CVS or SVN) on the date of their latest available commit.
Source Function: at the smallest level of granularity, both the functions of the procedural languages, and the methods of the Object-Oriented paradigm are considered as source functions, and treated as the basic unit measure for this study.
Complexity: within the software engineering literature, this is a very broad term. To help in scoping it down, this paper consider complexity only from the point of view of the source functions. The attribute that will be used to empirically detect the complexity of source functions is the McCabe cyclomatic complexity. This is a measure of structural complexity, and it can be calculated

3 http://www.parasoft.com/jsp/products/home.jsp?product=Insure
4 http://techbase.kde.org/index.php?title=Policies
5 English Breakfast Network: http://www.englishbreakfastnetwork.org

from a graph representation of a function, with each executable statement being a node on the graph, and arrows between the nodes showing the execution pathways and decision or branching nodes. Cyclomatic complexity is calculated as the number of decision (or branching) nodes plus one. In this research McCabe complexity (Mc) was evaluated for all the functions of each software system studied.
Coupling: it measures the degree to which each source function relies on other elements, that is, how interconnected is the code. Since this study is conducted at the function level, the union of all the function calls (and method invocations) form the network of couplings in a system. Each coupling can be uniquely categorized as inbound (c in) or outbound (c out) (or fan-in and fan- out), depending on the direction of the relative call. As an example, function ’sign off’ (Figure 1) has two inbound (fan-in) and three outbound (fan-out) couplings. In this study we separately measured the number of inbound and outbound couplings of each function.

Fig. 1. example of ‘inbound’ and ‘outbound’ couplings for the function “sign off”

Instability: from past literature, instability is the ratio of fan-out coupling (c o) to total coupling (c o + c i) such that I =    c o  . This metric is
(c o + c i)
an indicator of the resilience to change of software components (as in source functions) [13]. The range for this metric is 0 to 1, with I = 0 indicating the lowest instability for an element and I = 1 indicating a completely unstable element. In this paper it is argued that software systems should minimize the instability of its components in order to increase the quality of the underlying application.
KDE and SourceForge samples
The KDE forge 6 hosts a large number of OSS projects under a common name which together form both a desktop environment and associated application software, primarily for Unix-like operating systems. The KDE repository from which our samples are taken has somewhere in the order of 300 projects.
The SourceForge site 7 hosts more than 150,000 projects. However, it has been argued that a considerable proportion of SourceForge projects are to be considered as “tragedies” [10], owing to their failure to initiate a steady series of releases. No evidence of such a phenomenon in KDE is present, so to draw an accurate comparison, the sample from SourceForge has been extracted only from the pool of

6 http://www.kde.org/
7 http://sourceforge.net/index.php/

the “stable” projects (numbering approximately 20,000), i.e. those projects whose core developers labelled the status of the project with the tag “Production/Stable”. It was shown in a previous work [3] that certain exogenous characteristics of KDE differ significantly from SourceForge; specifically, KDE projects are, on average, subjected to a greater amount of activity from a greater number of developers and have been developed over a greater period of time. In addition, KDE projects were also observed to be significantly smaller than their counterparts within SourceForge.
GQM
The Goal-Question-Metric (GQM) method evaluates whether a goal has been reached, by associating that goal with questions that explain it from an opera- tional point of view, and providing the basis for applying metrics to answer these questions [2]. The aim of the method is to determine the information and metrics needed to be able to draw conclusions on the achievement of the goal.
In the following, we applied the GQM method to first identify the overall goal of this research; we then formulate a number of questions related to the two OSS forges and their relative complexity (and conversely, their quality); and finally we collected adequate product and process metrics to determine whether the goal has been achieved.
Goal: The long-term objective of this research is to assess the presence of cod- ing standards within distributed environments, and to evaluate its effectiveness towards the creation of software artefacts. In particular, the goal is to investi- gate whether OSS forges which reinforce coding standards achieve higher quality software.
Question: The purpose of this study is to establish differences between samples from KDE and SourceForge. Their complexity will be evaluated and a compar- ative research question will be evaluated via a direct comparison between the projects composing the two samples. Based on the complexity and coupling at- tributes defined above, the research question asks: in the presence of coding stan- dards, will projects be less complex, and of higher quality, than of the counterpart forges not reinforcing any standards.
Metrics: Every project from both samples will have their functions evaluated in terms of McCabe cyclomatic complexity (to assess structural complexity) and the fan-in and fan-out metrics (to assess the coupling). As a compounded metrics, the value of instability will also be evaluated based on the definition given above. Once completed, these measurements will be summarised per project for both metrics, specifically into a median value, a maximum value and a variance.

Research Hypotheses
Two related hypotheses have been formulated based on the research question com- posing the GQM approach. The objective is to show that the samples from the two forges achieve different levels of complexity and coupling, as measured by the three

attributes introduced above (mc, c i, I). The directional tests will be also consid- ered, in order to establish whether one forge achieves statistically higher quality results than the other: this means that a test will be run to check whether the KDE sample achieved a smaller level of complexity, or whether the KDE level of fan-in is larger than SourceForge. Based on common design principles, in fact, software designers and programmers should aim for low fan-out and high fan-in [11].
The statistical test have been used in this evaluation is the Wilcoxon test [32]: this is a non-parametric test, and the assumption of normality is not needed to run this test, as per the parametric family of tests. Nonparametric tests are more powerful in detecting population differences: since the normality assumptions are not clearly satisfied when considering the distribution of complexity and coupling attributes, the Wilcoxon tests were applied.
In this paper, three hypotheses were considered, as also summarized in Table 1:
Complexity: the first hypothesis relates to the complexity, measured through the cyclomatic index. The null hypothesis assumes that the KDE and the SourceForge samples display different quality, i.e. different distributions of cyclomatic complexity. In addition, the directional test will check whether the KDE sample achieves a statistically smaller complexity than the SourceForge counterpart. The tests used will be both a simple and a directional Wilcoxon test: they will be applied on the median, mean, maximum and variance of the distribution of each observed project. These values are reported in the rightmost parts of Table 3 for the KDE sample, and Table 4 for the SourceForge sample.
Table 1
Summary of the hypotheses to be tested

Fan-in: the second set of hypotheses relates to the inbound coupling (or fan- in), measured through the inbound connections of each source function. The null hypothesis assumes that the KDE and the SourceForge show different dis- tributions of the fan-in attribute. In addition, the directional test will check

whether the KDE sample achieves a statistically higher fan-in than the Source- Forge counterpart. The tests will be applied on the median, maximum and variance of the distribution of each project from KDE and SourceForge.
Instability: the last set of hypotheses considers the compounded metrics pre- sented above, which takes into account both the fan-in and the fan-out of each function. As above, the null hypothesis assumes that the KDE and the SourceForge show different distributions of the instability attribute. The added directional test instead compares the KDE and the SourceForge samples to de- tect whether the KDE one achieved a statistically lower instability. The tests will be applied on the median and variance of the distribution of each project from KDE and SourceForge. These values are reported in the central parts of Table 3 for the KDE sample, and Table 4 for the SourceForge sample.

Fig. 2. Boxplots of measured attributes in the KDE and SourceForge samples




Results
This section summarizes the findings that were collected evaluating the research hypotheses. The attributes presented above were evaluated at the latest available change recorded in the CVS or SVN repositories: the couplings (fan-in and fan- out), instability and complexity of all the functions of the projects from KDE and SourceForge were calculated. For every project in the samples, the median and variance values of all the functions were used to compare the two forges. The maximum value was also used where appropriate.
As discussed above, a statistical test [32] allowed the null hypothesis to be either rejected or confirmed. The R programming language has been used to carry out these tests based on evaluation of the data extracted earlier from the respective forges [9]. A summary of the tests and their results is provided in Table 2 below: as visible, the majority of the paired tests have non-significant p-values, and therefore it is not possible to reject the null hypothesis.


Table 2
Results of the Wilcoxon tests (p-values) when comparing the two forges – bold stands for high significance (95%), italics for weak significance




Complexity
In this work the complexity was measured, at the functions level, via the McCabe cyclomatic index [22]. As results, this paper reports on both the actual distribution of these indexes, and the conditions on the fringes of this metric. In particular, the percentage of the complexity indexes larger than a threshold (i.e., 10, from [23]) was evaluated for each project, in order to detect whether one forge achieves lower quality in terms of highly complex elements. Visually, the boxplots in figure 2 show a difference of distribution: it can be seen how the KDE forge has a much compact distribution of these highly complex functions, with only one outlier around 25%. On the other side, the SourceForge projects have a wider boxplot distribution, with a larger median, and two outliers in its distribution.
Statistically, and as visible from Table 2, only one difference was found to be significant: the median of the distributions of the complexity is statistically different in the two sample, and also the directional test is significant: the median of the complexities in the KDE sample is lower than the SourceForge counterpart. In all the other tests, this significance was not achieved, hence making it impossible to reject all the null hypotheses: from the data collected in the two sample, it is not possible to conclude that the KDE sample achieves a higher quality than SourceForge, from the point of view of the complexity achieved.

Coupling
In this work the coupling of a function is measured primarily by its instability. Whilst functions within KDE projects were observed to be more stable on average, they did not achieve a statistically significant difference from functions of Source- Forge projects.
As visible from Table 2, the median value of fan-in for KDE projects proved significantly higher than that of SourceForge projects, with H0 of hypothesis 1.2 rejected for the test c ikde < c isf at p = 0.016. However, the SourceForge projects (which are typically much larger than KDE projects) possessed significantly higher values of both variance and maximum coupling. While the projects in SourceForge may contain some functions that are used by a larger number of clients, any ran- domly chosen function from a KDE project is more likely to have a greater fan-in than that of a SourceForge project. However, examining in more detail the median fan-in results (summarized in figure 2) reveals the marginality of difference: in both forges, most projects have a median fan-in value of 1 (35 KDE projects and 29 SourceForge projects).

Threats to Validity
Two main threats to validity have been identified; they are as follows:
Size of populations – The SourceForge sample was taken from a considerably larger population than the KDE forge: approximately 20,000 “production/stable” SourceForge projects, compared around 300 within KDE. Consequently, the static sample size of 50 is not the same proportion of the population in both cases.
Automated coupling analysis – Because of the large amount of analysis necessary (100 real-world non-trivial software projects) the evaluation of coupling was au- tomated by analysis software, which is presently at a level of sophistication that has the following consequences:
Test suites, when included within the software package, are included in the analysis and so contribute to the perceived level of fan-in. It is arguable whether or not test suites should be considered “part of the software”;
The level of coupling, being measured by fan-in, is limited to being derived from a static view of the software; hence, dynamic coupling is not detected.
It is intended to refine the evaluation procedures for future analyzes to address these limitations in the analysis; and in future studies, the methods for selection of the sample populations will be given further consideration.

Conclusions
Within this paper the presence of coding standards and shared programming prac- tices, and their effectiveness on the quality of the resulting software artefacts, were analyzed. In particular this work has argued that, within the Open Source paradigm, open collections of software projects could potentially benefit from higher

quality software by openly sharing documents and guidelines on programming styles and coding standards. In order to assess this, two OSS forges (collections of software projects) were selected: the first (KDE) is a large container of applications which share the same graphical interface objectives, and guidelines are shared among de- velopers to comply with existing coding standards. The second (SourceForge) is a wider-spectrum collection of projects, and no explicit effort is attempted towards a common framework of coding rules.
Two similar sets of 50 projects were randomly selected from two similar pools of projects (i.e. the “stable” set of projects) of the selected forges. Two attributes were measured, as negative proxies for software quality, both at the level of granularity of functions (or methods): cyclomatic complexity and inbound coupling (fan-in). A third characteristic was also measured, based on the definition of instability, com- posing the inbound and outbound couplings. A Goal-Question-Metrics approach was applied, and a research hypothesis derived based on the measured characteris- tics: a random sample of sample projects from a forge (KDE) where active actions are taken towards quality will display more quality than projects were such effort is absent (SourceForge).
For the coupling characteristics of the software’s functions (as measured by in- stability and fan-in) results showed only certain marginal improvements of KDE over SourceForge. Instability was, on average, lower in KDE projects than those of SourceForge, but not significantly so. Functions within SourceForge projects had a greater variance of fan-in (with upper values exceeding those of KDE), However median fan-in values of KDE projects appeared significantly larger than Source- Forge projects. Only a more detailed inspection revealed that the improvement could likely be interpreted as marginal only.
For the complexity characteristics of the software’s functions, results showed that graphical differences could be observed in the distributions of the highly complex elements, resulting in SourceForge being more complex than KDE. Statistically, it was not possible to conclude that a significant difference could be observed in the complexity characteristics of the two forges. A general result was extracted from the metrics collected: whereas some results proved satisfactory (e.g. the statistical significance of the fan-in tests), other results contradict (complexity) these findings, creating a multi-faceted vision of software quality.

Further Work
The most important aim for future work on this topic is to refine the metrics and include new ones where it would increase understanding of the property being mea- sured. In particular it is intended to expand the scope of metrics examining modular structure, by quantifying a project’s individual structurally complex parts (modules with fan-in and fan-out values over a certain threshold) and by investigating the dynamic coupling.
It is also intended to carry out new work in addition to that outlined here. Firstly, we will investigate the evolution of the software from the perspective of

these metrics by measuring their change over time and comparing the results from each forge. Secondly, having already identified a particular subset of the KDE forge that lays claim to high quality standards (the KDE PIM), it will be established if these claims are evidenced by any resultant effects on our measurements.

References
International Organization for Standardization. Software Engineering - Product Quality - Part 1: Quality Model. ISO, Geneva, Switzerland, 2001. ISO/IEC 9126-1:2001(E) (2001).
Basili, V. R., G. Caldiera and D. H. Rombach, The goal question metric approach, in: Encyclopedia of Software Engineering (1994), pp. 528–532, see also http://sdqweb.ipd.uka.de/wiki/GQM.
Beecher, K., C. Boldyreff, A. Capiluppi and S. Rank, Evolutionary success of open source software: an investigation into exogenous drivers, Electronic Communications of the EASST: ERCIM Symposium on Software Evolution 8 (2007).
Briand, L. C. and J. Wu¨st, The impact of design properties on development cost in object-oriented systems, in: METRICS ’01: Proceedings of the 7th International Symposium on Software Metrics (2001), p. 260.
Capiluppi, A. and C. Boldyreff, Identifying and improving reusability based on coupling patterns, in:
ICSR ’08: 10th International Conference on Software Reuse, Beijing China, 25 - 29 May 2008.
Capiluppi, A., A. E. Faria and J. F. Ramil, Exploring the relationship between cumulative change and complexity in an open source system, In CSMR ’05: 9th Conference on Software Maintenance and Reengineering (2005), pp. 21–29.
Chen, K. and D. Wagner, Large-scale analysis of format string vulnerabilities in debian linux, in: PLAS ’07: Proceedings of the 2007 workshop on Programming languages and analysis for security (2007), pp. 75–84.
Crowston, K., J. Howison and H. Annabi, Information systems success in free and open source software development: Theory and measures, Software Process Improvement and Practice (2006), pp. 123–148.
Dalgaard, P., “Introductory Statistics with R,” Springer, 2002, 89–90 pp.
English, R. and C. M. Schweik, Identifying success and tragedy of floss commons: A preliminary classification of sourceforge.net projects, in: International Workshop on Emerging Trends in FLOSS Research and Development, 2007.
Ghezzi, C., M. Jazayeri and D. Mandrioli, “Fundamentals of Software Engineering,” Prentice Hall PTR, Upper Saddle River, NJ, USA, 2002.
Godfrey, M. W. and Q. Tu, Evolution in open source software: A case study, in: ICSM, 2000, pp. 131–142.
Gorton, I. and L. Zhu, Tool support for just-in-time architecture reconstruction and evaluation: an experience report, in: ICSE ’05: Proceedings of the 27th international conference on Software engineering, 2005, pp. 514–523.
Halloran, T. J. and W. L. Scherlis, High quality and open source software practices, in: Meeting Challenges and Surviving Success: 2nd ICSE Workshop on Open Source Software Engineering, Orlando, FL, 2002.
Halstead, M., “Elements of Software Science,” Elsevier, New York, 1977.
Henricson, M. and E. Nyquist, Programming in C++, rules and recommendations, Technical Report M 90 01 18 Uen (1992).
URL citeseer.ist.psu.edu/henricson92programming.html

Henry, S., D. Kafura and K. Harris, On the relationships among three software metrics, SIGMETRICS Perform. Eval. Rev. 10 (1981), pp. 81–88.
Johnson, S., Lint, a c program checker, in: Unix Programmer’s Manual, AT&T Bell Laboratories, 1978.
URL citeseer.ist.psu.edu/johnson78lint.html
Jones, C., Software metrics: Good, bad and missing, Computer 27 (1994), pp. 98–100.


Kim, H. and C. Boldyreff, Software metrics applicable to uml models: An investigation and an implementation, in: Proceedings of QAOOSE2002, 2002.
Kim, M., L. Bergman, T. Lau and D. Notkin, An ethnographic study of copy and paste programming practices in oopl, in: ISESE ’04: Proceedings of the 2004 International Symposium on Empirical Software Engineering (2004), pp. 83–92.
McCabe, T. J., A complexity measure, IEEE Trans. Software Eng. 2 (1976), pp. 308–320.
McCabe, T. J. and C. W. Butler, Design complexity measurement and testing, Commun. ACM 32
(1989), pp. 1415–1425.
Meyers, S. and M. Klaus, A first look at c++ program analyzers, Dr. Dobbs Journal 22 (1997).
Mockus, A., R. Fielding and J. Herbsleb, Two case studies of open source software development: Apache and mozilla, ACM Trans. Softw. Eng. Methodol. 11 (2002), pp. 309–346.
Mohan, A. and N. Gold, Programming style changes in evolving source code, iwpc 00 (2004), p. 236.
Oman, P. and J. Hagemeister, Construction and testing of polynomials predicting software maintainability, Journal of Systems and Software 24 (1994), pp. 251–266.
Oman, P. W. and C. R. Cook, Typographic style is more than cosmetic, Commun. ACM 33 (1990),
pp. 506–520.
Pfleeger, S. L., “Software engineering: the production of quality software,” Macmillan Publishing Co., Inc., Indianapolis, IN, USA, 1987.
Stamelos, I., L. Angelis, A. Oikonomou and G. Bleris, Code quality analysis in open source software development, Information Systems Journal (2002), pp. 43–60.
Succi, G. and M. Marchesi, editors, “Extreme programming examined,” Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2001.
Wilcoxon, F., Individual comparisons by ranking methods, Biometrics Bulletin 1 (1945), pp. 80–83.




Table 3
Summary of instability and complexity attributes in sample KDE projects




Table 4
Summary of instability and complexity attributes in sample SourceForge projects
