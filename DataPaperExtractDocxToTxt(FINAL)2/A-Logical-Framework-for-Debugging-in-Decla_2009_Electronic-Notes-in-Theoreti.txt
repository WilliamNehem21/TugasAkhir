

Electronic Notes in Theoretical Computer Science 256 (2009) 119–135
www.elsevier.com/locate/entcs

A Logical Framework for Debugging in Declarative Constraint Programming
Rafael del Vado V´ırseda 1,2
Dpto. de Sistemas Informa´ticos y Computacio´n Universidad Complutense de Madrid
Madrid, Spain

Abstract
We present a logical and semantic framework for diagnosing wrong computed answers in CFLP (D), a newly proposed generic scheme for lazy Constraint Functional Logic Programming which can be instantiated by any constraint domain D given as parameter, and supports a powerful combination of functional and constraint logic programming over D. Our approach extends and combines declarative debugging techniques previously developed for less expressive programming paradigms, namely the CLP (D) scheme and lazy functional logic languages. Debugging starts with the observation of a wrong computed answer which the user regards as incorrect w.r.t. an intended model that provides a declarative description of the program’s semantics. Debugging proceeds by exploring an abridged proof tree that provides a purely declarative view of the computation, so that the user does not need to understand the complex underlying operational mechanisms. Debugging ends with the detection of a function rule in the program that is incorrect w.r.t. the intended model. We prove the logical correctness of the debugging method for any sound CFLP (D)- system whose computed answers are logical consequences of the program, and we describe a practical tool which implements the debugging method for the domain of arithmetic constraints over the real numbers.
Keywords: Logical Frameworks, Declarative Programming, Algorithmic Debugging, Constraints.


Introduction
Debugging tools are a practical need for diagnosing the causes of erroneous computa- tions. Declarative programming paradigms involving complex operational details, such as constraint solving and lazy evaluation, do not fit well to traditional de- bugging techniques relying on the inspection of low-level computation traces. As a solution to this problem, declarative diagnosis uses Computation Trees (shortly, CTs) in place of traces. CTs are built a posteriori to represent the structure of a computation whose top level outcome is regarded as an error symptom by the user.

1 The author has been partially supported by the Spanish National Projects FAST-STAMP (TIN2008- 06622-C03-01), MERIT-FORMS (TIN2005-09027-C03-03), PROMESAS-CAM (S-0505/TIC/0407), and UCM-BSCH-GR58/08-910502 (GPD-UCM).
2 Email: rdelvado@sip.ucm.es

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.009

Each node in a CT represents the computation of some observable result, depending on the results of its children nodes. Declarative diagnosis explores a CT looking for a so-called buggy node which computes an incorrect result from children whose results are correct; such a node must point to an incorrect program fragment. The search for a buggy node can be implemented with the help of an external oracle (usually the user with some semiautomatic support) who has a reliable declarative knowledge of the expected program semantics, the so-called intended interpretation.
The generic description of declarative diagnosis in the previous paragraph follows [16]. Declarative diagnosis was first proposed in the field of logic programming [20,9], and it has been successfully extended to other declarative programming paradigms, including lazy functional programming [17,19], constraint logic programming [21,10] and functional logic programming [5,6]. In contrast to recent approaches to error diagnosis using abstract interpretation (as e.g. [7,12,1] and some of the approaches described in [8]), declarative diagnosis often involves complex queries to the user. This problem has been tackled by means of various techniques, such as user-given partial specifications of the program’s semantics [2,6], safe inference of information from answers previously given by the user [5], or CTs tailored to the needs of a particular debugging problem over a particular computation domain [10]. Current research in declarative diagnosis has still to face many challenges regarding both the foundations and the development of practical tools.
The aim of this paper is to present a logical and semantic framework for diagnos- ing wrong computed answers in CFLP (D), a newly proposed generic programming scheme which can be instantiated by any constraint domain D given as parameter, and supports a powerful combination of functional and constraint logic program- ming over D [14]. Borrowing ideas from CFLP (D) declarative semantics we obtain a suitable notion of intended interpretation, as well as a kind of abridged proof trees with a sound logical meaning to play the role of CTs. Our aim is to achieve a natural combination of previous approaches that were separately developed for the CLP (D) scheme [21] and for lazy functional logic languages [5]. We give theoretical results showing that the proposed debugging method is logically correct for any sound CFLP (D)-system whose computed answers are logical consequences of the program in the sense of CFLP (D) semantics. We also present a practical debugger called DDT , developed as an extension of previously existing but less powerful tools [3,6]. DDT implements the proposed diagnosis method for CFLP (R)-programming in the T OY system [15] using the domain R of arithmetic constraints over the real numbers.
The rest of the paper is organized as follows: Section 2 motivates our approach by presenting a debugging example which is used as illustration along the rest of the paper. Section 3 recalls the CFLP (D) scheme from [14] to the extent needed for understanding the theoretical results in this paper. Section 4 presents a correct method for the declarative diagnosis of wrong computed answers in any soundly im- plemented CFLP (D)-system. Section 5 describes the debugging tool DDT . Section

6 concludes and points to some plans for future work.



A Motivating Example
As a motivation for the rest of the paper, we consider the following program frag- ment written in T OY [15], a programming system which supports several instances of the CFLP (D) scheme:


Example 2.1 (Building Ladders in T OY)



Here, T OY is used to implement the instance CFLP (R) of the CFLP (D) scheme, with the parameter D replaced by the real number domain R, which provides real numbers, arithmetic operations and various arithmetic constraints, including equali- ties, disequalities and inequalities. The type figure is intended to represent geometric figures as boolean functions, the function rect is intended to represent rectangles (more precisely, (rect (X,Y) LX LY) is intended to represent a rectangle with leftmost- bottom vertex (X,Y) and rightmost-upper vertex (X+LX,Y+LY)); and the function ladder is intended to build an infinite list of rectangles in the shape of a ladder. Although the text of the program seems to include no constraints, it uses arithmetic and comparison operators that give rise to constraint solving in execution time. More

precisely, consider the following session in T OY:

Toy> /run(examples/debug/ladder)	% compile ladder.toy
Toy> /cflpr	% load CFLP (R)
Toy(R)> intersect (head (ladder (20,20) 50 20))
(head (ladder (5,5) 30 40)) (X,Y) == R	% goal
{ R –> true } { Y <= 5, X >= 2.0E+01, X <= 35 }	% computed answer
The goal asks for the membership of a generic point (X,Y) to the intersection of the two rectangles (rect (20,20) 50 20) and (rect (5,5) 30 40), computed indirectly as the first steps of two particular ladders. The diagram included in Example 2.1 shows these two rectangles as well as the rectangle corresponding to their intersection (highlighted in black). The T OY system has solved the goal by a combination of lazy narrowing and constraint solving; the computed answer consists of the substitution R –> true and three constraints imposed on the variables X and Y 3 . The only constraint imposed on Y (namely Y <= 5) allows for arbitrarily small values of Y, which cannot correspond to points belonging to the rectangle expected as intersection. Therefore, the user will view the computed answer as wrong w.r.t. the intended meaning of the program. As we will see in Sections 4 and 5, the declarative debugging technique presented in this paper leads to the diagnosis of the program rule for the function rect as responsible for the wrong answer. Indeed, this program rule is incorrect w.r.t. the intended program semantics; as shown in Example 2.1, the third inequality at the right hand side should be Y’ >= Y instead of Y’ <= Y.

The traditional approach to declarative debugging in the CLP (D) scheme in- cludes the diagnosis of both wrong and missing computed answers [21]. However, the declarative diagnosis of missing answers falls outside the scope of this paper.
The CFLP (D) Programming Scheme
In this section we recall the essentials of the CFLP (D) scheme [14] for lazy Cons- traint Functional Logic Programming over a parametrically given constraint domain D, which serves as a logical and semantic framework for the declarative diagnosis method presented in the paper.


Preliminary notions
We consider a universal signature Σ = ⟨DC, FS⟩, where DC = 


DCn and

FS =
n∈N FSn
n∈N
are countably infinite and mutually disjoint sets of data cons-

tructors resp. evaluable function symbols, indexed by arities. Evaluable functions are further classified into domain dependent primitive functions PFn ⊆ FSn and user deﬁned functions DFn = FSn \ PFn for each n ∈ N. We write Σ⊥ for the

3 There are other five computed answers consisting of the substitution R –> false and various constraints imposed on X and Y.

result of extending DC0 with the special symbol ⊥, intended to denote an undefined data value and we assume that DC includes the two constants true and false and the usual list constructors. We use the notations c, d ∈ DC, f, g ∈ FS and h ∈ DC ∪FS. We also assume a countably infinite set V of variables X, Y, . . . and a set U of primitive elements u, v,... (as e.g. the set R of the real numbers) mutually disjoint and disjoint from Σ⊥. Expressions e ∈ Exp⊥(U ) have the following syntax:
e ::= ⊥ | u | X | h | (e e1 ... em) % shortly: (e em)
where u ∈ U , X ∈ V, h ∈ DC ∪ FS. An important subclass of expressions is the set of patterns s, t ∈ Pat⊥(U ), whose syntax is defined as follows:

t ::= ⊥ | u | X | (c tm) | (f tm)
where u ∈ U , X ∈ V, c ∈ DCn with m ≤ n, and f ∈ FSn with m < n. Patterns are used as representations of possibly functional data values. For instance, the rectangle (rect (5, 5) 30 40) we met when discussing Example 2.1 is a functional data value represented as pattern. 4
As usual, we define substitutions σ ∈ Sub⊥(U ) as mappings σ : V → Pat⊥(U ) extended to σ : Exp⊥(U ) → Exp⊥(U ) in the natural way. By convention, we write eσ instead of σ(e) for any e ∈ Exp⊥(U ), and σθ for the composition of σ and θ. A substitution σ such that σσ = σ is called idempotent.


Constraints over a constraint domain
Intuitively, a constraint domain provides a set of specific data elements, along with certain primitive functions operating upon them. Primitive predicates can be mo- delled as primitive functions returning boolean values. Formally, a constraint do- main with primitive elements U and primitive functions PF ⊆ FS is any structure D = ⟨DU , {pD | p ∈ PF}⟩ with carrier set DU the set of ground patterns (i.e., with- out variables) over U and interpretations pD ⊆ Dn × DU of each p ∈ PFn satisfying the technical monotonicity, antimonotonicity, and radicality requirements given in [14]. We use the notation pD tn → t to indicate that (tn, t) ∈ pD.
Constraints over a given constraint domain D are logical statements built from atomic constraints by means of logical conjunction ∧ and existential quantification
∃. Atomic constraints can have the form ♦ (standing for truth), ◆ (standing for
falsity), or p en →! t , meaning that the primitive function p ∈ PFn with parameters en ∈ Exp⊥(U ) returns a total result t ∈ Pat⊥(U ) (i.e, with no occurrences of ⊥). Constraints whose atomic parts have the form ♦, ◆ or p tn →! t with tn ∈ Pat⊥(U ) are called primitive constraints. In the sequel, we use the notation PCon⊥(D) for the set of primitive constraints over D and DCon⊥(D) for the set of user defined constraints over D.


4 Note that (5, 5) can be seen as syntactic sugar for (pair 5 5), pair being a constructor for ordered pairs.

Example 3.1 (Constraint Domain R) The constraint domain R has the carrier set DR of ground patters over R and the primitives defined below:
eqR, equality primitive for real numbers, such that: eqR u u → true for all
u ∈ R; eqR u v → false for all u, v ∈ R, u /= v; eqR t s →⊥ otherwise.
R	R
seq, strict equality primitive for ground patterns over the real numbers, such that: seqR t t → true for all total t ∈ DR; seqR t s → false for all t, s ∈ DR such that t, s have no common upper bound w.r.t. the information ordering introduced in [14] and defined in the Appendix; seqR t s → ⊥ otherwise. In the sequel, e1 == e2 abbreviates seq e1 e2 →! true.
(iii) +, −, ∗, for addition, subtraction and multiplication, such that: x +R y → x +R y for all x, y ∈ R; t +R s →⊥ whenever t ∈/ R or s ∈/ R; and analogously for −R and ∗R.
(iv) <, ≤, >, ≥, for numeric comparisons, such that: x <R y → true for all x, y ∈
R with x <R y; x <R y → false for all x, y ∈ R with x ≥R y; t <R s → ⊥ 

whenever t ∈/
R or s ∈/
R; and analogously for ≤R, >R, ≥R. In the sequel,

e1 < e2 abbreviates e1 < e2 →! true and e1 ≥ e2 abbreviates e1 < e2 →! false
(analogously for other comparison primitives).
The set of valuations over a constraint domain D is defined as the set V al⊥(D) of ground substitutions (i.e., mappings from variables into ground patterns). The semantics of constraints relies on the idea that a given valuation can satisfy or not a given constraint. Therefore, the set of solutions of π ∈ PCon⊥(D) can be defined in a natural way as a subset SolD(π) ⊆ V al⊥(D); see [14] for details. Moreover, the

set of solutions of Π ⊆ PCon⊥(D) is defined as SolD(Π) = 
π∈Π
SolD(π).


Constraint functional-logic programming
For any given constraint domain D, a CFLP (D)-program P is presented as a set of constrained rewrite rules, called program rules, that define the behavior of user- defined functions. More precisely, a constrained program rule R for f ∈ DFn has the form R : f tn → r ⇐ Δ (abbreviated as f tn → r if Δ is empty) and is required to satisfy the conditions listed below: 5

The left-hand side f tn is a linear expression (i.e, there is no variable having more than one occurrence), and for all 1 ≤ i ≤ n, ti ∈ Pat⊥(U ) are total patterns. The right-hand side r ∈ Exp⊥(U ) is also total.
Δ ⊆ DCon⊥(D) is a finite set of total atomic constraints, intended to be interpreted as conjunction, and possibly including occurrences of user defined functions.
Program defined functions can be higher-order and/or non-deterministic. For ins- tance, the T OY program presented in Section 2 can be viewed as an example of

5 In practice, T OY and similar languages require program rules to be well-typed in a polymorphic type system. However, the CFLP (D) scheme can deal also with untyped programs. Well-typedness is viewed as an additional requirement, not as part of progam semantics.

CFLP (R)-program written in T OY’s syntax. The reader is referred to [14] for more explanations and examples in other constraint domains.
The intended use of programs is to perform computations by solving goals pro- posed by the user. An admissible goal for a given CFLP (D)-program must have the form G : ∃U. (P  Δ), where U is a finite set of so-called existential variables of the goal G (the rest of variables in G are called free variables and denoted by fvar(G)), P is a finite conjunction of so-called productions of the form e → s fulfilling the admissibility conditions given in [14], with e ∈ Exp⊥(U ) and s ∈ Pat⊥(U ) intended
to mean that e can be evaluated to s, and Δ ⊆ DCon⊥(D) is a finite conjunction of total user defined constraints. Two special kinds of admissible goals are interesting. Initial goals, where U and P are both empty (i.e., G has only a constrained part
Δ without occurrences of existential variables), and solved goals (also called solved forms) of the form S : ∃U. (σ   Π), where σ is a finite set of productions X → t
or s → Y interpreted as the variable bindings of an idempotent substitution and Π
⊆ PCon⊥(D) is a finite conjunction of total primitive constraints. Finally, a goal solving system for CFLP (D) is expected to accept a program P and an initial goal G from the user, and to obtain one or more solved forms Si as computed answers. As explained in Section 2, an initial goal G for the CFLP (R)-program shown in Example 2.1 can be intersect (head (ladder (20, 20) 50 20)) (head (ladder (5, 5) 30 40)) (X, Y ) == R and a computed answer S for G is R → true  X ≤ 35 ∧ X ≥ 20 ∧ Y ≤ 5.
Goal solving systems can be implementations of CFLP languages such as Curry
[11] or T OY [15], or formal goal solving calculi including recent proposals such as the CDNC(D) calculus [22], which is sound and complete w.r.t. the declarative semantics discussed in the next subsection, and behaves as a faithful formal model for actual computations in the T OY system.

Declarative semantics
In this subsection we recall some notions and results on the declarative semantics of CFLP (D)-programs which were developed in [14] and are needed for the rest of this paper. Given a constraint domain D we consider two different kinds of constrained statements (briefly, c-statements) involving partial patterns t, ti ∈ Pat⊥(U ), par- tial expressions e, ei ∈ Exp⊥(U ), and a finite set Π ⊆ PCon⊥(D) of primitive constraints:
c-productions e → t ⇐ Π, with e ∈ Exp⊥(U ) and t ∈ Pat⊥(U ), intended to mean that e can be evaluated to t if Π holds (if Π is empty they boil down to unconstrained productions written as e → t). As a particular kind of c- productions useful for debugging we distinguish c-facts f tn → t  ⇐ Π with f ∈ DFn. A c-production is called trivial iff t = ⊥ or SolD(Π) = ∅.
c-atoms p en →! t ⇐ Π, with p ∈ PFn and t total (if Π is empty they boil down to unconstrained atoms written as p en →! t ). A c-atom is called trivial iff SolD(Π) = ∅.
In the sequel, we use ϕ to denote any c-statement. A c-interpretation over D is defined as any set I of c-facts including all the trivial c-facts and closed under D-

entailment, a generalization of the entailment notion introduced in [5] to arbitrary constraint domains. We write I ▶D ϕ to indicate that the c-statement ϕ (not necessarily a c-fact) is semantically valid in the c-interpretation I. This notation relies on a formal definition given in [14]. Now we are in a position to define various semantics notions which rely on a given c-interpretation I over D.
Definition 3.2 (Interpretation-dependent Semantic Notions)
The set of solutions of δ ∈ DCon⊥(D) is a subset SolI(δ) ⊆ V al⊥(D) defined as follows:
SolI(π) = SolD(π), for any π ∈ PCon⊥(D).
SolI(δ) = {η ∈ V al⊥(D) | I ▶D δη}, for any δ ∈ DCon⊥(D) \ PCon⊥(D). The set of solutions of a set of constraints Δ ⊆ DCon⊥(D) is defined as

SolI(Δ) = 
δ∈Δ
SolI(δ).

The set of solutions of a production e → t is a subset SolI(e → t) ⊆ V al⊥(D) defined as SolI(e → t) = {η ∈ V al⊥(D) | I ▶D eη → tη}. The set of solutions

of a set of productions P is defined as SolI(P ) = 
(e→t)∈P
SolI(e → t).



The set of solutions of an admissible goal G : ∃U. (P   Δ) is a subset SolI(G)
⊆ V al⊥(D) defined as follows: SolI(G) = {η ∈ V al⊥(D) | η' ∈ SolI(P ) ∩
SolI(Δ) for some η' such that η'(X) = η(X) for all X ∈/ U}.
For primitive constraints one can easily check that SolI(Π) = SolD(Π). Moreover, we note that SolI(S) = SolD(S) for every solved form S.
Definition 3.3 (Model-theoretic Semantics) Let P a CFLP (D)-program and
I a c-interpretation.
I is a model of P (in symbols, I |=D P) iff every constrained program rule (ftn → r ⇐ Δ) ∈ P is valid in I: for any ground substitution η ∈ Sub⊥(U ) and t ∈ Pat⊥(U ) ground such that (ftn → r ⇐ Δ)η is ground, I ▶D Δη and I ▶D rη → t one has I ▶D (ftn)η → t (or equivalently, ((ftn)η → t) ∈ I).
A solved form S is a semantically valid answer for a goal G w.r.t. a program
P (in symbols, P |=D G ⇐ S) iff SolD(S) ⊆ SolI(G) for all I |=D P.

Declarative Diagnosis of Wrong Answers in CFLP (D)
In this section, we present the logical and semantic framework of the declarative diagnosis method for CFLP (D) and prove its logical correctness. In what follows, we assume that a constraint domain D and a CFLP (D)-program P are given.

Wrong answers and intended interpretations
Declarative diagnosis techniques rely on a declarative description of the intended program semantics. We will assume that the user knows (at least to the extent needed for answering queries during the debugging sesion) a so-called intended model I, which is a c-interpretation expected to satisfy I |=D P, unless P is incorrect. For

instance, rect (X, Y ) LX LY (A, B) → false ⇐ A < X ∧ LX > 0 ∧ LY > 0 could belong to the intended model I for the program fragment shown in Example 2.1. As explained in Subsection 3.4, the c-facts belonging to c-interpretations can be non-ground. Nevertheless, the model notion I |=D P used here (see Definition 3.3 above) corres- ponds to the so-called weak semantics from [14], which depends just on the ground c-facts valid in I. Therefore, different presentations of the intended model will be equivalent for the purposes of this paper, as long as the ground c-facts valid in them are the same.
The aim of declarative diagnosis is to start with an observed symptom of erro- neous program behavior, and detect some error in the program. The proper notions of symptom and error in our setting are as follows:
Definition 4.1 (Symptoms and Errors) Assume I is the intended interpreta- tion for program P, and consider a solved form S produced as computed answer for the initial goal G by some goal solving system. We define:
S is a wrong answer w.r.t I (serving as symptom) iff SolD(S) /⊆ SolI(G).
P is incorrect w.r.t. I iff there exists some program rule (ftn → r ⇐ Δ) ∈P 
(manifesting an error) that is not valid in I (in the sense of Definition 3.3).
For instance, the computed answer shown in Example 2.1 is wrong w.r.t. the in- tended model for the program assumed in that example, for the reasons already discussed in Section 2. As illustrated by this example, computed answers typi- cally include constraints on the variables occurring in the initial goal. However, goal solving systems for CFLP (D) programs also maintain internal information on constraints related to variables used in intermediate computation steps, but not occurring in the initial goal. Such information is relevant for declarative debug- ging purposes. Therefore, in the rest of this section we will assume that computed answers S include also constraints related to intermediate variables.
A logical calculus for witnessing computed answers
Assuming that S is a computed answer for an initial goal G using program P, declarative diagnosis needs a suitable Computation Tree (shortly, CT ) represen- ting the computation. In our setting we will obtain the CT from a logical proof P ▶CP P C(D) G ⇐ S which derives the statement G ⇐ S from the program P in the Constraint Positive Proof Calculus (shortly CPPC(D)) given by the inference rules in Fig. 1. We will say that the CPPC(D)-proof witnesses the computed answer.
Most of these rules have been borrowed from the proof theory of CRWL(D), a Constraint ReWriting Logic which characterizes the semantics of CFLP (D) pro- grams [14]. The main novelties in CPPC(D) are the addition of rule EX (to deal with the existential quantifiers in computed answers) and a reformulation of rule DFP , which is presented as the consecutive application of two inference steps named ARf and FAf , which cannot be applied separately. The purpose of this composite inference is to introduce the c-facts f tn → t ⇐ Π at the conclusion of inference FAf , called boxed c-facts in the sequel. As we will see, only boxed c-facts will appear




EX Existential	Gσ ⇐ Π
G ⇐ ∃U. (σ   Π)
if fvar(G) ∩ U = ∅.

TI Trivial Inference	ϕ	if ϕ is a trivial c-statement.
RR Restricted Reflexivity	t → t ⇐ Π	if t ∈ U ∪ V.

SP Simple Production

s → t ⇐ Π

if s ∈ Pat⊥(U ), s ∈ V or t ∈ V, and SolD(Π) ⊆ SolD(s → t).

DC Decomposition	e1 → t1 ⇐ Π ... em → tm ⇐ Π
hem → htm ⇐ Π

IR Inner Reduction	e1 → t1 ⇐ Π ... em → tm ⇐ Π
hem → X ⇐ Π
if hem ∈/ Pat⊥(U ), X ∈V and SolD(Π) ⊆ SolD(htm → X)

PF Primitive Function	e1 → t1 ⇐ Π ... en → tn ⇐ Π
p en → t ⇐ Π
if p ∈ PFn, ti ∈ Pat⊥(U ) for each 1 ≤ i ≤ n, and SolD(Π) ⊆ SolD(ptn → t).


DFP P-Defined Function

e1 → t1 ⇐ Π ... en → tn ⇐ Π

	Δ ⇐ Π	r → t ⇐ Π (FAf ) 





(ARf )

f en → t ⇐ Π
Δ ⇐ Π r → s ⇐ Π (FAf )
e1 → t1 ⇐ Π ... en → tn ⇐ Π	s ak → t ⇐ Π

f enak → t ⇐ Π	(ARf )


if f ∈ DFn (k > 0), (f tn → r ⇐ Δ) ∈ [P]⊥ ≡ {Rθ | R ∈ P, θ ∈ Sub⊥(U )} and

s ∈ Pat⊥(U ).

AC Atomic Constraint	e1 → t1 ⇐ Π ... en → tn ⇐ Π
p en →! t ⇐ Π
if p ∈ PFn, ti ∈ Pat⊥(U ) for each 1 ≤ i ≤ n, and SolD(Π) ⊆ SolD(ptn →! t).


Fig. 1. The Constraint Positive Proof Calculus CPPC(D)

at the nodes of CTs obtained from CPPC(D)-proofs. Therefore, all the queries asked to the user during a declarative debugging session will be about the validity of c-facts in the intended model of the program, which is itself represented as a set of c-facts. We also agree that the premises Gσ ⇐ Π in rule EX (resp. Δ ⇐ Π in rule DFP ) must be understood as a shorthand for several premises α ⇐ Π, one for each atomic ϕ in Gσ (resp. Δ). Moreover, rule PF depends on the side condition SolD(Π) ⊆ SolD(ptn → t) which is true iff pD tnη → tη holds for all η ∈ SolD(Π). Some other inference rules in Fig. 1 have similar conditions.
Any CPPC(D)-derivation P ▶CP P C(D) G ⇐ S can be depicted in the form of a Positive Proof Tree over D (shortly, PPT (D)) with G ⇐ S at the root and c-statements at the internal nodes, and such that the statement at any node is inferred from the statements at its children using some CPPC(D) inference rule. In particular, the statement at the root must be inferred using rule EX, which is then applied nowherelse in the proof tree. Fig. 2. shows a PPT (R) representing a CPPC(R)-derivation which witnesses the computed answer from Example 2.1, which is wrong w.r.t. the intended model of the program. We say that a goal solving system is called CPPC(D)-sound iff for any computed answer S obtained for an initial goal G using program P there is some witnessing CPPC(D)-proof P ▶CP P C(D) G ⇐ S. The next result shows that CPPC(D)-sound goal solving systems exist:
Theorem 4.2 (Existence of CPPC(D)-sound goal solving systems) The go- al solving calculus CDNC(D) given in [22] is CPPC(D)-sound.
Proof. Straightforward adaptation of the soundness theorem for CDNC(D) pre- sented in [22].	 
In addition to CDNC(D), other formal goal solving calculi known for CFLP (D) are also CPPC(D)-sound. Moreover, it is also reasonable to assume CPPC(D)- soundness for implemented goal solving systems such as Curry [11] and T OY [15] whose computation model is based on constrained lazy narrowing. Moreover, any CPPC(D)-sound goal solving system is semantically sound in the sense of item 2 in Definition 3.3:
Theorem 4.3 (Semantic correctness of the CPPC(D) calculus) If G is an initial goal for P and S is a solved goal s.t. P ▶CP P C(D) G ⇐S then P |=D G ⇐S.
Proof. For each of the inference rules EX, ARf , and FAf , we prove that an arbitrary model I |=D P such that the premises of the rule are valid in I, also verifies that the conclusion of the rule is valid in I. Similar proofs for the other inference rules in CFLP (D) can be found in [14].

The rule EX is semantically correct. Let I be an arbitrary model of P such that I |=D Gσ ⇐ Π, i.e., SolD(Π) ⊆ SolI(Gσ). We prove that I |=D G ⇐
∃U. (σ Π), i.e., SolD(∃U. (σ Π)) ⊆ SolI(G). Let η ∈ SolD(∃U. (σ Π)). By the syntactic form of solved goals, η ∈ SolD(∃U. (Xn → tn ∧ sm → Ym  Π)) and η ∈ SolD(∃ U. (Xn = tn ∧ Ym = sm  Π)). By applying Definition 3.2, there































Fig. 2. A Positive Proof Tree in CPPC(R)

exists η' ∈ V al⊥(D) such that η' =\U η y η' ∈ SolD(Xn = tn ∧Ym = sm Π), and therefore, η' ∈ SolD(Xn = tn ∧ Ym = sm) (i.e., η' ∈ SolD(σ)) and η' ∈ SolD(Π). Since by induction hypothesis SolD(Π) ⊆ SolI(Gσ), it follows that η' ∈ SolI(Gσ).
Moreover, since η' ∈ SolD(σ), we obtain η' ∈ SolI(G). In consequence, there exists η' ∈ V al⊥(D) such that η' =\U η and η' ∈ SolI(G). Finally, using the condition of applicability fvar(G) ∩ U = ∅ associated to the rule EX, we can conclude that η ∈ SolI(G).
The rule ARf is semantically correct. Let I be an arbitrary model of P such that I |=D ei → ti ⇐ Π for each 1 ≤ i ≤ n (i.e., SolD(Π) ⊆ SolI(ei → ti) for each 1 ≤ i ≤ n), I |=D ftn → s ⇐ Π (i.e., SolD(Π) ⊆ SolD(ftn → s)) and I |=D sak → s ⇐ Π (i.e., SolD(Π) ⊆ SolI(sak → t)). We prove that I |=D fenak → t ⇐ Π, i.e., SolD(Π) ⊆ SolI(fenak → t). Let η ∈ SolD(Π). We have then η ∈ SolI(ei → ti) for each 1 ≤ i ≤ n, and by Definition 3.2, I ▶D eiη → tiη



for each 1 ≤ i ≤ n. Analogously, η ∈ SolI(ftn → s), by Definition 3.2, I ▶D
ftnη → sη, and by the Conservation Property (see [14] for details), (ftnη → sη)
∈ I. Analogously, η ∈ SolI(sak → t) and by Definition 3.2, I ▶D (sη)(akη) → tη. But then, by applying of the rule DFI (see [14] for details), we have that I ▶D f (enη)(akη) → tη. From Definition 3.2, we obtain finally η ∈ SolI(fenak → t).

The rule FAf is semantically correct. By definition of [P]⊥, there are (ft'n → r'
⇐ Δ') ∈P and θ ∈ Sub⊥(U ) such that (ft'n → r' ⇐ Δ')θ ≡ (ftn → r ⇐ Δ). Let I be an arbitrary model of P such that I |=D Δ ⇐ Π (i.e., SolD(Π) ⊆ SolI(Δ)) and I |=D r → s ⇐ Π (i.e., SolD(Π) ⊆ SolI(r → s)). We prove that I |=D ftn → s ⇐ Π, i.e., SolD(Π) ⊆ SolI(ftn → s). Let η ∈ SolD(Π). Then we have η
∈ SolI(Δ), and by Definition 3.2, I ▶D Δη, and also, I ▶D Δ'θη. Analogously, η
∈ SolI(r → s), and by Definition 3.2, I ▶D rη → sη, and also, I ▶D r'θη → sη. We have then (ft'n → r' ⇐ Δ') ∈ P, θη ∈ Sub⊥(U ) ground substitution and sη
∈ Pat⊥(U ) ground such that (ft'n → r' ⇐ Δ')θη ≡ (ftn → r ⇐ Δ)η is ground, I ▶D Δ'θη and I ▶D r'θη → sη. Since I is a model of P, by applying Definition 3.3, we obtain ((ft'n)θη → sη) ∈ I, i.e., ((ftn)η → sη) ∈ I, or also, (ftn → s)η
∈ I. Finally, by applying the Conservation Property (see [14] for details), it is
equivalent to I ▶D (ftn → s)η, and by Definition 3.2, we can conclude that η ∈
SolI(ftn → s).


Declarative diagnosis using proof trees
Now we are ready to present a declarative diagnosis method and to prove its correct- ness. Our results apply to any CPPC(D)-sound goal solving system. First we prove that the observation of an error symptom implies the existence of some error in the program:
Theorem 4.4 (Wrong answers are caused by erroneous program rules) Assume that a CPPC(D)-sound goal solving system computes S as answer for the initial goal G using program P. If S is wrong w.r.t. the user’s intended interpreta- tion I then some program rule belonging to P is incorrect w.r.t. I.
Proof. Because of CPPC(D)-soundness of the goal solving system, we know that
P ▶CP P C(D) G ⇐ S. Then, from Theorem 4.3 we obtain P |=D G ⇐ S, i.e., SolD(S)
⊆ SolJ (G) for each model J |=D P. Since S is wrong w.r.t. the user’s intended model I, it must be the case that SolD(S) /⊆ SolI(G) because of Definition 4.1. Therefore, we can conclude that the intended model I is not a model of P. Then, by Definition 3.3, some program rule belonging to P is not valid in I.	 
The previous theorem does not yet provide a practical method for finding an erroneous program rule. As explained in the Introduction, a declarative diagnosis method is expected to find the erroneous program rule by inspecting a CT . We propose to use abbreviated CPPC(D) proof trees as CTs. Since DFP is the only inference rule in the CPPC(D) calculus that depends on the program, abbreviated

proof trees will omit the inference steps related to all the other CPPC(D) rules. More precisely, given a PPT (D) T , its associated Abbreviated Positive Proof Tree over D (shortly, APPT (D)) AT is defined as follows:
The root of AT is the root of T .
The children of a node N in AT are the closest descendants of N in T corres- ponding to boxed c-facts introduced by DFP inference steps.
A node in an APPT (D) is called a buggy node iff the c-statement at the node is not valid in the intended interpretation I, while all the c-statements at the children nodes are valid in I. Our last theorem guarantees that declarative diagnosis with APPT (D)s used as CTs leads to the correct detection of program errors. A proof is given in the Appendix.
Theorem 4.5 (Declarative diagnosis of wrong answers) Under the assump- tions of Theorem 4.4, any APPT (D) witnessing P ▶CP P C(D) G ⇐ S (which must exist due to CPPC(D)-soundness of the goal solving system) has some buggy node. Moreover, each buggy node points to a program rule belonging to P which is incorrect in the user’s intended interpretation.
A Practical Debugging Tool for CFLP (R)
Fig. 3 shows the APPT (R) associated to the PPT (R) of Fig. 2. as displayed by DDT , the debugger tool included in the system T OY. Although in theory all the c-facts in a PPT (R) should include the same constraint Π, in practice the tool simplifies Π at each c-fact f tn → t ⇐ Π, keeping only those atomic constraints related to the variables occurring on f tn → t. It can be checked that such a simplification does not affect the intended meaning of c-facts.
Before starting a debugging session the user may inspect and simplify the tree using several facilities. For instance the user could mark any node corresponding
to the infix function && as trusted, indicating that the definition of && is surely not erroneous. This makes all the nodes corresponding to && automatically valid. Valid nodes can be removed from the tree safely (the set of buggy nodes doesn’t
change) by using a suitable menu option.
Next, the user can start a debugging session by selecting one of the two possible strategies included in DDT : the top-down or the divide and query strategy (see [6] for a comparative between both strategies in an older version of DDT which did not yet support constraints). After selecting the divide and query strategy, which usually leads to shorter sessions, DDT asks about the validity of the following node:


The intended program model corresponds to the intuitions explained in Section 2. Therefore, the question must be understood as: Is (X, Y ) a point in the intersection of the two rectangles for all possible values of X, Y satisfying X ≤ 35,X ≥ 20,Y ≤ 5





Fig. 3. The APPT (R) corresponding to the PPT (R) of Fig. 2.

is (X, Y )? The answer is no, because with these constraints Y can take any value less than 5 and some of these values would yield a pair (X, Y ) out of the intersection for every X. Therefore the user marks the cross meaning that the c-fact is non-valid. The next question is:


which is also reported as non-valid by the user. At this point a buggy node is found by the tool, pointing out to the incorrect program rule and ending the debugging session:


The current version of the debugger supports programs using the constraint do- main R, which provides arithmetic constraints over the real numbers as well as

strict equality and disequality constraints over data values of any type; see Exam- ple 3.1 and [14] for details. The tool is as an extension of older versions which did not yet support constraints over the domain R [6,3], and it is part of the public distribution of the functional logic programming system T OY, available at http://toy.sourceforge.net. The APPT (R) associated to a wrong answer is constructed by means of a suitable program transformation. The yielded tree is then displayed through a graphical debugging interface implemented in Java. More detailed explanations on the practical use of DDT can be found in [6,3].

Conclusions and Future Work
We have presented a logical and semantic framework for the declarative diagnosis of wrong computed answers in CFLP (D), a generic scheme for constraint functional logic programming over a given constraint domain D. The diagnosis technique re- presents the computation which has produced a wrong computed answer by means of an abridged proof tree whose inspection leads to the discovery of some erro- neous program rule responsible for the wrong answer. The logical correctness of the method can be formally proved thanks to the connection between abbreviated proof trees and program semantics.
A debugging tool called DDT which implements the proposed technique over the domain R of arithmetic constraints over the real numbers has been implemented as a non-trivial extension of previously existing debugging tools. DDT provides several practical facilities for reducing the number and the complexity of the questions that are presented to the user during a debugging session.
As future work, we plan several improvements of DDT , such as enabling the diagnosis of missing answers, supporting finite domain constraints, and providing new facilities for simplifying the presentation of queries to the user.

Acknowledgement
The author is thankful to Mario Rodr´ıguez Artalejo and Rafael Caballero for their collaboration, comments and contributions during the first stages of the develop- ment of this work and for the help in preparing the final version of this paper.

References
M. Alpuente, D. Ballis, F.J. Correa, and M. Falaschi. Correction of Functional Logic Programs. Proc. ESOP’03, Springer LNCS, 2003.
J. Boye, W. Drabent, and J. Ma-luszyn´ski. Declarative Diagnosis of Constraint Programs: an Assertion- based Approach. DiSCiPl Delieverable D.WP2.2.M1.1-2, 1997.
R. Caballero. A Declarative Debugger of Incorrect Answers for Constraint Functional-Logic Programs. Proc. WCFLP’05, ACM SIGPLAN, pp. 8–13, 2005.
R. Caballero, F.J. L´opez-Fraguas, and M. Rodr´ıguez-Artalejo. Theoretical Foundations for the Declarative Debugging of Lazy Functional Logic Programs. Proc. of the 5th International Symposium on Functional and Logic Programming (FLOPS’2001), Springer LNCS 2024, pp. 170–184, 2001.


R. Caballero and M. Rodr´ıguez-Artalejo. A Declarative Debugging System for Lazy Functional Logic Programs. ENTCS 64, 63 pages, 2002.
R. Caballero and M. Rodr´ıguez-Artalejo. DDT : A Declarative Debugging Tool for Functional Logic Languages. Proc. FLOPS’04, Springer LNCS 2998, pp. 70–84, 2004.
M. Comini, G. Levi, M.C. Meo, and G. Vitiello. Abstract diagnosis. Journal of Logic Programming 39 (1–3): 43–93, 1999.
P. Deransart, M. Hermenegildo, and J. Ma-luszyn´ski (Eds.) Analysis and Visualization tools for Constraint Programming: Constraint Debugging. Springer LNCS 1870, pp. 151–174, 2000.
G. Ferrand. Error Diagnosis in Logic Programming, an Adaptation of E.Y. Shapiro’s Method. The Journal of Logic Programming 4(3), 177-198, 1987.
G. Ferrand, W. Lesaint, and A. Tessier. Towards declarative diagnosis of constraint programs over finite domains. ArXiv Computer Science e-prints, 2003.
M. Hanus (ed.), Curry: an Integrated Functional Logic Language, Version 0.8, April 15, 2003.
http://www.informatik.uni-kiel.de/∼mh/curry/.
M. Hermenegildo, G. Puebla, F. Bueno, and P. L´opez-Garc´ıa. Abstract Verification and Debugging of Constraint Logic Programs. Proc. CSCLP’02, pp. 1–14, 2002.
J.W. Lloyd. Declarative Error Diagnosis. New Generation Computing 5(2), 133–154, 1987.
F.J. L´opez-Fraguas, M. Rodr´ıguez-Artalejo, and R. del Vado-V´ırseda. A New Generic Scheme for Functional Logic Programming with Constraints. Journal of Higher-Order and Symbolic Computation, volume 20, numbers 1-2, pages 73-122, June 2007.
F.J. L´opez-Fraguas and J. S´anchez-Hern´andez. T OY: A Multiparadigm Declarative System. Proc. RTA’99, Springer LNCS 1631, pp 244–247, 1999. System and documentation available at http://toy.sourceforge.net.
L. Naish. A Declarative Debugging Scheme. Journal of Functional and Logic Programming, 1997-3.
H. Nilsson. How to look busy while being as lazy as ever: the Implementation of a lazy functional debugger. Journal of Functional Programming, 11(6):629–671, 2001.
H. Nilsson and P. Fritzson. Algorithmic Debugging of Lazy Funcional Languages. Journal of Functional Programming, 4(3):337–370, 1994.
B. Pope and L. Naish. Practical aspects of declarative debugging in Haskell 98. Proc. PPDP’03, ACM
Press, pp. 230–240, 2003.
E.Y. Shapiro. Algorithmic Program Debugging. The MIT Press, Cambridge, 1982.
A. Tessier and G. Ferrand. Declarative Diagnosis in the CLP Scheme. In P. Deransart, M. Hermenegildo,
J. Ma-luszyn´ski (eds.), Analysis and Visualization Tools for Constraint Programming, Chapter 5, pp. 151–174. Springer LNCS 1870, 2000.
R. del Vado-V´ırseda. Declarative Constraint Programming with Definitional Trees. Proc. FroCoS’05, Springer LNAI 3717 pp. 184–199, 2005.
