Electronic Notes in Theoretical Computer Science 117 (2005) 285–314 
www.elsevier.com/locate/entcs


Real-Time Maude 2.1
Peter Csaba O¨ lveczkya,b and Jos´e Meseguera
a Department of Computer Science, University of Illinois at Urbana-Champaign
b Department of Informatics, University of Oslo

Abstract
Real-Time Maude 2.1 is an extension of Full Maude 2.1 supporting the formal specification and analysis of real-time and hybrid systems. Symbolic simulation, search and model checking analysis are supported for a wide range of systems. This paper gives an overview of the tool and documents its semantic foundations.
Keywords: Rewriting logic, real-time systems, object-oriented specification, formal analysis, simulation, model checking

Introduction
In earlier work we have investigated the suitability of rewriting logic as a semantic framework for real-time and hybrid systems [10,14]. The positive results obtained were then used to build a prototype Real-Time Maude tool [13,10] based on an earlier version of Maude. This prototype showed that real- time system specifications of considerable generality and practical interest, falling outside the scope of the known real-time decision procedures, could be fruitfully executed, and analyzed by search and model checking [10,12].
Recent theoretical advances in rewriting logic, particularly on the seman- tics of frozen arguments in operators [3], as well as new features in the Maude
2.1 implementation [5], especially its efficient built-in support for search and LTL model checking, and Full Maude 2.1, have provided a good basis for both simplifying the specification of real-time and hybrid systems, and for develop- ing a well-documented [11] and efficient tool, Real-Time Maude 2.1, that we present in this paper.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.015


Real-Time Maude specifications are executable formal specifications. Our tool offers various simulation, search, and model checking techniques which can uncover subtle mistakes in a specification. Timed rewriting can simu- late one of the many possible concurrent behaviors of the system. Timed search and time-bounded linear temporal logic model checking can analyze all behaviors—relative to a given time sampling strategy of dense time as ex- plained in Section 4.2.1—from a given initial state up to a certain duration. By restricting search and model checking to behaviors up to a certain dura- tion and with a given time sampling strategy, the set of reachable states is restricted to a finite set, which can be subjected to model checking. Search and model checking are “incomplete” for dense time, since there is no guar- antee that the chosen time sampling strategy covers all interesting behaviors. However, all the large systems we have modeled in Real-Time Maude so far have had a discrete time domain, and in this case search and model checking completely cover all behaviors from the initial state. For further analysis, the user can write his/her own specific analysis and verification strategies using Real-Time Maude’s reflective capabilities.
At present, designers of real-time systems face a dilemma between expres- siveness and high assurance. If they can specify some aspects of their system in a more restricted automaton-based formalism, then high assurance about system properties may be obtained by specialized model checking decision procedures, but this may be difficult or impossible for more complex system components. In that case, simulation offers greater modeling flexibility, but is typically quite weak in the kinds of formal analyses that can be performed. We view Real-Time Maude as a tool that provides a way out of this dilemma and complements both decision procedures and simulation tools. On the one hand, Real-Time Maude can be seen as complementing tools based on timed and linear hybrid automata, such as Uppaal [8], HyTech [7], and Kronos [15]. While the restrictive specification formalism of these tools ensures that inter- esting properties are decidable, such finite-control automata do not support well the specification of larger systems with different communication models and advanced object-oriented features. By contrast, Real-Time Maude em- phasizes ease and generality of specification, including support for distributed real-time object-based systems. The price to pay for increased expressiveness is that many system properties may no longer be decidable. However, this does not diminish either the need for analyzing such systems, or the possibility of using decision procedures when applicable. On the other hand, Real-Time Maude can also be seen as complementing traditional testbeds and simulation tools by providing a wide range of formal analysis techniques and a more ab- stract specification formalism in which different forms of communication can

be easily modeled and can be both simulated and formally analyzed.
A key goal of this work is to document the tool’s theoretical foundations, based on a simplified semantics of real-time rewrite theories (Section 3) and on a family of theory transformations that associate to a real-time rewrite theory and a command a corresponding ordinary rewrite theory (a Maude system module) and a Maude command with the intended semantics (Section 5). The paper gives also an overview of all the language features, commands, and analysis capabilities, many of which are new (Section 4) and illustrates its use in practice by means of two examples (Section 6). Conclusions and future directions are presented in Section 7.

Preliminaries on Equational and Rewriting Logic
Membership equational logic (MEL) [9] is a typed equational logic in which data are first classified by kinds and then further classified by sorts, with each kind k having an associated set Sk of sorts, so that a datum having a kind but not a sort is understood as an error or undeﬁned element. Given a MEL signature Σ, we write TΣ,k and TΣ(X )k to denote respectively the set of ground Σ-terms of kind k and of Σ-terms of kind k over variables in X , where X = {x1 : k1,... , xn : kn} is a set of kinded variables. Atomic formulae have either the form t = t ' (Σ-equation) or t : s (Σ-membership) with t , t ' ∈ TΣ(X )k and s ∈ Sk ; and Σ-sentences are universally quantified Horn clauses on such atomic formulae. A MEL theory is then a pair (Σ, E ) with E a set of Σ-sentences. Each such theory has an initial algebra TΣ/E whose elements are equivalence classes of ground terms modulo provable equality.
In the general version of rewrite theories over MEL theories defined in [3], a rewrite theory is a tuple R = (Σ, E , ϕ, R) consisting of: (i) a MEL theory (Σ, E ); (ii) a function ϕ:Σ → ℘f(N) assigning to each function symbol f : k1 ··· kn → k in Σ a set ϕ(f ) ⊆ {1,... , n} of frozen argument positions; (iii) a set R of (universally quantified) labeled conditional rewrite rules r having the general form

(∀X ) r : t −→ t ' if 

i ∈I
pi = qi ∧ 

j ∈J
wj : sj ∧ 

l ∈L
tl −→ t '

where, for appropriate kinds k and kl in K , t , t ' ∈ TΣ(X )k and tl , t ' ∈ TΣ(X )kl
for l ∈ L.
The function ϕ specifies which arguments of a function symbol f can- not be rewritten, which are called frozen positions. Given a rewrite theory R = (Σ, E , ϕ, R), a sequent of R is a pair of (universally quantified) terms of the same kind t , t', denoted (∀X ) t −→ t ' with X = {x1 : k1,... , xn : kn} a set of kinded variables and t , t' ∈ TΣ(X )k for some k . We say that R en- tails the sequent (∀X ) t −→ t ', and write R ▶ (∀X ) t −→ t ', if the sequent


(∀X ) t −→ t ' can be obtained by means of the inference rules of reflexivity, transitivity, congruence, and nested replacement given in [3].
To any rewrite theory R = (Σ, E , ϕ, R) we can associate a Kripke structure K(R, k )LΠ in a natural way provided we: (i) specify a kind k in Σ so that the set of states is defined as TΣ/E,k , and (ii) define a set Π of (possibly parametric) atomic propositions on those states; such propositions can be defined equationally in a protecting extension (Σ ∪ Π, E ∪ D ) ⊇ (Σ, E ), and give rise to a labeling function LΠ on the set of states TΣ/E,k in the obvious way. The transition relation of K(R, k )LΠ is the one-step rewriting relation of R, to which a self-loop is added for each deadlocked state. The semantics of linear-time temporal logic (LTL) formulas is defined for Kripke structures in the well-know way (e.g., [4,5]). In particular, for any LTL formula ψ on the atomic propositions Π and an initial state [t ], we have a satisfaction relation K(R, k )LΠ , [t ] |= ψ which can be model checked, provided the number of states reachable from [t ] is finite. Maude 2.1 [5] provides an explicit-state LTL model checker precisely for this purpose.

Real-Time Rewrite Theories Revisited
In [14] we proposed to specify real-time and hybrid systems in rewriting logic as real-time rewrite theories, defined an extension of the basic model to include the possibility of defining eager and lazy rewrite rules, and suggested two different ways of modeling object-oriented real-time systems.
This section first recalls the definition of real-time rewrite theories. We then explain why the generalization of rewriting logic [3] has made the parti- tion into eager and lazy rules unnecessary, and how object-oriented real-time systems can now be specified in a more elegant way than before.
Real-Time Rewrite Theories
A real-time rewrite theory is a rewrite theory where some rules, called tick rules, model time elapse in a system, while “ordinary” rewrite rules model instantaneous change.
Definition 3.1 A real-time rewrite theory Rφ,τ is a tuple (R, φ,τ), where
R = (Σ, E , ϕ, R) is a (generalized) rewrite theory, such that
φ is an equational theory morphism φ : TIME → (Σ, E ) from the theory TIME [14] which defines time abstractly as an ordered commutative monoid (Time, 0, +, <) with additional operators such as −. (“monus”) and ≤;
(Σ, E ) contains a sort System (denoting the state of the system), and a specific sort GlobalSystem with no subsorts and supersorts and with only


one operator { } : System → GlobalSystem which satisfies no non-trivial equations; furthermore, the sort GlobalSystem does not appear in the arity of any function symbol in Σ;
τ is an assignment of a term τl of sort φ(Time) to every rewrite rule
l : {t } −→ {t '} if cond involving terms of sort GlobalSystem 1 ; if τl /= φ(0) we call the rule a tick rule and write

r : {t } −→
{t '} if cond .

The global state of the system should have the form {u}, in which case the form of the tick rules ensures that time advances uniformly in all parts of the system. The total time elapse τ(α) of a rewrite α : {t } −→ {t'} of sort GlobalSystem is the sum of the times elapsed in each tick rule application [14].
r
We write Rφ,τ ▶ {t } −→ {t '} if there is proof α : {t } −→ {t '} in R	with
τ(α)= r . Furthermore, we write Timeφ, 0φ, ..., for φ(Time), φ(0), etc.

Eager and Lazy Rules Revisited
The motivation behind having eager and lazy rewrite rules was to model urgency by letting the application of eager rules take precedence over the application of lazy tick rules [14]. This feature was supported in Real-Time Maude 1. The ability to define frozen operators in rewriting logic [3] means that it is no longer necessary to explicitly define eager and lazy rules. Instead, one may define a frozen operator
eagerEnabled : s → [Bool] [frozen (1)]
for the sorts s which can be rewritten, introduce an equation
eagerEnabled (t )= true if cond
for each “eager” rule t −→ t ' if cond , and add an equation
eagerEnabled (f (x1,... , xn )) = true if eagerEnabled (xi)= true
for each operator f and each i which is not a frozen position in f . A “lazy” tick rule should now have the form

l : {t } −→
{t '} if cond ∧ eagerEnabled ({t }) /= true.

This technique should make unnecessary any explicit support for eager and lazy rules at the system definition level to model urgency. In addition, the lazy/eager feature has not been needed in any Real-Time Maude application we have developed so far. Real-Time Maude 2.1 therefore does not provide explicit support for defining eager and lazy rules.

1 All rules involving terms of sort GlobalSystem are assumed to have different labels.

Object-Oriented Real-Time Systems Revisited
Maude’s object model can be extended to the real-time setting by just adding a subsort declaration Configuration ≤ System, for Configuration a sort whose elements are multisets of messages and objects. In [14] we suggested some specification techniques for the case where an unbounded number of ob- jects could be affected by the elapse of time and/or could affect the maximum time elapse in a tick step. We proposed to use functions δ : Configuration Timeφ → Configuration and mte : Configuration → Timeφ to define, re- spectively, the effect of time advance on a configuration, and the maximum time elapse possible from a configuration, and to let these functions distribute over the elements in a configuration. The function δ could easily lead to “ill-timed” rewrites where the configuration being rewritten is (a subterm of) an argument of δ, and is therefore an “aged” state, and the function mte : Configuration → Timeφ could easily introduce nontrivial rewrites in the time domain. We suggested to rewrite only terms of sort GlobalSystem, or to add “tokens” to avoid these problems. A more elegant solution in the general version of rewriting logic is to declare δ and mte to be frozen opera- tors. Instantaneous rewrite rules can then be defined exactly as in untimed rewriting logic. See [11] and Section 6.1 for examples.

Specification and Execution in Real-Time Maude 2.1
This section shows how to specify real-time rewrite theories in Real-Time Maude 2.1 as timed modules, and how to execute such modules in the tool. Specification in Real-Time Maude 2.1 is fairly similar to specification in Real- Time Maude 1 (except for the changes mentioned in Section 3). However, the set of execution commands is entirely different in the new version—both because of the new capabilities of the Maude 2 tool, and also to provide user- friendly syntax and high performance.

Speciﬁcation in Real-Time Maude 2.1
Real-Time Maude extends Full Maude [5] to support the specification of real- time rewrite theories as timed modules and object-oriented timed modules. Such modules are entered at the user level by enclosing the module body between the keywords tmod and endtm, and between tomod and endtom, re- spectively. To state nonexecutable properties, Real-Time Maude allows the user to specify real-time extensions of abstract Full Maude theories. Since Real-Time Maude extends Full Maude, we can also define Full Maude mod- ules in the tool. All the usual operations on modules provided by Full Maude

are supported in Real-Time Maude.
Specifying the Time Domain
The equational theory morphism φ in a real-time rewrite theory Rφ,τ is not given explicitly at the specification level. Instead, by default, any timed mod- ule automatically imports the following functional module TIME:
fmod TIME is
sorts Time NzTime . subsort NzTime < Time . op zero : -> Time .
op _plus_ : Time Time -> Time [assoc comm prec 33 gather (E e)] . op _monus_ : Time Time -> Time [prec 33 gather (E e)] .
ops _le_ _lt_ _ge_ _gt_ : Time Time -> Bool [prec 37] . eq zero plus R:Time = R:Time .
eq R:Time le R’:Time = (R:Time lt R’:Time) or (R:Time == R’:Time) . eq R:Time ge R’:Time = R’:Time le R:Time .
eq R:Time gt R’:Time = R’:Time lt R:Time . endfm
The morphism φ implicitly maps Time to Time,0 to zero, + to _plus_,
≤ to _le_, etc. Even though Real-Time Maude assumes a fixed syntax for time operations, the tool does not build a fixed model of time. In fact, the user has complete freedom to specify the datatype of time values—which can be either discrete or dense and need not be linear—by specifying the data elements of sort Time, and by giving equations interpreting the constant zero and the operators _plus_, _monus_, and _lt_, so that the axioms of the theory TIME [14] are satisfied. The predefined Real-Time Maude mod- ule NAT-TIME-DOMAIN defines the time domain to be the natural numbers as follows:
fmod NAT-TIME-DOMAIN is including LTIME . protecting NAT . subsort Nat < Time . subsort NzNat < NzTime .
vars N N’ : Nat . eq zero = 0 .
eq N plus N’ = N + N’ .
eq N monus N’ = if N > N’ then sd(N, N’) else 0 fi . eq N lt N’ = N < N’ .
endfm
To have dense time, the user can import the predefined module POSRAT-TIME- DOMAIN, which defines the nonnegative rationals to be the time domain. The set of predefined modules in Real-Time Maude also includes a module LTIME, which assumes a linear time domain and defines the operators max and min on the time domain, and the modules TIME-INF, LTIME-INF, NAT-TIME-DOMAIN- WITH-INF, and POSRAT-TIME-DOMAIN-WITH-INF which extend the respective time domains with an “infinity” value INF of a supersort TimeInf of Time.
Tick Rules
A timed module automatically imports the module TIMED-PRELUDE which contains the declarations


sorts System GlobalSystem .
op {_} : System -> GlobalSystem [ctor] .
A tick rule l : {t } −→ {t '} if cond is written with syntax
crl [l ] : {t } => {t'} in time τl if cond .
and with similar syntax for unconditional rules.
We do not require time to advance beyond any time bound, or the speci- fication to be “non-Zeno.” However, it seems sensible to require that if time can advance by r plus r ' time units from a state {t } in one application of a tick rule, then it should also be possible to advance time by r time units from the same state using the same tick rule. Tick rules should (in particular for dense time) typically have one of the forms
crl [l ] : {t } => {t ′} in time x if cond /\ x le u /\ cond ′ [nonexec] .	 (†), crl [l ] : {t } => {t ′} in time x if cond /\ x lt u /\ cond ′ [nonexec] .	 (‡), crl [l ] : {t } => {t ′} in time x if cond [nonexec] .	(∗), or
rl [l ] : {t } => {t ′} in time x [nonexec] .	(§),
where x is a variable of sort Time (or of a subsort of Time) which does not occur in {t } and which is not initialized in the condition. The term u denotes the maximum amount by which time can advance in one tick step. Each variable in u should either occur in t or be instantiated in cond . The (possibly empty) conditions cond and cond ' should not further constrain x (except possibly by adding the condition x =/= zero). Tick rules in which the time increment is not given by the match are called time-nondeterministic. All other tick rules are called time-deterministic and can be used e.g. in discrete time domains.
Real-Time Maude assumes that tick rule applications in which time ad- vances by zero do not change the state of the system. A tick rule is admissible if its zero-time applications do not change the state, and it is either a time- deterministic tick rule or a time-nondeterministic tick rule of any of the above forms—possibly with le and lt replaced by <= and < (in which case le and
<=, and lt and <, should be equivalent on the time domain). The execution of admissible tick rules is supported by the Real-Time Maude tool.




Deﬁning Initial States
For the purpose of conveniently defining initial states, Real-Time Maude al- lows the user to introduce operators of sort GlobalSystem. Each ground term of sort GlobalSystem must reduce to a term of the form {t } using the equa- tions in the specification.

Timed Object-Oriented Modules
Timed object-oriented modules extend both object-oriented and timed mod- ules to provide support for object-oriented real-time systems. In contrast to untimed object-oriented systems, functions such as δ and mte, and the tick rules, will observe the global configuration. It is therefore useful to have a richer sort structure for configurations. Timed object-oriented modules in- clude subsorts for nonempty configurations, configurations without messages, without objects, etc. The subsort declaration Configuration < System is automatically added to timed object-oriented modules. Section 6.1 gives an example of a timed object-oriented module.

Formal Analysis in Real-Time Maude 2.1
Our tool translates a timed module into an untimed module which can be exe- cuted in Maude. However, the following reasons indicate that it is useful to go beyond Maude’s standard rewriting, search, and model checking capabilities to execute and analyze timed modules:
Tick rules are typically time-nondeterministic and cannot be executed di- rectly in Maude.
It is more natural to measure and control the rewriting by the total duration of a computation than by the number of rewrites performed.
Search and temporal logic properties often involve the duration of a compu- tation (is a certain state always reached within time r ? is there a potential deadlock in the time interval [r , r ')?).
One natural way of reducing the reachable state space from an infinite set to a finite set for model checking purposes is to consider only all behaviors up to a certain total duration r .
In Section 4.2.1 we describe the tool’s time sampling strategies which guide the application of time-nondeterministic tick rules. Section 4.2.2 gives an overview of the analysis commands available in Real-Time Maude. These commands are timed versions of Maude’s rewriting, search, and model check- ing commands. To achieve high performance, our tool executes Real-Time Maude commands by transforming a timed module into an ordinary Maude module which is executed in Maude as explained in Section 5.

Time Sampling Strategies
The issue of treating admissible time-nondeterministic tick rules is closely related to the treatment of dense time. The decidable timed automaton for- malism “discretizes” dense time by defining “clock regions,” so that all states


in the same clock region are bisimilar and satisfy the same properties [1]. The clock region construction is possible due to the restrictions in the timed au- tomaton formalism, but in general cannot be employed in the more complex systems expressible in Real-Time Maude. Our tool instead deals with admis- sible time-nondeterministic tick rules by offering a choice of different “time sampling” strategies, so that instead of covering the whole time domain, only some moments are visited.
The Real-Time Maude command
(set tick def r .)
for r a ground term of sort Time in the “current” module, sets the time sampling strategy to the default mode, which means that each application of a time-nondeterministic tick rule will try to advance time by r time units. (If the tick rule has the form (†), then the time advance is the minimum of u and r .) The command (set tick max .) can be used when all time- nondeterministic tick rules have the form (†) to set a time sampling strategy which advances time by the largest possible amount, namely u. The command (set tick max def r .) sets the time sampling strategy to advance time by the maximum possible time elapse u in rules of the form (†) (unless u equals INF), and tries to advance time by r time units in tick rules having other forms. The time sampling strategy stays unchanged until another strategy is selected, and is initially in deterministic mode, in which case it is assumed that all tick rules are time-deterministic.
All applications of time-nondeterministic tick rules—be it for rewriting, search, or model checking—are performed using the current time sampling strategy. This means that some behaviors in the system, namely those ob- tained by applying the tick rules differently, are not analyzed. The results of Real-Time Maude analysis should be understood in this light. We are cur- rently working on identifying classes of real-time systems and system proper- ties for which a given time sampling strategy actually preserves the relevant system properties and therefore provides a complete method of analysis.

Real-Time Maude Analysis
The timed rewrite command
(trew [n] in mod : t0 in time <= r .)
simulates (at most n rewrite steps of) one behavior of the system, specified by the timed module mod , from initial state t0 (of sort GlobalSystem) up to a total duration less than or equal to the Time value r . The time bound can also have the forms in time < r and with no time limit. The timed fair rewrite (tfrew) command applies the rules in a position-fair and rule-fair way.

The ’[n]’ and ’in mod :’ parts of the command are optional.
The timed search command can be used to analyze not just one behavior, but to analyze all behaviors from a given initial state, relative to the chosen time sampling strategy. This command extends Maude’s search command to search for states which match a search pattern and which are reachable in a given time interval. The syntax variations of the timed search command are:
(tsearch t0 arrow pattern with no time limit .)

(tsearch t0 arrow pattern in time ∼ r .)	'
(tsearch t0 arrow pattern in time-interval between ∼
''  '
r and ∼  r .)

where t0 is a ground term of sort GlobalSystem, pattern is either t or has the form t such that cond , for a ground irreducible term t of sort GlobalSystem and a semantic condition cond on the variables occurring in t , ∼ is either <,
<=, >, or >=, ∼' is either >= or >, ∼'' is either <= or <, and r and r ' are ground terms of sort Time. The arrow is the same as in Maude, where =>1,
=>*, and =>+ search for states reachable from t0 in, respectively, one, zero or more, and one or more rewrite steps. The arrow =>! is used to search for “deadlocked” states, i.e., states which cannot be further rewritten. The timed search command can be parameterized by the number of solutions sought and/or by the module to analyze.
Real-Time Maude also has commands which search for the earliest (syntax (find earliest t0 =>* pattern .)) and latest (syntax (find latest t0 =>* pattern timeBound .)) time a desired state can be reached.
We can also analyze all behaviors, relative to the chosen time sampling strategy, of a system from a given initial state using Real-Time Maude’s time-bounded explicit-state linear temporal logic model checker. Such model checking extends Maude’s high performance model checker [6] by restrict- ing the duration of the behaviors. Temporal formulas are formed exactly as in Maude [6], that is, as terms of sort Formula constructed by user-defined atomic propositions and operators such as /\ (conjunction), \/ (disjunction),
~ (negation), [] (“always”), <> (“eventually”), U (“until”), => (“always im- plies”), etc. Atomic propositions, possibly parameterized, are terms of sort Prop and their semantics is defined by stating for which states a property holds. Propositions may be clocked, in that they also take the elapsed time into account. A module defining the propositions should import the prede- fined module TIMED-MODEL-CHECKER and the timed module to be analyzed. A formula represents an untimed linear temporal logic formula; it is not a formula in metric temporal logic or some other real-time temporal logic [2].
The syntax of the time-bounded model checking command is
(mc t0 |=t formula in time <= r .)


or with time bounds of the form < r or with no time limit. The model checker in general cannot prove a formula correct in the presence of time- nondeterministic tick rules, since it then only analyzes a subset of all possible behaviors. If the tool finds a counterexample, it is a valid counterexample which proves that the formula does not hold. Time-bounded model checking is guaranteed to terminate for discrete time domains when the instantaneous rules terminate.
The set of states reachable from an initial state in a timed module may well be finite, in which case search and model checking should terminate. However, the internal representation of a timed module described in Section 5 adds a clock component to each state, which makes the reachable “clocked state” space infinite, unless the specification is terminating. Real-Time Maude therefore provides untimed search (syntax (utsearch t0 arrow pattern .)) and untimed model checking (syntax (mc t0|=u formula .)) where the internal representation used for the execution does not add a clock, and therefore preserves the finiteness of the reachable state space.
Real-Time Maude also provides commands for checking “until” proper- ties (syntax (check t0 |= pattern1 until pattern2 timeBound .)) and “un- til/stable” properties (syntax (check t0 |= pattern1 untilStable pattern2 timeBound .)). While the properties that can be expressed by these com- mands are a restricted (but often useful) subset of those expressible in tem- poral logic, the check commands are implemented using breadth-first search techniques, and can therefore sometimes decide properties—without restrict- ing the duration of the behaviors—for which temporal logic model checking does not terminate.
Finally, the user can define his/her own specific analysis and verification strategies using Real-Time Maude’s reflective capabilities to further analyze a timed module. The predefined module TIMED-META-LEVEL extends Maude’s META-LEVEL module with the functionality needed to execute timed modules and can be used for these purposes.


Semantics of Real-Time Maude’s Analysis Commands
Real-Time Maude is designed to take maximum advantage of the high per- formance of the Maude engine. Most Real-Time Maude analysis commands are therefore executed by first transforming the current timed module into a Maude module, followed by the execution of a corresponding Maude command (at the Maude meta-level ). The actual transformation of a timed module de- pends on the Real-Time Maude command to execute. This section defines the

semantics of Real-Time Maude’s analysis commands in two ways by providing:
an “abstract” semantics, which specifies requirements for each command; and
a concrete “Maude semantics,” which defines the semantics of a Real-Time Maude command as the theory transformation and Maude command used to execute it.
In what follows we show how the concrete semantics satisfies the abstract one. Section 5.1 describes the “default” transformation of a real-time rewrite theory into a rewrite theory. Section 5.2 gives the semantics of the time sampling strategies. Sections 5.4 to 5.6 present the semantics of, respectively, the timed rewrite commands, timed search and related commands, and time- bounded linear temporal logic model checking. Section 5.7 treats Real-Time
Maude’s untimed analysis commands.


The Clocked Transformation

Definition 5.1 The clocked transformation, which maps a real-time rewrite theory Yφ,τ with Y = (Σ, E , ϕ, R) to an ordinary rewrite theory (Yφ,τ )C = (ΣC , EC , ϕC , RC ), adds the declarations
sorts ClockedSystem .	subsort GlobalSystem < ClockedSystem . op _in time_ : GlobalSystem Timeφ -> ClockedSystem [ctor] . eq (CLS:ClockedSystem in time R:Timeφ) in time R’:Timeφ =
CLS:ClockedSystem in time (R:Timeφ +φ R’:Timeφ) .
to (Σ, E , ϕ), and defines RC to be the union of the instantaneous rules in R
and a rule
l : {t } —→ {t '} in time τl if cond
for each corresponding tick rule in R.

This clocked transformation adds a clock component to each state and resembles the transformation ( )C described in [14], but is simpler, since it is essentially the identity. It is worth noticing that the reachable state space from a state {t } in (Yφ,τ )C is normally infinite, even when the reachable state space from {t } is finite in Yφ,τ .
Fact 5.2 For all terms t, t ' of sort GlobalSystem and all terms r /= 0φ, r ' of

sort Timeφ in Yφ,τ ,
Y	▶ t —r→ t ' ⇐⇒ (Y	)C ▶ t —→ t ' in time r
⇐⇒ (Yφ,τ )C ▶ t in time r ' —→ t ' in time r ' +φ r and

Yφ,τ
0φ
▶ t —→ t
⇐⇒ (Yφ,τ )C
▶ t in time r '
—→ t '
in time r '.

In addition, Yφ,τ

0φ
▶ t —→
t ' ⇐⇒ (Yφ,τ
)C ▶ t —→ t ' holds when Yφ,τ
con-

tains only admissible tick rules. Moreover, these equivalences hold for n-step rewrites for all n.
In Real-Time Maude, this transformation is performed by importing the module TIMED-PRELUDE, which contains the above declarations (with Time for Timeφ, etc.), and by leaving the rest of the specification unchanged. Real- Time Maude internally stores a timed module by its clocked representation. All Full Maude commands extend to Real-Time Maude and execute this clocked representation of the current timed module. Fact 5.2 justifies this choice of execution.
Time Sampling Strategies
Definition 5.3 The set tss(Yφ,τ ) of time sampling strategies associated with the real-time rewrite theory Yφ,τ with Y = (Σ, E , ϕ, R) is defined by
tss(Yφ,τ )= {def (r ) | r ∈ TΣ,Timeφ }∪ {max }
∪ {maxDef (r ) | r ∈ TΣ,Timeφ }∪ {det}.
In Real-Time Maude, these time sampling strategies are “set” with the respective commands (set tick def r .), (set tick max.), (set tick max def r .), and (set tick det .).
Definition 5.4 For each s ∈ tss(Yφ,τ ), the mapping which takes the real-

time rewrite theory Yφ,τ to the real-time rewrite theory Ys
, in which the

admissible time-nondeterministic tick rules are applied according to the time sampling strategy s, is defined as follows:

Ydef (r) equals Y
, with the admissible time-nondeterministic tick rules of

φ,τ
φ,τ

the forms (†), (‡), (∗), and (§) in Section 4.1.2, replaced by, respectively,
the following tick rules 2 :
· l : {t } —x→ {t '} if cond ∧ x := if (u ≤ r ) then u else r fi
∧ x ≤φ u ∧ cond '

2 The Real-Time Maude tool assumes the modified tick rules to be executable, and therefore “removes” their nonexec attributes.



l : {t } —x→ {t '} if x := r ∧ cond ∧ x <
l : {t } —x→ {t '} if x := r ∧ cond
l : {t } —x→ {t '} if x := r
u ∧ cond '

If the time domain is linear, so that φ can be extended to the theory
LTIME [14], the first of the above rules can be given in the simpler form
l : {t } —x→ {t '} if cond ∧ x := min (u, r ) ∧ cond '.

max
φ,τ
is Yφ,τ with each rule of the form (†) replaced by the rule
l : {t } —x→ {t '} if cond ∧ x := u ∧ cond '

(and with the other tick rules left unchanged). Notice that the condition does not hold if u evaluates to the infinity value.
YmaxDef (r) equals Ydef (r) with each (†)-rule replaced by the rule

φ,τ
φ,τ

l : {t } —x→ {t '} if cond ∧ x := if u : Time then u else r fi
∧ x ≤φ u ∧ cond '.

Ydet = Yφ,τ .

Real-Time Maude implements these transformations, with le for ≤φ, etc. We do not assume that the time domain is linear. By the current time sam- pling strategy we will mean the time sampling strategy defined by the last set tick command given, and we assume that any time value used in the last set tick command is a time value in the “current” timed module.

Fact 5.5 For each s ∈ tss(Yφ,τ
s
φ,τ
▶ t —r→ t ' implies Y
▶ t —r→ t ' for

all terms t, t ' of sort GlobalSystem, and all ground terms r of sort Timeφ.
Furthermore, this property holds for all n-step rewrites.

Tick Rules with zero Time Advance
Real-Time Maude does not apply a tick rule when time would advance by an amount equal to zero. This is a pragmatic choice based on the fact that advancing time by zero using admissible tick rules does not change the state,

but leads to unnecessary looping during executions. We denote by Ynz
the

real-time rewrite theory obtained from Yφ,τ by adding the condition τl /= 0φ

to each tick rule. We write Ys,nz
for (Ys
)nz .

Fact 5.6 Yφ,τ
▶ t —r→ t ' implies Ynz
▶ t —r→ t '. The implication extends to

rewrites of length n for any n, and is an equivalence for speciﬁcations Yφ,τ
with only admissible tick rules.

Timed Rewriting
The timed rewrite command
(trew [n] in Yφ,τ : t with no time limit .),
for t a term of sort GlobalSystem, returns a term t ' such that
Yφ,τ ▶ t —→ t ' is a rewrite in at most n steps, and

t ' cannot be further rewritten in Ys,nz
(for s the current time sampling

strategy) unless t —→ t ' is a rewrite in n steps.
This command is executed at the Maude meta-level by (a call to a built- in function equivalent to) executing the Maude command rewrite [n] in (Ys,nz )C : t ., for s the current time sampling strategy. The correctness of executing the timed command in this way follows from the fact that if the result is a term t ' in time r , then (Ys,nz )C ▶ t —→ t ' in time r , and we
have (Ys,nz )C ▶ t —→ t ' in time r =⇒ Ys,nz ▶ t —r→ t ' =⇒ Y	▶ t —r→ t '.

φ,τ
φ,τ
φ,τ

All implications preserve the number of rewrite steps. Finally, it also follows

from Fact 5.2 that t ' cannot be rewritten further in Ys,nz
if t ' in time r

cannot be rewritten in (Ys,nz )C . The correctness argument is analogous if the result of the rewrite command is a GlobalSystem term t '.
Let ∼ stand for either <= or <, and let <=φ and <φ stand for ≤φ and <φ.
The time-bounded rewrite command
(trew [n] in Yφ,τ : t in time ∼ r .),
again for t a term of sort GlobalSystem, returns a term t ' such that
r	'	'
Yφ,τ ▶ t —→ t , for r ∼φ r , is a rewrite in at most n steps, and

'
either t —→ t '
is an n-step rewrite, or there is no t ''
such that Ys,nz ▶

''
t —→ t ''
for r '
+φ r ''
∼φ r .

To execute time-bounded rewrite commands we use a different transfor- mation of a real-time rewrite theory which ensures that the clocks associated to the states never go beyond the time limit.
Definition 5.7 Let Yφ,τ be a real-time rewrite theory with Y = (Σ, E , ϕ, R), and let r ∈ TΣ,Timeφ . The mapping which takes Yφ,τ to the rewrite theory (Yφ,τ )≤r = (ΣB , EB , ϕB , R≤r ) is defined as follows:
ΣB = ΣC ∪{ [ ] : ClockedSystem → ClockedSystem } 3 ,
EB = EC ,

3 This operator is called global in the current implementation of the tool.

ϕB extends ϕ such that ϕB ([ ])= ∅, and
R≤r is the union of the instantaneous rules in Yφ,τ and a rule
l : [{t } in time y ] —→ [{t '} in time τl +φ y ] if cond ∧ τl +φ y ≤φ r
for each tick rule in Yφ,τ , where y is a variable of sort Timeφ which does not occur in the original tick rule.

Fact 5.8 • For all r ', r ''
with r

''+φr '

r '
≤φ r, we have that Yφ,τ ▶ t —→ t '
if and

only if (Yφ,τ )≤r ▶ [t in time r ''] —→ [t ' in time r '' +φ r ']. In addition, the number of rewrite steps are the same in both sides of the equivalence.
(Yφ,τ )≤r ▶ [t in time r '] —→ t '' and r ' ≤φ r implies that t '' is a term of the form [t ' in time r ''] with r '' ≤φ r. That is, it is not possible to rewrite beyond the time limit.
Real-Time Maude executes the time-bounded rewrite command
(trew [n] in Yφ,τ : t in time <= r .)
by executing the command rewrite [n] in (Ys,nz )≤r : [t in time 0φ] .
in Maude.
For the correctness argument, it follows from Fact 5.8 that the result is
[t ' in time r '] for some r ' ≤φ r since 0φ ≤φ r . By the first part of that
'	'	s,nz	r	'

fact, it follows that (since r
= 0φ +φ r ) Yφ,τ	▶ t —→ t , which implies

r	'
Yφ,τ ▶ t —→ t . Finally, it also follows from Fact 5.8 that there is no nontrivial

rewrite t
''
—→ t ''
with r '
+φ r ''
≤φ r in Ys,nz if [t '
in time r '] cannot be

further rewritten in (Ys,nz )≤r .
The execution of a timed rewrite command with a time bound of the form
< r is entirely analogous, with each occurrence of the symbol ≤ replaced by the symbol <.

Timed Search
The timed search command
(tsearch [n] in Yφ,τ : t0 =>* t such that cond
in time-interval between ∼ r and ∼' r ' .)
should return at most n substitutions σ satisfying cond such that Yφ,τ ▶

r ''	''
''	'	'

t0 —→ σ(t ) for r
∼φ r and r
∼φ r . It is executed as the Maude command

search [n] in (Ys,nz )∼'r '  :
[t0 in time 0φ] =>* [t in time TIME-ELAPSED] such that cond /\ TIME-ELAPSED ∼φ r .


for s the current time sampling strategy, and TIME-ELAPSED a variable of sort Timeφ which does not occur in t (otherwise a variable TIME-ELAPSED#1 is used).

For correctness, if σ is a solution, then (Ys,nz )∼'r ' ▶ [t  in time 0
] —→

φ,τ	0	φ

[σ(t ) in time σ(TIME-ELAPSED)]. By Fact 5.8, σ(TIME-ELAPSED) ∼'
r and

Ys,nz
▶ t σ(TIME-ELAPSED)
σ(TIME-ELAPSED)

φ,τ	0
—→	σ(t ), and therefore Yφ,τ ▶ t0
—→	σ(t ).

Finally, the such that condition implies that σ(TIME-ELAPSED) ∼φ r .
Real-Time Maude also allows the term t in the search pattern to have the form t ' in time t '' which is useful for searching for states matching patterns such as t (x ) in time x . Such patterns are treated by replacing TIME-ELAPSED with t ''.
Since all the facts used in the argumentation preserve the number of rewrite steps, the same translation can be used with the arrows =>1 and =>+ for =>*.
It is worth remarking that
the search will return (at most) n substitutions on the domain vars(t ) ∪
{TIME-ELAPSED}, which do not necessarily correspond to n distinct substi- tutions when restricted to vars(t );
the search will terminate if the time domain is discrete (or the time sampling strategy s makes Ys,nz “non-Zeno”), and the instantaneous rules terminate;
r ''
solutions σ with Yφ,τ ▶ t0 —→ σ(t ) can be missed because it may be that

s,nz
r ''

Yφ,τ / ▶ t0 —→ σ(t ).
The time-bounded search command for deadlocks
(tsearch [n] in Yφ,τ : t0 =>! t	such that cond
in time-interval between ∼ r and ∼' r ' .)








r ''

searches for substitutions σ satisfying cond such that Yφ,τ ▶ t0 —→ σ(t ) for
r '' ∼φ r and r '' ∼' r ', and such that σ(t ) cannot be further rewritten in Ys,nz .
The translation (Ys,nz )∼'r ' cannot be used since it would give deadlocks at all states which cannot be further rewritten within the time bound.
The following translation is used instead for searching for deadlocks. It adds a self-loop whenever a tick rule could advance the total time elapse of a computation beyond the time limit.


Definition 5.9 Let Yφ,τ be a real-time rewrite theory with Y = (Σ, E , R), and let r ∈ TΣ,Timeφ . The mapping which takes Yφ,τ to the rewrite theory

(Yφ,τ
)≤cr = (ΣB , EB , ϕB , R≤cr ), where R≤cr is the union of the instantaneous

rules in Yφ,τ and a rule
l : [{t } in time y ] —→ if (τl +φ y ≤φ r ) then [{t '} in time τl +φ y ]
else [{t } in time y ] fi if cond
for each tick rule in Yφ,τ , where y is a variable of sort Timeφ which does not occur in the original tick rule.

The transformation (Yφ,τ
)<cr is defined in the same way.

c
Since (Yφ,τ )≤r modifies (Y
)≤r by adding trivial rewrites, most of Fact 5.8

also holds in (Yφ,τ )
≤cr
. Moreover, since the instantaneous rules are unchanged,

and since for each tick rule which can be applied in Yφ,τ , the corresponding

rule can be applied to a corresponding state in (Yφ,τ )
≤cr
, it follows that a term

can be rewritten in Yφ,τ
if and only if it can be rewritten in (Yφ,τ )
≤cr :

'
Fact 5.10 • For all r ', r '' with r '' +φ r ' ≤φ r it is the case that Yφ,τ ▶ t —→ t '

c
if and only if (Yφ,τ )≤r ▶ [t in time r ''] —→ [t ' in time r '' +
r ']. In

addition, the number of rewrite steps can be preserved by the translation.
(Y )≤cr ▶ [t in time r '] —→ t '' and r ' ≤ r implies that t '' is (equiva- lent to) a term of the form [t ' in time r ''] with r '' ≤φ r. That is, it is not possible to rewrite beyond the time limit.

r '
If Yφ,τ ▶ t —→ t '
is a one-step rewrite, and r ''
≤φ r and ¬(r ''
+φ r '
≤φ r ),

then there is a one-step “identity” rewrite (Yφ,τ
)≤cr ▶ [t in time r ''] —→

[t in time r ''].
The above timed search command for deadlocks is interpreted by the Maude command

search [n] in (Ys,nz
)∼d'r ' :

[t0 in time 0φ] =>! [t in time TIME-ELAPSED] such that cond /\ TIME-ELAPSED ∼φ r .
To see that each solution σ is really a deadlock in Ys,nz , assume that

s,nz
φ,τ
▶ σ(t ) —r→ t ' in one step. It follows from Fact 5.10 that, depending

on whether r '' +φ r ' ≤φ r , the term [σ(t ) in time r ''] rewrites either to

[t ' in time r '' +φ
r '] or to [σ(t ) in time r ''] in one step in (Ys,nz
)∼^'r ' .

It is worth noticing that a deadlock in Ys,nz does not necessarily correspond to a deadlock in Yφ,τ , and that a deadlock in Yφ,τ may not necessarily be reached in Ys,nz .
For search commands with simpler time bounds, a command (tsearch t0 arrow t such that cond in time ∼	r .) is equivalent to (tsearch t0 arrow t such that cond in time- interval between >= 0φ and ∼ r .)


for ∼ either <= or <. If ∼ is either >= or >, the above search command is in- terpreted by the Maude command
search [n] in (Ys,nz )C : t0 arrow t in time TIME-ELAPSED
such that cond /\ TIME-ELAPSED ∼φ r .
A timed search command with bound ’with no time limit’ is the same as the corresponding search command with time bound >= 0φ.

Time-Bounded Temporal Logic Model Checking
What is the meaning of the time-bounded liveness property “the clock value will always reach the value 24 within time 24” in the specification
(tmod CLOCK is protecting POSRAT-TIME-DOMAIN .
op clock : Time -> System [ctor] .	vars R R’ : Time .
rl [tick] : {clock(R)} => {clock(R + R’)} in time R’ . endtm)
Real-Time Maude does not assume that time 24 must be “visited” when model checking a property “within time 24.” Such an assumption would make the above property hold within time 24 but not within time 25, and an ordinary simulation would not necessarily reach the desired state, which is counterintuitive if we have proved that the desired state is always reached within time 24. Instead, time-bounded linear temporal logic formulas will be interpreted over all possible paths, “chopped off” at the time limit:
Definition 5.11 Given a real-time rewrite theory Yφ,τ , a term t0 of sort
GlobalSystem, and a ground term r of sort Timeφ, the set Paths(Yφ,τ )≤r is
the set of all infinite sequences
[t0 in time r0] —→ [t1 in time r1] —→ · · · —→ [ti in time ri ] —→ ··· 
of (Yφ,τ )C -states, with r0 = 0φ, such that either
r '
for all i , ri ≤φ r and Yφ,τ ▶ ti —→ ti+1 is a one-step sequential rewrite for
ri +φ r ' = ri+1, or
there exists a k such that

r '
either there is a one-step rewrite Yφ,τ ▶ tk —→ t '
r ' /≤φ r , or
there is no one-step rewrite from tk in Yτ,φ,
r '
with rk ≤φ r and rk +φ


'

and Yφ,τ ▶ ti —→ ti+1 is a one-step sequential rewrite with ri +φ r
for all i < k ; and rj = rk and tj = tk for all j > k .
We denote by π(i ) the i th element of path π.
= ri +1


That is, we add a self-loop for each deadlocked state reachable within time r , as well as for each state which could tick beyond time r in one step, even if it could also rewrite to something else within the time limit.
The temporal logic properties are given as ordinary LTL formulas over a set of atomic propositions. We find it useful to allow both state propositions, which are defined on terms of sort GlobalSystem, and clocked propositions, which can also take the time stamps into account. To allow clocked proposi- tions, propositions are defined w.r.t. the clocked representation (Yφ,τ )C of a real-time rewrite theory Yφ,τ . The satisfaction of a state proposition ρ ∈ Π is independent of the time stamps, so the labeling function LΠ is extended to a
labeling LC which is the “smallest” function satisfying LΠ([t ]) ⊆ LC ([t ]) and
LΠ([t ']) ⊆ LC ([t ' in time r ]) for all t , t ', and r .
In Real-Time Maude, we declare the atomic (state and clocked) proposi- tions Π (as terms of sort Prop), and define their semantics LΠ, in a module which imports the module to analyze (represented by its clocked version) and the predefined module TIMED-MODEL-CHECKER. The latter extends Maude’s MODEL-CHECKER module with the subsort declaration ClockedSystem < State. Real-Time Maude transforms a module MLΠ defining Π and LΠ into a module

MLC
defining the labeling function LC
by adding the conditional equation

ceq GS:GlobalSystem in time R:Time |= P:Prop = true
if GS:GlobalSystem |= P:Prop .
The definition of the satisfaction relation of time-bounded temporal logic is given as follows:
Definition 5.12 Given a real-time rewrite theory Yφ,τ , a protecting exten- sion LΠ of (Yφ,τ )C defining the atomic state and clocked propositions Π, an initial state t0 of sort GlobalSystem, a Timeφ value r , and an LTL formula Φ, we define the time-bounded satisfaction relation |=≤r by
Yφ,τ , LΠ, t0 |=≤r Φ  if and only if  π, LC |=Φ for all paths π ∈ Paths(Yτ,φ)≤r ,
Π	t0
where |= is the usual definition of temporal satisfaction on infinite paths.
A time-bounded property which holds when a time sampling strategy is taken into account does not necessarily hold in the original theory. But a counterexample to a time-bounded formula when the time sampling strategy is taken into account, is also a valid counterexample in the original system if the time sampling strategy is different from det and all time-nondeterministic tick rules have the form (†):
Fact 5.13 Let Yφ,τ be an admissible real-time rewrite theory where each time- nondeterministic tick rule has the form (†) with u a term of sort Timeφ. Then, for any Timeφ value r, term t of sort GlobalSystem, and s ∈ tss(Yφ,τ ) with

s /= det, we have Paths(Ys,nz )≤r ⊆ Paths(Yφ,τ )≤r .
φ,τ t	t
Corollary 5.14 For Yφ,τ , s, r, and t as in Fact 5.13,
Ys,nz , LΠ, t |=≤r Φ	implies	Yφ,τ , LΠ, t |=≤r Φ.
Let Yφ,τ be the current module, LΠ a protecting extension of (Yφ,τ )C which defines the propositions Π, and let s be the current time sampling strategy.
Furthermore, let LCˆ be the protecting extension of (Y	)≤cr which extends
φ,τ
C by adding the equation
[x in time y ] |= P = true if x in time y |= P
for variables x , y , and P . The time-bounded model checking command
(mc t0 |=t Φ in time <= r .)
is interpreted by checking the ordinary LTL satisfaction

K((Ys,nz )≤cr , [ClockedSystem])
Cˆ , [[t0
Π
in time 0φ
]] |=Φ 

using Maude’s model checker [5]. The correctness of this choice is given by the following fact:
Fact 5.15
Yφ,τ , LΠ, t0 |=≤r Φ	if and only if

K((Yφ,τ
)≤cr , [ClockedSystem])
Cˆ , [[t0
Π
in time 0φ]] |= Φ.

This fact is based on the following observations:
For each path [t0 in time r0] —→ [t1 in time r1] —→ ··· in Paths(Yφ,τ )≤r there is a corresponding path [[t0 in time r0]] —→ [[t1 in time r1]] —→ ··· 

in K((Yφ,τ
)≤cr , [ClockedSystem])
Cˆ , and vice versa.
Π

LC ([t in time r ]) = LCˆ ([[t in time r ]]) for all terms t and r .
Π	Π
The case where the time bound in a model checking command has the form
< r is treated in an entirely similar way. The case with bound no time limit
is model checked by checking whether the LC -property Φ holds in the rewrite
theory (Ys,nz )C .
Untimed Search and Model Checking
Real-Time Maude provides commands for untimed search and temporal logic model checking, which are particularly useful when the reachable state space from a term {t } is finite in Yφ,τ but is infinite in (Yφ,τ )C due to the time stamps. The untimed commands use the transformation which takes a real- time rewrite theory Yφ,τ = (Σ, E , ϕ, R) to the rewrite theory (Yφ,τ )U =


(Σ, E , ϕ, RU ), where RU is the union of the instantaneous rules in R and a rule l : {t } —→ {t '} if cond for each tick rule in R. Since (Yφ,τ )U just ig- nores the durations of tick rules, it follows that the one-step rewrite relations in (Yφ,τ )U and in Yφ,τ are the same.
Real-Time Maude’s untimed search command, with syntax (utsearch [n] t0 arrow pattern .), and the untimed model checking command, with syntax (mc t0 |=u Φ .), are executed by the corresponding commands in Maude on the rewrite theory (Ys,nz )U for s the current time sampling strategy. The formula Φ should not contain clocked propositions.

Other Analysis Commands
The execution of (find earliest t0 =>* t such that cond .) in a module
Yφ,τ , relative to a chosen time sampling strategy s, uses Maude’s search ca-

pabilities to return a term σ(t ) in time r , such that Ys,nz
▶ t0
—r→ σ(t ) for

σ satisfying cond , and such that there is no σ' satisfying cond and r ' with
'	s,nz	r	'
r <φ r and Yφ,τ  ▶ t0 —→ σ (t ). The execution of this command may loop if
there is no such match σ.
The (find latest t0 =>* t such that cond timeBound .) command (where time-Bound is either	with no time limit,	in time < r , or in

time <= r for some time value r ) analyzes all behaviors in Ys,nz
and finds

the longest time needed, in the worst case, to reach a t -state from t0. That is, for timeBound of the form <= r , the command looks for a (Yφ,τ )C -term σ(t ) in time r ', with σ satisfying cond , such that
for each π ∈ Paths(Ys,nz )≤r there exist σ' (satisfying cond ), i , and r '' such
φ,τ t0

that π(i ) equals [σ'(t ) in time r ''];
there exists a (worst) path π ∈ Paths(Ys,nz )≤r
and a number i such that

φ,τ t0
π(i ) equals [σ(t ) in time r '] and such that there are no k < i , σ' satisfying
cond , and r '' with π(k )= [σ'(t ) in time r '']; and
for each path π ∈ Paths(Ys,nz )≤r , if π(i ) equals [σ'(t ) in time r ''] for some
φ,τ t0
i , σ' satisfying cond , and r '' with r '' <φ r ', then there exists a k < i such
that π(k )= [σ''(t ) in time r '''] for some σ'' satisfying cond and r '''.
The cases with timeBound of the forms < r and with no time limit are defined in a similar way.
For the check commands, let pi be a pattern ti such that condi , for i ∈ {1, 2}, where ti is a ground irreducible term of sort GlobalSystem or sort ClockedSystem. We can view each pi as a proposition and can define the labeling function L{p1 ,p2 } on (Rφ,τ )C -states by pi ∈ L{p1 ,p2 }([t ]) if and only if there exist a t ' ∈ [t ] and a substitution σ satisfying condi such that

t ' = σ(pi ). The command (check t0 |= p1 until p2 in time <= r .) checks the until property Ys,nz , L{p ,p }, t0 |=≤r p1 U p2, and the command (check t0
φ,τ	1 2
|= p1 untilStable p2 in time <= r .) checks whether the property p2 is in
addition stable, i.e., it checks the “until/stable” temporal property
Ys,nz , L{p ,p }, t0 |=≤r (p1 U p2) /\ (p2 => [] p2).
φ,τ	1 2
The treatment of time bounds of the forms < r and with no time limit is analogous. Notice that the find latest command implicitly contains a check of the liveness property <> pattern.
The find latest and check commands are implemented by breadth-first search strategies, and can therefore sometimes decide properties for which the temporal logic model checker fails. In addition, the user does not need to explicitly define temporal logic propositions for these commands. On the minus side, performance may be affected by the fact that these commands do not use Maude’s efficient search or model checking facilities.

Using Real-Time Maude
We illustrate specification and analysis in Real-Time Maude by a very simple example. A more interesting example illustrating object-oriented specification is given in Section 6.1.
The following timed module models a “clock” which may be running (in which case the system is in state {clock(r )} for r the time shown by the clock) or which may have stopped (in which case the system is in state
{stopped-clock(r )} for r the clock value when it stopped). When the clock shows 24 it must be reset to 0 immediately:
(tmod DENSE-CLOCK is protecting POSRAT-TIME-DOMAIN . ops clock stopped-clock : Time -> System [ctor] . vars R R’ : Time .
crl [tickWhenRunning] : {clock(R)} => {clock(R + R’)} in time R’
if R’ <= 24 - R [nonexec] .
rl [tickWhenStopped] :
{stopped-clock(R)} => {stopped-clock(R)} in time R’ [nonexec] . rl [reset] :	clock(24) => clock(0) .
rl [batteryDies] :	clock(R) => stopped-clock(R) . endtm)
The two tick rules model the effect of time elapse on a system by increas- ing the clock value of a running clock according to the time elapsed, and by leaving a stopped clock unchanged. Time may elapse by any amount of time less than 24 - r from a state {clock(r )}, and by any amount of time from a state {stopped-clock(r )}. To execute the specification we should first specify a time sampling strategy, for example by giving the command (set tick def 1 .). The command (trew {clock(0)} in time <= 99 .) then simulates one behavior of the system up to total duration 99. The com-


mand (tsearch [1] {clock(0)} =>* {clock(X:Time)} such that X:Time > 24 in time <= 99 .) checks whether some state {clock(r )}, with r > 24, can be reached from state {clock(0)} in time less than or equal to
99. Since the reachable state space is finite when we take the time sam- pling into account, we can check whether a state {clock(r )}, with r > 24, can be reached from state {clock(0)} by giving the untimed search command (utsearch {clock(0)} =>* {clock(X:Time)} such that X:Time > 24 .). The command (utsearch [1] {clock(0)} =>! G:GlobalSystem .) can show that there is no deadlock reachable from {clock(0)}. Finally, the command (utsearch [1] {clock(0)} =>* {clock(1/2)} .) will not find the sought- after state, since it is not reachable with the current time sampling strategy.
We are now ready for some temporal logic model checking. The following module defines the state propositions clock-dead (which holds for all stopped clocks) and clock-is(r ) (which holds if a running clock shows r ), and the clocked proposition clockEqualsTime (which holds if the running clock shows the time elapsed in the system):
(tmod MODEL-CHECK-DENSE-CLOCK is including TIMED-MODEL-CHECKER .
protecting DENSE-CLOCK .
ops clock-dead clockEqualsTime : -> Prop [ctor] . op clock-is : Time -> Prop [ctor] .
vars R R’ : Time .
eq {stopped-clock(R)}	|=	clock-dead = true .
eq {clock(R)}	|=	clock-is(R’) = (R == R’) .
eq {clock(R)} in time R’ |=	clockEqualsTime = (R == R’) . endtm)
The model checking command (mc {clock(0)} |=u [] ~ clock-is(25) .) checks whether the clock is always different from 25 in each computation (rela- tive to the chosen time sampling strategy). The command (mc {clock(0)} |=t clockEqualsTime U (clock-is(24) \/ clock-dead) in time <= 1000 .) checks whether the clock always shows the correct time, when started from
{clock(0)}, until it shows 24 or is stopped. (Since this latter property in- volves clocked propositions, we must use the timed model checking command.)

Example: An Object-Based Network Protocol
We illustrate real-time object-oriented specification with a protocol for com- puting round trip times (i.e., the time it takes for a message to travel from an initiator node to a responder node, and back) between pairs of nodes in a net- work. The setting will be simplified to illustrate key features of object-oriented real-time specifications—such as timers and the functions delta and mte— without drowning in details. A Real-Time Maude specification of a “real” protocol for estimating round trip times is given as part of the specification of the AER/NCA protocol suite [10].


The setting is simple: each node is interested in finding the round trip time to exactly one other node. Communication is modeled very generally by “ordinary” message passing, where it may take a message any amount of time to travel from one node to another.
The protocol is equally simple: An initiator object o has a local clock and starts a run of the protocol by sending an rttReq message to its neighbor o' with its current time stamp r (rule startSession). When the neighbor o' receives the rttReq message, it replies with an rttResp message, to which it attaches the received time stamp r (rule rttResponse). When the initiator node o reads the rttResp with its original time stamp r , the rtt value is just its current clock value minus the original time stamp r (rule treatRttResp). One problem with this version of the protocol is that it may happen that the response message is not received within reasonable time. In such case it is appropriate to assume that there is a problem with the message deliv- ery. Therefore, only round trip times less than a time value MAX-DELAY are considered (rule ignoreOldResp ignores responses which are too old). If the initiator does not receive a response in time less than MAX-DELAY, it has to initiate another round of the protocol exactly time MAX-DELAY after its first attempt (rule tryAgain). The process is repeated until an rtt value less than MAX-DELAY is found. A findRtt(o) message “kicks off” a run of the protocol
for object o.
In the following specification, each Node object uses a timer attribute to ensure that a new attempt is initiated at every MAX-DELAY time units, until an rtt value is found. If the timer has value r , it must “ring” in time r from the current time. The timer is turned off when its value is INF. The class Node has the attributes nbr, which denotes the node whose rtt value it is interested in, and a clock attribute denoting the value of its local clock. The rtt attribute stores the rtt to its preferred neighbor:
(tomod RTT is protecting NAT-TIME-DOMAIN-WITH-INF . op MAX-DELAY : -> Time .	eq MAX-DELAY = 4 .
class Node | clock : Time, rtt : TimeInf,
nbr : Oid, timer : TimeInf .
msgs rttReq rttResp : Oid Oid Time -> Msg .
msg findRtt : Oid -> Msg .	--- start a run
vars O O’ : Oid .	vars R R’ : Time .	var TI : TimeInf .
--- start a session, and set timer:
rl [startSession] :
findRtt(O) < O : Node | clock : R, nbr : O’ > =>
< O : Node | timer : MAX-DELAY >	rttReq(O’, O, R) .
--- respond to request:
rl [rttResponse] :
rttReq(O, O’, R) < O : Node | > =>
< O : Node | > rttResp(O’, O, R) .



--- received resp within time MAX-DELAY;
---	record rtt value and turn off timer:
crl [treatRttResp] :
rttResp(O, O’, R) < O : Node | clock : R’ > =>
< O : Node | rtt : (R’ monus R), timer : INF > if (R’ monus R) < MAX-DELAY .
--- ignore and discard too old message:
crl [ignoreOldResp] :
rttResp(O, O’, R) < O : Node | clock : R’ > => < O : Node | > if (R’ monus R) >= MAX-DELAY .
--- start new round and reset timer when timer expires:
rl [tryAgain] :
< O : Node | timer : 0, clock : R, nbr : O’ > =>
< O : Node | timer : MAX-DELAY > rttReq(O’, O, R) .
--- tick rule should not advance time beyond expiration of a timer: crl [tick] :
{C:Configuration} => {delta(C:Configuration, R)} in time R if R <= mte(C:Configuration) [nonexec] .
--- the functions mte and delta:
op delta : Configuration Time -> Configuration [frozen (1)] . eq delta(none, R) = none .
eq delta(NEC:NEConfiguration NEC’:NEConfiguration, R) = delta(NEC:NEConfiguration, R) delta(NEC’:NEConfiguration, R) .
eq delta(< O : Node | clock : R, timer : TI >, R’) =
< O : Node | clock : R + R’, timer : TI monus R’ > . eq delta(M:Msg, R) = M:Msg .
op mte : Configuration -> TimeInf [frozen (1)] . eq mte(none) = INF .
eq mte(NEC:NEConfiguration NEC’:NEConfiguration) = min(mte(NEC:NEConfiguration), mte(NEC’:NEConfiguration)) .
eq mte(< O : Node | timer : TI >) = TI . eq mte(M:Msg) = INF .
endtom)
This use of timers, clocks, and the functions mte and delta is fairly typical for object-oriented real-time specifications. Notice that the tick rule may advance time when the configuration contains messages. The following timed module defines an initial state with three nodes n1, n2, and n3:
(tomod RTT-I is including RTT . ops n1 n2 n3 : -> Oid .
op initState : -> GlobalSystem . eq initState =
{findRtt(n1) findRtt(n2) findRtt(n3)
< n1 : Node | clock : 0, timer : INF, nbr : n2, rtt : INF >
< n2 : Node | clock : 0, timer : INF, nbr : n3, rtt : INF >
< n3 : Node | clock : 0, timer : INF, nbr : n1, rtt : INF >} .
endtom)
The reachable state space from initState is infinite since the time stamps and clock values may grow beyond any bound, and since the state may contain any number of old messages. Search and model checking should be time- bounded to ensure termination. The command (set tick def 1 .) sets the

time sampling strategy to cover the discrete time domain. The command
(tsearch [1]
initState =>* {C:Configuration
< O:Oid : Node | rtt : X:Time,
ATTS:AttributeSet >}
such that X:Time >= 4 in time <= 20 .)
checks whether a state with an undesired rtt value ≥ 4 can be reached within time 20. The command
(tsearch [1]
initState =>* {C:Configuration
< n1 : Node | rtt : 2, ATTS:AttributeSet >
< n2 : Node | rtt : 3, ATTS’:AttributeSet >} in time <= 5 .)
checks whether a state with rtt values 2 and 3 can be reached.
We illustrate temporal logic model checking by proving that there are no superfluous messages being sent around in the system after an rtt value has been found. That is, if an object o has found an rtt value, then there should be no rttReq(o', o, r ) or rttResp(o, o', r ) message with r + MAX-DELAY > c, for c the value of o’s clock. The following module defines the proposition superfluousMsg:
(tomod MC-RTT is including TIMED-MODEL-CHECKER . protecting RTT-I . op superfluousMsg : -> Prop [ctor] .
vars REST : Configuration . vars O O’ : Oid . vars R R’ R’’ : Time . ceq {REST < O : Node | rtt : R, clock : R’ > rttReq(O’, O, R’’)}
|= superfluousMsg = true	if R’’ + MAX-DELAY > R’ .
ceq {REST < O : Node | rtt : R, clock : R’ > rttResp(O, O’, R’’)}
|= superfluousMsg = true	if R’’ + MAX-DELAY > R’ .
endtom)
The command (mc initState |=t [] ~ superfluousMsg in time <= 20 .) proves that there is no superfluous message in the system within time 20. More interesting temporal properties about similar specifications are given in [11].

Concluding Remarks
We have presented Real-Time Maude 2.1, have described and illustrated its features, and have documented the tool’s semantic foundations. Perhaps the most important lesson learned is that formal specification and analysis of real-time systems – including distributed object-based systems with real-time features – can be supported with good expressiveness and with reasonable efficiency in important application areas outside the scope of current decision procedures. What seems desirable for system design purposes is to have a spectrum of analysis methods that spans automated verification on one side and simulation and testbeds on the other. We view Real-Time Maude as addressing the middle area of this spectrum, and providing a good semantic

basis for integrating other methods on the spectrum’s edges in the future.
Several research directions should be investigated in the near future: (1) the current incomplete analyses due to choices in the time sampling strategies should be made complete by identifying useful system classes for which such strategies are complete, and by developing new abstraction techniques; (2) the use of Real-Time Maude specifications to generate code meeting desired real-time requirements should be investigated; and (3) symbolic reasoning and deductive techniques complementing the current analysis capabilities should be developed. Of course, all these future developments should be driven by new applications and case studies. We hope that the current tool will stimulate users to contribute their ideas and experience in advancing the research areas mentioned above and many others.
Acknowledgments: We thank Alberto Verdejo and the referees for helpful comments on earlier versions of this paper.

References
R. Alur and D. L. Dill. A theory of timed automata. Theoretical Computer Science, 126(2):183– 235, 1994.
R. Alur and T.A. Henzinger. Logics and models of real time: A survey. In J.W. de Bakker,
K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, Real Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science, pages 74–106. Springer, 1992.
R. Bruni and J. Meseguer. Generalized rewrite theories. In J. C. M. Baeten, J. K. Lenstra,
J. Parrow, and G. J. Woeginger, editors, Proc. 30th International Colloquium on Automata, Languages and Programming (ICALP 2003), volume 2719 of Lecture Notes in Computer Science, pages 252–266. Springer, 2003.
E. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 1999.
M. Clavel, F. Du´ran, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. Maude
2.0 Manual, June 2003. http://maude.cs.uiuc.edu.
S. Eker, J. Meseguer, and A. Sridharanarayanan.  The Maude LTL model checker.  In
F. Gadducci and U. Montanari, editors, Fourth International Workshop on Rewriting Logic and its Applications, volume 71 of Electronic Notes in Theoretical Computer Science. Elsevier, 2002.
T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. HyTech: A model checker for hybrid systems.
Software Tools for Technology Transfer, 1:110–122, 1997.
Kim G. Larsen, Paul Pettersson, and Wang Yi. Uppaal in a nutshell. Int. Journal on Software Tools for Technology Transfer, 1(1–2):134–152, October 1997.
J. Meseguer. Membership algebra as a logical framework for equational specification. In
F. Parisi-Presicce, editor, Proc. WADT’97, volume 1376 of Lecture Notes in Computer Science, pages 18–61. Springer, 1998.
P. C. O¨ lveczky. Speciﬁcation and Analysis of Real-Time and Hybrid Systems in Rewriting Logic. PhD thesis, University of Bergen, 2000. Available at http://maude.cs.uiuc.edu/papers.

P. C.
O¨ lveczky.	Real-Time Maude 2.0 Manual,  2003.

http://www.ifi.uio.no/RealTimeMaude/.


P. C. O¨ lveczky, M. Keaton, J. Meseguer, C. Talcott, and S. Zabele. Specification and analysis of the AER/NCA active network protocol suite in Real-Time Maude. In H. Hussmann, editor, Fundamental Approaches to Software Engineering (FASE 2001), volume 2029 of Lecture Notes in Computer Science, pages 333–347. Springer, 2001.
P. C. O¨ lveczky and J. Meseguer. Real-Time Maude: A tool for simulating and analyzing real- time and hybrid systems. In K. Futatsugi, editor, Third International Workshop on Rewriting Logic and its Applications, volume 36 of Electronic Notes in Theoretical Computer Science. Elsevier, 2000. http://www.elsevier.nl/locate/entcs/volume36.html.
P. C. O¨ lveczky and J. Meseguer. Specification of real-time and hybrid systems in rewriting logic. Theoretical Computer Science, 285:359–405, 2002.
S. Yovine. Kronos: A verification tool for real-time systems. Software Tools for Technology Transfer, 1(1–2):123–133, 1997.
