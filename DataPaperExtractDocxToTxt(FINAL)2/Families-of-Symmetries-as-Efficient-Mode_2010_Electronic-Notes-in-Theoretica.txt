

Electronic Notes in Theoretical Computer Science 264 (2010) 63–81
www.elsevier.com/locate/entcs

Families of Symmetries as Efficient Models of Resource Binding
Vincenzo Ciancia1
Institute for Logic, Language and Computation - Amsterdam (NL)
Alexander Kurz2
University of Leicester (UK)
Ugo Montanari3
Universit`a di Pisa (IT)

Abstract
Calculi that feature resource-allocating constructs (e.g. the pi-calculus or the fusion calculus) require special kinds of models. The best-known ones are presheaves and nominal sets. But named sets have the advantage of being finite in a wide range of cases where the other two are infinite. The three models are equivalent. Finiteness of named sets is strictly related to the notion of finite support in nominal sets and the corresponding presheaves. We show that named sets are generalisd by the categorical model of families, that is, free coproduct completions, indexed by symmetries, and explain how locality of interfaces gives good computational properties to families. We generalise previous equivalence results by introducing a notion of minimal support in presheaf categories indexed over small categories of monos. Functors and categories of coalgebras may be defined over families. We show that the final coalgebra has the greatest possible symmetry up-to bisimilarity, which can be computed by iteration along the terminal sequence, thanks to finiteness of the representation.
Keywords: Presheaves, Families, Named Sets, History-dependent Automata, Coalgebras, Symmetry Reduction, Partition Refinement


Introduction
Full abstraction and nominal calculi. One of the greatest concerns in program- ming language semantics is to find fully abstract models, where all the semantically

1 Research supported by the Comunidad de Madrid program PROMESAS (S-0505/TIC/0407), and by the VICI grant 639.073.501 of the Netherlands Organization for Scientific Research (NWO)
2 Research partially supported by EPSRC EP/G041296/1
3 Research partially supported by the EU FP6-IST IP 16004 project SENSORIA

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.07.014

equivalent programs are identified. A difficult question is how to do this for the so-called interactive systems, where the focus is not the final result of the com- putation, but rather on the interactions with the environment along the possibly non-terminating behaviour of a system. For languages such as the CCS [35] or the π-calculus [36], the operational semantics is expressed in terms of labelled transi- tion systems (LTS), and the fully abstract model is the quotient of all the possbile systems with respect to bisimilarity.
Calculi with resource allocation mechanisms (the so called nominal calculi ) typ- ically have a notion of bisimulation that does not coincide with the standard one over LTS. Thus, standard definitions and algorithms can not be reused. This is solved by resorting to presheaf categories, that is, categories of functors from a small category C to Set (see [23,10,9,24,34,33], and the foundational work by Moggi [37]), or to nominal sets [25] as done in [38]. Presheaves handle names, and in general resources, as having a global meaning across all possible processes. Thus, each freshly generated name must be different from all the previous ones, giving rise to infinite states in the presence of loops. Therefore, the operational semantics of a calculus typically has infinite states even for very simple processes, making it difficult to compute the abstract semantics, or to implement finite state methods, such as minimisation, equivalence checking or model checking.
Named sets. In the parallel research line of named sets [40,41], these difficul- ties were overcome using local names; in this case, establishing a binding between names of elements is necessary whenever two elements are related. This machin- ery allows one to reuse previously generated names that have been discarded. In [41], many formalisms (e.g. Petri nets and process calculi) have been mapped into named sets in a fully abstract way. The most important finding here is that mod- elling the symmetry group of each agent is necessary to have a unique abstract model of the π-calculus, leading to [20,43,21], where a coalgebraic minimsation (partition refinement) algorithm for the π-calculus has been implemented, based on history-dependent automata, that is, coalgebras in the category of named sets. The importance of modelling symmetries is recognised both in the theory of program- ming language semantics [45] and in practical applications such as model checking [18]. Due to well known results of group theory (in particular Lagrange’s theorem, see e.g. [17], §3.3), finite groups have an efficient representation in terms of gener- ators, which is logarithmic with respect to the size of the group. Moreover, many operations on groups can be computed on the compressed representation [32].
The categorical equivalence between nominal sets, named sets and the pullback- preserving full subcategory 4 of SetI, called the Schanuel topos, has been established in [27,22]. In [12,13], a number of ad-hoc constructions on named sets used for the π-calculus are turned into categorical notions such as products, coproducts, the power set and name abstraction, thus allowing one to reuse the same machinery to represent the semantics of other calculi with names.
Our contribution. An advantage of presheaf categories is the flexibility that can be obtained by varying the index category C, giving rise more complex struc-

4 Here I is the category of finite subsets of the natural numbers and injections between them.

tures than pure names (see e.g. [28], or [3]). This flexibility is lost when using named sets, since the index category is fixed to be I. First, in §2 we introduce families as concrete representation of free coproduct completions. Our contribution starts in §3 observing that named sets with symmetries are generalised by the cat- egorical model of families over a category of groups of automorphisms and related morphisms, that we call Sym(C). This model is equivalent in the categorical sense to a full subcategory of SetC, namely coproducts of symmetrised representables, that is, representables quotiented by composition with groups of automorphisms. Presheaves are represented by families as sets of elements that have an attached symmetry on their available local interfaces.
In a sense, this already generalises the equivalence results of [27,22]. However, the exact characterisation of which presheaves are (isomorphic to) coproducts of symmetrised representables is a difficult problem. Perhaps the most important topic in [25] is the notion of ﬁnite support, which generalises the notion of free variables in terms. The support is in turn the key ingredient to define named sets and the categorical equivalence between the two. In §4 we introduce a general notion of support in presheaf categories. Exploiting this definition, we show that the equivalence result of [27,22] can be extended to presheaves indexed by small categories, respecting three conditions: the index category has wide pullbacks, and the presheaves preserve them; the index category is made up of monos; all the arrows of the index category from an object to itself are isomorphisms. A non- trivial example respecting these conditions is the category E of finite equivalence relations and injective maps between their underlying sets, used in [3,4] to represent explicit fusions of names in process calculi.
Presheaves and families have a very different nature. We refer to this as locality of interfaces. In §5 we give a mathematical explanation of this property, which is reflected in the product construction. The product is just computed point-wise in presheaves, while it involves a mapping of the local interfaces of each involved element into a greater one, in the case of families. This corresponds to two radically different, though equivalent, views on how systems with interfaces may be related: either assuming a naming authority giving a global meaning to each available re- source, or relying on locally scoped links that connect the different systems.
In §6, we show how to compute the behavioural symmetry of an element of a coalgebra, that is, the greatest group of isomorphisms that leave an element bisimilar to itself. We remark that §5 and §6 do not depend on the conditions of §4, but rather they are in the general framework of §3.
Related work. To the best of our knowledge, the study of families for an efficient representation of the semantics of programming languages, and the inter- pretation of their properties as a theory of locality of interfaces, are new and have
never been investigated before. Coproducts of symmetrised representables are also interesting as a generalisation of the analytic functors of Joyal [30]. This is shown by Ada´mek and Velebil [2] for the case of locally presentable index categories. That
research line is different in scope and aim from this work: there, a characterisation of the morphisms between analytic functors (the regular natural transformations of

[30]) would be desirable, but it is still an open problem. Instead, in §4 we develop an equivalence of categories, characterising all the natural trasformations of the subcategory by the means of morphisms of families. Moreover, the conditions of
[2] to characterise coproducts of symmetrised representables and ours do not imply each other, and there are examples of categories, relevant for our purposes, that only fall under our conditions (see §4).

Background
Here we introduce the basic notions related to the family construction Fam(C), which is a representation of the free coproduct completion of C.
Remark 2.1 (notational conventions). For C a category, we denote with |C| its objects, with C(n, m) the set of arrows from n to m. We extend some categorical notations to sets of arrows. Let F ⊆ C(n, m) be a set; we define dom(F ) = n and cod (F ) = m. When F and G are two such sets, with dom(F ) = cod (G), f : cod (G) → m', and g : m'' → dom(F ), we define f ◦ G = {f ◦ g | g ∈ G}, F ◦ g =
{f ◦ g | f ∈ F}, and F ◦ G = {f ◦ g | f ∈ F, g ∈ G}. As a notation for the elements
of the coproduct  x∈S Px in Set, we use the set of pairs {⟨x, p⟩ | x ∈ S, p ∈ Px}. The copairing of a tuple of arrows fi∈I is denoted with i∈I fi. We often omit the parenthesis in function and functor application, e.g. we write Ffx to denote the action of the functor F : C → Set on the arrow f , applied to the element x. With pullbacks we actually refer to wide, but small, pullbacks, that is, limits of small diagrams made up of an arbitrary number of arrows into the same object.
A direct description of the free coproduct completion of a category C is obtained by the family construction, defined as follows.
Definition 2.2 Given a small category C, objects of the category Fam(C) are families of objects of C, that is, coproducts i∈I{ni} of singletons in Set, where I is a set, and, for each i ∈ I, ni ∈ |C|. An arrow from  i∈I{ni} to  j∈J{mj} is a tuple
⟨f,	{Hf }⟩, where f : I → J and, for each i ∈ I, Hf : ni → mf (i).
A family is a set I, where each i ∈ I has an associated C-object ni. The set I may represent, for example, the set of states of a system. The object ni represents the interface of the state i. For example, ni can be a set of names, a network topology, or any other possible feature associated to the states of a process calculus. Each arrow is a function f between two sets I and J, and for each i ∈ I there is a map Hf from the interface of i to that of f (i). This reflects the idea that interfaces are local to each element, therefore to properly define a function between such elements, one also has to specify how the interfaces of destination and source elements are related. When we use families to represent presheaves these maps go in the other direction, that is, from the destination to the source. Looking at the above definition, this does not make a big difference, as one can just consider the category Fam(Cop) to get these “backwards” arrows, as we shall do in the following. A real-world example of local interfaces which can help the intuition is the injective relabelling of memory

locations that may happen after an invocation of the garbage collector in a garbage- collected language. System states in this case have an associated memory layout (its “interface” in our terminology), that may change at each step of the execution. The relabelling is the “backward” arrow that we mention, mapping the memory layout of the destination into that of the source, thus tracking the history of variables and their memory locations along the computation. The coproducts in Fam(C) are freely generated, and described as follows.
Definition 2.3 The coproduct in Fam(C) of two objects  i∈I{ni} and  j∈J{mj}
is defined as  k∈I+J{ok}, where ok = ni if k = ⟨I, i⟩, and ok = mj if k = ⟨J, j⟩.

Families of symmetries
In this section we introduce a condition on presheaves in SetC, namely being co- products of symmetrised representables. The terminology is borrowed from [2]. In the rest of the paper we will discuss the good computational properties of such a representation, and introduce a representability criterion for presheaves over index categories of monos.

The category Sym(C)
First, given a small category C, we define a category of groups of automorphisms, and morphisms between them, that we call Sym(C).
Definition 3.1 We define the (small) category Sym(C) of symmetries over C:
|Sym(C)| =    {Φ ⊆ C(n, n) | Φ is a group w.r.t. composition}
n∈|C|
Sym(C)(Φ1, Φ2)= {h ◦ Φ1 | h ∈ C(dom(Φ1), dom(Φ2)) ∧ Φ2 ◦ h ⊆ h ◦ Φ1}
The identity of each object is id Φ = iddom(Φ)◦Φ = Φ; the composition of f1 = h1◦Φ1
and f2 = h2 ◦ Φ2 is defined as f2 ◦ f1 = h2 ◦ h1 ◦ Φ1.
An object of Sym(C) is just denoted by the group Φ, omitting the index n of the coproduct that is recovered as dom(Φ), the common domain of all the auto- morphisms in Φ. Arrows of the category are sets of arrows from C, obtained by composition of a group of isomorphisms with a single arrow. Notice that the com- position symbol on the left hand side of the last equation is the composition in Sym(C) which is being defined, while the composition on the right is composition of sets of arrows, as from Remark 2.1. However the following lemma ensures that the two possible interpretations coincide. This is a consequence of the condition Φ2 ◦ h ⊆ h ◦ Φ1.
Lemma 3.2 Consider two Sym(C) arrows h2 ◦ Φ2 : Φ2 → Φ3 and h1 ◦ Φ1 : Φ1 → Φ2. It holds that (h2 ◦ h1) ◦ Φ1 = {h2 ◦ ϕ2 ◦ h1 ◦ ϕ1 | ϕ2 ∈ Φ2 ∧ ϕ1 ∈ Φ1}.
Finally we note that C has a full embedding into Sym(C).

Definition 3.3 The embedding J : C → Sym(C) is defined on objects as J(n) = 
{idn} and on arrows as J(f ) = {f}.

Coproducts of symmetrised representables as families
Throughout the paper, we let C denote a small category. We recall that the (covari- ant) hom functor C(n, −) : C → Set, for n an object of C, acts on each object m as C(n, m), and on each arrow f : m1 → m2 as C(n, f )(g : n → m1) = f ◦ g : n → m2. A representable presheaf in SetC is a functor which is isomorphic to C(n, −), for n an object of C.
Definition 3.4 Let Φ be an object of Sym(C) with domain n. We call a symmetrised representable C(n, −)/Φ a representable quotiented by the indexed relation g1 ≡m g2 ⇐⇒ ∃ρ ∈ Φ.g1 = g2 ◦ ρ, for g1, g2 : n → m.
The equivalence classes of such a quotient at each index m are conveniently described as the composition of each possible arrow with Φ, that is (C(n, −)/Φ)m =
{h ◦ Φ | h : n → m}. Hereafter we assume that symmetrised representables are in this form. Notice that any f ◦ Φ is an arrow of Sym(C), which gives rise to the representation we propose.  For convenience we also state what is the action of
symmetrised representables on arrows of C, namely (C(n, −)/Φ)f (h ◦ Φ) = f ◦ h ◦ Φ.
Among the presheaves in SetC, some of them are isomorphic to a coproduct of symmetrised representables, giving rise to a full subcategory of SetC. This subcate- gory is equivalent to Fam(Sym(C)op ). In the rest of the paper we shall advocate that a representation using families is appealing for computer science applications. First of all, even though the proof of equivalence is easily understood, we make it precise by the means of the following well-known proposition (see [8], Lemma 42), also used in [42], to prove the equivalence between named sets and the Schanuel topos.
Proposition 3.5 Let D' be a locally small category having small coproducts, and D a small category. A functor F : D → D' can be extended to an equivalence from Fam(D) to D' if it satisﬁes the following conditions: F is an embedding (it is injective on objects and morphisms); objects in the image of F are indecomposable (for each n in |D|, the hom functor D'(Fn, −) preserves coproducts); every object of D' is a coproduct of objects in the image of F.
Here we instantiate the theorem with D = Sym(C) and D' the subcategory of coproducts of symmetrised representables in SetC. First, recall that if C is small, the functor category SetC is locally small and has coproducts (defined pointwise), hence Prop. 3.5 is applicable. We now exhibit a functor F : Sym(C)op → SetC.
Definition 3.6 The functor F acts on objects as FΦ = C(dom(Φ), −)/Φ. F acts on each arrow h◦ Φ1 : Φ2 → Φ1 of Sym(C)op returning a natural transformation, defined at each index n as (F(h ◦ Φ1))n(h' ◦ Φ2) = h' ◦ h ◦ Φ1.
Next, we show that F respects the first and second conditions of Prop. 3.5. The third condition is satisfied by construction, when restricting the codomain of F to symmetrised representables.

Proposition 3.7 F is a functor, and in particular an embedding, i.e. injective on objects and morphisms. For each object Φ : Sym(C), FΦ is indecomposable, that is, the homset functor SetC(FΦ, −) preserves coproducts.
As SetC has coproducts, F extends to a functor from Fam(Sym(C)op ) to SetC.
Definition 3.8 The functor Presh : Fam(Sym(C)op ) → SetC maps an object  i∈I{Φi}

into 

i∈I
FΦi and an arrow ⟨f, 

i∈I
{Hf }⟩ : 

i∈I
{Φi}→ 

j∈J
{Φ' } into the natu-

ral transformation 
(ιf (i) ◦ FHf ), where ιf (i) denotes the f (i)th injection of the

coproduct 

j∈J
i∈I	i
FΦ' .

By definition, each presheaf in the image of Presh is a coproduct of symmetrised representables. The functor is full and faitful, and becomes one direction of a categorical equivalence when its codomain is restricted to its image.
The other direction is given by the functor K mapping coproducts of symmetrised representables into Fam(Sym(C)op ). The action on objects is rather trivial. Given P =  i∈I C(dom(Φi), −)/Φi , we have KP =  i∈I{Φi}. The action on arrows is more
interesting: let Q =  j∈J C(dom(Φj), −)/Φj , and g : P → Q be a natural transfor-

mation. We define the morphism between families K(g : P → P') = ⟨f, 

i∈I
{Hf }⟩.

For each i ∈ I, let gn(⟨i, iddom(Φ ) ◦ Φi⟩) = ⟨j, h' ◦ Φj⟩. Then we let f (i) = j and Hf = h' ◦ Φj. The function f is well defined by indecomposability of objects in the image of F (Prop. 3.7), in turn coming from naturality of g.
The action of K on arrows may be roughly explained by the idea of local interfaces in families. This is better understood after having introduced the notion of orbit and representative, which is done in §4.

Pullback-preservation, monos and minimal support
In this section we illustrate a characterisation of the coproducts of symmetrised representables in categories indexed by monos, as functors that preserve all pull- backs. We consider the ﬁnite support condition in the work by Gabbay and Pitts on nominal syntax [26]: each system has a unique minimal “interface”. Preservation of pullbacks means preservation of “intersection of interfaces” in a very general sense, and makes it possible to recover a notion of support of an element x ∈ Pn of a presheaf P over an arbitrary category C as the minimal index n' where an element x' ∈ Pn' exists, such that Pfx' = x for some arrow f .
The results presented here are similar in spirit to the representation of analytic functors as species given by Joyal [30], and therefore to [2], where conditions similar to ours are sketched to identify the coproducts of symmetrised representables. We emphasize that the latter research line aims to characterise and extend Joyal’s analytic functors and regular natural transformations (the latter is still an open problem), whereas we are interested in all natural transformations between two coproducts of symmetrised representables. For this reason, we are able to provide an equivalence of categories. Moreover, the index category in [2] should be locally presentable (or at least should have an initial object, see §3 therein), thus ruling

out discrete categories and coproducts of categories (hence our results and [2] are logically independent).
The connection between representability of presheaves as families and pullback preservation has been studied in various works. A well known one is [7]. There, the connection between existence of connected limits, wide pullback preservation and familial representability is explained. But there the index category of the familial representation is still the same index category C, of the presheaf category, and not a category of symmetries over it. Indeed the latter provides one a bit more structure, which we then use for the symmetry reduction procedure of §6.
The idea of representing pullback-preserving presheaves by families of symme- tries comes from Staton [42], where it appears as a proof technique to show that named sets and the Schanuel topos are equivalent. The technical results that we present in this section are a direct generalisation of that work, even though the purposes are different, since we aim to explain the computational properties of the families model, which is done in the rest of the paper.
A wide pullback is the limit of a cocone of arbitrary cardinality (whereas an
ordinary pullback is the limit of a cocone of just two arrows). Notice that in the special case of the Schanuel topos of [42], these diagrams are necessarily finite, and thus wide pullbacks are determined by the binary ones. From now on, we let SetC denote the wide-pullback-preserving full subcategory of SetC. Our theory can be instantiated under the following conditions.
Criterion 4.1 We assume that all the arrows of C are monic, C has (small, wide) pullbacks, and for every object n of C, each f ∈ C(n, n) is an isomorphism.
Notice that we do not require strong properties on C e.g. completeness or co- completeness. Some examples may clarify the applicability of the characterisation.
Discrete categories: the one-object and one-arrow category 1 can be used as an index, resulting in a degenerate instantiation of the framework that actuall just contains sets and functions. This is correct, as Set1 is Set. More generally, discrete categories can be used, in this case the representation that we will define is just the set of elements of each presheaf, that is, pairs ⟨n, x⟩ where n is the index where x lives. This is a very natural representation of multi-sorted sets. These two examples show that the definition works also in these degenerate cases, giving the expected representation.
Coproducts of categories The coproducts of two non-empty categories certainly does not have an initial object and it is not complete. However, from the pro- gramming language semantics perspective, these index categories can be used represent calculi that feature several distinct kinds of agents, each one having a different notion of associated interface.
Finite sets and injections: in this case, the obtained equivalence is that between the Schanuel topos and named sets of [22,27]. The associated categories have been used in a wide range of applications as we already emphasized. The correspon- dence between families and named sets is made clear by the categorical definitions

given in [44,13]; the category Symset defined therein is Sym(I).
Finite graphs and injections: this category can be used to model calculi whose network structure is made explicit in the semantics (as opposed to the π-calculus, where the network structure is left implicit in the knowledge of channels by agents) and whose semantics is closed with respect to adding links to the network. The network coordination policies calculus (NCP) [11], has been developed by the first author et al. in the context of formal methods for service-oriented computing. In the calculus, states are pairs consisting of the network topology, represented as a graph, and a policy, which is a program. Entire fresh sub-topologies can be dynamically allocated along the transitions of the operational semantics. Even though category theory is not used in that work, it seems clear that the semantics can be represented using the standard presheaf approach, with finite graphs and injections as the index category. In NCP, bisimulation is used for the definition of conformance of the specification and the implementation, thus the implemen- tation of an efficient bisimulation checker (taking into account the dynamic allo- cation capabilities of the framework) is of high relevance. Therefore, the calculus will be an appealing case study for the symmetry reduction algorithm that we sketch in this work.
Fusions: Fusions may be described by an indexing category E of equivalence rela- tions with monic arrows [3]. This category has pullbacks, falls into the conditions of our framework, and it has a rich structure of objects that is used for fusions (see also [28,34]).


The symmetric decomposition of a presheaf
We now show that under Crit. 4.1, functors in SetC


are isomorphic to coproducts

of symmetrised representables, that is objects in the image of the functor Presh.
Therefore the full category SetC coincides exactly with the subcategory of coprod-
ucts of symmetrised representables.
We pursue our goal emplying Prop. 3.5 again. F being an embedding, and inde- composability of objects in its image are not affected by the additional hypothesis. However, we must prove that each presheaf in the image of F is pullback-preserving.
Theorem 4.2 For each Φ, assuming Crit. 4.1, FΦ preserves wide pullbacks.
The rest of the section is devoted to prove the last required condition of Prop. 3.5, that is, each pullback-preserving presheaf is a coproduct of symmetrised repre- sentables. We recall the notion of element of a presheaf. Hereafter, we let G denote an arbitrary functor in SetC .
Definition 4.3 The set of elements of G is defined as El (G) =  n∈|C| Gn.
For readability, but without loss of generality, in the following we assume that all the Gn are disjoint, so that we are able to denote with just x the element ⟨n, x⟩∈ El (G). When necessary, we denote the stage n of x as st (x ).
Roughly, we aim to represent presheaves by quotienting all the elements that

are “reachable” from some common element by the action of arrows. To make this formal, we introduce the notion of orbit.
Definition 4.4 Given x ∈ El (G), its orbit Ox is the set of elements y ∈ El (G) such

that there exist a span st (x ) fx
s → st (y ) and an element z ∈ Gs, with Gfx
z = x

and Gfyz = y.
In other words, an orbit is a connected component in the category of elements. In the following, for x ∈ El (G), we let Dx be the diagram in C consisting of the morphisms {d : n → st (x ) | ∃y ∈ G(n).Gdy = x}, for n ranging over |C|. Notice that, for each d, y is uniquely determined: Gd is injective because G is pullback-preserving, hence mono-preserving.
The following lemma forms the grounds of our representation. It is perhaps the most important property of orbits, due to pullback preservation of SetC .
Lemma 4.5 Let x and y belong to the same orbit. Let n be the pullback object of Dx and m be the pullback object of Dy. There exists an isomorphism between n amd m making n a pullback of Dy.
We now define the support of an element x, which is, roughly speaking, the smallest index where an element having the same properties of x can be found.
Definition 4.6 Let xO denote a choice of an element in Ox. We define the support
O
of x, denoted with Sx, as the pullback object of D(x ), and the normalising arrow
Nx : Sx → st (x ) as the diagonal of the pullback diagram of Dx, where we choose
Sx as the pullback object by Lemma 4.5.
With diagonal here we mean the composition of any arrow in Dx with the corresponding arrow making the pullback commute.
We are going to see that an object of SetC is determined (up-to isomorphism)
just by a set of representatives x^ of elements, called proper elements, and by the
set of isomorphisms over the stage of each x^ whose action leaves x^ unchanged.
Preservation of pullbacks plays a fundamental role here, allowing us to prove the following lemma and to define the representative of an element.
Lemma 4.7 There exists a unique element x^ ∈ GSx such that GNxx^ = x.
Definition 4.8 Let x ∈ El (G). We denote with x^ the representative of x, that is, the element of GSx such that GNx(x^) = x. The set of proper elements of G is defined as Pel(G) = {x^ | x ∈ El (G)}.
In this construction, Nx plays the role of a canonical arrow whose action recovers x from its representative x. The symmetry associates to each proper element an object of Sym(C).
Definition 4.9 The symmetry of x^ ∈ Pel(G) is the group of isomorphisms Gxb =
{ρ : Sx → Sx | Gρx^ = x^}.
Now we can define a functor from SetC to Fam(Sym(C)op ) which, together with
the functor Presh of Def. 3.8, completes the categorical equivalence.

Definition 4.10 The symmetric decomposition SymDec : SetC → Fam(Sym(C)op ) is defined on each presheaf G and natural transformation f : G1 → G2 as

SymDec(G) =	   {Gxb}	SymDec(f ) = ⟨λx^.f^(x^),	 

{Nf (xb)
◦G ^ }⟩
fSx (xb)

xb∈P el(G)	xb∈P el(G1)
The action of the functor on objects just records the proper elements of G, and their symmetry. The action on arrows is an arrow of Fam(Sym(C)op ), thus a function between the two index sets, and a family of arrows in Sym(C)op . The former returns, for each representative x, the representative of fSx (x). The mappings associated to the arrow are the normalising arrows of every obtained element, composed with the corresponding symmetry. Using it, one can reconstruct fSx (x) from its repre- sentative. A bit more intuition may be obtained by considering the support and symmetry of an element as a local interface of that element. The arrow N  ◦G
fSx (xb)
embeds the interface of f^(x^) into the interface of f (x^), which is the same of x^
because f is defined pointwise. The normalising arrow is the so-called history of
names along morphisms 5 used in the literature on named functions, and in coal- gebras it plays a similar role to the injective relabelling of memory locations done by garbage collectors in the implementation of programming languages.
Lemma 4.11 We have Gˆhx^ = x^, and NGhxb ∈ h ◦ Gxb.
Theorem 4.12 Every presheaf G in SetC is isomorphic to Presh(SymDec(G)), there-
fore SetC is equivalent to Fam(Sym(C)op ).
Remark 4.13 A great advantage of the proposed representation of presheaves using families is to reduce the size (the number of elements) of the represented presheaf, even getting a finite set out of an infinite one, while preserving the cate- gorical properties. For example, the “inclusion” presheaf Gn = n, Gf = f in SetI, that is, the object of names in SetI, is represented by a family having a single
element 6 in Fam(Sym(I)op ), namely i∈1{id1}. The intuitive meaning of this as- sertion is that each natural number is not distinguishable from any other, and has a single “name” (and trivial symmetry) as its interface. This “finitistic” representa-
tion is the main reason why named sets and history-dependent automata have been considered appealing for the static analysis of nominal calculi (model checking [29], and bisimulation checking [21]).
Locality of interfaces: the product construction
In [44], one of the authors extended the equivalence of [27,22] to the categories of coalgebras of equivalent endofunctors, in order to give a categorical characterisation of the various constructions that had been used in the past for named sets (including minimisation of the π -calculus). Here we generalise the results on the product of named sets presented therein.

5 In our case, we should call it the history of interfaces along morphisms.

6 G is different from the final object ‘

i∈1
{id0}, having a single element with trivial interface

Multi-(co)products are a specialisation of the notion of multi-(co)limit, studied in detail by Diers [16]. It is well known (see e.g. [14], remark 5) that Fam(C) has products whenever C has multi-products, and dually, Fam(Cop) has products if C has multi-coproducts. Here we provide a concrete characterization of the functor, that emphasizes the difference between global and local interfaces. The results presented here do not rely on arrows of C being mono.
Definition 5.1 Given a diagram D consisting of a tuple of objects ⟨n1,..., nk⟩, the multi-coproduct of D is a set mcp(D) of cocones over D such that for all cocones L' = ⟨f1 : n1 → m',..., fk : nk → m'⟩ over D there exists a unique cocone L = ⟨ι1 : n1 → m,..., ιk : nk → m⟩ ∈ mcp(D), and a unique arrow uL' : m → m' making the diagram L ∪ L' ∪ uL' commute. The unique cocone L will be denoted, with a bit of overloading, with mcp(L').
In words, the multi-coproduct of two objects P and Q is a set of canonical cospans between them, in the sense that they are quotiented by isomorphisms of cospans, and they are minimal.
We note that Sym(C) has multi-coproducts.
Theorem 5.2 If C has wide pullbacks, then Sym(C) has multi-coproducts.
In the following definitions, we assume that C has multi-coproducts, that P =
 i∈I{ni}, Q = i∈J{mj}, R = k∈K{ok} are three arbitrary objects of Fam(Cop), and we denote with S the set {⟨i, j, ⟨ι1, ι2⟩⟩ | i ∈ I∧j ∈ J ∧⟨ι1, ι2⟩∈ mcp(⟨ni, mj⟩)}.

Definition 5.3 The product of P and Q in Fam(Cop) is defined as the object P ×Q =
  ⟨i,j,⟨ι1,ι2⟩⟩∈S{cod (ι1)}.
Elements of the product P ×Q are triples, formed by an element of P , an element of Q, and a (canonical) cospan relating their symmetry.

Definition 5.4 Let π'
and π'
denote the first two projections of the ternary prod-

uct S.  The projections π1 : P × Q → P and π2 : P × Q → Q are defined as

π1 = ⟨π' , 
{ι1}⟩, π2 = ⟨π' , 
{ι2}⟩.

Definition 5.5 The pairing of ⟨f,	{Hf }⟩ : R → P and ⟨g,	{Hg }⟩ :
R → Q is the arrow ⟨h,	{Hh}⟩, where h(k) = ⟨f (k), g(k), mcp(⟨Hf , Hg ⟩)⟩,

and Hh = u	f	g .
k∈K	k	k	k

k	⟨Hk,Hk⟩
Theorem 5.6 The product, projections and pairing given above identify up to iso- morphism the binary product in Fam(Cop).
In the above definition, mcp(⟨Hf , Hg ⟩) and u	f	g  come from Def. 5.1. We
k	k	⟨Hk,Hk⟩
keep on with the intuition that the index category C in SetC should be perceived as a set of possible types, or interfaces of elements of the presheaf. In this light, the definition of the product above gives a notion of locality of interfaces in families, as opposed to a notion of global interfaces in presheaf categories.

In SetC the product is defined pointwise, and two elements may be related by just pairing them if they are in an appropriate (common) context. That is, any two interfaces have a natural choice of an embedding into a common, greater interface, thus their relative meaning is established once and for all. In the case of names (that is, where the index category is I), this is the vision adopted by the π-calculus, where the names of all the non-restricted channels of an agent have a global, unique meaning across all participating parallel components of a system, as if there was a naming authority assigning a meaning to any name.
In Fam(Cop), whenever we put two elements in a relation, we have to explicitly establish a link between their interfaces by exhibiting them as subobjects of a com- mon object, acting as the interface of the obtained tuple. In the case of names, this corresponds to having to “pull wires” among all parallel components of a sys- tem to make explicit how they can interact. This may be the most natural choice whenever one wants to model systems that do not have a naming authority, such as peer-to-peer systems.
As an example, bisimilarity in Fam(Cop) is made up of triples, because it is a subobject of the product: in order to compare two systems, we need to establish a correspondence between their local interfaces.

Symmetry reduction by final semantics
The presheaf approach to operational semantics roughly consists in defining a presheaf P of terms, that is, the initial algebra of some endofunctor over a presheaf category, and a coalgebra from P to TP for some endofunctor T, providing the se- mantics of the calculus. The unique morphism into the final coalgebra of T then gives the coinductive definition of the abstract semantics. Here we link the sym- metry of elements in Fam(Sym(C)op ) with behavioural equivalence, defined as the pullback object of a coalgebra morphism. We note that coalgebraic bisimilarity and behavioural equivalence coincide if the behavioural functor T preserves weak pullbacks (see [31] or [1] for details). Given a coalgebra in Fam(Sym(C)op ), and an element i, having symmetry Φ with dom(Φ) = n, we explain how computing the image of i along the unique morphism into the final coalgebra corresponds to iden- tify the subobject of n that is active in the semantics of i, and the greatest possible symmetry over this object that preserves behavioural equivalence.
The interest of this result is in providing a clean framework (namely, the equiv- alence between presheaves and families) for symmetry reduction of the semantics of programming languages. Symmetry reduction is an actively researched topic in computer science that consists in finding compressed representations of systems that have a symmetry (see [15] and subsequent works, or the more recent [19]). This is typically done exploiting equations on the syntax of calculi, or by adding symmetry information “by hand” to models. Our approach is very different: it allows one to compute the behavioural symmetry, that is, the best symmetry up-to bisimulation. This is certainly wanted in all the cases where bisimulation is the equivalence rela- tion of choice (e.g. static analysis in service oriented computing and model checking

of Hennessy-Milner-like logics). Model checking can be performed efficiently in the presence of symmetry [18].

Symmetry reduction
Remark 6.1 Equivalences extend to categories of coalgebras of suitable “equiv- alent” endofunctors. In particular, each endofunctor T' over the full subcategory of coproducts of symmetrised representables in SetC that has a final coalgebra has an equivalent endofunctor over Fam(Sym(C)op ) admitting a final coalgebra, obtained (up to isomorphism) as T = SymDec ◦ T' ◦ Presh.
We assume in the following such a pair of equivalent endofunctors T' and T. Even if for the scope of this work the given definition of T is sufficent, it may be necessary to have a compositional definition of T so that the elements of T(P ) are derived from those of P . In the case of the product, for example, the definition of
§5 is isomorphic to the one that we just mentioned, but not the same. This topic has been studied in detail in [44].
We now observe that each natural transformation between coproducts of sym- metrised representables induces a symmetry on elements of its source, explicitly
represented in the corresponding arrow of Fam(Sym(C)op ).  Consider a presheaf
G =  i∈I FΦi, a natural transformation f : G → G', and the corresponding arrow

⟨g, 

i∈I
{Hg}⟩ : 

i∈I
{Φi}→ 

j∈J
{Φ' }.

Definition 6.2 Let Rf denote the relation coming from the kernel pair of the
component f  of f at n. Let x ∈ Gn. We call the set Gh = {ρ : n → n | GρxRf x}
n	x	n
the symmetry on x induced by f .
Proposition 6.3 For each i ∈ I, n ∈ |C|, h ◦ Φi ∈ FΦin, and ρ : n → n, we have
(FΦ ρ(h ◦ Φ ))Rf (h ◦ Φ ) if and only if ρ ◦ h ◦ Hg = h ◦ Hg.
i	i	n	i	i	i
Observe that ρ ◦ h ◦ Hg = h ◦ Hg implies that, for each h' in h ◦ Hg, there is an
i	i	i
isomorphism ρ' ∈ Φ'	such that ρ ◦ h' = h' ◦ ρ', that is, the symmetry induced by
f is reflected in Φ'	.
It is now obvious to observe that the symmetry induced by coalgebra morphisms respects bisimulation. When f is the unique morphism into the final coalgebra, the induced symmetry is the greatest possible such subset. We call it the behavioural symmetry. In this case, the arrows in h◦Hg identify a subobject of n that intuitively is the active “sub-interface” of an element, i.e. operations that do not touch it may not affect the semantics. To make this more precise, observe that, for each h' ∈ h ◦ Hg, we either have ρ ◦ h' /= h' or ρ ◦ h' = h'. The first case is the one where
the symmetry Φ'	actually plays a role.  In the second case, as all the arrows

in h ◦ Hg
are obtained by composition of h' with an arrow in Φ'
, composition

with ρ leaves all of them unchanged. Then ρ is acting in some sense outside of
the subobject identified by h ◦ Hg. For example, when the index category is I, the image of h is the set of active names of a system, that is, names that are observable in the final semantics.

Partition reﬁnement as a generic symmetry reduction algorithm
Here and in the next section we explain how to compute bisimilarity on a subset of the terms of a calculus, if certain finiteness conditions hold.
Consider a calculus equipped with a semantics in SetC, s : P → T'P for P repre- senting the syntax. As we know (see Rem. 6.1), if P is a coproduct of symmetrised representables, there is a corresponding coalgebra t : P' → TP' in Fam(Sym(C)op ) of
a suitable endofunctor T corresponding to T'.
The partition refinement in Fam(Sym(C)op ) can be computed on an object  q∈Q{Gq}
(intended to be a subobject of P' above) as follows. First, we give an abstract de- scription of the general algorithm, then we explain in detail the single steps and
discuss some finiteness conditions to compute them in Fam(Sym(C)op ).
Definition 6.4 Coalgebraic partition refinement in Fam(Sym(C)op ) is an iterative algorithm using three variables, f , h and z, denoting arrows in Fam(Sym(C)op ).
Initialization: Let f = t, let h :  q∈Q{Gq} → 1 be the unique morphism into the final object of Fam(Sym(C)op ), and z the unique morphism from T1 to 1.
Iteration step(f, h, z): If z restricted to Im(Th◦f ) is an isomorphism in Fam(Sym(C)op ) then return Th ◦ f . Otherwise let f' = Tf ◦ f , h' = Th, z' = Tz, and compute Iteration step(f', z', w').
Correctness of the algorithm is well known by the theory of coalgebras (see e.g. [46]). An intuition can be given as follows. At the nth iteration of the algorithm, the kernel of Th◦ f :  q∈Q{Gq}→ Tn1 is a partition of Q, which quotients elements that have the same observations in n steps. At each step, this partition is refined, that is, possibly split, according to the observations made in the nth iteration of the system. When z is an isomorphism, a fixed point is reached, and it is guaranteed that in all successives steps, the partition will remain unchanged. Therefore, the elements of Q that are equalised by Th ◦ f are bisimilar. The isomorphism z is a subobject of the final coalgebra that represents the behaviour of the elements of Q.
Convergence of the algorithm is equivalent to deciding the semantics of a pro- gram, therefore it can not be guaranteed a priori for all calculi. For Turing- equivalent languages, the algorithm converges on an undecidable subset of all the possible programs. In labelled transition systems, one gets convergence if the set of states reachable from a given set of initial states is ﬁnite. When using coalgebras over presheaves, even trivial programs have infinite states, but finiteness of the ele- ments of the corresponding family is enough to guarantee convergence. This leads to a more refined notion of finiteness for presheaves.
Static constraints may be used (e.g. the ﬁnite-control π-calculus agents of [21]) to identify a subset of the convergent instantiations of the algorithm.
The pairs of bisimilar systems in Q are described by the kernel pair of the final value of the arrow Th ◦ f , and the behavioural symmetry of each element q ∈ Q is reflected in the symmetry of its image along the same arrow.  When C is the
free category over one object and T = Pfin (L × −), then Fam(Sym(C)op ) is Set, L is
a set of labels, and the algorithm is the classical partition refinement for labelled

transition systems. When C is I, there is a suitable endofunctor [13] such that the algorithm above is the partition refinement procedure for the π-calculus of [39,21].

Computing the semantics
Two basic assumptions are needed. First, objects and arrows of C should be “finite”, in the sense that they can be represented as data structures. Then, f should be computable in each step of the algorithm. Without these assumptions, the algorithm can not be implemented. Indeed, the cases studied in the literature on presheaves for process calculi fall under these hypotheses.
To be able to compute partition refinement, we first need to describe the final object in Fam(Sym(Cop)). In a similar fashion to Thm. 5.6, the final object in Fam(C) is a family of multi-initial objects, that is, a set MI of C-objects such that for each object c of C there is a unique element i ∈ MI and a unique arrow u : i → c. Similarly to Thm. 5.2, it is possible to show that if C has pullbacks, then Sym(C)op
has a set of multi-initial objects.
Proposition 6.5 Given a set MI of multi-initial objects in Sym(C), the object P =
 Φ∈MI {Φ} is a ﬁnal object in Fam(Sym(C)op ). The unique arrow from  j∈J{Φj} to P is ⟨λj.iΦj , Φ∈Φj {uΦj }⟩, where iΦj and uΦj denote respectively the unique element of MI and the unique arrow corresponding to Φj in MI .
It holds that if a category has an initial object i, then the singleton {i} is a family of multi-initial objects. Getting back to partition refinement, to compute h, z and f one needs that Q is finite and that from each object of q the corresponding element of the final object is computable.
One also needs that the image of f is finite on all the elements of Q, in order to be able to enumerate the elements on which z has to be an isomorphism. This requirement is certainly satisfied if T sends finite families into finite families. This happens in many interesting cases, including polynomial functors, name allocation, and certain non finite subfunctors of the power set. Remarkably, in [44] such a “finitistic” representation is given for the early semantics of the π-calculus, which is defined as an infinitary transition system, due to the input transitions.

Under the above restrictions, one has to check if z = ⟨fz, 
i∈Im(Th◦f )
{Hfz }⟩ is

an isomorphism. The criterion in Fam(Sym(C)op ) is that fz is an isomorphism in Set
and each Hfz is an isomorphism in Sym(C). To check the latter, it is necessary to
determine the symmetry of elements of Tn1 for each n. Having an effective procedure to compute this symmetry depends on the chosen functor. In [44] it is shown how to do this for polynomials, name abstraction and subfunctors of the power set. We conjecture that these results generalise to other categories of finite structures.

Garbage collection
We consider the representation using families appealing because it may allow one to implement iteration along the terminal sequence, starting from a coalgebra defining the operational semantics, in the presence of fresh resouce allocation. We emphasize

that fresh resources are perhaps the most important reason to employ presheaves for the semantics of programming languages.
In presheaf models, whenever behavioural functors that may allocate new re-
sources, such as the functor δ for name abstraction of [24], are used to build coal- gebras, the operational semantics obtained by rules typically becomes infinite even in very simple cases. Again, this comes from the fact that interfaces have a global
meaning in presheaves, whereas in the family representation the symmetry of each element is local. This is reflected in the definition of arrows: in presheaves, one does
not need to provide information on how the interface of the destination is mapped in the interface of the source, while this is exactly the role of the family of arrows in Sym(C) (one for each element) that are the second component of an arrow of
Fam(Sym(C)op ). Thus, elements that have the same behaviour up-to an operation
on their interface are not identified using presheaves. This is particularly problem- atic for recursive processes that allocate some resources while discarding older ones, keeping a finite quantity of resources allocated in each state (as explained in [12]). Using families, on the other hand, all these equivalent elements are identified. It is the purpose of the family of maps associated to each arrow of the category to identify a “sub-interface” of each source state, which is preserved in the destination state, thus discarding unused resources.

Concluding remarks
We have introduced a framework to represent the semantics of programming lan- guages that deal with resources or interfaces attached to system states: coalgebras over presheaf categories obeying to certain constraints, that give rise to a “fini- tistic” representation using families. This representation removes the redundant information coming from the notion of interfaces being global rather than local.
First of all, a complete example of application should be developed. The field of presheaf semantics for process calculi is still a relatively new research field, and there is not so much literature on calculi different from the π-calculus. However, by providing a representation theory, we prepare the grounds on which to build up new applications. An interesting case study is [4], since the presheaf category employed there respects the conditions of §4.
Applications are of great interest in the area of service-oriented computing, where resource allocation in the presence of network topologies [11], or constraints [6] is an active field of research, and finite representations are of vital importance for the implementation of analysis algorithms. An efficient implementation of the generic symmetry reduction algorithm that we have presented should be studied. For that, one may take advantage of algorithms on permutation groups exploiting the generators [32]. Finally, similar consideration apply to model checking. The study of a Stone-type duality for coalgebras over families in a similar fashion to [5], and a corresponding model checking algorithm exploiting the cases where the representation is finite, are one of our most important long-term goals.
It is expected that the categorical equivalence that we presented, combining the

ease of specifying the semantics using presheaves with the implementative advan- tages of named sets, will enable the development of a general framework to specify (using presheaves) and analyse (using families) the semantics of calculi that have richer interfaces than pure names, thus advancing the research line of presheaves, named sets and history dependent automata.

References
J. Adamek. Introduction to coalgebra. Theory and Applications of Categories, 14(8):157–199, 2005.
J. Adamek and J. Velebil. Analytic functors and weak pullbacks. Theory and Applications of Categories, 21(11):191–209, 2008.
F. Bonchi, M. Buscemi, V. Ciancia, and F. Gadducci. A Category of Explicit Fusions. LNCS - Festschrift for Ugo Montanari, 5065, 2008.
F. Bonchi, M. Buscemi, V. Ciancia, and F. Gadducci. A presheaf environment for the calculus of explicit fusions. Submitted, 2009.
M. M. Bonsangue and A. Kurz. Pi-calculus in logical form. In LICS, pages 303–312. IEEE Computer Society, 2007.
M. G. Buscemi and U. Montanari. Cc-pi: A constraint-based language for specifying service level agreements. In R. De Nicola, editor, ESOP, volume 4421 of LNCS, pages 18–32. Springer, 2007.
A. Carboni and P. Johnstone. Connected limits, familial representability and the artin glueing.
Mathematical Structures in Computer Science, 5, 1995.
A. Carboni and E. Vitale. Regular and exact completions. Journal of Pure and Applied Algebra, 125(1-3):79 – 116, 1998.
G. L. Cattani and P. Sewell. Models for name-passing processes: Interleaving and causal. In LICS, pages 322–332, 2000.
G. L. Cattani, I. Stark, and G. Winskel. Presheaf models for the π-calculus. In Category Theory and Computer Science, pages 106–126, 1997.
V. Ciancia, G. L. Ferrari, R. Guanciale, and D. Strollo. Event based choreography. Science of Computer Programming, To appear.
V. Ciancia and U. Montanari. A name abstraction functor for named sets. Electr. Notes Theor. Comput. Sci., 203(5):49–70, 2008.
V. Ciancia and U. Montanari.  Symmetries, local names and dynamic (de)-allocation of names.
Information and Computation, 2009. To appear.
C. Cirstea. Semantic constructions for the specification of objects. Theor. Comput. Sci., 260(1-2):3–25, 2001.
E. M. Clarke, E. A. Emerson, S. Jha, and A. P. Sistla. Symmetry reductions in model checking. In Computer Aided Verification, 10th International Conference, volume 1427 of LNCS, pages 147–158, 1998.
Y. Diers. Familles universelles de morphismes. Ann. Soc. Sci. Bruxelles, 93:175–195, 1979.
J. D. Dixon and B. Mortimer. Permutation Groups, volume Permutation Groups of Graduate Texts in Mathematics. Springer, 2006.
E. A. Emerson and A. P. Sistla. Symmetry and model checking. Formal Methods in System Design, 9(1/2):105–131, 1996.
E. A. Emerson and T. Wahl. Dynamic symmetry reduction. In N. Halbwachs and L. D. Zuck, editors,
TACAS 2005, volume 3440 of Lecture Notes in Computer Science, pages 382–396. Springer, 2005.
G. L. Ferrari, U. Montanari, and M. Pistore. Minimizing transition systems for name passing calculi: A co-algebraic formulation. In FoSSaCS, pages 129–158, London, UK, 2002. Springer-Verlag.
G. L. Ferrari, U. Montanari, and E. Tuosto. Coalgebraic minimization of hd-automata for the pi-calculus using polymorphic types. Theor. Comput. Sci., 331(2-3):325–365, 2005.

M. Fiore and S. Staton. Comparing operational models of name-passing process calculi. Inf. Comput., 204(4):524–560, 2006.
M. P. Fiore, E. Moggi, and D. Sangiorgi. A fully-abstract model for the pi-calculus (extended abstract). In LICS, pages 43–54, 1996.
M. P. Fiore and D. Turi. Semantics of name and value passing. In LICS, pages 93–104, 2001.
M. Gabbay and A. Pitts. A new approach to abstract syntax involving binders. In LICS, pages 214–224, 1999.
M. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Asp. Comput., 13(3-5):341–363, 2002.
F. Gadducci, M. Miculan, and U. Montanari. About permutation algebras, (pre)sheaves and named sets. Higher-Order and Symbolic Computation, 19(2-3):283–304, 2006.
N. Ghani, K. Yemane, and B. Victor. Relationally staged computations in calculi of mobile processes.
Electr. Notes Theor. Comput. Sci., 106:105–120, 2004.
S. Gnesi and G. Ristori. A model checking algorithm for π-calculus agents. In Proc. Second International Conference on Temporal Logic (ICTL ’97). Kluwer Academic Publishers, 1997.
A. Joyal. Foncteurs analytiques et espces de structures. In Combinatoire E`num´erative, volume 1234 of Springer Lecture Notes in Mathematics. Springer Verlag, 1985.
A. Kurz. Logics for Coalgebras and Applications for Computer Science. PhD thesis, Ludwig- Maximilians-Universitat Munchen, 2000.
E. M. Luks. Permutation Groups and Polynomial Time Computation. DIMACS Series in Discrete Mathematics and Theoretical Computer Science, 11:139–175, 1993.
M. Miculan. A categorical model of the fusion calculus. Electr. Notes Theor. Comput. Sci., 218:275– 293, 2008.
M. Miculan and K. Yemane. A unifying model of variables and names. In V. Sassone, editor, FoSSaCS, volume 3441 of Lecture Notes in Computer Science, pages 170–186. Springer, 2005.
R. Milner. A calculus of communicating systems. Lecture Notes in Computer Science, 92, 1980.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, part i. Information and Computation, 100(1):1–40, 1992.
E. Moggi. Notions of computation and monads. Information and Computation, 93(1):55–92, 1991.
U. Montanari and M. Pistore. pi-calculus, structured coalgebras, and minimal hd-automata. In MFCS, volume 1893 of LNCS, pages 569–578, 2000.
U. Montanari and M. Pistore. Structured coalgebras and minimal hd-automata for the pi-calculus.
Theoretical Computer Science, 340:539–576, 2005.
U. Montanari, M. Pistore, and D. Yankelevich. Efficient minimization up to location equivalence. In
ESOP, pages 265–279, 1996.
M. Pistore. History Dependent Automata. PhD thesis, Universit`a di Pisa, Dipartimento di Informatica, 1999. available at University of Pisa as PhD. Thesis TD-5/99.
S. Staton. Name-passing process calculi: operational models and structural operational semantics. Technical Report UCAM-CL-TR-688, University of Cambridge, Computer Laboratory, 2007.
E. Tuosto. Non-Functional Aspects of Wide Area Network Programming. PhD thesis, Dipartimento di Informatica, Universit`a di Pisa, May 2003. TD-8/03.
Vincenzo Ciancia. Accessible Functors and Final Coalgebras for Named Sets. PhD thesis, University of Pisa, 2008.
G. Winskel. Symmetry and concurrency. In CALCO, pages 40–64, 2007.
J. Worrell. Terminal sequences for accessible endofunctors. Electr. Notes Theor. Comput. Sci., 19, 1999.
