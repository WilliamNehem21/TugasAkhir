

Electronic Notes in Theoretical Computer Science 221 (2008) 103–114
www.elsevier.com/locate/entcs

Effective Computability of Solutions of Ordinary Differential Equations
The Thousand Monkeys Approach
Pieter Collins1,2
Centrum voor Wiskunde en Informatica, Amsterdam, The Netherlands
Daniel S. Grac¸a 1,3
DM/FCT da Universidade do Algarve, Faro, Portugal and SQIG/Instituto de Telecomunicac¸o˜es, Lisboa, Portugal

Abstract
In this note we consider the computability of the solution of the initial-value problem for ordinary differential equations with continuous right-hand side. We present algorithms for the computation of the solution using the “thousand monkeys” approach, in which we generate all possible solution tubes, and then check which are valid. In this way, we show that the solution of a differential equation defined by a locally Lipschitz function is computable even if the function is not effectively locally Lipschitz. We also recover a result of Ruohonen, in which it is shown that if the solution is unique, then it is computable, even if the right-hand side is not locally Lipschitz. We also prove that the maximal interval of existence for the solution must be effectively enumerable open, and give an example of a computable locally Lipschitz function which is not effectively locally Lipschitz.
Keywords: Ordinary differential equations, differential inclusions, Lipschitz condition, computability


Introduction
In this paper we study the computability of initial-value problems defined with ordinary differential equations. Let f : R × Rn → Rn be some function defined on

1 The authors wish to thank Ning Zhong for useful remarks and comments. DG was partially supported by Funda¸ca˜o para a Ciˆencia e a Tecnologia and EU FEDER POCTI/POCI via CLC, SQIG - Instituto de Telecomunica¸c˜oes and grant SFRH/BP D/39779/2007. Additional support to DG was also provided by the Funda¸cao Calouste Gulbenkian through the Programa Gulbenkian de Est´ımulo a` Investigac¸a˜o. PC was partially supported by Nederlandse Organisatie voor Wetenschappelijk Onderzoek (NWO) Vidi grant
639.032.408.
2 Email: pieter.collins@cwi.nl
3 Email: dgraca@ualg.pt

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.010

a closed box B ⊆ R × Rn and consider the initial-value problem defined by
⎧ x˙ = f (t, x)
⎩ x(0) = x0.



(1)


For simplicity of discussion, though not essential, we took the initial time to be t0 = 0. As shown in [1], [3], [8], if f satisfies a Lipschitz condition over B, then the unique solution of (1) can be computed from x0 and f . The idea is to use the classical result that shows that if f satisfies a Lipschitz condition on R, then the solution of (1) is unique — see e.g. [4] — by noticing that its proof is effective.
A question of interest is to determine which are the “weakest” conditions that f must satisfy in order that one might be able to compute the solution of (1). We remark that if the solution of (1) is non-unique, than it can happen that none of the solutions is computable [2], [11], though the solution set is upper-semicontinuous, and can be shown to be upper-semicomputable. In order to prevent pathological cases, we assume in this paper that: (i) f should be continuous (Peano’s existence theorem guarantees the existence of at least one solution in this case) and (ii) the solution of (1) should be unique.
The standard condition used in literature to study solutions of (1) is to assume that f is Lipschitz. For instance it is shown in [10], [13] that the solution of Lipschitz
differential inclusions x˙ ∈ F (t, x), where F is a set-valued function, subjected to
the condition x(0)  X, can be computed. Related results have also been obtained in [5] for one-sided Lipschitz functions. While differential inclusions are different in form from (1), under appropriate circumstances they can be useful to study the problem (1).  The general idea is to have a sequence of set-valued functions Fn
and initial sets Xn which converge to f and x0, respectively, such that under some
mild assumptions, the solution set of x˙ Fn(t, x), x(t0) X0 will converge to the solution of (1).
The technique sketched above was, for example, adapted in [15], to show com- putability of the solution for (1) if f is bounded or if its growth follows a very restricted condition which prevents, for instance, that this result can be applied to show computability of the solution of x˙ = x2, x(1) = 1 over (0, + ) (with unique solution x(t) = 1/t).
The results by Ruohonen have the desirable characteristic of not demanding f to be globally Lipschitz on its domain. While the latter condition ensures that a solution for (1) exists and is unique, it may be too strong as a requirement. This has already been noticed by mathematicians when establishing existence and uniqueness results for solutions of (1) in unbounded domains, where a Lipschitz condition usually doesn’t hold. To circumvent this problem, a possible approach is to require the Lipschitz condition to be satisfied only locally. In these conditions, the solution of (1) can be shown unique — see e.g. [4].
Following this reasoning, in [6], the authors introduce a notion of effectively locally Lipschitz functions and show that if f in (1) has this property, then the solution of (1) can be computed from f and x0 over the maximal interval of existence.

The existence of such maximal interval follows from standard results from the theory of ODEs, that ensure that when computing the solution of (1) one can extend it until the solution gets unbounded or reaches the boundary of region where f is defined. In particular, the results in [6] yield the (expected) computability of the solution of
the initial-value problem x˙ = −x2, x(1) = 1 over (0, +∞). The effectivity in this
definition is required in order that one might be able to pick for each compact set an appropriate Lipschitz constant to be used on the computation of the solution as soon as it reaches the aforementioned compact set.
In this paper we will prove that we can compute the solution of (1) requiring only that f is continuous and that (1) has a unique solution. We prove this result by giving an explicit algorithm based on the thousand monkey theorem — a thousand
monkeys 4 hitting keys at random on a typewriter keyboard will eventually type
a particular chosen text.  The idea is that we can approximate the solution of
x˙ = f (t, x), x(0) X0 from above with a union of boxes, with arbitrary precision. These boxes satisfy some relations between them, which only apply to this kind of covering, which can be effectively checked. Now we just need to use the thousand monkey theorem to run computations over n and corresponding finite sequences of boxes. We can check whether each sequence of boxes constitute a valid covering, and we know that such a covering approaching the solution of x˙ = f (t, x), x(0)  X0 with an arbitrary preassigned precision exists. Since, as we will see, the solution set of x˙ = f (t, x), x(0) Xn will converge to the solution of (1), it is enough to keep computing these sequences until we get a finite sequence of boxes which cover the solution at time t with the desired precision.
We give two versions of the algorithm. In the simpler version, which is sufficient to compute the solution of a locally Lipschitz differential equation, we bound the solution by a single box at all times. However, we give a counterexample demon- strating that this algorithm is not powerful enough to compute the solution of a non-Lipschitz differential equation even if the solution is unique. Instead, in the non-Lipschitz case we need to allow the solution bound to be a finite union of boxes, giving a slightly more complicated algorithm.
We now briefly sketch the contents of the paper. In Section 2 we present some standard results from ODEs, computable analysis, and Analysis that will support the main results of the paper. In Section 3 we show that our results are not a special case of those obtained in [6] since, as we will prove, there are computable functions which are locally Lipschitz (guaranteeing uniqueness of the solution), but not effectively locally Lipschitz. In Section 4 we prove that the solution of (1) can be computed provided f is continuous and the solution of (1) is unique. To achieve this result we present a first algorithm, that as we will see is not enough to compute the solution of (1), but will serve as a useful subroutine for a second algorithm that computes the desired solution.




4 actually, one (extremely long-lived) monkey suffices

Preliminaries
This section introduces concepts and results from the theory of ODEs, from com- putable analysis, and from Analysis. For more details the reader is referred to [4],
[9] for ODEs, and [12], [8], [16] for computable analysis.

Standard results from ODEs
We now recall some basic results concerning initial-value problems defined with ODEs. Let us consider the initial-value problem (1). The following theorem can be found in [7] (the expressions t  α+ and t  β− mean that t converges to α from above and to β from below, respectively).
Theorem 2.1 (Maximal interval of existence) Let E be a domain over Rm+1 and f : E  Rm be a continuous function. Let y be a solution of (1) on some interval. Then y can be extended (as a solution of (1)) over a maximal interval of existence (α, β). Also, if (α, β) is a maximal interval of existence, then y(t) tends to the boundary of E as t → α+ and t → β−.
In particular, if f satisfies a local Lipschitz condition in the second argument, this meaning that for each compact K E there exists some constant L > 0 such that
|f (t, x) − f (t, y)|≤ L|x − y| whenever (t, x), (t, y) ∈ K,
it can be shown [4], [9] that the maximal interval (α, β) is unique, and that (1) admits one and only one solution there.

Standard results from computability
We now continue our discussion with a presentation of fundamental concepts of computable analysis, which provides a notion of computability over the reals.
We define computability in terms of open rational boxes, which are sets of the form (a1, b1) × · · ·× (am, bm) ⊂ Rm where ai, bi ∈ Q for i = 1,..., m.  We could
equally use open rational balls B(a, r) = {x ∈ R : x − a < r}, where a ∈ Qm and
r ∈ Q with r > 0.
Definition 2.2
A name for a point x ∈ Rm is a sequence of nested open rational boxes (In)
such that ∩∞  In = {x}.
A name for an open set U ⊂ Rm is a sequence of open rational boxes (In) such
that In ⊂ U for all n ∈ N, and U =  ∞  In.
A name for a function f is a list of all pairs of open rational boxes (I, J) such that f (I) ⊆ J.
Definition 2.3 A point x Rm is computable if it has a computable name. An open set U  Rm is recursively-enumerable if it has a computable name. A function f is computable it has a computable name.

If Y and Z are spaces with an associated naming system, then an operator F : Y → Z is computable if there is a computable function which associates each name of y ∈ Y to a name of F (y) ∈ Z.
The following definition was introduced in [6], and gives a computable counter- part for the notion of a function which is locally Lipschitz in the second argument.
Definition 2.4 Let E =  ∞  B(an, rn) ⊆ Rm be a recursively enumerable open
set, where an ∈ Qm and rn ∈ Q yield computable sequences satisfying B(an, rn) ⊆
A function f : E → Rm is called effectively locally Lipschitz in the second argument if there exists a computable sequence {Kn} of positive integers such that

|f (t, x) − f (t, y)|≤ Kn |y − x| whenever (t, x), (t, y) ∈ B(an, rn).

The following result was proved in [6].
Theorem 2.5 Let E  Rm+1 be a recursively enumerable open set and f : E  Rm be an effectively locally Lipschitz function in the second argument. Let (α, β) be the maximal interval of existence of the solution x(t) of the initial-value problem (1), where (0, x0) is a computable point in E. Then:
The operator (f, x0)  (α, β) is semicomputable (i.e. α can be computed from above and β can be computed from below), and
The operator (f, x0) '→ x(·) is computable.

Standard results from analysis
In this section we state two classical theorems that are the main tools in finding solutions of differential equations.
Theorem 2.6 (Arzela-Ascoli) Let ξn be a sequence of uniformly equicontinuous functions X → Y , where X and Y are locally-compact Hausdorff spaces. i.e. ∀ϵ > 0, ∃δ > 0 ∀n ∈ N, x,y ∈ X, d(x, y) < δ =⇒ d(ξn(x), ξn(y)) < ϵ. Then there is a subsequence ξnk which converges uniformly to a continuous function ξ∞.
Theorem 2.7 (Banach-Alaoglu) Let X be a Banach space and X∗ the dual space with the weak-* topology. i.e. the topology generated by open sets of the form g  X∗ : g(x)  f (x) < ϵ for f  X∗, x  X and ϵ > 0. Then X∗ is locally compact.
In particular, since L∞ is the dual of L1, the closed unit ball in L∞ is compact. Combining the above results, we obtain the following corollary.
Corollary 2.8 Suppose f is a continuous function and ξє are absolutely continuous functions satisfying ||ξ˙є(t) − f (ξє(t))|| < ϵ for all t ∈ [0,T ]. Then any limit point of the functions ξє as ϵ → 0 is a solution of the differential equation x˙ = f (x).



Fig. 1. A spike function.
A computable, non-effectively locally Lipschitz func- tion
Before presenting our main result of this section, we start with a Lemma. Its proof can be obtained using material from [14].
Lemma 3.1 There exists a function S : N → N and a computable function u :
N2 → N such that:
For any given computable function f : N	N, there exist inﬁnitely many n	N
for which S(n) > f (n). In particular, S is non-computable.
for any given n ∈ N, one has limi→+∞ u(n, i) = S(n) and u(n, i) ≤ S(n) for every i ∈ N.
We now provide a brief sketch of an example of a computable function which is locally Lipschitz, but not effectively so. First, for λ ∈ R+, where R+ = [0, +∞),
we define a “spike” function gλ : R  R as depicted in Fig. 1. The function gλ is always 0, except in some interval, where it increases with slope λ, until it reaches half-way of the interval, and then decreases with slope  λ giving origin to
a “spike”, centered on the midpoint of that interval. We now define a sequence of computable functions fi i≥1 such that, on each interval [n, n + 1), fi is constituted by i + 1 spikes, in intervals of the format [n, n + 1/2], [n + 1/2,n + 3/4],... , with slopes u(n, 0),..., u(n, i), where u is defined in Lemma 3.1. It can be seen that the height of the spikes decrease proportionally to 2−i. Moreover fi and fi+1 have the same first i spikes, the difference being that fi+1 has an extra spike with height
proportional to 2−i−1. This shows that the sequence fi i≥1 converges uniformly
to a computable function f with the property that in the time interval [n, n + 1) it has infinitely many decreasing spikes, with slopes u(n, 0), u(n, 1),... .
The function f is locally Lipschitz: on an interval [n, n + 1], with n N, it satisfies
|f (x) − f (y)|≤ Kn |x − y|
iff Kn ≥ limk→+∞ u(n, k) = S(n), where the function S is defined in Lemma 3.1. In
general, |f (x) − f (y)| ≤ K |x − y| for a compact B ⊆  m [ai, ai + 1), with ai ∈ N,

where

K ≥ max({Kai |ai ≥ 0}).

Let us show that f is not effectively locally Lipschitz on R. Suppose, for contradic- tion, that there are computable sequences {an} and {rn}, an ∈ Q and rn ∈ Q such

that


∞
R =	B(an, rn)
n=0

and a computable sequence {Ln} of positive integers such that

|f (x) − f (y)|≤ Ln |x − y| whenever x, y ∈ B(an, rn).

Then we show that we will be able to present a computable function g : N → N which satisfies g(n) ≥ S(n) for all n ∈ N, thus deriving the desired contradiction. How can we compute g(n) for an arbitrary n ∈ N? First notice that [n, n + 1] is a compact set. Thus there must exist n1,..., nk ∈ N such that

k
[n, n + 1] ⊆	B(anj , rnj )	(2)
j=1

If we can compute the values n1,..., nk ∈ N satisfying (2), then we can take

g(n) = max Ln	S(n).
1≤j≤k

The remaining issue is to compute the values n1,..., nk	N satisfying (2). We can do that with the following algorithm:
Start with k = 1.
Check if
k
[n, n + 1] ⊆	B(ai, ri).
i=0
If yes, return 1,..., k, else increment k and go to Step (ii).
Notice that this algorithm always stops. Thus the result is proven. The above algorithm could certainly be improved to discard those balls which provably do not overlap [n, n + 1], but this is not necessary for our construction and therefore we avoid this step in order to prevent unneeded technical complications.
We thus have proved the following result.
Theorem 3.2 There is a computable function f : R	R which is locally Lipschitz, but not effectively so.
In particular, this also yields the following obvious corollary, which is more related to Theorem 2.5 since it proves that it cannot always be used when f is locally Lipschitz in the second variable.
Corollary 3.3 There is a computable function f : R	Rm	Rm which is locally Lipschitz in the second argument, but not effectively so.

Computing the Solution of Ordinary Differential Equations
We now consider the computation of the solution of an ordinary differential equation. We give two algorithms to compute the solution, the former of which is simpler and the latter more general. Both algorithms rely on an exhaustive enumeration of trial “runs” of the system; each run is then checked to see if it gives a valid bound for the solution set. In this way, we can compute bounds on the solution without a knowledge of Lipschitz constants or moduli of continuity. Of course, the resulting algorithms are highly inefficient in practice; the motivation for introducing them is their conceptual simplicity.
Without loss of generality, we suppose that f does not depend on the variable t (if this is true, just encode t as a new variable τ by adding the extra component τ˙ = 1, τ (0) = 0 to the system).
We obtain from our algorithms the following slight extension of the main result of Ruohonen [15].
Theorem 4.1 Consider the initial value problem
x˙ = f (x);	x(0) = x0,	(3)

where f is continuous on the open set E. Suppose there is a unique solution y(·), deﬁned on the maximal interval (α, β), such that y(t) ∈ E for each t ∈ (α, β). Then:
The operator (f, x0)	(α, β) is semicomputable (i.e. α can be computed from above and β can be computed from below), and
The operator (f, x0) '→ y(·) is computable.
In particular, if f is a computable function and x0 a computable point, then (α, β)
is a r.e. open set and the solution y(·) is a computable function.

The Thousand Monkeys Algorithm
We now present a first algorithm, that will give the support for the algorithm of the next subsection, which proves Theorem 4.1. The former algorithm proves the case where f is locally Lipschitz, but is not sufficient to prove Theorem 4.1 in complete generality, since we cannot compute the solution of a non-Lipschitz ordinary differential equation, even if the solution is unique, as we will see.
The idea underlying this algorithm is to enclose the solution at times ti by a box Xi. Since the solution of (1) is unique, there are covers which are arbitrarily close to the solution. In the time interval [ti, ti+1] we enclose the solution curve by a box Bi, and the derivative vectors in a box Ci. We can enumerate all sequences of times ti (actually, we use time differences hi = ti+1  ti) and boxes Xi, Bi and Ci, and test if they contain the solution.
We use the notation A  B if A¯  B◦ i.e. the closure of A is a subset of the interior of B.

Algorithm 4.2 Enumerate all tuples of the form
 (Xi)k  , (hi)k−1, (Bi)k−1, (Ci)k−1	(4)
where k	N, the X , B and C are rational boxes and h	Q. Deﬁne t  = 0 
and ti = Σi−1 hi for i = 1,..., k. We call a tuple of the form (4) a run of the
algorithm.
A run of the algorithm is said to be valid if x0 ∈ X0 and for all i = 0,...,k − 1:
f (Bi)  Ci,
Xi ∪ Xi+1 ⊂ Bi, and
Xi + hiCi ⊂ Xi+1.

Note that condition (i) is effectively veriﬁable since the pairs (I, J) such that f (I)
J is enumerated in a name of f, and conditions (ii,iii) can be checked algebraically. The algorithm works by launching computations of each of the countably many possible runs in parallel, and testing for validity. Whenever a run is shown to be
valid, that run is written to the output.
The following result shows that any valid run of the algorithm provides bounds on the solution.
Proposition 4.3 Let f be a continuous function, and ξ( ) be the unique solution of the initial value problem x˙ = f (x); x(0) = x0. Then if (Xi, hi, Bi, Ci) is a valid run of Algorithm 4.2, we have ξ(ti) ∈ Xi for all i = 0,..., k, and ξ(t) ∈ Bi whenever ti ≤ t ≤ ti+1.
Proof. [Sketch] For any valid run we have ξ(t0) = x0 ∈ X0. Suppose ξ(ti) ∈ Xi. Let hi,max = sup{h ≤ hi | ξ(t + h) ⊂ Bi}. Then ξ˙(t) ∈ Ci for t ∈ [ti, ti + hi,max], so ξ(t) ∈ Xi + [0, h]Ci  Bi. Therefore hi,max = hi, so ξ(t) ∈ Bi for t ∈ [ti, ti+1] and ξ(ti+1) ∈ Xi + hiCi ⊂ Xi+1. The result follows by induction.	 
Theorem 4.4 Let f be a locally Lipschitz function, and ξ( ) be the unique solution of the initial value problem x˙ = f (x); x(0) = x0. Let U be a neighbourhood of x(T ). Then there is a valid run of the thousand monkeys algorithm such that tk < T < tk+1 and Bk ⊂ U.
Proof. [Sketch] Let K be such that f (ξ(t)) < K for all t [0,T ]. Let L be a Lipschitz constant for f on a neighbourhood W of ξ([0,T ]). Fix δ < Lϵ/2(eLT  1) and h < δ/KL, where ϵ is the precision to which we would like to compute the solution. Suppose X is such that rad(X) < r. Then the solution over time step h lies in a box B of radius less than r + hK of the centre x of X. Then f (B) lies in a box C of radius less than (r + hK)L in U . Then X + hC lies in a box Y of radius r' less than r + (r + hK)Lh = (1 + Lh)r + KLh2.
Since h < δ/KL, we have r' < (1 + Lh)r + δh. If we now take X0 of radius r0, we can find Xn of radius rn < r0(1 + Lh)n + δ (1 + Lh)n − 1 /L. By taking r0 < ϵ/2eLT , we have for n ≤ T/h, that rn < δ(eLT − 1)/L < ϵ.
Since the Thousand Monkeys Algorithm enumerates over all rational boxes and

step sizes, we eventually find (Xi, hi, Bi, Ci) such that rad(Xi) < ri < ϵ for all i, and hence rad(Bi) < ϵ + hiK. Therefore for ϵ and hi sufficiently small, we have ξ(T ) ∈ Bk ⊂ U .	 
However, it is not true that the Thousand Monkeys algorithm can compute the solution of a non-Lipschitz ordinary differential equation, even if the solution is unique.
Example 4.5 Consider the ordinary differential equation x˙ = f (x) in R2 defined

in polar coordinates by

r˙ =
√r (cos θ − 1/2);

(5)

θ˙ = 1/√r.
In Cartesian coordinates, the system becomes


˙ = ( 2 +

2)1/4	x2
 y + x/2   ;

x	x	y	− √x2 + y2
x2 + y2

(6)

y	x2 + y2
√x2 + y2
2√x2 + y2

Since (x2 + y2)1/4	0 as x, y	0, and the other factors in the expression for x˙ and y˙ are bounded, we see that the right-hand side is continuous. We claim that

The initial value problem x˙ (0, 0) for all t, and
= f (x); x(0) = (0, 0) has unique solution x(t) = 

For any run of the Thousand Monkeys Algorithm, the solution estimate X(1) contains the point (1/4, 0).
For (i), suppose that the solution leaves the origin. Then it spirals round ex- tremely rapidly, with r increasing if θ < π/3 and decreasing otherwise. Since the average decrease of r per revolution exceeds the average increase, the state is pulled back to the origin immediately. Hence the only solution starting at the origin is the constant solution.
For (ii), suppose that an approximation to the solution is a box X containing the point (x, 0). Then f (X) contains the value (√x/2, y˙) and also (0, 0), so the box C contains (√x/2, 0). Since the initial box X(0) contains a point (x0, 0), then the box at time t, X(t), must contains a point x(t) solving x˙ = √y/2, x(0) = x0. From
this we can show that the point (1, 0) lies in the solution box X(1), regardless of the
value of x0 > 0. Hence the solution computed by the Thousand Monkeys algorithm does not converge to the true solution.

The Thousand Monkeys Algorithm with Subdivision
The following algorithm is called the Thousand Monkeys Algorithm with subdivision (TMS), and proves Theorem 4.1, because it computes the solution of (3) and gives a succession of time values which converge to β from below and, similarly, we could show that α is computable from above.

The idea of this algorithm is similar to Algorithm 4.2, but instead of enclosing the solution at time ti by a single box, we instead use a finite union of boxes,

li j=1
Xi,j. During the ith time step, we enclose the solution starting in Xi,j by a

box Bi,j, and find a box Yi,j containing this solution. At time ti+1, we use a different

subdivision  li+1 Xi+1,j equal to  li
Yi,j .

Algorithm 4.6 Enumerate all tuples of the form (Xi,j, hi, Bi,j, Ci,j, Yi,j) for i = 0,...,k	1, j = 1,..., l where k, l	N, X  , B  , C	are rational boxes and
hi ∈ Q. Such a tuple is a run of the algorithm. Deﬁne ti = Σi−1 hi for i = 0,..., k.
A run of the algorithm is said to be valid if x0 ∈  l0	X0,j and for all i =
0,...,k − 1 and j = 1,..., li, we have
f (Bi,j)  Ci,j;
Xi,j ∪ Yi,j ⊂ Bi,j;
Xi,j + hCi,j ⊂ Yi,j;

li
Yi,j =  li+1 Xi+1,j.

Just as in Algorithm 4.2, we enumerate all runs and verify whether a run is valid. The output is the inﬁnite sequence of all valid runs.


Theorem 4.7 Suppose the initial value problem x˙ = f (x); x(0) = x0 has a unique solution ξ(·) on [0,T ]. Then for all open U containing ξ(T ), there exists a run of
Algorithm 4.6 such that tk < T < tk+1 and  lk	Bk,j ⊂ U.


Proof. [Sketch] Let W be a bounded neighbourhood of ξ([0,T ]), let K be such that ||f (x)|| < K for all x ∈ W and let δ(·) be a modulus of continuity for f in W .
Define Xi =  li	Xi,j for i = 0,..., k, similarly for sets Bi, Ci and Yi.
Fix ϵ > 0 and a time step h < δ(ϵ)/K. If all the sets Xi,j each have radius less than δ(ϵ) hK, then the sets Bi,j can be chosen with radius less than δ(ϵ), and Ci,j with radius less then ϵ.
Consider a run of the algorithm such that the sets Ci,j each have radius less than ϵ, and that Xi,j + hCi,j = Yi,j. Define functions η by η(t0) ∈ X0, and for ti < t  ti+1 by η(t) = ξє(ti+1) = η(ti)+ (t  ti)ci for some ji such that η(ti)  Xi,ji and ci Ci,j Then η is a piecewise-affine function, and η˙(t) f (η(t)) < 2ϵ for almost every t. Further, given any yi Xi, we can construct such a function η with η(ti) = yi.
Taking any sequence of functions ξn corresponding to a sequence ϵn with ϵ 0, by Corollary 2.8, we see that ξn converges uniformly to a solution of the differential equation x˙ = f (x). Since the solution of the equation is unique, there are runs of the algorithm such that ti < T < ti+1 and hi, rad(Xi) and rad(Yi) are arbitrarily small. We then easily see that rad(Bi) can be taken arbitrarily small, and hence Bi ⊂ U as required.	 

Conclusion
We have shown that we can compute the solution of the initial-value problem for ordinary differential equations with continuous right-hand side, if the solution is assumed unique. We presented algorithms for the computation of the solution using the “thousand monkeys” approach. In this way, we have shown that the solution of a differential equation defined by a locally Lipschitz function is computable even if the function is not effectively locally Lipschitz, a situation which can happen, as we have seen.
Interesting directions for further work are to extend the results of [13], which proves the computability of solution set for Lipschitz differential inclusions, without requiring the Lipschitz constant, or with weaker conditions on the right-hand side.

References
O. Aberth. Computable analysis and differential equations. In A. Kino, J. Myhill, and R.E. Vesley, editors, Intuitionism and Proof Theory, Studies in Logic and the Foundations of Mathematics, pages 47–52. North-Holland, 1970.
O. Aberth. The failure in computable analysis of a classical existence theorem for differential equations.
Proc. Amer. Math. Soc., 30:151–156, 1971.
O. Aberth. Computable Analysis. McGraw-Hill, 1980.
E. A. Coddington and N. Levinson. Theory of Ordinary Differential Equations. McGraw-Hill, 1955.
G. Gabor. Continuous selection of the solution map for one-sided lipschitz differential inclusions.
Nonlinear Anal., 66(5):1185–1197, 2007.
D.S. Gra¸ca, N. Zhong, and J. Buescu. Computability, noncomputability and undecidability of maximal intervals of IVPs. Trans. Amer. Math. Soc., 2007. To appear.
P. Hartman. Ordinary Differential Equations. Birkh¨auser, 2nd edition, 1982.
K.-I Ko. Computational Complexity of Real Functions. Birkh¨auser, 1991.
S. Lefshetz. Differential Equations: Geometric Theory. Interscience, 2nd edition, 1965.
R. E. Moore. Interval Analysis. Prentice-Hall, 1966.
M. B. Pour-El and J. I. Richards. A computable ordinary differential equation which possesses no computable solution. Ann. Math. Logic, 17:61–90, 1979.
M. B. Pour-El and J. I. Richards. Computability in Analysis and Physics. Springer, 1989.
A. Puri, V. Borkar, and P. Varaiya. Epsilon-approximation of differential inclusions. In Proc. of the 34th IEEE Conference on Decision and Control, pages 2892–2897, 1995.
T. Rad´o. On non-computable functions. J. Bell Systems Tech., 41:877–884, 1962.
K. Ruohonen. An effective Cauchy-Peano existence theorem for unique solutions. Internat. J. Found. Comput. Sci., 7(2):151–160, 1996.
K. Weihrauch. Computable Analysis: an Introduction. Springer, 2000.
