Electronic Notes in Theoretical Computer Science 167 (2007) 79–93	
www.elsevier.com/locate/entcs

Schnorr Trivial Reals: A construction
Johanna N.Y. Franklin1 ,2
Group in Logic and the Methodology of Science University of California, Berkeley
Berkeley, CA

Abstract
A real is Martin-L¨of (Schnorr) random if it does not belong to any effectively presented null Σ0 (recursive) class of reals. Although these randomness notions are very closely related, the set of Turing degrees containing reals that are K-trivial has very different properties from the set of Turing degrees that are Schnorr trivial. Nies proved in [11] that all K-trivial reals are low. In this paper, we prove that if h is a high degree, then every degree a ≥T h contains a Schnorr trivial real. Since this concept appears to separate computational complexity from computational strength, it suggests that Schnorr trivial reals should be considered in a structure other than the Turing degrees.
Keywords: randomness, lowness, triviality, Schnorr trivial real


Preliminaries
A real is an element of 2ω, and a tree is a subset of 2<ω that is closed under substrings. The set of all infinite branches through a tree T will be represented by [T ], and the set of all τ ∈ 2<ω extending a binary string σ will be represented by [σ].
Throughout this paper, μ will represent Lebesgue measure.
Definition 1.1 A Turing machine M is preﬁx free if all distinct σ and τ in dom(M) are incomparable. A prefix-free Turing machine U is universal if for

1 This material is based upon work supported under a National Science Foundation Grad- uate Research Fellowship.
2 Email: franklin@math.berkeley.edu





1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.008

each prefix-free machine M, there is some τ ∈ 2<ω such that
(∀σ ∈ 2<ω)[U (τ -σ)= M(σ)].
Such a machine can easily be constructed by taking an effective list ⟨Mi⟩i∈ω
of all Turing machines and setting U (1i0-σ)= M(σ).
We will only use prefix-free Turing machines. Whenever the measure of a component of a Turing machine is discussed, it is always the domain. There- fore, we will write μ(M) for μ(dom(M)). Note that for a prefix-free machine, μ(M)= Σσ∈dom(M )  1  .
When the machine is unspecified, a universal Turing machine is used. Note that the particular universal Turing machine is irrelevant up to an additive constant.
Definition 1.2 We say that a Turing machine M is computable if the measure of its domain is a recursive real.
Definition 1.3 Let M be a Turing machine, and let σ ∈ 2<ω. The preﬁx-free complexity of σ with respect to M is KM (σ)= min{|τ || M(τ )= σ}.

Martin-Lo¨f randomness, lowness, and triviality
Before we begin analyzing the reals that are “far from Schnorr random,” we review what is known for the most studied notion of randomness, Martin-Lo¨f randomness.
Definition 2.1 A Martin-L¨of test is a uniformly r.e. sequence ⟨Vi⟩i∈ω of Σ0 classes such that μ(Vi) ≤  1 . A real A is Martin-L¨of random if for all Martin- L¨of tests ⟨Vi⟩i∈ω, A /∈ ∩i∈ωVi.
Martin-L¨of proved that there is a universal Martin-Lo¨f test; i.e., a Martin- L¨of test ⟨Ui⟩i∈ω such that a real A is Martin-L¨of random if and only if A /∈
∩i∈ωUi [9].
Theorem 2.2 [13,1] A is Martin-Lo¨f random if and only if (∃c ∈ ω)(∀n ∈
ω)[K(A T n) ≥ n − c].
It can be seen easily from the Martin-L¨of test definition of Martin-Lo¨f randomness that the Martin-Lo¨f random reals form a Π0 class. Therefore, we can apply the Low Basis Theorem and the Hyperimmune-free Basis Theorem to obtain a low Martin-Lo¨f random real and a hyperimmune-free Martin-Lo¨f random real, respectively. Among the results about the Turing degrees of Martin-L¨of random reals is the following theorem due to Kuˇcera.

Theorem 2.3 [8] If a > 0', then a is Martin-Lo¨f random.
We now turn our attention to the reals that are “far from Martin-Lo¨f random.” As with most types of randomness, we can develop a notion of relative Martin-Lo¨f randomness. Such a reducibility can then be used to define a triviality notion.
Definition 2.4 [5] A ≤K B if (∃c ∈ ω)(∀n ∈ ω)[K(A T n) ≤ K(B T n)+ c].
A is K-trivial if (∃c ∈ ω)(∀n ∈ ω)[K(A T n) ≤ K(0n)+ c].
Another way in which a real A can be “far from Martin-Lo¨f random” is if relativizing a definition of Martin-Lo¨f randomness to A generates the same class of sets. There are two ways in which this has been done.
Definition 2.5 Let ML be the class of Martin-Lo¨f-random sets. A real A is
low for K if MLA = ML; i.e., (∃c ∈ ω)(∀σ ∈ 2<ω)[K(σ) ≤ KA(σ)+ c].
Definition 2.6 A real A is low for Martin-Lo¨f tests if for every Martin- L¨of test relative to A ⟨UA⟩i∈ω, there is a Martin-L¨of test ⟨Vi⟩i∈ω such that
∩i∈ω UA ⊆ ∩i∈ω Vi.
We immediately note that the existence of a universal Martin-Lo¨f test implies that a real is low for K if and only if it is low for Martin-L¨of tests. In fact, it has been shown by Nies that all three of these notions coincide for Martin-L¨of randomness.
Theorem 2.7 [11] A is low for Martin-Lo¨f randomness if and only if A is low for Martin-Lo¨f tests if and only if A is K-trivial.
Chaitin was the first to show that all K-trivial reals are Δ0 [2], and Downey, Hirschfeldt, Nies, and Stephan showed that such reals cannot be high [5]. Later, Nies proved the following theorem.
Theorem 2.8 [11] The K-trivials form a nonprincipal Σ0 ideal in the ω-r.e. Turing degrees. This ideal is generated by its r.e. members. Furthermore, each K-trivial A is such that A' ≡tt 0' (A is superlow).
The three notions described above have been generalized to randomness notions other than Martin-Lo¨f randomness. We define low for R, low for R- tests, and R-trivial for an arbitrary notion of randomness R and then discuss their connections to each other.
Definition 2.9 A real A is low for R if R = RA.
Definition 2.10 A real A is low for R-tests if for every R-test relative to A
⟨UA⟩i∈ω, there is a R-test ⟨Vi⟩i∈ω such that ∩i∈ωUA ⊆ ∩i∈ωVi.
i	i

Definition 2.11 A real A is R-trivial if A ≤R 0ω, where ≤R is R’s notion of relative computational complexity.
Clearly, if A is low for R-tests, it is low for R. However, it is not obvious that either lowness notion is related to triviality.

Schnorr randomness, lowness, and triviality — Pre- vious results
Schnorr randomness is a more effective version of Martin-L¨of randomness. A Schnorr test is simply an effectively given Martin-L¨of test:

Definition 3.1 A Martin-L¨of test is a Schnorr test if μ(Vi)=  1
for all i. A

real A is Schnorr random if for all Schnorr tests ⟨Vi⟩i∈ω, A /∈ ∩i∈ωVi.
There is no universal Schnorr test. Therefore, we cannot use a univer- sal Turing machine to define Schnorr randomness in terms of computational complexity. Instead, we must quantify over all computable Turing machines.
Theorem 3.2 [4]A real A is Schnorr random if and only if (∀M comp.)(∃c ∈
ω)(∀n ∈ ω)[KM (A T n) ≥ n − c].
It is clear that all Martin-L¨of-random reals are also Schnorr random, but this implication is not reversible. In fact, Nies, Stephan, and Terwijn showed that these concepts are separable in the high degrees [12].
Downey, Griffiths, and Laforte developed the following characterization of Schnorr triviality in [3]. They began by defining a notion of Schnorr reducibil- ity.
Definition 3.3 [3] We say that A ≤Sch B if for every computable Turing machine M, there is a computable Turing machine M ' and a constant c ∈ ω such that (∀n ∈ ω)[KM' (A T n) ≤ KM (B T n)+ c]. Therefore, a real A is Schnorr trivial if the following statement holds.
(∀M comp.)(∃M comp.)(∃c ∈ ω)(∀n ∈ ω)[KM' (A T n) ≤ KM (0 )+ c] Downey, Griffiths, and Laforte have proved that there is a Turing complete
Schnorr trivial real, but that there is an r.e. degree that contains no Schnorr trivial reals [3]. While this shows that the Schnorr trivial Turing degrees are not downward closed, the Schnorr trivial tt-degrees are downward closed [3]. The work done with reals that are low for Schnorr to date has produced an entirely degree-theoretic characterization. Let Dn denote the nth canonical
finite set.

Definition 3.4 A set A is recursively traceable if there is a recursive, increas- ing, unbounded function p : ω −→ ω as follows.

(∀f ≤T A)(∃r : ω −→ ω rec.)(∀n ∈ ω)[f (n) ∈ Dr(n) and |Dr(n)|≤ p(n)]
In short, a real is recursively traceable if it is uniformly hyperimmune free. We say that r is a recursive trace and p is a bound for a recursive trace for every f ≤T A.
The first result on reals that are low for Schnorr comes from Terwijn and Zambella [14]. Later, Kjos-Hanssen, Nies, and Stephan used a similar tech- nique to demonstrate that, given Terwijn and Zambella’s result, the reals that are low for Schnorr randomness are precisely the reals that are low for Schnorr tests [7].
Theorem 3.5 [14] A set is recursively traceable if and only if it is low for Schnorr randomness.
Theorem 3.6 [7] A set is recursively traceable if and only if it is low for Schnorr tests.
Although the reals that are low for K are precisely those that are K-trivial, being low for Schnorr is not equivalent to being Schnorr trivial. All reals that are low for Schnorr are hyperimmune free, and there is a Turing complete Schnorr trivial. This Schnorr trivial is clearly not hyperimmune free and is thus not Schnorr low. The best that can be hoped for is that all Schnorr lows are Schnorr trivial. In another publication, we will show that this is, in fact, the case [6].
In [14], Terwijn and Zambella also demonstrated that there is a perfect set of Schnorr lows by showing that Miller and Martin’s construction in [10] produces only recursively traceable sets.

Schnorr trivial reals: The basic construction
Theorem 4.1 Let h be a high degree; i.e., h' ≥T 0''. Every degree a ≥T h
contains a Schnorr trivial.
The proof of this theorem requires, for every high degree h, the construc- tion of a perfect binary tree T recursive in h such that every branch of T is Schnorr trivial and every A ∈ 2<ω is encoded by some branch of T .
We note that Terwijn and Zambella’s perfect set of Schnorr lows is also a perfect set of Schnorr trivials. However, since it consists entirely of

hyperimmune-free degrees, a new construction is necessary to prove Theorem 4.1.
Theorem 4.2 There is a perfect set of Schnorr trivials.
The following facts will be necessary for the proof.
Theorem 4.3 (Kraft-Chaitin Theorem [1]) Let ⟨di, σi⟩i∈ω be a recursive
sequence with di ∈ ω and σi ∈ 2<ω for all i such that Σi  1  ≤ 1. (Such
a sequence is called a Kraft-Chaitin set, and each element of the sequence
is called a Kraft-Chaitin axiom.) Then there are strings τi and a preﬁx-free machine M such that |τi| = di and M(τi)= σi.
The Kraft-Chaitin Theorem allows us to construct a prefix-free machine by specifying only the lengths of the strings in the domain rather than the strings themselves. We will therefore identify ⟨τ, σ⟩ with ⟨d, σ⟩ where d = |τ | throughout.
Within the proof, we will consider an arbitrary computable machine. We introduce the following terminology to simplify the construction.
Definition 4.4 Let M be a computable machine. We say that a real A is
Schnorr trivial with respect to M if the following condition holds.
(∃M comp.)(∃c ∈ ω)(∀n ∈ ω)[KM' (A T n) ≤ KM (0 )+ c]
As demonstrated by Downey and Griffiths [4], we may consider only com- putable machines with domain 1. In fact, it should be noted that for every computable machine, there are infinitely many equivalent computable ma- chines with domain 1.
We say that σ ∈ M for σ ∈ 2<ω and a Turing machine M when there is a
τ ∈ 2<ω such that ⟨τ, σ⟩∈ M.
Proof. [Theorem 4.2] We build a perfect tree of Schnorr trivials by construct- ing a sequence of recursive trees Ti ⊇ Ti+1 such that each branch of Ti is Schnorr trivial with respect to the computable machine Mi for a given listing
⟨Mi⟩i∈ω of computable machines with domain 1.
We first illustrate the construction of the tree by describing the construc- tion for a single component. Let M be a computable machine with domain
1. We wish to build a perfect binary tree T such that every branch B of T is Schnorr trivial with respect to M.
Remark 4.5 Throughout the construction, note that, while we are building our T within 2<ω, we could easily build it within any recursive tree S.

To do so, we divide M’s domain into pieces of size approximately  1 
for

k ≥ 1. At step k, we increase the height of the components of our tree up
to the height of the longest string of 0s in M appearing by the first stage at which μ(M) ≥ 1 −  1 . We then add appropriate amounts of measure to all the strings in our tree of the appropriate heights to build another computable machine M' which demonstrates the Schnorr triviality of all branches of T with respect to M thus far. Then we insert a branching point in the tree in such a way as to ensure that the tree is perfect.
We will distinguish between the stages in the construction of the machine M we are using and the stages in our own construction of the tree T and the machine M '. Each stage k in our construction will correspond to the stages sk−1 < s ≤ sk in the construction of M. We will refer to the latter as M-stages and to the former simply as stages.
We define two sequences of natural numbers that are recursive in M and thus simply recursive. The first is ⟨sk⟩k∈ω, where sk is the least M-stage s such that μ(Ms) ≥ 1 −  1 . The second is ⟨nk⟩k∈ω, where nk = max{|σ|| σ ∈ Ms }.
2k	k
k = 0: Clearly, s0 =0 and n0 = 0. We define M ' = ∅ and T0 = 2<ω.
k = 1: We consider each s for s0 < s ≤ s1. If an axiom ⟨d, τ ⟩ enters M at M-stage s, we add ⟨d + 1, 1|τ|⟩ to M'. Note that in particular, whenever an axiom of the form ⟨d, 0n⟩ enters M, the pair ⟨d + 1, 1n⟩ enters M'. After the M-stage s1, we define M' to be the set of Kraft-Chaitin axioms enumerated
-	-
into M' thus far. Now let σ be the string 1n1 . We define T1 = [σ 0] ∪ [σ 1].
At this point, we have completely determined the tree up to height n1 +1, and we have two branches below this height.
k > 1: We consider each s for sk−1 < s ≤ sk. We let Σ = {σ1,... , σk} be the set of the longest elements of Tk−1 already determined; i.e., the set of elements of length nk−1 + 1. (There are precisely k, as we create one new branching point at each stage.) Suppose ⟨d, τ ⟩ enters M at M-stage s and define n = |τ |.
Case 1: n ≤ nk−1 + 1. For all σ ∈ Tk−1 such that |σ| = n, we add ⟨d+1, σ⟩ to M ' at M-stage s. There will be l many such σ for some l ≤ k, so we add ⟨d + 1, σ'⟩ to M' an additional k − l times, where σ' is the leftmost

σ ∈ Tk−1 such that |σ| = n. Note that we have added  l  +  k−l
=  k 

to μ(M ').
2d+1
2d+1
2d+1

Case 2: n > nk−1
+ 1. For all σi
∈ Σ, we add ⟨d + 1,σ -1n−|σi|⟩ to M' at

M-stage s. This time there will be k many such σi, so we have added
 k  to μ(M ').
This gives us M' . For each successive interval of 1  in μ(M), we add no
k	2k
more than  k  to μ(M '). We may add less because our last step may have

increased the measure of M more than  1 .
Now we define Tk.


Tk = [σϕ	'
-1]

where σϕ is the unique σ such that |σ| = nk, σ ∈ M' , and ϕ(σ) holds, where ϕ(σ) is true if and only if σ extends the branch immediately to the left of the branch extended with a 0 at the last stage, or, if there is no such branch, the rightmost branch. Note that since σϕ is unique, the number of branches increases by one in every stage. This condition also ensures that the tree is perfect.
Let T = ∩k∈ωTk and M' = ∪k∈ωM' . T is clearly a recursive perfect tree.
Lemma 4.6 M' is a Kraft-Chaitin set.
Proof. We must first demonstrate that the elements of M' can be found recursively. Suppose we wish to know whether ⟨d, σ⟩ is in M'. If it is, we will find out because the elements of M' form an r.e. set. We wait until stage sd.
At this point, there is ≤  1  remaining in the domain of M, so ⟨b, τ ⟩ cannot
enter M for any b < d and any τ . Therefore, ⟨b + 1, σ⟩ cannot enter M ' for any b +1 < d + 1, and if ⟨d, σ⟩ is not in M ' after stage d, it is not in M' at all.
Finally, we must show that Σi∈ω  1  ≤ 1. We know that μ(M)= 1. During stage k, if ⟨d, σ⟩ enters M, ⟨d + 1,τ ⟩ enters M' for k many τ . Then, when  1 
enters μ(M),	k  enters μ(M '). Therefore, μ(M ') ≤ Σk∈ω  k  = 1.	 

2k+1
Lemma 4.7 μ(M ') is a recursive real.
2k+1

Proof. During each stage k, approximately  1  enters μ(M). We may add less

if μ(Ms

k−1
) is strictly greater than 1 −  1 . However, we can always calculate

the amount of measure that has entered M by the end of stage k recursively.
Since we add  k  to M ' every time an axiom of the form ⟨d, τ ⟩ enters M, we can make a similar calculation for M'.
After stage k, no more than  1  will enter M, so no more than Σ	 j 

2k
can be added to dom(M '). We can therefore use the inequality
j>k 2j+1

|μ(M ') − μ(M ' )|≤ Σ	j
k	j>k 2j+1
to see that μ(M ') is a recursive real.	 
Therefore, by Lemmas 4.6 and 4.7, we may take M ' to be a computable Turing machine.
Lemma 4.8 M ' witnesses the Schnorr triviality of each branch of T with respect to M.

Proof. Let B ∈ [T ], and let n ∈ ω. If KM (0n) = ∞, we automatically have KM' (B T n) ≤ KM (0 ) + 1. Otherwise, suppose that d is the least integer such that ⟨d, 0n⟩ ∈ M, so d = KM (0n). Our construction guarantees that ⟨d + 1, σ⟩ ∈ M' for each σ of length n in our tree T , including B T n. Therefore, KM' (B T n) ≤ d +1 = KM (0 ) + 1. This is enough to show that the machine M' and the constant 1 witness the Schnorr triviality of B with respect to M.	 
Now that we have produced a perfect tree with all branches Schnorr trivial with respect to a single computable machine M, we produce a perfect tree with all branches Schnorr trivial (with respect to all computable machines) using our listing ⟨Mi⟩i∈ω of computable machines with domain 1.
For each i ∈ ω, we build a tree Ti and a machine M' such that Ti ⊇ Ti+1
and (∀A ∈ [Ti])(∀n ∈ ω)[KM' (A T n) ≤ KM (0n)+ (i + 1)]. Once again, we
i	i
define two sequences recursive in Mi for every i. The first is ⟨si,k⟩k∈ω, where
si,k is the least stage s such that μ(Mi,s) ≥ 1 −  1 . The second is ⟨ni,k⟩k∈ω,
where ni,k = max{|σ|| σ ∈ Msi,k }.
We build T0 and M' as previously. For i ≥ 1, we build the tree Ti within
Ti−1. As mentioned in Remark 4.5, this is permissible since Ti−1 is recursive.
We fix the tree through the first i branching points of Ti−1 to ensure that the resulting tree is perfect. We build M ' almost as before, but with some slight differences. Until ni,k is greater than the height of the ith branching point plus 1, we treat it as in Case 1 of the k > 1 case to ensure that the branching points do not disappear when we take the intersection of the Tis in the end. This means that we may have k + i branching points at the end of stage si,k
instead of k, so instead of adding ⟨d + 1, σ⟩ to M '	, we add ⟨d + i + 1, σ⟩. This
ensures that the measure of the machine M ' will still be less than or equal to
1, since Σk∈ω  k+i  ≤ 1 for any i.
Since we are working within Ti−1 instead of 2<ω, there are two other factors that we must take into account. First, there may not be a branching point in Ti−1 at precisely the height required by an ni,k. To compensate for this,

we generate a new recursive sequence ⟨n'
⟩k∈ω, where n'
is the height of the

lowest branching point in Ti−1 above ni,k, and we use this sequence rather than ⟨ni,k⟩k∈ω.
Second, whereas before we could assume there were k branching points in our tree after stage k, this time we cannot assume that there will be k + i after stage k. This depends entirely on Ti−1 and the sequence ⟨ni,k⟩k∈ω. Therefore, the set of the longest elements already determined, Σ = {σ1,... , σm}, may not contain k + i elements. To ensure that μ(M') is still a recursive real, we add (k + i) − m additional copies of ⟨d + 1, σ'⟩ to M', where σ' is the leftmost σ ∈ Tk−1 such that |σ| = n if Case 2 holds, just as we did in Case 1 before.

Let T = ∩i∈ωTi.
Claim 4.9 T is a perfect tree, and each branch of it is Schnorr trivial with respect to each machine Mi.
Proof. For all k > i, Tk has the same ith branching point, so T is infinitely branching. Given this, the use of ϕ as a condition for determining the branch- ing points ensures that ∀σ ∈ T , there are incomparable τ1 and τ2 extending σ. This is sufficient to see that T is a perfect tree.
Let B ∈ [T ], and let i ∈ ω and n ∈ ω. As before, if KM (0n) = ∞, we
automatically have KM' (B T n) ≤ KM (0n)+ (i + 1). Otherwise, there is a
i	i
least number d such that ⟨d, 0n⟩ ∈ Mi. We will have put ⟨d + i + 1, σ⟩ into
' for all σ of length n in T , including B T n. Therefore, KM' (B T n) ≤
d + (i + 1) = KM (0n)+ (i + 1) for each i, and each branch B is Schnorr
trivial with respect to each Mi. It follows that each branch B of T is Schnorr trivial.	 
T is thus a perfect tree of Schnorr trivial reals.

Corollary 4.10 There are 2ℵ0 Schnorr trivials.
Remark 4.11 The tree T is recursive in 0'', since the only nonrecursive com- ponent is the list of computable machines with domain 1, and that is recursive in 0''.
Theorem 4.12 Every degree a ≥T 0'' contains a Schnorr trivial.
Proof. We build a tree T of Schnorr trivials recursively in 0'' almost as before. However, now we must build our trees Ti such that every A ∈ 2ω is coded by a branch in T = ∩i∈ωTi.
The first step is to modify the construction to produce a uniform tree. Rather than branch once at each stage k ≥ 1 so there are k determined branching points at the end of each stage k, we instead extend each string of the appropriate length by both a 1 and a 0, and only at stages of the form 2k − 1, giving us up to 2k branches at the end of these particular stages. This will produce no more branching points at the end of any given stage than permitted in the original argument, so the Kraft-Chaitin Theorem will still apply.
We will need more than the simple uniformity of T to code every real A ∈ 2ω within T , though. We begin by observing that in our previous construction, a 0 would only appear in T at height n if there had been a branching point at height n − 1 in some Ti. We will adapt this construction so that in our final tree T , the 0s indicate the branching heights in T rather than simply some

Ti. This will allow us to code each element of 2ω into a branch of T via the elements immediately following these 0s.
Now we branch only at stages of the form 3k − 1, permitting us to have 3k branches at the ends of these stages. At such stages, we extend each string of the appropriate length by 11, 01, and 00 instead of simply 1 and 0 as before. Our goal is to produce a final uniform tree T = ∩i∈ωTi in which 0s appear only at branching points. When we fix the ith branching point in Tk for k > i, we prune the 11 branch, leaving only the 01 and 00 branches. Later in the construction, if we must remove a branching point, we prune the 01 and 00 branches to avoid introducing 0s into the final tree at nonbranching points, leaving only the 11 branch.
Every set in 2ω is coded by a branch in our tree T . Consider a set A. We code A(n) by the direction we go at the (n + 1)st branching point. If A(n) = 0, we follow the left, or 00, branch. If A(n) = 1, we follow the right, or 01, branch. Let the branch of T obtained in this way from A be called T (A).
Claim 4.13 If A ≥T 0'',A ≡T T (A).
Proof. Clearly, A ≥T T (A): by Remark 4.11, A computes the tree T since
A ≥T 0'', and A can identify the proper path through T .
Similarly, given T (A), we can find A(n) by looking for the (n+ 1)st disjoint pair beginning with a 0 and looking at the next bit. If it is a 1, then A(n)= 1, and if it is a 0, then A(n)= 0. Then T (A) ≥T A.

Therefore, if a ≥T 0'', there is B ∈ [T ] such that B ∈ a.

Now that we have constructed a perfect tree of Schnorr trivial reals in 0'' coding all A ∈ 2ω, we can adapt this construction to be recursive in any high degree. This will give us Theorem 4.1.
Proof. [Theorem 4.1]
Let h be a high degree, let H ∈ h, and let ⟨Me⟩e∈ω be a list of all Turing machines. Since H is high and the statement “the Turing machine Me is computable, and μ(Me) = 1” is recursive in 0'', we may define the following functional Ψ.


lim
t−→∞
Ψ(e, t, H)= ⎧⎨ 1 if Me is computable and μ(Me)= 1
⎩ 0 else

We will use this functional to build a perfect tree of Schnorr trivials through

a sequence of approximations so that


(∀Me comp.)(∃Me,c comp.)(∀n ∈ ω)[KM'
(A T n) ≤ KMe (0
)+ (c + 1)]

and every B ∈ 2ω is coded by a branch of T .
The necessity of such approximations produces the main differences be- tween this construction and the previous one. We cannot use a list of the computable Turing machines with domain 1, so we must consider all Turing machines. Therefore, we will not use M-stages in this construction. Since we cannot identify the computable Turing machines with domain 1 with certainty at any stage of the construction, we will build the trees simultaneously for all Me rather than building a tree for each Me within the tree for Me−1 after the latter has been entirely determined. This means that we may have parts of the tree that are irrelevant since we built them based on a machine that turns out not to be computable with domain 1. Furthermore, we might not begin to construct our tree for Me before we begin to construct it for Mi for some i > e. This may create extra branches in the tree for Me, but we will not know how many there will be at any given point.
To compensate for this, we will build an M'	for each Me and every c ≥ e.
The constant c will account for these “extra” branches, just as the constant i

did for M' in the previous construction. Infinitely many such M '
will work

i
for each Me, but we cannot identify them in advance.
e,c

We will only allow a machine Me to affect our construction at a stage t

when Ψ(e, t, H) = 1 and μ(Me) ≥ 1 −   1 
2
for a larger k than was used

the last time the machine was activated. The first requirement allows us to
only consider machines that appear to be computable with domain 1, and the second allows us to create a uniform tree coding every B ∈ 2ω as before.

s = 0: We let T0 = 2<ω and M'
= ∅ for all e and c. We then activate all Me

for stage 0.
s > 0: We compute Ψ(e, s, H) for all e ≤ s. If Ψ(e, s, H) = 0 for all such e, we let Ts = Ts−1 and go on to stage s + 1. Otherwise, we list all e ≤ s such that Ψ(e, s, H) = 1 in increasing order: e1 < e2 < ... < en. For each ei, let
ke ,s be the largest integer k for which μ(Me ,s) ≥ 1 −  1 .
i	i	23k −1
First, we consider e1. If ke1 ,s ≤ ke1,t, where t is the most recent stage at
which Me1 was activated, we end stage s. Otherwise, we activate Me1 and list all k such that 3ke1,t − 1 < k ≤ 3ke1,s − 1.
For each such k, we will construct our tree very much as before. Since we know such stages will exist now, we can define sk to be the least stage s such that μ(Ms) ≥ 1−  1  for these k. For each such k, we let Σ = {σ1,... , σm} be

the set of the longest elements of Ts−1 that have already been determined. We will call their length h.

We now construct the M '
s and trees via the following procedure for each

such k.
If ⟨d, τ ⟩ enters Me1 between states sk−1 and sk, we have the following two cases. Let n = |τ |.
Case 1: n ≤ h. For all σ ∈ Tk−1 such that |σ| = n, we add ⟨d + c + 1, σ⟩

'
e1,c
for all c ≥ e1. There will be l many such σ for some l ≤ k, so

we add ⟨d + c + 1, σ'⟩ to M'	an additional (k + c) − l times, where σ' is
the leftmost σ in our tree such that |σ| = n.

Case 2: n > h. For all σ  ∈ Σ, we add ⟨d + c + 1,σ -1|τ|−l⟩ to M'
for

i	i	e1,c
each c ≥ e1. This time there will be m such σi, so we add ⟨d + c + 1, σ1⟩

'
e1,c
an additional k − m times.

Note that in both Case 1 and Case 2, we added  k+c 
to μ(M '
) each

time we added  1  to μ(Me ).
2d	1
If k is of the form 3j − 1 for some j, we let our tree be


'
'
e1 ,sk


and |σ|=n' ([σ

11] ∪ [σ

01] ∪ [σ


-
00])

where n' = max{|σ|| σ ∈ M '	}.
After we have finished the above procedure for all k ≤ 3ke1 ,s − 1, we continue this process for each ei for i > 1 until we reach one for which kei,s ≤ kei,t, where t is the most recent stage at which Mei was activated, or we reach an ei whose kei,s requires us to branch higher in Ts,i−1 than the highest previously determined branching point. In either of these cases, we

end stage s. If neither case holds, we activate Me , augment the M'
s as

i
before, and build the tree Ts,i within Ts,i−1.
ei,c

The construction of Ts,i must do two things.	The first is to preserve
certain branching points to ensure that our final tree is perfect. To do this, when we build our tree according to Me, we will require that the first

e branching points appearing in the construction of the M '
s will be pre-

served. Therefore, for these branching points, we will prune the 11 branches of the existing tree. The second is to ensure that 0s only appear in the fi- nal tree at its branching points. Therefore, if we must remove a branching point, we will prune the 01 and 00 branches at that height and leave only the 11 branch as before.
Let the last tree produced before the end of the stage be Ts.
Let T = ∩s∈ωTs.

Claim 4.14 For every e ∈ ω, there is a c' ∈ ω such that M '
is a Kraft-

Chaitin set for all c ≥ c' for some c'.

Proof. Let e ∈ ω be given. By the definition of Ψ, there is an s such that for all t ≥ s, Ψ(i, t, H)= 1 if Mi is computable with domain 1 and Ψ(i, t, H)=0 

otherwise for all i ≤ e. After this stage s, the construction of M'
will be

identical to that in the previous construction. There may be more than k + e branches after μ(Me) ≥ 1 −  1 , but this number will now increase at the same rate as it did before. Therefore, some c' ≥ e will reflect this number
of branches. This is enough to see that μ(M ' ) ≤ 1 for all c ≥ c', and since

'
e,c
) is a recursive real for all c, M'
is a Kraft-Chaitin set for all c ≥ c'. 

Claim 4.15 Every branch A of T is Schnorr trivial.
Proof. Let A ∈ [T ], and let Me be an arbitrary computable machine with
'
domain 1.	We will show that (∃Me,c  comp.)(∀n ∈ ω)[KM' (A T n) ≤
KM (0n)+ (c + 1)]. Let c' be as in Claim 4.14, and let n ∈ ω be given.
If KM (0n) = ∞, it is clear that KM'  (A T n) ≤ KM (0n)+ (c' + 1).
e	e,c'	e
Otherwise, let d be the least integer such that ⟨d, 0n⟩ enters Me. Then d =

KM (0n). When ⟨d, 0n⟩ entered Me, ⟨d + c' + 1, σ⟩ entered M'
' for all σ of

e
length n in T , including A T n. Therefore, K '
e,c'
e,c
(A T n) ≤ d + (c' + 1) =

KM (0n)+ (c' + 1), and M ' ' and c' + 1 will witness the Schnorr triviality of

e
A with respect to Me.
e,c

Therefore, we will have K '
e,c'
(A T n) ≤ KM (0n)+ (c' + 1) for all n, and

'
e,c
' will witness the Schnorr triviality of A with respect to Me.	 

Now we can code every B ∈ 2ω by a branch in T . We code B(n) by the branch we choose at the (n + 1)st branching point. If B(n) = 0, we choose the left, or 00, branch. If B(n) = 1, we choose the right, or 01, branch. We call the branch chosen in this manner T (B).
Claim 4.16 If A ≥T H, A ≡T T (A).
Proof. This proof is identical to that of Claim 4.13.	 
Since T is a perfect tree of Schnorr trivial reals, T is recursive in h, and every B ∈ 2ω is coded by a branch of T , every degree above h contains a Schnorr trivial real. Since h is an arbitrary high degree, we have proved Theorem 4.1.

As previously noted, the Schnorr trivial Turing degrees are not closed downwards [3]. Theorem 4.1 provides additional evidence that the Turing degrees are not the appropriate framework in which to consider Schnorr trivi- ality, for it suggests that an arbitrarily computationally strong real may have minimal computational complexity.

Acknowledgments
I would like to thank Theodore A. Slaman, my advisor, and Leo Harrington for many useful conversations and suggestions.

References
Chaitin, G. J., A theory of program size formally identical to information theory, J. Assoc. Comput. Mach. 22 (1975), pp. 329–340.
Chaitin, G. J., Algorithmic information theory, IBM J. Res. Develop. 21 (1977), pp. 350–359.
Downey, R., E. Griffiths and G. Laforte, On Schnorr and computable randomness, martingales, and machines, Math. Log. Q. 50 (2004), pp. 613–627.
Downey, R. G. and E. J. Griffiths, Schnorr randomness, J. Symbolic Logic 69 (2004), pp. 533– 554.
Downey, R. G., D. R. Hirschfeldt, A. Nies and F. Stephan, Trivial reals, in: Proceedings of the 7th and 8th Asian Logic Conferences (2003), pp. 103–131.
Franklin, J. N. Y., Hyperimmune-free degrees and Schnorr triviality, in progress.
Kjos-Hanssen, B., A. Nies and F. Stephan, Lowness for the class of Schnorr random reals, SIAM J. Comput. 35 (2005), pp. 647–657 (electronic).
Kuˇcera, A., Measure, Π0-classes and complete extensions of PA, in: Recursion theory week (Oberwolfach, 1984), Lecture Notes in Math. 1141, Springer, Berlin, 1985 pp. 245–259.
Martin-Lo¨f, P., The deﬁnition of random sequences, Information and Control 9 (1966), pp. 602– 619.
Miller, W. and D. A. Martin, The degrees of hyperimmune sets, Z. Math. Logik Grundlagen Math. 14 (1968), pp. 159–166.
Nies, A., Lowness properties and randomness, Adv. Math. 197 (2005), pp. 274–305.
Nies, A., F. Stephan and S. A. Terwijn, Randomness, relativization and Turing degrees, J. Symbolic Logic 70 (2005), pp. 515–535.
Schnorr, C.-P., “Zuf¨alligkeit und Wahrscheinlichkeit,” Lecture Notes in Mathematics 218, Springer-Verlag, Heidelberg, 1971.
Terwijn, S. A. and D. Zambella, Computational randomness and lowness, J. Symbolic Logic
66 (2001), pp. 1199–1205.
