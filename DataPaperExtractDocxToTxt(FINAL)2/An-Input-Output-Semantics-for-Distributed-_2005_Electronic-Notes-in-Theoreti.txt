Electronic Notes in Theoretical Computer Science 137 (2005) 25–46  
www.elsevier.com/locate/entcs


An Input/Output Semantics for Distributed Program Equivalence Reasoning
Miquel Bertran1	Francesc-Xavier Babot2	August Climent3
Informatica La Salle, Universitat Ramon Llull, Barcelona

Abstract
A new notion of input/output equivalence of distributed imperative programs, with synchronous communications, is introduced. It preserves the input/output relation, encompassing both, ini- tial/final state and communication channel values. For its mathematical justification, the semantic framework of Manna and Pnueli, based on finite transition systems and reduced behaviors, is ex- tended with the notion of input/output behavior. A set of laws for the equivalence is overviewed. A deduction rule for the substitution of references to input/output equivalent procedures is defined and justified in the new semantics. The rule is applied to decompose distributed program simpliﬁ- cation proofs, introduced in a prior work, which use the laws to establish the equivalence between a sequential and a parallel communicating program. They include communication elimination as one of their steps. An outline of one of such proofs, for a pipelined processor model, is included.
Keywords: Distributed programs, parallel programs, input/output equivalence, equivalence preserving transformations, verification, program simplification, synchronous communications, laws of distributed programs.


Introduction
Imperative languages with explicit parallelism and communication statements provide an intuitive, explicit, and complete framework to express distributed and concurrent programs and system models, with the clarity required for verification. OCCAM [11,12,13], the simple programming language, SPL, of Manna and Pnueli [15,16], PROMELA of the SPIN model checker [10], and

1 Email: miqbe@salleURL.edu
2 Email: fbabot@salleURL.edu
3 Email: augc@salleURL.edu



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.01.038


the shared-variable language++, SVL++, in [7] are representatives of these im- perative notations.
Equivalence reasoning is heavily used for numbers, matrices, and other fields. However, for imperative programs, although having the potentiality of being a very intuitive verification activity, it has not been explored in concur- rency and distribution. Simplification via internal communication elimination
[2] is an equivalence proof that, since it decreases the size of the state vector, could complement other proof methods, such as model checking [10,17,5] and interactive verification [3,14]. It is based on the application of a set of laws, suitable for that purpose, as reductions to a program. The laws depend on the notion of equivalence and on the fairness assumptions [15].
A set of laws for OCCAM was given in [18]. Rather than simplification via communication elimination, the focus there was to obtain normal forms and to define the semantics of the notation. Some laws for SPL are given in [15], with an SPL semantics based on fair transition systems (FTS), but communication elimination laws are not given there. In the framework of SVL++, some laws are given in [7] but they do not suffice for communication elimination.
The first set of relations suitable for communication elimination was given and proved sound in [2], showing the necessity of avoiding strong fairness. A communication elimination proof of a distributed fast Fourier transform was outlined there as well. In this earlier work, the notion of equivalence was assimilated to congruence, a very strong equivalence. This had the draw- back of limiting the formulation of most communication elimination laws to unidirectional refinements. Clearly, the need of working with a weaker equi- valence, where all laws could be formulated with it, avoiding the asymmetry of refinement relations, was outstanding.
This paper introduces a notion of equivalence, input/output equivalence, weaker than congruence, but strong enough to preserve the input/output re- lation of the programs and to lead to laws for communication elimination. It is justified in a semantics which extends the Manna-Pnueli framework as the main contribution of the paper, where each statement denotes a set of input/output behaviors. They extend the notion of reduced behavior given in [15]. In order to capture the complete input/output relation, the former adds to the latter a recording of the values traversing synchronous channels, in addition to the usual data state variables. This reflects the fact that values may be input or output via channels, as well as via proper variables. In this context, the grounding work with streams introduced in [4] is related, but in our concrete imperative program context we needed a new model where both channel and variable values are taken into account. The work on compatibility of components [6] is also related.


An important ingredient of equivalence reasoning is substitution of proce- dure reference statements of two equivalent procedures. It would allow proof decomposition. Conditions for the validity of such substitutions are also given and their justification outlined. This establishes the necessary base theory for formal input/output equivalence reasoning with distributed programs.
The paper is organized as follows. After a section on the notation, in- cluding modular procedures, and some notions needed later in the paper, the concept of input/output behavior is introduced. Composition rules to obtain io-behaviors of sequential, parallel and selection compositions are detailed, in preparation for the justification of the substitution rule. Input/output equiva- lence of procedures is covered next, with the substitution rule and its justifica- tion. These sections contain the main contributions of the paper. A summary of the laws and of distributed program simplification proofs follows, together with their application to a pipelined processor model. This is an overview without proofs for illustrative purposes only. A brief section on conclusions and further work ends the paper.

Programming Notation
Syntax of the Basic Notation
Programs will be written in a reduced version of SPL, which is general enough to express any practical program. Its syntax is presented now. The basic statements are Skip, Nil, Stop, the assignment u:= e, send α ⇐ e, and receive α ⇒ u. We limit our work to synchronous channels α, which will be referred to as channels. In them both the sender and the receiver wait for each other before exchanging a value and continuing execution. Communica- tion statements will be referred to more simply as communications. The skip statement involves a transition in the underlying fair transition system, but without any effect on the data variables. The nil statement makes its pre and post control locations equivalent, involving no transition. The stop statement has neither the transition nor the label equivalence relation. Both channels and variables are declared globally before their usage. The rest of the notation is defined recursively.
Concatenation is n-ary: [S1; ··· ; Sn] . The iterations are [while c do S] , where c is a boolean expression, and [loop forever do S] , which is defined as [while true do S]. The cooperation statement is also n-ary: [S1||··· ||Sn]. Its substatements Sj are the top parallel statements of the cooperation state- ment, which is the minimal common ancestor of them. It will be assumed throughout the paper that the Sj’s are disjoint, in the sense that they only share read variables, and that they communicate values through synchronous


channels only. The regular selection and the communication selection state- ments are non-deterministic and have, respectively, the forms
[b1, S1 or ··· or bn, Sn] and [b1, c1, S1 or ··· or bn, cn, Sn] , where the bi’s are boolean expressions referred to as boolean guards, and the ci’s are syn- chronous communication statements referred to as communication guards.

Modular Procedures
This notion was introduced in [2] combining the notions of SPL module [15,8] and procedure. As modules, modular procedures can be composed in parallel, but may be invoked by procedure reference statements, which make explicit the names of all the interface channels and variables. Common variables are prohibited. The notation r ::= P (p) will be used for a procedure reference, where r and p stand for the result and parameter lists of the interface, and P is the procedure name. Modular procedures will be referred to more simply as procedures. An example of procedure is given below. Its procedure reference stands at the left, and the procedure body at the right.

out r : integer
out cr : channel of integer external in p : integer
7
local a1, a2: integer
(r, cr) ::= Pc(p, cp) ::
6	3 7
6 2cp ⇒ a1;	37 2cp ⇒ a2;	7 7
a1 := a1+ p;	c ⇒ r;
7 7

Notice that r and p are variables whereas cr and cp are channels. r and cr are the results, and p and cp are the parameters of the procedure. The exact meaning of modes out and external in is not important here, since processes are disjoint and communication is point to point and half-duplex. The declaration at the head of a procedure body will be omitted often in this work. No common variables or channels are allowed.
Semantics of the reference statement It is unchanged with the re- placement of the reference by the procedure body, with a renaming of variables and channels when necessary. It has to be consistent with the reverse opera- tion of encapsulation of a part of a program within a procedure.
The set O of observed variables of a procedure Contains all proper variables in the interface, and an auxiliary channel variable for each channel in the interface. The set O is also referred to as interface set.


A channel variable records, as a triplet, the value passed at a communi- cation event, a count reflecting the order of the channel event, and an in- put/output mark (i,o). When the event is internal, a dot replaces the in- put/output mark. For the above procedure, this set is O : {r, p, cr, cp}, where cr and cp are the auxiliary variables associated to the channels.




Basic Notions for the Semantics

The semantics of the specific SPL variant which we use follows the style of Manna and Pnueli, based on fair transition systems (FTS) [15,16]. In the following, some of its elements are summarized. A full account is in [2].
A computation is a sequence of states starting at an initial state with a transition taking any state to its successor. A reduced behavior, with respect to a set O of observed variables, is a computation where both its components of variables outside the observed set and stuttering steps (i.e. idling transitions) are deleted. The set O contains only proper variables. Transitions correspond to atomic actions, which are associated to statements. A program context P [ ] is a program P one of whose statements corresponds to a hole to be filled-in with an arbitrary statement S. With some abuse of notation P [S] will denote a program context, where S denotes the arbitrary statement placed in the hole. Some laws are congruence relations between statements. Statement S1 reﬁnes S2, written S1 ±O S2, when for any program context P [·], any reduced behavior of P [S1] is also a reduced behavior of P [S2]. S1 is congruent to S2, written S1 ≈O S2, when S1 ±O S2 and S2 ±O S1. These relations are defined with respect to a set O of observed variables.
Some extended notions, needed in the paper are introduced next. An input/output computation (io-computation) records the value histories of both the variables and the channels of the procedure body during an execution. It has a row for each value change and a column for each variable or channel.
An io-computation adds to a computation a column for each channel. Whereas a computation is a sequence of states only, an io-computation is a se- quence of states where the values crossing channels are also recorded. Groups of computations will be represented as schemas, which have value variables. Computations have just values (integers, booleans, etc...). A triplet (value, count, i/o indication) is associated to each new value of a channel variable.
The following is an io-computation schema of the procedure above.


x denotes any value and xT any triplet. p1 , cp1 , cp2 , etc ... are value variables, whereas a1, a2, r, and p are program variables. cp, cr, and c are auxiliary channel variables. Giving integer values to p1, cp1, and cp2, specific io-computations would be obtained. Leaving aside the initial row, each row corresponds to the state resulting from the transition of the statement at the second column. The transition of row 4 is the joint transition of the synchronous communication over channel c. All computations are of infinite length. Thus the last row corresponds to a terminal state, repeating itself implicitly by idle transition firings. A computation schema could be obtained by deleting the cr, cp, c, and the two left columns, and then deleting, as in [15], any row which equals its predecessor but not all of its successors.

Input/Output Behaviors
Basic Notions
An input/output behavior is a procedure execution trace seen from its outside.
Definition 3.1 (Input/Output behavior of a procedure) An input/out- put behavior of a procedure, also referred to as io-behavior, is the result of deleting from an io-computation all columns of variables not belonging to O, and then deleting any row which equals its predecessor but not all of its successors.
The condition in the last deletion is necessary since the infinite implicit repetitions of the last row should not be deleted. Due to event counters, consecutive events are not deleted when their values are equal. This should be so since they may correspond to two inputs of the procedure function. Thus all channel events are represented in a io-behavior by at least one row.
An io-behavior has one row for each value change of a result variable v ∈ O. A parameter variable never changes its value, unless it is also a result. Input and output channel variables exhibit value changes. The following io- behavior schema results from the io-computation schema above.


Rows 3 and 5 have been deleted since they are equal to their predecessors 2 and 4 respectively. Suppose now that cp1 = cp2, then row 2 would not be deleted due to the new value, 2, of the counter field of the cp column.
Definition 3.2 (Component of an io-behavior) An io-behavior compo- nent is the list of values, a column, corresponding to a variable of 0. But any value in the list which equals its predecessor but not all of its successors is deleted. There are both proper and channel variable components.
Definition 3.3 (Equivalence of io-behaviors) Two io-behaviors are equi- valent when they share the same interface set, and the two components of the same variable of both are equal.
The order of value changes among different components is lost in io- behaviors, but not the order of changes within the same component. Equiva- lence only requires equality of homologous component lists.
Composition of io-behaviors
This subsection introduces operations between io-behaviors, needed later for the justification of the substitution rules.
Sequential composition
The io-behaviors of a sequential composition are formed by post-coupling an io-behavior of its second statement to an io-behavior of the first. In the binary composition [r1 := P1(p1)] ; [r2 := P2(p2)] , in general, 01 /= 02, and 01∩02 may or may not be empty. Given schema b1 of P1, the schema b2 of P2 depends on the values of the last row of b1. The schema b1;2 of P1; P2 corresponding to b1 and b2 has as many components as variables in 01 ∪ 02. It is formed by post-coupling b2 after b1. Informally, the components of b2 go after the ones of b1 , but certain values of the first row of b2 have to equal their homologous ones in the last row of b1. More specifically, the post-coupling is done as follows:
Proper variable components. Cases:
v ∈ 01 ∩ 02 : b2 has to be such that the values of the first positions (initial row) of the components of such v’s equal the last value of their homologous components of b1. Such a b2 can always be found, since


corresponding values share the same type, when v is a parameter of P2, and undefined values (x) can be changed to any value, when v is a result of P2.
v /∈ 01 ∩ 02 and v ∈ 01 : The last values of such v components of b1
are propagated into the future, over the b2 selected as in (a).
v /∈ 01 ∩ 02 and v ∈ 02 : The first values of such v components of the b2 above are propagated into the past, over b1.
Channel variable components. Cases:
c ∈ 01 ∩ 02 : Any undefined initial triplets of such c components of b2 are set equal to the last triplets of their homologous components of b1. The counts of the rest of the triplets are increased accordingly.
c /∈ 01 ∩ 02 and c ∈ 01 : The last triplets of such c components of
b1 are repeated into the b2 portion, in other words into the future.
c /∈ 01 ∩ 02 and c ∈ 02 : The b1 portions of such c components are filled in with undefined triplets.

Example 3.4 In the composition [cr1,r := P1(cp1, p)] ; [cr2,p := P2(cp2, r)], a result variable r of the first is a parameter of the second, and a parameter p of the first is a result of the second. The respective interface sets are 01 :
{cr1, r, cp1, p} and 02 : {cr2, p, cp2, r}. No channel is shared. In addition, 01 ∩ 02 = {r, p} and we assume that 0 : 01 ∪ 02 : {cr1, r, cp1, p, cr2, cp2}. The following schemas, where the vij’s are program variables, are meant to be the io-behaviors b1 of P1, b2 of P2, and their post-coupling b1; b2.

b1	b2

b1 ; b2




Within b1; b2, the y2 of b2 becomes x5, and the x of b2 is coerced to x2.

Parallel Composition
The io-behaviors of parallel compositions are formed by side-coupling io-be- haviors of their component statements. In the following parallel composition [r1 := P1(p1)] || [r2 := P2(p2)] , in general 01 /= 02 and 01 ∩ 02 may or may not be empty. Given schemas b1 of P1 and b2 of P2 , the io-behavior schema b1||2 of P1||P2 corresponding to b1 and b2 has as many components as variables in P : (01 ∪ 02) − 0I where 0I ⊆ (01 ∪ 02) is the set of proper and channel variables declared as internal, non-observable, in the composition. Channels in 0I give rise to internal communication events. We assume disjointness of P1 and P2 and deadlock-freeness of their parallel composition. In this work, deadlock-freeness of P means internal deadlock-freeness, disregarding interaction with any environment where P may be embedded.
The io-behavior b1||2, resulting from side-coupling, is constructed as follows:
Selection of matching behaviors. Since P1 and P2 are disjoint, the selec- tion of b1 and b2, the io-behaviors of P1 and P2 respectively, is determined by the internal channels. They are chosen so that the value components of the two triplets, one in each io-behavior, giving rise to each internal communication event are equal. This will be always possible since we assume deadlock-freeness, which in our context means that any inter- nal communication in P1 has a matching communication in P2, and vice versa. Furthermore, under this assumption, the counts of corresponding triplets can also be made equal, and one of them will have an i mark and the other one an o mark, but not necessarily always in the same side (io-behavior). We say that such corresponding triplets are matching.
Construction of the intermediate form ¯b1||2.
Its number of components equals the number of variables in 01 ∪ 02.
Its rows are separated in sublists by its internal communication event rows, constructed first as follows: their variable components are filled in with the values of the corresponding variables of the matching rows of the two io-behaviors, with the exception of the internal communi- cation event triplet, constructed with the value and the count of the two matching triplets. A dot will be placed in its third component, replacing the i and the o. This assumes deadlock freeness.
The rows of the sublists of b1 and b2, separated by communication
event rows, are interleaved in ¯b1||2. Any interleaving is possible.
b1||2 is constructed by deleting the components of ¯b1||2 not in P, and any row of the result which equals its predecessor but not all of its successors.
Example 3.5 Consider the composition [r1, cr1 := S(p1, cp1)] || [r2, cp1 :=
A(p2, cr1)] of two disjoint processes, with set of internal channels 0I : {cr1, cp1}.

The interface sets of S and A are 0s : {r1, cr1, p1, cp1}	and	0 :
{r2, cp1, p2, cr1}. Assume that the interface set of the composition is P : (0S ∪ 0) − 0I : {r1, p1, r2, p2}. The following schemas correspond to the
io-behaviors bs of S, ba of A, and of their side-coupling intermediate form ¯bs||a.
bs	ba

b¯s||a

The rows of matching internal communications, over channels cr1 and cp1, and of internal communication evens have been isolated.
Selection Composition
For selection composition, [b1, c1; [r1 := P1(p1)] or ··· or bn, cn; [rn := Pn(pn)]], the set of io-behaviors is the union of the io-behaviors contributed by each of its alternatives Ak. Each of them contributes with the subset of the io-behaviors of [ck; [rk := Pk(pk)]] whose first row satisfies boolean condition bk.
Let 0k be the interface set of procedure Pk. Then the interface set 0Ak of alternative Ak is given by 0k ∪ var(ck) ∪ chan(ck) ∪ var(bk); where var(e) is
the set of variables of expression e, chan(c) is the singleton set containing the channel variable of c. The interface set of the above selection may be any set
P such that P ⊆  n	0A . All this is consistent with non-determinism.
k

Input/Output Equivalence
The Notion
Definition 4.1 (Io-equivalent procedures) Two procedures P1 and P2 are io-equivalent with respect to their interface set 0, written P1 =O P2, when any io-behavior of any of them is equivalent to an io-behavior of the other.
Io-equivalence is weaker than congruence. Congruent procedures are al- ways equivalent but not vice versa. The relative order of value changes in distinct components is neglected in io-equivalence. Therefore, substitution of


a reference to a procedure by a reference to another procedure, io-equivalent to the first, may introduce deadlock. Consider the two procedures
(r1, r2) ::= P 1(cp1, cp2) :: hcp1 ⇒ r1; cp2 ⇒ r2i
(r1, r2) ::= P 2(cp1, cp2) :: hcp2 ⇒ r2; cp1 ⇒ r1i

with the same interface set 0. Now P 1 /≈O P 2 , since if P 1 is parallel to a process which always offers an output via channel cp1 before offering another output via cp2 within a program, and we replace P 1 by P 2 in that program, deadlock is introduced. However, P 1 =O P 2.
Substitution rules
Substitution of reference statements to io-equivalent procedures is an essential step of equivalence reasoning. The three first lemmas, concerning concatena- tion, cooperation and selection, are given in preparation for the general rule. Only the post-concatenation case is treated, the other case would be carried out similarly.
Lemma 4.2 (Substitution in concatenation) Let S; [r := A(p)] be deadlock-free. Then, if [r := A(p)] =O [r := B(p)] , the equivalence S; [r := A(p)] =P S; [r := B(p)] holds, where У ⊆ 0 ∪ 0S , and 0 = 0A = 0B
Justification  The io-behaviors of S; A and S; B have the same interface set У by definition, and since A and B have the same interface set 0. Concerning equality of component lists, io-behaviors of the concatenation are formed by postcoupling an io-behavior of A, or of B, to an io-behavior of S. We show equality of component lists recalling the postcoupling construction rules given in subsection 3.2.
Proper variable components. Cases:
v ∈ 0S ∩0 : The initial values of this group of components of bA (or of bB) are equal to their corresponding last values of bS. Since A =O B, a bB (or a bA) io-equivalent to bA (or to bB) with the same initial values can always be found. Hence, the postcouplings of both sides will give the same lists of values for each one of these v components.
v /∈ 0S ∩0 and v ∈ 0S : For these components, the propagation into the future only depends on bS, the io-behavior of S, which is equal in both sides.
v /∈ 0S ∩0 and v ∈ 0 : The propagation into the past depends on
bA or on bB, which has been selected equivalent to bA in (a).
Channel variable components. Cases:


c ∈ 0S ∩0 : Since S is the same in both sides, the last triplets of these components of bS will be the same in both sides. Since bB has been selected equivalent to bA in (i-a), it will have the same pattern of initial undefined triplets, to be changed to the last values of the c components of bS. Hence the io-behaviors of both sides will be equivalent.
c /∈ 0S ∩0 and c ∈ 0S : The last triplets of bS which have to be repeated into the future, bA or bB region, are the same in both sides since S stands in both sides. Hence, they will give equal propagations into bA or bB.
c /∈ 0S ∩0 and c ∈ 0 : For these components, the lists of the two sides are formed by concatenating an undefined value with the lists of bA and bB which are equal, since they are io-equivalent.	 
We study now the preservation of equivalence in a substitution within a cooperation, parallelism, statement. Let S||[r := A(p)] have internal channel set I. If 0 is the interface set of [r := A(p)] , and 0I is the set of internal channel variables, corresponding to I, then 0I ⊆ 0 . Channel variables in 0− 0I correspond to external channels of S||[r := A(p)] . Similarly, 0I ⊆ 0S
, where 0S is the interface set of S . Also, channel variables in 0S − 0I correspond to external channels of S||[r := A(p)] . Actually, the interface set У of the parallel composition is such that У ⊆ (0S ∪ 0) − 0I , since there may be proper variables which are not declared as external.
Lemma 4.3 (Substitution in parallelism) Let S||[r := A(p)] be dead- lock-free, and r := A(p) be disjoint with S . Let also [r := A(p)] =O [r := B(p)] , and S||[r := B(p)] be deadlock-free. Then [S||[r := A(p)]] =P [S||[r := B(p)]] , where У ⊆ (0S ∪ 0) − 0I .
Justification  We will show that, in the construction of io-behaviors of S||A and S||B, the steps of side-coupling, given in subsection 3.2, can be followed so that equivalent io-behaviors result from the two statements. Deadlock-freeness is required since it has been assumed in the construction.
Selection of matching behaviors. Since bS is identical for both statements and A =O B, any io-behavior bA matching bS can be replaced by an equivalent bB, which will also be matching bS.
As a consequence, the intermediate forms ¯bS||A and ¯bS||B will be equivalent with respect to set 0S ∪ 0.
Hence, the operations of 3.2.2(iii), with the У defined above, starting

from either ¯bS||A
or from ¯bS||B
will give io-equivalent results.

Therefore, any io-behavior of S||A can be interpreted as an equivalent io- behavior of S||B and vice ver



Lemma 4.4 (Substitution in selection)	Let [ g, [r := A(p)] or R ] be deadlock-free, where R stands for the rest of the selection statement, and g is a boolean guard, for a selection, or both a boolean and a communication guard, for a communications selection. Let also [r := A(p)] =O [r := B(p)] , and 0R be the interface set of R. Then, with У ⊆ (0R ∪ 0)
[ g, [r := A(p)] or R ] =P [ g, [r := B(p)] or R ] .
Justification	Let IR , IAg , and IBg denote the sets of io-behaviors of R, the alternative of A and the alternative of B, respectively, and IA and IB be the sets of io-behaviors of A and B, respectively. If the statement is a regular selection, then IAg and IBg are formed with the io-behaviors of IA and IB, respectively, whose first rows satisfy the boolean guard of g. However, if the statement is a communications selection, each io-behavior of IAg is obtained by post-coupling an io-behavior of the IAg of the last case to the io-behavior of to the send or receive statement in the guard g. The same is true for IBg.
The set of io-behaviors of a selection statement is the union of the sets of io-behaviors of each of its alternatives. Hence IR ∪ IAg and IR ∪ IBg are the sets of io-behaviors of the l.h.s. and the r.h.s. , respectively.
Therefore, for any io-behavior bl of the l.h.s. there is an equivalent io- behavior br in the r.h.s. and vice versa. This is so in the case that the io-behavior belongs to IR since this set is included in both sides and equal io-behaviors are io-equivalent as well. In the remaining case, where the io- behavior is in IAg or in IBg the truth follows from the fact that [r := A(p)] =O [r := B(p)] and the guard g is the same in both sides.	 
The following result is needed for the organization of proofs around the procedures of a distributed program, making proof decomposition possible.
Lemma 4.5 (Equivalence deduction by procedure substitution)	Let P [ ] be a loop free program context, P [r := A(p)] be deadlock-free, and r := A(p) be disjoint with all its parallel substatements in P [r := A(p)]. Then, if [r := A(p)] =O [r := B(p)] , and P [r := B(p)] is deadlock-free, the equivalence P [r := B(p)] =P P [r := A(p)] holds for any У.
Justification The result follows from lemmas 4.2, 4.3, and 4.4. The mini- mal ancestor of A in P [r := A(p)], or in P [r := B(p)], is either a concatena- tion, a cooperation, or a selection. Then, equivalence between these ancestor statements follows from one of the three lemmas, and the associativity laws of both cooperation and concatenation compositions, as in next section. The same reasoning can now be applied recursively to the ancestors of these an- cestors until P [r := A(p)] and P [r := B(p)] are reached.	 

Laws for Input/Output Equivalence
Introduction
A set of laws needed for communication elimination equivalence proofs of some distributed programs is overviewed in this section. This is necessary in order to present an example of io-equivalence reasoning. Both communication elimination and the example are overviewed later in the paper.
There are both proper elimination and auxiliary laws. The latter, although not eliminating any communication directly, are needed to transform a pro- gram to a form where a proper communication elimination law can be applied. Some intuitive auxiliary laws are available in [2], where it is shown that many of them do not hold when strong fairness is assumed. Some of them are Nil; S ≈ S,	S; Skip ≈ S, S|| Skip ≈ S. In addition, both sequential and
parallel composition are associative. The latter is also commutative.
Laws for communication elimination
Attention will be restricted to statements whose communications are under the scope of neither selections nor iterations. We will refer to these statements as bounded communication (BC) statements. The number of communication events generated by their execution is finite and constant.
The laws to be given below allow the elimination of communications from BC statements. Communication elimination for some extended forms, with indefinite iterations, will also be covered in next section. For each BC state- ment S we define a set I of internal channels, whose communications have to be eliminated. The rest of the channels involved in S are external in the sense that communication statements over these channels never match with other communications in S. The following are two intuitive communication elimination laws.
[ α ⇐ e || α ⇒ u ] ≈ [u := e]
[Hl; α ⇐ e; T l]||[Hr; α ⇒ u; T r ] ≈ [Hl||Hr]; u := e; [T l||T r]
where Hl and Hr do not contain communication substatements over channels in I. As shown in [2], no bounded number of communication elimination laws suffices for the elimination, in a single reduction, of a pair of matching communications from a BC statement. The following schema of equivalences,

2	Hl ;	3	2
Hr ;	3
2  h	Hl
||	Hr
i ;3

6h Gk || Pk i ;7 || 6h Gk || Pk i ;7 =O  6  h Gk || Pk || Pk i ;	7
6	7	6	7	6	7

64	l

75	64
r	75

64  h	T l

||	T r
i 75


where k = 0, 1, ··· , defines an unbounded set of laws when we identify it with

l k+1
r k+1
] =O Gk+1

since then, the statements Gl , Gr , and Gk are defined recursively for k =
k	k
1, 2, ···	The initial condition statements Gl and Gr are α ⇐ e, and α ⇒ u,
respectively. G0 stands for u := e. There is a law for any finite integer k.
The former two laws are special cases for k = 0, 1 making some substate- ments equal to Nil. The laws hold for io-equivalence only. A law is applied as a reduction from left to right, in order to eliminate any matching pair of com- munication statements in a single reduction. Observe, also, in the last laws that some substatements are parallel in one side but not in the other. This disordering may introduce deadlock. Therefore, a set of suitable applicability conditions have to be checked for each law.

Applications to Verification
Distributed program simpliﬁcation (DPS)
This is a proof procedure applying, amongst others, the laws given above. The first step is carried out by a communication elimination reduction algo- rithm, which applies automatically the laws presented in last section. When the algorithm terminates successfully, there is a guarantee that the original statement is deadlock-free. The resulting io-equivalent form has parallelism between disjoint substatements but no internal communication statements.
The following is a procedure resulting from Pc, of subsection 2.2, after elimination of internal channel c. It has the same interface set.
(r, cr) ::= Pnc(p, cp) :: 2[cp ⇒ a1||cp ⇒ a2];	3
4r := a1+ p; a2 := r + a2; cr ⇐ a25
Each io-behavior of Pc is an io-behavior of Pnc and vice versa, so Pc =O P nc. The next step of DPS, parallelism to concatenation transformation, is car- ried out by applying permutation laws for transforming the parallel compo- sitions of disjoint processes to io-equivalent sequential forms. A sequential program io-equivalent to the initial one is obtained. The third and last step of DPS is redundant variable elimination. State-vector reduction comes with
this last step.

DPS for non-BC statements
There exist more than one way to extend simplification proofs to non-BC statements, where communications appear within indefinite loops. We will center only in the following very common structure:  S = [S1||··· ||Sm] ,


where the Sk’s are of the form Sk = loop forever do Bk. The Bk’s are BC statements. Since they have communication statements and appear within indefinite iterations, the whole statement is non-BC.
Assume that we unfold nk times the loop of each top substatement Sk, thus obtaining the statement  Su = [Bn1 ; S1||··· ||Bnm ; Sm]  , where the  Bnk ’s
1	m	k
stand for the concatenation of nk copies of Bk : Bk; ··· ; Bk .
We can apply DPS to Su partially, only considering its internal communica- tions in the Bnk statements. Assume that we succeed and obtain B; E , where B has no internal communication but the ending statement E is non-BC, it may have both parallelism and inner communication. Assume also that B; E is also reduced by DPS, partially as before, to B; B; E . Then, as a conse- quence of finite induction, S =O [Bn; E] for any finite integer n, where Bn is both inner parallelism and communication free. In the frequent case where the first elimination yields B; S, i.e.	E = S, then S =O loop forever do B and the right hand side statement has no inner communication. In many practical systems this occurs already for nk =1 ; k =1 ·· m.

Global structure of an equivalence proof
A brief account of a verification of a DLX-like [9] processor model, shown in the diagram below, will illustrate the utility of the reported results.


IF	ID	EX	WB





























The proof establishes io-equivalence between a program, pipeline2, with two hierarchical levels of parallelism and internal communication, modeling



the pipeline processor, and the following sequential program,
2for2 k := 1..n do

337

reg ::= V NCycle(reg, mem) ::
4
ir := mem(pc);
pc := pc + 1;
reg(ir.rd) := alures(ir.f unc, reg(ir.rs1), reg(ir.rs2))
575

which captures the essential behavior of the pipelined processor software model. As this program makes explicit, the processor interprets programs with ALU register to register instructions only. The instruction register is ir. The destination and source register indexes are ir.rd, ir.rs1 and ir.rs2. Procedure alures gives the result of the ALU operation selected by ir.func. Integer n is the length of the program in mem.
The parallel program has four processes connected in pipeline, modeling the four stages above: IF, ID, EX, and WB. Processes ID and EX are modeled with the following procedures which encapsulate a second level of parallelism.
(cxwW, cxwRES, cxwRD) ::= EXpar(cdxW, cdxA, cdxB, cdxRS1, cdxRS2, cdxF UNC, cdxRD, cwx) ::

2  2loop forever do ( ID/EX (dx) register )	33
6  6  2dxA ⇐ dx.a; dxB ⇐ dx.b; dxRS1 ⇐ dx.rs1; dxRS2 ⇐ dx.rs2; dxF UNC ⇐ dx.f unc;377

6 64
6
xxw.w := dx.w; xxw.rd := dx.rd;
cdxW ⇒ dx.w; cdxA ⇒ dx.a; cdxB ⇒ dx.b; cdxRS1 ⇒ dx.rs1; cdxRS2 ⇒ dx.rs2; cdxFUNC ⇒ dx.f unc; cdxRD ⇒ dx.rd; cxwW ⇐ xxw.w; cxwRD ⇐ xxw.rd
75757
7

||
6 2	3	7
loop forever do ( wx register )

6 64
"cwx ⇒ wx;
#75	7

wxRESa ⇐ wx.res; wxRESb ⇐ wx.res; wxRD ⇐ wx.rd
||

6  2loop forever do ( Forwarding control )
337	7

6 664
dxRS1 ⇒ rs1; dxRS2 ⇒ rs2;
wxRD ⇒ rd;
selA := (rs1= rd); selB := (rs2= rd);
selMuxA ⇐ selA; selMuxB ⇐ selB
75775	7

||
2	3
loop forever do ( Multiplexor of ALU input A )
6

6 64
dxA ⇒ a; wxRESa ⇒ resA; selMuxA ⇒ selA;
if selA then aluA := resA else aluA := a;
caluA ⇐ aluA	7

||
2	3
loop forever do ( Multiplexor of ALU input B )

6 64
dxB ⇒ b; wxRESb ⇒ resB; selMuxA ⇒ selB;
if selB then aluB := resB else aluB := b;
caluB ⇐ aluB	7

||
2	3
loop forever do ( ALU )
6	37	7

664
664
caluA ⇒ a; caluB ⇒ b; dxF UNC ⇒ func;
xxw.res := alures(func, a, b);
cxwRES ⇐ xxw.res
775775
775



(reg, cdx w, cdx a, cdx b, cdx rs1, cdx rs2, cdx func, cdx rd) ::= IDpar(reg, cfd, cwdW, cwdRES, cwdRD) ::
2  2loop forever do ( IF/ID (fd) register ) 37	3
2fdRS1 ⇐ fd.rs1;	3
6  6  6fdRD ⇐ fd.rd;	7	7	7
6  2	37
loop forever do ( Registers )
3

cwdW ⇒ wd.w; cwdRES ⇒ wd.res; cwdRD ⇒ wd.rd; control ⇒ w;
if (wd.w) then [reg(wd.rd) := wd.res] else nil;
6  6
777
777
777

:=
6	6
777

(w, reg(ir.rs1), reg(ir.rs2), ir.rs1, ir.rs2, ir.f unc, ir.rd);
6  6	777

fdRS1 ⇒ ir.rs1;
fdRS2 ⇒ ir.rs2; fdRD ⇒ ir.rd;
fdFUNC ⇒ ir.func; cdxW ⇐ xdx.w;
cdxB ⇐ xdx.b; cdxRS1 ⇐ xdx.rs1;
cdxFUNC ⇐ xdx.func;
6	cdxRD ⇐ xdx.rd

777


777

557

6|| 2	3	7
64	loop forever do ( Control )	75
4 hcontrol ⇐ true	i5

This detail is given not to be understood by the reader, but to illustrate the non-triviality of the example. The proof establishes the io-equivalence
[reg ::= V NCycle(reg, mem)] =O [reg ::= Pipeline2(reg, mem)]
where 0 : {reg, mem}. This result is proved with three DPS proofs, and the application of the io-equivalence reasoning rules introduced in this paper. Al- though the pipelined structure has more stages, we illustrate the partitioning of the proof only with the instruction decode (ID) and the execution (EX) stages. The two are modeled as sequential procedures also, IDseq and EXseq. With two DPS proofs, the following equivalences are established.
[reg, coutID ::= IDseq (reg, cinID)] =O [reg, coutID ::= IDpar(reg, cinID)] [coutEX ::= EXseq (cinEX)] =O [coutEX ::= EXpar(cinEX)]
The cout and cin names denote the lists of output and input channels respec- tively. Procedure Pipeline2 above has references to the procedures with inner parallelism, Pipeline2: Pipeline[IDP ar, EXP ar]. Pipeline is a procedure with one level of parallelism and two holes for the references to ID and EX.


An auxiliary procedure, Pipeline1, is defined as Pipeline with the references to the sequential procedures, Pipeline1 : Pipeline[IDSeq, EXSeq]. It has one level of parallelism. It is the following:
reg ::= Pipeline1(reg, mem) ::

local	pc	: integer
local	w	: boolean
local	instr, ir	: Typ IR
local	xdx, dx	: Typ DX
local	wd, wx, xxw, xw	: Typ XW
local	cfd	: channel of Typ IR
local	cdx	: channel of Typ DX
6local	cwd, cxw, cwx	: channel of Typ XW	7
pc := 1;
(ir.rs1, ir.rs2, ir.rd, ir.f unc) := (0, 0, 0, 0);
(dx.w, dx.a, dx.b, dx.rs1, dx.rs2, dx.f unc, dx.rd) := (false, 0, 0, 0, 0, 0, 0); (xw.w, xw.res, xw.rd) := (false, 0, 0);
6 (wx.w, wx.res, wx.rd) := (false, 0, 0);	7
6  2	2loop forever do	3	37

6  IF ::
2instr := mem(pc);37	||	77

6 6	4
6 6
pc := pc + 1;
cfd ⇐ instr
2loop forever do	77

6 6	seq 6
cwd ⇒ wd;
if (wd.w) then [reg(wd.rd) := wd.res] else nil;
(xdx.w, xdx.a, xdx.b, xdx.rs1, xdx.rs2, xdx.func, xdx.rd)	||	7

:=
6 6	6  6
77	77

6 6	6
(w, reg(ir.rs1), reg(ir.rs2), ir.rs1, ir.rs2, ir.f unc, ir.rd);
5	7

6  6	2loop forever do
37	77


6 6 EXseq :: 6
cwx ⇒ wx;
if (dx.rs1= wx.rd) then [dx.a := wx.res] else nil;
6if (dx.rs2= wx.rd) then [dx.b := wx.res] else nil;
377


||77

6 6	6
(xxw.w, xxw.res, xxw.rd) := (dx.w, alures(dx.f unc, dx.a, dx.b), dx.rd);
5

6  6	2loop forever do 37	77

64 64
WB ::
4
cwd ⇐ xw; cwx ⇐ xw; cxw ⇒ xw
7575


The bodies of procedures IDseq and EXseq are given in it. Notice that groups of channels in the parallel versions have been reduced to a single channel in the sequential versions. A channel group hide/unhide equivalence rule, given in [1], has been used in this part of the proof. Then, the equivalence
[reg ::= V NCycle(reg, mem)] =O [reg ::= Pipeline1(reg, mem)]
is established with a DPS proof. Finally, Pipeline1 =O Pipeline2 by the substitution rule of lemma 4.5, and assuming that its deadlock-freeness conditions hold. These hold since the success of the communication elimina-


tion algorithm guarantees deadlock-freeness of Pipeline1. Deadlock-freeness of Pipeline2 follows from deadlock-freeness of Pipeline1 and conservation of the order of the external communication offers of the parallel and sequential versions of the EX and ID procedures.

Conclusions and Future Work
A new semantics for distributed imperative programs has been presented as an extension of the semantics of Manna and Pnueli. Auxiliary variables, recording the list of values crossing channels, have been added to the state variables of computations and reduced behaviors. A general formulation of input/output equivalence of procedures, integrating values communicated through both vari- ables and synchronous channels, and a procedure reference substitution rule, have been formulated in the new semantics. A new set of laws for distributed imperative programs, and the decomposition of distributed program simplifi- cation proofs, via communication elimination, have been made possible with the new results. As an application example, a formal equivalence proof of a pipelined processor model has been summarized.
Although other equivalence proofs for distributed programs have been car- ried out already, this line of effort should continue for other classes of such programs. Soundness of the laws for io-equivalence was proved in a prior work. Completeness should be studied in the future.

Acknowledgement
We thank the encouragement received during the last years from Zohar Manna, Bernd Finkbeiner, and Tomas Uribe.

References
Babot, F., M. Bertran, J. Riera, R. Puig and A. Climent, Mechanized Equivalence Proofs of Pipelined Processor Software Models, in: Actas de las III Jornadas de Programacio´n y Lenguajes (2003), pp. 91–104.
Bertran, M., F. Babot, A. Climent and M. Nicolau, Communication and Parallelism Introduction and Elimination in Imperative Concurrent Programs, in: P. Cousot, editor, Static Analysis. 8th International Symposium, SAS 2001, LNCS 2126 (2001), pp. 20–39.
Bjørner, N., A. Browne, B. F. M. Col´on, Z. Manna, H. Sipma and T. Uribe, Verifying Temporal Properties of Reactive Systems. A Step Tutorial, in: Formal Methods in System Design, 2000,
pp. 227–270.
Broy, M., A logical basis for component-based systems engineering, in: M. Broy and
R. Steinbruggen, editors, Calculational System Design. (1999).
Clarke, E., O. Grumberg and D. Peled, “Model Checking,” The MIT Press, 1999.


de Alfaro, L., Game Models for Open Systems, in: International Symposium on Veriﬁcation (Theory and Practice), LNCS 2772 (2003).
de Roever, W.-P., F. de Boer, U. Hanneman, Y. Lakhnech, M. Poel and J. Zwiers, “Concurrency Verification: Introduction to Compositonal and Noncompositional Methods,” Cambridge University Press, 2001.
Finkbeiner, B., Z. Manna and H. Sipma, Deductive Veriﬁcation of Modular Systems, in: In Compositionality: The Signiﬁcant Difference, COMPOS’97, LNCS 1536 (1998), pp. 239–275.
Hennessy, J. L. and D. A. Patterson, “Computer Architecture: A Quantitative Approach,” Morgan Kaufmann Publishers Inc., San Mateo, California, 1990.
Holtzmann, G., “Design and Validation of Computer Protocols,” Prentice Hall, 1991.
INMOS-Limited, “Occam Programming Manual,” Prentice Hall, 1985.
INMOS-Limited, “Occam 2 Reference Manual,” Prentice Hall, 1988.
Jones, G., “Programming in Occam,” Prentice Hall, 1987.
Kaufmann, M. and J. S. Moore, An Industrial Strength Theorem Prover for a Logic Based on Common Lisp, IEEE Transactions on Software Engineering 23 (1997), pp. 203–213.
Manna, Z. and A. Pnueli, “The Temporal Logic of Reactive and Concurrent Systems. Specification,” Springer, 1991.
Manna, Z. and A. Pnueli, “Temporal Verification of Reactive Systems. Safety,” Springer, 1995.
McMillan, K. and D. Dill, “Symbolic Model Checking: An Approach to the State Explosion Problem,” Kluwer Academic, 1993.
Roscoe, A. and C. Hoare, The laws of OCCAM programming, Theoretical Computer Science
60 (1988), pp. 177–229.
