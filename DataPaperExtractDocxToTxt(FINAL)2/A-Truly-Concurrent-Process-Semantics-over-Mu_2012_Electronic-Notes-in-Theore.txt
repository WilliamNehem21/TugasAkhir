Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 307–321
www.elsevier.com/locate/entcs

A Truly Concurrent Process Semantics over Multi-Pomsets of Consumable Resources
Dan Teodosiu 1
Paris Centre Mathematical Sciences University Paris Diderot (Paris 7) 75205 PARIS CEDEX 13, France

Abstract
This paper develops a truly concurrent semantical approach, whereby concurrency is notionally independent of nondeterminism, that allows describing the deterministically concurrent behaviour of recursive processes accessing consumable resources. The process semantics is based on the new coherently complete and prime algebraic domains of real and complex multi-pomsets. The process language that we study contains several deterministic quantitative process operators, namely a renaming, a hiding, a restriction, a serial and a parallel operator, as well as a recursion operator. The displayed deterministic structural operational ma- chine engenders a linear and a complex operational semantics. A compositional denotational semantics is constructed, which uses a functional domain over environments of complex multi-pomsets. The robustness of the presented semantical work is established by proving that the denotational semantics is fully abstract with respect to both linear and complex operational semantics.
Keywords: process calculus, true concurrency, resource, consumption, quantification, pomset, denotational semantics, structural operational semantics, full abstraction.


Introduction
The seminal work of Hennessy & Plotkin [6] has shown how power domains could be employed to build semantic models that support parallel composition of pro- cesses. Supposing that a choice operator is part of the language, parallelism is simply reduced to interleaving and choice, thus introducing nondeterminism into the semantic models.
In this presentation, we follow a genuine approach to parallelism and concur- rency, which avoids using choice and nondeterminism. We, thereby, rely on true concurrency, which has inspired a wealth of domain-theoretic approaches. These are mainly due to the insight that the prime event structures of Winskel [12] are domains that provide suitable models to express truly concurrent process combina- tions.

1 Email: dan.teodosiu@wanadoo.fr

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.020

However, to our knowledge, the only truly concurrent semantical approach that has actually developed an operational and a matching denotational programming semantics, allowing for finitary process combinators, as well as recursion, originates in the work of Diekert & Gastin [2], Gastin & Teodosiu [5] and Gastin & Mislove [4]. The underlying denotational models are the pomsets advocated by Pratt [9] which, although being particular event structures, allow to simply express truly concurrent process combinations. Its intuition is based on the appealing interaction between processes and resources in any environment, a paradigm also driving the applied work in computer science of the last decades. One should also note the related work of Pym & Tofts [10] presenting a truly concurrent algebra and logic of processes and resources for a number of process combinators including choice.
A new stream in automata theory, as emphasized by the recent monograph on weighted automata [3], consists in attaching weights to transitions which express their cost or consumption in terms of some available resources and to extend these notions to recognized words and languages. Classical automata theory can in par- ticular be recovered by considering unit weights, which is why the weighted view is more versatile, opening the way to new applications in engineering and economy.
The present process language combines the above truly concurrent approach on the denotational side with a weighted automata view on the operational side. To this end, the labeling of the denotational models and of the operational transition rules is quantified with the bounded or unbounded time or amount of resources being consumed. Quantification requires to replace the previously employed algebra of sets of resources, seen as vectors over the booleans, by an algebra of multi-sets of resources, seen as vectors over the extended positive reals, while taking care that relevant algebraic properties remain valid in this new setting. Furthermore, it leads to defining operators whose quantitative semantics enriches that of previ- ously considered operators (serial, parallel), together with operators having a new, quantitative semantics (renaming, hiding, restriction, recursion).
Our semantics differs from previous approaches in several technical respects. Firstly, the representation of processes as complex multi-pomsets relies on a real part and a consumption part, which allows to trivially check the consumption com- mutation and continuity. Secondly, the new preﬁx partial order on complex multi- pomsets substantially simplifies the proofs, allowing to check the complex continuity solely for the real part. Finally, the semantics of recursion relies on the continuity with respect to two orders instead of one.
The paper is structured as follows. Section 2 recalls basic facts about partial orders. Section 3 introduces the domains of real and complex multi-pomsets. Section 4 presents the process language and defines the consumption semantics. Section 5 displays a deterministic structural operational machine, which engenders the linear and complex operational semantics. Section 6 is devoted to the compositional deno- tational semantics using a functional domain over environments of complex multi- pomsets. Section 7 presents the main results of congruence and full abstraction of the denotational semantics with respect to both linear and complex operational semantics.

The interested reader may find a complete version of our results in [11].
Partial Orders
For a detailed exposition we refer to the presentation of Abramsky & Jung [1].
A partial order (PO) is a pair (X, ≤) where ≤ is a reflexive, antisymmetric and transitive binary relation on X. A subset Y ⊆ X is directed (coherent ) iff it is non-empty and for all x, y ∈ Y there exists z ∈ Y (z ∈ X) such that x ≤ z and y ≤ z. Any directed set is coherent. (X, ≤) is a coherently complete PO (CCPO) (directed complete PO (DCPO)) iff every coherent subset (directed subset) has a least upper bound. Any CCPO is a DCPO.
An element x ∈ X is prime (compact ) iff for all (directed) subsets Y ⊆ X having a least upper bound, x ≤  Y implies x ≤ y for some y ∈ Y . The set of all prime (compact) elements of X below y ∈ X is denoted by Prm(y) (Kmp(y)). A partial order (X, ≤) is p-algebraic iff x =  Prm(x) for all x ∈ X. It is k-algebraic iff Kmp(x) is directed and x =  Kmp(x) for all x ∈ X. In the case of CCPOs, p-algebraicity also implies k-algebraicity.
A k-algebraic DCPO is called a (Scott-)domain. A mapping F : (X, ≤) →
(Xj, ≤j) is (Scott-)continuous iff for all directed sets Y ⊆ X, such that	Y exists,
j F (Y ) exists, and F (	Y )=	j F (Y ).
The set of finite ordinals (i.e. the least infinite ordinal) is denoted by ω.
Real and Complex Multi-Pomsets

We denote by + the set of positive reals and by + = + ∪{∞} the set of positive extended reals. The notations  and  are reserved for later purposes.
We fix in this section a countable set of resources R. The alphabet is the set of multi-sets of resources   = R →  +. We define 0, ∞ ∈   by 0(α) = 0 and
∞(α)= ∞ for all α ∈ R. The set of actions is  Y =  \ {0}.
The multiplicity attached by an action to a resource measures for instance the time consumed. The notion of time may just as well be replaced by amount, while the term consumed may be replaced by produced. If, for example, R = {A, B, C} then an action consuming respectively 3.5, 5.7 and 7.3 time units of A, B and C is denoted by the multi-set 3.5A + 5.7B + 7.3C. Concrete examples might come from computer science (an action consuming 5 processor, 10 channel and 2 memory time units) or workflow management (an action consuming 100 man, 5 tool and 10 object time units).
On  we define componentwise the order ≤⊆  × , the complement¯:  → , the sum + :  ×  →  , the infimum ∧ :  ×  →  , the supremum ∨ :  ×  → and the skew difference \ :  ×  →  , whereby for all n, m ∈  + we set n = ∞ if n = 0, n = 0 if n /= 0, n \ m = ∞ if n = ∞, n \ m = 0 if n /= ∞ and m = ∞, n \ m = (n − m) ∨ 0 if n, m /= ∞.
For a, b ∈   such that b ≤ a let a − b = a \ b. For a, b ∈   we define the
independence a ⊥ b iff a ∧ b = 0.


	
For a ∈  = R →  + and S ∈ R × R →  + we set S(a) = aS as a vector- matrix multiplication. The set of renamings  Y ⊆ R × R →  + is defined by S ∈  Y iff (a /= 0 =⇒ S(a) /= 0 for all a ∈  ) and (a ⊥ b =⇒ S(a) ⊥ S(b) for all a, b ∈  ).

The Domain of Real Multi-Pomsets 
A real multi-labelled partial order is a triple (E, ≤, ρ), where
the synchronization relation ≤⊆ E × E is a partial order on the set of events E satisfying the past ﬁniteness condition that { f ∈ E | f ≤ e } is finite for each e ∈ E,
the event-labelling ρ : E → Y satisfies the over-synchronization condition that ρ(e) ∧ ρ(f ) /=0 =⇒ e ≤ f or f ≤ e for each e, f ∈ E.
A real multi-pomset is the isomorphism class [E, ≤, ρ] of a real multi-labelled partial order (E, ≤, ρ). The set of real multi-pomsets is denoted by  . A ﬁnite multi-pomset is a multi-pomset whose event set is finite. The set of ﬁnite multi- pomsets is denoted by  . The empty multi-pomset is 0 = [∅, ∅, ∅] ∈  . For all a ∈  Y we define the action multi-pomset a = [({∅}, {(∅, ∅)}, {(∅, a)})] ∈  .
The synchronization relation reflects the temporal (or causal) order between the events of the multi-pomset. The past finiteness condition is a technical assumption that restricts the definition to real multi-pomsets, but can be relaxed if one wishes to deal with transfinite multi-pomsets.
The over-synchronization condition is equivalent to the fact that for each re- source the events consuming it are sequentialized (totally ordered). In partic- ular it implies that the multi-pomset has no auto-concurrency, that is, for all a ∈  Y the set ρ−1(a) = { e ∈ E | ρ(e) = a } is totally ordered by ≤. The number of occurrences | |a :   → ω +1 of a ∈  Y is defined for all x ∈   by
|x|a = ord(ρ−1(a), ≤ ∩ ρ−1(a) ×ρ−1(a)) ≤ ω, that is the ordinal associated with the well-order induced by ≤ on ρ−1(a).
In order to avoid cumbersome isomorphism proofs we define the standard repre- sentative of x = (E, ≤, ρ) as the unique isomorphic real multi-labelled partial order xˆ = (Ex, ≤x, ρx), such that
Ex = φx(E)= { (a, n) | a ∈  Y and n < |x|a } ⊆  Y × ω =  ,
(a, n) ≤x (a, m) for all a ∈  Y and n ≤ m < |x|a
ρx(a, n)= a for all a ∈  Y and n < |x|a.
The past in x ∈  of F ⊆  is ↓x F = { e ∈ Ex | ∃ f : e ≤x f ∈ F } . The restriction of x ∈  to F ⊆  is x/F = [Ex ∩ F, ≤x ∩F × F, ρx ∩ F ×  Y]. The preﬁx is defined for all x, y ∈  by x ≤ y iff Ex = ↓y Ex and x = y/Ex.
The next theorem shows that (  , ≤) is an interesting semantic domain.
Theorem 3.1 (  , ≤) is a p-algebraic CCPO, hence, it is a (Scott-)domain.

The alphabet alph :  → P( ) is defined for all x ∈  by alph(x)= { ρx(e) | e ∈ Ex } . The consumption cons :   →   is defined for all x ∈  by cons(x) = e∈Ex ρx(e). It can be shown that cons : ( , ≤) → ( , ≤) is continuous. For x, y ∈
  we define the independence x ⊥ y iff cons(x) ⊥ cons(y). The inﬁnite consumption
consinf :   →   is defined for all x ∈   and α ∈ R by consinf(x)(α) = ∞ if cons(x)(α)= ∞ and consinf(x)(α) = 0 otherwise.
We need later on the following definitions. For a ∈  Y and x ∈  satisfying the action preﬁx a ≤ x let the action residue be a—1x = x/(Ex \ {(a, 0)}). Let 0

denote the empty string in  ∗ . For u ∈  ∗
and x ∈  we define the linear preﬁx

Y	Y
u ª x and the linear residue u—1x inductively on u by:
Let 0 ª x and 0—1x = x,
For a ∈  Y let ua ª x iff u ª x, a ≤ u—1x, and let (ua)—1x = a—1(u—1x).
The set of linearizations of r is Lin(x)= { u ∈  ∗ | u ª x, u—1x = 0 } .
We note that for any a ∈  Y ⊆  and x ∈  we have a ª x iff a ≤ x iff x contains a minimal event labelled with a, so in this case the prefix and linear prefix relation coincide.
The main deficiency of ( , ≤) is the fact that it is unsuitable to define contin- uous denotations for the operators of our process language, since for example the sequential composition is not monotone (hence, not continuous). This is indeed not surprising, since already the sequential composition (catenation) of strings is not monotone with respect to the prefix order, as can be easily seen on the example a ≤ a; aj and b ≤ b; bj but a; b /≤ (a; aj); (b; bj) unless aj is empty.

The Domain of Complex Multi-Pomsets 
We surmount the above obstacle by introducing the domain of complex multi- pomsets.
A complex multi-pomset is a pair x = (r, R), where r ∈  is a real multi-pomset, and R ∈  is a multi-set of resources, such that cons(r) ≤ R. The set of complex multi-pomsets is denoted by  . The multi-pomset r is denoted by Re(x) and called the real part of x. The multi-set R is denoted by cons(x) and called the consumption part of x.
The imaginary part of x ∈  is Im(x) = cons(x) − cons(Re(x)). If its imagi- nary part Im(x) is zero, the complex multi-pomset x is called terminated. Note that, due to the convention regarding ∞ and the difference operator, we have consinf(Re(x)) ≤ Im(x).
The first component of a complex multi-pomset is a real multi-pomset describ- ing the observed part of the process, while the second component is a multi-set of resources representing the quota actually consumed by the process during its execution.
The preﬁx is defined for all (r, R), (s, S) ∈   by (r, R) ≤ (s, S) ⇔ r ≤ s and R = S. The underlying idea here is that we increase the information about a process by letting grow its observable part r ≤ s, while preserving the quota R = S

that may be consumed during the execution.
The next theorem shows that (  , ≤) is a suitable semantic domain.
Theorem 3.2 (  , ≤) is a p-algebraic CCPO, hence, it is a (Scott-)domain.

We need later on the following definitions.	For u ∈  ∗
and x ∈   we

extend the linear preﬁx by u ª x iff u ª Re(x) and the linear residue by
u—1x = (u—1 Re(x), cons(x) − cons(u)).
The main virtue of ( , ≤) is the fact that it allows defining internal and contin- uous denotations for all process operators of our language.
The Process Language
We fix in the following a countable set of constants C and a disjoint countable set of variables V. The set of resources is R = C ∪ V. The set of constant actions is
  C = (C →  ) \ {0}⊆  Y.
The language of terms L is generated by the following BNF-style grammar


p ::= SKIP | c | S(p) | p T | p  T | p · p | p

for all c ∈  C , S ∈  Y, T ∈  , C ⊆  Y and x ∈ V.
 p | x | rec x.p
C

Here, SKIP is the empty process, c is a constant action, S() is renaming through
S,  T is hiding of the consumption T ,  T is restriction to the consumption T , ·

is serial composition, 
C
is parallel composition synchronized on the channels in C,

x ∈V is a variable and rec x. is recursion over x.
The language of closed terms Lc is the set of terms without free variables.
The consumption Cons(p) :  V →  of a process term p ∈ L is inductively defined for all τ ∈  V by
Cons(SKIP)(τ ) = 0 
Cons(c)(τ ) = c Cons(S(p))(τ ) = S(Cons(p)(τ )) Cons(p T )(τ ) = Cons(p)(τ ) \ T
Cons(p  T )(τ ) = Cons(p)(τ ) ∧ T
Cons(p · q)(τ ) = Cons(p)(τ )+ Cons(q)(τ )

Cons(p 
C
q)(τ ) = Cons(p)(τ ) ∨ Cons(q)(τ )

Cons(x)(τ ) = τ (x)
Cons(rec x.p)(τ ) = lfp≤ R.({x} + Cons(p)(τ [x '→ R]))
For τ ∈ V we define τ [x '→ R] to be identical to τ on all arguments except x that is assigned the value R. The characteristic mapping {x}∈  is defined for all α ∈R by {x}(α) = 0 for α /= x and {x}(α) = 1 for α = x. One may show by structural induction over p ∈ L that Cons(p) : ( , ≤)V → ( , ≤) is continuous. Thus, the above definition determines a compositional consumption semantics Cons : L → (( , ≤)V → ( , ≤)).

The Operational Semantics
Table 1 presents the transition rules of our deterministic structural operational machine, whereby we let c ∈  C , T ∈  , C ⊆  Y, x ∈ V, p, pj, q, qj ∈ L, a ∈
 Y ∪ {0}, τ ∈ U . As usual, p[q/x] denotes the term that is obtained from p after substituting all occurrences of the variable x by q. Note that recursion is modelled in an observable way, each unwinding producing as observation the variable being recursed, which may subsequently be renamed or hidden.

For u ∈  ∗
and p, pj ∈ L, τ ∈  U , let the linear transition p =u⇒ pj be induc-
τ

tively defined on the length of u by
Let p =0⇒ pj iff p = pj,
τ
For a ∈  Y let p =u⇒a pj iff there exists q ∈L such that p =u⇒ q and q −a→ pj
τ	τ	τ
Using the linear transition we next define a linear and a complex operational semantics of closed process terms as follows.
The linear behaviour of p ∈ Lc is  ∗ (p)= { u ∈  ∗ | p =u⇒ } .
Y	Y
For any fixed E ⊆   the intersection	P of a set P ⊆   such that for all
r ∈ P we have Er = E is defined by ET P = E and ≤T P =  { ≤r | r ∈ P } . The
restriction of p ∈ Lc to E is p/E =  { u ∈  ∗ | p =u⇒ and Eu = E } .
The complex behaviour of p ∈ Lc is  (p)= { (p/Eu, Cons(p)) | p =u⇒ } .

p −a→ pj

[ACT]
[SER1] 	τ	

c −→c
τ
SKIP
p · q −a→
τ
pj · q

p −a→ pj	Cons(p)(τ ) ⊥ a, q −a→ qj
[REN] 	τ		[SER2] 	τ	

S(a)
S(p) −→
τ
S(pj)
p · q −a→
τ
p · qj

p −a→ pj
a ∈ C, p −a→ pj, q −a→ qj

[HID] 	τ	
[PAR0]
	τ	τ	

a\T
p T −→
τ
pj (T \ a)
p  q −a→
C	τ
pj  qj
C

p −a→
pj, a ≤ T
C, Cons(q)(τ ) ⊥ a, p −a→ pj

[RES] 	τ		[PAR1] 	τ	

p  T
−a→
τ
pj  (T − a)
p  q −a→
C	τ
pj  q
C

rec x.p = q
[REC]
[PAR ]
C, Cons(p)(τ ) ⊥ a, q −a→ qj
τ

{x}
q −→
τ
p[q/x]
2	p  q −a→
C	τ
p  qj
C



Table 1

The Denotational Semantics
We next construct a denotational semantics for our process language using a func- tional domain over environments of complex multi-pomsets.
We endow the set of environments  U with the product order ≤, that is, we set ( U , ≤) = ( , ≤)U . consU :  U →  U is defined for all environments σ ∈  U and x ∈ V by consU (σ)(x)= cons(σ(x)). We have a canonical embedding  ‹→ , R '→ (0, R), which allows identifying  with its image in  and set  ⊆ . Therefore, any function on  U is a function on  U .
The functional domain  is the set of mappings f : U →  satisfying the following functional conditions
consumption commutation: cons(f (σ)) = f (consU (σ)) for all σ ∈  U ,
consumption continuity : f : (  , ≤)U → (  , ≤) is continuous,
complex continuity : f : (  , ≤)U → (  , ≤) is continuous.
We pointwise lift the ordering ≤ from   to  , that is, for f, g ∈   we define
f ≤ g iff f (σ) ≤ g(σ) for all σ ∈  U .
Proposition 6.1   is closed by substitution and (  , ≤) is a DCPO.
The denotational semantics [[]] : L →  inductively defined below is uniquely determined by the denotation which will be defined in the next subsections for each ﬁnitary operator symbol as an operation on  having the same arity and satisfying the functional conditions of  (that is, we indeed have [[SKIP]], [c]], [S(p)]], [p T ]],

[[p T ]], [[p · q]], [[p 
C
q]] ∈  for p, q ∈ L) and the denotation which will be defined for

the inﬁnitary recursion operator symbol as an operation on   (that is, we indeed
have [[rec x.p]] ∈  for p ∈ L). Hereby, consumption commutation and continuity are straightforward to check whereas complex continuity is increasingly difficult to prove. From the above we may thus in advance state the following
Theorem 6.2 The denotational semantics [[]] : L→  inductively deﬁned by
[[SKIP]](σ) = (0, 0)	[p · q]](σ) = [[p]](σ) · [[q]](σ)

[[c]](σ) = (c, c)	[p 
C
q]](σ) = [[p]](σ) 
C
[[q]](σ)

[[S(p)]](σ) = S([[p]](σ))	[x]](σ) = σ(x)
[[p T ]](σ) = [[p]](σ) T	[[rec x.p]](σ) = (rec x.[[p]])(σ) [[p T ]](σ) = [[p]](σ) T
is well-deﬁned, that is [[p]] ∈  for all p ∈ L.
Directly on the denotation of each of the operators SKIP, c, S(),  T ,  T , ·, and rec x. we will also be able to inductively check the following
C
Proposition 6.3 If p ∈ L, σ ∈  U then cons([[p]](σ)) = Cons(p)(consU (σ)). We now proceed with the denotation of the operators of our language.

The Renaming Operator S(x)
Renaming amounts to a simple relabeling which preserves the events and their initial ordering. Simple as it may seem it nevertheless allows linear computations to take place on the labels of the events and may, therefore, be used to derive further operators from those of our language.
For every S ∈  Y the renaming operator S() :  →   is defined by S([E, ≤
, ρ]) = [E, ≤, S(ρ)], whereby S(ρ)(e) = S(ρ(e)) for all e ∈ E.  For every S ∈
 Y the renaming operator S() :  →  is defined for all x ∈  by S(x) = (S(Re(x)), S(cons(x))).

The Hiding Operator x T
The hiding operator allows to internalize some given quota of resources and prevents other processes from synchronizing on events that make use of them. As usually, this expresses the need for local, as opposed to global, computation and communication. For every T ∈  the hiding operator  T :  →  is defined for all [E, ≤, ρ]
∈  by [E, ≤, ρ] T = [Ej, ≤j, ρj] where
ρj(e)= ρ(e) \ (T \	f≺e ρj(f )),
Ej = { e ∈ E | ρj(e) /= 0 } ,
≤j=≤ ∩Ej × Ej.
For every T ∈   the hiding operator  T :   →   is defined for all x ∈   by
x T = (Re(x) T, cons(x) \ T ).
The hiding x T erases a given additive consumption T out of the past of each event of x, thereby rendering it unobservable.

The Restriction Operator x  T
The restriction operator blocks a process on all but some given quota of resources. This is used for instance in order to assure confinement of that process to a certain safe environment and may be useful in security protocols.
For every T ∈  the restriction operator  T :  →  is defined for all x ∈ by x T =	{ y ∈  | y ≤ x, cons(y) ≤ T } . For every T ∈  the restriction operator  T :  →  is defined for all x ∈  by x  T = (Re(x)  T, cons(x) ∧ T ).
One can easily see that x  T is the restriction of x to the set of events having a past that additively consumes resources below T , that is, we have x  T = x/Ej

where Ej
= { e ∈ Ex | Σ
f≤xe
ρx(f ) ≤ T } .

The Serial Composition x · y
The following presentation of the serial composition is a generalization of the con- catenation treated in [5]. The serial composition enforces synchronizations between the first and the second process only to prevent races for resources. Events at the end of the first and events at the beginning of the second process can thus occur

concurrently if they are independent. This construct may be of interest in automatic code parallelization and in transactional systems.
The serial composition · :  2 →  is defined for all x1 = [E1, ≤1, ρ1] ∈  and
x2 = [E2, ≤2, ρ2] ∈  if consinf(x1) ∧ cons(x2)=0 by x1 · x2 = [E, ≤, ρ], where
E = E1 ∪˙ E2,

≤= (≤1 ∪˙ { (e1, e2) ∈ E1 × E2 | ρ1(e1) ∧ ρ2(e2) /= 0 } ∪˙
ρ = ρ1 ∪˙ ρ2.
≤2)∗,

The serial composition · :  2 →  is defined for all x, y ∈  by x · y = (Re(x) ·
(Re(y)  Im(x)), cons(x)+ cons(y)).
It can be shown that using the serial composition together with hidings enables us to denote all compact multi-pomsets by closed terms of the process language, which means that the denotational semantics is optimal.
The Sequential Composition x ; y
The sequential composition should be employed whenever there is a need to tempo- rally completely synchronize two processes. The compound processes are scheduled such that the entire first process occurs before the entire second process, hence they are temporally ordered, even if independent.
The sequential composition ;:  2 →  is defined for x1 = [E1, ≤1, ρ1] ∈  and

x2 = [E2, ≤2, ρ2] ∈   by x1 ; x2 = [E1 ∪˙ E2, (≤1 ∪˙
E1 × E2 ∪˙
≤2)∗, ρ1 ∪˙ ρ2]. The

sequential composition ;:  2 →  is defined for all x, y ∈  by
x ; y =	(Re(x); Re(y), cons(x)+ cons(y)) if Im(x)=0 (Re(x), cons(x)+ cons(y))	otherwise.
It can be shown that the sequential composition can be expressed as a renaming of a the serial composition of renamings of the compound processes, hence it is a derived operator of our process language. We shall later on essentially use the sequential composition in order to define the denotational semantics of recursion.
The Parallel Composition x  y
C
The following presentation of the parallel composition is a generalization of the one treated in [4]. The parallel composition is indexed by a set of channels that processes are supposed to employ in order to synchronize. Events accessing the channels are commonly processed by the compound processes, while events which make no use of the channels may be independently processed by each compound process. This construct may in particular be used to model data-parallel programs running on PRAMs.
Let x1 = [E1, ≤1, ρ1], x2 = [E2, ≤2, ρ2] ∈  be in standard representation. We define their parallel composition by x1  x2 = [E1 ∪ E2, (≤1 ∪ ≤2)∗, ρ1 ∪ ρ2]. Note that x1  x2 may fail to be a real multi-pomset for two different reasons. First, ≤ may fail to be antisymmetric. This is the case for instance if x1 = a ; b and x2 = b ; a. Second, ≤ may fail to be over-synchronized. This is the case for instance if x1 = a

and x2 = b with ¬(a ⊥ b).
Let x1, x2 ∈  and C ⊆  Y. We define (r1, r2) ∈  C (x1, x2) ⊆  2 iff
for all i ∈ {1, 2} we have ri ≤ Re(xi),
|r1|a = |r2|a for all a ∈ C,
for all {i, j} = {1, 2} and a ∈ alph(ri) we have a ∈ C or (a ⊥ C and a ⊥ xj),
r1  r2 ∈  .

The parallel composition


 :  2 →  is defined for all x1, x2 ∈  and C ⊆  Y
C	W

The Recursion Operator rec x.f
The denotation of the recursion operator essentially differs from the least fixed point semantics. Indeed, the recursion operator rec x. :  →  , f '→ rec x.f is defined by computing (rec x.f )(σ) for all f ∈  and σ ∈ U using two chained fixed point computations. Firstly, we compute the least consumption of a fixed point by solving the recursion in the consumption domain ( , ≤) and, secondly, we compute the least fixed point having the least consumption by solving the recursion in the complex domain ( , ≤), as follows.
For σ ∈  U we define as usual σ[x '→ y] to be identical to σ on all arguments except x, which is assigned the value y. For x ∈V we define  x :  ×  U ×  → by Cx(f, σ, y) = {x} ; f (σ[x '→ y]), and Ax :   ×  U ×   →   by Ax(f, σ, R) = 
{x} + f (consU (σ)[x '→ R]) = cons(Cx(f, σ, R)).
Firstly, we start with R0 = 0 as lower bound and iterate the consumption mapping Ax(f, σ) : ( , ≤) → ( , ≤), which delivers the fixed point x0(f, σ) = n<ω Rn(f, σ) where Rn+1(f, σ)= Ax(f, σ, Rn(f, σ)) for all n < ω. Since Ax(f, σ): ( , ≤) → ( , ≤) can be easily shown to be continuous for each x ∈ V and R0 is a prefixed point, it follows that the sequence Rn(f, σ) is increasing in the DCPO
(  , ≤), hence the last supremum indeed exists.
Secondly, we start with x0(f, σ) as lower bound and iterate the complex map- ping Cx(f, σ) : (  , ≤) → (  , ≤), which delivers the fixed point (rec x.f )(σ) =

nW<ω
xn(f, σ) where xn+1(f, σ) = Cx(f, σ, xn(f, σ)) for all n < ω. Since Cx(f, σ) : 

( , ≤) → (  , ≤) can be easily shown to be continuous for each x ∈ V and x0(f, σ)
is a prefixed point, it follows that the sequence xn(f, σ) is increasing in the DCPO ( , ≤), hence the last supremum indeed exists.
Finally, we show that rec x. :  →  is well-defined, that is, rec x.f ∈  for all
f ∈  , and moreover that rec x. : (  , ≤) → (  , ≤) is continuous.
Congruence and Full Abstraction
We now arrive at the main results of the paper which require generalizing the arguments and constructions presented in [4]. We shall state in this section two results of full abstraction, a linear and a complex one. To this purpose we first

exhibit linear translations to and fro between linear transition on the operational side and linear prefix and residue on the denotational side.
The following hard technical lemma concerns the interaction of the operators with the action residue. Note the close resemblance of the denotational Table 2 to the operational Table 1. For all a ∈ Y, x, xj ∈  if a—1x = xj then we suppose in particular that a ª x.
Lemma 7.1 For any a ∈  Y ∪ {0}, x, xj, y, yj ∈  , c ∈  C, T ∈  , C ⊆  Y,
f ∈  , σ ∈  U we have the properties of Table 2.



[ACT] c—1c() = 0
a—1x = xj
[SER1]
a—1x = xj a—1(x · y)= xj · y
cons(x) ⊥ a, a—1y = yj

[REN]


S(a)—1S(x)= S(xj)
a—1x = xj
[SER2]


a—1(x · y)= x · yj
a ∈ C, a—1x = xj, a—1y = yj

[HID]

(a \ T )—1(x T )= xj (T \ a)
[PAR0]
a—1(x y)= xj	yj
C	C

[RES]
a—1x = xj, a ≤ T
a—1(x  T )= xj  (T − a)
[PAR1]
C, cons(y) ⊥ a, a—1x = xj


C	C

[REC]
(rec x.f )(σ)= y
{x}—1y = f (σ[x '→ y])
[PAR2]
C, cons(x) ⊥ a, a—1y = yj


C	C

Table 2

The next proposition, which is easy to prove relying on proposition 6.3 and the previous lemma, allows us to translate linear transition on the operational side to linear residue on the denotational side. For all u ∈  ∗ , x, xj ∈  if u—1x = xj then
we suppose in particular u ª x.
Proposition 7.2 Let u ∈  ∗ , p, pj ∈ L, σ ∈  U and τ = consU (σ). Then
p =u⇒ pj	=⇒	u—1[[p]](σ)= [[pj]](σ)
τ
The following easy technical lemma concerns the interaction of the operators with the action prefix.
Lemma 7.3 For any a ∈  Y, x, y ∈  , c ∈  C, T ∈  , C ⊆  Y, f ∈  , σ ∈  U
we have the properties of Table 3.
The next proposition, which is difficult to prove relying on proposition 6.3 and the previous lemma, allows us to translate linear prefix on the denotational side to linear transition on the operational side. The main difficulty resides in adequately treating the hiding operator which is the most difficult case. We only obtain the translation for a large subclass of terms that we call nice which do not contain hiding



[ACT] a ª c =⇒ a = c.
[REN] a ª S(x) =⇒ b ª x for some b ∈  Y such that a = S(b).
[HID] a ª x T =⇒ u ª ub ª x for some u ∈  ∗ and b ∈  Y
such that u T =0 and (ub) T = a
[RES] a ª x  T =⇒ a ª x and a ≤ T.
[SER] a ª x · y =⇒ (a ª x) or (cons(x) ⊥ a and a ª y).

[PAR] a ª x 
C
y =⇒ (a ∈ C and a ª x and a ª y) or (C, cons(y) ⊥ a and a ª x) or (C, cons(x) ⊥ a and a ª y).

[REC] a ª (rec x.f )(σ) =⇒ a = {x}.

Table 3

terms that hide variables of open subterms, a condition that is rather sensible to assume for any practical purposes.
Let ≤ denote the subterm ordering in L. p ∈L is a nice term iff for all subterms p1 T ≤ p we have T ∧V =0 or p1 ∈ Lc. The set of nice terms is denoted by Ln, the set of nice and closed terms is denoted by Lc,n.
Proposition 7.4 Let u ∈  ∗ , p ∈ Ln, τ ∈  U . Then
u ª [[p]](τ )	=⇒	p =u⇒
τ

Using the linear translations we are able to state a denotational characterization of the linear behaviour, which observes only strings of actions.
Theorem 7.5 (Linear Congruence) For all p ∈ Lc,n we have


  ∗ (p)= { u ∈  ∗
| u ª [[p]] }

Y	Y

As a main result, we next infer a linear full abstraction by probing processes terms in suitable hiding contexts. A context C( ) is a term C ∈ L with one dis- tinguished variable denoted by . A context C( ) is nice-preserving iff C(p) ∈ Ln whenever p ∈ Lc,n.
Theorem 7.6 (Linear Full Abstraction) For all p, q ∈ Lc,n we have
[[p]]= [[q]] ⇐⇒ for all nice-preserving C( ) we have  ∗ (C(p)) =  ∗ (C(q))
Y	Y

Using the fact that each multi-pomset x ∈  is the intersection of its set of lin- earizations Lin(x) ⊆ ∗ , we derive a denotational characterization of the complex behaviour, which observes multi-pomsets of actions.

Theorem 7.7 (Complex Congruence) For all p ∈ Lc,n we have
 (p)= Kmp( [p]]) and [[p]] =   (p)
This allows us to finally infer a complex full abstraction result.
Theorem 7.8 (Complex Full Abstraction) For all p, q ∈ Lc,n we have
[[p]]= [[q]] ⇐⇒ for all nice-preserving C( ) we have  (C(p)) =  (C(q))
We conclude the presentation with a result relating the denotational semantics to bisimilarity and the consumption semantics.

A relation S ⊆ Lc,n × Lc,n is a bisimulation iff for all u ∈  ∗
we have

pS q and q =u⇒ qj then p =u⇒ pj and pj S qj for some pj,
pS q and p =u⇒ pj then q =u⇒ qj and pj S qj for some qj.
The coarsest bisimulation ≈ = { S | S bisimulation } , called bisimilarity, is known to be an equivalence relation (see for example [8]).
Theorem 7.9 For all p, q ∈ Lc,n we have
[[p]]= [[q]] ⇐⇒ Cons(p)= Cons(q) and p ≈ q.

Conclusion
We developed a truly concurrent semantics that allows describing the concurrent behaviour of recursive processes accessing consumable resources. We first presented the coherently complete and prime algebraic ground domains of real and complex multi-pomsets. The modelled process language contains several deterministic quan- titative process operators as well as a recursion operator. Next, we displayed a deterministic structural operational machine that is straightforward to comprehend and allows extracting a linear and a complex behaviour. We then constructed a compositional denotational semantics using a functional domain over environments of complex multi-pomsets. The main results have finally shown that the denota- tional semantics is fully abstract with respect to both linear and complex operational semantics.
The only operator customary in classical process languages [7,8] that has been intentionally left out in ours is the non-deterministic choice. We think that using power-domains over complex multi-pomsets provides a clear way of handling choice at the expense of rendering the domain-theoretic tools more involved. Another possibility to achieve the same result could reside in enriching real multi-pomsets with a further relation on events expressing conflict of choices, thus imposing a modelling view closer to event structures.
Apart from the intended applications in engineering and economy the presented language can be also employed as a powerful formalism to abstractly specify and

handle labelled partial orders which are far more complex than the series-parallel constructions usually considered in the literature.
Acknowledgement
I thank Paul Gastin for several fruitful discussions, Volker Diekert for pointing out interesting extensions, Daniele Varacca for constructive criticism, and Pierre-Louis Curien for various pertinent remarks.

References
S. Abramsky, A. Jung. Domain Theory. In Handook of Logic in Computer Science, Vol. III, pages 1-168, Clarendon Press, 1994.
V. Diekert, P. Gastin. A Domain for Concurrent Termination: A generalization of Mazurkiewicz traces. Proceedings of the 22th International Colloquium on Automata, Languages and Programming, 1995. Lecture Notes in Computer Science 944, pages 15-26, Springer, 1995.
M. Droste, W. Kuich, H. Vogler. Handbook of Weighted Automata. EATCS Monographs in Theoretical Computer Science, Springer, 2009.
P. Gastin, M. Mislove. A Truly Concurrent Semantics for a Process Algebra using Resource Pomsets.
Theoretical Computer Science, volume 281, number 1-2, pages 369-421, 2002.
P. Gastin, D. Teodosiu. Resource Traces: A Domain for Processes sharing Exclusive Resources. Twelfth Conference on the Mathematical Foundations of Programming Semantics, 1996. Theoretical Computer Science, volume 278, number 1-2, pages 195–221, May 2002.
M. Hennessy, G. D. Plotkin. Full Abstraction for a Simple Parallel Programming Language. Lecture Notes in Computer Science 74, Springer, 1979.
C. A. R. Hoare. Communicating Sequential Processes. Prentice-Hall International Series in Computer Science, Prentice Hall, 1985.
R. Milner. Communication and Concurrency. Prentice Hall International Series in Computer Science, Prentice Hall, 1989.
V. Pratt. Modeling Concurrency with Partial Orders. International Journal of Parallel Programming, volume 15, issue 1, pages 33-71, Kluwer Academic Publishers, February 1986.
D. Pym, C. Tofts. A Calculus and Logic of Resources and Processes. Formal Aspects of Computing, volume 18, pages 495-517, 2006.
D. Teodosiu. A Truly Concurrent Semantics for Processes sharing Quantified Resources. PhD Thesis, Department of Computer Science, University Paris 7, March 2012, at http://teodosiu.pagesperso- orange.fr.
G. Winskel. Event Structures. In W. Brauer, W. Reisig, G. Rozenberg (editors), Petri Nets: Applications and Relationships to Other Models of Concurrency, Advances in Petri Nets 1986, Part II; Proceedings of an Advanced Course, Bad Honnef, September 1986, Lecture Notes in Computer Science 255, pages 325-392, Springer, 1987
