	Electronic Notes in Theoretical Computer Science 175 (2007) 131–149	
www.elsevier.com/locate/entcs

Extensionality of Spatial Observations in Distributed Systems
Lu´ıs Caires1 and Hugo Torres Vieira2
CITI / Departamento de Informa´tica, FCT Universidade Nova de Lisboa, Portugal

Abstract
We discuss the tensions between intensionality and extensionality of spatial observations in distributed systems, showing that there are natural models where extensional observational equivalences may be char- acterized by spatial logics, including the composition and void operators. Our results support the claim that spatial observations do not need to be always considered intensional, even if expressive enough to talk about the structure of systems. For simplicity, our technical development is based on a minimalist process calculus, that already captures the main features of distributed systems, namely local synchronous communication, local computation, asynchronous remote communication, and partial failures.
Keywords: Behavioral equivalence, spatial observations, spatial logics, Hennessy-Milner logic,


Introduction
Logical characterizations of concurrent behaviors have been introduced for a long time now. A fundamental result in the field, due to Hennessy and Milner [14], is the characterization of behavioral equivalence in process algebras as indistinguishability with respect to a modal logic. Such results are important not only theoretically, but also because of their influence in the design of practical specification languages for software systems. Hennessy-Milner logic (HML) adds to propositional operators the action modality ⟨λ⟩A, allowing the logic to observe a grain of behavior: a process satisfies ⟨λ⟩A if it satisfies A after performing action λ. HML characterizes behavioral equivalence in the sense that two processes are strongly bisimilar if and only if they satisfy exactly the same formulas.
More recently, spatial logics for concurrency [6,9,4] have been proposed with the aim of specifying distributed behavior and other essential aspects of distributed

1 Luis.Caires@di.fct.unl.pt
2 htv@di.fct.unl.pt


1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.056

computing systems. In general terms, these developments reflect a shift of focus in concurrency research, that has been building up from the last decade on, from the study of centralized concurrent systems to the study of general distributed systems. While centralized processes may be accurately modeled as pure objects of behavior, in distributed systems many interesting phenomena besides pure interaction, such as location dependent behavior, resource usage, and mobility, must be considered. Present in all spatial logics for concurrency are the composition operator A | B and the void operator 0 [4]. Intuitively, a system satisfies A | B if it can be decom- posed in two disjoint subsystems such that one satisfies A and the other satisfies B, while a system satisfies 0 if it is the empty system. The guarantee (logical adjunct of the composition operator) Ad B, introduced in [9], allows the logic to talk about contextual properties. Namely, a process satisfies Ad B if whenever composed with a system that satisfies A, yields a (possibly larger) system that satisfies B. Decom- position and composition of systems as mentioned here is generally interpreted up to structural congruence, and thus structural congruence seems to play a key role
in the semantics of spatial logics.
Observation of features such as spatial separation are frequently considered in- tensional because they usually induce fine distinctions among processes that are not substantiated by purely behavioral (extensional) observations. According to Sangiorgi [21], “A logic is intensional if it can separate terms on the basis of their internal structure, even though their behaviors are the same”. Moreover, in many situations, it turns out that the logical equivalence induced by a spatial logic on processes, is not only strictly finer than behavioral congruence, but coincides with structural congruence [21,5,11,22].
These results contributed to widespread the impression that spatial observa- tions, as those induced by spatial connectives, are intrinsically intensional, imposed extraneously so to increase the power of the observer. For example, Hirschkoff has shown [15] that if the so-called intensional connectives composition and void are removed from a spatial logic for the pi-calculus, while retaining the guarantee, one obtains a logic whose separation power precisely coincides with strong bisimulation and may then be considered extensional. The ability of the spatial connectives to capture structural congruence is also attributed to their ability to count, sep- arate, and express arithmetical constraints, e.g., about the number of subsystems of a given system. The observational power of spatial logics may then sometimes appear a bit arbitrary, in the sense that structural congruence does not have a canonical status among behavioral process equivalences, and is frequently seen just as a technical convenience, with a syntactic flavor, to ease the presentation of a calculus operational semantics.
On the other hand, it has been argued [4,2,3] that the intensional character of logical characterizations of spatiality in distributed computation may be, at least in part, incidental, and does not necessarily reflect the fundamental motivation for in- troducing spatial logics for concurrency. Ideally, we would like spatial observations, as captured by spatial logics, to reflect natural distinctions and similarities between distributed systems, in a context where spatial location is a relevant observable, in

parity with more standard behavioral observables. We expect spatial observations of the sort, captured by spatial logic operators such as composition, to be taken modulo an intended notion of equality of the observable space-time structure, inde- pendently on whether such equality relation is technically defined using a notion of structural congruence. If certain spatial-behavioral observations precisely capture the observable structure of a model in our sense, they would have to be considered extensional, even if able to detect aspects of spatial structure.
In this paper, we pursue the informal discussion started above in technical terms. Namely, we make precise the claim that spatial observations, including structural ones, may be understood as purely extensional in fairly natural models of distributed systems. To discuss the several issues of interest in a simplified setting, we consider a minimal distributed process calculus, obtained by extending the smallest concurrent fragment of CCS with flat anonymous locations. Our model can be seen as a general abstraction of the essence of distributed systems, already featuring all the key ingredients present in distributed process calculi, although in a possibly less refined way. Processes may synchronously communicate locally to a site through standard CCS-like synchronization, and asynchronously communicate at a distance, by means of a migration primitive. We also allow systems to nondeterministically exhibit partial failures, as in [1,13,12], which are a good example of distributed systems features that give away structural information. Notice that it is not our aim here to propose yet another distributed process calculus, but rather to set up a convenient setting to compare distributed system observational equivalences and their spatial logical characterizations.
Our technical contributions may be summarized as follows. After introducing the process calculus and its reduction semantics, we define observational equiva- lence by adopting the canonical notion of reduction barbed congruence. Barbed congruence [18] and reduction barbed congruence [17] are currently accepted as the standard approach to define reference behavioral equivalences for general process calculi. After showing some basic properties of reduction barbed congruence in our setting, we define strong bisimulation, an alternative coinductive characteriza- tion of observational equivalence, which is shown equivalent to reduction barbed congruence. The interesting aspect of our definition of strong bisimulation is that it contains “intensional” clauses (in the sense of [21]), namely a clause express- ing separation, and a clause for observing the empty system. We then use the characterization of reduction barbed congruence in terms of strong bisimulation to identify a spatial logic characterization of both reduction barbed congruence and strong bisimulation: our logic is an extension of HML with the composition and void operators of spatial logic. The same line of development is also carried out for the weak case. In this latter setting, we prove minimality of the logic, thus showing the essential role of all of the logic operators, in particular of the spatial operators, in the intended expressive and separation power. We can verify that in both the strong and weak cases the process equivalences induced by the logics are coarser than structural congruence, and that the presence of the composition and void operators, semantically interpreted in the standard way, do not carry any

lack of extensionality (with extensionality interpreted with reference to a standard observational equivalence), even if the logics can express separation and counting constraints on the structure of systems.

A Simple Model of Distributed Systems
In this section we present the syntax and operational semantics of our distributed process calculus. Assume given an infinite set Λ of names, ranged over by a, b, c.
Definition 1.1 [Actions, Processes and Networks] The sets A of actions, P of
processes, and N of networks are given by:
α ::= a¯  a  τ	P, Q ::= nil  P | Q  α.P  go.P	N, M ::= 0  N | M  [P ]
For actions we consider the output a¯, the input a and the internal computation τ . For processes, we consider the smallest fragment of CCS featuring some form of concurrency, thus we have inaction nil, parallel composition P | Q, and action prefixing α.P . On top of this, we introduce a notion of distribution by locating pro- cesses P inside sites of the form [P ], anonymous for simplicity, and by adding the migration capability go.P to processes which, since sites are not natively named, al- lows processes to non-deterministically migrate to other sites. A distributed system is thus represented by a network consisting of a collection of sites spread in space, by means of spatial composition N | M , which we will abbreviate using  j∈J Pj
for a J -fold collection of sites. 0 stands for the empty network. We use fn(N ) to
denote the set of free names of a network N , defined as usual. The operational semantics of our calculus follows, captured by the relations of structural congruence and reduction.
Definition 1.2 [Structural congruence] Structural congruence, noted ≡, is the least congruence on processes and networks such that (P, nil, |) and (N , 0, |) are com- mutative monoids, and P ≡ Q implies [P ] ≡ [Q].
Definition 1.3 [Reduction] Reduction, noted N → M , is the relation between processes inductively defined as follows
[a¯.P | a.Q | R] → [P | Q | R] (Red Comm)	[τ.P | Q] → [P | Q] (Red Tau) [go.P | Q] | [R] → [Q] | [P | R] (Red Go)		[P ] | N → 0 (Red Fail)

N → N '
N | M → N ' | M (Red Cong)
N ≡ N ' → M ' ≡ M
N → M	(Red Struct)

The rule (Red Comm) specifies interaction between two processes through co- action synchronization locally inside a site, while rule (Red Tau) specifies internal action of a process. Rule (Red Go) specifies that a process prefixed by go may migrate to another site. Rule (Red Fail) expresses that any non-empty network may fail, thus modeling fail-stop failure of an arbitrary subsystem.

Our aim now is to define a natural notion of observational equivalence on net- works. To that end, we adopt the canonical notion of reduction barbed congruence, according to which two systems are observationally equivalent if no context can dis- tinguish between them by barb detection. In our case, we restrict to one-hole spatial contexts, as e.g., in [1,13], hence of the form C [•] ::= N | •, for some network N .
We use the standard notion of barb observation [18], even if it assumes in a sense the existence of a global observer, which might be debatable in the context of distributed systems. Thus a network N exhibits barb a, noted N ↓a, if there are P, Q, M such that N ≡ [a.P | Q] | M , hence reflecting the fact that any external observer can get to know that an input is ready via some channel name, at some accessible site. We now define our reference observational equivalence relation, along the lines of [19,17].
Definition 1.4 [Strong reduction barbed congruence] Strong reduction barbed con- gruence, noted  , is the largest symmetric relation R such that for all (N, M ) ∈ R:
For all barbs a, if N ↓a then M ↓a	(Barb closed)
If N → N ' then there is M ' s.t. M → M ' and (N ',M ') ∈ R  (Reduction closed) For all contexts C [•], (C [N ] ,C [M ]) ∈ R	(Context closed)
We establish some standard properties of strong reduction barbed congruence, such as is a congruence. Notice that we just consider in this paper, congruences under spatial (static) contexts. As explained above, this does not carry a lack of generality, given the main motivations of our development. Moreover:
Proposition 1.5 We have ≡⊂  .
Proof. The proof of ⊆ follows standard lines. To prove that ≡ is strictly included in  we may show that [a.nil | a.nil]  [a.a.nil] but [a.nil | a.nil] /≡ [a.a.nil]. 
It follows from the congruence property that strong reduction barbed congruence is closed under composition. In particular for site composition, we have:
Lemma 1.6 Let Pi and Qi (i ∈ J ) be collections of processes. If for all i ∈ J we have Pi   Qi , then also  j∈J Pj    j∈J Qj .
Although Definition 1.4 is standard, with reference to the global observation of barbs in networks, observations already leak some relevant information about the distributed structure of systems. Lemma 1.7 states that strong reduction barbed congruent networks always result from an underlying one-one and onto correspon- dence of strong reduction barbed congruent sites. In particular, we conclude strong reduction barbed congruent networks always have the same number of sites.
Lemma 1.7 Let M, N be networks such that N   j∈J Pj , where Pj (j ∈ J ) is a collection of processes, and N  M. Then there is a collection of processes Qj (j ∈ J ) such that M ≡  j∈J Qj and for all j ∈ J we have Pj   Qj .
Proof. (Sketch, full proof in appendix A.1) We consider a context that holds pro- cesses that may migrate and mark every site of N with an input on the unique

name, and we make sure that every input is located at a different site. Since M behaves the same as N under this context (and using a symmetric reasoning) we obtain that M has #J sites. Interesting to notice is the fact that the ability to count sites results solely from the combination of mobility and local synchronization in the model. We then exploit failures in N that leave only a single site active, being that this behavior must be mimicked by failures in M that also leave just one site up. These singled out sites are strong reduction barbed congruent, hence hold the same unique input which ensures an unique correspondence. We then consider another context that may clean up the marker and all other foreign elements, which then allows us to conclude the sites were originally strong reduction barbed congruent. 


Strong Bisimilarity
Since strong reduction barbed congruence relies on universal quantification over all contexts, we now propose a more manageable characterization of observational equivalence. More concretely, we introduce a labeled transition system with the aim of capturing the contextual behavior of the networks, by means of observing process commitments, in turn expressed by transition labels. Building on such labeled transition system, a coinductive definition of bisimilarity is then presented. The set of transition labels, noted L, is given by L  {α | α ∈ A} ∪{[a] | a ∈ Λ}, and ranged over by λ. Transition labels reflect internal computation (τ ), and ab- stract communication and mobility from and to the external environment. Output (a¯) and input (a) transitions represent the interaction with a process that migrates
from the outer environment and communicates on a given channel.
Grow transitions ([a]) are used to allow the observation of process migration from the system to the external environment by internalizing this mobility. Such a grow transition allows the labeled transition system to import a minimal piece of the external environment, consisting on a site with a given input to distinguish it from the rest of the network, providing in this way a candidate foreign migration target. This turns out to be essential for covering the case of networks with a single site, since in that case only the enlargement of the system with a new site gives processes intending to migrate a possible destination.
Given these ingredients, we define our labeled transition system. As we will show later, these labels are essential to capture reduction barbed congruence.


Definition 2.1 [Commitment] Commitment, noted N
processes and labels inductively defined as follows
−λ→ M , is the relation on


[a¯.P | a.Q | R] −τ→ [P | Q | R] (Comm)	[τ.P | Q] −τ→ [P | Q] (Tau)
[a¯.P | Q] −a¯→ [P | Q] (Out)	[a.P | Q] −a→ [P | Q] (In)
[go.P | Q] | [R] −τ→ [Q] | [P | R] (Go)



[P ] | N −τ→ 0 (Fail)	N  [a]
N | [a.nil] (Grow)

N −λ→ N '
N | M −λ→ N ' | M
(Cong)
N ≡ N ' −λ→ M ' ≡ M N −λ→ M
(Struct)

We can verify that τ commitments match reductions and conversely. Notice that although e.g., the systems [nil] | [nil] and [τ.nil] have exactly the same commitment graph, they are not observationally equivalent in the light of Lemma 1.7. Thus, in order to properly capture strong reduction barbed congruence, we include in the definition of strong bisimulation two spatial clauses (referred to as “intensional clauses” in [21]).
We then have:
Definition 2.2 [Strong Bisimulation] A binary relation B ⊆ N × N is a strong bisimulation if and only if it is symmetric and whenever (N, M ) ∈ B then

N ≡ N ' | N '' ⇒ ∃M ',M '' . M ≡ M ' | M '' ∧ (N ',M ') ∈ B ∧ (N '',M '') ∈ B
N ≡ 0 ⇒ M ≡ 0
N −λ→ N ' ⇒ ∃M ' . M −λ→ M ' ∧ (N ',M ') ∈ B
We remark that the second clause in Definition 2.2 is subsumed by the third one since only void systems have no possible internal actions (due to failures), however we prefer to include it in the definition for the sake of uniformity with the corresponding weak version, and thus avoid some extra incidentality.
Notice also that the first clause properly distinguishes [τ.nil] and [nil] | [nil], because there is no way to split [τ.nil] (up to ≡) in two parts with some transition each.
We prove that strong bisimulations are equivalence relations closed under union, and define:
Definition 2.3 [Strong bisimilarity] Strong bisimilarity, noted ∼, is the largest strong bisimulation.

Full Abstraction
This section is devoted to proving that strong bisimilarity, as defined in Defini- tion 2.3, characterizes strong reduction barbed congruence in a fully abstract way. The proof builds on a series of intermediate technical results.
Lemma 2.4 Let M be a network and Pj(j ∈ J ) a collection of processes where
 j∈J Pj ∼ M. Then there is a collection of processes Qj(j ∈ J ) such that M ≡
  j∈J Qj and for all j ∈ J, Pj ∼ Qj .

Proof. By induction on the size of J , using the separation and emptiness clauses. 
The proof of the main result of this section (Theorem 2.6) is not technically involved, but critically depends on next Lemma 2.5, that expresses a key composi- tionality principle of our calculus. Notice that the basic building block of systems referred to in the statement of Lemma 2.5 is the process: since we have to take mi- gration into account, it is essential to assure compositionality at the process level. We abbreviate collections of sites such that each one holds a collection of processes.
Lemma 2.5 Let J be a ﬁnite set and Ij, for all j ∈ J, be a ﬁnite set. Let Pj and
i
Qj be processes such that for all j ∈ J and i ∈ Ij we have	j	j . Then


j∈J

i∈Ij

Pj ∼ 

j∈J

i∈Ij
Qj 

Proof. (Sketch, full proof in appendix A.2) By coinduction on the definition of strong bisimulation. We sketch the proof for the interesting case of migration.
We exploit the grow transition using a fresh name, in the sense that it does not occur in neither one of the Pjs and Qjs, which creates a possible target for
i	i
migrations and allows us to isolate migrating processes, since we can decompose
and observe the input on the fresh name. Using this technique and since we can establish that the newly created sites are bisimilar, we can be sure to obtain a collection of sites that respects the statement of the Lemma for any choice of target of the migration.	 

By Lemma 2.4 and Lemma 2.5 we prove strong bisimilarity is a congruence, from which follows, in standard lines, that ∼ ⊆ . We then prove ⊆ ∼, using Lemma 1.6 and Lemma 1.7 to address the structural issues. We can then state:
Theorem 2.6 (Full abstraction) We have ∼ =  .

Logical Characterization of Strong Bisimilarity
In this section, we characterize strong bisimilarity (and thus strong reduction barbed congruence) in logical terms, using a simple spatial logic.
Definition 2.7 [Spatial logic Ls] Formulas are defined by the following syntax: (Formulas) A, B, C ::= T ¬A A ∧ B  0 A | B  ⟨λ⟩A
Our logic, besides the usual action modality from HML, includes the compo- sition and void operators of spatial logics, interpreted in the standard way. For example, we may express property “network has exactly one site” by the formula
¬0 ∧ ¬(¬0 | ¬0). The semantics of the logic is given by the denotation of the formulas, i.e., a formula denotes the set of networks that satisfy it.

Definition 2.8 [Semantics of Ls] A formula’s denotation is inductively given by

 T)  N	 ¬A)  N \ A)	 A ∧ B)   A) ∩ B)	 0)  {N | N ≡ 0}
 A | B)  {N | ∃N ',N '' . N ≡ N ' | N '' ∧ N ' ∈ A) ∧ N '' ∈ B)}
 ⟨λ⟩A)  {N | ∃N ' . N −λ→ N ' ∧ N ' ∈ A)}

We write N |= A to mean N ∈ A). We say that networks M and N are logically equivalent w.r.t. Ls, written M =Ls N , if and only if they satisfy exactly the same formulas of Ls, namely if and only if, for any formula A of Ls, we have M |= A ⇐⇒ N |= A. We now state our logical characterization result.
Theorem 2.9 (Logical Characterization of ∼) We have ∼ = =Ls.
Proof. (Sketch, full proof in appendix A.3) Proof of ∼⊆ =Ls follows by a standard induction on the structure of the formulas. We prove =Ls ⊆ ∼ by coinduction on the definition of strong bisimulation, using the witness R  {(N, M ) | N =Ls M }. Proof of the emptiness clause is immediate. For both the separation and transition clauses we build on the fact that the image set of the transition for the latter and of all possible decompositions for the former are finite (up to structural congruence). We then exploit the finiteness of these sets to prove that there is a (logical equivalent) correspondence between at least one of their elements. Otherwise we could collect the finite set of all formulas that distinguish them in a conjunction that must hold for both networks, either after a decomposition or after an action, since they are
logically equivalent. We then obtain our bisimilar result by coinduction.	 
As a corollary we immediately conclude that =Ls precisely characterizes . Thus the separation power of our spatial logic coincides with behavioral equivalence, even if it includes the basic structural connectives of composition and void, allowing it to e.g., express arithmetical constraints on the number of sites in a system. We
may however ask whether these structural operations are essential to characterize behavioral equivalence, in other words, whether the logic is minimal in some sense. We will give a positive answer to this question in the next section, in the more interesting case of weak behavioral equivalences.

Weak Bisimilarity
In this section we refine our previous results by considering a coarser observational equivalence, disregarding internal action, thus we adopt weak reduction barbed con- gruence as the reference observational equivalence. We denote by ⇒ the reflexive- transitive closure of reduction ( → ) and state that a network N weakly exhibits a barb a, noted N ⇓a, if there is N ' such that N ⇒ N ' and N '↓a. We then have:
Definition 3.1 [Weak reduction barbed congruence] Weak reduction barbed con- gruence, noted ≅, is the largest symmetric relation R such that for all (N, M ) ∈ R:

For all barbs a, if N ↓a then M ⇓a	(Barb closed)
If N → N ' then there is M ' s.t. M ⇒ M ' and (N ',M ') ∈ R  (Reduction closed) For all contexts C [•], (C [N ] ,C [M ]) ∈ R	(Context closed)
We establish some standard properties of weak reduction barbed congruence, such as ≅ is a congruence. We relate ≅ to the strong reduction barbed congruence. Proposition 3.2 We have ⊂ ≅.
Proof. The proof of ⊆ follows standard lines. To prove that  is strictly included in ≅ we may show that [go.nil] ≅ [nil] but [go.nil] / [nil].	 
Note that from Proposition 3.2 and Proposition 1.5 we immediately conclude
≡⊆ ≅. From the congruence property we obtain that reduction barbed congruence is closed under composition, which in particular for site composition gives us:
Lemma 3.3 Let Pi and Qi (i ∈ J ) be collections of processes. If for all i ∈ J we have Pi ≅ Qi , then also  j∈J Pj ≅  j∈J Qj .
As for the strong case, weak reduction barbed congruence is already able to distinguish systems based on aspects of their structure, for instance, weak reduction barbed congruent networks always have the same number of sites. Also, as stated in Lemma 3.4, weak reduction barbed congruent networks weakly reduce to a one-one and onto correspondence of weakly reduction barbed congruent sites.
Lemma 3.4 Let M, N be networks such that N   j∈J Pj , where Pj (j ∈ J ) is a collection of processes, and N ≅ M. Then there is a collection of processes Qj (j ∈ J ) such that M ⇒   j∈J Qj and for all j ∈ J we have Pj ≅ Qj .
Proof. (Sketch, full proof in [7]) The general idea is similar to that in A.1. However, since now we may only weakly observe a barb, a different trick must be used to make sure that the migration of all the mark-placing processes has already occurred. We thus exploit the failure behavior of the context at a chosen point, avoiding in this way any chance for the migratory processes to postpone their choice of target, thus ensuring an unique correspondence.	 

Weak Bisimilarity
We now propose a coinductive characterization of weak reduction barbed congru-
ence. Weak commitment =⇒ is the transition relation such that N =⇒ N ' when
N −τ→∗ M ' −λ→ M '' −τ→∗ N ' and λ /= τ , and N =τ⇒ N ' when N −τ→∗ N '. Given
this we define weak bisimulations by adapting the labeled transition and separa-
tion clauses to the weak case. Notice that, contrasting with the strong case, the emptiness clause is essential here to distinguish, e.g., [nil] from 0.
Definition 3.5 [Weak Bisimulation] A binary relation B ⊆N ×N is a weak bisim- ulation if and only if it is symmetric and whenever (N, M ) ∈ B then



N ≡ N ' | N '' ⇒ ∃M ',M '' . M ⇒ M ' | M '' ∧ (N ',M ') ∈ B ∧ (N '',M '') ∈ B
N ≡ 0 ⇒ M ≡ 0
N −λ→ N ' ⇒ ∃M ' . M =λ⇒ M ' ∧ (N ',M ') ∈ B
We can prove that weak bisimulations enjoy usual properties, such as being equivalence relations, and closure under union. We thus define:
Definition 3.6 [Weak bisimilarity] Weak bisimilarity, noted ≈, is the largest weak bisimulation.
Full Abstraction
In this section, we prove that weak bisimilarity characterizes weak reduction barbed congruence in a fully abstract way, proof of which builds on the following results.
Lemma 3.7 Let M be a network and Pj (j ∈ J ) a collection of processes such that  j∈J Pj ≈ M. Then there is a collection of processes Qj (j ∈ J ) such that M ⇒  j∈J Qj and for all j ∈ J, Pj ≈ Qj .
Proof. By induction on the size of J , using the separation and emptiness clauses. 
Lemma 3.8 is the cornerstone for proving full abstraction (Theorem 3.9). As for the strong case we must ensure compositionality at the process level due to process mobile capability, as process migration to sites results in inner site composition.
Lemma 3.8 Let J be a ﬁnite set and Ij, for all j ∈ J, be a ﬁnite set. Let Pj and
i
Qj be processes such that for all j ∈ J and i ∈ Ij we have	j	j . Then


j∈J

i∈Ij

Pj ≈ 

j∈J

i∈Ij
Qj 

Proof. (Sketch, full proof in [7]) By coinduction on the definition of strong bisimu- lation following the lines of A.2 with several adaptations needed for the weak case. 
By Lemma 3.7 and Lemma 3.8 we prove that weak bisimilarity is a congruence, after which proof that ≈ ⊆ ≅ follows in standard lines. To prove ≅ ⊆ ≈ the
difficulty lies in the spatial clauses, given by Lemma 3.3 and Lemma 3.4. Thus:
Theorem 3.9 (Full abstraction) We have ≈ = ≅.
Logical Characterization of Weak Bisimilarity
We characterize weak bisimilarity (and thus weak reduction barbed congruence) using the spatial logic Lw.
Definition 3.10 [Spatial Logic Lw] Formulas are defined by the following syntax: (Formulas) A, B, C ::= T ¬A A ∧ B 0 A ²T B  ⟨⟨λ⟩⟩A

The logic Lw is obtained from Ls by adapting the composition operator, now noted A ²T B, and the action modality, now noted ⟨⟨λ⟩⟩A, to the weak case as defined in Definition 3.11. We leave the void operator with it’s standard interpretation (notice that N ⇒ 0 is a trivial condition, due to the failure behavior).
Definition 3.11 [Semantics of Lw] A formula’s denotation is inductively given by

 T)  N	 ¬A)  N \ A)	 A ∧ B)   A) ∩ B)	 0)  {N | N ≡ 0}
 A ²T B)  {N | ∃N ',N '' . N ⇒ N ' | N '' ∧ N ' ∈ A) ∧ N '' ∈ B)}
 ⟨⟨λ⟩⟩A)  {N | ∃N ' . N =λ⇒ N ' ∧ N ' ∈ A)}
We prove logical characterization of ≈, following the lines of Theorem 2.9.
Theorem 3.12 (Logical Characterization of ≈) We have ≈ = =Lw .
As a corollary of Theorem 3.12 we conclude that the separation power of Lw precisely coincides with weak reduction barbed congruence, even if it includes the spatial operators composition and void. At this point, we may ask, as at the end of Section 2.2, whether the spatial operators are essential to the characterization. We may verify that T can be expressed as ⟨⟨τ ⟩⟩0, and ⟨⟨τ ⟩⟩A as A ²T 0. Thus let Lmin be the (T, ⟨⟨τ ⟩⟩A)-free fragment of Lw. We may show that Lmin is as expressive as Lw, and moreover that all of its connectives are essential for its expressiveness.
Theorem 3.13 (Minimality) The logic Lmin is minimal. Moreover, the spatial operators are essential to characterize weak reduction barbed congruence.
Proof. (Sketch, full proof in [7]) We show that any logic obtained from Lmin by
removing each connective is strictly less expressive.
(¬A) In the ¬-free fragment we are not able to express property 1  {N | ∃P . N ≡
[P ]}, nor distinguish [nil] | [nil] from [nil].
(A ∧ B) In the ∧-free fragment we can no longer express property 1.
(0) In the 0-free fragment we can no longer express property {N | N ≡ 0}, nor tell 0 and [nil] apart.
(A ²T B) In the ²T-free fragment we can neither express property 2  {N | ∃P, Q . N ≡
[P ] | [Q]} nor separate [nil] | [nil] from [nil].
(⟨⟨α⟩⟩A, α = a¯, a) The ⟨⟨α⟩⟩-free fragment does not tell [α.nil] and [nil] apart.
(⟨⟨[a]⟩⟩A) The ⟨⟨[a]⟩⟩-free fragment does not distinguish [go.b.nil] from [nil].

Concluding Remarks
We have studied observational equivalences in a distributed computation model, having obtained spatial logic characterizations of observational congruence in both the strong and weak cases. Our long term goal is to get a better understanding

of how structural features contribute to observable distributed process behavior. Taking as reference semantics for observational congruence the standard reduction barbed congruence, we have derived equivalent characterizations of observational congruences in terms of co-inductively defined bisimilarities. The logics considered are natural extensions of HML with spatial operators, interpreted in the standard way.
We have thus shown, in a precise sense, that spatial logics, in particular the structural operators they offer, are not necessarily intensional, and may offer ade- quate expressive power for logically characterizing distributed behavior. We have also concluded, in the case of the specific process model here considered, that the composition operator A | B is essential to capture (extensional) observational equiv- alence. Intuitively, such structural observations do not violate extensionality be- cause distributed process behavior already has a related observational power, due to migration behavior and failures.
Observational equivalences of distributed systems have been studied extensively in the context of CCS-like models; a comprehensive survey may be found in [10]. However, it seems that logical characterizations have not been much discussed, and the distributed process equivalences proposed were technically defined by means of location or history-sensitive transition systems, where the use of location names plays a key role, both in the dynamic and static cases. Here, we build on a more abstract notion of spatial observation, avoiding the use of location names, and consider a calculus with anonymous sites, and migration primitives in the spirit of more recent proposals of calculi for distribution and mobility [8,20].
Our adoption of the simplest fail-stop failure model was motivated by the belief that it already captures the key consequences of failure, cf., the folklore slogan that in a distributed system one cannot distinguish a failed system from a system that will respond (much) later. The fail-stop model has been frequently adopted in formalizations of failure since [1], even if recent related works prefer to trigger failure by means of an explicit “kill” primitive [13]. Failures play an essential role in our results, even if, for the weak case, it is open whether failures, as we have modeled here, are absolutely essential. However, it is conceivable that other notions of failure, and a different set of spatial behaviors and spatial observations, may lead to results comparable to the ones reported in this paper.
It is interesting to compare our results with those of [15], where an extensional spatial logic (for the π-calculus) is considered. In that work, extensionality is ob- tained by removing the composition and void operators, while retaining the guar- antee, whereas here we obtain extensionality by retaining the composition and void operators, while doing without the guarantee. We believe that the guarantee could be added to our developments, without breaking the results. Then, it would be in- structive to see how to capture indirectly the action modalities, as in [16]. It would be certainly important to assess how to extend the general approach presented here to richer models, with name restriction, name passing, and full computational power.

Acknowledgement
We acknowledge the Funda¸c˜ao paraa Ciˆencia e Tecnologia PhD Scholarship SFRH
/ BD / 23760 / 2005 and project IP Sensoria IST-2005-16004. We thank the anonymous reviewers for their comments, and Lu´ıs Monteiro and Luca Cardelli for useful remarks.

References
R. M. Amadio and S. Prasad. Localities and Failures (Extended Abstract). In P. S. Thiagarajan, editor, Foundations of Software Technology and Theoretical Computer Science, volume 880 of Lecture Notes in Computer Science, pages 205–216. Springer-Verlag, 1994.
L. Caires. Behavioral and Spatial Properties in a Logic for the Pi-Calculus. In Igor Walukiwicz, editor, Proc. of Foundations of Software Science and Computation Structures’2004, Lecture Notes in Computer Science. Springer Verlag, 2004.
L. Caires.  Proof Techniques for Distributed Resources and Behaviors using Spatial Logics.  In
(discussion at) Symposium on Trustworthy Global Computing, 2005.
L. Caires and L. Cardelli. A Spatial Logic for Concurrency (Part I). Information and Computation, 186(2):194–235, 2003.
L. Caires and E. Lozes. Elimination of Quantifiers and Undecidability in Spatial Logics for Concurrency.
Theoretical Computer Science, 10(2), 2006.
L. Caires and L. Monteiro. Verifiable and Executable Specifications of Concurrent Objects in Lπ . In
C. Hankin, editor, 7th European Symp. on Programming (ESOP 1998), number 1381 in Lecture Notes in Computer Science, pages 42–56. Springer-Verlag, 1998.
L. Caires and H. T. Vieira. Extensionality of Spatial Observations in Distributed Systems (Draft). Technical Report TR-DI/FCT/UNL-1/2006, DI/FCT Universidade Nova de Lisboa, 2006. http://ctp.di.fct.unl.pt/∼ htv/pub/extspatial.pdf .
L. Cardelli and A. D. Gordon. Mobile Ambients. In M. Nivat, editor, First International Conference on Foundations of Software Science and Computation Structures (FoSSaCS ’98), volume 1378 of Lecture Notes in Computer Science. Springer-Verlag, 1998.
L. Cardelli and A. D. Gordon. Anytime, Anywhere. Modal Logics for Mobile Ambients. In 27th ACM Symp. on Principles of Programming Languages, pages 365–377. ACM, 2000.
I. Castellani. Process Algebras with Localities. In J. Bergstra, A. Ponse, and S. Smolka, editors,
Handbook of Process Algebra, pages 945–1045. North-Holland, 2001.
G. Conforti, D. Macedonio, and V. Sassone. Spatial Logics for Bigraphs. In L. Caires, G. F. Italiano,
L. Monteiro, C. Palamidessi, and M. Yung, editors, Automata, Languages and Programming, 32nd International Colloquium, ICALP 2005, volume 3580 of Lecture Notes in Computer Science, pages 766–778. Springer-Verlag, 2005.
R. De Nicola, D. Gorla, and R. Pugliese. Global Computing in a Dynamic Network of Tuple Spaces. In Jean-Marie Jacquet and Gian Pietro Picco, editors, COORDINATION, volume 3454 of Lecture Notes in Computer Science, pages 157–172. Springer, 2005.
A. Francalanza and M. Hennessy. A Theory of System Behaviour in the Presence of Node and Link Failures. In Mart´ın Abadi and Luca de Alfaro, editors, CONCUR, volume 3653 of Lecture Notes in Computer Science, pages 368–382. Springer, 2005.
M. Hennessy and R. Milner. Algebraic Laws for Nondeterminism and Concurrency. JACM, 32(1):137– 161, 1985.
D. Hirschkoff. An Extensional Spatial Logic for Mobile Processes. In P. Gardner and N. Yoshida, editors, CONCUR 2004 15th International Conference, volume 3170 of Lecture Notes in Computer Science, pages 325–339. Springer-Verlag, 2004.
D. Hirschkoff, E´. Lozes, and D. Sangiorgi. Minimality Results for the Spatial Logics. In P. K. Pandya and J. Radhakrishnan, editors, Foundations of Software Technology and Theoretical Computer Science, volume 2914 of Lecture Notes in Computer Science, pages 252–264. Springer-Verlag, 2003.
K. Honda and N. Yoshida. On Reduction-Based Process Semantics. Theoretical Computer Science, 151(2):437–486, November 1995.


R. Milner and D. Sangiorgi. Barbed Bisimulation. In Werner Kuich, editor, Automata, Languages and Programming, 19th International Colloquium, volume 623 of Lecture Notes in Computer Science, pages 685–695, Vienna, Austria, 13–17 July 1992. Springer-Verlag.
U. Montanari and V. Sassone. Dynamic Congruence vs. Progressing Bisimulation for CCS. Fundamenta Informaticae, 16(1):171–199, 1992.
J. Riely and M. Hennessy. Distributed Processes and Location Failures. Theor. Comput. Sci., 266(1- 2):693–735, 2001.

D. Sangiorgi. Extensionality and Intensionality of the Ambient Logics. In 28th Annual Symposium on Principles of Programming Languages, pages 4–13. ACM, 2001.
E. Tuosto and H. T. Vieira. An Observational Model for Spatial Logics. Electronic Notes in Theoretical Computer Science, 142:229–254, 2006.

Appendix (Proofs)
Proof of Lemma 1.7
Let M, N be networks such that N  j∈J Pj , where Pj (j ∈ J ) is a collection of processes, and N  M . We prove that there is a collection of processes Qj (j ∈ J ) such that M ≡  j∈J Qj and for all j ∈ J we have Pj   Qj .
Proof. Let us consider context
C [•]   t.nil |  i∈J go.(fi.nil |  k∈J \{i}f¯k.f ail.nil) | •
with ({t, f ail}∪ {fi | i ∈ J }) ∩ fn(N | M )= ∅ and ({t, f ail}∪ {fi | i ∈ J }) pairwise distinct. We can derive that
C  j∈J Pj  →#J+1  j∈J Pj | fj.nil |  k∈J \{j}f¯k .f ail.nil 
where f ail will never be observed as a barb and t is no longer exhibited. Since
 j∈J Pj  M we have that C [M ] →#J+1 M ' and
 j∈J Pj | fj.nil |  k∈J \{j}f¯k .f ail.nil  M '
and hence for all i ∈ J it is the case that M '↓f , and also f ail will never be exhibited and t is no longer observed. This can only be so, attending to the fact that we have exactly #J + 1 reductions and since we know that they are due to the migration of
the processes containing the fis and to the failure of the site containing t, if there is
M¯ and {Qj | j ∈ J } such that M ' ≡  j∈J Qj | fj.nil |  k∈J \{j}f¯k.f ail.nil | M¯ .
Since  is symmetric we have that M¯ ≡ 0 since otherwise following the same
reasoning we would get a contradiction to our initial condition that in  j∈J Pj 
there are #J sites. We can at this point conclude that M ≡  j∈J Qj .
We know that for all m ∈ J we can derive
 j∈J Pj | fj.nil |  k∈J \{j}f¯k.f ail.nil → Pm | fm.nil |  k∈J \{m}f¯k.f ail.nil 

and since j∈J Pj | fj.nil |  k∈J \{j}f¯k.f ail.nil  M ' we get that there exists Mm
such that M ' → Mm and Pm | fm.nil |  k∈J \{m}f¯k.f ail.nil  Mm, which, since
  identifies systems with the same number of sites as we proved before and recalling that it is barb closed, gives us that Mm ≡ Qm | fm.nil |  k∈J \{m}f¯k.f ail.nil .
We now consider context
C [•]   r.nil | go.(f¯m.nil |  k∈J \{m}fk.f a¯il.nil) | •
with r /∈ {t, f ail}∪ {fi | i ∈ J }∪ fn(N | M ). We can derive that
C  Pm | fm.nil |  k∈J \{m}f¯k.f ail.nil  →2×#J [Pm] | [r.nil] → [Pm]
from which we obtain C  Qm | fm.nil |  k∈J \{m}f¯k.f ail.nil  →(2×#J)+1 [Qm] and [Pm]  [Qm] thus completing the proof.	 

Proof of Lemma 2.5
Let J be a finite set and Ij, for all j ∈ J , be a finite set. Let Pj and Qj be
i	i




j∈J


i∈Ij

Pj ∼ 


j∈J


i∈Ij

Qj .

Proof. We abbreviate 


j∈J


i∈Ij
Pj  and 


j∈J


i∈Ij
Qj with NJ and MJ , re-

spectively, and proceed by coinduction on the definition of strong bisimulation.
Let us consider that there exist N ',N '' such that NJ ≡ N ' | N ''. We know that there exists J¯ ⊆ J such that N J¯ ≡ N ' and NJ\J¯ ≡ N ''. We also know that
MJ ≡ M J¯ | MJ\J¯. Since J¯ ⊆ J we have that for all j ∈ J¯ and i ∈ Ij it is
the case that Pj ∼ Qj which gives us that (N J¯,M J¯) ∈ B and also since for
all j ∈ J \J¯ and i ∈ Ij it is the case that Pj ∼ Qj from which we get that
i	i
(NJ\J¯,MJ\J¯) ∈ B, thus proving the first clause.
Now consider that NJ ≡ 0 which gives us that #J = 0 and hence we directly have that MJ ≡ 0, thus proving the second clause.
Let us now consider that there exists λ, N ' such that NJ −λ→ N '. We know that this transition can either be triggered by an unique site or else be a migration of a process from one site to another or else be due to a grow transition or finally be due to a failure.
(Transition triggered by a single site)
If a site triggers the transition, this can be due either to a firing of an action that can either be an input or an output or an internal action, due to either a synchronization between processes internal to one of the Pjs or to a τ prefix, or else to a synchronization between two distinct Pjs. Hence we can write that there

exist ¯j ∈ J and n, m ∈
¯¯j
¯¯j
such that either P ¯j −λ→ P¯¯j , with λ = α,


¯j	¯j  τ

 ¯¯j
I¯j and Pn, Pm	n	n
¯¯j 

(case of NJ −λ→ NJ\{¯j} |	¯j	¯¯j , λ = α)

i∈I¯\{n}Pi | Pn
We know that P ¯j −λ→ P¯¯j , which since P ¯j ∼ 

¯j  gives us that there

n	n
'	  ¯j  λ	'
n	Qn
 ¯¯j	'

leads to there exists Qn such that M '
≡ ¯¯j .

Hence we can derive MJ −λ→ MJ\{¯j} | 
¯j	¯¯j 



(NJ \{¯j} |	¯j	¯¯j ,MJ \{¯j} | 
¯j	¯¯j  ∈ B

i∈I¯\{n}Pi | Pn

since P¯¯j ∼ ¯¯j 
i∈I¯\{n}Qi | Qn )

(case of NJ −τ→ NJ\{¯j} | 
¯j	¯¯j
¯¯j )

i∈I¯\{n,m}Pi | Pn | Pm
Since a synchronization can take place we know that there exists a such that

either P ¯j ≡
a¯.R1
| R2
and P ¯j
≡p a.R3
| R4
or with the action and coaction placed

the other way around, being the proofs analogous. Considering P ¯j ≡ a¯.R
p	1
| R2

and P ¯j ≡ a.R  | R  we have that P ¯j  −a¯→ [R | R ] and P ¯j  −a→ [R | R ]
being that [R | R ] ≡ P¯¯j  and [R | R ] ≡ P¯¯j . Since P ¯j  ∼  ¯j  we ob-

1	2
¯j	a¯
n	3	4	m
'	 ¯¯j	'
n	Qn

to there exists Qn such that M '
≡  ¯¯j 
.	Also since
P ¯j  ∼
¯
Qm	we get

¯j	a	''
 ¯¯j	''

obtain that there exists
Qm such that M ''
≡  ¯¯j 
. Hence we can derive that

MJ −τ→ MJ \{¯j} | 
¯j	¯¯j
¯¯j , which along with

(NJ \{¯j} | 
¯j	¯¯j
¯¯j ,MJ \{¯j} | 
¯j	¯¯j
¯¯j ) ∈ B

since P¯¯j ∼ ¯¯j and P¯¯j ∼ ¯¯j , completes the proof for this case.
(Transition triggered by a migration)
We now consider that a migration takes place, for which we know that there are at least two sites involved, the origin and destination of the migrating process,
hence we have that #J ≥ 2. We also know that there exist ¯j,¯i such that P ¯j ≡

go.R	| R  from which we can obtain, considering a /∈ fn( P ¯j  | 
¯i	p
¯j

 P ¯j  [a]
 P ¯j | [a.nil] −τ→ [R ] | [a.nil | R ]. Since P ¯j ∼ 
¯j we get that there

¯i	−→	¯i
'
1
¯j  [a]
¯j 
2	¯i
τ	'
Q¯i
'

from which we can derive that there exist M ' ,M ' such that M ' ≡ M ' | M '
and

1	2	¯	1	2
Lemma 2.4, leads to there exist R3, R4 such that M ' ≡ [R3] and M ' ≡ [a.nil | R4].
a	1	2	a
From [a.nil | R2] ∼ [a.nil | R4] and [a.nil | R2] −→ [R2] we get that [a.nil | R4] −→
[R4] and [R2] ∼ [R4].
So we have that there exists ¯l ∈ J such that

NJ −τ→ NJ \{¯j,¯l} | 
¯j	 | 
P ¯l | R .

¯j  [a]
¯j	τ


MJ −τ→ MJ \{¯j,¯l} | 
¯j	 | 

Q¯l | R 


which along with
i∈I¯\{¯i}Qi | R3
i∈Il¯  i	4

( NJ \{¯j,¯l} | 
¯j	 | 
P ¯l | R ,

MJ \{¯j,¯l} | 
¯j	 | 

Q¯l | R ) ∈ B

since [R1] ∼ [R3] and [R2] ∼ [R4], completes the proof for this case. (Transition triggered by a grow transition)
We have that NJ	[a]  NJ | [a.nil] and we can directly derive that MJ	[a]
MJ | [a.nil] which along with (NJ | [a.nil],M J | [a.nil]) ∈ B , since [a.nil] ∼ [a.nil], completes the proof for this case.
(Transition triggered by a failure)
We have that there exists J¯ ⊆ J such that NJ −τ→ NJ\J¯. We can directly derive
that MJ −τ→ MJ\J¯ which along with (NJ\J¯,MJ\J¯) ∈ B completes the proof for
this case and also for this clause.	 

Proof of Theorem 2.9
We prove =Ls ⊆ ∼.
Proof. We prove that R   {(N, M ) | N =Ls M } is a strong bisimulation by coinduction on the definition of strong bisimulation.
Let us consider that there exist N ',M ' such that N ≡ N ' | N ''. Now consider
I   {1, 2,... , k} and {M ',M '' | i ∈ I} such that for all M ',M '' such that M ≡
i	i
M ' | M '' then there exists i ∈ I such that M ' ≡ M ' and M '' ≡ M ''. Aiming
at a contradiction, let us now assume that for all i ∈ I it is either the case that
N ' /=Ls M ' or N '' /=Ls M '' from which we can derive that there exists {Ai, Bi | i ∈ I}
i	i
such that for all i ∈ I it is either the case that N ' |= Ai and M ' |= Ai or N '' |= Bi

and M ''
|= Bi. We can now write that N |= ( 

i∈I
Ai) | ( 

i∈I
Bi) and since


N =Ls M we have that M |= ( i∈I Ai) | ( i∈I Bi) which gives us that there exist
M ',M '' such that M ≡ M ' | M '' and M ' |= ( i∈I Ai) and M '' |= ( i∈I Bi). We
also know that there exists j ∈ I such that M ' ≡ M ' and M '' ≡ M '' from which
j	j

follows that M ' |= ( 

i∈I
Ai) and M '' |= ( 

i∈I
Bi) which provides with the intended

contradiction since M ' |= Aj or M '' |= Bj. We can therefore conclude that there
j	j

exists i ∈ I such that N ' =Ls M ' and N '' =Ls M '', which completes the proof.
i	i
Now let us consider that N ≡ 0. We know that N |= 0 from which, since
N =Ls M , we get that M |= 0 hence M ≡ 0.
Let us now consider that there exist N ',λ such that N −λ→ N ', hence N |= ⟨λ⟩T
which since N =Ls M gives us that M |= ⟨λ⟩T and thus there exists M ' such that
M −λ→ M '. Let us consider I  {1, 2,... , k} and {M ' | i ∈ I} such that for all

M ' such that M
−λ→ M ' then there exists i ∈ I such that M ' ≡ M '. Aiming at

a contradiction, let us now assume that for all i ∈ I it is the case that N ' /=Ls M '
which gives us that there exists {Ai | i ∈ I} such that for all i ∈ I it is the case

that N ' |= Ai and M ' |= Ai. We can now write that N |= ⟨λ⟩( 

i∈I
Ai) and since

N =Ls M we have M |= ⟨λ⟩( i∈I Ai) from which we obtain that there exists M '

such that M −λ→ M ' and M ' |= 

i∈I
Ai. We also know that there exists j ∈ I such

that M ' ≡ M '
which gives us M '
|=  i∈I
Ai which contradicts M '
|= Aj, hence

there exists i ∈ I such that N ' =Ls M ' which completes the proof.	 
