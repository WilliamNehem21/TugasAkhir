

Electronic Notes in Theoretical Computer Science 223 (2008) 119–135
www.elsevier.com/locate/entcs
Switching Graphs
Jan Friso Groote1 and Bas Ploeger2 ,3
Department of Mathematics and Computer Science Eindhoven University of Technology
P.O. Box 513
5600 MB Eindhoven The Netherlands

Abstract
Switching graphs are graphs containing switches. By using boolean functions called switch settings, these switches can be put in a fixed direction to obtain an ordinary graph. For many problems, switching graphs are a remarkable straightforward and natural model, but they have hardly been studied. We study the complexity of several natural questions in switching graphs of which some are polynomial, and others are NP-complete. We started investigating switching graphs because they turned out to be a natural framework for studying the problem of solving Boolean equation systems, which is equivalent to model checking of the modal μ-calculus and deciding the winner in parity games. We give direct, polynomial encodings of Boolean equation systems in switching graphs and vice versa, and prove correctness of the encodings.
Keywords: Switching graphs, parity games, μ-calculus, model checking, Boolean equation systems.


Introduction
We are inspired by the long open problem of finding a polynomial algorithm for the equivalent problems of solving Boolean equation systems (BES) [11], model checking formulas in the modal μ-calculus [10] and finding a winning strategy in parity games [2,14]. Especially the intriguing algorithms that use hill-climbing techniques with smartly chosen progress measures drew our attention [8,16]. While studying the question how ‘progress’ could be captured better in the formalism, we started to use what we call switching graphs.
A switching graph is an ordinary graph with switches. A typical instance of a directed labelled switching graph is given in Fig. 1; in Fig. 2(a) an undirected unlabelled switching graph is depicted. A switch is a triple of vertices (v1, v2, v3) where it is possible to move either from v1 to v2 or from v1 to v3 depending on a

1 Email: J.F.Groote@tue.nl
2 Email: S.C.W.Ploeger@tue.nl
3 This author is partially funded by the Netherlands Organisation for Scientific Research (NWO) under VoLTS grant number 612.065.410.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.035



Fig. 1. A directed labelled switching graph
switch setting, which is a function from switches to booleans. In Fig. 1, there are two switches s1 and s2. If the switch setting for s1 is true, it is possible to move from the vertex labelled 1 to the vertex labelled 4, indicated by a straight solid arrow. If the switch setting for s1 is false, the dashed arrow must be followed. The curved arrows are ordinary directed edges in the graph. Note that only if both switches are set to 1, there is a loop on which the lowest number is odd.
As switching graphs are a natural extension to ordinary graphs and a natural abstract domain for representing concrete problems, we expected switching graphs to be widely studied, but this appears not to be the case. In [12] a slightly different notion of switching graphs is used essentially omitting switches, unifying nonde- terminism with switches. In [3] proof nets are proposed which closely resemble switching graphs, except that here switches move in pairs. Other notions in the literature (like switch graphs [7], bidirected graphs [1] and skew-symmetric graphs [4]) also deal with choices excluding other options, but appear to be of a different nature than switching graphs.
We show that solving BESs can naturally be formulated as a problem on directed labelled switching graphs, namely as the v-parity loop problem: does a switch setting exist such that the lowest label on every loop reachable from v is even. The v-parity loop problem is essentially the same problem as that of deciding the winner in parity games. This problem is already known to be in NP ∩ co-NP (or even UP ∩ co-UP) and is also known to be equivalent to the BES problem via translations to/from the μ-calculus model checking problem. The fact that the v-parity loop problem is equivalent to solving BESs is therefore not surprising, neither is the immediate complexity result. However, a direct encoding of BESs in switching graphs (and vice versa) is, to our opinion, more intuitive and a natural generalisation of the encoding of conjunctive/disjunctive BESs in ordinary graphs [6].
Moreover, we prove that it is impossible to synchronise switches in the context of the v-parity loop problem. Although we believe that this property is key to finding a polynomial algorithm we were not able to discover it.
We also investigate the complexities of several variations of the parity loop prob- lem, in order to gain more insight into its nature. If we relax the total ordering of labels we obtain the NP-complete cancellation loop problem. If we relax the require- ment of loops we get the NP-complete connection- and disconnection problems. If we relax the requirements on labels we obtain the polynomial loop- and 1-2-loop problems.
In this paper we first define switching graphs (Sect. 2). Next, we investigate several problems on switching graphs and provide their characterisation in terms of complexity (Sect. 3). In Sect. 4 we connect the v-parity loop problem to that of

solving BESs. As we found switching graphs to be interesting in themselves as a natural abstract model for many problems, we list a number of problems of which the complexity is unknown (at least to us) in Sect. 5. It should be obvious that these are only a fraction of the interesting questions that exist about switching graphs.

Preliminaries
Switching graphs
Definition 2.1 A directed labelled switching graph (DLSG ) is a four-tuple G = (V, E, S, l) where
V is a set of vertices;
E ⊆ V × V is a set of directed edges;
S ⊆ V × V × V is a set of directed switches;
l : V → N is a labelling function.
For edges v and w, we write v → w if (v, w) ∈ E. If (v1, v2, v3) ∈ S, we write v1 →1 v2 and v1 →0 v3. For a switch s = (v1, v2, v3) we write s1 for v2 and s0 for v3. We call v1 the root of s, v2 the 1-vertex of s and v3 the 0-vertex of s.
A switch setting is a function f : S → {0, 1}. An f -path from vertex v to vertex w is a sequence v1, v2,... , vn with v = v1, w = vn and for all 1 ≤ i < n it either holds that vi → vi+1, or there is a switch s ∈ S with vi+1 = sf(s). An f -path from v to v is called an f -loop through v. For b ∈ {0, 1} we write f [s:=b] for the switch setting f where switch s is set to b. Similarly, f [S:=b] denotes the switch setting f in which every switch in the set S is set to b.
For any DLSG G = (V, E, S, l) and switch setting f over S, the directed labelled graph Gf = (V, E', l) is called the f-graph of G where:
E' = E ∪ {(v, w) | ∃u ∈ V . ((v, w, u) ∈ S ∧ f (v, w, u)= 1) ∨
((v, u, w) ∈ S ∧ f (v, u, w)= 0)}

A switching graph with no labelling function is simply called a directed switching graph. A switching graph of which the set of edges is symmetric, is called an undirected (labelled) switching graph.
Example 2.2 An example of an undirected switching graph is found in Fig. 2(a). This graph is only not connected if both switches are set to 1.
A typical application comes from investigating possible partitions of a set. The elements of the set are the vertices. An edge between two vertices indicates that they are related. Two elements are equivalent if they are connected. Using switches alternative relations between individual elements can be represented. Typical ques- tions can be whether a switch setting exists such that the equivalence partition has exactly k elements (or more than k, or exactly an even number, etc.).


	
(a)	(b)
Fig. 2. An undirected (a) and a directed (b) switching graph.
Example 2.3 In Fig. 2(b) a simple example of a directed switching graph is de- picted. It illustrates that ordinary graphs and switching graphs are not quite the same. Compare the switching graph with an ordinary graph where both branches of switch s1 are ordinary edges. The question whether there is a (switch setting with a) loop through both A and B is answered with yes in the graph, and with no in the switching graph. If the switching graph is compared to the graph that contains only one branch of the switch, the question whether there is a (switch setting with a) loop through A and a (switch setting with a) loop through B is answered with no for the graph, and with yes for the switching graph.
The 3SAT problem
We use the well-known 3SAT problem for proving NP-completeness of several prob- lems in Sect. 3.
Definition 2.4 A 3CNF formula is a logical formula of the form
  (li,1 V li,2 V li,3)
i∈I
where I is a finite index set and li,j are literals, i.e. formulas of the shape p or чp for a proposition letter p taken from a set P . The 3SAT problem is the question whether a given 3CNF formula is satisfiable.
A famous result by Karp is that the 3SAT problem is NP-complete [9]. In this paper, we assume some ordering < on the proposition letters P and assume that the literals in each clause of a 3CNF formula are ordered according to <, such that the leftmost proposition letter in that clause is the smallest, and the rightmost is the largest.
Boolean equation systems
We assume the existence of a set of proposition variables X with typical elements X, X1, X2,... and a type B representing Booleans with elements ⊥ and T repre- senting 0 (false) and 1 (true) respectively.
A Boolean equation system (BES) is a sequence of fixed-point equations over the Boolean lattice. It can be defined inductively as follows:
ϵ denotes the empty BES;

for every BES E, (σX = φ) E is also a BES, where σ ∈ {μ, ν} is a ﬁxed-point symbol, X is a proposition variable and φ is a proposition formula.
A fixed-point symbol is either μ for least fixed-point, or ν for greatest fixed point. Proposition formulae φ are defined by the following grammar:
φ ::= ⊥|T| X | φ ∧ φ | φ V φ
where X ∈X is a proposition variable of type B.
The BES problem is the problem of finding an assignment of either 0 or 1 to each variable Xi such that every equation is satisfied and for every 1 ≤ i ≤ n, the assignment to Xi is as strong as possible if σi = μ, and as weak as possible if σi = ν. We call this assignment the solution of the BES, which we now define formally. A proposition environment is a function θ : X → {0, 1} that assigns a Boolean value to every proposition variable in X .
Definition 2.5 The solution of a BES in the context of a proposition environment
θ is defined inductively as follows, for any BES E:
[ϵ]θ	= θ
[(σX = φ) E]θ = [E]θ[φ([E]θ[bσ/X])/X]
where bμ =0 and bν = 1. The BES problem is the problem of determining ([[E]θ)(X) for a given BES E, environment θ and variable X.
It is known that the BES problem is equivalent to the μ-calculus model-checking problem [11]. This problem was shown to be in NP ∩ co-NP by Emerson, Jutla and Sistla by showing equivalence to the non-emptiness problem of parity tree automata [2]. Later, Stirling reduced the problem to that of deciding the winner in parity games, obtaining the same complexity result [14].
In this paper, we only consider BESs of the following form:
E = (σ1X1 = φ1) ... (σnXn = φn) for some n ∈ N. Moreover, E is:
in standard form if every φi is either Xj or Xj V Xk or Xj ∧ Xk;
in 2-conjunctive normal form (2CNF) if every φi is of the form  p∈Ii ci,p where
Ii is an index set and ci,p is either Xj or Xj V Xk;
conjunctive if no φi contains a V;
disjunctive if no φi contains a ∧.
It is known that every BES can be linearly transformed to standard form such that its solution is maintained, modulo renaming of variables [11]. If E is conjunctive or disjunctive, the dependency graph of E is a directed labelled graph (V, E, l) where V = {1,... , n}, E = {(i, j) | Xj occurs in φi} and l(i) = 2i + sign(σi)

with sign(μ) = 1 and sign(ν) = 0. The following result was obtained in [6] as Lemma 3. 4
Lemma 2.6 (Lemma 3 in [6].) Let θ be an environment, E be a conjunctive BES and G be its dependency graph. Then for any variable Xi of E we have that ([E]θ)(Xi) = 0 iff G contains a loop that is reachable from i on which the lowest label is odd.
For disjunctive BESs the dual result holds (i.e. replacing 0 by 1 and “odd” by “even”). The loop problem on the dependency graph can be solved in polynomial time, which is also shown in [6].
Switching graph problems and their complexities
In this section we investigate the complexity of several problems on a fixed DLSG G = (V, E, S, l). For many problems there are straightforward and efficient algo- rithms. Therefore, we often only state the complexity and sketch the algorithm without further explanation.
The v-w-connection problem
The v-w-connection problem is the question whether there is a switch setting f such that there is an f -path in G from a given vertex v to a given vertex w.
Theorem 3.1 The v-w-connection problem is solvable in linear time.
Proof. A straightforward depth-first search suffices where both branches of each switch are taken as ordinary edges. When a path from v to w is found, no vertex, and hence no switch, occurs on this path more than once. The switch setting f is set accordingly, where those switches not on the path can be set arbitrarily. 

The v-w-disconnection problem
The v-w-disconnection problem is the question whether there is a switch setting f
such that there is no f -path in G from a given vertex v to a given vertex w.
Theorem 3.2 The v-w-disconnection problem is solvable in linear time.
Proof. Mark vertices backwards from w in a breadth-first fashion. A vertex u is marked if an outgoing edge leads to a marked vertex, or if both branches of a switch with root u lead to marked vertices. This marking algorithm will terminate in linear time. Answer yes if v was not marked and no otherwise. The switch setting is obtained by setting the switches such that they point to an unmarked vertex. Switches that point to vertices that are both marked or unmarked can be set arbitrarily.	 

4 In [6] the labelling function is a function l' that maps vertices to {μ, ν}. In the original lemma, t should contain a loop on which the vertex with the lowest index has label μ. It is obvious that l'(i) = μ iff l(i) is odd and l'(i) = ν iff l(i) is even. Also i < j iff l(i) < l(j). Hence, the result indeed carries over to our version here.

The loop problem
The loop problem is the question whether there is a switch setting f such that G
contains an f -loop.
Theorem 3.3 The loop problem is solvable in quadratic time.
Proof. This problem is equivalent to the v-v-connection problem for every vertex
v. If for some vertex v a switch setting f is found such that v is connected to itself, then the answer is yes. Otherwise, the answer is no.	 

The v-parity loop problem
The v-parity loop problem is the question whether there is a switch setting f such that every f -loop in G that is reachable from a given vertex v, has an even number as lowest label.
It is not hard to see that this problem is equivalent to that of deciding the winner of a parity game, starting from a vertex v of the game graph. Hence, this problem is in NP ∩ co-NP and it is an open question whether a polynomial algorithm exists. We provide direct translations from this problem to that of solving BESs and vice versa in Sect. 4.
We now show that it is not possible to keep two switches synchronised in the following sense. Consider a switching graph containing at least two switches. It is not possible that if two switches are fixed to opposite positions, the answer to the v- parity loop problem is yes, whereas if the same switches are fixed to equal positions, the answer to the v-parity loop problem on the remaining graph is no. A similar non-synchronisation property holds for the loop problem. In the cancellation and connection problems (Sects. 3.8 and 3.9), it is exactly this capability of synchronising switches that allows us to prove NP-completeness.
In order to formulate the non-synchronisation property we write L(f )= 1 for a switch setting f if all f -loops reachable from v in G have an even number as lowest label, and L(f ) = 0 otherwise. For concrete values of f , L(f ) can be calculated in polynomial time.
Lemma 3.4 Consider two switches s and s'. If for all switch settings f with f (s) /= f (s') with L(f ) = 1, then there are no switch settings g and h such that g(s) = g(s')= 0, h(s)= h(s')=1 and L(g)= L(h)= 0.
Proof. Assume the contrary, i.e. there are switch settings g and h such that g(s)= g(s')= 0, h(s)= h(s')= 1 and L(g)= L(h)= 0. Consider a g-loop reachable from v that has an odd value m as lowest label. This loop must pass through both s and s', as if it does not go through s, then g[s:=1] also has a loop with m as lowest number, contradicting the assumption of the lemma. Similarly, if the loop does not pass through s', then g[s':=1] has a loop with m as lowest label. Using the same line of reasoning, there is an h-loop reachable from v with lowest odd label n going through both s and s'.
Assume without loss of generality that m ≤ n. The vertex labelled with m can

be positioned between the 0-edge of s and the 0-edge of s' or vice versa between the 0-edge of s' and the 0-edge of s. In the first case g[s':=1] also has a loop reachable from v with m as lowest odd label, contradicting the assumption. In the second case g[s:=1] has a loop reachable from v with m as lowest odd label also contradicting the assumption. Note that as m ≤ n, there are no even labels on these loops smaller than m. Hence, all cases lead to a contradiction, proving the lemma.	 

The parity loop problem
The parity loop problem is the question whether a switch setting f exists such that all f -loops in G have an even number as lowest label. This problem is very similar to the v-parity loop problem. In particular no polynomial algorithm is known, and it is also not possible to synchronise switches in this setting.

The parity loop-through-v problem
The parity loop-through-v problem is the question whether a switch setting f exists such that all f -loops through v in G have an even number as lowest label. A particular property of this problem is that it allows switches to be synchronised using a rather contrived construction. We therefore expect that it will even be harder to find a polynomial algorithm for this problem than for the v-parity loop problem.

The 1-2-loop problem
A simplification of the parity loop problem is the 1-2-loop problem where the labels are restricted to the values 1 and 2. For this special case we are able to provide a polynomial time algorithm. It is a weight improvement algorithm inspired by [8,16].
Assume l(v) ∈ {1, 2} for all v ∈ V . The 1-2-loop problem is the question whether a switch setting f exists such that every f -loop in G has 2 as lowest label.
Theorem 3.5 The 1-2-loop problem is solvable in polynomial time.
Proof. First we define the weight of every vertex v for a switch setting f . If no loop containing a label 1 (i.e. a 1-loop) can be f -reached from v, then the weight is
†. Otherwise, the weight is (k, d, p) where k is the maximal number of 1’s on a path from v to a 1-loop, d is the minimal number of switches on a path with k 1-labelled vertices from v to a 1-loop, and p is the number of 1’s on this loop. The weight † is the smallest of all. Furthermore, (k, d, p) < (k', d', p') iff k < k' or, k = k' and d > d' or, k = k', d = d' and p < p'.
Note that if a vertex is on a 1-loop, its weight is (0, 0, p) for some p > 0. It is also worth noting that we only need p in the weight if k = d = 0. Given a switch setting f , the 1-loops can be determined in time O(|V |+|E|) using an algorithm to detect strongly connected components on graphs [15]. The number p of 1’s on a loop can be determined in time proportional to the size of the loop, and also requires O(|V | + |E|) time. Finally, determining the maximal/minimal values for k

and d can be done by a backward-marking algorithm in time O(|V |+|E|). Hence, the total time to calculate the weight is O(|V |+|E|).
The algorithm for this problem works as follows. Take an arbitrary switch setting
f . Repeatedly try changing every switch and accept the change if the weight of the root of this switch decreases. If no switch can be changed decreasing its root’s weight, the algorithm stops. If in the final switch setting there are no 1-loops, report yes. Otherwise report no.
We claim that the algorithm requires polynomial time. Calculating the weight for the root of a switch requires time O(|V |+|E|). Hence, the time to try out all switch settings is O((|V |+|E|)|S|). The number of possible values for the weight of a root of a switch is |V |3. Summed over all switches the number of possible values for weights is at most |V |3|S| which is decreased by at least one at every step. Hence, the total complexity is O((|V |+|E|) |V |3 |S|2). Note that this is a rough overestimation, merely intended to show that the algorithm is polynomial.
In order to see that the algorithm works correctly, it is only necessary to look at the case where the algorithm terminates reporting no, with a switch setting f containing a 1-loop, although a switch setting f ' without any 1-loops exists. Suppose, such pairs f and f ' exist, and consider a pair f and f ' that differ at a minimal number of switches s1,... , sn with n > 0. Let T = {si|1≤i≤n}. For reasons of symmetry we can without loss of generality assume that f (si) = 1 and f '(si) = 0 for all 1≤i≤n. We show that the assumption of the existence of such an f and f ' leads to a contradiction, proving the theorem.
First observe that no switch si from T has an f -weight †. To see this, suppose si has f -weight †. Then each switch in T that is f -reachable from s1, must also have weight †. Let Tˆ ⊆ T be the set of all switches f -reachable from s1. In f '[Tˆ := 1] there is no 1-loop. As f and f '[Tˆ:=1] differ on less switches than f and f ' we apparently did not take a pair of switch settings that differ on a minimal number of switches, contradicting one of the assumptions above.
Now consider the switch setting f '. Note that for each switch si ∈ T there must be a path from s0 to the root of a switch sj ∈ T . As if not, the switch si has a weight † in switch setting f [si:=0]. As si has an f -weight not equal to †, setting si to 0 decreases the weight of the root of si, contradicting that changing a switch in T cannot lead to a weight decrease. But if every 0-branch of a switch has an f '-path to a next switch, there is a set of switches T ' ⊆ T , such that for all switches s ∈ T ', the f '-reachable switches are also in T ', and for all switches s, s' ∈ T ' the switch s is f '-reachable from s'. Note that for every pair of switches s, s' ∈ T ', there cannot be 1-labelled vertex on the f '-path from s to s' as otherwise there would be a 1-loop for f '.
Now consider a switch s ∈ T ' with highest f -weight (k, d, p) from all switches in T '. When changing switch s, it gets a new f [s:=0] weight (k', d', p'). This weight cannot be smaller than (k, d, p), as otherwise the algorithm would not have come to a halt. The weight (k', d', p') is larger or equal to the weight (k, d, p) for one of the following reasons. We show that every case leads to a contradiction.
k' > k. This means there is an f -path with k'>0 1-labelled vertices from s0 to

a 1-loop. If there is no switch s' ∈ T ' on the path nor on the loop, the switch setting f ' would give rise to a 1-loop, which by assumption is not the case. If there is no switch s' ∈ T ' on the path to the loop, this path cannot contain a 1-labelled vertex and k' = 0, which is also a contradiction. So, there is a switch s' on the path to the loop and the root of s' has weight (k', d'', p'') for some d'' and p''. But this means that we did not consider the vertex with the highest weight, which is also a contradiction.
k' = k > 0 and d' ≤ d. By using exactly the same argument as in the previous case, we can conclude that there is a switch s' ∈ T ' on the path from s0 to a 1-loop with weight (k', d'', p''). As the switch s' is closer to the loop than s, d'' < d. But this means that the weight of switch s' is larger than that of s, contradicting that the weight of s was highest.
k' = k = 0, d' ≤ d and d > 0. So, there is a path from s0 to a 1-loop of which s is not a part. The loop contains a switch s' ∈ T ', as otherwise there would be a 1-loop with switch setting f ' also. The weight of the root of this switch is (0, 0, p'') for some p'' and hence, the weight of s' is higher than that of s. So s should not be considered at all.
k' = k = 0, d' = d =0 and p' ≥ p. Note that p > 0. Changing switch s leads to the situation that there is an f [s:=0]-loop through s with p' 1-labelled vertices on it. Hence, there is a switch s' ∈ T ' not equal to s on this loop which can be used to break this loop. There is an f -path from the 1-vertex of switch s' to the root of s with p' relevant vertices, as there cannot be any relevant vertices on the path from s0 to the root of s'. Suppose s' is not on a 1-loop. Then there is an f -path with p' relevant vertices to a loop, and hence s' has a weight of at least
(p', dˆ, pˆ) with p' > 0, which means we should have considered s' instead of s.
So, we can assume that s' is also on a 1-loop. But using the same argument as above, there is a path from the 1-vertex of a switch s'' ∈ T ' to the root of s' containing as many relevant vertices as there are on the loop through s'. As there are only a finite number of vertices in T ', this argument will at some point cycle through switches s1, s2, s3,... , sm, s1, s2 etc. In particular, there is a path from the 1-vertex of si+1 to si and from the 1-vertex of s1 to the root of sm. The number of relevant vertices on this cycle is the sum of all relevant vertices on the individual cycles. This means that unless m =1 the p value in the weight of each root of each switch is less than its possible maximal value. So, the cycle can at most have length 1, but this contradicts with the previous paragraph, showing that there should at least be two different switches from T ' in a loop.
So, we have shown that if the algorithm terminates with a switch setting f con- taining a 1-loop, and no change of a switch can decrease the weight of the root of a switch, then a switch setting f ' without 1-loops cannot exist.	 

The cancellation loop problem
The cancellation loop problem is the question whether there is a switch setting f
such that each f -loop in G that contains an even label n does not contain the label






n − 1.
Fig. 3. Translation of a clause pi,1 ∨ ¬pi,2 ∨ pi,3 for the cancellation loop problem.

Theorem 3.6 The cancellation loop problem is NP-complete.
Proof. It is straightforward to see that this problem is in NP. If a switch setting is given, checking that every loop with even label n does not have a label n − 1 can be done in polynomial time. In order to show that the problem is NP-hard, we reduce the 3SAT problem to the cancellation loop problem. We start with a 3CNF formula  i∈I (li,1 V li,2 V li,3) where I is an index set that does not contain 0. We generate a switch for every occurrence of a proposition letter in a clause. For each clause li,1 V li,2 V li,3 with proposition letters pi,1, pi,2 and pi,3 three switches are generated. The root of the first switch is labelled with an even number 2i. All other vertices have label 0. If li,1 is a positive literal then the 0-vertex of the switch for pi,1 is connected to the next switch and the 1-vertex is connected to the root of the switch for pi,1. Otherwise, these connections are interchanged. In the same way the second switch is connected to the third switch, and the third switch to the first switch. If li,3 is positive, the 0-vertex of the third switch is labelled with 2i − 1. Otherwise, its 1-vertex is labelled with 2i − 1. If two or more of the proposition letters in a clause are the same, then either the clause is omitted in case the literals have opposite signs, or only one or two switches are necessary. See Fig. 3 for an example.
Now assume for each proposition letter p that all different switches for p are synchronised, in the sense that they are all set to 0, or they are all set to 1. Then it is straightforward to see that every loop with even label n does not contain label n − 1 iff the formula is satisfiable.
We now show that all the switches for a proposition letter p can be synchronised. For this, we introduce for each proposition letter p three unique even numbers greater than 0: ap, bp and cp. Uniqueness means that these numbers are neither equal to any aq, bq or cq for any other proposition letter q nor are they equal to 2i for any i ∈ I. For any p we add two switches sp,1 and sp,2 and we connect the switches as indicated in Fig. 4. The column of switches under the letter p are all the different switches introduced for every occurrence of p in some clause. We also label certain vertices by ap, bp, cp, ap − 1, bp − 1 and cp − 1. Unlabelled vertices are considered to have the value 0.
Observe that all switches (including sp,1 and sp,2) either must all be set to 0, or they must all be set to 1: otherwise there is a loop containing labels n and n − 1. As the required case distinction is straightforward, we omit it here.	 




Fig. 4. Construction for keeping all switches for one proposition letter p synchronised in the translation of the cancellation loop problem.






vi	wi







Fig. 5. Translation of a clause i of the shape p1 ∨ ¬p2 ∨ p3 for the connection problem.
The connection problem
Given a set of pairs of vertices {(vi, wi) | i ∈ I} for some index set I. The connection problem is the question whether there is a switch setting f such that, for every i ∈ I, there is an f -path in G from vi to wi.
Theorem 3.7 The connection problem is NP-complete.
Proof. It is obvious that this problem is in NP and therefore we only show that it is NP-hard. We reduce the 3SAT problem to the connection problem in a straight- forward way. Consider the following 3CNF formula:
  (li,1 V li,2 V li,3)
i∈I
for an index set I. We introduce one switch for every proposition letter occurring in the formula. We translate each clause li,1 V li,2 V li,3 in which proposition letters pi,1, pi,2 and pi,3 occur, as follows. We introduce a start vertex vi, and an end vertex wi. The vertex vi is connected to the roots of the switches pi,1, pi,2 and pi,3. Moreover, if li,k is a positive literal then the 1-vertex of switch pi,k is connected to wi, otherwise its 0-vertex is connected to wi. See Fig. 5 for an example.
We can now directly observe that the 3CNF formula is satisfiable iff there is a



vi	wi



Fig. 6. Translation of a clause pi,1 ∨ ¬pi,2 ∨ pi,3 for the disconnection problem.
switch setting f such that for all i ∈ I there is an f -path from vi to wi.	 

The disconnection problem
Given a set of pairs of vertices {(vi, wi) | i ∈ I} for some index set I. The discon- nection problem is the question whether there is a switch setting f such that, for every i ∈ I, there is no f -path in G from vi to wi.
Theorem 3.8 The disconnection problem is NP-complete.
Proof. It is again easy to show that this problem is in NP. For showing NP- hardness, we again reduce the 3SAT problem to this problem but the translation is
considerably more involved than for the connection problem. We start again with a 3CNF formula:
  (li,1 V li,2 V li,3)
i∈I
for an index set I. We introduce a switch for every occurrence of a proposition letter in a clause. For each clause li,1 V li,2 V li,3 with proposition letters pi,1, pi,2 and pi,3 a start vertex vi, an end vertex wi and three switches are generated. The vertex vi is connected to the root of the first switch. If li,1 is a positive literal then the 0-vertex is connected to the next switch, otherwise the 1-vertex is connected to the next switch. In the same way the second switch is connected to the third switch, which is in turn connected in the same way to the vertex wi. If two or more of the proposition letters in a clause are the same, then either the clause is omitted in case the literals have opposite signs, or only one or two switches are necessary. See Fig. 6 for an example.
Now assume for each proposition letter p that all different switches for p are synchronised, i.e. they are all set to 0, or they are all set to 1. Then it is straight- forward to see that for all i ∈ I there is no path from vi to wi iff the 3CNF formula is satisfiable.
We now show that synchronisation of all switches for a proposition letter p can
be enforced. In order to do so, we add three pairs of start and end vertices for p, namely (Ap, A' ), (Bp, B' ) and (Cp,C' ), and three switches sp,1, sp,2 and sp,3. We
p	p	p
connect the switches and vertices as indicated in Fig. 7. The column of switches
under the letter p are all the switches introduced for every occurrence of p in some clause.
We claim that only if all switches under p are set to 0, or all switches are set to 1, there are no paths between any of the pairs (Ap, A' ), (Bp, B' ) and (Cp,C' ). In
p	p	p
order to see that all switches for p must be synchronised, it suffices to note that all
switches (including sp,1, sp,2 and sp,3) in Fig. 7 either must all be set to 0, or they



'
p
Cp
'
p




Fig. 7. Construction for keeping all switches for one proposition letter p synchronised in the translation of the disconnection problem.
must all be set to 1. Otherwise there is an unwanted path. As the required case distinction is straightforward, we omit it here.	 

Equivalence of the v-parity loop and BES problems
In this section we provide reductions from the BES problem to the v-parity loop problem and vice versa. For the proofs we need to be able to remove every disjunc- tion from a BES in 2CNF by selecting one of the disjuncts and eliminating the other one, resulting in a conjunctive BES. The operation resembles that of obtaining the f -graph Gf from a DLSG G and a switch setting f .
Definition 4.1 Given the following BES in 2CNF:
E = (σ1X1 =   c1,j) ... (σnXn =   cn,j)
j∈I1	j∈In
for clauses ci,j and index sets Ii. Let f be a function such that for every 1 ≤ i ≤ n and j ∈ Ii: f (i, ci,j)= Xk if ci,j = Xk, and either f (i, ci,j)= Xk or f (i, ci,j)= Xl if ci,j = Xk V Xl. We call f a selection function. Then the f-BES Ef is the following conjunctive BES:
Ef = (σ1X1 =   f (1, c1,j)) ... (σnXn =   f (n, cn,j)).
j∈I1	j∈In
The following results follow directly from results by Mader [11].
Lemma 4.2 Given a BES E and environment θ. For all selection functions f and variables X of E we have that ([Ef]θ)(X) implies ([E]θ)(X).
Proof. By Lemma 3.16 in [11].	 
Proposition 4.3 (Proposition 3.36 in [11].) For every BES E and environment θ
there is a selection function f such that [Ef]θ = [E]θ.
Reducing the BES problem to the v-parity loop problem
Our translation is similar to the one for conjunctive and disjunctive BESs given in [5], which produces a directed labelled graph without switches. We fix a BES

E = (σ1X1 = φ1) ... (σnXn = φn) for some n ∈ N. Without loss of generality, we assume that E is in standard form.
Definition 4.4 The DLSG corresponding to E is a DLSG (V, E, S, l) where V =
{1,... , n} and:
E = {(i, j) | φi contains Xj but not V};
S = {(i, j, k) | φi = Xj V Xk};
l(i)= 2i + sign(σi) for all i ∈ V .
Theorem 4.5 Let G be the DLSG corresponding to E , θ be an arbitrary environ- ment and 1 ≤ i ≤ n. Then the BES-problem on E , θ and Xi is polynomially equivalent to the i-parity loop problem on G.
Proof. Observe that G can be constructed in polynomial time. We show that ([E]θ)(Xi) = 1 iff there is a switch setting of G such that on every loop reachable from vertex i the lowest label is even.
(⇒) We prove this part by contraposition. Assume that for all switch settings of G there is a loop reachable from i on which the lowest label is odd. We have to show that ([[E]θ)(Xi) = 0. By Proposition 4.3 there is a selection function f such
that [Ef]θ = [E]θ. Take this f and construct a switch setting fˆ of G as follows,

for any (i, j, k) ∈ S:
fˆ(i, j, k) = 1 if f (i, Xj V Xk) = Xj, and fˆ(i, j, k) = 0 if

f (i, Xj V Xk)= Xk. (Note that φi = Xj V Xk by construction of G.) Observe that the fˆ-graph Gfˆ is the dependency graph of the f -BES Ef . Then by Lemma 2.6 we have ([Ef]θ)(Xi) = 0, hence ([E]θ)(Xi)= 0.
(⇐) Assume the existence of a switch setting fˆ such that on every fˆ-loop reachable from i the lowest label is even. Construct a selection function f as follows. For any (i, j) ∈ E define f (i, Xj)= Xj and for any (i, j, k) ∈ S define:
⎧ Xj if fˆ(i, j, k)= 1
f (i, Xj V Xk)= 
⎩ Xk if fˆ(i, j, k)= 0.
(Note that φi contains the required clauses – Xj or Xj V Xk – by construction of G.) Observe that the fˆ-graph Gfˆ is the dependency graph of the f -BES Ef and that the lowest label on every loop in Gfˆ reachable from i is even. Then by Lemma 2.6 we have ([Ef]θ)(Xi) = 1. Hence, by Lemma 4.2, ([E]θ)(Xi)= 1.	 

Reducing the v-parity loop problem to the BES problem
We fix a DLSG G = (V, E, S, l). Without loss of generality, we assume that V =
{1,... , n} for some n ≥ 1, and l(i) ≤ l(i + 1) for all 1 ≤ i < n.
Definition 4.6 The BES corresponding to G is the following BES:
E = (σ1X1 = φ1) ... (σnXn = φn)

where, for all 1 ≤ i ≤ n:
σi = μ if l(i) is odd and σi = ν otherwise;
φi =  {Xj | (i, j) ∈ E} ∧  {(Xj V Xk) | (i, j, k) ∈ S}.
Theorem 4.7 Let 1 ≤ i ≤ n, E be the BES corresponding to G and θ be an arbitrary environment. Then the i-parity loop problem on G is polynomially equivalent to the BES problem on E , θ and Xi.
Proof. Observe that E can be constructed in polynomial time and is in 2CNF. We have to show that ([[E]θ)(Xi) = 1 iff there is a switch setting of G such that on every loop reachable from vertex i the lowest label is even. The proof is very similar to that of Theorem 4.5 and is therefore omitted.	 

Conclusions
In this paper, we introduced switching graphs as a natural extension to ordinary graphs and determined the complexity of several problems on such graphs. The v- w-connection, v-w-disconnection, loop and 1-2-loop problems are solvable in poly- nomial time. The cancellation loop, connection and disconnection problems are NP-complete by reductions from the 3SAT problem. Finally, the v-parity loop problem is in NP ∩ co-NP, both by the already known result on parity games and by the direct translations to/from the BES problem presented here. The complexity of the strongly related parity loop problem is left as an open question.
Of course, by its equivalence to the BES and μ-calculus model-checking prob- lems, the v-parity loop problem is particularly interesting. Studying this problem and related problems in the context of switching graphs may help in answering the long open question whether all of these problems have a polynomial algorithm.
We conclude this paper by listing a number of switching graph problems of which we do not know the complexity. Resolving these may help in finding the answer to the open question mentioned above. Typically, those problems that have a polynomial solution for ordinary graphs can become hard in the setting of switching graphs. Open questions regarding undirected switching graphs are:
Is there a switch setting f such that the f -graph is connected? 5
Is there a switch setting f such that the f -graph contains an Euler tour (i.e. a path through the f -graph that traverses each edge exactly once)?
Is there a switch setting f such that the f -graph is planar?
Find a switch setting f such that the f -graph has a minimal number of con- nected vertices (to some vertex v), or is k-connected (i.e. after removing k edges the f -graph is still connected).
Open questions regarding directed switching graphs are:

5 Recently, this problem was shown to be polynomially solvable [13].

Is there a switch setting f such that the f -graph is a strongly connected com- ponent?
Is there a switch setting f such that the f -graph can be topologically sorted? This is equivalent to finding a switch setting f such that the f -graph does not contain non-trivial connected components.
Is there a switch setting f such that the f -graph is a tree, has a network flow of sufficient capacity or has a path between two vertices shorter than a given k?
Given two vertices v and w. Is there a switch setting f such that an f -loop through v and w exists?
Acknowledgement
We thank Mark de Berg, Herman Geuvers and Jaco van de Pol for various insights and references to relevant literature.

References
Edmonds, J. and E. L. Johnson, Matching: A well-solved class of integer linear programs, in:
Combinatorial Optimization, LNCS 2570 (2003), pp. 27–30.
Emerson, E. A., C. S. Jutla and A. P. Sistla, On model-checking for fragments of μ-calculus, in: Proc. CAV 1993, LNCS 697 (1993), pp. 385–396.
Girard, J.-Y., Linear logic, Theoretical Computer Science 50 (1987), pp. 1–102.
Goldberg, A. V. and A. V. Karzanov, Path problems in skew-symmetric graphs, Combinatorica 16
(1996), pp. 353–382.
Groote, J. F. and M. Kein¨anen, A sub-quadratic algorithm for conjunctive and disjunctive BESs, CS- Report 04-13, Technische Universiteit Eindhoven.
Groote, J. F. and M. K. Kein¨anen, Solving disjunctive/conjunctive boolean equation systems with alternating fixed points, in: Proc. TACAS 2004, LNCS 2988 (2004), pp. 436–450.
Hochstein, J. M. and K. Weihe, Edge-disjoint routing in plane switch graphs in linear time, Journal of the ACM 51 (2004), pp. 636–670.
Jurdzin´ski, M., Small progress measures for solving parity games, in: Proc. STACS 2000, LNCS 1770 (2000), pp. 290–301.
Karp, R. M., Reducibility among combinatorial problems, in: R. Miller and J. Thatcher, editors,
Complexity of Computer Computations, Plenum Press, 1972 pp. 85–103.
Kozen, D., Results on the propositional μ-calculus, Theoretical Computer Science 27 (1983), pp. 333– 354.
Mader, A., “Verification of Modal Properties Using Boolean Equation Systems,” Ph.D. thesis, Technische Universit¨at Mu¨nchen (1997).
Meinel, C., Switching graphs and their complexity, in: Proc. MFCS 1989, LNCS 379 (1989), pp. 350–359.
Ritter, I. and A. Wolff (2008), personal communication.
Stirling, C., Model checking and other games (1996), notes for Mathfit Workshop on Finite Model Theory.
Tarjan, R., Depth-first search and linear graph algorithms, SIAM Journal on Computing 1 (1972),
pp. 146–160.
V¨oge, J. and M. Jurdzin´ski, A discrete strategy improvement algorithm for solving parity games (extended abstract), in: Proc. CAV 2000, LNCS 1855 (2000), pp. 202–215.
