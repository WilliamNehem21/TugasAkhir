

Electronic Notes in Theoretical Computer Science 229 (2009) 19–35
www.elsevier.com/locate/entcs

Security Policies Enforcement Using Finite Edit Automata
Dani`ele Beauquier a,1	Jo¨elle Cohena,2	Ruggero Lanotteb,3
a LACL
University Paris-Est CRETEIL, FRANCE
b Dipartimento di Scienze della cultura, Politiche e dell’Informazione Universita` dell’Insubria
COMO, ITALIA

Abstract
Edit automata have been introduced by J.Ligatti et al. as a model for security enforcement mechanisms which work at run time. In a distributed interacting system, they play a role of monitor that runs in parallel with a target program and transforms its execution sequence into a sequence that obeys the security property. In this paper we characterize security properties which are enforceable by finite edit automata,
i.e. edit automata with a finite set of states. We prove that these properties are a sub-class of ∞-regular
sets. Moreover given an ∞-regular set P , one can decide in time O(n2) whether P is enforceable by a finite edit automaton (where n is the number of states of the finite automaton recognizing P ) and we give an algorithm to synthesize the controller.
Keywords: Controller, finite edit automata, security.


Introduction
Security enforcement mechanisms are used to prevent violation of a policy which must guarantee protection of an extensible system and its user. Web browsers which upload and run applets programs or a database that allows users to submit their own queries have to ensure that the behavior of the system is not dangerous. This goal can be reached by means of a program monitor which enforces the security policy.
We restrict ourselves to enforcement mechanisms which work at run time in parallel with the program under control.

1 Email: beauquier@univ-paris12.fr
2 Email: j.cohen@univ-paris12.fr
3 Email: ruggero.lanotte@uninsubria.it

1571-0661 © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.037

Schneider[7,3] defined the first formal model of program monitor and studied what properties are enforceable with respect to this model. Ligatti and al. [4,5,2] propose a more general model based on edit automata. The monitor is not only able to interrupt a program execution in the case when it violates the security policy but it also can modify its behavior using suppression and insertion mechanisms.
Our goal is to characterize policies which can be enforced by edit automata having limited capabilities namely a finite memory. In [8] a family of edit automata named Bounded History Automata is introduced and policies enforceable by these automata are characterized, but the framework is different, the input alphabet and the set of states are not necessarily finite. Our results depend crucially on the finiteness of these two parameters.
The next section is devoted to definitions. Section 3 gives general properties of edit automata, in particular the fact that any recursive security policy is enforceable by an edit automaton. In section 4 we study the power of finite edit automata. The behavior of a finite edit automaton is analyzed as well as the structure of the enforced policy. The main result is given in section 5 : security policies enforceable by a finite edit automaton are exactly ∞-regular properties which are memory bounded. It is also proved that if the policy P is given by its finite automaton with n states, one can decide in O(n2) whether P is enforceable by a finite edit automaton and synthesize the controller in the positive case. We conclude in the last section with an example to illustrate the obtained results.

Basic notions
An execution σ is a finite sequence of actions a1a2 ... an. With |σ| we denote the length n of σ. We use the notation A∗ (resp. Aω) to denote the set of all finite length (resp. infinite length) sequences of actions on a system with finite action set
A. Let A∞ = A∗ ∪ Aω. The symbol ϵ denotes the empty sequence. We use the notation σ[i] to denote the i-th action in the sequence. The notation σ[..i] denotes the prefix of σ of length i, and σ[i + 1..] denotes the corresponding suffix. When τ is a proper prefix of σ we write τ < σ and we write τ ≤ σ to denote the fact that τ < σ or τ = σ.
An ultimately periodic sequence is an infinite sequence of the form uvω, where
u, v ∈ A∗,v /= ϵ.
For σ ∈ A∞ let us denote Pref(σ) the set of prefixes of σ, and fora set P ⊂ A∞, Pref(P ) denotes the set {u ∈ A∞ | u ∈ Pref(σ)for some σ ∈ P }. A security policy P is a subset of A∞ such that ϵ ∈ P .
We denote Pfin the set P ∩ A∗ and Pinf the set P ∩ Aω.

For X ⊂ A∗
−→
, the limit of X denoted X is the set of infinite sequences which

have infinitely many prefixes in X.
An edit automaton A is a deterministic finite or countably infinite state machine (Q, i, δ) that is defined with respect to some system with action set A. Q is the set of automaton states, s is the initial state, and, δ : Q × A → Q × (A ∪ {ϵ}), is the transition function. We require that δ be Turing Machine computable. If

δ(q, a) = (q', b), and b /= ϵ, the transition is an insertion step: a is observed on the input but not consumed and b is produced on the output. We will write the
·a
transition q −→ q'.
If δ(q, a) = (q', ϵ), the transition is a suppression step: a is read (consumed) on the input and nothing is produced on the output. We will write the transition
a·  q'.
A configuration is a pair (σ, q) ∈ A∞ × Q.
We define a labeled relation '→ on the set of configurations as follows:
b	'	·a	'
(aσ, q) '−→ (aσ, q ) if q −→ q is an insertion step in A.
Observe that an insertion is not possible if the input is empty.
є	'	a·	'
(aσ, q) '−→ (σ, q ) if q −→ q is a suppression step in A.
A computation of the edit automaton is a finite or infinite sequence

(σ ,q ) b1	b2
bn+1

0 0 '−→ (σ1, q1) '−→ ...(σn, qn) '−→ (σn+1, qn+1)....
In such a computation, on the input σ0 starting from state q0, the edit automaton produces the output b1b2...bn... and the piece of the input which is read after n steps is the prefix σ' of σ0 such that σ0 = σ'σn.
The reflexive and transitive closure of '→ is denoted '→∗. For β ∈ Aω we write
β
(α, q) '−→ ω if from configuration (α, q) there is no more suppression and the output
β[..n]
is β. More precisely, for every n there is a computation (α, q) '−→ (α, qn).
We define the function TA : A∞ → A∞ as the function assigning to each execu- tion σ its output τ from the initial state s.
More precisely TA(σ)= τ iff
τ	'	'
D1 if (σ, s) '−→∗ (σ , q) then τ ≤ τ
D2 for every τ ' ∈ A∗ prefix of τ there exists a state q and a sequence σ' such that
τ	'
(σ, s) '−→∗ (σ , q).
In [4], several types of enforcements are defined. As it is done in [5] we limit our study to effective enforcement. An effective enforcement preserves soundness and transparency. An enforcement mechanism of a policy P is sound when it ensures that outputs always obey P . Soundness is the main goal of an enforcement. It is transparent if it preserves the executions that already obey P . Notice that without transparency, any policy can be enforced in a trivial way just by outputing the empty sequence for example without reading the input. The formal definition is given below.
An edit automaton A effectively enforces a policy P ⊂ A∞ if
E1 ∀σ ∈ A∞,  TA(σ) ∈ P (soundness)
E2 ∀σ ∈ P  TA(σ)= σ. (transparency)
In [5] a characterization of properties enforceable by edit automata is given:

Theorem 2.1 There exists an edit automaton A that effectively enforces a security property P iff

∀σ ∈ Aω

−−→

σ ∈ Pinf iff σ ∈ Pfin or
∃σ' < σ ∀τ > σ' τ ∈ P =⇒ τ = σ and the existence and actions of σ are computable from σ'
the membership problem is decidable for Pfin.

Properties of edit automata
By transitivity of '→∗ we have the following proposition on the monotonicity of T .
Proposition 3.1 Let A be an edit automaton. If σ ≤ τ, then TA(σ) ≤ TA(τ ).
The next Lemma describes the possible outputs of a finite input, and the possible inputs for a finite output.
Lemma 3.2 Let A be an edit automaton that effectively enforces a policy P.
If TA(σ)= τ and σ ∈ A∗ then
either τ ∈ A∗ and (σ, s) τ	(ϵ, q) for some state q
or τ is inﬁnite and the computation from (σ, s) is inﬁnite and from some step it contains only insertions.
If TA(σ)= τ and τ ∈ A∗ then
either σ ∈ A∗ and (σ, s) '−τ→ (ϵ, q) for some state q
or σ is inﬁnite and there exists a preﬁx σ1 of σ = σ1σ2 such that
(σ , s) τ	(ϵ, q) and from (σ , q) the computation contains only suppressions.
1	'−→	2
if σ ∈ Pfin then (σ, s) '−σ→ (ϵ, q) for some state q and the last step of this computation is a suppression step.
Proof. 1. Let σ ∈ A∗ and TA(σ) = τ . The number of suppression steps in the computation from (σ, s) is therefore finite and bounded by |σ|.
Suppose that τ ∈ A∗. Then the number of insertion steps in the computation from (σ, i) is also finite. Let us consider the last insertion step in the computation with input σ:

τ	'	b	'
'	b	'

(σ, s) '−→ ∗(aσ , q1) '−→ (aσ , q2) where (aσ , q1) '−→ (aσ , q2) is the last inser-
tion step.
From configuration (aσ', q2) only suppression steps occur. Moreover A is com- plete therefore there exists a state q such that (aσ', q2) '−→ ∗(ϵ, q). Concatening the
two computations we get (σ, s) τ	(ϵ, q).
Suppose now that τ ∈ Aω. Here the number of insertion steps in the computation from (σ, s) is infinite. Since there is no possible computation from any configuration (ϵ, q), the last suppression step is of the form (aσ', q1) '−→ (σ', q2) for some non empty suffix σ' of σ and some states q1, q2. It follows that from configuration (σ', q2) there are only insertion steps and infinitely many.
the second point is proved in a symmetric way.
if σ ∈ Pfin then TA(σ) = σ and from point 2.  of the lemma we get

(σ, s) '—σ→ (ϵ, q) for some state q. The last step of this computation cannot be an insertion step because the input is empty at the end of this step.	 
Lemma 3.3 If A is an edit automaton effectively enforcing P, then for any σ ∈ A∞:
(σ' < σ and σ' ∈ P ) =⇒ σ' ≤ 7A(σ).
Proof. From Proposition 3.1, since σ' ≤ σ, then 7 (σ') ≤ 7A(σ). Moreover since
σ' ∈ P we have 7A(σ')= σ'.	 
Given σ ∈ A∗ and a policy P , with σP we denote the longest prefix of σ in P . This prefix exists since ϵ ∈ P .
Given σ ∈ Pfin, with PreIm(σ) we denote the set

{τ ∈ A∗ | τP = σ, τ /∈ P and τa ∈ P for some a ∈ A}.
Intuitively the set PreIm(σ) is the set of executions τ not in P having their longest prefix in P equal to σ and such that τa belongs to P for some a. This notion will be useful in the next section.
Lemma 3.4 Let A be an edit automaton effectively enforcing P let σ ∈ P and τ1, τ2 ∈ PreIm(σ) such that τ1 /= τ2. If τ is a preﬁx of τ1 and τ2 such that σ < τ, then 7A(τ )= σ.
Proof.
First of all we note that by definition of PreIm(σ), there exist a1, a2 ∈ A such that τ1a1 and τ2a2 are in P . We note also that, since τ1 ≥ τ > σ and τ1 ∈ PreIm(σ), we have that, for any γ such that τ1 ≥ γ > σ, it holds that γ /∈ P . Hence τP = σ.
Therefore by Lemma 3.3, σ ≤ 7A(τ ). Hence either 7A(τ )= σ or σ < 7A(τ ). We prove by contradiction that 7A(τ )= σ.
Let us suppose that σ < 7A(τ ). Since τ1a1 ∈ P we have that 7A(τ1a1)= τ1a1.
Since τ < τ1a1, by monotonicity, σ < 7A(τ ) ≤ τ1a1.
By definition of 7A, we have that 7A(τ ) ∈ P , but we have noticed that, for any
γ such that σ < γ ≤ τ1, it holds that γ /∈ P . Hence 7A(τ )= τ1a1.
Similarly we can prove that 7A(τ ) = τ2a2. Hence τ1a1 = τ2a2 implying that
τ1 = τ2 that is a contradiction by hypothesis.

Finite edit automata
A ﬁnite edit automaton is an edit automaton with a finite set of states. Our goal is to characterize properties enforceable by a finite edit automaton. We briefly recall some definitions about regular sets of finite or infinite sequences. For more details see [6].

Regular sets of ﬁnite or inﬁnite sequences
A deterministic ﬁnite automaton on an alphabet A is a tuple A = (Q, A, s, F, δ), where Q is a finite set of states, s is the initial state, F the set of terminal states,
and δ : Q ×A → Q is a partial transition function. We write q a	q' if δ(q, a)= q'. A finite sequence u ∈ A∗ is recognized (or accepted) by A if s '—a→ q' and q' ∈ F .
∗
The set of sequences recognized by A is denoted L(A). The automaton A is pruned
if every state q is reachable from s and q can reach at least one state of F .
A set L ⊂ A∗ is regular if there exists a deterministic finite automaton A such that L = L(A).
A deterministic Muller automaton on an alphabet A is a tuple A = (Q, A, s, F, δ), where Q is a finite set of states, s is the initial state, F ⊂ 2Q the family of sets of infinitely repeated states, and δ : Q ×A → Q is a partial transition function. An infinite sequence u ∈ Aω is recognized by A if there is an infinite run of A with input u whose set of infinitely repeated set of states belongs to F.
A set L ⊂ Aω is ω-regular if there exists a deterministic Muller automaton such that L = L(A).
A set F ⊂ Q is alive if there is at least one run from s whose set of infinitely repeated set of states is equal to F .
The automaton A is pruned if
every set of F is alive
every state q is reachable from s and q can reach at least one state of one set of F.
A set P ⊂ A∞ is ∞-regular if Pfin is regular and Pinf is ω-regular.
Clearly a set P ⊂ A∞ is ∞-regular iff there exists a generalized Muller automa- ton A = (Q, A, s, F, F, δ) such that (Q, A, s, F, δ) recognizes Pfin and (Q, A, s, F, δ) recognizes Pinf.
The generalized Muller automaton A is pruned if
every state q is reachable from s and q can reach at least one state of F or one set of F
every set of F is alive.
In the next two subsections we study the properties of Pfin and Pinf for a property P enforced by a finite edit automaton.

Properties of Pfin

Lemma 4.1 If there exists a ﬁnite edit automaton A that effectively enforces a security policy P then Pfin is regular.
Proof. We give only a sketch of the proof. Let q be a state in A. We define Lq as the set of finite sequences v ∈ A∗ such that there exists a finite sequence u and a
computation (u, s) v	(ϵ, q) (i.e. 7A(u)= v).
If A enforces the policy P , from Lemma 3.2(iii) we have Pfin = ∪q∈QLq. Proving that Lq is regular will imply that Pfin is regular.

It is easy to construct a finite automaton Aq that accepts Lq.

Proposition 4.2 If there exists a ﬁnite edit automaton A that effectively enforces a security policy P then for any σ ∈ Pfin, it holds that PreIm(σ) is a ﬁnite set.
Proof. By contradiction suppose that PreIm(σ) is an infinite set for some σ ∈ P . Recall that all sequences of PreIm(σ) have σ as prefix. Since the alphabet A is finite, there is an action a and c such that σα ∈ PreIm(σ) and σαa ∈ P .
For each of these sequences α, using Lemma 3.2(iii), we have:

(σ, s) σ
(ϵ, q) and (σαa, s) σαa
(ϵ, qσ) for some states q, qσ, and the last steps

of these two computations are a suppression step.

Thus (σαa, s) σ
(αa, q) αa
(ϵ, qσ).

Let us analyse the second part of this computation. There is a step where the input contains only the last action a, it means that σα has been suppressed from the input. From Lemma 3.4, since σα /∈ P the output is σ.
So we have:

(σαa, s) '—σ→ (αa, q) '—→є
(a, q' ) '—α→a
(a,'' ) '—→є
(ϵ, qσ).

Because the set of states of A is finite there is three states q1, q2, q3 and infinitely many sequences α such that

(αa, q) '—→є
(a, q ) '—α→a
(a, q ) '—→є
(ϵ, q3). (∗)

Therefore, for fixed q, q1, q2, we have for infinitely many σ:
(αa, q) '—→є	(a, q ) '—α→a  (a, q ). Since the alphabet A is finite, there is a sequence
2
σ0 of length greater than n, where n is the number of states of A satisfying (∗).
Thus there is a repeated state in the part (a, q ) α0 a  (a, q ). But in this com-
1 '—→	2
putation there are only insertions, so if a state is repeated in this part, since the input does not change and is equal to a, it implies that the controller which his deterministic will make insertions for ever and will never realize the suppression of a in the last part. Contradiction.

A finite automaton A is simple if every cycle in A contains at least one state of
F .
Lemma 4.3 If Pfin is a regular set recognized by a deterministic pruned ﬁnite automaton A then
the set PreIm(σ) is ﬁnite for any σ ∈ Pfin iff A is simple.
Proof. The ”if” part is proved by contradiction. Suppose there is a cycle in A
without final states. Then there is a path s w1	q —→w	q —→v	w a	q where
——→∗ 2
q1, q2 are final states,
v is the label of the non-final cycle,

there is no final state except q ,q 
on the path q
wvw2a	q .

1  2	1 ————→∗ 2
Then w1wv∗w2 ⊂ PreIm(w1) that contradicts Proposition 4.2.

Conversely, let u ∈ P  and s —→u  q be the path labeled by u starting from s. There are finitely many reachable final states from final state q. A sequence τ in PreIm(u) labels a path where q is the last final state of the path, because u is its longest prefix that belongs to Pfin. Moreover, this path can be extended up to a
final state q' such as s u	τa	q'. As there are no cycles between q and q', the
—→∗
number of such sequences is finite.	 

Properties of Pinf
From Theorem 2.1, we know that if a security policy P is effectively enforceable by
——→

a finite edit automaton A then Pfin ⊂ Pinf.
——→

Let us study now the infinite sequences σ of Pinf which are not in Pfin. The
next Lemma proves that the computation of such a sequence can be decomposed in three parts, the first part reads and outputs σP , in the second part the controller consumes a piece of the input and outputs nothing, in the last part, the input no longer changes and the controller makes infinitely many insertions.
Lemma 4.4 If a ﬁnite edit automaton effectively enforces a security policy P then
——→
every σ ∈ Pinf \ Pfin can be written in a unique way σ1αβ such that:
σ1 is the longest ﬁnite preﬁx of σ in Pfin

(σ αβ, s)  σ1	(αβ, q) '—→є
(β, q') for some q, q'

1	'—→∗	∗

(β, q') αβ
and β is ultimately periodic

σ1α /∈ Pref (Pfin).
Proof. Let P ' = Pinf

——→
Pfin. Consider σ ∈ P . Let σ1

be the longest finite prefix of σ
——→

such that σ1 ∈ Pfin. The sequence σ1 exists since σ /∈ Pfin and ϵ ∈ P . Then using
Lemma 3.2 there is a computation (σ , s) σ1	(ϵ, q) where the last computation

step is a suppression one.
1	'—→∗

Let σ = σ σ'. So one has (σ σ', s) σ1
(σ', q) (1).

1	1	'—→∗
Since σ ∈ P , for every β ∈ A+ such that σ1β < σ we have a computation

(σ, s) σ1 β  (σ''
, q'') (2) for some σ''
, q''.

Now, using the determinism of the controller, computation (1) is a prefix of computation (2) Then from (σ', q), there must be an insertion step in order to output β.
Let then σ' = ασ'' where α is the longest finite prefix of σ' on which A pro- duces only suppressions (α can be the empty sequence). We have the computation

(σ', q) '—→є
(σ'', q') '—→b
(σ'',q ) where (σ'', q') '—→b
(σ'', q1) is the first insertion step

after (σ', q).
Suppose now that there is a suppression step after this insertion step and again consider the first one : we have σ' = ασ'' and states q1, q2 such that there is

σ1	'
є	''	'	α	''

a computation (σ, s) '—→∗ (σ , q) '—→∗ (σ
,q ) '—→∗ (σ
, q1) and the next step is a

suppression one. It follows that 7A(σ1α) = σ1α'. Hence we have σ1α' ∈ Pfin and
σ1 < σ1α' ≤ σ whereas σ1 is the longest finite prefix of σ that belongs to P :

contradiction.
Therefore in the computation from (σ', q), once there is an insertion step, there are always insertion steps. Let q be the state from which only insertions steps occur in computation from (σ', q).  Let then σ = σ1αβ with computation
(σ, s)  σ1	(αβ, q)	є	(β, q'). Moreover since there is no more suppression step,
the computation of length n from (β, q') produces as output the prefix of length
' (αβ)[..n]
n of αβ: (β, q ) '—→	(β, qn) for some state qn. But A has a finite set of states,
and the input does not change from (β, q') thus there exists integers n1 < n2 such that qn1 = qn2 and from qn1 the output is periodic, so from (β, q') the output is ultimately periodic.
We have proved that any infinite sequence in P ' is of the form σ1αβ where σ1 ∈ Pfin, α as input corresponds to a sequence of suppression steps and β is an ultimately periodic sequence.
Remark that for such a sequence σ in P ', the set Pref(σ) ∩ Pref(Pfin) is finite. Indeed if it was not the case there would exist a prefix γ of σ and γ' ∈ A∗ such that γ = σ1αaβ' with β' < β and γγ' ∈ Pfin. Then we should have 7 (γγ')= γγ'. But on the other hand 7 (γγ') = 7 (σ1αaβ'γ') = σ. A contradiction. We deduce that there is a longest prefix of σ in Pref(Pfin) and this prefix is of the form σ1α' where α' ≤ α.	 
——→
We are now in position to give an ω-regular expression of Pinf \ Pfin
Proposition 4.5 If a ﬁnite edit automaton effectively enforces a security policy P

then P
——→
\	is of the form ∪
R β  where

inf
Pfin
j∈J  j j

J is ﬁnite
for every j ∈ J, Rj is regular
for every j ∈ J, βj is an ultimately periodic sequence in Aω
for every j ∈ J, Rj ∩ Pref(Pfin)= ∅
Rj ∩ Pref(Ri)= ∅ for i /= j
for every u < v with u /∈ Pref(Pfin) and v ∈ Rj we have |v|— |u| ≤ K where K
is the number of states of A.
As a consequence Pinf is ω-regular.

Proof. Let P ' = P
——→
\	, then σ has the form σ α β
satisfying properties of

inf
Pfin
1 σ σ

Lemma 4.4. Remark that the set Pref(σ) ∩ Pref(Pfin) is finite. Indeed if it is not finite then there exists a prefix γ of σ and γ' ∈ A∗ such that γ = σ1ασβ' with β' < βσ and γγ' ∈ Pfin. Then we should have the following : 7A(γγ')= γγ'. But we have using Lemma 4.4, 7A(γγ')= 7A(σ1ασβ'γ')= σ. Contradiction.
We deduce that there is a longest prefix of σ in Pref(Pfin) and this prefix is of the form σ1α' where α' ≤ ασ.
Now we focus on the set E of finite sequences ασ for all σ in P ' and we prove that E is finite.
Recall that each σ ∈ P ' is written in a unique way σ1ασβσ such that the com-

putation starting in (σ1ασβσ, s) is as follows:

(σ α β
, s) σ1
(α β ,q )	є
(β , q' )ασβσ	.

1 σ σ
'—→∗
σ σ	σ
'—→∗
σ	σ '—→ ω

If E is infinite, there exists an infinite sequence α such that every prefix α[..p]
'
of α is also a prefix of some ασp in E for some σp ∈ P . Since the set of states of A
and the alphabet A are finite, there exist an action a and states q and q' such that

for all σp we have qσp
= q, q'
= q' and a is the first letter of βσ .

Thus for all σp we have:

(ασβσ
, q) '—→є
(βσ
, q')ασβσ	.

' ασp βσp	'

But the computation (βσp ,q ) '—→ ω depends only on q
and the first letter of

βσp . Thus all the outputs ασp βσp are equal and so necessarily equal to α. The
sequence α is ultimately periodic α = α1αω. There exists p large enough such that αp = α1αKα' , where K is the number of states of A. Then the computation

2
(ασ βσ , q) '—→є
p
(βσ , q') has some repeated state in the following way:

p	p	∗	p

(α αKα' , q)	є
(αK1 α' β
,q )	є
(αK2 α' β
,q )	є
(β  , q').

2	p
'—→∗
p σp
1 '—→∗
2	p σp
1 '—→∗	σp

On the other hand α' βσ = αω. So from configuration (α' βσ , q1) the computa-
p	p	2	p	p

tion makes only suppressions for ever. It contradicts the fact that (βσ
, q')ασβσ	.

Since σ ∈ P ', we deduce that σ1α1α'kα2aβ ∈ P ' for any positive integer k. Then we must have for any positive integer k:
7A(σ1αaβ)= σ
7A(σ1α1α'kα2aβ)= σ1α1α'kα2aβ
Besides that we have 7A(σ1α1α'kα2aβ)= σ.
Hence for any positive integer k we have σ1α1α'α2aβ = σ1α1α'kα2aβ. We deduce that σ = σ1α1α'ω. In that case 7A(σ)= σ1. Contradiction.
We have proved that E is finite and the number of sequences in E is bounded by K2|A|.
Now we make precise the set P '. From Lemma 4 Pfin is regular. Let L' =
{u | (u, s) '—v→ (ϵ, q) for some v ∈ A∗}. From A it is easy to construct a finite
automaton which recognizes L' . Consider L¯' = L' ∩ Pfin Clearly, for each u ∈ L¯'
q	q	q	q
we have (u, s) u	(ϵ, q). And L¯' is a regular set.
Let a ∈ A. We define the set of states Qa = {q ∈ Q|∃q' ∈ Q δ(q, a)= (q', b)}.
For q ∈ Qa we can notice that there is exactly one infinite computation from (aγ, q) for any finite or infinite sequence γ; this computation performs only insertion steps and the output for this computation is ultimately periodic as proved in Lemma
7. Let us denote βq,a this ultimately periodic sequence.
Let q be a state of A and q' be a state of Qa for a non empty Qa. Let Fq,q' ,a
be the set of sequences α in A∗ whose length is less than K such that there is a
computation (α, q) '—→є	(ϵ, q') and such that αa < β '  .
q ,a
The set Fq,q',a has at most one sequence. Indeed, if α and α' are two different sequences in Fq,q',a, since α and α' are prefixes of βq',a one has α < α' (or the converse). It follows that α' = αau for some u.

Besides we have also the computations

(α, q)	є	(ϵ, q') and (α', q)	є
(ϵ, q'). From the first one we deduce the com-

putation (αau, q) '—→є	(au, q'). From the second one we deduce the computation
(αau, q) '—→є	(ϵ, q'). But from (au, q') there are only insertions steps that is in con-
tradiction with this last computation. Let us denote αq,q',a the unique sequence in
Fq,q',a when Fq,q' ,a is not empty. And we can set :

βq',a = αq,q',aaβ' '
for q, q',a such that Qa /= ∅ and Fq,q' ,a /= ∅. Moreover one

can prove that |αq,q',a| < K2, otherwise in the last part of the computation when there are only insertion steps, the repetitive part would begin inside the production of αq,q',a and αq,q',a would contain at least K times the period. But in that case the

computation starting from (αq,q',aaβ' '
, q) would be made of suppressions for ever.

A contradiction.
We have then
|αq,q',a| < K2
βq' ,a is ultimately periodic.
We define the sets Rq,q',a = L¯q αq,q',aa.
We have proved that P ' ⊂ ∪q,a,q' Rq,q',aβq' ,a. By construction we have clearly also ∪q,q',aRq,q',aβq' ,a ⊂ Pinf. Moreover an infinite sequence in some Rq,q',aβq' ,a cannot belong to Pfin since Rq,q',a ∩ Pref(Pfin)= ∅.
Hence P ' = ∪q,q',aRq,q',aβq' ,a.
We have to prove that sets Rq,q',a satisfy
Rq,q',a ∩ Pref(Pfin)= ∅,
they are mutually disjoints,
they are regular
Rq,q',a ∩ Pref(Rq ,q' ,b)= ∅ for any (q, q', a) /= (q1, q' , b).
1 1	1
The first property follows from Lemma 7.
Let u ∈ Rq,q',a ∩ Rq1,q' ,b. Then we have u = vαaa = wαbb with v, w ∈ Pfin
such that there are computations

(v, s) '—→v
(w, s)  w
(ϵ, q) with a suppression last step (ϵ, q ) with a suppression last step

'—→∗
(αaa, q)	є
(α b, q ) '—→є
1
(a, q')
(b, q' ).

b	1	∗	1
Firstly a = b clearly holds.
Suppose now v < w. Then we have w = vα' where α' ≤ αa and there is a com-
putation (w, q )	v	(α', q)	є	(ϵ, q ) for some q . Hence v = w and moreover

αa = αb.
0 '—→∗
'—→∗	2	2

Rq,q',a has been proved to be regular.
Let u ∈ Rq,q',a ∩ Pref(Rq1,q' ,b). Then on one hand we have u = vαaa = with

v ∈ P
with a computation (u, q )	v
(a, q') with a suppression last step. On

fin
0 '—→∗

the other hand we have a sequence u' such that uu' = vαaau' ∈ Rq ,q' ,b. Thus
1 1

there must be the computation (uu',q ) '—→w	(b, q' ). Hence we have (uu',q ) —→
0	∗	1	0	∗
(au', q') '—→∗ (b, q' ). But from (au', q') there are only insertion steps. It follows
that u' = ϵ and u ∈ Rq ,q' ,b. As aforementioned we deduce (q, q', a)= (q1, q' , b). 
1 1	1
Definition 4.6 A policy P is memory bounded if P is of the form P = P	∪
——→
Pfin ∪j∈J Rjβj where
ϵ ∈ P
J is finite
Pfin ⊂ A∗ is recognized by a simple finite automaton
for every j ∈ J, Rj is regular
for every j ∈ J, βj is an ultimately periodic sequence in Aω
for every j ∈ J, Rj ∩ Pref (Pfin)= ∅
Rj ∩ Pref(Ri)= ∅ for i /= j
there exists a constant K such that for every u < v with u /∈ Pref(Pfin) and
v ∈ Rj |v|— |u| ≤ K.
From Proposition 4.5 we obtain:
Theorem 4.7 If a security policy P is enforced by a ﬁnite edit automaton, then P
is memory bounded.
We intend now to characterize the generalized Muller automata which recognize properties that are memory bounded.
Definition 4.8 A pruned generalized Muller automaton A is simple if:
S0. s ∈ F
S1. each cycle encounters F or a set of J
S2. the restriction of the automaton A to each set Fi in J which has no state in F
is an elementary cycle Ci
S3. there is no edge from a state in Ci to a state not in Ci for every i
S4. each alive set G such that G ∩ F /= ∅ belongs to J.
Proposition 4.9 Given a pruned generalized Muller automaton A, L(A) is mem- ory bounded iff A is simple.
Proof. • Let us suppose that A is simple. Let P be the property recognized by A.
——→
Because of S0, ϵ ∈ P . Because of condition S4 we have Pfin ⊂ Pinf. Let

P ' = P \ (Pfin
——→
∪ Pfin). Let
J' be the family of sets Fj
in J disjoint from F . Let

us remark that from properties S2 and S3 one can deduce that for distinct Fi and Fj in J', cycles Ci and Cj are disjoint. Let us call this property, property S5. For each G in J', and each q ∈ G let Rq be the set of finite sequences recognized by A in a computation which starts in the initial state and stops in state q without running through G before the last state q. Let βq be the periodic infinite sequence

recognized by A in a computation which starts in q. Because of properties S2 and
S3, βq is unique.

Clearly P ' = 

G∈F ',q∈G
Rqβq where J' is the set of Fi in J disjoint of F .

By construction, Rq ∩ Pfin = ∅, and from property S3, Rq ∩ Pref(Pfin) = ∅. Because of properties S3 and S5, Rq ∩ Pref(Rq' ) = ∅. At last, for two different q and q', there is no common sequence to Rqβq and Rq' βq' because either q and q' are not in the same G of J' and the computation of σ cannot have two distinct infinitely repeated sets, or q and q' are in the same G of J' and the first state of G reached in the computation of σ is unique.
So if A satisfies properties S0 — S4, then P ' has the required form.
Conversely, if property S0 is not satisfied then ϵ /∈ P . If S4 is not satisfied,

——→
then Pfin /⊂ Pinf . If property S2 is not satisfied then P '
contains infinite sequences

which are not ultimately periodic. Thus P ' cannot have the required form.
Let us suppose that A satisfies properties S0, S2, S4 but not property S3. There exists a cycle Ci in J' which has an outgoing edge. In that case, since the automaton is pruned, this edge can be extended either in a path which reaches F , or ina path which reaches another cycle Cj. Because of Proposition 2 and Lemma 5 Ci cannot reach F . So it reaches another cycle Cj.
For any constant K > 0 one can build an infinite path with a piece p larger than K and larger than the number of states of A inside Ci and reaching after that Cj for ever. Let σ the infinite sequence labeling this infinite path. Invoking the determinism of the automaton, the piece p cannot contain a period of the ultimately periodic part of σ. So if P ' has the required form, σ belongs to some Riβi, but the the piece p corresponds to prefixes of σ which are not in Pref(Pfin) and the length of p is larger than K. A contradiction. We have proved that if A satisfies property S2 but not property S3 then P ' cannot have the required form.
Suppose now that A satisfies properties S0, S2 S3 and S4 but not property S1. It means that there exists a cycle C from which one can reach either F , or some Ci. Then along the same lines as in the previous case P ' cannot have the required form.	 
Proposition 4.10 Given a pruned generalized Muller automaton A with n states, one can decide in time O(n2) whether L(A) is memory bounded.
Proof. Here is the algorithm :
Check that s ∈ F
Compute the set C of terminal strongly connected components of A
Compute the set C' of terminal strongly connected components which do not intersect F
Check whether there is only one infinite path from one state of each component in C'
Compute the set of states D not in F that can reach F .
Check that the set of paths that reach F from each state in D is finite.



Characterization of policies effectively enforced by a ﬁnite edit automaton
In this subsection we give the reverse part of Theorem 4.7.
Theorem 4.11 Given a pruned generalized Muller automaton A recognizing a se- curity policy P which is memory bounded, one can build a ﬁnite edit automaton which effectively enforces P.
Proof. From Proposition 4.9 the automaton A is simple. We now build the edit automaton which enforces P . Let us first describe informally the behavior of this controller. The states of the automaton A can be divided into three parts: F , I the set of internal states not in F but that can reach F , and the set O for the other ones. Let an input u1u2...uk in Pfin which has k +1 prefixes in Pfin, namely ϵ, u1, u1u2, ...u1u2...uk. The controller reads u1 except its last letter and memorizes it, then observes the last letter of u1 and writes u1, and finally reads the last letter of u1, the controller processes in the same way for u2, ...uk. The reason why the controller does not read immediately the last letter of u1 is that after this reading, the output must be u , so the controller must write entirely u before the end of
——→
the reading of u1. Sequences in Pfin ∪ Pfin are processed in this way. For infinite
sequences in P \(Pfin ∪ Pfin), as long as the prefix is in Pref(Pfin) the treatment is as before, but when the input is no longer in Pref(Pfin), which happens when the automaton A enters a state in O then the controller reads the input and memorizes it until a final cycle is reached. When a final cycle is reached the controller stops the reading and writes the memorized factor followed by the periodic final part. For any sequence σ not in P , the behavior of the controller at the beginning is the same, but as soon as the automaton A cannot read a letter the controller stops the writing and reads the input up to the end. So the output is the longest prefix of σ that is in Pfin. We give now the detailed transitions of the controller. Let A = (Q, A, s, F, δ). The set of states Q can be divided into three parts: F the set of final states, I the set of states not in F but that can reach F , and O the set of other states. We divide O into Oi the set of states in O which do not belong to a set in J and Of the complement. Due to the fact that A is simple, each state q of Of defines a unique sequence aquq which is the label of the elementary cycle starting in q.
The set of states of the edit automaton is: Q = Q ∪ Qˆ × A ∪ (Q ∪ Q¯) × A≤n ∪ {t}. Transitions are :

a·|є
q —→
·a|a
q
' if q ∈ F and δ(q, a)= q' /∈ F
'

—→ qˆa if q ∈ F and δ(q, a)= q ∈ F
a·|є
qˆa —→ q if q ∈ F
a·|є
q

u —→ qua if δ(q, a)= q and q
/∈ F ∪ Of

The controller memorizes the factor it will write later if the input is admissible.

·a|b
qbu —→
'	if δ(q, a)= q' and q' ∈ F ∪ Of

·a|b
q¯bua —→
·a|a
q¯ua if q ∈ F ∪ Of

q¯a —→ qˆa if q ∈ F ∪ Of
·a|b
qˆ

a —→ qˆa if q ∈ Of and δ(q, b)= q
∈ Of

The controller writes the factor it has memorized.
a·|є
qˆa —→ q if q ∈ F The controller ends the reading of a sequence in Pfin.
·a|b
qˆ

a —→ qˆa if q ∈ Of and δ(q, b)= q
∈ Of

The controller writes an infinite periodic sequence and no longer reads any letter.
a·|є	a·|є
qu —→ t and q —→ t if there is no transition δ(q, a)
a·|є
t —→ t for every a ∈ A.
The input is not in P , its longest prefix in P has been written, the end of the input is read without writing anything.

From Theorems 4.7 and 4.11 we get:
Theorem 4.12 A security policy is effectively enforceable by a ﬁnite edit automaton iff it is memory bounded.
and from Proposition 4.10:
Theorem 4.13 Given a pruned generalized Muller automaton A with n states, one can decide in O(n2) whether L(A) is effectively enforceable by a ﬁnite edit automaton.

An example
In the following example the set of actions is A = {0, 1, a, } where
0 is an action for opening a session
1 is an action for closing a session
a is an action that is allowed to be done only outside a session
	is an interruption that can be used to end processing while a user intends to have a forbidden behavior.
The policy we consider here is : 
P = Pref(X) ∪ —→ ∪ X0 ω where X = ((01)∗ ∪ a)∗.
The “normal” behavior is represented by Pref(X) ∪ —→
execute action a inside a session, namely just after an opening action 0 the process is interrupted by an infinite sequence of  actions that corresponds to X0 ω.
An edit automaton that enforces P is shown below. It interrupts any attempt of running action a when a session is opened but not closed. Any irrelevant opening or closing action is suppressed as well as irrelevant interruptions. An insertion

·a|a
step q —→ q
followed by a suppression step q' a·|є  q” is compressed in one single

a·|a
transition q —→ q”.
1·, ·| ϵ


a ·| a









1·, ·| ϵ	0 ·| ϵ

Discussion
In this paper we have characterized the policies that can be enforced by finite edit automata. These policies are a subclass of ∞-regular policies. Moreover, we provide an algorithm which constructs the program monitor from an automaton that recognizes the policy.
Finite transducers [1] are a classical notion very close to edit automata. A finite transducer on an alphabet A is defined by its finite set of states Q, an initial state s and a set of transitions δ ⊂ Q × A × {ϵ} × Q ∪ Q × {ϵ} × A × Q. Transitions (q, a, ϵ, q') (read transitions) represent a suppression of a on the input and nothing is written on the output, transitions (q, ϵ, b, q') (write transitions) correspond to an input unchanged and a b is written on the output. Determinism implies there are no two different read transitions from the same state and the same read action, no two different write transitions from the same state and if there is a read action form a state there is no write action from the same state. A finite transducer is complete if from every state where a write transition is impossible there is a read transition for every letter in input. Thus the difference between deterministic complete finite transducers (dcft) and edit automata is very minimal, the write transitions in dcft do not depend on a future input (the input can empty) but only on the current state contrary to edit automata. One can prove and it is not surprising that finite edit automata and dcft enforce the same class of policies.
Our future work will be done in several directions. A natural question is whether one can decide if a given edit automaton enforces the set of sequences of its output. We will solve this question positively at least in the case when the edit automaton is finite. Secondly, we plane to explore the power of pushdown edit automata. At last, we intend to distinguish actions of different types. Actually in practice there are some limitations about the power of the controller. Some actions are unsuppressible by the controller or uninsertable. So it may be of interest to consider a specification

that takes into account this feature.

References
J. Berstel. Transductions and Context-free Languages. Teubner Verlag, 1979.
L. Bauer, J. Ligatti, and D. Walker. More enforceable security policies, 2002.
Kevin W. Hamlen, Greg Morrisett, and Fred B. Schneider. Computability classes for enforcement mechanisms. ACM Transactions on Programming Languages and Systems (TOPLAS), 28(1):175 – 205, 2006.
J. Ligatti, L. Bauer, and D. Walker. Edit automata: Enforcement mechanisms for run-time security policies. International Journal of Information Security, 4:2–16, 2005.
J. Ligatti, L. Bauer, and D. Walker. Enforcing non-safety security policies with program monitors. In Computer Security - ESORICS 2005, volume 3679 of Lecture Notes in Computer Sciences, pages 353–373, 2005.
D. Perrin and J.E. Pin. Infinite Words Automata, Semigroups, Logic and Games, volume 141 of Pure and Applied Mathematics. Elsevier, 2004.
Fred B. Schneider. Enforceable security policies. ACM Trans. Inf. Syst. Secur., 3(1):30–50, 2000.
C. Talhia, N. Tawbia, and M. Debbabib. Execution monitoring enforcement under memory-limitation constraints. Information and Computation, 2008.
