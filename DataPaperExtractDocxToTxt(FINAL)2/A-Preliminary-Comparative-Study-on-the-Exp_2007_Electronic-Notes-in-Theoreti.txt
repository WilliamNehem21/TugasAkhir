Electronic Notes in Theoretical Computer Science 180 (2007) 3–19	
www.elsevier.com/locate/entcs

A Preliminary Comparative Study on the Expressive Power of Reo and Linda
Silvia Amaro 1 ,4
Dpto. de C. de la Computacio´n, National University of Comahue Neuqu´en, Argentina

Ernesto Pimentel2 ,5
Dpto. de Lenguajes y Ciencias de la Computacio´n, University of M´alaga M´alaga, Spain

Ana M. Roldan3 ,5
Dpto. de Ing. Electro´nica y Sist. Informa´ticos, University of Huelva Huelva, Spain


Abstract
Component-based Software Development is an emerging discipline in the field of Software Engineering. In this context, coordination languages may be used to specify the interactive behavior of software components, and most of the proposals presented in the literature are based on shared data-space models, as Linda. On the other hand, a new model for coordination based on communication channels (Reo) is also emerging, and we argue it also can be used to describe component protocols in a very elegant way. Making a comparative analysis on the expressiveness of this channel based model and Linda is the main objective of the present work, which presents a first step to make an exhaustive formal study. Thus, in this paper we provide a couple of modular embeddings for the synchronous case and the asynchronous case by defining a common formalism in order to allow the comparison of both models at an homogeneous level of abstraction. We hope these results will help us to develop a complete study about the Reo’s expressiveness, and to define an interaction description language based on Reo for component coordination, as it has already made in the context of Linda.
Keywords: Coordination, process algebra, modular embedding, expressivity.



1 Email: samaro@uncoma.edu.ar
2 Email: ernesto@lcc.uma.es
3 Email: amroldan@diesia.uhu.es
4 The work of Silvia Amaro has been partially supported by CYTED, proyect VII-J-RITOS2
5 The work of Ana M. Rold´an and E. Pimentel has been partially supported by the Spanish project TIC2001-2705-C03-02

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.043

Introduction
A number of works on coordination models and languages are centered in software interoperability. Such models and languages have evolved towards data oriented models and control-event oriented models [1]. Recently a new model, called Reo, based on the combination of connectors (constructed as a set of communicating channels) has been defined [2].
Linda [10] is one of the most representative coordination languages, originally presented as a set of inter-agent communication primitives which can be added to virtually any programming language. Linda’s communication primitives allow pro- cesses to add, delete and test for the presence/absence of tuples in a shared tuple space. The tuple space is a multiset of data (tuples), shared by concurrently running processes. Delete and test operations are blocking and follow an associative naming scheme that operates like select in relational databases. Reo is a recently introduced channel-based coordination model which enforces the use of connectors for the co- ordination of concurrent processes or component instances in a component-based system. Channels are the basic connectors from which more complex connectors can be constructed through composition. The channel composition mechanism in addition to the great diversity of channel types (with a well defined behavior) al- lows the construction of many different connectors, where each connector imposes a specific coordination pattern.
The expressive power of both models (Linda and Reo) has been independently studied by using different approaches. A very complete study on the expressive power of Linda was made by Brogi and Jacquet in [6,7] where different Linda-like concurrent languages were compared by using the notion of modular embedding [5]. On the other hand, when Reo was introduced, Arbab [2] provideda number of examples to show the expressive power of his proposal, simulating in a simple and elegant way different communication mechanisms. The objective of this paper is starting a comparison between both models, making a comparative analysis between Reo and Linda, considering both the asynchronous behavior (inherent to Linda), and the synchronous one. Both models present very different abstraction levels: Linda is based on a set of communication primitives accessing to a shared tuple space, whereas Reo is also defined in terms of communications primitives, but acting on connectors which are constructed as a combination of different kinds of channels. In order to have an homogeneous level of abstraction which allows a fair comparison, we will define two process calculi for each formalism, following the work by [9], and we will compare them.
In the case of Linda, we will define a process calculus L encoding the primitives and including usual parallel and non-deterministic choice operators, such as it was made in [8]. A similar process calculus R will be defined for Reo, but in this case, the operational semantics will be parameterized with respect to the connector on which primitives are accessing. Thus, the actual comparison will be made between Linda and several “instantiations” of Reo, and it will be given by the definition of a couple of modular embeddings [5], one for the asynchronous case (considering the bag channel in Reo), and the other one for the synchronous case (where a

synchronous channel will be used in Reo).
The rest of the paper is organized as follows. In Section 2 we present both interaction models, their semantics, the two process calculi previously mentioned, and the properties defining them. The comparing method and its application to compare both models is presented in Section 3. Finally, we give some conclusions and future work.

Shared tuples and channel-based connectors
In the context of coordination models and languages we can identify data-driven ori- ented languages and control-driven oriented ones. Nowadays, a new channel-based coordination language based on composition of communication channels (introduced by Arbab and others [4]) is appearing. The main characteristic of data-driven co- ordination models and languages is that the state of the computation at any time is defined in terms of both values of the data received or sent and the actual config- uration of the coordinated components. In the case of channel-based coordination models the framework evolves by means of performing communication actions over input or output ends of channels to which the coordinated components are con- nected.
Linda [10] belongs to the first family (data-driven). It was the first coordina- tion language, originally presented as a set of inter-agent communication primitives which can be added to virtually any programming language. Linda’s communica- tion primitives allow processes to add, delete and test for the presence/absence of tuples in a shared tuple space. The tuple space is a multiset of data (tuples), shared by concurrently running processes. Reo [2] is a recently introduced channel-based coordination model which enforces the use of connectors for the coordination of con- current processes or component instances in a component-based system. Channels are the basic connectors from which more complex connectors can be constructed through composition. The channel composition mechanism in addition to the great diversity of channel types (with a well defined behavior given by ordering schemes, buffers, synchronism, end types) allow the construction of many different connectors. Each connector imposes a specific coordination pattern.In this context communica- tion among component instances takes place by means of input and output actions over connector ends, acting as connection points. Connectors are modelled as ab- stract behavior types (ABT)[3]. An ABT defines an abstract behavior as a relation among the observable input/output that occur through a set of connection points. Each connection point is identified as an input or output portal. The expression R(I1, I2, ..., Ik; O1, O2, ..., Oh) defines an ABT with k input portals, h output portals and the relation R over them. For example the behavior of a synchronous channel (which is one of the basic connectors proposed by Reo) is captured by the following ABT:
Sync(⟨α, a⟩; ⟨β, b⟩) ≡ ⟨α, a⟩ = ⟨β, b⟩
This ABT represents the behavior of any entity that produces an output identical to its input and at the same time.

The variety of channel types that can be used in Reo makes possible to construct other coordination models. Consider the bag channel type, it has one input end, one output end and an unbounded buffer in which all data items matching the filter of the channel are accepted and kept, as in a multiset. So the write operation is always possible, and a read or take operation over the output end selects in a non- deterministic way one of the items that match the pattern specified. This behavior permits us to simulate the actions of Linda over the store. In a forward section we will prove this relation.
In this work, we present a comparative study on the expressive power of these two models. As Linda and Reo describe coordination issues at two different levels of abstraction, we propose two process calculi L and R to define a common formalism including the communication primitives of both models.

The Linda calculus
Following [9], we shall consider a process algebra L containing the communication primitives of Linda. These primitives permit to add a tuple (out ), to remove a tuple (in), and to test the presence of a tuple (rd ) in the shared dataspace. The language L also includes the standard prefix, choice and parallel composition operators in the style of CCS.
The syntax of L is formally defined as follows:
P ::= 0L | A.P | P + P | P  P | recX.P
A ::= rd(t) | in(t) | out(t)
where 0L denotes the empty process and t denotes a tuple.
The operational semantics of L can be modelled by a labelled transition system defined by the rules of Table 1. Notice that the configurations of the transition system extend the syntax of agents by allowing parallel composition of tuples. For- mally, the transition system of Table 1 refers to the extended language L' defined as:
P ' ::= P | P ' ||L ⟨t⟩
Rule (1)L states that the output operation consists of an internal move (τout) which creates the tuple ⟨t⟩. Rule (2)L shows that a tuple ⟨t⟩ is ready to offer itself to the environment by performing an action labelled t. Rules (3)L and (4)L describe the behavior of the prefixes in(t) and rd(t) whose labels are t, and t, respectively. Rule (5)L is the standard rule for choice composition. Rule (6)L is the standard rule for the synchronization between the complementary actions t and t: It models the effective execution of an in(t) operation. Rule (7)L defines the synchronization between two processes performing a transition labelled t and t, respectively. Notice that the process performing t is left unchanged, since the read operation rd(t) does not modify the dataspace. The usual rule (8)L for the parallel operator can be applied with different labels. Following [9], there are no rules for recursion since its semantics is defined by structural axiom recX.P ≡ P [recX.P/X] which applies an unfolding step to a recursively defined process. We also consider the transition



Table 1 Transition system for L.

system closed under the usual structural axioms for parallel or choice operators.
The rules of Table 1 are used to define the set of derivations for a Linda system. Following [9] we consider the output action (τL) as a observable transitions. Notice that the above operational characterization of L employs the so-called ordered se- mantics of the output operation. Namely, when a sequence of outputs is executed, the tuples are rendered in the same order as they are emitted. It is also worth noting that also the store can be seen as a process which is the parallel composition of a number of tuples.
The Reo calculus
We also propose a process algebra R based on the communication primitives of Reo. We consider the basic actions to insert an item in a connector (write), to remove an item from the connector (take) and to capture an item without removing it (read). Agents in R are constructed by means of the prefix operator, the nondeterministic choice and the parallel composition. Formally, the syntax of R is defined as follows:
P ::= 0R | A.P | P + P | P  P | recX.P
A ::= wr (c, v ) | tk (c, v ) | rd (c, v )
where 0R denotes the empty process and c denotes an input or output end of a connector. The prefixes wr, tk and rd are shorthand for the basic operations write, take and read respectively. As in Reo communication is possibly only in presence of a connector, in order to define the operational semantics of R we must consider the semantics of the connector on which actions are acting on.
Following the notion of ABT, we consider a connector C defined as a tuple C= (I1, I2, ..., Ik; O1, O2, ..., Oh; Σ; '−→C)
where Ii, Oj represents input and output ends respectively, Σ is the set of possible states of the connector, and '−→C is a set of transition rules giving its behavior.

The transitions are of the form:

⟨C, act


act1
⟩ '−→C
⟨C', act2⟩

where C represents the connector C in a state σ and C' represent it in a state σ', –σ, σ' ∈ Σ–, act denotes the set of actions which applied in parallel over the ends of C in a state σ may produce a progress on the connector, producing eventually a state change. The set act1 denotes the actions actually applied, and act2 represents pending actions. These multisets must respond to the relation act = act1  act2. A connector progresses when at least one successful input or output operation is performed on one of its ends.
An example of a simple connector in Reo is given below. It has one input end I1 and one output end O1, and presents the same behavior as a channel of type bag [2], though it may be in two different states: σ when the buffer is empty, and σ' when the buffer contains data items. We will denote this connector by LR = (I1; O1; {σ, σ'}; '−→LR), and consider the following transitions:

(1)
⟨LR, {wr(I , d)
{wr(I1,d)} ⟨LR', ∅⟩

1	}⟩ '−→LR

(2)
⟨LR', {wr(I , d)
{wr(I1,d)} ⟨LR', ∅⟩


(3)
1	}⟩
⟨LR', {tk(O , d)
'−→LR
{tk(O1,d)} ⟨LR', ∅⟩

1	}⟩ '−→LR

(4)
⟨LR', {tk(O , d)
{tk(O1,d)}
⟨LR, ∅⟩

1	}⟩ '−→LR

(5)
⟨LR', {rd(O , d)
{rd(O1,d)} ⟨LR', ∅⟩

1	}⟩ '−→LR
The transition system presented in Table 2 describes the computational model of R. Rule (2)R describe the behavior of the choice operator. In rule (3)R the operational meaning of the parallel operator is defined in the standard way. The synchronization between two agents intending to perform complementary actions is modelled by rule (4)R. The observable progression of agents will be made following rules (5)R and (6)R, where the corresponding connector (on which actions are being
act
applied) can proceed by consuming some of the pending actions. Transition >C

represents any derivation act1


act2
...


'−ac→tn
, such that act = 
act . As in L,

there are no rules for recursion, its semantics is defined by the structural axiom
recX.P ≡ P [recX.P/X] which applies an unfolding step to a recursively defined process. Finally, we consider the transition system closed under the structural axioms for parallel and choice operators.

Comparing Linda and Reo
In this section, we will compare the languages previously defined, L and R, taking into account that we will get different versions of R depending on the connector to be considered. To do this, we first formalize the notion of modular embedding used for the comparison. Then, we analyze the expressiveness of both languages L and R, in both directions, by defining compilers for each case, and proving the existence of modular embedding between L and R.



Table 2 Transition system for R

Comparison method: modular embedding
To compare the expressive power of two languages we use the notion of modular embedding propose by De Boer and Palamidessi in [5], which is an extension of the basic idea of embedding considered by Shapiro in [12], suited for a concurrent framework. Now we summarize the method.
Consider two languages L and L', and assume the semantics mappings (observa- bles) O : L → ObsL and O' : L' → ObsL' , where ObsL and ObsL' are some domains. Then we say that L is more expressive than L' (or L' can be embedded into L), if exists a mapping C (compiler) from the statements of L' to the statements of L (C : L' → L) and a mapping D (decoder) from ObsL to ObsL' such that for every statement A in L, D(O(C(A))) = O'(A)’, i.e. the following diagram commutes:
'	O'	 
L	Obs,L,'


C	D

J	O	 O bsL
For the embedding to be modular the coder C and the decoder D must satisfy the following three properties:
D should be defined in an element-wise way with respect to ObsL , that is
∀X ∈ ObsL : D(X)= {Del(x)|x ∈ X}

for some convenient mapping Del.
the compiler C should be defined in a compositional way with respect to every n-ary operator op in the language R :
C(op(A1,... , An)) = o˜p(C(A1),... , C(An))
the embedding must preserve the behavior of the original processes with respect to failure and success, this is:
∀X ∈ ObsL, ∀x ∈ X : tm'(Del(x)) = tm(x)
where tm and tm' give information about the termination mode of the ob- servables of L and L', respectively.
Asynchronous case
In this particular case, we use the notion of modular embedding described in the previous section to study the embedding between L and R. We will consider a very simple notion of observability for both languages, encoding successful and failure computations. That is, ObsL = ObsR = ℘({ss , ff }).
Definition 3.1 Observables in L are given by the mapping OL : L→ ObsL which is defined as follows: (1) ss ∈ OL(P ) if P is a L-process presenting a successful trace (i.e. P →∗ 0, or there exist n tuples, t1,... , tn such that P →∗< t1 >  ..  < tn >), and (2) ff ∈ OL(P ) if P presents a failure trace (i.e. there exits a non-empty process Q, which is not a parallel composition of tuples, such that P →∗ Q /→.
Similarly, the notion of observables is defined for R.
Definition 3.2 Given a connector C, observables in R are given by the mapping OR : R → ObsR which is defined as follows: (1) ss ∈ OR(P ) if P is a R-process presenting a successful trace (i.e. ⟨P, C⟩ →∗ ⟨0R, C'⟩, and (2) ff ∈ OR(P ) if P presents a failure trace (i.e. there exists a non-empty R-process Q such that
⟨P, C⟩ →∗ ⟨Q, C'⟩ /→).
In this section we work over the asynchronous case. We compare the expressive power of L and R in presence of the connector LR introduced in section 2.2. As the connector LR has only one input end (I1) and one output end (O1), to sim- plify the presentation of the compiler we will omit them when R-actions are used. Thus, input actions like tk(t, O1) and rd(t, O1) will be denoted by tk(t) and rd(t), respectively, and the output action wr(t, I1) will be denoted by wr(t).
Definition 3.3 We define the compiler C : L −→R by: C(in(t).P ) =def tk(t).C(P )
C(out(t).P ) =def wr(t).C(P )
C(rd(t).P ) =def rd(t).C(P )
C(P1 +L P2) =def C(P1) +R C(P2)

C(P1 L P2) =def C(P1) R C(P2) C(0L) =def C(0R)
As we mentioned previously the buffer of the bag type in Reo is a multiset as the store in Linda. Each time a tuple is present in the store, ie. St = ⟨t⟩, also a data item t is present in the buffer of the connector LR, and if the store is empty, ie. St = ⟨⟩, there is no data item in the connector. In both cases we can consider that the connector LR is in a state equivalent to the store, and we indicate this by the expression LRst.

Proposition 3.4 Given two processes P, P ' ∈ L, if P L St  α
P '  L St' (α /= t)

then ⟨C(P ), LR
αR
St⟩ −→ ⟨C
(P '), LR
St' ⟩, where






Proof. See appendix 5.1.
⎧ τ	if α = τ αR =	tk(t) if α = t
⎪⎪⎩ rd(t) if α = t

The previous result shows the relation among the transition systems of both calculi. Now considering this relation, we can establish the following corollary.
τR
Corollary 3.5 If P  and P	are two processes in R such that ⟨P, LRSt⟩ −→
⟨P ', LRSt' ⟩, and there exists Q,Q' in L verifying C(Q)= P, C(Q')= P ', then


τL
Q	St −→
Q'	St'

Proof. We proof this corollary reasoning as in the proof of the proposition 3.4, by applying structural induction over the transition system of R.
Considering the definition of the compiler C, the observability notion, and the decoder D that we defined as the identity, we can prove the following theorem.
Theorem 3.6 The compiler C is a modular embedding.
Proof. See appendix 5.1.
Notice that we can define a modular embedding in the opposite direction, con- sidering the same connector. Both compilers allows to claim that considered models based on Linda and Reo are equally expressive when considering the asynchronous case and the connector LR.
Synchronous case
In order to compare Reo and Linda for the synchronous case, we introduce the connector RLS = (I1; O1; {σ}; '−→RLS). Because of its nature this connector may be only in one state, so RLS = RLS'. Its behavior is given by the following transitions:

(6)
⟨RLS, {wr(I1, d), tk(O1, d)}⟩
{wr(I1,d),tk(O1,d)}
'−→RLS	⟨RLS, ∅⟩



(7)
⟨RLS, {wr(I1, d), rd(O1, d)}⟩
{rd(O1,d)}
'−→RLS ⟨RLS, {wr(I1, d)}⟩

In this case we restringe the comparison to a subset of R, considering only the communication primitives wr and tk. We will consider the same notion of observable defined in previous section. To simulate the operations in Reo as operations in Linda, we need to represent the synchronous behavior of Reo in presence of the connector RLS. To do this we propose that processes communicate the actions they can offer and then each process accept one of the actions in the store in case it can on his side perform the complementary action. The compilation of parallel and alternative operators in R is given in terms of the parallel operator in L. In order to get compositionality, we associate to each agent an identifier u which ranges in an arbitrary countable set Id of process identifiers. Again we are in presence of a very simple connector with only one input end and one output end. Thus, we will proceed as in Definition 3.3, missing the name of channels.
Definition 3.7 We define the compiler C from R into L as:
Cu(P1  R P2) =def Cu1(P1) L Cu2(P2) Cu(P1 +R P2) =def Cu(P1) L Cu(P2)
Cu(tk(t).P ) =def out(tk, t, u).(rd(wr, t, v).out(u, v).
(in(v, u).in(wr, t, v).out(u).Cu1 (P )+ rd(v).in(u, v).0)
+rd(u).0)
Cu(wr(t).P ) =def out(wr, t, u).(rd(tk, t, v).out(u, v).
(in(v, u).in(tk, t, v).out(u).Cu1(P )+ rd(v).in(u, v).0)
+rd(u).0)
Cu(0R) =def Cu(0L)
In this context, we consider that the parallel composition of two processes in Reo is translated into the parallel composition of two independent processes in Linda, that are identified by different labels. On the other hand, in the case of the nondeterministic choice, the application of the compiler must preserve the identifier of the original process to avoid the synchronization between two branches of the same process. Now we show some useful results to prove the modularity of the embedding.

{wr(t)}
Lemma 3.8 Let P, Q be processes in R, if ⟨P, RLS⟩	−→ R
⟨P ', RLS⟩ and

⟨Q, RLS
{tk(t)}
⟨Q', RLS⟩ then ∀u ∈ Id ,v ∈ Id , ∃u' ∈ (Id − Id∗), v' ∈

⟩	−→ R
1	2	1	1

(Id2 − Id∗) such that
Cu(P ) L Cv(Q) →∗ Cu' (P ') L Cv' (Q') L ⟨ui⟩ L ⟨vj⟩ L St'
where Id∗ and Id∗ represents the subsets of identifiers of processes derived from u
1	2
and v respectively, Id1 ∪ Id2 = Id, Id1 ∩ Id2 = ∅, ui ∈ Id∗ and vj ∈ Id∗
1	2

Proof. See appendix 5.2.
{wr(t),tk(t)}
Lemma 3.9 Let P be a process in R, if ⟨P, RLS⟩	−→	R


⟨P ', RLS⟩ then

∀u ∈ Id, ∃u' ∈ Id∗ such that

Cu(P ) →∗ Cu' (P ') L St'

Proof. The proof is by induction over the complexity of processes in R. See ap- pendix 5.2.
Proposition 3.10 Given two processes P, P ' in R and the connector RLS, if
⟨P, RLS⟩ −→R ⟨P ', RLS'⟩ then C(P ) →∗ C(P ')  St'


Proof. We will analyze rule 5R. See appendix 5.2.
Corollary 3.11 If P and P ' are two processes in L such that P	St τL

P '	St',

and ∃ Q and Q' in R that veriﬁes C(Q)= P, C(Q')= P ' then
⟨Q, RLSSt⟩ −→ ⟨Q', RLSSt' ⟩
Considering the definition of the compiler C, the sets of observables and the decoder D that we defined as the identity, we can prove the following theorem.
Theorem 3.12 The compiler C is a modular embedding
Proof. See appendix 5.2.
Conclusions
In this paper, we have presented some preliminary results on the comparison of the expressive power of Linda and Reo. To do this, firstly we defined a common formalism to work at the same level of abstraction, and then we study the asyn- chronous and synchronous cases using specific connectors of Reo, showing that both languages are equivalent for these connectors. Thus, the complexity embedded in the compiler of the synchronous case suggests that Reo is more expressive than Linda in presence of connectors imposing special communication patterns, because of the possible merging of synchronous and asynchronous behaviors. Thus, we can find some connectors for which Reo is strictly more expressive than Linda.
Our future work will be devoted to make a more detailed study of the expressive power of Reo, providing an exhaustive analysis of more complex connectors and different variations of Linda-like languages, and also considering more sophisticated notions of observables, like finite sequences of actions corresponding to successful terminating computations or finite sequences that represent failure situations.

References
F. Arbab.	The IWIM model for coordination of concurrent activities.	In First International Conference on Coordination Models, Languajes and Applications (Coordination’96),1061 Lecture Notes

in Computer Science, pages 34–56, 1996.
F. Arbab. A Channel-based Coordination Model for Component Composition. Electronic Notes in Theorethical Computer Science, 68(3), 2003.
F. Arbab. Abstract behavior types: a foundation model for components and their composition. CWI Report SEN- R0305 ISSN 1386-3711 , 2003.
F. Arbab and J.J.M.M. Rutten. A coinductive calculus of component connectors. CWI Report SEN- R0216 ISSN 1386-369X , 2002.
F.S. de Boer and C. Palamidesi. Embedding as a tool for language comparision. In Information and Computation, 108(1):128-157, 1991.
A. Brogi, N. Busi, M. Gabbrielli and G. Zavattaro Comparative analysis of the expressiveness of shared dataspace coordination. Electronic Notes in Theorethical Computer Science, 62,2001.
A. Brogi and J. M. Jacquet. On the Expressiveness of Linda-like Concurrent Languages. Electronic Notes in Theoretical Computer Science, 16, 1998.
A. Brogi, E. Pimentel, and A. Rold´an. Compatibility of Linda-based Component Interfaces. Electronic Notes in Theoretical Computer Science, 66(4), 2002.
N. Busi, R. Gorrieri, and G. Zavattaro. Comparing three semantics for Linda-like languages. Theoretical Computer Science, 240(1): 49-90, 2000.
N. Carriero and D. Gelernter. Linda in Context. Communications of the ACM, 32(4):444-458, 1989.
D. Gelernter. Generative Communication in Linda. ACM Transactions on Programming Languages and Systems, 7:1 (1985), pp.80-112.
E.Y. Shapiro.	Embedding among Concurrent Programming Languages.	In Proceedings of CONCUR’92, pages 486-503, Springer Verlag, 1992.

Appendix
In this Appendix we show the proofs of the results presented in the paper.


Asynchronous case
Proposition 3.4 Given two processes P, P ' ∈ L, if P L St  α

P '  L St' (α /= t)

then ⟨C(P ), LR
αR
St⟩ −→ ⟨C
(P '), LR
St' ⟩, where

⎧ τ	if α = τ αR =	tk(t) if α = t
⎪⎪⎩ rd(t) if α = t
Proof. The proof is by structural induction. First we analyze the base cases that are identified with the single rules of the transitions system of L:
Base Cases

Consider the rule (1)L. Let P1 
τ
−→	1
 St', with P1
= out(t).P and

St = ∅. So, we have that out(t).P −τ→ ⟨t⟩ P , where P = P ' and St' = ⟨t⟩.
τ	1
We want to show that ⟨wr(t).C(P ), LR∅⟩ −→ ⟨C(P ), LR⟨t⟩⟩. By defini-
wr(t)
tion of the compiler C and the rule (1)R, we infer ⟨wr(t).C(P ), LR∅⟩ −→
⟨C(P ), LR∅⟩, and considering the rule (1) of the connector LR and the rule (5)R, we obtain

⟨wr(t).C(P ), LR ⟩ −τ→ ⟨C(P ), LR
⟨t⟩⟩.

Let P1
St −→t	'	St with P	= in(t).P , and St = ∅ = St', so,
1
t

in(t).P −→ P and LRSt = LRSt' . Now by definition of C and the rule
tk(t)
(1)R, we obtain ⟨tk(t).C(P ), LR∅⟩ −→ ⟨C(P ), LR∅⟩.
t	t
Consider P1	St −→	'	St', being P1 = rd(t).P . Then, rd(t).P	P
and St = ∅ = St' and LRSt = LRSt' . Finally, following with a similar rea-
rd(t)
soning to the previous case, we obtain ⟨rd(t).C(P ), LR∅⟩ −→ ⟨C(P ), LR∅⟩.
Now, we analyze the rest of the rules that describe the transition system in
L. The inductive hypothesis supposes that the proposition is true for every antecedent of the considered rules.
Analyze the rule (5)L. Then, (P +L Q)  St α P '  St'. We want to prove

that ⟨C(P +L
Q), LR
St⟩
α
−→ ⟨C
(P '), LR
St' ⟩. Considering the inductive

hypothesis we have ⟨C(P ), LR
α
St⟩ −→ ⟨C
(P '), LR
St' ⟩.

If α = τ then αR = τ , and this mean that ∃act /= ∅ such that

⟨C(P ), LRSt⟩
−a→ct
⟨C(P '), LRSt⟩, and ⟨LRSt, act⟩
'−→act
⟨LRSt' , ∅⟩. So

applying rule (2)R, the previous one over the connector and rule (5)R we

obtain that ⟨C(P +R Q), LRSt
α
⟩ −→ ⟨C
(P ' +R Q), LR
St' ⟩.

If α /= τ then St = St', so by applying rule (2)R and the compiler

definition we obtain ⟨C(P +R
Q), LR
αR
St⟩ −→ ⟨C
(P ' +R
, LR
St' ⟩.

Consider the rule (6)L. Then (P  Q)  St −τ→ (P '  Q')  St' and

we want to prove ⟨C(P  Q), LRSt⟩
τ
−→ ⟨C
(P '	Q'), LR
St' ⟩.  Suppose

St = Stp  Stq and the rule (6)L we have: P  Stp
−→t
P '	St'
and


Q  Stq −→t  Q'  St' , where St' = Stp, Q = Q' and Stq = St'  ⟨t⟩.
q	p	q

By inductive hypothesis ⟨C(P ), LR
Stp ⟩
tk(t)
−→ ⟨C
(P '), LR
Stp
⟩. Thus, by

applying rule (3)R
we can affirm that ⟨C(P )	C(Q), LR
tk(t)
St⟩ −→ ⟨C
(P ')

C(Q), LRSt⟩. On the other hand the connector LR is in a state equivalent

to Stp  St'
⟨t⟩, so it is possible to apply transition (3) or (4) of LR

and then, using the rule (5)R
we obtain ⟨C(P )	C(Q), LR
tk(t)
St⟩ −→ ⟨C
(P ')

C(Q), LRSt' ⟩. Finally, by definition of the compiler and the fact that Q =
Q', results that ⟨C(P	Q), LRSt⟩ −τ→ ⟨C(P '	Q'), LR ' ⟩.
St
Suppose the rule (7)L, then (P  Q)  St	τ	(P '  Q)  St'. As in the

previous case, we consider St = Stp  Stq and so, P  Stp −→t
P '	St' y


Q  Stq −→t	Q'  St' , where St' = Stp, Q = Q' and St' = Stq'  ⟨t⟩. By
q	p	q

inductive hypothesis we have ⟨C(P ), LR
tk(t)
Stp ⟩ −→ ⟨C
(P '), LR
Stp
⟩, and the

connector LR is in a state in which transition 3 can be applied. Following
the same reasoning, considering rules (3)R, (5) of LR and (5)R and the

definition of C we obtain ⟨C(P  Q), LRSt
τ
⟩ −→ ⟨C
(P '	Q), LR
St' ⟩.

Finally we analyze the rule (8)L. If (P  Q) L St −α→ (P '  Q)  St' and

α /= t, we want to prove that ⟨C(P	Q), LR
α
St⟩ −→ ⟨C
(P '	Q), LR
St' ⟩.

We prove this reasoning as in cases (b) and (c), and by the application of

the rule (3)R. If α = t, we reason as in case (a).
Theorem 3.6 The compiler C is a modular embedding.
Proof. The properties (1) y (3) of 3.1 are satisfied directly, considering the no- tion of observables and that D is the identity . (2) is evident observing that the compiler preserves the operators. In order to prove (4), we need to verify that O(C(A))) = O'(A). We will proceed proving the double inclusion considering the possible elements in the sets of observables: ss y ff.
O'(A) ⊆ O(C(A))
If ss ∈ O'(A), then A →∗ 0L. In this case, we have a sequence similar to
A →L A1 →L A2 →L ....An →L 0L, where Ai = Bi  Sti. We want to
prove ss ∈ O(C(A)), i.e. ⟨C(A), LR⟩ →∗ ⟨0R, LRn+1⟩. In this case, we have
the sequence ⟨C(A), LR⟩ →R ⟨C(B1), LR1⟩ →R ⟨C(B2), LR2⟩ →R	→R
⟨0R, LRn+1⟩. We only need to prove that for each transition Aj →L Ak in L there is one transition ⟨C(Bj), LRj⟩ →R ⟨C(Bk), LRk⟩ in R. Immediate by proposition 3.4.

If ff  ∈ O'(A) then ∃Q /= 0 .	A  →∗
Q /'−→, .	We assume

Q = Q'  St.	In this situation, we want to obtain ⟨C(A), LR∅⟩ →∗
⟨C(Q'), LR'⟩ /→R. We prove it by reduction to the absurd. We suppose that ∃S . ⟨C(Q'), LR'⟩ →R ⟨S, LR''⟩, then there are a set of actions act



which respond to ⟨C(Q'), LR'⟩ −a→ct


⟨S, LR'⟩ and ⟨LR', act⟩ '−→act
⟨LR'', ∅⟩.

By corollary 3.5 ∃P in L, P = P '  St . C(P ')= S y Q →L P . Contra-
diction. So, ⟨C(Q'), LR'⟩ /→R and ff ∈ O(C(A)) By (i) and (ii), we obtain O'(A) ⊆ O(C(A)))
O(C(A)) ⊆ O'(A)

If ss ∈ O(C(A)), then ⟨C(A), LR∅⟩ →∗
⟨0R, LRn+1⟩.This indicates a se-

quence similar to ⟨C(A), LR⟩ →R ⟨B1, LR1⟩ →R ⟨B2, LR2⟩ →R	→R

⟨0R, LRn⟩. We want to prove ss ∈ O'(A), i.e., A →∗
0L. In this case,

we have a sequence like A →L A1 →L A2 →L ...An →L 0L, where Ai = Di  Sti and Bi = C(Di). We prove it following the same reasoning that we consider in a.)i.), by the application of the corollary 3.5.
If ff ∈ O(C(A)), then ∃S /= 0 . ⟨C(A), LR∅⟩ →∗ ⟨S, LR'⟩ /→R. We want

to verify ff ∈ O'(A), i.e., ∃Q /= 0 . A →∗
Q /'−→. We prove it following

the same reasoning that we considered in a.)ii.), by the application of the proposition 3.4.
By (i) and (ii), we obtain O(C(A)) ⊆ O'(A).



Synchronous case
{wr(t)}
Lemma 3.8 Let P, Q be processes in R, if ⟨P, RLS⟩	−→ R


⟨P ', RLS⟩ and

⟨Q, RLS
{tk(t)}
⟨Q', RLS⟩ then ∀u ∈ Id ,v ∈ Id , ∃u' ∈ (Id − Id∗), v' ∈

⟩	−→ R
1	2	1	1

(Id2 − Id∗) such that
Cu(P ) L Cv(Q) →∗ Cu' (P ') L Cv' (Q') L ⟨ui⟩ L ⟨vj⟩ L St'

where Id∗ and Id∗ represents the subsets of identifiers of processes derived from u
1	2
and v respectively, Id1 ∪ Id2 = Id, Id1 ∩ Id2 = ∅, ui ∈ Id∗ and vj ∈ Id∗
1	2
Proof. The proof is by induction over the complexity of processes in R.
Base case: Let P = wr(t).P ' and Q = tk(t).Q'. We will work over Cu(P ) L
Cv(Q).
Cu(P )	L Cv(Q) −→ 1L, 7L, 1L −→ (A L ⟨wr, t, u⟩ L ⟨u, v⟩)  L (B  L
⟨tk, t, v⟩ L ⟨v, u⟩) where
A = in(v, u).in(tk, t, v).out(u).Cu' (P ')+ rd(u)..in(u, v).0,
B = in(u, v).in(wr, t, u).out(v).Cv' (Q')+ rd(v).in(v, u).0.
Now, applying rule 6L and rule 1L results that Cu(P )  L Cv(Q) →∗
Cu' (P ') L Cv' (Q') L ⟨u⟩ L ⟨v⟩ L St'
Inductive hypothesis: the lemma is true for every pair of processes Pi, Qj in
R.
Let P = P1 R P2 and Q = tk(t).Q'.
If the rule applied is 3R and P1 is the process which proceed then

⟨P , RLS
{wr(t)}
⟨P ', RLS⟩ and P ' = P '	P .

1	⟩ −→ R	1
1  R	2

Applying the hypothesis over P1 and Q, Cu1 (P1) L Cv(Q) →∗ Cu' (P ') L
L	1	1
Cv' (Q')  L ⟨u1⟩ L ⟨v⟩ L St', and finally by rule 8L and the compiler
definition

Cu(P1  R P2)  L Cv(Q) →∗
Cu' (P '
R P2)  L Cv' (Q')  L St'. Then

Cu(P ) L Cv(Q) →∗ Cu' (P ') L Cv' (Q') L St'
Let P = P1 +R P2 and Q = tk(t).Q'
If the rule applied is 2R and P1 is the process which proceed then

⟨P , RLS
{wr(t)}
⟨P ', RLS⟩ and P ' = P '.

1	⟩ −→ R	1	1
On the other hand Cu(P ) L Cv(Q)= Cu(P1 + P2) L Cv(Q)= Cu(P1) L
Cu(P2) L Cv(Q).
Applying the hypothesis over P1 and Q, Cu(P1) L Cv(Q) →∗ Cu' (P ') L
L	1
Cv' (Q') L St', (St' = ⟨u⟩  ⟨v⟩),
and finally by rule 8L
Cu(P1)  L Cu(P2)  L Cv(Q) →∗ Cu' (P ')  L Cu(P2)  L Cv' (Q')  L St'.
By definition of the compiler Cu(P2) can only proceed choosing the branch
rd(u).0, then applying rule 7L we conclude that C(P ) L C(Q) →∗ C(P ') L
C(Q') L St'
Let P = P1 R P2 and Q = Q1 +R Q2.

By hypothesis ⟨P
P , RLS
{wr(t)}
P ', RLS⟩

1  R	2
⟩ −→ ⟨

and ⟨Q +
Q , RLS
{tk(t)}
Q', RLS⟩.

1	R	2
⟩ −→ ⟨

If rules applied are 3R and 2R, and the processes which proceed are P1
and Q2 then

{wr(t)}
⟨P , RLS⟩
⟨P ', RLS⟩, ⟨Q , RLS
{tk(t)}
⟨Q' , RLS⟩, and P ' =

1	−→	1	1	⟩  −→	1
'  R P2, Q' = Q' . So by inductive hypothesis Cu1 (P1) L Cv1 (Q1) →∗
Cu' (P ') L Cv' (Q' ) L ⟨u1⟩ L ⟨v1⟩ L St'.
1	1	1	1
Now by 8L and the compiler definition
Cu(P ) L Cv1 (Q1) L Cv1 (Q2) →∗ Cu' (P ') L Cv' (Q' ) L ⟨u1⟩  L ⟨v1⟩  L

St  L Cv1 (Q2).
L	1	1

But as Cv1 (Q2) can only proceed by the branch rd(v1).0, considering the
store and applying 7L results Cv1 (Q2) −→ 0. Therefore
Cu(P ) L Cv1 (Q) →∗ Cu' (P ') L Cv' (Q') L ⟨u1⟩ L ⟨v1⟩ L St  .
L	1
For the rest of the cases the proof is analogous to the previous ones.

{wr(t),tk(t)}
Lemma 3.9 Let P be a process in R, if ⟨P, RLS⟩	−→	R
⟨P ', RLS⟩ then

∀u ∈ Id, ∃u' ∈ Id∗ such that
Cu(P ) →∗ Cu' (P ') L St'

Proof. The proof is by induction over the complexity of processes in R.
Base case: P is a single process, so the hypothesis does not verify.
Inductive hypothesis: the lemma is true for every process Pi in R present in the expression of P .
Let P = P1 R P2.
If rule applied is 4R, then

⟨P1, RLS⟩
⟨P , RLS
{wr(t)}
−→ R
{tk(t)}
⟨P ', RLS⟩,
⟨P ', RLS⟩ and P ' = P '

P '.

2	⟩ −→ R	2
1  R	2

By applying lemma 3.8 we obtain
Cu1 (P1) L Cu2 (P2) →∗ Cu' (P ') L Cu' (P ') L ⟨u1⟩	L ⟨u2⟩ L St.
L	1	1	2	2
Therefore by definition of compiler Cu(P ) →∗ Cu' (P ')	L St', (St' =
⟨u1⟩ L ⟨u2⟩ L St).
If the rule applied is 3R and P1 is the process which proceed then

{wr(t),tk(t)}
⟨P , RLS⟩
⟨P ', RLS⟩ and P ' = P '
P .  By inductive

1	−→	R	1
1	R	2

hypothesis Cu1 (P1) →∗ Cu' (P ')  L St'. Applying rule 8L and compiler
L	1	1
definition results Cu(P ) →∗ Cu' (P ') L St'.

Let P = P  +
P , so ⟨P  +
{wr(t),tk(t)}
P , RLS⟩
⟨P ', RLS⟩.	Ap-

1	R	2
1	R	2
−→	R

plying rule 2R and reasoning as in the previous cases, we obtain that
Cu(P ) →∗ Cu' (P ') L St'.

Proposition 3.10 Given two processes P, P ' in R and the connector RLS, if
⟨P, RLS⟩ −→R ⟨P ', RLS⟩ then C(P ) →∗ C(P ')  St'.
Proof. We will analyze rule 5R.
Let P = P1 R P2, so we have ⟨P1 R P2, RLS⟩ →R ⟨P ', RLS⟩. By applying

rule 5R
we have that ⟨P1  R
P2, RLS


act
⟩ −→R


⟨P ', RLS⟩ and ⟨RLS, act⟩ act

⟨RLS, ∅⟩. By definition of RLS transitions, act must be {wr(t), tk(t)}
if we consider rule 4R, P ' = P '  R P ' and

⟨P1, RLS⟩
⟨P2, RLS⟩
{wr(t)}
−→ R
{tk(t)}
−→ R
⟨P ', RLS⟩,
⟨P ', RLS⟩.

Applying lemma 3.8 we obtain
Cu1 (P1)  L Cu2 (P2) →∗ Cu' (P ')  L Cu' (P ')  St'. Now by definition of
L	1	1	2	2
compiler C, results that
Cu(P1 R P2) →∗ Cu' (P '  R P ')  St', that is Cu(P ) →∗ Cu' (P ')  St'.
L	1	2	L
if we consider rule 3R, assuming P1 proceeds,

P ' = P '
{wr(t),tk(t)}
P and ⟨P , RLS⟩
⟨P ', RLS⟩. By lemma 3.9,

1 R	2	1
−→	R	1

Cu(P1) →∗  Cu' (P ') L St'.	Now applying rule 8L and the compiler
Cu(P1 R P2) →∗ Cu' (P '  R P2)  St'. Therefore Cu(P ) →∗ Cu' (P ')  St'
L	1	L
Let P  = P1 +R P2.	Reasoning as in previous cases, and applying rules
5R, 2R and lemma	3.9 we obtain Cu(P1) →∗ Cu' (P ')  St'. By rule 8L,
Cu(P1)  L Cu(P2) →∗ Cu' (P ')  L Cu(P2)  L St'. Now as Cu(P2) can only
proceed by branch rd(u)..0 and ⟨u⟩ ⊆ St', by rule 7L, and the compiler definition we obtain Cu(P ) →∗ Cu' (P ')  St'.

Theorem 3.12 The compiler C is a modular embedding.
Proof. The properties (1) y (3) of 3.1 are satisfied directly, considering the notion of observables and that D is the identity . (2) is evident noting that C(A  B)= 
In order to prove (4), we need to verify that O'(C(A))) = O(A). We will pro- ceed proving the double inclusion considering the possible elements in the sets of observables: ss and ff .
O(A) ⊆ O'(C(A))
If ss ∈ O(A), then ⟨A, RLS⟩ →∗  ⟨0R, RLS⟩. In this case, we have a
sequence similar to ⟨A, RLS⟩ →R ⟨A1, RLS⟩ →R ⟨A2, RLS⟩ →R	→R
⟨0R, RLS⟩. By applying previous properties we obtain the following se- quence of τ -transitions in L: C(A) → C(A1)  St1 → C(A2)  St2 →
....C(An−1)  Stn−1 → C(0)  Stn, where Sti−1 ⊆ Sti. Then C(A) →∗
0L  L Stn. Therefore ss ∈ O'(C(A)).
If ff ∈ O(A) then ∃Q /= 0R and a state of the connector RLS' such that
⟨A, RLS⟩ →∗ ⟨Q, RLS⟩ /→R. By applying previous properties we obtain
C(A) →∗ C(Q)  Stq. Now reasoning by reduction to the absurd, suppose
the existence of a process S, S = S'  Sts such that C(Q) L Stq →L S'  L Sts. But by applying corollary 3.11 exists a state of the connector RLSSts and a process P in R that verifies C(P )= S' and ⟨Q, RLS⟩ →R ⟨P, RLSSts ⟩. Contradiction. Therefore ff ∈ O'(C(A)).
By (i) and (ii), we obtain O(A) ⊆ O'(C(A))).
O'(C(A)) ⊆ O(A). The proof is analogous to the one given for case a.
