Electronic Notes in Theoretical Computer Science 117 (2005) 183–207 
www.elsevier.com/locate/entcs


Representing the MSR Cryptoprotocol Specification Language in an Extension of Rewriting Logic with Dependent Types
Iliano Cervesato1
ITT Industries, Inc., Advanced Engineering and Sciences Division Alexandria, VA 22303, USA
Mark-Oliver Stehr2
University of Illinois at Urbana-Champaign, Computer Science Department, Urbana, IL 61801, USA

Abstract
This paper presents a shallow and hence efficient embedding of the security protocol specification language MSR into rewriting logic with dependent types, an instance of the open calculus of constructions which integrates key concepts from equational logic, rewriting logic, and type theory. MSR is based on a form of first-order multiset rewriting extended with existential name generation and a flexible type infrastructure centered on dependent types with subsorting. This encoding is intended to serve as the basis for implementing an MSR specification and analysis environment using existing first-order rewriting engines such as Maude.
Keywords: MSR, protocol specification, open calculus of constructions, dependent types, Maude.


Introduction
MSR originated as a simple logic-oriented language aimed at investigating the decidability of protocol analysis under a variety of assumptions [8]. It evolved into a precise, powerful, flexible, and still relatively simple framework

1 Email: iliano@itd.nrl.navy.mil
2 Email: stehr@uiuc.edu


1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.023






   


This paper


 )	OCC


 )
. . . . . .
. . . .a.
[14]

. . . .
. . . .

.
Figure 1. Architecture of the Embedding of MSR into Rewriting Logic


for the specification of complex cryptographic protocols, possibly structured as a collection of coordinated subprotocols [3,5]. It uses strongly-typed multiset rewriting rules over first-order atomic formulas to express protocol actions and relies on a form of existential quantification to symbolically model the generation of nonces and other fresh data. Dependent types are a useful abstraction mechanism not available in other languages. For instance, the dependency of public/private keys on their owner can be naturally expressed at the type level. Finally, MSR supports an array of useful static checks that include type-checking [4] and data access verification [6].
This work outlines an encoding of the core of MSR into rewriting logic (RWL), to be more precise into its extension with dependent types (RWLDT). Rewriting logic [11] draws on the observation that many paradigms can nat- urally be captured by conditional rewriting modulo an underlying equational theory, the theory of multisets being a particularly important case for the specification of concurrent systems and protocols. Recently a combination of equational logic and rewriting logic with dependent types has been studied in [14] under the name open calculus of constructions (OCC). In this paper we show that a restricted predicative instance of OCC, that we call rewriting logic with dependent types (RWLDT), can be used to represent typed MSR specifications in a way which preserves all type information. RWLDT does not natively support the expression of existential name generation: our en- coding implements it with counters. Moreover, ensuring the executability of the resulting code required some care.
Composing the mapping from MSR into RWLDT with a mapping from RWLDT into RWL, which has already been implemented as part of the OCC prototype [14], we obtain an encoding from MSR into RWL, which can serve as the basis of an execution environment for MSR in a RWL-based language such as Maude [9]. This two-level approach, which is summarized in Figure 1, has some advantages over a direct mapping into RWL. The first is modularity and separation of concerns: the mapping from MSR into RWLDT is only


concerned with the dynamics (given by the rules) but preserves the static part (given by declarations, types, and terms). The second advantage is that RWLDT seems to be the right level for user interaction, because terms and types closely correspond to those of MSR. Finally, the preservation of types and the fact that RWLDT is a sub-logic of OCC provides suitable level of abstraction for formal reasoning, a possibility that is not the subject of this paper, but that we hope to explore in the future.
This work serves as the basis for a forthcoming prototype of MSR, which will eventually run on top of Maude [9]. The linguistic affinity between MSR and RWLDT allow for a much simpler construction than a direct implemen- tation. Mapping MSR into the popular CAPSL Intermediate Language [10] would have been more difficult, because MSR has a much richer typing infras- tructure than CIL.
The remainder of this paper is organized as follows: We introduce MSR and RWLDT in Sections 3 and 4, respectively. In Section 5 we define the mapping from MSR into RWLDT, state its key properties, and outline some simple optimizations. It is applied to our running example, the Otway-Rees protocol, in Section 6. We conclude this paper with a discussion of limitations, implementation aspects, and possible extensions of our approach. First, some notation.

Notation
We use [] to denote the empty list and a comma to denote list concatenation. We write identifiers ranging over lists in bold, and indicate their length with a superscript. Therefore, Xn denotes a list of n elements. We will generally omit the length information when irrelevant or easily deducible from the context.
Occasionally, we write |X| for the length of a list X. We write Xi (or Xn) for the i-th element of X. We abbreviate constructions over all elements in a list as constructions over the list itself: for example, we may write (M Nn) for (M N 1 ... Nn), and ∀Xn : Un for ∀X1 : U 1 ... ∀Xn : Un.

The MSR Cryptoprotocol Specification Language
The syntax of instances of MSR tailored to specific security protocols has been presented in [4,5]. Here, we will instead concentrate on a more abstract syntax, currently undergoing formalization in [7], which allows the user to declare operators such as message concatenation and encryption rather than having them hard-coded in the language. The core of the syntax of MSR is given in the following table:



MSR is based on first-order terms, that for simplicity we limit to identifiers
(X) and application. Here, X can be either a bound variable or a previously declared identifier. For conciseness, we describe atomic types (i.e., objects of kind type) as if they were terms. Reserved atomic types include the type of states (state), principals (princ) and messages (msg). We write {X : T }T ' for
a dependent type, simplifying this syntax into T → T ' when X does not occur
free in T '. A context (called signature in [4,5]), is a list of declarations of term
constants and type families. A state is a comma-separated multiset of terms (of type state). We later use the comma for message concatenation as well, an overloading that is disambiguated by the surrounding context. A rule relates two states S and S'. The latter can be prefixed by a sequence of existential declarations (e.g., for creating nonces), while other variables in the rule will often be universally quantified at its head. Roles are nonempty sequences of rules prefixed by zero or more existential predicate declarations. We assume that MSR specifications satisfy a restricted format, where the existential pred- icates are used to introduce local intermediate states for sequentializing the rules inside a role. A role has a distinguished owner P , which can be either an arbitrary principal in generic roles, or a fixed principal (e.g., a server) for anchored roles, that are introduced by the keyword FOR (which is not a binder).
MSR’s actual syntax, as described in [4,5,7] has other constructions, that we either ignore for simplicity or leave out for future work. In particular, we assume that MSR’s native subtyping is emulated by explicit coercions, that MSR’s module structure has been expanded into a single sequence of declarations, and that all typing information is explicit, while MSR allows pointwise reconstruction. Simple preprocessing or standard techniques suffice to account for these discrepancies. In this paper, we do not treat other features of MSR, in particular guarded rules, equations, and a syntactic check known as data access specification. They will be the subject of future work.


We will rely on the Otway-Rees authentication protocol [12] to illustrate the use of MSR. In this protocol, an initiator, A, wants to obtain a short-term secret key kAB to communicate securely with a responder B. They rely on a server S, with whom both share long-term secret keys kAS and kBS respectively, to generate this new key. The “usual notation” for this protocol is as follows:
A → B : n, A, B, {nA, n, A, B}kAS
B → S : n, A, B, {nA, n, A, B}kAS , {nB, n, A, B}kBS
S → B : n, {nA, kAB}kAS , {nB, kAB}kBS
B → A : n, {nA, kAB}kAS
Here, A and B range over arbitrary principals, S is a fixed principal, the key server. Moreover, n, nA and nB are nonces, freshly generated values aimed at avoiding the replay of old messages.
As mentioned earlier, we assume appropriate declarations of types other than princ, state and msg and their elements. For this example, we rely on the type nonce, type families ltK and stK (for long- and short-term keys, respectively), and concatenation (overloaded as the infix “,”) and encryption (written { } ) as additional message constructor. We use the state predicate
N for representing messages in transit on the network. The superscripts p,
n and k represent coercions from principals, nonces and short-term keys to messages, respectively and l denotes the coercion from long-term keys to the shared keys expected by the encryption function (full MSR uses subsorting instead). The complete MSR specification can be found in [4]. Here we show only the generic role for the responder (B):

ROLE 2: ∀B : princ .
∃L : {B : princ}princ → nonce → nonce → (ltK B S) → state .
⎛ ∀A : princ . ∀n : nonce . ∀kBS : (ltK B S) . ∀X : msg .	⎞
⎜ N (nn, Ap, Bp,X) −→ ∃nB : nonce .	⎟

RULE 21 : ⎜
n	p	p
n	n	p	p	⎟

(L B A n nB kBS)
⎛ ∀A : princ . ∀n, nA : nonce . ∀Y : msg .	⎞
RULE 22 : ⎜⎝ ∀kBS : (ltK B S) . ∀kAB : (stK A B) .	⎟⎠
B	AB	BS

This role is generic and has two rules which are both in the scope of the quantifiers for B and L. In contrast, the role for S would be an anchored role, since S is a fixed principal.


The operational semantics of MSR [4,5] uses transition judgments that transform conﬁgurations of the form [S]R. Here S is an MSR state, R is an active roles set which collects the active roles, i.e., instantiated and pos- sibly partially executed roles, available at the next step, and Σ is an MSR dynamic context (called signature in [4,5]), which accounts for all the dynam- ically generated fresh constants available to R in state S. Using a slightly richer syntax than [4,5] we write an active role in the form ACTROLE i : FOR A : princ . WITH N : T . ρ (again FOR and WITH are no binders), meaning that it is the instance of either a generic role ROLE i : 6P : princ . EL : T . ρ with
P instantiated by A and L instantiated by N , or the instance of an anchored
role ROLE i : FOR A : princ . EL : T . ρ with L instantiated by N .
In this paper we initially rely on two judgment forms to describe transi-

tions: Given declarations Ð and roles У, the judgment Ð, У ▶ [S]R —→
A,N
i

[S]R' denotes the full instantiation, i.e., instantiation of all outer universal and existential quantifiers, of the role i (A and N define the particular instanti-

ation). We write Ð, У ▶ [S]R —→
A,N
i,j
[S']R' to denote a transition resulting

in the application of a rule j from the active role i (the instance with A and
N ), followed by the removal of the active i if it has been fully executed. If
one of these transitions can be derived we simply write Ð, У ▶ [S]R —→I,E
' R'	Σ
[S ]Σ' . The rules for a marginally more abstract version of this semantics can
be found in [4,5].

Rewriting Logic with Dependent Types
The open calculus of constructions (OCC), from which we derive the rewrit- ing logic with dependent types (RWLDT) by instantiation and restriction, is a family of type theories that are concerned with three classes of terms: ele- ments, types and universes. Types serve as an abstraction for collections of elements, and universes as an abstraction for collections of types.
OCC is parameterized by OCC signatures defining the universe structure. In this paper we use a fixed signature Σ = (£, Type, :, Y, ≤) with predicative universes £ = {Type, Type1, Type2,... }, which form a cumulative predicative hierarchy. This means that we have Type : Type1 : Type2 ... , a subtyping rela-
'
tion Type ≤ Type1 ≤ Type2 ... (also called subuniverse relation), and (s, s ,s H
s') ∈ Y for all s, s' ∈ £, where H denotes the least upper bound w.r.t. ≤. 3
The formal system of OCC is designed to make sense under the propositions- as-types interpretation, where propositions are interpreted as types and proofs

3 The effect of this choice of Y, a standard parameter for pure type systems [1], is that for arbitrary types S : s (in a context Γ) and T : s′ (in a context Γ,X : S) with s, s′ ∈ £ we can form the dependent type {X : S}T : s′′ (in Γ) for s′′ = s H s′.


are interpreted as elements of these types. Since in OCC there is no a pri- ori distinction between terms and types, and furthermore between types and propositions, we use all these notions synonymously.
OCC has the standard constructs known from pure type systems (cf. [1,14,15]) and a few additional ones. An OCC term can be one of the follow- ing: a universe s, a variable X, a typed λ-abstraction [X : S]M, a dependent
function type {X : S}T ,a type assertion M : T , an ϵ-construct ϵ A to denote an irrelevant proof of a proposition A, a propositional equality M = N , or one of three flavors of operational propositions, written as || A, !! A, or ?? A. Here and in following we usually use M, N , P , Q, S, T , U , V , A, and B to range over OCC terms, and X, Y , Z to range over names. Operational propositions can either be structural propositions designated by ||, computa- tional propositions designated by !!, or an assertional propositions designated by ??. Subsequently, we use τ to range over these three flavors {||, !!, ??}.
OCC contexts are lists of declarations of the form X : S. The empty
context is written as []. Typically, we use Γ to range over OCC contexts.
An OCC speciﬁcation is simply an OCC context Γ in this paper. Such a specification can introduce rewrite predicates by declarations of the form R : {Y : S}{Y ' : S} T → Type. The idea is that each rewrite predicate can be regarded as a labeled transition system, which can be executed in a
very similar way as rewriting logic specifications. Note that R : {Y : S}{Y ' : S} T → Type is the declaration of a ternary predicate R where S is the type of states and T is the type of actions, which could range from atomic labels to rewrite proofs, depending on the requirements of the application. In the case where the type T does not depend on Y and Y ', this declaration takes the form R : S → S → T → Type.
Since we are working with a predicative instance of OCC, it is entirely
straightforward to define a model-theoretic semantics based on classical set theory with suitable universes [14]. The appropriate level of abstraction for this paper is, however, the operational semantics, which is given by the formal system of OCC. It is a direct generalization of the operational semantics of rewriting logic [11] and its membership-equational sublogic [2] as implemented in Maude [9].
The formal system of OCC defines derivability of OCC judgments Γ ▶ J and has been shown to be sound w.r.t. the set-theoretic semantics [14]. For brevity we only give an informal explanation of all judgments and their intuitive operational meaning.
The type inference judgment Γ ▶ M →: S asserts that the term M is an element of the inferred type S in the context Γ. Operationally, Γ and M are given and S is obtained by syntax-directed type inference and possible


reduction using computational equations modulo the structural equations of Γ.
The typing judgment Γ ▶ M : S asserts that M is an element of type S in the context Γ. Operationally, Γ, M and S are given and verifying Γ ▶ M : S amounts to type checking. Type checking is always reduced to type inference and the verification of an assertional subtyping judgment.
The structural equality judgment Γ ▶ || (M = N ) is used to express that M and N are considered to be structurally equal elements in the context Γ. Operationally, structural equality is realized by a suitable term represen-
tation so that structurally equal terms cannot be distinguished when they participate in computations.
The computational equality judgment Γ ▶ !! (M = N ) is the judgment that defines the notion of reduction for the simplification of terms. The judgment states that the element M can be reduced to the element N in the context
Γ. Operationally, Γ and M are given and N is the result of reducing M using the computational equations in Γ modulo the structural equations in Γ.
The assertional judgment Γ ▶ ?? A states that A is provable by means of the operational semantics in the context Γ. Operationally, Γ and A are given and the judgment is verified by a combination of reduction using the
computational equations and exhaustive goal-oriented search using the as- sertional propositions in Γ. Both processes take place modulo the structural equations in Γ.
The assertional equality judgment Γ ▶ ?? (M = N ) states that M and N are assertionally equal in Γ, a notion that treats equality as a predicate and subsumes the structural and computational equality judgments. Op- erationally, Γ, M and N are given and the judgment is verified like other
assertional judgments in a goal-oriented fashion.
The assertional subtyping judgment Γ ▶ ?? (S ≤ T ) subsumes the asser- tional equality judgment and states that S is a subtype of T in Γ as a consequence of the cumulativity of the universe hierarchy. Operationally,
Γ, S and T are given and the judgment is verified like other assertional judgments in a goal-oriented fashion.
The computational rewrite judgment Γ ▶ !! (R M M ' P ) expresses that by means of the computational rewrite rules specified in Γ for the rewrite predicate R the element M can be rewritten to the element M ' and this rewrite is labeled by the element P . Operationally, Γ and M are given and M' is computed by the application of a computational rewrite rule in Γ modulo the computational and structural equations in Γ. In addition, an

abstract witness P for this rewrite is constructed.
By fixing the signature at the beginning of this section, we have introduced a particular instance of OCC. For the purpose of this paper we further re- strict this instance by requiring that specifications use a unique fixed rewrite
predicate R which is declared as R : S → S → T → Type. The idea is that this ternary rewrite predicate precisely corresponds to the labeled rewrite relation of rewriting logic. To remind us of this correspondence we refer to this re-
stricted sublanguage of OCC in the following as rewriting logic with dependent types (RWLDT). 4 Since R is unique, we can use the usual notation [P ]: M ⇒ N instead of the less intuitive (R M N P ). Similarly, we use Γ ▶ !! [P ]: M ⇒ N to denote the corresponding computational rewrite judgment.

Mapping MSR to RWLDT
In this section we give a precise definition of our mapping from MSR into RWLDT. The translations of kinds, types, terms, and states are very direct. The translation of roles and rules may appear somewhat technical, but the un- derlying idea is simple. To make it better accessible to the reader we introduce the mapping of roles and rules in three steps: In Sections 5.1–5.3, we give an initial mapping that is correct in a rather obvious way, and then we deal with some deficiencies of this mapping in two further steps in Sections 5.4 and 5.5. The result is a mapping which is not only correct but ensures executability of the resulting RWLDT specification (in the sense of ordinary rewrite systems). It furthermore avoids the introduction of any superfluous intermediate states that would lead to unnecessary inefficiencies, especially if we use the result of the translation for symbolic state space exploration.

Initial Context
The MSR multiset union constructs will be translated to an ordinary RWLDT function union. To this end, we define initial context as an OCC context that contains the following declarations.
There are the structural axioms for multisets:
state : Type, empty : state,
union : state → state → state,
union_comm : || {X, Y : state}(union X Y )= (union Y X),

4 Compared with [14] we have omitted assertional rewrite judgments in our presentation of OCC, because we do not need rewrite conditions in this paper. Such conditions are admitted in RWL and hence in the most general version of RWLDT.


union_assoc : || {X, Y, Z : state} (union (union X Y )Z)= 
(union X (union Y Z)),
union_id : || {X : state}(union empty X)= X.
The initial context also contains the following declarations, which we de- scribe only intuitively. Their purpose will become clear as we lay out the translation.
princ : Type, msg : Type. The types of principals and messages, respectively.
Tij : princ → T → state. For each role i with existential quantifier types T and with a rule j,a token (Tij A N ) will be used to represent the fact that role i has been instantiated with values A and N .
nat : Type, and 0 : nat and S : nat → nat. Natural numbers are used to index fresh symbols, i.e., symbols that have not been used in the past.
F : nat → state. As an invariant of our representation there is a unique (F N ) that holds the next available fresh index N .
V¯ : nat → V . For each type V which can be generated, this function allows us to index (some of) its elements by natural numbers, a way to generate fresh symbols of this type.
E : {T : Type}T → state. The term (E T M) expresses the fact that M is an element of type T , as part of the state. We will use this predicate only in Section 5.4.
act : Type, Ai : act for each role i, and Aij : act for each of its rules j. These constants are used to label the rewrite rules resulting from the translation.

Translating Kinds, Types, Terms, States, and Contexts
For the following we assume that MSR specifications do not use names intro- duced by initial context other than state, princ and msg. We also assume that all declared and bound variables are distinct. This allows a clear presentation of the main ideas without worrying about renaming and capturing. We then define the translation of MSR kinds, types, states, and contexts as follows:
kind (type)= Type
type({X : T }K)= {X : type(T )}kind (K)
type(X)= X type(state)= state type(princ)= princ type(msg)= msg
type(T M)= (type(T ) term(M))
type({X : T }T ')= {X : type(T )}type(T ')

term(X)= X
term(M N)= (term(M) term(N ))
state(·)= empty
state(S, S')= (union state(S) state(S'))
state(M)= term(M)
context(·)= initial context
context(Ð,X : K)= context (Ð),X : kind (K)
context(Ð,X : T )= context(Ð),X : type(T ).
Subsequently, (union (S1,... , Sn)) abbreviates (union S1 (union (S2,... , Sn))), and (union ()) abbreviates empty. We also refer to this term as the formal multiset of S1,... , Sn.
The adequacy of this translation is expressed by the following theorem:
Theorem 5.1  If Ð is a well-typed MSR context then:
If K is an MSR kind, then
Ð ▶ K kind in MSR iff context(Ð) ▶ kind (K): Type1 in RWLDT.
If in addition Ð ▶ K kind and T is an MSR type, then
Ð ▶ T : K in MSR iff context (Ð) ▶ type(T ): kind (K) in RWLDT.
If in addition Ð ▶ T : K and M is an MSR term, then
Ð ▶ M : T in MSR iff context(Ð) ▶ term(M): type(T ) in RWLDT.
If S is an MSR state, then
Ð ▶ S : state in MSR iff context (Ð) ▶ state(S): state in RWLDT.
Furthermore, Ð is well-typed iff context(Ð) is well-typed.
Proof Sketch. First of all, it is straightforward to verify that each MSR inference rule [7] can be simulated by one or more inference rules of RWLDT [14]. As a consequence, the ⇒ direction of the equivalences (i)–(iv) holds.
To deal with the more interesting ⇐ direction of these equivalences, we first observe that several features of RWLDT are not relevant for the purpose
of this proof. Our representation does not exploit higher universes (beyond Type0) or universe subtyping in any essential way (the only use of Type1 in our representation is to serve as a type of kinds). Both, computational equations and assertional propositions of RWLDT are not used. Structural equations are only used to represent MSR states (multisets) and they are used in such a way that they precisely represent the MSR syntax. The computational rewrite axioms of RWLDT do not have any impact on type checking, so they can be ignored here. Another major simplification is that MSR and hence the repre- sentation in RWLDT does not use λ-abstractions, and the type assertions and the ϵ-operator of RWLDT are not used either. As a consequence, many of the


inference rules of RWLDT [14] can be ignored or reduced to trivial cases, be- cause they cannot have been used in the RWLDT derivation or have only been used in a trivial form. For instance, without λ-abstractions and computational equations the computational equality reduces to structural equality. Without assertional propositions, inference rules for assertional propositions other than assertional equality and assertional subtyping are superfluous. Without the use of higher universes, assertional subtyping coincides with assertional equal- ity which reduces to structural equality and α-conversion. Now it is easy to verify the ⇐ direction of (i)–(iv) by simulating each inference rule of the sim-
plified RWLDT using inference rules of MSR [7]. A slight remaining difficulty
is to overcome the gap between implicit α-conversion in MSR and explicit α-conversion in RWLDT (including its more general notion of context), but the proof techniques for pure type systems used in [15] can be easily adapted to our simple setting.
Finally, the proof that Ð is well-typed iff context(Ð) is well-typed, can be done by induction over the length of Ð using the previous statements.	 It is important to note that this theorem does not imply that each well-
typed RWLDT term in the context context (Ð) is a representation of an MSR term, type, or kind. For instance, a counterpart of the RWLDT type Type → Type : Type1 does not exists in MSR. Similarly, we could use λ-abstractions and other constructs in RWLDT, but they do not have counterparts in MSR. In fact, the restricted syntax of MSR and our representation carves out a sub- language of RWLDT, and only terms in this sublanguage are used inside the
operational semantics. The specification itself, however, requires constructs such as structural equations and computational rewrite axioms, which are outside of this sublanguage.

Translating Roles and Rules
To further simplify the presentation, we assume that the identifier of the i-th role is i and the identifier of its j-th rule is j. We then define the translation of MSR roles and rules as follows (using У and У' to range over role sequences):
roles(·) = [].
roles(ROLE i FOR A : princ . EL : T . ρ)= 
Ri : role(i, A, EL : T . ρ).
roles(ROLE i : 6P : princ . EL : T . ρ)= 
Ri : {P : princ}role(i, P, EL : T . ρ).
roles(У, У')= roles(У), roles(У').
role(i, P, EL : T . ρn)= 
{Z, Z' : nat}{L : type(T )}fresh(Z, L, T , Z') →

[Ai]: (F Z) ⇒ (union ((Ti1 P L),... , (Tin P L) (F Z'))),
rule(i, P, L, T , ρn),... , rule(i, P, L, T , ρn).
1	n
rule(i, P, L, T , RULE j : 6X : U . M —→ EY : V . N)= 
'
Rij : {P : princ}{Z, Z : nat}{L : type(T )}
{X : type(U )}{Y : type(V )}fresh(Z, Y , V , Z') →
[Aij]: (union ((Tij P L), (F Z), state(M))) ⇒
(union ((state(N ), (F Z')))).
fresh(Z, Y y, V y, Z')= 
Y y=V¯ y (Z)), Y y=V¯ y (S(Z)),... , Y y=V¯ y (Sy−1(Z)), Z'=Sy (Z).
1	1	2	2	y	y
In the last equation we assume that for type V there is an injection with

the same name V¯
initial context.
: nat → V , a declaration that needs to be included in

Above we use A1,... , An → B to abbreviate A1 → ... → An → B, which here means that A1,... , An are conditions. It should also be noted, however, that the use of conditions here is not essential, because they are all of the form Y =Q and hence can trivially be eliminated. We only use conditions for
better readability and to maintain a more direct correspondence to the MSR syntax.
The idea behind the definition of role is that it maps each MSR role i to several RWLDT rewrite axioms: There is one rewrite axiom labelled Ai, representing the instantiation of this role. In addition, there is one rewrite axiom labelled Aij (generated by rule) for each of its rules j. The first axiom Ai, apart from the generation of fresh terms needed for the new instance, generates tokens (Ti1 P L),..., (Tin P L), representing the fact that none of the rules of this role have been executed yet. Each of the remaining axioms Aij simulates the corresponding MSR rule j, so that each application of a rule removes its corresponding token. This realizes the MSR policy that rules of active roles can only be executed once.
The following lemma expresses that the generation of fresh symbols is correctly represented in RWLDT.

Lemma 5.2 (Freshness Invariance) Let (Ð, У) be an MSR specification. The representation in RWLDT maintains the following invariant: If there is a term of the form (F (Sn0)) in the RWLDT state and no other occurrence of F
then for each k (including 0) the term (Sn+k0), and consequently V (Sn+k0), is fresh, i.e., it does not occur in any other part of the state.

Proof Sketch. Can be directly verified as an inductive invariant for each of the RWLDT rewrite axioms in our representation, using our earlier assumption

on the initial context that 0 and S are not used in the MSR specification. 
To express the relationship between MSR and its representation we also need a representation of dynamic entities such as active roles:
actroles(·)= empty.
actroles(ACTROLE i : FOR A : princ . WITH N : T . ρ)= 
the formal multiset of all (Tij A N ) s.t. ρ contains rule j.
actroles(R, R')= (union actroles(R) actroles(R')), where R and R' range over active role sets.
Recall that ACTROLE i : FOR A : princ . WITH N : T . ρ is the form of an active role, i.e., one that has been (fully) instantiated and possibly partially executed. The fact that the active role set contains an active role of this form corresponds to the fact that for each rule j of the active role (i.e., a rule that has not been executed yet) the term (Tij A N ) is part of the distributed state in the representation.
The subsequent theorem justifies the use of representations of MSR con- figurations of a particular form in all the remaining theorems.
Theorem 5.3 (Representation Invariance) Let (Ð, У) be an MSR spec- ification. If context(Ð), roles(У) ▶ !! [P ] : M ⇒ M ' and M is a represen- tation of an MSR configuration, i.e., of the form (union ((F (Sn 0)), state(S), actroles(R))) for some n, some MSR state S, and some MSR active role set R, then M' is a representation of an MSR configuration as well.
Proof Sketch. Again this is an inductive invariant that obviously holds for each of the RWLDT rewrite axioms in our representation.	 
For the proof of the main theorem, we need the following lemma.
Lemma 5.4 (Representation Uniqueness) Let (Ð, У) be an MSR speci- fication. Then each MSR active role set R reachable in the operational seman- tics of MSR can be uniquely reconstructed from its representation actroles(R).
Proof Sketch. Observe that active role sets can contain only elements that can actually be obtained by (full) instantiation of known roles followed by removal of some of its rules (after they are executed). We need to consider two cases:
If there is at least one token (left) that represents the active role, then this token carries the full information, namely i, A, and N , to determine the initial role instance. Unfortunately, we need to argue that together all tokens of the form (Tij A N ) uniquely determine the rules of this active role, i.e., the rules that still need to be executed. The only po- tential source of confusion is that the representation may contain several


instances of the same active role i executing concurrently with the same values A and N . Since N is generated fresh the confusion can only occur if N is the empty list, i.e., when the role does not have any existential quantifiers. Because of the restricted format of MSR specifications (ex- istential predicates are used to sequentialize the rules inside a role) this means that the role can only have a single rule, and hence it can be in only one state, namely the state after it has been instantiated but not executed.
In case there is no token (left) that represents the active role, the role must have been fully executed, and hence by definition of our operational semantics for MSR it cannot be part of the active role set. Hence, again its contribution to the active role set is uniquely determined.	 
Lemma 5.5 Let (Ð, У) be an MSR specification, let S, S' be MSR states, and let R, R' be MSR active roles sets. Then for all n, k we have the following equivalences:

There are MSR contexts Σn, Σ'n+k s.t. Ð, У ▶ [S]R —→
A,N
i
[S']R'  iff

context(Ð), roles(У) ▶ !! [Ai]: (union ((F (Sn 0)), state(S), actroles(R))) ⇒
(union ((F (Sn+k 0)), state(S'), actroles(R'))),
n	'n+k	R	' R'

There are MSR contexts Σ , Σ
s.t. Ð, У ▶ [S]  —→ A,N [S ] ' iff
i,j

context(Ð), roles(У) ▶ !! [Aij]: (union ((F (Sn 0)), state(S), actroles(R))) ⇒
(union ((F (Sn+k 0)), state(S'), actroles(R'))).
In both statements we identify terms that are structurally equal in context (Ð).
Proof Sketch. First, an observation that simplifies the proof of both state- ments of the lemma: We can verify using the previous lemma that
(union ((F (Sn0)), state(S), actroles(R)))
can only represent the MSR state S, the MSR active role set R, and hence only an MSR configuration [S]R for some dynamic context Σ. Similarly,
(union((F (Sn+k 0)), state(S'), actroles(R')))
can only represent a configuration [S']R' again for some dynamic context Σ'. To prove the first equivalence of the lemma, note that the left-hand side expresses that role i is instantiated for some principal A (if it is generic, otherwise A is already fixed), the existential quantifiers are instantiated with fresh symbols, and the corresponding role instance is added to the active role set. According to the change in the MSR dynamic context on the left-hand side (Σn becomes Σ'n+k) k fresh symbols are generated, which means that the role has k existential quantifiers. We need to verify that this step in the operational semantics of MSR is equivalent to the right-hand side, i.e., to the


application of the rewrite axiom labeled Ai (see definition of role) in RWLDT. Using the freshness invariance lemma is it easy to see that the existential quantifiers of role i are correctly instantiated using k fresh terms N which are generated in this process. Apart from maintaining the freshness information, the only effect of the rule is that the terms (Ti1 A N ),... , (Tin A N ) are added to the RWLDT state. This can only correspond to the addition of a new instance of role i to the active role set.
For the second equivalence of the lemma, note that the left-hand side expresses that an instance of role i is selected from the active role set and its rule j, which is of the form RULE j : 6X : U . M —→ EY : V . N , is
executed. According to the change in the dynamic MSR context on the left-
hand side (Σn becomes Σ'n+k) k fresh symbols are generated, which means that the rule has k existential quantifiers. We again need to verify that this step in the operational semantics of MSR is equivalent to the right-hand side, i.e., the application of the rewrite axiom labeled Aij (see definition of rule) in RWLDT. Using the freshness lemma it is easy to see that the existential quantifiers of rule j are correctly instantiated using k fresh terms. Apart from maintaining the freshness information, the rule has two effects: It replaces the term state(M ') by state(N ') (the terms M' and 'N ' are instances of M and N , respectively), a step precisely corresponding to the execution of the MSR rule, and it removes the token (Tij A N ), which can only correspond to the fact that the rule is removed from the active role, because it has been executed.
Obviously, for both equivalences the detailed proof would establish a bi- jection between the fresh symbols generated by MSR and the fresh terms generated in RWLDT.	 
The following theorem summarizes the statements of the previous lemma:
Theorem 5.6 (Soundness and Completeness) Let (Ð, У) be an MSR specification, let S, S' be MSR states, and let R, R' be MSR active roles sets. Then for all n, k we have the following equivalence:

There are MSR contexts Σn,Σ'n+k s.t. Ð, У ▶ [S]R —→
I,E
[S']R'  iff

there exists P s.t. context(Ð), roles(У) ▶
!! [P ]: (union ((F (Sn 0)), state(S), actroles(R))) ⇒
(union ((F (Sn+k 0)), state(S'), actroles(R'))),
where we identify terms that are structurally equal in context(Ð).
Achieving Executability
Unfortunately, the resulting RWLDT specification is not necessarily executable in the ordinary sense of rewriting, since there may be rules with variables on the right-hand side that do not appear on the left-hand side and hence cannot


be bound by matching. Therefore, we apply another simple transformation which makes certain types and their elements explicit in the state by making use of the predicate E : {T : Type}T → state. This leads to the following
modifications:
role(i, P, EL : T . ρn)= 
{Z, Z' : nat}{L : type(T )}fresh(Z, L, T , Z') →
[Ai]: (union((E princ P ), (F Z)) ⇒
(union((E princ P ), (Ti1 P L),..., (Tin P L), (F Z')))
rule(i, P, L, T , ρn), ... , rule(i, P, L, T , ρn).
1	n
rule(i, P, L, T , RULE j : 6X : U . M —→ EY : V . N)= 
'
Rij : {P : princ}{Z, Z : nat}{L : type(T ij)}
{X : type(U )}{Y : type(V )}fresh(Z, Y , V , Z') →
[Aij]: (union (ES, (Tij P L), (F Z), state(M))) ⇒
(union (ES, state(N ), (F Z')))
where ES is a formal multiset containing (E Ux Xx),... , (E Ux Xx).
1	1	x	x
The theorem is as before except for that we have to provide a sufficient amount of explicit typing information (see ES below) to perform a simulation step:
Theorem 5.7 (Soundness and Completeness) Let (Ð, У) be an MSR specification, let S, S' be MSR states, and let R, R' be MSR active roles sets. Then for all n, k we have the following equivalence:

There are MSR contexts Σn, Σ'n+k s.t. Ð, У ▶ [S]R —→
I,E
[S']R'  iff

there exists P , ES s.t. context(Ð), roles(У) ▶
!! [P ]: (union (ES, (F (Sn0))), state(S), actroles(R))) ⇒
(union (ES, (F (Sn+k 0)), state(S'), actroles(R')))
where we identify terms that are structurally equal in context (Ð), and ES is a formal multiset containing (E U Q) only for terms Q of type U .
Proof Sketch. The only modification to our previous representation (Sec- tion 5.3) is that we have added terms of the form (E U Q) to the rewrite axioms, such that as an obvious invariant these terms are preserved by applications of rewrite axioms. These terms cannot be confused or interact with any of the terms representing the MSR configuration, so that the original behavior is preserved (disregarding the newly introduced terms), assuming that the ap- plicability of rewrite axioms is not compromised. To guarantee the latter, the theorem has been relaxed w.r.t. the previous one (Section 5.3) by adding the formal multiset ES to the state on the left-hand side of the rewrite judgment (and since ES is preserved it is added on the right-hand side as well). Since ES is existentially quantified it can be instantiated by any sufficient number of


terms compensating for the (E U Q) that are now needed to apply the rewrite axioms.	 
As a slight optimization, the term (E princ A) in the translation above can be dropped in the rewrite axiom Ai if it is the translation of an anchored rule, because in this case A is a constant declared in Ð and not a variable
that needs to be determined by matching. Furthermore, (E Ux Xx) can be
j	j
dropped from ES in the translation if Xx occurs in M, because in this case
it can be bound by matching.

Eliminating Intermediate States
A drawback of the operational semantics of MSR defined in terms of the

transition judgment Ð, У ▶ [S]R —→
I,E
[S']R' and our representation above is

that role instantiation can occur anytime and arbitrarily often even if there is
no subsequent use of the role. This is an unnecessary source of nondeterminism and nontermination and without any other means to control the execution it would prevent symbolic execution and analysis.
By considering a slightly more abstract semantics that composes role in- stantiation with the execution of a rule of this role, we can eliminate such superfluous intermediate states. For the modified operational semantics of

MSR we write Ð, У ▶ [S]R —→
(I)E
[S'']R'' iff there exists a role i with a rule j

(and A, N ) s.t.
Ð, У ▶ [S]R —→
[S']R' and Ð, У ▶ [S']R' —→
[S'']R''  or

Σ
Ð, У ▶ [S]R —→
A,N
i

A,N
i,j
Σ'
''
]Σ'' .
'	A,N
i,j
Σ''

Our representation will be modified correspondingly as follows:
role(i, P, EL : T . ρn)= 
rule1(i, n, P, L, ρn), rule2(i, n, P, L, ρn),... ,
1	n
rule1(i, n, P, L, ρn), rule2(i, n, P, L, ρn).
n	n
rule1(i, n, P, L, T , RULE j : 6X : U . M —→ EY : V . N)= 
'	''
Rij1: {P : princ}{Z, Z ,Z : nat}{L : type(T )}
{X : type(U )}{Y : type(V )}
fresh(Z, L, T , Z'), fresh(Z', Y , V , Z'') →
[Aij1] : (union ((E princ P ), ES, (F Z), state(M))) ⇒
(union ((E princ P ), ES, state(N ),TS, (F Z''))) where TS is the formal multiset containing
(Ti1 P L) ... (Tin P L) with (Tij P L) removed.
rule2(i, n, P, L, T , RULE j : 6X : U . M —→ EY : V . N)= 
'	''
Rij2: {P : princ}{Z, Z ,Z : nat}{L : type(T )}

{X : type(U )}{Y : type(V )}fresh(Z, Y , V , Z') →
[Aij2] : union (ES, (Tij P L), (F Z), state(M)) ⇒
union (ES, state(N ), (F Z ))
The idea behind these definitions is that the rewrite axiom labelled Rij1 gener- ated by rule1 simulates the effect of instantiating role i immediated followed by the execution of one of its roles, which is j in this case. As a conse- quence it generates the formal multiset of tokens (Ti1 P L) ... (Tin P L) with (Tij P L) removed, because the corresponding rule has already been ex- ecuted. The rewrite axiom labelled Rij2 generated by rule2 takes care of the execution of remaining rules, and hence remains unchanged compared with the previous section.
Now we obtain a result entirely analogous to the previous theorem:
Theorem 5.8 (Soundness and Completeness) Let (Ð, У) be an MSR specification, let S, S' be MSR states, and let R, R' be MSR active roles sets. Then for all n, k we have the following equivalence:

There are MSR contexts Σn, Σ'n+k s.t. Ð, У ▶ [S]R —→
(I)E
[S']R'  iff

there exists P , ES s.t. context(Ð), roles(У) ▶
!! [P ]: (union (ES, (F (Sn0)), state(S), actroles(R))) ⇒
(union (ES, (F (Sn+k 0)), state(S'), actroles(R'))),
where we identify terms that are structurally equal in context (Ð), and ES is a formal multiset containing (E U Q) only for terms Q of type U .
Proof Sketch. The only difference w.r.t. the previous theorem is that we use

the new judgment Ð, У ▶ [S]R —→
(I)E
[S'']R'' as the operational semantics of

MSR. By definition there are two cases to consider:
There is a role i with a rule j such that

'	'
Ð, У ▶ [S]R —→	[S']R and Ð, У ▶ [S']R —→
[S'' R''

A,N	'
i
'	A,N
i,j
]Σ'' .

Observe that we are concerned with a sequential composition of the judg- ments that we represented in our previous representation (Section 5.4). Omitting quantifiers and conditions for clarity, the first judgment was represented by the rewrite axiom
[Ai]: (union((E princ P ), (F Z)) ⇒
(union((E princ P ), (Ti1 P L),... , (Tin P L), (F Z'))),
and the second judgment was represented by the rewrite axiom [Aij]: (union (ES, (Tij P L), (F Z'), state(M))) ⇒
(union (ES, state(N ), (F Z''))).
Consequently, our new representation (see definition of rule1) uses the sequential composition of these two:


[Aij1] : (union ((E princ P ), (F Z), ES, state(M))) ⇒
(union ((E princ P ), TS, ES, state(N ),TS, (F Z''))),
where TS is the formal multiset containing (Ti1 P L) ... (Tin P L) with (Tij P L) removed.

There is a role i with a rule j such that Ð, У ▶ [S]R —→ A,N [S
i,j
'' R''
Σ''

For this case, we just need to simulate the execution of a rule. Hence,
the rewrite axiom (see definition of rule2) is as in the previous represen- tation:
[Aij2] : union (ES, (Tij P L), (F Z), state(M)) ⇒
union (ES, state(N ), (F Z )).
 
As an optimization, the rewrite axiom Rij1 can be omitted if M contains any of the variables in L. The reason is that we have the invariant (for the reachable states we are concerned with in the theorem) that the variables L are instantiated by objects which do not exist in the state, so that this axiom could never be applied.
Another obvious optimization is to omit the rewrite axiom Rij when the role i contains only a single rule. This optimization relies on the fact that in this case Tij can never appear in the state, an invariant that holds for the reachable states we are concerned with in the theorem. More generally, we drop any rule that depends on a Tij that is never generated. This can hap- pen, because the only rule that generates Tij has been eliminated by previous optimizations.

Translation in our Example
Returning to the Otway-Rees protocol and its specification in MSR, we now illustrate how its responder role (role number 2) is translated into RWLDT. For brevity, we omit all declarations, except the ones for the network predicate, message concatenation (denoted , in MSR), and the encryption function, (which was written as { } in MSR):
N : msg -> state
append : msg -> msg -> msg
encrypt : {A,B : princ} msg -> (shK A B) -> msg
As for union, we write (append (M1,... , Mn)) to abbreviate (append M1
(append (M2,... , Mn))).
We have the following coercions (to which we have given longer names here):
nonce-msg : nonce -> msg


princ-msg : princ -> msg
ltK-shK : {A,B : princ} (ltK A B) -> (shK A B)
stK-shK : {A,B : princ} (stK A B) -> (shK A B)
We also declare the following injections as required by the translation to generate fresh symbols of the target type:
NONCE : nat -> nonce
L2 : nat -> ({B : princ} princ ->
nonce -> nonce -> (ltK B S) -> state)
Finally, we declare token constructors relevant for the responder role:
T21 : princ -> ({B : princ} princ ->
nonce -> nonce -> (ltK B S) -> state) -> state .
T22 : princ -> ({B : princ} princ ->
nonce -> nonce -> (ltK B S) -> state) -> state .
The translation of the responder role produces four rewrite rules, but two of them can be eliminated by our optimizations:
R211 : !! {B:princ}
{L:{B:princ} princ -> nonce -> nonce -> (ltK B S) -> state}
{A:princ}{kBS:(ltK B S)}{X:msg}
{fresh,fresh’:nat}{n,nB:nonce}
(L := (L2 fresh)) ->
(nB := (NONCE (suc fresh))) ->
(fresh’ := (suc fresh)) ->
[A211] : (union ((E (ltK B S) kBS), (F fresh),
(N (append ((nonce-msg n),
(princ-msg A),
(princ-msg B),
X)))))
=> (union ((E (ltK B S) kBS), (F fresh’), (N (append (n,A,B,X,
(encrypt (append ((nonce-msg nB),
(nonce-msg n),
(princ-msg A),
(princ-msg B))) (ltK-shK B S kBS))))),
(L B A n nB kBS), (T22 B L)))
R222 : !! {B:princ}
{L:{B:princ} princ -> nonce -> nonce -> (ltK B S) -> state}
{A:princ}{kBS:(ltK B S)}{kAB:(stK A B)}{Y:msg}{n,nB:nonce}
[A222] : (union ((N (append ((nonce-msg n),Y,
(encrypt (append ((nonce-msg nB),
(stK-msg A B kAB))) (ltK-shK B S kBS))))),
(L B A n nB kBS), (T22 B L)))


=> (N (append ((nonce-msg n),Y)))
The justification for eliminating R221 is that it contains (L B A n nB kBS) with L fresh on its left-hand side. Since R212 depends on (T21 B L), which could only be generated by R221, this rule can be dropped as well.
The full RWLDT specification successfully passes the OCC type checker, which implies that the original MSR specification is type-correct as well. The OCC prototype can further be used to explore the dynamics of the protocol. For example, to restrict the protocol execution to one instance of each role and to observe termination we add STARTi and TERMINATEDi tokens to respectively the first and last rules of each role i.
A:princ . B:princ . kAS:(ltK A S) . kBS:(ltK B S) .
rew (union ((F 0),(E P A),(E P B),
(E (ltK A S) kAS),(E (ltK B S) kBS),
(START1 A), (START2 B), (START3 S))) .
trace:
A111 A211 A311 A222 A122
result:
(union ((F 6),(E P A),(E P B),
(E (ltK A S) kAS),(E (ltK B S) kBS),
(TERMINATED1 A), (TERMINATED2 B), (TERMINATED3 S)))
After starting the symbolic execution the system performs a series of actions each corresponding to the application of a rule. Finally, the terminating state is reached, the explicit type information is preserved, and six fresh constants have been used. An exploration of the state space using Maude shows that the above execution is the only possible one from the given initial state.

Final Remarks
In this paper we have presented a shallow and hence efficient embedding from MSR into rewriting logic with dependent types (RWLDT), which has been in- troduced as a restricted instance of the open calculus of constructions (OCC). This mapping forms the basis for an ongoing implementation of an MSR ex- ecution and analysis environment. A mapping from RWLDT into RWL has already been implemented as part of the OCC prototype in Maude. This en- abled us to perform symbolic execution of the translated MSR specification in our example. The user interaction takes place at the level of RWLDT terms, which directly correspond to MSR terms, and hence the user does not need to be concerned with the resulting translation into RWL. A similar interface for symbolic search and model checking would be easy to implement. At the moment, we can however already export the RWL translation of the RWLDT specification and perform symbolic search and model checking at the level of

Maude.
For the sake of clarity we made a number of simplifying assumptions in this paper. We decoupled the issue of inferring implicit parts of an MSR specification from the actual translation phase, which is exactly the way we would like to organize the architecture of the translator. We also assumed the absence of name clashes, an assumption that is not necessary if we use the CINNI explicit substitution calculus [13,14] and its term representation. In fact the theory and prototype for OCC are already based on this calculus.
An additional feature of MSR that may require changes to our represen- tation are constraints, i.e., conditions attached to MSR rules. Constraints do not appear in [4,5], but have proved useful, for instance, in the Kerberos analysis [3]. Among the options are the direct translation into conditional rules of RWLDT, the extension of the linear state by a non-linear counterpart (as in standard sequent presentations of linear logic) and its use to verify the constraints, or a combination of these two possibilities. Equations are a re- cent addition to MSR, inspired by this collaboration. They can be directly mapped to the computational equations of RWLDT. Further extensions of MSR, such as moving to richer executable fragments of linear logic in the style of CLF [16], a direction currently investigated by the first author, seem to require deeper embedding of MSR into RWLDT, an interesting topic that we leave for future research.
An important part of MSR, the data access specification [6], has not been treated in this paper, because a sufficiently generic and concise formulation is still subject of ongoing work. Our most recent idea to formalize the data access specification is to use predicates inside the type theory to express the accessibility of information relative to principals. In combination with the assertional propositions of RWLDT this may simplify the representation of data access rules significantly and would provide a great deal of flexibility. Furthermore, the proof that the data access specification is satisfied would become an object inside the type theory. In fact, the logical nature of RWLDT is far from being fully exploited so far, which leads us to the last point of the conclusion.
In addition to the automatic symbolic analysis techniques mentioned above, our two-level architecture opens the door to performing formal reasoning at the level of RWLDT, which contains all the type information of the original MSR specification and uses practically the same term syntax. Indeed, interactive theorem proving is supported by OCC [14], but to make use of it our transla- tion needs to be enriched to make explicit the inductive nature of MSR, which can be achieved essentially by adding suitable elimination/induction princi- ples. Formal reasoning would ultimately rely on the model-theoretic semantics


of OCC, but it can use its operational semantics to enhance the expressivity of types and to provide partial automation in proofs.
See  http://formal.cs.uiuc.edu/stehr/msr.html	for the complete specification of the Otway-Rees example, other examples, and recent progress on the project.
Acknowledgment. The research reported has been conducted in the scope of the CONTESSA project http://formal.cs.uiuc.edu/contessa. The first author is partially supported by NRL under contract N00173-00-C-2086. The second author is supported by ONR Grant N00014-02-1-0715.

References
Barendregt, H. P., Lambda-calculi with types, in: S. Abramsky, D. M. Gabbay and T. S. E. Maibaum, editors, Background: Computational Structures, Handbook of Logic in Computer Science 2, Claredon Press, Oxford, 1992 .
Bouhoula, A., J.-P. Jouannaud and J. Meseguer, Speciﬁcation and proof in membership equational logic, Theoretical Computer Science 236 (2000), pp. 35–132.
Butler, F., I. Cervesato, A. D. Jaggard and A. Scedrov, A Formal Analysis of Some Properties of Kerberos 5 Using MSR, in: Fifteenth Computer Security Foundations Workshop (2002), pp. 175–190.
Cervesato, I., A speciﬁcation language for crypto-protocols based on multiset rewriting, dependent types and subsorting., in: Workshop on Speciﬁcation, Analysis and Validation for Emerging Technologies, 2001, pp. 1–22.
Cervesato, I., Typed MSR: Syntax and examples, in: 1st International Workshop on Mathematical Methods, Models and Architectures for Computer Networks Security (2001), pp. 159–177.
Cervesato, I., Data Access Speciﬁcation and the Most Powerful Symbolic Attacker in MSR, in:
Software Security, Theories and Systems (2003), pp. 384–416.
Cervesato, I., MSR: Language deﬁnition and programming environment (2003), draft available from http://theory.stanford.edu/~iliano/MSR/.
Cervesato, I., N. Durgin, P. D. Lincoln, J. C. Mitchell and A. Scedrov, A Meta-Notation for Protocol Analysis, in: 12th Computer Security Foundations Workshop (1999), pp. 55–69.
Clavel, M., F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer and J. F. Quesada,
Maude: Speciﬁcation and programming in rewriting logic, Theoretical Computer Science (2001).
Denker, G. and J. K. Millen, CAPSL Intermediate Language, in: N. Heintze and E. Clarke, editors, Proceedings of the Workshop on Formal Methods and Security Protocols — FMSP, Trento, Italy, 1999.
Meseguer, J., Conditional rewriting logic as a uniﬁed model of concurrency, Theoretical Computer Science 96 (1992), pp. 73–155.
Otway, D. and O. Rees, Efficient and timely mutual authentication, Operating Systems Rewiew
21 (1987), pp. 8–10.
Stehr, M.-O., CINNI – A Generic Calculus of Explicit Substitutions and its Application to
λ-,	σ-	and	π-calculi,	in:
K. Futatsugi, editor, 3rd International Workshop on Rewriting Logic and its Applications, ENTCS 36 (2000), pp. 71 – 92, http://www.elsevier.nl/locate/entcs/volume36.html.


Stehr,	M.-O.,	Programming,  Speciﬁcation,  and  Interactive Theorem Proving — Towards a Uniﬁed Language based on Equational Logic, Rewriting Logic, and Type Theory, Doctoral Thesis, Universit¨at Hamburg, Fachbereich Informatik, Germany (2002), http://www.sub.uni-hamburg.de/disse/810/.
Stehr, M.-O. and J. Meseguer, Pure type systems in rewriting logic, in: From Object-Orientation to Formal Methods: Dedicated to The Memory of Ole-Johan Dahl, LNCS 2635 (2004).
Watkins, K., I. Cervesato, F. Pfenning and D. Walker, A Concurrent Logical Framework I: Judgments and Properties, Technical Report CMU-CS-02-101, Department of Computer Science, Carnegie Mellon University (2003).
