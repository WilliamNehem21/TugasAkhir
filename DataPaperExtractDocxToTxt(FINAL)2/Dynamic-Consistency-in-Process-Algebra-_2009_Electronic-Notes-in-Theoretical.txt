

Electronic Notes in Theoretical Computer Science 229 (2009) 3–20
www.elsevier.com/locate/entcs

Dynamic Consistency in Process Algebra: From Paradigm to ACP
S. Andova1 ,2
Formal Methods Group
Technical University of Eindhoven, The Netherlands
L.P.J. Groenewegen
FaST Group, LIACS Leiden University, The Netherlands
E.P. de Vink
Formal Methods Group
Technical University of Eindhoven, The Netherlands

Abstract
The coordination modelling language Paradigm addresses collaboration between components in terms of dynamic constraints. Within a Paradigm model, component dynamics are consistently specified at various levels of abstraction. To enable automated verification of Paradigm models, a translation of Paradigm into process algebra is provided. Examples are given and guidelines for a systematic translation into the process algebra ACP are discussed. Verification results building on the mCRL2 toolset are presented as well.
Keywords: automated verification, collaboration, dynamic consistency, dynamic constraint, Paradigm, process algebra


Introduction
Process algebras are becoming an important stepping stone from software archi- tecture and description formalisms to automated analysis and verification tools,
e.g. [1,16,14,13]. In this paper, we link the coordination modeling language Paradigm via the process algebra ACP with the mCRL2 toolset. This way, the flexibility of

1 Corresponding author
2 Email: s.andova@tue.nl

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.026

coordination, regarding a software system as a loosely coupled, but structured ag- gregation of components, is connected to the computational rigor of process equiv- alence and model-checking. A systematic translation of Paradigm collaborations as a recursive specification of a system of parallel processes is presented. Central to Paradigm is the decomposition of dynamic constraints along two axes: (i) vertically, restrictions of a component with respect to the roles it fulfills in all collaborations it is engaged in, (ii) horizontally, coordination and synchronization of subbehaviour enforced upon participants in a collaboration.
The coordination modeling language Paradigm [8,9] specifies roles and interac- tions within collaborations between components. Interactions are in terms of tem- porary constraints on the dynamics of components. The constraints can be of two kinds, either purely sequential per component (vertical) or step-wise synchronizing for an ensemble of components (horizontal). A sequential constraint corresponds to a role within a protocol of a component, a behavioral view on the component’s underlying, typically hidden dynamics. A synchronizing constraint corresponds to the distributed execution of the protocol by the components, a specific paralleliza- tion of their roles, constituting a dynamically consistent coordinated computation. Specific for Paradigm is, via suitable constraint composition it allows for modelling evolution and self-adaptation [9].
Processes algebras (PA for short), such as CCS, CSP, LOTOS, ACP, provide a powerful framework for formal modeling and reasoning about concurrent systems. Keystone is the notion of compositionality. Each component of the system is mod- eled separately, and the complete system is obtained as a parallel composition of its interacting components. In addition, process algebras have mechanisms to de- fine the synchronization and hiding of actions (by renaming them into the so-called silent action τ ). Characteristic for the process algebra ACP [2,4] is the user-defined communication function ‘|’ of multi-actions, such that e.g. ∂{a,b,c}(a.P  b.Q  c.R) yields d.(P  Q  R) if we have a | b | c = d. Various equivalences can be built upon process calculi. For ACP, strong bisimulation and branching bisimulation are the prominent ones.
In the present paper, the translation of Paradigm models into PA is first intro- duced by means of two examples. In both cases the system consists of n clients who try to get service from one server exclusively, a critical section problem. The difference is, that in one example the server is supposed to choose the next client in a non-deterministic manner, while in the other example this is done in a round- robin manner. For both examples, a translation into PA is given and a subsequent analysis with the mCRL2 toolset discussed.
While the translation of the Paradigm models into PA for both examples is done manually, the computation of the state spaces of the entire systems (including all interleaving and interaction) and their analysis exceed human capabilities as the number of clients increases. (As discussed in Section 4, for an n-client system this is (5·2n−2−1)·n + 1.) Exploiting of the toolset mCRL2, unleashes push-button techniques to generate the complete, symbolic state spaces, on which further analysis can be done. Several properties of functional correctness of the two examples have

been checked. For instance, as expected, the non-deterministic server does not guarantee eventual access to the service, unless fairness is assumed. In contrast, the round-robin server guarantees, as is no surprise either, access within one cycle. However, the main point is, that once translation into ACP has been achieved, formal methods for analysis of a Paradigm collaboration are within reach. Thus, the embedding of the collaboration into process algebra brings model-checking and analysis, together with its rigor, at the abstraction level of the coordination. Our translation into PA preserves the general structure and dynamics of the original Paradigm model, a property we do not expect to hold when e.g. translating into Petri-nets. As a consequence, to be discussed in outline, a counterexample obtained by model-checking can be traced back in the original Paradigm model.
Related work. Our work on consistency in a horizontal and vertical dimension has been influenced by the work of Ku¨ster [6,12]. The Wright language [1] based on CSP provides FDR support to check static consistency properties. Next to consistency, which is built-in for Paradigm, the focus in Paradigm modelling is on dynamics and change of constraints. As for the Korrigan ADL [15], the formalism should be more than just a box-and-line notation. Managers of Paradigm collaborations are reminiscent to the orchestration connector of [3]. However, in Paradigm there is an explicit separation of the manager and its coordinating of the collaboration, yielding different ‘slices’ of abstraction.
Other bridges from software architecture to automated verification include the pipeline from UML via Rebeca and Promela to the SPIN model-checker and from UML via Object-Z and CSP to the FDR model-checker [17,13]. Process algebra driven prototyping as coordination from CCS is proposed in [16]. The skeletons generated from CCS-specifications overlap with Paradigm collaborations. In the TITAN framework [14], CCS is playing a unifying role in a heteorgeneous environ- ment for aspect-oriented software engineering.
Structure of the paper. In Section 2 the basics of Paradigm is given together with two running examples. Section 3 briefly introduces process algebra. In Section 4,a detailed translation of the Paradigm models of the two protocols is given, followed by a general translation of Paradigm models in Section 5. Section 6 concludes the paper.

Paradigm and two critical section models
This section briefly describes the main notions of Paradigm. By means of two examples, that will be used as running examples through out the paper, the main aspects of the Paradigm approach are explained. We also introduce an UML-style architectural diagram for collaborating components, that sets the stage for various notions of dynamics. We point out where the Paradigm notions are relevant and how consistency of dynamics can be guaranteed.
The following notions constitute Paradigm’s basic concepts: state-transition dia- gram, phase, (connecting) trap, partition and global process.

A state-transition diagram or STD is a triple ⟨ST, AC, TS⟩. Here, ST is the set of states, AC the set of actions and TS ⊆ ST × AC × ST is the set of transitions. A transition (x, a, x') ∈ TS is said to be from state x to state x' and is denoted by
x →a x'.
A subprocess or phase of an STD ⟨ST, AC, TS⟩ is an STD ⟨st, ac, ts⟩ such that
st ⊆ ST, ac ⊆ AC and ts ⊆{ (x, a, x') ∈ TS | x, x' ∈ st,a ∈ ac }.
A trap t of a phase S = ⟨st, ac, ts⟩ is a non-empty set of states t ⊆ st such that
x ∈ t and x →a x' ∈ ts imply that x' ∈ t. A trap connects the phase S it belongs

to with another phase S' = ⟨st', ac', ts'⟩ if t ⊆ st', notation S →t
S'.

A partition { (Si, Ti) | i ∈ I } of an STD ⟨ST, AC, TS⟩, I a finite index set, is a set of phases Si = ⟨sti, aci, tsi⟩, each with a set Ti of its traps.
A global process or global STD at the level of a partition π = { (Si, Ti) | i ∈ I } of an STD Z = ⟨ST, AC, TS⟩ is an STD Z(π)= ⟨S^T, A^C, T^S⟩ with S^T ⊆ { Si | i ∈ I },
A^C ⊆  i∈I Ti and T^S ⊆ { Si → Sj | i, j ∈ I, t ∈ A^C } a set of phase changes. Z is
called the detailed STD of the global STD Z(π).





Client−i




Without
3 phases of each Client−i		partition CS: Without

triv




Interrupt



With
Interrupt



With


notYet





done

request







Fig. 1. (a) STD, (b) phase and (c) trap constraints and partition.

An STD is a step-wise description, from state to state, of the dynamics belonging to some component. Often it is visualized as a directed graph, where nodes are states and action-labeled edges are transitions. The initial state of an STD is graphically indicated by a black dot-and-arrow. Figure 1a gives an example STD Clienti in and around a shop. The entire system we consider later, contains n such clients with the same dynamics each (as well as other components).
The meaning of states and actions should be self-explanatory. The overall re- quirement is that only one client at a time, out of all n clients, is allowed to be in its state Busy. So, being in state Busy is a Critical Section problem (CS for later use). To solve it, Clienti dynamics is constrained by the phase prescribed. Figure 1b visualizes the phases Without, Interrupt and With. Phase Without excludes being in state Busy by prohibiting to take the (steps labeled with) actions explain and thank. Contrarily, phase With allows both, going to and leaving state Busy. Finally, phase Interrupt is an interrupted form of Without, as action enter cannot be taken, but

being in state Waiting is allowed, though.
In view of a change of the current phase into a next phase to take place, enough progress within the current phase must have been made; a connecting trap has to be entered first. Figure 1c pictures relevant connecting traps for the above three phases, drawn as polygons around the states the trap consists of. In particular we need, trap triv to be connecting from Without to Interrupt, trap notYet to be connecting from Interrupt back to Without, trap request to be connecting from Interrupt forward to With and finally, trap done to be connecting from With back to Without. In this manner, Figure 1c gives all ingredients needed for the dynamics of a Clienti STD at the higher, more global level of these phases and their traps. The ingredients constitute a partition as well as a global STD Clienti(CS)– see Figure 2a. The two additional trivial traps, triv of Interrupt as well as triv of With, are not really needed for the higher level dynamics and are not drawn.

Client−i(CS)	... and its ACP−refinement







done







global STD Client−i(CS)	global STD Client−i(CS) in refined form

Fig. 2. (a) Global process and (b) refined global process.

Figure 2b presents a slightly refined diagram of the ‘official’ global STD. Here the state names keep track of the most recently entered trap within a current phase –as if it could be taken as a smaller phase committed to within the one currently imposed; action names similarly refer to the corresponding trap entering. As it will be pointed out below, the refined form of a global process serves its purpose for our PA translation.
So far, we have discussed the sequential composition of constraints: imposed phases alternated via traps committed to. Any current phase constrains the actions that can be selected to those belonging to the phase. As a consequence, at any moment, a current detailed state should belong to the current phase too. From this, consistent dynamics of the detailed STD and of the global STD follows.
Paradigm’s consistency rules are to the essence of synchronizing composition. They specify the combination of detailed behaviour of a so-called manager and global behaviours of arbitrarily many so-called employees. Any consistency rule describes a simultaneous execution of a step of the manager, and a global step of each of the employees.
Figure 3 presents an overview of a Paradigm model as a liberal mixture of UML’s object, composite structure and collaboration diagrams: a general collaboration at the left, the CS collaboration at the right. The elements called Clienti are employee




	
. . .	. . .


Fig. 3. Impression of Paradigm’s architecture: (a) general, (b) CS example.
components of collaboration CS. As employees, they contribute their dynamics to the collaboration, not directly but via the global STDs Clienti(CS) serving as roles. The suitably synchronized roles together are the protocol, whose dynamics is driven by one or more managers, exactly one manager for each step. The consistency rules specify the protocol dynamics in a consistent manner: Paradigm’s constraints express how single role dynamics and correspondingly single, detailed employee dynamics stay consistent. Syntactically, a consistency rule couples global steps from different global STDs, appearing at the right-hand side of the rule, as a list of phase changes, with the one detailed manager step at the left-hand side.
For our running examples, of n clients getting service, one at a time, we will consider two instantiations of the collaboration of a server with n clients, a non- deterministic and a round-robin one. The non-deterministic server checks the clients in an arbitrary order. If the client that is checked is ready to be served, it is served,
i.e. permitted to the critical section. If not, the client is refused. Only after finishing the serving of the particular client, the server returns into the idle position, where it can select any client for inspection again.
NDetServer



. . .


Fig. 4. STD non-deterministic manager NDetServer.
The STD of the nondeterministic server NDetServer comprises Figure 4. Being the manager, the detailed steps of NDetServer need to be coupled to phases of the Clients. This can be done as follows

NDetServer :	Idle  ch→ecki
NDCheckingi  ∗ Clienti(CS) : Without	t→riv
Interrupt

NDetServer : NDCheckingi	re→fuse
permit
Idle	∗ Clienti(CS) : Interrupt no→tYet
request
Without

NDetServer :  NDCheckingi	→	NDHelpingi	∗ Clienti(CS) : Interrupt
→	With

NDetServer :	NDHelpingi  con→tinue
Idle	∗ Clienti(CS) :	With  d→one	Without

where ‘∗’ separates a manager step from the global steps and 1 ≤ i ≤ n. Note, for this protocol, a manager step of the server corresponds to a phase change of exactly one client. E.g., the server moves from the state Idle to NDCheckingi iff the global

client process Clienti(CS) changes from the phase Without to the phase Interrupt. The server then makes a checki transition. In general, there is a precondition, however. Within the phase Without sufficient progress should have been made, such that the trap, in this case the trivial trap triv, has been reached. Here, the requirement is vacuous as the trivial trap, consisting of all states of the detailed STD, is trivially reached. For the actual checking, the two middle consistency rules above, dependent on the trap, viz. notYet vs. request, the target of the manager transition and the next employee phase is decided, viz. state Idle and phase Without or state NDHelpingi and phase With, respectively.
The consistency rules maintain horizontal consistency, in the present example between server and the clients. The constraint that a detailed transition of a client needs to be allowed by the current phase and the relevant trap, enforces verti- cal consistency of the employee, on the one hand, and its abstraction within the collaboration, on the other hand.
As a variation to the above example, we next consider round-robin access to service. Now, the server checks the clients in turn for a request for being served. Clients wait, if necessary, for being checked. The STD of the server RoRoServer is given in Figure 5.
The server acts, in our set-up, as the manager of the partition CS of which each client is an employee via their global process Clienti(CS). The consistency rules that synchronize the detailed steps of the server and the global phases of the clients are the following (implicitly counting modulo n and 1 ≤ i ≤ n):

RoRoServer : RRCheckingi
gr→ant RRHelping ∗ Clienti(CS) : Interrupt
req→uest With

RoRoServer : RRHelpingi
pro→ceed RRChecking	∗

Clienti(CS): With d→one
triv
Without,	Clienti+1 (CS) : Without
Interrupt

RoRoServer : RRChecking p→ass RRChecking	∗
Clienti(CS): Interrupt no→tYet Without,	Clienti+1(CS): Without t→riv Interrupt
Note the difference with the non-deterministic protocol. For instance, in the sec- ond consistency rule here, the synchronization between the server step proceed with the global step done of Clienti(CS) and the global step triv of Clienti+1(CS), exactly expresses the simultaneous events of Clienti leaving the critical section and Clienti+1 being interrupted to be checked. In contrast, in the previous non-deterministic case, analogous coordination is splitted in two consistency rules, viz. first a return of the server to idling after helping client i, followed by a check of the next client.


Fig. 5. STD round-robin manager RoRoServer.

Process algebra
Process Algebra (PA) is a formal method used for modeling and analyzing systems of concurrent processes. Basic ingredients of any PA are a set of operators, including constants, and a set of equations, also called axioms or laws, capturing dependencies between the operators. A PA is typically parameterized by a set of atomic actions A, the smallest activities that a process can perform. In a PA, the actions are con- sidered as constants. Other basic operators common to most process algebras are sequential composition ‘·’, non-deterministic choice ‘+’ and parallel composition ‘  ’. The process algebra ACP [2,4] we will consider here, has as additional operators, encapsulation ‘∂H ’ and abstraction ‘τI ’. The encapsulation operator ‘∂H ’ can be used to block actions from the set H ⊆ A, generally to avoid unmatched synchro- nization. The abstraction operator ‘τI ’ is used to hide observable actions that are part of the set of actions I, i.e. any action in I is considered internal and is renamed into τ , the special action denoting internal activity.
Processes are described by algebraic expressions, and relations between processes by equalities. Infinite processes can be expressed by recursive specifications. For instance, a process Clienti, considered in isolation, is described by the following recursive specification:
Outi =	enteri · Waitingi Waitingi = explaini · Busyi
Busyi = thanki · AtDoori AtDoori =	leavei · Outi
In the specification, the index i appears as a parameter that ranges over { 1,... ,n }. Note, process Clienti has sequential behaviour without any branching, therefore, non-deterministic choice does not occur in the description.
The behaviour of the parallel composition of two processes is obtained by in- terleaving the two separate behaviours. In addition, processes can communicate by synchronizing on certain actions. In ACP, action synchronization is user-defined by a so-called communication function. The communication function may involve two or more arguments, enabling multi-party synchronization. As we will discuss in Section 4, the synchronization by communication very naturally expresses the consistency rules in Paradigm. This will not come as a surprise, as they are both meant to express synchronization between some behaviours.
Higher level abstract behaviour is obtained by hiding activities, that are con- sidered internal. These actions will subsequently be ignored in the further compu- tations (to a large extent). For instance, the more abstract behaviour of process Client shown in Figure 2a. can easily be obtained from the more detailed behaviour of the process in Figure 2b, by abstracting away the following events: action done between states With[triv] and With[done], action notYet between Interrupt[triv] and Interrupt[notYet] and similar for the action request. The abstract behaviour is ob- tained, first, by renaming these actions into the special action τ , and then manip- ulating the specification by means of some algebraic laws that allow removing of some τ events from the specification.

As elaborated below, process algebraic descriptions of Paradigm models help us to ‘observe’ the dynamics at a more detailed level. While in Paradigm, for instance, the mechanism by which one phase imposes constraints on the detailed STD dynamics is implicit, in process algebra this has to be explicitly specified. In fact it is defined as a synchronization of the two behaviours by which certain information is exchanged, in this particular case, an allowance or disallowance to make certain steps.
Once all components that build the Paradigm model are translated into pro- cess algebra, in principle, the complete behaviour can be computed. Furthermore, various verification techniques can be applied to the system obtained. A widely accepted technique for verifying properties of a system, which we use as well below, is model-checking. In short, once the model is obtained in the form of an STD, a modal formula can be checked against the model of the system. For instance, one can verify if the property “at any moment there is at most one client in the crit- ical section” holds for the system. Usually, the model that describes the complete system is very large and it is beyond human capabilities to reason about it with- out computer assistance. Fortunately, many efficient tools have been developed to support the analysis, in particular automated tools providing model-checking. For our experiments, we have used the toolset mCRL2 [10,11]. 3 Its formal specification language mCRL2 is based on ACP, together with facilities for abstract datatypes and the method of parameterized boolean equation systems (PBES) for symbolic model-checking purposes.

Two example models translated into ACP
In this section, the various STDs from the example Paradigm models introduced earlier, will be translated into ACP processes. In particular, each STD will be interpreted as a set of recursively defined processes, extended with specific commu- nication details. For the communication of a detailed STD and the global STD, we use actions ok?(.) and ok!(.) that take the labels of detailed steps as their argument. The complementary actions synchronize if the step to be taken by the detailed STD is allowed by the current phase as constraint. In addition, we use the actions at?(.) and at!(.) to signal the current state from detailed STD to global STD. Upon syn- chronization of these actions, the global process will update its trap information. For the communication within the protocol, e.g. between the server and its clients, actions man(.) on the side of a manager are meant to complement emp(.) actions on the side of the employees. Synchronization leads to execution of the corresponding consistency rule: a local transition of the manager, phase changes for the employees involved.
For the two concrete examples this yields the following. We adorn the n processes


3 Available from http://www.mcrl2.org .

Clienti with state actions at! and transition actions ok?.
Outi =		at!(Outi) . Outi	+	ok?(enteri) . Waitingi Waitingi =	at!(Waitingi) . Waitingi + ok?(explaini) . Busyi
Busyi =	ok?(thanki) . AtDoori
AtDoori =	at!(AtDoori) . AtDoori +	ok?(leavei) . Outi .
In a similar manner, the n processes Clienti(CS) are augmented with the actions at? and ok!. As these global processes are involved as employees in the protocol, the emp actions have been put in place as well. See Figure 1.
Withouti[triv] =	ok!(leavei) . Withouti[triv] + ok!(enteri) . Withouti[triv] +
emp(trivi) . Interrupti[triv]
Interrupti[triv] =	at?(AtDoori) . Interrupti[notYet] + at?(Outi) . Interrupti[notYet] +
at?(Waitingi) . Interrupti[request] + ok!(leavei) . Interrupti[triv] Interrupti[notYet] =		ok!(leavei) . Interrupti[notYet] + emp(notYeti) . Withouti[triv] Interrupti[request] =	emp(requesti) . Withi[triv]
Withi[triv] =	at?(AtDoor)i . Withi[done] + ok!(explaini) . Withi[triv] +
ok!(thanki) . Withi[triv] Withi[done] =	emp(donei) . Withouti[triv] .
The nondeterministic NDetServer STD is defined by the following specification:

Idle =	Σn
man(checki) . NDCheckingi

NDCheckingi =	man(permiti) . NDHelpingi	+ man(refusei) . Idle
NDHelpingi =	man(continuei) . Idle .
See also Figure 4. For the communication function ‘|’ we put
at!(s) | at?(s)= at(s)	and	ok?(a) | ok!(a)= ok(a),
for s = Outi, Waitingi, AtDoori, and a = enteri, explaini, thanki, leavei. Note, ACP allows for keeping the resulting action of a synchronization observable, useful for verification. Moreover, in the case of the protocol driven by NDetServer, we assume


man(checki) | emp(trivi) = checki
man(permiti) | emp(requesti) = permiti
man(refusei) | emp(notYeti) = refusei
man(continuei) | emp(donei) = continuei .

All actions from the set H = { man, emp, at?, at!, ok?, ok! } need to be blocked to enforce communication. Finally, the collaboration process is given as
CSNDet = ∂H (Client1  Client1(CS)  ...  Clientn  Clientn(CS)  NDetServer) .

For the round-robin case, the translations of the Clienti STDs remain the same. The translation of the global STD Clienti(CS) changes slightly only. We simply adapt Client1(CS), the global process of the first client. This is because this global STD will start in phase Interrupt. More specifically, its starting state is Interrupt[triv].
Client1(CS)= Interrupti[triv]	and	Clientk (CS)= Withouti[triv]	for k ≥ 1
The STD of RoRoServer does have a rather different translation however, reflecting

the different character of the protocol. See Figure 5.
RRCheckingj =	man(grantj ) . RRHelpingj + man(passj ) . RRCheckingj+1
RRHelpingj =	man(proceedj ) . RRCheckingj+1 .
The communication function for the round-robin protocol is defined as
man(granti) | emp(requesti) = granti
man(proceedi) | emp(donei)	= proceedi
man(passi) | emp(notYeti) | emp(trivi+1)  = passi .
The set of blocked actions is now defined as H' = { man, emp, at?, at!, ok?, ok!}. The complete collaborative process for the round-robin protocol is defined by
CSRoRo = ∂H' (Client1  Client1(CS)  ...  Clientn  Clientn(CS)  RoRoServer).

Translation of ACP-based specifications into the input language of the mCRL2 toolset of the n clients Clienti, the global Clienti(CS) and the servers NDetServer and RoRoServer is largely straightforward. In the appendix, the mCRL2 specifications of the collaborative processes for three clients are given. Similarities with the ACP specifications are obvious. From these specifications the tool generates correspond- ing transition systems. For four clients the entire state space for the round-robin protocol consists of 1080 states and 3456 transitions. However, if we abstract from internal communications and focus on entrance and exit of the critical section, it can be reduced to 77 states with 204 transitions only using branching bisimulation. More generally, we found in the round-robin case, for n clients (n ≥ 2) the number of states can be reduced to (5·2n−2−1)·n + 1.
We consider the following properties for the two protocols, where we assume clients Clienti and Clientj for i /= j:
At any moment of time at most one client will be given service. In other words, never two (or more) clients, will be in the critical section at the same time. In μ-calculus, the property specification language of mCRL2, it is expressed as
[ true*.ok(explaini).(!ok(thanki))*.ok(explainj) ] false
A sequence of actions in which ok(explaini) appears and at some later point ok(explainj) and no action ok(thanki) appears in between is impossible. Clearly, we use ok(explaini) and ok(thanki) to detect entering and leaving the critical sec- tion. For further details we refer to [5].
At any moment of time the server will not permit two different clients to be served. In other words, two or more clients will be not allowed to access the critical section at the same time. Obviously, this corresponds to the previous property, only seen from the server perspective. In μ-calculus, for RoRoServer (and similar for NDetServer) it is expressed as:
[ true*.granti.(!proceedi)*.grantj ] false
Two clients may request access to the critical section at the same time. In other words, more than one client can be in state Waiting in the detailed STD. Again,

using the action transition of the underlying detailed STD, we can express this property by the following μ-calculus formula:
< true*.ok(enteri).(!ok(thanki))*.ok(enterj) > true
There is a sequence of actions in which an occurrence of action ok(enteri) is followed (not necessarily in a consecutive way) by ok(enterj ) before any occurrence of action ok(thanki).
Under the usual strong fairness assumption, every client who requested a service, eventually gets served, i.e. enters the critical section. The corresponding formula is:
[ true*.ok(enteri).(!ok(explaini))* ] < true*.ok(explaini) > true
Once a client requires service, she will be allowed access, under the assumption that any loop that does not contain this action will be eventually left.
Every client who requested service will be eventually served, without further assumption. It is expressed by the following formula:
[ true* .	ok(enteri) ] mu X . [ !ok(explaini) ] X
As expected, the first four properties are valid for the non-deterministic server, while the fifth one is not, because the NDetServer does not guarantee general access to the critical section. This is clear from the specification, as the NDetServer can always ignore a client, even if it has requested a service. On the other hand, all five properties are valid for the round-robin protocol.

Embedding Paradigm in ACP
Based on the two example translations presented above, we proceed by formulat- ing how to express a general Paradigm model in ACP. For clarity, we restrict to the hierarchal case where a component in a collaboration is either a manager or an employee [8]. However, employees are allowed to have multiple roles address- ing different managers. Furthermore, for ease of presentation, we assume action- determinism, i.e. that any two different transitions have different actions. This way, a transition is identified by its label.
Employees synchronize their detailed behaviour with the global behaviour, while the global behaviour is governed by the consistency rules. The behaviour of a manager is connected to that of the employees by means of the consistency rules as well. The process algebraic translation of an employee contains ‘informing’ and ‘performing’ elements. To clarify this dual nature, in Figure 6 we repeat essential fragments from the architectural impression from Figure 3, additionally decorated with communication actions. The ‘informing’ in the process for one employee is modeled by the action at. It keeps the process unchanged, thus informing about the original STD state towards one performing role. In addition, ‘performing’ by an employee is modeled by the action ok, with relevant argument.
We need a refined form of the original global STDs, as in Figure 2b. After such a role process has been informed about the current state of the detailed STD and has




at!, ok?

at?, ok!
Role




Fig. 6. Process interaction: (a) sequential, (b) synchronized.

concluded that a new trap has been entered (without changing the current phase yet), it stores this information as it were, by making a step to the next refined global state: with the same phase as before, but with the inner trap replacing the trap entered so far.
An employee Z in Paradigm has a number of roles, R1 to Rn say. In each role we distinguish phases pij,1 ≤ i ≤ n,1 ≤ j ≤ ni. For each state s, we define a recursive equation in ACP as follows:
Zs = at!(s).Zs + Σ a ' ok?(a).Zs' .
s → s
For a phase p in a role Ri of the employee Z, we define a system of recursive equations p[t], indexed by the traps t in the phase p.

p[t] = Σ	'
at?(s).p[t']+ Σ a  '
oki(a).p[t]+ 

Σ{ crγ(a, t1,... , t,... , tm).p'[triv] |

γ : s →a
s' ∗ p1
→t1 p' , ... , p →t
p', ... , pm
→tm p' }.

Thus, the detailed STD is willing to communicate its state information to every partition; a partition only synchronizes via at?(s) if s is in an inner trap t' of the current trap t. The communication function satisfies at!(s) | at?(s)= τ for s ∈ Z.
A transition s →a s' in the detailed STD can only be made if allowed by all the
partitions. Therefore, the single ok?(a) of As should be matched by all oki(a) in any of the phases p[t], t a trap of p, p a phase of Pi, 1 ≤ i ≤ n. In this case, synchronization is amongst n + 1 parties, the detailed STD and its n partitions. We put ok?(a) | ok1(a) | ··· | okn(a) = τ . The last part of the equation for the phase/trap process p[t], chooses from all consistency rules γ that involve the trap t of the phase p. If the consistency rule is fired, the phase p' is entered in the partition Pi. As there is no specific state information, the trivial trap triv is assumed. Synchronization and communication function are to be discussed below. The process expression for a manager Z is simpler, as there is no interaction with its possible roles. However, all transitions made by the manager should match a consistency rule for the particular collaboration. For a state s ∈ Z, we now have
the recursive equation

Z  = Σ{ cr (a, t ,... ,t  ).Z ' | γ: s a
s' ∗ p
t1 p' , ... , p
tm p' }.

s	γ	1	m	s	→
1 →  1
m → m

So, in the collaboration, apart from the manager Z, m employees are involved. For a consistency rule γ to apply, Z must have reached state s, while the employees must have reached the traps t1,... , tm, respectively. Therefore, for the communication

function we require that m+1 copies of the same communication action synchronize,
crγ(a, t1,... , tm) | crγ(a, t1,... , tm) | ··· | crγ(a, t1,... , tm)= τ.

From the above general translation outline one can see, that and how more compli- cated Paradigm models can be dealt with. More than one manager per protocol just has, at the time, at most one cr action of one of the managers, synchronized with the relevant combination of cr actions from different processes for different roles, possibly driven differently.

Conclusions
In this paper we have linked the coordination modeling language Paradigm via the process algebra ACP with the mCRL2 toolset, enabling systematic translation of Paradigm models into ACP and subsequent tool supported verification of their correctness. Each Paradigm STD, detailed or global, is described as a recursive specification. Thus, separate specifications exist for each global and detailed STD, managers included. The composed pair of a detailed and corresponding global rep- resentation (an employee and one role of it) has specific interaction, guaranteeing consistent progress of combined dynamics. The interaction of global dynamics of the coordinated components, driven by a manager process, is described in Paradigm by the consistency rules. Therefore, in the translation, the consistency rules are captured by the communication function. Thus, all interaction between Paradigm STDs, either explicitly described (consistency rules) or implicitly, is flattened: rep- resented, after the process algebraic translation, by a single communication pattern indeed, loosing its architectural level characteristics.
As various verification techniques can be applied to a process algebraic specifica- tion, via the translation, correctness of Paradigm models can now be analyzed. For our experiments, we have used the mCRL2 toolset, which is closely related to the ACP process algebra. The ACP specifications for both examples of the non-deterministic and round-robin protocols, have been analyzed with the tool. mCRL2 has generated automatically the complete state spaces for further inspection. We have run the model-checker and checked several properties of interest. The results confirmed correctness of the Paradigm models. It is noted, the translation into ACP, although introducing explicit exchange of state and step information, provides a semantical definition by itself.
In addition to confirming the correctness of a Paradigm model by means of model checking its PA translation, counterexamples found by the model checker can be translated back into the Paradigm setting too. The generated trace refuting the property under consideration, can be reconstructed at the level of Paradigm. We present an outline of such inverse translation here: When mapping to PA, each Paradigm model is eventually translated into a collaboration process ∂H (...  ... 
.. .), a parallel composition of constituent processes specified as explained above. In fact, each such constituent process uniquely corresponds to a Paradigm STD. Moreover, the dynamics of one such STD –sequences of transitions– correspond to

rather similar sequences of atomic actions taken according to that process’ specifica- tion, interspersed additionally with communication actions at?(), at!(), ok!(). The similarity of both types of sequences lies in the property of preserving the original step order –the STD dynamics– per constituent process from the PA translation; that is, adorned with a communication indicator ok? in case of an employee step, adorned with a communication indicator emp in case of a non-refined global STD step, or adorned with a communication indicator man in case of a manager step. Note, the latter three communication actions ok?(), emp(), man() do correspond one-to-one to a Paradigm STD transition; the former three communication actions at?(), at!(), ok!() are extra, needed for technical PA reasons.
So, a particular counterexample can be traced back to the particular composition of similar sequences of steps per STD, to clarify where in the original Paradigm model the problem occurs. On the basis of Paradigm’s semantics, formulated in the product space spanned by the STDs of the various Paradigm processes (cf. the appendix in [7]), the reason of the problem occurring then is visible. As is to be expected, understanding why the Paradigm model didn’t satisfy a particular property, while it was designed to do so, remains the task of the modeler. In the Paradigm domain, faulty or insufficient communication is being mirrored in terms of wrongly chosen phases (at?, at! communication) or traps (ok?, ok! communication) or consistency rules (emp, man communication).
Last but not least, we did some verification based on equivalence checking, as supported by the mCRL2 toolset. Experiments with branching bisimulation reduc- tion yielded substantial reductions of the state spaces. In particular, for the non- deterministic protocol, we obtain a very simple structure after reduction. However, due to interleaving of internal activity, for the round-robin protocol a minimal model remains rather complex. In our future work we will investigate how further simpli- fication can be achieved. To that aim, we want to formulate suitable process equiv- alences, possibly depending on Paradigm’s architectural structure. Other future work is to extend the translation presented here, to Paradigm’s approach towards self-adaptation, based on lazily defined coordination of migration. Verification of such self-adaptive systems then should be straightforward.

References
R.J. Allen. A Formal Approach to Software Architectures. PhD thesis, Carnegie Mellon University, 1997.
J.C.M. Baeten and W.P. Weijland. Process Algebra. CUP, 1990.
M.A. Barbosa and L.S. Barbosa. An orchestrator for dynamic interconnection of software components. In G. Boella et al., editor, Proc. CoOrg 2006 and MTCoord 2006, pages 49–61. ENTCS 181, 2007.
J.A. Bergstra, A. Ponse, and S.A. Smolka. Handbook of Process Algebra. Elsevier, 2001.
J. Bradfield and C. Stirling. Modal mu-calculi. In Handbook of Modal Logic, pages 721–756. Elsevier, 2007.
G. Engels, R. Heckel, J.M. Ku¨ster, and L. Groenewegen. Consistency-preserving model evolution through transformations. In J.-M. J´ez´equel, H. Hußmann, and S. Cook, editors, Proc. UML 2002, pages 212–226. LNCS 2460, 2002.


L. Groenewegen, A. Stam, P. Toussaint, and E. de Vink. Paradigm as organization-oriented coordination language. In L. van de Torre and G. Boella, editors, Proc. CoOrg 2005, pages 93–113. ENTCS 150(3), 2005.
L. Groenewegen and E. de Vink. Operational semantics for coordination in Paradigm. In F. Arbab and C. Talcott, editors, Proc. Coordination 2002, pages 191–206. LNCS 2315, 2002.
L. Groenewegen and E. de Vink. Evolution-on-the-fly with Paradigm. In P. Ciancarini and H. Wiklicky, editors, Proc. Coordination 2006, pages 97–112. LNCS 4038, 2006.
J.F. Groote and M.A. Reniers. Handbook of Process Algebra, chapter 17, Algebraic Process Verification, pages 1151–1208. Elsevier, 2001.
J.F. Groote et al. The formal specification language mCRL2. In E. Brinksma et al., editor, Methods for Modelling Software Systems. IBFI, Schloss Dagstuhl, 2007. 34 pages.
J.M. Ku¨ster. Consistency Management of Object-Oriented Behavioral Models. PhD thesis, University of Paderborn, 2004.
M. M¨oller, E.-R. Olderog, H. Rasch, and H. Wehrheim. Integrating a formal method into a software engineering process with UML and Java. Formal Aspects of Computing, pages 161–204, 2008.
M.A. P´erez-Toledano, A. Navasa, J.M. Murillo, and C. Canal. TITAN: a framework for aspect-oriented system evolution. In Proc. ICSEA 2007, Cap Esterel. IEEE, 2007. 8 pages.
P. Poizat and J.-C. Royer. A formal architectural description language based on symbolic transition systems and modal logic. Journal of Universal Computer Science, 12:1741–1782, 2006.
N.F. Rodrigues and L.S. Barbosa. Architectural prototyping: From CCS to .Net. In A. Mota and A.V. Moura, editors, Proc. SBMF 2004, pages 151–167. ENTCS 130, 2005.
M. Sirjani, A. Movaghar, A. Shali, and F.S. de Boer. Modeling and verification of reactive systems using Rebeca. Fundamenta Informaticae, 63:385–410, 2004.

mCRL2 code of the NDet-server example
%% model with non-deterministic server for 3 clients sort
STran = struct check | permit | refuse | continue ;
CName = struct A | B | C ;
CStat = struct out | waiting | busy | atdoor ; CTran = struct enter | explain | thank | leave ; CTrap = struct triv | notyet | request | done ;
act
ati, ato, at : CName # CStat ; oki, oko, ok : CName # CTran ;
man, emp, sync : STran # CName # CTrap ;
proc
%% detailed server process ServerIdle = sum i:CName .
man(check,i,triv) . ServerChecking(i); ServerChecking(i:CName) =
man(refuse,i,notyet).ServerIdle + man(permit,i,request) . ServerHelping(i);
ServerHelping(i:CName) = man(continue,i,done) . ServerIdle;
%% detailed client process ClientOut(i:CName) =
ato(i,out).ClientOut(i) + oki(i,enter).ClientWaiting(i) ;
ClientWaiting(i:CName) = ato(i,waiting).ClientWaiting(i) + oki(i,explain).ClientBusy(i) ;
ClientBusy(i:CName) = ato(i,busy).ClientBusy(i) + oki(i,thank).ClientAtDoor(i) ;
ClientAtDoor(i:CName) = ato(i,atdoor).ClientAtDoor(i) + oki(i,leave).ClientOut(i) ;
%% global client process for partition CSM ClientCSMWithoutTriv(i:CName) =


oko(i,leave).ClientCSMWithoutTriv(i) + oko(i,enter).ClientCSMWithoutTriv(i) + emp(check,i,triv).ClientCSMInterruptTriv(i);
ClientCSMInterruptTriv(i:CName) = ati(i,out).ClientCSMInterruptNotYet(i) + ati(i,atdoor).ClientCSMInterruptNotYet(i) + ati(i,waiting).ClientCSMInterruptRequest(i);
ClientCSMInterruptNotYet(i:CName) = oko(i,leave).ClientCSMInterruptNotYet(i) + emp(refuse,i,notyet).ClientCSMWithoutTriv(i);
ClientCSMInterruptRequest(i:CName) = emp(permit,i,request).ClientCSMWithTriv(i);
ClientCSMWithTriv(i:CName) = ati(i,atdoor).ClientCSMWithDone(i) + oko(i,explain).ClientCSMWithTriv(i) + oko(i,thank).ClientCSMWithTriv(i);
ClientCSMWithDone(i:CName) = emp(continue,i,done).ClientCSMWithoutTriv(i);
init
allow(
{ at, ok, sync }, comm(
{ ati|ato -> at, oki|oko -> ok, man|emp -> sync },
ServerIdle ||
ClientOut(A) || ClientCSMWithoutTriv(A) || ClientOut(B) || ClientCSMWithoutTriv(B) || ClientOut(C) || ClientCSMWithoutTriv(C)
));


mCRL2 code of the RoRo-server example
%% model with round-robin server for 3 clients sort
CStat = struct Out | Waiting | Busy | AtDoor ; CTran = struct enter | explain | thank | leave ; CTrap = struct triv | notyet | request | done ;
sort
CN = struct A | B | C ;
map next : CN -> CN ; eqn
next(A) = B ; next(B) = C ; next(C) = A ;
sort
STran = struct grant | proceed | pass;
act
ati, ato, at : CN # CStat ; oki, oko, ok : CN # CTran ;
man3, emp3, sync3 : STran # CN # CTrap ;
man5, emp5, sync5 : STran # CN # CTrap # CN # CTrap ;
proc
%% detailed server process RRServerChecking(i:CN) =
man3(grant,i,request) . RRServerHelping(i) + man5(pass,i,notyet,next(i),triv) . RRServerChecking(next(i)) ;
RRServerHelping(i:CN) =
man5(proceed,i,done,next(i),triv) . RRServerChecking(next(i)) ;
%% detailed client process ClientOut(i:CN) =
ato(i,Out) . ClientOut(i) + oki(i,enter) . ClientWaiting(i) ;
ClientWaiting(i:CN) =
ato(i,Waiting) . ClientWaiting(i) + oki(i,explain) . ClientBusy(i) ;
ClientBusy(i:CN) =
ato(i,Busy) . ClientBusy(i) + oki(i,thank) . ClientAtDoor(i) ;
ClientAtDoor(i:CN) =
ato(i,AtDoor) . ClientAtDoor(i) + oki(i,leave) . ClientOut(i) ;



%% global client process for partition RR ClientRRWithoutTriv(i:CN) =
oko(i,leave) . ClientRRWithoutTriv(i) + oko(i,enter) . ClientRRWithoutTriv(i) + sum i’:CN,t’:CTrap .
emp5(proceed,i’,t’,i,triv) . ClientRRInterruptTriv(i); ClientRRInterruptTriv(i:CN) =
oko(i,leave) . ClientRRInterruptTriv(i) + ati(i,Out) . ClientRRInterruptNotYet(i) + ati(i,AtDoor) . ClientRRInterruptNotYet(i) + ati(i,Waiting) . ClientRRInterruptRequest(i);
ClientRRInterruptNotYet(i:CN) =
oko(i,leave) . ClientRRInterruptNotYet(i) + sum i’:CN,t’:CTrap .
emp5(pass,i,notyet,i’,t’) . ClientRRWithoutTriv(i); ClientRRInterruptRequest(i:CN) =
emp3(grant,i,request) . ClientRRWithTriv(i); ClientRRWithTriv(i:CN) =
ati(i,AtDoor) . ClientRRWithDone(i) + oko(i,explain) . ClientRRWithTriv(i) + oko(i,thank).ClientRRWithTriv(i);
ClientRRWithDone(i:CN) = sum i’:CN,t’:CTrap .
emp5(proceed,i,done,i’,t’) . ClientRRWithoutTriv(i);
init
allow(
{ at, ok, sync3, sync5 }, comm(
{ ati|ato -> at, oki|oko -> ok, man3|emp3 -> sync3,
man5|emp5|emp5 -> sync5 }, RRServerChecking(A) ||
ClientOut(A) || ClientRRInterruptTriv(A) || ClientOut(B) || ClientRRWithoutTriv(B) || ClientOut(C) || ClientRRWithoutTriv(C)
)));
