Cyber Security and Applications 1 (2023) 100007

		




PPT-LBS: Privacy-preserving top-k query scheme for outsourced data of location-based services
Yousheng Zhoua, Xia Li a,âˆ—, Ming Wangb, Yuanni Liua
a School of Cyber Security and Information Law, Chongqing University of Posts and Telecommunications, Chongqing 400065, China
b College of Computer Science and Technology, Chongqing University of Posts and Telecommunications, Chongqing 400065, China


a r t i c l e	i n f o	a b s t r a c t

	

Keywords:
Privacy protection Location-based services Top-k query Outsourcing computing
Location-based service (LBS) is enjoying a great popularity with the fast growth of mobile Internet. As the volume of data increases dramatically, an increasing number of location service providers (LSPs) are moving LBS data to cloud platforms for benefit of affordability and stability. However, while cloud server provides convenience and stability, it also leads to data security and user privacy leakage. Aiming at the problems of insuï¬ƒcient privacy protection and ineï¬ƒcient query in the existing LBS data outsourcing schemes, this paper presents a novel privacy-preserving top-k query for outsourcing situations. Firstly, to ensure data security of LSP and privacy of the user, the enhanced asymmetric scalar-product preserving encryption and public key searchable encryption have been adopted to encrypt outsourced data and LBS query, which can effectively lower the computational cost and realize the privacy protection search. Secondly, an eï¬ƒcient and secure index structure is constructed by using a coded quadtree and the bloom filter, so that the cloud server can quickly locate the userâ€™s query region to improve retrieval eï¬ƒciency. Finally, the formal security analysis is given under the random oracle model, and the performance is evaluated by experiments which demonstrates that our scheme is preferable to existing schemes.





Introduction

Location-based service (LBS) has been used in many fields, such as military, medical treatment, emergency rescue, etc., due to the rapid popularity of mobile devices [1]. However, as the upsurge of LBS dataset, LBS dataâ€™s high storage and computation costs produce a heavy burden on location service providers (LSPs). The rapid development of cloud computing provides a new operation mode for LBS, that is, LSP up- loads a large amount of LBS data onto the cloud to process userâ€™s queries with its powerful computing power, which effectively reduces LSP cost. However, cloud computing brings data security and user privacy prob- lems while facilitating data computing and storage. In a traditional com- puting mode, the userâ€™s data is usually on the LSP-controlled or trusted platform for processing. Still, after outsourcing data to a cloud server (CS), the dataâ€™s physical control capability is handed over to the cloud. In the outsourcing environment, the CS is usually supposed to be â€œsemi- honestâ€, it will perform the userâ€™s query request honestly. Meanwhile, it also attempts to derive useful information from the userâ€™s query and the stored data [2â€“5]. Hence, LBS data secure storage and computation in an untrusted cloud environment have become a critical issue that needs to be resolved urgently.
To achieve the LBS systemâ€™s privacy protection in an outsourcing
environment, researchers present a series of location privacy protection

âˆ— Corresponding author.
E-mail address: s190802004@stu.cqupt.edu.cn (X. Li).
methods. Zeng et al. [6] presented a new search scheme based on en- hanced asymmetric scalar-product preserving encryption algorithm and encrypted inverted index technology to support generic LBS query over encrypted data for cloud environment. In this scheme, the user can spec- ify the geographical scope and search keywords. After searching, the CS returns the point of interest (POI) records which matches the given area and keywords. Yang et al. [7] presented a verifiable privacy pro- tection scheme for kNN query under road network environment based on Voronoi diagram, 2-Hop tag index, and some cryptographic prim- itive, which could simultaneously preserve the privacy of spatial data and kNN query, and verify the reliability of query results. Xie and Wang
[8] put forward an LBS privacy protection scheme based on attribute en- cryption of ciphertext policy (CP-ABE), which calculate and compare lo- cation distance for the authorized user without revealing its privacy. Zhu et al. [9,10], aiming at the privacy and eï¬ƒciency problems in the LBS range query service process, designed an LBS circle region and polygon region range query scheme with eï¬ƒcient privacy protection by using an improved homomorphic encryption algorithm, which can provide query service while ensuring the userâ€™s query privacy and the data confiden- tiality of LSP. However, the existing research on privacy protection for LBS data outsourcing mainly focuses on the geographic scope or interest keywords query and rarely supports top-k query. Besides, the retrieval algorithm of LBS data fails to protect the userâ€™s search mode.


https://doi.org/10.1016/j.csa.2022.100007
Received 19 April 2022; Received in revised form 10 June 2022; Accepted 18 August 2022
Available online 23 August 2022
2772-9184/Â© 2022 The Authors. Published by Elsevier B.V. on behalf of KeAi Communications Co., Ltd. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/)






Fig. 1. The system model.


Our contributions are outlined as follow:
Firstly, we present a top-k query scheme for LBS outsourced data. To protect the LBS data and userâ€™s query against the attacker, the en- hanced asymmetric scalar-product preserving encryption and public key searchable encryption are utilized to construct our secure query scheme while supporting accurate top-k search over the encrypted LBS data.
to study useful information from the userâ€™s query and stored LBS data. As with other related studies [2,3,6,7,9], LSP and user are assumed to be honest, and LSP and user do not conspire with CS to obtain other userâ€™s privacy. Therefore, to protect the LBS data and the userâ€™s query, our scheme achieves the following security objectives:
Confidentiality: The CS cannot understand any content of LBS data stored by LSP. The outsourced LBS data is encrypted to prevent the CS from obtaining any valid information from the data set.
Privacy: The userâ€™s query should be confidential to the CS since it contains private information, such as area and personal interest. To ensure that the userâ€™s query privacy is not disclosed, this paper encrypts the userâ€™s query request and submits it to CS in the form of a query trap- door, thus preventing CS from obtaining any useful information about the userâ€™s query.

Preliminaries

Some basics used in our scheme are introduced in this section, includ- ing bilinear pairing map, hard problem assumptions, and bloom filter.

Bilinear pairing map

ğ”¾ and ğ”¾ğ‘‡ are two ğ‘-order multiplication cyclic groups, with the gen- erator ğ‘” of ğ”¾. ğ‘’ âˆ¶ ğ”¾ Ã— ğ”¾ â†’ ğ”¾ğ‘‡ is a bilinear map, and it has the follow
properties:
Bilinearity: for any ğ‘¥, ğ‘¦ âˆˆ â„¤âˆ—, there is ğ‘’(ğ‘”ğ‘¥, ğ‘”ğ‘¦) = ğ‘’(ğ‘”, ğ‘”)ğ‘¥ğ‘¦.

Secondly, we construct a secure index structure based on coded
quadtree and bloom filter, which enables the CS to fast locate the userâ€™s
Non-degenerate:
ğ‘
ğ‘’(ğ‘”, ğ‘”) â‰  1.

query region with the userâ€™s query request, thereby improving the re- trieval eï¬ƒciency.
Lastly, we conduct formal security proof and experiments based performance analysis, which exhibit that our presented scheme is secure and eï¬ƒcient.
Organization. The remainder of our thesis is organized as follows. Section 2 introduces the system model and design goals. In Section 3, we give some preliminaries. Then, the detailed construction of the proposed scheme is illustrated in Section 4. The security analysis and performance evaluation are demonstrated in Section 5 and Section 6, respectively. Finally, the paper is concluded in Section 7.
Problem formulations
(PPT)    algorithm    to    evaluate    ğ‘’(ğ‘”,   ğ‘”). (3) Computability: there exists a probabilistic polynomial-time

Hard problem assumptions

that there is a ğ‘-order group ğ”¾ and a generator ğ‘”. Provided with Decisional Bilinear Diffie-Hellman (DBDH) Assumption: Assume
ğ‘”ğ‘, ğ‘”ğ‘, ğ‘”ğ‘ âˆˆ ğ”¾, ğ‘ âˆˆ ğ”¾ğ‘‡ , where ğ‘, ğ‘, ğ‘ âˆˆ â„¤âˆ—, the DBDH problem is to de-
cide ğ‘ =? ğ‘’(ğ‘”, ğ‘”)ğ‘ğ‘ğ‘ .
m Decisional Linear (mDLIN) Problem: The mDLIN problem is a
order is ğ‘ and the generator is ğ‘”. Provided with ğ‘”ğ‘, ğ‘”ğ‘, ğ‘”ğ‘Ÿğ‘, ğ‘”ğ‘¡âˆ•ğ‘, ğ‘”ğ‘ , where variant of the DLIN problem. Assume that there is a group ğ”¾, where the
ğ‘, ğ‘, ğ‘Ÿ, ğ‘¡, ğ‘ are randomly chosen from â„¤âˆ—. mDLIN problem is to determine

System model

Our scheme aims to provide the user with secure and eï¬ƒcient query services while ensuring LBS data security and user query privacy. There are three entities: the location service provider (LSP), the cloud server(CS), and the LBS user, as shown in Fig. 1.
Location Service Provider (LSP): An LSP owns a large number of
LBS resources. It outsources massive LBS data to the CS to benefit from
cheap storage and reliable computation services. To guarantee LBS data confidentiality, each LBS data will be encrypted at first and then up- loaded to the cloud. Besides, LSP also provides registration service for the LBS user. Once the user passes registration, LSP sends an authenti- cation certificate and the key to the user via a secure communication channel.
Cloud Server (CS): CS has abundant storage and computing re-
sources, it is responsible for storing ciphertext data sets from LSP and
providing LBS query services for users.
ğ‘”ğ‘ =? ğ‘”ğ‘Ÿ+ğ‘¡ .

Bloom filter

the current set, the core is a bit array and ğ‘¡ independent hash function The bloom filter can easily determine whether an element belongs to
ğ»ğ‘– âˆ¶ {0, 1}âˆ— â†’ {1, 2, â€¦ , â€¦ , ğ‘š}, ğ‘– âˆˆ [1, ğ‘¡], the initial state of the values in the array is 0. Given a set ğ‘‹ = {ğ‘¥1 , ğ‘¥2 â‹¯ ğ‘¥ğ‘› }, select ğ‘¡ hash functions to
map each element to the bloom filter and set the bit position of each generated hash value to 1.
When verifying whether an certain element ğ‘¥ğ‘– , ğ‘– âˆˆ [1, ğ‘›] exists in the
set ğ‘‹, use ğ‘¡ hash function to map ğ‘¥ğ‘– to the bloom filter. If one of the corresponding positions is 0, then ğ‘¥ğ‘– must not belong to ğ‘‹.If each of these corresponding positions is 1, then maybe ğ‘¥ğ‘– is a member of ğ‘‹, as
shown in Fig. 2.
The error rate ğ‘ of the bloom filter is defined as:
âˆ’ğ‘¡ğ‘› ğ‘¡

LBS User: A LBS user first registers with LSP to obtain the key.
ğ‘ = 1 âˆ’ (ğ‘’ ğ‘š )
(1)

In order to protect privacy, the query requests of users are submitted to the CS in the way of trapdoor.
Design goals

In this paper, it is assumed that CS is â€œhonest but curiousâ€. In other words, it will execute the userâ€™s query request honestly, but it also tries
where ğ‘š is the length of bit array, ğ‘› denotes the size of ğ‘‹,and ğ‘¡ denotes
the amount of hash functions [3].

Construction of PPT-LBS

The concrete construction of our proposed scheme is described in this section. Our scheme is improved based on Zhao et al. [11], which




Fig. 3. Map devision.





Table 1
Fig. 2. Schematic diagram of bloom filter.
(1) The user randomly selects ğ‘¥ğ‘¢
ğ‘¥ğ‘¢, the public key is ğ‘ƒ ğ¾ğ‘¢ = ğ‘”ğ‘¥ğ‘¢ ;
âˆˆ â„¤âˆ— and sets its private key ğ‘†ğ¾ğ‘¢ =

Symbols definition.

Notations	Definition
M1 , M2	invertible matrix
ğ‘™	matrix dimension, set ğ‘™ = 80 in this scheme
ğ‘ âˆˆ {0, 1}ğ‘™	a bit string of length ğ‘™
((ğ‘¥, ğ‘¦), ğ‘¤)	one POI data
((ğ‘¥ğ‘¢, ğ‘¦ğ‘¢ ), ğ‘…)	the userâ€™s coordinate is ğ‘¥ğ‘¢ , ğ‘¦ğ‘¢  and the query radius is ğ‘…
ğ‘¤ğ‘	userâ€™s query keyword
ğ‘˜	the user want to query the number of POIs closest to his/her location
ğ‘„	the intersection region
â„œâˆ—	a set of all expanded code sequences




enables users can perform keyword query of POI and top-k query. For example, Alice wants to query the three restaurants closest to him/her within 500 m nearby. At the same time, under the premise of ensuring that her location and query keywords are not leaked, the CS returns the POI records that meet Aliceâ€™s conditions.
The proposed scheme is made up of eight phases: system initializa- tion, key generation, user registration, LBS data encryption, index con- struction, LBS query generation, LBS data retrieval, respectively. Sym- bols used are defined as in Table 1.

System setup

System setup is used to generate some public parameters, which are performed by LSP. With the following steps:
LSP selects two multiplication cyclic groups ğ”¾ and ğ”¾ğ‘‡ with the large prime order ğ‘. Let ğ‘” be a generator of ğ”¾ and a bilinear pairing map
The user calculates registration information ğ‘€ğ¼ğ·ğ‘¢ = ğ»0(ğ¼ğ·ğ‘¢),
and send it to the LSP for registration request;
sent by the user, LSP computes an authentication certificate ğ¶ğ‘¢ = (3) When the LSP receives the registration request message
ğ‘’((ğ‘€ğ¼ğ·ğ‘¢)ğ‘†ğ¾ğ¿ , ğ‘”) for the user and send the ğ‘˜ğ‘’ğ‘¦ to the user via secure
communication channel;
(4) LSP sends the ğ¶ğ‘¢ to the CS, which stores it in the user list for
subsequent user authentication.

LBS Data encryption
The POI data set stored in the LSP is represented as DB =
{ğ‘‘1, ğ‘‘2, â€¦ , ğ‘‘ğ‘›}. To be simple, use ğ‘‘ğ‘– = {(ğ‘¥, ğ‘¦), ğ‘¤} to represent one of POI record, where (ğ‘¥, ğ‘¦) means the coordinates of the POI, ğ‘¤ shows the key-
word of the POI(e.g., restaurants, hotels, bars, etc.). In order to ensure data confidentiality, LSP outsources data set DB to the CS in the form of ciphertext.
Coordinate Encryption
For POI coordinate (ğ‘¥, ğ‘¦), LSP generates an ğ‘™-dimensional vector pÌ‚, where the first three dimensions of data is (ğ‘¥, ğ‘¦, âˆ’0.5(ğ‘¥2 + ğ‘¦2)). For ğ‘— âˆˆ [4, ğ‘™], set pÌ‚[ğ‘—] = ğ›¼  . Then, pÌ‚ is split according to the bit string ğ‘ into two
ğ‘™ dimensional vector pÌ‚ğ‘ and pÌ‚ğ‘:
if ğ‘[ğ‘–] = 1, ğ‘– âˆˆ [1, ğ‘™], set pÌ‚ğ‘[ğ‘–] + pÌ‚ğ‘[ğ‘–] = pÌ‚[ğ‘–];
if ğ‘[ğ‘–] = 0, ğ‘– âˆˆ [1, ğ‘™], set pÌ‚ğ‘[ğ‘–] = pÌ‚ğ‘[ğ‘–] = pÌ‚[ğ‘–]. Calculate:Cğ‘ = M1ğ‘‡ pÌ‚ğ‘, Cğ‘ = M2ğ‘‡ pÌ‚ğ‘.
Output coordinat ciphertext: ğ¶ğ‘ğ‘œğ‘Ÿğ‘‘ = {Cğ‘, Cğ‘}.
Keyword Encryption
LSP randomly selects ğ‘Ÿ âˆˆ â„¤âˆ—, and derives the keywords ciphertext
ğ¶ğ‘¤ = {ğ¶ğ‘¤1 , ğ¶ğ‘¤2 }, where

ğ‘’ âˆ¶ ğ”¾ Ã— ğ”¾ â†’ ğ”¾ğ‘‡ ;
(2) LSP selects a one-way hash function ğ»
âˆ¶ {0, 1}âˆ— â†’ ğº and a hash
ğ¶ğ‘¤ = ğ»0(ğ‘¤)ğ‘†ğ¾
ğ¿ â‹… ğ‘”ğ‘Ÿ,	(2)

family with ğ‘¡ hash functions ğ» âˆ¶ {0 1}âˆ—
0
{1 2 â€¦ â€¦
}  âˆˆ [1 ],

ğ‘–	,
â†’	, ,
,	, ğ‘š , ğ‘–
, ğ‘¡

where ğ‘š denotes the size of the bloom filter, whose main function is
to map a bit string into the bloom filter vector.
LSP open public parameters ğ‘ğ‘ğ‘Ÿğ‘ğ‘š = {ğ”¾, ğ”¾ğ‘‡ , ğ‘”, ğ»0, ğ»ğ‘–}, ğ‘– âˆˆ [1, ğ‘¡].

Key generation

LSP selects two ğ‘™ Ã— ğ‘™ dimensions invertible matrix M1, M2, a bit string ğ‘ of length ğ‘™ and ğ‘™ âˆ’ 3 random number {ğ›¼ğ‘— }ğ‘—âˆˆ[1,ğ‘™âˆ’3]. Here the matrix dimension ğ‘™ should be big enough to resist brute force attacks, matrix dimensions are set ğ‘™ = 80;
ğ‘˜ğ‘’ğ‘¦ = {M1, M2, ğ‘, {ğ›¼ğ‘— }ğ‘—âˆˆ[1,ğ‘™âˆ’3]} is stored as a secure key in LSP,
which is used for user to generate trapdoor and decrypt data ;
LSP randomly chooses ğ‘¥ğ¿ âˆˆ â„¤âˆ— and sets its private key ğ‘†ğ¾ğ¿ = ğ‘¥ğ¿, the public key is ğ‘ƒ ğ¾ğ¿ = ğ‘”ğ‘¥ğ¿ .

User registration

When a new user join the LBS system, LSP registers the user at this phase.
ğ¶ğ‘¤2 = ğ‘ƒ ğ¾ğ‘¢ .	(3)
So far, a piece of POI ciphertext data ğ¶ğ‘‘ is represented as: ğ¶ğ‘‘ =
{ğ¶ğ‘ğ‘œğ‘Ÿğ‘‘ , ğ¶ğ‘¤}.
sented   as:   EDB   =   {ğ¶ğ‘‘   },  ğ‘–   âˆˆ   [1,  ğ‘›]. LSP encrypts all POI data in DB, and the ciphertext data set is repre-
The LSP uploads the ciphertext data set EDB to the CS.

Index construction

Binary coding of geographic data
LSP recursively divides the map into four regions until the number of POI stored in each subregion does not exceed a specified threshold. At the same time, LSP selects 00,01,10,11 to denote four regions, each of which can be represented by a bit string, as shown in Fig. 3.
For example, in Fig. 4, the entire region is divided into four subre- gions, encode as 00,01,10,11. The upper right subregion with the bit string â€œ01â€ is further divided into four subregions encoded as 0100, 0101, 0110, 0111, and the bit string â€œ0101â€ region is divided again, and so on so that each region is a unique bit string encode.





Fig. 4. Hierarchical coding of a region.


Coded quadtree index construction
The LSP uses a quadtree to store bit string and POI ciphertext data of the above-divided regions. In this coded quadtree index structure, the root node denotes the entire region, and each non-leaf node has 4 child nodes denoting four subregions. Non-leaf nodes store bit strings of each region, and leaf nodes store the ciphertext of POI within the
region. For a given POI data ğ‘‘, LSP first encrypts it to ğ¶ğ‘‘ , then find its
subregion encode, and finally adds it to the corresponding leaf node of
the subregion of the coded quadtree.
Take the example of inserting data in the region of the bit string as â€œ001001â€. It starts from the root node to search the data record pertain- ing to the subregions 00, 010, 01001, respectively. Afterwards, the data record is interjected into subregion 001001, as shown in Fig. 5.

LBS Query generation

An	LBS	userâ€™s	query	request	can	be	expressed	as:
{((ğ‘¥ğ‘¢, ğ‘¦ğ‘¢ ), ğ‘…), ğ‘¤ğ‘ , ğ‘˜}, where ((ğ‘¥ğ‘¢, ğ‘¦ğ‘¢ ), ğ‘…) is the userâ€™s current coor-







Fig. 6. Example of userâ€™s query.


Index trapdoor V ğµğ¹ generation
according to the current position ğ‘¥ğ‘¢ , ğ‘¦ğ‘¢  and the query radius ğ‘…, as First of all, the user computes the circular region as the query range
the userâ€™s query range and the subregions divided is expressed as ğ‘„ = shown in the shaded green part of Fig. 6. The intersecting region of
{ğ‘1 , ğ‘2 , â€¦ , ğ‘ğ‘˜ }, as shown in the blue shaded part of Fig. 6.
Once ğ‘„ is determined, i.e.,ğ‘„ = {ğ‘1 , ğ‘2 , â€¦ , ğ‘7 }, it can be expanded into a series of bit strings by listing all prefix substrings of ğ‘ğ‘– , ğ‘– âˆˆ [1, 7]
for every two neighbouring bits.
quence is represented as â„œğ‘–, â„œğ‘– = {11, 1111, 111101}. User combine the For instance, suppose a bit string is 111101, the extended code se- extended code sequence of all query subregions ğ‘ğ‘– (ğ‘– âˆˆ [1, ğ‘˜]) to get a set

dinates and the query radius, ğ‘¤ğ‘ is the userâ€™s query keyword, ğ‘˜ is user
ğ‘–=ğ‘˜
of code sequence, â„œâˆ— =	â„œğ‘–. For every bit string in â„œâˆ—, the user uses

want to query the number of POIs closest to his/her location. In the cloud-based LBS system, in order to prevent the private query being disclosed, the user will send the query in the form of trapdoor.
ğ‘–=1
ğ‘¡ hash functions ğ»ğ‘– âˆ¶ {0, 1} â†’ {1, 2 â€¦â€¦ ğ‘š}, ğ‘– âˆˆ [1, ğ‘¡] to hash each bit string sequence in â„œâˆ— to get an index trapdoor V ğµğ¹ .




Fig. 5. Example of data insertion.







Take an example in Fig. 7. Assume that the current coordinate of
to the query radius ğ‘…, which is represented as the green circular region, the user is (26, 81). The user first determines the query range according
which is represented as ğ‘„ = {ğ‘1, â€¦â€¦ , ğ‘5}. The bit string of the seven and its intersection with the subregion divided is the blue shaded part, subregions  is  â„œ={1100, 1101, 1110, 111100, 111101, 111110, 111111}.
The user then expands these bit strings into collections â„œâˆ— =
{11, 1100, 1101, 1110, 1111, 111100, 111101, 111110, 111111}.	Finally,
the user uses ğ‘¡ hash functions to hash all the bit strings in â„œâˆ— to obtain index trapdoor V ğµğ¹ =10101100101011. (2) Generation of coordinate
trapdoor
User randomly selects a positive integer ğœ†, computes the first 3 di- mensions of data (ğœ†ğ‘¥ğ‘¢ , ğœ†ğ‘¦ğ‘¢ , ğœ†). For ğ‘— âˆˆ [4, ğ‘™-1], set qÌ‚ [ğ‘—]=ğœ›ğ‘— (ğœ›ğ‘— is a ran-
dom number). For the last dimension, set q[ ] = âˆ’ âˆ‘ğ‘™âˆ’1 ğ›¼ğ‘–âˆ’3 ğœ›ğ‘– . Then, q is
Fig. 7. Example of range derivation.

Ì‚ ğ‘™
  ğ‘–=4		Ì‚
ğ›¼ğ‘–âˆ’3

split according to the bit string ğ‘ into two ğ‘™ dimensional data qÌ‚ğ‘ and qÌ‚ğ‘ :
if ğ‘[ğ‘–] = 0, ğ‘– âˆˆ [1, ğ‘™], set qÌ‚ğ‘ [ğ‘–] + qÌ‚ğ‘ [ğ‘–] = qÌ‚ [ğ‘–];
if ğ‘[ğ‘–] = 1, ğ‘– âˆˆ [1, ğ‘™], set qÌ‚ğ‘ [ğ‘–] = qÌ‚ğ‘ [ğ‘–] = qÌ‚ [ğ‘–]. Calculate:Tğ‘ = M1 âˆ’1 qÌ‚ğ‘ , Tğ‘ = M2 âˆ’1 qÌ‚ğ‘ . Output coordinat trapdoor: ğ‘‡ğ¿ = {Tğ‘, Tğ‘}.
(3) Generation of keyword trapdoor
Since the keyword searched by the user may expose sensitive infor- mation such as interests, hobbies, behavior habits, etc., the user needs





Fig. 8. Example of coordinate matching.



Coordinate matching

to encrypt the search keyword before sending the query request. User
first chooses their query keyword ğ‘¤ğ‘ , and then randomly choose ğ‘Ÿâ€² âˆˆ â„¤âˆ—
After receiving the V
ğµğ¹
in the query trapdoor from the user, CS uti-

to encrypt
ğ‘¤ğ‘ into ğ‘‡ğ‘¤ = {ğ‘‡ğ‘¤1 , ğ‘‡ğ‘¤2 , ğ‘‡ğ‘¤3 }, where
ğ‘	lizes it to search the coded quadtree. In the coded quadtree, each non-
leaf node is denoted by a bit string. CS examines if the mapping posi-

ğ‘‡	= ğ‘’(ğ» (ğ‘¤ )ğ‘†ğ¾ğ‘¢ , ğ‘ƒ ğ¾ ğ‘Ÿâ€² ),	(4)
tions of ğµğ‘– of the node are all â€œ1â€ in V ğµğ¹ . If it is, CS subsequently search

ğ‘¤1
ğ‘‡ğ‘¤2
ğ‘‡
0  ğ‘	ğ¿
= ğ‘”ğ‘Ÿâ€² ,	(5)
= ğ‘ƒ ğ¾ ğ‘Ÿâ€² .	(6)
on the search until all data in â„œâˆ— is hit, as shown in Fig. 8. CS stores down the encoding quadtree; otherwise, CS changes the branch to carry
these data in the temporary resource list (TRL) and then goes to step
; (2) Keyword matching
Verify whether data ğ‘‡ğ‘¤1 â‹… ğ‘’(ğ¶ğ‘¤2 , ğ‘‡ğ‘¤2 ) = ğ‘’(ğ¶ğ‘¤1 , ğ‘‡ğ‘¤3 ) in the TRL is es-

ğ‘¤3
ğ‘¢
The	user	sends	the	query	trapdoor	TRAPDOOR =
tablished. If it is established, it means that the POI record meets the userâ€™s query keyword, and go to step (3); otherwise, select the next POI

{ğ‘€ ğ¼ ğ·ğ‘¢, V ğµğ¹ , ğ‘‡ğ¿, ğ‘‡ğ‘¤, ğ‘˜} to the CS.
LBS Data retrieval

userâ€™s identity and determines whether the ğ¶ğ‘¢ = ğ‘’(ğ‘ƒ ğ¾ğ¿, ğ‘€ ğ¼ ğ·ğ‘¢ ) is estab- Once the CS receives TRAPDOOR from the user, it first verifies the
lished. If not, CS rejects the query; otherwise, CS searches user query. Specific steps are as follows:
record for matching;
top ğ‘˜POI closest
Suppose {ğ¶1ğ‘, ğ¶1ğ‘ } and {ğ¶2ğ‘, ğ¶2ğ‘} are the ciphertext data of the data
ğ‘ƒ ğ‘‚ğ¼ 1 and ğ‘ƒ ğ‘‚ğ¼ 2 respectively, {ğ‘‡ğ‘, ğ‘‡ğ‘} is the trapdoor of the user query. Determine whether (C1ğ‘ âˆ’ C2ğ‘ )Tğ‘ + (C1ğ‘ âˆ’ C2ğ‘ )Tğ‘ > 0 is true. If it is true, the ğ‘ƒ ğ‘‚ğ¼ 1 is closer to the user than the ğ‘ƒ ğ‘‚ğ¼ 2 .
the   first   ğ‘˜   encrypted   POI   to   the   user. Finally, CS performs distance comparison and sorting, and returns



User decryption
Trapdoor query Uğ‘‡ : A sends the keyword ğ‘¤ğ‘– to C for trapdoor

query and C retrieves ğ‘¤ , â„ , ğ›¼ , ğœ
from the list ğ¿
. If ğœ =0, it randomly

ğ‘–  ğ‘–
â€²
ğ‘–  ğ‘– âŸ©
ğ»	ğ‘–

User get ğ‘˜ specified POI ciphertext records from the CS, expressed as
{Cğ‘ğ‘– , Cğ‘ğ‘– }, ğ‘– âˆˆ [1, ğ‘˜]. For one of the POI ciphertext records, the user first
calculates:
pÌ‚ = ğœ‹ (Mğ‘‡ )âˆ’1 Ã— C ,	(7)
outputs a bit ğœ‡ âˆˆ {0,1} as its guess of ğœ‡. Otherwise, it randomly se- lects ğ‘Ÿğ‘– âˆˆ â„¤âˆ— and derives the trapdoor ğ‘‡ğ‘¤ = {ğ‘‡1 , ğ‘‡2 , ğ‘‡3 } = {ğ‘’(ğ‘”ğ›¼ğ‘– ğ‘ , ğ‘”ğ‘ğ‘Ÿğ‘– ) =
ğ‘’(ğ» (ğ‘¤ğ‘– )ğ‘, ğ‘”ğ‘ğ‘Ÿğ‘– ), ğ‘”ğ‘Ÿğ‘– , ğ‘”ğ‘ğ‘Ÿğ‘– }. C then returns ğ‘‡ğ‘¤ to A.
Challenge:
After polynomial queries, A sends two keywords ğ‘¤âˆ—, ğ‘¤âˆ— to C, which

0	1

pÌ‚ = ğœ‹ (Mğ‘‡ )âˆ’1
Ã— Cğ‘,	(8)
have not been queried to Uğ‘‡ nor Uğ¶ . Then, C performs the following
operations:

2	ï‚ C performs a Hash query on ğ‘¤âˆ—, ğ‘¤âˆ— respectively: ğ» (ğ‘¤âˆ—) =
0	1	0

where ğœ‹ğ‘‘ = (ğ¼ğ‘‘ , 0) is a 2 Ã— 80 matrix, ğ¼ğ‘‘ is a 2 Ã—2 identity matrix.
â„âˆ— and ğ» (ğ‘¤âˆ—) = â„âˆ—. ğ‘¤âˆ—, ğ‘¤âˆ— correspond to tuples âŸ¨ğ‘¤*, â„*, ğ›¼*, ğœ*âŸ© and

ğ‘	ğ‘	ğ‘¡
[ ] =	]	[
ğ‘œ	ğ‘
(
ğ‘
=  [2])
âŸ¨ğ‘¤*, â„*, ğ›¼*, ğœ*âŸ©, respectively. If ğœ*, ğœ* are both 1, C aborts the query and

randomly outputs ğœ‡ âˆˆ {0,1} as its guess of ğœ‡;
ï‚‚ If at least one of ğœ* and ğœ* is 0, set ğœ‡Ì‚ be the bit such that

Security analysis
0	1
* ğ‘

ğœâˆ— = 0. C computes the ciphertext ğ¶ âˆ— = (ğ¶ âˆ—, ğ¶ âˆ—) = (ğ‘Š â‹… (ğ‘”ğ›¼ğœ‡Ì‚ )
â‹… ğ‘”ğ‘˜ğ‘– , ğ‘”ğ‘ğ‘˜ğ‘– ).

ğœ‡Ì‚	1  2

Data confidentiality
If ğ‘Š = ğ‘”
ğ‘Ÿ+ğ‘¡
, then ğ¶ * = ğ‘”ğ‘Ÿ+ğ‘¡
â‹… ğ‘”
ğ‘ğ›¼*
ğœ‡Ì‚  ğ‘” ğ‘–	ğ‘”
(ğ‘Ÿ+ğ‘˜ğ‘– )+(ğ‘¡+ğ‘ğ›¼* )  *
2
ğ‘ğ‘˜
ğ‘– , where

For each LBS data, LSP outsources it to the CS in the form of ci- phertext. Specifically, for the coordinates of POI record, we use the enhanced ASPE algorithm [12] to encrypt it. In the known ciphertext model, if CS wants to get the real value of POI coordinates, it must re-
store two matrix M , M from the ciphertext and correctly guess the
ğ‘Ÿ + ğ‘˜ğ‘– is random in A perspective. If ğ‘Š is a random element of ğ”¾,
so is ğ¶ *. In addition, since ğ‘˜ğ‘– is a random ğ¶ * is also random in A
perspective.
More trapdoor queries:
A sends ğ‘¤Ìƒ to C for more trapdoor queries, where ğ‘¤Ìƒ â‰  ğ‘¤âˆ—, ğ‘¤Ìƒ â‰  ğ‘¤âˆ—

1	2	and C respond to the query as before.	0	1

bit string ğ‘. For CS, the equations used to determine the transformation
matrices are:Cğ‘ = Mğ‘‡ Ã— pÌ‚ğ‘ and Cğ‘ = Mğ‘‡ Ã— pÌ‚ğ‘ , where M1 and M2 are two
ğ‘™2
Guess:
A outputs its guess ğœ‡Ì‚â€² âˆˆ {0, 1}. If ğœ‡Ì‚â€² = ğœ‡Ì‚, then C outputs ğœ‡â€² = 0; oth-

unknown ğ‘™ Ã— ğ‘™ dimensional matrixs, there are 2 unknowns in M1 and M2 . The vector pÌ‚ğ‘ , pÌ‚ğ‘ are split from the ğ‘™-dimensional bit string ğ‘, which has 2ğ‘™ unknowns. Since given only 2ğ‘™ equations, which are less than the
amount of unknowns, the transformation matrix cannot be solved by the adversary without enough information. Also, Wong et al. [12] secu-
rity analysis shows that when ğ‘™=80, its security is equivalent to that of
the 1024-bit key RSA encryption algorithm. Thus, under the premise of
key security, the CS cannot restore the real location of the POI through
erwise, C outputs ğœ‡â€² = 1.
Refer to [13], we use ğ‘¡ğ‘’ğ‘Ÿ to denote two cases in which Challenger C
aborts during the game, as follows:
ï‚ When C simulates Uğ‘‡ and Uğ¶ , ğœğ‘– = 0. Since that each ğœğ‘– is picked
is Pr ğ‘¡ğ‘’ğ‘Ÿ1 = (1 âˆ’ ğœƒ)ğ‘ğ‘‡ +ğ‘ğ¶ , where ğ‘ğ‘‡ and ğ‘ğ‘ represent the adversary A randomly and independently, the probability that C aborts the game invokes at most ğ‘ğ‘‡ , ğ‘ğ¶ queries to Uğ‘‡ and Uğ¶ , respectively.
ï‚‚ In the challenge keywords chosen by adversary A, ğœâˆ—=ğœâˆ—=1, the

ciphertext data.	0	1

Lemma 1. Assuming that the problem of mDLIN is hard, then for any prob-
probability that C aborts the game is Pr ğ‘¡ğ‘’ğ‘Ÿ2 = 1 âˆ’ (1 âˆ’ ğœƒ) . Hence, the
probability of C not aborts in the game is Pr |ğ‘¡ğ‘’ğ‘Ÿ| = ((1 âˆ’ ğœƒ)ğ‘ğ‘‡ +ğ‘ğ¶ )(1 âˆ’

ability polynomial time adversary A , the probability advantage Advğ¶ (ğœ†) of
âˆš  ğ‘ +ğ‘ 
|  ||  |

A	(1 âˆ’ ğœƒ)2). When ğœƒ=1-
ğ‘‡  ğ¶
, the probability ğ‘ƒ ğ‘Ÿ ğ‘¡ğ‘’ğ‘Ÿ takes the maxi-

Proof 1. Assuming that exists an adversary A that can correctly distin- guish the keyword ciphertext with a non-negligible probability advan-
mum value:
ğ‘ƒ ğ‘Ÿ|ğ‘¡ğ‘’ğ‘Ÿ|=(  ğ‘ğ‘‡ + ğ‘ğ¶   )
ğ‘‡  ğ¶
ğ‘ğ‘‡ +ğ‘ğ¶
â‹… 	2	 ,	(9)

tage ğœ–ğ¶ . We demonstrate that the challenger C can solve the mDLIN
|  |	ğ‘ğ‘‡ + ğ‘ğ¶ +2 	 ğ‘ğ‘‡ + ğ‘ğ¶ +2

problem with a non-negligible advantage ğœ–ğ¶ . Given an instance of
the mDLIN problem with parameters (ğ‘”, ğ‘”ğ‘, ğ‘”ğ‘, ğ‘”ğ‘Ÿğ‘, ğ‘”ğ‘¡âˆ•ğ‘, ğ‘Š ) âˆˆ ğ”¾, where
which nearly equal to	2
ğ‘ğ‘‡ +ğ‘ğ¶ )
, and thus non-negligible. Therefore, the

ğ‘, ğ‘, ğ‘Ÿ, ğ‘¡ âˆˆ â„¤âˆ—, the goal of C is to determine ğ‘Š = ğ‘”ğ‘Ÿ+ğ‘¡ or a random ele- ment of ğ”¾. C set ğœ‡ âˆˆ {0, 1}, if ğ‘Š = ğ‘”ğ‘Ÿ+ğ‘¡, ğœ‡=0; if ğ‘Š is random, ğœ‡=1.
Initialization:
The Challenger C sets (ğ‘ƒ ğ¾ , ğ‘ƒ ğ¾ ) = (ğ‘”ğ‘, ğ‘”ğ‘) and sents it to the adver- sary A along with the public parameter ğ‘ğ‘ğ‘Ÿğ‘ğ‘š = (ğ”¾, ğ”¾ğ‘‡ , ğ‘’, ğ‘, ğ‘”).
Query:
A can ask C for the following query:
Hash query Uğ» : A sends the keyword ğ‘¤ğ‘– to C for hash query. C
will do the following:
success probability that of C guessing the bit ğœ‡ (i.e., solving the mDLIN
problem) is:
Pr ğœ‡ = ğœ‡ =	+ ğœ– â‹… Pr ğ‘¡ğ‘’ğ‘Ÿ .	(10)
If ğœ–ğ¶ is non-negligibl|e, s|o is Pr[ğœ‡ = ğœ‡] âˆ’ 1âˆ•2 .

Userâ€™s query privacy

Each LBS data will be encrypted and submitted to CS as a query trap-

ï‚ C maintains an initially empty list ğ¿
ğ‘¤ , â„ , ğ›¼ , ğœ
for Aâ€™s query,
door when a user query. Specifically, for POI coordinates, as discussed

ğ» âŸ¨ ğ‘–  ğ‘–  ğ‘–
ğ‘–âŸ© ) =
in the encryption phase, the vector qÌ‚ will also be split into two random

ï‚‚ Otherwise, C produces a random number ğœğ‘– âˆˆ {0,1} in probability
such that ğ‘ƒ ğ‘Ÿ[ğœğ‘– = 0] = ğœƒ.
If ğœğ‘– =0, randomly chooses ğ›¼ğ‘– âˆˆ â„¤âˆ— and computes â„ğ‘– = ğ‘”ğ‘¡âˆ•ğ‘ â‹… ğ‘”ğ›¼ğ‘– ; Oth- erwise, sets â„ğ‘– = ğ‘”ğ›¼ğ‘– .
vector qÌ‚ğ‘ and qÌ‚ğ‘ according to the bit string ğ‘. Since the CS cannot obtain
the invertible matrix M1, M2 and the bit string ğ‘, after a series of op-
erations such as splitting and matrix multiplication, CS can not get the
userâ€™s actual coordinates and query radius with the userâ€™s query trap-

ï‚ƒ C stores the tuple ğ‘¤ , â„ , ğ›¼ , ğœ
in ğ¿
and returns ğ» (ğ‘¤ ) = â„ to
door.

ğ‘–
A.
ğ‘–  ğ‘–
ğ‘– âŸ©	ğ»
ğ‘–	ğ‘–
Lemma 2. Allowing the problem of DBDH is hard, then for any PPT A , the

Ciphertext query Uğ¶ : A sends the keyword ğ‘¤ğ‘– to C for ci-
probability advantage Advğ‘‡ (ğœ†) who breaches the keywords trapdoor privacy

phertext query and C retrieves
ğ‘¤ , â„ , ğ›¼ , ğœ
from the list ğ¿
. If ğœ =0,	A

ğ‘–  ğ‘–
â€²
ğ‘–  ğ‘– âŸ©
ğ»	ğ‘–
of our scheme is negligible.

it randomly outputs a bit ğœ‡ âˆˆ {0,1} as its guess of ğœ‡. Otherwise, it randomly selects ğ‘˜ğ‘– âˆˆ â„¤âˆ— and computes the ciphertext ğ¶ğ‘¤ = (ğ¶1 , ğ¶2 ) =
((ğ‘”ğ›¼ğ‘– )ğ‘ â‹… ğ‘”ğ‘˜ğ‘– =ğ‘”ğ›¼ğ‘– ğ‘+ğ‘˜ğ‘– , (ğ‘”ğ‘)ğ‘˜ğ‘– ). C then returns ğ¶ğ‘¤ to A.

Proof 2. Assuming that there is a probabilistic polynomial time adver- sary A can breach the trapdoor privacy of our proposed scheme with a



non-negligible advantage ğœ–ğ‘‡ , there is a challenger C whose probability
of the DBDH problem with parameters (ğ‘”, ğ‘”ğ‘, ğ‘”ğ‘, ğ‘”ğ‘) âˆˆ ğ”¾, ğ‘Š âˆˆ ğ”¾ğ‘‡ , where of solving the DBDH problem cannot be negligibled. Given an instance
ğ‘, ğ‘, ğ‘ âˆˆ â„¤âˆ—, the goal of C is to determine ğ‘Š = ğ‘’(ğ‘”, ğ‘”)ğ‘ğ‘ğ‘ or a random el-

ement in ğ”¾ğ‘‡ . C sets ğœ‡ âˆˆ {0, 1}, if ğ‘Š = ğ‘’(ğ‘”, ğ‘”)ğ‘ğ‘ğ‘, ğœ‡=0; if ğ‘Š is a random element from ğ”¾ğ‘‡ , ğœ‡=1.
Initialization:
The C sets (ğ‘ƒ ğ¾ğ‘¢, ğ‘ƒ ğ¾ğ¿) = (ğ‘”ğ‘, ğ‘”ğ‘) and sents it to the adversary along with the public parameter ğ‘ğ‘ğ‘Ÿğ‘ğ‘š = (ğ”¾, ğ”¾ğ‘‡ , ğ‘’, ğ‘, ğ‘”).
Query:
A can ask C for the following query:
Table 2
Symbol definition.



mum value:

Hash query Uğ»
: A sends the keyword ğ‘¤ğ‘– to C for hash query. C
|  | (  ğ‘ğ‘‡ + ğ‘ğ¶   )
ğ‘ğ‘‡ +ğ‘ğ¶
2		2	

will do the following:
ğ‘ƒ ğ‘Ÿ ğ‘¡ğ‘’ğ‘Ÿ =
ğ‘ + ğ‘ +2
â‹… ğ‘
+ ğ‘ +2 ,	(11)

ï‚ C maintains an initially empty list ğ¿  ğ‘¤ , â„ , ğ›¼ , ğœ  for Aâ€™s query,
|  |	ğ‘‡	ğ¶
ğ‘‡	ğ¶


ï‚‚ Otherwise, C randomly chooses ğœğ‘– âˆˆ {0,1} in probability such that
ğ‘ƒ ğ‘Ÿ[ğœğ‘– = 0] = ğœƒ.
If ğœğ‘–=0, randomly chooses ğ›¼ğ‘– âˆˆ â„¤âˆ— and sets â„ğ‘– = ğ‘”ğ‘§+ğ›¼ğ‘– ; Otherwise, set
â„ğ‘– = ğ‘”ğ›¼ğ‘– .
ğ‘ğ‘‡ +ğ‘ğ¶ )
success probability that of C guessing the bit ğœ‡ (i.e., solving the DBDH
problem) is:
Pr |ğœ‡ = ğœ‡| =	+ ğœ–ğ‘‡ â‹… Pr |ğ‘¡ğ‘’ğ‘Ÿ|.	(12)

to A.
Ciphertext query Uğ¶ : A sends the keyword ğ‘¤ğ‘– to C for ciphertext
If ğœ–ğ‘‡ is non-negligible, so is Pr[ğœ‡ = ğœ‡] âˆ’ 1âˆ•2 .

query and C retrieves ğ‘¤ , â„ , ğ›¼ , ğœ
from the list ğ¿
. If ğœ =0, it aborts the
Index security

âŸ¨ ğ‘–
ğ‘–  ğ‘–
ğ‘–âŸ© â€²
ğ»	ğ‘–

query and randomly outputs a bit ğœ‡ âˆˆ {0,1} as its guess of ğœ‡. Otherwise,
it randomly picks ğ‘˜ğ‘– âˆˆ â„¤âˆ— and computes the ciphertext ğ¶ğ‘¤ = (ğ¶1, ğ¶2) = ((ğ‘”ğ›¼ğ‘– )ğ‘ â‹… ğ‘”ğ‘˜ğ‘– =ğ‘”ğ›¼ğ‘– ğ‘+ğ‘˜ğ‘– , (ğ‘”ğ‘)ğ‘˜ğ‘– ). C then returns ğ¶ğ‘¤ to A.
Trapdoor query Uğ‘‡ : A sends the keyword ğ‘¤ğ‘– to C for trapdoor

Lemma 3. Even if an adversary A obtains the index, the probability of the
A successfully deriving the keyword or coordinates is negligible.

query and C retrieves
âŸ¨ ğ‘–  ğ‘–  ğ‘– â€² ğ‘–âŸ©
from ğ¿ğ» . If ğœğ‘–=0, it aborts the query
}
Proof 3. In our scheme, the bit string of the subregion is stored in each non-leaf node of the coded quadtree, and the LBS data ciphertext

it randomly picks ğ‘Ÿğ‘– âˆˆ â„¤âˆ— and derives the trapdoor ğ‘‡ğ‘¤ = {ğ‘‡1, ğ‘‡2, ğ‘‡3} =
{ğ‘’(ğ‘”ğ›¼ğ‘– ğ‘, ğ‘”ğ‘ğ‘Ÿğ‘– ) = ğ‘’(ğ» (ğ‘¤ğ‘–)ğ‘, ğ‘”ğ‘ğ‘Ÿğ‘– ), ğ‘”ğ‘Ÿğ‘– , ğ‘”ğ‘ğ‘Ÿğ‘– }. C then returns ğ‘‡ğ‘¤ to A.
Challenge:
After polynomial queries, A sends two keywords ğ‘¤âˆ—, ğ‘¤âˆ— to C, which
is stored in the leaf node. Even if the A obtains the coded quadtree,
query, it is assumed that the query range is {(ğ‘¥ğ‘™ , ğ‘¦ğ‘™ ), (ğ‘¥ğ‘Ÿ, ğ‘¦ğ‘Ÿ), ğ‘›}, where the data ciphertext cannot be decrypted without the key. When a userâ€™s
(ğ‘¥ğ‘™ , ğ‘¦ğ‘™ ) and (ğ‘¥ğ‘Ÿ, ğ‘¦ğ‘Ÿ) represent the top left and bottom right vertices of

have not been queried to U
0	1
nor U . Then, C
query region ğ‘„ respectively, and ğ‘› denotes the amount of subregions in

operations:
ğ‘‡	ğ¶
performs the following
query region ğ‘„. Since the userâ€™s position coordinates can be in any of the

ï‚ C performs a Hash query on ğ‘¤âˆ—, ğ‘¤âˆ— respectively: ğ» (ğ‘¤âˆ—) =
divided subregions, the probability of correctly guessing the userâ€™s loca-

0	1	0

â„âˆ— and ğ» (ğ‘¤âˆ—) = â„âˆ—. ğ‘¤âˆ—, ğ‘¤âˆ— correspond to tuples  ğ‘¤*, â„*, ğ›¼*, ğœ*  and
âŸ¨ğ‘¤*, â„*, ğ›¼*, ğœ*âŸ©, respectively. If ğœ*, ğœ* are both 1, C aborts the query and
tion in a certain subregion is 1/n. In addition, in view of the one-wayness of the hash function, even if the index Vğµğ¹ is leaked, the adversary can

randomly outputs a bit ğœ‡ âˆˆ {0,1}as its guess of ğœ‡;

ï‚‚ If at least one of ğœ*
and ğœ*
is 0, let
ğœ‡Ì‚
be the bit sat-

isfying ğœâˆ— = 0. C
0	1	ğ‘‡ * = {ğ‘‡ âˆ—, ğ‘‡ âˆ—, ğ‘‡ âˆ—}, where
Performance evaluation

ğœ‡Ì‚
calculates the trapdoor
1  2  3

âˆ—	ğ‘  ğ‘Ÿ ğ‘ ğ›¼âˆ—	âˆ—	ğ‘Ÿ	âˆ—	ğ‘ğ‘Ÿ
ğ‘ğ‘ğ‘	*

ğ‘‡1 = ğ‘Š â‹… ğ‘’(ğ‘” , ğ‘” ğ‘– ) ğœ‡Ì‚ , ğ‘‡2 = ğ‘” ğ‘– , ğ‘‡2 = ğ‘” ğ‘– . If ğ‘Š = ğ‘’(ğ‘”, ğ‘”)  , then ğ‘‡1 =
ğ‘’(ğ‘”, ğ‘”)ğ‘ğ‘(ğ‘+ğ‘Ÿğ‘– ğ›¼âˆ— ). Since ğ‘Ÿ ğ›¼âˆ— is a random value, so ğ‘‡ * = ğ‘’(ğ‘”, ğ‘”)ğ‘ğ‘(ğ‘+ğ‘Ÿğ‘– ğ›¼âˆ— ) =
In this section, we analyze the performance of PPT-LBS from the perspectives of data encryption, trapdoor generation and data retrieval,

ğœ‡Ì‚
ğ‘– ğœ‡Ì‚
ğœ‡Ì‚
1

ğ‘’(â„ğœ‡Ì‚â€² , ğ‘”ğ‘ğ‘), C outputs 0; if ğ‘Š is a random member of ğ”¾ğ‘‡ , then ğ‘‡ * is also
respectively. The experiments are run in Windows 10 operating system

a random element in ğ”¾ğ‘‡ , C outputs 1. In addition, since ğ‘Ÿ
value, ğ‘‡ *, ğ‘‡ * are also random for A.
1
ğ‘– is a random
with Intel (R) Core (TM) i5-10200H CPU @2.40GHz and 16GB mem- ory. The cryptographic operations have been realized by using the Java

2  3	Pairing-Based Cryptography (JPBC) library.

More trapdoor queries:
A sends ğ‘¤Ìƒ to C for more trapdoor queries, where ğ‘¤Ìƒ â‰  ğ‘¤âˆ—, ğ‘¤Ìƒ â‰  ğ‘¤âˆ—
Comparison of computational cost

and C respond to the query as before.
Guess:
0	1	For convenience, Table 2 lists the symbol description definitions used
in the comparison. Since the time cost of matrix and vector multiplica-

A outputs its guess ğœ‡Ì‚â€² âˆˆ {0, 1}, if ğœ‡Ì‚â€² = ğœ‡Ì‚, then C outputs ğœ‡â€² = 0, oth-
erwise C outputs ğœ‡â€² = 1.
Refer to [13], we use ğ‘¡ğ‘’ğ‘Ÿ to denote two cases in which Challenger C
aborts during the game, as follows:
ï‚ When C simulates Uğ‘‡  and Uğ¶ , ğœğ‘– = 0. Since that each ğœğ‘–
the  game  is  Pr ğ‘¡ğ‘’ğ‘Ÿ1 = (1 âˆ’ ğœƒ)ğ‘ğ‘‡ +ğ‘ğ¶ ,  where  ğ‘ğ‘‡  and  ğ‘ğ‘  represent is picked randomly and separately, the probability that C aborts the adversary A invokes at most ğ‘ğ‘‡ , ğ‘ğ¶ queries to Uğ‘‡ and Uğ¶ ,
respectively.
ï‚‚ In the challenge keywords chosen by adversary A, ğœâˆ—=ğœâˆ—=1, the
tion operation, hashing operation, symmetric encryption and decryption operation is relatively low, it is ignored in the comparison.
Table 3 shows the comparison results of PPT-LBS and the existing schemes [9,14,15] with regard to computational cost.
Comparison of characteristics
In Table 4, characteristics of our scheme and the existing schemes [9,14,15] are compared.
Comparison of experiments
Figure 9 indicates the comparison results of our scheme and the ex- isting similar scheme [9,14,15] in the data encryption phase. Among

0	1	them, our scheme and Ou et al.â€™s [14] scheme use matrix operation and

probability that C aborts the game is Pr ğ‘¡ğ‘’ğ‘Ÿ2 = 1 âˆ’ (1 âˆ’ ğœƒ) . Hence, the
probability of C not aborts in the game is Pr |ğ‘¡ğ‘’ğ‘Ÿ| = ((1 âˆ’ ğœƒ)ğ‘ğ‘‡ +ğ‘ğ¶ )(1 âˆ’
public key searchable encryption to process LBS coordinates and key-

(1 âˆ’
)2)
1 âˆš ğ‘ +ğ‘
|  ||  |
word. The computational cost is lower than Lin et al.â€™s [15] scheme

ğ‘ğ‘‡ +ğ‘ğ¶ +2

Table 3
Comparison of computational cost in each phase.









Table 4


Data encryption	Trapdoor generation	Data retrieval Ou et al. [14]	ğ‘ ğ‘‡ + ğ‘‡	2ğ‘‡	ğ‘ 2ğ‘‡ + ğ‘‡
Zhu et al. [9]	ğ‘ 6ğ‘‡ + 2ğ‘‡	4ğ‘ğ‘‡	ğ‘™ğ‘œğ‘” ğ‘ â‹… 5ğ‘‡ + 2ğ‘‡
Lin et al. [15]	ğ‘ğ‘› 3ğ‘‡ + ğ‘‡ +ğ‘‡	2ğ‘›(ğ‘‡ + ğ‘‡ )	ğ‘™ğ‘œğ‘” ğ‘ â‹… (ğ‘›ğ‘‡ + (2ğ‘› + 1)ğ‘‡ )
Ours	3ğ‘ğ‘‡ğ‘’	2ğ‘‡ğ‘’ + ğ‘‡ğ‘	ğ‘™ğ‘œğ‘”4 ğ‘ â‹… (2ğ‘‡ğ‘ + ğ‘‡ğ‘š )



Comparison of characteristics.

Query privacy	Location privacy	Geographic range query	Keyword query	Top-k query


Ou et al. [14] Zhu et al. [9] Lin et al. [15] Ours

âˆš	âˆš	âˆš

âˆš	âˆš	âˆš
Ã—âˆš	Ã—
Ã—	Ã—
âˆš	âˆš























Fig. 9. The experiment comparison of LSP data encryption.



data to ğ‘› dimension on the basis of Zhu et al.â€™s scheme, so it has the mechanism over the composite order group. Lin et al.â€™s scheme extends
than ours, the key matrix of Ou et al.â€™s scheme is only 3 Ã—3 dimen- highest cost. Although Ou et al.â€™s schemeâ€™s calculation cost is lower
sions, which is easy to be cracked by force and has certain security risks.
Figure 10 shows the comparison results of ours scheme and the ex- isting similar scheme [9,14,15] in the trapdoor generation phase. Sim- ilar to the encryption process, our scheme has a lower cost than the Zhu et al.â€™s [9] scheme and Lin et al.â€™s [15] scheme using a homo- morphic encryption mechanism. Besides, in Zhu et al.â€™s scheme and Lin et al.â€™s scheme, users do not support constructing a query trap- door based on a keyword but can only return all the data in the query area through the CS to decrypt and filter the required data. In the Ou et al.â€™s [14] scheme, when a user query the same keyword, the same parameters will be generated in the trapdoor, which is not random and easy to disclose the user query mode, resulting in the disclosure of user privacy.
Figure 11 shows the comparison results of ours scheme and the ex- isting similar scheme [9,14,15] in the data retrieval phase. Zhu et al.â€™s
[9] scheme and Lin et al.â€™s [15] scheme use dichotomy to retrieve data, our scheme uses coded quadtree to retrieve data, the time complexity are
both ğ‘‚(ğ‘™ğ‘œğ‘”ğ‘ ). Still, neither Zhu et al.â€™s scheme nor Lin et al.â€™s scheme
supports distance top-k query, while Ou et al.â€™s [14] scheme need to
Fig. 10. The experiment comparison of userâ€™s trapdoor generation.


Fig. 11. The experiment comparison of the data retrieval.
traverse all of the data and time complexity is ğ‘‚(ğ‘ ), which cannot be applied to massive data.
Therefore, comprehensively, our scheme is suitable for LBS query in outsourcing environment.



Conclusion

A privacy-preserving top-k query scheme for outsourcing situation is constructed based on enhanced asymmetric scalar-product preserv- ing encryption and public key searchable encryption in this paper. In addition, we use the coded quadtree and bloom filter to construct an index structure, which enables the CS fast locate the userâ€™s query area in the massive encrypted data. Security analysis demonstrates that our scheme not only ensures the data security of LSP but also protects the privacy of usersâ€™ query, and has preferable to similar scheme in performance.

Declaration of Competing Interest

The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.

Acknowledgments

Our work was jointly supported by the National Natural Science Foundation of China (No. 61872051, No. 61702067), the Chongqing Natural Science Foundation of China (No. cstc2020jcyj-msxmX0343), and the Venture & Innovation Support Program for Chongqing Overseas Returnees (No. CX2018122).

Supplementary materials

Supplementary material associated with this article can be found, in the online version, at doi:10.1016/j.ejps.2020.105216.
References

X. Zhang, X. Gui, Z. Wu, Privacy preservation for location-based services: a survey,
J. Softw. 26 (9) (2015) 2373â€“2395.
X. Zhu, E. Ayday, R. Vitenberg, A privacy-preserving framework for outsourcing location-based services to the cloud, IEEE Trans. Dependable Secure Comput. (2019).
Z. Liu, L. Wu, J. Ke, W. Qu, W. Wang, H. Wang, Accountable outsourc- ing location-based services with privacy preservation, IEEE Access 7 (2019) 117258â€“117273.
R. Li, A.X. Liu, A.L. Wang, B. Bruhadeshwar, Fast and scalable range query processing with strong privacy protection for cloud computing, IEEE/ACM Trans. Netw. 24 (4) (2015) 2305â€“2318.
R. Li, A.X. Liu, Adaptively secure conjunctive query processing over encrypted data for cloud computing, in: 2017 IEEE 33rd International Conference on Data Engineer- ing (ICDE), IEEE, 2017, pp. 697â€“708.
M. Zeng, K. Zhang, J. Chen, H. Qian, P3GQ: a practical privacy-preserving generic location-based services query scheme, Pervasive Mob. Comput. 51 (2018) 56â€“72.
S. Yang, S. Tang, X. Zhang, Privacy-preserving k nearest neighbor query with au- thentication on road networks, J. Parallel Distrib. Comput. 134 (2019) 25â€“36.
Q. Xie, L. Wang, Privacy-preserving location-based service scheme for mobile sens- ing data, Sensors 16 (12) (2016) 1993.
H. Zhu, R. Lu, C. Huang, L. Chen, H. Li, An eï¬ƒcient privacy-preserving loca- tion-based services query scheme in outsourced cloud, IEEE Trans. Veh. Technol. 65 (9) (2015) 7729â€“7739.
H. Zhu, F. Liu, H. Li, Eï¬ƒcient and privacy-preserving polygons spatial query frame- work for location-based services, IEEE Internet Things J. 4 (2) (2016) 536â€“545.
L. Zhao, Q. Liu, H. Huang, X. Jia, Eï¬ƒcient privacy-preserving query processing on outsourced geographic databases, in: 2018 IEEE Global Communications Conference (GLOBECOM), IEEE, 2018, pp. 1â€“6.
W.K. Wong, D.W.-l. Cheung, B. Kao, N. Mamoulis, Secure kNN computation on en- crypted databases, in: Proceedings of the 2009 ACM SIGMOD International Confer- ence on Management of data, 2009, pp. 139â€“152.
Q. Huang, H. Li, An eï¬ƒcient public-key searchable encryption scheme secure against inside keyword guessing attacks, Inf. Sci. 403 (2017) 1â€“14.
L. Ou, H. Yin, Z. Qin, S. Xiao, G. Yang, Y. Hu, An eï¬ƒcient and privacy-preserving multiuser cloud-based LBS query scheme, Secur. Commun. Netw. 2018 (2018).
J. Lin, J. Niu, H. Li, M. Atiquzzaman, A secure and eï¬ƒcient location-based service scheme for smart transportation, Future Gener. Comput. Syst. 92 (2019) 694â€“704.

Zhou Yousheng, received the PhD degree from the Beijing University of Posts and Telecommunications, in 2011. He is currently an associate professor with the Chongqing Univer- sity of Posts and Telecommunications. He has published more than 20 academic papers in peer-reviewed international jour- nals. His research interests include mobile security and cloud security. Email: zhouys@cqupt.edu.cn






Li Xia, is currently a master student of School of Cyber Secu- rity and Information Law, Chongqing University of Posts and Telecommunications. Her research interest include blockchain security and the IoT security. Email: lixiacr7@163.com










Wang Ming, received the masterâ€™ s degree from the Chongqing University of Posts and Telecommunications. His research in- terests include mobile security and the IoT security. Email: s180231886@stu.cqupt.edu.cn










Liu Yuanni, is an associate professor at the Institute of Fu- ture Network Technologies, ChongQing University of Posts and Telecommunications, China. She received her PhD from the Department of Network Technology Institute, Beijing Uni- versity of Posts and Telecommunications, China, in 2011. Her research interests include mobile crowd sensing, IoT security, and data virtualization. Email: liuyn@cqupt.edu.cn
