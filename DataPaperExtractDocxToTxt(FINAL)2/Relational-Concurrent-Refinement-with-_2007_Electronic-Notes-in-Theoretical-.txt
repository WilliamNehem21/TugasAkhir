Electronic Notes in Theoretical Computer Science 187 (2007) 35–53	
www.elsevier.com/locate/entcs

Relational Concurrent Refinement with Internal Operations
John Derrick1
Department of Computer Science, University of Sheffield, Sheffield, UK

Eerke Boiten2
Computing Laboratory, University of Kent, Canterbury, Kent, UK

Abstract
Data refinement in a state-based language such as Z is defined using a relational model in terms of the input-output behaviour of abstract programs. Downward and upward simulations form a sound and jointly complete methodology for verifying relational data refinements.
Refinement in a concurrent context, for example, as found in a process semantics, takes a number of different forms. Typically this is based on a notion of observation, for example, which events a system is prepared to accept or refuse. Concurrent refinement relations include trace refinement, failures-divergences refinement, readiness refinement and bisimulation.
In this paper we survey recent results linking the relational model of refinement to the process algebraic models. Specifically, we detail how variations in the relational framework lead to relational data refinement being in correspondence with traces-divergences, singleton failures and failures-divergences refinement in a process semantics. We then extend these results by showing how the effect of internal operations can be incorporated into the relational model. As a consequence simulation rules for failures-divergences refinement can be derived.
Keywords: Data refinement, Z, simulations, process algebraic semantics, failures-divergences refinement, internal operations.


Introduction
Motivated by both theoretical comparisons of refinement and integrations of spec- ification languages, there has been recent interest in relating differing models of relational data refinement with process refinement relations arising in a concurrent

1 Email: J.Derrick@dcs.shef.ac.uk
2 Email: E.A.Boiten@kent.ac.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.043

context. The purpose of this paper is to survey and extend these results. In par- ticular, we derive simulation rules for relational data refinement of specifications containing internal operations.
Models of relational refinement arise in contexts such as state-based specifica- tion languages like Z [19]. Specifications are considered to define abstract data types (ADTs), in which programs (sequences of operations) can be interpreted. Refine- ment in this context is taken to be the subset relation over program behaviours, where what is deemed visible is the input/output relation. Thus an ADT C refines an ADT A if for every program and sequence of inputs, the outputs that C produces are outputs that A could also have produced. Simulations have become the accepted approach to make verification of refinements tractable [10]. Theoretical background is given in [10], and examples of their use in Z are given in [21,11].
An alternative model is found in a process algebra where differing process se- mantics induce different refinement relations. For example, in CSP one could use trace refinement, failures refinement or failures-divergences refinement [17]. In CCS, bisimulation is typically used [16], whereas in LOTOS reduction, extension and con- formance are defined [3]. A survey of many prominent refinement relations is given in [20]. These relations are often motivated by the description of an idealised ma- chine by which one manipulates the system and observes its behaviour. Different concurrent refinement relations arise by varying the functionality of this machine.
In order to understand the nature and structure of refinement, as well as provide a means to combine specification languages and their development methodologies, it is necessary to understand the correspondence between data and process refine- ments. Work relating the two paradigms includes Josephs [15], He [14], Woodcock and Morgan [22], Bolton and Davies [5,6], Derrick and Boiten [2,12] and Schnei- der [18]. That due to Josephs [15], He [14], Woodcock and Morgan [22] defines a basic correspondence between simulation rules and failures-divergences refinement. The more recent work of Bolton and Davies [5,6], Derrick and Boiten [2,12] and Schneider [18] investigates a direct correspondence between the relational model and process semantics, and includes a specific consideration of input and output which introduces some subtleties.
The purpose of this paper is two-fold. First, we survey this existing work linking relational models of refinement to their process algebraic counterparts. Second, we extend these results (and, in particular, [12]) by showing how the effect of internal operations can be incorporated into the relational model.
The correspondence between a relational model and a process model can be investigated either by defining a ’corresponding process’ in, say, CSP for each ADT, and then deriving the process semantics, or by defining a process semantics directly for an ADT. Schneider [18] and Bolton and Davies [5,6] do the former, whilst Derrick and Boiten the latter [12]. Either way, a process semantics [A ] can be given for an ADT A. The central aim is to derive results of the following form:
In relational model X, A ±data C if and only if [A]] ±ps [[C]].

where ±data denotes some variation of relational data refinement, and ±ps the re- finement relation induced by the given process semantics, the latter typically given as semantic models of CSP, for example, traces-divergences or failures-divergences. The variations in the relational model include the interpretation of an operation given as a partial relation, and the observations made. Two possible interpretations are usually articulated for a partial operation: non-blocking and blocking. The former denotes a contract approach - outside a precondition anything may happen
- the latter a behavioural approach - outside a precondition (guard) nothing may happen. The observations made in a relational model are usually restricted to the input/output of the ADT, however, these can be extended to include, for example, the refusals in a given state. We thus gain results such as:
In the non-blocking relational model with standard observations, A ±data C if and only if [A ] is traces-divergences refined by [C]].
This particular result is due to Schneider [18]. A version in a blocking model is due to Bolton and Davies, where the process semantics induced is a singleton-failures model. Derrick and Boiten [12] show what additional observations are needed to induce failures-divergences refinement, and derive corresponding simulation rules.
In this paper we extend these results with the consideration of internal (unob- servable) operations, in particular deriving simulation rules for failures-divergences refinement. This is an important generalisation from previous approaches, partic- ularly highlighting the role of divergence due to unbounded internal evolution and its effect on the simulation rules. We derive downward and upward simulation con- ditions for the blocking model, and as a consequence, relational refinement can be used as a basis for checking failures-divergences refinement of concurrent processes with internal operations. Thus, the verification of refinement using simulations can now be applied to all of CSP including hiding.
The paper is structured as follows. Section 2 highlights crucial elements of the background material, refering to other sources for the full details. Section 3 surveys work on relating refinement in relational and process semantics. Section 4 provides the extension of the blocking model to internal operations, and we conclude in Section 5.

Background
Relational reﬁnement for Z
For the full details of abstract data type refinement in a relational setting and how this is used to develop a refinement theory for Z, both in the blocking and non-blocking approach, see [11] or the full version of this paper [13].
In summary, an abstract data type contains a (hidden) state space, initialisation, operations and a finalisation. A program corresponds to a sequence of operations, with initialisation and finalisation, representing a relation characterising observa-

tions on the visible state space. The definition of refinement between abstract data types requires (relational) inclusion of such observations for all programs, i.e., re- duction of non-determinism. Downward and upward simulations form a sound and complete way of proving refinement by consideration of single operations.
The relational refinement theory comes in two equally valid flavours: for partial and for total relations. Here, we consider the total relation version only. Operations are often described by partial relations, which need to be embedded into total re- lations (“totalised”) by the addition of fictitious elements to the observation space. This, also, comes in two variants, with corresponding interpretations. The block- ing totalisation links states outside the operation’s domain with a fictitious value only, indicating a state that the system should never reach – a property then to be preserved in refinement. The non-blocking totalisation links such states to all possible states including a fictitious one, indicating that any outcome is acceptable, thereby introducing non-determinism that may be reduced in refinement. In both approaches the simulation rules for partial operations are derived from those for totalised operations by removing references to the fictitious element.
Specifications in Z provide the additional complication that operations may have inputs and outputs. This is accommodated in the relational model by adding se- quences of inputs and outputs to the visible and hidden state, with inputs provided at initialisation and all outputs observed at finalisation. Operations each consume one input and produce one output. The following definition, of the relational ﬁnal- isation induced by a Z data type (which does not contain an explicit finalisation), is included fully, as it will be varied upon in the rest of this paper.
Fin == {State; is : seq Input ; os : seq Output • (is, os, θState) '→ (⟨⟩, os)}
The following (standard) definitions of refinement in Z follow from the constructions
described above.
(AState, AInit , {AOpi }i∈I ) and C = (CState, CInit , {COpi }i∈I ). The relation R Definition 2.1 (Standard downward simulation in Z) Given Z data types A = on AState ∧ CState is a downward simulation from A to C in the non-blocking
model if
∀ CState' • CInit ⇒ ∃ AState' • AInit ∧ R'
and for all i ∈ I , Input and Output :
∀ AState; CState • pre AOpi ∧ R ⇒ pre COpi
∀ AState; CState; CState'; • pre AOpi ∧ R ∧ COpi ⇒ ∃ AState' • R' ∧ AOpi
In the blocking model, the final condition (“correctness”) becomes
∀ AState; CState; CState'; Input ; Output • R ∧ COpi ⇒ ∃ AState' • R' ∧ AOpi

Definition 2.2 (Standard upward simulation in Z)
Given Z data types A = (AState, AInit , {AOpi }i∈I ) and C = (CState, CInit ,
{COpi }i∈I ). Then the relation T on AState ∧ CState is an upward simulation from
A to C in the non-blocking model if
∀ CState • ∃ AState • T
∀ AState'; CState' • CInit ∧ T ' ⇒ AInit
and for all i ∈ I :
∀ CState • ∃ AState • T ∧ (pre AOpi ⇒ pre COpi )
∀ AState'; CState; CState' •
(COpi ∧ T ') ⇒ (∃ AState • T ∧ (pre AOpi ⇒ AOpi ))
In the blocking model, the correctness condition becomes
∀ AState'; CState; CState' • (COpi ∧ T ') ⇒ ∃ AState • T ∧ AOpi
Process reﬁnement
A contrasting view of refinement is that offered by a process algebraic description of a system. There, instead of a relation over a global state being representative of a program, the traces of events (in essence, a record of all terminating programs) are recorded. There are a number of semantic models for CSP, each of which induces its own refinement relation.
Failures-divergences semantics The standard semantics of CSP is the failures-
(A, F, D) where A is its alphabet, F is its failures and D is its divergences. The divergences semantics developed in [9,8,17]. A process is modelled by the triple failures of a process are pairs (t , X ) where t is a finite sequence of events that the
process may undergo and X is a set of events the process may refuse to perform
after undergoing t . That is, if the process after undergoing t is in an environment which only allows it to undergo events in X , it may deadlock. The divergences of a process are the sequences of events after which the process may undergo an infinite sequence of internal events, i.e. livelock.
Failures and divergences are defined in terms of the events in the alphabet of the process. The failures of a process with alphabet A are a set
F ⊆ A∗ × P A
such that a number of properties hold: the sequences of events that a process can undergo form a non-empty, prefix-closed set; if a process can refuse all events in a set X then it can refuse all events in any subset of X ; a process can refuse any event which cannot occur as the next event. The divergences of a process with alphabet A and failures F are a set D ⊆ dom F such that:

t1 ∈D ∧ t2 ∈ A∗ ⇒ t1 - t2 ∈D 
t ∈D ∧ X ⊆ A ⇒ (t , X ) ∈F 
These capture the idea that it is impossible to determine anything about a divergent
process in a finite time. Therefore, the possibility that it might undergo further events cannot be ruled out. In other words, a divergent process behaves chaotically.
The failures-divergences semantics induces a refinement ordering defined in terms of failures and divergences [8]. A process Q is a refinement of a process P , denoted P ±fd Q , if F(Q ) ⊆ F(P ) and D(Q ) ⊆ D(P ).
There are two other semantics models for CSP relevant to this paper.
Traces-divergences semantics The traces-divergences semantics is just the failures- divergences semantics with the refusal information removed. A process P is now
modelled by (A, T , D), where T are the traces of P . It is obtained from the failures- divergences semantics by defining the traces as T (P ) == {tr | (tr , ∅) ∈ F}.
The traces-divergences semantics induces a refinement ordering, where P ±td Q
iff T (Q ) ⊆T (P ) and D(Q ) ⊆ D(P ).
Singleton failures semantics The singleton failures semantics for CSP was used by Bolton [4] (and published in [5,6]) in order to define an appropriate correspon- dence with blocking data refinement. Essentially the singleton failures semantics is a failures semantics where the refusal sets have cardinality at most one. Specifically,
a process is now modelled by (A, S) where S ⊆ A∗ × P1 A (and P1 forms subsets of cardinality at most one).
If P is a process expressed in terms of stop, →, H,  and , then its singleton failures are given as the obvious projection from its failures, that is: S(P )= F(P ) ∩ (A∗ × P A). This does not hold for processes containing hiding.
The singleton failures semantics induces a refinement ordering, where P ±sf Q
iff S(Q ) ⊆ S(P ).
Clearly, failures-divergences refinement is stronger than traces-divergences re- finement, that is, P ±fd Q ⇒ P ±td Q . For divergent-free processes we have P ±sf Q ⇒ P ±td Q , and for divergent-free basic processes (i.e., ones expressed in terms of stop, →, H, and ) we have P ±fd Q ⇒ P ±sf Q . The relationship of singleton failures to other semantic models is discussed in [20] and later in [7].



Relating data and process refinement

The previous section outlined the standard relational theory of refinement as well as briefly mentioning relevant process based definitions. We now survey recent existing work relating relational refinement with process refinement. The correspondences are summarised in the following table.


Both Bolton and Davies and Schneider consider the standard definition of data refinement, which are thus verified by simulations as given (in Z) in Definitions 2.1 and 2.2. The ’extended finalisations’ of Derrick and Boiten add conditions to the simulation rules, and these thus require augmented definitions.

Non-blocking data reﬁnement and the traces-divergences semantics
Inspired by the work by Bolton and Davies [5,6] discussed below, Schneider [18] shows that non-blocking data refinement corresponds to traces-divergences refine- ment in a process semantics. To show this he translates ADTs into CSP directly, and uses the traces-divergences semantics on the resulting CSP process.
As with all approaches the result is first proved for ADTs without input and output, and then extended to the general case. The extension to ADTs with inputs and outputs (which Schneider calls communicating data types following Bolton) involves the embedding of input and output sequences in the global states similar to the one described above. For such an ADT the translation of an ADT A into a CSP process process(A) is given by
process(A) == Hs ∈ State, (∗, s) ∈ Init • ProcA(s) ProcA(s) ==
 i ∈ I , in ∈ Input , (⟨in⟩, ⟨ ⟩, s) ∈ dom AOpi •
Hs' ∈ State, out ∈ Output , (⟨in⟩, ⟨ ⟩, s) '→ (⟨ ⟩, ⟨out ⟩, s') ∈ AOpi •
AOpi.in.out → ProcA(s')
 

 i ∈ I , in ∈ Input , (⟨in⟩, ⟨ ⟩, s) /∈ dom AOpi • Hout ∈ Output • AOpi .in.out → div
Note that here div is the divergent CSP process, which ensures that all events are possible after an operation has been called outside its precondition. The following (in the notation used in this paper) is then proved.
Theorem 3.1 In the non-blocking model,
A ±data C if and only if process(A) ±td process(C ).

Blocking data reﬁnement and the singleton failures semantics
Bolton in [4] and Bolton and Davies in [5,6] discuss the relationship between data refinement and the singleton failures semantics [20] model. They consider both the blocking and non-blocking relational data type semantics, and, like Schneider, translate ADTs directly into CSP.
For the blocking model, the translation of an ADT A into a CSP process
processb (A) is given by (using, for uniformity, the notation already introduced):
processb (A) == Hs ∈ State, (∗, s) ∈ Init • PA(s)
PA(s) ==
 i ∈ I , in ∈ Input , (⟨in⟩, ⟨ ⟩, s) ∈ dom AOpi •
Hs' ∈ State, out ∈ Output , (⟨in⟩, ⟨ ⟩, s) '→ (⟨ ⟩, ⟨out ⟩, s') ∈ AOpi •
AOpi.in.out → PA(s')
As can be seen the enabling of this process is identical to that of Schneider,
however, the effect of calling an operation outside its precondition is not now diver- gence but, since we are in the blocking model, simply inability to perform any event associated with that operation. This thus correctly reflects the intended meaning to the blocking model. For ADTs with deterministic outputs (or no input/output) the following is shown.
Theorem 3.2 In the blocking model, for ADTs with deterministic outputs (or no input/output), A ±data C if and only if processb (A) ±sf processb (C ).
The inclusion of non-deterministic outputs complicates the process semantics needed, and an additional constraint is needed in order to characterise blocking data refinement. To do this a further partial translation is introduced, called inputProcess which provides a characterisation of when a particular input is in the domain. For the blocking model this is defined as:
inputProcessb (A) == Hs ∈ State, (∗, s) ∈ Init • PA(s) PA(s) ==  i ∈ I , in ∈ Input , (⟨in⟩, ⟨ ⟩, s) ∈ dom AOpi •
Hs' ∈ State |
(∃ out ∈ Output | (⟨in⟩, ⟨ ⟩, s) '→ (⟨ ⟩, ⟨out ⟩, s') ∈ AOpi ) •
AOpi .in → PA(s')
As can be seen, this is the same as processb except that the outputs are unob-
servable. Blocking data refinement can then be shown to be equivalent to singleton failures refinement of both the process and the input process. That is:
Theorem 3.3 In the blocking model, A ±data C if and only if processb (A) ±sf
processb (C ) and inputProcessb (A) ±sf inputProcessb(C ).

Two corollaries are worth noting. First, that this characterisation is equivalent to checking the singleton failures of the input process and trace refinement of the process. Second, that
processb (A) ±fd processb (C ) ⇒ A ±data C
in the blocking model.
Bolton and Davies also consider the non-blocking model. However, the corre- sponding process used is different to that of Schneider. Specifically, they define processnb by
processnb (A) == Hs ∈ State, (∗, s) ∈ Init • QA(s)
QA(s) ==	PA(s)
 
(( i ∈ I , in ∈ Input , (⟨in⟩, ⟨ ⟩, s) /∈ dom AOpi •
Hs' ∈ State, out ∈ Output • AOpi .in.out → Chaos)
Hstop)
where Chaos == (Hi ∈ I , in ∈ Input , out ∈ Output • AOpi .in.out → Chaos) H
stop is the non-divergent process that can perform any event, yet also refuse any
event. In the process QA the lower stop is being used to represent non-termination of the operation. With this corresponding process analogous results are derived (i.e., data refinement corresponding to singleton as opposed to failures-divergences refinement). This non-blocking translation differs in key aspects from that defined by Schneider. In particular, the use of Chaos and stop to model non-termination seems a less natural embedding of non-blocking than using explicit divergence.

Deﬁning a correspondence with failures-divergences reﬁnement
Derrick and Boiten [2,12], motivated by the work of Bolton and Davies, explored what additional conditions were needed on relational refinement in order to achieve a correspondence with failures-divergences refinement. It turned out that explicit observation of refusals was the required ingredient, and since the finalisation deter- mines what is observable, this involves generalising the finalisations used.

Basic construction
from being {State • θState '→ ∗} to becoming {State • θState '→ E }. E will be To add refusals to the observations of a data type, the finalisation used is generalised a set of operation names representing the operations that could be refused at the
state in which the finalisation is applied. Operations are indexed over I , and these are used as the set of operation names. Refusals E are any subset of the maximal

refusals in a given state: {i : I | ¬ pre Opi }. The full embedding is as follows 3 .
Definition 3.4 (Refusals embedding) An ADT (State, Init , {Opi }i∈I ) in the re- fusals interpretation is embedded in the relational model as follows. The global
state G is P I , finalisation is given by
Fin == {State; E : P I | (∀ i ∈ E • ¬ pre Opi ) • θState '→ E }
and initialisation is given by
Init == {Init ; E : P I • E '→ θState'}
The local state and the embedding of operations are unchanged.
Derrick and Boiten then derive two results. The first is to show what the con- sequence is on the simulation rules of this extended finalisation. The second is to show correspondence with failures-divergences refinement.
Simulation rules
The relational downward and upward simulation rules [11] contain conditions on the finalisations. Specifically, for a downward simulation that
R o CFin ⊆ AFin
ran(dom AFin D R) ⊆ dom CFin
and for an upward simulation that
CFin ⊆ T o AFin
∀ c : CState • T(| {c} |) ⊆ dom AFin ⇒ c ∈ dom CFin
With the extended finalisation, where refusals are observed, the second down- ward simulation condition is always satisfied, and the first is equivalent to the stan- dard downward applicability condition. Thus in the presence of refusals Definition
2.1 represents the correct formalisation.
For an upward simulation, ∀ c : CState • T(| {c} |) ⊆ dom AFin ⇒ c ∈ dom CFin is always satisfied, however, CFin ⊆ T o AFin leads to a strengthening of the standard applicability condition from Definition 2.2 to
(1)	∀ CState • ∃ AState • ∀ i : I • T ∧ (pre AOpi ⇒ pre COpi )
As noted in [12]: ’The standard upward simulation applicability condition re-
quires that we have to consider pairs of abstract and concrete states for each opera- tion. The finalisation condition, on the other hand, requires that for every abstract state we can find a single concrete state such that all the preconditions of the ab- stract operations imply the preconditions of their concrete counterparts.’

3 Since the result type of finalisation and the input of initialisation should both be G, the initialisation will take a set of operations as its input for consistency.

Correspondence with failures-divergences reﬁnement
Bolton and Davies, and Schneider, both define the process semantics by first defining a ’corresponding process’ in CSP and then using an appropriate semantics of this process. Derrick and Boiten, however, define a process semantics directly. The difference is not important, as long as the results are consistent.
With no outputs the traces, failures and divergences can be defined easily in either model, for the construction in the presence of input and output, see [1].
Blocking model Traces arise from sequences of operations which are defined within their guards. Refusals indicate the impossibility of applying an operation outside its precondition. Furthermore, there are no divergences since each operation is either blocked or gives a well-defined result.
Non-blocking model As no operation is blocked, every trace is possible: those that arise in the blocking model, and any others following divergence. There are no refusals beyond those after a divergence, as no operation is blocked, it either gives a well-defined result or causes divergence. There are now, however, divergences, which arise from applying an operation outside its precondition.
The following is then proved.
Theorem 3.5 In both the non-blocking and the blocking model, relational reﬁne- ment with extended ﬁnalisations corresponds to failures-divergences reﬁnement.

Discussion
We have seen that in both the non-blocking and blocking models it has been neces- sary to place additional restrictions (i.e., observations) on the standard definition of data refinement in order that failures-divergences refinement is achieved in a process semantics. Why this is is perhaps best illustrated via an example.
The non-blocking model. We have seen that without input/output non- blocking data refinement is equivalent to traces-divergences refinement. However, it is worth noting that this does not mean that data refinement suffers from the weakness of the CSP traces model. Specifically, although traces refinement is nor- mally considered too weak since the deadlocked behaviour stop refines all processes, such a behaviour is not a feasible translation of an ADT. That is, no ADT will have corresponding process stop, since the non-blocking model allows all traces due to no operation being refused. In addition, unlike in trace refinement there is no bottom of the refinement ordering since all ADTs with all operations deterministic and fully defined have no strict refinements in this framework.
Without input/output, non-blocking data refinement is, in fact, also equivalent to failures-divergences refinement. To see this, note that without output the process semantics obtained identifies traces-divergences refinement and failures-divergences refinement, that is, process(A) ±td process(C ) iff process(A) ±fd process(C ). This is simply because there are no refusals (beyond those after a divergence) in the process semantics, since refusals only arise due to the presence of outputs.

simple










luxury
ensuite

A	C

Fig. 1. Non-blocking, no input/output = traces-divergences and failures-divergences
Consider Figure 1, where in this and subsequent examples we define them via simple LTSs which represent the ADT’s partial relations before totalisation.
These two specifications have the same traces and divergences, and are thus data refinement equivalent. There are no refusals, thus they are also failures-divergences equivalent. However, note that the stronger applicability condition needed for the blocking model does not hold here - for example for state ensuite it is not the case that any abstract state has
∀ i : I • T ∧ (pre AOpi ⇒ pre COpi )
The difference (i.e., why this does not matter in a traces-divergences model) is that with failures the refusals are tied to the traces, whereas for divergences we simply require their inclusion.
The blocking model.  However, when considered under a blocking totalisa- tion A and C are not failures-divergences equivalent. In fact, in a blocking scenario these are singleton failures equivalent and hence a blocking data refinement. To see this note that in a blocking model there are no divergences, the traces are the
same in each. Now, although A has failure (⟨Book ⟩, {TVF , ESF }) which is not
(⟨Book ⟩, {TVF }), (⟨Book ⟩, {ESF }), ... thus the difference is not observable. To present in C , under a singleton failures model in A we just obtain singleton failures recover failures-divergences refinement in the blocking model one needs to add the
strengthened applicability condition. That is, it is precisely the condition
∀ CState • ∃ AState • ∀ i : I • T ∧ (pre AOpi ⇒ pre COpi ) that fails in this example.
Adding Internal Events to the Blocking model
In this section we consider refinement, and derive simulation rules, in the blocking model where divergences may arise from the existence of an internal, or unobserv-

able, operation τ . As in the set-up described above, the observable operations, as well as τ , will be described as partial relations. We thus adapt the above totalisa- tion, over which we can use the standard definition of data refinement.
τ as an additional component of an ADT. From a (partial) abstract data type We use the standard relational framework but now include an internal operation S == (State, Init, {Opi}i∈I , τ, Fin) where the finalisation Fin observes refusals as in
Definition 3.4, our totalisation is
^d	^ d  ^ d	ˆd	^ d
S == (State , Init , {Opi }i∈I , Fin )
defined as follows.
State We take the standard blocking totalisation and add in another state, ⊥d, to denote divergence.
^ d
State == State⊥,⊥d == State ∪ {⊥, ⊥d}
Where ⊥, ⊥d /∈ State, and ⊥ /= ⊥d. As these values will ultimately be observable,
they will also be contained in the global state G.
Notation To define the totalised operations etc, we will use the following notations.
evolution.   That  is,  v  ▶  State  ↓  iff  v  ▶  ¬ dom τ . State ↓ denotes stable states, i.e. those from which it is not possible to do an internal
τ∗ denotes finite internal evolution. It could be defined as the least fixed point of
λ R • id ∪ τ o R.
τ ∗| == τ∗ D− (dom τ) is maximal finite internal evolution, leading to a stable state. τ ω denotes unbounded internal evolution, and, in particular, the set dom τ ω consists states”). That set is defined as the largest fixed point of λ S . dom(τ D S ). We of all the states from which unbounded internal evolution could start (“divergent also use the predicate State ↑ to denote that a state is divergent, and Init ↑ to
indicate that the ADT has a divergent initial state.
τ^ω encodes unbounded internal evolution as divergence, and is defined by
τ^ω == dom τ ω × State⊥,⊥
for the appropriate state space State.

IE == τ∗ ∪ τ^ω encodes all internal evolution. In states where unbounded internal evolution is possible, the encoding through τ^ω subsumes all finite internal evolu- tion from such a state.
div Op characterises all the states where the application of Op might be followed by unbounded internal evolution, and is defined by
div Op == dom(Op o τ ω)

DP == {⊥d}× State⊥,⊥d encodes preservation of divergence once it has occurred, using the appropriate state space State.
BP == {(⊥, ⊥)} encodes the preservation of blocking.
sation followed by any potential internal evolution due to τ , encoded as divergence Initialisation The totalisation of the initialisation will correspond to the initiali- where unbounded. BP and DP are included to ensure totality of the initialisation.


I^nitd
== Init o IE ∪ BP ∪ DP


Operations The totalisation of a partial relation Op is achieved in two stages.
^b

First, the blocking totalisation is applied, yielding an operation Op
^d
total on State⊥.

Second, we form Op
: State⊥,⊥d ↔ State⊥,⊥d which appends any potential evolution

due to τ , encoded as divergence where it is unbounded.
^d	^b o
Op == (Op 9 IE) ∪ DP
We thus absorb the effect of τ into the operations and initialisation, and represent its behaviour as non-determinism and divergence.
Finalisation We assume the partial ADT’s finalisation already records refusals as in Definition 3.4. In order to achieve a correspondence with the stable failures
where τ is not enabled. To this purpose, we prepend maximal internal behaviour model, we need to ensure that refusals are only recorded in stable states, i.e., ones to the finalisation. If the observed state was divergent already, this will have been
taken into account by the previous operation (or initialisation if none). Otherwise, we record all refusals in all stable states reachable from the current one through internal evolution 4 .

d
Fin
== (τ
∗| o Fin) ∪ BP ∪ DP

Data refinement Data refinement is defined via the totalisation, that is, A ±data C
iff A^d ±data C^d.
The correspondence with failures-divergences reﬁnement
We next need to define the failures-divergences semantics of an abstract data type, that is, its stable failures and divergences 5 . This can be defined either directly, or
the failures-divergences semantics (α(A), F(A), Div (A)) of a data type A by [A]]. via a corresponding CSP process (e.g., as in [5,18]). We do the former. We denote

4 Note that this is not strictly necessary as those states would already be part of the considerations for the semantics of the same trace; however, the alternative of making the finalisation a partial relation, though probably harmless in the end, takes us outside the constraints of the underlying theory [11].
5 Note that the traces in this semantic model can be derived from the failures.

Op	Op
		

tau



d	d
cb  cd	cb
Fig. 2. Op, Op , Op and Op \ divOp
The alphabet α(A) is the set of operation indices I . Every trace is a sequence of indices. A (non-divergent) trace represents a computation (non-empty relation)
interleaved with finitely many internal operations. That is, < i1,... , in > is a trace consisting of an initialisation, followed by the corresponding sequence of operations,
of A iff ∃j =0...n Statej • State0 ∈ ran(Init o τ∗) ∧ ∀ k : 1..n • (Statek−1, Statek ) ∈
Op o τ∗. If the data type is clear from the context, we identify the trace with this
ik 9
relation and write, for example, (g, State') ∈ tr or State' ∈ ran tr .
Divergences are traces from which an infinite sequence of internal operations are
feasible. A trace tr is divergent (denoted tr ↑) whenever there exist a prefix tr ' of
tr and a state State' ∈ ran tr ' such that State' ∈ State ↑.
Stable failures are pairs (tr , X ), where tr is a trace, and a stable state State' ∈
ran tr exists such that ∀ i ∈ X • State' ▶ ¬ dom Opi . Every non-divergent trace
leads to at least one such stable state.
Theorem 4.1 In the blocking model, A ±data C iff [[A]] ±fd [[C]].
Proof. See [13]. 

The simulation rules
We have shown that under the process semantics given to abstract data types, in a context where we have included internal events and their potential divergence, relational refinement corresponds to failures-divergences refinement. It remains now to extract simulation rules that can be applied to the schema calculus, since we do not wish to work with sets of events as currently embedded in the finalisation, nor explicit calculation of divergent traces.
We use the standard method to describe simulation rules on the underlying partial relations for verifying data refinement with extended finalisations. The key

^d
to doing this is to see that Op
^b
is constructed as two totalisations. The first, Op ,

the standard blocking totalisation, the second, where we add in ⊥d is, in fact, the
^b
standard non-blocking totalisation on Op \ div Op. See Figure 2.

^b
Let us denote Op
\ div Op by O^p.


Downward simulations
We consider simulation relations R˜ on the extended state spaces defined in terms of simulations R between the basic state spaces, as follows:
R˜ == R ∪ BP ∪ DP
i.e., relating blocking and divergence in the state spaces in the obvious way.
We first unwind the downward simulation conditions. For the moment, we elide the finite internal evolution included with initialisation and after every operation.
^d	^
Simulation rules on Op are unwound in terms of Op. Specifically, we consider
a relation R from AState to CState such that R˜ is a downward simulation, i.e.:
^d	^d o ˜
CInit ⊆ AInit 9 R

d
R 9 CFin
d
⊆ AFin

∀ i : I • R˜ o C^Op d ⊆ A^Op d o R˜
9	i	i 9
The standard relational argument [11, pp. 77–79] shows that the following equa- tions precisely characterise such a downward simulation:
^	^
C^Init ⊆ A^Init o R
^	^
R o C^Fin ⊆ A^Fin
^	^
ran(dom AFin D R) ⊆ dom CFin
^	^
∀ i : I • ran(dom AOpi D R) ⊆ dom COpi

^
∀ i : I • (dom AOp
D R) o C^Op
^
⊆ AOp
o (R ∪ BP)

i	9	i	i 9
These are unwound to give the equivalent set of conditions on the underlying partial relations. Specifically, they become:
CInit ↑⇒ AInit ↑
¬AInit ↑⇒ CInit ⊆ AInit o R
R o CFin ⊆ AFin
∀ i : I • ran(¬ div AOpi D R) ⊆ ¬ div COpi
∀ i : I • ran(¬ div AOpi ∩ dom AOpi D R) ⊆ dom COpi

∀ i : I • (¬ div AOp
D R) o COp ⊆ AOp o R

i	9	i	i 9
We now translate these relational conditions into conditions on the Z represen- tation of the abstract data type. Finite internal evolution after initialisation and operations is still elided.

CInit ↑⇒ AInit ↑
¬AInit ↑⇒ ∀ CState' • CInit ⇒ ∃ AState' • AInit ∧ R'
∀ i : I • ∀ AState; CState • div COpi ∧ R ⇒ div AOpi
∀ i : I • ∀ AState; CState • pre AOpi ∧ R ⇒ (pre COpi ∨ div AOpi )
∀ i : I • ∀ AState; CState; CState' •
¬ div AOpi ∧ R ∧ COpi ⇒ ∃ AState' • R' ∧ AOpi

Thus these are the Z schema calculus downward simulation rules for a block- ing semantics without consideration of input/output. Making the finite internal evolution explicit once again gives:

CInit ↑⇒ AInit ↑
¬AInit ↑⇒ ∀ CState' • CInit o τ∗ ⇒ ∃ AState' • AInit o τ∗ ∧ R'
9 C	9 A
∀ i : I • ∀ AState; CState • div COpi ∧ R ⇒ div AOpi
∀ i : I • ∀ AState; CState • pre AOpi ∧ R ⇒ (pre COpi ∨ div AOpi )
∀ i : I • ∀ AState; CState; CState' •
¬ div AOpi ∧ R ∧ COpi o τ∗ ⇒ ∃ AState' • R' ∧ AOpi o τ∗
9 C	9 A
(Note that pre(Op o τ∗) ≡ pre Op, and analogously for div.)
Upward simulations
We now perform a similar unwinding on the upward simulation rules. Specifically, we consider T from CState to AState satisfying

C^Initd o	d

d
CFin
d
⊆ T 9 AFin
d	d

∀ i : I • C^Op	o T˜ ⊆ T˜ o A^Op
i  9	9	i

and elide finite internal evolution for the moment.
The standard relational argument [11, pp. 79–80] then shows that the following equations precisely characterise such an upward simulation:

^	^
C^Init o T ⊆ A^Init
^	o ^
CFin ⊆ T 9 AFin
^	^
∀ c : CState • T(| {c} |) ⊆ dom AFin ⇒ c ∈ dom CFin
^	−	^
∀ i : I • dom COpi ⊆ dom(T D dom AOpi )
—	^ − ^ o	o ^
∀ i : I • dom(T D dom AOpi ) D COpi 9 T ⊆ (T ∪ BP) 9 AOpi

Also taking account of finite internal evolution, we translate these to:
CInit ↑⇒ AInit ↑
¬AInit ↑⇒ ∀ AState'; CState' • CInit o τ∗ ∧ T ' ⇒ AInit o τ∗
9 C	9 A
∀ CState • ∃ AState • T
∀ i : I • ∀ CState • ∃ AState • T ∧ (div COpi ⇒ div AOpi )
∀ CState • ∃ AState • ∀ i : I • T ∧ (pre AOpi ⇒ (pre COpi ∨ div AOpi ))
∀ i : I • ∀ AState'; CState; CState' •
(COpi o τ∗ ∧ T ') ⇒ (∃ AState • T ∧ (pre AOpi ⇒ AOpi o τ∗ ))
9 C	9 A
Conclusions
This paper has been concerned with a relational view of process algebraic refinement. After surveying the current results in the area, we have concentrated on deriving a correspondence between failures-divergences refinement and relational data refine- ment, in particular in the presence of internal evolution. A precise characterisation of the generalised finalisation needed has been given, as well as a derivation of the additional simulation conditions that are a consequence of the finalisation used.
These results extend [12] by considering the explicit presence of internal events in the blocking model. Further work in this area includes extending the results to the non-blocking model, as well as the full consideration of input and output and the effect that the extra subtleties introduced have upon the results derived above. This will be the subject of an expanded version of this paper [1].

Acknowledgement
We would like to thank Christie Bolton, Jim Davies, Gerhard Schellhorn, Steve Schneider, Helen Treharne and Heike Wehrheim for discussions on these issues. John Derrick was supported by the Leverhulme Trust via a Research Fellowship for this work.

References
Boiten, E. and J. Derrick, Relational concurrent refinement with internal operations and outputs (2006), submitted for publication.
Boiten, E. A. and J. Derrick, Unifying concurrent and relational refinement, ENTCS 70 (2002), proceedings REFINE’02, Editors: J. Derrick, E. A. Boiten, J. von Wright and J. C. P. Woodcock.
Bolognesi, T. and E. Brinksma, Introduction to the ISO Specification Language LOTOS, Computer Networks and ISDN Systems 14 (1988), pp. 25–59.
Bolton, C., “On the refinement of state-based and event-based models,” Ph.D. thesis, University of Oxford (2002).
Bolton, C. and J. Davies, Refinement in Object-Z and CSP, in: M. Butler, L. Petre and K. Sere, editors,
Integrated Formal Methods (IFM 2002), Lecture Notes in Computer Science 2335 (2002), pp. 225–244.
Bolton, C. and J. Davies, A Singleton Failures Semantics for Communicating Sequential Processes, Formal Aspects of Computing 18 (2006), pp. 181–210.


Bolton, C. and G. Lowe, A hierarchy of failures-based models: Theory and application, Theoretical Computer Science 330 (2005), pp. 407–438.
Brookes, S. and A. Roscoe, An improved failures model for communicating processes, in: S. Brookes,
A. Roscoe and G. Winskel, editors, Seminar on Concurrency, Lecture Notes in Computer Science 197
(1985), pp. 281–305.
Brookes, S. D., C. A. R. Hoare and A. W. Roscoe, A theory of communicating sequential processes, Journal of the ACM 31 (1984), pp. 560–599.
de Roever, W.-P. and K. Engelhardt, “Data Refinement: Model-Oriented Proof Methods and their Comparison,” CUP, 1998.
Derrick, J. and E. Boiten, “Refinement in Z and Object-Z: Foundations and Advanced Applications,” FACIT, Springer Verlag, 2001.
Derrick, J. and E. Boiten, Relational concurrent refinement, Formal Aspects of Computing 15 (2003),
pp. 182–214.
Derrick, J. and E. Boiten, Relational concurrent refinement with internal operations (full version), Technical report, University of Sheffield (2006).
Jifeng, H., Process refinement, in: J. McDermid, editor, The Theory and Practice of Refinement (1989).
Josephs, M. B., A state-based approach to communicating processes, Distributed Computing 3 (1988),
pp. 9–18.
Milner, R., “Communication and Concurrency,” Prentice-Hall, 1989.
Roscoe, A., “The Theory and Practice of Concurrency,” International Series in Computer Science, Prentice Hall, 1998.
Schneider, S., Non-blocking data refinement and traces-divergences semantics (2006), personal communication.
Spivey, J. M., “The Z Notation: A Reference Manual,” International Series in Computer Science, Prentice Hall, 1992, 2nd edition.
van Glabbeek, R. J., The linear time - branching time spectrum I. The semantics of concrete sequential processes, in: J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, North-Holland, 2001 pp. 3–99.
Woodcock, J. C. P. and J. Davies, “Using Z: Specification, Refinement, and Proof,” Prentice Hall, 1996.
Woodcock, J. C. P. and C. C. Morgan, Refinement of state-based concurrent systems, in: D. Bjorner,
C. A. R. Hoare and H. Langmaack, editors, VDM’90: VDM and Z!- Formal Methods in Software Development, Lecture Notes in Computer Science 428 (1990).
