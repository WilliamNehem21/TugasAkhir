Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 295 (2013) 79–93
www.elsevier.com/locate/entcs

A Model Slicing Method for Workflow Verification
Fazle Rabbi	Hao Wang	Wendy MacCaull	Adrian Rutle
Centre for Logic and Information St. Francis Xavier University, Canada
{rfazle, hwang, wmaccaul, arutle}@stfx.ca


Abstract
Workflow systems increase productivity and quality of service; however, defects in a workflow model may have severe consequences. While model checking techniques can be used to verify the correctness of a workflow model, these techniques typically suffer from the state explosion problem. We propose a model slicing algorithm with a formal proof to address this problem. The algorithm is integrated into our NOVA Workflow framework, which facilitates design, verification, execution, and error-handling. An experimental result has been presented to show that the proposed algorithm makes the verification more efficient in terms of state space and hence for memory and time usage.
Keywords: Model slicing, formal verification, workflow modelling, model checking, linear temporal logic

Introduction
Workflows coordinate activities performed by various participants, e.g., persons, robots or software components, in order to achieve a business goal. Today workflow models are frequently used to describe the behaviour of software components in dis- tributed and heterogeneous environments with characteristics like concurrency, re- source sharing, and synchronisation. In such a collaborative environment, workflow systems could be used for controlling runtime execution and service orchestration, based on a workflow model describing the behaviour of the components.
Many of today’s workflows are complex, requiring a high degree of flexibility, massive data and knowledge management. However, the resulting implementations of unverified, complex workflow models are at risk of undesirable runtime execu- tions. Model checking or other similar verification techniques are required to ensure that these process models exhibit the desired behaviour. The time complexity of model checking algorithms depends on the size of the transition system which is exponential in the number of variables, concurrent components, and channels. This problem is commonly known as the state explosion problem [4]. While current model

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.04.007

checkers are much more powerful than their predecessors, they still frequently suf- fer from this problem. Much research has been done in this field during the past decade. While there are many techniques to optimize model checking algorithms, e.g., Partial Order Reduction (POR) [15], Symmetry-based Reduction [9], the cate- gory of techniques called Model Abstraction [4] is also very important to alleviate the state explosion problem. These techniques abstract away irrelevant details w.r.t. the properties being verified before the system model is input to the model checker. There are two types of model abstraction techniques: data abstraction, which uses a smaller set of data values to represent the actual values of the system, and model slicing, which eliminates model components that will not affect the truth value of the property being verified. In this paper we focus on the latter technique. While the problem of software program slicing [7] is a well-studied topic, there are relatively few works in slicing for formal diagrammatic languages, even fewer for workflow modelling languages. This paper develops and integrates model abstrac-
tion techniques into a workflow framework.
Our group developed NOVA Workflow, a framework for workflow design, ver- ification, execution, and error-handling, which has three components: an editor, an engine and a translator. Using the NOVA Editor one can graphically model workflows for many application domains, e.g., healthcare protocols, business pro- cesses, scientific workflows, etc., using the Compensable Workflow Modeling Lan- guage (CWML) [17] and write business logic for the tasks. These workflow models are executed by the NOVA Engine. Before execution, the workflow models are au- tomatically translated to DVE, the input language of the DiVinE [3] model checker, using the NOVA Translator [17]. Although we could model a large workflow and translate it into a model checking program, the time and space required for the ver- ification was sometimes unacceptable. Our experiments showed that even though DiVinE is equipped with POR and many other heuristics, it requires a huge amount of memory and time for the verification of a large model.
In this paper we present a model slicing algorithm for the workflows constructed using CWML. The algorithm has been implemented in the NOVA Translator. It takes a workflow model and the specification of a temporal logic formula φ and reduces the model in such a way that the truth of φ is preserved and reflected. Linear Temporal Logic (LTL) is a powerful tool for reasoning about system properties that vary over time. LTL is a type of temporal logic which, in addition to the classical propositional logical operators, uses the temporal operators: always (G), eventually (F ), until (U ), and next time (X). Its full semantics may be found in [4]. The slicing algorithm presented in this paper works with LTL−X formulae (the subset of LTL formulae not containing the X operator [4]).
We give the details of the proof of the equivalence of the original model and reduced model generated by our algorithm. Moreover, we show how effectively the proposed method reduces the size of the state space. We expect the proposed algorithm to be easily applied to any block-structured modelling language, e.g., BPEL [8]. Note that the algorithm deals with the feature of data-awareness now commonly found in workflow modelling languages. We show the applicability and

effectiveness of the method with a fairly big model of a healthcare workflow.
Fig. 1 shows an overview over the different steps in the proposed approach of the paper. Our workflow models M are specified by CWML. Each model M is seri- alised as a corresponding textual expression valid w.r.t. the BNFs in Definitions 2.2 and 2.3. We use the Text2TST algorithm (see Algorithm 1) to parse the expression and generate a Task Syntax Tree (TST) λ. The slicing algorithm (see Algorithm 2) is used to reduce λ to a reduced TST λj w.r.t. an LTL—X formula φ. From the reduced TST λj, the TST2Text algorithm creates a textual expression which in turn will be deserialised and visualised by NOVA Workflow as a CWML model M j. The TST2Text algorithm is not included in the paper since it is straightforward. In Section 3.3, we prove that the models M and M j are stuttering equivalent w.r.t. φ.

Fig. 1. Overview of the proposed approach

Section 2 provides some background information. In Section 3 we present the model slicing algorithm and the proof of the stuttering equivalence of a workflow model M and the corresponding reduced model M j. Section 4 presents a realistic experiment on a real world model for health services delivery. Section 5 relates our approach to other work, and Section 6 concludes the paper and outlines future research.

Preliminaries
A workflow model in CWML consists of tasks and operators connecting these tasks. The execution of some tasks are guarded by preconditions, and may perform some actions when executed. We begin by reviewing some definitions.
Definition 2.1 (Term, Precondition and Action) A term t is recursively de- fined using BNF as t ::= c | χ | t ◦A t, where ◦A ∈ {+, −, ∗, ÷}, c is a natural number and χ is a (natural) variable. A precondition is a formula ψ defined as ψ ::= t ◦C t | ψ ◦P ψ, where ◦C ∈ {<, ≤, >, ≥, ==} and ◦P ∈ {&&, }. An action α is an assignment defined as α ::= v = t; v is called an assignee variable. We abuse the notation {α} to denote a set of actions.
A compensable task can undo or rollback its operations at a later time after its successful execution, if required. In CWML, compensable tasks are composed

with t -calculus operators [11] to provide for a variety of methods of compensation. t -calculus allows one to combine compensable transactions to set up a long running business transaction which has compensation as its main error recovery technique. A compensable task consists of atomic compensable tasks composed with the com- pensable operators ◦Tc .
Definition 2.2 (Compensable Task) A compensable task Tc is recursively de-

fined using BNF as Tc ::= τc | ({ψT
}Tc1 ◦
{ψT }T
), where τc ::= ⟨id⟩{ατ , αb }

c1	Tc
c2	c2
c	τc

is an atomic compensable task which has a set of forward and compensation actions
associated to it and ⟨id⟩ is the name of the task, moreover, ◦Tc ∈{ • , ∧ , × , S , A } is a t-calculus operator. Only for Tc1 × Tc2, does each of Tc1, Tc2 have a precondition ψTc1 , ψTc2 , respectively.
The operators used to combine compensable tasks are explained as follows:
T1 • T2 (Sequential): T1 will be executed first, then T2 will be executed.
T1 ∧ T2 (Parallel): T1 and T2 will be executed in parallel. If either of them is aborted, the other one will also be aborted.
T1 × T2 (Internal choice): Exactly one of the tasks will be executed.
T1 S T2 (Speculative choice): T1 and T2 will be executed in parallel, the task that reaches the goal first will be accepted, the other one will be aborted.
T1 A T2 (Alternative forwarding): T1 will be executed first to achieve the goal, if
T1 is aborted, T2 will be executed to achieve the goal.
A task may contain both compensable tasks and uncompensable tasks, con- nected by operators.
Definition 2.3 (Task) A task T is recursively defined using BNF as T ::= τ | Tc |
({ψT }T1 ◦T {ψT }T2) | {ψT }(T )+, where τ ::= ⟨id⟩{α} is an atomic uncompensable
1	2
task which has a set of actions {α} associated to it and ⟨id⟩ is the name of the task,
moreover, ◦T ∈ {•, ∧, ×, ∨} is a binary operator, and T + is a unary operator applied to T . Only for T1 × T2, T1 ∨ T2 and T +, does each of T1, T2,T have a precondition ψT1 , ψT2 , ψT , respectively.
The operators used to combine tasks are explained as follows:
T1 • T2 (Sequential): T1 will be executed first, then T2 will be executed.
T1 ∧ T2 (Parallel): T1 and T2 will be executed in parallel.
T1 × T2 (Exclusive choice): Exactly one of the two tasks will be executed.
T1 ∨ T2 (Choice): T1 or T2 or both will be executed in parallel.
T + (Loop): T is executed once or some (specified) finite number of times as long as the precondition is true.
A workflow model M in CWML is a task with one input and one output condi- tion. The underlying semantics of M is given by a Petri net; see [16] for the Petri nets underlying each of the tasks. The state of M is determined by the marking of its underlying Petri net. A path in M is defined as follows.

Definition 2.4 (Path) Given a workflow model M , a path π = (s0 → s1 → s2 →
... ) is a sequence of states. The transition between one state and another caused
by executing a task in M . The length of a path π is the number of state changes in π.

Note that by (s0
→ s1
... s

τi j −→

sj+1
... ) we denote any path that involves the

execution of the task τi. We use πk to denote a path of length k. A task which
causes a change of state could be either uncompensable or compensable. Therefore, in Section 3.3, we are able to prove the stuttering equivalence by using structural induction on the length of the path regardless of the kind of tasks used.

Workflow Slicing
In this section, we first present an algorithm to create TSTs from CWML models. Then we present our slicing algorithm and prove that using that algorithm to reduce a workflow model will yield a model that is stuttering equivalent to the original model.
Task Syntax Tree
Workflow models specified by CWML have a graphical structure. These structures are serialised as textual expressions which are valid w.r.t. the BNFs in Defini- tions 2.2 and 2.3. These expressions are parsed and represented as task syntax trees (TST) where a non-leaf node represents an operator and a leaf node represents an atomic (possibly compensable) task (see Fig. 2). Text2TST (see Algorithm 1), which outlines how a TST is generated from textual expressions, is adapted from the standard parsing process [12] with assignment of preconditions and actions. Note

that only non-leaf nodes (operators) of × (XOR) or ∨ (OR) or or + have non-empty preconditions.
(Internal choice)



w ∨ ¸¸
c	¸¸

ψτ1 www	¸¸¸ψτ2
ψτ  cccc	¸¸¸¸ψτ

w
w,7
¸¸¸¸z#
c1
cccc
c2
¸¸¸¸

τ {α
}	τ {α  }
, c	z 

τ1
τ2
τc1
{ατc1
b τc1
}	τc2
{ατc2
τc2 }

Syntax tree with atomic uncom-
pensable tasks
Syntax tree with atomic compensable tasks

Fig. 2. Examples of workflow syntax trees


Slicing Algorithm
The slicing algorithm (see Algorithm 2) reduces the size of the workflow model based on the LTL formula subject to verification. Given a workflow, we reduce its TST λ based on the LTL formula φ that we wish to verify. In the workflow slicing algorithm, we first determine the variables occurring in φ and store them in a set E (Preserved Elements). Then, the set E will be extended recursively with tasks, preconditions, variables and actions that are visible w.r.t. the variables occurring

Input: Textual expression of workflow model M
Result: Task Syntax Tree λ
Create tokens using Lexical Analysis;
Create parse tree, λ, using the grammar provided in Definitions 2.1, 2.2, and
(while parsing, parenthesis have precedence over operators);
Assign preconditions to the immediate branch(es) of non-leaf nodes;
Assign actions to leaf nodes (atomic tasks).
Algorithm 1. Text2TST: Constructs a TST from the textual expression of a workflow model
in φ. For example, a variable is visible and added to E, though it does not occur in φ, if it affects the preconditions for an operator which in turn affects the assignment of another variable in φ.
Definition 3.1 (Visible Precondition, Action, Atomic Task, and Opera- tor) An action α is visible iff the assignee variable of α (see Definition. 2.1) is in E. An atomic (compensable) task τ is visible iff there exists any action ατ of τ which is visible. An operator is visible iff any of its operands (can be operators or tasks) is visible. Preconditions of an operator are visible iff the operator is visible.
Suppose a variable v1 is in E, then an action v1 = 1 becomes a visible action since the variable v1 is the assignee of the action; i.e., it appears at the left hand side of the assignment operation. Note that if v1 appears on the right hand side of the assignment operation, it will not make the action visible, because in this situation the action will not affect the truth value of the property to be verified.
The slicing algorithm constructs a reduced syntax tree λj by eliminating all nodes and preconditions not present in E. The next example illustrates the algorithm’s main steps.
Example 3.2 (Workflow Slicing) Fig. 3 shows a workflow model Mex containing 10 atomic tasks. The formula φ we wish to verify is: G((v1 == 1) → F (v2 == 1)), meaning that if v1 is set with value 1, v2 will eventually be set with value 1. Task preconditions are shown along the edges and task actions are shown below the tasks. The textual representation of the lower portion of the workflow is as follows: (({} Task 2 { v1 = { 1,2 } } •( { v1 == 1 } Task 5 { v2 = 1 } ×{ v1 != 1 } Task 6 { v3 = 1 } )) •{ } Task 9 { v6 = 1 }).
Fig. 4 shows the TST for Mex. The variables v1 and v2 are visible since they appear in φ. The tasks Task 2, Task 5 and Task 3 become visible since the visible variables v1 and v2 appear as assignees in their actions. Paths from these tasks to the root node are then made visible and all the preconditions (v4 != 1, v4 == 1, v1
== 1 and v1 != 1) along these paths will become visible (indicated by solid lines). Since the preconditions v4 == 1 and v4 != 1 became visible, the variable v4 becomes also visible. Task 1 becomes visible since the visible variable v4 appears as assignee in its action. The rest of λex will be invisible (indicated by dotted lines). Although the visible variable v1 appears on the right hand side of the action of Task 10, since the assignee variable v6 is not visible the action will not become visible.

Input: TST λ, and LTL formula φ
Result: Reduced TST λj
1 E → ∅;
for each variable v ∈ φ do
/* add variables from the LTL formula	*/
2	E → E ∪ {v};
3 size → 0;
while size /= E.size do
4	size → E.size;
for each leaf node η ∈ λ do
5	if  αη is visible then
6	E → E ∪ {η, αη }∪ αη.variables; ηcurr → η.parentNode;
/* recursively add all ancestors	*/
7	while ηcurr is not the root do
8	E → E ∪ {ηcurr};
/* the four operators with conditions	*/
9	if ηcurr is × or ∨ or	or + then
10	ηl → ηcurr.lef tChild; ηr → ηcurr.rightChild;
/* add all branch conditions	*/
11	E → E ∪ {ψηl , ψηr }∪ ψηl .variables ∪ ψηr .variables;
12	ηcurr → ηcurr.parentNode;

/* Construct the reduced syntax tree λj by eliminating invisible elements from λ	*/
13 λj → λ;
for each node η ∈ λj do
14	if η ∈/ E then
15	η → NIL;

Algorithm 2. The slicing algorithm



Task_6
v3 = 1

Fig. 3. A sample workflow Mex


















Task_3




Task_1
•




Task_2
v1 = {1,2}
1
x
v1 ==
Task_5

v1 = 2	v2 = 1
Fig. 4. The syntax tree λex of the workflow Mex from Fig. 3



Fig. 5. The reduced workflow M ′
of the workflow Mex from Fig. 3



The reduced workflow M j
is shown in Fig. 5. M j
has fewer concurrent tasks

but will provide the same verification result for φ (see the proof of stuttering equiv-

alence in Section 3.3). In M j
the formula φ does not hold; one of the counter ex-

amples is the following sequence of task execution: (Task 2 → Task 1 → Task 3 → Task 9 → Task end). This counter example shows that the variable v1 is set with the value 1 in task Task 2, and it is reset with another value 2 in task Task 3. For

this execution the formula G((v1 == 1) → F (v2 == 1)) does not hold in M j
and

hence not in Mex.
The complexity of the slicing algorithm is in the best case O(n), where n is the number of atomic tasks; this happens when all tasks are invisible. In this situation, the algorithm checks every task once and then stops searching. The worst case complexity is O(n2log n); this happens when the algorithm discovers a new visible element in every iteration.
Proof of Stuttering Equivalence
This section gives a proof for the stuttering equivalence of a workflow model M and the sliced model M j w.r.t. an LTL formula φ. We adapted the definition of stuttering equivalence from [4] using paths generated from the workflow model in

which each state results from the execution of one task and each transition denotes such an execution. Let V be the set of system variables, where the variables range over a finite set D, sometimes called the domain or universe of the interpretation. A valuation for V is a function that associates a value d ∈ D to each variable v ∈ V . AVP is a set of atomic valuation propositions, where each proposition typically has the form v = d. Note that AVP is a subset of the atomic propositions AP. The labelling function L : S → 2AV P returns the subset L(s) ⊆ AV P which are true in s ∈ S. Further, the visible labelling function Lφ returns for each s the subset Lφ(s) ⊆ L(s) whose variables occur in φ.
Definition 3.3 (Visible Label Function) Let φ be an LTL formula and let Vφ be the set of variables occurring in φ; the visible label function for a state s, Lφ(s), is defined as Lφ(s)= {p | var(p) ∈ Vφ}, where p is a proposition in L(s) and var(p) returns the variable of proposition p.
We now define the stuttering equivalence of paths and workflow models.
Definition 3.4 (Stuttering Equivalence of Paths) Two finite paths π = (s0 →
s2 → s3 ... ) and πj = (sj → sj → sj ... ) are stuttering equivalent w.r.t. an
LTL formula φ, written π ∼stφ πj, if there are two finite sequences of positive integers 0 = i0 < i1 < i2 < ... and 0 = j0 < j1 < j2 < ... such that for every

k ≥ 0, Lφ(si ) = Lφ(si +1) = ··· = Lφ(si
—1) = Lφ(sj ) = Lφ(sj
) = ··· =

k	k
jk+1—1).
k+1
jk	jk+1

Thus π ∼stφ πj iff the paths can be partitioned into finitely many blocks, such that the states in the kth block of π are labelled (w.r.t. φ) the same as the states in the kth block of πj.
Definition 3.5 (Stuttering Equivalence of Workflow Models) Two workflow models M and M j are stuttering equivalent (M ∼stφ M j) w.r.t. an LTL formula φ iff:
Lφ(s0) = Lφ(sj ), where s , sj are the initial states of M and M j, respectively,
i.e., M and M j have the same set of initial states (one each);
for each path π of M there exists a path πj of M j such that π ∼stφ πj; and,
for each path πj of M j there exists a path π of M such that πj ∼stφ π.
The following theorem shows that to prove that φ is invariant under stuttering, it is sufficient to show that M and M j are stuttering equivalent. The proof of the following theorem may be found in [4]. Note that M, s0 |= Aφ denotes that all paths in M starting at s0 satisfy φ.
Theorem 3.6 Any LTL—X formula is invariant under stuttering; that is, if φ is

an LTL—X formula and M ∼stφ M j then M, s0 |= Aφ iff M j, sj
|= Aφ.

Lemma 3.7 Given a workflow model M, an LTL—X formula φ and a reduced model

M j generated by the slicing algorithm, for any two paths π = s
τi
i −→
si+1
and πj = sj ,

if τi is invisible and Lφ(si) = Lφ(sj ), then Lφ(si) = Lφ(si+1) = Lφ(sj ) and hence
j	j
π ∼stφ πj.

Proof. The proof follows from the fact that the invisible task τi will not change the truth value of any propositions in Lφ(si).	2
Lemma 3.8 Given a workflow model M, an LTL—X formula φ and a reduced model

M j generated by the slicing algorithm, for any two paths π = s
τi
i −→
si+1
and πj =

sj τi	j	j	j
j −→ sj+1, if τi is visible and Lφ(si)= Lφ(sj ), then Lφ(si+1)= Lφ(sj+1) and hence
π ∼stφ πj.
Proof. The proof follows from the fact that the visible task τi will have the same effect on both Lφ(si) and Lφ(sj ).	2
Theorem 3.9 Given a workflow model M, an LTL—X formula φ and the reduced model M j generated by the slicing algorithm from M, then M ∼stφ M j.
Proof. Let φ be an LTL—X formula. The workflow model M is reduced to M j according to the slicing algorithm w.r.t. the formula φ. We will prove the theorem using structural induction on the length of paths in M and M j.
Base Case: Let π0 be a path with 0 length in M ; i.e., π0 = s0. We have to show that there exists a path πj in M j such that π0 ∼stφ πj.

Let πj = sj be a path in M j where sj
is the initial state of M j; according to the

0	0	0
slicing algorithm, Lφ(s0) = Lφ(sj ) as all the variables occurring in formula φ are visible and as a result they are preserved in M j. So, π0 ∼stφ πj .
Induction: Assume that for any path πk in M , there exists a path πj in M j, for an
l ≤ k, such that πk ∼stφ πj; that is, s0 → s1 ... s	→ s  ∼stφ sj → sj ... sj	→ sj.
l	k—1	k	0	1	l—1	l

We have to show that, for any path π
k+1
= s0
→ s1
... s
τi k −→
sk+1
in M , there exists

in M j a path stuttering equivalent to πk+1. There are two possibilities:
τi is invisible According to the slicing algorithm, τi is not present in M j.
Due to the induction hypothesis, we have s0 → s1 ... sk—1 → sk ∼stφ  sj →
τi
sj ... sj	→ sj; due to Lemma 3.7, s → s ... s	→ s	s	∼	sj →

1	l—1	l
0	1	k—1
k −→
k+1
stφ	0

sj ... sj	→ sj. That is, the path πj in M j is stuttering equivalent to π	.
1	l—1	l	l	k+1
τi is visible According to the slicing algorithm, τi is still present in M j. Due to
the induction hypothesis, we have s0 → s1 ... sk—1 → s ∼stφ sj → sj ... sj	→
k	0	1	l—1

sj; and due to Lemma 3.8, s
→ s ... s
→ s	τi  s
~	sj → sj ... sj	→

l
sj τi	j
0	1	k—1
j
k −→
j
k+1
stφ  0
1	l—1

l −→ sl+1. That is, we have a path πl+1 in M
πk+1.
that is stuttering equivalent to
2

Since the loops in our model are bounded loops, they eventually terminate and thus produce a finite number of states. We conclude that for any path in M there is a stuttering equivalent path in M j. Similarly we can prove that for any path in M j there is a stuttering equivalent path in M .

Experimental Results
The Canadian Hospice Palliative Care Association National Model (CHPCA 2002) [6] was built on an understanding of health, the illness and bereavement experiences, and the role hospice palliative care plays in relieving suffering and improving quality of life. We developed a Hospice Palliative Care (HPC) workflow, in collaboration with the local health authority the Guysborough Antigonish Strait Health Author- ity (GASHA), following the CHPCA 2002 model. This model contains general guidelines, called Norms of Care. We used the NOVA Workflow to model a HPC workflow and developed LTL formulae that the workflow must satisfy to comply with the norms.
After the patient’s referral is received, her eligibility is checked for HPC. If eligi- ble, the patient is sent for a set of therapeutic encounters which contains six essential steps – each is represented as a composite task in the “Overall” workflow (Fig. 6)– that guide the interaction between care givers, the patient and family. Fig. 6 also zooms into two composite tasks, namely PC CONSULT and CARE PLANNING. The palliative workflow has approximately 250 atomic tasks and 40 decision points. The PC CONSULT task contains uncompensable tasks and the CARE PLANNING task contains compensable tasks. Table 1 shows some preconditions and actions of tasks.

Fig. 6. Overview of the palliative care process model

Prop1 If patient is at home, then home service must be provided. Otherwise, the patient must move to the hospital (compensation via alternative choice). In LTL: G (( location == 1) → F ((home service == 1) || (location == 2))). In Fig. 6, patient’s location is set with either 1 (representing home) or 2 (representing hos- pital) at the time of registration (FILL PATIENT INFO FORM); This information is accessed inside CARE PLANNING workflow.

Table 1
Some of the tasks and their preconditions and actions from Fig. 6

Table 2
Verification results for the DiVinE model checker

Prop2 If patient is distressed, then a social worker must be assigned in the care team. LTL: G ((distressed == 1) → F( social worker == 1))
Prop3 If the patient is assigned a PPS of 50% or lower, s/he must be moved to the hospital. LTL: G ((pps ≤ 50) → F ((location == 2)))
Prop4 If the patient is with priority level of 3 or lower, s/he must be moved to the hospital. LTL: G ((patients level ≤ 3) → F ((location == 2)))
Prop5 If the patient’s mobility change is identified, a Physiotherapist is notified.
LTL: G ((change in mobility == 1) → F (ack physiotherapist == 1))
All experiments were executed with 64 CPU’s and 3GB memory (per CPU) on the Mahone2 cluster of ACEnet (www.ace-net.ca). The results are shown in Table 2. Time and memory are reduced using WS (workflow slicing) + POR (partial order reduction) compared to using POR alone. More details of these (and larger) experimental results may be found in [16].
We also perfomed a general performance comparison for different types of work- flows. These experiments were done using DiVinE 2.4 on a single CPU with 3GB of Memory. Workflows consisting only of ∧, workflows with only × and workflows with only ∨ were considered; for each operator a different number of tasks were tested. For operator ∧, the LTL property we verified was whether two tasks, e.g. Task 1 and Task 2, can occur concurrently (i.e., G( Task 1 active && !Task 2 active)). Ta- ble 3 shows the number of transitions for the verification with WS and POR for various numbers of concurrent tasks. Note that we have proved this property by contradiction, so “Accepting Cycle” “YES” means Task 1 and Task 2 execute con- currently. The slicing algorithm excludes all tasks except visible tasks. So in the result, the number of states in WS + POR remains the same. Workflows with × were tested using various number of tasks, and it was determined whether Task 1 and Task 2 were mutually exclusive (In LTL—X, G(Task 1 active → F(!Task 2 active)
|| G(Task 2 active → F(!Task 1 active)))). Workflows with operator ∨ were tested using various number of tasks, and it was determined whether the join task is even- tually reachable (In LTL—X, G F(Join operator active)). From these experimental

Table 3
Comparison for ∧ (AND), × (XOR) and ∨ (OR)

results we can see the effectiveness of the slicing; it becomes especially significant in situations where there are ∧ or ∨ with many tasks.

Related Work
Program slicing [21] is a well-studied technique. The basic idea is to abstract away variables and statements that do not influence the “point of interest”, called the slicing criterion. Program slicing can be applied to debugging, testing, software maintenance, and formal verification. Hatcliff et al. [7] extract slicing criteria using primitive propositions in LTL formulae and more importantly, define and prove formally the correctness of program slicing.
Sloane and Holdsworth [20] propose generalized slicing, which deals with differ- ent kinds of software entities and constructs. More importantly (w.r.t. the relevance of our work), they use the program syntax tree as the vehicle for the slicing algo- rithm. Unfortunately they have not included formal verification in their framework. Millett and Teitelbaum [14] propose a slicing algorithm for Promela (the input lan- guage of the model checker SPIN). Barbuti et al. [2] present, from the model check- ing point of view, a general theoretical result of an equivalence between a transition system model and the reduced one based on formulae represented in their proposed temporal logic called the selective mu-calculus. All these works strongly suggest that slicing can be applied to modelling languages at different abstraction levels.
Slicing techniques have been applied to Petri nets. Evangelista et al. [5] present a reduction technique for Coloured Petri nets (CPN). This technique only preserves the liveness of the net and only those LTL formulae that do not observe the reduced transitions of the net. Rakow [18] presents a Petri net slicing algorithm and applies it to the verification of LTL formulae; the case study in the paper is based on a small textbook workflow example. We remark that CWML can be deemed as an abstraction of CPN. We required two distinct CPN one for the atomic uncompens- able tasks and another for compensable tasks [17] as the two basic building blocks of the language and built up more complex Petri nets for each composite task. This type of abstraction is needed as real world workflows are generally complex and Petri net (including CPN) models of them can easily grow to be too large to be manageable.
There are several works that reduce the size of a workflow model. Wynn et al. [23] present reduction rules for YAWL [22] workflows with Cancellation regions and OR-joins to reduce the size of the workflow, while preserving its essential

formulae w.r.t. a particular analysis problem. There, the authors only focused on the reachability analysis, whereas our slicing method works for any LTL—X formula. Awad et al. [1] present a reduction procedure for BPMN graphs, but formal studies on the model equivalence are lacking. An ADEPT2 [19] workflow can be verified using the SeaFlows compliance checker [10]. In [10] authors discuss a data abstraction technique. As combining slicing and data abstraction is common practice in this area, we expect their technique and our slicing algorithm should complement each other well.

Conclusion and Future Work
This paper presents a model slicing algorithm. We prove the stuttering equiva- lence of the original models and the reduced models generated by the algorithm. This technique has been integrated into NOVA Workflow framework. Our exper- iments show that the technique greatly reduces the amount of memory and time for verification and makes verification of real world models of compensable systems possible.
We expect that translation of CWML to other model checkers is straightforward. Once other automated translation methods are developed, other model checkers can be used to verify large workflow models. In the future, we will consider time [13] in the model slicing algorithm as many specifications in a safety critical system such as healthcare are time sensitive. In [7] the authors defined control dependence which might be used in our approach to identify infinite loops from a model by pre- processing. In future we will enhance our work with unstructured workflow models with an infinite number of states.

Acknowledgement
This research is supported by Natural Sciences and Engineering Research Council of Canada, by an Atlantic Computational Excellence Network (ACEnet) Post Doc- toral Research Fellowship and by the Atlantic Canada Opportunities Agency. The computational facilities are provided by ACEnet.

References
Awad, A., G. Decker and M. Weske, Efficient Compliance Checking Using BPMN-Q and Temporal
Logic, in: BPM 2008: 6th International Conference on Business Process Management, Lecture Notes in Computer Science 5240 (2008), pp. 326–341.

Barbuti, R., N. D. Francesco, A. Santone and G. Vaglini, Selective Mu-Calculus and Formula-Based Equivalence of Transition Systems, Journal of Computer and System Sciences 59 (1999), pp. 537 – 556.
Barnat, J., L. Brim, M. Cˇeˇska and P. Roˇckai, DiVinE: Parallel Distributed Model Checker (Tool paper), in: Parallel and Distributed Methods in Verification and High Performance Computational Systems Biology (HiBi/PDMC 2010) (2010), pp. 4–7.
Clarke, E. M., O. Grumberg and D. A. Peled, “Model Checking,” The MIT Press, 1999.

Evangelista, S., S. Haddad and J.-F. Pradat-Peyre, Syntactical Colored Petri Nets Reductions, in:
ATVA 2005: 3rd International Symposium on Automated Technology for Verification and Analysis, Lecture Notes in Computer Science 3707 (2005), pp. 202–216.
Ferris, F. D., H. M. Balfour, K. Bowen, J. Farley, M. Hardwick, C. Lamontagne, M. Lundy, A. Syme and P. J. West, A Model to Guide Hospice Palliative Care (2002).
Hatcliff, J., M. B. Dwyer and H. Zheng, Slicing Software for Model Construction, Higher Order and Symbolic Computation 13 (2000), pp. 315–353.
IBM, Bea, Microsoft, SAP and Siebel, “Business Process Execution Language for Web Services Version
1.1,” (2003).
Ip, C. N. and D. L. Dill, Better Verification Through Symmetry, Formal Methods System Design 9
(1996), pp. 41–75.
Knuplesch, D., L. T. Ly, S. Rinderle-Ma, H. Pfeifer and P. Dadam, On enabling data-aware compliance
checking of business process models, in: ER 2010: 29th International Conference on Conceptual Modeling, Lecture Notes in Computer Science 6412 (2010), pp. 332–346.
Li, J., H. Zhu, G. Pu and J. He, A Formal Model for Compensable Transactions, in: ICECCS 2007: 12th IEEE International Conference on Engineering Complex Computer Systems (2007), pp. 64–73.
Louden, K. C., “Compiler Construction: Principles and Practice,” Course Technology, 1997.
Mashiyat, A. S., F. Rabbi and W. MacCaull, Modeling and Verifying Timed Compensable Workflows
and an Application to Health Care, in: Proceedings of FMICS 2011: 16th International Workshop on Formal Methods for Industrial Critical Systems, Lecture Notes in Computer Science 6959 (2011), pp. 244–259.
Millett, L. I. and T. Teitelbaum, Slicing Promela and its Applications to Model Checking, Simulation, and Protocol Understanding, in: SPIN 1998: 4th International SPIN Workshop, 1998, pp. 75–83.
Peled, D., Ten years of partial order reduction, in: CAV 1998: the 10th International Conference on Computer Aided Verification, Lecture Notes in Computer Science 1427 (1998), pp. 17–28.
Rabbi, F., “Design, Development and Verification of a Compensable Workflow Modeling Language,” Master’s thesis, Dept. of Math., Stats. and CS, StFX University, Canada (2011).
Rabbi, F., H. Wang and W. MacCaull, Compensable Workflow Nets, in: Proceedings of ICFEM 2010: 12th International Conference on Formal Engineering Methods, Lecture Notes in Computer Science
6447 (2010), pp. 122–137.
Rakow, A., Slicing Petri Nets with an Application to Workflow Verification, in: SOFSEM 2008: 34th Conference on Current Trends in Theory and Practice of Computer Science, Lecture Notes in Computer Science 4910 (2008), pp. 436–447.
Reichert, M., S. Rinderle, U. Kreher, H. Acker, M. Lauer and P. Dadam, ADEPT2 - Next Generation Process Management Technology, in: 4th Heidelberg Innovation Forum (2007).
Sloane, A. M. and J. Holdsworth, Beyond Traditional Program Slicing, in: ISSTA 1996: International Symposium on Software Testing and Analysis (1996), pp. 180–186.
Tip, F., A Survey of Program Slicing Techniques, Journal of Programming Languages 3 (1995), pp. 121– 189.
van der Aalst, W. M. P. and A. H. M. ter Hofstede, YAWL: yet another workflow language, Information Systems 30 (2005), pp. 245–275.
Wynn, M. T., W. M. P. van der Aalst, A. H. M. T. Hofstede and D. Edmond, Reduction Rules for YAWL Workflows with Cancellation Regions and OR-Joins, Information and Software Technology 51 (2009), pp. 1010–1020.
