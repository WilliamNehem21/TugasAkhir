Electronic Notes in Theoretical Computer Science 174 (2007) 27–45	
www.elsevier.com/locate/entcs
Rewrite-Based Decision Procedures
Maria Paola Bonacina1	Mnacho Echenim2
Dipartimento di Informatica Universita` degli Studi di Verona Ca’ Vignal 2, Strada Le Grazie 15 37134 Verona, Italy

Abstract
The rewrite-based approach to satisfiability modulo theories consists of using generic theorem-proving strate- gies for first-order logic with equality. If one can prove that an inference system generates finitely many clauses from the presentation T of a theory and a finite set of ground unit clauses, then any fair strategy based on that system can be used as a T -satisfiability procedure. In this paper, we introduce a set of sufficient conditions to generalize the entire framework of rewrite-based T -satisfiability procedures to rewrite-based T -decision procedures. These conditions, collectively termed subterm-inactivity, will allow us to obtain rewrite-based T -decision procedures for several theories, namely those of equality with uninterpreted func- tions, arrays with or without extensionality and two of its extensions, finite sets with extensionality and recursive data structures.
Keywords: Rewrite-based inference systems, T -decision procedures


Introduction
The rewrite-based approach to satisfiability modulo theories introduced in [3] was used in [3,1] to devise decision procedures for satisfiability in several theories of data structures, including the theories of arrays and records. The idea behind this approach is to use generic theorem-proving strategies based on the superposition calculus SP on input sets consisting of the presentation of the considered theory T and ground unit clauses. Since such strategies are semi-decision procedures for first-order validity, if one can prove that they terminate for any set of ground unit clauses, then they are actually decision procedures for T -satisﬁability. Another fea- ture that makes the rewrite-based approach appealing is that the combination of several theories becomes conceptually simple: if termination is preserved, it suffices to consider the union of the presentations. Preservation of termination requires to

1 Email: mariapaola.bonacina@univr.it
2 Email: echenim@sci.univr.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.042

show that the inference system is modular with respect to termination. Such a mod- ularity result was obtained in [1] by introducing the notion of variable-inactivity : if the combined theories are variable-inactive, a strategy based on SP terminates on their combination, provided it terminates on each individual theory. As far as efficiency is concerned, contrary to the common expectation that a generic theorem- prover would be outperformed by more specialized systems such as CVC ([6,15]) or CVC Lite ([4]), the experimental results of [1] showed that this is not the case, and that such procedures are very efficient on several problems.
The next step is to investigate how to generalize the rewrite-based approach to T -decision problems, or deciding T -satisfiability of quantifier-free formulae. Of course, a T -satisfiability procedure could be applied after reduction to disjunctive normal form, but this approach is not practical. Another method would be to investigate how to integrate rewrite-based T -satisfiability procedures with a SAT solver, as done for example in [7,10,2,12,5] for T -satisfiability procedures based on congruence closure. Here, we choose instead to study the problem of whether rewrite-based theorem-proving strategies can be themselves T -decision procedures.
The main contributions of the paper are the following:
We introduce the notion of subterm-inactivity and prove that if a theory T is subterm-inactive, a fair SP-based strategy is a decision procedure for the T - decision problem.
The conditions to be met for a theory to be subterm-inactive are easy to test, and all but one can be tested automatically. This is a significant advantage, compared to the termination proofs of [3,1] where one has to analyze the inferences that can be carried out starting from the presentation T and a set of ground unit clauses. Furthermore, the only requirement we impose on the complete simplification ordering > assumed by SP is that t > c for every compound term t and constant c.
We prove that every subterm-inactive theory is also variable-inactive.
We show that several of the theories considered in [3,1], as well as two extensions of the theory of arrays, are subterm-inactive.
Due to a lack of space, most of the proofs could not be included in this paper.
They can all be found in [8].

Preliminaries
Terms, literals and clauses
Given a signature Σ, Σn denotes the set of functions in Σ with arity n. Thus, Σ0 denotes the set of constants in Σ. We consider the standard definitions of Σ-terms, Σ-literals and Σ-clauses. As usual, clauses are assumed to be variable-disjoint. In
the following,  is unordered equality, da is either  or / . The letters l, r, u, v and
t will denote terms, w, x, y, z variables, and all other lower-case letters will denote constants or function symbols. Given a term t, top(t) is the symbol appearing as

t’s top symbol, and Var(t) denotes the set of variables appearing in t. We will also consider the natural extension of Var to literals and clauses: for example, if C is a clause, then Var(C) is the set of variables appearing in C.
Given the presentation T of a theory, a function symbol is interpreted if it appears in an axiom of T , and it is uninterpreted otherwise. The T -satisﬁability problem is the problem of deciding whether a set of ground unit clauses is satisfiable in T . The more general T -decision problem is the problem of deciding the satisfia- bility of any ground formula in T . Without loss of generality, we can assume that the considered ground formulae are conjunctions of clauses.
Definition 2.1 Given a signature Σ, a selection function is a function from Σ to N such that for all f ∈ Σ, Γ(f ) ∈ {1,... , arity(f)}. ΩΣ denotes the set of selection functions for Σ.
A selection function selects an argument in a term. For example, for a function symbol f and selection function Γ, if Γ(f )= i, then Γ selects the subterm ti from the term f (t1,... , tn). The name “selection function” is also used for functions that select a literal in a clause: the two definitions are compatible, since such functions can be seen as selecting an argument of a disjunction operator.
We define the notion of symbol-freeness, which prevents some function or con- stant symbols from appearing in a clause.
Definition 2.2 (Symbol-freeness) Given a term t, Φ(t) denotes the set of func- tion and constant symbols appearing in t. Also, let Φ(l da r) = Φ(l) ∪ Φ(r) and Φ(C)=  L∈C Φ(L). Given a set of function and constant symbols Σ', a term t is Σ'-symbol-free if Φ(t) ∩ Σ' consists only of constants, and t is strictly Σ'-symbol-free
if this intersection is empty. A literal (resp. clause) is Σ'-symbol-free if every term appearing in it is. A clause is subsymbol-free from Σ' if every literal in C that contains a function symbol is strictly Σ'-symbol-free.

Flattening
If a term t is a constant or a variable, then the depth of t is depth(t) = 0, otherwise depth(f (t1,... , tn)) = 1 + max{depth(ti) | i = 1,... , n}. The depth of the literal l da r is max(depth(l), depth(r)). A positive literal is flat if depth(l) +depth(r) ≤ 1, and a negative literal is flat if its depth is 0.
Definition 2.3 A literal is strictly flat if its depth is 0. For a clause C, let Maxd(C) = max{depth(t) | t is a term appearing in C}. The clause C is flat, re- spectively, strictly flat, if all its literals are.
We will make an intensive use of flattening. The operation of flattening consists in transforming a finite set of ground clauses S over a signature Σ, into a finite set of ground clauses S' over a signature Σ', in such a way that:
Σ' is obtained by adding a finite number of constants to Σ,
every non-unit clause in S' is strictly flat,



Fig. 1. Expansion inference rules of £P: in expansion rules, what is below the inference line is added to the clause set that contains what is above the inference line.
every unit clause in S' is flat,
for all sets 7 , 7 ∪ S and 7 ∪ S' are equisatisfiable.
This flattening operation is fairly straightforward, and it is more general than the one in [3], where only unit clauses are considered. As an example, consider the set S = {f (f (a))  b V f (c) / d}: by introducing fresh constants c1, c2 and c3, we obtain the equisatisfiable set
S' = {f (a)  c1, f (c1)  c2, f (c)  c3, c2  b V c3 / d}.

Rewrite-based inference systems
A simpliﬁcation ordering > is an ordering that is stable, monotonic and contains the subterm ordering: if s > t, then c[s]σ > c[t]σ for any context c and substitution σ, and if t is a subterm of s then s > t. A complete simpliﬁcation ordering, or CSO, is a simplification ordering that is total on ground terms. We write t < s if s > t. More details on orderings can be found, e.g., in [11].
In the sequel, except stated otherwise, we will assume that for the considered CSO, if t is a compound term and c a constant, then t > c. This condition is part



Fig. 2. Contraction inference rules of £P: in contraction rules, what is above the double inference line is removed from the clause set and what is below the double inference line is added to the clause set.
of the 7 -goodness requirement for all the theories considered in [1]. We refer to this requirement simply as the goodness requirement.
The superposition calculus, or SP (see [13]), is a rewrite-based inference system which is refutationally complete for first-order logic with equality. It consists of expansion rules (see Figure 1) and contraction rules (see Figure 2), and is based on a CSO on terms which is extended to literals and clauses in the standard way. Given a CSO >, we write SP> for SP equipped with >. A clause C is redundant with respect to SP in a set of clauses S, if S can be derived from S ∪ {C} by application of a contraction rule in SP. Since SP is the only inference system in this article, we write redundant for redundant with respect to SP. An inference is redundant in S, if either its conclusion or one of its premises is redundant in S.
An SP-strategy is given by SP together with a search plan that controls the application of the inference rules. An SP>-derivation is a sequence
S0 ▶£P> S1 ▶£P> ... Si ▶£P> ... ,
where each Si is a set of clauses, obtained by applying an expansion or a contraction rule to clauses in Si−1. The limit of such a derivation is the set of persistent clauses:
S∞ =	Si.
j≥0 i≥j
A derivation S0 ▶£P> ... Sn ▶£P> ... is fair with respect to SP> if all expansion inferences in SP> with premises in S∞ are redundant in some Sj for j ≥ 0. A search plan is fair if all the derivations it controls are fair, and an SP>-strategy is fair if its search plan is. A set of clauses S is saturated if every clause generated from clauses in S by an SP-inference is redundant.
A clause C is variable-inactive for > (see [1]) if no maximal literal in C is an equation t  x, where x ∈/ Var(t). A set of clauses is variable-inactive for > if all

its clauses are variable-inactive for >. A presentation 7 is variable-inactive for > if the limit S∞ of a fair SP>-derivation from S0 = 7 ∪ S is variable-inactive. When no confusion is possible, we will say that a clause (resp. a set of clauses or a theory presentation) is variable-inactive, without any mention of >.
We conclude the preliminaries with the notion of depth-preservation. Intuitively, this notion prevents the clauses generated by the expansion inference rules from becoming arbitrarily large.
Definition 2.4 Let C, C' and D be clauses, and suppose D is generated from C by a unary inference: this inference is depth-preserving if Maxd(D) ≤ Maxd(C). Suppose D is generated from C and C' by a binary inference: this inference is depth-preserving if Maxd(D) ≤ max{Maxd(C), Maxd(C')}.
Subterm-inactivity
The proofs that the superposition calculus terminates on satisfiability problems for different theories are based on an enumeration of the kinds of clauses that can be generated by the inferences (see [3,1,8]). However, the number of clauses in S∞ can
n2
be exponentially large (it can contain for example up to O(2  ) clauses in the theory
of arrays, see [1] for details), and in general, such proofs consist of showing that all generated clauses belong to one of several categories: if each of these categories contains a finite number of clauses, so will S∞. These proofs can be quite long, and at each new inference, a new category to deal with may arise. In this section, we introduce a set of conditions guaranteeing that a fair strategy based on SP> is a decision procedure for the considered theory. These conditions are easy to verify and more importantly, almost all can be verified automatically.
Informally, we will consider 7 -decision problems whose clauses can be divided into three disjoint sets:
a set Tg of ground clauses,
a set T1 of non-ground clauses representing properties that can be deduced by considering one interpreted function symbol,
a set T2 of non-ground clauses representing the way two interpreted function symbols may interact in 7 .
This pattern applies to 7 -decision problems in several theories of interest such as, for example, the theory of arrays.
Example 3.1 The theory of arrays A, based on the signature ΣA = {select, store}, where select has arity 2 and store has arity 3, is axiomatized as follows:
∀x, z, v. select(store(x, z, v), z)  v,	(1)
∀x, z, w, v. (z  w V select(store(x, z, v), w)  select(x, w)).	(2)
The theory of arrays with extensionality Ae is defined by axioms (1) and (2), along with the following extensionality axiom:
∀x, y. (∀z. select(x, z)  select(y, z) ⊃ x  y).	(3)

A rewrite-based 7 -decision procedure for the theory Ae takes as input a set Tg of ground clauses, together with {(1), (2), (3)}. This set can itself be decomposed into two disjoint subsets: T2 = {(1), (2)} which describes the way select and store interact, and T1 = {(3)} which describes the equality property that can be deduced from the select function.
Of course, these sets can interact with each other, and it is necessary to control these interactions as much as possible in order to guarantee termination. Before giving any formal definition, we informally enumerate the requirements that should be satisfied by these sets and which conditions are imposed to satisfy them.
General properties
Each clause in T2 expresses a single property verified when combining at most two interpreted function symbols, and each clause in T1 expresses a property that can be deduced by considering a single interpreted function symbol (closure);
Any SP>-inference generating a persistent clause is depth-preserving (flatness).
Binary inferences
There is no binary SP>-inference between a clause in T2 and one in T1
(interaction-freeness);
A binary SP>-inference between a clause in T1 ∪ T2 and a clause in Tg gen- erates a clause in T1 or in Tg (closure + negative disconnection);
A binary SP>-inference between two clauses in T2 generates a clause which is deleted eventually (saturation);
A binary SP>-inference between two clauses in T1 generates a clause in T1
or in Tg (closure).
Unary inferences
A unary inference within T2 generates a clause that is deleted eventually (saturation);
A unary inference within T1 generates a clause that is in T1, in Tg, or is deleted eventually (variable-inactivity preservation).
In the following subsections we formally define these notions.
Restrictions on T2
The conditions we impose on T2 are termed collectively saturation closure. Infor- mally, these conditions ensure that T2 is saturated, and that every clause generated by a binary inference involving a clause in T2 is in T1 or in Tg.
Definition 3.2 (Ordered flatness) A clause C is ordered flat if it only contains strictly flat literals except for one, say l da r. Furthermore, it must be r < l, and r must contain only function symbols appearing in l.
Example 3.3 Consider the following clauses:

C = f (a)  b V c / d,
C' = f (g(a))  g(a) V c / d.
These two clauses are ordered flat.
Definition 3.4 (Internal closure) Let S be a set of clauses and Γ be a selection function. S is Γ-internally closed if for every clause C ∈ S and every non-strictly flat literal L = l da r in C:
If L is negative, then:
icn.1: for every subterm u of l of depth 1, Var(C) ⊆ Var(u), icn.2: every positive literal in a clause of S is Φ(L)-symbol-free.
If L is positive, then we must have r < l and:
icp.1: depth(l) = 2, and l contains a unique subterm u of depth 1, icp.2: Var(C)= Var(l),
icp.3: if top(r) /= top(l), then depth(r)= 0 and Var(C) ⊆ Var(u),
icp.4: if top(r)= top(l), then depth(r)= 1, r|qf = l|qf , l|qf appears nowhere else in l or r, and Var(l) \ Var(u)= {l|qf }.
By also imposing that T2 is saturated and that every literal appearing in T2 that contains a constant is strictly flat (formally, that every clause is subsymbol-free from Σ0), we obtain the following definition of saturation closure:
Definition 3.5 (Saturation-closure) Let Γ ∈ ΩΣ, a set of clauses S is Γ- saturation-closed if
it is saturated,
every clause in S is subsymbol-free from Σ0,
every clause in S is ordered flat,
S is Γ-internally closed.

Restrictions on T1
The restrictions imposed to T1 prevent its clauses from interacting with T2, and control the clauses generated by inferences involving these clauses.
Definition 3.6 (Weak flatness) A clause C is weakly flat, if C only contains literals with terms of depth at most 1, and at least one non-ground literal l da r which is not strictly flat. Furthermore, if C contains a literal x da t, then t is of depth 0.
Example 3.7 The clause C = f (a)  b V f (x) / d is weakly flat.
Definition 3.8 (Variable-inactivity preservation) Given a function Γ ∈ ΩΣ,a clause C is Γ-variable-inactive preserving if and only if:
vip-1: For every variable x ∈ Var(C) and for every literal L in C which is not strictly flat, x is a variable of a term of depth 1 in L.

vip-2: If C contains a negative literal l / r with top(l)= top(r)= f , then C also contains a literal x t such that either t is a variable and Var(C) ⊆ {x, t}, or Var(C)= {x}. Furthermore, let qf = Γ(f ), then:
if t is a variable, then {x, t} = {l|qf , r|qf },
if t is a constant, then there is a constant c (not necessarily equal to t) such that {x, c} = {l|qf , r|qf }.
A set of clauses S is Γ-variable-inactive preserving if every clause in S is.
Example 3.9 Let ΣI = {Inj}, where Inj is a predicate of arity 1, and consider the theory AI , based on the signature ΣA ∪ ΣI , which is axiomatized by axioms (1) and
(2) of Example 3.1, and the following axiom denoted by (inj):
Inj(x) ⇔ ∀z, w. (z / w ⊃ select(x, z) / select(x, w)).
Intuitively, the predicate Inj is true for array a if and only if all the elements in a are pairwise distinct (a is injective). Consider the following clausal form, logically equivalent to Inj(a):
C = z  w V select(a, z) / select(a, w).
This clause contains a single literal that is not strictly flat, L = select(a, z) / select(a, w). We have Var(C)= {z, w}, and these two variables appear in terms of depth 1 in L. Let Γ be any function in ΩΣ such that Γ(select) = 2. Since z  w is also a literal in C and condition (vip.2.a) holds on C, this clause is Γ-variable- inactive preserving.
Definition 3.10 (External closure) Let C be a clause, S' be a set of clauses, Γ ∈ ΩΣ, and for every f ∈ Σ, let qf = Γ(f ). C is Γ-externally closed from S' if for every positive literal l  r in C such that top(l)= f ,
ec.1: top(l)= top(r),
ec.2: all the other literals in C are strictly flat,
ec.3: l|qf = r|qf is the only variable in C and this variable appears nowhere else in l or r.
ec.4: every negative literal in a clause of S' is {f }-symbol-free.
A set of clauses S is Γ-externally closed from S' if every clause in S is.
Example 3.11 Let ΣS = {Swap}, where Swap is a predicate that has arity 4, and consider the theory AS , based on signature ΣA ∪ ΣS and axiomatized by (1), (2) (the axioms of A, see Example 3.1) and the following axiom denoted by (swp):
Swap(x, y, z1, z2) ⇔ select(x, z1)   select(y, z2) ∧
select(x, z2)  select(y, z1) ∧
∀w. (w / z1 ∧ w / z2 ⊃ select(x, w)  select(y, w)).
Given constants b, b',i and i', the atom Swap(b, b', i, i') is true if and only if b' is identical to b, except that the elements at indices i and i' are swapped. Consider the clause
D = w  i V w  i' V select(b, w)  select(b', w).

Let Γ be any function in ΩΣ such that Γ(select) = 2, and let S' = {(1), (2)}. It is simple to check that D satisfies conditions (ec.1) to (ec.4), and is therefore Γ-externally closed from S'.
Definition 3.12 (Immunity) Given two sets of clauses S and S' and a function Γ ∈ ΩΣ, S is Γ-immune from S' if and only if
every clause in S is weakly flat,
every clause in S is Γ-variable-inactive preserving,
S is Γ-externally closed from S'.
Definition 3.13 (Interaction-freeness) Given two sets of clauses S and S' and a function Γ ∈ ΩΣ, S is Γ-interaction-free from S' if the following condition is satisfied: let f be a function symbol, let pf = Γ(f ), and suppose that
either f occurs at the same time in a positive literal of a clause in S and in a literal of a clause in S',
or f occurs at the same time in a positive literal of a clause in S' and ina literal of a clause in S.
Then for all clauses C ∈ S ∪ S' containing a literal L = l da r, such that f appears in l or in r, the following conditions must hold:
if.1: f only appears as the top symbol of l or r,
if.2: if C ∈ S, then l|pf is a constant, and if r is neither a constant nor a variable, then r|pf is a constant,
if.3: if C ∈ S' and L is negative, then l|pf is a term of depth 1,
if.4: if C ∈ S' and L is positive, then u = l|pf is a term of depth 1, and if r is neither a constant nor a variable, then r|pf is either a constant or a variable in Var(u).
Example 3.14 Consider S = {D}, where D is the clause of Example 3.11 and S' = {(1), (2)}. The only function symbol these sets have in common is select. Let Γ be any function in ΩΣ such that Γ(select) = 1. Then it is clear that D satisfies conditions (if.1) and (if.2), and that the clauses in S' satisfy condition (if.4). Thus, S is Γ-interaction-free from S'. Similarly, consider the clause C from Example 3.9, then {C} is also Γ-interaction-free from S'.

Restrictions on Tg
We finally define the notion of flat disconnection for Tg.
Definition 3.15 (Positive flatness) A clause C is positively flat if each time C contains a positive literal which is not strictly flat, this literal is flat and all the other literals in C are strictly flat.
Example 3.16 Consider the following clauses:

C = f (a)  b V c / d,
C' = f (f (a)) / b V f (c) / d,
The clauses C and C' are both positively flat.
Definition 3.17 (Negative disconnection) Let C be a clause and S' be a set of clauses. C is negatively disconnected from S' if whenever C contains a negative literal l / r such that depth(l) ≥ 2, every positive literal of a clause in S' is Φ(C)- symbol-free. A set of clauses S is negatively disconnected from S' if every clause in S is negatively disconnected from S'.
Definition 3.18 (Flat-disconnection) Given a clause C and a set of clauses S',
C is flat-disconnected from S' if and only if C is
positively flat,
negatively disconnected from S'.
A set of clauses S is flat-disconnected from S' if every clause in S is.
Example 3.19 Any set of flattened ground clauses is flat-disconnected from any other set of clauses S'. Indeed, such a set is trivially positively flat; since all its negative literals are strictly flat, there is no literal l / r with depth(l) ≥ 2, and the set is also negatively disconnected from S'.

Subterm-inactivity
We introduce the fundamental notion of subterm-inactivity, which guarantees the termination of £У on the decision problem in the considered theory.
Definition 3.20 (Subterm-inactivity) Let Tg, T1 and T2 be three disjoint sets of clauses. The tuple ⟨Tg, T1, T2⟩ is subterm-inactive if there exist two functions Γ and Γ' in ΩΣ such that:
Tg only contains ground clauses and is flat-disconnected from T1 ∪ T2,
T1 is Γ-immune and Γ'-interaction-free from T2,
T2 is Γ-saturation-closed.
A presentation of a theory 7 is subterm-inactive if there exists a partition Tg T1 T2
of 7 such that ⟨Tg, T1, T2⟩ is subterm-inactive.
Since we can flatten any set of ground clauses, we can safely add it to a subterm- inactive presentation:
Proposition 3.21 If 7 is a subterm-inactive presentation, then for every set of ground clauses S, there exists a set of ground clauses S' such that S' ∪7 is equi- satisﬁable to S ∪7 , and S' ∪7 is subterm-inactive.
We will give several examples of subterm-inactive theories in the following sec- tion. Before that, we state the main results we obtain under the subterm-inactivity hypothesis:

Theorem 3.22 Given a set of clauses 7 = Tg  T1  T2 such that ⟨Tg, T1, T2⟩ is a subterm-inactive tuple:
If D is a persistent clause generated by an £У-inference in 7 , then the inference is depth-preserving and:
either D is ground and ⟨Tg ∪ {D}, T1, T2⟩ is subterm-inactive,
or D is not ground and ⟨Tg, T1 ∪ {D}, T2⟩ is subterm-inactive.
A fair £У>-strategy is a decision procedure for 7 .
7 is variable-inactive.
The proof of Theorem 3.22, and especially of (i) requires considering all possible inferences that can be applied to the sets Tg, T1 and T2. The complete treatment of the different cases and the other proofs can all be found in [8].
Variations on the theory of arrays
In what follows, we consider the theory of arrays (see Example 3.1) and two of its extensions. It was shown in [3] that a satisfiability problem in Ae can be reduced to an equisatisfiable satisfiability problem in A, and that the superposition calculus provides a satisfiability procedure for A: a proof that the limit S∞ is finite can be found in [1]. This kind of analysis requires long proofs: for A, the clauses in S∞ can belong to any one of 14 classes of clauses. We have the following result:
Theorem 4.1 The presentation of A is subterm-inactive.
Proof. We prove that the tuple ⟨∅, ∅, {(1), (2)}⟩ is subterm-inactive.
The only inference that can be applied to {(1), (2)} is a superposition between
(1) and (2). This generates the clause z  z V select(x, z)  v, which is deleted. Thus, this set is saturated.
It is trivial to check that the clauses in {(1), (2)} are ordered flat. Since they do not contain any constants, they are also subsymbol-free from Σ0.
The maximal literals in (1) and (2) are both positive and one can check that
{(1), (2)} is Γ-internally closed, for any selection function Γ such that Γ(select) = 2.

Thus, by Theorem 3.22 (ii), we deduce that:
Corollary 4.2 Any fair £У>-strategy is a decision procedure for the theory of ar- rays with or without extensionality.
An injectivity predicate
Next, we consider the theory AI of arrays augmented with an injectivity predicate, as defined in Example 3.9:
Inj(x) ⇔ ∀z, w. (z / w ⊃ select(x, z) / select(x, w)).

We assume that each occurrence of the injectivity predicate has a constant as an argument. There is no loss of generality under this assumption. For example, the clause Inj(f (a)) V B can be safely replaced by the clause Inj(b) V B and the flat literal f (a)  b, where b is a fresh constant. Still without loss of generality, we may suppose that if the injectivity predicate appears in a non-unit clause, then this clause is of the form Inj(a) V чp or чInj(a) V чp, where p is a propositional variable. Indeed, such a formula can be obtained from S by repeatedly replacing clauses of the form Inj(a) V D (resp. чInj(a) V D), where D is not a propositional variable, by the clauses Inj(a) V чpa and pa V D (resp. чInj(a) V чpa and pa V D), where pa is a fresh propositional variable. The formula thus obtained is equisatisfiable to S (see [14] for details).
We remove all occurrences of the predicate Inj in the following way. For every constant a, we consider the clause Ca and its negated form C' , respectively defined
by:
Ca = z  w V select(a, z) / select(a, w),
C' = (sk1 / sk2 Λ select(a, sk1)  select(a, sk2)),
where sk1 and sk2 are fresh Skolem constants. Note that, by definition, Inj(a) is logically equivalent to 6z, w. (z / w э select(a, z) / select(a, w)), and Ca is the clausal form of the latter formula. Thus, Ca and Inj(a) are logically equivalent;

similarly, C'
and чInj(a) are also logically equivalent.

We can therefore safely replace every clause of the form Inj(a) V чp by Ca V чp, and every clause of the form чInj(a) V чp by the clausal form of C' V чp.
Example 4.3 Let S = {чInj(a) V Inj(b)}. By introducing the fresh propositional variable pa we obtain the set S' = {чInj(a) V чpa, Inj(b) V pa}, and after the aforementioned transformation we get
S'' = { sk1 / sk2 V чpa,
select(a, sk1)  select(a, sk2) V чpa,
z  w V select(b, z) / select(b, w) V pa}
where z and w are implicitly universally quantified variables.
Given a set of clauses S, the reduced set of clauses thus obtained is equisatisfiable to S, and we have the following:
Lemma 4.4 Let {a1,... , an} be a set of constants, for all i ∈ {1,... , n} let pi be a propositional variable (or the negation of a propositional variable) and deﬁne
Ci = 6z, w. z  w V select(ai, z) / select(ai, w).
The theory A∪ {Ci V pi | i = 1,... , n} is subterm-inactive.
Proof. We show that the tuple ⟨∅, {C1 V p1,... , Cn V pn}, {(1), (2)}⟩ is subterm- inactive. In Theorem 4.1, we showed that {(1), (2)} is Γ-saturation-closed with Γ(select) = 2. Consider any function Γ' ∈ ΩΣ such that Γ'(select) = 1, and a

clause Ci V pi. This clause is Γ-immune from {(1), (2)}: we have shown that Ci is Γ-variable-inactive preserving in Example 3.9, and it is simple to verify that Ci V pi is also Γ-externally closed from {(1), (2)}; the other conditions are trivial to verify. It is also Γ'-interaction-free from {(1), (2)}, hence the result.
Since these conditions are satisfied for every clause of the form Ci V pi, it is clear that ⟨∅, {C1 V p1,... , Cn V pn}, {(1), (2)}⟩ is subterm-inactive and the proof is complete.	 
Thus, by Theorem 3.22 (ii), an £У>-strategy together with a fair search plan can be used to test the satisfiability of A∪ {Ci V pi | i = 1,... , n}. We therefore have the following result:
Corollary 4.5 A fair £У>-strategy is a decision procedure for AI .
A Swap predicate
We now turn to the theory AS of arrays augmented with a swap predicate, as defined in Example 3.11:
Swap(x, y, z1, z2) e select(x, z1)   select(y, z2) Λ
select(x, z2)  select(y, z1) Λ
6w. (w / z1 Λ w / z2 э select(x, w)  select(y, w)).
Consider a ground AS -formula S. Similar to the case of the injectivity predicate, up to adding flat equalities to S, we assume that each occurrence of the swap pred- icate only has constants as arguments, and that the clauses in which this predicate appears are of the form Swap(b, b', i, i') V чp or чSwap(b, b', i, i') V чp.
We remove all occurrences of the predicate Swap in the following way: for every tuple of constants G = ⟨b, b', i, i'⟩, where b and b' are of sort array and i and i' are

of sort index, we consider the formula DG and its negated form D'
respectively

defined by:
DG = select(b, i)  select(b', i') Λ select(b, i')  select(b', i)Λ 6w. (w / i Λ w / i' э select(b, w)  select(b', w))
'  = select(b, i) / select(b', i') V select(b, i') / select(b', i)V
(sk / i Λ sk / i' Λ select(b, sk) / select(b', sk)),
where sk is a fresh Skolem constant. By definition, Swap(b, b', i, i') and DG are log-

ically equivalent, and one can check that чSwap(b, b', i, i') and D'
are also logically

equivalent.
Given a tuple G = ⟨b, b', i, i'⟩, we can therefore safely replace every formula of the form Swap(b, b', i, i') V чp by the clausal form of DG V чp, and every formula of

the form чSwap(b, b', i, i') V чp by the clausal form of D'
V чp. The set we obtain

is equivalent to S. In the following lemma, the clause Dk comes from the clausal
form of DG; the rest of the clausal form of DG is ground, as is the clausal form of
D' : they are not needed to prove subterm-inactivity.

Lemma 4.6 Let {bk, b' , ik, i' | k = 1,... , m} be a set of constants and for every
k	k
k ∈ {1,... , m}, let pk be a propositional variable (or the negation of a propositional
variable) and consider the clause
Dk = w  ik V w  i' V select(bk, w)  select(b' , w).
The theory A∪ {Dk V pk | k = 1,... , m} is subterm-inactive.
Proof. We prove that ⟨∅, {D1 V p1,... , Dm V pm}, {(1), (2)}⟩ is subterm-inactive. It is simple to check that {(1), (2)} is Γ-saturation-closed with Γ(select) = 2. Consider a clause Dk, it can be seen by applying Definition 3.12 that Dk V pk is Γ-immune from {(1), (2)} (see also Example 3.11). As shown in Example 3.14, Dk is Γ'- interaction-free from {(1), (2)} for any Γ' such that Γ'(select) = 1, and it is simple to show that Dk V pk is also Γ'-interaction-free from {(1), (2)}. Hence, for every k,
⟨∅, {Dk V pk}, {(1), (2)}⟩ is subterm-inactive. Since this is true for every k, we have the result.	 
As for Corollary 4.5, we deduce:
Theorem 4.7 A fair £У>-strategy is a decision procedure for AS .
Finally, consider the theory A' axiomatized by (1), (2), (inj) and (swp), and let Γ and Γ' be selection functions such that Γ(select) = 2 and Γ'(select) = 1. Given the sets A = {Ci V pi | i = 1,... , n} and B = {Dk V p' | k = 1,... , m}, and for the
selection functions Γ and Γ' defined above,
⟨∅, A, {(1), (2)}⟩ is subterm-inactive by Lemma 4.4,
⟨∅, B, {(1), (2)}⟩ is subterm-inactive by Lemma 4.6.
We deduce that the tuple ⟨∅, A∪B, {(1), (2)}⟩ is also subterm-inactive. We therefore have the following result:
Theorem 4.8 A fair £У>-strategy is a decision procedure for A'.
A non-obvious example
The next example shows that although the conditions required for a tuple to be subterm-inactive are quite strong, some of them are tight, and allow us to point out some non-obvious results.
Example 4.9 Consider the following predicate: Consty(x) e 6z. select(x, z)  y,
that expresses the property that an array represents a constant function. It is easy to check that given two constants a and e, 7 = A∪ {Conste(a)} is not subterm- inactive: there exists no Γ such that Conste(a) is Γ-immune from any other set (condition (ec.1) does not hold), or Γ-saturation-closed (condition (icp.1) does not hold). Actually, 7 is not even variable-inactive; consider the following set:
S = {store(a, i, e1)  a', Conste(a), Conste' (a')},
e {store(a, i, e1)  a', select(a, z)  e, select(a', z)  e'}.

A superposition of the unit clause store(a, i, e1)   a' into the axiom z   w V
select(store(x, z, v), w)  select(x, w) yields the clause
w  i V select(a, w)  select(a', w).	(4) Simplifications of this clause by select(a', z)  e' and select(a, z)  e yield the clause
w  i V e  e'. This clause is not variable-inactive, and since it cannot be deleted,
S∞ is not variable-inactive either.

A collection of decision procedures
The approach based on subterm-inactivity allows us to re-obtain other termina- tion results for £У on 7 -satisfiability problems and generalize them to 7 -decision problems.

Finite sets with or without extensionality
The theory of finite sets is based on the signature Σset = {member, insert}, where member and insert both have arity 2. Intuitively, member(e, s) is true if e is an element of the s, and insert(e, s) inserts element e into the set s. The theory is defined by the following presentation, denoted by F£:
6x, v. member(v, insert(v, x))  true,	(5)
6x, v, w. v / w ⇒ member(v, insert(w, x))  member(v, x).	(6)
The theory of finite sets with extensionality is presented by F£e, which consists of axioms (5) and (6) along with the following extensionality axiom:
6x, y. (6v.(member(v, x)  member(v, y))) ⇒ x  y.	(7)
It was proved in [3, Theorem 8.1] that any F£e-decision problem can be reduced to an F£-decision problem. We have the following result:
Lemma 5.1 ⟨∅, ∅, {(5), (6)}⟩ is subterm-inactive.
Proof. All one has to do is to verify that {(5), (6)} is saturation-closed. This is the case, since the superposition of (5) into (6) generates v  v V member(v, x)  true, and this clause can be deleted by the Deletion inference rule. Thus, {(5), (6)} is saturated, and it is simple to check that it is subsymbol-free from Σ0 and that both clauses are ordered-flat. Let Γ be any function in ΩΣ such that Γ(member) = 1. Conditions (icp.1), (icp.2) and (icp.3) hold on axiom (5), and conditions (icp.1), (icp.2) and (icp.4) hold on axiom (6), so that {(5), (6)} is Γ-internally closed. 

Recursive data structures
The class of recursive data structures includes the theory of integer offsets and the theory of acyclic lists. The members of this class are denoted RD£k, where k represents the number of selectors in the theory. The theory RD£k is based on the following signature:

ΣRD£k = {cons}∪ Σsel ,
Σsel = {sel1,... , selk},
where cons has arity k, and the seli’s all have arity 1. The function symbols sel1,... , selk stand for the selectors, and cons stands for the constructor. This theory is axiomatized by the following (infinite) set of axioms, denoted Ax(YÐ£k):
seli(cons(x1,... , xi,... , xk))  xi	for i = 1,... ,k 
cons(sel1(x),... , selk(x))  x,
t[x] / x,
where x and the xi’s are (implicitly) universally quantified variables and t[x] is any compound Σsel -term where the variable x occurs. The axioms t[x] / x are termed acyclicity axioms and prevent the theory from entailing equations such as sel1(sel2(x))  x. For the sake of clarity, we also define the set
Ac(n) = {6x. t[x] / x | depth(t) ≤ n}.


Example 5.2 Consider the case where k = 2. If we write car(x) instead of sel1(x) and cdr(x) instead of sel2(x), then our axioms become:
car(cons(x, y))  x,
cdr(cons(x, y))  y,
cons(car(x), cdr(x))  x,
t[x] / x,
and the theory YÐ£2 is the theory of non-empty acyclic lists.
Consider the following axiom, denoted by (ext):


6x, y. x  y V
  k

(seli(x) / seli(y)) .

i=1
It was proved in [9] that a 7 -satisfiability problem in YÐ£k can be reduced to a 7 -satisfiability problem in the theory defined by {(ext)}∪ Ac(n), where n is computed by considering the number of constructors and selectors in the original set of ground literals (see [9, Definition 3.2 and Corollary 4.9] for details). We also have the following result:
Lemma 5.3 ⟨∅, {(ext)}, Ac(n)⟩ is subterm-inactive.
Proof. Let Γ be a function in ΩΣ such that for every f ∈ Σsel , Γ(f ) = 1. We show that {(ext)} is Γ-immune from Ac(n). This set is trivially Γ-externally closed from Ac(n) since every positive literal in (ext) is strictly flat. Also, (ext) is weakly flat and conditions (vip.1) and (vip.2.a) hold, so that {(ext)} is Γ-variable-inactive preserving. Since {(ext)}∪ Ac(n) only contains positive literals that are strictly flat, {(ext)} is trivially Γ-interaction free from Ac(n).
We now show that Ac(n) is saturation-closed. It is simple to check that this set is saturated and subsymbol-free from Σ0. Since it only contains unit clauses, all these

clauses are trivially ordered-flat. The clauses in Ac(n) are all of the form t[x] / x, so that condition (icn.1) holds. Since these clauses are all negative, condition (icn.2) trivially holds.	 
Theorem 5.4 The superposition calculus yields 7 -decision procedures for the fol- lowing theories:
Equality with Uninterpreted Functions (EUF).
Arrays with or without extensionality, possibly augmented with an injectivity pred- icate, a swap predicate or both.
Finite sets with or without extensionality.
Recursive data structures.
Proof. The result is obvious for the theory of equality with uninterpreted functions, which is presented by the empty set, and was shown for the variations of the theory of arrays in the previous section. Lemmas 5.1 and 5.3 prove the result for finite sets with or without extensionality and recursive data structures, respectively. 

Discussion
In this paper, we introduced the notion of subterm-inactive theory, that guaran- tees that £У yields 7 -decision procedures. Almost all the conditions for subterm- inactivity are static, which means they can be tested automatically and only once. We showed that several theories, including most of those considered in [3,1], and two extensions of the theory of arrays, satisfy these conditions, which indicates that they are not too strong. Still, some of the theories of [1] are not subterm-inactive. They are the theory of possibly empty lists, the theory of records and the theory of inte- ger offsets modulo. We intend to investigate how to weaken the subterm-inactivity conditions to obtain a larger class of subterm-inactive theories.
The subterm-inactivity condition guarantees the termination of any fair £У>- strategy, but the efficiency of such an approach to 7 -decision problems of practical interest still has to be tested. It would be especially relevant to investigate how well such a generic approach can manage 7 -decision problems with a large boolean part.
Another important issue is how to combine subterm-inactive theories with Pres- burger arithmetic, especially for the theory of arrays. Indeed, using Presburger arithmetic on indices allows one to work on more complex properties about arrays, such as testing whether subarrays are identical.

Acknowledgement
The authors wish to thank Alessandro Armando and Silvio Ranise for bringing injective arrays to their attention.

References
Alessandro Armando, Maria Paola Bonacina, Silvio Ranise, and Stephan Schulz. On a rewriting approach to satisfiability procedures: Extension, combination of theories and an experimental appraisal. In Bernhard Gramlich, editor, Proc. 5th FroCoS, volume 3717 of LNAI, pages 65–80. Springer, 2005. The full version is available at http://profs.sci.univr.it/∼ bonacina/rewsat.html .
Alessandro Armando, Claudio Castellini, Enrico Giunchiglia, and Marco Maratea. A SAT-based decision procedure for the boolean combination of difference constraints. In Online Proc. SAT-7, 2004.
A. Armando, S. Ranise, and M. Rusinowitch. A Rewriting Approach to Satisfiability Procedures. Info. and Comp., 183(2):140–164, June 2003.
Clark W. Barrett and Sergey Berezin. CVC lite: A new implementation of the Cooperating Validity Checker. In Rajeev Alur and Doron Peled, editors, Proc. CAV-16, volume 3114 of LNCS, pages 515–518. Springer, 2004.
Marco Bozzano, Roberto Bruttomesso, Alessandro Cimatti, Tommi Junttila, Peter van Rossum, Stephan Schulz, and Roberto Sebastiani. MathSAT: Tight integration of SAT and mathematical decision procedures. J. of Autom. Reason., 35(1–3):265–293, Oct. 2005.
Clark W. Barrett, David L. Dill, and Aaron Stump. A framework for cooperating decision procedures. In David A. McAllester, editor, Proc. CADE-17, volume 1831 of LNAI, pages 79–98. Springer, 2000.
Clark W. Barrett, David L. Dill, and Aaron Stump. Checking satisfiability of first-order formulas by incremental translation to SAT. In Kim G. Larsen and Ed Brinksma, editors, Proc. CAV-14, volume 2404 of LNCS, pages 236–249. Springer, 2002.
M. P. Bonacina and M. Echenim. Generic theorem proving for decision procedures. Technical Report RR 41/2006, Universit`a degli studi di Verona, 2006. Full version available at http://profs.sci.univr.it/∼ echenim/.
Maria Paola Bonacina and Mnacho Echenim. Rewrite-based satisfiability procedures for recursive data structures. In Byron Cook and Roberto Sebastiani, editors, Proceedings of the Fourth Workshop on Pragmatics of Decision Procedures in Automated Reasoning (PDPAR), Third International Joint Conference on Automated Reasoning (IJCAR) and Fourth Federated Logic Conference (FLoC), Electronic Notes in Theoretical Computer Science. Elsevier, August 2006. To appear.
Leonardo de Moura, Harald Rueß, and Maria Sorea. Lazy theorem proving for bounded model checking over infinite domains. In Andrei Voronkov, editor, Proc. CADE-18, volume 2392 of LNAI, pages 438–
455. Springer, 2002.
Nachum Dershowitz and David A. Plaisted. Rewriting. In J.A. Robinson and A. Voronkov, editors,
Handbook of Automated Reasoning, volume I, pages 535–610. Elsevier Science Publishers, 2001.
Harald Ganzinger, George Hagen, Robert Nieuwenhuis, Albert Oliveras, and Cesare Tinelli. DPLL(T): Fast decision procedures. In Rajeev Alur and Doron A. Peled, editors, Proc. CAV-16, volume 3114 of LNCS, pages 175–188. Springer, 2004.
Robert Nieuwenhuis and Albert Rubio. Paramodulation-based theorem proving. In John Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Reasoning, pages 371–443. Elsevier and MIT Press, 2001.
Alexandre Riazanov and Andrei Voronkov. Splitting without backtracking. In Bernhard Nebel, editor, Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence, IJCAI 2001, Seattle, Washington, USA, August 4-10, 2001, pages 611–617. Morgan Kaufmann, 2001.
Aaron Stump, Clark W. Barrett, and David L. Dill. CVC: A Cooperating Validity Checker. In Rajeev Alur and Doron Peled, editors, Proc. CAV-16, volume 3114 of LNCS, pages 500–504. Springer, 2004.
