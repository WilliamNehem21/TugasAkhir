Electronic Notes in Theoretical Computer Science 175 (2007) 3–19	
www.elsevier.com/locate/entcs

Matching of Bigraphs

Lars Birkedal1	Troels Christoffer Damgaard1 Arne John Glenstrup1
IT University of Copenhagen, Denmark
Robin Milner2
University of Cambridge, UK

Abstract
We analyze the matching problem for bigraphs. In particular, we present a sound and complete inductive characterization of matching of binding bigraphs. Our results pave the way for a provably correct matching algorithm, as needed for an implementation of bigraphical reactive systems.
Keywords: Bigraphs, bigraphical reactive systems, matching, complete inductive characterization.


Introduction
Over the last decade, a theory of bigraphical reactive systems has been devel- oped [9,13,14]. Bigraphical reactive systems (BRSs) provide a graphical model of computation in which both locality and connectivity are prominent. In essence, a bigraph consists of a place graph; a forest, whose nodes represent a variety of com- putational objects, and a link graph, which is a hyper graph connecting ports of the nodes. Bigraphs can be reconfigured by means of reaction rules. Loosely speaking, a bigraphical reactive system consists of set of bigraphs and a set of reaction rules, which can be used to reconfigure the set of bigraphs. BRSs have been developed with principally two aims in mind: (1) to be able to model directly important as- pects of ubiquitous systems by focusing on mobile connectivity (the link graph) and mobile locality (the place graph), and (2) to provide a unification of existing theo- ries by developing a general theory, in which many existing calculi for concurrency

1 Email: {birkedal,tcd,panic}@itu.dk
2 Email: Robin.Milner@cl.cam.ac.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.04.013

and mobility may be represented, with a uniform behavioural theory. The latter is achieved by representing the dynamics of bigraphs by an abstract definition of reaction rules from which a labelled transition system may be derived in such a way that an associated bisimulation relation is a congruence relation. The unifica- tion has recovered existing behavioural theories for the π-calculus [9], the ambient calculus [8], and has contributed to that for Petri nets [11]. Thus the evaluation of the second aim has so far been encouraging. In [2], Birkedal et al. initiate an evaluation of the first aim, in particular it is shown how to give bigraphical models of context-aware systems.
As suggested and argued in [9,1,2] it would be very useful to have an implemen- tation of the dynamics of bigraphical reactive systems to allow experimentation and simulation. In the Bigraphical Programming Languages research project at the IT University, we are working towards such an implementation. The core problem of implementing the dynamics of bigraphical reactive systems is the matching problem, that is, to determine for a given bigraph and reaction rule whether and how the reaction rule can be applied to rewrite the bigraph. The topic of the present paper is to analyze the matching problem.
In Figure 1 we show several bigraphs. Consider the bigraph named a. It is intended to model two buildings, one belonging to a corporation and one belonging to a consultancy group. Inside the buildings are laptops with data nested inside folders. The nesting structure depicts the place graph. Links are used to name the buildings and, moreover, to model which folders can be shared between the corporation and the consultancy group and inside the corporation. Thus the laptop shown in the middle is intended to belong to a consultant working for the corporation
— the consultant has folders with data belonging to the consultancy group (the link shown to the left) and folders with data belonging to the corporation (the link shown to the right). The fact that folders belonging to the corporation should not leave the corporation is expressed by linking those folders to a so-called binding port on the corporation building, indicated by the circle.
The abstract semantic definition of matching, as defined in the theory of bi- graphs [9], is roughly as follows (omitting many details): Given a reaction rule with redex R and reactum R' (with R and R' both bigraphs), and a bigraph a (the agent to be rewritten), if a = C ◦(R ⊗idZ) ◦ d, then it can be rewritten to C ◦(R' ⊗idZ) ◦ d. Here ◦ denotes composition of bigraphs and Z is the set of global names of d. In other words, if the reaction rule matches a, in the sense that a can be decomposed into a context C, redex R and a parameter d, then a can be rewritten.
Consider again the example in Figure 1. There is a reaction rule expressed by the redex R and the reactum R'; the intention of the reaction rule is to allow copying of data between connected folders in the same nesting hierarchy (note the link in R between the two folders and the so-called local name y). The agent a can be written as a composition of C, R and d — formally, a = C ◦ (R ⊗ idz) ◦ d. Composition works by (1) plugging the roots of R and d into the holes (aka sites) of C respectively R; (2) fusing together the connections between folder and z (in d) and z and folder (in C), removing the name z in the process; (3) fusing together

consultancy	corporation




a =



consultancy	corporation




C =



z
y



R =


y



R' =


z



d =


Fig. 1. Example of a ground agent a = C ◦ (idz ⊗ R) ◦ d. Reaction rule R → R' copies data between connected folders.

the connection between the local name y and the two folders in R and the name y and the bound port in C, removing the name y in the process. Note the use of idz in the composition a = C ◦ (R ⊗ idz) ◦ d; it allows a name z from the parameter d to be “passed through” the redex and be attached to something in the context C. The reactum R' contains a copy of the site numbered 1 in R, expressing that data is copied between the shared folders. The sites numbered 0 and 2 in R allow the reaction rule to apply also when the laptops contain other folders than the two that are connected. Thus a can be rewritten using the reaction rule to another agent a' like a but with two data items in the rightmost laptop (the agent a' is not shown

in Figure 1).
In the present paper we provide an inductive characterization of when a = C ◦(R⊗idZ)◦d holds, by induction on a and R (the input to a matching algorithm). It is a precise characterization in the sense that it is both sound and complete with respect to the abstract definition. This provides a detailed analysis of the matching problem, and paves the way for developing and proving correct an actual matching algorithm (which, given a and R, must find C, d, and Z such that a = C ◦(R⊗idZ)◦d holds). We further include a discussion of how one may derive matching algorithms from our inductive characterization. We will report on our work on an actual implementation of matching in a subsequent paper.
Our inductive characterization is based on normal form theorems for bi- graphs [13,5], which express how general bigraphs may be decomposed into a compo- sition of simpler graphs. The normal form theorems and also the inductive charac- terization we present here is based on so-called discrete decompositions of bigraphs. Discrete bigraphs are bigraphs with a simple form of linkage. To a large extent, this allows us to analyze matching of a general bigraph by considering its link graph and place graph separately.
Of course, the matching problem is closely related to the NP-complete graph embedding problem. Thus we analyze the embedding problem for a restricted class of graphs, and our inductive characterization makes good use of the algebraic pre- sentation of such graphs [13,5]. One hopes that matching implementations will be efficient in practice since redices typically are small. Furthermore, sorting bi- graphs [3] could be a source of early search elimination.
The remainder of this paper is organized as follows. In Section 2 we give an informal description of binding bigraphs. The main contribution of this paper is in Section 3, where we present our inductive characterization of matching. Section 4 discusses how the inductive characterization may ensure a correct and efficient al- gorithm for matching. In the final sections we discuss related work and conclude.
Detailed proofs of Theorem 3.15, which states completeness of the characteriza- tion, can be found in Damgaards Master’s thesis [4].

Binding Bigraphs
Here we present bigraphs informally; for a formal definition, see [9,5].

Concrete Bigraphs
A concrete binding bigraph G consists of a place graph GP and a link graph GL. The place graph is an ordered list of trees indicating location, with roots r0,... , rn, nodes v0,... , vk, and a number of special leaves s0,... , sm called sites, while the link graph is a general graph over the node set v0,... , vk extended with inner names x0,... , xl, and equipped with hyper edges, indicating connectivity.
We usually illustrate the place graph by nesting nodes, as shown in the upper part of Figure 2 (ignore for now the interfaces denoted by “ : · → ·”). A link is

Bigraph G : ⟨3, [{}, {}, {x0, x2}],X⟩ → ⟨2, [{y0}, {}],Y ⟩
y0	y1	y2


X = {x0, x1, x2}
Y = {y ,y ,y }
0  1  2



Place graph GP :3 → 2
x1
Link graph GL : X → Y

roots:
names:
y0	y1	y2







sites:
v0




inner names:
v2

v1  e v3
e'
x0	x2	x1

Fig. 2. Example bigraph illustrated by nesting and as place and link graph.
a hyper edge of the link graph, either an internal edge e or a name y. Links that are names are called open, otherwise they are closed. Names and inner names can be global or local, the latter being located at a specific root or site, respectively. In Figure 2, y0 is located at r0, indicated by a small ring, and x0 and x2 are located at s2, indicated by writing them within the site. Global names like y1 and y2 are drawn anywhere at the top, while global inner names like x1 are drawn anywhere at the bottom. A link, including internal edges like e' in the figure, can be located with one binder (the ring), in which case it is a bound link, otherwise it is free. However, a bound link must satisfy the scope rule, a simple structural requirement that all points of the link lie within its location (in the place graph), except for the binder itself. This prevents y2 and e in the example from being bound.
Controls
Every node v has a control K which determines a binding and free arity, indicated by v : K. In the example of Figure 2, we could have vi : Ki,i = 0, 1, 2, 3, where K0 :0 → 1, K1 :0 → 2, K2 :0 → 3, K3 :1 → 2. The arities determine the number of bound and free ports of the node, to which bound and free links, respectively, are connected. Ports and inner names are collectively referred to as points.
Abstract Bigraphs
While concrete bigraphs with named nodes and internal edges are the basis of bigraph theory [9], our prime interest is in abstract bigraphs, equivalence classes of concrete bigraphs that differ only in the names of nodes and internal edges 3 . Abstract bigraphs are illustrated with their node controls, as shown in Figure 1 with Building, Laptop, etc. In what follows, “bigraph” will thus mean “abstract bigraph.”

3 Formally, we also disregard idle edges, those edges not connected to anything.

Interfaces
Every bigraph G has two interfaces I and J, written G : I → J, where I is the inner face and J the outer face. An interface is a triple ⟨m, X→ , X⟩, where m is the width (the number of sites or roots), X the entire set of local and global names,

and X→
indicates the locations of each local name, cf. Figure 2. We let ϵ = ⟨0, [ ], {}⟩;

when m = 1 the interface is prime, and if all x ∈ X are located by X→ , the interface is local. As in [12] we write G : → J or G : I → for G : I → J when we are not concerned about about I or J, respectively.
A bigraph G : I → J is called ground, or an agent, if I = ϵ, prime if I is local and J prime, and a wiring if m = n = 0, where m and n are the widths of I and J, respectively. For I = ⟨m, X→ , X⟩, bigraph idI : I → I consists of m roots, each root ri containing just one site si, and a link graph linking each inner name x ∈ X to name x.
Discrete and Regular Bigraphs
We say that a bigraph is discrete iff every free link is a name and has exactly one point. The virtue of discrete bigraphs is that any connectivity by internal edges must be bound, and node ports can be accessed individually by the names of the outer face. In Figure 1, only R, R' and d are discrete, because the free internal edges of a and C have two points. Further, a bigraph is name-discrete iff it is discrete and every bound link is either an edge, or (if it is an outer name) has exactly one point. Note that name-discrete implies discrete.
A bigraph is regular if, for all nodes v and sites i, j, k with i ≤ j ≤ k, if i and k are descendants of v, then j is also a descendant of v. Further, for roots ri' and rj' , and all sites i and j where i is a descendant of ri' and j of rj' , if i ≤ j then i' ≤ j'. The bigraphs in the figures are all regular, the permutation in Table 1 is not. The virtue of regular bigraphs is that permutations can be avoided when composing them from basic bigraphs.
Tensor Product, Parallel Product, and Composition
For bigraphs G1 and G2 that share no names or inner names, we can make the tensor product G1 ⊗ G2 by juxtaposing their place graphs, constructing the union of their link graphs, and increasing the indexes of sites in G2 by the number of sites of G1. For instance, bigraph d of Figure 1 is a tensor product of four primes. We write  n Gi for the iterated tensor G0 ⊗ ··· ⊗ Gn−1, which, in case n = 0, is idє.
The parallel product G1 || G2 is like the tensor product, except global names can be shared: if y is shared, all points of y in G1 and G2 become the points of y in G1 || G2.
We can compose bigraphs G2 : I → I' and G1 : I' → J, yielding bigraph G1 ◦ G2 : I → J, by plugging the sites of G1 with the roots of G2, eliminating both, and connecting names of G2 with inner names of G1—as in Figure 1, where a = C ◦ (idz ⊗ R) ◦ d. In the following, we will omit the ‘◦’, and simply write G1G2 for composition, letting it bind tighter than tensor product.

Active, Passive and Atomic Controls
In addition to arity, each control is assigned a kind, either atomic, active or passive, and describe nodes according to their control kinds. We require that atomic nodes contain no nodes except sites; any site being a descendant of a passive node is passive, otherwise it is active. If all sites of a bigraph G are active, G is active.
For Figure 1 we could have Data : atomic(0 → 0), Folder : passive(0 → 1),
Laptop : active(0 → 0), Building : active(1 → 1).
Bigraphical Reactive Systems
Bigraphs in themselves model two essential parts of context: locality and connec- tivity. To model also dynamics, we introduce bigraphical reactive systems (BRS) as a collection of rules. Each rule R →ę R' consists of a regular redex R : I → J, a regular reactum R' : I' → J, and an instantiation Q, mapping each site of R' to a site of R. Interfaces I = ⟨m, X→ , X⟩ and I' = ⟨m', X→ ',X'⟩ must be local, and are related by X' = Xę(i). We illustrate Q by a ‘i := j’, as shown in Figure 1, whenever Q(i) = j /= i. Given an instantiation Q and a discrete bigraph d = d0 ⊗ ··· ⊗ dk with prime di’s, we let Q(d)= dę(0) ⊗ ··· ⊗ dę(k), allowing copying, discarding and reordering parts of d.
Given an agent a, a match of redex R is a decomposition a = C(id7 ⊗ R)d, with active context C, discrete parameter d, and some set of names Z. Dynamics is achieved by transforming a intoa new agent a' = C(id7 ⊗ R')d', where d' = Q(d)— an example is shown in Figure 1. This definition of a match is as in [9], except that we here also require R to be regular. This restriction to regular redexes R (and to discrete parameters d) does not limit the set of possible reactions. We restrict attention to regular R’s because it simplifies the inductive characterization of matching by allowing us to omit trivial permutations.
Notation, Basic Bigraphs, and Abstraction
In the sequel, we will use the following notation:  denotes union of sets required

to be disjoint; we write {Y→ } for Y0	  Yn−1 when Y→
= Y0,... Yn−1, and similarly

{→y} for {y0,... , yn−1}. For interfaces, we write n to mean ⟨n, [∅,... , ∅], ∅⟩, X to
mean ⟨0, [ ],X⟩, ⟨X⟩ to mean ⟨1, [{}],X⟩ and (X) to mean ⟨1, [X],X⟩.
Any bigraph can be constructed by applying composition, tensor product and abstraction to identities (on all interfaces) and a set of basic bigraphs, shown in

Table 1 [5]. For permutations, when used in any context, πX→ G or GπX→ , X→
is given

entirely by the interface of G; in these cases we simply write πX→
as π.

Given a prime P , the abstraction operation localises a subset of its outer names.
Note that the scope rule is necessarily respected since the inner face of a prime P is required to be local, so all points of P are located within its root. The abstraction operator is denoted by (·)· and reaches as far right as possible.
For a renaming α : X → Y , we write  α’ to mean (id1 ⊗ α) X’, and when σ : U → Y , we let σ = (Y )(σ ⊗ id1) U ’. We write substitutions →y/[∅,... , ∅]: ϵ → Y as Y .

Notation	Example



Concretion  X’ : (X) → ⟨X⟩	 {x1, x2}’ =
x1 x2

y1y2y3 z

Abstraction (Y )P
({y ,y })({y }) {y ,y ,y ,z}’ =

: I → ⟨1, [Y ],7  Y ⟩
1  2	3
1  2  3

y1 y2 y3

Substitution →y/X→ : X → Y	[y1, y2, y3]/[{x1, x2}, {}, {x3}] = 
σ
x1 x2 x3
y1 y2 y3

Renaming
α, β
→y/→x : X → Y	[y1, y2, y3]/[x1, x2, x3] = 
x1 x2 x3

Closure	/X : X → {}	/{x1, x2, x3} = x1 x2 x3


Wiring
(id ⊗ /7)σ
(id{y1,y2}
⊗ /{z1, z2})
y1	y2
=

ω	: X → Y


K→y(X→ )
[y1, z1, y2, z2] /
[{}, {x1, x2}, {x4, x5}, {x6}]

x1 x2 x4 y1 y2

x5 x6

Ion
: ({X→ }) → ⟨{→y}⟩	K[y1 ,y2 ]([{x1},{x2,x3 },{}]) =
y	x

Permutation {i '→ j,.. .}

{0 '→ 2, 1 '→ 0, 2 '→ 1}	=

πX→
: ⟨m, X→ , X⟩ → ⟨m, π(X→ ),X⟩

Table 1
[{x},∅,{y}]

Basic bigraphs, the abstraction operation, and variables ranging over bigraphs.

Note that [ ]/[] = /∅ = π0 = idє and merge1 = ∅’ = π1 = id1, where πi is the nameless permutation of width i.
As an example, the bigraph of Figure 2 can be written
G = (ω ⊗ (({y0})(y0/Y ⊗ id1) Y ’)) (((Y )P1) ⊗ P2 ⊗ y2/x1) , where
ω = (/e ⊗ id{y ,y })[y1, y2, e]/[{y1}, {y2, y' , y''}, {e, e'}],	Y = {y0, y' , y''}
1 2	2	2	0	0
P1 = (id{y0,y1,y' ,e} ⊗ merge2)  (id{y0,e} ⊗ K0[y' ])K1[y0,e] ⊗ K2[y'',y1,y' ] merge0 
P2 = (id{e',y''} ⊗ merge2)(K3[e',y'']([{x0,x2}]) ⊗  ∅’),
2	2
and for Figure 1 we have a = (id{consultancy ,corporation } ⊗ /z) (p1 || p2), where
p1 = (idz ⊗ Building[consultancy ]([{}])Laptop)Folder[z]Data merge0
p2 = (idz ⊗ Building[corporation ]([{y ,y }]))({y1, y2})(id{z,y ,y } ⊗ merge2) (p' ⊗ p'')
1 2	1 2	2	2
p'  = (id{z,y } ⊗ Laptop merge 2)(Folder[z]Datamerge0 ⊗ Folder[y ]Data merge0)
2	1	1
p'' = (idy ⊗ Laptop)Folder[y ]Data merge
2	0
Finally, a molecule is a prime with just one outermost node.

Inductive Characterization of Matching
In this section we present our inductive characterization of matching. To ease the presentation we shall disregard the requirement that the context in a match must be active (it is straightforward to extend the following presentation to include the active requirement).

Preliminaries
In this subsection we introduce useful notation and establish some propositions about how one may decompose bigraphs. To simplify notation we shall simply write id for identity bigraphs, without a subscript showing the interface, when it is clear from the context what interface is intended.
The following propositions express how bigraphs may be decomposed into sim- pler constitutent components. The proofs follow easily from the normal form the- orem in [5]. Note that ω, α, σ and π range over wirings, renamings, substitutions and permutations, cf. Table 1.
Proposition 3.1 Any bigraph G can be decomposed into a composition of the fol- lowing form
G = (ω ⊗ id)(D ⊗ idY ),
where D is discrete and with local innerface. Any other decomposition of G on this form takes the form G = (ω' ⊗ id)(D' ⊗ idY ), where ω' = ω(α ⊗ idY ) and D' = (α−1 ⊗ id)D, for suitable α.
Proposition 3.2 Any discrete bigraph D of width n with local innerface can be decomposed such that
n
D =	(σi ⊗ id)Pi π,
i
where the Pi’s are name-discrete and prime. Any other decomposition on this form
of D takes the form  n(σ^' ⊗ id)P ' π', where, for some α^i, ρi, for all i, P ' =
(α^i−1 ⊗ id)Piρi ( n ρi)π' = π, and σ^' = σ^iα^i.
For primes and molecules, the normal form can be found in loc. cit.
One can decompose binding ions K → into Ky→(u→)  n(ui)/(Xi). Such decom-
positions will be useful because of the following proposition, which is a corollary of Theorem 1, item 1, in [5] (specialized to free discrete ions).
Proposition 3.3 Any free discrete molecule M : I → ({→y} Z) can be decomposed as
M = (K→y(→u) ⊗ id7)P,
where P is a discrete prime. Any other decomposition of M on this form, has the form (K→y(→x) ⊗ id7)P ', where there exists a unique α, given by ui '→ xi, such that K→y(→u)α^ = K→y(→x) and P = (α^ ⊗ id7)P '.

Matching Sentences
We now define matching sentences and rules for deriving valid matching sentences.

Definition 3.4 A matching sentence is a 7-place relation among wirings and bigraphs, written ωa, ωR, ωC ▶ a, R ‹→ C, d, satisfying that ωa, ωR, ωC are wirings, and a, R, C, d are discrete bigraphs, R and C have local inner faces, and R is regular.
Definition 3.5 A matching sentence ωa, ωR, ωC ▶ a, R ‹→ C, d, where ωR :→ Y , and d has global outer names Z, is valid, denoted ωa, ωR, ωC ▶ a, R ‹→ C, d, iff
(id ⊗ ωa)a = (id ⊗ ωC)(C ⊗ idY ⊗ id7)(id ⊗ id7 ⊗ ωR)(R ⊗ id7)d. where unqualified identities are local and determined from the context.
Note that for a valid sentence ωa, ωR, ωC ▶ a, R ‹→ C, d, if we let a' = (id ⊗ ωa)a,
C' = (id ⊗ ωC)(C ⊗ idY ⊗ id7), and R' = (id ⊗ ωR)R, then a' = C'(R' ⊗ id7)d. Conversely, if, for general a', C', R', d we have a match a' = C'(R' ⊗ id7)d, then by Proposition 3.1, we can decompose a', C', and R' and obtain a corresponding valid sentence. Thus, valid sentences precisely capture the abstract definition of matching.
Rules for Matching
In Figure 3 we present a set of rules for inferring matching sentences. In par we require further that the tensor products of all discrete components be defined. Also, in the premises of the rules perm and ion, and in the conclusion of rules merge, ion, and switch we require the id’s to have width 0 (hence be link graph identities). This determines them entirely from the context.
We now explain the rules.
The perm rule simply pushes a permutation on the inside of the context through the redex, permuting the discrete primes, and producing a pushed-through permuta- tion π, depending on π and the innerface of the redex, as stated in the push-through lemma [5].
The par rule explains how to match a product, given two valid matches, which share some context wiring ω if the two parts of the redex share a (necessarily global) name, cf. Figure 4.
The lsub rule allows us to match any discrete prime (c.f. Proposition 3.2) by matching an underlying free (name)discrete prime with the wiring of agent and con- text extended with the underlying global substitutions σa and σC. In other words, this rule expresses that we can match a bigraph with local names by matching the corresponding free bigraph (forgetting that the names are local) and then remember to make the correct names local again.
The merge rule simply states that to match bigraphs with an outer merge and a global id, we must be able to match the underlying bigraphs.





perm
ωa, ωR, ωC ▶ a,  m Pπ−1(i) ‹→ C, (π ⊗ id)d ωa, ωR, ωC ▶ a,  m Pi ‹→ Cπ, d




par
ωa, ωR, ωC || ω ▶ a, R ‹→ C, d	ωb, ωS, ωD || ω ▶ b, S ‹→ D, e ωa || ωb, ωR || ωS, ωC || ωD || ω ▶ a ⊗ b, R ⊗ S ‹→ C ⊗ D, d ⊗ e


 σa ⊗ ωa, ωR, σC ⊗ ωC ▶ p, R ‹→ P, d	σa : Z → W	σC : U → W  ωa, ωR, ωC ▶ (σ^a ⊗ id)(Z)p, R ‹→(σ^C ⊗ id)(U )P, d

ωa, ωR, ωC ▶ a, R ‹→ C, d	a global
merge
ωa, ωR, ωC ▶ (merge ⊗id)a, R ‹→(merge ⊗id)C, d



ion
ωa, ωR, ωC ▶ ((→v)/(X→ ) ⊗ id)p, R ‹→((→v)/(Z→ ) ⊗ id)P, d	α = →y/→u	σ : {→y}→ 
σ || ωa, ωR, σα || ωC ▶ (K→y(X→ ) ⊗ id)p, R ‹→(K→u(7→ ) ⊗ id)P, d




switch
ωa, idє, ωC(σ ⊗ ωR ⊗ id) ▶ p, id ‹→ P, d	P :→ ⟨W  Y ⟩	σ : W → U ωa, ωR, ωC ▶ p, (σ^ ⊗ id)(W )P ‹→ U ’,d 

α : X →	β : Z →	p : ⟨X  Z⟩

prime-axiom


ω, idє, ω(α−1 ⊗ β−1) ▶ p, id ‹→ α’, (X)(β ⊗ id⟨X⟩)p



wiring-axiom


y, Y, y/Y ▶ idє, idє ‹→ idє, idє




close
σa, σR, idУR ⊗ σC ▶ a, R ‹→ C, d	σC :→ Y  YC	σR :→ U  YR


(id ⊗ /(YR  YC))σa, (id ⊗ /YR)σR, (id ⊗ /YC)σC ▶ a, R ‹→ C, d

Fig. 3. Rules for matching binding bigraphs



ωa		ωb
xw1y1	y2w2 z

ωC
x	y1
ω	ωD
w  y2	z



a	b

УC = {w}
УD = {w, z}
C⊗idYC


ωR
idYD ⊗D

w	z
ωS

xw1y1	y2w2 z

R	S

Fig. 4. Matching a product using the par rule

The ion rule works intuitively by splitting up a binding ion into a free, discrete ion and an underlying local substitution. For any given match of discrete primes, we can compose with ions K→y(X→ ) or K→u(7→ ), if we extend the wirings of agents and contexts with isomorphic wiring on the outer names →y and →u; stated in the rule by requiring that we extend with σy and σyα (where α = →y/→u). For example, if we seek to match the agent a = (id ⊗ K→y(X→ ))p yielding a context C = (id ⊗ K→u(7→ ))P , then it suffices to consider matching of a' = (→v)/(X→ )p yielding a context C' = (→v)/(Z→ ), as illustrated in Figure 5.

'	'	'
1  2	1
σy

'
2
σyα

y1 y2
u1 u2
v1 v2 v3
v1 v2 v3

 
a	C	a'	C'
Fig. 5. Matching ion agent a yielding context C by matching a' yielding context C'

Given an agent and considering an inference tree operationally bottom up, the rules specify how to decompose the agent while constructing the corresponding context (cf., e.g., the ion rule). At the point where the root of the redex is matched, the switch rule is applied, switching the redex into context position, so that further decomposition of the agent checks that the redex matches. Thus, when inferring a match, every rule except switch can be used in two modes: one where the agent and redex are given, resulting in a context and parameter; and one where the agent and context are given, resulting in a parameter.
The prime-axiom and wiring-axiom axioms are our base cases and are intu- itively clear (the latter is used to match bigraphs of zero width).
The close rule allows us to infer a match for bigraphs where all global links are open, and “close” this match by replacing names in wirings with edges, cf. Figure 6. An internal edge in the agent need not have the same identity as its counterpart in redex or context, hence the α.
a	R	u	C
 	

y	z1	z2
u
y	u	y  z1	z2

 	
y u
a'	R'	C'

Fig. 6. Matching closed links within and between redex and context

Theorem 3.6 The rules for matching in Figure 3 are sound, that is, any matching sentence that can be derived is valid.
Proof. Straightforward, but tedious, standard algebraic manipulations.	 
The completeness theorem will be proved by induction on the size of valid sen- tences, which is defined as follows.
Definition 3.7 The size of a matching sentence ωa, ωR, ωC ▶ a, R ‹→ C, d is the number of ions in a.
The following lemmas express how a valid sentence may be derived by applica- tions of inference rules to valid sentences of lesser or equal size. The proofs proceed by first decomposing the components of the given valid sentence, then defining the components of the valid sentence(s) claimed to exist and, finally, verifying that (1) the sentences claimed to exist really are valid and (2) that the given sentence can in- deed be derived as claimed. The decompositions are obtained via Propositions 3.1, 3.2, and 3.3, and the verifications proceed using centrally the unicity results for these normal forms and lemmas as found in [5].
Lemma 3.8 Every valid sentence ωa, ωR, ωC ▶ a, R ‹→ C, d is provable using the close and the perm rule on a valid sentence, of equal size, of the form σa, σR, σC ▶ a, S ‹→  n Pi, e.
Lemma 3.9 Every valid sentence σa, σR, σC ▶ a, R ‹→ P ⊗  n Pi, d, with P and
Pi prime and discrete, is provable using the par rule on valid sentences, of lesser

or equal size, of the form σP , σP , σP
|| σS
▶ p, S ‹→ P, e and σC, σC , σC || σS ▶

a', R' ‹→  n Pi, e'.
a	R	C	C
a	R	C	C

Lemma 3.10 Every valid sentence σa, σR, σC ▶ a, R ‹→ idє,d is provable using par and wiring-axiom.
Lemma 3.11 Every valid sentence ωa, ωR, ωC ▶ p, R ‹→ P, d, with p and P prime and discrete, is provable using the lsub rule on a valid sentence, of lesser or equal
size, of the form ω' , ω' , ω' ▶ p',R ‹→ P ', d, where p' and P ' are discrete free primes.
a	R	C
Lemma 3.12 Every valid sentence σa, σR, σC ▶ p, R ‹→ Q, d, with p and Q discrete and free primes, is provable using merge, par (iterated), and switch rules on valid sentences, each of lesser or equal size, and each on one of two forms:
σ' , σ' , σ' ▶ pN , id ‹→ PN , e, where pn and PN are free discrete primes,
a	R	C
σ' , σ' , σ' ▶ m, S ‹→ M, e, where m and M are free discrete molecules.
a	R	C
Lemma 3.13 Every valid sentence σa, σR, σC ▶ m, R ‹→ M, d, with m and M free
discrete molecules, is provable using the ion rule on a valid sentence σ' , σ' , σ' ▶

p, R ‹→ P, d, of lesser size, where p and P are discrete primes.
a	R	C

Lemma 3.14 Every valid sentence σa, σR, σC ▶ p, id ‹→ P, e, with p and P free discrete primes, is provable using the merge and par (iterated) rules on valid sentences of equal or lesser size, which are either instances of rule prime-axiom or
of the form σ' , σ' , σ'  ▶ m, R ‹→ M, d.
a	r	M

Theorem 3.15 The rules for matching in Figure 3 are complete, that is, any valid matching sentence can be derived from the rules.
Proof. By induction on the size of a sentence. By the lemmas above, we have that all valid sentences with size n can be derived from valid sentences of the form σa, σR, σC ▶ m, R ‹→ M, d, with m and M free discrete molecules, of size less than or equal to n. By Lemma 3.13, these can be derived from sentences of size less than
n.	 

Towards Algorithms for Matching
The completeness theorem tells us that we can find all valid matching sentences by applications of the rules for matching. Thus the rules for matching define an algo- rithm for matching, for instance easily expressed in Prolog, which simply operates by searching for inference trees using the rules.
Although we can (e.g., in Prolog) base a matching algorithm directly upon the matching rules, we do not claim that an efficient matching algorithm has to be so based. We have introduced matching rules for a dual purpose: first, to characterise matching structurally and inductively in order to understand it (in particular to understand the relation to representations based on normal forms and to understand where exactly choices between different matches can be made during matching); second, to provide a point from which to begin the search for truly efficient matching algorithms, and to verify them. This rigorous approach to matching is justified, in our view, because matching will be the workhorse of any implementation of bigraph dynamics.
In practice, one is, of course, interested in minimizing unnecessary blind search, and thus, for instance, only search for inference trees of a certain form. Indeed, one can show that it suffices to consider so-called normal inference trees, which put restrictions on the order in which the inference rules are applied (such as, e.g., always concluding with the close rule). We shall not include a formal definition of normal inference trees here, but rather discuss some of the possibilities for defining normal inference trees. We first remark that to retain completeness, any definition of normal inference must, of course, ensure no loss of provability. Looking at the formulations of the lemmas leading up to the completeness theorem, we see that there are indeed several possibilities for the definition of normal inference tree. For example, from Lemma 3.8 we see that we are free to conclude each inference tree with close and then perm or vice versa. Further, in several rules we are allowed to propagate closed links, even though close intuitively makes that unnecessary. We have chosen to leave this freedom in the rule system and instead comment on how we could extend the set of rules to allow even more freedom in chosing our definition of normal inference tree. This is important when thinking about implementations, as each definition of normal inference tree corresponds to a different algorithmic approach to matching.
One may say that the current set of rules naturally give rise to normal inferences that are a mix between matching the link graph “lazily”or “eagerly”. Instead of

the close rule, one could have amended the par and ion rules (those with || in the conclusion) such that they would also handle matching of closures. This would have allowed true “by need” link-matching. Conversely, one could have amended the close to also compare substitutions, allowing us to consider matching of dis- crete bigraphs up to renaming isos on their outerfaces. If we amended the lsub and switch rules to work accordingly, this would actually preclude the need for the wirings ωa, ωR, ωC in matching sentences. It seems, though, that the tedious complexity added into these rules would mean that we would gain little in removing complexity from the rules as a whole. Anyhow, these changes would allow us to define a variant of normal inferences, which would be “strict” in the link graph, in that we would immediately be able to reject possible matches based on the link graph (instead of the place graph).
Another possibility would be to add a rule glob, allowing us to match all wiring stemming from a single prime as global wiring. This idea seems to indicate that matching in local bigraphs [12] (where there is no global linkage but instead multi- located names) could be handled similarly, by recasting the rules to work on local links and just locating names at all roots where they occur.

Representations of Graphs
An implementation of matching must, of course, represent bigraphs in some way. One possibility is to represent bigraphs directly by place and link graphs, and then implement the normal form lemmas, which express how bigraphs may be decom- posed into simpler bigraphs; then matching can proceed by induction on the de- composed graph. In general, however, the “decomposition functions” return sets of possible decompositions, because normal forms are only unique up to certain permutations. (For example, merge (M1 ⊗ M2) = merge(M2 ⊗ M1).) A matching implementation needs to explore all the possible decompositions. This can be made explicit formally, by phrasing the inductive characterization of matching not on bi- graphs but on bigraphical expressions (syntax), as defined in [13,5]. Doing so forces us to add an inference rule, which allows one to replace any expression in a matching sentence ωa, ωR, ωC ▶ a, R ‹→ C, d, say a, by another, say a', that is provably equal via the axioms for equality in [5]. Doing so clearly yields a complete set of rules on bigraphical expressions. When defining normal inference trees for these, one seeks, of course, to restrict the application of the equality axioms. The definition of nor- mal inference trees will then formally explicate all the possibilities that a matching algorithm needs to explore. We have worked out a definition of normal inference tree for matching of place graph expressions and proved it complete. Based on that experience, we believe it should not be too hard to work out a suitable definition of normal inference tree binding bigraph expressions and prove it complete.

Conclusion and Related Work
We have presented a sound and complete inductive characterization of matching for binding bigraphs. We are currently working toward an implementation of matching

based upon the characterization.
Bigraphical reactive systems are related to graph transformations systems; see [6] for a recent comprehensive overview of graph transformation systems. In partic- ular, bigraph matching is strongly related to the general graph pattern matching (GPM) problem, so general GPM algorithms might be applicable [17,7,10,20]. Due to the special structure of bigraphs, general GPM algorithms are expected to be inefficient, although some GPM tools [19] use heuristic search strategies that might be able to discover and exploit bigraph structure. A special aspect of bigraphs is that we may match a set of subtrees with a single node (site) in the redex, and match multiple redex roots in different places within the agent. Fu [7] handles such wildcard nodes and multiple patterns, but directly applying his algorithm is not straightforward, as he attacks the problem of tree isomorphism of rooted graphs unfolded to finite unbounded depths. The subtree isomorphism problem [15,18,16] is simpler than GPM, but applying it directly to the place graphs of bigraphs would not exploit the constraints imposed by the link graphs. Rather, efficient imple- mentations of bigraph matching should be derived from the initial implementation by experimenting with different normal inference tree definitions, and combining it with subtree isomorphism algorithms. The inductive characterization provided here will make it easier to prove the actual algorithm correct.

Acknowledgement
This work was funded in part by the Danish Research Agency (grant no.: 2059-03- 0031) and the IT University of Copenhagen (the LaCoMoCo project).

References
Birkedal, L., Bigraphical Programming Languages—a LaCoMoCo research project, in: Second UK UbiNet Workshop, Cambridge, 2004, position paper.
Birkedal, L., S. Debois, E. Elsborg, T. Hildebrandt and H. Niss, Bigraphical models of context-aware systems, in: L. Aceto and A. Ingo´lfsd´ottir, editors, FOSSACS ‘06: Proceedings of 9th International Conference on Foundations of Software Science and Computation Structures, LNCS 3921 (2006), pp. 187–201.
Birkedal, L., S. Debois and T. Hildebrandt, Sortings for reactive systems, Technical Report 84, IT University of Copenhagen (2006).
Damgaard, T. C., “Syntactic Theory for Bigraphs,” Master’s thesis, IT University of Copenhagen (2006).
Damgaard, T. C. and L. Birkedal, Axiomatizing binding bigraphs, Nordic Journal of Computing 13
(2006), pp. 58–77.
Ehrig, H., K. Ehrig, U. Prange and G. Taentzer, “Fundamentals of Algebraic Graph Transformation,” Monographs in Theoretical Computer Science. An EATCS Series, Springer, 2006.
Fu, J. J., Directed graph pattern matching and topological embedding, Journal of Algorithms 22 (1997),
pp. 372–391.
Jensen, O. H., “Mobile Processes in Bigraphs,” Ph.D. thesis, Univ. of Cambridge (2006).
Jensen, O. H. and R. Milner, Bigraphs and mobile processes (revised), Technical Report UCAM-CL- TR-580, University of Cambridge (2004).

Larrosa, J. and G. Valiente, Constraint satisfaction algorithms for graph pattern matching, Mathematical Structures in Computer Science 12 (2002), pp. 403–422.
Leifer, J. J. and R. Milner, Transition systems, link graphs and Petri nets, Technical Report UCAM- CL-TR-598, University of Cambridge (2004).
Milner, R., Bigraphs whose names have multiple locality, Technical Report UCAM-CL-TR-603, University of Cambridge, Computer Laboratory (2004).
Milner, R., Axioms for bigraphical structure, Mathematical Structures in Computer Science 15 (2005),
pp. 1005–1032.
Milner, R., Pure bigraphs: structure and dynamics, Inf. Comput. 204 (2006), pp. 60–122.
Selkow, S. M., The tree-to-tree editing problem, Information Processing Letters 6 (1977), pp. 184–186.
Shamir, R. and D. Tsur, Faster subtree isomorphism, Journal of Algorithms 33 (1999), pp. 267–280.
Ullman, J. D., An algorithm for subgraph isomorphism, Journal of the ACM 23 (1976), pp. 31–42.
Valiente, G., “Algorithms on Trees and Graphs,” Springer, Berlin, 2002.
Varr´o, G., D. Varr´o and K. Friedl, Adaptive graph pattern matching for model transformations using model-sensitive search plans, in: G. Karsai and G. Taentzer, editors, GraMot 2005, International Workshop on Graph and Model Transformations, Electronic Notes in Theoretical Computer Science, 2005, pp. 191–205.
Zu¨ndorf, A., Graph pattern matching in PROGRES, in: J. Cuny, H. Ehrig, G. Engels and G. Rozenberg, editors, Proceedings of the 5th International Workshop on Graph-Grammars and their Application to Computer Science, LNCS 1073 (1996), pp. 454–468.
