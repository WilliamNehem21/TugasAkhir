Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 307 (2014) 33–45
www.elsevier.com/locate/entcs

An Abstract Domain to Infer Symbolic Ranges over Nonnegative Parameters
Xueguang Wu1, Liqian Chen2 and Ji Wang3
National Laboratory for Parallel and Distributed Processing, National University of Defense Technology,
Changsha 410073, China

Abstract
The value range information of program variables is useful in many applications such as compiler optimiza- tion and program analysis. In the framework of abstract interpretation, the interval abstract domain infers numerical bounds for each program variable. However, in certain applications such as automatic paral- lelization, symbolic ranges are often desired. In this paper, we present a new numerical abstract domain, namely the abstract domain of parametric ranges, to infer symbolic ranges over nonnegative parameters for each program variable. The new domain is designed based on the insight that in certain contexts, program procedures often have nonnegative parameters, such as the length of an input list and the size of an input array. The domain of parametric ranges seeks to infer the lower and upper bounds for each program variable where each bound is a linear expression over nonnegative parameters. The time and memory complexity of the domain operations of parametric ranges is O(nm) where n is the number of program variables and m is the number of nonnegative parameters. On this basis, we show the application of parametric ranges to infer symbolic ranges of the sizes of list segments in programs manipulating singly-linked lists. Finally, we show preliminary experimental results.
Keywords: Abstract interpretation, Abstract domains, Intervals, Symbolic ranges.


Introduction
The range information of variable values, that is the lower and upper bound of the values that a variable may take, is quite useful in many applications including compiler optimization, automatic parallelization, bug detection, etc. Value range analysis seeks to automatically infer a range [a, b] for each program variable x at compile time, which denotes the constraint a ≤ x ≤ b. The theory of abstract interpretation [8] provides a general framework to compute statically approximate but sound value ranges for program variables. The interval abstract domain [7] can discover lower and upper bounds on the values of program variables but the

1 Email: xueguangwu@sina.cn
2 Email: lqchen@nudt.edu.cn
3 Email: wj@nudt.edu.cn

http://dx.doi.org/10.1016/j.entcs.2014.08.004
1571-0661/© 2014 Elsevier B.V. All rights reserved.

found bounds are numerical constants. However, in certain applications (such as automatic parallelization [3], symbolic bounds analysis [14] and bitwidth analysis [17]), symbolic ranges are desired. Symbolic range means that the bounds a and b of variable x are symbolic expressions over program variables except x.
In this paper, we present an abstract domain, namely parametric ranges, for deriving symbolic ranges over nonnegative parameters for each program variable. The new domain is designed based on the insight that in certain applications, the parameters of program procedures are often nonnegative, such as the initial length of an input list, the initial size of an input array (or memory region), and the starting address of a memory region. The domain of parametric ranges seeks to infer the lower and upper bounds for each program variable where each bound is a linear expression over nonnegative parameters, i.e., x ∈ [Σmaipi + c, Σmbipi + d] where
i	i
pi denotes the symbolic value of the ith nonnegative parameter of the program
procedure, ai, bi ∈ R,c ∈ R ∪ {−∞},d ∈ R ∪{+∞}. The time and space complexity of the domain operations of parametric ranges is O(nm) where n is the number of program variables and m is the number of nonnegative parameters. On this basis, we show the application of parametric ranges to infer symbolic ranges of list segment sizes for programs manipulating singly-linked lists. Moreover, we show how to combine the domain of parametric ranges with the affine equality domain to infer more complicated relations. Finally, we show preliminary experimental results.
We illustrate the domain of parametric ranges for invariant generation using a motivating example shown in Fig. 1 which has a nonnegative parameter n of type unsigned int. The interval domain [7] can only infer x ∈ [0, +∞] at the loop head ʘ. However, our domain of parametric ranges infers interesting symbolic ranges for x. Moreover, for this example, the invariants generated by the domain of parametric ranges are as precise as those given by the polyhedra domain [9].

void foo(unsigned int n) {
unsigned int x; x := n;
ʘ while (x ≤ 2n) do {
	if (?) then	x := x + 2;
else	x := 2 ∗ x + 1;
© } od
}

Fig. 1. A motivating example

The rest of the paper is organized as follows. Section 2 discusses some related work. Section 3 presents the new abstract domain of parametric ranges. In Sec- tion 4, we show the application of parametric ranges to infer symbolic ranges of list segment sizes in list-manipulating programs. Section 5 presents our prototype im- plementation together with preliminary experimental results. Finally, conclusions as well as suggestions for future work are given in Section 6.

Related Work

Value range analysis has received much attention in compilation optimization, au- tomatic parallelization and program analysis. In the framework of abstract inter- pretation, Cousot and Cousot [7] present the interval abstract domain to perform interval analysis using widening and narrowing. The interval domain can only infer numerical bounds of variable values, but scales to large-scale software in practice due to its linear time and space complexity.
Blume and Eigenmann [3] present symbolic range propagation technique to com- pute symbolic ranges in the context of parallelizing compilers. In their approach, symbolic range of variable x can be non-linear expressions with max/min operators over arbitrary variables except x. Hence, their approach is of exponential complexity in the worst case and requires heuristics to derive polynomial time operations. Our domain of parametric ranges differs from theirs in the following respect: parametric ranges of program variables are linear expressions over nonnegative parameters. In our approach, the set of program variables and the set of nonnegative parameters are disjoint. These restrictions greatly simplify the algorithms for implementing domain operations of parametric ranges. Thanks to these restrictions, the domain operations of parametric ranges are O(nm) in time and space complexity.
Rugina and Rinard [14] present a framework for symbolic bounds analysis of pointers, array indices and accessed memory regions. They utilize symbolic poly- nomial expressions to bound the ranges of the pointers and array indices used to access memory. Instead of using fixed-point algorithms, their approach formulates the symbolic bound analysis problem as a system of constraints over symbolic bound polynomials and then reduces the constraint system into a linear program. The step of reduction to linear program is incomplete. Moreover, the soundness of the reduc- tion to linear programs requires that all the variables in the symbolic polynomial expressions should be nonnegative. Our approach also requires that all the param- eters in symbolic ranges are nonnegative. However, our approach only allows linear expressions as parametric ranges and is designed as an abstract domain. And our analysis does not need linear programming.
Sankaranarayanan et al. [15] present an abstract domain of symbolic range constraints. They assume a linear ordering among program variables and restrict the range for a variable x to involve variables of order strictly higher than x. Our domain restricts the range for a program variable to involve a separate set of nonnegative parameters rather than other program variables. In general, our domain is less expressive than their domain, since one could always assign nonnegative parameters with higher order than program variables in their domain. Moreover, their domain allows explicit relations among program variables and does not restrict parameters involved in the ranges to be nonnegative. However, with respect to time complexity, our domain is cheaper than their domain.
Our domain of parametric ranges is closest to the gauge abstract domain pro- posed by Venet [16] which is able to efficiently infer linear inequality invariants between each program variable and all loop counters in the scope of the loops. In

the gauge domain, each program variable is approximated by a pair of symbolic ranges that are linear expressions with integer coefficients over loop counters. Our domain of parametric ranges restricts the parameters to be nonnegative but not nec- essarily integers. Also we do not restrict the coefficients in the parametric ranges to be integers. The analysis based on the gauge domain will introduce a loop counter for each level of loops during the analysis, and thus could infer symbolic ranges for each program variable in terms of loop counters. Those loop counters can not be considered as parameters in our domain of parametric ranges, since they are ini- tialized by zero and increase during the analysis. However, the loop bounds can be considered as parameters in our domain, and then we could infer parametric ranges for program variables in terms of loop bounds.
Symbolic Ranges over Nonnegative Parameters
Domain Representation
Let’s consider a program procedure with n program variables x1,..., xj,..., xn, to- gether with m nonnegative parameters p1,..., pi,..., pm. In practice, those param- eters can be chosen from formal parameters of program procedures, global variables that are only read but never written by the considered program procedure, inputs from I/O devices, etc.
We maintain parametric ranges for each program variable xj in the abstract domain, denoted as
xj ∈ [Σiaipi + c, Σibipi + d]
where ai, bi ∈ R,c ∈ R ∪ {−∞},d ∈ R ∪ {+∞} and pi is a non-negative parameter.
The concretization is defined by
γ([Σiaipi + c, Σibipi + d]) = {xj ∈ R | Σiaipi + c ≤ xj ≤ Σibipi + d}
which represents the set of possible values of xj.
Relaxation of the non-negativity restriction. Note that the non-negativity restriction of parameters can be relaxed. If we know one of the numerical lower bound c or the numerical upper bound d for a parameter pi that may take both negative or positive values, we could introduce a new auxiliary nonnegative param- eter pj such that
pj d=ef pi − c
or
pj d=ef d − pi

It is easy to see that it always holds that pj
≥ 0. Then we could replace all the

appearances of pi by pj + c (or d − pj ) in the whole program syntactically.
i	i
Domain Operations
Before we show domain operations over parametric ranges, we first define the fol- lowing ordering ±e (иe) on linear expressions over nonnegative parameters such

that
Σiaipi + c ±e Σibipi + d	if and only if	∀p ∈ [ p, p ], Σi(bi − ai)pi + (d − c) ≥ 0
( Σiaipi + c иe Σibipi + d	if and only if	∀p ∈ [ p, p ], Σi(bi − ai)pi + (d − c) > 0 )
where [ p, p ] denotes numerical ranges for parameters p. Note that it always holds that [ pi, pi ] ⊆ [0, +∞] (where 0 ≤ i ≤ m). In our implementation, we first check whether it holds that



where
Σi(bi − ai)pj + (d − c) ≥ 0
( Σi(bi − ai)pj + (d − c) > 0 )
pj = ⎧⎨ pi	if ai ≥ bi

⎩ pi	otherwise
which implies Σi(bi −ai)pi +(d−c) ≥ 0 (or Σi(bi −ai)pi +(d−c) > 0). However, note that Σi(bi −ai)pi + (d−c) ≥ 0 does not necessarily imply Σi(bi −ai)pj + (d−c) ≥ 0. We utilize ⊥p to denote the empty parametric range when Σi(bi −ai)pi +(d−c) < 0
.
Now we describe the implementation of the most common domain operations that are used in numerical static analysis.
Inclusion Test.	Inclusion test ±p between two parametric ranges for the same program variable xj, is defined as
[Σiaipi + c, Σibipi + d] ±p [Σiaj pi + cj, Σibj pi + dj]
i	i


d=ef
Σiaj pi + cj ±e Σiaipi + c ∧ Σibipi + d ±e Σibj pi + dj

i	i
Meet. The intersection Hp of two parametric ranges for the same program variable
xj, is defined as
[Σiaipi + c, Σibipi + d] Hp [Σiaj pi + cj, Σibj pi + dj]
i	i
def ⎧⎨ ⊥p	if Σibipi + d иe Σiaj pi + cj ∨ Σibj pi + dj иe Σiaipi + c
=	i	i
⎩ [lexp, lexpj]	otherwise

where

⎧⎪ Σiaipi + c	if Σiaj pi + cj ±e Σiaipi + c

i
⎪
def ⎪⎨ Σiaj pi + cj	else if Σiaipi + c ±e Σiaj pi + cj

i
⎪⎩ Σiaj pi + cj	otherwise

and
⎧⎪ Σibipi + d	if Σibipi + d ±e Σibj pi + dj

i
⎪
def ⎪⎨ Σibj pi + dj	else if Σibj pi + dj ±e Σibipi + d

i
⎪⎩ Σibj pi + dj	otherwise
Note that for lexp we try to choose the smaller one (with respect to ±e) between Σiaipi +c and Σiaj pi +cj. When Σiaipi +c and Σiaj pi +cj are not comparable, we use
i	i
a heuristic strategy to pick one from them as the new lower bound, by comparing
the sums of the coefficients. It is worth noting that it is sound to choose either Σiaipi + c or Σiaj pi + cj as the resulting lower bound, according to the concrete semantics of intersection, i.e.,
γ([Σiaipi + c, Σibipi + d]) ∩ γ([Σiaj pi + cj, Σibj pi + dj])
i	i
⊆ γ([Σiaipi + c, Σibipi + d] Hp [Σiaj pi + cj, Σibj pi + dj]).
i	i
The same idea applies to lexpj for upper bound.
Join. To abstract the control-flow join in the program, we need to compute the union of two parametric ranges for the same program variable xj. In this paper, we compute an over-approximation [lexp, lexpj] of the union such that both the two input parametric ranges are included in [lexp, lexpj]. The join operation Hp is defined as follows:
[Σiaipi + c, Σibipi + d] Hp [Σiaj pi + cj, Σibj pi + dj] d=ef [lexp, lexpj]
i	i


where

lexp d=ef

⎧ Σ a p + c	if Σ a p + c ± Σ aj p + cj
⎨ Σ aj p + cj	else if Σ aj p + cj ± Σ a p + c

i i i
i i i
e	i i i

⎪⎪⎩ Σi min(ai, aj )pi + min(c, cj)	otherwise


and

lexpj d=ef

⎧ Σ b p + d	if Σ bj p + dj ± Σ b p + d
⎨ Σ bj p + dj	else if Σ b p + d ± Σ bj p




+ dj

i i i
i i i
e	i i i

⎪⎪⎩ Σi max(bi, bj )pi + max(d, dj)	otherwise
Note that since for all i we have pi ≥ 0, it always holds that
(Σi min(ai, aj )pi + min(c, cj)) ±e (Σiaipi + c)


and
(Σibipi + d) ±e (Σi max(bi, bj )pi + max(d, dj))

Hence, the result of the join operation Hp always provides an overapproximation of the two input parametric ranges.
Example 3.1 Consider the program shown in Fig. 1. When the fixed point itera- tion becomes stable, at  , we have x ∈ [n, 2n]. At the program point after applying the assignment transfer function of the then branch, we get x ∈ [n + 2, 2n + 2]. And at the program point after applying the assignment transfer function of the else branch, we get x ∈ [2n + 1, 4n + 1]. Then, at the control-flow join point ©, we need to compute the join [n + 2, 2n + 2] Hp [2n + 1, 4n + 1], which will result in [n + 1, 4n + 2].
Test Transfer Function. Any conditional test involving program variables (xj) and parameters (pi) can be converted to a series of conditional tests of the form xj ≤ Σiaipi + c or xj ≥ Σibipi + d, by substituting each variable xk (where k /= j) in the conditional test constraint by its parametric range. Then we define the test transfer function as follows:
[[xj ≤ Σiaipi + c]]# (ρx ) d=ef ρx Hp [−∞, Σiaipi + c]
[[xj ≥ Σibipi + d]]# (ρx ) d=ef ρx Hp [Σibipi + d, +∞]
where ρ denotes the abstract environment that maps each program variable to its symbolic range before applying the transfer function and ρxj denotes the symbolic range of xj.
Assignment Transfer Function. Any assignment xj := e wherein e is an expression involving program variables (xj) and parameters (pi) can be converted to an assignment of the form xj := [Σiaipi + c, Σibipi + d], by substituting each program variable in e by its parametric range. Then we define the assignment transfer function as follows:
[[xj := [Σiaipi + c, Σibipi + d]]]# (ρx ) d=ef [Σiaipi + c, Σibipi + d]

Widening with Thresholds. Widening with thresholds [2] qT is a widening pa- rameterized by a finite set of threshold values T , including −∞ and +∞. Widening with thresholds for the parametric ranges domain is defined as:
[Σiaipi + c, Σibipi + d]∇T [Σiaj pi + cj, Σibj pi + dj]
p	i	i
d=ef [Σiajjpi + cjj, Σibjjpi + djj]
i	i
where
i	i	i
⎪
⎪⎨ cjj d=ef c ≤ cj ? c : max{l ∈ T | l ≤ cj}

i	i	i
⎪
⎩ djj d=ef d ≥ dj ? d : min{h ∈ T | h ≥ dj}

where T is a finite set of threshold values, including −∞ and +∞. Recall that ? : denotes the conditional operator.

Intuitively, qT
utilizes element-wise the interval widening with thresholds for

each coefficient of parameters as well as the constant term. Furthermore, when a program variable xj is also known to be always nonnegative, e.g., of type unsigned int, the widening for the parametric ranges of xj can be improved as:
[Σiaipi + c, Σibipi + d]∇T [Σiaj pi + cj, Σibj pi + dj]
p	i	i
def ⎧⎨ [Σiajjpi + cjj, Σibjjpi + djj]	if 0 ±e Σiajjpi + cjj
⎩ [0, Σibjjpi + djj]	otherwise where ajj, cjj, bjj, djj are defined the same as above.
i	i
Example 3.2 Consider the procedure shown in Fig. 2 which is adapted from [6]. After the first iteration, the input arguments of the widening at ʘ are ρx : [0.75n +

1, 0.75n + 1] and ρj
: [0.6875n + 1,n + 1.25]. If we use {0, 0.5, 1, 1.5} together with

+∞ and −∞ as the threshold set T , ρx∇T ρj
will result in [0.5n + 1,n + 1.5], which

p  x
will be stable in the subsequent increasing iterations.
void foowiden(unsigned int n){
real x;
x := 0.75 ∗ n + 1;
while (true) do {
ʘ	if (?)
then	x := n + 1;
else	x := 0.25 ∗ x + 0.5 ∗ n + 1;
} od
}
Fig. 2. An example to show widening of parametric ranges.


Application to Infer Symbolic Ranges of List Segment Sizes
In our previous work [4][5], we have shown an approach to derive a numerical pro- gram with nonnegative integer variables from a program that manipulates singly- linked lists. The main idea is as follows: a singly-linked list can be divided into a set of non-overlapping list segments, according to reachability of pointer variables to list nodes. For each list segment, we introduce an auxiliary nonnegative integer variable, called counter variable, to denote the size of that list segment (that is the number of the list nodes contained in that list segment). In list-manipulating program pro- cedures, there often exist nonnegative parameters that represent the initial lengths of the input lists. Hence, in the derived numerical programs from list-manipulating programs, counter variables together with those numerical variables appeared in the

original list-manipulating programs can be considered as program variables, while the initial lengths of the input lists can be considered as nonnegative parameters.
In the derived numerical programs from list-manipulating programs, there often exist affine equality relations between program variables and parameters. Hence, we combine the domain of parametric ranges with the affine equality abstract domain
[12] to perform the analysis. We use parametric ranges to track symbolic range information of each program variable, and use affine equalities to track the affine equality relations among program variables and parameters. Assume that there are n program variables and m nonnegative parameters. Then each domain element in the combined domain is described by an affine equality system Ay = b where y = [x p]T and A ∈ R(n+m)×(n+m),b ∈ Rn+m, together with symbolic ranges for program variables xj ∈ [Σiaipi + c, Σibipi + d] (where ai, bi ∈ R,c ∈ {R, −∞},d ∈ {R, +∞}) and numerical ranges for nonnegative parameters pi ∈ [cj, dj] (where 0 ≤ cj ≤ dj).
Bound tightening. In the combined domain, the symbolic ranges of each pro- gram variable are maintained by the domain of parametric ranges. However, the parametric ranges may be changed during domain operations of the affine equality domain. E.g., when an affine equality is added, the parametric ranges of variables can be tightened. In this paper, we adapt the bound prorogation technique that is a kind of constraint propagation widely used in constraint programming [1], to tighten the parametric ranges.
In fact, each affine equality of the combined domain can be used to tighten the parametric ranges for those program variables occurring in it. Let [xj, xj] denote the parametric range of program variable xj. Then, given an equality Σiaixi + Σjajpj = b, if ai /= 0, a new candidate parametric lower bound for xi comes from: xj = (b − Σjajpj − Σj/=iajxj )/ai where xj = aj > 0? xj : xj , and a new candidate parametric upper bound for xi comes from: xj = (b − Σjajpj − Σj/=iajxj )/ai where
i	j
xj = aj > 0? xj : xj. If the new parametric ranges are tighter, then xi’s ranges are updated. This process can be repeated with each variable in that equality and with
each equality in the system.
Example 4.1 Consider  the  list-manipulating  program  procedure copy and delete() shown in Fig. 3 (a). It has a nonnegative parameter n as the initial length of the input list x. The program first reversely copies list x to list p, and then delete both lists simultaneously. To prove the memory safety of this program, a key invariant is needed to show that the length of list p is equal to the length of list x after line 11. Moreover, if a statement accesses the next field of a list variable p (e.g., the statements in Lines 6, 8, 13, 14), we need to show that the length of the list segment pointed to by p is greater than or equal to 1. Fig. 3 (b) shows a numerical program derived from the list-manipulating program copy and delete(), in which tpq denotes the size of the list segment that can be reached by list variables p and q.  For example, the list assignment statement
{y := x; } on Line 3 in Fig. 3 (a) means that after the assignment both x and
y point to the list segment that used to be pointed to by only x. And after the assignment, it is easy to see that there will be not any more list segment that is pointed to by only x (without y).  Hence, according to the semantics of list

void copy and delete(List* x, uint n){	void copy and delete num(uint n){
1:	List* y, p, q;	uint tx, ty, txy, tp, tq, tpq;
2:	assume \length(x)==n;	tx := n;
3:	y := x;	txy := tx; tx := 0;
4:	q := p := null;	tp := 0; tq := 0; tpq := 0;
5:	while (y != null) do {	while (txy ≥ 1) do {
6:	y := y → next;	tx := tx+1; txy := txy -1;
7:	q := malloc();	tp := tpq; tpq := 0; tq := 1;
8:	q → next := pList;	tpq := tp; tp := 0;
9:	p := q;	tpq := tq+tpq; tq := 0;
10:	} od	} od
11:	y := x;	txy := tx; tx := 0;
12:	while (y != null) do {	while (txy ≥ 1) do {
tx := tx+1; txy := txy -1;
tp := tp+1; tpq := tpq -1; ty := txy; txy := 0; tx := 0; tq := tpq; tpq := 0; tp := 0; txy := ty; ty := 0;
tpq := tq; tq := 0;

(a)	(b)
Fig. 3. A list-manipulating program (a) together with its numerical version (b). uint denotes unsigned int.
assignment, we can derive the numerical statements {txy := tx; tx := 0; } shown on Line 3 in Fig. 3 (b). We refer the reader to [4][5] for details about how to derive a numerical program from a list-manipulating program. Using the combined domain of parametric ranges and affine equalities, after Line 12, we infer invariants:
{txy −tpq == 0, txy ∈ [1, n], tpq ∈ [1, n],n ∈ [1, +∞]}. These invariants are sufficient to prove the memory safety of the second loop (i.e., from Line 12 to Line 19).
Implementation and Experiments
We have implemented our prototype domain of parametric ranges PaRa, inside the Apron [11] numerical abstract domain library which provides a common in- terface for numerical abstract domains. Our experiments were conducted using the Interproc [13] static analyzer.
In order to assess the precision and efficiency of PaRa, we compare the obtained invariants as well as the performance of PaRa with the interval domain Box and the polyhedra domain NewPolka in Apron. Our experiments were conducted on two sets of examples. The results are summarized in Figs. 4-5. The column “#Vars” gives the number of program variables and “#Pars” gives the number of nonnegative parameters. “PaRa+AffineEqs” denotes the combined domain of parametric ranges and affine equalities. “Inv.” compares as a whole the invariants obtained by two domains.  A “>” (“<”, “=”, “/=”) indicates that the left-side

analysis outputs stronger (weaker, equivalent, incomparable) invariants than the right-side analysis. The analysis times are given when the analyzer is run on a
2.5GHz PC with 2G of RAM running Fedora 12.

Fig. 4. Experimental results on numerical programs.
Fig. 4 shows the results on a collection of small numerical programs. foo and foowiden respectively correspond to the programs shown in Fig. 1 and Fig. 2. Pro- grams with prefix “ex ” are taken from related work of symbolic ranges analysis [3,14,15,16], symbolic complexity bound analysis [10]. The program all above is con- structed by concatenating all the other programs listed in Fig. 4. For all programs listed in Fig. 4 except ex cav12 2 (which involves no parameters), PaRa gives more precise invariants than the interval domain Box. Compared with the polyhedra domain NewPolka, PaRa generates less precise invariants in most cases. How- ever, for the program foowiden, PaRa generates more precise invariants than New- Polka due to the widening with thresholds used in PaRa which tries thresholds on coefficients of parameters. For all programs with prefix “ex ” except ex ipps95 and ex cav12 1, although PaRa is less precise than NewPolka, “PaRa+AffineEqs” is as precise as NewPolka, since these programs involve affine equality relations between program variables, which cannot be expressed in PaRa but can be ex- pressed in “PaRa+AffineEqs”. For ex cav12 1, “PaRa+AffineEqs” is less precise than NewPolka, since this program involves inequality invariants among program variables which cannot be expressed in “PaRa+AffineEqs” but can be captured by NewPolka.
Fig. 5 shows the results on a set of numerical programs which are manually de- rived from list-manipulating programs. These list-manipulating programs contain commonly used operations over singly-linked lists such as create, traverse, reverse, merge, copy, delete and dispatch. The program list all above is constructed by concatenating all the other programs listed in Fig. 5. This kind of numerical pro- grams derived from list-manipulating programs often involve affine equality relations among program variables and nonnegative parameters. Hence, we utilize the com- bined domain of parametric ranges and affine equalities to analyze these programs. On these programs, “PaRa+AffineEqs” gives as precise invariants as those given by NewPolka. And these invariants are precise enough to prove the memory safety of the original list-manipulating programs.


Fig. 5. Experimental results on numerical programs derived from list-manipulating programs.
Conclusion
We have presented an abstract domain of parametric ranges to capture the sym- bolic ranges of each program variable, wherein the bounds of value ranges of each program variable are described as linear expressions over nonnegative parameters. This domain is more powerful than the interval abstract domain. The time and space complexity of its domain operations is O(nm) where n is the number of pro- gram variables and m is the number of nonnegative parameters. As an example to illustrate the usefulness of the new domain, we have shown its application to infer symbolic ranges of list segment sizes for analyzing list-manipulating programs.
It remains for future work to consider experiments on larger programs and the usage of parametric ranges in more applications such as buffer overflow analysis. Another direction of work is to consider using nonlinear expressions over nonnegative parameters as symbolic ranges. In this case, a nonlinear template could be chosen for each program variable.
Acknowledgement
We would like to thank the anonymous reviewers for their constructive comments. This work is supported by the 973 Program under Grant No. 2014CB340703, the NSFC under Grant Nos. 61202120, 61120106006, 91318301, and the SRFDP under Grant No. 20124307120034.

References
Bessiere, C., Constraint propagation, in: F. Rossi, P. van Beek and T. Walsh, editors, Handbook of Constraint Programming, Elsevier, 2006 .
Blanchet, B., P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Monniaux and X. Rival, A static analyzer for large safety-critical software, in: PLDI (2003), pp. 196–207.
Blume, W. and R. Eigenmann, Symbolic range propagation, in: IPPS (1995), pp. 357–363.
Chen, L., R. Li, X. Wu and J. Wang, Static analysis of list-manipulating programs via bit-vectors and numerical abstractions, in: SAC (2013), pp. 1204–1210.
Chen, L., R. Li, X. Wu and J. Wang, Static analysis of lists by combining shape and numerical abstractions, Science of Computer Programming (2014), http://dx.doi.org/10.1016/j.scico.2014.06.004.

Chen, L., A. Min´e, J. Wang and P. Cousot, An abstract domain to discover interval linear equalities, in: VMCAI, LNCS 5944 (2010), pp. 112–128.
Cousot, P. and R. Cousot, Static determination of dynamic properties of programs, in: Proc. of the 2nd International Symposium on Programming (1976), pp. 106–130.
Cousot, P. and R. Cousot, Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints, in: POPL (1977), pp. 238–252.
Cousot, P. and N. Halbwachs, Automatic discovery of linear restraints among variables of a program, in: POPL (1978), pp. 84–96.
Gulwani, S., Speed: Symbolic complexity bound analysis, in: CAV, LNCS 5643 (2009), pp. 51–62.
Jeannet, B. and A. Min´e, Apron: A library of numerical abstract domains for static analysis, in: CAV, LNCS 5643 (2009), pp. 661–667.
Karr, M., Affine relationships among variables of a program, Acta Inf. 6 (1976), pp. 133–151.
Lalire, G., M. Argoud and B. Jeannet, Interproc, http://pop-art.inrialpes.fr/people/bjeannet/bjeannet- forge/interproc/.
Rugina, R. and M. C. Rinard, Symbolic bounds analysis of pointers, array indices, and accessed memory regions, ACM Trans. Program. Lang. Syst. 27 (2005), pp. 185–235.
Sankaranarayanan, S., F. Ivancic and A. Gupta, Program analysis using symbolic ranges, in: SAS, LNCS 4634 (2007), pp. 366–383.
Venet, A., The gauge domain: Scalable analysis of linear inequality invariants, in: CAV, LNCS 7358
(2012), pp. 139–154.
Zaks, A., Z. Yang, I. Shlyakhter, F. Ivancic, S. Cadambi, M. K. Ganai, A. Gupta and P. Ashar, Bitwidth reduction via symbolic interval analysis for software model checking, IEEE Trans. on CAD of Integrated Circuits and Systems 27 (2008), pp. 1513–1517.
