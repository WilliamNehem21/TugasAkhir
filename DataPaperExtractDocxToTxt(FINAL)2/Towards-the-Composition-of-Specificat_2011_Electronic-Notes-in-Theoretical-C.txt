Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 280 (2011) 81–93
www.elsevier.com/locate/entcs

Towards the Composition of Specifications in Event-B
Renato Silva1,2
School of Electronics and Computer Science University of Southampton
Southampton, UK

Abstract
The development of a system can start with the creation of a specification. Following this viewpoint, we claim that often a specification can be constructed from the combination of specifications which can be seen as composition. Event-B is a formal method that allows modelling and refinement of systems. The combination, reuse and validation of component specifications are not currently supported in Event-B. We extend the Event-B formalism using shared event composition as an option for developing (distributed) systems. Refinement is used in the development of specifications using composed machines and we prove that properties and proof obligations of specifications can be reused to ensure valid composed specifications. The main contributions of this work are the Event-B extension to support shared event composition and refinement including the proof obligations for a composed machine.
Keywords: composition, refinement, Event-B, development of specifications, formal methods


Introduction
Systems can often be seen as a combination and interaction of several sub- specifications (hereafter called sub-components) where each sub-component has its own functionality aspect. This view introduces modularity in the system: differ- ent sub-components represent a particular functionality and changes in the sub- components are accommodated more gracefully [12] in the system specification. We use composition to structure specifications through the interaction of sub- components seen as independent modules. This use of composition is not new in other formal notations: examples are [22,13,15]. Here we express how we can use (and reuse) composition for building specifications in Event-B [2] through sub- components (modules) interaction, benefiting from their properties and proof obli-

1 R. Silva receives a Doctoral Degree Grant sponsored by Funda¸c˜ao Ciˆencia e Tecnologia (FCT-Portugal). Part of this research was carried out within the European Commission ICT project 214158 DEPLOY (http://www.deploy-project.eu)
2 Email:ras07r@ecs.soton.ac.uk

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.11.020

gations (POs). The interesting part of composition involves the interaction of sub- components which usually occurs by shared state [4], shared operations [7] ora com- bination of both (for example, fusion composition [15]). Although sub-components have states, we mainly focus on their (visible) events similar to CSP [11,14]: we fol- low a shared event composition approach where events are synchronised in parallel. This document is structured as follows: Sect. 2 briefly describes Event-B. Sec- tion 3 introduces the notion and properties for shared event approach. Composed machine, POs and the monotonicity property are introduced in Sect. 4. Related
work, conclusions and future work are drawn in Sect. 5.
Event-B Language
Event-B is a formal methodology that uses mathematical techniques based on set theory and first order logic supporting system development. An abstract Event-B specification is divided into a static part called context and a dynamic part called machine. A machine sees as many contexts as desired. A context consists of sets s (collection of elements or a type definition), constants c and axioms A(... ) of the system. A machine contains the state (global) variables v whose values are assigned in events. Events that can be parameterised (local variables p) and occur when enabled by their guards G(... ) being true and as a result actions S(... ) are executed. Invariants I(... ) define the dynamic properties of the specification and POs are generated to verify these properties. An event evt is expressed by parameters p, guards G(s, c, p, v) and actions S(s, c, p, v, vj):
evt =^ ANY p WHERE G(s, c, p, v) THEN S(s, c, p, v, v′) END.

When G(s, c, p, v) is true then evt is enabled and S(s, c, p, v, vj) updates the set of variables v to vj (value of v after the assignment). An abstract Event-B specification can be reﬁned with the introduction of more details, becoming closer to a concrete implementation. A context extends an abstract one by adding sets, constants or axioms. Machine refinement consists in refining existing events. The relation be- tween concrete and abstract variables is given by a gluing invariant J (... ). POs are generated to ensure that this invariant is always preserved. New events can be added, refinining skip and may be declared as convergent (the convergence is proved if each new event decreases a variant that must be well-founded and may be an integer or a finite set) or anticipated (to avoid a technical difficulty of using abstract variables in a new event during a refinement step; they must not increase the variant, only needing to decrease it when they become convergent in a further refinement [2]).
Shared Event Approach
Sub-component specifications that are part of a full system specification, deal with a particular part of the system being modelled. Sub-component interaction must be verified to comply with the desired behavioural semantic of the system. The

interaction usually occurs as a shared state, shared event or a combination of both as described. Here we focus on the developments using shared event composition only where composition is treated as the conjunction of individual elements’ properties: conjunction of individual invariants, conjoining variables and synchronisation of events. Consider Fig. 1(a) where machine M has events e1 and e2 that use variable

(a)	(b)
Fig. 1. Simple view of the shared event composition of M and N (a) resulting in P (b)
v1. Moreover machine N has events e3, e4 and e5 using variables v2 and v3. If events e2 and e3 occur in parallel, they can be synchronised: machines M and N are composed by sharing events. For example, machine P in Fig. 1(b) composes e2 from machine M and e3 from machine e3 : e2  e3. The interaction of machines M and N through their events results in a composed event sharing two independent variables: v1 and v2. The parallel composition of events e2 and e3 from Fig. 1 is defined as Def. 3.1 [7]:
Definition 3.1 Composition of events e2 and e3 with parameter p results in:
e2 =^ ANY p?,x WHERE p? ∈ C ∧ G(p?, x, m) THEN S(p?, x, m) END
e3 =^ ANY p!,y WHERE H(p!, y, n) THEN T (p!, y, n) END
e2  e3 =^ ANY p!, x,y WHERE p! ∈ C ∧ G(p!, x, m) ∧ H(p!, y, n)
THEN S(p!, x, m)  T (p!, y, n) END
where x, y, p are sets of parameters from each of the events e2 and e3. Event e2 has p? as an input parameter and e3 has p! as an output parameter and the resulting composition is p! itself an output parameter (like in CSP). “!”, “?” are used as syntactic sugar and are not part of the Event-B language. This property can be used to model value-passing systems: e3 sends a message to e2 using parameter p. Communication between parameters of type input is also possible but not between types output since this could lead to a deadlock state [7]. Event-B has the same semantic structure and refinement definitions as action systems [17]. It is possible to make a correspondence between parallel composition in CSP and an event-based view of parallel composition for action systems [9,6].
Theorem 3.2 The shared event parallel composition of Event-B machines corre- sponds to CSP parallel-composition. The failure-divergence semantics of CSP can be applied to Event-B machines. The failure divergence semantics of machine M in parallel with N, M  N is deﬁned as:
JM  N ) = JM )  JN )
where JM ) and JN ) are the failure divergence semantics of M and N respectively. The proof of this theorem can be found in [9].

The semantics of the parallel composition of machines M and N corresponds to the set of failure-divergence for each individual machine in parallel. From the correspondence between action systems and Event-B, machines M and N can be refined independently which is one of the most important and powerful properties that shared event composition in Event-B inherits from CSP. The monotonicity property for the shared event composition in Event-B is proved by means of proof obligation in Sect. 4.4. When sub-components are composed it is desirable to define properties that relate the individual sub-components allowing interactions. These properties are expressed by adding composition invariants ICM (s, c, v1,..., vm) to the composed machine constraining the variables of all machines being composed.
Definition 3.3 The invariant of the parallel composition of machines M 1 to Mm with variables v1 to vm respectively is the conjunction of the individual invariants and the composition invariant ICM (s, c, v1,..., vm):

I(M 1  ···  Mm) =^ I1(s, c, v1) ∧ ··· ∧ Im(s, c, vm) ∧ ICM (s, c, v1,..., vm).	(1)

In Fig. 1, composed machine P has as invariant the conjunction of the individ- ual invariants I(M  N ) =^ IM (s, c, v1) ∧ IN (s, c, v2, v3) plus possible composition invariant ICM (s, c, v1, v2, v3). In a shared event composition the sub-components have independent state space (variables are unique to each machine). Although the resulting invariant in composed machines is more complex than the original ones, due to the state space separation and conjunction of properties, the individual in- variants are automatically discharged in the composed machines. We only need to deal with composition invariants. Consequently composition reasoning is simplified as there are no constraints between state spaces of sub-components.
Composed Machines: Composition and Refinement
We define a new construct composed machine, representing the shared event com- position of Event-B machines. We aim to have a construct that remains reactive to changes in the sub-components. Consequently the composition is structural. The interaction of sub-components following a “top-down” approach, can represent a reﬁnement of an existing abstraction. To formalise the composition, it is necessary to define composition and refinement POs. In the following sections, we introduce the structure of a composed machine, static checks, respective POs and prove the monotonicity property.
Structure of Composed Machines
A shared event composed machine is expressed as the parallel conjunction of sub- component properties. Machines are composed in parallel including their properties and events: CM =^ M 1  · · ·  Mm as seen in Fig. 2. Moreover:
The composed machine variables are all the sub-component variables (v1 from
M 1, v2 from M 2, ..., vm from M m) and are state-space disjoint.

The invariants of the composed machine are defined as Def. 3.3.
The composed events are defined according to Def. 3.1.

Fig. 2. Composed machine CM composing machines M 1 to Mm seeing context Ctx





Static Checks
For the implementation of a tool for composition, composed machines need to be val- idated against some well-formedness conditions. We distinguish between necessary technical conditions for the composition and methodological conditions (convenient and for simplicity). The technical conditions are as follows:
The machines to be composed belong to independent refinement chains.
A composed event is defined by events of different sub-components.
The same event can be synchronised and composed with different events. The methodological conditions are:
A composed machine is defined by at least one sub-component.
Composed machines refinining an abstract one do not introduce new events. For simplicity we restrict adding new events. Adding events before or after the com- position has a similar outcome to adding them during composition.
A composed event is defined by at least one event.
Variants are not required for composed machines. Only new convergent or antici- pated events require variants and they are not allowed, as justified in the previous point. Consequently, we restrict anticipated event refinements.
When the composed machine refines an abstract machine, the rules and refine- ment POs are applied similarly to standard machines.
An important point to address is the convergence of composed events. If we care about convergence, then the events in the included machines must be conver- gent. The composed events result from parallel synchronisation of include machines events. Therefore the convergence of composed events relies on the convergence of the original events. The conclusion is: if the events to be composed are convergent, then the resulting composed event is also convergent. Next we present the required POs to verify composed machines.

Proof Obligations
POs play an important role in Event-B developments. POs are generated to verify the properties of a model. For simplicity we define POs in terms of a composition of two machines M1 and M2 that refine machine M0, but the rules generalise easily to the composition of n machines. Furthermore context elements in the formulas (s, c, A(s, c)) are not considered. The POs defined for standard machines (invariant preservation, well-definedness, refinement, etc) [2] are defined for composed ma- chines. We simplify the composed machines POs by assuming that the POs of the individual machines hold. We define the additional POs necessary to ensure that the composed machine satisfies all the standard POs. We consider that the POs of the M 0, M1 and M2 hold. The respective composition POs are described as follows.

Consistency
Consistency POs are required to be always verified. Consistency is expressed by the feasibility and invariant preservation POs for each event. The feasibility proof obligation for the composed event evt1  evt2 is FISevt1  evt2.
Theorem 4.1 The individual FIS PO for each event can be reused for proving fea- sibility for each composed event and that is enough to verify this property. From [2]:

1	1
2	2

1	2	1	2
Assume: FISevt1 and FISevt2. Prove: FISevt1  evt2.
Proof.  Assume the hypotheses of FISevt1  evt2. Prove:
∃vj , vj ·(S1(p1, v1, vj ) ∧ S2(p2, v2, vj )).
1	2	1	2
The proof proceeds as follows:
∃vj ·(S1(p1, v1, vj )) ∧ ∃vj ·(S2(p2, v2, vj ))	{disjoint v1 and v2}
1	1	2	2
⇐ (FISevt1 ∧ FISevt2).	{(2),(3)+ hypotheses of (4)}
2

In the composed machine, invariant preservation PO INVCM corresponds to the invariant preservation in all events. The invariant preservation PO for the composed event evt1  evt2 is INVevt1  evt2.
Theorem 4.2 For each invariant i from the set of invariants I in a composed

machine, composition invariant ICM (v0, v1, v2) needs to be veriﬁed. From [2]:

INVevt1 :	I1(v1) ∧ G1(p1, v1) ∧ S1(p1, v1, vj ) ▶ i1(vj )	(5)
1	1
INVevt2 :	I2(v2) ∧ G2(p2, v2) ∧ S2(p2, v2, vj ) ▶ i2(vj )	(6)
2	2
INVevt1  evt2 :	ICM (v0, v1, v2) ∧ I1(v1) ∧ I2(v2) ∧ G1(p1, v1) ∧ G2(p2, v2)
∧ S1(p1, v1, vj ) ∧ S2(p2, v2, vj ) ▶ i1(vj ) ∧ i2(vj ) ∧ iCM (v0, vj , vj )

1	2	1	2
1	2
(7)


Assume: INVevt1 and INVevt2. Prove: INVevt1  evt2.
Proof.  Assume the hypotheses of INVevt1  evt2. Prove:

i1(vj ) ∧ i2(vj ) ∧ iCM (v0, vj , vj ).
1	2	1	2

The proof proceeds as follows:

i1(vj ) ∧ i2(vj ) ∧ iCM (v0, vj , vj )
1	2	1	2
⇐ INVevt1 ∧ INVevt2 ∧ iCM (v0, vj , vj ).	{(5),(6) and hypotheses of (7)}
1	2
2

Well-definedness for expressions (guards, actions, invariants, etc) needs to be verified. These are verified by means of POs in Event-B [3]. For composed machines, well-definedness POs are only generated for ICM (v0, v1, v2). Other expressions are verified in the individual machines.

Reﬁnement
Refinement POs are required when the composed machine refines an abstract ma- chine. Machine M0 with variables v0, invariant I0(v0) and abstract event evt0 is refined by composed machine CM defined by machines M1 with variables w1, in- variant I1(w1), event evt1 and M2 (w2 ; I2(w2); evt2) and composition invariant JCM (v0, w1, w2). The composed event evt1  evt2 refines the abstract event evt0. A general refinement PO (REFevti) for a machine M refining event evt follows from:

REFevti =^ Ii(vi) Λ Ji(vi, wi) Λ Hi(qi, wi) Λ Ti(qi, wi, w′) ▶ Ev′ ·Gi(vi) Λ Si(pi, vi, v′) Λ Ji(v′, w′).	(8)
i	i	i	i	i

Theorem 4.3 For each composed event evt1  evt2, reﬁning abstract event evt0 through (gluing) composition invariant in a composed machine, the reﬁnement REF PO consists in proving the guard strengthening of abstract guards, proving the simulation of the abstract variables (vj ) and preserving the gluing invariant

(JCM (vj , wj , wj )). From [2] and (8):
0	1	2
INVevt1 :	I1(w1) ∧ H1(q1, w1) ∧ T1(q1, w1, wj ) ▶ i1(wj )	(9)
1	1
INVevt2 :	I2(w2) ∧ H2(q2, w2) ∧ T2(q2, w2, wj ) ▶ i2(wj )	(10)
2	2
REFevt0±(evt1 evt2) :	I0(v0) ∧ I1(w1) ∧ I2(w2) ∧ JCM (v0, w1, w2)
∧ H1(q1, w1) ∧ H2(q2, w2) ∧ T1(q1, w1, wj ) ∧ T2(q2, w2, wj )
1	2
▶ ∃vj ·G0(p0, v0) ∧ S0(p0, v0, vj ) ∧ I1(wj )
0	0	1
∧ I2(wj ) ∧ JCM (vj , wj , wj ).
2	0	1	2
Assume: INVevt1 (9) and INVevt2 (10). Prove: REFevt0±(evt1  evt2).
Proof.  Assume the hypotheses of REFevt0±(evt1  evt2). Prove:
∃vj ·G0(p0, v0) ∧ S0(p0, v0, vj ) ∧ I1(wj ) ∧ I2(wj ) ∧ JCM (vj , wj , wj ).
0	0	1	2	0	1	2
The proof proceeds as follows:
G0(p0, v0) ∧ I1(wj ) ∧ I2(wj )	{∧ goal; v0, wj , wj
1	2	1	2
∧ ∃vj ·(S0(p0, v0, vj ) ∧ JCM (vj , wj , wj ))	are free variables}
0	0	0	1	2
≡ G0(p0, v0) ∧ ∃vj ·(S0(p0, v0, vj ) ∧ JCM (vj , wj , wj ))	{from (9) + (10)

0	0	0	1	2
for each i1(wj ),i2(wj )}
2

These are the required POs to verify composed machines. Next we show that composed machines are monotonic which allows to further refine individual ma- chines preserving composition.

Monotonicity of Shared Event Composition for Composed Machines
An important property of the shared event composition in Event-B is monotonicity. We prove it by means of refinement POs confirming the result described by Butler [9] using actions systems and CSP. Figure 3 shows abstract component specification M 1 composed with other component specification N 1, creating a composed model M 1  N 1. M 1 is refined by M 2 and N 1 by N 2 respectively. Once we compose component specifications M 1 and N 1, discharge the required composed POs, M 1 and N 1 can be refined individually while the composition properties are preserved without the need to recompose refinements M 2 and N 2. We want to formally prove the monotonicity property through refinement POs between composed machines. Therefore if the refinement POs hold between CM 1 and CM 2, we can say that CM 2 refines CM 1: CM 1 ± CM 2. The gluing invariant of the refinement between M1 and M2 is expressed as JM (vM , wM ) relating the states of M1 and M2: M 1 ±JM M 2. We can derive the refinement PO between M 2 and M 1 for the concrete event evtM2 refining abstract event evtM1.



Fig. 3. Refinement of composed machine CM 1 =^ M 1  N 1 by CM 2 =^ M 2  N 2



REFevtM 1±evtM 2  :	IM (vM ) ∧ JM (vM , wM ) ∧ GM (pM , vM ) ∧ HM (qM , wM )
∧ SM (pM , vM , vj ) ∧ TM (qM , wM , wj )

▶ ∃vj
·GM (pM , vM ) ∧ SM (pM , vM , vj
) ∧ JM (vj
, wj
). (11)

The refinement PO between N 2 and N 1 is similar. We refine an abstract event in CM1 by a concrete one in CM2 and verify that the refinement POs for each individual machine hold for the composition. Event evtM1 from machine M 1 and event evtN1 from machine N1 are composed, resulting in the abstract composed event evtM1  evtN1 in CM 1 from Fig. 3. The gluing invariant relating the states of CM 1 and CM 2 is expressed as the conjunction of the gluing invariants between (M 1 and M 2) and (N 1 and N 2):
JCM (vM , vN , wM , wN )= JM (vM , wM ) ∧ JN (vN , wN )	(12)
Theorem 4.4 The reﬁnement POs for composed machines is expressed as the con- junction of the reﬁnement POs for the individual machines. Therefore the mono- tonicity property holds if the reﬁnement POs of individual machines hold. The re- ﬁnement PO between concrete composed event evtM2  evtN2 and abstract composed event evtM1  evtN1 is expressed as:
REF(evtM1  evtN1)±(evtM2  evtN2) :	IM (vM ) ∧ IN (vN ) ∧ JCM (vM , vN , wM , wN )
∧ HM (qM , wM ) ∧ HN (qN , wN )
∧ TM (qM , wM , wj ) ∧ TN (qN , wN , wj )

▶ ∃vj
, vj
·GM (pM , vM ) ∧ GN (pN , vN )

∧ SM (pM , vM , vj ) ∧ SN (pN , vN , vj )

∧ JCM (vj
, vj
, wj
, wj
).	(13)


Assume: REFevtM 1±evtM 2 and REFevtN 1±evtN 2 . Prove: REF(evtM1  evtN1)±(evtM2  evtN2).
Proof.  Assume the hypotheses of REF(evtM 1  evtN 1)±(evtM 2  evtN 2). Prove:

∃vj
, vj
·GM (pM , vM ) ∧ GN (pN , vN ) ∧ SM (pM , vM , vj ) ∧

SN (pN , vN , vj
) ∧ JCM (vj
, vj
, wj
, wj ).

The proof proceeds as follows:


∃vj
, vj
·GM (pM , vM ) ∧ GN (pN , vN )

∧ SM (pM , vM , vj ) ∧ SN (pN , vN , vj )

∧ JM (vj
, wj
) ∧ JN (vj
, wj
)	{expanding JCM from (12)}

≡ ∃vj
·GM (vM ) ∧ SM (pM , vM , vj
) ∧ JM (vj
, wj )

∧ ∃vj
·GN (vN ) ∧ SN (pN , vN , vj
) ∧ JN (vj
, wj
)	{disjoint vj
,vj }

⇐ REFevtM 1±evtM 2 ∧ REFevtN 1±evtN 2	{(11) + hypotheses of (13)}
2
We also need to prove the monotonicity for single (non-composed) events that appear at both levels of abstraction. We shall prove it using machines M 1 and CM 2. In this case, the gluing invariant described in (12) does not use neither the variables (vN ) neither the invariants(IN ) neither events (evtN1) from N 1. Therefore it can be simplified and rewritten as:
JCM (vM , wM , wN )= JM (vM , wM ) ∧ JN (wN )	(14)
Theorem 4.5 An individual event evtM1 in machine M 1 is reﬁned by a composed event evtM2  evtN2 in composed machine CM 2. The monotonicity is preserved if the reﬁnement PO between M 1 and M 2 hold in conjunction with the gluing invariant preservation PO for the composed event evtM2  evtN2. The reﬁnement PO between concrete composed event evtM2  evtN2 and abstract non-composed event evtM1:
REFevtM 1±(evtM 2  evtN 2) :  IM (vM ) ∧ JCM (vM , wM , wN ) ∧ HM (qM , wM )
∧ HN (qN , wN ) ∧ TM (qM , wM , wj ) ∧ TN (qN , wN , wj )
▶ ∃vj ·GM (pM , vM ) ∧ SM (pM , vM , vj )

∧ JCM (vj
, wj
, wj
).	(15)

Assume: REFevtM 1±evtM 2 and INVevtM 2  evtN 2 (based on (7)). Prove: REFevtM1±(evtM2  evtN2).
Proof.	Assume the hypotheses of REFevtM 1±(evtM 2  evtN 2) and the hypotheses of
INVevtM 2  evtN 2 . Prove:


∃vj
·GM (pM , vM ) ∧ SM (pM , vM , vj
) ∧ JCM (vj
, wj
, wj ).

The proof proceeds as follows:


∃vj
·GM (pM , vM ) ∧ SM (pM , vM , vj
) ∧ JM (vj
, wj
) ∧ JN (wj )

{expanding JCM by (14)}

≡ ∃vj
·(GM (pM , vM ∧ SM (pM , vM , vj
) ∧ JM (vj
, wj
)) ∧ JN (wj
)	{free vj }

⇐ REFevtM 1
±evtM2
∧ JN (wj
)	{(11)+hypotheses of (15)}

⇐ REFevtM 1±evtM 2 ∧ INVevtM 2  evtN 2	{(7)}
2

New events can be added during refinement, respecting the refinement POs. The refinement PO proof for new events is similar to the previous cases but applied to a single event refined by a composed event. Due to the lack of space we do not present it here.

Related Work, Conclusions and Future Work
Composition allows the interaction of sub-components. Back [16], Abadi and Lamport[1] studied the interaction of components through shared variable compo- sition. Jones [21] also proposes a shared variable composition for VDM by restrict- ing the behaviour of the environment and the operation itself in order to consider the composition valid using rely-guarantee conditions. In Z, composition can be achieved by combining schemas [20] where variables within the same scope cannot have identical names or by views [12] allowing the development of partial specifica- tions that can interact through invariants that relate their state or by operations’ synchronisation. Although systems are developed in single machines in classical B, Bellergarde et at [5] suggest a composition by rearranging separated machines and synchronising their operations under feasibility conditions. The behaviour of a component composition is seen as a labelled transition system using weakest precon- ditions, where a set of authorised transitions are defined. The objective is to verify the refinement of synchronised parallel composition between components but it is limited to finite state transitions and a finite number of components. This work dif- fers from ours as it uses a labelled transition system allowing variable sharing while we use synchronisation and communication in the CSP style. Butler and Walden [8] discuss a combination of action systems and classical B by composing machines us- ing parallel systems in an action system style and preserving the invariants of the individual machines. This approach allows the classical B to derive parallel and distributed systems and since the parallel composition of action system is mono- tonic, the sub-systems in a parallel composition may be refined independently. This work is closely related to our work with similar underlying semantics and notion of refinement based on CSP. Abrial et al [4] propose a state-based decomposition for Event-B introducing the notion of shared variables and external events. Although it allows variable sharing, this approach is also monotonic but its respective nature is more suitable for parallel programs [10].
Our Event-B composition is based on the close relation between action sys-
tems and Event-B plus the correspondence between action systems and CSP [9]. A methodology for composition is defined including the verification of properties through the generation of POs. We extend Event-B to support shared event compo- sition, allowing combination and reuse of existing sub-components through composed machines and we prove it to be monotonic. Refinement in a “top-down” style for developing specifications is allowed. Sub-components interact through parameters by value-passing and can be further refined. POs of included machines are reused to discharge composition POs. Composition invariants can be added relating the state space of included machines, generating additional POs. From our experience,

these POs “suggest” the (possible) modifications to be applied to the included ma- chines, ensuring the invariant preservation by the composed events. Refinement of anticipated events is currently not allowed. We shall study this option in the future, lifting the restriction of variants usage. This approach seems suitable for modelling (distributed) systems resulting from the exploration of specifications’ composition. We do not address the step corresponding to the translation of this composition to an implementation. This study needs to be carried out in the future. A tool has been developed to support composition in the Rodin platform [18]. Some case studies have been applying composition with success, in particular for distributed systems as part of decomposition [19].

References
Mart´ın Abadi and Leslie Lamport. Composing Specifications. In J. W. de Bakker, W.-P. de Roever, and
G. Rozenberg, editors, Stepwise Refinement of Distributed Systems - Models, Formalisms, Correctness, volume 430, pages 1–41, Berlin, Germany, 1989. Springer-Verlag.
Jean-Raymond Abrial. Modeling in Event-B: System and Software Engineering. Cambridge University Press, 2010.
Jean-Raymond Abrial, Michael Butler, Stefan Hallerstede, Thai Son Hoang, Farhad Mehta, and Laurent Voisin. Rodin: An Open Toolset for Modelling and Reasoning in Event-B. International Journal on Software Tools for Technology Transfer (STTT), April 2010.
Jean-Raymond Abrial and Stefan Hallerstede. Refinement, Decomposition, and Instantiation of Discrete Models: Application to Event-B. Fundam. Inf., 77(1-2):1–28, 2007.
Fran¸coise Bellegarde, Jacques Julliand, and Olga Kouchnarenko. Synchronized Parallel Composition of Event Systems in B. In ZB ’02: Proceedings of the 2nd International Conference of B and Z Users on Formal Specification and Development in Z and B, pages 436–457, London, UK, 2002. Springer-Verlag.
Michael Butler. Stepwise Refinement of Communicating Systems. Science of Computer Programming, 27(2):139–173, September 1996.
Michael Butler. An Approach to the Design of Distributed Systems with B AMN. In Proc. 10th Int. Conf. of Z Users: The Z Formal Specification Notation (ZUM), LNCS 1212, pages 221–241, 1997.
Michael Butler and Marina Wald´en. Distributed System Development in B. Technical Report TUCS- TR-53, Turku Centre for Computer Science, 14, 1996.
Michael J. Butler. A CSP Approach to Action Systems. PhD thesis, Oxford University, 1992.
Thai Hoang and Jean-Raymond Abrial. Event-B Decomposition for Parallel Programs. Abstract State Machines, Alloy, B and Z, pages 319–333, 2010.
Charles Antony Richard Hoare. Communicating Sequential Processes. Prentice Hall International Series in Computer Science, 1985.
Daniel Jackson. Structuring Z specifications with views. ACM Trans. Softw. Eng. Methodol., 4(4):365– 389, 1995.
Cliff B. Jones. Wanted: a compositional approach to concurrency. In Programming methodology, pages 5–15. Springer-Verlag New York, Inc., New York, NY, USA, 2003.
Carroll Morgan. Of wp and CSP. In Beauty is our business: a birthday salute to Edsger W. Dijkstra, pages 319–326. Springer-Verlag New York, Inc., New York, NY, USA, 1990.
Michael Poppleton. The Composition of Event-B Models. In ABZ2008: Int. Conference on ASM, B and Z, volume 5238, pages 209–222. Springer LNCS, September 2008.
Ralph-Johan R. Back. Refinement Calculus, part II: Parallel and Reactive Programs. In REX workshop: Proceedings on Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, pages 67–93, New York, NY, USA, 1990. Springer-Verlag New York, Inc.
Ralph-Johan R. Back and R. Kurki-Suonio. Decentralization of Process Nets with Centralized Control. In PODC ’83: Proceedings of the second annual ACM symposium on Principles of distributed computing, pages 131–142, New York, NY, USA, 1983. ACM.


Renato Silva and Michael Butler. Parallel Composition Using Event-B. http://wiki.event-b.org/ index.php/Parallel_Composition_using_Event-B, July 2009. Online; accessed 27-July-2010.
Renato Silva, Carine Pascal, Thai Son Hoang, and Michael Butler. Decomposition Tool for Event-B.
Software: Practice and Experience, 41(2):199–208, February 2011.
J. Mike Spivey. The Z Notation: a Reference Manual. Prentice-Hall, Inc., 1989.
Jim Woodcock and B. Dickinson. Using VDM with Rely and Guarantee-Conditions. In Proceedings of the 2nd VDM-Europe Symposium on VDM—The Way Ahead, pages 434–458, New York, NY, USA, 1988. Springer-Verlag New York, Inc.
Pamela Zave and Michael Jackson. Conjunction as Composition. ACM Trans. Softw. Eng. Methodol., 2(4):379–411, 1993.
