Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 403–421
www.elsevier.com/locate/entcs
Stateful Runners of Effectful Computations
Tarmo Uustalu1
Institute of Cybernetics, Tallinn University of Technology, Akadeemia tee 21, 12618 Tallinn, Estonia

Abstract
What structure is required of a set so that computations in a given notion of computation can be run statefully with this set as the state set? For running nondeterministic computations statefully, a resolver structure is needed; for interactive I/O computations, a “responder-listener” structure is necessary; to be able to serve stateful computations, the set must carry the structure of a lens. We show that, in general, to be a stateful runner of computations for a monad corresponding to a Lawvere theory (defined as a set
equipped with a monad morphism between the given monad and the state monad for this set) is the same as to be a comodel of the theory, i.e., a coalgebra of the corresponding comonad. We work out a number of instances of this observation and also compare runners to handlers.
Keywords: effects, monads, Lawvere theories, comodels, state monads, handlers


Introduction
This paper is about Moggi’s monad-based and Plotkin and Power’s Lawvere theories based approaches to effectful computation [8,10].
Given a monad (T, η, μ), a computation of a value in X is an element of T X. Computations are there to compute values, so we consider it natural to wish to extract these values, to run computations. Ideally, we might want to have at our disposal a polymorphic function θ : ∀X. T X → X for extracting values from com- putations, but this is generally too much to ask (although it is possible, e.g., for writer monads).
However we can often produce a value, if we are allowed to rely on some input— think of it as an initial state—drawn from some set C with suitable structure. For example, if we have a finitely nondeterministic computation in the sense of a binary wellfounded leaf tree, a bitstream can be used to identify a leaf. As running should reasonably be compositional in the sense that running the sequence of two computations should be the same as composing two runs, a run should not only

1 tarmo@cs.ioc.ee

http://dx.doi.org/10.1016/j.entcs.2015.12.024
1571-0661/© 2015 The Author. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

depend on an initial state, but also return a final state (that can serve as the initial state for another run). In the case of nondeterminism and bitstreams, the final state could be the remainder of the bitstream provided as the initial state. So in general we might want to look for a polymorphic function θ : ∀X. T X → TC X where (TC, ηC, μC) is the state monad for C as the state set. The compositionality we want amounts to θ being not just a natural transformation, but a monad morphism. In this paper, we answer the question of when a set C can be used to run computations in a monad (T, η, μ) statefully, assuming that the monad corresponds to a Lawvere theory. The answer is: C has to carry a comodel of the Lawvere theory (i.e., a coalgebra of the corresponding comonad). We spell out a number of instances of this generality, for nondeterminism, interactive I/O and stateful computations. This is an easy exercise, but the results are quite instructive, we find. For some versions of nondeterminism, for instance, runners can only recover a part of the information in a given computation; other versions of nondeterminism admit only trivial runners that reveal nothing about the computation. So some variations of
nondeterminism are inherently more operational than others.
Runners are somewhat similar to handlers, but one bigger difference is that runners are polymorphic in the value set. For example, handling allows one to extract a value from a nondeterministic computation (a binary wellfounded leaf tree) over a specific value set that carries a binary operation by folding this operation over the leaf labels. (If for us a nondeterministic computation is a nonempty list of values, this operation must be associative.) Running does not allow such things. In our view, the pragmatics of handlers and runners are different: handlers are a programming language construct, but runners are compilation schemes.
The paper is organized as follows. In Section 2, we review the few basic facts about Lawvere theories, models and comodels that we need. In Section 3, we show that stateful runners for a monad corresponding to a Lawvere theory are in a bijection with comodels of the theory (coalgebras of the corresponding comonad). We also compare this observation to a fact about monad morphisms to continuation monads—a different type of runners. In Section 4, we work out the instances for nondeterminism, interactive I/O and stateful computation. Just before concluding, in Section 5, we compare runners to handlers.

Lawvere theories, models, comodels
We begin by reviewing the most basic definitions and facts about finitary Lawvere theories and models (for a proper exposition, see, e.g., [6]) as well as Power’s comod- els [13,11]. Countable Lawvere theories and κ-ary Lawvere theories for a regular cardinal κ are defined analogously.

Lawvere theories
A (ﬁnitary) Lawvere theory is given by a small category L with finite products and a functor L : Fop → L that is identity on objects and strictly preserves the finite products of Fop.

Here F is the category of finite cardinals, i.e., the skeleton of the category of finite sets. It is a strict monoidal category wrt. finite coproducts, in fact it is the free such category on the one-object category.
A theory can (non-uniquely) be specified by a presentation, i.e., by some subset of the maps opj : Ij → Oj of L (operations) from which all other maps are definable together with some subset of the commuting diagrams lhsk = rhsk of L (equations) from which all other commuting diagrams follow.
Notice that one can always do with operations of arities I → 1 only. As O =
`	1, any operation op : I → O can be replaced with O many operations opo :
o∈O
I → 1 via opo = ino ◦ op and op = (`	opo) ◦ ∇. 2 )
o∈O
Models
A model of a theory (L, L) is given by a functor J−) : L → Set that preserves the finite products of L (non-strictly).
To give a model of (L, L), it suffices to specify a set
A = J1)
since, for any other object Y , we have JY ) = J`	1) ∼=	J1) = J1) ⇐ Y 3
together with functions
opj = Λ−1 Jopj) : Oj × (J1) ⇐ Ij) → J1)

since, for any other map f , Jf ) is then uniquely determined by functoriality and preservation of finite products. Moreover, any set A with functions opj : Oj × (A ⇐ Ij) → A defines a model, provided that the equations lhsk = rhsk hold for the derived functions lhsk, rhsk.
Theories and monads
A theory defines a unique monad whose algebras are essentially the same as its models.
The monad corresponding to a theory (L, L) is a quotient of a free monad. The underlying functor is
T X = T0 X/∼∗
where T0 X is the set defined inductively by


	x : X	
var x : T0 X
o : Oj	f : T0 X ⇐ Ij


opj (o, f ): T0 X

(so that, in a more compact notation, T0 X = μZ. X + ` Oj × (Z ⇐ Ij)) and ∼X

2 We write maps of L in terms of the operations of the presentation, maps of F, the product bifunctor of L, which we denote + (sic!) to agree with the notation for the coproducts of F, and composition of L. Note that maps of F have their directions reversed in L, so ino :1 → O in F, but ino : O → 1 in L etc.
3 To avoid the need to explicitly use the symmetry of × in the examples, we will use two exponential functors ⇐ and ⇒; think of −⇐ Y as the right adjoint of Y ×− and Y ⇒− as the right adjoint of −× Y .

is a binary relation on T0 X defined inductively by
∀i : Ii.f i ∼X fj i
opj (o, f ) ∼X opj (o, fj)	lhsk (o, f ) ∼X rhsk (o, f )
The unit η is var and the multiplication μ is defined recursively by μ (var t)= t and
μ (opj (o, f )) = opj (o, λi. μ (f i)).
Algebras of (T, η, μ) are essentially the same as models. A model (A, (opj : Oj × (A ⇐ Ij) → A)j) and an algebra (A, α : T A → A) are interdefinable recur- sively by α (var x) = x and α (opj (o, f )) = opj (o, λi. α (f i)) and by opj (o, f ) = α (opj (o, λi. var (f i))).
The monad corresponding to a theory is finitary. And any monad corresponds to at most one theory in this fashion.
Comodels
We are now prepared to discuss Power’s notion of comodels.
A comodel of a theory (L,L : Fop → L) is given by a functor ⟨⟨− ⟩ : Lop → Set that preserves the finite coproducts of Lop (recall that a model was a functor from L preserving its finite products).
To give a comodel, it suffices to specify a set
C = ⟨⟨1⟩⟩
since ⟨⟨X⟩⟩ = ⟨⟨`	1⟩⟩ ∼= `	⟨⟨1⟩⟩ = ⟨⟨1⟩⟩ × X, together with functions
opj = ⟨⟨opj⟩⟩ : ⟨⟨1⟩⟩ × Oj → ⟨⟨1⟩⟩ × Ij
where we often split opj as ⟨opnj, opsj⟩ (with n and s mnemonic for “next” and “show”). Also, any set C with functions opj : C × Oj → C × Ij defines a comodel, provided that the equations lhsk = rhsk hold for the derived functions lhsk, rhsk.
Theories and comonads
Besides defining a (finitary) monad whose algebras are the same as models, a theory also defines a comonad with the property that comodels of the theory are the same as coalgebras of the comonad.
The comonad corresponding to a theory (L, L) is a subcomonad of a cofree comonad. The underlying functor is defined by
DX = D0 X | ok X
where D0 X is a set defined coinductively by 4

d : D0 X
var d : X
d : D0 X	o : Oj
opnj (d, o): D0 X
d : D0 X	o : Oj
opsj (d, o): Ij



4 We write coinductive definitions in a destructor-based fashion (as opposed to the constructor-based style commonly used in proof assistants), as this works more smoothly.

(so that, in a more compact notation, D0 X ∼= νZ. X ×   (Oj ⇒ Z × Ij)) and ok X
is a predicate on D0 X defined coinductively by


	ok X d	
ok X (opnj (d, o))
	ok X d	
lhsnk(d, o)= rhsnk(d, o)
	ok X d	
lhssk(d, o)= rhssk(d, o)

The counit ε is var. The comultiplication δ is defined corecursively by var (δ d)= d,
opnj (δ d, o)= δ (opnj (d, o)), opsj (δ d, o)= opsj (d, o).
A comodel (C, opj : C ×Oj → C ×Ij)j) is interdefinable with a coalgebra (C, γ : C → D C) corecursively by var (γ c)= c, opnj (γ c, o)= γ (opnj (c, o)), opsj (γ c, o)= opsj (c, o), and by opnj (c, o)= var (opnj (γ c, o)), opsj (c, o)= opsj (γ c, o).
The comonad corresponding to a theory in the above fashion is in general non- finitary. Also, one comonad can correspond to many theories. (E.g., all theories with at least one nullary operation (op : 0 → O with O /= 0) have the initial comonad (DX = 0) as the corresponding comonad.)

Stateful runners = comodels
We are prepared to prove the theorem that this paper revolves around. We prove that a stateful runner is the same as a comodel.
Proposition 3.1 Given a Lawvere theory (L, L), let (T, η, μ) be the monad corre- sponding to the theory. Given a set C, let (TC, ηC, μC) be the state monad for C. There is a bijection between monad morphisms from (T, η, μ) to (TC, ηC, μC) and comodels on C (i.e., coalgebras of the comonad (D, ε, δ) corresponding to (L, L)).
Proof. Let the Lawvere theory (L, L) be given by operations opj : Ij → Oj and equations lhsk = rhsk. The corresponding monad (T, η, μ) is then constructed as described in the previous section.
Given a comodel (opj : C ×Oj → C ×Ij)j, the monad morphism θ : ∀X. T X →
(C × X) ⇐ C is defined by recursion on t : T0 X by

θX (var x) = λc. (c, x)
θX (opj (o, f )) = λc. θX (f (opsj (c, o)) (opnj (c, o))
For this definition to be legitimate, θX must send ∼X -related computations in T0 X to equal computations in TC X. This is proved by induction on the proof of t ∼X tj from lhsnk = rhsnk and lhssk = rhssk.
The unit preservation law of a monad morphism holds trivially. The multipli- cation preservation law is a “substitution lemma” that is proved by induction on t : T0 (T0 X).
In the converse direction, given a monad morphism θ, we define the comodel (opj )j by
opj (c, o)= θIj (opj (o, λi. var i)) c


			
The equations lhsnk = rhsnk and lhssk = rhssk follow from θX sending ∼X -related computations in T0 X to equal computations in TC X.
The roundtrip from a comodel to a monad morphism and back is straightfor- wardly identity. The other roundtrip is identity thanks to naturality of θ.	2
We compare this theorem to the following well known theorem (see, e.g., [5]) about running with continuations.
Proposition 3.2 Given a monad (T, η, μ) and a set A. Let (TA, ηA, μA) be the continuation monad for A. Monad morphisms θ from (T, η, μ) to (TA, ηA, μA) are in a bijection with (T, η, μ)-algebra structures α on A.
Proof. Given an algebra structure α : T A → A, the monad morphism θ : ∀X. T X → (A ⇐ X) ⇒ A is defined by θX t = λf. α (T f t); the laws of a monad morphism follow from the laws of an algebra.
In the converse direction, given a monad morphism θ, the corresponding algebra structure α is defined by αt = θA t idA; the laws of an algebra follow from the laws of a monad morphism.
The roundtrip from an algebra to a monad morphism and back is straight- forwardly identity. The proof of the other roundtrip being identity relies on the naturality of θ.	2

Notice that in the first theorem we use a Lawvere theory to relate a monad and a comonad (however the Lawvere theory is determined by the monad). The second theorem can be stated without referring to a Lawvere theory.
A more important difference is this. Given any monad, for any value set X, one can find a runner with continuations (A, θ) such that θX is mono, i.e., all information about a computation over a given value set X in the given monad is retained in its counterpart in the continuation monad. Indeed, for any X, invoking the free algebra (T X, μX ), we have θX t ηX = t.
In the case of stateful running, it is much more difficult to achieve θX being mono. As we will see shortly, it is easy to construct examples where no state set C is sufficient to recover computations over a given value set X.
Both theorems can be strengthened to isomorphisms of categories; we skip the details here.


Instances
Nondeterminism
Let us see the above proposition at work on the example of various finite nondeter- minism monads as well as the partiality monad.

Finite nondeterminism
First we consider theories given by the following operation and some of the following equations:


1+1 
ch
(1 + 1) + 1
ch +1
1+ (1+ 1)
1+ch 1 +¸1 
ch
1+1 
σ+
1+1 
ch
1
∇ 1 +¸1 
ch

	 	ch	 ¸ 
z1	 

A model of each such theory is given by a set A carrying the following function and satisfying the correct equations from among the following:


A × A
(A × A) × A	 A ¸× (A × A) A×ch A ¸× A
A × A σ× A ¸× A
A  Δ A ¸× A

	ch×A
  
  	  

A	A × A	ch	 A ¸
zA	A

We see that models of these theories are exactly what we expect: without any equa- tions we get magmas, with (c) semigroups, with (c), (d) commutative semigroups, with (c), (d), (e) semilattices, with (d) alone commutative magmas.
The corresponding monads are those of binary leaf trees (free magmas, T X ∼= μZ. X + Z × Z), nonempty lists (free semigroups), nonempty finite multisets (free commutative semigroups), nonempty finite sets (free semilattices), binary unordered leaf trees (free commutative magmas). All of them are quotients of the first monad. They all model nondeterminism to some level of granularity; which monad to use depends on what exactly one wants to track as the nondeterminism effect (and in fact on whether one wants to be able to resolve nondeterminism, as we will see shortly). The theory view of these monads tells us that the single operation ch is complete for programming finitely nondeterministic functions.
A comodel (a runner for nondeterministic computations) is a set C with the following function satisfying the intended equations from among the following:



C +,C, (c) (C + C,) +,C ¸,C + (C + C)

C¸+,ch
+
C +,C, (d) C + C,¸ C +,C, (e) C
¸∇,

ch	ch +C	ch	ch
C	C + C ¸,	ch	 C	ch	C	C

Reformulating minimally, a comodel is a set C with a function ch = ⟨chn, chs⟩ : C → C × 2 satisfying the appropriate equations. For the theory without equations, it is nothing but a resolver (scheduler) for the finest notion of nondeterminism that remembers the order that binary choices are made, the order of options in binary choices etc. It is a machine that can make a binary choice on request and go to a new state. Given a nondeterministic computation, which is binary leaf-labelled tree in this case, it can thus choose a path from the root to some leaf.
Equation (e) forces that chn x = x. Equation (c) requires chs (chn x) = chs x and chn (chn x)= chn x, which are trivially fulfilled when chn is identity. So a re- solver for the version of nondeterminism where order of binary choices is considered irrelevant and a binary choice between two equal options is considered the same as no choice at all (so computations are nonempty square-free lists of values, i.e., lists

with no sublist occurring twice in a row) amounts to a set C with an unconstrained function chs : C → 2, This is a machine that always makes its choice without changing its state, so, given a leaf tree (identified with other leaf trees that flatten into the same nonempty list), it walks down from the root by always turning to the left or always turning to the right, eventually reaching the leftmost or rightmost leaf (the first or last position of the list). Note that the other leaves (inner positions of the list) are unreachable for a runner—they are not addressable “crisply” enough. 5 In a comodel for any theory containing equation (d), it must be that not (chs x)= chs x, which can only hold when C ∼= 0. This says that, as soon as the order of the options in a choice is considered immaterial, resolving nondeterminism is impossible,
apart from the uninteresting degenerate case.
The comonad for the equationless theory is that of streams of states and bits, DX ∼= νZ. X × (2 ×Z). The comonads for more specific theories are subcomonads. In particular, the comonad for the theory with (c) alone has DX ∼= X × (2 × X), the theory with both (c) and (e) has DX ∼= X × 2. The comonads for theories containing (d) have DX ∼= 0.
Finite nondeterminism with failure
Let us consider extending the theories considered with the following operation and, possibly, the following equations:


0
die
1
(a)	0+1 
die+
(b)
1+die
1+0	1 + 1 


A model is now a set A supporting the following function satisfying the intended equations from among following:


1	(a)	1 × A
(b) A × 1A×die A ¸× A

die
A
die×A	ch
A × A	A	A


Models are pointed magmas, monoids, commutative semilattices with a bottom, commutative pointed magmas. The monads are the monad of nullary-binary leaf trees (free pointed magmas, T X ∼= μZ. X +1+ Z ×Z) and its different quotients— the monads of lists (free monoids), finite multisets (free commutative monoids), finite sets (free commutative semilattices with bottom), nullary-binary unordered leaf trees (free pointed commutative magmas). They all model notions of nondeter- minism where also “no-option” choices are allowed.
A comodel isa set C with the following function satisfying the intended ones of

5 These two elements of T 3 are equal: t0 = ch (ch (var 0, var 1), var 2) and t1 = ch (var 0, ch (var 1, var 2)).

But t0	=	μ t′
and t1	=	μ  t′
for t′
=	ch (var(ch (var 0, var 1)), var (var 2)) and t′	=

ch (var (var 0), var (ch (var 1, var 2))) in T (T 3). Both t′
and t′
are of the form ch (var(.. .), var (.. .)). A

runner that is able to extract from t0 the value 1, must process t′ by first going to the left, but then it must do the same to t′ in which case it cannot extract the value 1 from t1, which was equal to t0.

the following equations:
0,, (a)  0 +,C,,¸	(b)




C¸+d,ieC + C


die
C

die+C
C + C ¸ch,C
C + 0,¸	,,
ch
C

It is immediate that there are no interesting comodels: the carrier of a comodel must be empty even in the case of no equations. The comonads are all constant 0 (DX ~= 0). It is impossible (except for the uninteresting degenerate case of an impossible initial state) to resolve a nondeterministic computation that may fail.
Observe that the same happens with any theory with one or more nullary op- erations (op :0 → O where O /= 0) or, in terms of monads, with any monad such that T 0 /= 0.
Partiality
Finally we could also skip ch and consider the theory with just die and no equations. Models of this theory are pointed sets. The monad is the maybe monad (of sets with an added point, free pointed sets, T X ~= 1+ X), commonly used for modelling partiality. We learn the unsurprising fact that die is the sole operation needed for programming partial functions. We know already that there are no interesting
comodels.
Interactive input/output
We move on to consider examples of other types. For the start, take two sets I, O, and consider the very simple theory with the following two operations and no equations:
I	1
get	put
       
A model is a set A endowed with functions

A ⇐ I
get
A

A
put
A ⇐ O

The monad is the free monad defined by T X = μZ. X + (Z ⇐ I)+ O × Z. We recognize in it the monad for interactive input/output with I and O as the input and output alphabets.
A comodel is a set C with two functions
C ×,I,	C,,
get	put
C	C × O
It is a runner for interactive input/output, a machine that can provide input and consume output, changing its state. The comonad is the cofree comonad defined by DX = νZ. X × (Z × I) × (O ⇒ Z).

The case of interactive input only is covered by the special case O =0 when we could just as well drop the operation put as forced and void of information.
Allowing interactive output only corresponds to dropping the get operation. This is different from the case I = 0 (input from an empty alphabet, leads to partiality), as well as from the case I = 1 (input from a singleton alphabet). But via P = O∗ (the free monoid on O) it is an instance of writing considered in the next section.
Stateful computation
We proceed to stateful computation. We first look at reading only and writing only, to then continue with reading and overwriting (modelled by state monads). We finish by analyzing reading and general updating (modelled by what we call update monads).
Reading
We begin with reading. Take a set S (of states). We look at this theory:

S	1   !	 S ¸	S × S 	Δ	 S ¸

lkp
1
lkp
1
lkp×S
lkp
 lkp  ¸ 

A model is a set A with


A ⇐ S
lkp
A ⇐ 1  A⇐!  A ¸⇐ S
lkp
A ⇐ S × S 	A⇐Δ	 A ¸⇐ S
lkp

	z ˛ 
  
(A ⇐ S) ⇐ S
lkp⇐S A ¸⇐ S
lkp	 ¸ 

By the general construction, the monad for this theory is given by T X =

T0 X/~∗
with T0 X and ~X defined inductively by



  x : X	
var x : T0 X

(so that T0 X ~= μZ. X + (Z ⇐ S)) and
f : T0 X ⇐ S


lkp f : T0 X


∀s. f s ∼X f′ s
lkp f ∼X lkp f′ c ∼X lkp (λs. c) lkp (λs′. lkp (λs. f s s′)) ∼X lkp (λs. f s s)
It is easy to verify that every element of T X can be presented in the normal form lkp (λs. var (f s)) for a unique f : X ⇐ S. It follows that the monad can alternatively be defined without quotienting by T X = X ⇐ S and ηx = λs. x, μf = λs. f s s. This is the reader monad for S as the state set.
A comodel is a set C with


C ×,S, C × 1
lkp
C×!
×,S,
lkp
C × (S,×,S) ¸,
C×Δ
C ×,S,
lkp


	
C	C	(C × S) × S ¸lkp,×S C × S ¸,lkp	C

or equivalently with
C,, S,,	C , ¸

lkpn
C
lkps
C	C
lkpn
lkpn
lkps
C



In the latter description, the 1st equation explicitly asks that lkpn = idC, making lkpn redundant, and the 2nd and 3rd follow, so we are left with a function lkps : C → S and no equations. A runner for reading amounts thus to a machine that is happy to serve a lookup request with an external state (drawn from set S) and continue then in the same internal state (from set C)—so next time it will provide the same external state again.
It follows that the comonad can be defined by DX = X × S and ε (x, s) = x,
δ (x, s)= ((x, s), s). This is the cofree comonad on the constant S functor.
Writing
For writing, we take a monoid (P, o, ⊕) (of updates) and consider the following theory:
1	1  upd  P ¸	1 	upd	 P ¸
upd	o	upd	⊕

  	  
  
P	1 × P
 upd×P	 
P × P

A model of this theory is a set A with

upd	 ¸
A	A	A ⇐ P

upd

upd


  upd⇐P ¸
A⇐⊕
 ¸ 


or, alternatively, in uncurried form,


P × A
upd
1 × A o×A P ¸× A
upd
(P × P ) × A	⊕×A	 P ¸× A
upd

	v ˛ 
  
P × (P × A)
P ×upd P ¸× A
upd	 ¸ 

which is exactly what it means to be a left action of (P, o, ⊕).
The general construction tells us that the corresponding monad is given by

T X = T0 X/~∗
where T0 X and ~X are defined inductively by



  x : X	
var x : T0 X
p : P  c : T0 X


upd (p, c): T0 X

(so that T0X = μZ. X + P × Z) and
c ∼X c′
upd (p, c) ∼X upd (p, c′) c ∼X upd (o, c) upd (p, upd (p′, c)) ∼X upd(p ⊕ p′, c)

We can witness that every element of T X can be cast in the form upd (p, var x) for a unique pair (p, x): P ×X. As a consequence, the monad is alternatively definable

by T X = P × X and ηx = (o, x), μ (p, (pj, x)) = (p ⊕ pj, x). This is the familiar writer monad for (P, o, ⊕) as the monoid of updates.
A comodel for the theory of writing (a runner for writing computations) is a set
C with

	

C,,
upd
,	C,¸,,
×o
upd
C ×,P,
C×⊕

C × P
C × 1

C × P ¸upd,×P (C × P ) × P ¸,  C × (P × P )

i.e., a right action of the monoid. We think of it as a machine that listens to updates and changes its state.
The comonad is constructed by taking DX = D0 X | ok X where D0 X and ok X
are defined coinductively by


c : D0 X
var c : X
c : D0 X  p : P


upd (c, p): D0 X

(so that D0 X = νZ. X × (P ⇒ Z)) and


	ok X c	

ok X (upd (c, p))
	ok X c	 c = upd (c, o)
	ok X c	

upd (upd (c, p), p′)= upd (c, p ⊕ p′)

Here it is the case that everything that can be learned at all about an element [ ] of DX (i.e., an ok element of D0 X) is summarized in the function λp. var (upd ([ ], p)) : P ⇒ X. It is a universal way of observing elements of DX in the sense that, for any set Y , any function f : DX → Y is expressible as λc. g (λp. var (upd (c, p))) for a unique g : (P ⇒ X) → Y . Therefore, the comonad is more succinctly (without carving a subset) defined by DX = P ⇒ X, εv = v o, δv = λp. λpj.v (p ⊕ pj).
Reading and overwriting
We can now proceed reading and overwriting a state.
Given a set S (of states), the theory of reading and overwriting is given by two operations lkp and upd


S	1	1  upd  S ¸
1 	upd	 S ¸
S   lkp	 1  ¸upd	 S,¸,

lkp
upd
lkp	upd
   
snd

1	S	1
S	 1 ×¸S upd×S S ×¸S
1 × S	upd×S	 S ×¸S

A model is a set A with functions lkp and upd such that

A ⇐ S
A
A	upd	 A ¸⇐ S

lkp
upd
upd
  	
A⇐snd

A	A ⇐ S
A	A ⇐ S upd⇐S (A¸⇐ S) ⇐ S	 A ¸⇐ S × S

A ⇐ S 	lkp	 A ¸upd	 A ¸⇐,S,

upd⇐S
	 ¸
A⇐Δ

or, alternatively, in uncurried form,


A ⇐ S
lkp
S × A
upd
(S × A) ⇐ S  upd⇐S A ¸⇐ S
,,
lkp
(S × S) × A 	snd×A	 S ×¸A
upd

A	A	A
    S×upd  ¸
upd	 ¸ 



S × (A ⇐ S) 	S×lkp	 S ×¸A 	upd	 A,¸,

Δ×(A⇐S)
	 ¸
upd
	 ¸

The corresponding monad is T X = T0 X/~∗
where T0 X and ~X are defined

inductively by

  x : X	
var x : T0 X

f : T0 X ⇐ S


lkp f : T0 X

s : S  c : T0 X

upd (s, c): T0 X

(so that T0 X = μZ. X + (Z ⇐ S)+ S × Z) and


∀s. f s ∼X f′ s


lkp f ∼X lkp f′
c ∼X c′


upd (s, c) ∼X upd (s, c′)


  
c ∼X lkp (λs. upd (s, c)) upd (s, upd (s′, c)) ∼X upd (s′, c) upd (s, lkp f ) ∼X upd (s, f s)

As every element of T X can be uniquely presented in the normal form lkp (λs. upd (g s, var (h s)) for some ⟨g, h⟩ : (S × X) ⇐ S, we have that T X ~= (S × X) ⇐ S whereby ηx = λs. (s, x), μf = λs. let (sj, g) → f s in g sj —the state monad for S.
A comodel is a set C together with functions lkp and upd such that

	

C ×,S,	C,, C ¸up,d
C ×,S,	C,¸,,
upd
C ×,S,

lkp
upd
lkp
upd
C×snd

C	C × S
C	C × S ¸upd,×S (C × S) × S ¸,  C × (S × S)


	

C ×,S,¸,lkp	C ¸,upd
upd×S
C × S
C×Δ

(C × S) × S ¸,	
or, splitting lkp = ⟨lkpn, lkps⟩,
  
C × (S × S)


	

C,, S,, C,,C ¸up,d
C ×,S,	C,¸,,

upd
C ×,S,

lkpn
lkps
upd
(lkpn,lkps⟩
upd
C×snd

C	C	C × S
C	C × S ¸upd,×S (C × S) × S ¸,  C × (S × S)


			

C ¸lk,pn
C ¸up,d

upd
C × S
S ,¸lk¸,ps
C ¸up,d

snd
C × S


	
Here the 1st and 3rd equation together give that lkpn = idC making lkpn redundant. The 1st equation then simplifies to upd ◦ ⟨idC, lkps⟩ = idC and the 3rd equation becomes tautological. We see that a runner for a stateful computation is a machine

responding to lookups (without changing its state) and listening to overwrites. 6 This structure is known in bidirectional transformations [4] as a lens 7 between C and S. 8
The comonad is DX = D0 X | ok X where D0 X and ok X are defined coinduc- tively by

c : D0 X
var c : X
c : D0 X

lkps c : S
 c : D0 X  s : S

upd (c, s): D0 X

(so that D0 X = νZ. X × S × (S ⇒ Z)) and


	ok X c	

ok X (upd (c, s))
	ok X c	 c = upd (c, lkps c)
	ok X c	

upd (upd (c, s), s′)= upd (c, s′)
	ok X c	

lkps (upd (c, s)) = s

All that can be known about an element [ ] of DX can be summarized in the universal observation (lkps [ ], λs. var (upd ([ ], s)) : S×(S ⇒ X). Hence the comonad can also be defined by DX = S × (S ⇒ X) and ε (s, v) = vs and δ (s, v) = (s, λsj. (sj, v)). This comonad is known as the costate (or array) comonad [13,9].
Reading and general writing
Let us also consider reading and general writing (as opposed to just overwriting) in combination.
Given a set S (of states), a monoid (P, o, ⊕) (of updates) and a right action
↓ : S ×P → S (describing application of updates to states), we are interested in the theory given by the following operations and equations: 9

S	1   !	 S ¸	S × S 	Δ	 S ¸

lkp
1
lkp
1
lkp×S
lkp
 	 ¸lkp  ¸ 


1	1  upd  P ¸	1 	upd	 P ¸
upd	o	upd	⊕

  	  	  
P
 1 ×¸P
 upd×P	 
P × P

S 	lkp	 1  ¸upd	 P ¸	 1 ×¸,P,
lkp×P
   upd×S ¸ 	(snd,↓⟩	 ¸
A model a set A with functions lkp and upd such that


A ⇐ S
lkp
A ⇐ 1  A⇐!  A ¸⇐ S
lkp
A ⇐ S × S 	A⇐Δ	 S ⇒¸A
lkp

	z ˛ 
  
(A ⇐ S) ⇐ S
lkp⇐S A ¸⇐ S
lkp	 ¸ 



6 The computation has S as its state set; the runner’s state set is C. The final comodel has C = S,
lkps = idS and upd = snd, but it is not the only comodel. It is the case however that, for any comodel, C ∼= S × C′ for some set C′. The C′ projection of the runner’s state cannot be looked up, cannot be overwritten by computations.
7 More precisely, the bidirectional transformations term would be ’very well-behaved lens’, but from our perspective the weaker (less well behaved) structures do not deserve the name ’lens’.
8 In that context, S is called the view state set and C the source state set.
9 This is not the minimal presentation, but the simplest one. The minimal one has the same operations, but three (more involved) equations.

upd	 ¸
A	A	A ⇐ P

upd



upd




  upd⇐P ¸
A⇐⊕
 ¸ 

A ⇐ S 	lkp	 A ¸ upd⇐S
upd	 A ¸⇐,P,
lkp⇐P

	 ¸
A⇐(snd,↓ ⟩ ¸
	 ¸

where upd and the equations involving it can also be written in uncurried form.

The monad is T X = T0 X/~∗
where T0 X and ~X are defined inductively by



  x : X	
var x : T0 X
f : T0 X ⇐ S


lkp f : T0 X
p : P  c : T0 X


upd (p, c): T0 X

(so that T0 X ~= μZ. X + (Z ⇐ S)+ P × Z) and

∀s. f s ∼X f′ s


lkp f ∼X lkp f′

c ∼X c′

  
upd (p, c) ∼X upd (p, c′) c ∼X lkp (λs. c) lkp (λs′. lkp (λs. f s s′)) ∼X lkp (λs. f s s)


  
c ∼X upd (o, c) upd (p, upd (p′, c)) ∼X upd (p ⊕ p′, c) upd (p, lkp f ) ∼X lkp (λs. upd (p, f (s ↓ p)))
Since the equations allow us to present any element of T X uniquely in the normal form lkp (λs. upd (g s, var (h s))) for some ⟨g, h⟩ : (P × X) ⇐ S, we get that T X ~= (P × X) ⇐ S whereby
ηX x = λs. (o, x)
μX f = λs. let (p, g) → f s; (p′, x) → g (s ↓ p) in (p ⊕ p′, x)
We have called this monad the update monad for S, (P, o, ⊕), ↓ [2]. Update monads are exactly the compatible compositions of reader and writer monads—distributive laws between them are in bijections with right actions.
A comodel is a set C with functions lkp and upd such that


C ×,S, C × 1 ¸C,×!
S ×,C, C × (S,×,S) ¸,
C×Δ



lkp
C
lkp

	
C	(C × S) × S ¸lkp,×S C × S ¸,lkp	C


	

C,, C ¸up,d
C ×,P,	C,¸,,
upd
C ×,P,

upd
C×o
upd
C×⊕

C × P
C × 1
C × P ¸upd,×P (C × P ) × P ¸,  C × (P × P )

C ×,S,¸, lkp upd×S
C ¸,


upd

C × P

(C × P ) × S ¸,  C × (P × S) ¸(snd,,↓⟩ C × (S × P ) ¸, 
(C × S) × P

Splitting lkp = ⟨lkpn, lkps⟩, we see that the 1st equation just says lkpn = idC, making lkpn redundant. This makes the 2nd equation tautological and simplifies the 5th to


S ¸lk,ps

S ¸,

C ¸up,d

↓
C × P

S × P

We have previously christened these structures update lenses [1], they are a refinement of state-based lenses. An update lens is a machine that responds to lookups (without changing its state) and listens to updates.
The corresponding comonad is DX = D0 X | ok X where D0 X and ok X are defined coinductively by


c : D0 X
var c : X
c : D0 X

lkps c : S
c : D0 X  p : P


upd (c, p): D0 X

(so that D0 X = νZ. X × S × (P ⇒ Z)) and


	ok X c	

ok X (upd (c, p))
	ok X c	 c = upd (c, o)
	ok X c	

upd (upd (c, p), p′)= upd (c, p ⊕ p′)
	ok X c	

lkps (upd (c, p)) = lkps c ↓ p

All information available about an element [ ] of DX is captured in the universal observation (lkps [ ], λp. var (upd ([ ], p))) : S × (P ⇒ X), which tells us that DX ~=
S × (P ⇒ X) (the coupdate comonad) whereby
εX (s, v)= v o
δX (s, v)= (s, λp. (s ↓ p, v (p ⊕ p′)))

Continuations
Continuation monads have no rank, so our analysis in terms of Lawvere theories does not apply. However it it is easy to check directly that they cannot have non-trivial runners (i.e., runners with a non-empty carrier).
Indeed, fix a nonempty set R. A runner structure on a set C would be a monad morphism between the continuation monad for R and the state monad for C, so a family of maps θ : ∀X. (R ⇐ X) ⇒ R → (C × X) ⇐ C. Consider θ0. The set (0 ⇒ R) ⇒ R is obviously inhabited (for any element r of R, it contains λf. r), but for the set (C × 0) ⇐ C to be inhabited we need a function C → 0, which can only exist if C = 0.
Running vs. handling
Runners bear some similarity to Plotkin and Pretnar’s handlers [12], but they are not the same. Let us spell out the exact relationship.
Broadly speaking, both are about specifying ways to extract a value from a computation.
Handling is based on the fact that, for any set A, (T A, μA : T (T A) → T A) is the free (T, η, μ)-algebra on A, with ηA : A → T A as the associated injection.
Spelled out, this means that, given two sets A, B, a map f : A → B and a (T, η, μ)-algebra structure g : T B → B, we havea unique map h : T A → B making the diagrams

A   ηA  T A¸¸,μA

z ¸ ,g
T (T A)
  

commute.
Running, at the same time, is based on the observation that any coalgebra (C, g : C → D C) of a suitable comonad (D, ε, δ) induces a unique monad morphism between the given monad (T, η, μ) and the state monad (TC, ηC, μC). This is to say that we have a unique natural transformation θ satisfying


X   ηX  T X¸¸,
z   μC 
μX
T (T X)
T θX
θ C

T C X ¸,X T C (T C X) ¸T ,X  T (T C X)
X

The important differences are these. First, handlers are monomorphic and any codomain is possible: a handler defines map from T A to B for some fixed sets A,
B. Runners are polymorphic, but the codomain is restricted to a specific form: a runner gives a family of functions from T X to TC X for a fixed set C. Second, the data inducing handlers and runners are different.
Runners are an instance of handlers, but not in a very useful way: as a circular unique existence property rather than a direct one. Indeed, in the diagram above
we have rendered the pentagon stating the condition that θX sends μX to μC in
a layout suggesting that the composite map ξX = μC ◦ θT CX might be a (T, η, μ)- algebra structure on TC X, and it is easily verified to be so. But ξX is defined in terms of θT C X , i.e., another component of θ. So we cannot say that the algebra morphism θX is induced by an independently given algebra structure ξX .
Modulo this reservation, due to their polymorphic nature, runners are actu- ally more than just handlers, they are uniform handlers. A general definition of a uniform handler proceeds from natural transformations as monad algebra struc- tures. Say that a set functor F with a natural transformation σ : T · F → F is a (T, η, μ)-algebra (or a left module), if it also meets the conditions

F X	T (T (F X)) T σX  T (¸F X)

ηF X 
   σX	 ¸
μF X 
σX
σX	 ¸ 


It is now easy to check that the free (T, η, μ)-algebra on F is (T · F, μ · F : T · T · F → T · F ), with η · F : F → T · F as the associating injection. Accordingly, for any functor G, a natural transformation φ : F → G and a (T, η, μ)-algebra structure ψ : T · G → G, we have a unique natural transformation χ : T · F → G such that
F X   ηF X  T (¸F X) ¸μ,F X T (T (F X))

χX
v ˛¸ ,ψX
T χX
  

GX	T (GX)
A runner θ is now a uniform handler for F = Id, G = TC, φ = ηC, ψ = μC ◦ (θ · TC). All of these considerations apply of course to any monad morphism from (T, η, μ), e.g., the morphism to the continuation monad on the the carrier of a (T, η, μ)-algebra
discussed in Section 3—a monad morphism is always a monad algebra morphism.

Conclusion and future work
We showed when a computation in a given monad can be mapped into a stateful computation: it is when the state set carries a comodel of the corresponding Lawvere theory (a coalgebra of a suitable comonad). We find this to be a nice small new application of comodels (cf. the discussion by Behrisch et al. [3] on whether comodels are the “correct” dual of models). We also believe that it gives some new insight into the mechanics of different monadic/algebraic notions of effects, especially in regard to the impact the degree of abstractness (i.e., how much detail of effects we want to observe). For nondeterminism, for example, we saw that some approaches that make perfect sense for denotational semantics are not operational at all and there are simple mathematical reasons why this has to be so. We find it curious that state monads turn out to have a special role in connecting models and and comodels. Something similar appears in Møgelberg and Staton’s work [7] on every monad being a linear state monad (under a certain viewpoint).
In future work, we intend to study sufficient conditions for a monad morphism to a state monad to be mono (so the stateful computation can capture all information in a given computation). We also plan to consider other target monads, in particular, combinations of state monads with other monads such as exception monads, and to relate this work and Plotkin and Power’s [11] tensor of a comodel and a model.
Acknowledgment
I am most grateful to Gordon Plotkin, Alex Simpson, Tom Schrijvers and Nicolas Wu for the comments they made in response to my talks on this material as well as to the MFPS reviewers for their feedback. This research was supported by the ERDF funded projects EXCS and Coinduction, the Estonian Ministry of Education and Research institutional research grant no. IUT33-13 and the Estonian Science Foundation grant no. 9475.

References
Ahman, D. and T. Uustalu, Coalgebraic update lenses, in: B. Jacobs, A. Silva, and S. Staton, eds., “Proc. of 30th Conf. on Mathematical Foundations of Programming Semantics, MFPS XXX (Ithaca, NY, June 2014),” Electron. Notes in Theor. Comput. Sci. 308, Elsevier, 2014, pp. 25–48.
Ahman, D. and T. Uustalu, Update monads: cointerpreting directed containers, in: R. Matthes and A. Schubert, eds., “Proc. of 19th Conf.d on Types for Proofs and Programs, TYPES 2013 (Toulouse, Apr. 2013),” Leibniz Int. Proc. in Inform. 26, Dagstuhl Publishing, 2014, pp. 1–23.
Behrisch, M., S. Kerkhoff, and J. Power, Category theoretic understandings of universal algebra and its dual: monads and Lawvere theories, comonads and what?, in: U. Berger and M. Mislove, eds., “Proc. of 28th Conf. on Mathematical Foundations of Programming Semantics, MFPS XXVIII (Bath, June 2012),” Electron. Notes in Theor. Comput. Sci. 286, Elsevier, 2012, pp. 5–16.
Foster, J. N., M. B. Greenwald, J. T. Moore, B. C. Pierce, and A. Schmitt, Combinators for bidirectional tree transformations: a linguistic approach to the view-update problem, ACM Trans. on Program. Lang. and Syst. 29(3), 2007, article 17.
Hyland, M., P. B. Levy, G. Plotkin, and J. Power, Combining algebraic effects with continuations,
Theor. Comput. Sci. 375(1–3), 2007, pp. 20–40.


Hyland, M. and J. Power, The category theoretic understanding of universal algebra: Lawvere theories and monads, in: L. Cardelli, M. Fiore, and G. Winskel, eds., “Computation, Meaning, and Logic: Articles Dedicated to Gordon Plotkin,” Electron. Notes in Theor. Comput. Sci. 172, Elsevier, 2007,
pp. 437–458.
Møgelberg, R. E. and S. Staton, Linear usage of state, Log. Methods in Comput. Sci. 10(1), 2014, article 17.
Moggi, E., Notions of computation and monads, Inf. and Comput. 93(1), 1991, pp. 55–92.
O’Connor, R., Functor is to lens as applicative is to biplate: introducing multiplate, arXiv preprint 1103.2841, 2011. (Paper presented at WGP 2011, Tokyo, Sept. 2011.)
Plotkin, G. and J. Power, Notions of computation determine monads, in: M. Nielsen and U. Engberg, “Proc. of 5th Int. Conf. on Foundations of Software Science and Computation Structures, FoSSaCS 2002 (Grenoble, Apr. 2002),” Lect. Notes in Comput. Sci. 2303, Springer, 2002, pp. 342–356. Springer
(2002)
Plotkin, G. and J. Power, Tensors of comodels and models for operational semantics, in: A. Bauer and M. Mislove, eds., “Proc. of 30th Conf. on Mathematical Foundations of Programming Semantics, MFPS XXIV (Philadelphia, PA, May 2008),” Electron. Notes in Theor. Comput. Sci. 218, Elsevier, 2008, pp. 295–311.
Plotkin, G. and M. Pretnar, Handling algebraic effects, Log. Methods in Comput. Sci. 9(4), 2013, article 23.
Power, J. and O. Shkaravska, From models to comodels: state and arrays, in: J. Ad´amek and S. Milius, eds., “Proc. of 7th Int. Wksh. on Coalgebraic Methods in Computer Science, CMCS 2004 (Barcelona, March 2004),” Electron. Notes in Theor. Comput. Sci. 106, Elsevier, 2004, pp. 297–314.
