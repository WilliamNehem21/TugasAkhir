

Electronic Notes in Theoretical Computer Science 256 (2009) 67–85
www.elsevier.com/locate/entcs
Selective Memoization with Box Types
Favio Ezequiel Miranda-Perea1 Lourdes Del Carmen Gonza´lez-Huesca2
Departamento de Matema´ticas Facultad de Ciencias UNAM
Circuito Exterior s/n, Cd. Universitaria, M´exico D.F. 04510, M´exico

Abstract
Memoization is a useful technique to eliminate computational redundancy. A memo function remembers all the arguments to which it has been applied, together with their corresponding results, by storing them in a table. This table is consulted before each functional call to determine if the particular argument is in it. If so, the call is skipped and the stored result is returned; otherwise the call is performed and its result added to the table. Acar, Belloch and Harper present a framework to apply memoization selectively, that is, enabling the programmer to determine precisely the dependences between the input and the result of a function. This framework is efficient and yields programs whose performance can be analyzed using standard techniques. The language, implemented as an SML library, is based on a modal type system which allows the programmer to reveal the true data input/output dependences in a program. However, the modality seems to be an ad-hoc choice for the implementation. In this paper we develop selective memoization, using instead box types, corresponding to the necessitation modality . We also include non-memoized functions, and provide full proofs of type safeness and soundness of the dynamic semantics with respect to an effect-free system which is later translated into the very well-known language PCF .
Keywords: selective memoization, modal types, box types, adaptive computation, type safeness, functional programming.


Introduction
Memoization is a well known technique to avoid repeated computation which has been around a half century [6]. It refers to the tabulation of the results of a compu- tation to elude their repeated calculation and has been extensively used in several areas such as dynamic programming [3], incremental computation [12] and others [10]. To be adequate for implementation a memoization framework must provide control over equality tests, space management as well as a precise identification of dependences between the input and the output of memoized code. The selective

1 Email: favio@matematicas.unam.mx
2 Email: l gonzalez@uxmcc2.iimas.unam.mx

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.006

memoization framework presented in [2] provides control over equality and identifi- cation of dependences, and some control over space management. When detecting dependencies, it is essential not to omit any, or the function caching will be unsound. However, it is also important not to introduce too broad dependencies, or the mem- oization will be ineffective. For the technique to be most effective, each function call’s dependencies must be recorded as precisely as possible. As an example con- sider the following simple function: fun f(x,y,z) = if x > 0 then y else z. The choice point (x>0) causes the arguments on which f depends, to change in a dynamic way. For instance in the call to f(1,2,3) the result depends only on x and y; the value of z being irrelevant. Moreover observe that the evaluation of f(x,y,z) does not depend on the exact value of the first argument x, since it suffices to know the sign of x; therefore, a later invocation to say f(3,2,35) in which the result is identical to the one in the previous call, for the argument y is identical, should yield a table lookup using as key the former input (1,2,3). To handle this kind of function calls efficiently, instead of using the input arguments to index the memo table, a list of choice points, called events, is used. Thus, this list, called branch of events, records the control flow of information from the input to the result of a function. This technique improves the memoization process, as showed in [2], although it could still yield recalculations as in the case of f(-1,5,2), since the argument -1 corresponds to a different event, namely not (x > 0).
An incremental exploration process guided by a modal type reveals the needed dependences to build a branch. However, the modality ! employed in [2] for this
purpose, seems to be an ad-hoc choice for the implementation. To build the type ! T, called a bang type, the underlying type T is required to be indexable, which means that T must admit an injective function, that maps each value of T to a unique in- teger. Therefore, the type ! T makes explicit the indexable feature of the type T 3 , which is needed for the implementation with hash tables, and although box types
are mentioned as an important extension and even used in the implementation they were not formalized. In this paper we propose a system for selective memoization with essentially the same evaluation semantics but using a static semantics which dismisses bang types in favor of box types as defined in [11]. This type, correspond- ing to the necessitation modality in logic, has been used for different applications such as mobility and locality in distributed computation [9], secure information flow
[8] or extensions with persistent code [13]. To our purposes  T can be thought of
as a type which encapsulates certain ordinary values by means of immutable refer- ences, that is, there is a way to allocate values (box) and to deallocate them (let box).
However, we cannot assign a new value to the same box. Furthermore, the encap- sulation of a value v by a box signals that v should be explored to reveal its control and data dependences. Particularly, in practice, memoized functions involve a box type in their domains.
As we will rely on the language MFL of [2] we give here a brief comparison between this system and our proposal: In this paper we are mainly interested in the mechanism of identification of dependences and their formal definition and behavior,

3 ! T could even be syntax sugar for the product type ⟨T, T → Int⟩ as implemented in [2].

by means of a type system and an evaluation semantics. Although we consider that other aspects of that framework, such as performance and equality tests needed for the implementation, are of great importance, we have decided not to treat them here. However, as our evaluation semantics is very similar to that of MFL, we expect that those aspects behave in a similar way, but of course further research is needed. For the time being, we believe that the advantage of our system over MFL is a theoretical one since, apart from the use of box types, which have a strong logical foundation, we prove here in detail its type safeness, as well as its soundness with respect to a non-memoized semantics, as opposed to the work in [1,2].
Our paper is organized as follows: after this introduction we present a system SM of selective memoization with box types in section 2. The auxiliary system S, which keeps the selectivity mechanism but without effects (storages), is developed in section 3, where we also prove that it is type safe. In section 4 the type safeness of SM is proved by means of a faithful translation to S. A translation of S to PCF is provided in section 5 proving indirectly the soundness of the original effectful evaluation semantics of SM with respect to the purely functional semantics of PCF. Finally in section 6 we provide some closing remarks and future work.

Selective Memoization
In this section we present a system for selective memoization based on the original system given in [2] but with the following differences: we eliminate the use of indexable and bang types in favor of box types and include non-memoized functions, case analysis and projections among the terms. With respect to static semantics we propose type judgments with an additional context for locations keeping the dynamic semantics essentially equal to the original one.
The syntax is structured in terms and expressions, in the same sense as in [11]. A term corresponds to a program which is evaluated in an ordinary way, whereas expressions are meant to be evaluated with respect to a given memo table. The type structure engages function, product and sum types as well as the necessitation modality  , deeply studied in [11] from the type-theoretical point of view.
Types. Types are built from a set of basic types B including the unit type Unit
and the integers Int
T ::= B | T → T | T + T | T × T |  T
Terms. Built from an infinite set of term variables x, an infinite set of resource variables a and primitive operators o, including numbers n
t, r, s ::= x | a | o(t,..., t) |  | n | λx : T .r | mfunl(f.a.e) | rs | inlT r | inrT s |
case(r, x.s, y.t) | ⟨r, s⟩ | fst r | snd r | box t
where box t is the constructor of box typed terms; and mfunl(f.a.e) defines a memoized, usually recursive, function with name f , in this case the metavariable l belongs to a set L of label locations disjoint from ordinary variables and resources. The dot notation on abstractions, case analysis and function declarations denotes

binding: in every expression of the form x.t the occurrences of the term variable x in t are considered bound. This binding mechanism using the dot avoids the use of parentheses, the dot signals an opening parentheses which closes as far to the right as syntactically possible. This same convention as well as the usual α-equivalence also apply to expressions below.
Expressions. Built from terms
e ::= return t | let box (t, x.e) | letprod (t, a1.a2.e) | mcase (t, a1.e1, a2.e2)
Expressions provide a binding mechanism for either data dependences (ordinary variables of modal type), or control dependences (resource variables). The idea is that an expression, as opposed to a term, will be evaluated with respect to a memo table. This will be made clear later when defining the semantics. Observe that every term can be considered as an expression due to the return constructor.
Contexts. There are three kinds of contexts, which are finite sets of pairs. Variable contexts Γ; resource contexts Δ and location contexts Σ defined by:
Γ ::= ·| Γ,x : T   Δ ::= ·| Δ,a :: T   Σ ::= ·| Σ,l : T
where · denotes the empty set.
Variable contexts correspond to the validity context of [11] whereas resource context correspond to truth contexts. We use a third context for labels to keep exact track of the labels occurring in a term or expression. With aid of this context we will statically ensure that location labels of different functions in a same program will be different.


Type System
The static semantics is given by a type system which derives judgments of the form Γ | Δ | Σ ▶ r : T denoting that the term or expression r is well-typed in contexts Γ, Δ and Σ. The rules for deriving these judgments are defined as follows:

Γ,x : T | Δ | Σ ▶ x : T (Tvar)	Γ | Δ,a :: T | Σ ▶ a : T (Tresource)


Γ | Δ | Σ ▶ ti : T i (1 ≤ i ≤ n)	▶ o : T1 ×·· · × Tn → T
Γ | Δ | Σ ▶ o (t1,..., tn) : T
(Tbasicop)

Γ | Δ | Σ ▶ : Unit (Tunit)	Γ | Δ | Σ ▶ n : Int (Tnum)


  Γ, x : T 1 | Δ | Σ ▶ t : T2	
Γ | Δ | Σ ▶ λx : T1 .t : T1 → T2
(Tlam)	 Γ, f : T 1 → T 2 | Δ, a :: T 1 | Σ ▶ e : T 2 
Γ | Δ | Σ,l : T 2 ▶ mfunl (f.a.e) : T 1 → T 2
(Tmfun)

Γ | Δ | Σ ▶ t1 : T 1 → T 2	Γ | Δ | Σ ▶ t2 : T 1 Γ | Δ | Σ ▶ t1 t2 : T 2
(Tapply)



	Γ | Δ | Σ ▶ t : T 1	
Γ | Δ | Σ ▶ inlT2 t : T 1 + T 2
(Tinl)		Γ | Δ | Σ ▶ t : T 2	
Γ | Δ | Σ ▶ inrT1 t : T 1 + T 2
(Tinr)


Γ| Δ| Σ ▶ t : T 1 + T 2
Γ, x1 : T 1| Δ| Σ ▶ t1 : T
Γ, x2 : T 2| Δ| Σ ▶ t2 : T
Γ| Δ| Σ ▶ case (t, x .t , x .t ) : T (Tcase)


Γ | Δ | Σ ▶ t1 : T 1	Γ | Δ | Σ ▶ t2 : T 2 Γ | Δ | Σ ▶ ⟨t1, t2⟩ : T 1 × T 2
(Tpair)



Γ | Δ | Σ ▶ t : T 1 × T 2
Γ | Δ | Σ ▶ fst t : T 1
(Tfst)	Γ | Δ | Σ ▶ t : T 1 × T 2
Γ | Δ | Σ ▶ snd t : T 2
(Tsnd)



  Γ | · | Σ ▶ t : T	
Γ | Δ | Σ ▶ box t :  T
(Tbox)


Observe that in rule (Tbasicop) the typing of the primitive operator o is supposed to be given beforehand. Furthermore, in the rule (Tmfun) we expand the label context, guaranteeing thus, that every new memoized function term is associated to a unique label. In the case of rule (Tbox) the requirement of an empty resource context in the premise, ensures that the term t does not have free resources before its encapsulation in box t this is necessary for an adequate operational behavior of boxed expressions. A logical motivation for this rule can be found in [11].
Expressions are typed as follows:


	Γ| · | Σ ▶ t : T	
Γ| Δ| Σ ▶ return t : T
(Treturn)	Γ| Δ| Σ ▶ t :  T 1	Γ , x : T 1| Δ| Σ ▶ e : T 2
Γ| Δ| Σ ▶ let box(t, x.e) : T 2
(Tletbox)



Γ| Δ| Σ ▶ t : T 1 × T 2	Γ| Δ , a1 :: T 1, a2 :: T 2| Σ ▶ e : T
Γ| Δ| Σ ▶ letprod (t, a1.a2.e) : T
(Tletprod)


Γ| Δ| Σ ▶ t : T 1 + T 2
Γ| Δ, a1 :: T 1| Σ ▶ e1 : T
Γ| Δ, a2 :: T 2| Σ ▶ e2 : T
Γ| Δ| Σ ▶ mcase (t, a .e , a .e ) : T (Tmcase)
The rule (Treturn) provides an inclusion of terms in expressions, it is a special purpose rule for memoization with no analogue in modal logic. Its premise requires not to have free-resources, this will ensure that any dependence on a memoized function argument is made explicit in program code before introducing a return statement. On the other hand, the rule (Tletbox) is the elimination rule for box types. The expression constructor let box binds a boxed value to an ordinary vari- able, which may be used without restriction. Again a logical motivation for this rule can be found on [11]. To bind further resources with other ordinary terms we use the constructors letprod and mcase. As an example, consider the following definition of the Fibonacci function mfib :  Int − > Int

mfunl mfib (a:: Int) = letbox x = a in
return (if x<2 then x
else mfib (box (x-1)) + mfib (box (x-2))).
The let box constructor in this definition causes the underlying value of parameter
a, which is a resource, to be exposed before performing the two recursive calls. This, instead of generating an immediate evaluation, will produce a lookup in a memo table, as formalized in the following subsection. Moreover, the domain is given a box type to signal the fact that an actual argument to the function should be explored, since the final result depends completely on this value.

Dynamic Semantics
The evaluation of a term or expression is given by two mutually defined big-step semantics, which involve stores of memo tables indexed by branches that trace choice points in the evaluation process. For terms, the semantics ⇓t is quite standard. This semantics interacts with the one used for expressions in the case of an application
of a memoized function. The semantics for expressions ⇓e	performs an evaluation
according to a given branch β which will be used to query the memo table stored at a given location l. We define now these concepts in detail.
The set of values is a subset of terms defined as follows:
v ::=  | n | λx : T .t | mfunl(f.a.e) | inl v | inr v | ⟨v, v⟩ | box v
We have carefully defined a set of values which consists of terms including neither variables nor resources; as opposed to the set of values defined in [2].
Definition 2.1 A branch β is a list of events ε. An event signals a choice point in the evaluation of an expression. Such a point arises either by a case analysis or by a boxed value. The definitions are:
β ::= •| ε · β	ε ::= !v | inl | inr
Definition 2.2 A memo table θ is a partial function θ : B → VT mapping branches to values of a given type T. We write θ[β '→ v] for the extension of θ that binds β with v, always assuming that β /∈ dom(θ).
Definition 2.3 A store μ is a partial function with finite domain μ : L → T mapping location labels l to memo tables θ. A store is initial if and only if it contains only empty memo tables, that is, ∀l ∈ dom(μ)(μ(l) = ∅).
We write μ[l '→ θ] for the extension of μ that binds l with θ, always assuming that l /∈ dom(μ). Moreover, when l ∈ dom(μ), we write μ[l ← θ] for the update of store μ which binds l to θ.
The evaluation semantics for terms is given by a relation μ, t ⇓t v, μ' modeling the evaluation process of term t with respect to store μ resulting in a final value v and store μ', defined by the following inference rules: 4

4 For the sake of a direct comparison observe that this semantics corresponds to σ, t ⇓t v, σ' in [2].



μ, t1 ⇓t v1, μ1	...		μn−1, tn ⇓t vn, μn μn, o(v1,..., vn) ⇓t v, μ' μ, o (t ,...,t ) ⇓t v, μ'
(Ebasicop)

1	n








l ∈/ dom(μ)
(Eunit)	(Enum)
μ,  ⇓t  , μ	μ, n ⇓t n, μ
(Elam)
μ, λx : T .t ⇓t λx : T .t, μ

(Emfun)	l ∈ dom(μ)






(Emfun − in)

μ, mfunl (f.a.e) ⇓t mfunl (f.a.e), μ[l '→ ∅]	μ, mfunl (f.a.e) ⇓t mfunl(f.a.e), μ 


μ, t1 ⇓t λx : T .t, μ1 μ1, t2 ⇓t v', μ2
μ, t1 ⇓t	v1 = mfunl (f.a.e), μ1 μ1, t2 ⇓t	v2, μ2

μ2, t[x := v'] ⇓t v, μ'
(Eapply)
μ2, e[f, a := v1, v2] ⇓e
v, μ'
(Emapply)

μ, t1t2 ⇓t v, μ'


μ, t ⇓t v, μ'


μ, inl t ⇓t inl v, μ'


(Einl)
μ, t1t2 ⇓t v, μ'

μ, t ⇓t v, μ'


μ, inr t ⇓t inr v, μ'


(Einr)



μ, t ⇓t inl v, μ1 μ1, t1[x1 := v] ⇓t v1, μ'
μ, case (t, x1.t1, x2.t2) ⇓t v1, μ'


(Ecase − l)
μ, t ⇓t inr v, μ1 μ1, t2[x2 := v] ⇓t v2, μ'
μ, case (t, x1.t1, x2.t2) ⇓t v2, μ'


(Ecase − r)



μ, t1 ⇓t v1, μ1 μ1, t2 ⇓t v2, μ'

μ, ⟨t1, t2⟩ ⇓t ⟨v1, v2⟩, μ'


(Epair)



μ, t ⇓t ⟨v1, v2⟩, μ' μ, fst t ⇓t v1, μ'
(Efst)
μ, t ⇓t ⟨v1, v2⟩, μ' μ, snd t ⇓t v2, μ'
(Esnd)



μ, t ⇓t v, μ'


μ, box t ⇓t box v, μ'
(Ebox)

The substitution operations r[x := s] and r[a := s] where r, s can be terms or expressions –appearing in some rules above– are defined in a standard fashion, in- cluding an implicit renaming of bound variables. Observe that a memoized function is a value, but its evaluation can yield the creation of a new empty memo table, in case a memo table for this function does not already exists. Moreover, the applica- tion of such a function launches an expression evaluation starting from the empty branch, which means that an exploration of dependences begins.
The corresponding semantics for expressions is given by a relation μ, e ⇓e	v, μ',
meaning that the evaluation of expression e with respect to store μ results in a value v and store μ'; all according to the query of branch β at the memo table stored at location l in μ.
The deriving rules for this semantics are 5 :

5 Again, for a direct comparison our relation μ, e ⇓e	v, μ' corresponds to σ, l : β, e ⇓e v, σ' in [2].







μ(l)(β) = v
μ(l) = θ β ∈/ dom(θ)
μ, t ⇓t v, μ'
μ'(l) = θ'

μ, return t ⇓e
(Efound)
v, μ
μ, return t ⇓e
(Enotfound)
v, μ'[l ← θ'[β '→ v]]



μ, t ⇓t box v, μ1	μ, t ⇓t ⟨v1, v2⟩, μ1

μ1, e[x := v] ⇓e
μ, let box (t, x.e) ⇓e
v', μ'
v', μ'

(Eletbox)
μ1, e[a1, a2 := v1, v2] ⇓e
μ, letprod (t, a1.a2.e) ⇓e
v, μ'
v, μ'

(Eletprod)

β@l	β@l


μ, t ⇓t inl v, μ1	μ, t ⇓t inr v, μ1

μ1, e1[a1 := v] ⇓e
v1, μ'

(Emcase − l)
μ1, e2[a2 := v] ⇓e
v2, μ'

(Emcase − r)

μ, mcase (t, a1.e1, a2.e2) ⇓e
, v1, μ'
μ, mcase (t, a1.e1, a2.e2) ⇓e
, v2, μ'

There is a subtlety in the definition of rule (Enotfound). Observe that for θ'[β '→ v] to be defined we must have β ∈/ dom(θ'), but the rule only requires β ∈/ dom(θ). We will justify the soundness of this rule definition later in lemma 4.5.
The main goal of this paper is to prove the type safeness of the above system, stated next.
Theorem 2.4
If Γ|· |Σ ▶ t : T and μ, t ⇓t v, μ' with μ initial, then there exists Σ' such that
Γ|· |Σ' ▶ v : T.
If Γ|· |Σ ▶ e : T and the evaluation μ, e ⇓e	v, μ' originates in an application 6
μ٨, t1t2 ⇓t v٨, μ٨' with μ٨ initial, then there exists Σ' such that Γ|· |Σ' ▶ v : T.
It is worth noting that part (ii) of this theorem does not have a counterpart in [1], which is an important omision since it is needed for the proof of part (i).
To prove this theorem we will translate SM to a system S defined in the following section. We will prove that S is type safe and that the translation is faithful getting
as a corollary a proof of theorem 2.4. For part (i) this idea is sketched without details in [1]. Here we provide a full proof.

A selective system without effects
To prove the safeness for the system SM we define an auxiliary system S which keeps the selective feature but avoids memoization. This system is quite similar to the original one, with some differences mainly in the dynamic semantics for expressions. With this, we provide a detailed alternative to the missing definitions and properties



6 This means that μ, e ⇓e
v μ' arises as part of a derivation of the premise involving ⇓e
' in an instance

Ø@Æ
of the rule (Emapply).
@Æ

of the relations ⇓t , ⇓e of [1,2], which are critical to the proof of soundness for their
p	p
system MFL.
Types. The same types used for SM
Terms. The same terms as for SM except for the memoized functions declaration where now there is no label associated with a function. That is, we use terms of the form mfun(f.a.e) instead of mfunl(f.a.e). This class of term is called named function.
Expressions. The same as for SM
Contexts. We keep the contexts for ordinary variables Γ and for resource variables Δ.
Type system. The same rules as for SM, adapted accordingly to the terms of S, eliminating all the label contexts Σ. For instance the typing rule for named functions is:
Γ, f : T 1 → T 2 | Δ, a :: T 1 ▶ e : T 2
Γ | Δ ▶ mfun(f.a.e) : T 1 → T 2
This inference system satisfies the usual structural properties of monotonicity, exchange and contraction. Moreover, since the inferences are syntax-directed it also satisfies typing inversion. These properties can be shown routinely by structural induction.

Dynamic semantics
The evaluation relation for terms is completely analogous to the one for SM, we simply eliminate the stores and modify the class of values accordingly. For expres-

sions, the evaluation relation denoted e ⇓e
f
v depends now on a branch β and a

functional value vf of the form mfun(f.a.e). For the cases of let box, letprod or mcase
statements the evaluation rules are obtained from the ones for ⇓e	replacing β@l
for β; vf accordingly. For the case of a return statement we need a partial access function vf @β, defined below, which will compute a return statement obtained by exploring the given branch β.
Definition 3.1 Given a term or expression r and a branch β we define the partial access function r@β as follows:


mfun(f.a.e) @ β = e @ β
return t @ • = return t
let box(t, x.e) @ β ^!v = e[x := v] @ β
letprod(t, a1.a2.e) @ β = e @ β mcase(t, a1.e1, a2.e2) @ β ^ inl = e1 @ β mcase(t, a1.e1, a2.e2) @ β ^ inr = e2 @ β

where the notation β ^ε makes explicit the last event ε of a branch whose previous elements are those of β.

The evaluation of a return statement can now be defined as



vf @β = return t t ⇓t v


(Ereturn)

return t ⇓e	v
f
This rule causes the evaluation of the argument t of the return statement to always take place. The side condition vf @β = return t makes sure that the branch β really corresponds to the exploration of the functional value vf which we are using to evaluate.
The dynamic semantics for terms t ⇓t v is analogous to the one for SM, the
main difference arises in the rule for application of named functions which is:


t1  ⇓t
t2  ⇓t
e[f, a := v1, v2] ⇓e
v1 = mfun(f.a.e)
v2 v




(Emapply)

t1 t2 ⇓t v

Type safeness for S
It is conventional to prove the type safeness for S, since this is an effect-free system. We state next a standard substitution lemma needed in the proof.
Lemma 3.2 (Substitution lemma) The static semantics of system S satisﬁes:
If Γ, x : R |Δ ▶ t : T and Γ|· ▶ r : R then Γ|Δ ▶ t[x := r] : T.
If Γ, x : R |Δ ▶ e : T and Γ|· ▶ r : R then Γ|Δ ▶ e[x := r] : T.
If Γ|Δ, a :: R ▶ t : T and Γ|Δ ▶ r : R then Γ|Δ ▶ t[a := r] : T.
If Γ|Δ, a :: R ▶ e : T and Γ|Δ ▶ r : R then Γ|Δ ▶ e[a := r] : T.
Proof Straightforward induction on the first given derivation in each case.	 
Now we can prove the safeness theorem.
Theorem 3.3 System S is type safe, that is:
If Γ|· ▶ t : T and t ⇓t v then Γ|· ▶ v : T.
If Γ|· ▶ e : T and e ⇓e	v, for any β and vf , then Γ|· ▶ v : T.
Proof We prove both parts simultaneously by performing induction on both eval-

uation relations ⇓t
and ⇓e	.
f

Let us show the cases for applications of named functions and return statements.
Assume that t = t1t2 with t1t2 ⇓t v derived from t1 ⇓t v1 = mfun(f.a.e), t2 ⇓t v2
p	p	p
and e[f, a := v1, v2] ⇓e	v. As Γ|· ▶ t1t2 : T, inversion of typing implies that
Γ|· ▶ t1 : R → T and Γ|· ▶ t2 : R. By I.H. of part (i) we get Γ|· ▶ v1 : R → T and Γ|· ▶ v2 : T. Next observe that the typing of v1 implies that Γ,f : R → T |a :: R ▶ e : T. Therefore by the substitution lemma parts (ii) and (iv) we obtain
Γ|· ▶ e[f, a := v1, v2] : T. Finally, as e[f, a := v1, v2] ⇓e	v, the I.H. for part (ii)
of this theorem yields Γ|· ▶ v : T.

Assume e = return t with return t ⇓e
f
v derived from vf @β = return t and t ⇓t v.

Γ|· ▶ return t : T yields, from inversion of typing, Γ|· ▶ t : T which by I.H. for part

, together with return t ⇓e
f
v leads us to Γ|· ▶ v : T.


This system will later be translated into the well-known system PCF. In this way we indirectly reduce the system of selective memoization to a pure functional system proving soundness of the original memoized semantics with respect to the pure semantics of PCF.

A translation from SM to S
In this section we develop a faithful translation from SM to S and use it to prove the type safeness of SM.
Definition 4.1 The translation (·)− from the terms and types of SM to the terms and types of S is defined as follows:
The translation on types is the identity function.
The translation on terms is the forgetful map on labels. In particular we have
mfunl(f.a.e)− = mfun(f.a.e−) and (return t)− = return t−
Later on, we will also apply this translation to branches β, obtaining a branch
β− by replacing each event of the form !v occurring in β, by !(v−).

Important features of our translation are its compatibility with substitution and its compliance with typing derivations.
Lemma 4.2 If r is a term or expression then r[x := t]− = r−[x := t−] and r[a :=
t]− = r−[a := t−].
Proof Straightforward simultaneous induction on terms and expressions.	 
Proposition 4.3 The translation t '→ t− respects types.
If Γ|Δ|Σ ▶ t : T then Γ|Δ ▶ t− : T.
If Γ|Δ|Σ ▶ e : T then Γ|Δ ▶ e− : T.
Proof Straightforward simultaneous induction on typing derivations.	 
To prove that our translation is faithful we need to simulate a store μ in an ad- equate way. To this purpose we use function tables which associate a label location with a named function value.
Definition 4.4 A function table τ is a partial function τ : L → F with finite domain, mapping location labels to functional values of the form mfun(f.a.e).
Using function tables and access functions we can justify the subtlety in the definition of the evaluation rule (Enotfound) by means of the following

Lemma 4.5 If μ, t ⇓t v, μ', μ(l)@β = return t and μ(l)(β) is undeﬁned then
μ'(l)(β) is also undeﬁned.
Proof See [1].	 
For the evaluation simulation to succeed, we need to associate an adequate function table τ with a given store μ. The needed intrinsic relationship between a store μ in SM and a table τ in S is that every memoized function f , for which there is a memo table stored in μ at location l, should have a corresponding named function f− as image of the same location l in τ . To achieve this we will use the following
Definition 4.6 Let μ be a store, τ a function table, r a term or expression and e
an expression.
τ is consistent with r if and only if for each subterm of r of the form mfunl(f.a.e), we have τ (l) = mfun(f.a.e−)
τ is consistent with μ if and only if for all l ∈ dom(μ) and β ∈ dom(μ(l)), if
μ(l)(β) = v then τ is consistent with v.
τ is compatible with μ if and only if:
dom(μ) = dom(τ )
τ is consistent with μ.
For all l ∈ dom(μ), β ∈ dom(μ(l)) and t term, if μ(l)(β) = v and τ (l)@β− =
return t− then t− ⇓t v−. Let us call this condition (⬦).
To prove that the translation simulates the evaluation relation we will need the following concepts.
Definition 4.7 An augmented branch γ is a list of augmented events ϵ. An aug- mented event records choice points and the bindings of resource variables.
γ ::= •| ϵ · γ
ϵ ::= (v) | !v | ⟨v1, v2⟩ | inl v | inr v
Partial access functions for augmented branches are defined as follows:
mfunl(f.a.e) @ γ ^(v) = e[f, a := mfunl(f.a.e), v] @ γ e @ • = e
let box(t, x.e) @ γ ^ !v = e[x := v] @ γ
letprod(t, a1.a2.e) @ γ ^⟨v1, v2⟩ = e[a1, a2 := v1, v2] @ γ mcase(t, a1.e1, a2.e2) @ γ ^ inl v = e1[a1 := v] @ γ mcase(t, a1.e1, a2.e2) @ γ ^ inr v = e2[a1 := v] @ γ
Augmented branches are a device needed in the proof of proposition 4.9 below. Given an augmented branch γ we can easily obtain a simple branch denoted γ◦, by forgetting events of the form (v) and ⟨v1, v2⟩, as well as the event v in the injections inl v, inr v. Moreover the translation γ− of an augmented branch γ is defined by

replacing each value v, occuring in γ, by v−.

Operationally, the augmented branches give the same results as simple branches as ensured by the following
Lemma 4.8 Augmented branches do not modify return statements. That is, if
τ (l)@γ = return t then τ (l)@γ◦ = return t
Proof See [1].	 
The following proposition states the preservation of the selective memoized se- mantics of SM with respect to the selective semantics without memoization of S, and allows us to conclude the faithfulness of the translation.
Proposition 4.9 The translation t '→ t− simulates evaluation under the following conditions:
Let τ be consistent with t and compatible with store μ. If μ, t ⇓t v, μ' then t− ⇓t v− and there exists τ' ⊇ τ such that τ' is consistent with v and compatible with μ'.
Let τ be consistent with expression e and compatible with store μ, β be a simple
branch and γ be an augmented branch. If μ, e ⇓e	v, μ', γ◦ = β and τ (l)@γ− =
e− then there exists τ' ⊇ τ such that τ' is consistent with v and compatible with
μ' and e− ⇓e	'	v−
β ; r (l)
Proof The two parts are proved simultaneously by induction on both evaluation relations. We show the most important cases, application of a named function and return statements.
t = t1t2 and μ, t1t2 ⇓t v, μ' derived from μ, t1 ⇓t v1 = mfunl(f.a.e), μ1, μ1, t2 ⇓t
v', μ2 and μ2, e[f, a := v1, v2] ⇓e	v, μ'. Let τ be consistent with t and compatible
with μ. In particular τ is consistent with t1 which by I.H. yields t− ⇓t v− and
p  1
τ1 ⊇ τ consistent with v1 and compatible with μ1. Applying now the I.H. for t2
with τ1 which is possible for τ1 extends τ and therefore τ1 is also consistent with
t2 we obtain t− ⇓t v− and τ2 ⊇ τ1 consistent with v2 and compatible with μ2.
p  2
We observe now that τ2 is also consistent with e[f, a := v1, v2] for τ2 is consistent with v1, v2 and also with e for e is a subexpression of v1. It suffices now to show a γ such that γ◦ = • and τ2(l)@γ− = (e[f, a := v1, v2])−. For then the I.H. for
e[f, a := v1, v2] will get us a τ such that e[f, a := v1, v2]− ⇓e  '	v− which will

yield t− ⇓t v− as desired. Define γ = (v2) · •, then
; r (l)

τ2(l)@γ− = v−@γ−
= e−[f, a := v−, v−]
1	2


e = return t and μ, e ⇓e
= (e[f, a := v1, v2])− (by lemma 4.2)
v, μ' derived with the rule found, therefore μ' = μ and

μ(l)(β) = v. Assume τ consistent with return t and compatible with μ, γ◦ = β and
τ (l)@γ− = (return t)− = return t−. Observe that, as μ(l)(β) = v the compatibility

of τ with μ implies that τ is consistent with v. Moreover, as τ (l)@γ− = return t−, lemma 4.8 implies τ (l)@(γ−)◦ = return t−. But (γ−)◦ = (γ◦)− = β−. Therefore
τ (l)@β− = return t− and again by compatibility we get t− ⇓t v− which finally,
using the rule for return, yields return t− ⇓e	v−. Therefore, in this case it

suffices to take τ' = τ .
e = return t and μ, e ⇓e

v, μ' derived with the rule notfound. Assume τ consis-

tent with return t and compatible with μ, γ◦ = β and τ (l)@γ− = (return t)− =
return t−. By I.H. there exists τ1 ⊇ τ consistent with v and compatible with μ'
and t− ⇓t v−. Take τ' = τ1. It remains to be proved that τ' is compatible with
μ'' = μ'[l ← θ'[β '→ v]]. We show this now:
dom(μ'') = dom(τ') because μ'' is only an update of μ'.
τ' is consistent with μ''. Observe that, as τ' is consistent with μ' it suffices to show consistency for the update μ''(l)(β) = v. In this case we need to show that τ' is consistent with v, but this is true by definition of τ'.
To show that condition (⬦) holds, it suffices again to show it for l, β and an arbitrary term t' such that μ''(l)(β) = v and τ (l)@β− = return t'−. But observe that, τ (l)@β− = τ (l)@γ− = return t− which implies that t = t', for @ is a
function. Hence we have to show t− ⇓t v− but this was consequence of the I.H.


It is easy to see that, if t = f v is an application of a memoized function with no free variables f to a value v, the part (i) of proposition 4.9 entails that the translation of this memoized function computes indeed an application t− = f−v−, which corresponds to a non-memoized function with the same outcome as f . In particular, the memoized function given in page 5 will compute the actual Fibonacci function.
Next we give some conditions which guarantee the existence of function tables as required by proposition 4.9.

Lemma 4.10 If (e @ γ) is deﬁned, then for every augmented event ϵ, (e @ γ)@ ϵ =
e @ ϵ · γ

Proof Straightforward induction on the augmented branch γ.


Lemma 4.11 Let e be an expression such that μ, e ⇓e	v, μ' originates in an
application μ٨, t1t2 ⇓t v٨, μ٨' with μ٨ initial, then there exists a table function τe
and an augmented branch γ such that τe is consistent with e and compatible with μ, γ◦ = β and τe(l)@γ− = e−.

Proof According to the statement of the lemma we have the following situation:


μ, e ⇓e	v, μ'
μ'', e' ⇓e	v, μ'
.	.	β1@l
.	.	.
μ٨, t1 ⇓t v1 = mfunl(f.a.e1), μ1	μ1, t2 ⇓t v2, μ2	μ2, e1[f, a := v1, v2] ⇓e	v٨, μ٨'
μ٨, t1t2 ⇓t v٨, μ٨'

The proof is by induction on the number n of inference rules from the evaluation of e1[f, a := v1, v2] up to the evaluation of e.
Induction basis: n = 0 which means there is no inference rule, that is, e = e1[f, a := v1, v2] and v1 = mfunl(f.a.e1). As μ٨ is initial we can build a τ consistent with t1t2 and compatible with μ٨. From this τ , repeated applications of proposition 4.9 yield the desired τe. In particular we have τe(l) = mfun(f.a.e−). Define now γ = (v2) · •, and observe that τe(l)@γ− = e−[f, a := v−, v−] · • =
1	1	2
e−[f, a := v−, v−]. But by lemma 4.2 e−[f, a := v−, v−] = e1[f, a := v1, v2]− =
1	1	2	1	1	2
e−, which completes the proof.
Inductive step: assume that there are n + 1 inference rules from e1[f, a := v1, v2] up to e. The proof proceeds by a case analysis on the top rule and is illustrated for the case of rule (Eletbox). In this case we have e' = let box(t, x.e1), e = e1[x :=
v1],β =!v1 · β1 and μ'',t ⇓t box v1, μ. By I.H. there are τe' and γ1 such that τe'
is consistent with e' and compatible with μ'', τe' (l)@γ− = e'− and γ◦ = β1. In
1	1
particular τe' is consistent with t and therefore, by proposition 4.9, there is a τ '' such that τ '' ⊇ τe' is consistent with box v1 and compatible with μ. Moreover, τ '' is also consistent with e = e1[x := v1], and as it was compatible with μ we can define τe = τ ''. Define now γ =!v1 · γ1 and observe that γ◦ =!v1 · γ◦ =!v1 · β1 = β.
This suffices to show that τe(l)@γ− = e−.
τe(l)@γ− = τe' (l)@γ−
= τe' (l)@(!v− · γ−)
1	1
= (τe' (l)@γ−)@!v−) (by lemma 4.10)
1	1
= let box(t−, x.e−)@!v−
1	1
= e−[x := v−]@•
1	1
= e−[x := v−] = e−  (by lemma 4.2)
1	1
The cases for letprod and mcase are analogous.


After a final lemma, we will be able to prove now the type safeness for system
SM .
Lemma 4.12 Let r be a term or expression of SM. If Γ|Δ ▶ r− : T then there exists a label context Σ such that Γ|Δ|Σ ▶ r : T
Proof Straightforward induction on the typing derivation of r−.	 

Type safeness for SM
We can now develop the proof of type safeness for SM stated in theorem 2.4.

Proof of theorem 2.4
Part (i). Assume Γ|·|Σ ▶ t : T and μ, t ⇓t v, μ' with μ an initial store. Let Lt be the set of labels occurring in t. Without loss of generality we can assume dom(μ) = Lt = dom(Σ). Observe that the typing ensures that for every l ∈ dom(τ ) there is a unique expression e such that mfunl(f.a.e) occurs in t. Therefore we can define a function table τ with dom(τ ) = dom(μ) by defining τ (l) = mfun(f.a.e−) for every l ∈ dom(τ ). In this way τ is consistent with t by construction and it is compatible with μ due to the initiality of μ. Therefore we can apply part (i) of proposition 4.9 to get a τ' ⊇ τ such that τ' is consistent with v, compatible with μ' and t− ⇓t v−. On the other hand, proposition 4.3 yields the typing Γ|· ▶ t− : T
which together with t− ⇓t v− implies, by type safeness of system S (prop. 3.3),
that Γ|· ▶ v− : T. Finally lemma 4.12 yields a Σ' such that Γ|· |Σ' ▶ v : T.
Part (ii). Assume Γ|· |Σ ▶ e : T and μ, e ⇓e	v, μ' originating in an application
μ٨, t1t2 ⇓t v٨, μ٨' with μ٨ initial. By lemma 4.11 there is a τe consistent with e
and compatible with μ, and a γ such that τe(l)@γ− = e− and γ◦ = β. The proof proceeds analogous to part (i).


We have now fulfilled our main goal. However, although system S does not have explicit effects, from a strict point of view, this system is still not pure, for it keeps the distinction between types and expressions as well as the selectivity feature. To solve this problem we provide a translation of S to the purely functional language PCF.


A translation from S to PCF
In section 4 we have developed a faithful translation from SM to S, a system which can be considered to be effect-free. However we are not comfortable claiming that this translation shows the soundness of the memoized semantics with respect to a pure functional semantics. Our main reason to this remark is that the operational semantics of S is not pure strictly speaking, for it refers to a function table and upholds the selective mechanism of the original system SM. Moreover, the return instruction, which has a strong imperative flavor, is maintained. To avoid this problem we give a translation (·)∗ from S to the very well-known pure functional language PCF.
The translation on types is the identity function except in the case of a box type where the definition is ( T)∗ = T∗. Furthermore, terms and expressions of S collapse into terms of PCF according to the following table, where every resource variable a is mapped to a unique variable xa of PCF.



r x a
box t
mfunl(f.a.e) return  t let box(t, x.e)
letprod(t, a1.a2.e)
r∗ x xa t∗
fun(f.xa.e∗)
t∗
let(t∗, x.e∗)
let(snd t∗, xa .(let(fst t∗, xa .e∗)))

2	1
mcase(t, a1.e1, a2.e2)	case(t∗, xa .e∗, xa .e∗)
1  1	2  2
For ease of presentation we have assumed named functions fun and let expressions as primitives in PCF, though they are indeed syntax sugar. All syntactic forms missed in the table are defined in a homomorphic way.
The following results prove that the translation is faithful. Their proofs are completely conventional due to the fact that S does not have actual effects.
Proposition 5.1 Let r be a term or expression. If Γ|Δ ▶ r : T then Γ∗, Δ∗ ▶ r∗ :
T٨, where Γ∗ = {x : T٨ | x : T ∈ Γ} and Δ∗ = {xa : T∗ |a :: T ∈ Δ}.
Proposition 5.2 The translation (·)∗ satisﬁes:
If t ⇓t v then t∗ ⇓PCF v∗.

If e ⇓e
f
v then e∗ ⇓PCF v∗.

Finally an adequate combination of propositions 4.9 and 5.2 allows us to claim the soundness of the original memoization semantics with respect to a pure func- tional semantics.

Conclusions and Final Remarks
The framework MFL of selective memoization makes explicit the performance effects of memoization by capturing control and data dependences between the input and the result of a memoized function. Moreover it yields programs whose running times can be analyzed by standard techniques and has been implemented as an SML library. An essential feature of the system is the use of a modal type to reveal dependences. In this paper we have presented a framework SM, similar to the one developed in [2], with the following improvements from the theoretical point of view: instead of the bang modality, which in our opinion, was an ad-hoc choice for the implementation of the original system, we use the box type corresponding to the necessitation modality deeply discussed in [11] from the logical point of view. We provide our system with a static semantics which keeps exact track of the location labels occurring in a term or expression. Hence, we statically ensure the uniqueness of the label assignment for memoized functions. Type safeness for SM is proven by its translation to an effect-free system which is later translated

to the purely functional language PCF. This way we have shown that selective memoization does not affect the outcome of evaluation as compared to a purely functional non-memoizing semantics.
Concerning current and future work, above all we do not discard a reformulation of the dynamic semantics of our systems in the framework of operational structural
semantics, which would allow to pursuit an analysis of evaluation progress. We are working towards an implementation of the system in Haskell, based on the framework of polytypic memoization of [5]. From the logical point of view neither
MFL nor SM have a clear sight under the Curry-Howard correspondence. Hence
an interesting question is to formulate a system which directly corresponds to the necessitation fragment of the judgmental reconstruction of modal logic given in [11]. In particular the typing relations for terms and expressions should be different, but mutually defined as in the case of evaluation relations; and the return instruction should be dismissed. Regarding further extensions of our system, a natural one is
to add the type ◯ T representing monadic memoization and other computations of type T.
Memoization becomes more complicated when the language includes composite value types like records, in that case the data dependencies should be as fine-grained as possible, as discussed in [4]. Therefore, it is interesting to pursuit the modeling of such dependencies in our framework. Last, but not least, and regarding the inclu- sion of recursive types, we recall that memoization is most effective when applied to the kind of programs used in dynamic programming, which usually are neither sim- ple iterative nor primitive-recursive, but course-of-value recursive. This fact leads us to investigate an extension with inductive types modeling the latter principle, motivated by our previous work in [7].
Acknowledgement
We are thankful to the anonymous referees for the helpful comments and suggestions regarding the contents and presentation of this paper. We also gratefully acknowl- edge the LSFA 2009 travel grants committee for providing partial funds to attend the meeting and Martha Buschbeck Alvarado for improving the English manuscript.

References
Acar U. A., G. E. Blelloch and R. Harper, Selective memoization, Technical Report CMU-CS-02-194, Carnegie Mellon University, Computer Science Department, 2002.
Acar U. A., G. E. Blelloch and R. Harper, Selective memoization, In Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (2003), 14-25.
Cormen T. H., C. Leiserson and R. Rivest, “Introduction to algorithms”, MIT Press, 1990.
Heydon A., R. Levin and Y. Yu, Caching function calls using precise dependencies, In Proceedings of the ACM SIGPLAN 2000 conference on Programming language design and implementation, 311-320.
Hinze R., Memo functions, polytypically!, Proceedings of the 2nd Workshop on Generic Programming (2000), 17-32.
Michie D., ”Memo” Functions and Machine Learning, Nature (1968), 218:19-22.


Miranda-Perea F. E., Some Remarks on Type Systems for Course-of-value Recursion To appear in Electronic Notes in Theoretical Computer Science. Elsevier Science Holland 2009.
Miyamoto K. and A. Igarashi, A modal foundation for secure information flow, In Proceedings of Workshop on Foundations of Computer Security (2004), 187-203.
Moody J., Logical Mobility and Locality Types, In Proceedings of the International Symposium on Logic-based Program Synthesis and Transformation (2004), 69-84.
Norvig P., Techniques for Automatic Memoization with Applications to Context-Free Parsing, Computational Linguistics 17 (1991), 91-98.
Pfenning F. and R. Davies, A judgmental reconstruction of modal logic, Mathematical Structures in Computer Science 11 (2001), 511-540.
Pugh W. and T. Teitelbaum, Incremental Computation via Function Caching, In Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (1989), 315-328.
Yuse Y. and A. Igarashi, A modal type system for multi-level generating extensions with persistent code, In Proceedings of the 8th ACM SIGPLAN international conference on Principles and practice of declarative programming (2006), 201-212.
