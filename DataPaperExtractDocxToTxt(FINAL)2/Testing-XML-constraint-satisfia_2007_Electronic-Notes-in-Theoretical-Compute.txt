Electronic Notes in Theoretical Computer Science 174 (2007) 45–61	
www.elsevier.com/locate/entcs

Testing XML constraint satisfiability
Nicole Bidoit1 ,2	Dario Colazzo1 ,3
Univ Paris Sud, UMR CNRS 8623, Orsay F-91405 CNRS, Orsay F 91405

Abstract
In a previous paper, we have showed that Hybrid Modal Logic can be successfully used to model semistruc- tured data and provides a simple and well suited formalism for capturing “well typed” references and of course a powerful language for expressing constraint. This paper builds on the previous one and provides a tableau proof technique for constraint satisfiability testing in the presence of schemas.
Keywords: Database, Semistructured data, Integrity constraints, Schema, Multimodal and Hybrid logic


Introduction
Schemas and integrity constraints play an important role with respect to data ma- nipulation, reasoning and optimization. This of course applies to semistructured data and XML documents. It is also widely recognized that, being able to model schemas, constraints and queries within the same formalism (logic as a matter of fact) is a key issue to investigate problems like subtyping, constraint implication and satisfiability, query correctness etc.
The modal logic approach to model semistructured data is naturally motivated by the fact that semistructured data, hence XML documents, are commonly viewed as edge labeled graphs thus as Kripke models [24]. This approach has been inves- tigated in different ways to tackle different problems [18]: schemas subsumption [1,14], path constraints [2], query languages [15], XPath queries [25]...
In [7] and subsequently in [8], we have investigated how to capture well-typed references as first class citizen within the definition of semistructured data schema. References are most commonly found in practice. However, surprisingly enough, the notions of schema provided in the literature [29,26] do not provide a mechanism for

1 This work has been partially supported by the French National ACI Tralala project.
2 Email: nicole.bidoit@lri.fr
3 Email: dario.colazzo@lri.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.025

specifying the types of the referenced elements in a document. The notion of schema capturing well-typed references provided in [8], called ref-schema, is very general and extends the one previously introduced in [7], called normalized ref-schema. Another contribution of [7,8] has been to show that ref-schema can be expressed in Hybrid Modal Logic (HML)[10]. Although modal logic is a simple formalism for working with graphs, it has no mechanism for referring to and reasoning about the individual nodes in such structures. HML increases the effectiveness of modal logic by allowing one to grasp the nodes via formulas. HML provides a unique formalism to express sophisticated schemas, constraints and navigational queries a la XPath.
The work presented here builds naturally on [7,8] and addresses constraint sat- isfiability in presence of ref-schema: given a ref-schema G and a constraint C, does there exist a document conforming to G and satisfying C? In our framework, this
leads to the question: is τG ∧C finitely satisfiable? The translation given in [8] of ref- schema into normalized ref-schema allows us to study this problem wlog in the case where G is a normalized schema. The paper provides a proof procedure based on tableau techniques [23] for testing satisfiability by generating models. Our tableau
system is naturally based on internalizing labeled deduction, as investigated in [11], which is elegant and powerful. In general, HML is not decidable [9,22] and the logic does not have the finite model property 4 . Thus, we restrict the satisfiability problem to the case of non recursive schemas. Although this assumption ensures that the depth of documents are upper bounded, we show that it is still not suffi- cient to entail the finite model property. The tableau system presented is showed to be sound and complete for satisfiability, although finite satisfiability is the relevant notion for reasoning about XML. This issue is discussed in the last section of the paper where some hints are given for solving finite satisfiability in presence of non recursive schema.

Related work
Quite a few studies address typing mechanisms for references in semistructred and XML data. XML Schema [29] contains some mechanisms to type references which are neither flexible nor direct. Indeed, as observed in [20], references are defined by means of XPath, which is rather complex and requires a good amount of expertize to be used correctly. Moreover, reasoning about constraints defined with XPath is highly intricate, if not impossible.
Simeon and Fan [20] propose an extension of DTD able to model classical re- lational and object oriented referential constraints. So the focus is on problems related to key constraints and foreign-key constraints. These constraints can be used to capture reference enforcement. It seems that this approach and that of XML are closely related. Rather negative results concerning decidability for key and foreign-key constraints have been showed in [5].
Note that we do not address the decidability and complexity issues, which have

4 It is not the case that each satisfiable HML wff has a finite model.

been extensively studied in [6,19] in a slightly different setting, although it appears that in our setting decidability is an open problem, as discussed in the last section of the paper.
The quite recent paper [13] provides another interesting approach to the problem of logically characterizing XML schemas and constraints. Main differences wrt to this work, and references therein, are the followings. The work [13] proposes a decidable logic able to model inclusion constraints only over one attribute, otherwise decidability is lost. So, some kind of references can be modeled in the standard way by means of inclusions constraints. Of course decidability is lost if the references require multiple attributes. Here, instead of capturing references indirectly and partially like in [13], by means of inclusion constraints, we model typed references by using primitive mechanisms, defined by means of HML primitives and which are able to describe references in an abstract and general way, as much as for object-oriented databases. Also, differently from [13], the logic we consider allows to model navigational properties requiring to visit all descendants of certain nodes (by using Gφ formulae); actually, the logic [13] essentially enables only one step navigation (parent, child, ...) plus a kind of somewhere navigation, allowing to jump to some arbitrary node, not necessarily related with the current one. As stated in [13], if the proposed decidable logic is extended with navigational mechanisms like G, decidability is not proved to hold (it is an open problem). However, in our context, we are quite confident that this property holds for a wide class of constraints (involving F and G) under the assumption that data are constrained by a schema, and currently we are actively investigating this possibility.
Finally, a further difference wrt [13] , and works referenced therein, is that while they deal with ordered XML documents, we move in a more database framework, where ordering is uninfluential.

Organization
Section 2 is devoted to a short introduction to HML and its relationship with semistructured data and XML. Schemas capturing well-typed references are intro- duced in Section 3. The tableau system for testing satisfiability of constraints in presence of schemas is presented in Section 4. The last section is devoted to a discussion on further research directions.

Hybrid multimodal logic
We assume the reader familiar with modal logics and just recall here the main features of Hybrid Modal Logic (HML). The interested reader is invited to read [9,3,4] for a full presentation of HML. Hybrid Modal Logic is an extension of modal logics which provides a mechanism to name states (or graph nodes) and to assert that a formula is true at a named state (or graph node). This is made possible by four fundamental features: (1) a nominal or a state variable is a special atomic formula that names or denotes the unique state where the formula holds (under a given variable assignment); (2) the satisfaction operator @u applied to a formula ψ

enables to check satisfaction of ψ at the state named (or denoted) by the nominal (or state variable) u; (3) the binder operator ↓x applied to a formula ψ binds the state variable x in ψ to the current state.
An HML alphabet is a set of propositions P = {p, q, ·· ·}, a set of nominals N om = {a, b, ·· ·}, a set of state variables V ar = {x, y, ·· ·} and a finite set of labels E = {e1, ..., en} 5 . Well formed formulas (wffs) are defined by:
WFF ::= p | T | ¬ψ | ψ1 ∧ ψ2 | [e]ψ | u | ↓x ψ | @uψ
where ψ, ψ1 and ψ2 are wffs, p ∈ P , x ∈ V ar and u ∈ N om ∪ V ar.
Roughly, the multimodality of the language comes from the combination of the modal operator [] with labels leading to the finite set of modal operators [e].
We also use the operators ∨, ⇒ and ⟨e⟩ classically defined by: ψ1 ∨ ψ2 =def
¬(¬ψ1 ∧ ¬ψ2),  ψ1 ⇒ ψ2 =def  ¬ψ1 ∨ ψ2	and	⟨e⟩ψ =def  ¬[e]¬ψ.
A model M of HML is a Kripke structure (S, r, R, IP , IN ) where: S is a set of states containing a distinguished element r; R = {re|e ∈ E} is a set of binary accessibility relations on S; the function IP :P → Pow(S) assigns to each proposition p the set of states where p holds; the function IN :N om → S assigns a unique state to each nominal. A valuation is a function g:V ar → S assigning a state to each
state variable. By g x g' we denote that g' is a x-variant of g.
The semantics of HML is defined as follows, where we restrict the presentation to
the hybrid features: a model M satisfies the wff ψ at state s wrt a valuation g, noted M, g,s |= ψ, if:
M, g,s |= a	iff IN (a)= s,	where a ∈ N om
M, g,s |= x	iff g(x)= s,	where x ∈ V ar

M, g,s |= ↓x ψ	iff M, g',s |= ψ with g x
g', g'(x)= s, where x ∈ V ar

M, g,s |= @xψ	iff M, g, g(x) |= ψ where x ∈ V ar
M, g,s |= @aψ	iff M, g, IN (a) |= ψ where a ∈ N om
We write M,s |= ψ when M, g,s |= ψ is verified for any valuation g of the state variables.
The language is extended with two dual modalities G and F : M, g,s |= Gψ iff for any state accessible via a path from the current state s, ψ holds at s, and Fψ =def ¬G¬ψ. We also use G∗ψ for ψ ∧ Gψ and F ∗ψ for ψ ∨ Fψ. Recall that when such modalities are added, HML is no longer a fragment of first order logic.
The next example illustrates how a semistructured data is mapped to a model of an HML language and illustrates the semantics of the hybrid operators.
Example 2.1 The document X of Figure 1 can be viewed as an HML model M
where: the states of M are the nodes of X ; the distinguished state r of M is the

5 As usual, the sets P , Nom and V ar are assumed pairwise disjoint.

root of X ; a unique nominal root is needed in the language to name r and thus IN (root)= r; the accessibility relations of M are given by the labeled edges of X ; the function IP is given by the labeling of nodes in X .
In Figure 1, the name n is given to one of the node for the sake of the presentation but it should not be considered neither as a nominal nor as a proposition. The wffs

[author]¬Scott, ↓x
−−−→ −−−→⟩x, @ 
[doc][article]⟨author⟩T are satisfied at n

⟨pubby⟩⟨pubB
root

by X . The wff F Scott is satisfied at r but G[doc]⟨book⟩T is not.

r

Fig. 1. Representation of a library database

In the case of modal logics, different restrictions may be imposed on the accessibility relations, thereby obtaining different logics with several styles of sound and complete proof systems [21,28]. Here, no such restriction exists and thus one can see HML as an extension of the modal logic K. Moreover, HML allows one to express such restrictions inside the logic itself [9]. For example, reflexivity of the accessibility relation re is expressed by ↓x ⟨e⟩x.

Schemas capturing well-typed references
The main contribution of [8,7] is to introduce a notion of XML schema which pro- vides a simple and well-founded notion of reference typing. References are then first class citizen. The notion of schema introduced in [8] is fully general whether the notion of schema in [7], called here normalized ref-schema 6 is restricted. Moreover, in [8], we show how to translate a general schema into a normalized one. This allows us here, for the purpose of testing constraint satisfiability in presence of schema, to restrict the presentation to normalized ref-schema without loss of generality.
A normalized ref-schema is specified in a style very close to that used to specify DTD. We assume that V is a finite set of non-terminal symbols, containing the symbol Start, and Λ denoting the empty word. By convention, a non terminal
symbol starts with a capital letter while a label starts with a non-capital letter.

The set of labels E
is partitioned in two disjoint sets E and
−→
−→
E : labels in E are

called child labels whereas labels in E are called references. We use the following

6 A different terminology is used in [7] where normalized ref-schemas are called pattern schemas.

convention : e (resp. −→e , e˜) denotes a child label (resp. a reference, any label). For the sake of the presentation, we avoid to consider base types.
Definition 3.1 [Normalized Ref-schema] A normalized ref-schema G is given by (E , V, Start, θ) where the typing function θ associates to each non terminal symbol X a regular expression of the form:  R := B | R + R, and  B := Λ | (e˜X)op | B, B where op is either !, ∗ or +.
It is assumed that (1) in a conjunctive expression (B, B), each occurrence of an elementary pattern (e˜X) is unique and that (2) the typing function θ satisfies that:
(a) for each label e˜, type(e˜) is a singleton, where type(e˜) denotes the set of non terminals occuring in elementary pattern of the form e˜X, and (b) for each non

terminal X distinct from Start, Start ⇒∗
X holds where ⇒∗
is the transitive

closure of the relations ⇒e defined by X ⇒e Y if Y occurs in θ(X) in some pattern
(eY )op with e being a child label.
Example 3.2 Consider that (1) E contains the child labels doc, editor, name,
−→	−−−→ −−−→
article, book, author, title, isbn and (2) E contains the references pubA, pubB,
−−−→ −−−→ −−−→
citeA, citeB, pubby and (3) the non terminal symbols are Start, Editor, Doc, Art,
Book, Name, Isb. Below, the set of rules R defines a normalized ref-schema.
{	Start	::=	(doc Doc)∗, (editor Editor)∗

Editor	::=
! −−−→
∗  −−−→	∗

(name Name) , (pubB Book) , (pubA Art)
Doc	::=	(article Art)! + (book Book)!

Art	::=
+	!  −−−→
∗  −−−→ Book)∗

(author Name) , (title Name) , (citeA Art) , (citeB

Book	::=
!  −−−→
∗  −−−→ Book)∗ + (author Name)+,

(isbn Isb) , (citeA Art) , (citeB

! −−−→
∗  −−−→
∗  −−−→	!

(title Name) , (citeA Art) , (citeB Book) , (pubby Editor)
Name	::=	Λ	Isb ::= Λ }
Note that: (i) by condition (1) of the definition, it is not allowed to write a subex- pression such as (titleName)!, (titleName)+, (ii) the same non terminal symbol may be associated to different labels, for instance Name appears in (author Name)+ and (title Name)!; (iii) by condition (2a), a label (child label or reference) is always as- sociated to the very same non terminal symbol, for instance the child label author
−−−→

always appears in elementary pattern (authorName) and the reference
−−−→
citeB in

(citeBBook). Indeed, condition (1) can be relaxed as well as condition (2a) for
references (see [8] for a discussion).
Intuitively, if the elementary pattern (doc Doc)∗ matches a document at state s, then zero or more doc edges are leaving s. The expression (article Art)!+(book Book)!
says that exactly one article edge or else exactly one book edge has source s. The
+	!	−−−→	∗  −−−→	∗
conjunctive expression (author Name) , (title Name) , (citeA Art) , (citeB Book)
that defines the “type” Art enforces that at least one author edge, exactly one title
−−−→	−−−→
edge and possibly, some citeA and citeB references leave the state s.
Like for DTDs, normalized ref-schemas have the ability to specify recursive data

structures, like sequences or trees (see [7]). Expressions of the form (e1X1, ··· , ekXk)∗ are not allowed in normalized ref-schema but they are part of the definition of (gen- eral) ref-schema as defined in [8].
In [8,7] documents conforming to a schema G, also called instances of G, are defined as documents matching the expressions given by the schema. Here, for the sake of the presentation, we prefer to define an instance of G directly as a model of a
HML formula τG . The definition of an instance M of a schema G requires a first structural property, namely that the “subframe” of M generated by child labels is a tree. This property which is independent of the schema G is expressed by a HML formula tree not presented here (see [7]). Then in a modular manner, we associate a HML wff τexp to each expression of the schema as follows.
If exp is Λ then τexp is  e˜∈E ¬⟨e˜⟩T
If exp is of the form exp1 + ··· + expk then τexp is τexp1 ∨ ··· ∨ τexpk
If exp is of the form (e˜1X1)op1 , ··· , (e˜kXk)opk then
τexp is  i=1···k τi	∧	 e˜ not in exp ¬⟨e˜⟩T
where if opi is ! then τi = ↓x ⟨e˜i⟩↓y (@x[e˜i]y) if opi is ∗ then τi = T, and
if opi is + then τi = ⟨e˜i⟩T
Notation: First, type(e˜) is a singleton {X} where X is a non terminal symbol, thus we abusively write type(e˜) for X. We also use the notation τX instead of τθ(X) and thus when e is a child label, τtype(e) is the HML formula associated with
the regular expression θ(type(e)). When −→e is a reference, child(−→e ) denotes the
set {e | e ∈ E and type(e) = type(−→e )}. For instance, with our running example,
−−−→
type(author)= Name and child(citeA)= {article}.

Theorem 3.3 [7] Let G be a normalized ref-schema and let M be a model (docu- ment). The model M is conforming to G, denoted M : G, iff M,r |= τG where the
−→
HML wff τG = tree ∧ τ E ∧ τ E with:
G	G
τ E = @root τStart ∧  e∈E G∗[e]τtype(e)	and

−→
τ	=@ 
−→ G [ e ]↓x 
−→ @
F ⟨e⟩x  .


Intuitively, the wff τ E checks that, given a state x reachable by an e child edge, the outgoing edges (child edges as well as references) are the ones allowed by the
−→
schema. The wff τ E is concerned with reference type checking: it checks that the
targets of references have the rigth types.

Example 3.4 For the normalized ref-schema G of our running example, the formula
τ E is

@root (τStart ∧ G∗[editor]τEditor ∧ G∗[doc]τDoc ∧ G∗[article]τArt ∧ G∗[book]τBook ∧ G∗[name]τName ∧ G∗[author]τName ∧ G∗[title]τName  ∧ G∗[isbn]τIsb )
−→
and the formula τ E is

@root
−−−→
( [ G [citeA]↓x @
rootF
∗⟨article⟩x)  ] ∧	∗ −−−→ ↓x @
rootF
∗⟨book⟩x ]

−−−→
∧ [ G [pubA]↓x @rootF
∗⟨article⟩x  ] ∧	∗ −−−→ ↓x @	F
∗⟨book⟩x ]

−−−→
∧ [ G [pubby]↓x @
rootF
∗⟨editor⟩x  ])

For instance
τStart =def	 e˜∈E−{doc,editor} ¬⟨e˜⟩ T 
τName =def	 e˜∈E ¬⟨e˜⟩ T 
τEditor =def	↓x ⟨name⟩↓y (@x[name]y) ∧  e˜∈E−{name,−−→} ¬⟨e˜⟩ T 
τDoc =def	(↓x ⟨article⟩↓y @x[article]y ∧  e˜∈E−{article} ¬⟨e˜⟩ T)	∨
(↓x ⟨book⟩↓y @x[book]y ∧  e˜∈E−{book} ¬⟨e˜⟩ T)
Indeed, the document given in Figure 1 is a model of τG , thus an instance of the schema G.

Constraint satisfiability under non recursive schemas
In our framework, both schemas and constraints are HML wffs which advantageously entails that the problem “does a document M conforming to the schema G exist such that it satisﬁes the constraint C?” can be restated directly as ”is τG ∧C ﬁnitely satisﬁable?”. This section is devoted to the presentation of a tableau proof system for testing satisfiability of τG ∧ C. Obviously, the ultimate goal is to provide a terminating proof system. However, HML is not decidable in general [9,22]. Thus we choose to consider several restrictions and relax, in a first step, finiteness over models.
Here we consider non recursive normalized ref-schemas, that are schemas not defining a non terminal symbol X by an expression using directly or indirectly X itself. This restriction entails that, wrt accessibility relations associated with
child labels, the depth of any instance of τG is bounded. Unfortunately, this is not sufficient to entail that it is finite. The next example exhibits a schema G and a constraint C, such that τG ∧C does not have the finite model property. Although found independently, this example is strongly related to the query given in [19] to show that the non positive fragment with left-sibling axis of XPath does not have the finite model property.
Example 4.1 The schema is given by Start := (e End)∗ and End := (−→e End)∗
and the constraint is ψ1 ∧ ψ2 ∧ ψ3 ∧ ψ4 where:

ψ1 is ⟨e⟩↓y (⟨−→e ⟩y),	ψ2 is [e][−→e ]↓y (@root⟨e⟩↓z (¬y ∧ @y⟨−→e ⟩z)),
ψ3 is [e]↓x [−→e ][−→e ]↓y @x⟨−→e ⟩y,	ψ4 is [e]↓x [−→e ]↓y (@xy ∨ @y[−→e ]¬x).
Intuitively, the wff ψ1 forces the instance to contain at least one e edge followed by a (reflexive) −→e reference. The wff ψ2 forces to create a new reference edge starting from the target of an existing reference. This is the main reason of the infiniteness of all the models although it needs to be combined with the wffs ψ3 and ψ4, expressing respectively the transitivity and antisymmetry over −→e references. One model is given in Figure 2.

root









Fig. 2. Infinite model
The satisfiability problem considered next is the following :

In the rest of the presentation, we abusively use the term instance of a schema
G to designate a potentially infinite model of τG .
The tableau system
The tableau system defined below is geared to model building rather than refu- tation. This reversed use of tableau system is well-known [23]. Indeed the tableau system does not use directly the wff τG but rather the wffs τexpr as side effects of some of its rules. This has the advantage to make the rules for the modalities G
and F unnecessary as long as they are not allowed in the constraint C. Adding rules for these modalities is a subject of further study. Our tableau system is a prefixed tableau system: prefixes, here abusively called nominals 7 , are naming states and they are prefixing modal wffs. Roughly, the prefixed formula n : ϕ intends to cap- ture that during the proof, a state n has been created and that ϕ has to be satisfied at state n. This feature fits very well with modal logic [23,3,17] and particularly with HML [11]. Indeed, in a set of prefixed wffs Φ, the prefixed wffs of the form n :: ⟨e˜⟩m can be seen as (the frame of) a Kripke model; in other words, it means that, the tableau deduction for Φ builds Kripke models of Φ internally while check- ing its satisfiability. The reader should pay attention to the fact that, in order to

7 For obvious reasons, we prefer not to use the term label for prefix as done in the literature.

avoid ambiguity, we write n :: ⟨e˜⟩m when building a new ⟨e˜⟩ edge of a model and we write n : ⟨e˜⟩m when it has to be checked that there exists a ⟨e˜⟩ edge linking n and m.
We assume wlg that (1) the wff C is closed rectified: at most one binding ↓x occurs for each distinct state variable x and (2) it is in negation normal form: negation is only applied to propositions, nominals and state variables. The rules of the tableau system deal with sets of (generalized) prefixed formulas; each rule is dedicated to one formation rule and thus a (generalized) prefixed formula is distinguished in the denominator of the rule. The rules are partitioned in three groups: the propositional rules, the state variables and hybrid rules (these are the classical ones [11,12]) and finally the transition rules specified for the purpose of satisfiability checking in presence of non recursive schemas.

Propositional rules:	(α)
n : ϕ ∧ ψ,  Φ
n : ϕ,  n : ψ,  Φ
(β)
n : ϕ ∨ ψ,  Φ



State variable rule:	(Ref )
Φ


n : n,  Φ
if	n occurs in Φ



Hybrid rules :	(@) n : @mϕ, Φ m : ϕ, Φ
n : ↓x ϕ,  Φ
(↓ )
n : ϕ[x\n],  Φ

We now present the six transition rules. The ⟨E⟩-rule below considers a distin- guished prefixed wff of the form ⟨e⟩ϕ with e a child label. This choice rule is defined in the case where ϕ is not a nominal.:
the left part of the denominator propagates ϕ to an existing nominal (state) reachable by an existing e-edge,
the right part expands the “model” with a new nominal (state) m and a new e-edge from n to m and propagates ϕ to m. The schema constraint τG is locally enforced by introducing the prefixed wff m : τtype(e).


⟨E⟩
n : ⟨e⟩ϕ,  Φ



The next ⟨En⟩-rule deals with the case where the formula ϕ is a nominal:

⟨En
⟩	n : ⟨e⟩m, Φ Φ
for n :: ⟨e⟩m ∈ Φ

The
−→
⟨ E ⟩-rule below considers a distinguished prefixed wff of the form ⟨ e ⟩ϕ with

−→e a reference. This choice rule is defined in the case where ϕ is not a nominal n:
the left part of the denominator is similar to that of the ⟨E⟩-rule;

the center part creates a new −→e -reference from n to an existing state m while the condition f ∈ child(−→e ) ensures that m is well-typed, in other word it is meant to check that m is a valid target for a −→e -reference;
the right part creates a new −→e -reference edge leading to a new nominal (state)
m. The wff π(−→e , m) defined below enforces that m is linked to the root of the “model” by a well-typed path of child edges.
π(−→e , m) =def  e∈child(−→e )( ph∈P ath(e) ph m)
where Path(e) is the set of ”modal” paths ⟨e1⟩··· ⟨en⟩ such that Start ⇒e1
G
X1,... , ⇒en Xn holds wrt the ref-schema G and with en = e.
G	−−−→
For instance, for our running example, π(pubA, m) is ⟨doc⟩⟨article⟩m.
Introducing this wff π(−→e , m) is one of the important features of our system: it entails that a dandling state is never introduced. Indeed, it is worth noticing that writing this formula is only possible because the schema G is non recursive.


−→
⟨ E ⟩

m : ϕ, Φ
for n :: ⟨−→e ⟩m ∈ Φ
n : ⟨−→e ⟩ϕ,  Φ
n :: ⟨−→e ⟩m, m : ϕ, Φ

for p :: ⟨f ⟩m ∈ Φ and f ∈ child(−→e )

root : π(−→e , m), m : ϕ, n :: ⟨−→e ⟩m, Φ
for a new m and
π(−→e , m) defined above

The next
−→
⟨ En
⟩-rule takes care of the case where ϕ is a nominal.

−→
⟨ En⟩
n : ⟨−→e ⟩m,  Φ
Φ
n :: ⟨−→e ⟩m, Φ

for n :: ⟨−→e ⟩m ∈ Φ
for p :: ⟨f ⟩m ∈ Φ and f ∈ child(−→e )

The next two rules deal with the [e˜] modality.
The [E]-rule considers a distinguished prefixed formula of the form [e˜]ϕ with e˜ being any label. It generates an initial generalized prefixed formula further used to control that ϕ is propagated to all e˜-successors of n. A generalized prefix formula is of the form n : ([e˜]ϕ, Δ) where Δ stores the e˜ successors of n over which the formula ϕ has already been propagated.
The (Y )-rule processes new e˜-successors of n by propagating ϕ in order to enforce [e˜]ϕ at state n.


[E]
n : [e˜]ϕ, Φ
(Y )
n : ([e˜]ϕ, ∅), Φ
n : ([e˜]ϕ, Δ), Φ
{m : ϕ | m ∈ Δ'}, n : ([e˜]ϕ, Δ ∪ Δ'), Φ for Δ' = {m|n :: ⟨e˜⟩m ∈ Φ}− Δ

Systematic construction of a G-tableau T for C
A G-tableau T for C is a proof tree, each branch corresponding to an attempt to build an instance of G satisfying C, hence a model of τG ∧ C. The systematic

construction follows more or less a breath-first traversal strategy with some priority over rule applications.
Stage 1 : Put the prefixed formula root : τStart ΛC at the root of the tableau. Stage i + 1 : Choose a leaf node L of the tableau under construction as close as possible to the root of the tableau. Assume that L contains a set Φ of (generalized) prefixed formulas.
If possible, choose a prefixed formula n : ϕ in Φ in order to apply one of the tableau
rules other than the (Y) one with the following priority : (1) propositional rules,

state variable rule, hybrid rules, (2) ⟨E⟩ rules, (3)
—→
⟨ E ⟩ rules, (4) S and expand L by

applying the corresponding rule with respect to n : ϕ in all manners, meaning that if the rule is a choice rule, each possible application of the rule is developed, each one leading to create a new descendant for L containing the appropriate prefixed formulas.
Otherwise, apply “simultaneously” the (Y) rule to all possible generalized prefix formulas in Φ.
Proposition 4.2 (Fairness) If a (generalized) prefixed formula n : ϕ belongs to some leaf L of the tableau under construction at stage i, then it will become the distinguished formula at some later step of the systematic construction.
Note that the systematic tableau construction may go on ad infinitum : the tableau constructed for the schema G and constraint C of Example 4.1 is infinite.
Definition 4.3 [Open/Closed G-Tableau] A G-tableau T for the constraint C is a (potentially infinite) tree constructed as described above. A branch 8 У is closed iff one of its nodes contains both prefixed wffs of the form n : ϕ and n : чϕ, or some statement n : m for n /= m. A branch is open if it is not closed and the tableau T is open iff one of its branches is open (otherwise it is closed).

Soundness and completness of the tableau system
Due to space limitation, the proofs of soundness and completness of the tableau system are sketched below. The proofs rest on the notion of G-Hintikka set whose definition follows the line of and extends the one in [11]. Intuitively, a G-Hintikka set is a potentially infinite set of prefixed formulas characterizing some model of τG and thus in the proofs, G-Hintikka sets bridge the gap between open branches of a G-tableau T and models (potentially infinite instances of G) of τG.
Definition 4.4 [G-Hintikka sets] Let G be a schema. A potentially inﬁnite set of prefixed formulas H is called a G-Hintikka set iff it satisfies the following conditions:
for each atom α and each nominal n, if n : α ∈ H then n : чα /∈ H, and conversely
for each nominal n occuring in H, n : n ∈ H,
for each pair of nominals n and m such that n /= m, n : m /∈ H,

8 A branch of T is any path from the root downwards in the proof tree.

(Tree condition) if n :: ⟨e⟩m ∈ H then for each n', e' we have n' :: ⟨e'⟩m ∈ H
implies n' = n and e' = e;
(Unique root) there exists exactly one nominal denoted root, such that for each
m :: ⟨e⟩n ∈ H, we have n /= root, and root : τStart ∈ H;
(Schema enforcement for child labels) if n :: ⟨e⟩m ∈ H then m : τtype(e) belongs to H,
(Schema enforcement for references) if n :: ⟨—→e ⟩m ∈ H then there exists n' and
f ∈ Child(—→e ) such that n' :: ⟨f ⟩m,
if n : ⟨e˜⟩ϕ ∈ H then there exists at least one nominal m such that n : ⟨e˜⟩m ∈ H
and m : ϕ ∈ H,
if n : [e˜]ϕ ∈ H then for each m ∈ {m' | n :: ⟨e˜⟩m' ∈ H}, we have m : ϕ ∈ H.
if n : ϕ Λ φ ∈ H then n : ϕ ∈ H and n : φ ∈ H,
if n : ϕ ∨ φ ∈ H then either n : ϕ ∈ H or n : φ ∈ H or both,
if n : @mϕ ∈ H then m : ϕ ∈ H
if n : ↓x ϕ ∈ H then n : ϕ[x/n] ∈ H
Next, N om(H) denotes the set of prefixes (nominals) n occurring in H. A model is associated to a G-Hintikka set in the obvious manner:
Definition 4.5 Let H be a G-Hintikka set. Then MH=(N om(H), root, R, IP , Inom) is the HML model associated to H where each accessibility relation re˜ in R is defined by {(n, m) | n :: ⟨e˜⟩m ∈ H}, IP (p)= {n | n : p ∈ H}, and Inom(root)= root.
The next lemma simply states that the model associated to a G-Hintikka set satisfies each prefixed formula in H and is a (potentially infinite) instance of G.
Lemma 4.6 Let G be a schema. Let H be a G-Hintikka set. Then :
if n : ϕ ∈ H then MH,n |= ϕ.
MH , root |= τG
For each m ∈ N om(H) — {root}, we have MH, root |= ( ph∈P ath(e) ph m) where Path(e) is defined as before for a child label e.
The proof of Lemma 4.6 is done by induction.
We now establish the dual of Lemma 4.6 stating that, from a model M which is a (potentially infinite) instance of G and satisfies a modal formula C at its root, it is possible to build a G-Hintikka set.
Lemma 4.7 Let M (assuming IN (root) = r as usual) be an instance of G such that M,r |= C where C is a HML constraint. Then there exists a G-Hintikka set H such that MH=M.
Proof (Sketch) The central idea of the proof is to define an inflationary operator T over sets of prefixed formulas. Intuitively the operator T is defined by making use of the items 4, 6, 7, 8 and 9 of Definition 4.4 as “production” rules guarded by the model M. The operator T is used to build an inflationary sequence Fi(i≥0 ) of

prefixed formulas such that Fi ⊆ Fi+1. Because of the finite subformula property, there exists k such that for i ≥ k, Fi = Fk. By construction, it is easy to show that Fk is a G-Hintikka set such that its induced model MFk is the model M of τG Λ C. 
We are now ready to prove that our tableau system is sound which is stated by:
Theorem 4.8 (Soundness) Let T be a G-tableau build for C. If У is an open branch of T then HB is a G-Hintikka that satisfies C where HB is the set of all prefixed formulas occuring in the branch У.
Proof (Sketch) Assuming that У is an open branch of a G-tableau T for C, it is sufficient to show that the set of prefixed wffs HB is a G-Hintikka set. Indeed, this entails that the induced model of HB satisfies τG Λ C, by Lemma 4.6 since root : C ∈ HB. To this end, assume that HB is not a G-Hintikka set. Then this means that one of the items of definition 4.4 is violated. The proof is then developed by a simple case study.	 
We now turn to proving that the tableau system is complete which is stated by:
Theorem 4.9 (Completness) If there exists an instance M of G satisfying the constraint C (i.e. such that M,r |= C) then the G-tableau T for C is open.
We need the following intermediate results. The first one states that adding to a G-Hintikka set some prefixed “path” formula “satisfied” by MH , leads to a G-Hintikka set.
Lemma 4.10 If H is a G-Hintikka set then H+ deﬁned below is a G-Hintikka such that MH = MH+ .
H+ = H ∪ {(n0 : ⟨e1⟩⟨e2⟩ ... ⟨ek⟩nk+1) | (ni :: ⟨ei+1⟩ni+1) ∈ H for  i = 0 ... k}
Now, we show that the G-Hintikka set associated with M denoted HM can be used as a guide to “build” (or identify) an open branch У of T . Of course, the G- Hintikka set HB associated to the open branch У and build using HM as a guide, is not necessarily equal to HM. Given a proof segment P (which is specified by a path from the root of T to some proof node), HP denotes the set of all prefixed formulas occuring in P excluding the generalized ones. The set of nominals occuring in HP is denoted N om(P).
An embedding of  the proof segment P in a model M is a mapping μ from
N om(P) to N om(H+ ) such that μ is total, injective, and μ(HP ) ⊆ H+ , where
M	M
μ(HP ) is defined in the natural way. Note that, for the purpose of the proof and
precisely to deal with π(⟨—→e ⟩	—→

we use here the G-Hintikka set H+
rather than HM.

A proof segment P is said to be a pre-model of M if there exists at least one embedding function of the proof segment P in the model M. An extension of a proof segment P is a segment having P as a prefix.
In order to prove the completeness theorem above we need to show that if the proof segment P is a pre-model of M and P is not a branch (i.e. a saturated

segment) then it can be extended (by the systematic construction strategy) and at least one of the extensions of the proof segment P is a pre-model of M. Formally:
Lemma 4.11 Given a schema G and a constraint C. Let M be an instance (may be an infinite one) of G satisfying the constraint C (i.e. M,r |= τG Λ C). Let T be a G-tableau for C and P a proof segment of T . We have:
If P is a pre-model of M then either P is a branch (saturated segment) or there exists at least one extension of P which is a pre-model of M.

Proof (Sketch) Assume that the proof node P is the extremity of segment P. Use the priority rule to expand the proof node P . From the definition of G-Hintikka sets, it is easy to show that the extension of P is a pre-model of M when P is expanded by applying one of the rules (α) or (β) or (@) or (↓ ) or (S )or (Y ). The other possible rule applications need to be studied more carrefully but do not present any difficulty.	 
Proof (Theorem 4.9) Lemma 4.11 entails completness of our tableau system as follows: if τG ΛC is satisfiable and M is one of its HML model then, root : τG ΛC is the root of any G-tableau T for C and it is of course a pre-model of M; thus Lemma
4.11 entails that there exists an open branch in T ; hence T is open, which concludes the proof.	 

Discussion and further research direction
This section is devoted to discuss some of the restrictions made in the presentation. First, the tableau system is presented for (non recursive) normalized ref-schemas.
In [8], we show how a general ref-schema (allowing full regular expressions) can be equivalently translated by a normalized ref-schema together with a set of structural constraints expressed by HML formulas. This implies that the tableau system can be used for checking constraints satisfiability in presence of general (non recursive) ref-schemas although a slight extension need to be done in order to deal with the modality G used in the structural constraints.
We now discuss the absence of the modalities F and G in the constraint ex- pressions. The tableau system can be extended to integrate these modalities. The extension is quite obvious for F and G restricted to child labels because we can utilize the fact that the schemas are non recursive. However a carefull writting of the rules for F and G in the general case is required in order to control potential “loops”: roughly, attempting to check the satisfiabiliy of n : Fϕ may lead, after several steps to check again for the satisfiability of n : F ϕ. The idea is to design the rules in a way similar to what has been done here for the [e˜] modality.
We now turn to the main limitation of the tableau system presented in the pa- per: it is sound and complete for checking satisfiability, but not ﬁnite satisfiability which is of course the relevant notion for XML databases. As usual, two directions of investigation are possible: (1) the syntaxic approach leads to exhibit conditions over the constraint C in order to ensure the finite satisfiability, (2) the second direc-

tion is more “proof” oriented and involves enreaching the tableau system itself in order to prune infinite open branches. We are currently investigating a combined approach. Indeed, non recursive ref-schemas are not sufficicient to ensure decidabil- ity: the tiling problem can be encoded in our framework very easily. Thus syntactic restrictions over constraints are mandatory. We are currently investigating such restrictions which slightly relax those given in [16] 9 and take care of multimodality which is also a source of undecidability [27] 10 . These restrictions still allow one to write constraints having infinite models and thus we are currently modifying our tableau system in order to introduce a check for potentially infinite branches based on some kind of bissimulation property over pairs of sets of prefixed formulas.

References
Alechina N., “Semi-structured information: a modal logic approach“, Tech. Report CSR-97-08, School of Computer Science, The University of Birmingham, 1997.
Alechina N., Demri S., De Rijke M., “A Modal Perspective on Path Constraints“, J. Log. Comput. 13(6), 2003, p. 939–956.
Areces C., Blackburn P., Marx M., “Hybrid Logics: Characterization, Interpolation and Complexity“,
J. of Symbolic Logic, Vol. 66, Num. 3, 2001, p. 977–1010.
Areces C., Blackburn P., Marx M., “A Road-map on Complexity for Hybrid Logics“, Proc. of the 8th Annual Conf. of the EACSL, Madrid, LNCS, Springer, 1999, p. 307–321.
Arenas M., Fan W. , Libkin L., “Consistency of XML Specifications“, Inconsistency Tolerance, 2005,
p. 15–41.
Benedikt M., Fan W., Geerts F., “ XPath satisfiability in the presence of DTDs.“, Proc. of the Twenty-fourth ACM SIGACT- SIGMOD-SIGART Symp. on Principles of Database Systems, 2005, p. 25-36.
Bidoit N., Cerrito S., Thion V., “ A first step towards modeling semistructured data in hybrid multimodal logic “, J. of Applied Non-Classical Logics, Vol. 14, Num. 4, 2004, p. 447–476.
Bidoit N., Colazzo D., “XML schemas capturing references“, BDA 2006.
Blackburn P., Seligman J., “Hybrid Languages“, J. of Logic, Language and Information, Vol. 4, 1995,
p. 251–272.
Blackburn P., “Representation, Reasoning, and Relational Structures: a Hybrid Logic Manifesto“, Logic
J. of the IGPL, Vol. 8, Num. 3, 2000, p. 339–365.
Blackburn P., “Internalizing labelled deduction“, Journal of Logic and Computation, Vol. 10, Num. 1, 2000, p. 137-168.
Blackburn P., Marx M., “Tableaux for Quantified Hybrid Logic“, Proc. Int. Conf. on Automated Reasoning with Analytic Tableaux and Related Methods, 2002, p. 38-52.
Bojanczyk M. David C. Muscholl A. Schwentick Th. , Segoufin L., “Two-variable logic on data trees and XML reasoning“, PODS, 2006, p. 10–19.
Calvanese D., De Giacomo G. , Lenzerini M., “Representing and Reasoning on XML Documents: A Description Logic Approach.“, J. Log. Comput. 9(3), 1999, p. 295–318.
Cardelli L. , Ghelli G., “A Query Language Based on the Ambient Logic“, ESOP, 2001, p. 1–22.
ten Cate B. , Franceschet M. “On the Complexity of Hybrid Logics with Binders“, CSL, 2005, p. 339-354.
De Giacomo G., Massacci F., “Combining Deduction and Model Checking into Tableaux and Algorithms f or Converse-PDL“, J. of Information and Computation, Vol. 162, Num. 1-2, 2000, p. 117-137.

9 [16] show that the source of undecidability is the []↓ [] pattern.
10 Note that the encoding of the tiling problem provided in [16] uses three accessibility relations.

Demri S., “(Modal) Logics for Semistructured Data“, Invited talk at “Third Workshop on Methods for Modalities (M4M-3)”, 2003.
Fan W., Geerts F., “Satisfiability of XPath Queries with Sibling Axes“,	Database Programming Languages, 10th Int. Symp. Vol. 3774 of LNCS, 2005, p. 122-137.
Fan W. , Sim´eon J., “Integrity Constraints for XML“, PODS, 2000, p. 23–34.
Fitting M., Proof Methods for Modal and Intuitionist Logic, D.Reidel Publishing Company, 1983.
Goranko V. “Hierarchies of Modal and Temporal Logics with Reference Pointers“, Journal of Logic, Language and Information Vol. 5 Num. 1, 1996, p. 1–24.
Gore R., “Tableau methods for modal and temporal logics“, ReportNum.TR-ARP-15-95 Australian National University, 1995.
Kripke S., “Semantic Considerations on Modal Logic“, Linski L., Ed., Reference and Modality, London, 1971, Oxford University Press, p. 63-72.
Marx M. “XPath and Modal Logics of Finite DAG’s“, TABLEAUX, 2003, p. 150–164.
Murata M. , Lee D. , Mani M., “Taxonomy of XML Schema Languages Using Formal Language Theory“, Proc. of the Extreme Markup Languages Conference, 2001.
Mundhenk M. , Schneider T., “ Undecidability of Multi-modal Hybrid Logics“, Hylo, LICS 2006 Workshop
Wallen L. A., Automated Deduction in Nonclassical Logics: Efficient Matrix Proof Methods for Modal and Intuitionistic Logics, MIT Press, 1990.
“XML Schema“, On http://www.w3.org/TR/xmlschema-0/ , W3C Recommendation.
