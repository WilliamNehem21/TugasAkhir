Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 339 (2018) 111–134
www.elsevier.com/locate/entcs
Dioids for Computational Effects
Ezequiel Postan
DCC–ECEN
Facultad de Cs. Exactas, Ingenier´ıa y Agrimensura Universidad Nacional de Rosario
Rosario, Argentina
Exequiel Rivas and Mauro Jaskelioff
DCC–ECEN
Facultad de Cs. Exactas, Ingenier´ıa y Agrimensura Universidad Nacional de Rosario
and CIFASIS–CONICET
Rosario, Argentina

Abstract
There are different algebraic structures that one can use to model notions of computation. The most well- known are monads, but lately, applicative functors have been gaining popularity. These two structures can be understood as instances of the unifying notion of monoid in a monoidal category. When dealing with non-determinism, it is usual to extend monads and applicative functors with additional structure. However, depending on the desired non-determinism, there are different options of interaction between the existing and the additional structure. This article studies one of those options, which is captured algebraically by dioids. We generalise dioids to dioid categories and show how dioids in such a category model non- determinism in monads and applicative functors. Moreover, we study the construction of free dioids in a programming context.
Keywords: dioid, monad, Haskell, computational effect

Introduction
Algebraic structures have been central to the modelling of computational effects. For example, monads [12,13,21,17] have been used to model many computational effects such as global state, exceptions, environments, input/output, and continuations. More recently, applicative functors [11] are becoming popular in diverse applications such as modelling parsers [18], characterising traversals [4,7], and in combination with monads to obtain concurrent queries [10].
While monads and applicative functors are two different algebraic structures, they have a unified framework. Rivas and Jaskelioff [14] have shown that both of them can be seen as instances of a same unifying concept: monoids in a monoidal

https://doi.org/10.1016/j.entcs.2018.06.008
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

category [9]. This unification of concepts is extremely useful, as it allows us to translate concepts, properties, and techniques from one structure to the other. For example, through the unified framework, an old optimisation technique for lists [6] is shown to be essentially the same as a newer one for monads [20], and led to the discovery of a new one for applicative functors [14] by means of a simple translation. In many applications of monads and applicative functors one has to deal with non-determinism. There are different flavours of non-determinism [19], but in func- tional programming the most common are deep backtracking and shallow backtrack- ing [16]. When modelling deep backtracking, the algebraic structure that arises is near-semirings. This insight lead to a unified framework for deep-backtracking non- determinism in monads and applicative functors [15]. If, on the other hand, one wants to model shallow backtracking, then one arrives at the algebraic structure of
dioids [5].
This article studies the shallow-backtracking variant of non-determinism by studying the categories that support the definition of dioids, namely dioid cate- gories. Working at this level of abstraction allows us to obtain a unified model of shallow-backtracking non-determinism for both monads and applicative functors. Moreover, we study the construction of free dioids. Intuitively, free dioids can be thought of as the programs that can be written when only the dioid interface is exposed, and therefore provide a canonical representation for programs structured as a computation with shallow-backtracking non-determinism.
The article is structured as follows: In Section 2 we introduce monoids and monoidal categories, and show how they provide a unified framework to study the notions of monads and applicative functors. In Section 3, we introduce dioids and dioid categories. Moreover, we show how these categories provide a unified frame- work to study shallow non-determinism in monads and applicative functors. In Section 4, we turn to the construction of free dioids. We provide a formula that allows to construct dioids on Set (the category of sets and functions) and to con- struct the free dioid applicative. Unfortunately, it does not allow us to express the free dioid monad. Finally, in Section 5, we conclude.
In the rest of this article, unless we explicitly say otherwise, when we write non-determinism we mean shallow-backtracking non-determinism.

Monoids
We start by studying monoids and its generalisation: monoids in monoidal cate- gories. In order to keep the ideas close to programming practice, we express the different concrete constructions in an idealised functional programming language with syntax inspired by Haskell.

Monoids in Programming
In functional languages, such as Haskell, algebraic structures may be implemented using type classes. For example, for monoids we may declare:

class Monoid m where u	∶∶	()	→ m (⊗) ∶∶ m × m → m
which means that a type m is a monoid whenever it is equipped with a chosen binary operation ⊗ (the multiplication) and a nullary operation u (the unit ). Instances of this class are expected to satisfy the monoid laws
a ⊗(u ()) = a	(1)
(u ()) ⊗ a = a	(2)
a ⊗(b ⊗ c)= (a ⊗ b)⊗ c	(3)
which state that ⊗ is associative, and that u is a right and left unit for it. For example, we may declare that the type Integer of arbitrary-precision integers is a monoid of addition and zero:
instance Monoid Integer where
u () = 0
x ⊗ y = x + y
Another important example is the monoid of endofunctions over a type a. With- out mathematical jargon, they are just functions from a to a with composition as multiplication and the identity function as unit.
data Endo a where
Endo ∶∶ (a → a)→ Endo a
instance Monoid (Endo a) where
u ()	= Endo id
(Endo f ) ⊗(Endo g )= Endo (f ○ g )

When studying an algebraic structure, an important concept is that of homo- morphism: structure-preserving maps between instances of the algebraic structure. In the case of monoids, they are defined as follows: let M1 and M2 be instances of Monoid. A monoid homomorphism is a function f ∶∶ M1 → M2 such that the monoid instances are preserved:
f (u ()) = u ()
f (a ⊗ b)= f a ⊗ f b 
The type of f determines that the operations u and ⊗ on the left-hand side come from the Monoid instance of M1, while those on the right-hand side come from the Monoid instance of M2.
For example, the following is a monoid homomorphism from the Monoid instance
Integer to the Monoid instance Endo Integer.

rep ∶∶ Integer → Endo Integer rep x = Endo (λy → x + y )

We want to program with algebraic structures such as Monoid above, but we may also want to generalise from types to types constructors, and from the Carte- sian product × to other ways of putting two things together. The appropriate generalisation is the notion of monoid in a monoidal category.

Categoriﬁcation
Monoidal categories generalise the notion of monoids to categories C.
Definition 2.1 A monoidal category is a sextuple (C, ⊗,I, α, λ, ρ), where:
C is a category;
⊗∶C × C → C is a bifunctor;
I is an object of C;
The bifunctor ⊗ and I generalise × and () in the code above.
α, λ, and ρ are natural isomorphisms:
α ∶ A ⊗ (B ⊗ C)≅ (A ⊗ B)⊗ C λ ∶ I ⊗ A ≅ A
ρ ∶ A ⊗ I ≅ A
All these natural transformations should obey coherence laws [9]. Given a monoidal category, we can define the notion of a monoid in it.
Definition 2.2 A monoid in a monoidal category is an object M , together with operations e ∶ I → M and m ∶ M ⊗ M → M , for which the following laws hold:
m ○ (e ⊗ id)= λ	(4)
m ○ (id ⊗ e)= ρ	(5)
m ○ (id ⊗ m)= m ○ (m ⊗ id)○ α	(6)
The laws for monoids in monoidal categories are the corresponding generalisa- tions of equations (1), (2), and (3).
For example, the category Set of sets and functions is a monoidal category with the Cartesian product as its tensor, and singleton sets as unit object, and monoids in this monoidal category reduce to ordinary monoids.

Functors
In this article we are mainly interested in the category of endofunctors and natural transformations. Endofunctors are type constructors that can map a function on the underlying type. For example, lists are functors since

given a type, say Integer, they construct a type of list of Integers;
given a function, say from Integers to Booleans, they can apply the function to every Integer to obtain a list of Booleans.
More precisely, a functor is an instance of the following class
class Functor f where
fmap ∶∶ (a → b)→ f a → f b 
where the laws fmap id = id, and fmap (f ○ g )= fmap f ○ fmap g hold.
For example, the identity type constructor is a functor.
data Identity where
Id ∶∶ a → Identity a
instance Functor Identity where
fmap f (Id a)= Id (f a)
Furthermore, the composition of two functors is a functor.
data (f ○ g ) a where
Comp ∶∶ f (g a)→ (f ○ g ) a
instance (Functor f , Functor g )⇒ Functor (f ○ g ) where
fmap f (Comp x )= Comp (fmap (fmap f ) x )
In this instance, to the left of the ⇒ symbol, we note the requirement that f and g
must be functors.
Natural transformations are functions between functors which are polymorphic on the underlying type [1].
type (f → g )= ∀x . f x → gx 
As a last functor example, we consider the Maybe data type constructor. This functor is commonly used to represent either a value or a failure, and it is sometimes known as Option.
data Maybe a where Nothing ∶∶ Maybe a Just	∶∶ a → Maybe a
The functor instance simply maps a function if we have a value, or it does nothing otherwise.
instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x )= Just (f x )

Monads
The category of endofunctors and natural transformations can be given a monoidal structure by choosing the tensor ⊗ to be the composition of functors ○, and the object I to be the identity functor Identity. This monoidal category is strict, which means that the three natural transformations λ, ρ, and α, which complete the monoidal category, are identities.
The monoids in this monoidal category are functors m with operations e and
⋅	⋅
m of type Identity → m, and m ○ m → m respectively. Expanding the definitions of
natural transformation, identity functor, and functor composition, and renaming e
to η and m to μ, we arrive at the following type class:
class Functor m ⇒ Triple m where
η ∶∶ a → ma 
μ ∶∶ m (m a)→ ma 
and the general monoid laws (4), (5), and (6) become:
μ ○ η = id
μ ○ fmap η = id
μ ○ fmap μ = μ ○ μ

A monoid in the monoidal category with functor composition as tensor is none other than a monad. Monads have other presentations. For example, in Haskell, monads are defined as:
class Monad m where
return ∶∶ a → ma 
(>=)	∶∶ ma → (a → m b)→ mb 
subject to some laws which correspond to the laws above under the following equiv- alence. The classes Triple and Monad can be seen to be equivalent by noting that η = return, that μ can be defined as μ x = (x >= id), and that (>=) can be defined as (x >= k )= μ (fmap k x ). Notice that Monad m does not require the type constructor m to be a functor: the fmap operation is derivable from the Monad instance by defining fmap f v = (v >= return ○ f ).
Remark 2.3 The function (>=) in the Monad class does not take two arguments; instead it takes only one argument and returns a function which takes the other argument and finally delivers the result. Writing functions in this style is equivalent to writing functions with two arguments, as the following conversion functions show:
curry ∶∶ (a × b → c)→ (a → b → c)
curry f a b = f (a, b)
uncurry ∶∶ (a → b → c)→ (a × b → c)
uncurry f (a, b)= f a b

In the rest of the presentation we use two argument functions or their curried form indistinctly.
Both lists and Maybe are functors which are also Monad instances. We provide the instance for Maybe, which will be one of our main examples.
instance Monad Maybe where return x	= Just x Nothing >= f = Nothing (Just x ) >= f = f x 
The category of endofunctors can be given other monoidal structures, and there- fore monads are not the only monoids in the category of endofunctors. Another im- portant class are applicative functors, introduced by McBride and Paterson [11] as a way to capture certain effectful computations that do not fit well in the monadic framework.

Applicative functors
Applicative functors are based on a category of endofunctors, but with different tensor than monads: the Day convolution [3]. The Day convolution may be imple- mented as follows:
data (⋆) f g a where
Day ∶∶ f (b → a)× (g b)→ (f ⋆ g ) a
instance (Functor f , Functor g )⇒ Functor (f ⋆ g ) where
fmap h (Day ff gx )= Day (fmap (λf → h ○ f ) ff ) gx
Just like for composition of functors (○), the I object for Day convolution is the identity functor. However, in this case the monoidal category is not strict. The isomorphisms λ, ρ and α for this monoidal category are as follows (we give only one direction of each isomorphism).
λ ∶∶ Functor f ⇒ (Identity ⋆ f ) a → f a 
λ (Day (Identity f ) x )= fmap f x 
ρ ∶∶ Functor f ⇒ (f ⋆ Identity) a → f a 
ρ (Day f (Identity b)) = fmap (λh → h b) f
α ∶∶ (Functor f , Functor g )⇒ 
(f ⋆ (g ⋆ h)) a → ((f ⋆ g )⋆ h) a
α (Day f (Day g z )) = Day (Day (fmap (○) f ) g ) z
The monoids in this monoidal category are functors f with operations e and
m of type Identity → f , and f ⋆ f → f respectively. Expanding the definitions of
natural transformation, identity functor, and Day convolution, and renaming e to
pure and m to ⊛, we arrive at the following type class:

class Functor f ⇒ Applicative f where
pure ∶∶ a → f a 
(⊛) ∶∶ f (b → a)× f b → f a 
Instantiating the general monoid laws (4), (5), and (6) to this monoidal category, we obtain the applicative laws:
pure f ⊛ u = fmap f u 
u ⊛ pure x = fmap (λh → h x ) u
(fmap (○) u ⊛ v )⊛ w = u ⊛ (v ⊛ w )

By generalising monoids to monoids in monoidal categories, we were able to show that two different structures used in programming are instances of the same abstract construction.
Remark 2.4 Monad and Applicative type classes are not totally independent: every instance of the former is an instance of the latter, as it is reflected in the next code.
instance Monad m ⇒ Applicative m where
pure x = return x
u ⊛ v = u >= λf → v >= λx → return (f x )

Therefore every Monad determines an Applicative, but not the other way. As an example of an Applicative which is not a Monad, consider the constant functor on a monoid:
data K x a where
MK ∶∶ x → K x a 
instance Functor (K x ) where
fmap f (MK x )= MK x
instance Monoid x ⇒ Applicative (K x ) where
pure a	= MK u
(MK x )⊛ (MK y )= MK (x ⊗ y )


Dioids
We extend the notion of monoids in order to account for non-determinism. More precisely, we introduce dioids, which extend monoids with additional monoid oper- ations, which we denote with ⊕ and z. Whereas the multiplicative monoid gives a model of sequencing, the ⊕ operation models a non-deterministic choice, and mod- els z the absence of choice. What makes this structure a good model for shallow- backtracking non-determinism, and what differentiates it from other models, is its interaction with the existing monoid structure.

Set dioids
Dioids are an algebraic structure, so we might declare them as a type class, just like we did with monoids:
class Dioid d where
z  ∶∶ () → d u ∶∶ () → d (⊕) ∶∶ d × d → d (⊗) ∶∶ d × d → d
This time, we expect the following laws to be satisfied:
a ⊗(u ()) = a	(7)
(u ()) ⊗ a = a	(8)
a ⊗(b ⊗ c)= (a ⊗ b)⊗ c	(9)
a ⊕(z ()) = a	(10)
(z ()) ⊕ a = a	(11)
a ⊕(b ⊕ c)= (a ⊕ b)⊕ c	(12)
(z ()) ⊗ a = z ()	(13)
(u ()) ⊕ a = u ()	(14)
The laws 7 to 12 express that d is a monoid with respect to (⊗, u) and (⊕, z). Laws 13 and 14 relate these (otherwise independent) monoid structures, by saying that the unit of one is left absorbent of the other. Because of this left-bias, we might call these left dioids instead of just dioids.
Every bounded distributive lattice is a dioid for which (⊗) commutes, perhaps the most classical example is Bool. The following is an instance in which (⊗) does not commute:
type BinFun a = a × a → a
instance Dioid (BinFun a) where
z	= λ(a, b)→ a
u	= λ(a, b)→ b
f ⊕ g = λ(a, b)→ f (g (a, b), b)
f ⊗ g = λ(a, b)→ f (a, g (a, b))

In models of deep-backtracking non-determinism, law 14 is replaced by a distri- bution.
(a ⊕ b)⊗ c = (a ⊗ c) ⊕(b ⊗ c)
This makes the structure a near-semiring. See the work of Rivas, Jaskelioff and Schrijvers [15] for details. In this case it is possible to explore different results, whereas in the shallow case, we explore possible results in order only until one is found.

Let D1 and D2 be instances of Dioid.  A dioid homomorphism is a function
f ∶∶ D1 → D2 such that the dioid instances are preserved:
f (u ()) = u ()
f (z ()) = z ()
f (a ⊗ b)= f a ⊗ f b f (a ⊕ b)= f a ⊕ f b 
The type of f determines that the operations u, z, ⊗, and ⊕ on the left-hand side come from the Dioid instance of D1, while those on the right-hand side come from the Dioid instance of D2.
Categoriﬁcation
Just as monoidal categories provide the right setting to express the notion of monoid in full generality, we now look for the analogous categorical structure to express the notion of dioid.
Definition 3.1 A dioid category is a tuple (C, ⊗,I, α⊗, λ⊗, ρ⊗, ⊕, Z, α⊕, λ⊕, ρ⊕, κ⊗, κ⊕)
where:
C is a category;
⊗∶C × C → C and ⊕∶C × C → C are bifunctors;
I and Z are objects of C;
α⊗, λ⊗, ρ⊗, α⊕, λ⊕, and ρ⊕ are natural isomorphisms:
α⊗ ∶ A ⊗ (B ⊗ C)≅ (A ⊗ B)⊗ C λ⊗ ∶ I ⊗ A ≅ A
ρ⊗ ∶ A ⊗ I ≅ A
α⊕ ∶ A ⊕ (B ⊕ C)≅ (A ⊕ B)⊕ C λ⊕ ∶ Z ⊕ A ≅ A
ρ⊕ ∶ A ⊕ Z ≅ A
κ⊗ and κ⊕ are natural transformations:
κ⊗ ∶ Z ⊗ A → Z κ⊕ ∶ I ⊕ A → I
Again, we expect these natural transformations to obey some coherence laws, which include those of (C, ⊗,I, α⊗, λ⊗, ρ⊗) and (C, ⊕, Z, α⊕, λ⊕, ρ⊕) being monoidal cate- gories.
Given a dioid category, we can define what a dioid is.
Definition 3.2 A dioid in a dioid category is an object D, together with operations
z ∶ Z → D, e ∶ I → D, s ∶ D ⊕ D → D and m ∶ D ⊗ D → D for which the following

laws hold:
m ○ (e ⊗ id)= λ⊗	(15)
m ○ (id ⊗ e)= ρ⊗	(16)
m ○ (id ⊗ m)= m ○ (m ⊗ id)○ α⊗	(17)
s ○ (z ⊕ id)= λ⊕	(18)
s ○ (id ⊕ z)= ρ⊕	(19)
s ○ (id ⊕ s)= s ○ (s ⊕ id)○ α⊕	(20)
m ○ (z ⊗ id)= z ○ κ⊗	(21)
s ○ (e ⊕ id)= e ○ κ⊕	(22)
The laws for dioids in dioid categories are the corresponding generalisations of equations for dioids.
To recover ordinary dioids, we take the category of sets and functions Set with Z = I = {∗} and ⊕=⊗= ×. Notice that κ⊗ = κ⊕ = π1 ∶ {∗} × A → {∗} is not a natural isomorphism, but only a natural transformation.
Lemma 3.3 In general, from a monoidal category (C, ⊗,I, α, λ, ρ) with Cartesian structure (that is, with terminal object and binary products), we obtain a dioid category (C, ⊗,I, α, λ, ρ, ×, 1, α×, π2, π1, κ⊗, π1), where:
α× = ⟨⟨π1, π1 ○ π2⟩, π2 ○ π2⟩∶ A × (B × C)→ (A × B)× C κ⊗ = !1⊗A ∶ 1 ⊗ A → 1
We close our discussion on categorification of dioids by giving the generalisation of dioid homomorphism, which is a direct generalisation of that for ordinary dioids.
Definition 3.4 A dioid homomorphism from a dioid (D1, z1, e1, s1, m1) to a dioid (D2, z2, e2, s2, m2) is a morphism f ∶ D1 → D2 such that the following equations hold:
f ○ e1 = e2 f ○ z1 = z2
f ○ m1 = m2 ○ (f ⊗ f ) f ○ s1 = s2 ○ (f ⊕ f )
Cartesian structure for functors
We can use Lemma 3.3 to extend the monoidal categories of endofunctors discussed in Sections 2.4 and 2.5 to dioid categories. We need to establish that the category of endofunctors on a category C has terminal object and binary products. If the base category C has terminal object, then the constant functor to the terminal object is the terminal object on the category of endofunctors.
data K1 a where
K1 ∶∶ () → K1

instance Functor K1 where
fmap f (K1 ()) = K1 ()
Here, the unit type () represents the terminal object. Similarly, a product of endo- functors is defined in terms of product for objects in the base category, in a point- wise fashion:
data (f × g ) a where
Pair ∶∶ f a × ga → (f × g ) a
instance (Functor f , Functor g )⇒ Functor (f × g ) where
fmap h (Pair (fa, ga)) = Pair (fmap h fa, fmap h ga)
Thus, the endofunctors form a monoidal category with the Cartesian structure, and the monoidal categories supporting monads and applicative functors can be extended to dioid categories.
Non-determinism Monads
By Lemma 3.3 and the Cartesian structure introduced above, we know that the category of endofunctors forms a dioid category by choosing tensor ⊗ to be com- position of functors ○, tensor ⊕ to be the binary product of functors ×, the object I to be the identity functor Identity and the object Z to be the constant terminal functor K1.
The dioids in this dioid category are functors d with operations ζ, η, σ and μ of

type K1 →
d , Identity →
d , d × d →⋅
d and d ○ d →
d respectively. If we expand the

definitions, we can present this information in a type class:
class DioidM d where
ζ ∶∶ ()	→ da 
η ∶∶ a    → da σ ∶∶ da × da → da μ ∶∶ d (d a) → da 
subject to the laws:
μ ○ η = id
μ ○ fmap η = id
μ ○ fmap μ = μ ○ μ σ ○ pair id zero = fst
σ ○ pair zero id = snd
σ ○ pair id σ = σ ○ pair σ id ○ α μ ○ ζ = ζ
σ ○ pair η id = η ○ fst
where pair f g (x, y ) = (f x , g y) and α (x, (y, z )) = ((x , y ), z ). The operations η

and μ form an instance of Triple. In this way,a dioid might be seen as an extended monad. This justifies the equivalent type class
class Monad m ⇒ MonadPlus m where
mzero ∶∶ ma 
mplus ∶∶ ma → ma → ma 
subject to the following laws
mplus mzero u = u
mplus u mzero = u
mplus u (mplus v w )= mplus (mplus u v ) w
mzero >= f = mzero mplus (return x ) u = return x
in addition to those of monads.
Perhaps the most representative instance of MonadPlus subject to these axioms is Maybe.
instance MonadPlus Maybe where mzero	= Nothing mplus Nothing v = v
mplus (Just x ) v = Just x
An important non-example of MonadPlus subject to these axioms are lists. While the empty list and list concatenation would give an implementation for mzero and mplus, such implementation would not satisfy the law mplus (return x ) u = return x . (In fact, lists are the canonical example of deep-backtracking non-determinism.)
Non-determinism Applicative Functors
We turn again to Lemma 3.3 to obtain a dioid category of endofunctors, but this time with the Day convolution as a tensor instead of functor composition.
The dioids in this dioid category are functors d with operations empty, pure,

(⟨∣⟩) and (⊛) of type K1 →
d , Identity →
d , d × d →⋅
d and d ⋆ d →
d respectively. If

we expand the definitions, we can present this information in a type class:
class DioidF d where
empty ∶∶ ()	→ da 
pure  ∶∶ a	→ da 
(⟨∣⟩) ∶∶ da × da	→ da 
(⊛)	∶∶ d (b → a)× db → da 
As we did with monads, we separate the applicative functor contained in this type class, and create a class that extends applicative functors with the additional infor- mation:

class Applicative f ⇒ Alternative f where
empty ∶∶ f a 
(⟨∣⟩)  ∶∶ f a → f a → f a 
By instantiating the laws for dioids, we obtain the following laws for Alternative, which are additional to those of the underlying Applicative instance.
empty ⟨∣⟩ u = u u ⟨∣⟩ empty = u
u ⟨∣⟩ (v ⟨∣⟩ w )= (u ⟨∣⟩ v ) ⟨∣⟩ w
empty ⊛ u = empty pure x ⟨∣⟩ u = pure x
We can extend Remark 2.4 to the type classes MonadPlus and Alternative, and obtain the following result.
instance MonadPlus m ⇒ Alternative m where
empty = mzero
u ⟨∣⟩ v = mplus uv 
In fact, most Alternative instances found in programming practice are actually MonadPlus instances. An example of an Alternative which is not a MonadPlus is the constant functor on a Dioid.
instance Dioid d ⇒ Alternative (K d ) where
empty	= MK z
(MK d1) ⟨∣⟩ (MK d2)= MK (d1 ⊕ d2)

Free structures
Free structures are a fundamental tool in universal algebra, as in some sense they provide the most general models of an algebraic structure, free of any additional equation over terms. In computer science, this phenomenon is often referred to as the no junk, no confusion principle [2]. In our setting, we employ free structures as a device to work with those programs that only use the structure under analysis.
Free monoids
The notion of free ordinary monoid is captured by a universal property. Formally, we say that the type FreeMona is the free monoid over a when:
FreeMona is an instance of Monoid;
there is a function ins ∶∶ a → FreeMona;
for any Monoid instance m and function f ∶∶ a → m, there exists a unique monoid homomorphism univ f ∶∶ FreeMona → m such that univ f ○ ins = f .

While mathematically precise, this definition is not constructive: it does not provide a procedure to construct such FreeMona from a given a. A possible technique to find a concrete construction is to provide a unique form for monoidal terms, such that two terms that are equal by the monoid laws are represented by the same term. For example, a ⊗(u () ⊗(b ⊗ c)) and (a ⊗ b) ⊗(c ⊗ u ()) should have a unique representation in the data type representing the free monoid over a set which includes a, b and c. To see that two monoid expressions are equivalent, we can apply the monoid laws in a methodological way:
every atom a is replaced by a ⊗ u ();
every expression associated to the left is re-associated to the right;
every expression u () ⊗ t is reduced to t .
Applying this method to the expressions above, we obtain the term a ⊗(b ⊗(c ⊗ u ())) in both cases. After some thinking, one can conclude that every term reduces to a list of atoms ending in u (). This observation inspires the following data type for representing canonical forms.
data FreeMon a where
Nil	∶∶ FreeMon a
Cons ∶∶ a × FreeMon a → FreeMon a
This data type is equivalent to a list of as, and therefore has a monoid instance given by the empty list and list concatenation:
instance Monoid (FreeMon a) where
u ()	= Nil
Nil	⊗ bs = bs
(Cons a as)⊗ bs = Cons a (as ⊗ bs)
The insertion function represents an a atom by a singleton list.
ins ∶∶ a → FreeMon a
ins a = Cons a Nil
The function univ is written by recursion on FreeMon a:
univ ∶∶ Monoid m ⇒ (a → m)→ FreeMon a → m
univ f Nil	= u ()
univ f (Cons a as)= f a ⊗ univ f as
Using set theory, the free monoid over a set a, i.e. lists of a, can be seen as the least solution a∗ to the recursive equation:
a∗ = {∗} ⊍ a × a∗
where ⊍ represents the disjoint union of sets.

Generalising to monoidal categories the equation becomes
A∗ ≅ I + A ⊗ A∗	(23)
which gives a candidate for the free monoid in a monoidal category. Before instan- tiating this formula to other cases, we first review the general universal property for a free monoid in a monoidal category (C, ⊗,I).
Definition 4.1 Let X be an object, the free monoid over X is a monoid (F, eF , mF ) together with a morphism ins ∶ X → F such that for any monoid (M, eM , mM ) and morphism f ∶ X → M there exists a unique monoid homomorphism univ(f )∶ F → M such that univ(f )○ ins = f . Diagrammatically, we have:
X 	ins	/F¸
univ(f )
z 
M
The morphism ins is called the insertion morphism, and univ f is known as the lifting of f .
As in the case of ordinary monoids, this definition provides an abstract char- acterisation for the free monoid. To obtain a concrete description, we instantiate formula 23 to the corresponding monoidal category.
For obtaining the free Monad, we apply formula 23 to the monoidal category of endofunctors with functor composition as tensor, which yields the equation
f ∗ ≅ Identity + f ○ f ∗
that leads to the following data type:
data Free f a where
Nil○	∶∶ a → Free f a 
Cons○ ∶∶ f (Free f a)→ Free f a 
This is indeed the free monad on a functor f , with monad instance:
instance Functor f ⇒ Monad (Free f ) where
return x	= Nil○ x
Nil○ x	>= f = f x 
Cons○ v >= f = Cons○ (fmap (>=f ) v )
The insertion morphism and lifting are as follows:
ins ∶∶ Functor f ⇒ f → Free f
ins v = Cons○ (fmap Nil○ v )
⋅	⋅
univ ∶∶ (Functor f , Monad m)⇒ (f → m)→ (Free f → m)

univ f (Nil○ x )	= return x
univ f (Cons○ v )= f (fmap (univ f ) v ) >= id
We now turn our focus to the monoidal category of endofunctors with Day convolution as tensor. Instantiating formula 23 to this monoidal category results in:
f ∗ ≅ Identity + f ⋆ f ∗
which leads to the following data type
data FreeA f a where
Nil⋆	∶∶ a → FreeA f a 
Cons⋆ ∶∶ f (b → a)× FreeA f b → FreeA f a 
Again, we find the instantiation of the general formula yields the free applicative functor on a functor f , with applicative instance:
instance Functor f ⇒ Applicative (FreeA f ) where
pure x	= Nil⋆ x
Nil⋆ h	⊛ x = fmap hx 
Cons⋆ (h, x )⊛ y = Cons⋆ (fmap uncurry h)
(fmap (, ) x ⊛ y )
where (, ) is the pair constructor. The insertion morphism and lifting are imple- mented as follows.
ins ∶∶ Functor f ⇒ f → FreeA f
ins v = Cons⋆ (fmap const v ) (Nil⋆ ())
⋅	⋅
univ ∶∶ (Functor f , Applicative g )⇒ (f → g )→ (FreeA f → g )
univ f (Nil⋆ x )	= pure x
univ f (Cons⋆ v r )= f v ⊛ univ f r 
Starting with the analysis of the free monoid, we have generalised the solution to monoidal categories, and then we have used this formula to obtain the free monad and the free applicative. General conditions for the existence of free monoids can be found in the work of Kelly [8]. The case of free monads and free applicative functors is analysed in detail by Rivas and Jaskelioff [14].
Free dioids
For constructing free dioids, it would be desirable to adapt the methodology we followed to obtain free monoids. This is, we expect to come up with a formula for ordinary free dioids, and then generalise this formula to obtain a candidate for free dioids in a dioid category.
Instead of introducing free ordinary dioids and then generalising them, we present directly free dioids in a dioid category (C, ⊗,I, α⊗, λ⊗, ρ⊗, ⊕, Z, α⊕, λ⊕, ρ⊕, κ⊗, κ⊕),

and then obtain the ordinary notion for the dioid category Set with binary products and terminal object as both additive and multiplicative structures.
Definition 4.2 Let X be an object of a dioid category, the free dioid over X is a dioid (F, zF , eF , sF , mF ) together with a morphism ins ∶ X → F such that for any dioid (D, zD, eD, sD, mG) and morphism f ∶ X → G there exists a unique dioid homomorphism univ(f )∶ F → G such that univ(f )○ ins = f .
As in the case of monoids, the presentation by universal property does not give a concrete construction for free dioids. To obtain a concrete presentation for the free ordinary dioid over a set X, we need to come up with a canonical form for dioid terms. We propose the least solution to the following recursive equations of sets:
X∗= 0 ⊍ 1 ⊍ T	(24)
T = X ⊍ (S ×⊕ 1)⊍ (S ×⊕ T )⊍ (M ×⊗ 0)⊍ (M ×⊗ T )	(25)
S = X ⊍ (M ×⊗ 0)⊍ (M ×⊗ T )	(26)
M = X ⊍ (S ×⊕ 1)⊍ (S ×⊕ T )	(27)
where 0 = 1 = {∗} and ×⊗ = ×⊕ = ×. Although these last renamings are unnecessary at this point, they will become useful when we generalise these equations to dioid categories. Performing some simplifications, we can implement these equations as a data type:
data Free a where Zero ∶∶ Free a Unit ∶∶ Free a
Term ∶∶ Term a → Free a
data Term a where
LiftT	∶∶ a → Term a
SumT1 ∶∶ Sum a → Term a
SumT2 ∶∶ Sum a × Term a → Term a
MultT1 ∶∶ Mult a → Term a
MultT2 ∶∶ Mult a × Term a → Term a
data Sum a where
LiftS	∶∶ a → Sum a
MultS1 ∶∶ Mult a → Sum a
MultS2 ∶∶ Mult a × Term a → Sum a
data Mult a where
LiftM	∶∶ a → Mult a
SumM1 ∶∶ Sum a → Mult a
SumM2 ∶∶ Sum a × Term a → Mult a
The dioid operations for Free a are not difficult to write, although their length can be intimidating. Two auxiliary functions (⊕T ) and (⊗T ) are provided, as they

help to structure the multiplication and addition. We give the implementation only for (⊗T ), as the implementation for (⊕T ) is dual.
(⊗T ) ∶∶ Term a → Free a → Term a
LiftT x	⊗T Zero	= MultT1 (LiftM x )
LiftT x	⊗T Unit	= LiftT x
LiftT x  ⊗T Term y = MultT2 (LiftM x , y ) SumT1 x  ⊗T Zero = MultT1 (SumM1 x ) SumT1 x   ⊗T Unit  = SumT1 x
SumT1 x	⊗T Term y = MultT2 (SumM1 x , y ) SumT2 (x, y ) ⊗T Zero	= MultT1 (SumM2 (x, y )) SumT2 (x, y ) ⊗T Unit	 = SumT2 (x, y )
SumT2 (x, y ) ⊗T Term z = MultT2 (SumM2 (x, y ), z )
MultT1 x	⊗T y	= MultT1 x
MultT2 (x, y ) ⊗T z	= MultT2 (x, y ⊗T z )
Using those functions, the Dioid instance for Free is the following:
instance Dioid (Free a) where
z () = Zero
u () = Unit Zero	⊕ x = x
Unit	⊕ v = Unit
Term x ⊕ y = Term (x ⊕T y )
Zero	⊗ v = Zero Unit	⊗ x = x
Term x ⊗ y = Term (x ⊗T y )
The insertion morphism and lifting are as follows:
ins ∶∶ a → Free a
ins a = Term (LiftT a)
univ ∶∶ Dioid d ⇒ (a → d )→ Free a → d
univ f Zero	= z ()
univ f Unit	= u ()
univ f (Term v )= univT f v 
univT ∶∶ Dioid d ⇒ (a → d )→ Term a → d
univT f (LiftT x )	= f x 
univT f (SumT1 s)	= univM f s ⊕ u ()
univT f (SumT2 (s, t )) = univM f s ⊕ univT f t 
univT f (MultT1 s)	= univS f s ⊗ z ()
univT f (MultT2 (s, t )) = univS f s ⊗ univT f t 
where univM and univS are auxiliary functions that work as expected.

The definition of the free dioid and its operations is not complicated but is rather subtle. Therefore we have formally verified that this is indeed the free dioid using Agda as a proof assistant.
We now turn to the problem of generalising the equations (24–27) to other dioid categories. For generalising the free monoid construction, we replaced disjoint union
⊍ for coproduct +, Cartesian product × for monoidal tensor ⊗, and the singleton set {∗} for the unit object I of a monoidal category. In the case of dioids, the system of recursive equations presented only involve, in addition to disjoint union, Cartesian product × and the singleton set {∗}. Nevertheless, a dioid category has more structure: two objects Z and I, and two bifunctors ⊕ and ⊗. That is the reason we introduced the renamings ×⊗, ×⊕, 0, and 1: for keeping track of which constructors correspond to the additive structure and which to the multiplicative structure.
Replacing ⊍ for +, ×⊗ for ⊗, 1 for I, ×⊕ for ⊕, and 0 for Z in the equations, we obtain the following system of equations for the tentative free dioid over an object X:
X∗ = Z + I + T
T = X + (S ⊕ I)+ (S ⊕ T )+ (M ⊗ Z)+ (M ⊗ T ) S = X + (M ⊗ Z)+ (M ⊗ T )
M = X + (S ⊕ I)+ (S ⊕ T )

When considering the category of endofunctors with composition as multiplica- tion and Cartesian product as addition, we obtain data type constructors represent- ing these formulas:
data Free○ f x where
Zero○ ∶∶ K1 x → Free○ f x Unit○ ∶∶ Identity x → Free○ f x Term○ ∶∶ Term○ f x → Free○ f x 
data Term○ f x where
LiftT○ ∶∶ f x → Term○ f x 
SumT1 ∶∶ Sum○ f x × Identity x → Term○ f x SumT2 ∶∶ Sum○ f x × Term○ f x → Term○ f x MultT1 ∶∶ Mult○ f (K1 x )→ Term○ f x MultT2 ∶∶ Mult○ f (Term○ f x )→ Term○ f x 
data Sum○ f x where
LiftS○ ∶∶ f x → Sum○ f x 
MultS1 ∶∶ Mult○ f (K1 x )→ Sum○ f x 
MultS2 ∶∶ Mult○ f (Term○ f x )→ Sum○ f x 
data Mult○ f x where
LiftM○ ∶∶ f x → Mult○ f x 
SumM1 ∶∶ Sum○ f x × Identity x → Mult○ f x 

SumM2 ∶∶ Sum○ f x × Term○ f x → Mult○ f x 
While at first sight this data type seemed to work, we ran into problems when we tried to define the MonadPlus instance. Specifically, we got stuck when writing the (>=) operator on Free○ f , as we needed to distribute coproducts on the right of
. Our conjecture is that the recursive equations presented only work for tensors which distribute coproducts on both parameters. Fortunately, Day convolution satisfies such requirement, and we successfully applied the formulas to obtain the free Alternative. The resulting data type constructor is similar to that of monads, but we inlined the data type constructors K1 and Identity to avoid some clutter:
data Free⋆ f x where Zero⋆ ∶∶ Free⋆ f x Unit⋆ ∶∶ x → Free⋆ f x 
Term⋆ ∶∶ Term⋆ f x → Free⋆ f x 
data Term⋆ f x where
LiftT⋆ ∶∶ f x → Term⋆ f x 
SumT1 ∶∶ Sum⋆ f x → x → Term⋆ f x SumT2 ∶∶ Sum⋆ f x → Term⋆ f x → Term⋆ f x MultT1 ∶∶ Mult⋆ f (a → x )→ Term⋆ f x 
MultT2 ∶∶ Mult⋆ f (a → x )→ Term⋆ f a → Term⋆ f x 
data Sum⋆ f x where
LiftS⋆  ∶∶ f x → Sum⋆ f x 
MultS1 ∶∶ Mult⋆ f (a → x )→ Sum⋆ f x 
MultS2 ∶∶ Mult⋆ f (a → x )→ Term⋆ f a → Sum⋆ f x 
data Mult⋆ f x where
LiftM⋆ ∶∶ f x → Mult⋆ f x 
SumM1 ∶∶ Sum⋆ f x → x → Mult⋆ f x 
SumM2 ∶∶ Sum⋆ f x → Term⋆ f x → Mult⋆ f x 
The instances of Functor, Applicative and Alternative are involved, although they follow the same pattern of the operations for free ordinary dioids. We present the Applicative instance, as its multiplication is the most involved operation.
instance Functor f ⇒ Applicative (Free⋆ f ) where
pure x = Unit⋆ x
Zero⋆	⊛ v = Zero⋆
Unit⋆ f ⊛ x = fmap f x 
Term⋆ x ⊛ y = Term⋆ (x ⊛T y )
The function (⊛T ) is the equivalent to (⊗T ) for free ordinary dioids, and it is defined as follows:
(⊛T ) ∶∶ Functor f ⇒
Term⋆ f (a → b)→ Free⋆ f a → Term⋆ f b 

LiftT⋆ x	⊛T Zero⋆	= MultT1 (LiftM⋆ x ) LiftT⋆ x	⊛T Unit⋆ y = LiftT⋆ (evalF x y) LiftT⋆ x	⊛T Term⋆ y = MultT2 (LiftM⋆ x ) y
SumT1 x y ⊛T Zero⋆	= MultT1 (SumM1 x y)
⋆	⋆	⋆
SumT1 x y ⊛T Unit⋆ v = SumT1 (evalF x v ) (y v )
⋆	⋆
SumT1 x y ⊛T Term⋆ v = MultT2 (SumM1 x y) v
⋆	⋆	⋆
SumT2 x v ⊛T Zero⋆	= MultT1 (SumM2 x v )
⋆	⋆	⋆
SumT2 x v ⊛T Unit⋆ y = SumT2 (evalF x y) (evalF v y )
⋆	⋆
SumT2 x v ⊛T Term⋆ y = MultT2 (SumM2 x v ) y
⋆	⋆	⋆
MultT1 x	⊛T v	= MultT1 (fmap uncurry x )
⋆	⋆
MultT2 x v ⊛T w	= MultT2 (fmap uncurry x )
⋆	⋆
(fmap (, ) v ⊛T w )
evalF ∶∶ Functor f ⇒ f (a → b)→ a → f b 
evalF va = fmap (λf → f a) v
The lifting function is also involved, although we insist again that it follows the pattern presented for ordinary dioids. We close our discussion for free structures by presenting the insertion function for Free⋆.
ins⋆ ∶∶ Functor f ⇒ f a → Free⋆ f a 
ins⋆ v = Term⋆ (LiftT⋆ v )
The correctness for these definitions was also formally verified using Agda.

Conclusion
This paper has introduced a generalised notion of dioids, which was used to study computations with shallow-backtracking non-determinism. By considering the in- stances of MonadPlus and Alternative type classes as dioids, we have obtained a set of laws that those instances should obey.
We have shown a concrete description for the free ordinary dioid, and then generalised the construction to dioid categories. By instantiation, this resulted in the construction of the free Alternative, but we were not able to do the same to obtain a free MonadPlus.
As further work, it would be interesting to study the notion of dioid in the dioid category of endoprofunctors, and see whether the general formulation for free dioids presented can be used in this setting to obtain a free arrow with a notion of shallow-backtracking non-determinism.

Acknowledgment
The authors are grateful to the members of IFIP WG 2.1 for preliminary discussions about the topic of this paper.

References
Bainbridge, E., P. J. Freyd, A. Scedrov and P. J. Scott, Functorial polymorphism, Theoretical Computer Science 70 (1990), pp. 35 – 64.
URL http://www.sciencedirect.com/science/article/pii/0304397590901517

Burstall, R. M. and J. A. Goguen, “Algebras, Theories and Freeness: An Introduction for Computer Scientists,” Springer Netherlands, Dordrecht, 1982 pp. 329–349.
URL  http://dx.doi.org/10.1007/978-94-009-7893-5_11
Day, B., Note on monoidal localisation, Bulletin of the Australian Mathematical Society 8 (1973),
pp. 1–16.
URL http://journals.cambridge.org/article_S0004972700045433
Gibbons, J. and B. c. d. s. Oliveira, The essence of the iterator pattern, J. Funct. Program. 19 (2009),
pp. 377–402.
URL http://dx.doi.org/10.1017/S0956796809007291

Grandis, M., Cubical monads and their symmetries, Rend. Instit. Mat. Univ. Tieste 25 (1993), pp. 223– 264.
URL http://hdl.handle.net/10077/4693

Hughes, J., A novel representation of lists and its application to the function “reverse”, Information Processing Letters 22 (1986), pp. 141–144.
URL  http://dx.doi.org/10.1016/0020-0190(86)90059-1

Jaskelioff, M. and O. Rypacek, An investigation of the laws of traversals, in: J. Chapman and P. B. Levy, editors, Proceedings Fourth Workshop on Mathematically Structured Functional Programming, Tallinn, Estonia, 25 March 2012, Electronic Proceedings in Theoretical Computer Science 76 (2012),
pp. 40–49.
URL https://arxiv.org/abs/1202.2919v1

Kelly, G. M., A unified treatment of transfinite constructions for free algebras, free monoids, colimits, associated sheaves, and so on, Bulletin of the Australian Mathematical Society 22 (1980), pp. 1–83.
URL https://doi.org/10.1017/S0004972700006353

Mac Lane, S., “Categories for the Working Mathematician,” Number 5 in Graduate Texts in Mathematics, Springer-Verlag, 1971, second edition, 1998.
Marlow, S., L. Brandy, J. Coens and J. Purdy, There is no fork: An abstraction for efficient, concurrent, and concise data access, in: Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming, ICFP ’14 (2014), pp. 325–337.
URL http://doi.acm.org/10.1145/2628136.2628144
McBride, C. and R. Paterson, Applicative programming with effects, Journal of Functional Programming
18 (2008), pp. 1–13.
URL http://dx.doi.org/10.1017/S0956796807006326

Moggi, E., Computational lambda-calculus and monads, in: Proceedings of the Fourth Annual Symposium on Logic in Computer Science (1989), pp. 14–23.
URL http://dl.acm.org/citation.cfm?id=77350.77353
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), pp. 55–92.
URL  http://dx.doi.org/10.1016/0890-5401(91)90052-4
Rivas, E. and M. Jaskelioff, Notions of computation as monoids, CoRR abs/1406.4823 (2014).
URL http://arxiv.org/abs/1406.4823

Rivas, E., M. Jaskelioff and T. Schrijvers, From monoids to nearsemirings: The essence of monadplus and alternative, in: M. Falaschi and E. Albert, editors, Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming, PPDP’15 (2015), pp. 196–207.
URL http://doi.acm.org/10.1145/2790449.2790514
Spivey, J. M., When maybe is not good enough., J. Funct. Program. 22 (2012), pp. 747–756.
URL  http://dblp.uni-trier.de/db/journals/jfp/jfp22.html#Spivey12
Spivey, M., A functional theory of exceptions, Sci. Comput. Program. 14 (1990), pp. 25–42.
URL  https://doi.org/10.1016/0167-6423(90)90056-J
Swierstra, S. D. and L. Duponcheel, Deterministic, error-correcting combinator parsers, in:
J. Launchbury, E. Meijer and T. Sheard, editors, Advanced Functional Programming, Second International School, Olympia, WA, USA, August 26-30, 1996, Tutorial Text, Lecture Notes in Computer Science 1129 (1996), pp. 184–207.
URL  http://dx.doi.org/10.1007/3-540-61628-4_7


Uustalu, T., A divertimento on monadplus and nondeterminism, J. Log. Algebr. Meth. Program. 85
(2016), pp. 1086–1094.
URL http://dx.doi.org/10.1016/j.jlamp.2016.06.004

Voigtl¨ander, J., Asymptotic improvement of computations over free monads, in: Proceedings of the 9th International Conference on Mathematics of Program Construction, MPC ’08 (2008), pp. 388–403.
URL  http://dx.doi.org/10.1007/978-3-540-70594-9_20

Wadler, P., Comprehending monads, in: Proceedings of the 1990 ACM Conference on LISP and Functional Programming, LFP ’90 (1990), pp. 61–78.
URL http://doi.acm.org/10.1145/91556.91592
