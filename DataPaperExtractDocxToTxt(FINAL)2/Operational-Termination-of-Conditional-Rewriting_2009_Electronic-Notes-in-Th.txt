

Electronic Notes in Theoretical Computer Science 237 (2009) 75–90
www.elsevier.com/locate/entcs

Operational Termination of Conditional Rewriting with Built-in Numbers and Semantic Data Structures 
Stephan Falke1 Deepak Kapur2
Department of Computer Science, University of New Mexico, Albuquerque, NM 87131, USA

Abstract
While ordinary conditional rewrite systems are more elegant than unconditional ones, they still have limited expressive power since semantic data structures, such as sets or multisets, cannot be modeled elegantly. Extending our work presented at RTA 2008 [9], the present paper defines a class of conditional rewrite systems that allows the use of semantic data structures and supports built-in natural numbers, including constraints taken from Presburger arithmetic. The framework is both expressive and natural. Rewriting is performed using a combination of normalized equational rewriting with recursive evaluation of conditions and validity checking of instantiated constraints.
Termination is one of the most important properties of any kind of rewriting. For conditional systems, it is not sufficient to only show well-foundedness of the rewrite relation, but it also has to be ensured that evalu- ation of the conditions terminates. These properties are captured by the notion of operational termination. In this work, we show that operational termination for the class of conditional rewrite systems discussed above can be reduced to (regular) termination of unconditional systems using a syntactic transformation.
Powerful methods for showing termination of unconditional systems are presented in [9].
Keywords: Conditional term rewriting, operational termination, semantic data structures


Introduction
Conditional term rewrite systems operating on free data structures provide a pow- erful framework for specifying algorithms. This approach has successfully been taken by the system Maude [4]. Many algorithms, however, operate on semantic data structures like finite sets, multisets, or sorted lists (e.g., using Java’s collection classes or the OCaml extension Moca [3]). Constructors used to generate such data structures satisfy certain properties, i.e., they are not free. For example, finite sets can be generated using the empty set, singleton sets, and set union. Set union is

٨ Partially supported by NSF grant CCF-0541315.
1 Email: spf@cs.unm.edu
2 Email: kapur@cs.unm.edu

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.036

associative, commutative, idempotent, and has the empty set as unit element. Such semantic data structures can be modeled using equational axioms.
Extending our work presented at CADE 2007 and RTA 2008 [7,9], the present paper introduces conditional constrained equational rewrite systems (CCESs) which have three components: (i) R, a set of conditional constrained rewrite rules for specifying algorithms on semantic data structures, (ii) S, a set of constrained rewrite rules, and (iii) E , a set of equations. Here, (ii) and (iii) are over the constructors of
R and are used for modeling semantic data structures such that normalization with
S yields normal forms that are unique up to equivalence w.r.t. E . The constraints for R and S are Boolean combinations of atomic formulas of the form s  t and s > t from Presburger arithmetic. Rewriting with such a system is performed using a combination of normalized rewriting [12] with evaluation of conditions and validity checking of instantiated constraints. Before matching a redex with the left side of a rule, the redex is first normalized with S. Additionally, the rewrite step is only performed if the instantiated conditions of the rule can be established by recursively rewriting them and if the instantiated constraint of the rule is valid. The difference between conditions and constraints in a rule is thus operational.
Example 1.1 This example shows a quicksort algorithm that takes a set and re- turns a list. It is a modiﬁcation of an example from [2] that is widely used in the literature on conditional rewriting. Sets are constructed using ∅ and ins, where ins adds an element to a set. The semantics of sets is modeled using S and E as follows.
E:	ins(x, ins(y, zs))  ≈  ins(y, ins(x, zs))
S:	ins(x, ins(x, ys)) → ins(x, ys)
Quicksort is speciﬁed by the following conditional constrained rewrite rules.
app(nil, zs)  → zs
app(cons(x, ys), zs)  →  cons(x, app(ys, zs))
split(x, ∅) → ⟨∅, ∅⟩
split(x, zs) →∗ ⟨zl, zh⟩ | split(x, ins(y, zs)) → ⟨ins(y, zl), zh⟩	 x > y)
split(x, zs) →∗ ⟨zl, zh⟩ | split(x, ins(y, zs)) → ⟨zl, ins(y, zh)⟩	 x /> y)
qsort(∅) → nil
split(x, ys) →∗ ⟨yl, yh⟩ | qsort(ins(x, ys))  →	app(qsort(yl), cons(x, qsort(yh)))
Here, split(x, ys) returns a pair of sets ⟨yl, yh⟩ where yl contains all y ∈ ys such that x > y and yh contains all y ∈ ys such that x /> y.	 
One of the most important properties of a CCES is that a rewrite engine operat- ing with it always terminates. For this, it has to be shown that the rewrite relation is well-founded and that the evaluation of the conditions terminates. These properties

can be characterized by the notion of operational termination [11]. 3 The recursive nature of conditional rewriting is reflected in an inference systems for proving that a term s can be reduced to a term t, and operational termination is the property that this inference system does not allow infinite derivations.
The present paper shows that operational termination of a conditional system can be reduced to termination of an unconditional system using a syntactic trans- formation. This transformation is similar to the transformation used for ordinary conditional rewriting, see, e.g., [13, Definition 7.2.48]. Powerful methods based on dependency pairs for showing termination of unconditional systems are presented in [9], and in combination with the current paper these methods can be used for showing operational termination of CCESs as well.
This paper is organized as follows. In Section 2, the rewrite relation is defined. In Section 3, we formally define the notion of operational termination and show that termination and operational termination coincide for unconditional systems. Section 4 introduces a transformation from conditional systems into unconditional ones. We show that termination of the transformed system implies operational ter- mination of the original system. The omitted proofs may be found in the full version of this paper [8], and [6] contains several nontrivial conditional systems whose oper- ational termination can be shown by applying the transformation presented in this paper and using the termination techniques presented in [9].

Conditional Normalized Rewriting with Constraints
We assume familiarity with the concepts and notations of term rewriting [1]. We consider terms over two sorts, nat and univ, and we use an initial signature JPA =
{0, 1, +} using only sort nat.  Here, “УA” stands for “Presburger Arithmetic”.
Properties of natural numbers are modelled using the set УA = {x + (y + z) ≈ (x + y) + z, x + y ≈ y + x, x + 0 ≈ x} of equations. For each k ∈ N — {0}, we denote the term 1 + ... + 1 (with k occurrences of 1) by k.
We then extend JPA by a finite sorted signature J. We omit stating the sorts explicitly in examples if they can be inferred. In the following we assume that all terms, contexts, context replacements, substitutions, rewrite rules, equations, etc. are sort correct. For any syntactic construct c we let V(c) denote the set of variables occurring in c. The root symbol of a term s is denoted by root(s). The root position of a term is denoted by λ. For an arbitrary set S of equations and terms s, t we write s →E t iff there exist an equation u ≈ v ∈ S, a substitution σ, and a position p ∈ Уos(s) such that s|p = uσ and t = s[vσ]p. The symmetric closure of →E is denoted by ▶EE , and the reflexive transitive closure of ▶EE is denoted by ~E . For two terms s, t we write s ~>λ t iff s = f (s1,..., sn) and t = f (t1,..., tn) such that si ~E ti for all 1 ≤ i ≤ n, i.e., if equations are only applied below the root.
An atomic УA-constraint has the form T (truth), s  t (equality) or s > t
(greater) for terms s, t ∈7 (JPA, V). The set of УA-constraints is defined to be the

3 Another commonly used characterization is effective termination, see, e.g., [13]. However, as argued in [11], operational termination better captures the behaviour of actual rewrite engines.

closure of the set of atomic УA-constraints under ¬ (negation) and ∧ (conjunction). Validity (the constraint is true for all assignments) and satisfiability (the constraint is true for some assignment) of УA-constraints are defined as usual, where we take the set of natural numbers as universe of concern. We also speak of УA-validity and УA-satisfiability. These properties are decidable [15].
Now the conditional rewrite rules considered are combined with УA-constraints.
Definition 2.1 (Conditional Constrained Rewrite Rule) A conditional con- strained rewrite rule has the form s1 →∗ t1,..., sn →∗ tn | l → r C) such that
l, r ∈7 (J ∪ JPA, V) such that root(l) ∈ J,
si, ti ∈7 (J ∪ JPA, V),
C is a УA-constraint,
V(r) ⊆ V(l) ∪  n	V(tj), and
V(si) ⊆ V(l) ∪  i−1 V(tj) for all 1 ≤ i ≤ n. 4
The difference between conditions and constraints in a rule is operational. Con- ditions need to be evaluated by recursively rewriting them, while constraints are checked using a decision procedure for УA-validity. This distinction will be for- malized in Definition 2.7. In a rule l → r T) the constraint T will be omitted. For a set R of constrained rewrite rules, the set of deﬁned symbols is given by D(R) = {f | f = root(l) for some s1 →∗ t1,..., sn →∗ tn | l → r C) ∈ R}. The set of constructors is C(R) = J — D(R). Note that according to this definition, the symbols from JPA are considered to be neither defined symbols nor constructors.
Properties of non-free data structures are modelled using constructor equations
and constructor rules. Constructor equations need to be linear and regular.
Definition 2.2 (Constructor Equations) A constructor equation has the form u ≈ v for terms u, v ∈ 7 (C(R), V) such that u ≈ v has identical unique variables (is i.u.v.), i.e., u and v are linear and V(u) = V(v).
Similar to conditional constrained rewrite rules, constructor rules have a УA- constraint that will guard when a rule is applicable.
Definition 2.3 (Constructor Rules) A constructor rule is a rule l → r C) with
l, r ∈7 (C(R), V) and a УA-constraint C where root(l) ∈ C(R) and V(r) ⊆ V(l).
Again, constraints C of the form T will be omitted in constructor rules. Con- structor rules and equations give rise to the following rewrite relation. It is based on extended rewriting [14] but requires that the УA-constraint of the constructor rule is УA-valid after being instantiated by the matcher. For this, we require that variables of sort nat are instantiated by terms over JPA in order to ensure that УA- validity of the instantiated УA-constraint can be decided by a decision procedure for УA-validity. 5

4 Using the notation of [13], the last two conditions yield deterministic type 3 rules.
5 This requirement can be relaxed slighlty by requiring that only those variables of sort nat that occur in the PA-constraint need to be instantiated by terms over FPA.

Definition 2.4 (УA-based Substitutions) Let σ be a substitution. Then σ is
УA-based iff σ(x) ∈7 (JPA, V) for all variables x of sort nat.
Definition 2.5 (Constructor Rewrite Relation) Let S be a ﬁnite set of con- structor equations and let S be a ﬁnite set of constructor rules. Then s →PA  E\S t iff there exist a constructor rule l → r C) ∈ S, a position p ∈ Уos(s), and a УA-based substitution σ such that
s|p ~E∪PA lσ, 6
Cσ is УA-valid, and
t = s[rσ]p.

We write s →>λ
t iff s →

PA E\S
t at a position p /= λ, and s →! >λ
t iff s

reduces to t in zero or more →>λ	steps and t is a normal form w.r.t. →>λ	.
We combine conditional constrained rewrite rules and constructor rules and equations into a conditional constrained equational system (CCES).
Definition 2.6 (CCES) A CCES has the form (R, S, S ) for a ﬁnite set R of conditional constrained rewrite rules, a ﬁnite set S of constructor rules, and a ﬁnite set S of constructor equations such that
~E∪PA commutes over →PA  E\S, i.e., ~E∪PA ◦ →PA  E\S ⊆ →PA  E\S ◦ ~E∪PA, and
→PA E\S is convergent modulo ~E∪PA, i.e., →PA E\S is terminating and we

∗
PA E\S
∗
PA E\S
∗
PA E\S
◦ ~E∪PA ◦ ←∗	.

The commutation property intuitively states that if s ~E∪PA s' and s' →PA  E\S
t', then s →PA  E\S t for some t ~E∪PA t'. Thus, if s ~E∪PA s' and s is irreducible by
→PA  E\S, then s' is irreducible by →PA  E\S as well. If S does not already satisfy the commutation property then it might be achieved by adding extended rules [14,10].
It is in general hard to check the conditions on →PA  E\S automatically and an implementation might thus be restricted to some commonly used data structures for which these properties have been established beforehand. Several examples are listed in Figure 1. The rule “(∗)” is needed in order to make ~E∪PA commute over
→PA  E\S. The constructor ⟨·⟩ creates a singleton set or multiset, respectively.
If R is unconditional (i.e., n = 0 for all s1 →∗ t1,..., sn →∗ tn | l → r C) in R), a CCES will also be called a CES [9]. The rewrite relation corresponding to a CCES is an extension of the rewrite relation considered in [9].
Definition 2.7 (Conditional Rewrite Relation) Let (R, S, S ) be a CCES. The

rewrite relation →S
PA E\R
is the least relation satisfying s →S
PA E\R
t iff there exist

a conditional constraint rewrite rule s1 →∗ t1,..., sn →∗ tn | l → r C) in R, a position p ∈ Уos(s), and a УA-based substitution σ such that

s|p →! >λ
>λ
E∪PA
lσ,

Cσ is УA-valid,

6 Recall that PA also denotes the set of equations introduced above.


Fig. 1. Commonly used data structures.

siσ →S ∗  	◦ ~E∪PA tiσ for all 1 ≤ i ≤ n, and
t = s[rσ]p.
Notice that the restriction to УA-based substitution enforces a kind of innermost rewriting for function symbols with resulting sort nat. The least relation satisfying Definition 2.7 can be obtained by an inductive construction, similarly to ordinary conditional rewriting (see, e.g., [13]).

Example 2.8 Continuing Example 1.1 we now illustrate →S

PA E\R
. Consider t =

qsort(ins(1, ins(3, ins(1, ∅)))) and the УA-based substitution σ = {x '→ 3, ys '→

ins(1, ∅), yl '→ ins(1, ∅), yh '→ ∅}. We have t →! >λ
qsort(ins(1, ins(3, ∅))) ~>λ

qsort(ins(x, ys))σ and thus t
→S	app(qsort(ins(1, ∅)), cons(3, qsort(∅))) using

the third rule for qsort, provided split(3, ins(1, ∅)) →S ∗ 	◦ ~E∪PA ⟨ins(1, ∅), ∅⟩. In order to verify this, we use the second split-rule. For this, we ﬁrst need to check that the instantiated constraint 3 /> 1 is УA-valid. Furthermore we need to show that split(3, ∅) →S ∗ 	◦ ~E∪PA ⟨∅, ∅⟩, which is established by the ﬁrst split-rule. Reduc- ing app(qsort(ins(1, ∅)), cons(3, qsort(∅))) eventually produces cons(1, cons(3, nil)). 

It is shown in [8] that whenever s ~E∪PA s' and s →S		t, then s' →S		t'
for some t' ~E∪PA t, i.e., ~E∪PA commutes over →S	.

Lemma 2.9 For any CCES (R, S, S ) we have ~E∪PA ◦
S
PA E\R
S
PA E\R

~E∪PA. Furthermore, the →S
PA E\R
steps can be performed using the same condi-

tional constrained rewrite rule and УA-based substitution.


Termination and Operational Termination
Termination of a CCES means that there is no term that starts an infinite →S

reduction, i.e., that the relation →S

PA E\R
is well-founded. As is well-known, ter-

mination is not the only crucial property of conditional rewriting. In order to get a decidable rewrite relation it additionally has to be ensured that evaluation of the conditions terminates. As argued in [11], the notion of operational termination is a
natural choice for this since it better captures the behavior of actual rewrite engines than other commonly used notions like effective termination [13].
As in [11], the recursive nature of conditional rewriting is reflected in an inference

system that aims at proving s →S
PA E\R
t or s →S ∗	t. Operational termination

is then characterized by the absence of infinite proof trees for this inference system.
Definition 3.1 (Proof Trees) Let (R, S, S ) be a CCES. The set of (ﬁnite) proof trees for (R, S, S ) and the head of a proof tree are inductively deﬁned as follows.
An open goal G, where G is either s → t or s →∗ t for some terms s, t, is a proof tree. In this case head(G) = G is the head of the proof tree.
A derivation tree, denoted by


T1	···	Tn
T =
G
(Δ)


is a proof tree, where G is as in the ﬁrst case, Δ is one of the derivation rules in Figure 2, and T1,..., Tn are proof trees such that

head(T1)	···	head(Tn)
G

is an instance of Δ. In this case, head(T ) = G.
A proof tree is closed iff it does not contain any open goals.
Example 3.2 We again consider the CCES for quicksort from Examples 1.1 and
Then qsort(ins(1, ins(3, ins(1, ∅)))) → app(qsort(ins(1, ∅)), cons(3, qsort(∅))) is



Fig. 2. Derivation rules.

an open goal and


(Repl)
split 3, ∅ → ⟨∅, ∅⟩
⟨∅, ∅⟩ →∗ ⟨∅, ∅⟩ (Refl)

split(3, ∅) →∗ ⟨∅, ∅⟩	(Tran)
split(3, ins(1, ∅)) → ⟨ins(1, ∅), ∅⟩

⟨ins(1, ∅), ∅⟩ →∗ ⟨ins(1, ∅), ∅⟩ (Refl)

split(3, ins(1, ∅)) →∗ ⟨ins(1, ∅), ∅⟩	(Tran)
(Repl)
qsort(ins(1, ins(3, ins(1, ∅)))) → app(qsort(ins(1, ∅)), cons(3, qsort(∅)))

is a closed proof tree with this goal as its head.	 
An infinite proof tree is a sequence of proof trees such that each member of the sequence is obtained from its immediate predecessor by expanding open goals.
Definition 3.3 (Prefixes of Proof Trees, Infinite Proof Trees) A proof tree T is a prefix of a proof tree T ', written T ⊂ T ', if there are one or more open goals G1,..., Gn in T such that T ' is obtained from T by replacing each Gi by a derivation tree Ti with head(Ti) = Gi. An infinite proof tree is an inﬁnite sequence
{Ti}i≥0 of ﬁnite proof trees such that Ti ⊂ Ti+1 for all i ≥ 0.
The notion of well-formed proof trees captures the operational behavior of a rewrite engine that evaluates the conditions of a rewrite rule from left to right.
Definition 3.4 (Well-formed Proof Trees) A proof tree T is well-formed if it

is either an open goal, a closed proof tree, or a derivation tree of the form
T1	···	Tn (Δ)
G

where Tj is a well-formed proof tree for all 1 ≤ j ≤ n and there is an i ≤ n such that Ti is not closed, Tj is closed for all j < i, and Tk is an open goal for all k > i. An inﬁnite proof tree is well-formed if it consists of well-formed proof trees.
As mentioned above, operational termination is characterized by the absence of infinite well-formed proof trees.
Definition 3.5 (Operational Termination) A CCES (R, S, S ) is operationally terminating iff there are no inﬁnite well-formed proof trees.
It can be shown that the notions of termination and operational termination coincide for unconditional systems [8].
Lemma 3.6 Let (R, S, S ) be a CES. Then (R, S, S ) is operationally terminating iff (R, S, S ) is terminating.

Elimination of Conditions
In order to show operational termination of a CCES (R, S, S ), we transform it into a CES (U (R), S, S ) such that operational termination of (R, S, S ) is implied by oper- ational termination of (U (R), S, S ). We then check for termination of (U (R), S, S ), which, by Lemma 3.6, is equivalent to operational termination of (U (R), S, S ). The transformation generalizes the classical one for ordinary conditional rewriting (see, e.g., [13, Definition 7.2.48]) to rewriting with equations, normalization, and con- straints. An extension of the classical transformation to context-sensitive rewriting with equations was proposed in [5]. Our presentation is influenced by that paper.
Definition 4.1 (Transformation U ) Let ρ : s1 →∗ t2,..., sn →∗ tn | l → r C)
be a conditional constrained rewrite rule. Then U (ρ) is deﬁned by
if n = 0 then U (ρ) = { ρ }
if n > 0 then U (ρ) = { l → U ρ(s1, x∗) C) } ∪	(1)
1	1
{ U ρ  (ti−1, x∗  ) → U ρ(si, x∗) C) | 2 ≤ i ≤ n } ∪	(2)
i−1	i−1	i	i

{ U ρ(tn
, x∗ ) → r C) }	(3)

Here, the U ρ are fresh function symbols and, for 1 ≤ i ≤ n, the expression x∗
denotes the sorted list of variables in the set V(l) ∪ V(t1) ∪ ... ∪ V(ti−1) according
to some ﬁxed order on the set V of all variables. For a ﬁnite set R of conditional

constrained rewrite rules we let U (R) = 

ρ∈R
U (ρ).

Example 4.2 Continuing Examples 1.1, 2.8, and 3.2 we get the following uncon- ditional constrained rewrite rules.


U3(⟨yl, yh⟩, x, ys)	→	app(qsort(yl), cons(x, qsort(yh)))
In order to ease readability we used simpliﬁed names for the function symbols U ρ
from Deﬁnition 4.1. Termination of this system is shown in [6, Appendix D.3]. 
In order to show that (R, S, S ) is operationally terminating if (U (R), S, S ) is operationally terminating we make use of the following lemma.
Lemma 4.3 There exists a mapping β from well-formed proof trees for (R, S, S ) to well-formed proof trees for (U (R), S, S ) such that for any well-formed proof tree T with head goal s → t or s →∗ t, β(T ) is well-formed and has s →∗ t as head goal. Furthermore, if T ⊂ T ' for some T ', then β(T ) ⊂ β(T').
The following properties are used freely in the proof of Lemma 4.3.
Property 4.4 Given the proof tree
T1	···	Tn s → t
and a term s' ~E∪PA s, it is possible to construct the proof tree
T1	···	Tn s' → t'
where t' ~E∪PA t is given by Lemma 2.9.	 
Property 4.5 Given the proof tree





T1	s1


T2
→ s2
Tn sn−1 → sn
.

s  →∗ t (Refl)
(Tran)

s0 → s1
s →∗ t	(Tran)

s →∗ t	(Tran)

with s0 = s and a term s' ~E∪PA s, it is possible to construct the proof tree

Tn

T2
T	s˜ → s˜
s˜n−1
→ s˜n
.
s˜n
→∗ t (Refl)
(Tran)

1	1


s˜ → s˜
2	.
s˜ →∗ t	(Tran)

0	1	1
s' →∗ t	(Tran)

where s˜0 = s' and s˜i ~E∪PA si for all 0 ≤ i ≤ n. Here, the s˜i are given by Lemma
Notice that s˜n ~E∪PA t since s˜n ~E∪PA sn and sn ~E∪PA t.	 

Proof of Lemma 4.3
Assume that T is a well-formed proof tree for (R, S, S ) whose head goal is either s → t or s →∗ t. The construction of β(T ) is done by induction on the structure of T . There are two cases, depending on whether the head goal of T is of the form s →∗ t or s → t.
The head goal is s →∗ t:
If the inference rule (Refl) is applied to s →∗ t then we are immediately done. Otherwise, the inference rule (Tran) is applied to s →∗ t. First, we assume that T is closed. Then, T has the shape






T1	s1


T2
→ s2
Tn sn−1 → sn
.

s  →∗ t (Refl)
(Tran)

s0 → s1
s →∗ t	(Tran)

s →∗ t	(Tran)

where s0 = s and sn ~E∪PA t. By the inductive hypothesis we can assume that each subtree


Ui =
Ti si−1 → si

has a transformed tree β(Ui) of the form


ki
i			
(Refl)

2	ski−1 → ski
ski →∗ si

Ti	i	i .	i
T 1	s1 → s2	.
(Tran)

si−1
i
→ s1
i	i


si−1
s1 →∗ si
→∗ si
(Tran)
(Tran)

The proof tree β(T ) is now built by suitably “gluing” the β(Ui) together.


	T kn

(Refl)

˜kn −1	gkn	gkn	∗
 sn	→ sn	sn → t
(Tran)




	T 1


  T 2
sf1 → sf2
˜kn −1	∗
n
.
.
.
.
.


˜kn
→ sf1
 n	n	.	 (Tran)
sf1 →∗ t

 n−1	n	n	 (Tran)



  T 1
˜kn	∗
sn−1 → t
.
.
.

T k1
gk1
.
→ se1	.

1	 1	2	.	 (Tran)

˜k1 −1	gk1
gk1	∗

s1	→ s1
s1 → t
˜k1 −1	∗
(Tran)

  T 2
T 1	se1 → se2
s1	→ t
.
.

	1		1	1
se0 → se1
.
se1 →∗ t s →∗ t
(Tran)
(Tran)


If T is not closed since some leftmost T i is not closed, then β(T ) needs to be cut at the level of T i. In either case, β(T ) is a well-formed proof tree if T is well-formed and β(T ) ⊂ β(T') if T ⊂ T '.
The head goal is s → t:
Again, we first assume that T is closed. Then, it has the shape


S1


s1σ →∗ t1σ	··· 
s → t
Sn


snσ →∗ tnσ



(Repl)


for some rule ρ : s1 →∗ t1,..., sn →∗ tn | l → r C) from R.  In order to ease notation, we assume that the position in the (Repl) rule is p = λ, i.e.,

! >λ
PA E\S
~E∪PA lσ and t = rσ. If the constrained rewrite rule that is used is

unconditional, then this rule is also present in U (R) and we obtain the following proof tree for (U (R), S, S ):


s → t (Repl)	t →∗ t (Refl)
s →∗ t	(Tran)


Otherwise, U (R) contains rules of the form (1), (2) and (3) from Definition 4.1. We construct proof trees for (U (R), S, S ) with the following head goals:

U ρ(tn, x∗ )σ	→∗	rσ	(Gn)
U ρ(sn, x∗ )σ	→∗	rσ	(Hn)

ρ n−1
(tn−1, x∗
)σ	→∗	rσ	(Gn−1)

ρ n−1
(sn−1, x∗
)σ	→∗	rσ	(Hn−1)
.

U ρ(t1, x∗)σ	→∗	rσ	(G1)
1	1
U ρ(s1, x∗)σ	→∗	rσ	(H1)
1	1
s	→∗	t	(K)
For the following, notice that Cσ is УA-valid by assumption.
Proof tree for (Gn): We can construct the proof tree


U ρ(tn
, x∗ )σ → rσ (Repl)	rσ →∗ rσ (Refl)

(Tran)
U ρ(tn, x∗ )σ →∗ rσ
using rule (3) from Definition 4.1.
Proof tree for (Hk) using the proof tree for (Gk): We assume that we have already constructed a proof tree Tk for the goal (Gk) = U ρ(tkσ, x∗σ) →∗ rσ.
k	k
By induction on the tree structure, we can assume that the subtree

Sk
Pk = s σ →∗ t σ
k	k

has a transformed tree β(Pk) of the form
l k

	T 2
1	u1 → u2
ul−1
→ ul
u →∗ t σ (Refl)
.	(Tran)
.

u0 → u1
u →∗ t σ	(Tran)

s σ →∗ t σ	(Tran)
k	k
where u0 = skσ and ul ~E∪PA tkσ. Then, we can construct a proof tree for the goal U ρ(skσ, x∗σ) →∗ rσ as follows:

k	k

l k


u'	→ u'

Tk


U ρ(ul, x∗σ) →∗ rσ

  l−1	l	k	k	
(Tran)

	T 2
'
l−1
→∗ rσ
.

1
k
' → u'
' → u'
.
' →∗ rσ	(Tran)

U ρ(s σ, x∗σ) →∗ rσ	(Tran)
k	k	k

where u' = U ρ(ui, x∗σ).
i	k	k
Proof tree for (Gk−1) using the proof tree for (Hk): We assume that we have
already constructed a proof tree Tk for the goal (Hk) = U ρ(skσ, x∗σ) →∗ rσ.

Then, we can construct a proof tree for the goal
ρ	( k
k
∗	) →∗

as follows:
Uk−1 tk−1σ, xk−1σ	rσ


U ρ	(t	σ, x∗	σ) → U ρ(s σ, x∗σ) (Repl)	T

  k−1  k−1	k−1	k	k	k	k

ρ k−1
(tk−1
∗
k−1
σ) →∗ rσ	(Tran)

where the (Repl) step uses rule (2) from Definition 4.1.
Proof tree for (K) using the proof tree for (H1): We assume that we have already constructed a proof tree T1 for the goal (H1) = U ρ(s1σ, x∗σ) →∗ rσ.
1	1
Then, we can construct a proof tree for the goal s →∗ t as follows:
s → U ρ(s σ, x∗σ) (Repl)	T
s →∗ t	(Tran)

where the (Repl) step uses rule (1) from Definition 4.1.
As in case I., if the original proof tree is not closed, then the transformed tree is cut at some level. In either case, β(T ) is well-formed if T is well-formed and β(T ) ⊂ β(T ') if T ⊂ T '.	 
Lemma 4.3 now easily implies the following result.
Theorem 4.6 (R, S, S ) is operationally terminating if (U (R), S, S ) is operationally terminating.
In combination with Lemma 3.6 we get the key result of the present paper.
Corollary 4.7 (R, S, S ) is operationally terminating if (U (R), S, S ) is terminating.
Example 4.8 The following CCES speciﬁes the sieve of Eratosthenes. primes(x) returns a list containing the prime numbers up to x. In this example we have S = S = ∅.
primes(x) → sieve(nats(2, x))
nats(x, y) → nil	 x > y) nats(x, y) → cons(x, nats(x + 1, y)) x /> y) sieve(nil) → nil
sieve(cons(x, ys)) →  cons(x, sieve(filter(x, ys)))
filter(x, nil) → nil
isdiv(x, y) →∗ true | filter(x, cons(y, zs)) → filter(x, zs)

isdiv(x, y) →∗ false | filter(x, cons(y, zs)) → cons(y, filter(x, zs))
isdiv(x, 0) → true	 x > 0)
isdiv(x, y) → false	 x > y ∧ y > 0)
isdiv(x, x + y) → isdiv(x, y)	 x > 0)
Using Deﬁnition 4.1 we obtain the following U (R).

By Corollary 4.7 the CCES (R, ∅, ∅) is operationally terminating if the uncondi- tional CES (U (R), ∅, ∅) is terminating. Termination of (U (R), ∅, ∅) is shown in [6, Appendix F.2].	 

Conclusions and Future Work
We have presented conditional constrained equational rewrite systems for specifying algorithms. Rewriting with these systems is based on normalized equational rewrit- ing combined with evaluation of conditions and validity checking of instantiated constraints. Semantic data structures like finite sets, multisets, and sorted lists are modeled using constructor rules and equations. Natural numbers are built-in and constraints are taken from Presburger arithmetic.
We have shown that operational termination of such conditional systems can be reduced to termination of unconditional systems using a syntactic transformation. Powerful methods based on dependency pairs for showing termination of uncondi- tional systems are presented in [9]. These methods can thus be used for showing operational termination of conditional systems as well. Using this approach, oper-

ational termination of several nontrivial conditional systems is shown in [6].
We will next study properties apart from operational termination. In particular, we will investigate confluence and sufficient completeness. Orthogonal to this, we plan to generalize the rewrite relation by considering other built-in theories, most importantly integers instead of natural numbers.

References
Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, 1998.
Bertling, H. and H. Ganzinger, Completion-time optimization of rewrite-time goal solving, in:
N. Dershowitz, editor, Proceedings of the 3rd Conference on Rewriting Techniques and Applications (RTA ’89), Lecture Notes in Computer Science 355 (1989), pp. 45–58.
Blanqui, F., T. Hardin and P. Weis, On the implementation of construction functions for non- free concrete data types, in: R. D. Nicola, editor, Proceedings of the 16th European Symposium on Programming (ESOP ’07), Lecture Notes in Computer Science 4421 (2007), pp. 95–109.
Clavel, M., F. Dur´an, S. Eker, Patrick, Lincoln, N. Mart´ı-Oliet, J. Meseguer and C. Talcott, “All About Maude–A High-Performance Logical Framework,” Lecture Notes in Computer Science 4350, Springer-Verlag, 2007.
Dur´an, F., S. Lucas, C. March´e, J. Meseguer and X. Urbain, Proving operational termination of membership equational programs, Higher-Order and Symbolic Computation 21 (2008), pp. 59–88.
Falke, S. and D. Kapur, Dependency pairs for rewriting with built-in numbers and semantic data structures, Technical Report TR-CS-2007-21, Department of Computer Science, University of New Mexico (2007), available at http://www.cs.unm.edu/research/tech-reports/.
Falke, S. and D. Kapur, Dependency pairs for rewriting with non-free constructors, in: F. Pfenning, editor, Proceedings of the 21st Conference on Automated Deduction (CADE ’07), Lecture Notes in Artificial Intelligence 4603 (2007), pp. 426–442.
Falke, S. and D. Kapur, Operational termination of conditional rewriting with built-in numbers and semantic data structures, Technical Report TR-CS-2007-22, Department of Computer Science, University of New Mexico (2007), available at http://www.cs.unm.edu/research/tech-reports/.
Falke, S. and D. Kapur, Dependency pairs for rewriting with built-in numbers and semantic data structures, in: A. Voronkov, editor, Proceedings of the 19th Conference on Rewriting Techniques and Applications (RTA ’08), Lecture Notes in Computer Science 5117 (2008), pp. 94–109.
Giesl, J. and D. Kapur, Dependency pairs for equational rewriting, in: A. Middeldorp, editor, Proceedings of the 12th Conference on Rewriting Techniques and Applications (RTA ’01), Lecture Notes in Computer Science 2051 (2001), pp. 93–108.
Lucas, S., C. March´e and J. Meseguer, Operational termination of conditional term rewriting systems, Information Processing Letters 95 (2005), pp. 446–453.
March´e, C., Normalized rewriting: An alternative to rewriting modulo a set of equations, Journal of Symbolic Computation 21 (1996), pp. 253–288.
Ohlebusch, E., “Advanced Topics in Term Rewriting,” Springer-Verlag, 2002.
Peterson, G. E. and M. E. Stickel, Complete sets of reductions for some equational theories, Journal of the ACM 28 (1981), pp. 233–264.
Presburger, M., U¨ber die Vollsta¨ndigkeit eines gewissen Systems der Arithmetik ganzer Zahlen, in welchem die Addition als einzige Operation hervortritt, in: Comptes Rendus du Premier Congr`es de Math´ematiciens des Pays Slaves, 1929, pp. 92–101.
