Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 87‚Äì120
www.elsevier.com/locate/entcs
The Effects of Effects on Constructivism
Liron Cohena, Sofia Abreu Faro and Ross Tatea
a Department of Computer Science Cornell University
Ithaca, NY 14853-7501

Abstract
It is commonly understood that Countable Choice holds constructively due to the underlying computa- tional nature of constructivism. However, in this paper we demonstrate that invoking different notions of computation result in radically different behaviors regarding Countable Choice. In particular, we illustrate that, although deterministic computation guarantees Countable Choice, non-deterministic computation can negate Countable Choice. We then further show that using stateful computation can restore Countable Choice even in the presence of non-determinism. This finding suggests that much of the modern discourse of constructivism assumes a deterministic underlying computational system, despite non-determinism being a fundamental aspect of modern-day computation.
Keywords: constructivism, effects, countable choice, non-determinism, stateful computation

Introduction
As software has grown increasingly critical to our society‚Äôs infrastructure, mechan- ically verified software has grown increasingly important, feasible, and prevalent. Proof assistants such as Coq [5], Agda [8], Twelf, and Nuprl [1, 14] are some of the most popular tools for mechanical verification. Each of these proof assistants sits on top of a computational system that embodies the mathematical philosophy of constructivism ‚Äúunder which an object exists only if we can construct it‚Äù [9]. In proof assistants, construction is done through programs via a tight correspondence to proofs often referred to as the proofs-as-programs paradigm [2].
This paradigm, most famously exhibited by the BHK interpretation, grounds constructivism in computation [43]. Yet there are many different notions of com- putation. While Turing machines and the Œª-calculus crosscut these notions, even they have some subtlety. For example, an algorithm is required to terminate on all inputs, but the definition of termination varies in non-classical settings. One definition gives Markov‚Äôs Principle [28], where an iterative computation terminates if it cannot proceed indefinitely; another definition gives Bar Induction [12], where a recursive computation terminates if every possible recursion path encounters a

https://doi.org/10.1016/j.entcs.2019.09.006
1571-0661/¬© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

base case; and there are yet more definitions. Thus it is well known that some constructive principles depend on the specifics of what one considers to entail com- putation [9].
Nonetheless, some principles are often considered to transcend such details about computation, meaning their verity or falsity is independent of the particular notion of computation employed. A notable example is Countable Choice (CC), which is widely accepted amongst contructivists [7, 9, 25, 32, 33, 36, 44], though not uni- versally [37‚Äì41]. Put simply, CC states that any total relation from the natural numbers has a corresponding function exhibiting the totality of that relation. It has been shown that CC holds for any model of type theory standardly constructed from any model of the Œª-calculus‚Äîmore specifically from any partial combinatory algebra [15, 17, 47]‚Äîand as such is independent of factors such as a particular def- inition of termination. In essence, the computation realizing the proof of totality itself describes the desired choice function. This example is particularly important to constructivism because CC is often relied upon to achieve what classically would be done through the Law of Excluded Middle (LEM). For example, without CC and LEM the types (not to be confused with setoids) of (modulated) Cauchy re- als are not necessarily Cauchy complete, nor are they necessarily equivalent to the Dedekind reals [27]. CC unifies the most common constructive formulations of the reals, namely the Cauchy, modulated Cauchy, and Dedekind reals [10].
However, in this paper we illustrate that the standard justification for CC makes an implicit assumption about computation, one that underlies much of the discourse of constructivism. That assumption is that the computation used to construct an object (in order to show it exists) is deterministic. Indeed, the computational systems underlying every major proof assistant are all deterministic. While some systems such as Coq rely on canonicalization to achieve decidable type-checking, even undecidable extensional systems like Nuprl have coincidentally all made their computational systems deterministic. That is, while there is significant research in constructively modeling and reasoning about non-deterministic computation, non- deterministic computation has not itself been directly incorporated into the compu- tational systems underlying proof assistants.
We show how non-deterministic computation can be soundly incorporated into these computational systems. In fact, the standard computational models of type theory trivially extend to non-deterministic computation‚Äînone of the definitions or proofs for these models were truly utilizing the deterministic assumption. However, the same is not true for principles that were derived from these standard models. For example, we show that adding even a modicum of non-determinism, in the form of a possibilistic coin flip, not only makes CC no longer hold in the model, it in fact makes the negation of CC hold. This formally supports Schuster‚Äôs philosoph- ical concern that CC would be incompatible with non-deterministic extensions to constructivism [41].
Non-determinism is just one example of effectful computation. Thus, we also consider the impact of stateful computation on constructive models. We show that, in addition to still forming a consistent model of type theory, stateful computation

can be used to restore CC even in the presence of non-determinism. This is because state can be used to memoize [29] computations. Thus CC can be implemented by memoizing the computation contained in the proof of totality. This suggests that constructive systems wanting to directly support (rather than just model) probabilistic or non-deterministically parallel algorithms should also support some form of state as well in order to be consistent with CC and the unification of the reals.

Background
While our discussion will be focused on constructive type theory, we want our find- ings to be relevant to set theory as well, and so we must discuss type theories with appropriate expressivenes. Since we will be building multiple such type theories to evaluate the various impacts of effects, to focus on the computational aspects of these theories we rely on known tools to generate the boilerplate. To this end we provide background on topos theory and tripos theory corresponding to models of type/set theory and higher-order logic.

From Set Theory to Topos Theory
In order to be comparable to common set theories, a type theory needs to exhibit certain important properties. One is that proofs must be irrelevant but not erased, meaning proofs can be used in computations so long as the result of the computation does not depend on the specifics of the proof. This enables functions to correspond to total and determined relations. Another is extensionality of entailment, i.e. that equality on predicates is extensional. This enables the correspondence between functions and total, determined relations to be bijective. Lastly, propositions must be impredicative, meaning there is a type/set (not just universe) of propositions, denoted Œ©. This enables the construction of powersets.
Altogether these requirements place us in the setting of (elementary) topos the- ory [23]. Toposes are well established to form models of both set theory and exten- sional dependent type theories with impredicative propositions [34]. More specif- ically, since we here focus on Countable Choice, we work within the context of W -topos theory, i.e. toposes with a natural-number object modeling the natural numbers.

From Tripos Theory to Topos Theory
We will be particularly interested in toposes constructed from triposes [19, 35]. A tripos is a model of higher-order logic whose type theory is modeled by sets and functions. 1  Higher-order logic has a simple type theory‚Äîunit, pairs, and

1 A tripos is actually a model of higher-order dependent predicate logic whose dependent type theory is modeled by sets and functions, but the additional dependent structure is irrelevant for our purposes. We use triposes solely in order to construct toposes, and the process for doing so applies to any model of higher-order (simple) logic over any (simple) type theory [20, Corollary 6.1.7].

functions‚Äîand a predicate logic formed by T, ‚ä•, conjunction, disjunction, impli- cation, equality, and universal and existential quantification. Importantly, the type theory also includes a type, Œ©, of propositions, whose terms correspond to proposi- tions in the predicate logic. Thus, higher-order logic provides a means of abstractly reasoning about relations, including impredicative quantification over propositions. Given a tripos modeling higher-order logic (or more generally a higher-order fibration [20, Definition 5.3.1] 2 ), one can construct a topos via the ‚Äútripos-to-topos construction‚Äù [19]. Whereas the tripos models a simple type theory, the resulting topos is well established to model a dependent type theory. And whereas the tripos might not model extensionality of entailment, the resulting topos necessarily will.
Thus the tripos-to-topos construction enables us to work in a simpler setting, with the more complex constructions being automatically generated for us.
Since this construction is standard, we only review the key components. First, an object in the constructed topos is given by a pair ‚ü®I, ‚âàI‚ü© of a type I and a partial- equivalence relation ‚âàI on I√óI in the tripos. Second, a morphism in the constructed topos from ‚ü®I, ‚âàI‚ü© to ‚ü®J, ‚âàJ ‚ü© is a relation R on I √ó J that respects ‚âàI and ‚âàJ in the tripos. This relation must be total, meaning ‚àÄi : I. i ‚âàI i ‚äÉ ‚àÉj : J. i R j holds in the tripos, and determined, meaning ‚àÄi : I, j, jj : J. i R j ‚àß i R jj ‚äÉ j ‚âàJ jj holds in the tripos. Furthermore, two morphisms are considered equal if their relations are equivalent in the tripos, effectively baking in extensionality of entailment.

Realizability Toposes and Triposes
The tripos-to-topos construction is often used for building realizability models [24, 47] of (extensional, impredicative) dependent type theory. In particular, a real- izability topos is a topos that is constructed from a realizability tripos, where a realizability tripos is a tripos that is constructed from a partial combinatory alge- bra (of codes) through a process we discuss in Section 3.2. The key intuition is that a predicate on a set I specifies for each element i of I which codes (if any) ‚Äúrealize‚Äù that the predicate holds for i. This means that an object in the resulting realizability topos is a set I (from the metatheory) along with a relation i ‚âàI ij specifying which codes (if any) are considered to realize that i and ij are equal. A common example takes I to be set of natural numbers N and takes n ‚âàN nj to be realized solely by the Church encoding of n when n and nj are equal, and by nothing otherwise. Thus objects in a realizability topos conceptually specify a set I along with a computational interpretation of equality on I.
Another example is the object representing the powerset of natural numbers. For this object the set I is the set of predicates on N in the tripos. The predi- cate ‚âàI states that a code realizes that two predicates œÜ and œà are equivalent if it can convert any realizer of œÜ(n) into the Church encoding of n and it can convert any realizer of œÜ(n) into a realizer of œà(n) and vice versa. Thus two predicates are con-

2 There is an error in this definition due to a change in terminology across works [21]. The definition should only require a weak generic object. This is relevant and evident because realizability triposes have a strict generic object, which can only be shown to be weak generic objects. Non-weak generic objects furthermore model extensionality of entailment.

sidered equivalent if they are computationally strict, i.e. there is a computation that can extract the natural number for which the realizer holds, and computationally equivalent, i.e. there is a computation that can convert between the realizers.
Note that ‚âàI is not reflexive since there may not be a way to computationally realize that a predicate is strict. Hence, the predicate i ‚âàI i is often called the ‚Äúex- istence predicate‚Äù for i as it indicates that i ‚Äúexists‚Äù. The definition of morphisms is designed so that they conceptually need only handle elements that exist according to this existence predicate.


Relating Topos and Tripos Models of Higher-Order Logic
A topos has an internal model of higher-order logic given by its subobjects, i.e. sub- sets [20, Corollary 5.4.9]. When a topos is constructed from a tripos, the inter- nal model of the topos is closely related to the associated tripos. In particular, (equivalence classes of) subobjects of ‚ü®I, ‚âàI‚ü© in the topos bijectively correspond to (equivalence classes of) predicates on I that are strict with respect to ‚âàI in the tripos [20, Proposition 6.1.6(ii)]. As such, the interpretations of many propositional connectives, like conjunction, coincide in the two models.
However, there are some differences between these models. For example, the quantification ‚àÄi : ‚ü®I, ‚âàI‚ü©. œÜ(i) in the topos corresponds to the quantification ‚àÄi :
I. i ‚âàI i ‚äÉ œÜ(i) in the tripos, and similarly ‚àÉi : ‚ü®I, ‚âàI‚ü©. œÜ(i) in the topos corresponds to ‚àÉi : I. i ‚âàI i ‚àß œÜ(i) in the tripos [20, Proposition 6.1.6(iii)]. That is, whenever the topos quantifies over an element i : ‚ü®I, ‚âàI‚ü©, the translation of that quantifi- cation in the tripos quantifies over an element of i : I and insists that i ‚Äúexists‚Äù,
i.e. i ‚âàI i. This step in the translation is particularly important for realizability toposes since it means that proofs of ‚àÄi : ‚ü®I, ‚âàI‚ü©. œÜ(i) can have access to a realizer that i ‚Äúcomputationally exists‚Äù, i.e. i ‚âàI i, and that proofs of ‚àÉi : ‚ü®I, ‚âàI‚ü©. œÜ(i) must provide a realizer that i ‚Äúcomputationally exists‚Äù.


Countable Choice in a Tripos
CC has an internal and an external definition in topos theory that correspond to internal and external CC in set theory [23, 45]. In this paper we discuss internal CC because we are concerned about whether it can be used within the theory.
Definition 2.1 (Internal CC for Topos) CC holds internally in a W-topos when the following holds in its internal model of higher-order logic for all objects œÑ:
‚àÄR : N √ó œÑ ‚Üí Œ©. (‚àÄn : N.‚àÉt : œÑ. n R t) ‚äÉ ‚àÉf : N ‚Üí œÑ.‚àÄn : N. n R f (n)
In this paper we focus on toposes constructed from triposes, so we focus on this definition‚Äôs counterpart in tripos theory.
Definition 2.2 (Internal CC for Tripos) CC holds internally in a tripos when the following holds in its internal model of higher-order logic for all sets I:

‚àÄR : N √ó I ‚Üí Œ©.	Tot(R) ‚äÉ ‚àÉS : N √ó I ‚Üí Œ©. Tot(S) ‚àß S ‚äÜ R ‚àß Det(S)
where	Tot(R)	‚àÄn : N. ùïün ‚äÉ ‚àÉi : I. n R i
ùïün	‚àÄœÜ : N ‚Üí Œ©. œÜ(0) ‚àß (‚àÄnj : N. œÜ(nj) ‚äÉ œÜ(nj+1)) ‚äÉ œÜ(n) 3
S ‚äÜ R	‚àÄn : N,i : I. n S i ‚äÉ n R i
Det(S)	‚àÄn : N, i, ij : I. n S i ‚àß n S ij ‚äÉ i =I ij



Lemma 2.3 A W-topos constructed from a tripos internally models CC iff the tripos internally models CC.
Proof In the case where œÑ is of the form ‚ü®I, =I‚ü©, this follows easily from interpret- ing Definition 2.1 in the model of strict predicates of the tripos, which is equiv- alent to the internal model of the topos constructed from that tripos [20, Propo- sition 6.1.6(ii)]. For œÑ of the form ‚ü®I, ‚âàI‚ü©, the S given by Definition 2.1 only re- spects =I , so one then defines n Sj i as ‚àÉij : I. ij ‚âàI i ‚àß n S ij to get the appropriate relation that furthermore respects ‚âàI .	2
In the sequel we construct three triposes each based on a different notion of computation with respect to which effects are directly incorporated into the com- putational model. Using Lemma 2.3, we demonstrate that varying one‚Äôs notion of computation wildly affects the validity of CC in the resulting constructive type theory.
In order to avoid digressing into low-level details or metatheoretic concerns, we take ZFC [46] as our prevailing metatheory, though we do make a point to note where this particular choice of metatheory is relevant. All of the following lemmas and theorems have been mechanically verified, with more care taken towards metatheoretic concerns, so we refer readers interested in those details to the Coq proofs [13] or appendices.
Constructivism and Determinism
Realizability is at the heart of constructivism as it captures the notion of extracting (computable) content from proofs. In turn, partial combinatory algebras [15, 17] are at the heart of realizability as they formalize the key components of compu- tation that serve the proofs-as-programs correspondence. Indeed, a topos is called a realizability topos if it can be derived through a standard construction from a partial combinatory algebra. Due to the properties of this construction and of par- tial combinatory algebras, every realizability topos models CC [47], supporting the common understanding that CC holds constructively [7,9,25,32,33,36,44]. Next we review partial combinatory algebras and the relevant standard constructions, and we illustrate why CC follows from these foundations of constructivism.
3 ùïü is designed so that defining n ‚âàN n‚Ä≤ as n =N n‚Ä≤ Œõ ùïün makes ‚ü®N, ‚âàN‚ü© a natural-number object in the constructed topos.

Partial Combinatory Algebras


Put simply, a computation accepts inputs and produces outputs. These inputs and outputs can themselves describe computation, i.e. computations are also data. A combinatory algebra formalizes this view, which is critical to developing Turing- complete systems like the Œª-calculus, via a set of codes and an ability to apply codes to one another to produce outputs. However, another important aspect of Turing-completeness is that computations may not always manage to actually pro- duce an output, i.e. terminate. A partial combinatory algebra incorporates this by permitting application of codes to be partial.
Partial combinatory algebras are formalized in two steps. The first introduces the concepts of codes and application of codes‚Äîknown as a partial applicative struc- ture. The second step then ensures that the partial applicative structure has the necessary expressiveness for modeling computational systems like the Œª-calculus.
Definition 3.1 (Partial Applicative Structure) A partial applicative structure is a set C of ‚Äúcodes‚Äù c and a partial binary ‚Äúapplication‚Äù operator ¬∑ on C. We use cf ¬∑ ca ‚Üì cr to denote cr being the (successful) result of the application cf ¬∑ ca.
Given a partial applicative structure, one can consider application ‚Äúexpressions‚Äù such as (c1 ¬∑(c2 ¬∑ c3)) ¬∑(c4 ¬∑ c5). A partial combinatory algebra is a partial applicative structure that is ‚Äúfunctionally complete‚Äù, meaning there is a way to encode such expressions with n free variables as individual codes accepting n arguments through applications.



e ::= i ‚àà N | c ‚àà C | e ¬∑ e
En = {e | all is in e are < n}
c ‚Üì c
ef ‚Üì cf	ea ‚Üì ca	cf ¬∑ ca ‚Üì cr
ef ¬∑ ea ‚Üì cr


Definition 3.2 (Partial Combinatory Algebra) A partial combinatory algebra (PCA) is a partial applicative structure with an assignment of every expression e ‚àà En+1 to a code cŒªn.e ‚àà C that conceptually embodies the Œª-calculus term binding the n +1 free variables in e, as formalized by the following requirements:
‚àÄn.‚àÄe ‚àà En+2.‚àÄca. cŒªn+1.e ¬∑ ca ‚Üì cŒªn.e[ca]	‚àÄe ‚àà E1.‚àÄca, cr. cŒª0.e ¬∑ ca ‚Üì cr ‚áê‚áí
e[ca] ‚Üì cr
Perhaps the more standard definition of PCAs is as partial applicative structures with S and K combinators satisfying certain behaviors [47]. These combinators are simply encodings of particular expressions that are sufficient to ensure that all ex- pressions can be encoded. In our formalization, the S and K combinators are simply the codes cŒª2.(0 ¬∑ 2) ¬∑(1 ¬∑ 2) and cŒª1.0 modeling the Œª-calculus terms Œªx.Œªy.Œªz. (x z) (y z) and Œªx.Œªy.x, respectively. Similarly, one can define a code cŒª that Church-encodes

the natural number n:
cŒª = cŒª1.1	cŒª

= cŒª1.0 ¬∑((cŒª ¬∑ 0) ¬∑ 1)

0	n+1	n

Modeling Higher-Order Logic with PCAs
Given a PCA one can construct its corresponding realizability tripos via a standard construction [47]. The core intuition behind a realizability tripos is that a predicate on a set I specifies for each element i which codes from the PCA serve as realizers that the predicate holds for i, and that one predicate œÜ entails another œà when there is a uniform code that converts all the realizers of œÜi, i.e. œÜ(i), to realizers of œài for every i in I. Uniformity means that the code does not itself depend on i‚Äîthe same code must work for all elements of I.
Uniformity is critical for ensuring entailment corresponds to computation. To see why, consider the fact that in every realizability tripos there is a predicate ùïü on the natural numbers N specifying that its only realizer for a natural number n is its Church encoding cŒª. Given a function f : N ‚Üí N in the metatheory, we can define another predicate on the natural numbers, call it œÜf , whose only realizer for
a given n is cŒª	. Consider what it means for ùïü to entail œÜf . If entailment could be
evidenced by a different code cn for each n ‚àà N, then ùïü entails œÜf for any function f

since cn could be the constant computation that returns cŒª
. However, requiring

a uniform code that works for all indices n ‚àà N ensures the predicate ùïü entails œÜf if and only if f is computable according to the PCA at hand. Thus uniformity ensures that entailment actually has computational significance.
With these intuitions in mind, we can informally describe how the various propo- sitional connectives are modeled by realizability triposes, with formal descriptions to come as a special case of the more general system in Figure 2. The realizers of a conjunction œÜ1 ‚àß œÜ2 are simply the Church-encoded pairs of realizers of œÜ1 and œÜ2. The realizers of an implication œÜ1 ‚äÉ œÜ2 are simply the codes that, when applied to a realizer of œÜ1, necessarily produce a realizer of œÜ2. There are no realizers for ‚ä•, and the realizers of a disjunction œÜ1 ‚à® œÜ2 are the Church-encoded tagged unions of realizers of œÜ1 and realizers of œÜ2. A realizer of a universal quantification ‚àÄi:I.œÜi (for inhabited I) is anything that is a realizer of œÜi for every i ‚àà I, whereas a realizer of an existential quantification ‚àÉi:I.œÜi is anything that is a realizer of œÜi for some i ‚àà I. Lastly, any code is a realizer of T, and any code is a realizer of i =I ij if and only if i and ij are equal in I in the metatheory.
Notice that the realizers for the quantifiers are themselves uniform. That is, a realizer of ‚àÉi:I.œÜi has no computational way of knowing which i it is a realizer for, and similarly a realizer of ‚àÄi:I.œÜi cannot computationally depend on the index i. Thus there is a difference between, for example, realizers of ‚àÄn:N.œÜn versus realizers of ‚àÄn:N. ùïün ‚äÉ œÜn. A realizer of the former must be a single code that simultaneously realizes all œÜns, whereas a realizer of the latter is a computation that maps each n to a realizer of œÜn.

Countable Choice in Realizability Triposes
Now we consider Countable Choice with this model of higher-order logic in mind. For this, we introduce a new notation, ‚Äú‚àÉi : I | œÜi. œài‚Äù, indicating that there internally exists an i in I that externally satisfies œÜi and internally satisfies œài.

A realizer of ‚àÉi : I | œÜi. œài is anything that is a realizer of œài for some i ‚àà I satisfying œÜi. We also denote n R i with R‚ü®n,i‚ü©, and we use R‚ü®n,i‚ü©(c) to denote that c is a realizer for R‚ü®n,i‚ü©.
Lemma 3.3 CC is equivalent in every realizability tripos to the following holding for every set I:
‚àÄR : N √ó I ‚Üí Œ©. Tot(R) ‚äÉ ‚àÉS : N √ó I ‚Üí Œ© | S ‚äÜ R Œõ Det(S). Tot(S)
where
S ‚äÜ R = ‚àÄn, i, c. S(n,i‚ü©(c) =‚áí R(n,i‚ü©(c)	Det(S)= ‚àÄn, i, i‚Ä≤, c, c‚Ä≤. S(n,i‚ü©(c) Œõ S(n,i'‚ü©(c‚Ä≤) =‚áí i = i‚Ä≤

Proof [13, E-A3] Given Lemma 2.3, this lemma essentially states that inclusion and determinism can be proven computationally if and only if they can be proven in the metatheory. The backwards direction of this is simple. Unfolding definitions, a realizer of inclusions is a code that uniformly converts realizers of S‚ü®n,i‚ü© to realizers of R‚ü®n,i‚ü©. If inclusion is provable in the metatheory, then the identity computation exhibits inclusion trivially. Unfolding the definition of determinism, note that the equality predicate =I is computationally vacuous, meaning the realizers have no computational value beyond whether a realizer exists at all. In this case, i =I ij has a realizer if and only if i and ij are equal (in I) in the metatheory. Consequently, Det is itself computationally vacuous; it has a realizer if and only if S‚ü®n,i‚ü© and S‚ü®n,i‚Ä≤‚ü© both have realizers for a given n only when i equals ij in the metatheory. Thus, if determinism is provable in the metatheory, then the identity computation exhibits determinism since equality is realized by anything provided the equality holds.
The greater challenge is the forwards direction: showing there is a relation where inclusion and determinism hold in the metatheory whenever there is an appropriate relation where inclusion and determinism are proven computationally.  Given a

realizer cc of CC and a realizer cR
of totality for some relation R, then applying cc

R
tot
necessarily results in a triple of codes cS
S
det
, and cS
that realize inclusion,

determinism, and totality, respectively, for some relation S. Define a new relation SÀÜ

such that SÀÜ
is realized by c when R‚ü®n,i‚ü©
is realized by c and S‚ü®n,i‚ü©
has a realizer

(which can be anything). Clearly SÀÜ is included in R in the metatheory. Similarly,
SÀÜ is determined in the metatheory because it has realizers for ‚ü®n, i‚ü© and ‚ü®n, ij‚ü© only

when S does, which the existence of cS
realizing Det(S) in turn implies that i

and ij are equal. Lastly, totality of SÀÜ is realized by the sequential composition

S
tot
realizing totality of S and cS
realizing inclusion of S into R.	2

Theorem 3.4 CC is modeled by every realizability tripos.
Proof [13, E-B1; adapted from 18] By Lemma 3.3, it is sufficient to provide a code that converts realizers that an arbitrary relation R is total into realizers that some metatheoretically-determined subrelation S of R is total. That code is simply the identity computation cŒª0.0. To see why, note that the definition of S can depend on
the specific realizer cR that R is total. By the definition of totality, applying cR
to the Church encoding of any natural number n must result in a realizer, say cn, of R‚ü®n,i‚ü© for some index i ‚àà I, without specifying or even necessarily knowing what i is. In fact, the returned code might even be a realizer of R‚ü®n,i‚ü© for multiple indices

in I. Let in ‚àà I be such a corresponding index for each n ‚àà N. 4 Define S‚ü®n,i‚ü© to be realized by cn if and only if i equals in, trivially making S determined. Since each cn is a realizer of R‚ü®n,in‚ü©, S is a subrelation of R. Because application is deterministic,
applying cR to the Church encoding of n will always result in cn and hence always
be a realizer of S‚ü®n,in‚ü©, thereby realizing totality.	2
Thus all realizability toposes, which by definition are derived from PCAs, nec- essarily model CC.

Introducing Non-Deterministic Computation
Notice that the fact that application is deterministic is critical to the proof that realizability models exhibit CC. However, as we show next, determinism is entirely irrelevant to the realizability interpretation of higher-order logic. Rather, determin- ism is simply a historical artifact imposing an artificial constraint, and realizability can actually be similarly formulated on the basis of non-deterministic, i.e. relational, combinatory algebras. Thus, in this section we develop relational combinatory al- gebras, illustrate how they naturally still form a model of higher-order logic, and demonstrate that this natural generalization has dramatic effect on constructivism, with something as simple as a coin flip changing CC from being necessarily true to being necessarily false.

Relational Combinatory Algebras
In order to directly model non-deterministic computation, we developed relational combinatory algebras (RCAs), a generalization of PCAs in which the application operator is relational rather than functional. Thus applying one code to another can have zero, one, or many possible outcomes.
There is a subtlety to address though. Because PCAs are deterministic, if an application results in some code then that application always terminates. However, with RCAs, an application can successfully result in a code on one execution yet fail to terminate on another execution. Thus RCAs need a termination predicate in addition to an application relation.
Definition 4.1 (Relational Applicative Structure) A relational applicative struc- ture is a set C of ‚Äúcodes‚Äù c, an ‚Äúapplication‚Äù relation cf ¬∑ ca ‚Üì cr, and a ‚Äútermina- tion‚Äù predicate cf ¬∑ ca‚Üì satisfying the following:
Progress ‚àÄcf , ca. cf ¬∑ ca‚Üì =‚áí ‚àÉcr. cf ¬∑ ca ‚Üì cr
For a relational applicative structure, one can extend the termination predi- cate e‚Üì to applicative expressions:
ef ‚Üì	ea‚Üì	‚àÄcf , ca. ef ‚Üì cf ‚àß ea ‚Üì ca =‚áí cf ¬∑ ca‚Üì
c‚Üì	ef ¬∑ ea‚Üì

4 This assumes CC in the metatheory, which is standard practice here, and which is why we assume specifically ZFC in this paper.




c ::= Œªn.En+1 | n | p
e[c]‚Üì	e[c] ‚Üì c‚Ä≤

   
(Œª0.e) ¬∑ c‚Üì	(Œª0.e) ¬∑ c ‚Üì c‚Ä≤	(Œªn+1.e) ¬∑ c‚Üì	(Œªn+1.e) ¬∑ c ‚Üì Œªn.e[c]

p ::= constn | succ | on ‚Üín do p else p‚Ä≤ | flip
‚Üín ::= n,... 
p ¬∑ n‚Üì	constn' ¬∑ n ‚Üì n‚Ä≤	succ ¬∑ n ‚Üì n +1	flip ¬∑ n ‚Üì 0	flip ¬∑ n ‚Üì 1


n ‚àà ‚Üín	p ¬∑ n ‚Üì n‚Ä≤
(on ‚Üín do p else p‚Ä≤) ¬∑ n ‚Üì n‚Ä≤



n ‚àà/ ‚Üín	p‚Ä≤ ¬∑ n ‚Üì n‚Ä≤
(on ‚Üín do p else p‚Ä≤) ¬∑ n ‚Üì n‚Ä≤


Figure 1. Flip-RCA
Definition 4.2 (Relational Combinatory Algebra) A relational combinatory algebra is a relational applicative structure with an assignment of expressions e ‚àà En+1 to codes cŒªn.e ‚àà C satisfying the followings:
‚àÄn.‚àÄe ‚àà En+2.‚àÄca, cr.	cŒªn+1.e ¬∑ ca ‚Üì cr =‚áí cr = cŒªn.e[ca]
‚àÄe ‚àà E1.‚àÄca, cr.	cŒª0.e ¬∑ ca ‚Üì cr =‚áí e[ca] ‚Üì cr
‚àÄn.‚àÄe ‚àà En+2.‚àÄca.	cŒªn+1.e ¬∑ ca‚Üì
‚àÄe ‚àà E1.‚àÄca.	e[ca]‚Üì =‚áí cŒª0.e ¬∑ ca‚Üì
Each of these definitions are the straightforward generalizations of PCAs to non- terminating non-deterministic computation. That is, PCAs are simply the special case of RCAs in which application is deterministic and implies termination:

‚àÄcf , ca, cr, cj . cf ¬∑ ca ‚Üì cr ‚àß cf ¬∑ ca ‚Üì cj =‚áí cr = cj
‚àÄcf , ca, cr. cf ¬∑ ca ‚Üì

r	r	r
cr =‚áí cf ¬∑ ca‚Üì

Modeling Higher-Order Logic with RCAs
Given an RCA one can construct its corresponding RCA tripos. All truths in this tripos are still realizable, suggesting that having the term ‚Äúrealizability tripos‚Äù refer specifically to PCAs is a misnomer. As such, we introduce the more accurate term ‚ÄúPCA tripos‚Äù for that particular notion of realizability.
The core intuition behind an RCA tripos is exactly the same as fora PCA tripos. A predicate on a set I specifies which codes from the RCA serve as realizers that the predicate holds for a particular element i. A predicate œÜ entails another predicate œà when there is a uniform code that for all i ‚àà I terminates when applied to any realizer of œÜi and any possible resulting code is a realizer of œài. The constructions and the proofs are all the same as well, with formal descriptions to come as a special case of the more general system in Figure 2. Thus the deterministic behavior of PCAs is surprisingly irrelevant to their ability to model higher-order logic (and type theory), suggesting that RCAs are actually a more natural fit for realizability theory.
Refuting Countable Choice with Non-Determinism
This natural generalization of realizability theory, however, has major consequences. In particular, in Figure 1 we present Flip-RCA, an RCA whose corresponding tripos refutes CC simply due to the presence of a coin flip.
Flip-RCA is comprised of three key parts. The first is the Œªn.En+1 construct,

which describes a Œª-value with n + 1 variables. This construction makes functional completeness trivial, since the code cŒªn.e is simply given by Œªn.e. The termina- tion and reduction rules are standardly defined to guarantee such codes behave as required by functional completeness.
The second key part is the natural-number codes n and primitives succ and on ‚Üín do p else pj. These are not strictly necessary, but they make the proof much simpler due to the fact that every ‚Äúprimitive‚Äù p only accepts inputs and produces outputs of the form n. In particular, on ‚Üín do p else pj emulates the behavior of p on a finite list of inputs ‚Üín and otherwise defers to pj. Also, defining cast(e) as e ¬∑ succ ¬∑ 0 provides an expression that evaluates to n whenever the expression e evaluates to the Church encoding of n.
The third key part is flip, the only source of non-determinism in the system that makes this an RCA that is not a PCA. All flip does is non-deterministically evaluate to either 0 or 1.
Lemma 4.3 Flip-RCA is an RCA.
Proof [13, E-C2] The cŒªn.e codes are given by the Œªn.e codes.	2
This simple coin flip is enough to refute CC. To demonstrate how, we rely on the following lemma capturing the fact that Flip-RCA describes an extensional finitary
computational system. In the lemma we use cÀô to informally denote codes with
a ‚Äúprimitive hole‚Äù such that cÀô[p] denotes the code resulting from filling that hole with the primitive p. The formal definitions are tedious and thus omitted here, but can be found in [13, E-C3]. The lemma states that any reduction involving a primitive follows from only finite interactions with that primitive, and so the reduction can proceed similarly for any other primitive that can also exhibit those same interactions.
Lemma 4.4 For all cÀôf , cÀôa, p, and cr, such that cÀôf [p] ¬∑ cÀôa[p] ‚Üì cr holds, there exists a cÀôr satisfying:
cr = cÀôr[p] ‚àß ‚àÉB ‚äÜ N √ó N. B is Ô¨Ånite ‚àß ‚àÄ‚ü®ni, no‚ü©‚àà B. p ¬∑ ni ‚Üì no
‚àß ‚àÄpj. (‚àÄ‚ü®ni, no‚ü©‚àà B. pj ¬∑ ni ‚Üì no) =‚áí cÀôf [pj] ¬∑ cÀôa[pj] ‚Üì cÀôr[pj]
Proof [13, E-C4] Induction on the proof of cÀôf [p] ¬∑ cÀôa[p] ‚Üì cr.	2
Lemma 4.5 CC is internally equivalent in every RCA tripos to the following hold- ing for every set I:
‚àÄR : N √ó I ‚Üí Œ©. Tot(R) ‚äÉ ‚àÉS : N √ó I ‚Üí Œ© | S ‚äÜ R ‚àß Det(S). Tot(S)
Proof [13, E-A3] Same definitions of S ‚äÜ R and Det(S) and proof as with PCAs in Lemma 3.3.	2
Theorem 4.6 There exists a set I for which the negation of CC is internally mod- eled by the Flip-RCA tripos.
Proof [13, E-C5] We use N as the set I for which we prove this negation. RCA (and PCA) triposes model ¬¨œÜ if œÜ has no realizers. Thus it suffices to show that

the existence of a realizer of CC onto N for Flip-RCA leads to a contradiction. By Lemma 4.5, we can do so by showing there is no code that can convert realizers of totality for relations R on N into realizers of totality for some metatheoretically- determined subrelation of R.
Suppose cc is such a code. Consider applying cc to Œª0.const0 ¬∑ cast(0). The code Œª0.const0 ¬∑ cast(0) is a realizer of totality for the relation R0 whose sole realizer
for R0 ‚Ä≤ is 0 when nj equals 0. Thus this application terminates and results in
a realizer c0	of totality for some subrelation S0 of R0. Since R0 is a determined

relation, one can easily deduce that this implies that c0
results in 0 whenever it is

applied to a Church encoding of a natural number.
Now define cÀô to be Œª0.‚Ä¢¬∑ cast(0) so that cÀô[const0] is Œª0.const0 ¬∑ cast(0). Lemma 4.4 implies there is a cÀôtot and some finite behavior B exhibitable by const0 such that

cÀôtot [const0] equals c0
and applying cc to cÀô[p] can reduce to cÀôtot [p] whenever p can

exhibit behavior B. Let ‚Üín be the list of inputs in B. Then on ‚Üín do const0 else p is guaranteed to exhibit behavior B regardless of what p is. Thus applying cc to cÀô[on ‚Üín do const0 else p] can reduce to cÀôtot [on ‚Üín do const0 else p] for any primi- tive p.
There are two particularly important primitives to consider. One is primi- tives of the form constm, in which case cÀô[on ‚Üín do const0 else constm] is a realizer

of totality for the relation R‚Üín;m whose sole realizer for R‚Üín;m
is 0 when n is in ‚Üín

and nj equals 0, or m when n is not in ‚Üín and nj equals m. This implies that cÀôtot[on ‚Üín do const0 else constm] is a realizer of totality for some subrelation S‚Üín;m of R‚Üín;m. Again, since R‚Üín;m is a determined relation, one can easily deduce that this implies that c‚Üín;m = cÀôtot [on ‚Üín do const0 else constm] results in m whenever it is applied to a Church encoding of a natural number not in ‚Üín.
The other important case is the primitive flip. Then, cÀô[on ‚Üín do const0 else flip] is a non-deterministic realizer of totality for the relation RN whose sole realizer

for RN
‚Ä≤ is nj for any n. This implies that cflip
= cÀô[on ‚Üín do const0 else flip] is a 

realizer of totality for some determined subrelation SN of RN. Now consider what happens when we apply cflip to some n not in ‚Üín. We know that c‚Üín;m ¬∑ n evaluates
tot	tot
to m. Since flip can recreate the input-output behaviors of both const0 and const1,
Lemma 4.4 implies that cflip ¬∑ ‚Üín can evaluate to both 0 and 1. This means that

0 must realize SN
for some n0, and similarly 1 must realize SN
for some n1.

Since 0 can only realize RN	when n0 equals 0, and SN is a subrelation of RN, this
implies n0 must equal 0, and similarly n1 must equal 1. Thus both SN  and SN
are realizable. Since the assumed behavior of cc implies that SN is determined, this implies 0 equals 1, thereby producing a contradiction.	2
Interestingly, this proof can easily be modified to show that Flip-RCA refutes even Weak Countable Choice, which states that choice is possible if there is at most one choice to be made across all the countable inputs [10]. Weak Countable Choice is sufficient to unify the various formulations of the reals [10], thus suggesting that the Cauchy, modulated Cauchy, and Dedekind reals might indeed be distinct in the topos for Flip-RCA.

Introducing Stateful Computation
We have shown that, although non-determinism naturally fits into realizability mod- els of higher-order logic, a flip of a coin can invalidate CC despite it holding so trivially before. Now we demonstrate that further extending the computation sys- tem with mutable state can restore CC even in the presence of non-determinism. This means that CC is not wholly incompatible with non-determinism, contrary to Schuster‚Äôs concern [41].


Stateful Combinatory Algebras
In order to directly model stateful computation, we developed stateful combinatory algebras (SCAs), a generalization of RCAs in which the application operator is stateful. That is, applying one code to another requires a state that it can then mutate. Just as there are PCAs that can model non-deterministic computation [42], PCAs can model state by using, say, the state monad [31]. But it is impossible to force PCA computations to share state‚Äîthe requirements for the S combinator force it to duplicate any state a PCA computation might be using. SCAs ensure that all computation operates on the same mutating state, which, as we show, is a critical component in their ability to implement CC even in the presence of non-deterministic computation.
Definition 5.1 (Stateful Applicative Structure) A stateful applicative struc- ture is an inhabited set Œ£ of ‚Äústates‚Äù œÉ, a ‚Äúpossible future‚Äù preorder œÉ ‚â§ œÉj, a set C of ‚Äúcodes‚Äù c, 5 an ‚Äúapplication‚Äù relation cf ¬∑ ca ‚ÜìœÉ‚Ä≤ cr, and a ‚Äútermination‚Äù
predicate cf ¬∑ ca‚ÜìœÉ satisfying the following properties:
Preservation ‚àÄœÉ, cf , ca, œÉj, cr. cf ¬∑ ca ‚ÜìœÉ‚Ä≤ cr =‚áí œÉ ‚â§ œÉj
Progress ‚àÄœÉ, cf , ca. cf ¬∑ ca‚ÜìœÉ =‚áí ‚àÉœÉj, cr. cf ¬∑ ca ‚ÜìœÉ‚Ä≤ cr
The concept of ‚Äúpossible futures‚Äù here captures the fact that, even in a system with mutable state, the system can maintain certain invariants about its state and how it progresses, as enforced by the preservation property. These invariants will be critical to implementing CC. Note, though, that the application relation and termi- nation predicate are not themselves necessarily preserved by futures; an application is permitted to reduce to a code in a given state that it cannot reduce to in a future state, and a termination only guarantees that the current state can be mutated to provide a result. Thus this is not simply a standard possible-worlds structure [26]. We extend the definitions of application e ‚ÜìœÉ‚Ä≤ cr and termination e‚ÜìœÉ to applica-
tive expressions as follows:


5 Our Coq formalization [13, C-D1] also permits one to specify a ‚Äúvalidity‚Äù predicate œÉ ‚ñ∂ c indicating which codes are valid in which states. Here we elide this additional degree of control as it is irrelevant for the current discussion.

ef ‚ÜìœÉ‚Ä≤ cf
‚Ä≤
ea  œÉ‚Ä≤‚Ä≤ ca
cf ¬∑ ca
‚Ä≤‚Ä≤
œÉ‚Ä≤‚Ä≤‚Ä≤ cr



c ‚ÜìœÉ c

e ‚ÜìœÉ	‚àÄœÉj,c . e ‚ÜìœÉ c
ef ¬∑ ea ‚ÜìœÉ‚Ä≤‚Ä≤‚Ä≤ cr
=‚áí e ‚ÜìœÉ‚Ä≤ ‚àß ‚àÄœÉjj,c . e ‚ÜìœÉ‚Ä≤ c

=‚áí c

¬∑ c ‚ÜìœÉ‚Ä≤‚Ä≤

f


c‚ÜìœÉ
f	f  œÉ‚Ä≤  f
a
ef ¬∑ ea‚ÜìœÉ
a	a  œÉ‚Ä≤‚Ä≤  a	f	a

Definition 5.2 (Stateful Combinatory Algebra) A stateful combinatory alge- bra is a stateful applicative structure with an assignment of every expression e ‚àà En+1 to a code cŒªn.e ‚àà C satisfying the following properties in all states œÉ, œÉj ‚àà Œ£:

‚àÄn.‚àÄe ‚àà En+2.‚àÄca, cr.	cŒªn+1.e ¬∑ ca ‚ÜìœÉ‚Ä≤ cr =‚áí œÉj
= œÉ ‚àß cr = cŒªn.e[ca]

‚àÄe ‚àà E1.‚àÄca, cr.	cŒª0.e ¬∑ ca ‚ÜìœÉ‚Ä≤ cr =‚áí e[ca] ‚ÜìœÉ‚Ä≤ cr
œÉ	œÉ
‚àÄn.‚àÄe ‚àà En+2.‚àÄca.	cŒªn+1.e ¬∑ ca‚ÜìœÉ
‚àÄe ‚àà E1.‚àÄca.	e[ca]‚ÜìœÉ  =‚áí cŒª0.e ¬∑ ca‚ÜìœÉ
RCAs are the special case of SCAs with precisely one state.

Modeling Higher-Order Logic with SCAs
Since PCAs and RCAs are each special cases of SCAs, we were informal about how they model impredicative higher-order logic. Now we provide a formal de- scription of the model in Figure 2. One technical note is that types in our model are inhabited sets. This technically means that our model specifies a higher-order fibration [20, Definition 5.3.1] 6 , which is a generalization of a tripos. We do this because it permits a simpler interpretation of universal quantification. Furthermore, the standard tripos-to-topos construction works for any higher-order fibration [20, Corollary 6.1.7], so the applicability to set theory and type theory is maintained. In fact, the resulting topos is equivalent to the topos that would be derived from the tripos construction.
Theorem 5.3 For any SCA, Figure 2 speciÔ¨Åes a consistent model of higher-order logic.
Proof [13, D-C1] The remaining components and proofs for a higher-order fibration follow easily from the definitions in Figure 2. The only thing we prove explicitly here is consistency.
A proposition œÜ in Figure 2 is realizable if there exists a state œÉ and code cœÜ such that œÜœÉ(cœÜ) holds. The progress property of SCAs and the definition of entailment in Figure 2 imply that when a proposition entails another one, realizability of the former implies realizability of the latter. Since the proposition T is realizable and the proposition ‚ä• is not, T cannot entail ‚ä•, guaranteeing consistency of the model for any SCA.	2
6 There is an error in this definition due to a change in terminology across works [21]. The definition should only require a weak generic object. This is relevant and evident because realizability triposes have a strict generic object, which can only be shown to be weak generic objects. Non-weak generic objects furthermore model extensionality of entailment.

Notation	Predicates

cf ¬∑ ca ‚ÜìœÉ œÜ , cf ¬∑ ca‚ÜìœÉ Œõ ‚àÄœÉ‚Ä≤, cr. cf ¬∑ ca ‚ÜìœÉ' cr	=‚áí
œÜœÉ' (c )
Fibration	
Type A type œÑ is an inhabited set.
Top The predicate T in Œì is realized by (any) c
for Œ≥ in œÉ.
Conjunction The predicate œÜ √ó œà in Œì is real- ized by c for Œ≥ in œÉ if the following holds:

Context A context Œì is an inhabited set.
‚àÄœÉ‚Ä≤. œÉ ‚â§ œÉ‚Ä≤ =‚áí c ¬∑ c

Œª1 .1
‚ÜìœÉ' œÜ
Œõ c ¬∑ c

Œª1 .2
‚ÜìœÉ'

Proposition A proposition œÜ is a ‚Äústateful‚Äù predicate on codes œÜœÉ(c) that is ‚Äúfuture-stable‚Äù:

‚àÄœÉ, œÉ‚Ä≤, c. œÉ ‚â§ œÉ‚Ä≤ Œõ œÜœÉ(c) =‚áí œÜœÉ' (c)
œàŒ≥


Bottom The predicate ‚ä• in Œì has no realizers for Œ≥ in any œÉ.
Disjunction The predicate œÜ‚à®œà in Œì is realized

Predicate A predicate œÜ in context Œì assigns to each in- habitant Œ≥ of Œì a proposition œÜŒ≥ .
by cŒª1 .1 ¬∑ cœÜ
by cŒª1 .2 ¬∑ cfi
for Œ≥ in œÉ if œÜœÉ(cœÜ) holds, and
for Œ≥ in œÉ if œàœÉ(cœà) holds.

Entailment A predicate œÜ entails a predicate œà in Œì if there exists a code c satisfying the following:
‚àÄŒ≥ ‚àà Œì.‚àÄœÉ, cœÜ. œÜœÉ(cœÜ) =‚áí c ¬∑ cœÜ ‚ÜìœÉ œàŒ≥

Substitution A substitution t from a context Œì to a con- text Œì‚Ä≤ is a function from Œì to Œì‚Ä≤. For a predicate œÜ in context Œì‚Ä≤, the substituted predicate œÜ[t] in Œì is realized by c for Œ≥ in œÉ when œÜœÉ (c) holds.
Types
Unit The type 1 is the singleton set 1.
Product The type œÑ √ó œÑ‚Ä≤ is the set of pairs œÑ √ó œÑ‚Ä≤.
Function The type œÑ ‚Üí œÑ‚Ä≤ is the set of functions œÑ ‚Üí œÑ‚Ä≤.
Impredicativity The	type		Œ©	is	the	set	of future-stable	stateful	predicates		on		codes
{œÜ ‚äÜ Œ£ √ó C | œÜ is future-stable}.
Implication The predicate œÜ ‚äÉ œà in Œì is real- ized by c for Œ≥ in œÉ if the following holds:

'	'
‚àÄœÉ , cœÜ. œÉ ‚â§ œÉ Œõ œÜŒ≥ (cœÜ) =‚áí c ¬∑ cœÜ ‚Üì
œàŒ≥


Equality The predicate =œÑ  in context Œì √ó (œÑ √ó œÑ ) is realized by (any) c for
‚ü®Œ≥, ‚ü®x, y‚ü©‚ü© ‚àà Œì √ó (œÑ √ó œÑ ) in œÉ if x equals y.
Universal Quantification For a predicate œÜ in a context Œì √ó œÑ , the predicate ‚àÄœÑ.œÜ in Œì is realized by c for Œ≥ in œÉ if ‚àÄx ‚àà œÑ. œÜœÉ  (c)
holds.
Existential Quantification For a predicate œÜ in a context Œì √ó œÑ , the predicate ‚àÉœÑ.œÜ in Œì is realized by c for Œ≥ in œÉ if ‚àÉx ‚àà

œÉ
(Œ≥,x‚ü©
Figure 2. SCA Model of Higher-Order Logic
(c) holds.

Restoring Countable Choice with State
Next we show that introducing state enables SCA triposes to model CC even in the presence of non-determinism. In particular, we use state to memoize realizers of totality. Memoization [29] (whose original intent was to optimize computation) is the method of wrapping a computation with something that keeps track of inputs already passed to this computation and their corresponding outputs. Most impor- tantly for our purposes, it has the benefit of always providing the same output for a given input even when the generating computation is itself non-deterministic. While we could provide a general proof that a tripos for any SCA with a special memoiz- ing combinator models CC, due to space constraints we simply provide a concrete example of such an SCA. Thus Figure 3 defines Mem-SCA, whose ndnat code pro- vides non-determinism, and whose memo code implements memoization (via lookup codes).
Mem-SCA is presented in two parts. We describe the left-hand side of Figure 3 first, which formalizes pre-states and a ‚Äúfrozen‚Äù computational system under a given pre-state œÇ. A pre-state is comprised of an ‚Äúallocation‚Äù table Œ± and a ‚Äúmemoization‚Äù table Œº. These tables do not necessarily satisfy the invariants of the system that will enable Mem-SCA to model CC, but they are sufficient for specifying a computational system. An entry ‚ü®l, c‚ü© in an allocation table Œ± indicates that the memoizations at location l should be generated by code c. An entry ‚ü®l, n, c‚ü© in a memoization table Œº




Figure 3. Mem-SCA

indicates that the input n has a memoized output c at location l. Consequently, the computational system specifies that memo applied to a code c can reduce to a lookupl for any location l whose entries should be generated by c according to Œ±. Similarly, the computational system specifies that lookupl applied to a Church-encoded natural number n can reduce to a memoized ouput c for input n at location l according to Œº. The remainder of the computational system behaves as expected for the Œª-calculus, with the addition that ndnat can reduce to any Church-encoded natural number.
Note that a pre-state does not actually guarantee that the entries in its mem- oization table are generated according to its allocation table, nor does it have any notion of mutating state. Both of these issues are addressed by the right-hand side of Figure 3, which formalizes states and a mutating computational system. A state is a pre-state satisfying additional invariants. First and second, a given location can be generated by at most one code and can have at most one memoized output for each given input. Third, every memoized output is indeed a possible result of applying the input to the generating code. Last, the tables are finite. A state‚Äôs possible futures are simply all states containing its entries (and possibly more). Termination is straightforward, with the one subtlety that lookupl only terminates on inputs that its generating code terminates on. Lastly, mutating reduction does not actually prescribe how the state should be mutated‚Äîinstead, its effect is that the state can be mutated to any future state provided the application would re- duce according to the frozen computational system, i.e. provided the future state has enough entries that the application can reduce without needing to add more entries. This means that the issue of determining actually how to mutate the state such that the reduction can be completed is delegated to the proof of progress.
Lemma 5.4 Mem-SCA is an SCA.
Proof [13, E-D2] We provide the only interesting aspect of this proof, which is progress. For this, we rely on the fact that cf ¬∑ ca ‚ÜìœÇ cr is easily shown to imply
‚Ä≤
cf ¬∑ ca ‚ÜìœÇ c whenever œÇj contains all the entries in œÇ. Progress is proven by in-
duction on the proof of termination, the only interesting cases for which are memo
and lookupl.

Suppose memo ¬∑ ca‚ÜìœÉ holds. We need to provide a state œÉj and a code cr such that memo ¬∑ ca ‚ÜìœÉ‚Ä≤ cr holds. Since Œ±œÉ is finite, there is an ‚Äúunused‚Äù location l. Define œÇj to be œÇœÉ with ‚ü®l, c‚ü© added to the allocation table, and define cr to be lookupl. The required reduction and the fact that the pre-state œÇj satisfies the requirements to provide a state œÉj follow easily.
Now suppose lookupl ¬∑ ca‚ÜìœÉ holds. We need to provide a state œÉj and a code cr such that lookupl ¬∑ ca ‚ÜìœÉ‚Ä≤ cr holds. The assumption implies that ca is the Church encoding of some natural number n, that l has a corresponding code cf in the allocation table Œ±œÉ, and that cf ¬∑ cŒª‚ÜìœÉ holds. Since ŒºœÉ is finite we can check to see if it has a code c corresponding to l and n, in which case œÉj is simply œÉ and cr is simply c. Otherwise, by the induction hypothesis cf ¬∑ cŒª‚ÜìœÉ entails the existence
of a state œÉÀÜ and code cÀÜ such that cf ¬∑ cŒª	œÉ cÀÜ holds. Again, since ŒºœÉÀÜ is finite we
can check to see if it has a code cj corresponding to l and n, in which case œÉj is simply œÉÀÜ and cr is simply cj. Otherwise, we define œÇj to be œÇœÉÀÜ with ‚ü®l, cÀÜ‚ü© added to the allocation table, and we define cr to be cÀÜ. The required reduction and the fact that the pre-state œÇj satisfies the requirements to provide a state œÉj follow easily. 2
Lemma 5.5 CC is internally equivalent in every SCA tripos to the following hold- ing for every set I:
‚àÄR : N √ó I ‚Üí Œ©. Tot(R) ‚äÉ ‚àÉS : N √ó I ‚Üí Œ© | S ‚äÜ R ‚àß Det(S). Tot(S)
where

S ‚äÜ R :	‚àÄn, i, œÉ, c. SœÉ
(c) =‚áí RœÉ
(c)

Det(S):	‚àÄn, i, ij, œÉ, c, cj. SœÉ	(c) ‚àß SœÉ ‚Ä≤ (cj) =‚áí i = ij
‚ü®n,i‚ü©	‚ü®n,i ‚ü©
Proof [13, E-A5] The reasoning is very similar to PCAs and RCAs except for one

nuance with state. One applies cc to cR
as before, now in some given state œÉ, to

again get a triple of codes cS
S
det
, and cS
, and a future state œÉj. As before, define

the new relation SÀÜ such that SÀÜœÉ‚Ä≤‚Ä≤
is realized by c when RœÉ‚Ä≤‚Ä≤
is realized by c, SœÉ‚Ä≤‚Ä≤

has a realizer, and œÉjj is a possible future of œÉj. This final requirement addresses the

fact that cS
S
det
, and cS
are only guaranteed to exhibit their expected behaviors

in state œÉj and any of its possible futures due to the future-stability of propositions.
Consequently, the remainder of the proof can proceed as before.	2
Note that the definition of Det(S) in Lemma 5.5 requires realizability of S‚ü®n,i‚ü©
j
and S‚ü®n,i‚Ä≤‚ü© to imply that i and i are equal only if they are realizable in the same
state œÉ. Thus it is perfectly acceptable for S‚ü®n,i‚ü© and S‚ü®n,i‚Ä≤‚ü© to be realizable for distinct i and ij in distinct states. Furthermore, totality of S only requires S‚ü®n,i‚ü© to eventually be a realizable for some i for each n. Thus S can be non-deterministic
across states and be only finitely defined at any particular state, which is how we address the challenges of non-determinism.
Theorem 5.6 CC is internally modeled by the tripos for Mem-SCA.
Proof [13, E-D3] The realizer of the proposition in Lemma 5.5 for Mem-SCA is

simply memo. Suppose cR
is a realizer of totality in a given state œÉ for a relation R.

We need to show that memo ¬∑ cR
terminates in œÉ, and that any code it can reduce

to in a possible future œÉj is necessarily a realizer of totality in œÉj of some determined subrelation of R. Termination is trivial since memo is defined to terminate on all inputs in all states, so reduction is the primary challenge.

By definition, memo ¬∑ cR
only reduces to lookupl and only in states œÉj for which

‚ü®l, cR ‚ü© is in Œ±œÉ‚Ä≤ . Thus we need to show that lookupl is a realizer of totality in œÉj for
œÉ‚Ä≤‚Ä≤	œÉ‚Ä≤‚Ä≤
some determined subrelation of R. Let cn  denote codes for which ‚ü®l, n, cn ‚ü©‚àà ŒºœÉ‚Ä≤‚Ä≤
and œÉj ‚â§ œÉjj hold, which (if it exists) is necessarily unique for a given œÉjj. Note

that, if cœÉ‚Ä≤‚Ä≤ exists, then it is a realizer of RœÉ‚Ä≤‚Ä≤
for some i. The reason is that, by

n	‚ü®n,i‚ü©
the required properties of states, in order to be in the memoization table for l the
code cœÉ‚Ä≤‚Ä≤ must be a possible result of applying the generator for l (as specified by Œ±)

to cŒª. By assumption, that generator is cR
and consequently a realizer of totality

n	tot

of R, so its output on input cŒª is necessarily a realizer of RœÉ‚Ä≤‚Ä≤
for some i. So let

n	‚ü®n,i‚ü©

iœÉ‚Ä≤‚Ä≤ be a selection of indices in I such that cœÉ‚Ä≤‚Ä≤ is a realizer of RœÉ‚Ä≤‚Ä≤
, and such that

n	n	‚ü®n,iœÉ‚Ä≤‚Ä≤ ‚ü©
iœÉ‚Ä≤‚Ä≤‚Ä≤ equals iœÉ‚Ä≤‚Ä≤ whenever both are defined and œÉjjj is a possible future of œÉjj (and so

n
cœÉ‚Ä≤‚Ä≤‚Ä≤
n
œÉ‚Ä≤‚Ä≤  7

n	equals cn ).
Given these choices, define SœÉ‚Ä≤‚Ä≤
(c) to hold when c equals cœÉ‚Ä≤‚Ä≤
and when i

equals iœÉ‚Ä≤‚Ä≤
(and both cœÉ‚Ä≤‚Ä≤
and iœÉ‚Ä≤‚Ä≤
exist). Each proposition S
‚ü®n,i‚ü©
is future-stable

because cœÉ‚Ä≤‚Ä≤ is future-stable and each iœÉ‚Ä≤‚Ä≤ was chosen to be future-stable. Since we

n
already established that cœÉ‚Ä≤‚Ä≤
n
is a realizer of RœÉ‚Ä≤‚Ä≤
n
, S is a subrelation of R. By

definition, SœÉ‚Ä≤‚Ä≤
œÉ‚Ä≤‚Ä≤
‚ü®n,i‚Ä≤‚ü©
are both realizable in a given state œÉjj only when both

equal in , ensuring determinism of S. It remains to prove that lookupl is a realizer
of totality for S. Since cR is a realizer of totality in œÉj, it terminates on all Church-
encoded natural-number inputs in œÉj, which implies lookupl does as well. Any code that can result from applying lookupl to a cŒª in a possible future œÉjj is necessarily

in the memoization table for l in œÉjj
‚Ä≤‚Ä≤
and therefore equal to cn , which by definition

is a realizer of S‚ü®n,iœÉ‚Ä≤‚Ä≤ ‚ü© in œÉjj. Thus lookupl is a realizer of totality for a determined subrelation of R, and hence memo is a realizer of the proposition in Lemma 5.5, thereby evidencing that the tripos for Mem-SCA models CC.	2
Although we do not formally develop it here, a similar SCA can even model a principle known as dependent choice (DC), which is strictly stronger than CC [4,22]. The state provides a table in which each entry of the required sequence is simply generated on demand from the previous one according to the allocated realizer of totality. As with Mem-SCA, this works even in the presence of non-determinism.
Related Work and Conclusions
This paper demonstrates that key principles of constructivism highly depend on the effectful notion of the computation system, using CC as an illustrative example. We show that the traditional constructive proof of CC fundamentally relies upon a deterministic computational system, and that adding even a coin flip entails its

7 This assumes Zorn‚Äôs Lemma in the metatheory, which is why we assume specifically ZFC in this pa- per. The Coq proof provides a more careful construction that, as is standard practice here, assumes only countable choice in the metatheory [13, E-D3].

negation. We further show that then adding mutable state to the computational system makes it again possible to implement CC. In doing so, the paper extends the boundaries of constructivism towards a truly proofs-as-programs paradigm, not just a proofs-as-deterministic-programs paradigm.
This paper focuses on the effect of effects on existing principles of constructivism. Other works similarly each make some choice principle compatible with computa- tions with continuations [3, 16, 30]. Interestingly, despite the difference in goals, these systems use techniques as coinduction, lazy evaluation, and infinite terms that are employed in a manner bearing resemblance to our memoization technique. It would also be interesting to explore what new principles might be made possible by effects. For example, Bickford et al. [6] explore using the stateful nature of Nuprl‚Äôs library system to provide free-choice sequences [11]. We suspect these techniques can be combined to model both CC and free choice, and even extended
to support notions of choice almost reaching ZFC.

References
Stuart F. Allen, Mark Bickford, Robert L. Constable, Richard Eaton, Christoph Kreitz, Lori Lorigo, and Evan Moran. Innovations in Computational Type Theory using Nuprl. Journal of Applied Logic, 4(4):428‚Äì469, 2006.
Joseph L. Bates and Robert L. Constable. Proofs as Programs. Transactions on Programming Languages and Systems, 7(1):113‚Äì136, January 1985.
Stefano Berardi, Marc Bezem, and Thierry Coquand. On the Computational Content of the Axiom of Choice. Journal of Symbolic Logic, 63(2):600‚Äì622, 1998.
Paul Bernays. A System of Axiomatic Set Theory. Part III. Infinity and Enumerability. Analysis.
Journal of Symbolic Logic, 7(2):65‚Äì89, 1942.
Yves Bertot and Pierre Casteran. Interactive Theorem Proving and Program Development. Springer- Verlag Berlin Heidelberg, 2004.
Mark Bickford, Liron Cohen, Robert L. Constable, and Vincent Rahli. Computability beyond Church- Turing via Choice Sequences. In Logic in Computer Science, pages 245‚Äì254, 2018.
Errett Bishop and Douglas Bridges. Constructive Analysis. Springer-Verlag Berlin Heidelberg, 1985.
Ana Bove, Peter Dybjer, and Ulf Norell. A Brief Overview of Agda ‚Äì A Functional Language with Dependent Types. In Theorem Proving in Higher Order Logics, pages 73‚Äì78, 2009.
Douglas Bridges and Fred Richman. Varieties of Constructive Mathematics. London Mathematical Society Lecture Notes Series. Cambridge University Press, 1987.
Douglas Bridges, Fred Richman, and Peter Schuster. A Weak Countable Choice Principle. Proceedings of the American Mathematical Society, 128(9):2749‚Äì2752, 2000.
L. E. J. Brouwer. Begru¬®ndung der Mengenlehre unabha¬®ngig vom logischen Satz vom ausgeschlossenen Dritten. Zweiter Teil: Theorie der Punktmengen. Verhandelingen der Koninklijke Nederlandse Akademie van Wetenschappen te Amsterdam (Eerste Sectie), 12(7), 1919.
L. E. J. Brouwer. Brouwer‚Äôs Cambridge Lectures on Intuitionism. Cambridge University Press, 1981.
Liron Cohen, Sofia Abreu Faro, and Ross Tate. The Effects of Effects on Constructivism: Coq Proof. preprint, 2019. URL: https://www.cs.cornell.edu/~ross/publications/effectful/

R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. Implementing Mathematics with the Nuprl Proof Development System. Prentice-Hall, Inc., 1986.
Solomon Feferman. A Language and Axioms for Explicit Mathematics. In Algebra and Logic, pages 87‚Äì139, 1975.


Hugo Herbelin. A Constructive Proof of Dependent Choice, Compatible with Classical Logic. In Logic in Computer Science, pages 365‚Äì374, 2012.
Pieter J. W. Hofstra. Partial Combinatory Algebras and Realizability Toposes. 2004.
J. M. E. Hyland. The Effective Topos. In The L. E. J. Brouwer Centenary Symposium, volume 110 of Studies in Logic and the Foundations of Mathematics, pages 165‚Äì216. North-Holland, 1982.
J. M. E. Hyland, P. T. Johnstone, and A. M. Pitts. Tripos Theory. Mathematical Proceedings of the Cambridge Philosophical Society, 88(2):205‚Äì232, 1980.
Bart Jacobs. Categorical Logic and Type Theory, volume 141 of Studies in Logic and the Foundations of Mathematics. North-Holland, 1998.
Bart Jacobs. Personal communication, 2014.
R. B. Jensen. Independence of the axiom of dependent choices from the countable axiom of choice (abstract). Journal of Symbolic Logic, 31(2):294, 1966.
Peter T. Johnstone. Sketches of an Elephant: A Topos Theory Compendium, volume 1. Oxford University Press, 2002.
S. C. Kleene. On the Interpretation of Intuitionistic Number Theory. The Journal of Symbolic Logic, 10(4):109‚Äì124, 1945.
Stephen Cole Kleene and Richard Eugene Vesley. The Foundations of Intuitionistic Mathematics: Especially in Relation to Recursive Functions, volume 39 of Studies in Logic and the Foundations of Mathematics. North-Holland, 1965.
Saul A. Kripke. Semantical Considerations on Modal Logic. Acta Philosophica Fennica, 16(16):83‚Äì94, 1963.
Robert S. Lubarsky. On the Cauchy Completeness of the Constructive Cauchy Reals. Electronic Notes in Theoretical Computer Science, 167:225‚Äì254, 2007. Proceedings of the Third International Conference on Computability and Complexity in Analysis.
A. A. Markov. On the Continuity of Constructive Functions. Uspekhi Matematicheskikh Nauk, 9(3):226‚Äì230, 1954. Meetings of the Moscow Mathematical Society.
Donald Michie. ‚ÄúMemo‚Äù Functions and Machine Learning. Nature, 218(5136):19‚Äì22, 1968.
E¬¥tienne Miquey. A Sequent Calculus with Dependent Types for Classical Arithmetic. In Logic in Computer Science, pages 720‚Äì729, 2018.
Eugenio Moggi. Notions of Computation and Monads. Information and Computation, 93(1):55‚Äì92, 1991. Selections from 1989 IEEE Symposium on Logic in Computer Science.
Joan Rand Moschovakis and Garyfallia Vafeiadou. Some Axioms for Constructive Analysis. Archive for Mathematical Logic, 51(5-6):443‚Äì459, 2012.
John Myhill. Constructive Set Theory. The Journal of Symbolic Logic, 40(3):347‚Äì382, 1975.
Gerhard Osius. Categorical Set Theory: A Characterization of the Category of Sets. Journal of Pure and Applied Algebra, 4(1):79‚Äì119, 1974.
Andrew M. Pitts. Tripos Theory in Retrospect. Mathematical Structures in Computer Science, 12(3):265‚Äì279, 2002.
Michael Rathjen. Choice Principles in Constructive and Classical Set Theories. In Logic Colloquium, Lecture Notes in Logic, pages 299‚Äì326. Cambridge University Press, 2002.
Fred Richman. Constructive Mathematics without Choice. In Reuniting the Antipodes ‚Äî Constructive and Nonstandard Views of the Continuum, pages 199‚Äì205. Springer Netherlands, 2001.
Fred Richman. Pointwise Differentiability. In Reuniting the Antipodes ‚Äî Constructive and Nonstandard Views of the Continuum, pages 207‚Äì210. Springer Netherlands, 2001.
Wim Ruitenburg. Constructing Roots of Polynomials over the Complex Numbers. In Computational Aspects of Lie Group Representations and Related Topics, pages 107‚Äì128, 1990.
Peter M. Schuster. Elementary Choiceless Constructive Analysis. In Computer Science Logic, pages 512‚Äì526, 2000.
Peter M. Schuster. Countable Choice as a Questionable Uniformity Principle. Philosophia Mathematica, 12(2):106‚Äì134, 2004.


Dana Scott. Completeness and Axiomatizability in Many-Valued Logic. In Proceedings of the Tarski Symposium, pages 411‚Äì436, 1974.
A. S. Troelstra. History of Constructivism in the 20th Century. In Set Theory, Arithmetic, and Foundations of Mathematics: Theorems, Philosophies, Lecture Notes in Logic, pages 150‚Äì179. Cambridge University Press, 2011.
A. S. Troelstra and D. van Dalen. Constructivism in Mathematics: An Introduction, Volume I, volume 121 of Studies in Logic and the Foundations of Mathematics. North-Holland, 1988.
Benno van den Berg. Predicative Topos Theory and Models for Constructive Set Theory. PhD thesis, Utrecht University, 2006.
Jean van Heijenoort. From Frege to Go¬®del: A Source Book in Mathematical Logic, 1879‚Äì1931. Harvard University Press, 1967.
Jaap van Oosten. Realizability: An Introduction to its Categorical Side, volume 152 of Studies in Logic and the Foundations of Mathematics. North-Holland, 2008.

Coq Formalization: Table of Contents

3	Definition of a Stateful Combinatory Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . 
Lambdas.v
112

1	Framework for Building Codes with Lambda-Terms and Primitives	112
FreeRCA.v
1	Framework for Building Relational Combinatory Algebras with Lambda-Terms and Primitives .	112
FreeSCA.v
1	Framework for Building Stateful Combinatory Algebras with Lambda-Terms and Primitives	112
Higher-Order Fibrations	113
HOFs.v
1	Definition of a Higher-Order Fibration	113
RCAstoHOFs.v
1	Proof that a Relational Combinatory Algebra forms a Higher-Order Fibration	114
SCAstoHOFs.v
1	Proof that a Stateful Combinatory Algebra forms a Higher-Order Fibration	115
Countable Choice	116
CountableChoice.v
E-A1	Definition of Internal Countable Choice in Evidenced Frames	116
E-A2	Definition of Internal Countable Choice in Relational Combinatory Algebras	116
E-A3	Proof that Internal CC for a PCA/RCA is Equivalent to Internal CC for its Higher-Order
Fibration	116
4	Definition of Internal Countable Choice in Stateful Combinatory Algebras	116
5	Proof that Internal CC for an SCA is Equivalent to Internal CC for its Higher-Order Fibration	117
CCPCAs.v
1	Proof that Partial Combinatory Algebras Internally Model Countable Choice	117
NCCRCA.v
1	Definition of Flip-RCA	117
E-C2	Proof that Flip-RCA is an RCA	117
E-C3	Definition of Flip-RCA Codes with Primitive Holes	117
E-C4	Proof that Flip-RCA is Extensional and Finitary	118
E-C5	Proof that Flip-RCA Internally Negates Countable Choice	118


E-D CCSCA.v
Overview
The contributions of this paper have all been mechanically verified. This appendix is intended to let the reader know what exactly has been mechanically verified. In particular, it provides all the relevant formal definitions and formal statements of the lemmas and theorems. It does not, however, walk through the proofs in detail. For that, we refer the interested reader to directly interact with the Coq proofs themselves [13].
A-A. Conventions
Because Coq does not have quotient types and true subset types (due to the lack of baked-in proof irrelevance with support for unification), we employ a convention of define a type, then a validity predicate on that type, and then an equivalence relation on that type if appropriate. We only use elements of a type that are valid.
A-B. Metatheoretic Assumptions
The proof only makes one metatheoretic assumption, countable choice, in two places: the proof that all PCAs model countable choice, and the proof that Mem-SCA models countable choice.
Categories
B-A. Common.v
We use Set to ensure that a type belongs to the universe of sets rather than some larger universe. We cannot use the standard Set universe because we need Set to contain Prop to model impredicativity.
Definition Set : Type := Type. Inductive ‚àÖ : Set :=.
B-B. Categories.v
1. Definition of a Category
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type Category.
Parameter O : Type. Parameter JO : O ‚Üí Prop.
Parameter ~ : O ‚Üí O ‚Üí Type.
Parameter J~ : ‚àÄ {o1 o2 : O}, ~ o1 o2 ‚Üí Prop.
Parameter ‚âà~ : ‚àÄ {o1 o2 : O}, ~ o1 o2 ‚Üí ~ o1 o2 ‚Üí Prop.
End Category.
B-C. Cartesian.v
1. Definition of a Cartesian Category
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type CartesianCategory.
Include Category.
Parameter 1 : O.
Parameter ! : ‚àÄ o : O, ~ o 1.
Parameter √ó : O ‚Üí O ‚Üí O.
Parameter (¬∑, ¬∑‚ü© : ‚àÄ {o o1 o2 : O}, ~ o o1 ‚Üí ~ o o2 ‚Üí ~ o (√ó o1 o2 ).
Parameter œÄ1 : ‚àÄ o1 o2 : O, ~ (√ó o1 o2 ) o1 .
Parameter œÄ2 : ‚àÄ o1 o2 : O, ~ (√ó o1 o2 ) o2 .
End CartesianCategory.
B-C2. Definition of a Cartesian-Closed Category
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type CartesianClosedCategory.
Include CartesianCategory.
Parameter ‚áí : O ‚Üí O ‚Üí O.
Parameter Œõ : ‚àÄ {o o1 o2 : O}, ~ (√ó o o1 ) o2 ‚Üí ~ o (‚áí o1 o2 ).
Parameter eval : ‚àÄ o1 o2 : O, ~ (√ó (‚áí o1 o2 ) o1 ) o2 .
End CartesianClosedCategory.
B-C3. Definition of a Nautral-Number Object
This definition is standard. We include here only the structural components so that the reader may be introduced the notation.
Module Type NaturalNumberObject (CC : CartesianCategory ).
Parameter N : O.
Parameter Z : ~ 1 N.


Parameter S : ~ N N.
Parameter recN : ‚àÄ {o : O}, ~ 1 o ‚Üí ~ o o ‚Üí ~ N o.
End NaturalNumberObject.
B-D. Sets.v
B-D1. Definition of the Category of Inhabited Sets
Module InhabitedSets <: CartesianClosedCategory.
Record O : Type := { set : Set; Jset : set ‚Üí Prop; ‚âàset : set ‚Üí set ‚Üí Prop }.
Objects are required to be inhabited sets (but not pointed sets), as indicated by sinh.
Record JO (o : O) : Prop
:= { sinh : ‚àÉ s : set o, Jset o s 
; srefl : ‚àÄ s : set o, Jset o s ‚Üí ‚âàset o s s
; ssym : ‚àÄ s s‚Äô : set o, Jset o s ‚Üí Jset o s‚Äô ‚Üí ‚âàset o s s‚Äô ‚Üí ‚âàset o s‚Äô s
; strans : ‚àÄ s s‚Äô s‚Äô‚Äô : set o, Jset o s ‚Üí Jset o s‚Äô ‚Üí Jset o s‚Äô‚Äô ‚Üí ‚âàset o s s‚Äô ‚Üí ‚âàset o s‚Äô s‚Äô‚Äô ‚Üí ‚âàset o s s‚Äô‚Äô }.
Definition ~ (o1 o2 : O) : Type := set o1 ‚Üí set o2 .
Note that morphisms are not required to preserve the required inhabitant, making this the category of inhabited sets rather than pointed sets.
Record J~ (o1 o2 : O) (m : ~ o1 o2 ) : Prop
:= { mpresv : ‚àÄ s1 : set o1 , Jset o1 s1 ‚Üí Jset o2 (m s1 )
; mprese : ‚àÄ s1 s1‚Äô : set o1 , Jset o1 s1 ‚Üí Jset o1 s1‚Äô ‚Üí ‚âàset o1 s1 s1‚Äô ‚Üí ‚âàset o2 (m s1 ) (m s1‚Äô ) }.
Definition ‚âà~ {o1 o2 : O} (m1 m2 : ~ o1 o2 ) : Prop := ‚àÄ s1 s1‚Äô : set o1 , Jset o1 s1 ‚Üí Jset o1 s1‚Äô ‚Üí ‚âàset o1 s1 s1‚Äô ‚Üí
‚âàset o2 (m1 s1 ) (m2 s1‚Äô ).
We omit the remainder of this module as it simply demonstrates that inhabited sets form a cartesian-closed category, which is not novel. Note, though, that the ability to customize the validity predicate and equivalence relation are necessary for this construction.
End InhabitedSets.
Module InhabitedSetsNat <: NaturalNumberObject InhabitedSets.
We omit the contents of this module as they simply demonstrate that inhabited sets have the obvious natural-number object.
End InhabitedSetsNat.
Combinatory Algebras
C-A. Expressions.v
1. Definition of Applicative Expressions
Module ApplicativeExpression.
Fixpoint V (C : Set) (n : N) : Type := match n with 0 '‚Üí C | S n '‚Üí option (V C n ) end.
Fixpoint vcode {C : Type} (c : C) (n : N) : V C n := match n with 0 '‚Üí c | S n '‚Üí Some (vcode c n ) end.
Inductive E? {C : Set} {n : N} : Type := evar (c : V C n ) | ¬∑ (ef ea : E?).
Definition Expr (C : Set) : Type := E? C 0.
Fixpoint JV {C : Set} (JC : C ‚Üí Prop) {n : N} : V C n ‚Üí Prop
:= match n with 0 '‚Üí JC | S n '‚Üí Œª v '‚Üí match v with None '‚Üí True | Some v '‚Üí JV JC v end end. Inductive JE {C : Set} (JC : C ‚Üí Prop) {n : N} : E? C n ‚Üí Prop
:= evarv (c : V C n ) : JV JC c ‚Üí JE JC (evar n c)
| eappv (ef ea : E? C n ) : JE JC ef ‚Üí JE JC ea ‚Üí JE JC (¬∑ ef ea ).
Fixpoint eÀô[¬∑] {C : Set} (c : C) {n : N} (e : E? C (S n)) : E? C n
:= match e with evar  v '‚Üí evar n (match v with None '‚Üí vcode c n | Some v '‚Üí v end) | ¬∑ ef ea '‚Üí ¬∑ (eÀô[¬∑] c ef ) (eÀô[¬∑] c
ea ) end.
Lemma esubstv (C : Set) (JC : C ‚Üí Prop) (c : C) (n : N) (e : E? C (S n)) : JC c ‚Üí JE JC e ‚Üí JE JC (eÀô[¬∑] c e).
Definition (¬∑) {C : Set} (c : C) {n : N} : E? C n := evar n (vcode c n ).
Lemma ecodev (C : Set) (JC : C ‚Üí Prop) (c : C) (n : N) : JC c ‚Üí JE JC (n := n ) ((¬∑) c).
End ApplicativeExpression.
C-B. RCAs.v
1. Definition of a Relational Applicative Structure
This is the formal statement of Definition 4.1.
Module Type RelationalApplicativeStructure.
Parameter C : Set.
Parameter JC : C ‚Üí Prop.
Parameter ‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop. Parameter ‚Üì : C ‚Üí C ‚Üí Prop.
Parameter preservation : ‚àÄ cf ca cr : C, JC cf ‚Üí JC ca ‚Üí ‚Üìc cf ca cr ‚Üí JC cr .
Parameter progress : ‚àÄ cf ca : C, JC cf ‚Üí JC ca ‚Üí ‚Üì cf ca ‚Üí ‚àÉ cr : C, ‚Üìc cf ca cr .
End RelationalApplicativeStructure.
C-B2. Definition of Relational Reduction and Termination of Applicative Expressions
Module RelationalApplicativeExpression.
Inductive ‚ÜìE {C : Set} (‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop) : E0 C ‚Üí C ‚Üí Prop
:= revar (c : C) : ‚ÜìE ‚Üìc (evar 0 c) c
| reapp (ef ea : E0 C) (cf ca cr : C) : ‚ÜìE ‚Üìc ef cf ‚Üí ‚ÜìE ‚Üìc ea ca ‚Üí ‚Üìc cf ca cr ‚Üí ‚ÜìE ‚Üìc (¬∑ ef ea ) cr .
c	c	c


Inductive ‚ÜìE {C : Set} (‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop) (‚Üì : C ‚Üí C ‚Üí Prop) : E0 C ‚Üí Prop
:= tevar (c : C) : ‚ÜìE ‚Üìc ‚Üì (evar 0 c)
| teapp (ef ea : E0 C) : ‚ÜìE ‚Üìc ‚Üì ef ‚Üí (‚àÄ cf : C, ‚ÜìE ‚Üìc ef cf ‚Üí ‚ÜìE ‚Üìc ‚Üì ea ‚àß (‚àÄ ca : C, ‚ÜìE ‚Üìc ea ca ‚Üí ‚Üì cf ca ))
c	c
‚Üí ‚ÜìE ‚Üìc ‚Üì (¬∑ ef ea ).
Definition ‚ÜìœÜ {C : Set} (‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop) (‚Üì : C ‚Üí C ‚Üí Prop) (cf ca : C) (œÜr : C ‚Üí Prop) : Prop
:= ‚Üì cf ca ‚àß (‚àÄ cr : C, ‚Üìc cf ca cr ‚Üí œÜr cr ).
Lemma termred forall {C I : Set} (‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop) (‚Üì : C ‚Üí C ‚Üí Prop) (JI : I ‚Üí Prop) (cf ca : C) (œÜr : I
‚Üí C ‚Üí Prop) : (‚àÉ i : I, JI i ) ‚Üí (‚àÄ i : I, JI i ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì cf ca (œÜr i )) ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì cf ca (Œª cr '‚Üí ‚àÄ i : I, JI i ‚Üí œÜr i cr ).
Fixpoint ‚ÜìE {C : Set} (‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop) (‚Üì : C ‚Üí C ‚Üí Prop) (e : E0 C) (œÜr : C ‚Üí Prop) : Prop
:= match e with evar  c '‚Üí œÜr c | ¬∑ ef ea '‚Üí ‚ÜìE ‚Üìc ‚Üì ef (Œª cf '‚Üí ‚ÜìE ‚Üìc ‚Üì ea (Œª ca '‚Üí ‚ÜìœÜ ‚Üìc ‚Üì cf ca œÜr )) end.
œÜ	œÜ
Lemma termredexpr {C : Set} (‚Üìc : C ‚Üí C ‚Üí C ‚Üí Prop) (‚Üì : C ‚Üí C ‚Üí Prop) (e : E0 C) (œÜr : C ‚Üí Prop) : ‚ÜìE ‚Üìc ‚Üì
e œÜr ‚Üí ‚ÜìE ‚Üìc ‚Üì e ‚àß (‚àÄ cr : C, ‚ÜìE ‚Üìc e cr ‚Üí œÜr cr ).
End RelationalApplicativeExpression.
3. Definition of a Relational Combinatory Algebra
This is the formal statement of Definition 4.2.
Module Type RelationalCombinatoryAlgebra.
Include RelationalApplicativeStructure.
Parameter cŒª : ‚àÄ n : N, E? C (S n) ‚Üí C.
Parameter cencodev : ‚àÄ n : N, ‚àÄ e : E? C (S n), JE JC e ‚Üí JC (cŒª n e).
Parameter red encode S : ‚àÄ n : N, ‚àÄ e : E? C (S (S n)), ‚àÄ ca cr : C, JE JC e ‚Üí JC ca ‚Üí ‚Üìc (cŒª (S n) e) ca cr ‚Üí cŒª n
(eÀô[¬∑] ca e) = cr .
Parameter red encode 0 : ‚àÄ e : E? C 1, ‚àÄ ca cr : C, JE JC e ‚Üí JC ca ‚Üí ‚Üìc (cŒª 0 e) ca cr ‚Üí ‚ÜìE ‚Üìc (eÀô[¬∑] ca e) cr .
Parameter term encode S : ‚àÄ n : N, ‚àÄ e : E? C (S (S n)), ‚àÄ ca : C, JE JC e ‚Üí JC ca ‚Üí ‚Üì (cŒª (S n) e) ca .
Parameter term encode 0 : ‚àÄ e : E? C 1, ‚àÄ ca : C, JE JC e ‚Üí JC ca ‚Üí ‚ÜìE ‚Üìc ‚Üì (eÀô[¬∑] ca e) ‚Üí ‚Üì (cŒª 0 e) ca .
End RelationalCombinatoryAlgebra.
C-C. PCAs.v
1. Definition of a Partial Combinatory Algebra
This is the formal statement of Definition 3.2
Module Type PartialCombinatoryAlgebra.
Include RelationalCombinatoryAlgebra.
Parameter red deterministic : ‚àÄ cf ca cr c' : C, JC cf ‚Üí JC ca ‚Üí ‚Üìc cf ca cr ‚Üí ‚Üìc cf ca c' ‚Üí cr = c' .
r	r	r
Parameter red term : ‚àÄ cf ca cr : C, JC cf ‚Üí JC ca ‚Üí JC cr ‚Üí ‚Üìc cf ca cr ‚Üí ‚Üì cf ca .
End PartialCombinatoryAlgebra.
C-D. SCAs.v
1. Definition of a Stateful Applicative Structure
This is the formal statement of Definition 5.1. One difference, though, is that in this definition we allow code-validity to depend on the current state so long as code-validity is future-stable. Although our proofs do not rely on this additional degree of flexibility, it can be convenient for keeping the model clean, say by guaranteeing that any references a valid code has to the state necessarily refer to allocated locations.
Module Type StatefulApplicativeStructure.
Parameter Œ£ : Set.
Parameter JŒ£ : Œ£ ‚Üí Prop. Parameter sinhabited : ‚àÉ œÉ : Œ£, JŒ£ œÉ.
Parameter ‚â§ : Œ£ ‚Üí Œ£ ‚Üí Prop. Parameter frefl : ‚àÄ œÉ : Œ£, JŒ£ œÉ ‚Üí ‚â§ œÉ œÉ.
Parameter ftrans : ‚àÄ œÉ œÉ' œÉ'' : Œ£, JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí JŒ£ œÉ'' ‚Üí ‚â§ œÉ œÉ' ‚Üí ‚â§ œÉ' œÉ'' ‚Üí ‚â§ œÉ œÉ'' .
Parameter C : Set.
Parameter JC : Œ£ ‚Üí C ‚Üí Prop.
Parameter codev fut : ‚àÄ œÉ œÉ' : Œ£, ‚àÄ c : C, JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí JC œÉ c ‚Üí JC œÉ' c.
Parameter ‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop. Parameter ‚Üì : Œ£ ‚Üí C ‚Üí C ‚Üí Prop.
Parameter preservation : ‚àÄ œÉ : Œ£, ‚àÄ cf ca : C, ‚àÄ œÉ' : Œ£, ‚àÄ cr : C, JŒ£ œÉ ‚Üí JC œÉ cf ‚Üí JC œÉ ca ‚Üí ‚Üìc œÉ cf ca œÉ' cr ‚Üí
JŒ£ œÉ' ‚àß ‚â§ œÉ œÉ' ‚àß JC œÉ' cr .
Parameter progress : ‚àÄ œÉ : Œ£, ‚àÄ cf ca : C, JŒ£ œÉ ‚Üí JC œÉ cf ‚Üí JC œÉ ca ‚Üí ‚Üì œÉ cf ca ‚Üí ‚àÉ œÉ' : Œ£, ‚àÉ cr : C, ‚Üìc œÉ cf ca
œÉ' cr .
End StatefulApplicativeStructure.
C-D2. Definition of Stateful Reduction and Termination of Applicative Expressions
Module StatefulApplicativeExpression.
Inductive ‚ÜìE {Œ£ C : Set} (‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop) : Œ£ ‚Üí E0 C ‚Üí Œ£ ‚Üí C ‚Üí Prop
:= revar (œÉ : Œ£) (c : C) : ‚ÜìE ‚Üìc œÉ (evar 0 c) œÉ c
| reapp (œÉ : Œ£) (ef ea : E0 C) (œÉ' : Œ£) (cf : C) (œÉ'' : Œ£) (ca : C) (s‚Äô‚Äô‚Äô : Œ£) (cr : C) : ‚ÜìE ‚Üìc œÉ ef œÉ' cf ‚Üí ‚ÜìE ‚Üìc œÉ'
c	c
ea œÉ'' ca ‚Üí ‚Üìc œÉ'' cf ca s‚Äô‚Äô‚Äô cr ‚Üí ‚ÜìE ‚Üìc œÉ (¬∑ ef ea ) s‚Äô‚Äô‚Äô cr .
Inductive ‚ÜìE {Œ£ C : Set} (‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop) (‚Üì : Œ£ ‚Üí C ‚Üí C ‚Üí Prop) : Œ£ ‚Üí E0 C ‚Üí Prop
:= tevar (œÉ : Œ£) (c : C) : ‚ÜìE ‚Üìc ‚Üì œÉ (evar 0 c)
| teapp (œÉ : Œ£) (ef ea : E0 C) : ‚ÜìE ‚Üìc ‚Üì œÉ ef ‚Üí (‚àÄ œÉ' : Œ£, ‚àÄ cf : C, ‚ÜìE ‚Üìc œÉ ef œÉ' cf ‚Üí ‚ÜìE ‚Üìc ‚Üì œÉ' ea ‚àß (‚àÄ œÉ'' :
Œ£, ‚àÄ ca : C, ‚ÜìE ‚Üìc œÉ' ea œÉ'' ca ‚Üí ‚Üì œÉ'' cf ca )) ‚Üí ‚ÜìE ‚Üìc ‚Üì œÉ (¬∑ ef ea ).
Definition ‚ÜìœÜ {Œ£ C : Set} (‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop) (‚Üì : Œ£ ‚Üí C ‚Üí C ‚Üí Prop) (œÉ : Œ£) (cf ca : C) (œÜr : Œ£ ‚Üí C ‚Üí Prop) : Prop


:= ‚Üì œÉ cf ca ‚àß (‚àÄ œÉ' : Œ£, ‚àÄ cr : C, ‚Üìc œÉ cf ca œÉ' cr ‚Üí œÜr œÉ' cr ).
Lemma termred forall {Œ£ C I : Set} (‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop) (‚Üì : Œ£ ‚Üí C ‚Üí C ‚Üí Prop) (JI : I ‚Üí Prop) (œÉ : Œ£) (cf ca : C) (œÜr : I ‚Üí Œ£ ‚Üí C ‚Üí Prop) : (‚àÉ i : I, JI i ) ‚Üí (‚àÄ i : I, JI i ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì œÉ cf ca (œÜr i )) ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì œÉ cf ca (Œª œÉ' cr '‚Üí ‚àÄ i : I, JI i ‚Üí œÜr i œÉ' cr ).
Fixpoint ‚ÜìE {Œ£ C : Set} (‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop) (‚Üì : Œ£ ‚Üí C ‚Üí C ‚Üí Prop) (œÉ : Œ£) (e : E0 C) (œÜr : Œ£ 
‚Üí C ‚Üí Prop) : Prop
:= match e with evar  c '‚Üí œÜr œÉ c | ¬∑ ef ea '‚Üí ‚ÜìE ‚Üìc ‚Üì œÉ ef (Œª œÉ' cf '‚Üí ‚ÜìE ‚Üìc ‚Üì œÉ' ea (Œª œÉ'' ca '‚Üí ‚ÜìœÜ ‚Üìc ‚Üì œÉ'' cf ca
œÜ	œÜ
œÜr )) end.
Lemma termredexpr {Œ£ C : Set} (‚Üìc : Œ£ ‚Üí C ‚Üí C ‚Üí Œ£ ‚Üí C ‚Üí Prop) (‚Üì : Œ£ ‚Üí C ‚Üí C ‚Üí Prop) (œÉ : Œ£) (e : E0 C)
(œÜr : Œ£ ‚Üí C ‚Üí Prop) : ‚ÜìE ‚Üìc ‚Üì œÉ e œÜr ‚Üí ‚ÜìE ‚Üìc ‚Üì œÉ e ‚àß (‚àÄ œÉ' : Œ£, ‚àÄ cr : C, ‚ÜìE ‚Üìc œÉ e œÉ' cr ‚Üí œÜr œÉ' cr ).
œÜ	c
End StatefulApplicativeExpression.
3. Definition of a Stateful Combinatory Algebra
This is the formal statement of Definition 5.2.
Module Type StatefulCombinatoryAlgebra.
Include StatefulApplicativeStructure.
Parameter cŒª : ‚àÄ n : N, E? C (S n) ‚Üí C.
Parameter cencodev : ‚àÄ n : N, ‚àÄ e : E? C (S n), ‚àÄ œÉ : Œ£, JŒ£ œÉ ‚Üí JE (JC œÉ) e ‚Üí JC œÉ (cŒª n e).
Parameter red encode S : ‚àÄ œÉ œÉ' : Œ£, ‚àÄ n : N, ‚àÄ e : E? C (S (S n)), ‚àÄ ca cr : C, JŒ£ œÉ ‚Üí JE (JC œÉ) e ‚Üí JC œÉ ca ‚Üí ‚Üìc
œÉ (cŒª (S n) e) ca œÉ' cr ‚Üí œÉ' = œÉ ‚àß cŒª n (eÀô[¬∑] ca e) = cr .
Parameter red encode 0 : ‚àÄ œÉ œÉ' : Œ£, ‚àÄ e : E? C 1, ‚àÄ ca cr : C, JŒ£ œÉ ‚Üí JE (JC œÉ) e ‚Üí JC œÉ ca ‚Üí ‚Üìc œÉ (cŒª 0 e) ca œÉ' cr ‚Üí ‚ÜìE ‚Üìc œÉ (eÀô[¬∑] ca e) œÉ' cr .
Parameter term encode S : ‚àÄ œÉ : Œ£, ‚àÄ n : N, ‚àÄ e : E? C (S (S n)), ‚àÄ ca : C, JŒ£ œÉ ‚Üí JE (JC œÉ) e ‚Üí JC œÉ ca ‚Üí ‚Üì œÉ (cŒª
(S n) e) ca .
Parameter term encode 0 : ‚àÄ œÉ : Œ£, ‚àÄ e : E? C 1, ‚àÄ ca : C, JŒ£ œÉ ‚Üí JE (JC œÉ) e ‚Üí JC œÉ ca ‚Üí ‚ÜìE ‚Üìc ‚Üì œÉ (eÀô[¬∑] ca e) ‚Üí
‚Üì œÉ (cŒª 0 e) ca .
End StatefulCombinatoryAlgebra.
C-E. Lambdas.v
1. Framework for Building Codes with Lambda-Terms and Primitives
Module LambdaTerm.
Defines Œª-body expressions L parameterized by a set of codes C, and defines codes C? parameterized by a set of primitives P such that a code is either a primitive or a Œª-code of a Œª-body expression.
End LambdaTerm.
C-F. FreeRCA.v
1. Framework for Building Relational Combinatory Algebras with Lambda-Terms and Primitives
We elide the construction as it is just tedious and made complex by the fact that there is no direct way to define mutually dependent inductive types or propositions across modules. We only show the module type for specifying the set of primitives and their termination and reduction behavior.
Module FreeRelationalCombinatoryCode.

Defines relational application ‚ÜìŒª and termination ‚ÜìŒª
C
for Œª-body expressions, and application ‚Üìc  and termination ‚Üì

for codes, each parameterized by application and termination rules for the appropriate unknown sets of codes/primitives.
End FreeRelationalCombinatoryCode.
Module Type PrimitiveApplicativeStructure.
Parameter P : Set.
Parameter JP : P ‚Üí Prop.
Parameter ‚Üìp : P ‚Üí C? P ‚Üí C? P ‚Üí Prop. Parameter ‚Üìp : P ‚Üí C? P ‚Üí Prop.

Parameter preservation prim : ‚àÄ pf : P , ‚àÄ ca : C? P , ‚àÄ cr : C? P , JP pf ‚Üí JC
JP ca ‚Üí ‚Üìp pf ca cr ‚Üí JC
JP cr .

?	c	?
p	p
Parameter progress prim : ‚àÄ pf : P , ‚àÄ ca : C? P , JP pf ‚Üí JC? JP ca ‚Üí ‚Üì pf ca ‚Üí ‚àÉ cr : C? P , ‚Üì pf ca cr .
End PrimitiveApplicativeStructure.
Module FreeRelationalCombinatoryAlgebra (PAS : PrimitiveApplicativeStructure) <: RelationalCombinatoryAlgebra.
Include FreeRelationalCombinatoryCode.
Include PAS.
Tediously ties the mutually recursive knot.
End FreeRelationalCombinatoryAlgebra.
C-G. FreeSCA.v
1. Framework for Building Stateful Combinatory Algebras with Lambda-Terms and Primitives
We elide the construction as it is just tedious and made complex by the fact that there is no direct way to define mutually dependent inductive types or propositions across modules. We only show the module type for specifying the set of primitives and their termination and reduction behavior.
Module FreeStatefulCombinatoryCode.
Defines stateful application ‚ÜìŒª and termination ‚ÜìŒª for Œª-body expressions, and application ‚ÜìC? and termination ‚ÜìC?
c	c
for codes, each parameterized by application and termination rules for the appropriate unknown sets of codes/primitives
and states.
End FreeStatefulCombinatoryCode.
Module Type PrimitiveApplicativeStructure.



Parameter Œ£ : Set.
Parameter P : Set.
Parameter JŒ£ : Œ£ ‚Üí Prop. Parameter sinhabited : ‚àÉ œÉ : Œ£, JŒ£ œÉ.
Parameter ‚â§ : Œ£ ‚Üí Œ£ ‚Üí Prop. Parameter frefl : ‚àÄ œÉ : Œ£, JŒ£ œÉ ‚Üí ‚â§ œÉ œÉ.
Parameter ftrans : ‚àÄ œÉ œÉ' œÉ'' : Œ£, JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí JŒ£ œÉ'' ‚Üí ‚â§ œÉ œÉ' ‚Üí ‚â§ œÉ' œÉ'' ‚Üí ‚â§ œÉ œÉ'' .
Parameter JP : Œ£ ‚Üí P ‚Üí Prop.
Parameter primv fut : ‚àÄ œÉ œÉ' : Œ£, ‚àÄ p : P , JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí JP œÉ p ‚Üí JP œÉ' p.
Parameter ‚Üìp : Œ£ ‚Üí P ‚Üí C? P ‚Üí Œ£ ‚Üí C? P ‚Üí Prop. Parameter ‚Üìp : Œ£ ‚Üí P ‚Üí C? P ‚Üí Prop.
Parameter preservation prim : ‚àÄ œÉ : Œ£, ‚àÄ pf : P , ‚àÄ ca : C? P , ‚àÄ œÉ' : Œ£, ‚àÄ cr : C? P , JŒ£ œÉ ‚Üí JP œÉ pf ‚Üí JC














(JP œÉ) ca

‚Üí ‚Üìp œÉ pf ca œÉ' cr ‚Üí JŒ£ œÉ' ‚àß ‚â§ œÉ œÉ' ‚àß JC (JP œÉ' ) cr .
c	?
p	'
Parameter progress prim : ‚àÄ œÉ : Œ£, ‚àÄ pf : P , ‚àÄ ca : C? P , JŒ£ œÉ ‚Üí JP œÉ pf ‚Üí JC? (JP œÉ) ca ‚Üí ‚Üì œÉ pf ca ‚Üí ‚àÉ œÉ : Œ£,
‚àÉ cr : C? P , ‚Üìp œÉ pf ca œÉ' cr .
End PrimitiveApplicativeStructure.
Module FreeStatefulCombinatoryAlgebra (PAS : PrimitiveApplicativeStructure) <: StatefulCombinatoryAlgebra.
Include FreeStatefulCombinatoryCode.
Include PAS.
Tediously ties the mutually recursive knot.
End FreeStatefulCombinatoryAlgebra.
Higher-Order Fibrations
D-A. HOFs.v
D-A1. Definition of a Higher-Order Fibration
Module Type HigherOrderFibration (CCC : CartesianClosedCategory).
Propositions
Parameter Œ¶ : O ‚Üí Type.
Parameter JŒ¶ : ‚àÄ {o : O}, Œ¶ o ‚Üí Prop.
Entailment
Parameter ‚ñ∂ : ‚àÄ {o : O}, Œ¶ o ‚Üí Œ¶ o ‚Üí Prop.
Parameter refl : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ œÜ œÜ.
Parameter trans : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 œÜ3 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ œÜ3 ‚Üí ‚ñ∂ œÜ1 œÜ2 ‚Üí ‚ñ∂ œÜ2 œÜ3 ‚Üí ‚ñ∂ œÜ1 œÜ3 .
Substition
Parameter œÜÀô[¬∑] : ‚àÄ {o1 o2 : O}, ‚àÄ m : ~ o1 o2 , Œ¶ o2 ‚Üí Œ¶ o1 .
Parameter substv : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , ‚àÄ œÜ2 : Œ¶ o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ (œÜÀô[¬∑] m œÜ2 ).
Parameter substi : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , ‚àÄ œÜ2 œÜ' : Œ¶ o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ œÜ' ‚Üí ‚ñ∂ œÜ2 œÜ'
2	2	2
‚Üí ‚ñ∂ (œÜÀô[¬∑] m œÜ2 ) (œÜÀô[¬∑] m œÜ' ).
Parameter subste : ‚àÄ o1 o2 : O, ‚àÄ m1 m2 : ~ o1 o2 , ‚àÄ œÜ2 : Œ¶ o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m1 ‚Üí J~ m2 ‚Üí JŒ¶ œÜ2 ‚Üí ‚âà~
m1 m2 ‚Üí ‚ñ∂ (œÜÀô[¬∑] m1 œÜ2 ) (œÜÀô[¬∑] m2 œÜ2 ) ‚àß ‚ñ∂ (œÜÀô[¬∑] m2 œÜ2 ) (œÜÀô[¬∑] m1 œÜ2 ).
Parameter substid : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ œÜ (œÜÀô[¬∑] (id o) œÜ) ‚àß ‚ñ∂ (œÜÀô[¬∑] (id o) œÜ) œÜ.
Parameter substcomp : ‚àÄ o1 o2 o3 : O, ‚àÄ m12 : ~ o1 o2 , ‚àÄ m23 : ~ o2 o3 , ‚àÄ œÜ3 : Œ¶ o3 , JO o1 ‚Üí JO o2 ‚Üí JO o3 ‚Üí J~ m12 ‚Üí J~ m23 ‚Üí JŒ¶ œÜ3 ‚Üí ‚ñ∂ (œÜÀô[¬∑] m12 (œÜÀô[¬∑] m23 œÜ3 )) (œÜÀô[¬∑] (; m12 m23 ) œÜ3 ) ‚àß ‚ñ∂ (œÜÀô[¬∑] (; m12 m23 ) œÜ3 ) (œÜÀô[¬∑] m12 (œÜÀô[¬∑] m23 œÜ3 )).
True
Parameter T : ‚àÄ o : O, Œ¶ o.
Parameter topv : ‚àÄ o : O, JO o ‚Üí JŒ¶ (T o).
Parameter topi : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ œÜ (T o).
Parameter tops : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí ‚ñ∂ (T o1 ) (œÜÀô[¬∑] m (T o2 )).
Conjunction
Parameter ‚àß : ‚àÄ {o : O}, Œ¶ o ‚Üí Œ¶ o ‚Üí Œ¶ o.
Parameter conjv : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ (‚àß œÜ1 œÜ2 ).
Parameter conji : ‚àÄ o : O, ‚àÄ œÜ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ œÜ œÜ1 ‚Üí ‚ñ∂ œÜ œÜ2 ‚Üí ‚ñ∂ œÜ (‚àß œÜ1 œÜ2 ).
Parameter conje1 : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (‚àß œÜ1 œÜ2 ) œÜ1 .
Parameter conje2 : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (‚àß œÜ1 œÜ2 ) œÜ2 .
Parameter conjs : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , ‚àÄ œÜ1 œÜ2 : Œ¶ o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (‚àß (œÜÀô[¬∑]
m œÜ1 ) (œÜÀô[¬∑] m œÜ2 )) (œÜÀô[¬∑] m (‚àß œÜ1 œÜ2 )).
False
Parameter ‚ä• : ‚àÄ o : O, Œ¶ o.
Parameter botv : ‚àÄ o : O, JO o ‚Üí JŒ¶ (‚ä• o).
Parameter bote : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ (‚ä• o) œÜ.
Parameter bots : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí ‚ñ∂ (œÜÀô[¬∑] m (‚ä• o2 )) (‚ä• o1 ).
Disjunction
Parameter ‚à® : ‚àÄ {o : O}, Œ¶ o ‚Üí Œ¶ o ‚Üí Œ¶ o.
Parameter disjv : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ (‚à® œÜ1 œÜ2 ). Parameter disji1 : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ œÜ1 (‚à® œÜ1 œÜ2 ). Parameter disji2 : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ œÜ2 (‚à® œÜ1 œÜ2 ).
Parameter disje : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ œÜ1 œÜ ‚Üí ‚ñ∂ œÜ2 œÜ ‚Üí ‚ñ∂ (‚à® œÜ1 œÜ2 ) œÜ.
Parameter disjs : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , ‚àÄ œÜ1 œÜ2 : Œ¶ o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (œÜÀô[¬∑] m
(‚à® œÜ1 œÜ2 )) (‚à® (œÜÀô[¬∑] m œÜ1 ) (œÜÀô[¬∑] m œÜ2 )).


Implication
Parameter ‚äÉ : ‚àÄ {o : O}, Œ¶ o ‚Üí Œ¶ o ‚Üí Œ¶ o.
Parameter impv : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí JŒ¶ (‚äÉ œÜ1 œÜ2 ).
Parameter impi : ‚àÄ o : O, ‚àÄ œÜ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (‚àß œÜ œÜ1 ) œÜ2 ‚Üí ‚ñ∂ œÜ (‚äÉ œÜ1 œÜ2 ).
Parameter impe : ‚àÄ o : O, ‚àÄ œÜ1 œÜ2 : Œ¶ o, JO o ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (‚àß (‚äÉ œÜ1 œÜ2 ) œÜ1 ) œÜ2 .
Parameter imps : ‚àÄ o1 o2 : O, ‚àÄ m : ~ o1 o2 , ‚àÄ œÜ1 œÜ2 : Œ¶ o2 , JO o1 ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ (‚äÉ (œÜÀô[¬∑]
m œÜ1 ) (œÜÀô[¬∑] m œÜ2 )) (œÜÀô[¬∑] m (‚äÉ œÜ1 œÜ2 )).
Universal Quantification
Parameter ‚àÄ : ‚àÄ {o1 : O}, ‚àÄ o2 : O, Œ¶ (√ó o1 o2 ) ‚Üí Œ¶ o1 .
Parameter sforallv : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ (‚àÄ o2 œÜ12 ).
Parameter sforalli : ‚àÄ o1 o2 : O, ‚àÄ œÜ1 : Œ¶ o1 , ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ12 ‚Üí ‚ñ∂ (œÜÀô[¬∑] (œÄ1 o1 o2 ) œÜ1 ) œÜ12 ‚Üí ‚ñ∂ œÜ1 (‚àÄ o2 œÜ12 ).
Parameter sforalle : ‚àÄ o1 o2 : O, ‚àÄ œÜ1 : Œ¶ o1 , ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ12 ‚Üí ‚ñ∂ œÜ1 (‚àÄ o2
œÜ12 ) ‚Üí ‚ñ∂ (œÜÀô[¬∑] (œÄ1 o1 o2 ) œÜ1 ) œÜ12 .
Parameter sforalls : ‚àÄ o1 o' o2 : O, ‚àÄ m : ~ o1 o' , ‚àÄ œÜ' : Œ¶ (√ó o' o2 ), JO o1 ‚Üí JO o' ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ'
1	1	12	1	1	12
‚Üí ‚ñ∂ (‚àÄ o2 (œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (; (œÄ1 o1 o2 ) m ) (œÄ2 o1 o2 )) œÜ' )) (œÜÀô[¬∑] m (‚àÄ o2 œÜ' )).

Existential Quantification
12	12

Parameter ‚àÉ : ‚àÄ {o1 : O}, ‚àÄ o2 : O, Œ¶ (√ó o1 o2 ) ‚Üí Œ¶ o1 .
Parameter sexistsv : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ (‚àÉ o2 œÜ12 ).
Parameter sexistsi : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), ‚àÄ œÜ1 : Œ¶ o1 , JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ œÜ1 ‚Üí ‚ñ∂ œÜ12 (œÜÀô[¬∑] (œÄ1 o1 o2 ) œÜ1 ) ‚Üí ‚ñ∂ (‚àÉ o2 œÜ12 ) œÜ1 .
Parameter sexistse : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), ‚àÄ œÜ1 : Œ¶ o1 , JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ œÜ1 ‚Üí ‚ñ∂ (‚àÉ o2 œÜ12 )
œÜ1 ‚Üí ‚ñ∂ œÜ12 (œÜÀô[¬∑] (œÄ1 o1 o2 ) œÜ1 ).
Parameter sexistss : ‚àÄ o1 o' o2 : O, ‚àÄ m : ~ o1 o' , ‚àÄ œÜ' : Œ¶ (√ó o' o2 ), JO o1 ‚Üí JO o' ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ'
1	1	12	1	1	12
‚Üí ‚ñ∂ (œÜÀô[¬∑] m (‚àÉ o2 œÜ' )) (‚àÉ o2 (œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (; (œÄ1 o1 o2 ) m ) (œÄ2 o1 o2 )) œÜ' )).
12	12
Equality
Parameter = : ‚àÄ {o1 : O}, ‚àÄ o2 : O, Œ¶ (√ó o1 o2 ) ‚Üí Œ¶ (√ó o1 (√ó o2 o2 )).
Parameter seqv : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ (= o2 œÜ12 ).
Parameter seqi : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), ‚àÄ œÜ122 : Œ¶ (√ó o1 (√ó o2 o2 )), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ œÜ122
‚Üí ‚ñ∂ œÜ12 (œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (œÄ1 o1 o2 ) ((¬∑, ¬∑‚ü© (œÄ2 o1 o2 ) (œÄ2 o1 o2 ))) œÜ122 ) ‚Üí ‚ñ∂ (= o2 œÜ12 ) œÜ122 .
Parameter seqe : ‚àÄ o1 o2 : O, ‚àÄ œÜ12 : Œ¶ (√ó o1 o2 ), ‚àÄ œÜ122 : Œ¶ (√ó o1 (√ó o2 o2 )), JO o1 ‚Üí JO o2 ‚Üí JŒ¶ œÜ12 ‚Üí JŒ¶ œÜ122
‚Üí ‚ñ∂ (= o2 œÜ12 ) œÜ122 ‚Üí ‚ñ∂ œÜ12 (œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (œÄ1 o1 o2 ) ((¬∑, ¬∑‚ü© (œÄ2 o1 o2 ) (œÄ2 o1 o2 ))) œÜ122 ).
Parameter seqs : ‚àÄ o1 o' o2 : O, ‚àÄ m : ~ o1 o' , ‚àÄ œÜ' : Œ¶ (√ó o' o2 ), JO o1 ‚Üí JO o' ‚Üí JO o2 ‚Üí J~ m ‚Üí JŒ¶ œÜ' ‚Üí ‚ñ∂ 
1	1	12	1	1	12
(œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (; (œÄ1 o1 (√ó o2 o2 )) m ) (œÄ2 o1 (√ó o2 o2 ))) (= o2 œÜ' )) (= o2 (œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (; (œÄ1 o1 o2 ) m ) (œÄ2 o1 o2 )) œÜ' )).
12	12
Impredicativity
Parameter Œ© : O.
Parameter holds : Œ¶ Œ©.
Parameter œá : ‚àÄ {o : O}, Œ¶ o ‚Üí ~ o Œ©.
Parameter opropv : JO Œ©.
Parameter holdsv : JŒ¶ holds.
Parameter characterv : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí J~ (œá œÜ).
Parameter holdsi : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ œÜ (œÜÀô[¬∑] (œá œÜ) holds).
Parameter holdse : ‚àÄ o : O, ‚àÄ œÜ : Œ¶ o, JO o ‚Üí JŒ¶ œÜ ‚Üí ‚ñ∂ (œÜÀô[¬∑] (œá œÜ) holds) œÜ.
End HigherOrderFibration.
When a higher-order fibration is defined over a category with a natural-number object N, it automatically has an ùïü predicate over N. However, the automatic construction of ùïü tends to be complicated, so here we allow one to specify an optimized, necessarily equivalent, construction.
Module Type NatHigherOrderFibration (CCC : CartesianClosedCategory) (NNO : NaturalNumberObject CCC ).
Include HigherOrderFibration CCC.
Parameter ùïü : Œ¶ N.
Parameter isnatv : JŒ¶ ùïü.
Parameter isnatiz : ‚ñ∂ (T 1) (œÜÀô[¬∑] Z ùïü).
Parameter isnatis : ‚ñ∂ ùïü (œÜÀô[¬∑] S ùïü).
Parameter isnate : ‚àÄ œÜ : Œ¶ N, JŒ¶ œÜ ‚Üí ‚ñ∂ (T 1) (œÜÀô[¬∑] Z œÜ) ‚Üí ‚ñ∂ œÜ (œÜÀô[¬∑] S œÜ) ‚Üí ‚ñ∂ ùïü œÜ.
End NatHigherOrderFibration.
D-B. RCAstoHOFs.v
D-B1. Proof that a Relational Combinatory Algebra forms a Higher-Order Fibration
This module demonstrates that every relational (and partial) combinatory algebra forms a consistent higher-order fibration over the inhabited sets, as claimed in Section 4.2 (and Section 3.2). We only show the definitions of the constructions and the realizers of the various entailments and omit the lemmas required by NatHigherOrderFibration, the proofs of which are straightforward from the definitions.
Module RCAtoHOF (RCA : RelationalCombinatoryAlgebra ) <: NatHigherOrderFibration InhabitedSets InhabitedSetsNat.
Definition Œ¶ (o : O) : Type := set o ‚Üí C ‚Üí Prop.
Definition JŒ¶ {o : O} (œÜ : Œ¶ o) : Prop := ‚àÄ x x‚Äô : set o, ‚àÄ c : C, Jset o x ‚Üí Jset o x‚Äô ‚Üí ‚âàset o x x‚Äô ‚Üí JC c ‚Üí œÜ x c ‚Üí œÜ
x‚Äô c.
Definition ‚ñ∂ {o : O} (œÜ1 œÜ2 : Œ¶ o) : Prop := ‚àÉ c : C, JC c ‚àß ‚àÄ x : set o, ‚àÄ c1 : C, Jset o x ‚Üí JC c1 ‚Üí œÜ1 x c1 ‚Üí ‚ÜìœÜ
‚Üìc ‚Üì c c1 (œÜ2 x ).
Definition ‚äÜŒ¶ {o : O} (œÜ1 œÜ2 : Œ¶ o) : Prop := ‚àÄ x : set o, ‚àÄ c : C, Jset o x ‚Üí JC c ‚Üí œÜ1 x c ‚Üí œÜ2 x c.
Definition caxiom : C := cŒª 0 (evar 1 None).
Definition ccut (c1 c2 : C) : C := cŒª 0 (¬∑ ((¬∑) c2 ) (¬∑ ((¬∑) c1 ) (evar 1 None))).
Definition œÜÀô[¬∑] {o1 o2 : O} (m : ~ o1 o2 ) (œÜ2 : Œ¶ o2 ) : Œ¶ o1 := Œª s1 '‚Üí œÜ2 (m s1 ).
Definition T (o : O) : Œ¶ o := Œª x c '‚Üí True.


Definition c2sel1 : C := cŒª 1 (evar 2 None).
Definition c2sel2 : C := cŒª 1 (evar 2 (Some None)).
Definition ‚àß {o : O} (œÜ1 œÜ2 : Œ¶ o) : Œ¶ o := Œª x c '‚Üí ‚ÜìœÜ ‚Üìc ‚Üì c c2sel1 (œÜ1 x ) ‚àß ‚ÜìœÜ ‚Üìc ‚Üì c c2sel2 (œÜ2 x ).
Definition cconji (e1 e2 : C): C := cŒª 1 (¬∑ (¬∑ (evar 2 (Some None)) (¬∑ ((¬∑) e1 ) (evar 2 None))) (¬∑ ((¬∑) e2 ) (evar 2 None))).
Definition cconje1 : C := cŒª 0 (¬∑ (evar 1 None) ((¬∑) c2sel1 )).
Definition cconje2 : C := cŒª 0 (¬∑ (evar 1 None) ((¬∑) c2sel2 )).
Definition ‚ä• (o : O) : Œ¶ o := Œª x c '‚Üí False.
Definition ‚à® {o : O} (œÜ1 œÜ2 : Œ¶ o) : Œ¶ o := Œª x c '‚Üí (‚àÉ c1 : C, JC c1 ‚àß œÜ1 x c1 ‚àß cŒª 1 (¬∑ (evar 2 None) ((¬∑) c1 )) = c)
‚à® (‚àÉ c2 : C, JC c2 ‚àß œÜ2 x c2 ‚àß cŒª 1 (¬∑ (evar 2 (Some None)) ((¬∑) c2 )) = c).
Definition cdisji1 : C := cŒª 2 (¬∑ (evar 3 (Some None)) (evar 3 None)). Definition cdisji2 : C := cŒª 2 (¬∑ (evar 3 (Some (Some None))) (evar 3 None)). Definition cdisje (e1 e2 : C) : C := cŒª 0 (¬∑ (¬∑ (evar 1 None) ((¬∑) e1 )) ((¬∑) e2 )).
Definition ‚äÉ {o : O} (œÜ1 œÜ2 : Œ¶ o) : Œ¶ o := Œª x c '‚Üí ‚àÄ c1 : C, JC c1 ‚Üí œÜ1 x c1 ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì c c1 (œÜ2 x ). Definition ctuple2 : C := cŒª 2 (¬∑ (¬∑ (evar 3 (Some (Some None))) (evar 3 None)) (evar 3 (Some None))). Definition cimpi (e : C) : C := cŒª 1 (¬∑ ((¬∑) e) (¬∑ (¬∑ ((¬∑) ctuple2 ) (evar 2 None)) (evar 2 (Some None)))). Definition cimpe : C := cŒª 0 (¬∑ (¬∑ (evar 1 None) ((¬∑) c2sel1 )) (¬∑ (evar 1 None) ((¬∑) c2sel2 ))).
Definition ‚àÄ {o1 : O} (o2 : O) (œÜ12 : Œ¶ (√ó o1 o2 )) : Œ¶ o1 := Œª x1 c '‚Üí ‚àÄ x2 : set o2 , Jset o2 x2 ‚Üí œÜ12 (pair x1 x2 ) c. Definition ‚àÉ {o1 : O} (o2 : O) (œÜ12 : Œ¶ (√ó o1 o2 )) : Œ¶ o1 := Œª x1 c '‚Üí ‚àÉ x2 : set o2 , Jset o2 x2 ‚àß œÜ12 (pair x1 x2 ) c. Definition = {o1 : O} (o2 : O) (œÜ12 : Œ¶ (√ó o1 o2 )) : Œ¶ (√ó o1 (√ó o2 o2 ))
:= Œª x122 c '‚Üí ‚âàset o2 (fst (snd x122 )) (snd (snd x122 )) ‚àß œÜ12 (pair (fst x122 ) (fst (snd x122 ))) c.
Definition Œ© : O := {| set := C ‚Üí Prop; Jset := Œª œÜ '‚Üí ‚àÄ c : C, JC c ‚Üí œÜ c ‚Üí œÜ c; ‚âàset := Œª œÜ p‚Äô '‚Üí ‚àÄ c : C, JC c ‚Üí œÜ
c ‚Üî p‚Äô c |}.
Definition holds : Œ¶ Œ© := Œª œÜ '‚Üí œÜ.
Definition œá {o : O} (œÜ : Œ¶ o) : ~ o Œ© := œÜ.
Fixpoint cŒª (n : N) : C
:= match n with 0 '‚Üí cŒª 1 (evar 2 (Some None)) | S n '‚Üí cŒª 1 (¬∑ (evar 2 None) (¬∑ (¬∑ ((¬∑) (cŒª n )) (evar 2 None)) (evar 2
(Some None)))) end.
Definition ùïü : Œ¶ N := Œª n '‚Üí eq (cŒª n ).
Definition cnatiz : C := cŒª 0 ((¬∑) (cŒª 0)).
Definition cnatis : C := cŒª 2 (¬∑ (evar 3 (Some None)) (¬∑ (¬∑ (evar 3 None) (evar 3 (Some None))) (evar 3 (Some (Some None))))).
Definition cnate (cz cs : C) : C := cŒª 0 (¬∑ (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 None) ((¬∑) cs)) (evar 2 (Some None))))) (evar 1
None)) (¬∑ ((¬∑) cz ) ((¬∑) caxiom ))).
Inductive Realizable (œÜ : Œ¶ 1) : Prop := realizable (c : C) : JC c ‚Üí œÜ tt c ‚Üí Realizable œÜ.
Theorem entails realizable (œÜ1 œÜ2 : Œ¶ 1) : JŒ¶ œÜ1 ‚Üí JŒ¶ œÜ2 ‚Üí ‚ñ∂ œÜ1 œÜ2 ‚Üí Realizable œÜ1 ‚Üí Realizable œÜ2 .
Theorem consistent : ‚ñ∂ (T 1) (‚ä• 1) ‚Üí False. End RCAtoHOF.
D-C. SCAstoHOFs.v
D-C1. Proof that a Stateful Combinatory Algebra forms a Higher-Order Fibration
This module demonstrates that every stateful combinatory algebra forms a consistent higher-order fibration over the in- habited sets, as claimed in Theorem 5.3. It is the formal statement of Figure 2. We only show the definitions of the constructions and omit the lemmas required by NatHigherOrderFibration, the proofs of which are straightforward from the definitions (and the realizers of entailment for which are the same as for RCAs).
Module SCAtoHOF (SCA : StatefulCombinatoryAlgebra ) <: NatHigherOrderFibration InhabitedSets InhabitedSetsNat.
Definition Œ¶ (o : O) : Type := set o ‚Üí Œ£ ‚Üí C ‚Üí Prop. Record JŒ¶ {o : O} (œÜÀÜ : Œ¶ o) : Prop
:=
{ propv : ‚àÄ x : set o, ‚àÄ s s‚Äô : Œ£, ‚àÄ c : C, Jset o x ‚Üí JŒ£ s ‚Üí JŒ£ s‚Äô ‚Üí ‚â§ s s‚Äô ‚Üí JC s c ‚Üí œÜÀÜ x s c ‚Üí œÜÀÜ x s‚Äô c
; prope : ‚àÄ x x‚Äô : set o, ‚àÄ s : Œ£, ‚àÄ c : C, Jset o x ‚Üí Jset o x‚Äô ‚Üí ‚âàset o x x‚Äô ‚Üí JŒ£ s ‚Üí JC s c ‚Üí œÜÀÜ x s c ‚Üí œÜÀÜ x‚Äô s c
}.
Definition ‚ñ∂ {o : O} (œÜÀÜ1 œÜÀÜ2 : Œ¶ o) : Prop := ‚àÉ c : C, ‚àÄ s : Œ£, JŒ£ s ‚Üí JC s c ‚àß ‚àÄ x : set o, ‚àÄ s : Œ£, ‚àÄ c1 : C, Jset o x ‚Üí
JŒ£ s ‚Üí JC s c1 ‚Üí œÜÀÜ1 x s c1 ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì s c c1 (œÜÀÜ2 x ).
Definition ‚äÜŒ¶ {o : O} (œÜÀÜ1 œÜÀÜ2 : Œ¶ o) : Prop := ‚àÄ x : set o, ‚àÄ s : Œ£, ‚àÄ c : C, Jset o x ‚Üí JŒ£ s ‚Üí JC s c ‚Üí œÜÀÜ1 x s c ‚Üí œÜÀÜ2
x s c.
Definition œÜÀô[¬∑] {o1 o2 : O} (m : ~ o1 o2 ) (œÜÀÜ2 : Œ¶ o2 ) : Œ¶ o1 := Œª s1 '‚Üí œÜÀÜ2 (m s1 ).
Definition T (o : O) : Œ¶ o := Œª x s c '‚Üí True.
Definition c2sel1 : C := cŒª 1 (evar 2 None).
Definition c2sel2 : C := cŒª 1 (evar 2 (Some None)).
Definition ‚àß {o : O} (œÜÀÜ1 œÜÀÜ2 : Œ¶ o) : Œ¶ o := Œª x s c '‚Üí ‚àÄ s‚Äô : Œ£, JŒ£ s‚Äô ‚Üí ‚â§ s s‚Äô ‚Üí ‚ÜìœÜ ‚Üìc ‚Üì s‚Äô c c2sel1 (œÜÀÜ1 x ) ‚àß ‚ÜìœÜ ‚Üìc ‚Üì
s‚Äô c c2sel2 (œÜÀÜ2 x ).
Definition ‚ä• (o : O) : Œ¶ o := Œª x s c '‚Üí False.
Definition ‚à® {o : O} (œÜÀÜ1 œÜÀÜ2 : Œ¶ o) : Œ¶ o := Œª x s c '‚Üí (‚àÉ c1 : C, JC s c1 ‚àß œÜÀÜ1 x s c1 ‚àß cŒª 1 (¬∑ (evar 2 None) ((¬∑) c1 ))
= c) ‚à® (‚àÉ c2 : C, JC s c2 ‚àß œÜÀÜ2 x s c2 ‚àß cŒª 1 (¬∑ (evar 2 (Some None)) ((¬∑) c2 )) = c).
Definition ‚äÉ {o : O} (œÜÀÜ1 œÜÀÜ2 : Œ¶ o) : Œ¶ o := Œª x s c '‚Üí ‚àÄ s‚Äô : Œ£, ‚àÄ c1 : C, JŒ£ s‚Äô ‚Üí ‚â§ s s‚Äô ‚Üí JC s‚Äô c1 ‚Üí œÜÀÜ1 x s‚Äô c1 ‚Üí
‚ÜìœÜ ‚Üìc ‚Üì s‚Äô c c1 (œÜÀÜ2 x ).
Definition ‚àÄ {o1 : O} (o2 : O) (œÜÀÜ12 : Œ¶ (√ó o1 o2 )) : Œ¶ o1 := Œª x1 s c '‚Üí ‚àÄ x2 : set o2 , Jset o2 x2 ‚Üí œÜÀÜ12 (pair x1 x2 ) s c. Definition ‚àÉ {o1 : O} (o2 : O) (œÜÀÜ12 : Œ¶ (√ó o1 o2 )) : Œ¶ o1 := Œª x1 s c '‚Üí ‚àÉ x2 : set o2 , Jset o2 x2 ‚àß œÜÀÜ12 (pair x1 x2 ) s c. Definition = {o1 : O} (o2 : O) (œÜÀÜ12 : Œ¶ (√ó o1 o2 )) : Œ¶ (√ó o1 (√ó o2 o2 ))
:= Œª x122 s c '‚Üí ‚âàset o2 (fst (snd x122 )) (snd (snd x122 )) ‚àß œÜÀÜ12 (pair (fst x122 ) (fst (snd x122 ))) s c.
Definition Œ© : O
:= {| set := Œ£ ‚Üí C ‚Üí Prop
; Jset := Œª œÜÀÜ '‚Üí ‚àÄ s s‚Äô : Œ£, ‚àÄ c : C, JŒ£ s ‚Üí JŒ£ s‚Äô ‚Üí ‚â§ s s‚Äô ‚Üí JC s c ‚Üí œÜÀÜ s c ‚Üí œÜÀÜ s‚Äô c


; ‚âàset := Œª œÜÀÜ p‚Äô '‚Üí ‚àÄ s : Œ£, ‚àÄ c : C, JŒ£ s ‚Üí JC s c ‚Üí œÜÀÜ s c ‚Üî p‚Äô s c |}.
Definition holds : Œ¶ Œ© := Œª œÜÀÜ '‚Üí œÜÀÜ.
Definition œá {o : O} (œÜÀÜ : Œ¶ o) : ~ o Œ© := œÜÀÜ.
Fixpoint cŒª (n : N) : C
:= match n with 0 '‚Üí cŒª 1 (evar 2 (Some None)) | S n '‚Üí cŒª 1 (¬∑ (evar 2 None) (¬∑ (¬∑ ((¬∑) (cŒª n )) (evar 2 None)) (evar 2
(Some None)))) end.
Definition ùïü : Œ¶ N := Œª n  '‚Üí eq (cŒª n ).
Inductive Realizable (œÜÀÜ : Œ¶ 1) : Prop := realizable (s : Œ£) (c : C) : JŒ£ s ‚Üí JC s c ‚Üí œÜÀÜ tt s c ‚Üí Realizable œÜÀÜ.
Theorem entails realizable (œÜÀÜ1 œÜÀÜ2 : Œ¶ 1) : JŒ¶ œÜÀÜ1 ‚Üí JŒ¶ œÜÀÜ2 ‚Üí ‚ñ∂ œÜÀÜ1 œÜÀÜ2 ‚Üí Realizable œÜÀÜ1 ‚Üí Realizable œÜÀÜ2 .
Theorem consistent : ‚ñ∂ (T 1) (‚ä• 1) ‚Üí False. End SCAtoHOF.
Countable Choice
E-A. CountableChoice.v
E-A1. Definition of Internal Countable Choice in Evidenced Frames
This is the formal statement of Definition 2.2. It is in point-free notation because it is defined over any cartesian-closed category, not just sets.
Module CCinHOF (CCC : CartesianClosedCategory) (NNO : NaturalNumberObject CCC ) (HOF : NatHigherOrderFibration CCC NNO ).
Definition total (o1 o2 : O) (œÜ1 : Œ¶ o1 ) : Œ¶ (‚áí o1 (‚áí o2 Œ©))
:= ‚àÄ o1 (‚äÉ (œÜÀô[¬∑] œÄ2 œÜ1 ) (œÜÀô[¬∑] (eval o1 (‚áí o2 Œ©)) (‚àÉ o2 (œÜÀô[¬∑] (eval o2 Œ©) holds)))).
Definition includes : Œ¶ (√ó Œ© Œ©) := ‚äÉ (œÜÀô[¬∑] œÄ2 holds) (œÜÀô[¬∑] œÄ1 holds).
Definition lift (o1 o2 : O) (œÜ2 : Œ¶ (√ó o2 o2 )) : Œ¶ (√ó (‚áí o1 o2 ) (‚áí o1 o2 ))
:= ‚àÄ o1 (œÜÀô[¬∑] ((¬∑, ¬∑‚ü© (; ((¬∑, ¬∑‚ü© (; œÄ1 œÄ1 ) œÄ2 ) (eval o1 o2 )) (; ((¬∑, ¬∑‚ü© (; œÄ1 œÄ2 ) œÄ2 ) (eval o1 o2 ))) œÜ2 ).
Definition determined (o1 o2 : O) : Œ¶ (‚áí o1 (‚áí o2 Œ©))
:= ‚àÄ o1 (œÜÀô[¬∑] (eval o1 (‚áí o2 Œ©)) (‚àÄ o2 (‚àÄ o2 (‚äÉ (œÜÀô[¬∑] (; ((¬∑, ¬∑‚ü© (; œÄ1 œÄ1 ) (; œÄ1 œÄ2 )) (eval o2 Œ©)) holds)
(‚äÉ (œÜÀô[¬∑] (; ((¬∑, ¬∑‚ü© (; œÄ1 œÄ1 ) œÄ2 ) (eval o2 Œ©)) holds)
(œÜÀô[¬∑] ((¬∑, ¬∑‚ü© ! ((¬∑, ¬∑‚ü© (; œÄ1 œÄ2 ) œÄ2 )) (= o2 (T (√ó 1 o2 ))))))))).
Definition countable choice (o : O) : Œ¶ 1
:= ‚àÄ (‚áí N (‚áí o Œ©)) (œÜÀô[¬∑] œÄ2 (‚äÉ (total N o ùïü)
(‚àÉ (‚áí N (‚áí o Œ©)) (‚àß (‚àß (œÜÀô[¬∑] œÄ2 (total N o ùïü)) (lift N (‚áí o Œ©) (lift o Œ© includes)))
(œÜÀô[¬∑] œÄ2 (determined N o)))))).
End CCinHOF.
E-A2. Definition of Internal Countable Choice in Relational Combinatory Algebras
This is the formal statement of the definition in Lemmas 3.3 and 4.5.
Module CCinRCA (RCA : RelationalCombinatoryAlgebra ).
Definition ‚àÉ| {o1 : O} (o2 : O) (P12 : set o1 ‚Üí set o2 ‚Üí Prop) (p12 : Œ¶ (√ó o1 o2 )) : Œ¶ o1
:= Œª x1 c '‚Üí ‚àÉ x2 : set o2 , Jset o2 x2 ‚àß P12 x1 x2 ‚àß p12 (pair x1 x2 ) c.
Definition rca included {o : O} (S R : set (‚áí N (‚áí o Œ©))) : Prop := ‚àÄ n : N, ‚àÄ x : set o, ‚àÄ c : C, Jset o x ‚Üí JC c ‚Üí S n x c‚Üí R n x c.
Definition rca determined {o : O} (S : set (‚áí N (‚áí o Œ©))) : Prop
:= ‚àÄ n : N, ‚àÄ x x‚Äô : set o, ‚àÄ c c‚Äô : C, Jset o x ‚Üí Jset o x‚Äô ‚Üí JC c ‚Üí JC c‚Äô ‚Üí S n x c ‚Üí S n x‚Äô c‚Äô ‚Üí ‚âàset o x x‚Äô.
Definition rca countable choice (o : O) : Œ¶ 1
:= ‚àÄ (‚áí N (‚áí o Œ©)) (œÜÀô[¬∑] œÄ2 (‚äÉ (total N o ùïü)
(‚àÉ| (‚áí N (‚áí o Œ©)) (Œª R S '‚Üí rca included S R ‚àß rca determined S ) (œÜÀô[¬∑] œÄ2 (total N o
ùïü))))).
E-A3.  Proof that Internal CC for a PCA/RCA is Equivalent to Internal CC for its Higher-Order Fibration
We provide the codes exhibiting equivalence, but we elide here the actual proof of Lemmas 3.3 and 4.5 as it is rather tedious and follows from the definitions of the codes.
Definition csimplify : C := cŒª 1 (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 None) ((¬∑) csnd )) (¬∑ (¬∑ (evar 2 None) ((¬∑) cfst )) (evar 2 (Some None)))))) (¬∑ (¬∑ (evar 2 None) (evar 2 (Some None))) ((¬∑) cfst ))).
Definition ccomplicate : C := cŒª 1 (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 (Some None)) (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 (Some None)) (evar
2 None)) ((¬∑) (cŒª 0 (evar 1 None)))))) (evar 2 None))) ((¬∑) (cŒª 2 (evar 3 (Some (Some None)))))))) (¬∑ (evar 2 None) (evar 2 (Some None)))).
Lemma rca countable choice equiv (o : O): JO o ‚Üí‚ñ∂ (countable choice o) (rca countable choice o) ‚àß‚ñ∂ (rca countable choice o) (countable choice o).
End CCinRCA.
E-A4. Definition of Internal Countable Choice in Stateful Combinatory Algebras
This is the formal statement of the definition in Lemma 5.5.
Module CCinSCA (SCA : StatefulCombinatoryAlgebra ).
Definition ‚àÉ| {o1 : O} (o2 : O) (P12 : set o1 ‚Üí set o2 ‚Üí Prop) (p12 : Œ¶ (√ó o1 o2 )) : Œ¶ o1
:= Œª x1 œÉ c '‚Üí ‚àÉ x2 : set o2 , Jset o2 x2 ‚àß P12 x1 x2 ‚àß p12 (pair x1 x2 ) œÉ c.
Definition sca included {o : O} (S R : set (‚áí N (‚áí o Œ©))) : Prop
:= ‚àÄ n : N, ‚àÄ x : set o, ‚àÄ œÉ : Œ£, ‚àÄ c : C, Jset o x ‚Üí JŒ£ œÉ ‚Üí JC œÉ c ‚Üí S n x œÉ c‚Üí R n x œÉ c.
Definition sca determined {o : O} (S : set (‚áí N (‚áí o Œ©))) : Prop
:= ‚àÄ n : N, ‚àÄ x x‚Äô : set o, ‚àÄ œÉ : Œ£, ‚àÄ c c‚Äô : C, Jset o x ‚Üí Jset o x‚Äô ‚Üí JŒ£ œÉ ‚Üí JC œÉ c ‚Üí JC œÉ c‚Äô ‚Üí S n x œÉ c ‚Üí S n x‚Äô œÉ
c‚Äô ‚Üí ‚âàset o x x‚Äô.
Definition sca countable choice (o : O) : Œ¶ 1
:= ‚àÄ (‚áí N (‚áí o Œ©)) (œÜÀô[¬∑] œÄ2 (‚äÉ (total N o ùïü)
(‚àÉ| (‚áí N (‚áí o Œ©)) (Œª R S '‚Üí sca included S R ‚àß sca determined S ) (œÜÀô[¬∑] œÄ2 (total N o
ùïü))))).

5. Proof that Internal CC for an SCA is Equivalent to Internal CC for its Higher-Order Fibration
We provide the codes exhibiting equivalence, but we elide here the actual proof of Lemma 5.5 as it is rather tedious and follows from the definitions of the codes.
Definition csimplify : C := cŒª 1 (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 None) ((¬∑) csnd )) (¬∑ (¬∑ (evar 2 None) ((¬∑) cfst )) (evar 2 (Some None)))))) (¬∑ (¬∑ (evar 2 None) (evar 2 (Some None))) ((¬∑) cfst ))).
Definition ccomplicate : C := cŒª 1 (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 (Some None)) (¬∑ ((¬∑) (cŒª 1 (¬∑ (¬∑ (evar 2 (Some None)) (evar
2 None)) ((¬∑) (cŒª 0 (evar 1 None)))))) (evar 2 None))) ((¬∑) (cŒª 2 (evar 3 (Some (Some None)))))))) (¬∑ (evar 2 None) (evar 2 (Some None)))).
Lemma sca countable choice equiv (o : O): JO o ‚Üí‚ñ∂ (countable choice o) (sca countable choice o) ‚àß‚ñ∂ (sca countable choice o) (countable choice o).
End CCinSCA.
E-B. CCPCAs.v
1. Proof that Partial Combinatory Algebras Internally Model Countable Choice
This module demonstrates that the higher-order fibration for any PCA internally models countable choice, as claimed in Theorem 3.4. We only show the metatheoretic assumption made and the key lemma enabled by determinism that permits PCAs to model countable choice; we elide here the detailed proof of the theorem.
Module CCPCA (PCA : PartialCombinatoryAlgebra ).
Here we assume the axiom of countable choice in the metatheory.
Axiom axiom of countable choice : ‚àÄ I : Set, ‚àÄ JI : I ‚Üí Prop, ‚àÄ R : N ‚Üí I ‚Üí Prop, (‚àÄ n : N, ‚àÉ i : I, JI i ‚àß R n i ) ‚Üí ‚àÉ 
S : N ‚Üí I ‚Üí Prop, (‚àÄ n : N, ‚àÄ i : I, S n i ‚Üí R n i ) ‚àß (‚àÄ n : N, ‚àÄ i i‚Äô : I, S n i ‚Üí S n i‚Äô ‚Üí i = i‚Äô ) ‚àß ‚àÄ n : N, ‚àÉ i : I, JI i
‚àß S n i.
This is the key lemma that enables us to prove choice. It requires the red deterministic property of PCAs.
Lemma red exists (cf ca : C) (I : Set) (JI : I ‚Üí Prop) (œÜ¬∑ : I ‚Üí C ‚Üí Prop) : JC cf ‚Üí JC ca ‚Üí (‚àÉ i : I, JI i ) ‚Üí ‚ÜìœÜ ‚Üìc
‚Üì cf ca (Œª cr '‚Üí ‚àÉ i : I, JI i ‚àß œÜ¬∑ i cr ) ‚Üí ‚àÉ i : I, JI i ‚àß ‚ÜìœÜ ‚Üìc ‚Üì cf ca (œÜ¬∑ i ).
Definition cc : C := cŒª 0 ((¬∑) caxiom ).
Theorem countable choice (o : O) : JO o ‚Üí ‚ñ∂ (T 1) (countable choice o).
End CCPCA.
E-C. NCCRCA.v
1. Definition of Flip-RCA
This is the formal definition of Flip-RCA in Figure 1. It uses the FreeRCA module for Œª-terms, so the following module specifies the primitives and their behavior. Note that primitives here include the n codes, with pvalue being the corresponding constructor. We use O here to refer to what the paper refers to as primitives.
Module FlipApplicativeStructure <: PrimitiveApplicativeStructure.
Inductive O : Set := const (n : N) | succ | on ¬∑ do ¬∑ else ¬∑ (n : list N) (oon ooff : O) | flip.
Inductive Prim‚Äô : Set := pvalue (n : N) | pop (o : O).
Definition JP (p : P ) : Prop := True.
Inductive ‚ÜìO : O ‚Üí N ‚Üí N ‚Üí Prop
:= roconst (n na : N) : ‚ÜìO (const n ) na n
| rosucc (n : N) : ‚ÜìO succ n (S n)
| robranchon (n : list N) (oon ooff : O) (na nr : N) : In na n ‚Üí ‚ÜìO oon na nr ‚Üí ‚ÜìO (on ¬∑ do ¬∑ else ¬∑ n oon ooff ) na nr
| robranchoff (n : list N) (oon ooff : O) (na nr : N) : (In na n ‚Üí False) ‚Üí ‚ÜìO ooff na nr ‚Üí ‚ÜìO (on ¬∑ do ¬∑ else ¬∑ n oon ooff ) na nr
| rotails (na : N) : ‚ÜìO flip na 0
| roheads (na : N) : ‚ÜìO flip na 1.
Definition ‚Üìp (pf : P ) (ca : C? P ) (cr : C? P ) : Prop
:= ‚àÉ of : O, pop of = pf ‚àß ‚àÉ na : N, (¬∑) (pvalue na ) = ca ‚àß ‚àÉ nr : N, (¬∑) (pvalue nr ) = cr ‚àß ‚ÜìO of na nr .
Definition ‚Üìp (pf : P ) (ca : C? P ) : Prop := ‚àÉ of : O, pop of = pf ‚àß ‚àÉ na : N, (¬∑) (pvalue na ) = ca .

Lemma preservation prim (pf : P ) (ca : C? P ) (cr : C? P ) : JP pf ‚Üí JC
JP ca ‚Üí ‚Üìp pf ca cr ‚Üí JC
JP cr .

?	c	?
p	p
Lemma progress prim (pf : P ) (ca : C? P ) : JP pf ‚Üí JC? JP ca ‚Üí ‚Üì pf ca ‚Üí ‚àÉ cr : C? P , ‚Üì pf ca cr .
End FlipApplicativeStructure.
E-C2. Proof that Flip-RCA is an RCA.
The proof of Lemma 4.3 is a trival application of the FreeRCA module.
Module FlipRCA := FreeRelationalCombinatoryAlgebra FlipApplicativeStructure.
E-C3. Definition of Flip-RCA Codes with Primitive Holes
The first part of this module provides the formal definitions of codes with holes and of the operations for filling those holes used in Lemma 4.4.
Module FlipNCC.
Inductive OÀô : Type := hohole | hoconst (n : N) | hosucc | hobranch (n : list N) (oÀôon oÀôoff : OÀô ) | hoflip.
Fixpoint fill op (o : O) (oÀô : OÀô ) : O
:= match oÀô with
| hohole '‚Üí o
| hoconst n '‚Üí const n
| hosucc '‚Üí succ
| hobranch n oÀôon oÀôoff '‚Üí on ¬∑ do ¬∑ else ¬∑ n (fill op o oÀôon ) (fill op o oÀôoff )
| hoflip '‚Üí flip
end.
Inductive PÀô : Type := hpvalue (n : N) | hpop (oÀô : OÀô ).
Definition CÀô : Type := C? PÀô .
Definition fill prim (o : O) (pÀô : PÀô ) : P := match pÀô with hpvalue n '‚Üí pvalue n | hpop oÀô '‚Üí pop (fill op o oÀô) end. Definition fill lambda (fill code : CÀô ‚Üí C) {n : N} : L CÀô n ‚Üí L C n


:= fix fill lambda (hl : L CÀô n ) : L C n
:= match hl with (¬∑) cÀô '‚Üí (¬∑) (fill code cÀô) | lvar  v '‚Üí lvar n v | ¬∑ hlf hla '‚Üí ¬∑ (fill lambda hlf ) (fill lambda hla ) end.
Fixpoint fill code (o : O) (cÀô : CÀô ) : C := match cÀô with (¬∑) pÀô '‚Üí (¬∑) (fill prim o pÀô) | Œª¬∑ n hl '‚Üí Œª¬∑ n (fill lambda (fill code o) hl ) end.
E-C4. Proof that Flip-RCA is Extensional and Finitary
The actual proof is elided here, as it is straightforward from induction on the given proof of application. Only the formal statement of Lemma 4.4 is shown.
Lemma continuity code (cÀôf cÀôa : CÀô ) (o : O) (cr : C)
: ‚ÜìC? ‚Üìp (fill code o cÀô ) (fill code o cÀôa ) cr
c	c	f

‚Üí ‚àÉ cÀôr : CÀô ,
fill code o cÀôr = cr
‚àß ‚àÉ io : list (prod N N),
Forall (Œª io '‚Üí ‚ÜìO o (fst io) (snd io)) io
‚àß ‚àÄ o‚Äô : O, Forall (Œª io '‚Üí ‚ÜìO




C? ‚Üìp (fill code o‚Äô cÀô ) (fill code o‚Äô cÀôa ) (fill code o‚Äô cÀôr ).

o‚Äô (fst io) (snd io)) io ‚Üí ‚Üìc	c	f
E-C5. Proof that Flip-RCA Internally Negates Countable Choice
The detailed proof of Theorem 4.6 is elided here, but we provide the primary lemmas to provide some insight.
Fixpoint filled op (o : O) : OÀô
:= match o with const n '‚Üí hoconst n | succ '‚Üí hosucc | on ¬∑ do ¬∑ else ¬∑ n oon ooff '‚Üí hobranch n (filled op oon ) (filled op ooff )
| flip '‚Üí hoflip end.
Definition filled prim (p : P ) : PÀô := match p with pvalue n '‚Üí hpvalue n | pop o '‚Üí hpop (filled op o) end. Definition filled lambda (filled code : C ‚Üí CÀô ) {n : N} : L C n ‚Üí L CÀô n
:= fix filled lambda (√Ü : L C n ) : L CÀô n
:= match √Ü with (¬∑) c '‚Üí (¬∑) (filled code c) | lvar  v '‚Üí lvar n v | ¬∑ √Üf √Üa '‚Üí ¬∑ (filled lambda √Üf ) (filled lambda √Üa ) end. Fixpoint filled code (c : C) : CÀô := match c with (¬∑) p '‚Üí (¬∑) (filled prim p) | Œª¬∑ n √Ü '‚Üí Œª¬∑ n (filled lambda filled code √Ü)
end.
Lemma fill filled code (o : O) (c : C) : fill code o (filled code c) = c.
Lemma red cnat (n : N) : ‚ÜìC? ‚Üìp ‚Üìp (cŒª n ) ((¬∑) (pop succ)) ‚àß ‚àÄ cns : C, ‚ÜìC? ‚Üìp (cŒª n ) ((¬∑) (pop succ)) cns ‚Üí ‚àÄ m : N,
c	¬∑	c	c  ¬∑
‚ÜìC? ‚Üìp ‚Üìp cns ((¬∑) (pvalue m )) ‚àß ‚àÄ cnm : C, ‚ÜìC? ‚Üìp cns ((¬∑) (pvalue m )) cnm ‚Üí (¬∑) (pvalue (n + m )) = cnm .
c	c	c
Definition cop (o : O) : C := Œª¬∑ 0 (¬∑ ((¬∑) ((¬∑) (pop o))) (¬∑ (¬∑ (lvar 1 None) ((¬∑) ((¬∑) (pop succ)))) ((¬∑) ((¬∑) (pvalue 0))))).
Lemma red cop (o : O) (m : N) (cm : C) (œÜr : C ‚Üí Prop) : ùïü m cm ‚Üí (‚àÄ n : N, ‚ÜìO o m n ‚Üí œÜr ((¬∑) (pvalue n ))) ‚Üí ‚ÜìœÜ
‚Üìc ‚Üì (cop o) cm œÜr .
Definition hcop (oÀô : OÀô ) : CÀô := Œª¬∑ 0 (¬∑ ((¬∑) ((¬∑) (hpop oÀô))) (¬∑ (¬∑ (lvar 1 None) ((¬∑) ((¬∑) (hpop hosucc)))) ((¬∑) ((¬∑) (hpvalue 0))))).
Lemma fill cop (o : O) (oÀô : OÀô ) : fill code o (hcop oÀô) = cop (fill op o oÀô).
Definition Rop (o : O) : set (‚áí N (‚áí N Œ©)) := Œª m n c '‚Üí ‚ÜìO o m n ‚àß ((¬∑) (pvalue n )) = c.
Lemma Ropv (o : O) : Jset (‚áí N (‚áí N Œ©)) (Rop o).
Lemma Rop total (o : O) : total N N ùïü (Rop o) (cop o).
Definition ncc : C := caxiom.
Theorem neg countable choice : ‚àÉ o : O, ‚ñ∂ (countable choice o) (‚ä• 1).
End FlipNCC.
E-D. CCSCA.v
E-D1. Definition of Mem-SCA
This is the formal definition of Mem-SCA in Figure 3. It uses the FreeSCA module for Œª-terms, so the following module specifies the primitives and their behavior. There are a few differences between this definition and that in Figure 3, all for the sake of reducing metatheoretic assumptions. In particular, Œ£ (i.e. the set of œÇs) is defined inductively as a sequence of allocation/memoization events, and ‚â§ is simply to be defined to be prefix. This means that if a pre-state has two predecessors, then one of the those predecessors must be a future of the other. It also means that if a location-input pair has a memoization in the current pre-state, then we can determine via sfirst the first point in the past where that pair was allocated in the pre-state. Any subsequent futures will have that same first state for the given entry, as proven by sfirst fut eq. This means that we can take a choice relation that is not future-stable, and define from it a choice relation that is future-stable by having every state instead the choice for a particular entry that was assigned to its first predecessor that had that entry (which might be itself). Beyond this, the proof is the same is given in Theorem 5.6.
Module MemoizingApplicativeStructure <: PrimitiveApplicativeStructure.
Primitives and Pre-States
Definition L : Set := N.
Inductive P : Set := ndnat | memo | lookup (√Ü : L).
Inductive Œ£ : Set := sempty | sallocate (œÉ : Œ£) (√Ü : L) (cf : C? P ) | smemoize (œÉ : Œ£) (√Ü : L) (n : N) (cr : C? P ).
Inductive ‚â§ (œÉ : Œ£) : Œ£ ‚Üí Prop
:= frefl‚Äô : ‚â§ œÉ œÉ 
| fallocate (œÉ' : Œ£) (√Ü : L) (cf : C? P ) : ‚â§ œÉ œÉ' ‚Üí ‚â§ œÉ (sallocate œÉ' √Ü cf )
| fmemoize (œÉ' : Œ£) (√Ü : L) (n : N) (cr : C? P ) : ‚â§ œÉ œÉ' ‚Üí ‚â§ œÉ (smemoize œÉ' √Ü n cr ).
Lemma ftrans‚Äô (œÉ œÉ' œÉ'' : Œ£) : ‚â§ œÉ œÉ' ‚Üí ‚â§ œÉ' œÉ'' ‚Üí ‚â§ œÉ œÉ'' .
Lemma flinear {s1 s2 œÉ' : Œ£} : ‚â§ s1 œÉ' ‚Üí ‚â§ s2 œÉ' ‚Üí ‚â§ s1 s2 ‚à® ‚â§ s2 s1.
Inductive Allocated (œÉ : Œ£) (√Ü : L) (cf : C? P ) : Prop := aallocate (sa : Œ£) : ‚â§ (sallocate sa √Ü cf ) œÉ ‚Üí Allocated œÉ √Ü cf .
Inductive Memoized (œÉ : Œ£) (√Ü : L) (n : N) (cr : C? P ) : Prop := mmemoize (sm : Œ£) : ‚â§ (smemoize sm √Ü n cr ) œÉ ‚Üí
Memoized œÉ √Ü n cr .
Inductive JP (œÉ : Œ£) : P ‚Üí Prop
:= pndv : JP œÉ ndnat
| pallocv : JP œÉ memo
| plookupv (n : N) (cf : C? P ) : Allocated œÉ n cf ‚Üí JP œÉ (lookup n ).
Lemma allocated fut (œÉ œÉ' : Œ£) (√Ü : L) (cf : C? P ) : ‚â§ œÉ œÉ' ‚Üí Allocated œÉ √Ü cf ‚Üí Allocated œÉ' √Ü cf .
Lemma memoized fut (œÉ œÉ' : Œ£) (√Ü : L) (n : N) (cr : C? P ) : ‚â§ œÉ œÉ' ‚Üí Memoized œÉ √Ü n cr ‚Üí Memoized œÉ' √Ü n cr .


Lemma primv fut‚Äô (œÉ œÉ' : Œ£) (p : P ) : ‚â§ œÉ œÉ' ‚Üí JP œÉ p ‚Üí JP œÉ' p.

Lemma pcodev fut‚Äô (œÉ œÉ' : Œ£) (c : C? P ) : ‚â§ œÉ œÉ' ‚Üí JC (JP œÉ) c ‚Üí JC
?
(JP œÉ' ) c.

Fixpoint cchurch {P : Set} (n : N) : C? P
:= match n with 0 '‚Üí Œª¬∑ 1 (lvar 2 (Some None)) | S n '‚Üí Œª¬∑ 1 (¬∑ (lvar 2 None) (¬∑ (¬∑ ((¬∑) (cchurch n )) (lvar 2 None)) (lvar
2 (Some None)))) end.
Application within a Pre-State
These define frozen reduction within a pre-state.
Inductive ‚Üìp ? (œÉ : Œ£) : P ‚Üí C? P ‚Üí C? P ‚Üí Prop
:= rpfnd (ca : C? P ) (n : N) : ‚Üìp ? œÉ ndnat ca (cchurch n )
| rpfalloc (cf : C? P ) (√Ü : L) : Allocated œÉ √Ü cf ‚Üí ‚Üìp ? œÉ memo cf ((¬∑) (lookup √Ü))
| rpflookup (√Ü : L) (n : N) (cr : C? P ) : Memoized œÉ √Ü n cr ‚Üí ‚Üìp ? œÉ (lookup √Ü) (cchurch n ) cr .

Inductive ‚ÜìŒª (‚ÜìC? : C  P ‚Üí C  P ‚Üí C  P ‚Üí Prop) : L (C  P ) 0 ‚Üí C
P ‚Üí Prop

:= rlfcode (c : C
P ) : ‚ÜìŒª ‚ÜìC? ((¬∑) c) c

?	œÇ  œÇ

| rlfapp (lf la : L (C
? P ) 0) (cf ca cr : C?
P ) : ‚ÜìŒª ‚ÜìC? lf c ‚Üí ‚ÜìŒª ‚ÜìC? la ca
‚Üí ‚ÜìC? c  ca cr ‚Üí ‚ÜìŒª ‚ÜìC? (¬∑ lf la) cr .

Inductive ‚ÜìC? (œÉ : Œ£) : C
P ‚Üí C?
P ‚Üí C?
P ‚Üí Prop

:= rcprim (p
: P ) (ca : C  P ) (cr : C  P ) : ‚Üìp ? œÉ p  ca cr
C? œÉ ((¬∑) p ) ca cr

f	?	?	œÇ	f
‚Üí ‚ÜìœÇ	f

| rclam0 (lb : L (C
P ) 1) (ca cr : C  P ) : ‚ÜìŒª (‚ÜìC? œÉ) (lsubst ca lb) cr
C? œÉ (Œª¬∑ 0 lb) ca cr

?	?	œÇ	œÇ
‚Üí ‚ÜìœÇ

| rclamS (n : N) (lb : L (C?
P ) (S (S n))) (ca : C?
P ) : ‚ÜìC? œÉ (Œª¬∑ (S n) lb) ca (Œª¬∑ n (lsubst ca lb)).

Lemma red lambda frozen fut (‚ÜìC? ‚áìC? : C P ‚Üí C P ‚Üí C P ‚Üí Prop) (√Ü : L (C P ) 0) (cr : C P ) : (‚àÄ c
ca cr :

C P , ‚ÜìC? c
ca cr
‚Üí ‚áìC? c
ca cr ) ‚Üí ‚ÜìŒª ‚ÜìC? √Ü cr ‚Üí ‚ÜìŒª ‚áìC? √Ü cr .

Lemma red prim frozen fut (œÉ œÉ' : Œ£) (pf : P ) (ca : C? P ) (cr : C? P ) : ‚â§ œÉ œÉ' ‚Üí ‚Üìp ? œÉ pf ca cr ‚Üí ‚Üìp ? œÉ' pf ca cr .

Lemma red code frozen fut (œÉ œÉ' : Œ£) (c
ca cr : C
œÇ
'	C? œÉ c ca cr
C? œÉ' c
œÇ
ca cr .

f
Inductive UnAllocated : Œ£ ‚Üí L ‚Üí Prop
? P ) : ‚â§ œÉ œÉ ‚Üí ‚ÜìœÇ	f
‚Üí ‚ÜìœÇ	f

:= uaempty (lf : L) : UnAllocated sempty lf
| uaallocate (lf : L) (œÉ : Œ£) (√Ü : L) (cf : C? P ) : UnAllocated œÉ lf ‚Üí (lf = √Ü ‚Üí False) ‚Üí UnAllocated (sallocate œÉ √Ü cf )
lf
| uamemoized (lf : L) (œÉ : Œ£) (√Ü : L) (n : N) (cr : C? P ) : UnAllocated œÉ lf ‚Üí UnAllocated (smemoize œÉ √Ü n cr ) lf.
Inductive UnMemoized : Œ£ ‚Üí L ‚Üí N ‚Üí Prop
:= umempty (lf : L) (nf : N) : UnMemoized sempty lf nf
| umallocate (lf : L) (nf : N) (œÉ : Œ£) (√Ü : L) (cf : C? P ) : UnMemoized œÉ lf nf ‚Üí UnMemoized (sallocate œÉ √Ü cf ) lf nf
| ummemoized (lf : L) (nf : N) (œÉ : Œ£) (√Ü : L) (n : N) (cr : C? P ): UnMemoized œÉ lf nf ‚Üí (lf = √Ü ‚Üí nf = n ‚Üí False)
‚Üí UnMemoized (smemoize œÉ √Ü n cr ) lf nf.
Lemma memoized unmemoized false (œÉ : Œ£) (√Ü : L) (n : N) (cr : C? P ) : Memoized œÉ √Ü n cr ‚Üí UnMemoized œÉ √Ü n ‚Üí
False.
States
Rather than defining state validity by the behaviors we need of states, as in Figure 3, we define state validity inductively and prove that it implies the necessary behaviors.
Inductive JŒ£ : Œ£ ‚Üí Prop
:= semptyv : JŒ£ sempty
| sallocatev (œÉ : Œ£) (√Ü : L) (cf : C? P ) : JŒ£ œÉ ‚Üí UnAllocated œÉ √Ü ‚Üí JC? (JP œÉ) cf ‚Üí JŒ£ (sallocate œÉ √Ü cf )
| smemoizev (œÉ : Œ£) (√Ü : L) (n : N) (cr : C? P ) (cf : C? P ) : JŒ£ œÉ ‚Üí Allocated œÉ √Ü cf ‚Üí UnMemoized œÉ √Ü n ‚Üí JC?

(J œÉ) cr
C? œÉ c (cchurch n ) cr ‚Üí J (smemoize œÉ √Ü n cr ).

P	‚Üí ‚ÜìœÇ	f	Œ£
Lemma statev fut (œÉ œÉ' : Œ£) : ‚â§ œÉ œÉ' ‚Üí JŒ£ œÉ' ‚Üí JŒ£ œÉ.
Lemma allocated det (œÉ : Œ£) (sv : JŒ£ œÉ) (√Ü : L) (cf cf‚Äô : C? P ) : Allocated œÉ √Ü cf ‚Üí Allocated œÉ √Ü cf‚Äô ‚Üí cf = cf‚Äô.
Lemma memoized det (œÉ : Œ£) (sv : JŒ£ œÉ) (√Ü : L) (n : N) (cr cr‚Äô : C? P ) : Memoized œÉ √Ü n cr ‚Üí Memoized œÉ √Ü n cr‚Äô ‚Üí
cr = cr‚Äô.
Lemma allocated valid (œÉ : Œ£) (sv : JŒ£ œÉ) (√Ü : L) (cf : C? P ) : Allocated œÉ √Ü cf ‚Üí JC? (JP œÉ) cf .
Lemma memoized valid (œÉ : Œ£) (sv : JŒ£ œÉ) (√Ü : L) (n : N) (cr : C? P ) : Memoized œÉ √Ü n cr ‚Üí JC? (JP œÉ) cr .
Lemma memoized allocated (œÉ : Œ£) (sv : JŒ£ œÉ) (√Ü : L) (n : N) (cr : C? P ) : Memoized œÉ √Ü n cr ‚Üí ‚àÉ cf : C? P , Allocated
œÉ √Ü cf .
Lemma memoized red (œÉ : Œ£) (sv : JŒ£ œÉ) (√Ü : L) (cf : C? P ) (n : N) (cr : C? P ) : Allocated œÉ √Ü cf ‚Üí Memoized œÉ √Ü n
c	C?
r ‚Üí ‚ÜìœÇ  œÉ cf (cchurch n ) cr .
Lemma sinhabited : ‚àÉ œÉ : Œ£, JŒ£ œÉ.
Lemma frefl (œÉ : Œ£) : JŒ£ œÉ ‚Üí ‚â§ œÉ œÉ.
Lemma ftrans (œÉ œÉ' œÉ'' : Œ£) : JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí JŒ£ œÉ'' ‚Üí ‚â§ œÉ œÉ' ‚Üí ‚â§ œÉ' œÉ'' ‚Üí ‚â§ œÉ œÉ'' .
Lemma primv fut (œÉ œÉ' : Œ£) (p : P ) : JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí JP œÉ p ‚Üí JP œÉ' p.

Lemma pcodev fut (œÉ œÉ' : Œ£) (c : C? P ) : JŒ£ œÉ ‚Üí JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí JC (JP œÉ) c ‚Üí JC
?
(JP œÉ' ) c.

Application and Termination with States
This defines the application relation that does mutate pre-state.
Definition ‚Üìp (œÉ : Œ£) (pf : P ) (ca : C? P ) (œÉ' : Œ£) (cr : C? P ) : Prop := ‚â§ œÉ œÉ' ‚àß JŒ£ œÉ' ‚àß ‚Üìp ? œÉ' pf ca cr .
c	œÇ
Inductive ‚Üìp (œÉ : Œ£) : P ‚Üí C? P ‚Üí Prop
:= tpfnd (ca : C? P ) : ‚Üìp œÉ ndnat ca
| tpfalloc (cf : C? P ) : ‚Üìp œÉ memo cf
| tpflookup (√Ü : L) (n : N) (cf : C? P ) : Allocated œÉ √Ü cf ‚Üí ‚ÜìC? ‚Üìp ‚Üìp œÉ cf (cchurch n ) ‚Üí ‚Üìp œÉ (lookup √Ü) (cchurch n ).

Progress
Lemma preservation prim (œÉ : Œ£) (pf : P ) (ca : C? P ) (œÉ' : Œ£) (cr : C? P ) : JŒ£ œÉ ‚Üí JP œÉ pf ‚Üí JC


(JP œÉ) ca ‚Üí ‚Üìp œÉ

pf ca œÉ' cr ‚Üí JŒ£ œÉ' ‚àß ‚â§ œÉ œÉ' ‚àß JC (JP œÉ' ) cr .
Lemma new (œÉ : Œ£) : (‚àÉ √Ü : L, ‚àÄ √Ü' : L, √Ü ‚â§ √Ü' ‚Üí UnAllocated œÉ √Ü' ).
Lemma memoized (œÉ : Œ£) (√Ü : L) (n : N) : (‚àÉ cr : C? P , Memoized œÉ √Ü n cr ) ‚à® (UnMemoized œÉ √Ü n ).


Lemma red code freeze (œÉ : Œ£) (c ca : &

P ) (œÉ' : Œ£) (cr : &

P ) : J œÉ ‚Üí J  (J œÉ) c  ‚Üí J

(J œÉ) ca

C? ‚Üìp

f	?
C?
œÉ cf ca œÉ' cr ‚Üí ‚Üì	œÉ' c  ca cr .
?	Œ£	C?  P
f	C?  P
‚Üí ‚Üìc	c

Lemma red code thaw (œÉ : Œ£) (c
ca : &
P ) (cr : &
C? œÉ c  ca cr
C? ‚Üìp œÉ c  ca œÉ cr .

f	?	? P ) : JŒ£ œÉ ‚Üí ‚ÜìœÇ	f
‚Üí ‚Üìc	c	f

p	'
Lemma progress prim (œÉ : Œ£) (pf : P ) (ca : &? P ) : JŒ£ œÉ ‚Üí JP œÉ pf ‚Üí JC? (JP œÉ) ca ‚Üí ‚Üì œÉ pf ca ‚Üí ‚àÉ œÉ : Œ£, ‚àÉ cr :
&? P , ‚Üìp œÉ pf ca œÉ' cr .
End MemoizingApplicativeStructure.
E-D2. Proof that Mem-SCA is an SCA.
The proof of Lemma 5.4 is a trival application of the FreeSCA module.
Module MemoizingSCA := FreeStatefulCombinatoryAlgebra MemoizingApplicativeStructure.
E-D3. Proof that Mem-SCA Internally Models Countable Choice
The detailed proof of Theorem 5.6 is elided here, but we provide the primary lemmas to provide some insight.
Module MemoizingCC.
Here we assume the axiom of countable choice in the metatheory, asserting without proof that the set of states Œ£ and the set of codes C are both countable, and that JŒ£ , ‚â§, and Memoized are each recognizable predicates so that the subset of states and codes satisfying them is also countable.
Axiom axiom of countable choice : ‚àÄ I : Set, ‚àÄ JI : I ‚Üí Prop, ‚àÄ œÉ : Œ£, ‚àÄ √Ü : L, ‚àÄ R : N ‚Üí I ‚Üí Œ£ ‚Üí & ‚Üí Prop, (‚àÄ n : N,
‚àÄ œÉ' : Œ£, ‚àÄ c : &, JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí Memoized œÉ' √Ü n c ‚Üí ‚àÉ i : I, JI i ‚àß R n i œÉ' c) ‚Üí ‚àÉ S : N ‚Üí I ‚Üí Œ£ ‚Üí & ‚Üí Prop, (‚àÄ n : N, ‚àÄ i : I, ‚àÄ œÉ' : Œ£, ‚àÄ c : &, S n i œÉ' c ‚Üí R n i œÉ' c) ‚àß (‚àÄ n : N, ‚àÄ i i‚Äô : I, ‚àÄ œÉ' : Œ£, ‚àÄ c : &, S n i œÉ' c ‚Üí S n i‚Äô œÉ' c ‚Üí i = i‚Äô ) ‚àß ‚àÄ n : N, ‚àÄ œÉ' : Œ£, ‚àÄ c : &, JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí Memoized œÉ' √Ü n c ‚Üí ‚àÉ i : I, JI i ‚àß S n i œÉ' c.
First predecessor with a given entry
Fixpoint sfirst (√Ü : L) (n : N) (œÉ : Œ£) : Œ£ 
:= match œÉ with
| sempty '‚Üí sempty
| sallocate œÉ √Ü' cf '‚Üí sfirst √Ü n œÉ
| smemoize œÉ √Ü' n‚Äô cr '‚Üí if eq dec √Ü √Ü' then if eq dec n n‚Äô then smemoize œÉ √Ü' n‚Äô cr else sfirst √Ü n œÉ else sfirst √Ü n œÉ
end.
Lemma smemoize sfirst fut (œÉ œÉ' : Œ£) (√Ü : L) (n : N) (cr : &): ‚â§ (smemoize œÉ √Ü n cr ) œÉ' ‚Üí ‚â§ (smemoize œÉ √Ü n cr ) (sfirst
√Ü n œÉ' ).
Lemma sfirst memoized (√Ü : L) (n : N) (œÉ : Œ£) (cr : &) : Memoized œÉ √Ü n cr ‚Üí Memoized (sfirst √Ü n œÉ) √Ü n cr .
Lemma sfirst fut eq (√Ü : L) (n : N) (œÉ œÉ' : Œ£) (cr : &) : JŒ£ œÉ' ‚Üí ‚â§ œÉ œÉ' ‚Üí Memoized œÉ √Ü n cr ‚Üí sfirst √Ü n œÉ = sfirst √Ü
n œÉ' .
Lemma sfirst fut (√Ü : L) (n : N) (œÉ : Œ£) : ‚â§ (sfirst √Ü n œÉ) œÉ.
Lemma sfirst unmemoized (œÉ : Œ£) (√Ü : L) (n : N) (œÉ' : Œ£) (cr : &) : UnMemoized œÉ √Ü n ‚Üí Memoized œÉ' √Ü n cr ‚Üí ‚â§ œÉ œÉ'
‚Üí ‚â§ œÉ (sfirst √Ü n œÉ' ).
Countable Choice
Definition cc : & := cŒª 0 (ecode ((¬∑) memo)).
Theorem countable choice (o : O) : JO o ‚Üí ‚ñ∂ (T 1) (countable choice o).
End MemoizingCC.
