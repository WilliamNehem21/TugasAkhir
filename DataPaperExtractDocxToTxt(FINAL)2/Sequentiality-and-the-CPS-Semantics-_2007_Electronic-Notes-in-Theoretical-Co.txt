

Electronic Notes in Theoretical Computer Science 173 (2007) 203–219
www.elsevier.com/locate/entcs

Sequentiality and the CPS Semantics of Fresh Names
J. Laird1 ,2
Dept. of Informatics University of Sussex UK

Abstract
We investigate the domain-theoretic denotational semantics of a CPS calculus with fresh name declaration. This is the target of a fully abstract CPS translation from the nu-calculus with first-class continuations. We describe a notion of “FM-categorical” model for our calculus, with a simple interpretation of name generation due to Shinwell and Pitts. We show that full abstraction fails (at order two) in the simplest instance of such a model (FM-cpos) because of the presence of parallel elements. Accordingly, we define a sequential model — FM-biorders, based on “bistable FM-bicpos” and bistable functions — and prove that it is fully abstract up to order four (our main result), but that full abstraction fails at order five.
Keywords: Continuation-passing style, Fresh names, Sequentiality, FM-sets, Full Abstraction.


Introduction
This paper is a study of the denotational semantics of freshly generated names in a continuation-passing style (CPS) setting. Freshly generated names are a key ele- ment of many computational effects, and are also intrinsically interesting; they may be used to represent secrets such as cryptographic keys, for example. The behaviour of names in a functional setting is rather subtle, and has been studied, via proto- typical calculi such as the nu-calculus [7], using both operational and denotational techniques.
An approach to the denotational semantics of naming which has been advocated by Pitts and others is via Fraenckel-Mostowski (FM) set-theory. In essence, a FM- set is an action of the group of permutations of a countable set of atoms (representing names) in which each element of the carrier set depends on only finitely many atoms (its support ): if we interpret terms as elements of the carrier set then the

1 Supported by UK EPSRC grant GR/S72181
2 Email: jiml@sussex.ac.uk



1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.035

group action corresponds to substitution of one name for another. So, for example, we may interpret the type of names as the FM-set (or flat FM-cpo) N of natural numbers with the canonical permutation group action. Shinwell and Pitts [6] have observed that there is a simple and natural continuation-passing-style interpretation of name generation in such a setting: if we take the CPS “answer-object” to be the two-point set (or order) Σ = {T, ⊥} then new-name generation should correspond
to a function from ΣN into Σ. Any element of ΣN — a function from N into Σ
— must take the same value on every argument which is not in its support, so the result of supplying a new name to f must be that value.
The limitation of this approach, when confined to the FM-cpo model may be seen when we consider the questions of universality (what “junk” does it contain?) and full abstraction (which equivalences does it reflect accurately?). The presence of parallel elements in the model, but not the language, means that full abstraction will fail as for PCF, moreover some of the simplest equivalences between terms which create and generate new names are broken. In particular, we have a function
p : ΣN → Σ such that p(f ) = T if there exists n such that f (n) = T, effectively allowing the names recognized by f to be “guessed”.
The main goal of this paper is to investigate a sequential CPS model of naming, obtained by working in a category of bistable “FM-bicpos”. These are obtained simply by extending FM-cpos with additional structure such that functions which preserve that structure (bistable functions) are strongly sequential. Bistable Bicpos were introduced in [2,4], where they were shown to give a fully abstract model of a functional language with control operators (SPCF). Here we shall give the semantics of a CPS target language with a name generating operation. There is a fully abstract translation into this calculus from (for example) the nu-calculus extended with first-class continuations.
It is straightforward to show that our calculus may be soundly interpreted in any “FM-category” with finite products and Σ-exponentials, and satisfying some simple axioms. We then study the completeness properties of the bistable bicpo interpretation, showing that full abstraction holds for terms up to fourth order (i.e.
terms with types containing up to four nestings of the continuation ч-operator). However, full abstraction fails at fifth order, showing that even in this extensional setting, sequentiality is not sufficient to obtain full abstraction.

Related Work
Several models for functional languages with freshly generated names have been proposed, including (equivalent) functor category and FM-set models for the nu- calculus described by Stark in [7], the FM-cpo CPS models of mini-FreshML [6], and games models [3] and [1], also based on nominal sets. Both extensional and intensional models give limited information about equivalence in a functional set- ting with fresh names, in the extensional cases, because full abstraction fails at low-level types, in the more intensional (games) models because full abstraction depends either on a quotient, or on allowing names to be leaked through the store. Although our semantics is not fully abstract, it does capture a substantial frag-

Γ▶v:Bv ∈ {tt , ff }	Γ▶n:N n ∈ N	Γ▶C:Σ C ∈ {T, ⊥}


Γ▶s:N	Γ▶t:N
Γ▶s=t:B
Γ▶s:B	Γ▶t:B
Γ▶bop(s,t):B





Γ,x:T ▶T
Γ▶s:чP	Γ▶t:P s t:Σ





Γ▶new:ччN
Γ▶r:B	Γ▶s:Σ	Γ▶t:Σ
If r then s else t:Σ

Γ▶si:Ti : i<n

Γ▶⟨si | i<n⟩:Πi<nTi
 Γ,x0:T1,...,xn−1:Tn−1▶s:Σ 
Γ▶λ(x0,...,xn−1).s:чΠi<nTi



Table 1
Term-Formation for the CPS-nu Calculus

ment of functional naming without requiring additional powerful techniques such as logical relations.

A CPS calculus with name-generation
The CPS-nu-calculus is in essence a simply-typed λ-calculus in which terms take either a basic “answer-type” Σ, a value type — B (boolean) and N (names) and continuations — or a product of value types. The value and product types are given by the following grammar:
T ::= B | N | чP	P ::= Πi<nTi
Value types are included in the product types as unary products; we write U for the empty product (unit type) and define (Πi<mSi) × (Πi<mTi) to be Πi<m+nRi, where Ri = Si for i < m and Ri = Ti+m for i > m. The order of a type is its continuation- nesting depth — so N, B have order 0, Πi<nTi has order max{o(Ti) | i ≤ n} and чP has order o(P )+ 1.
Terms are formed over contexts of variables of value type by λ-abstraction and
application, together with: constants T (error) and ⊥ (divergence) at return type, a set of names (constants) {n | n ∈ N}, a conditional, a new-name generator new : ччN and boolean expresions formed from tt , ff and equality testing on names. We write νx.s for new λx.s. The term-formation/typing rules are given in Table 1.

Operational Semantics
The operational semantics (Table 2) is given by a termination predicate, ⇓, on pairs s, k of a term s of return type and a value k such that every name occurring in s is less than k. Note that a closed term s : B is simply a formula of propositional logic







T,k⇓
s ⟨k⟩,k+1⇓
new ⟨s⟩,k⇓
	s[→t/→x],k⇓	
(λ(→x).s) ⟨→t⟩,k⇓



	s,k⇓	
If r then s else t,k⇓ |r| = tt
	t,k⇓	
If r then s else t,k⇓ |r| = ff


Table 2
Operational Semantics of the CPS-nu-calculus


over a set of atoms consisting of equality statements n = m for natural numbers n, m, and thus has a standard interpretation as a boolean value |s|. We write s ⇓ if there exists k such that s, k ⇓ and define standard notions of observational approximation — s  t if for any compatible context C[ ] of return type, C[s] ⇓ implies C[t] ⇓ — and equivalence — s ≈ t if s  t and t  s.
Lemma 2.1 (Context Lemma) For any terms s, t : чP, s  t if and only if for all terms L : P, M L ⇓ implies N L ⇓.
Proof. Follows the standard proof for e.g. PCF [5].	 
Lemma 2.2 If s, t are terms without explicit names then s  t if for any name-free compatible context C[ ], C[s] ⇓ implies C[t] ⇓.
Proof. Given name-free terms which are distinguished by a context C[ ], we may obtain a distinguishing context by replacing all explicit names in C[ ] by variables and declaring them with new.	 

As in the nu-calculus there are some useful examples of equivalences in our calculus which capture aspects of name generation in the calculus, and can be used to test any candidate models. These are related to nu-calculus equivalences considered by Stark [7], although they are not CPS translates of the latter. The two key instances of such equivalences are:
At the type чччN : λκ.νn.κ λy.If x = n then T else⊥  λy.⊥.
At the type чччч(N × чU ):
λk.νn.k ⟨λf.νm.f ⟨m, λa.f ⟨n, ⊥⟩⟩⟩   λk.k ⟨λf.νm.f ⟨m, ⊥⟩⟩
Informally, (1) holds because any argument of type ччN supplied must apply its argment to a name which is not equal to n. (2) holds because any argument supplied cannot “recognize” n and therefore cannot apply λf.ν m.f ⟨m, λa.f ⟨n, ⊥⟩⟩ to an argument which can distinguish n from the fresh name m. We will prove both equivalences formally, using semantic means.

s = t = λκ.s ⟨λa.t ⟨λb.κ ⟨a = b⟩⟩⟩	v = λκ.κ ⟨v⟩	v ∈ {tt , ff }
λx.s = λκ.κ ⟨λ(x, z).s ⟨z⟩⟩	st = λκ.s λ(a).t λb.a ⟨b, κ⟩
If s then t1 else t2 = λκ.s ⟨λa.If a then t1 ⟨κ⟩ else t2 ⟨κ⟩⟩	x = λκ.κ ⟨x⟩.

call/cc s = λκ.s ⟨λa.a ⟨λ(b, c).κ ⟨b⟩, κ⟩	new = new
Table 3
CPS Translation of the control nu-calculus

CPS Translation
We may use the CPS-nu-calculus to interpret languages such as the nu-calculus by CPS translation. Here we shall give such a (fully abstract) translation for the nu-calculus extended with first-class continuations. Our source calculus is a simply- typed, call-by-value λ-calculus over the base types ν, o (names and booleans), with constants: tt : o and ff : o, equality testing of names, a conditional, new-name generation new : ν and call-with-current-continuation call/cc : ((T ⇒ S) ⇒ T ) ⇒
T .
We may interpret this by a standard CPS translation ( ) into the CPS-nu- calculus, sending each base type to the corresponding value type and S ⇒ T to ч(S × чT ). The translation taking terms-in-context x1 : S1,... , xn : Sn ▶ M : T to x1 : S1,... , xn : Sn ▶ M : ч(чT ) is given in Table 3. For closed terms s : o, we may write s ⇓ tt if s ⟨λb.If b then T else ⊥⟩, 0 ⇓ — it is straightforward to show that this agrees with the standard operational semantics for terms of the nu-calculus. Thus we may derive a notion of observational equivalence for terms of the control nu-calculus, with respect to which CPS translation is sound by definition; it is also complete and thus fully abstract (Corollary 3.7).

CPS Semantics of Naming
The CPS interpetation of name generation introduced by Shinwell and Pitts [6] was sketched in the introduction. Here, we give a more formal and general account of the semantics of our CPS calculus in any “FM-enriched” category with the requisite structure.
For a countable set of “atoms” X, let G be the topological group of automor- phisms on X, with the product topology. An action of G on a set A is continuous (with respect to the discrete topology on A) if and only if for every element a ∈ A, there is a finite subset k ⊆ X such that π(x)= x for all x ∈ k implies π · a = a. Let ν(a), the support of a, be the least such subset. A FM-set (A, ·) is a set A with a continuous G-action on it, a FM-order is a FM-set (A, ·) with a partial order on A such that x ≤ y iff π · x ≤ π · y. A FM-order D is a FM-cpo if every directed set X with bounded support (i.e. such that {ν(x) | x ∈ X} is finite) has a least upper bound.
A FM-category is a category C enriched with a continuous G-action — i.e. every hom-set is a FM-set — such that (π ·f ); (π ·g)= π ·(f ; g) and π ·id = id. A morphism

f is invariant if ν(f )= ∅. The basic example of a FM-category is that of FM-sets (i.e. objects are FM-sets, morphisms from A to B are functions f : A → B with π · f defined (π · f )(a)= π · (f (π−1 · a)). Similarly, we have FM-categories of FM- orders and monotone functions and FM-cpos and continuous functions. Note that all of these categories are Cartesian closed. We may also construct FM-categories of games and strategies [3,1].
Henceforth we shall take the set X of atoms to be N. Let C be a FM-category with finite products. We shall say that C has boolean, naming and Σ-objects if it contains objects B, N, Σ such that:
B is a disjoint coproduct of the terminal object with itself.

	
C(1,N ) consists of distinct maps {i | i ∈ N} such that π · i = π(i), and there is a “decidable equality” morphism eq : N × N → B such that ⟨n, m⟩; eq = inl(∗) if and only if n = m.
C(1, Σ) consists of distinct, invariant maps {⊥, T} such that f : N → Σ = g :
N → Σ if and only if n; f = n; g for all n.
In the category of FM-sets, B and Σ are just two-point sets and N is the set of natural numbers with canonical G-action. In the category of FM-cpos, B and N have the discrete order and ⊥ ± T in Σ. The interpretation of the new-name
generation constant new, is derived from the following observation.
Lemma 3.1 Given f : N → Σ and m, n : 1 → N, m; f = n; f if and only if
m ∈ ν(f ) ⇐⇒ n ∈ ν(f ).
Proof. Suppose without loss of generality that m; f = T for some m /∈ ν(f ). Let [m ↔ n] ∈ G be the automorphism which swaps m and n and leaves all other points alone. If n /∈ ν(f ) then [m ↔ n] is in the stabilizer of f so m; f = ([n ↔ m] · n); f = n; ([n ↔ m] · f )= n; f = T. Hence {l | l; f = ⊥} ⊆ ν(f ).
Given π ∈ G, suppose π · n = n for all n such that n; f = ⊥. Then for any n, if n; f = ⊥ then n; (π · f )= (π−1 · n); f = n; f = ⊥ and if n; (π · f )= (π−1 · n); f = ⊥ then π(π−1(n)) = n = π(n) and so n; f = ⊥. Thus π is in the stabilizer of f and so ν(f ) ⊆ {n | n; f = ⊥} and m; f = n; f if and only if m ∈ ν(f ) iff n ∈ ν(f ) as required.	 
Definition 3.2 Suppose C is an FM-category with Σ-exponentials — i.e. a Σ- object, and for any object A, an exponential ΣA of Σ by A. (So each morphism f : N → Σ has a “name”  f ’ : 1 → ΣA.) Let ϵ be a choice function on P(N). A morphism new : ΣN → Σ in C is a name generator if for any f : N → Σ,
 f ’; new = ϵ(ν(f )c); f .
By Lemma 3.1, f ’; new = n; f if and only if n /∈ ν(f ). Since each f :1 → ΣN has finite support, {x | f (x) = T} is thus either finite or co-finite, and we have new; f ’ = T if and only if {n | n; f = ⊥} is finite. Thus in the category of FM- sets we may define a name generator: new(f ) = T if and only if {n | n; f = ⊥} is finite. This is also a well-defined morphism in the categories of FM-orders and FM-cpos: to show that it is bounded continuous: suppose F ⊆ ΣN is directed and

has bounded support, and suppose new(f )= ⊥ for all f ∈ F . Then (. F )(x)= T iff there exists f ∈ F such that f (x)= T iff there exists f ∈ F such that x ∈ ν(f ). Hence by boundedness of the support of F , (. F )(x)= T for finitely many x and
so new(. F )= ⊥ as required.
Given a FM-category with boolean and naming objects, finite products and Σ-exponentials, a name-generator and decidable equality, let [B]] = B, [[N ]] = N , [[чT ]] = Σ[[T ]] and [[Πi<nTi]] = Πi<n[[Pi ]. The categorical structure yields direct inter- pretations of the operations and constants, and a straightforward proof of soundness
with respect to the operational semantics. We establish the following by a simple structural induction.
Lemma 3.3 If n ∈ ν([[s]]) then n occurs in s.
Proposition 3.4 (Soundness) For any closed term, if s, k ↓ then [[s]] = T.
Proof. By induction on derivation. For the new rule, suppose s ⟨k⟩,k +1 ↓ and so
⟨[[s]], k⟩; app = T by induction hypothesis. By assumption, k does not occur in s, and so k /∈ ν([[s ]) by Lemma 3.3, and so [new s]] = [[s]]; new = ⟨[[s]], k⟩; app = T as required.	 
Proposition 3.5 (Adequacy) If [[s]] = T then s ↓.
Proof. By a standard computability predicate argument.	 
Thus any FM-categorical model of the calculus is equationally sound — [s]] = [[t]] implies s ≈ t — and any FM-order-enriched model (with ⊥ ≤ T) is inequationally sound — [s]] ± [[t ] implies s  t. As a first application of our semantics, we may use it to prove that the CPS translation of the control nu-calculus is fully abstract.

Proposition 3.6 For every name-free term s : T of the CPS-nu-calculus there exists a term s^ : T of the control nu-calculus (extended with constants T, ⊥ : o) such that [[s^]] = [[s]].
Proof. We prove by induction on length that for any β-normal term x1 :
T1,... , xm  :  Tm, y1  :  чS1,... , yn  : чSm  ▶  s  :  Σ there is a term x1  :
T1,... , xm : Tm, y1 : S1 → B,... , yn : Sn → B ▶ s^ : B such that [s^]](⊥) =
[[s[λ(a).z1 ⟨a, λb.⊥⟩/y1] ... [λ(a).z1 ⟨a, λb.⊥⟩/y1]]], and for any β-normal term of
value type x1 : T1,... , xm : Tm, y1 : чS1,... , yn : чSm ▶ s : R there is a

term x1 : T1,... , xm : Tm, y1 : S1 → B,... , yn : Sn → B ▶
[[s^]] = [[λ κ.κ ⟨s[λ(a).z1 ⟨a, λb.⊥⟩/y1] ... [λ(a).z1 ⟨a, λb.⊥⟩/y1]⟩]].
For example:
s^ : R such that


		
Suppose s = x ⟨t1, λa.t2⟩, where x : S → T = ч(S ×чT ). Then s^ = (λa.t^2) (xi t^1).
Suppose s = y ⟨t⟩, where y : чS. Then s^ = y t.
Suppose s = λ(x, y).t : S → T = ч(S ×чT ). Then s^ = λx.call/cc λy.((λk.^t) ⊥).
 

Corollary 3.7 CPS translation from the control nu-calculus into CPS-nu-calculus is fully abstract.

Proof. Given closed terms s, t : T of the control nu-calculus, suppose s /≈ t. Then there exists a term λk.r : чT such that s λk.r ↓ and t λk.r ↓. Let v : T → o = λk.call/cc λf.r[f tt /T, (f ff )/⊥] Then [[If vs thenT else ⊥]] = [[s λk.r]] = T and [[If vt thenT else ⊥]] = [[s λk.r]] = ⊥ and so vs ↓ tt and vt /↓ tt as required. 
Having defined an (in)equationally sound semantics for the CPS-nu-calculus in a general class of models, we may ask: for which types are our models complete with respect to observational equivalence? If we consider the model consisting of FM-cpos and bounded continuous functions, then completeness must fail for the fragment of the calculus over just the boolean and continuation types, since the model contains parallel elements. However, the non-sequential character of the model also means that it fails to accurately reflect equivalences specifically related to name generating behaviour. For instance, the only contextual equivalence classes of closed terms of
the language at the type ччN are new, λκ.T, λκ.⊥, and λκ.κ n for each name n. However, in the FM-cpo model, there are many more functions from ΣN into Σ —
e.g. p defined by p(f )= T if there exists n such that f (n)= T. This is sufficient to break equivalence (1) between F = λκ.ν n.κ λx.If (x = n) thenT else ⊥ and λx.⊥
— F (p) = ν n.p(λx.If (x = n) thenT else ⊥) = νn.T = T and ⊥(p) = ⊥. The key to defining a model which reflects naming more accurately would therefore seem to
be to capture the sequential nature of the calculus fully, and this is what we aim to achieve, using bistable biorders, in the remainder of the paper.

FM-biorders
Amongst possible equivalent definitions of bistable biorder, we give the following:
Definition 4.1 A (bistable) biorder [2,4] is a tuple (D, ±, ‡), where (D, ±) is a partial order (the extensional order), and ‡ is an equivalence relation (bistable co- herence) on D such that each ‡-equivalence class is a distributive lattice with respect to ±, and inclusion into D preserves binary meets and joins.
Definition 4.2 A FM-biorder is a tuple (D, ±, ‡, ·) where (D, ±, ‡) is a bistable biorder, (D, ±, ·) is a FM-order and for every d, e ∈ D, d ‡ e implies π · d ‡ π · e.
D is a FM-bicpo if (D, ±, ·) is a FM-cpo and if X, Y ⊆ D are directed sets with bounded support such that X ‡ Y (i.e. for all x ∈ X and y ∈ Y there exists x' ∈ X, y' ∈ Y such that x ± x',y ± y' and x' ‡ y') then .{x Λ y | x ∈ X Λ y ∈
Y Λ x ‡ y} = . X Λ . Y .
We define a FM-category JУ in which objects are FM-bicpos and morphisms from A to B are bounded-continuous functions f : |A| → |B| which are bistable: for each x, f T [x]‡ is a lattice homomorphism into [f (x)]‡ — i.e. for all x, y ∈ |D| such that x †↓ y, f (x) ‡ f (y), f (x Λ y)= f (x) Λ f (y) and f (x V y)= f (x) V f (y). A function into a biorder with T and ⊥ elements is strict if f (T)= T and f (⊥)= ⊥.

Cartesian closure is obtained by combining the relevant definitions from the CCCs of bistable bicpos and FM-cpos.
Proposition 4.3 JУ is bi-Cartesian closed.
Proof. The product and co-product operations on bistable orders are defined di- rectly (pointwise) from the operations on the underlying sets with units 1 and 0 being the one-point and empty biorders. Given FM-bicpos D, E, we define the
exponential D ⇒ E to be the set of and bistable functions from D to E, ordered extensionally, with f ‡ g if x ‡ y implies f (y) †↓ g(x) and f (x) Λ g(y)= f (y) Λ g(x) and f (x) V g(y)= f (y) V g(x). The requisite meets and joins are defined pointwise
— see [4] for the proof that this is a bicpo.	 
JУ has boolean, naming and Σ-objects, and a name generator — the function new(f )= f (ϵ(ν(f )c) is bistable since for all f, g, we have new(f Λ g)= (f Λ g)(ϵ(N — (ν(f ) ∪ ν(g)))) = f (ϵ(N — (ν(f ) ∪ ν(g)))) Λ g(ϵ(N — (ν(f ) ∪ ν(g)))) = new(f ) Λ new(g) and similarly new(f V g)= new(f ) V new(g).
We may first observe that our model is bisequential (i.e. sequential with respect to both ⊥ and T elements). For example, it excludes parallel composition par : Σ × Σ → Σ since ⊥ = par(⊥, ⊥) /= par(T, ⊥) Λ par(⊥, T) = T Λ T = T. More generally, the following was proved in [2]:
Lemma 4.4 Given pointed bistable biorders A1,... , An, every strict, monotone and bistable function f : A1 × ... × An → Σ is i-strict (i.e.πi(x)= ⊥ implies f (x)= ⊥ and πi(x)= T implies f (x)= T) for some i ≤ n(unique if the Ai are non-terminal).
As an example of the force of bistability with respect to naming, we observe that unlike the FM-cpo model there is no “junk” at type ччN . First, define pn ∈ N ⇒ Σ= λx.If x = n then T else ⊥, and qn ∈ N ⇒ Σ= λx.If x = n then ⊥ else T
Proposition 4.5 The only elements of (N ⇒ Σ) ⇒ Σ are T, ⊥, {λk.k n | n ∈ N}
and new.
Proof. Suppose f : (N ⇒ Σ) ⇒ Σ is not in {T, ⊥, new}. Then there exists some
g : N ⇒ Σ such that f (g) /= g(ν(g)c). Suppose f (g)= T, so g(n)= T if and only if
n ∈ ν(g). Then g =	pn and so by bistability, f (pn)= T for some n. Since
f /= T, we have f (pn) Λ f (qn)= f (pn Λ qn)= f (⊥)= ⊥ — i.e. f (qn)= ⊥. Hence
f (g)= T if and only if pn ± g — i.e. f = λg.g(n).	 
Hence the model validates equivalence (1).
Corollary 4.6 [[λk.νn.k ⟨λx.If x = n then T else ⊥⟩]] = [[λk.k ⟨λx.⊥⟩]].
Proof. [[λk.νn.k ⟨λx.If x = n then T else ⊥⟩]](f ) = f (⊥) for f ∈ {T, ⊥, new} ∪ 
{λk.k n | n ∈ N}.	 
Full Abstraction to Third Order
In the remainder of the paper we shall consider the completeness properties of our model. Because it is extensional and bounded-continuous, we may prove full

abstraction to order n + 1 by proving that all elements, or a finite basis of elements, are definable at order n.
A key idea that we shall use is the notion of definable retraction between types
— we write σ Œ τ if there are terms x : σ ▶ inj : τ and x : τ ▶ proj : σ such that [[inj]]; [[proj ] is the identity. In this case, if universality holds at type τ then it holds at type σ — if [[inj]](e) is definable as M : τ then e ∈ [[σ ] is definable as proj[M/x]. Definable retractions are used to show universality of the name-free fragment of the language as in [4].
Proposition 5.1 Universality holds at every name-free type.
Proof. We show that every name-free type is a retract of (ччBk)l for some k, l. 
We also have a definable retraction B Œ N , via the terms x ▶ x = 0 and
y ▶ If y then 0 else 1.
Lemma 5.2 For any k, l, чNk × чNl Œ чN max{k,l}+1
Proof. We have чNk × чNl Œ (чN max{k,l})2 ~= ч(B × N max{k,l}) Œ ч(N ×
N max{k,l})= чN max{k,l}+1.	 
By repeated application of this lemma we obtain the following:
Lemma 5.3 For any second-order σ there exist k, l such that σ Œ ч(чNk × Nl).
Lemma 5.4 If universality holds at чT then universality holds at ч(N × T ).
Proof. Given f ∈ ч(N × T ), suppose m /∈ ν(f )= i1,... , in. Let Mf = λ(x, →y).
If x = i1 then Mλe.f (i1,e) ⟨→y⟩ ... If x = in then Mλe.f (in,e) ⟨→y⟩ else Mλe.f (m,e)[x/m] ⟨→y⟩.
Then if j ∈ ν(f ), [M ]](j, e) = [Mf(j)]](e)= f (j, e), and if j /∈ ν(f ), [M ]](j, e) = 
[[Mf (m)[j/m]]](e) = [m — j]([[Mf (m) ]](e)) = [m — j](f (m, e)) = f (j, e) as re- quired.	 
Corollary 5.5 Universality holds at чNk for any k.
Note that g ‡ h for every g, h ∈ Nk ⇒ Σ and so Nk ⇒ Σ is a lattice. Moreover, it is a boolean algebra: every element g ∈ Nk ⇒ Σ has a complement g⊥ (defined g⊥(i)= ⊥ iff g(i)= T) such that g Λ g⊥ = ⊥ and g V g⊥ = T. Note that every strict map f : (N k ⇒ Σ) → Σ is a boolean homomorphism: if f (g)= ⊥ then f (g⊥)= T, and vice-versa, since f (g) V f (g⊥)= f (g V g⊥)= f (T)= T.
Definition 5.6 An element p ∈ Nk ⇒ Σ isa quasi-atom if it is a true atom — i.e. p ± g V h implies p ± g or p ± h — or an ‘invariant atom” — i.e. p is invariant and for any invariants g, h, p ± g V h implies p ± g or p ± h. A literal is an element e such that e or e⊥ is a quasi-atom.
Given i < k and n ∈ N, let pn(i): Nk ⇒ Σ= λ(→x).If xi = n then T else ⊥. Given
i, j < k, let p(i, j): Nk ⇒ Σ= λ(→x).If xi = xj then T else ⊥.
It is straightforward to see that p is a true atom iff p = ⊥ or p = pn(i) for some i, n, and p is an invariant atom iff p = ⊥ or p = p(i, j) for some i, j. We have the following “literal completeness” property for Nk ⇒ Σ

Lemma 5.7 For any element g ∈ Nk ⇒ Σ there exists a ﬁnite family of ﬁnite

families of literals {{hij | j ∈ Ji}| i ∈ I} such that g = 

i∈I

j∈Ji
hij.

Proof. By Corollary 5.5 it suffices to show that for any (β-normal) term λ(→x).t : Nk ⇒ Σ, [t ] has a disjunctive normal form as claimed. Supposing t /∈ {T, ⊥}. Then t = If B thens1 else s2 for some s1, s2, and [t]] = ([[If B then T else ⊥]] Λ [[s1]]) V ([[If B then ⊥ else T]] Λ [[s2 ]). Since B has a disjunctive normal form, so do [[If B then T else ⊥]] and [[If B then ⊥ else T ], and thus applying the inductive hypoth-
esis and distributivity laws we are done.	 

Hence to show that f : (N k ⇒ Σ) → Σ= g, it suffices to show that f (p)= g(p) for all quasi-atoms p.
Lemma 5.8 Every invariant element f ∈ (Nk ⇒ Σ) ⇒ Σ is deﬁnable.
Proof. If f ∈ {T, ⊥} then it is definable, so assume that f is strict.	Define
m : {1,... k} → {1,... k} by m(i) = min{j  ≤ k | f (p(i, j)) = T}, and let
Mf = λg.νx1 ... νxk.g xm(1) ... xm(k). Then [Mf ]] = f : for any atom pn(i), we
have f (pn(i)) = [Mf ]](pn(i)) = ⊥ since for m /= n, f (pm(i)) = [m — n]f (pn(i)) =
f (pn(i)) and so f (pn(i)) = f (pn(i)) Λ f (pm(i)) = f (pn(i) Λ pm(i)) = f (⊥)= ⊥.
For an atom p(i, j), if f (p(i, j)) = T then m(i) = m(j) and so [Mf ]](p(i, j)) = new([[λx.If x = x then T else ⊥]]) = T. If f (p(i, j)) = ⊥ then m(i) /= m(j) and so [[Mf ]](p(i, j)) = [νx.νy.If x = y then T else ⊥]] = ⊥.

Lemma 5.9 Universality holds at ччNk for all k.
Proof. By induction on k. If f ∈ (Nk+1 ⇒ Σ) ⇒ Σ is invariant then it is definable by Lemma 5.8. So suppose f is not invariant. Then there exists g ∈ Nk+1 ⇒ Σ, and π ∈ G such that f (g) = T and f (π · g) = ⊥, and since the meet, join and complement operations are π-invariant, we may assume by Lemma 5.7 that g is atomic — i.e. g = pn(i) for some n ∈ N and i ≤ k + 1.
Let fi : (Nk ⇒ Σ) ⇒ Σ be defined fi (g) = f (λ→x.g x1 ... xi−1nxi ... xk).
Then we claim that for any h : Nk+1 ⇒ Σ, f (h) = fi (λ→x.h(x1 ... xi−1nxi ... xk). Suppose f (h) = T, then T = f (pn(i) Λ h) = f (λ→x.If xi = n then h(→x) else ⊥) ± f (λ→x.h(x1 ... xi−1nxi ... xk)). Similarly, if f (h) = ⊥, then ⊥ = f (pn(i)⊥ V h) ± f (λ→x.h(x1 ... xi−1nxi ... xk)).

By hypothesis, fi
is definable as a term M n
i
and so f is definable as

λg.Mfi (λ→x.g x1 ... xi−1nxi ... xk).	 
Proposition 5.10 Universality holds at all second-order types.
Proof. By Lemma 5.3 it suffices to show this for types of the form ч(Nk × чNl). But this follows by induction on k for which the base case is Lemma 5.9 and the induction case is Lemma 5.4.	 

Full Abstraction to Fourth Order
We shall now show sketch the proof of full abstraction up to fourth order. Uni- versality does not hold at third order — consider the least upper bound of the chain of approximants gi ∈ [[ч(N × ч(N × чN ))]] given by g0 = λ(x, f ).⊥, gi+1 = λ(x, f ).f ⟨x, λy.gi ⟨y, f ⟩⟩: this is definable only if we include recursion in the language. However, we may show that every element at third-order type is the limit of a (finitely supported) chain of definable approximants, and thus prove full
abstraction up to fourth order. We establish definability of finite chains of approx- imants for types of the form чч(Nk × чNl) and extend it to all third-order types using definable retractions and Lemma 5.4. A (non-constant) function f of this type first tests its argument with a k-tuple of new and explicit names and receives
a l-tuple of new and explicit names in return, from which it can construct a second k-tuple of names, and so on. Thus to construct a defining chain of approximating terms for f we successively extract representations of these k and l-tuples, whilst keeping track of introduced names.
By our results in the previous section, we may think of a strict function f ∈ (Nk ⇒ Σ) ⇒ Σ as representing a “generalised” k-tuple of names, each of which may be either concrete — i.e. f (pn(i)) = T if the ith name is n — or fresh names, which can be tested for equality with one another. So given a set of “known names” S, f ∈ (Nk ⇒ Σ) ⇒ Σ and a k-tuple of names →a ∈ Nk, we may define a corresponding test “equivalence up to S” which holds essentially when f cannot be distinguished from λκ.κ →a by an observer who only knows the names in S.
Define the predicate EqS (f,→a) to hold iff for all i ≤ k:
(i) f pn(i)= T implies ai = n
(ii) if f pn(i)= ⊥ for all n then ai /∈ S
(iii) for all j ≤ k, f p(i, j)= T if and only if ai = aj
Lemma 6.1 If ν(d) ⊆ S and EqS (f,→a) then f d = d →a.
Proof. It is sufficient to prove this for quasi-atomic d. If d = pn(i) then f (d)= T implies ai = n and hence d(→a) = T by definition (i). If f (d) = ⊥, then either f (pm(i)) = T for some m /= n — in which case ai = m and so d(→a)= ⊥ — or else f (pm(i)) = ⊥ for all m ∈ N, and so by (ii), ai /∈ S thus ai /∈ ν(d) and so ai /= n and d(→a)= ⊥ as required. If d = p(x, y) then f (d)= d(→a) by definition (iii).	 
Say that an element e ∈ (Nk × (Nl ⇒ Σ)) ⇒ Σ is parametric if e /∈ {T, ⊥} and for each prime pn(i) either e⟨→a, d⟩ = e(π · →a)pn(i) for all →a ∈ Nk and π ∈ G, or e(→a)pn(i) = e(π · →a)pπ(n)(i) for all →a ∈ Nk and π ∈ G. Thus a parametric element represents a generalised l-tuple of names each of which is either a concrete name, a new name, or some one of the ai.
Given f ∈ ((N k × (Nl ⇒ Σ)) ⇒ Σ) ⇒ Σ and e ∈ (Nk × (Nl ⇒ Σ)) ⇒ Σ, we now define a series of tuples of names passed between f and e, and thus a series of approximants to the “revealed fragment” of e.
Given boolean values b1,... , bk, and names n1,... , nk+1, let case [b1  '→

n1,... , bk '→ nk, nk+1] = ni, where i is the least value such that bi = tt , or
case [b1 '→ n1,... bk '→ nk, nk+1]= nk+1 if each bi = ff .
For each i ∈ ω we define:
a set of “revealed names” Ui (e) ⊆ N consisting of all of the names known to f
together with all names revealed by e so far during interaction.
a generalised k-tuple of names supplied by f at the ith step of interaction; Φi (e): 
(Nk ⇒ Σ) ⇒ Σ
a (parametrised) generalised l-tuple of names returned by e, Ψi (e): (N k ×(Nl ⇒
Σ)) ⇒ Σ.
a “reconstruction” Γi (e, d, S) : (((N k × (Nl ⇒ Σ)) ⇒ Σ) of e with respect to a set of names S, which tests its input for equality (up to S) with the tuples already supplied by f , and returns the corresponding l-tuple observed to have been supplied by e, and otherwise behaves as d.
These are defined:
U 0(e)= ν(f ) and Γ0 (e, d, S)= d
f	f
Φi+1(e)= λh.f (Γi (e, (λ(a, b).h(a)),U i (e))).
f	f	f
Ψi+1(e)= λ(→x, y).Φf	(e) λ→z.e ⟨→z, λw→ .y ⟨t1 ... tl⟩⟩, where tj = case [(z1 = wj Λ wj /∈
f	i+1
S '→ x1),... (zk = wj Λ wj /∈ S '→ xk), wj].
Ui+1(e)= Ui (e) ∪ ν(Γi+1(e, Ui (e))
f	f	f	f
Γi+1(e, d, S)= λ(→x, h).If EqS (Φi (e, S), →x) then Ψi (e)⟨→x, h⟩ else Γi (e, d, S)⟨→x, h⟩.
f	f	f	f
We now prove the following facts using Lemma 6.1.
Lemma 6.2 If ν(e) ∪ ν(f ) ⊆ S, then the following hold for all i ∈ ω:
If EqS (Φi+1(e), a1,... ak) then Ψi+1(e)⟨→a, q⟩ = e ⟨→a, q⟩.
f	f
If Γi (e, ⊥, S) ± e ± Γi (e, T, S).
f	f
Φn+1(e) /∈ {T, ⊥} implies Φi (e) /= Φn+1(e).
f	f	f
For each n, either Ψn+1(e) ∈ {T, ⊥} or Γn(e, ⊥, S) и Γn+1(e, ⊥, S).
f	f	f
Lemma 6.3 Given an inﬁnite chain with bounded support e1 ± e2 ± ... ∈ (Nk ×
(Nl ⇒ Σ)) ⇒ Σ there exists m such that em = en for all n ≥ m.
Proof. By induction on k. For the base case, we note that if e ± e' ∈ (Nl ⇒ Σ) ⇒ Σ then either e = ⊥ or e = e' or e' = T. For the induction case, suppose we have a chain e1 ± e2 ± ... ∈ N ⇒ (Nk ⇒ (Nl ⇒ Σ) ⇒ Σ), with bounded support S. Then for each i ∈ S there exists mi with emi (i)= en(i) for all n ≥ mi. Also, there exists m' such that for all j /∈ S, we have em' (j)= en(j) for all n ≥ m'. So we may take m = max({m'}∪ {mi | i ∈ S}).	 
Proposition 6.4 For all f, e, there exists n such that Φn(e) ∈ {T, ⊥}.
Proof. Let S = ν(f )∪ν(e). Then if Φn(e) /∈ {T, ⊥} for all n, we have Γn(e, ⊥, S) и
f	f
Γn+1(e, ⊥, S) for all n — i.e. Γn(e, ⊥, S)(⊥) forms an infinite, strictly increasing
f	f

chain with support bounded by S, contradicting Lemma 6.3.	 
For any element e ∈ (Nk × (Nl ⇒ Σ)) ⇒ Σ, and d ∈ {T, ⊥}, let e[d]i ∈ Nk ⇒
(Nl ⇒ Σ) ⇒ Σ be λ(→x, g).If xi = n then d else e ⟨→x, g⟩.
Lemma 6.5 If n /∈ ν(f ) ∪ ν(e) then f (e[⊥]i )= f (e[T]i )= f (e) for each i.
n	n
Proof. Suppose f (e) = T.	Choose m such that m /∈ ν(f ) ∪ ν(e).	Then
f (e[T]i [T]i )= T, and since e[T]i [⊥]i ‡ e[T]i [⊥]i and e[T]i [⊥]i V e[T]i [⊥]i =
n	m	n	m	m	n	n	m	m	n
e[T]i [T]i , by bistability we have f (e[T]i [⊥]i ) = T or f (e[T]i [⊥]i ) = T.
n	m	n	m	m	n

But we also have f (e[T]i [⊥]i ) = f ([n — m] · e[T]i [⊥]i
) = [n  —  m] ·

m	n	n	m

f (e[T]i [⊥]i ) = f (e[T]i [⊥]i ) = T.	Hence by bistability, f ([⊥]i [⊥i
]) =

n	m	n	m	m	m
f (e[T]i [⊥]i Λ e[T]i [⊥]i ) = f (e[T]i [⊥]i ) Λ f (e[T]i [⊥]i ) = T. So f (e[⊥]i ) =≥
n	m	m	n	n	m	m	n	n

f ([⊥]i
[⊥i
]) = T as required.	 

For a set of names X = {a1,... , an}, let e[d]X = e[d]1
.. .k
.. .1
.. .k .

Lemma 6.6 For all f, e, there exists n such that Ψn(e)= λx.f (e).


Proof. By Proposition 6.4, there exists n such that Ψn+1
∈ {T, ⊥}.	Suppose

w.l.og. that Ψn(e) = T — then f (Γn(e, Un(e))(⊥)) = T. Let X = S — Un(e).
f	f	f	f
Then Γn(e, Un)(⊥)[⊥]X ± Γn(e, S)(⊥), since for any →a ∈ Nk, if ν(→a) ∩ X /= ∅
f	f
then Γf (e, Uf (e)(⊥)[⊥]X (→a) = ⊥, and if ν(→a) ∩ X = ∅ then EqUn(e)(g, →a, g) if
n	n
f
and only if EqS (g, →a) and so Γn(e, ⊥,Un(e)⟨→a⟩ = Γn(e, ⊥, S)⟨→a⟩. By repeated ap-
f	f	f
plication of Lemma 6.5, f (Γn(e, ⊥,U (e)n)[⊥]X) = f (Γn(e, ⊥,U (e)n)) = T and so
f	f
f (Γn(e, ⊥, S)) = T. Since Γn(e, ⊥, S) ± e we have f (e)= T as required.	 
f	f
For each f ∈ ((N k × (Nl ⇒ Σ)) ⇒ Σ) ⇒ Σ we have Ψn(e)(⊥) = T implies Ψn+1(e)(⊥)= T by definition — i.e. {λx.Ψi (x)(⊥) | i ∈ ω} is an ω-chain.
f	f
Proposition 6.7 For any f ∈ (Nk × (Nl ⇒ Σ)) ⇒ Σ) ⇒ Σ, f = . λx.Ψi (x)(⊥).
Proof. For any e, if f (e) = T then by Lemma 6.6 there exists n such that
Ψn(e)(⊥)= T and so (. λx.Ψi (x)(⊥)) = T. Conversely, if (. λx.Ψi (x)(⊥))(e) = 
f	f	f
T then there exists n such that Ψn(e)(⊥)= T and so by Lemma 6.6, f (e)= T. 
Deﬁnability
We now need to show that for each f ∈ ((N k × (Nl ⇒ Σ)) ⇒ Σ) ⇒ Σ, and i ∈ ω, the function sending e to Ψi (e)(⊥) is definable. Note that the test EqS is definable for any S — more precisely, for any k, m there is a defin- able function test ∈ (Nm × ((N k ⇒ Σ) ⇒ Σ) × Nk × (B ⇒ Σ)) ⇒ Σ such that test(n1,... nm, f, →a, g) = f , if f ∈ {T, ⊥}, test(n1,... nm, f, →a, g) = g tt if
Eqn1 ,...,nm (f,→a) and test(n1,... nm, f, →a, g)= g ff otherwise.
A key element of our definability proof is to establish that we may encode Ψi (e)
as a tuple of names; since it is a parametric element of (Nk ×(Nl ⇒ Σ)) ⇒ Σ it may be represented as a tuples (→b, →c) in Nl × Nl. The basic idea is that if e(→a)(pn(i)) = ⊥ for all n (i.e. λg.e⟨→a, λm→ .g(mi)⟩ = new) then we record this by setting bi = 0. We

then use ci to record the least j such that e⟨→a, p(i, j)⟩ = T for all →a. If e⟨→a, pn(i)⟩ = T for all →a, then we record this by setting bi = k +1 and ci = n. Otherwise, there exists j ≤ k such that e⟨→a, paj (i)⟩ = T for all →a, and we may record this by setting bi to be the least such j.

In order to define Φi
for each i we also need a definable function to keep track

of the revealed names Ui (e): for each i we define χi : ((N k × (Nl ⇒ Σ)) ⇒ Σ) ⇒
f	f
(N (l×i) ⇒ Σ) ⇒ Σ such that ν(χi (e)) ∪ ν(f )= Uf (e) for all i by:
f	i
χi+1 = λ(x, g).χi (x) λ→y.ν→a.Φi+1 →a λz.g →y→z. Using second-order definability we may
f	f	f
now show:
Proposition 6.8 For each f ∈ ((N k × (Nl ⇒ Σ)) ⇒ Σ) ⇒ Σ, and i ∈ ω, Ψi , Φi
f	f
and χi are all deﬁnable.
Using definable retractions and Lemma 5.4 (modified) we may now prove:
Theorem 6.9 Full abstraction holds at every fourth-order type.

Failure of Full Abstraction at Fifth Order
We shall now give an example of a non-definable element at fourth order, and show that it leads to a failure of full abstraction at fifth order. Although the possible be- haviours at this order are complicated, the counterexample itself is relatively simple: equivalence 2 between λk.νn.k λf.ν m.f ⟨m, λa.f ⟨n, ⊥⟩⟩ and λk.k λf.ν m.f ⟨m, ⊥⟩
does not hold in our model. First we shall prove that these terms are indeed observa-
tionally equivalent (using the FM-biorder semantics). Fix a name n, and define Fn : чч(N ×чU )= λf.ν m.f ⟨m, λa.f ⟨n, ⊥⟩⟩ and F⊥ : чч(N ×чU )= λf.ν m.f ⟨m, ⊥⟩. By the Context Lemma, the equivalence holds if for any term M : ччч(N ×(чU )
not containing the name n, M Fn ↓ implies M F⊥ ↓.
Lemma 7.1 For any term x1 : N,... , xk : N, y1 : чU,... , yl : чU, g : чч(N ×

чU ) ▶ M :Σ not containing the name n, any m→
[[M ]](m→ , e, Fn)= [M ]](m→ , e, F⊥).
∈ Nk not including n, and e ∈ Σl:

Proof. By induction on the length of the β-normal form of M , with the addi-

tional inductive hypothesis (∗): for any m→
∈ Nk (possibly including occurrences

of n), e ∈ Σl, and a name a /∈ ν([[M ]]) ∪ {n}, if [M ]](m→ [a/n], e[⊥]i, Fn) = ⊥ and

[[M ]](m→ [a/n], e[T]i, Fn)= T then [M ]](m→ , e[⊥]i, Fn)= ⊥. (Where m→ [a/n] is m→
all occurrences of n replaced with a.)
with

If M ≡ ⊥ , M ≡ T, or M ≡ yi ⟨⟩ then the result is immediate. If M = νx.M ' then we may apply the inductive hypothesis to M '. If M ≡ If N1 then N2 else N3 then we may show [N1(m→ )]] = [N1(m→ [a/n]) ] and so we may apply the induction hypotheses to each of N2, N3.
So suppose M ≡ g λ(xk+1, yl+1).N . We first show that (∗) holds: suppose [[M ]](m→ [a/n], e[⊥]i, Fn) = ⊥ and [M ]](m→ [a/n], e[T]i, Fn) = T. Let b be a fresh name. By strong sequentiality of the model (Lemma 4.4), we have either:

[[N ]](m→ [a/n], b, T[⊥]i, T, Fn) = ⊥ and [N ]](m→ [a/n], b, ⊥[T]i, ⊥, Fn) = T — in which case [N ]](m→ , b, T[⊥]i, T, Fn)= ⊥ by hypothesis and so [M ]](m→ , e, Fn)= ⊥ as required — or else:
[[N ]](m→ [a/n], b, T, ⊥, Fn) = ⊥ and [N ]](m→ [a/n], b, T, T, Fn) = T. But then by
hypothesis, [N ]](m→ [a/n], n, T, ⊥, Fn)= ⊥ and hence [M ]](m→ [a/n], e[T]i, Fn)= ⊥, contradicting the assumption above.
We may now prove the main induction hypothesis. Suppose [M ]](m→ , e, F⊥)= ⊥ and [[M ]](m→ , e, Fn)= T. Then [N ]](m→ , b, e, F⊥)= [N ]](m→ , b, e, ⊥, Fn)= ⊥ by hypothesis on N , and so we must have [N ]](m→ , b, e, T, Fn)= T and thus [N ]](m→ , b, T→ , ⊥, Fn)= 
⊥ and [N ]](m→ , b, ⊥→ , T, Fn)= T. By (∗), [N ]](m→ , n, T→ , ⊥, Fn)
= ⊥, so [M ]](m→ , e, Fn)= [N ]](m→ , b, e, [[N ]](m→ , n, e, ⊥, Fn), Fn)= [[N ]](m→ , b, e, ⊥, Fn)
= ⊥ which is a contradiction.	 
Corollary 7.2 Equivalence (2) holds in the CPS-nu-calculus.
To show that it does not hold in the FM-bicpo model, for each i ∈ N define fi : (N × Σ) ⇒ Σ: fi(n, e) = T iff i = n or e = T. Consider the function G : (((N × Σ) ⇒ Σ) ⇒ Σ) ⇒ Σ defined G(h) = T iff h(fi) = T for some i ∈ N. This is a bistable function — it clearly preserves all binary joins and to show that it preserves bistable meets, suppose h ‡ k and G(h) = G(k) = T. Then there exists i such that h(fi)= T and j such that k(fj)= T. Define gi : (N × Σ) ⇒ Σ by gi(n, e) = ⊥ iff i = n or e = ⊥. Then gi ‡ fi and gi ± fj for all j. So by definition of ‡, T = h(fi) = h(fi) V k(gi) = h(gi) V k(fi) and so either k(fi) = T
(and so (h Λ k)(fi)= T) or else h(fj) ± h(gi)= T (and so (h Λ k)(fj)= T). Thus
G(h Λ k)= T as required.
Proposition 7.3 [[λk.νn.k ⟨λf.νm.f ⟨m, λa.f ⟨n, ⊥⟩⟩⟩]]	/= [[λk.k ⟨λf.νm.f ⟨m, ⊥⟩⟩]].
Proof.  G([[λf.νm.f ⟨m, λa.f ⟨n, ⊥⟩⟩]])	=	[[λf.νm.f ⟨m, λa.f ⟨n, ⊥⟩⟩]](fn)	=	T.
Hence [λk.νn.k λf.νm.f ⟨m, λa.f ⟨n, ⊥⟩⟩]](G) = T. But [λf.νm.(f ⟨m, ⊥⟩)]](fi) = 
⊥ for all i and hence [λk.k λf.νm. ⟨m, ⊥⟩]](G)= ⊥.	 
So we may deduce that G is not definable in the CPS-nu-calculus.

Conclusions
We have given a general notion of CPS model with fresh names, of which many notions of functional (stable, strongly stable, etc.) will yield an instance. We have shown that “bistable coherence” structure, by imposing sequentiality, increases the fragment of the language which can be interpreted fully abstractly to all fourth- order terms. (This fourth order fragment is quite expressive; it may be used, for example, to describe protocols involving the generation and exchange of fresh names as in the cryptographic λ-calcuus [8].
The most obvious further questions concern the failure of full abstraction in the bistable model. On the one hand, the functional G can be implemented sequentially

(using state, for example), and it can be added to the language. Is the bistable model fully abstract for the resulting language? On the other hand, is there a stronger constraint on functionals which will eliminate G from the language? Is this sufficient to obtain full abstraction?

References
S. Abramsky, D. R. Ghica, A. S. Murawski, C.-H. L. Ong, and I. Stark. Nominal games and full abstracion for the nu-calculus. In Proceedings of LICS ’04. IEEE Press, 2004.
J. Laird. Bistability: an extensional characterization of sequentiality. In Proceedings of CSL ’03, number 2803 in LNCS. Springer, 2003.
J. Laird. A game semantics of local names and good variables. In Proceedings of FOSSACS ’04, number 2987 in LNCS, pages 289–303. Springer, 2004.
J. Laird. Bistability: A sequential domain theory. To appear in Logical Methods in Computer Science, 2007.
R. Milner. Fully abstract models of typed lambda-calculi. Theoretical Computer Science, 4:1–22, 1977.
M. R. Shinwell and A. M. Pitts. On a monadic semantics for freshness. Theoretical Computer Science, 342:28–55, 2005.
I. Stark.	Names and Higher-Order Functions.	PhD thesis, University of Cambridge Computer Laboratory, 1995.
E. Sumii and B.C. Pierce. Logical relations for encryption. Journal of Computer Security, 11:521–554, 2002.
