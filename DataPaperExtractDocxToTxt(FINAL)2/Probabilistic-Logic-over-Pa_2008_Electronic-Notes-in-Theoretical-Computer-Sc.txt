

Electronic Notes in Theoretical Computer Science 220 (2008) 79–96
www.elsevier.com/locate/entcs
Probabilistic Logic over Paths
Evan Tzanis and Robin Hirsch 1,2,3
Department of Computer Science University College of London UK

Abstract
We introduce a probabilistic modal logic PPL extending the work of [13,12] by allowing arbitrary nesting of a path probabilistic operator and we prove its completeness. We prove that our logic is strictly more expressive than other logics such as the logics cited above. By considering a probabilistic extension of CTL we show that this additional expressive power is really needed in some applications.
Keywords: Probabilistic Logics, Modal Logic, Completeness

There are many papers combining logic and probability, the ones mentioned here are far from exhaustive [4,18,19,10,11,1,14,15], [16,3,8,22,7,5,20]. Some of these papers deal with probabilistic model checking and some deal with theorem proving for probabilistic logics. There are very few probabilistic logics with complete proof systems, the only ones we are aware of are based on [12,13,21] and we will focus on this type of logic in this paper. One serious restriction to these languages is their inability to express non-linear probabilistic terms. The lack of multiplication in the signature means that they cannot express such basic notions as independence of events and conditional probability. The other limitation of these languages is that the probability operator applies to single formulas, rather than sequences of formulas. But there are probabilistic versions of CTL which really require us to express probabilities of sequences of formulas (or branches in a probabilistic model), rather than probabilities of single individual formulas. Unfortunately no deduction system is known to be complete for these probabilistic versions of CTL. The focus of the current paper is to extend known probabilistic logics so as to allow us to express probabilities of sequences of probabilistic formulas. We provide axioms and rules for our logic and prove their soundness and completeness. We also show that

1 We would like to thank the anonymous referees for their useful comments.
2 Email: e.tzanis@cs.ucl.ac.uk
3 Email: r.hirsch@cs.ucl.ac.uk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.020

our logic is strictly more expressive than the previously cited probabilistic logics, which lack path expressiveness.
The previously mentioned logic of [12] is actually a probabilistic epistemic logic (we call this logic PEL following [17]). Since our interest here has more to do with probabilistic reasoning than epistemic reasoning, we consider the non-epistemic part of PEL and name this PEL× . PEL× is a probabilistic propositional logic in which we can refer to and compare probabilities of formulas (see definition 2.3 below), for example we can write P(p) > P(¬q). The probability operators can be nested, so we can write P(P(p) > P(¬q)) < 2 × P(¬p). The language also allows us to form arbitrary linear combinations of terms involving probabilities.
The outline of the paper is as follows: Over the next section we define a proba- bilistic modal logic called PPL (Path Probabilistic Logic). PPL is a probabilistic branching logic with some similarities to the logic in [16,3]. In section 3 we present a number of worked examples illustrating the use of this logic and we relate our logic with other known logics of the field. We show that PPL is strictly more ex- pressive than PEL× and we illustrate also the different expressive power between PPL and the probabilistic version of CTL [16]. In section 4 we prove that PPL has the finite model property, we provide axioms and inference rules and prove their completeness, thereby solving an important open problem. To quote [21, page 2], “To the best of our knowledge, so far no sound and complete proof system for the branching-time probabilistic logics has been proposed”.
Probabilistic Path Logic PPL
We start by setting up the syntax of PPL, we define its semantics and we present examples for illustrating its use. Let PROP = {p, q, r,.. .} be a non empty set of propositional variables.
Definition 1.1
Formulas of the language PPL are built out of numerical terms τ as follows. In the recursive definitions below, p ∈ PROP, φ, φ1,... represent PPL formulas and τ, τ1, τ2 represent terms.
τ := r | Pn(φ1,..., φn) | (τ1 + τ2) | (τ1 × r)  (r ∈ Q, n ∈ N)
φ := p | τ > 0 | ¬φ | φ ∧ ψ

deg(φ) denotes the degree of a formula φ and deg(τ ) is the degree of a term τ , defined as follows: deg(p) = deg(r) = 0 (p ∈ Prop, r ∈ Q), deg(¬φ) = deg(φ), deg(φ ∧ ψ) = max{deg(φ), deg(ψ)} , deg(τ1 + τ2) = max{deg(τ1), deg(τ2)},
deg(τ × r) = deg(τ ), deg(τ > 0) = deg(τ ), deg(Pk(φ1,..., φk)) = max{0, 1 + 
deg(φ1), 2+ deg(φ2),...,k + deg(φk)}

Notation
Throughout the paper a sequence of formulas (φ1,..., φk) will be denoted φ
(some k ∈ N, some formulas φ1,..., φk), in other words it will be implicit that the

m’th formula in the sequence φ is φm (for 1 ≤ m ≤ k). Therefore we write Pnφ instead of Pn(φ1,..., φn). When we wish to refer to a number of different sequences of formulas, we will use superscripts (e.g. φ1, φ2,.. .) to avoid confusion with this convention. The length of the sequence φ is |φ|. For 0 ≤ i ≤ |φ|, we write φTi for the restriction (φ1,..., φi) of the sequence, noting that φT0 is the empty sequence. φ[m/ψ] is obtained from φ by substituting the formula ψ for the m’th element φm. We refer to the last element of a non-empty sequence φ as last(φ) = φ|φ|. If f is a function with finite domain X we may write (f (x) : x ∈ X) for the sequence (f (x0),...,f (xk−1)), where x0,..., xk−1 is some arbitrary but fixed enumeration of X.
A term of the form r or Pnφ is called a primitive term, and Pnφ should be thought of as ‘the probability of the sequence φ’. Formulas of the form τ > 0, p are called primitive formulas. Primitive formulas and negated primitive formulas are called literals. We write (φ ∨ ψ) as an abbreviation of ¬(¬φ ∧ ¬ψ) and (φ → ψ) for ¬(φ ∧ ¬ψ). A disjunctive normal form (DNF) is a disjunction of conjunctions of literals. We write τ1 > τ2 as an abbreviation for the primitive formula (τ1 + (−1) × τ2) > 0, and τ1 = τ2 abbreviates the non-primitive formula ¬(τ1 > τ2) ∧ ¬(τ2 > τ1). We may write τ2 < τ1 instead of τ1 > τ2, when convenient. We will usually write Pφ instead of Pkφ, where k is implicitly defined to be the length of the sequence φ. The empty sequence is written (). For a sequence (φ) of length one, we may write Pφ instead of P1(φ). Given two sequences of formulas φ and ψ, we denote the concatenation of the two sequences by φψ. So, for 1 ≤ l ≤ |ψ| + |ψ|, we have:



(φψ)l
= ,⎨ φl,	if 1 ≤ l ≤ |φ|;
, ψl−|φ| if |φ| < l ≤ |φ| + |ψ|

We may write φφ or (φ : φ) for the concatenation of the one element sequence (φ) with the sequence φ, and similarly φφ is the concatenation of φ and the one element sequence (φ). Now we define the semantics.
Definition 1.2 [Models] A structure M for PPL is M = (W, f, V ) such that, W /= ∅, is a countable 4 set of possible worlds, V : Props → ℘(W ) assigns a set of worlds to each proposition and f : W × W → [0, 1] satisfies 5 :   v∈W f (w, v) = 1 for all w ∈ W .
PPL-terms can be evaluated in a structure M = (W, f, V ) by:
[r]M,w = r where r ∈ Q
[P()]M,w = 1 
[P(φ : φ)]M,w = Σv:M,v|=φ f (w, v) · [Pφ]M,v

4 There are problems in defining sums of probabilities if there are uncountably many worlds. A generali- sation to uncountable but measurable semantics can be carried forward as in [12] where f is required to be integrable with respect to each of its arguments.
5 Another generalisation of these structures cPan be obtained by letting the range of f be the non-negative
real numbers and replacing the requirement	f∈W f (w, v) = 1 by the bounded sum condition: for any
w ∈ W the supremum of {P	f (w, x): X ⊆ W is finite} exists. Such a logic could be useful for counting
or measuring various quantities. In the set of axioms given in figure 2 it would be necessary to delete W0
to axiomatise these more general structures.

[τ1 + τ2]M,w = [τ1]M,w + [τ2]M,w .
[τ × r]M,w = [τ ]M,w · r.
Formulas of this logic can be evaluated by
M,w |= p iff w ∈ V (p)
M,w |= τ > 0 iff [τ ]M,w > 0
M,w |= ¬ϕ iff M,w |= ϕ
M,w |= ϕ ∧ ψ iff M,w |= ϕ and M,w |= ψ

Note: syntactic terms of PPL are built up from rational numbers but [P(φ : φ)]M,w , above, could potentially result in terms evaluating to irrational, real num- bers, even if the range of the function f were contained in the set of rational numbers. If M is a structure, φ is a PPL-formula and M,w |= φ then (M, w) is a model of φ.

Lemma 1.3 Let φ be a non-empty sequence and let ψ be an arbitrary sequence of
PPL formulas, and let M = (W, f, V ) be any PPL-structure.

[P(φψ)]M,v =	 Σ  
f (vi, vi+1) · [Pψ]M,v|φ|

for 1≤i≤|φ| v¯∈W |φψ|:M,vi|=φi


0≤i<|φ|


	
Proof. The proof is by induction over |φ|. By definition 1.2, the case |φ| = 1 holds. Now let φ = φ1 : φ/1 where φ/1 = (φ2, φ3,..., φ|φ|) is non-empty. By definition 1.2 again, and by our inductive hypothesis,
[P(φψ)]M,v0 = [P(φ1 : φ/1ψ)]M,v0

=	Σ
v1:M,v1|=φ1
=	Σ


f (v0, v1) · [P(φ/1ψ)]M,v1
f (v0, v1) ·	Σ



f (vi, vi+1) · [Pψ]M,v|φ|



v1:M,v1|=φ1
=	Σ
M,vi|=φi, 2≤i≤|φ| 1≤i<|φ|
 f (v0, v1) ·	 


f (vi, vi+1) · [Pψ]M,v|φ|

v:M,v1|=φ1, M,vi|=φi, (2≤i≤|φ|)	1≤i<|φ|
=	Σ		 f (vi, vi+1) · [P]M,v|φ|
v:M,vi|=φ, (1≤i≤|φ|) 0≤i<|φ|
as required.	 

Examples and related logics
We start this section with some examples of PPL formulas for illustrating the semantics of our logic.
Example 2.1 Some formulas of PPL are:
P(p, p) > 0.19. We will show later that formulas like this have no equivalent in
PEL×.

P(p ∧ Pp > 0.49) > 0.39 As we note below, this formula is (apart from minor notational changes) a formula of PEL× [12].
We could say that PPL is a logic for stating properties such as, ”the probability that q will hold continuously over 2 seconds is greater than the probability that p will hold over 2 seconds”. Such properties, as we will discuss later, are not expressible in the probabilistic version of CTL [16]. In PPL we could write something like that: P(q, q) > P(p, p)
PEL
We continue by surveying a number of well known logics of the field of probabilistic logics. In [12] a probabilistic epistemic logic was given and proved to be complete and decidable, based on a number of results of [13]. This logic allows nesting of the probabilistic operator, but the operator is applied to single formulas, not sequences.
Definition 2.2 [PEL in [17]] Let P be a countable set of propositional letters and let A be a finite set of agents. PEL formulas are defined by the following rule.
φ := p | ¬φ | φ ∧ ψ |  aφ | q1 × Pa(φ1)+ ... + qn × Pa(φn) ≥ q
where p ∈ P, a ∈A and q1,..., qn,q are rationals.
A sentence of the form Pa(φ) ≥ q should be read as the probability that agent a assigns to φ is greater than or equal to q. Also PEL expresses higher order probabilities such as Pa(Pb(φ) ≥ q1) ≥ q2. We could read this sentence as the probability a assigns to the sentence that the probability b assigns to φ is greater or equal to q1, is greater or equal q2.
The semantics of this logic as formulated in [12], is probabilistic epistemic models. These models M = (W, f, V ) have a function f that assigns a proba- bility function fa to each agent a at each world. In more detail we have: f : (A× W ) → (W → [0, 1]) where A is the set of agents. To interpret Pa(φ) we have: [Pa(φ)]M,w =  w:M,v|=φ f (a, w, v)
Our logic has no epistemic operators, but we can eliminate the epistemic aspects of PEL if we assume that the probability function fa : (w, v) '→ f (a, w, v) is the same for all agents. For this non-epistemic case we rewrite PEL’s syntax as follows:
Definition 2.3 PEL× is the non-epistemic sublanguage of PEL, defined by,
φ := p | ¬φ | (φ ∧ ψ) | q1 × P(φ1)+ ... + qn × P(φn) ≥ q
where p is a propositional letter, q, q1,..., qn are rational numbers and φ, ψ, φ1,..., φn
are formulas. A PEL×-structure M = (W, f, V ) is defined just as in definition 1.2, but where a term P(φ) is evaluated by: [P(φ)]M,w = Σv:M,v|=φ f (w, v)
Thus, PEL× can be obtained from our language PPL be restricting terms to
τ :=  r|P1φ|(τ1 + τ2)|τ × r (r ∈ Q)
Thus, the P operator can now only be applied to single formulas, rather than sequences of formulas. Below we show that this restriction really diminishes the expressive power of the language.

R
.
/ 
/
/	u
/
/
/

p	.//  A
/\
. ¬p

/  \	/ \
/	\
/	\	v /	\
\

/
/
p /. B
\
\
¬p \.
/	\
/	\
/	\
.p	\ . ¬p


Fig. 1. The binary tree T (x, y, z, u, v, w).
We have just seen that the set of PEL× formulas forms a fragment of PPL. Here we will show that this is a proper fragment, by showing that there are PPL formulas that have no equivalent in PEL×. We will use a result due to [12, Theo- rem 4.1] (based on a theorem of [13, Theorem 2.2]) that the satisfiability of a PEL× formula is reduced to satisfiability of a set of linear inequalities over the variables representing the weight of the edge from a node to one of its successors.
Definition 2.4 Let ψ be a non-epistemic PEL× formula and let φ be a PPL formula. We say that ψ is equivalent to φ if for all PPL structures M and all worlds w we have M,w |= ψ ⇐⇒ M,w |= φ. Since PEL×-structures have the same form as PPL-structures, this makes sense.
Theorem 2.5 There is a PPL formula for which there is no equivalent PEL×
formula.
Proof. Consider the formula φ = (P(p, p) = 1 ). This is about the simplest PPL formula you could write, that does not directly translate into PEL×, because the P applies to a sequence of formulas of length greater than one. Consider the class of PPL-structures of the form of figure 1, i.e. binary trees of depth 2. Denote the tree in the diagram as T (x, y, z, u, v, w), where x is the weight of the edge from the root to the successor (A) where p holds and y, z, u, v, w are the weights of the other edges, as shown in the diagram. [Note that the variables we are using here, representing the weight of the edge from a node to one of its successors, are the same sort of variables used in [12] for PEL. In our completeness proof, below, we use different variables representing the weight of a branch from the root to a given node of the tree.] It is clear that T (x, y, z, u, v, w),R |= φ iff xy = 1 . Now for any PEL× formula ψ the set {(x, y, z, u, v, w) : T (x, y, z, u, v, w),R |= ψ} can easily be shown along the lines of [13, Theorem 2.2] to be a subset of R6 defined by linear inequalities only. But {(x, y, z, u, v, w) : xy = 1 } cannot be defined by linear inequalities. Therefore there is no PEL× formula equivalent to φ.	 

Related work
For probabilistic modal logics closely related with the investigations of Halpern and Fagin we refer to [9,23,2]. The first two papers study a logic with an operator P>(φ) meaning that ‘the probability of φ is greater than r’. Clearly, such formulas can be expressed in the sublanguage of PEL given in definition 2.3, but unlike PEL, these languages cannot express non-trivial linear combinations of probabilities. In
[2] a complete axiomatization was proved by using an infinitary rule for languages containing an operator Pr(φ) standing for ‘the probability of φ is equal to r’. A complete axiomatization was proved regarding the logics in [9,23] with respect to the class of models where probabilities are taken from a finite set subset of [0, 1].

PCTL
During the 1990s various probabilistic temporal logics were studied, combining tem- poral logics with probabilities. A probabilistic extension of CTL was given in [16,3] where a number of results concerning the decidability of model checking were also proved. The definition given here is a minor variation on the one given in [6].
Definition 2.6 The syntax of PCTL is defined by the following grammar:
φ := p | ¬φ | φ1 ∧ φ2 | Pdd ψ
ψ := φ1Uφ2 | φ1U≤tφ2
where p is a propositional letter, d is a rational from [0, 1], d ∈ {>, ≥} 6 and t ∈ N. Formulas defined in (1) are called state formulas and formulas defined in (2) are called path formulas. In the right hand side of the definitions, φ, φ1, φ2 stand for arbitrary state formulas and ψ is an arbitrary path formula.
The syntax of WPCTL is the same as that of PCTL, except that in the definition of path formulas, only the ‘restricted until’ is allowed.
ψ := φ1U≤tφ2
Here Pdd is a probabilistic operator, while the temporal operator U≤t is a re- stricted version of the ‘until’ operator. U≤t is like the standard until operator except that, in ψ1U≤tψ2, ψ2 should be true within t time units. A time unit is one transi- tion in the model of the formulas, and as models they consider discrete time Markov chains.
The semantics of PCTL is a structure (S, s0, f,V ) where, S is a finite set of states, s0 is the initial state, f is the probability function f : S × S → [0, 1] such that for any state s we have:  s' f (s, s') = 1, and V is a propositional valuation. For s ∈ S, an s-path σ : ω → S is a countable sequence of states σ[0], σ[1],.. ., such that σ[0] = s. We write σTn = (σ[0], σ[1],..., σ[n]) for the initial segment of σ with n + 1 terms. We can define a σ-algebra generated by certain sets of s-paths and a measure on such sets, as follows. For any finite sequence of states (s0, s1,..., sn),

6 In [6], d can also be < or ≤, but these relations are not needed since τ < d ≡ ¬(τ ≥ d) and τ ≤ d ≡
¬(τ > d).

let (s0,..., sn) ↑ be the set of all s0-paths σ such that σ[i] = si, for each i ≤ n.
{(s0,..., sn) ↑: s0 = s, n ∈ N, si ∈ S (i ≤ n)}
generates a σ algebra, by taking countable unions and complements. If X is a set of s-paths, let −X be the complement of X in the set of all s-paths. We define a measure μs by letting
μs(s0, s1,..., sn) ↑ =   f (si, si+1), where s0 = s
i<n
μs(−X)=1 − μs(X)
μs(  Xi)= Σ μS(Xi), if the Xi are disjoint
i<ω	i<ω
It can be shown, for any path formula ψ, that {s-paths σ such that σ|≡ ψ} is measurable.
Formulas of this logic can be evaluated over states (relation |= )and paths (re- lation |≡):
S, s |= p iff s ∈ V (p)
S, s |= ¬ϕ iff S, s |= ϕ
S, s |= ϕ ∧ ϕ' iff S, s |= ϕ and S, s |= ϕ'
S, s |= Pdd ψ iff μs{σ : σ[0] = s ∧ σ|≡ ψ} dd 
σ|≡ ϕ U ϕ' iff ∃i ∈ N, (S, σ[i] |= ϕ' and ∀j < i, S, σ[j] |= ϕ) σ|≡ ϕ U≤t ϕ' iff ∃i ≤ t, (S, σ[i] |= ϕ' and ∀j < i, S, σ[j] |= ϕ)
PCTL is able to express soft deadline properties, such as ‘after a request for service, there is at least a 98 percent probability that the service will be carried out within 2 seconds’. For example, the property: ‘with at least 0.8 probability q will hold continuously for the next 7 time units’ is expressed by the formula
¬P≥0.2(TU≤7¬q).
The unrestricted until is beyond the scope of our language PPL, but the restricted language WPCTL can be expressed in PPL. According to [21] a complete set of axioms for WPCTL is not known and its complexity is also unknown. Based on our completeness proof in Section 4, we could show that there is a 2 − EXPTIME upper bound for the validity problem of WPCTL.
Definition 2.7 The translation Tr takes state formulas of WPCTL to PPL is defined as follows: Tr(p) = p, Tr(¬φ) = ¬Tr(φ), Tr(φ ∧ ψ) = Tr(φ) ∧ Tr(ψ) and

, ψ ∨ (φ ∧ [P(ψ)+ P((φ ∧ ¬ψ), ψ)+ ... 
Tr(P>d(φU ≤tψ)) =	... + Pt((φ ∧ ¬ψ),..., (φ ∧ ¬ψ), ψ)] > d)

d < 1

⎪⎪, ⊥	d ≥ 1
and the translation of P≥d(φU≤tψ) is similar. Note that (3) can be expressed in PPL as
q ∧ (P(q, q, q, q, q, q, q) ≥ 0.8)

We have seen that such expressions have no equivalents in logics such as PEL×.
Lemma 2.8 Suppose (S, s0, f,V ) |= φ, for some state formula φ of WPCTL. Then (S, f, V ), s0 |= Tr(φ).
Conversely, if (W, f, V ),w |= Tr(φ) for some state formula φ of WPCTL then
(W, w, f, V ) |= φ.
The proof is entirely routine and omitted. So WPCTL is expressively equivalent to a fragment of PPL. In fact this fragment is a proper fragment since PPL- formulas such as
3 × P(p, p)+2 × P(p, q) > 0.5
have no equivalent in WPCTL.

Completeness
Before we really start, we should mention that PPL is not compact; this could be proved along the lines of [17]. This compactness failure indicates that a strong completeness result is not provable for this logic; we prove weak completeness below.
In figure 2 we give a set of inference rules and axioms for PPL. We write ▶ ψ if ψ can be proved by the rules and axioms included in the figure. If ψ can be proved using only modus ponens and Prop we may write ▶Prop ψ. We will show that the rules and axioms of figure 2 are sound and complete. As is often the case, the
proof of soundness is relatively straightforward. To prove completeness we will show that an arbitrary consistent formula has a model, in fact the model we construct will have only finitely many worlds, and the number of worlds will be bound by an exponential function, in terms of the size of the formula. Some notation first. From definition 1.1 we see that every term is a linear sum of primitive terms. A term

k i=1
​
ci × Pψi + d (ci,d ∈ Q) can be written as
L(Pψ1, Pψ2,..., Pψk)+ d

where L is the linear operator L : (x1,..., xk) '→ Σk	ci × xi. Thus, every term
has the form (4), for some linear operator L, some primitive terms Pψ1,..., Pψk
and some d ∈ Q. Figure 2 is divided in to two parts: inference rules and axioms. All but one of these are rephrased versions of the axioms and rules given by [13] for reasoning about probabilities, but the inference rule Extension is a brand new rule for reasoning about probabilistic paths.
Lemma 3.1 The rules and axioms of ﬁgure 2 are sound.
Proof. We prove that Extension is sound, the other cases are routine (and covered by [13]). Suppose that


last(φ) → L(Pψ1,..., Pψk) Δ d

is valid, for some sequences φ, ψ1 ,..., ψk , some Δ∈ {<, =, >}, some d ∈ Q and some L. Let ł be any PPL-structure with a node v0 such that

ł, v0 |= Pφ > 0



Fig. 2. Quantitative Rules and Axioms. In ‘Extension’, d ∈ Q, Δ stands for <, = or >. L is an arbitrary linear operator.

We must show that


ł, v0 |= L(Pφψ1,..., Pφψk) Δ (Pφ × d)
Let n = |φ|. Let v = (v0, v1,..., vn) be a sequence of nodes in ł such that for 1 ≤ i ≤ n we have ł, vi |= φi (such a sequence must exist, by (6)).So ł, vn |= last(φ) and by (5),
[L(Pψ1,..., Pψk)]M,vn Δ d
Write f (v) for i<n f (vi, vi+1). By lemma 1.3, for 1 ≤ m ≤ k,

​
[Pφψm]M,v0 =	Σ
v:M,vi|=φi, (1≤i≤n)


f (v) · [Pψm]M,vn

and by (6), we can choose the sequence v so that f (v) > 0. By linearity of L and by (9),

[L(Pφψ1,..., Pφψk)]M,v0
= L([Pφψ1]M,v0 ,..., [Pφψk]M,v0 )

= L(	Σ
v:M,vi|=φi (1≤i≤n)
f (v) · [Pψ1]M,vn ,...,	Σ
v:M,vi|=φi (1≤i≤n)


f (v) · [Pψk]M,vn )

=	Σ
v:M,vi|=φi (1≤i≤n)

	
f (v) · [L(Pψ1,..., Pψk)]M,vn

Δ	Σ
v:M,vi|=φi (1≤i≤n)

= [Pφ]M,v0 · d
f (v) · d (by (8) since f (v) > 0, some v included in sum)

which proves (7), as required.	 
Lemma 3.2 For each formula φ there is a DNF formula φ' with ▶Prop φ — φ', where φ' is a disjunction of conjunctive clauses and each clause is a conjunction of propositions, negated propositions and inequalities 7 L(Pψ1,..., Pψk) Δ d, for Δ∈ {<, =, >}.
Proof. By propositional reasoning, φ is equivalent to DNF. A literal of PPL ч(L(Pψ1,..., Pψk) > d) is equivalent (using Reals) to (L(Pψ1,..., Pψk) = d) V (L(Pψ1,..., Pψk) < d).
Similarly, literals ч(L(Pψ1,..., Pψk) = d) and ч(L(Pψ1,..., Pψk) < d) can each be replaced by the disjunction of two primitive formulas. Let φ∗ be obtained from φ by first finding an equivalent DNF and then replacing each such negated primitive formula by an equivalent disjunction of two primitive formulas. Now repeatedly apply the distribution law
▶ A Λ (B V C) — (A Λ B) V (A Λ C)
to transform φ∗ to an equivalent DNF formula φ'.  Note that literals involving
L(Pψ1,..., Pψk) Δ d (for Δ∈ {<, =, >}) only occur positively in φ'.	 
Before we proceed with completeness, we need to prove some lemmas. The ones that follow, Lemma 3.3 and Lemma 3.7 are similar to [13, Lemma 2.3]. That is, we define certain ‘atoms’ in an algebra generated by subformulas of a given formula φ. The proof of completeness of our logic follows the outline of the corresponding proof in [13], but with the added complication of handling paths of formulas rather than single formulas. Here will use sequences of atoms as worlds in the model we construct.
Lemma 3.3 Let 1 ≤ m ≤ |φ|. If ▶ φm — ψ1 V ... V ψn and ▶ ч(ψl Λ ψl' ) for all distinct 1 ≤ l, l' ≤ n (l /= l' ) (in other words, it is provable that ψ ,...,ψ 
1	n
are mutually exclusive and their disjunction is equivalent to φm) then  ▶ Pφ =
P(φ[m/ψ1]) + ... + P(φ[m/ψn]).
Proof. For n = 1 we have ▶ φm — ψ1. By two applications of rule Generalisa- tion and an instance of Reals, we deduce that
P(φ1,..., φm−1, φm, φm+1,..., φk) = P(φ1,..., φm−1, ψ1, φm+1,..., φk), as required.
Assume the lemma holds for some n ≥ 1. For the inductive step, we must prove the lemma when ▶ φm — (ψ1V.. .Vψn+1) and ▶ ч(ψlΛψl' ) (any distinct 1 ≤ l, l' ≤ n+1). By the axiom W2 of figure 2, ▶ Pφ = Pφ[m/φm Λ ψn+1]+ Pφ[m/φm Λ чψn+1]. By our assumptions, ▶ (φm Λ ψn+1) — ψ n+1 and ▶ (φm Λ чψn+1) — (ψ1 V ... V ψn). Hence, using Generalisation:  ▶ Pφ = Pφ[m/ψn+1] + Pφ[m/(ψ1 V ... V ψn)].


	
7 In fact we could even make the restriction Δ∈ {<, =}, since the primitive formula L(Pψ1,..., Pψk ) < d 
is equivalent to (−L)(Pψ1,..., Pψk ) > (−d), where (−L) is the linear operator whose coefficients are the negations of those of L. But we do not need this restriction in the proofs that follow.

By our induction hypothesis ▶ Pφ[m/(ψ1 V ... V ψn)] = Σn	Pφ[m/ψi]. Hence
▶ Pφ = Σn+1 Pφ[m/ψi]	 
For the remainder of this section we fix a formula φ and let n = deg(φ).
Definition 3.4 Let m ∈ N.
Sm(φ) denotes the set of primitive subformulas of φ of degree at most m (see definition 1.1). Clearly |Sm(φ)|≤ |φ|.
S+(φ) ⊇ Sm(φ) is obtained from Sm(φ) by replacing each proposition p ∈ Sm(φ) by both p and чp, and each primitive formula (τ Δ d) ∈ Sm(φ) by all three formulas (τ < d),  (τ = d),  (τ > d). We have |S+(φ)|≤ 3 · |φ|.
A φ-formula is any formula whose primitive subformulas belong to S+(φ). A
φ-term is a linear combination of terms Pψ, where each ψi is a φ-formula.
A subset σ of S+(φ) is said to be complete if
|{p, чp}∩ σ| =1 
|{(τ < d), (τ = d), (τ > d)}∩ σ| =1 
whenever the proposition p occurs in φ and (τ Δ d) occurs in φ.
If σ ⊆ S+(φ) is complete then  σ Λ  {чx : x ∈ S+(φ) \ σ} is called an atom
of degree m of φ. The set of atoms of degree m of φ is defined to be
Am(φ) = {  σ Λ  {чx : x ∈ S+(φ) \ σ} : σ ⊆ S+(φ) is complete}
m	m
|Am(φ)|≤ 23·|φ|.
For 0 ≤ k ≤ m ≤ n, let X(m,k) = Am−1(φ) × ... × Ak(φ). Write Xm for X(m,0). We have |X(m,k)|≤ 23·(m−k)·|φ|.

Let θ, ψ be sequences of formulas with |θ|≥ |ψ|. We write ▶Prop θ → ψ if for each i with 1 ≤ i ≤ |ψ| we have ▶Prop θi → ψi.

We define the degree deg(ψ) of a sequence ψ of formulas to be max{0,i +
deg(ψi) : 1 ≤ i ≤ ψ}.
We define a map αm from terms of degree m to terms of the form L(Pa :
a ∈ Xm). For any sequence of formulas ψ with deg(ψ) ≤ m, let αm(Pψ) = 

Σa∈Xm : ▶Propa→ψ
Pa and for an arbitrary linear combination Σk
ci · Pψi of

such terms let αm(Σk
ci·Pψi) = Σk
ci·αm(Pψi) = Σ

a∈X
(Σi : ▶Propa→ψi
ci)·

Pa
Propositional axioms suffice to prove that distinct atoms of the same degree are disjoint. Also, since any subformula ψ of φ is a boolean combination of primitive subformulas of degree at most deg(ψ), propositional reasoning suffices to prove that ψ is equivalent to a disjunction of atoms of degree deg(ψ).
Our completeness theorem will build a tree-like model for φ out of sets X(m,k).
We first define this tree structure:
Definition 3.5 We define a model X for φ as the triple X = (X, V, f ) where:
the root node of X is the empty string ().

X is the union of all X(n,m):  0≤m≤n X(n,m).
In our tree, we draw an edge from a sequence s to a sequence t if and only if
|s| +1 = |t|≤ n and tT|s| = s.
V is the valuation defined by: Let () ∈ V (p) ⇐⇒ ▶Prop φ → p and for non-empty
a ∈ X let a ∈ V (p) ⇐⇒ ▶Prop last(a) → p.
We comment on all four clauses. First, the root of the model will be the empty sequence, its ‘children’ will be sequences of length one and their elements atoms of degree n − 1, its grandchildren will be sequences of length two where their first elements are atoms of degree n − 1 and their second elements are atoms of degree n − 2, etc. Regarding the second clause, note that X(n,0) = {()} and |X(n−i)| ≤ 

23·(n−i)·|φ|. Thus |X|≤ Σn
23·(n−i)·|φ| ≤ (n + 1) · 23·n·|φ|. The third clause ensures

that we draw an edge from s to t, only when t extends s with a single atom.
Regarding the function f we need also to deduce various constraints on the weights of the branches of this tree, evaluated at the root. Valuation V equates the truth of a propositional symbol at a with its membership at the last element of a. Also, for this construction to yield a genuine model of φ it will also be necessary (in order to prove a ‘truth lemma’) that certain constraints hold concerning the weights of branches evaluated away from the root. The following two lemmas will allow us to translate such constraints to constraints on branch weights evaluated back at the root.

Lemma 3.6 Let a ∈ X(n,n−| a|). Let Σk
ci · Pψi be a term of degree at most

n − |a|. If α(n−|a|)(Σl

 
ci · Pψi) = L(Pb : b ∈ Xn−|a|) then:
k

αn(Σ ci · Paψi) = L(Pab : b ∈ Xn−|a|)
i=1
Proof. For any atoms a, b ∈ Am(φ) (any m ∈ N) we have ▶Prop a → b if and only if a = b. Hence, if d ∈ Xn and aψ is a sequence of degree at most n with ai ∈ An−i(φ) for 1 ≤ i ≤ |a|, then ▶Prop d → aψ  ⇐⇒ ∃b : d = ab and ▶Prop
b → ψ.	αn−|a|(Σk	ci · Pψi) is, by definition, a linear combination of terms
(Pb : b ∈ Xn−|a|). For b ∈ Xn−|a|, the coefficient of Pb in this linear combination

is Σ

i : ▶Propb→ψi
ci (definition 3.4(ix)). The coefficient of ab in αn(Σk
Paψi) is

Σi : ▶Propd→aψi ci = Σi : Σ▶Propb→ψi ci, by the previous paragraph. Thus, the co-
αn(Σk	Paψi). This proves the lemma.	 
Lemma 3.7 Let m ∈ N and let τ be a φ-term of degree at most m. Then: ▶ τ =
αm(τ )

Proof. First consider a primitive term τ = Pψ, of degree not more than m. Let ψ' be obtained by concatenating ψ with a sequence of (m−|ψ|) Ts, so that |ψ'| = m. By axiom W0, ▶ Pψ = Pψ'. For 1 ≤ i ≤ m, let Ai = {a ∈ Am−i(φ) : ▶Prop a → ψ'}. Then a ∈ A1 × ... × Am iff ▶Prop a → ψ'. By propositional reasoning, since ψ' is

a φ-formula, ▶Prop ψ' — 

a∈Ai
a, for 1 ≤ i ≤ m. By lemma 3.3, for 1 ≤ i ≤ m, we

have ▶ Pψ' = Σa ∈A P(ψ'[i/ai]). Repeating this, for each dimension i,

▶ Pψ' =	Σ
a1∈A1,...,am∈Am


Pψ'[1/a1] ... [m/am]

=	Σ	Pa
a∈A1×...×Am

=	Σ


▶Propa→ψ'


Pa = αm(Pψ)

which yields the result, for primitive terms. The result follows also for linear com- binations of primitive terms, by linearity of αm.	 

Theorem 3.8 The formula φ (deg(φ) = n) is either inconsistent or it is satisﬁed at the root w of a tree like model ł (deﬁned below) of depth n and size not more than: (n + 1) · 23·n·|φ|.

Proof. Suppose φ is consistent. Since φ is consistent: φ Λ  a∈X (Pa = 0 V Pa > 0) is also consistent.  By propositional reasoning, there is a set Z ⊆ X such that φ Λ  a∈Z Pa = 0 Λ  a∈N Pa > 0 is consistent too, where N = X \ Z. By axioms W0 and W2, ▶ Pa = 0 → Pab = 0, so ab ∈ N ⇒ a ∈ N . By lemma 3.2, there is a DNF formula i γi ≡ φ, where each clause γi is a conjunction of propositions, negated propositions and primitive formulas τ Δ d. Furthermore, there is a clause γ = γi (some i) such that
φ = γ Λ    Pa = 0 Λ   Pa > 0


is consistent.
a∈Z
a∈N

We will define a model X = (X, V, f ) for φ0 (hence a model for	i γi ≡ φ) according to the lines of definition 3.5. We aim to build this model in such a way
that for any a ∈ N and any ψ ∈ S+	(φ),
▶Prop last(a) → ψ ⇐⇒ X, a |= ψ
and for an arbitrary ψ ∈ S+(φ),
If ▶Prop γ → ψ then X, () |= ψ
(11) will show that X is a model for γ, hence a model for φ. The definition of the valuation V of X ( 3.5, fourth clause) ensures that (10) and (11) hold for propositions and negated propositions occurring in φ0.
To complete the definition of X it remains to define the weight function f . Each term Pa for a ∈ X will be considered as a real-valued variable and we will define a consistent set of linear constraints in these variables. A solution to these constraints

will then be used to define f . The set of constraints is
C = {Pa = 0 : a ∈ Z}∪ {0 < Pa : a ∈ N}


(12)
∪ {αn(τ ) Δ d :▶Prop γ → (τ Δ d)}

∪ {αn(L(Paψ1,..., Paψk)) Δ (Pa × d) : 

a ∈ N \ {()}, ▶Prop last(a) → (L(Pψ1,..., Pψk) Δ d)}


	
and we let C¯ be the set of all linear constraints L(Pa1,..., Pak) Δ d (L  a linear operator, ai ∈ X, Δ∈ {<, =, >}, d ∈ Q) such that ▶ C → L(Pa1,..., Pak) Δ d.
We claim that ▶ φ0 →  C. For this claim, each element of the first two sets is a conjunct of φ0.  For the third set, let ▶Prop γ → (τ Δ d).  By lemma 3.7,
▶ (τ = αn(τ )) and by Reals ▶ γ → (αn(τ ) Δ d), so ▶ φ0 → (αn (τ ) Δ d). For the final set, let a ∈ N be non-empty and let ▶Prop last(a) → L(Pψ1,..., Pψk) Δ d.
Note that deg(L(Pψ1,..., Pψk)) ≤ n — |a|, since last(a) ∈ An−|a|(φ). By inference rule Extension we have ▶ Pa > 0 → L(Paψ1,..., Paψk) Δ Pa × d. Since a ∈ N we know that ▶ φ0 → Pa > 0, hence ▶ φ0 → L(Paψ1,..., Paψk) Δ Pa × d. By lemma 3.7 and Reals we get ▶ φ0 → αn(L(Paψ1,..., Paψk)) ΔPa×d. This proves the claim.
Hence the set C is a consistent set of constraints, and consequently the ‘provable closure’ C¯ of C is also consistent. By completeness of Reals there is a map g : X → R such that

L(Pa1,..., Pam) Δ d ∈ C¯ ⇒ L(g(a1),..., g(am)) Δ d  holds
Observe that g(a) > 0 for all a ∈ N , since Pa > 0 is a constraint in C.
Now we can complete the definition of X by defining the weight function f . We let f (a, b) = 0, unless b = aa for some a ∈ An−(1+|a|)(φ) such that b ∈ N , i.e. the edges with non-zero weight are contained in a tree with root () with edges defined by extending a sequence by a single atom producing a sequence in N . To define the weights of such edges, let

f (a, ab) = 
g(ab)
g(a)

(since ab ∈ N we have a ∈ N so g(a) > 0). This completes the definition of X .
It remains to verify (10) and (11).  For the left to right implication in (10),
suppose a ∈ N is non-empty, (L(Pψ1,..., Pψk) Δ d) ∈ S+	(φ) and

▶Prop last(a) → L(Pψ1,..., Pψk) Δ d

We must show that X, a |= L(Pψ1,..., Pψk) Δd. Assume, as an induction hypoth- esis over n — |a|, that (10) holds at w, whenever |w| > |a| and w ∈ N . (This holds when |w| = n since in this case we are only required to verify (10) for subformulas of φ of degree 0, i.e. propositional formulas, and we have already seen that (10) holds in this case, by definition of the valuation V .) It follows, for any w ∈ N with
|w| > |a| and any atom a ∈ An−|w|(φ),X, w |= a ⇐⇒ a = last(w)

Hence by lemma 1.3,

[Pb]X,a = f (a, abT1) · f (abT1, abT2) ··· f (abT|b|−1), ab) · 1
g(ab)
g(a)

when ab ∈ N . Therefore
g(a) × [L∗(Pb1,..., Pbk)]X ,a = L∗(g(ab1),..., g(abk))
for any linear operator L∗, provided ab1,..., abk ∈ N . By (14) and (12),

​
Let (17)

	
αn(L(Paψ1,..., Paψk)) Δ Pa × d  ∈ C

 
αn−|a|(L(Pψ1,..., Pψk)) = L'(Pb : b ∈ Xn−|a|)


	
 
(some linear operator L'). By lemma 3.6 αn(L(Paψ1,..., Paψk)) = L'(Pab : b ∈
Xn−|a|). Hence

L'(g(ab) : b ∈ Xn−|a|) Δ g(a) · d by (13) and (16)

 
[L'(Pb : b ∈ X	)]X ,a Δ d	by (15), g(a) > 0
[α	(L(Pψ1,..., Pψk))]X,a Δ d	by (17)
[L(Pψ1,..., Pψk)]X,a Δ d	by lemma 3.7
and so X, a |= L(Pψ1,..., Pψk) Δ d. We have shown that ▶Prop last(a) → ψ ⇒
X, a |= ψ, for ψ = L(Pψ1,..., Pψk) Δ d  ∈ S+	(φ). The right to left implication
in (10) is now easy.
If /▶Prop last(a) → L(Pψ1,..., Pψk) Δ d (where (L(Pψ1,..., Pψk) Δ d) ∈

+
n−|a|
(φ)) then by definition 3.4(iv) and3.4(v), ▶Prop last(a) → L(Pψ1,..., Pψk)Δ'

d for some Δ' ∈ {<, =, >} \{Δ}. By the already proved left to right implication, we deduce X, a |= L(Pψ1,..., Pψk) Δ' d and therefore X, a |= L(Pψ1,..., Pψk) Δ d, as required. This proves (10) at a; by induction it holds throughout X .
It follows that
(18)	[Pa]X ,() = g(a)
for any a ∈ N . The equation also holds for a ∈ Z, more trivially, since in this case [Pa]X,() = g(a) = 0. For (11) recall that γ is a conjunction of propositions, negated propositions and primitive formulas L(Pψ1,..., Pψk)Δd. We have already dealt with propositional formulas. Let ▶Prop γ → (L(Pψ1,..., Pψk) Δ d). Let αn(L(Pψ1,..., Pψk)) = L'(Pa : a ∈ Xn) for some linear operator L'.
L'(Pa : a ∈ Xn) Δ d ∈ C	by (12)
L'(g(a) : a ∈ Xn) Δ d	by (13)
[L'(Pa : a ∈ Xn)]X ,() = L'([Pa]X,() : a ∈ Xn) by linearity of L
= L'(g(a) : a ∈ Xn)	by (18)


	
so [L'(Pa : a ∈ Xn)]X,() Δ d. By lemma 3.7, ▶ L(Pψ1,..., Pψk) = L'(Pa : a ∈ Xn) and by soundness (lemma 3.1) it follows that [L(Pψ1,..., Pψk)]X,() Δ d. Hence X, () |= L(Pψ1,..., Pψk)Δd. This proves (11). Therefore X, () |= γ, so X, () |= φ. 
Conclusion
We have provided a sound and complete set of axioms and rules for a probabilistic path logic, PPL, and we have shown that this logic has the finite model property, thereby solving an open problem in the context of branching probabilistic logics [21]. Based on that completeness proof we could show that the validity problem for PPL has 2-EXPTIME complexity, at worst. We have shown that the fragment of PCTL where only the restricted until is allowed for path formulas, is a proper fragment of PPL. We named this fragment as WPCTL. Thus, the 2-EXPTIME upper bound of PPL is an upper bound of WPCTL, therefore we found a fragment of PCTL which is decidable. The ability of the logic PPL to represent properties of paths rather than mere points makes it more expressive than other probabilistic logics, such as PEL×. We introduced also a formula of PPL which is not expressible in a probabilistic version of CTL.

References
Martin Abadi and Joseph Y. Halpern. Decidability and expressiveness for first-order logics of probability. J. Symbolic Computation, 112(1):1–36, 1994.
Natasha Alechina Logic with Probabilistic Operators. in: A. Nieuwendijk (Ed.), Proc. of the ACOLADE, 1994, 121-138.
Adnan Aziz, Vigyan Singhal, Felice Balarin, Robert K. Brayton, and Alberto L. Sangiovanni-Vincentelli. It usually works: The temporal logic of stochastic systems. In Proc. of Conference on Computer-Aided Verification, 1995.
Bacchus, F. Representing and Reasoning with Probabilistic Knowledge, A Logical Approach to Probabilities. Cambridge, Massachusetts: The MIT Press.
Daniele Beauquier, Alexander Rabinovich, Anatol Slissenko A logic of probability with decidable model checking. J. Log. Comput. 16(4): 461-487 (2006)
Frank Ciesinski, Marcus Groesser. On probabilistic Computation Tree Logic. in LNCS 2925, Validation of Stochastic Systems, page 147-188.
Rance Cleaveland, S. Purushothaman Iyer, Murali Narashima. Probabilistic Temporal Logic via the Modal Mu-Calculus. Theoretical Computer Science Volume 342 , Issue 2-3 (September 2005), Pages: 316 - 350, 2005.
Josee Desharnais, Abbas Edalat, and Prakash Panangaden. Bisimulation for labelled Markov processes. In Proceedings of the 12th Symposium on Logic in Computer Science 1997, pages 149158.
M. Fattorosi-Barnaba, G. Amati Modal operators with probabilistic interpretations. Studia Logica, 4:383-393, 1984.
Yishai A. Feldman. A decidable propositional dynamic logic with explicit probabilities. Information and Control, 63:1138, 1984.
Yishai A. Feldman and David Harel. A probabilistic dynamic logic. Journal of Computer and System Sciences, 28:193215, 1984.
Ronald Fagin and Joseph Y. Halpern. Reasoning about knowledge and probability. Journal of the ACM, 41(2):340–367, 1994.
Ronald Fagin, Joseph Y. Halpern, and Nimrod Megiddo. A logic for reasoning about probabilities.
Information and Computation, 87(1,2):78–128, 1990.


Joseph Y. Halpern. An analysis of first order logics of probability. Artificial Intelligence, 46:311–350, 1990.
J Halpern. The relationship between knowledge, belief, and certainty. Annals of Mathematics and Artificial Intelligence, 4:301–322, 1991.
Hans Hanssohn and Bengt Johnsson. A logic for reasoning about time and reliability. Formal Aspects of Computing, 6(5):512–535, 1994.
Barteld Kooi. Knowledge, chance, and change. PhD thesis, University of Amsterdam, 2003, 2003.
Dexter Kozen. Semantics of probabilistic programs. Journal of Computer and System Sciences, 22:328– 350, 1981.
Dexter Kozen. A probabilistic PDL. Journal of Computer and System Sciences, 30:162–178, 1985.
P. Mateus and A. Sernadas. Weakly complete axiomatization of exogenous quantum propositional logic. Information and Computation 204 (2006)
Ognjanovic Zoran	Discrete Linear-time Probabilistic Logics: Completeness, Decidability and Complexity. Journal of Logic Computation, Vol. 16, No. 2, 257–285, 2006.
J van Benthem. Conditional probability and update logic. Journal of Logic, Language and Information, 12: 409-421, 2003
W. van der Hoek Modalities for reasoning about knowledge and quantities. Ph.D. thesis, Free University of Amsterdam.
