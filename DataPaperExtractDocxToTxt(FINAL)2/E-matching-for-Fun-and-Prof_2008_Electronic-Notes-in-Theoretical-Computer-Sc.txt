Electronic Notes in Theoretical Computer Science 198 (2008) 19–35	
www.elsevier.com/locate/entcs


E-matching for Fun and Profit
Micha-l Moskal1 ,2	Jakub L- opuszan´ski3
Institute of Computer Science University of Wroc-law
Wrocl-aw, Poland
Joseph R. Kiniry4
University College Dublin Dublin, Ireland

Abstract
Efficient handling of quantifiers is crucial for solving software verification problems. E-matching algorithms are used in satisfiability modulo theories solvers that handle quantified formulas through instantiation. Two novel, efficient algorithms for solving the E-matching problem are presented and compared to a well-known algorithm described in the literature.
Keywords: E-matching, quantifier instantiation, SMT.


Motivation
Satisfiability Modulo Theories (SMT) solvers usually operate in the quantifier- free fragments of their respective logics. Yet program verification problems often require expressiveness and flexibility in extending the underlying back- ground theories with universally quantified axioms. The typical solution to this problem is to generate ground instances of the quantified subformulas

1 Partially supported by Polish Ministry of Science and Education grant 3 T11C 042 30.
2 Email: mjm@ii.uni.wroc.pl
3 Email: jlo@ii.uni.wroc.pl
4 Email: kiniry@acm.org


1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.078

during the course of the proof search and hope that the particular instances generated are the ones required to prove unsatisfiability.
As an example, consider the following formula, which we try to satisfy modulo linear arithmetic and uninterpreted function symbols theories:
P (f (42)) ∧ ∀x. P (f (x)) ⇒ x < 0 If the prover were able to guess the implication:
(∀x. P (f (x)) ⇒ x < 0) ⇒ P (f (42)) ⇒ 42 < 0
then, by boolean unit resolution (with the currently known facts P (f (42)) and
∀x. P (f (x)) ⇒ x < 0), the prover would try to assert 42 < 0, which would cause contradiction in the linear arithmetic decision procedure.
The tricky part is how to figure out which instances are going to be useful. A well-known [7] solution is to designate subterms occurring in the quantified formula called triggers, and only add instances that make those subterms equal to ground subterms that are currently being considered in the proof. In our example one such trigger is P (f (x)), which works as expected.
However it is often not enough to consider only syntactic equality. If we modify our example a little bit:
a = f (42) ∧ P (a) ∧ ∀x. P (f (x)) ⇒ x < 0
then our choice of trigger no longer works. We could use a less restrictive trigger (namely f (x)), but such a trigger leads to generating excessive, irrel- evant instances, which reduces the efficiency of the prover. We therefore use a different technique: instead of using syntactic equality, use the equality re- lation induced by the current context 5 . For example: in the context P (a), a = f (42) the substitution [x := 42] makes the term P (f (x)) equal to P (a).
Because we do not treat boolean formulas as terms, it is sometimes not possible to designate a single trigger containing all the variables that are quan- tified. A classical example is the transitivity axiom. In such a case we use a multitrigger, which is a set of triggers, hopefully sharing variables, that are supposed to match simultaneously.
There are two remaining problems here: identifying the set of triggers for a given formula, and identifying the substitutions that make the trigger

5 SMT solvers usually refute a formula ψ by refuting every boolean assignment to literals of ψ that make ψ true. The term “current context” refers to such an assignment (which can be partial).

equal to some ground term. As for the first problem, it is possible to apply heuristics 6 , as well as ask the user to provide the triggers. The second problem is E-matching. We present a well-known algorithm for solving the E-matching problem (Sect. 3), introduce two other, efficient algorithms (Sect. 4 and 5) and compare them to the well-known one.

Definitions
Let V be the infinite, enumerable set of variables. Let Σ be the set of function and constant symbols. Let T be the set of first order terms constructed over Σ and V.
A substitution is a function σ : V → T that is not the identity only for a finite subset of V. We identify a substitution with its homomorphic extension to all terms (i.e., σ : T → T ). Let S be the set of all substitutions.
We will use letters x and y, possibly with indices for variables, f and g for function symbols, c and d for constant symbols (functions of arity zero), σ and ρ for substitutions, t for ground terms, and p for possibly non-ground terms. We will use the notation [x1 := t1,... , xn := tn] for substitutions, and σ[x := t] for a substitution augmented to return t for x.
An instance of an E-matching problem 7 consists of a finite set of active ground terms A ⊆ T , a relation =∼g ⊆ A × A, and a finite set of non-variable, non-constant terms p1,... , pn, which we call the triggers. Let ∼= ⊆ T × T be the smallest congruence relation over Σ containing ∼=g. Let root : T → T be a function 8 such that:
(∀t, s ∈ T . root(t)= root(s) ⇔ t ∼= s) ∧ (∀t ∈ T . root(t) ∼= t) The solution to the E-matching problem is the set:


T =  σ 
∃t1,... , tn ∈ A. σ(p1) =∼ t1 ∧ ... ∧ σ(pn) ∼= tn,
∀x ∈ V. σ(x)= root(σ(x))



6 Some heuristics are described in the Simplify technical report [7].
7 In the automated reasoning literature, the term E-matching usually refers to a slightly different problem, where A is a singleton and ∼= is not re- stricted to be finitely generated [15]. On the other hand the Simplify technical report [7] as well as the recent Z3 paper [6] use the term E-matching in the sense defined above.
8 Such a function exists by virtue of ∼= being an equivalence relation, and is provided by the typical data structure used to represent ∼=, namely the E-graph (see Simplify technical report [7] for details on E-graph).


fun simplif y match([p1,... , pn])
R := ∅
proc match(σ, j)
if j = nil then R := R ∪ {σ}
else case hd(j) of
(c, t) ⇒	/∗ 1 ∗/
if c ∼= t then match(σ, tl(j))
else skip
(x, t) ⇒	/∗ 2 ∗/
if σ(x)= x then match(σ[x := root(t)], tl(j)) else if σ(x)= root(t) then match(σ, tl(j)) else skip
(f (p1,... , pn), t) ⇒	/∗ 3 ∗/
foreach f (t1,... , tn) in A do
if t = ∗∨ root(f (t1,... , tn)) = t then
match(σ, (p1, root(t1)) :: ... :: (pn, root(tn)) :: tl(j))
match([], [(p1, ∗),... , (pn, ∗)])	/∗ 4 ∗/
return R

Fig. 1. Simplify’s matching algorithm
The problem of deciding for a fixed A and ∼=g, and a given trigger, if T /= ∅, is NP-hard [12]. The NP-hardness is why each solution to the problem is inherently backtracking in nature. In practice, though, the triggers that are used are small, and the problem is not the complexity of a backtracking search for a particular trigger, but rather the fact that in a given proof search there are often hundreds of thousands of matching problems to solve.

Simplify’s Matching Algorithm
Simplify is a legacy SMT system, the first one to efficiently combine theory and quantifier reasoning. This combination made it a popular target for various software verification systems. The Simplify technical report [7] describes a recursive matching algorithm simplify match given in Fig. 1. The symbol :: denotes a list constructor, nil is an empty list, [x1,... , xn] is a shorthand for x1 :: ... :: xn :: nil, and [] is an empty (identity) substitution. hd and tl are the functions returning, respectively, head and tail of a list (i.e., hd(x :: y)= x and tl(x :: y)= y). The command skip is a no-op.

The simplify match algorithm maintains the current substitution and a stack (implemented as a list) of (trigger, ground term) pairs to be matched. We refer to these pairs as jobs. Additionally, it uses the special variable ∗ in place of a ground term to say that we are not interested in matching against any specific term, as any active term will do.
We start (line marked /∗ 4 ∗/) by putting the set of triggers to be matched on the stack and then proceed by taking the top element of the stack.
If the trigger in the top element is a constant (/∗ 1 ∗/), we just compare it against the ground term, and if the comparison succeeded, recurse.
If the trigger is a variable x (/∗ 2 ∗/), we check if the current substitution already assigns some value to that variable, and if so, we just compare it against the ground term t. Otherwise, we extend the current substitution by mapping x to t and recurse. Observe that t cannot be ∗ because we do not allow a trigger to be a single variable, and ∗ is only paired with triggers in the initial call, never with subtriggers.
If the trigger is a complex term f (p1,..., pn) (/∗ 3 ∗/), we iterate over all the terms with f in the head (possibly checking if they are equivalent to the ground term we are supposed to match against), construct the set of jobs matching respective children of the trigger against respective children of the ground term, and recurse.
The important invariants of simplify match are: (1) the jobs lists contain stars instead of ground terms only for non-variable, non-constant triggers; (2) all the ground terms t in the job lists satisfy root(t) = t; (3) for all x either σ(x)= x or σ(x)= root(σ(x)).
The detailed discussion of this procedure is given in the Simplify technical report [7].

Subtrigger Matcher
This section describes a novel matching algorithm, optimized for linear trig- gers. A linear trigger is a trigger in which each variable occurs at most once. Most triggers used in the program verification problems we have inspected are linear. The linearity means that matching problems for subterms of a trigger are independent, which allows for more efficient processing.
However, even if triggers are not linear, it pays off to treat them as linear, and only after the matching algorithm is complete discard the resulting sub- stitutions that assign different terms to the same variable. This technique is often used in term indexes [16] used in automated reasoning. The algorithm, therefore, does not require the trigger to be linear.
This matcher algorithm is given in Fig. 2. It uses operations H and H,


fun f etch(S, t, p)
if S = T then return {[p := root(t)]} else if S = ×∧ t ∼= p then return {[]} else if S = × then return ∅
else return S(root(t))
fun match(p)
case p of
x ⇒ return T c ⇒ return × f (p1,... , pn) ⇒
foreach i in 1 ... n do Si := match(pi)	/∗ 1 ∗/
if ∃i. Si = ⊥ then return ⊥	/∗ 2 ∗/
if ∀i. Si = × then return ×	/∗ 3 ∗/ S := {t '→ ∅ | t ∈ A}
foreach f (t1,... , tn) in A do	/∗ 4 ∗/ t := root(f (t1,... , tn))
S := S[t '→ S(t) H (f etch(S1, t1, p1) H ... H f etch(Sn, tn, pn))]
if ∀t. S(t)= ⊥ then return ⊥
else return S

fun topmatch(p)	/∗ 5 ∗/ S := match(p)
return .t∈A S(t)
fun subtrigger match([p1,... , pn])
return topmatch(p1) H ... H topmatch(pn)

Fig. 2. Subtrigger matching algorithm








which are defined on sets of substitutions:


A H B = {σ ⊕ ρ | σ ∈ A, ρ ∈ B, σ ⊕ ρ /= ⊥}
A H B = A ∪ B
σ ⊕ ρ = ⎧⎨ ⊥	when Ex. σ(x) /= x Λ ρ(x) /= x Λ σ(x) /= ρ(x)
⎩ σ · ρ otherwise
σ · ρ(x) = ⎨ σ(x) when σ(x) /= x
⎩ ρ(x) otherwise
H returns a set of all possible non-conflicting combinations of two sets of sub- stitutions. H sums two such sets. The next section shows an implementation of these operations that does not use explicit sets.
The match(p) function returns the set of all substitutions σ, such that σ(p) =~ t, for a term t ∈ A, categorized by root(t). More specifically, match returns a map from root(t) to such substitutions, or one of the special symbols T, ⊥, ×. Symbol T means that p was a variable x, and therefore the map is: {t '→ {[x := t]} | t ∈ A, root(t) = t}, symbol ⊥ represents no matches (i.e., {t '→ ∅ | t ∈ A, root(t)= t}), and × means p was ground, so the map is
{root(p) '→ {[]}} ∪ {t '→ ∅ | t ∈ A,t = root(t),t /= p} 9 .
The only non-trivial control flow case in the match function is the case of a complex trigger f (p1,... , pn), which works as follows:
/∗ 1 ∗/ recurse on subtriggers. Conceptually, we consider the subtriggers to be independent of each other (i.e., f (p1,..., pn) is linear). If they are, how- ever, dependent, then the H operation filters out conflicting substitutions.
/∗ 2 ∗/ check if there is any subtrigger that does not match anything, in which case the entire trigger does not match anything.
/∗ 3 ∗/ check if all the children of f (p1,... , pn) are ground, in which case
f (p1,... , pn) is ground as well.
/∗ 4 ∗/ otherwise we start with an empty result map S and iterate over all terms with the correct head symbol. For each such term f (t1,... , tn), we combine (using H) the already present results for root(f (t1,... , tn)) with results of matching pi against ti. The fetch function is used to retrieve results of subtrigger matching by ensuring the special symbols are treated as the maps they represent.

9 Here we assume all the ground subterms of triggers to be in A. This is easily achieved and does not affect performance in our tests.










  

Fig. 3. Example of s-tree operations
Finally (/∗ 5 ∗/) the topmatch function just collapses the maps into one big set.
S-Trees
This section introduces a new data structure, s-tree, which is used to com- pactly represent sets of substitutions, so they can be efficiently manipulated during the matching.
The s-trees data structure itself can be viewed as a special case of substi- tution trees used in automated reasoning [16] with rather severe restrictions on their shape. We, however, do not use the trees as an index and, as a con- sequence, require a different set of operations on s-trees than those defined on substitution trees.
S-trees require a strict, total order ≺ ⊆ A×A and are defined inductively:
(1) ϵ is an s-tree; (2) if T1,..., Tn are s-trees and t1,... , tn are ground terms, then the pair x D ([(t1, T1),... , (tn, Tn)]) is an s-tree.
The invariant of the s-tree data structure is that in each node the term t1,... , tn are sorted according to ≺ (i.e. for all i and j, i < j ⇒ ti ≺ tj) 10 , and that there exists a sequence of variables x1 ... xk such that the root has the form x1 D (.. .) and each node (including the root) has the form:

10 This invariant is employed in implementation of the H operator.

xi D ([(t1, xi+1 D (.. .)),... , (tn, xi+1 D (.. .))]) or
xk D ([(t1, ϵ),... , (tn, ϵ)])
for some n, t1,... , tn and 1 ≤ i < k. In other words, the variables at a given level of a tree are the same.
The yield function maps a s-tree into the set of substitutions it is intended to represent.


yield(ϵ) = {[]}
yield(x D ([(t , T ),... , (t , T )])) = ⎧⎪⎨σ[x := t ]

i ∈ {1,..., n},
σ ∈ yield(Ti)
⎫⎪⎬

⎪⎪⎩	σ(x)= x V σ(x)= ti ⎪⎪⎭
Example s-trees are given in Fig. 3. The trees are represented as ordered di- rected acyclic graphs with aggressive sharing. An s-tree xD([(t1, T1),... , (tn, Tn)]) has the label x on the node, ti label the edges and each edge leads to another tree Ti. The ground symbol corresponds to the empty tree ϵ. E.g., the middle bottom one represents x D ([(a, y D ([(f (c), ϵ), (f (d), ϵ)])), (c, y D ([(c, ϵ)]))]),
which yields {[x := a, y := f (c)], [x := a, y := f (d)], [x := c, y := c]}. The ordering of terms used in the example is a < b < c < d < f (a) < f (c) < f (d). We now define an analogous for s-trees of the operators H and H we defined earlier for sets of substitutions. Formally, the operators are defined so that
yield is a homomorphism from s-trees to sets of substitutions.
ϵ H T = T
x D ([(t1, T1),... , (tn, Tn)]) H T = x D ([(t1, T1 H T ),... , (tn, Tn H T )])
ϵ H ϵ = ϵ
x D (X) H x D (Y ) = x D (merge(X, Y ))
⎧ (t, T H T ') :: merge(X, Y )	if t = t' merge((t, T ) :: X, (t',T ') :: Y ) = ⎨ (t, T ) :: merge(X, (t',T') :: Y ) if t < t'
⎪ (t',T') :: merge((t, T ) :: X, Y ) if t' < t 
merge(nil, X) = X merge(X, nil) = X
The H corresponds to stacking trees one on top of another, while H does a








Fig. 4. Example of an index for flat triggers with g in head
recursive merge. Example applications are given in Fig. 3.
The precondition of the H operator is that the operands have the same shape, meaning the x1 ... xk sequence from the invariant is the same for both trees; otherwise, H is undefined. This precondition is fulfilled by the subtrigger matcher, since it only combines trees resulting from matching of the same trigger, which means the variables are always accessed in the same order.
To change subtrigger match to use s-trees, we need to change the fetch
function, to return p D ([(root(t), ϵ)]) instead of [p := root(t)], ϵ instead of
{[]} and x D (nil) for some variable x instead of ∅. After this is done we only call yield at the very end, to transform an s-tree into a set of substitutions.

Flat Matcher
During performance testing, we found that most triggers shared the head sym- bol and matching them was taking a considerable amount of time. Moreover, the triggers had a very simple form: f (x, c) 11 . This form is a specific exam- ple of something we call flat triggers. A flat trigger is a trigger in which each variable occurs at most once and at a depth of one.
Flat triggers with a given head can be matched all at once by constructing a tree that indexes all the triggers with the given function symbol in the head. Such a tree can be viewed as a special kind of a discrimination tree [16], where we consider each child of the pattern as a constant term, instead of traversing it pre-order. Unlike in discrimination trees used for matching our index has non-ground terms and queries are ground.
We assume, without loss of generality, each function symbol to have only one arity. A node in the index tree is either a set of triggers {p1,... , pn}, or a set of pairs {(t1, I1),... , (tn, In)}, where each of the ti is a ground term or a special variable ∗, and Ii are index trees.
We call (t1,... , tn, p)a path in I if and only if: (1) n =0 and p ∈ I; or (2) (t1, I') ∈ I and (t2,... , tn, p) is a path in I'.

11 The	actual	function	symbol	was	a	subtyping	predicate	in ESC/Java2’s [11] Simplify-based object logic.


fun topmatch(p')
if p is flat then
let f (p1, ..., pn)= p
If := index for all triggers with head f
foreach p in If do Sp := ∅
foreach f (t1,... , tn) in A do
foreach p '→ T in match'(f (t1,... , tn), [t1,... , tn], If ) do
Sp := Sp H T
return Sp'
else
S := match(p')
return .t∈A S(t)

Fig. 5. Flat matcher


Let star(x)= ∗ for a variable x and star(t)= t, for any non-variable term
t. We say that I indexes a set of triggers Q if for any f (p1,... , pn) ∈ Q there exists a path (star(p1),... , star(pn),f (p1,... , pn)) in I, and for every path there exists a corresponding trigger.
Given an index I, we find all the triggers that match the term f (t1,..., tn) by calling match'(f (t1,... , tn), [t1,... , tn], {I}), where match' is defined as follows:
match'(t, [t1,... , tn], A)= 
match'(t, [t2,... , tn], {I' | I ∈ A, (p, I') ∈ I, p ~= t1 V p = ∗})
match'(f (t1,..., tn), nil, A)= 
{f (p1,... , pn) '→ Hi=1...n, pi∈V [pi := root(ti)] | I ∈ A, f (p1,... , pn) ∈ I}
The algorithm works by maintaining the set of trigger indices A containing triggers that still possibly match t. At the bottom of the tree we extract the children of t corresponding to variables in the trigger. We only consider position at which the trigger has variables, not ground terms (the condition pi ∈ V).
A flat-aware matcher is implemented by replacing the topmatch function from Fig. 2 with the one from Fig. 5. The point of using it, though, is to cache If and Sp across calls to subtrigger match.

Implementation and Experiments
We have implemented all three algorithms inside the Fx7 SMT solver 12 . Fx7 is implemented in the Nemerle [13] language and runs on the .NET platform. In each case the implementation is highly optimized and only unsatisfactory results with the simplify match algorithm led to designing and implementing the second and the third algorithm.
The implementation makes heavy use of memoization. Both terms and s-trees use aggressive (maximal) sharing. The implementations of H and H ex- ploit this sharing, by memoizing results to avoid processing the same (shared) subtree more than once.
An important point to consider in the design of matching algorithms is incrementality. The prover will typically match, assert some facts, and then match again. The prover is then interested only in receiving the new results. The Simplify technical report [7] cites two optimizations to deal with incre- mentality. We have implemented one of them, the mod-time optimization, in all three algorithms. The effects are mixed, mainly because our usage patterns of the matching algorithm are different than those of Simplify: we generally change the E-graph more between matchings due to our proof search strategy. To achieve incrementality we memoize s-trees returned on a given proof path and then use the subtraction operation on s-trees to remove substitutions that had been returned previously. The subtraction on s-trees corresponds to
set subtraction and its implementation is very similar to the one of H. Another fine point is that the loop over all active terms in the imple-
mentations of all three algorithms skips some terms: if we have inspected
f (t1,... , tn) then we skip f (t' ,... , t' ) given that ti ~= t' for i = 1 ... n. Fol-
1	n	i
lowing work on fast, proof-producing congruence closure [14], we encode all
the terms using only constants and a single binary function symbol ·(.. .). E.g., f (t1,... , tn) is represented by ·(f, ·(t1,... ·(tn−1, tn))). Therefore the loop over active terms is skipped when root(·(t1,... · (tn−1, tn))) was already visited.
Yet another issue is that we map all the variables to one special symbol during the matching, do not store the variable names in s-trees, and only introduce the names when iterating the trees to get the final results (inside the yield function). This allows for more sharing of subtriggers between different triggers and is fairly common practice in term indexing.
The tests were performed on a 1 GHz Pentium III box with 512 MiB of RAM running Linux and Nemerle r7446 on top of Mono 1.2.3. The memory used was always under 200 MiB. We ran the prover on a randomly selected set of verification queries generated by the ESC/Java [10] and Boogie [2] tools.

12 Available online at http://nemerle.org/fx7/.

The benchmarks are now available as part of SMT-LIB [17].
The subtrigger matcher helps speed up matching by around 20% in the Boogie benchmarks and around 50% in the ESC/Java benchmarks. The flat matcher is around 2 times faster than Simplify’s matcher in the Boogie bench- marks and around 10 times in the ESC/Java benchmarks. The detailed results are given in the Appendix A.
Now we give some intuitions behind the results. For example, consider the trigger f (g1(x1),... , gn(xn)). If each of gi(xi) returns two matches, except for the last one which does not match anything, the subtrigger matcher exits after O(n) steps, while the Simplify matcher performs O(2n) steps. Even when gn(xn) actually matches something (which is more common), the subtrigger algorithm still performs O(n) steps to construct the s-tree and only performs O(2n) steps walking that tree. These steps are much cheaper (as the tree is rather small and fits in the CPU cache) than matching the gis several times, which Simplify’s algorithm does. The main point of the subtrigger matcher is therefore not to repeat work for a given (sub)trigger more than once.
The benefits of the flat matcher seem to be mostly CPU cache-related. For example, a typical problem might have one hundred triggers with head f , and one thousand ground terms with the head f . The flat matcher processes a data structure (of size one hundred) one thousand times, while the subtrigger matcher (and also Simplify’s matcher) processes a different data structure (of size one thousand) one hundred times. Consequently, given that these data structures occupy a considerable amount of memory, frequently the smaller data structures in the former case fit the cache, while the larger ones in the latter case do not.

Conclusions and Related Work
We have presented two novel algorithms for E-matching. They are shown to outperform the well-known Simplify E-matching algorithm.
The E-matching problem was first described, along with a solution, in the Simplify technical report [7]. We know several SMT solvers, like Zap [1], CVC3 [4], Verifun [9], Yices [8] and Ergo [5] include matching algorithms, though there seem to be no publications describing their algorithms. Specif- ically, Zap uses a different algorithm that also relies on the fact of triggers being linear and uses a different kind of s-trees. Zap, however, does not do anything special about flat triggers.
In a recent paper [6] on Z3 (a rewrite of the Zap prover), a way of compiling patterns into a code tree that is later executed against ground terms is defined. Such a tree is beneficial if there are many triggers that share the top part of

triggers. We, on the other hand, exploit sharing in the bottom parts of triggers, and the flat matcher handles the case of simple triggers that share only the head symbol. The Z3 authors also propose an index on the ground terms that is used to speed up matching in an incremental usage pattern. Such an index could perhaps be used also with our approach. Of course, the usefulness of all these techniques largely depends on benchmarks and the particular search strategy employed in an SMT solver.
During the 2007 SMT competition [3] there were four solvers participating in the Arithmetic, Uninterpreted Functions, Linear Integer Arithmetic and Arrays (AUFLIA) division. The AUFLIA division includes software verifica- tion problems and is the only one involving heavy use of quantifier reasoning. Z3 was first and Fx7 was second, with the same number of solved benchmarks but much worse run time. Both solvers used improved matching algorithms, while other participants (CVC3 and Yices) did not, which is some indication of importance of E-matching in this kind of benchmarks.
Some of the problems in the field of term indexing [16] in saturation-based theorem provers are also related. As mentioned earlier, our work uses ideas similar to substitution trees and discrimination trees. It seems to be the case, however, that the usage patterns in the saturation provers are different than those in SMT solvers. Matching SMT solvers must deal with several orders of magnitude fewer non-ground terms, a similar number of ground terms, but the time constraints are often much tighter. This different set of constraints and goals consequently leads to the construction of different algorithms and data structures.
We would like to thank Mikol´aˇs Janota for his comments regarding this paper.
This work is being supported by the European Project Mobius within the frame of IST 6th Framework, national grants from the Science Foundation Ireland and Enterprise Ireland, and by the Irish Research Council for Science, Engineering and Technology. This paper reflects only the authors’ views and the Community is not liable for any use that may be made of the information contained therein. This work is partially supported by Science Foundation Ireland under grant number 03/CE2/I303-1, “LERO: the Irish Software En- gineering Research Centre.”

References
Ball, T., S. K. Lahiri and M. Musuvathi, Zap: Automated theorem proving for software analysis., in: G. Sutcliffe and A. Voronkov, editors, LPAR, Lecture Notes in Computer Science 3835 (2005), pp. 2–22.

Barnett, M., K. Leino and W. Schulte, The Spec# programming system: An overview, in:
Proceeding of CASSIS 2004, LNCS 3362 (2004).
Barrett,  C.,  L.  de  Moura  and  A.  Stump,  Design  and  Results  of  the 3rd Satisﬁability Modulo Theories Competition (SMT-COMP 2007) (2007), to appear, also http://www.smtcomp.org/2007/.
Barrett, C. and C. Tinelli, CVC3, in: W. Damm and H. Hermanns, editors, CAV, LNCS 4590
(2007), pp. 298–302.
Conchon, S., E. Contejean, J. Kanig and S. Lescuyer, Lightweight Integration of the Ergo Theorem Prover inside a Proof Assistant, in: Second Automated Formal Methods workshop series (AFM07), Atlanta, Georgia, USA, 2007.
de Moura, L. M. and N. Bjørner, Efficient E-matching for SMT solvers, in: F. Pfenning, editor,
CADE, LNCS 4603 (2007), pp. 183–198.
Detlefs, D., G. Nelson and J. B. Saxe, Simplify: A theorem prover for program checking, Technical Report HPL-2003-148, HP Labs (2003).
Dutertre, B. and L. M. de Moura, A fast linear-arithmetic solver for DPLL(T)., in: T. Ball and R. B. Jones, editors, CAV, LNCS 4144 (2006), pp. 81–94.
Flanagan, C., R. Joshi and J. B. Saxe, An explicating theorem prover for quantiﬁed formulas, Technical Report 199, HP Labs (2004).
Flanagan, C., K. Leino, M. Lillibridge, G. Nelson, J. B. Saxe and R. Stata, Extended static checking for Java, in: ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI’2002), 2002, pp. 234–245.
Kiniry, J. R. and D. R. Cok, ESC/Java2: Uniting ESC/Java and JML: Progress and issues in building and using ESC/Java2 and a report on a case study involving the use of ESC/Java2 to verify portions of an Internet voting tally system, in: Construction and Analysis of Safe, Secure and Interoperable Smart Devices: International Workshop, CASSIS 2004, LNCS 3362, 2005.
Kozen, D., Complexity of ﬁnitely generated algebras, in: Proceedings of the 9th Symposium on Theory of Computing, 1977, pp. 164–177.
Moskal, M., K. Skalski, P. Olszta et al., Nemerle programming language, http://nemerle.org/.
Nieuwenhuis, R. and A. Oliveras, Proof-Producing Congruence Closure, in: J. Giesl, editor, 16th International Conference on Term Rewriting and Applications, RTA’05, Lecture Notes in Computer Science 3467 (2005), pp. 453–468.
Plotkin, G. D., Building-in equational theories, in: D. Michie and B. Meltzer, editors, Machine Intelligence (1972), pp. 73–90.
Ramakrishnan, I. V., R. C. Sekar and A. Voronkov, Term indexing., in: J. A. Robinson and
A. Voronkov, editors, Handbook of Automated Reasoning, Elsevier and MIT Press, 2001 pp. 1853–1964.
Ranise, S. and C. Tinelli,  The Satisﬁability Modulo Theories Library (SMT-LIB),
http://www.smt-lib.org (2007).

A  Detailed Experimental Results
The first column lists the benchmark name, the second, third and fourth columns are the average times spent matching a single trigger during proof search for a given benchmark. The times are given in microseconds. The second column refer to the subtrigger matcher (Fig. 4), the third one for

the subtrigger matcher combined with the flat matcher (Fig. 5) and the last column refers to the Simplify matcher (Fig. 3).


Benchmark name	Subtrig.	Subtrig.
+ Flat
Simpl.






Benchmark name	Subtrig.	Subtrig.
+ Flat
Simpl.


