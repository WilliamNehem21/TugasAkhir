	Electronic Notes in Theoretical Computer Science 212 (2008) 87–102	
www.elsevier.com/locate/entcs

Proof Search and Counter Model of Positive Minimal Predicate Logic
Tao Xue1 ,2	Qichao Xuan3
State Key Laboratory of Computer Science Institute of Software Chinese Academy of Science Beijing, China

Abstract
This paper presents an algorithm of proof search for positive formulas in minimal predicate logic. It is based on the LJB deduction system introduced in[2]. The algorithm returns a deduction tree, and hence a proof, when the formula is provable, and a counter-model will be constructed when the formula is unprovable. The soundness and the completeness are proved.
Keywords: Kripke model, LJB, counter model, proof search


Introduction
To find a proof for a logical formula is a classical subject in mathematic logic, and proof search is a method with a long history to deal with the problem. It is used in a variety of system of logic, including classical, intuitionistic, linear and modal systems, at the propositional, first- and higher-order levels. There are many researches focusing on constructive logics like intuitionisitc logic, mainly because of the researches in type theory and the relation between intuitionistic logic and type theory through Curry-Howard’s isomorphism.
Although proof-search is a good method to find out the proof, when a failure comes, we lack an intuition view for the unprovable. However, Kripke model can be a good counter model to explain the unprovable more intuitively, and usually, the trace of the failure contains enough information for the counter model construc- tion. Sequent calculus with multiple conclusions is a standard method to construct

1 This work is partially supported by NSFC 60673045, NSFC major research program 60496321 and NSFC 60721061.
2 Email: xuet@ios.ac.cn
3 Email: xuanqichao-1982@163.com

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.055

counter-model, and there has been many works on it. In [3] Roy Dyckhoff gives a contraction-free sequent calculus LJT in which proof search does not loop. Then Roy Dyckhoff and Pinto used a variant of LJT and defined a new calculus CRIP to capture unprovablity in [6]. They used LJT to generate proof and CRIP to con- struct counter-model. In [8], the system Porgi can return either a proof deduction or a Kripke counter model, but it also used LJT to get the proof and CRIP to construct counter model, so it still needed to deal the provable and unprovable in separate algorithm. Hirokawa and Nagano[5] showed a different method to get proof or counter-model in long normal form proof, they used only one algorithm for both proof and counter-model generating. Moreover, this algorithm showed an that the structure of counter-model is in accordance with the structure of proof deduction. All the works up are in propositional logic, and we find seldom on predicate logic.
Mainly because the provability of the logic system been considered is required, but provability in minimal predicate logic is not decidable. However in [2], Dowek and Jiang proved the decidability of positive fragment of minimal predicate logic and proposed a proof search algorithm base on special sequent calculus called LJB.
In this paper, we use the LJB deduction system, and extent the algorithm of constructing counter model in [5]. Given a closed positive formula in minimal predicate logic, we introduce an algorithm to get proofs to the formulas which are provable and get counter-models with Kripke structure to the formulas which are not provable. Like in [5], our algorithm shows a relation between the structure of proof and structure of counter model. We don’t consider the efficiency and a loop-checking is needed.
Our algorithm firstly search the proof backward using the rules in the LJB system. If the formula is provable, the search will finally get a proof. If it is unprovable, the search will stop in a stage where we can not use any rule to search upwards, or we find a loop. In this case, we start to construct the counter-model from the leaves to the root. We assign every variable a different constant, give the atomic formulas of every leaf an original assignment, and construct model with the subnodes for every internal node.
Section 2 will give some basic knowledge for the whole paper. In section 3, the algorithm of proof search and counter-model construction is introduced, and two small examples are given. In section 4, we prove the correctness of the counter model construction. Finally we give a proof to the soundness and completeness in the last section.



Preliminaries

In this section, we call the definitions and some properties of positive formula, LJB deduction system in [2], and the Kripke model in [7]. There are some differences in notation and presentation. Further details can be got in the references.

Positive formula
In minimal predicate logic, the syntax of terms and formulas are given by
t = x | f (t,... , t)
A = P (t,... , t) | (A → A) | ∀xA
Superfluous parentheses are omitted as usual. Free and bound occurrences of variables in a formula are defined as usual.
A context is a finite multiset of formula. A sequent Γ ▶ A is a pair formed by a context Γ and a formula A.
Definition 2.1 (Free and bound variables of a context) Free and bound vari- ables of a context are defined by
FV ({A1,... , An})= FV (A1) ∪ ... ∪ FV (An).
BV ({A1,... , An})= BV (A1) ∪ ... ∪ BV (An).
A formula in minimal predicate logic is positive if all its universal quantifier occurrences are positive. More precisely, the set of positive and negative formula are define by induction as follows.
Definition 2.2 (Positive and negative formulas and sequents)
An atomic formula is positive and negative,
a formula of the form A → B is positive(resp. negative) if A is negative(resp. positive) and B is positive(resp. negative),
a formula of the form ∀xA is positive if A is positive,
a sequent A1,... , An ▶ B is positive if A1,... , An are negative and B is positive.
Note 1 A negative formula has the form A1 → ... → An → P where P is an atomic formula, A1,... , An are positive formulas, and we note T (A)= P

LJB: a sequent calculus with brackets
When we have a sequent of the form Γ ▶ ∀xA, we usually need to rename the variable x with a variable x' that is free neither in Γ nor in A in order to apply the R∀ rule. But here we take another sequent calculus introduced in [2], where, instead of renaming the variable x ,we bind x and all the other variables bound in A, in the context Γ with brackets. And obtain the sequent [Γ]V ▶ A, V is the set of all bound variables in ∀xA.
Definition 2.3 (LJB-contexts and items)LJB-contexts and items are mutually inductively defined as follows.
A LJB-context Γ is a finite multiset of items I1,... , In,
an item I is either a formula or an expression of the form [Γ]V where V is a set of vriables and Γ is a context.

In the item [Γ]V the variables of V are bound by the symbol [ ].
Definition 2.4 (Free and bound variables of a LJB-context and of an item)The set of free variables of a LJB-context is defined by
FV ({I1,... , In})= FV (I1) ∪ ... ∪ FV (In),
and the set of free variables of an item by
FV (A)= FV (A),
FV ([Γ]V )= FV (Γ)\V .
the set of bound variables of a LJB-context is defined by
BV ({I1,... , In})= BV (I1) ∪ ... ∪ BV (In),
and the set of free variables of an item by
BV (A)= BV (A),
BV ([Γ]V )= BV (Γ) ∪ V .
A LJB-sequent Γ ▶ A is a pair formed by a LJB-context Γ and a formula A.
The system LJB is formed by two sets of rules: the usual deduction rules and additional transformation rules. The transformation rules deal with bracket ma- nipulation. They form a terminating rewrite system. The first transformation rule allows to replace an item of the form [I, Γ]V by two items I and [Γ]V provided no free variable of I is in V . The second rule allows to remove trivial items. The third rule to replace two identical item by one.
Definition 2.5 (Cleaning LJB-contexts) We consider the following rules sim- plifying LJB-contexts, where I is a item and Γ is a LJB-context.
[I, Γ]V −→ I, [Γ]V ,	if FV (I) ∩ V = ∅
[ ]V −→ ∅
II −→ I
As usual the rules may be applied anywhere in a LJB-context.
Proposition 2.6 (Termination) The rewrite system of Deﬁnition 2.5 terminates.
Note 2 : We take Γ ↓ as the normal form of a context Γ with the rules.
Definition 2.7 (LJB , A sequent calculus with brackets)
Γ' ▶ A1 ...  Γ' ▶ An
Γ ▶ P	L →


where
Γ= Γ1, [Γ2, [... Γi−1, [Γi, A1 → ... → An → P ]Vi−1 .. .]V2 ]V1
Γ = ([... [[Γ1]V1 , Γ2]V2 ,... , Γi−1]Vi−1 , Γi, A1 → ... → An → P ) ↓

P is atomic and has no free variable in V1 ∪ V2 ∪ ... ∪ Vi−1
[Γ]V ↓ ▶ A R∀
Γ ▶ ∀xA

where V is the set of all variables bound in ∀xA
(Γ, A) ↓ ▶ B
Γ ▶ A → B R →

Kripke model
Definition 2.8 (Kripke frame) A Kripke frame for intuitionistic predicate logic is a triple < W, R,D >, where W is a non-empty set, R is a binary reflexive and transition relation on W , D is a domain function assigning to every w ∈ W a non-empty set D(w) expanding with respect to R: wRw' implies D(w) ⊆ D(w').
Every world w of a Kripke frame < R, W,D > corresponds an extension Lw of the language of predicate logic obtained by adding constants for all elements of the domain D(w). We identify such a constant with the corresponding element of D(w). Hence sentences of Lw are formulas containing no free occurrences of variables but possibly containing objects of D(w).
Definition 2.9 (Kripke model) A Kripke model for intuitionistic predicate logic is a 4-tuple < W, R, D,V >, where < W, R,D > is a Kripke frame and V assigns a function V (f ) to every function symbol f and a predicate symbol V (P ) to every predicate P , and the following condition are satisfied.
For all w ∈ W , d1,... , dn ∈ D(w) (and n-ary f ,P ):
V (f )(d1,... , dn, w) ∈ D(w) and V (P )(d1,... , dn, w) ∈ {0, 1}
wRw' implies V (f )(d1,... , dn, w')= V (f )(d1,... , dn, w)
wRw' and V (P )(d1,... , dn, w) = 1 implies V (P )(d1,... , dn, w)= 1
Definition 2.10 (values in Kripke model)
The value V (t, w) ∈ D(w) of a constant term t ∈ D(w): Constants: V (d, w)= d if d ∈ D(w)
Composite terms: V (f (t1,... , tp), w)= V (f )(V (t1, w),... ,V (tp, w), w)
The value V (A, w) ∈ {0, 1} for a formula A in w. V (P (t1,... , tn), w)= V (P )(V (t1, w),... ,V (tn, w), w)
B → C : V (B → C, w) = 1 iff for all w' with wRw' we have V (B, w') = 1 implies
V (C, w')= 1.
∀xB : V (∀xB) = 1 iff for all w' with wRw' we have V (B[x/d], w') = 1 for all
d ∈ D(w').
We say a formula A is valid or |= A , if for every model < W, R, D,V >, every w ∈ W , and every substitution σ = [x1/d1,... , xn/dn] of objects in D(w) for free variables of A, V (Aσ, w)= 1.
Proposition 2.11 (Monotonicity) Assume wRw', then V (A, w) = 1 implies
V (A, w')= 1.
Definition 2.12 (Pointed frame and pointed model) A pointed frame is an ordered 4-tuple < G, W, R,D >, where < W, R,D > is a Kripke frame, G ∈ W and GRw for all w ∈ W . A pointed model is a tuple M=< G, W, R, D,V > where

< G, R, D,V > is a pointed frame and V is a valuation on < W, R,D >. Truth in M is truth in the world G: M |= A iff V (G, A)= 1
Definition 2.13 (Partial order) A binary relation R on a set W is a partial order iff R is reflexive, transitive and antisymmetric.
Proposition 2.14 A formula is valid iff it is true in all pointed models, iff it is true in all pointed models where accessibility relation is a partial order.
Note 3 For a easier writing, in the remain of the article we will use ≤ instead of R, if wRw' then we write w ≤ w' or w' ≥ w. We also write w |= A instead of V (A, w)= 1, and w |= A instead of V (A, w)= 0.
Here we have some other definitions for our model construction
Definition 2.15 (Support sets) Given a Kripke model < W, R, D,V > and a node w ∈ W , then Support assigns a set of atomic formulas to every node w as following Support(w)= {A | w |= A, A is atomic}. And Support(W )= {A | w |= A, A is atomic , ∀w ∈ W }.
Definition 2.16 (Singleton model) A singleton model M with a set of atomic formulas S = {A1,... , An} and domain D0 is a Kripke model < W, R, D,V > such that W = {w} is a singleton set, R is the trivial order wRw, D(w) = D0 , and Support(w)=S.
Definition 2.17 (Joint model) Given Kripke models Mi =< Wi, Ri, Di, Vi >, i ∈
{1,... , n}, the joint model of Mi with respect to Σ is a model M =< W, R, D,V >
such that
W = {w0}∪ W1 ∪ ... ∪ Wn,
w0Ru, ∀u ∈ W ,
D = D1 ∩ ... ∩ Dn,
Support(w0)= Support(W1) ∩ ... ∩ Support(Wn) − Σ. Σ is a set of atomic or an ∅.

Proof search algorithm and counter model construc- tion
In this section we show a proof search algorithm which gives a proof of a given closed positive formula E in LJB when it is provable, or construct an counter model when E is not provable.
First, to the given closed positive formula E, our aim is to search a proof for
▶ E. More generally, we consider the search for a LJB sequent Γ ▶ P , and we use a list of sequent ξ to store the search path for loop checking. The algorithm Search takes a LJB sequent Γ ▶ P and ξ as parameters, and gives a trees of LJB sequents as a result. The tree is called a deduction tree with leaves labeled in three kinds, ”axiom”, ”stop” and ”loop”. If one leaf is label by ”axiom”, it implies all the leaves are labeled by ”axiom”, then the tree is a proof of the sequent and called proof tree.

Else we will get a deduction tree with leaves labeled ”stop” or ”loop”, and we call it a fail tree.
More precisely, we explain how the deduction tree is constructed step by step. A deduction tree is composed inductively by the rules of LJB system, we just make a explanation of rule L → since the cases of other two rules are trivial. Given a sequent Γ ▶ P , P is atomic, there are several choices to use the rule L →(fig.1.a). If there is at least one provable case, suppose case i, then we take all the nodes in this case as the subnodes of Γ ▶ P (fig.1.b). If all the cases are unprovable, that means there is at least one node unprovable in every case. Then from each case we take an unprovable node, and make all these nodes to be subnodes of Γ ▶ P (fig.1.c). Finally, when we come to a node which we can not use any rule on the sequent, we label it ”stop”. Or, when we look up ξ and find the sequent been dealt before, we label it ”loop”. If the sequent can be proved trivially by L →, it will be labeled ”axiom”.







Fig. 1.


Definition 3.1 (Search algorithm) Search(Γ ▶ P ; ξ) is defined inductively as follows:
If P is atomic.
If P ∈ Γ. Then it’s a proof and return a node P ∈ Γ labeled ”axiom”.
If P /∈ Γ.
If Γ ▶ P ∈ ξ. Then it’s not a proof and return a node Γ ▶ P labeled ”loop”.
If Γ ▶ P /∈ ξ.
If Γ does not contain any such formula A, which is bracketed by V and T (A) = P , P has no free variables in V . Then it’s not a proof and return Γ ▶ P labeled ”stop”.
If Γ contains some Ai bracketed by Vi st. T (Ai) = P , P has no free

variables in Vi. Let A1,... , Am be all of such formulas and Ai = Bi
→ ... →

i  → P (1 ≤ i ≤ m). Then for every Ai, Γ can be written as

Γ= Γi , [Γi , [... Γi
, [Γi , Bi → ... → Bi
→ P ] i
.. .] i ] i

1	2	ni−1
ni	1
ni	Vni−1
V2 V1

and we have
Γi = ([... [[Γi ]
i , Γi ]
i ,... Γi
] i	, Γi
, Bi → ... → Bi
→ P ) ↓

V1
V2
ni−1 Vni−1	ni	1	ni

Then by using the algorithm recursively, we have
i = Search(Γi ▶ Bi ;Γ ▶ P + ξ) for 1 ≤ i ≤ m, 1 ≤ k ≤ ni.

If for some i (1 ≤ i ≤ m), all ui ,... , ui
are proofs. Return a proof

1	ni
ui	...	ui
 1	ni
Γ ▶ P
If for each i (1 ≤ i ≤ m), we have some ui (1 ≤ ki ≤ ni) is not a proof.

Return a tree whose root is Γ ▶ P and has all the ui
as subtrees above the root.

If P = ∀xA. We have u = Search([Γ]V ↓ ▶ A, Γ ▶ P ).
If u is a proof, return a proof
u
Γ ▶ P


If u is not a proof, return a tree whose root is Γ ▶ P and has u as subtree above the root.
If P = A → B. We have u = Search(([Γ]V, A) ↓ ▶ B, Γ ▶ P ).
If u is a proof, return a proof
u
Γ ▶ P


If u is not a proof, return a tree whose root is Γ ▶ P and has u as subtree above the root.
Example 3.2 We try to prove the formula
∀x((P (x) → Q(x)) → ∀y(Q(y) → P (x) → Q(x)))

P (x) → Q(x), Q(y),P (x) ▶ P (x) L →
P (x) → Q(x), Q(y),P (x) ▶ Q(x) L →
P (x) → Q(x) ▶ Q(y) → P (x) → Q(x) R → (2)

P (x) → Q(x) ▶ ∀y(Q(y) → P (x) → Q(x)) R∀
▶ (P (x) → Q(x)) → ∀y(Q(y) → P (x) → Q(x)) R →
▶ ∀x((P (x) → Q(x)) → ∀y(Q(y) → P (x) → Q(x))) R∀
Thus, the formula is provable.
If Search(▶ E, nil) returns not a proof but a fail tree t for a given closed positive formula E, we need to construct a counter model. For a counter model, we need only

to get one evidence for uprovable, so we give an assignment to every free variable. For the sake of our assignment, we define a c-substitute to substitute all the free variables in the nodes of the fail tree t with constants from root to leaves, and we assign the variables with fresh constants instead of using brackets so that we can move all the brackets away. The detail is followed.
Definition 3.3 (c-substitute) For the fail tree t, Γ ▶ P is a node of the tree we define the c-substitute of the node by induction on structure.
If Γ ▶ P is the root of t.
The c-substitute of this node is Γ ▶ P .
If Γ ▶ P is a subnode of node Γ0 ▶ A which has c-substitute Σ ▶ A'
If A is atomic.
Then Γ and Γ0 can be written as:
Γ= ([... [[Γ1]V1 , Γ2]V2 ,... , Γi−1]Vi−1 , Γi, B1 → ... → Bi → A) ↓
Γ0 = Γ1, [Γ2, [... Γi, [Γi, B1 → ... → Bn → A]Vi−1 .. .]V2 ]V1
and P = Bj, j ∈ {1,... , n}.
In Σ ▶ A', Bj has been substituted by P ', then the c-substitute of Γ ▶ P is Σ ▶ P '
If A = ∀xP .
A' can be expressed as ∀x'P '. Let a be a fresh constant which is not in Σ ▶ A', the
c-substitute of Γ ▶ P is Σ ▶ P '(x/a).
If A = Q → P
A' can be expressed as Q' → P ', the c-substitute of Γ ▶ P is Σ, Q' ▶ P '.
Next, we come to construct a Kripke model. We start from leaves, and transform them into singleton models. At each inner node, we construct a joint model with the submodels obtained from the subtrees of the node. When there is a leaf of sequent Γ ▶ P labeled with ”loop”, the tree contains another occurrence of Γ ▶ P below the leaf, then we identify all the nodes between the two. Given such a deduction tree t, the following algorithm shows how to generate a model tm as well as the set tl of sequences to tree repetition.
Definition 3.4 (construction of Kripke model, tm and tl)
Given a closed positive formula E, t = Search(▶ E, nil) is a fail tree, we do c- substitute to all nodes in t, and suppose Con(E) is a set of all constants we have used in the c-substitute.
Suppose Γ ▶ P is a node in t, and the c-substitute of Γ ▶ P is Σ ▶ P '.
If P is atomic.
If t is a leaf labeled ”loop” with Γ ▶ P . tm is singleton model with T (Σ)\{P '}, and has Con(E) as its domain, T (Σ) = {T (A)|A ∈ Σ}, tl =Γ ▶ P .
If t is a leaf labeled ”stop” with Γ ▶ P . tm is singleton model with T (Σ), and has Con(E) as its domain, tl = ∅.
If t is the root with subtrees t1,... , tn.
If Γ ▶ P does not occur in any tl, then tm is the joint model of tm,... tm
i	1	n
'	l	l	l
with respect to {P }, t = t1 ∪ ... ∪ tn.
If Γ ▶ P occurs in some tl, then construct a model M which is the joint
model of tm,... , tm with respect to {P '}, tm is obtained from M by identifying all
1	n

the nodes r which satisfy Γ ▶ P ∈ rl in tm. tl = tl ∪ ... ∪ tl \{Γ ▶ P } .
i	1	n
If P = ∀xA, then t has a subtree t1. tm is a joint model of tm with respect to ∅,
and tl = tl .
If P = A → B, then t has a subtree t1. tm is a joint model of tm with respect to
∅, and tl = tl .
For every sequent Γ ▶ P in the deduction tree, and its corresponding world w built from the sequent in the counter model. We say Γ ▶ P and w correspond to each other.
Example 3.5 Let’s try another formula.  For easy reading, we write X, Y, Z
instead of P (X), Q(Y ), R(Z).
∀X(((∀Y ∀Z(((Y → X) → Z) → (Y → Z) → Z)) → X) → X)
Let C(X)= (∀Y ∀Z(((Y → X) → Z) → (Y → Z) → Z)) → X

C(X), [(Y → X) → Z, Y → Z, Y ]YZ , (Y → X) → Z, Y → Z ▶ Z loop
C(X), [(Y → X) → Z, Y → Z, Y ]YZ ▶ ((Y → X) → Z) → (Y → Z) → Z R →
C(X), [(Y → X) → Z, Y → Z, Y ]YZ , (Y → X) → Z, Y → Z, Y ▶ ∀Y ∀Z(((Y → X) → Z) → (Y → Z) → Z) R∀

	C(X), [(Y → X) → Z, Y → Z, Y ]YZ , (Y → X) → Z, Y → Z, Y ▶ X
C(X), [(Y → X) → Z, Y → Z, Y ]YZ , (Y → X) → Z, Y → Z ▶ Y → X	R →
L →
C(X), [(Y → X) → Z, Y → Z, Y ]YZ , (Y → X) → Z, Y → Z ▶ Y stop

→
	C(X), [(Y → X) → Z, Y → Z, Y ]YZ , (Y → X) → Z, Y → Z ▶ Z 	→
	C(X), [(Y → X) → Z, Y → Z, Y ]Y Z ▶ ((Y → X) → Z) → (Y → Z) → Z
C(X), (Y → X) → Z, Y → Z, Y ▶ ∀Y ∀Z(((Y → X) → Z) → (Y → Z) → Z)  R∀
C(X), (Y → X) → Z, Y → Z, Y ▶ X	L →
C(X), (Y → X) → Z, Y → Z ▶ Y → X	R →	C(X), (Y → X) → Z, Y → Z ▶ Y stop
→
C(X), (Y → X) → Z, Y → Z ▶ Z R →
C(X) ▶ ((Y → X) → Z) → (Y → Z) → Z	∀
C(X) ▶ ∀Y ∀Z(((Y → X) → Z) → (Y → Z) → Z)
→
C(X) ▶ X  R →
▶ C(X) → X	∀
▶ ∀X(C(X) → X)


and the c-substitute of the deduction tree is

	C(a), (b → a) → c, b → c, b, (d → a) → e, d → e, d, (f → a) → g, f → g ▶ g	 R →
	C(a), (b → a) → c, b → c, b, (d → a) → e, d → e, d ▶ ((f → a) → g) → (f → g) → g	 R∀
C(a), (b → a) → c, b → c, b, (d → a) → e, d → e, d ▶ ∀Y ∀Z(((Y → a) → Z) → (Y → Z) → Z) L →
	C(a), (b → a) → c, b → c, b, (d → a) → e, b → e, d ▶ a R →
C(a), (b → a) → c, b → c, b, (d → a) → e, d → e ▶ d → a	C(a), (b → a) → c, b → c, b, (d → a) → e, d → e ▶ d L →
	C(a), (b → a) → c, b → c, b, (d → a) → e, d → e ▶ e  R →
	C(a), (b → a) → c, b → c, b ▶ ((d → a) → e) → (d → e) → e   R∀
C(a), (b → a) → c, b → c, b ▶ ∀Y ∀Z(((Y → a) → Z) → (Y → Z) → Z) L →
	C(a), (b → a) → c, b → c, b ▶ a R →
	C(a), (b → a) → c, b → c ▶ b → a	C(a), (b → a) → c, b → c ▶ b L →
	C(a), (b → a) → c, b → c ▶ c  R →
	C(a) ▶ ((b → a) → c) → (b → c) → c	 R∀
C(a) ▶ ∀Y ∀Z(((Y → a) → Z) → (Y → Z) → Z) L →
 C(a) ▶ a  R →
	▶ C(a) → a	 ∀
▶ ∀X(C(X) → X)



Fig. 2.
The formula was shown to be unprovable in [2]. Here we construct a counter model for it. First, using the algorithm Search on the sequent ▶ ∀X(C(X) → X), we get a fail tree which contains two stops and one loop. Next, we make c-substitute on every node in the fail tree to assign the variables with constants. Then we construct a Kripke model using our method from the leaves to the root. Notice that there exists a loop, and the sequents which correspond to w18 and w12 are both C(X), [(Y → X) → Z, Y → Z, Y ]YZ, (Y → X) → Z, Y → Z ▶ Z. So we should identify all the notes between w18 and w12. Hence the model in real line on the left is our final counter model which is constructed by the worlds w1,... , w13.

Correctness of the counter model
In this section, we prove our construction of counter model is correct. That is to say, for a given closed formula E, if E is unprovable then we get model M by the algorithm, and M |= E.
Remark 4.1 If Search(Γ ▶ A; ξ) is not a proof but a deduction tree, then no sequent Δ ▶ B in the tree is provable.
Lemma 4.2 Let t = Search(Π ▶ P ; ξ), w be a node in the Kripke model tm and Γ ▶ A be a sequent in t which corresponds to w, and Σ ▶ A' is the c-substitute of it. Then the following is hold.
w |= M for all M ∈ Σ.
w |= A'.
Proof. We consider the lowest occurrence of Γ ▶ A in tm. If w is the leaf of the model labeled with ”stop”.
Then by the definition, we know A' is atomic, and A' /∈ Σ. Then it is easy to prove
(1)and(2) by the definition of the leaves.
Else, let t∗ be the tree with w as root, and suppose the result has be proved in all

the nodes of t∗ except w.
If A is atomic.
From the definition of tm we can easy know w |= A'.
Next, let’s proof w |= M
by the definition of the counter model, we know that w has a series of subnodes
w1,... , wm, each wi corresponds to a sequent Γi ▶ Bi ,i ∈ {1,... , m}

Γi = ([... [[Γi ]
i , Γi ]
i ,... , Γi
] i	, Γi , Bi → ... → Bi
→ A) ↓

1 V1
2 V2
si−1 Vsi−1	si	1	ni

and Γ can be written as

Γ= Γi , [Γi , [... Γi
, [Γi , Bi → ... → Bi
→ A] i
.. .] i ] i

1	2	si−1
si	1
ni	Vsi−1
V2 V1

Bi ∈ {Bi , Bi ,... , Bi }
1	2	ni
We note the c-substitute of Γi ▶ Bi as Σi ▶ B'. By HI we know wi |= B' , and
i	i
wi |= X for all X ∈ Σi Since M ∈ Σi , wi |= M .
If M is atomic.
If there is a sequent Γ0 ▶ A0 whose c-substitute Σ0 ▶ M occurs in t∗. Then we have M ∈ Σ0, and this sequent is provable, a contradict. So t∗ does not contain a sequent with c-substitute Σ0 ▶ M , hence w |= M by definition of tm
If M is not atomic.
Then we have M = C1 → ... → Cn → N . N is atomic. We prove w |= M by showing u |= N assuming u |= C1,... ,u |= Cn for an arbitrary u ≥ w.
If u > w.
We can find that u ≥ wi, i ∈ {1,... , m}. Sincne wi |= M , we can get the result simply by definition.
If u = w.
t∗ does not contain a sequent whose c-substitute has the form Σ0 ▶ N . Then by the definition of tm, w |= N , so we have w |= M = C1 → ... → Cn → N .
If t∗ contains a sequent Γ0 ▶ A0 whose c-substitute is Σ0 ▶ N . Consider a node v in model t∗ that corresponds to Γ0 ▶ A0, v ≥ w. 1.2.2.2.2.1. If v > w
We can know ∃i ∈ {1,... , m}, st. v ≥ wi. By HI, for v we have v |= N . Suppose w |= C1,... ,w |= Cn, then we have wi |= C1,... , wi |= Cn. Since wi |= M , wi |= N comes, so we get v |= N . A contradiction. Thus it does not happen that w |= C1,... ,w |= Cn, so w |= M .
1.2.2.2.2.2. If v = w
Then N = A', M = C1 → ... → Cn → A' is a c-substitute of Bi → ... → Bi  → A
1	ni
for some i ∈ {1,... , m}, Cj is a c-substitute of Bi, j=1,...,n, and ni = n.
Suppose w |= C1,... ,w |= Cn, thus wi |= C1,... , wi |= Cn. But we know wi |=
' by HI, and by the definition of c-substitute, we have Bi ∈ {C1,... , Cn}. A
contradiction. Then it does not happen that w |= C1,... ,w |= Cn, so w |= M .
If A = ∀xB. So the sequent in t is Γ ▶ ∀xB, and A' is of form ∀xB'. It is obtained by using the rule on the sequent [Γ]V ↓ ▶ B which corresponds to w'. By definition, its c-substitute is Σ ▶ B'', B'' = B'(s/x) and s is a fresh constant not in Σ ▶ B'. Also we have w' is a child node of w. By definition we have w' > w. So we get w' |= M for every M ∈ Σ, w' |= B' by HI.

Assuming w |= A', or equally w |= ∀xB'. By definition we have ∀u ≥ w, ∀a ∈ D(u),u |= B(a/x). But we have w' > w, w' |= B''. A contradiction. So we have w |= A'.
Next we proof ∀M ∈ Σ,w |= M . Firstly, by HI w' |= M .
If M is atomic M ∈ Support(w'), by the definition M ∈ Support(w), so
w |= M .
If M is not atomic. Then we have M = C1 → ... → Cn → N . N is atomic. We proof w |= M by showing u |= N assuming u |= C1,... ,u |= Cn for an arbitrary u ≥ w.
If u > w.
We can find that u ≥ w'. Since w' |= M , we can get the result simply by definition.
If u = w.
If t∗ does not contain a sequent whose c-substitute is of the form Σ0 ▶ N . Then by the definition of tm, w |= N , so we have w |= M = C1 → ... → Cn → N .
If t∗ contains a sequent Γ0 ▶ A0 whose c-substitute is of the form Σ0 ▶ N .
Consider a node v in model tm that corresponds to Γ0 ▶ A0, Obviously v /= w, v ≥ w'. By HI ,v |= N . Suppose w |= C1,... ,w |= Cn, then we have w' |= C1,... , w' |= Cn, since w' |= M , we have w' |= N , so we get v |= N . A contradiction. Thus it does not happen that w |= C1,... ,w |= Cn, so w |= M .
If A = B → C. So the sequent in t is Γ ▶ B → C, and A' is of the form B' → C'. It is obtained by using the rule on the sequent (Γ, B) ↓ ▶ C which corresponds to a node w'. By definition its c-substitute is Σ, B' ▶ C'. Also we have w' is a child node of w, w' > w. So by HI, w' |= M for every M ∈ Σ ∪ {B'}, w' |= C'.
Assuming w |= A', or equally w |= B' → C'. By definition we have ∀u ≥ w, if u |= B then u |= C. But we have w' > w, w' |= B' ,w' |= C'. A contradiction. So we have w |= A'.
Next we proof ∀M ∈ Σ,w |= M . Firstly, by HI w' |= M .
If M is atomic M ∈ Support(w'), by the definition, M ∈ Support(w), so
w |= M .
If M is not atomic. Then we have M = C1 → ... → Cn → N . N is atomic. We proof w |= M by showing u |= N assuming u |= C1,... ,u |= Cn for an arbitrary u ≥ w.
If u > w.
We can find that u ≥ w'. Since w' |= M , we can get the result simply by definition.
If u = w.
If t∗ does not contain a sequent whose c-substitute is of the form Σ0 ▶ N . Then by the definition of tm, w |= N , so we have w |= M = C1 → ... → Cn → N .
If t∗ contains a sequent Γ0 ▶ A0 whose c-substitute is of the form Σ0 ▶ N .
Consider a node v in model tm that corresponds to Γ0 ▶ A0, Obviously v /= w, v ≥ w'. By HI ,v |= N . Suppose w |= C1,... ,w |= Cn, then we have w' |= C1,... , w' |= Cn, since w' |= M , we have w' |= N , so we get v |= N . A contradiction.

Thus it does not happen that w |= C1,... ,w |= Cn, so w |= M .	 
Proposition 4.3 Given a closed positive formula E. If E is unprovable, and t =
Search(▶ E, nil), M = tm then M |= E.
Proof. By definition, the c-substitute of ▶ E is ▶ E, applying Lemma 4.2 to the root of model M and sequent ▶ E, the theorem follows.	 

Soundness and completeness
In this section we prove, for a given closed positive formula E in minimal predicate logic, E is provable in system LJB if and only if E is valid.
Definition 5.1 We define a function F ormula, it assigns a set of formulas to every LJB context Γ. F ormula(Γ) is a set of all the formulas in Γ' which is obtained from Γ by erasing all the brackets.
Theorem 5.2 (soundness) ▶ E ⇒|= E
Proof. We prove, more generally for a given LJB context Γ, if Γ ▶ E, then for every Kripke model < W, R, D,V > every w ∈ W , and every substitution σ = [x1/d1,... , xn/dn] of objects for free variables in F ormula(Γ) and E, if every A ∈ F ormula(Γ), w |= Aσ, then w |= Eσ.
Let’s prove inductively by the reduction of rules.
If E is atomic and E is in Γ . The result follows trivially.
If the last rule is L →.
Since A1 → ... → An → E ∈ F ormula(Γ), we have w |= (A1 → ... → An → E)σ, that means for all w' ≥ w, if w' |= A1σ,... , w' |= Anσ, then w' |= Eσ. By monotonicity, every A ∈ F ormula(Γ), w' |= Aσ, we can get for every A ∈ F ormula(Γ'), w' |= Aσ. Then w' |= A1σ,... , w' |= Anσ by HI, so we get w' |= Eσ. Hence we get w |= Eσ.
If the last rule is R∀.
E = ∀xM , we extent σ to σ', σ' = σ[x/d], d is a fresh constant. Equally we want to prove for every w' ≥ w, w' |= Mσ' . By monotonicity, every A ∈ F ormula(Γ), w' |= Aσ, we can get for every A ∈ F ormula([Γ]V ↓), w' |= Aσ'. Then w' |= Eσ' by HI. Hence we get w |= Eσ.
If the last rule is R →.
E = M → N , equally we try to prove if for every w' ≥ w, w' |= Mσ, then w' |= Nσ. By monotonicity, every A ∈ F ormula(Γ), w' |= Aσ, and since w' |= Mσ, we can get for every A ∈ F ormula((Γ,M ) ↓), w' |= Aσ. Then w' |= Nσ by HI. Hence we get w |= Eσ.	 
Theorem 5.3 (completeness)|= E ⇒▶ E.
Proof. For |= E, suppose /▶ E, then by Proposition 4.3, there exists an model M ,
M |= E, a contradiction. So the theorem follows.	 

Acknowledgement
The authors thank Professor Jiang Ying a lot for many helpful advices for the subject, and thank the anonymous referees whose suggestions have helped improving the paper a lot. Also appreciate all who have offered their help.

References
Dalen, D. v., ”Logic and Structure(3rd edition)” Springer,1997.
Dowek, G. and Y. Jiang, Eigenvariables, bracketing and the decidability of positive minimal predicate logic, Theoretical Computer Science 360(2006), pp. 193-208.
Dyckhoff, R., Contraction-free sequent calculi for intuitionistic logic, Journal of Symbolic Logic
57(1995),pp.795-807.
Galmiche, D. and D. J. Pym, Proof-search in type-theoretic languages: an introduction. Theoretical Computer Science 232(2000), pp. 5-53.
Hirokawa, S. and D. Nagano, Long Normal Form Proof Search and Counter-Model Generation, Electronic Notes Theorem Computer Science 37(2000).
Pinto, L., R. Dyckoff, Loop-free construction of counter-models for intuitionistic propostional logic, in Behara and al. editors, Symposia Gaussian, 1995, pp. 225-232.
Mints, G., ”A Short Introduction to Intuitionistic Logic”, Kluwer academic publishers, 2002.
Stoughton, A., Porgi:a Proof-Or-Refutation Generator for Intuitionistic propositional logic, in D. Galmiche, editor, CADE Workshop on Proof-search in Type-theoretic Languages, 1996, pp. 109-116
