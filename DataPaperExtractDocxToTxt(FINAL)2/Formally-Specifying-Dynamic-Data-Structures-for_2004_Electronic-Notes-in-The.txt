Electronic Notes in Theoretical Computer Science 108 (2004) 99–112 
www.elsevier.com/locate/entcs


Formally Specifying Dynamic Data Structures for Embedded Software Design: an Initial Approach
Edgar G. Daylighta,b,1	Bart Demoenb,2	Francky Catthoora,c,1
a DESICS Division, IMEC vzw, Kapeldreef 75, B-3001 Heverlee, Belgium
b Department of Computer Science, Katholieke Universiteit Leuven,
Celestijnenlaan 200A, B-3001 Heverlee, Belgium
c Department of Electrical Engineering, Katholieke Universiteit Leuven, Kasteelpark Arenberg 10, B-3001 Heverlee, Belgium

Abstract
In the embedded, multimedia community, designers deal with data management at different levels of abstraction ranging from abstract data types and dynamic memory management to physical data organisations. In order to achieve large reductions in energy consumption, memory footprint, and/or execution time, data structure related optimizations are a must. However, the complexity of describing and implementing such optimized implementations is immense. Hence, a strong, prac- tical need is present to unambiguously (i.e. mathematically) describe these complicated dynamic data organisations.
The objective of this article is to formally describe data structures and access operations -or dynamic data structures for short- that we have implemented in prior, application-related work. We do this by (a) extending the syntax and semantics of Separation Logic -a logic developed recently in the program verification community- and (b) using it as a specification language for our applications. The short-term benefit of this work is that it allows the embedded software designer to unambigu- ously express and hence more easily explore low cost, dynamic data structures. In practice this means that the designer can clearly reason and consequently implement nontrivial but optimal dynamic data structures. The benefit in the long term is that it provides an avenue for future optimizing compilers to increase the global scope of optimizations that are related to dynamic data management.
Keywords: Embedded system design, Separation logic, Dynamic data structures


1 Email: {voudheus,catthoor}@imec.be
2 Email: {bmd}@cs.kuleuven.ac.be



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.015

Introduction
Designing and implementing low cost data structure implementations on an embedded platform is a tedious (i.e. time consuming and error-prone) task. But in the context of embedded, multimedia applications, this task is of ex- treme importance. Due to the data dominance in this application domain, very efficient code can be produced if the data structures of the application are taken into account early during the design trajectory. This implies that not only verification of the implementation (i.e. the output of the design tra- jectory) is required. Also the ability to systematically explore various data organisations [3,14] (while traversing the design trajectory) is to the benefit of the designer. It is this latter issue that concerns us.

Modelling Low Cost, Dynamic Data Structures
We motivate our formal work by presenting one example of a data structure transformation. In Figure 1(a), the initial data structure 1 is transformed into data structure 2 by adding links to data structure 1. These links allow easy traversal through data structure 2 which usually results in a decrease of the average amount of data accesses. The memory footprint on the other hand has increased due to the additional links. A clear trade-off is present between data accesses and memory footprint. This trade-off can span a large range when the size of the data set grows.


r = data record




data structure 1












(a)


 = link





data structure 2

input data structure



output data structure



(b)


Fig. 1. (a) Adding an array of links on top of an array of records. (b) An example of dynamics: inserting a record in data structure 1.

The traversal operation, used in the above example, is an access operation in which all stored records (r) in the data structure need to be consulted. Due to the dynamic behaviour of the multimedia application, it is not a priori known which records are stored in the data structure. Traversal is a very dominant access operation in multimedia applications as is demonstrated in various case studies in [4]. This implies that memory-related energy con- sumption can decrease drastically for data structure 2 (in comparison to data structure 1) due to the decrease in number of data accesses, even though the memory footprint has increased.


In our previous work [4] we have explored various data structures and cor- responding transformations. We have only presented one transformation here but in practice, we apply various transformations in sequence and hence obtain low cost but difficult-to-understand data structures and corresponding access operations. The problem we faced during our explorations was the inability to exactly state what data structure 2 (or data structure 1) means without having to implement the data structure in code. Two factors contribute to this problem. (i) The process of implementing complicated, dynamic data structures is a time-consuming and error-prone process. (ii) Even if the im- plementation phase is successfully completed, other designers and even the same designer have difficulty extracting and understanding from the code the data structure and its access operations.
The exact problem we address in this paper is the development of a formal model that allows a designer to compactly and unambiguously express the exact behaviour of nontrivial but low cost dynamic data structures. Our con- tribution is the extension of Separation Logic [9,10,11] in terms of syntax and semantics and using it as a specification language for dynamic data structures. In the rest of this section we demonstrate our two main contributions in terms of formalisation: (i) sparseness and (ii) access operations. We do so by using data structure 1 as an example. We use the term data structure and heap interchangeably. For instance, data structure 1 is a synonym for heap 1.
Sparseness
To describe the spatial orientation of data structure 1, we can use the * con- nective of Separation Logic in the following specification.
∃l. ∃r1. ∃r7. (l '→ _)  (l +1 '→ r1)  (l +2 '→ _)	 (l +6 '→ _) (l +7 '→ r7 )
The specification states that the data structure contains eight consecutive heap cells starting at location l. The sparseness of the data structure is two (out of a total of eight elements). However, the specification is too strict for it specifies exactly which two heap cells contain a record (i.e. v1 and v7) as opposed to expressing that any two of the eight heap cells can contain a record. It is exactly this characteristic which needs to be modelled because it is the main source of complexity in dynamic data structures for embedded, multimedia applications. We will later show how to deal with sparseness formally.
Access Operations
Another, more fundamental problem is the inability to model change (of a data structure) in Separation Logic. Consider for instance the insertion of a record v3 in data structure 1 as is shown in Figure 1(b). To specify heap changes (or


data structure changes) such as these, we need to extend the original syntax and semantics to incorporate notions of input heap and output heap. The input heap corresponds to the original data structure (i.e. before the insertion has taken place). The output heap corresponds to the data structure that contains the record v3. Insertion is only one of the access operations that we define formally in this paper.
Overview
We present related work in Section 2 and re-introduce all relevant, initial work on Separation Logic in Section 3. We extend Separation Logic in two different ways in Section 4 in order to handle sparseness and access operations. In this section we model data structure 1 of Figure 1(a). Due to lack of space, we refer to a technical report [5] in which we present all the syntax and semantics of our specification language and completely model data structure 2 of Figure 1(a). We state our conclusions in Section 5.

Related Work
Besides the references given in the introduction, other sources of inspiration from the verification literature are [15,1]. Yang [15] discusses soundness and completeness of Separation Logic. Ahmed et al. [1] use type systems in conjunction with a variant of Separation Logic in order to describe hierarchical memory layouts.
The difference between the program verification community and our (em- bedded systems’) community is that we do not develop a logic intended for verification of an imperative program. We use and extend the syntax and semantics of the original logic in order to model data structures and access operations. The goal is to aid the embedded systems’ designer in expressing complex but low cost, dynamic, data organisations. Soundness, completeness and other logical properties are of no concern for our (current) objective.
When designing and implementing an embedded (e.g. hand-held) device, reduction of energy consumption for a given task is the main objective [2,3,6]. In the subdomain of multimedia, embedded systems, data management is a main contributor to power consumption [3,6,12,13]. Polyhedral models [8,3] are often used in this community (e.g. in optimization tools) to mathemati- cally model data storage and data accesses.
Our specification language differs in two ways from currently used formal approaches for data organisations in the embedded systems’ community. First, we describe the correlations between subparts of a compound data structure as opposed to only modelling the compound data structure as a set of uncor-


related arrays. For example, the two arrays that together form data structure 2 of Figure 1(a) are correlated in a specific way. We model this explicitly (see [5]). Second, we distinguish between the different kinds of data accesses that are applied on the data structure under investigation. For example, we distinguish between data accesses that correspond to the insertion of a record and data accesses that correspond to the removal of a record as opposed to simply modelling both as physical accesses without further distinction. These two additional sources of information are explicitly taken into account in our formalism. If exploited correctly, this valuable information allows significant reductions in energy consumption, memory footprint, and/or execution speed (as is demonstrated in our previous work [4]).

Separation Logic
All fundamental concepts in this section are originally from O’Hearn, Reynolds, and co. [7,11,15]. We re-introduce the concepts for didactic purposes only. Readers who are unfamiliar with Separation Logic are recommended to read [11].
Stack vs. Heap
To describe a data organisation, we use a stack and a heap. An element s ∈ S is a stack and dom(s) denotes the domain of the stack s. An element h ∈ H is a heap and dom(h) denotes the domain of the heap h. A stack maps variables onto values. A heap maps locations onto values. Values are either integers, atoms, or locations.
V al = Int ∪ Atoms ∪ Loc	S = V ar ~fin V al	H = Loc ~fin V al
Loc= {l,.. .} is a set of locations and ∀l ∈ Loc. l +1 ∈ Loc and (l + 1) − 1= l. Var = {x, y,.. .} is a set of variables. Atoms = {nil, a,.. .} is the set of atoms. We use the notation ~fin for finite partial functions.

Syntax
Expressions E are presented in Table 1 where E1 and E2 are either both integers or locations. In the latter case, addition and subtraction on locations still needs to be defined.
Separation Logic is an extension of classical (predicate) logic. The empty heap, spatial conjunction, and spatial implication 3 constitute this extension. The nonatomic formulae β are presented in Table 1 where P and Q are nonatomic formulae. The atomic formulae α are presented in Table 1 where

3 We do not use spatial implication in this paper.






E	::=	x	variable
|	42	integer
|	nil	nil
|	a	atom
|	l	location
|	E1 + E2	addition
|	E1 − E2	subtraction
|	··· 
α	::=	E1 = E2	Equality
Table 1
Syntax
β	::=	α	Atomic Formulae
|	false	Falsity
|	P ⇒ Q	Classical Implication
|	emp	Empty Heap
|	P  Q	Spatial Conjunction
|	P → Q	Spatial Implication
|	∃x.P	Existential Quantification

E1 and E2 are expressions. The other connectives (see Table 1) are defined in terms of those presented previously. We define the set fvee(P ) of free variables of a formula as usual.
Semantics
The relation of the form s, h |= P asserts that P is true of stack s ∈ S and heap h ∈ H. It is required that fvee(P ) ⊆ dom(S). We use the notation

h ⊥ h
to denote that heap h and heap h'
are disjoint:

dom(h) ∩ dom(h )= ∅. Also, h . h' denotes the union of disjoint heaps (i.e.
the union of functions with disjoint domains).
An expression E is interpreted as a heap-independent value [[E]] s ∈ V al where the dom(s) includes the free variables of E. Examples are [[x]] s = s x where x ∈ V av and [[3]] s = 3 and [[l]] s = l where l ∈ Loc. Also, [[E1 + E2]] s = [[E1]] s + [[E2]] s and [[E1 − E2]] s = [[E1]] s − [[E2]] s.  The
semantic clauses are presented below. (See [7] for the motivation of these
definitions.)
s, h |= E1 = E2 iff [[E1]] s = [[E2]] s	s, h |= P →٨Q iff ∀h' . if h' ⊥ h s, h |= E1 '→ E2 iff {[[E1]] s} = dom(h) and		and s, h' |= P
h([[E1]] s)= [[E2]] s		 then s, h . h' |= Q s, h |= emp	iff h = ∅ (h is the empty heap)	s, h |= false	never
s, h |= P ٨ Q	iff ∃h0, h1 . h0 ⊥ h1, h0 . h1 = h,	s, h |= P ⇒ Q iff if s, h |= P  then s, h |= Q s, h0 |= P and s, h1 |= Q	s, h |= ∃x.P	iff ∃v ∈ V al. [s |x '→ v],h |= P
The first clause implicitly assumes that equality is defined for values since [[E]] s ∈ V al with E being an expression. This amounts to assuming that equality is defined for atoms and locations. Similar assumptions hold for the additional clause: s, h |= E1 < E2 iff [[E1]] s < [[E2]] s. Also,


we interpret E1 ≤ E2 as the abbreviation for (E1 < E2) ∨ (E1 = E2) and E1 ≤ E2 < E3 as the abbreviation for (E1 ≤ E2) ∧ (E2 < E3), etc. We also use the underscore in a points-to relation to mean the following:
e '→ _		∃x. e '→ x where x is not free in e.

Extending the Specification Language
In each of the following two sections, we start off with the original syntax of Section 3.2 and the original semantics of Section 3.3 and extend both syntax and semantics in order to model realistic problems that we have encountered in our applications (see [4]).
In Section 4.1 we extend the logic in order to model the spatial (e.g. sparse) characteristics of data structure 1 of Figure 1(a). In Section 4.2 we extend the logic in order to model the insertion and removal access operations of data structure 1. Based on the extensions presented in this paper, we completely specify data structure 2 in [5].
Array: Spatial Orientation
In order to mathematically describe an array, we (re)use the Iterated Sepa- rating Conjunction operator and define a similar operator in order to model sparseness. We explain how to subtract one heap from another and distinguish between active and passive records. Finally we obtain an exact mathematical description of data structure 1 of Figure 1(a) as intended.






I



Loc




Val






[[ E ]] s 1
= m






[[ E ]] s 2
= n

array l n
l l+1		l+6 l+7 n=8
sparse l n sp
l+1	l+7
	sp=2	


fragmentation l n sp l	l+6

sparse l n sp l+1	l+7
sp=2



fragmentation l n sp l	l+6



SParray l n sp
l l+1	l+6 l+7


n=8


(a)

(b)

(c)


Fig. 2. (a) Mathematical objects that are used to define ISC. (b) A heap of length 8 and two disjoint subheaps. (c) Composing the sparse array from two disjoint subheaps.

Iterated Separating Conjunction

E2 v=E1
operator [11] is called Iterated Separating Conjunction (ISC) and

is defined below. In Figure 2(a) we graphically represent the mathematical
objects that are used in the definition. The integers m and n are defined


in terms of E1 and E2 respectively. The interval I is represented as a line segment starting at m and ending at n. The function M maps each integer on the line segment onto a heap h ∈ H. Each heap is a function from locations to values. The figure also shows that each heap is disjoint from all other heaps. This means that the locations that belong to the domain of a specific heap do not belong to the domain of any other heap.

s, h |= JE2	P
iff
v ∈/ dom (s) and
let  m = [[E1]] s ∈ Int, n = [[E2]] s ∈ Int, I = {i | m ≤ i ≤ n}
This allows us to define an array.

<continued> in	∃M ∈ I → H.
∀i, j ∈ I. i /= j implies
Mi⊥Mj and
h = S {Mi | i ∈ I} and
∀i ∈ I. [s | v '→ i] ,Mi |= P

array l n		Jn−1 (l + k '→ _)
This is equivalent to: (l '→ _) * (l +1 '→ _) * ... * (l + n − 1 '→ _). This array is depicted at the top in Figure 2(b) for n = 8.
Note that the right hand side of (2) is a formula. Whenever the notation
avvay l n is used in a specification, it should be substituted with the formula
  n−1 (l + k '→ _). E.g.: ∃l. ∃n. (avvay l n) is syntactically equivalent to
k=0   n−1
∃l. ∃n.	(l + k '→ _). For convenience we sometimes refer to (2) as For-
mula (2).
We can state properties of the array. For instance, the lookup property:
lookup l n index val		(0 ≤ index < n) ∧ (l + index '→ val)
expresses that (i) the value index lies in the range defined by 0 and n and
(ii) the current heap contains the value val at location l + index. To state that the data organisation under investigation is an array with the lookup property we assert that: ∃l.∃n.∀index.∃val. (avvay l n) ∧ (lookup l n index val). This formula will only evaluate to true, for a given stack s and heap h, if there exists an l and an n such that for all index values that lie in between the range defined by 0 and n, there exists a val such that both  n−1 (l + k '→ _)
and (l + index '→ val) hold.
Even though Formula (3) follows naturally from Formula (2), we still state Formula (3) explicitly. Recall that our objective is to describe specific proper- ties of a data structure regardless of whether these properties can be derived from other logical formulae (cf. Section 2 in which we relate our work to the program verification community).
Another property of the array is presented in Formula (4) which is an


inductive definition 4 . It describes how to traverse an array. The boundary of the traversal is defined by l and n, the current heap cell (of the traversal) that is being consulted is characterized by i, function f is applied to the value v that is stored in the current heap cell, and ves is the result which represents the sum of all the function applications during the traversal.
traverse l n i f res		(emp ∧ (res = 0)) ∨
((0 ≤ i < n) ∧ (∃v. (l + i '→ v) ٨ (traverse l n (i + 1) f (res − (f v)))))
For instance, ∃l.∃n.∃f.∃ves. (avvay l n) ∧ (tvavevse l n 0 f ves) evaluates to true if the data organisation under investigation, defined by the given stack s and heap h, has the structure described by Formula (2) and Formula (4) for a given l, n, function f , and result ves.
Formulae (3) and (4) describe access operations but, since they do not change the heap, we have been able to specify them in this section. In general, access operations change the heap. This issue is dealt with in Section 4.2.
In the rest of this article, we will state formulae -such as Formulae (2),(3), and (4)- in isolation.


Sparse Iterated Separating Conjunction
In order to specify sparseness, we introduce the Spavsesp  E2
which we call Sparse Iterated Separating Conjunction (Sparse ISC).

operator

s, h |= Sparsesp JE2	P
iff
v ∈/ dom (s) and let	m = [[E1]] s ∈ Int,
n = [[E2]] s ∈ Int, I = {i | m ≤ i ≤ n}
<continued>
in	0 < sp < n − m + 1,
∃J ⊆ I and |J| = sp,
∃M ∈ J → H.
∀i, j ∈ J. i /= j implies
Mi⊥Mj and
h = S {Mj | j ∈ J} and
∀j ∈ J. [s | v '→ j] ,Mj |= P

A specific example of sparseness is presented in the middle of Figure 2(b) in which sp = 2. The mathematical formulation is:
sparse l n sp		Sparsesp Jn−1 (l + k '→ _)
which describes a subheap of the array. The subheap consists of sp heap cells.



4 We do not analyze the termination property of this inductive definition. Neither do we do so for other definitions in this paper.


Spatial Subtraction
Subtracting the sparse array from the array results in a fragmented array (see bottom data structure in Figure 2(b)). We express this as follows.
fragmentation l n sp  (array l n) g (sparse l n sp)
The g connective, which we call spatial subtraction, is defined as follows.
s, h |= P g Q iff ∃h .∃h .  h = h − h	and s, h |= P  and s, h |= Q
It is possible to define g in terms of the original syntax (of Section 3.2) but we omit this for brevity.
Active vs. Passive Records
The heap described by spavse l n sp is not equivalent to data structure 1 in Figure 1(a) because this heap only contains sp heap cells while data structure 1 contains all n heap cells. In the case of data structure 1, a total of sp heap cells contain an active record (i.e. r1 and r7) and all other heap cells contain passive records. In order to specify data structure 1, we introduce a new notation: Active (E1 '→ E2). This notation asserts that the corresponding heap cell of E2 is an active record. We apply the following changes to our initial semantics.
H = Loc ~fin V al × {Active, Passive}
s, h |= E1 '→ E2	iff	{[[E1]] s} = dom(h) and h([[E1 ]] s)= ⟨[[E2]] s, _⟩
s, h |= Active (E1 '→ E2)	iff	{[[E1]] s} = dom(h) and h([[E1 ]] s)= ⟨[[E2]] s, Active⟩
Using Active allows us to define exactly a sparse array: SPavvay l n sp.
This is data structure 1 of Figure 1(a).
array l n		Jn−1 (l + k '→ _)
sparsel n sp		Sparsesp Jn−1 Active (l + k '→ _)
fragmentationl n sp		(array l n) g (sparsel n sp)
SParray l n sp		(sparsel n sp)  (fragmentation l n sp)
See Figure 2(c) for the corresponding graphical representations.

Array: Access Operations
We extend the original syntax (Section 3.2) and semantics (Section 3.3) to model change. We do this by changing the relation s, h |= P to s, hi, ho |= P . We use hi to denote the input heap (i.e. the heap before the change has occurred) and ho to denote the output heap (i.e. the heap after the change). We do not split the stack s into an input stack si and an output stack so.
We present extended syntax, additional notation, and corresponding se- mantics. Based on these extensions, we specify various access operations of data structure 1.

Syntax
The additional, nonatomic formulae β are:
β ::= empi	Empty Input Heap
|  empo	Empty Output Heap
|  Same	IIOH
|  Same (R) IIOH and both model R
|  P ; Q	Sequential Composition
where P and Q are nonatomic formulae and R is a nonatomic formula that describes only one heap. In other words, R is a nonatomic formula of Section 3.2. IIOH is an abbreviation for Identical Input and Output Heaps.
The additional atomic formulae α are:
α ::= E1 '→i E2  Points to Relation in Input Heap
|  E1 '→o E2 Points to Relation in Output Heap
Instead of having emp to denote that the (one and only) heap h is empty, we use empi to denote that input heap hi is empty and empo to denote that output heap ho is empty. We use Same to describe that hi and ho are identical. Similarly, Same (R) is used when both hi and ho adhere to the description
R. For instance, s, hi, ho |= Same ((5 '→ 3) * tvue) is semantically equivalent to s, hi, ho |= ((5 '→i 3) ∧ (5 '→o 3)) * Same. Note that we use two different points-to relations: '→i for the input heap hi and '→o for the output heap ho.
The sequential composition P ; Q denotes a heap change that is composed of two consecutive heap changes; i.e. heap change P followed by heap change Q.

Notation
Since we are dealing with an input heap hi and an output heap ho in order to model heap changes, we extend the concept of disjointness of heaps (cf. Section 3.3) to disjointness of heap changes. Similarly, we extend the concept of the union of disjoint heaps to the union of disjoint heap changes and the
same holds for set inclusion. Finally, we define the projections of a couple of heaps to one heap.
We use (h ,h ) ⊥ h' , h'  to denote that h ⊥ h and h ⊥ h . Similarly,

'	'	i  o	'	'
i	i	o	o
'	'

(hi, ho) .
'
hi, ho
denotes
'
hi . hi, ho . ho
. Similarly, (hi, ho) ±
hi, ho
denotes

hi ± hi and ho ± ho. Also, Π1 (h1, h2)= h1 and Π2 (h1, h2)= h2.

Semantics
The semantics of assertions are given by:
s, hi, ho |= P with free(P ) ⊆ dom(s)



thb

s, h ,h |= E = E






iﬀ	[[E ]] s = [[E ]] s


Table 2
Semantics
s, h ,h |= P →sQ	iﬀ






'  '	if  “ '





' ” ⊥ (h ,h )

i  o	1	2	1	2	i  o
∀hi, ho.
'
hi, ho	i  o
'

s, hi, ho |= E1 < E2	iﬀ	[[E1 ]] s < [[E2 ]] s	and  s, hi, ho |= P  then

s, h ,h |= E
'→ E
iﬀ	{[[E ]] s} = dom(h )
s, “h .
' ” , “h .
' ” |= Q

and  hi([[E1 ]] s)= ([[E2 ]] s⟩
s, hi, ho |= E1 '→o E2	iﬀ	{[[E1 ]] s} = dom(ho)
and ho ([[E1 ]] s)= ([[E2 ]] s⟩ s, hi, ho |= empi	iﬀ	hi = ∅
s, hi, ho |= empo	iﬀ	ho = ∅
s, hi, ho |= P s Q	iﬀ	∃hi,1 , ho,1 , hi,2 , ho,2 .
(hi, ho )= `hi,1 , ho,1 ´ . `hi,2 , ho,2 ´ ,
s, hi,1 , ho,1 |= P and s, hi,2 , ho,2 |= Q
s, hi, ho |= false	iﬀ	never
s, hi, ho |= P ⇒ Q	iﬀ	if s, hi, ho |= P
then s, hi, ho |= Q
s, hi, ho |= ∃x.P	iﬀ	∃v ∈ V al. [s |x '→ v], hi, ho |= P s, hi, ho |= P ; Q	 iﬀ	 ∃htmp . s, hi, htmp |= P
and s, htmp, ho |= Q s, hi, ho |= Same	iﬀ	hi = ho
s, hi, ho |= Same (R)	iﬀ	s, hi |= R  and  s, ho |= R
and s, hi, ho |= Same


Table 3
The array and its access operations.

array l n		Same “Jn−1 `l + k '→ _´” insert l n index v			(0 ≤ index < n) ∧ (∃w. (l + index '→i w) ∧ (l + index '→o v)) s Same

remove l n index v		(0 ≤ index < n) ∧ ((l + index '→i v) ∧ ¬ (l + index '→o v)) s Same modif y l n index f			∃v.
(remove l n index v); (insert l n index (f v))


The basic domains of Section 3.1 remain unchanged. The semantic clauses of the original and extended syntax are defined in Table 2. Note that in the last semantic clause we use the relation s, h |= R of Section 3.3. In addition to the semantic clauses of Table 2, we add the semantical interpretation of the Iterated Separating Conjunction but we omit the (almost identical) Sparse ISC for brevity:


s, hi, ho |= JE2	P
iff
v ∈/ dom (s) and let	m = [[E ]] s ∈ Int,

in	∃M ∈ J → H × H.
∀k, l ∈ J. k /= l implies
Mk⊥Ml and

1	h = S {Π
(Mk) | k ∈ J} and

n = [[E2]] s ∈ Int,
J = {j | m ≤ j ≤ n}
<continued>
ho = S {Π2 (Mk) | k ∈ J} and
∀k ∈ J. [s | v '→ k] , Π1 (Mk) , Π2 (Mk) |= P


Specifying Access Operations
In Table 3 we specify an array, insertion, removal, and modification of a record in an array. As a simple application of sequential composition, we specify the modification of an array element as the sequential composition of the removal of a value v followed by the insertion of the modified value (f v).
Note that for the insertion of a record in the array, we specify that value
w is overwritten by value v regardless of whether values w and v are equal.

Conclusions
In this article we have addressed the need of formally describing dynamic data structures as they occur in real-life, multimedia applications. Two rele- vant characteristics that we have modelled are (i) sparseness and (ii) access operations. While doing so, we have extended the original syntax and seman- tics of Separation Logic -a logic used in the program verification community- in various ways of which the introduction of input heap vs. output heap is the most profound. As an application of our syntactical and semantical ex- tensions, we have specified data structure 1 of Figure 1(a) in this article and data structure 2 in [5], both in terms of spatial orientation and in terms of access operations.

Acknowledgement
The first author thanks P. O’Hearn and C. Calcagno for helping him specify access patterns.

References
A. Ahmed, L. Jia, D. Walker, “Reasoning about Hierarchical Storage” 18th Annual IEEE Symposium on Logic in Computer Science, June 22 - 25, 2003 Ottawa, Canada.
L. Benini, G. DeMicheli, “Dynamic Power Management Design Techniques and CAD Tools” , 1998, Kluwer Academic Publishers, ISBN 0-7923-8086-X.
F. Catthoor, et al., “Custom Memory Management Methodology: Exploration of Memory Organisation for Embedded Multimedia System Design”Kluwer Academic Publishers, 1998.
E.G. Daylight, D. Atienza, et al., “Memory-Access-Aware Data Structure Transformations for Embedded Software with Dynamic Data Accesses” To appear in: Special Issue on IEEE Transactions on VLSI Systems, 2003/2004. http://www.imec.be/design/ddte

E.G. Daylight, B. Demoen, F. Catthoor, “Formally Specifying Dnyamic Data Structures for Embedded Software Design: a More Thorough Initial Approach”, DESICS Division, IMEC vzw, technical report B-3001 Heverlee, Belgium, January 2004. http://www.imec.be/design/ddte
D. Fisher, J. Lin, “Profiling Energy Consumption on the Palm III Personal Digital Assistant” ,
UC Berkeley Computer Science Division, Berkeley, CA 94720-1776
S. Ishtiaq, P.W. O’Hearn, “BI as an Assertion Language for Mutable Data Structures”, Proc. of the 28th ACM-SIGPLAN London, Jan. 2001.
W. Kelly, W. Pugh, “A framework for unifying reordering transformations”, Dept of CS, Univ. of Maryland, technical report CS-TR-3193, College Park MD, USA, April 1993.
P. O’Hearn, J. Reynolds, H. Yang, “Local Reasoning about Programs that Alter Data Structures”, Proceedings of CSL’01, Paris, 2001. Pages 1-19, LNCS 2142 ⃝c Springer-Verlag.
D.J. Pym, “The Semantics and Proof Theory of the Logic of Bunched Implications” Kluwer Academic Publishers, 2002, ISBN 1-4020-0745-0.


J.C. Reynolds, “Separation Logic: A Logic for Shared Mutable Data Structures”, Proceedings of the Seventeenth Annual IEEE Symposium on Logic in Computer Science, July 22-25, 2002 in Copenhagen, Denmark.
D. Singh, J. Rabaey, et al., “Power conscious CAD tools and methodologies: a perspective” , special issue on “Low power electronics” of the Proc. of the IEEE, Vol. 83, No.4, pp. 570-594, April 1995.
N. Vijaykrishnan, M. Kandemir, et al., “Evaluating integrated hardware-software optimisations using a unified energy estimation framework” , IEEE Transactions on Computers, Vol. 5.2, No.1, pp 59-75, Jan. 2003.
S. Wuytack, et al., “Transforming Set Data Types to Power Optimal Data Structures”, Proc. IEEE Intnl. Workshop on Low Power Design, Laguna Beach CA, pp.51-56, April 1995.
H. Yang, “Local Reasoning for Stateful Programs”, Ph.D. dissertation, UIUC, July 2001.
