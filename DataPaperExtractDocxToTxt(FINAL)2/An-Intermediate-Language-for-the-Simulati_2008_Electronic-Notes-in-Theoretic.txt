Electronic Notes in Theoretical Computer Science 194 (2008) 19–34	
www.elsevier.com/locate/entcs

An Intermediate Language for the Simulation of Biological Systems1
Roberto Barbuti,2	Giulio Caravagna,3 Andrea Maggiolo–Schettini4	and Paolo Milazzo5
Dipartimento di Informatica Universita` di Pisa
Largo Bruno Pontecorvo 3, 56127 - Pisa, Italy


Abstract
We propose String MultiSet Rewriting (SMSR) as an intermediate language for simulation of biomolecular systems. Higher level formalisms for biological systems description can be translated into SMSR and SMSR descriptions can be simulated by adapting an existing simulator. In this paper we show the translation of one of these formalisms, CLS+, into SMSR, and we prove correctness and completeness of the translation.
Keywords: MultiSet Rewriting, Stochastic Simulation, Calculus of Looping Sequences.


Introduction
Stochastic simulation of biomolecular systems traditionally is based on Gillespie’s framework [8] which describes a system as a multiset of elements representing molecules. A system transformation due to a chemical reaction among molecules is described as the replacement in the multiset of the elements representing reactants with those representing products of the reaction.
Multisets and their transformations are easily implemented and many tools exist to the purpose. Moreover, multisets and their transformations are formalized as multiset rewriting systems [10].

1 This research has been partially supported by MiUR PRIN 2006 Project “Biologically Inspired Systems and Calculi and their Applications (BISCA)”.
2 Email: barbuti@di.unipi.it
3 Email: caravagn@di.unipi.it
4 Email: maggiolo@di.unipi.it
5 Email: milazzo@di.unipi.it

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.12.004

In the last years the need has arisen to describe biological phenomena at system level, namely by ignoring structural and behavioral details of individual system com- ponents and by taking into account organization of components in compartments and their interaction capabilities.
Multiset rewriting does not allow descriptions at this high level and, conse- quently, many formalisms, sometimes adaption of existing ones, have been pro- posed. We mention, as examples, The κ–calculus [6], the biochemical Stochastic pi–calculus [14], the Brane Calculi [3] and P Systems [12]. For some of the for- malisms mentioned specific simulators exist (e.g. SPiM [15] based on the Stochastic pi–calculus, and CytoSim and PSym [13] based on P Systems). However, the de- velopment of simulators for high level descriptions may be not easy. Moreover, also the translation from a high level formalism to multiset rewriting which allows the use of existing simulators, may pose some difficulties.
In this paper we propose an extension of multiset rewriting, called String Mul- tiSet Rewriting (SMSR), in which multiset elements are strings and left hand sides of rewrite rules can contain an operator, called maximal matching operator, which allows representing the multiset of all strings having a common given prefix.
SMSR can be used as an intermediate language for simulation. On the one end, it is easy to develop simulators for SMSR, for instance by extending the GBS simulator [9]. On the other hand, the maximal matching operator facilitates the translation of higher level languages, in particular those based on term rewriting. The idea is that a term can be seen as a tree, a tree can be seen as a set of strings representing all paths from root to leaves and the replacement of a subtree becomes the replacement of a set of strings having a common prefix. As an example we show how a formalism based on term rewriting, CLS+ [11,2] can be translated into SMSR, proving translation correctness and completeness.
Other formalisms, such as Brane Calculi [3] and P Systems [12], could be trans- lated into SMSR directly or via their translation into CLS+ along the lines described in [11,1]. In both cases one would have the possibility of using the simulator for SMSR to simulate high level descriptions.


String MultiSet Rewriting
In this section we introduce the String MultiSet Rewriting formalism. It is based on term rewriting: we will define the syntax of terms and a structural congruence relation on them. Then we will introduce rewrite rules and define an operational semantics describing the evolution of terms by means of rewrite rules application.
We assume an infinite alphabet E = {e1, e2,.. .} and an infinite set of variables V = VE ∪ VS ∪ VM where VE is a infinite set of element variables, ranged over by x, y, z,.. ., VS is a infinite set of string variables, ranged over by x, y, z,.. ., and VM is a infinite set of multiset variables, ranged over X, Y, Z,.. ..
Definition 2.1 (Terms) Multisets M and strings S over an alphabet E are defined

by the following grammar:
M ::= S		M | M
S ::= ϵ		e		S · S
where ϵ is the empty string, e is a generic element of E, · is string concatenation, and | is multiset union. We denote the set of all multisets as M and the set of all strings as S.
Strings over E can be constructed by means of the concatenation operator ·, with ϵ representing the concatenation of zero elements. Multisets of strings can be constructed by means of the union operator |. We use the notation | for multiset union instead of the more usual notation ∪ to have a notation similar to that of process calculi.
Now we define a structural congruence relation on terms to express the associa- tivity of · and |, the commutativity of the latter, and the neutral role of ϵ.
Definition 2.2 (Structural Congruence) The structural congruence relation ≡
is the least congruence relation on multisets satisfying following axioms:
S1 · (S2 · S3) ≡ (S1 · S2) · S3	S · ϵ ≡ S
M1 | M2 ≡ M2 | M1	M1 | (M2 | M3) ≡ (M1 | M2) | M3	M | ϵ ≡ M
By means of the structural congruence we can define the usual containment operator ∈ on multisets as follows: S ∈ M ⇐⇒ ∃M '. M ≡ S | M '.
Now we introduce SMSR patterns, that are terms enriched with variables and with a maximal matching operator. This operator is the main novelty of SMSR.
Definition 2.3 (Patterns) Multiset patterns MP and string patterns SP over an alphabet E are defined by the following grammar:


MP ::= SP
 
	MP | MP		{|SP |}X		{|SP |}SP

SP  ::= ϵ
	e		SP · SP	 
x˜		x

where ϵ is the empty string, e is a generic element of E, x, x and X are generic string, element and multiset variables, · is string concatenation, | is multiset union and {| |} is the maximal matching operator. We denote the set of all multiset patterns as MP and the set of all string patterns as SP.
Patterns are used to define rewrite rules of SMSR. A rewrite rule is essentially a pair of patterns in which the first element describes the term that is modified by an application of the rule and the second describes how the term changes after the application. Variables in patterns allow a rewrite rule to be applicable to any term that can be obtained by replacing such variables with proper elements or strings. The maximal matching operator {|SP |} represents a multiset of strings which have as prefix the same instantiation of the string pattern SP .

As it is shown in the grammar of multiset patterns, we have two different forms for the maximal matching operator. In the first case we have a multiset variable as subscript of the operator, namely we have {|SP |}X . In the second case the subscript is a sequence pattern, namely we have {|SP1|}SP2 .
We define a pattern expansion function ⟨ ⟩ . In the case of the first form of
the maximal matching operator the function transforms each maximal matching operator into the union of sequence patterns, all with the same prefix S followed by different sequence variables. We call n–expansion of {|S|}X the replacement of a maximal matching operator {|S|}X by a union of n sequence patterns S · x1 |
... | S · xn. The value of n for the expansion of each maximal matching operator
will be given by an auxiliary function ρ : VS → N, which is a parameter of the pattern expansion function. In the case of the second form of the maximal matching operator, {|SP1|}SP2 , the expansion function gives SP1 · SP2.
Definition 2.4 (Pattern Expansion Function) The pattern expansion function
⟨ ⟩  : MP × (VM → N) →M is recursively defined as follows:
⟨SP ⟩ρ = SP
⟨ {|SP |}X ⟩ρ = SP · x˜1 | ... | SP · x˜ρ(X)	where x˜ ∈ VS
⟨ {|SP1|}SP2 ⟩ρ = SP1 · SP2	where SP2 ∈ SP
⟨ M P1 | M P2 ⟩ρ = ⟨M P1⟩ρ | ⟨M P2⟩ρ
Let us define the following functions:
V ar : MP '→ ℘(V)
V ar(M ) denotes the set of variables that appear in multiset M , notice that by the expansion of the maximal matching operator we have that V ar({|SP |}X ) = V ar(SP ) ∪ {x˜i | i ∈ N} and that V ar({|SP1|}SP2 ) = V ar(SP1) ∪ V ar(SP2); for instance V ar(a · x˜ | a · x | {|d|}Y )= {x˜, x}∪ {y˜i|i ∈ N};
Symbols : MP '→ ℘(E)
Symbols(M ) denotes the set of elements of E that appear in multiset M ; for instance Symbols(a · x˜ | a · x | {|d|}e)= {a, d, e}.
We assume Symbols to be trivially extended to sets of SMSR terms and we define the set of fresh names for a multiset M as the infinite set E\Symbols(M ).
An instantiation is a function σ : VE ∪ VS → M; we denote by Σ be the set of all possible instantiations. Given M ∈ MP, with Mσ we denote the multiset obtained by replacing each occurrence of variable v appearing in M with the corresponding instantiation σ(v). We denote with σ(V ) the set {T | σ(v)= T, v ∈ V }.
A rewrite rule is a pair of patterns.
Definition 2.5 (Rewrite Rule) A rewrite rule R is a pair (M, M '), denoted by M '→ M ', where M, M ' ∈ MP and M /≡ ϵ. With ঩ we denote the set of all possible rewrite rules.
A multiset M is ground if and only if V ar(M )= ∅;a rule M '→ M ' is ground if and only if both M and M ' are ground. We write V ar(R) for V ar(M ) ∪ V ar(M ')

and Symbols(R) for Symbols(M ) ∪ Symbols(M ').
Notice that, in a rewrite rule M '→ M ' we have no constraints on V ar(M ) and V ar(M '). In particular, some variables may exist that appear only in M ' and not in M . We call these variables free and the others, namely those appearing in M , bound. Formally, FV : R '→ ℘(V) and BV : R '→ ℘(V) are the functions
FV (M '→ M ') = {v | v ∈ V ar(M ') ∧ v /∈ V ar(M )}
BV (M '→ M ')  =  V ar(R) \ FV ( (M, M ')) = V ar(M ).
Free variables are related to the generation of fresh names, in particular their instantiation in the process of application of a rule R to a multiset M will be such that σ(FV (R)) ∩ (Symbols(M ) ∪ Symbols(R)) = ∅. The semantics of SMSR, that follows, provides for the choice of the correct instantiation function.
Definition 2.6 (Semantics) Given a finite set of rewrite rules R⊂঩ the seman-
ξ,ζ
tics of SMSR is the least labeled transition relation −−→ closed with respect to ≡
and satisfying the following inference rules:




(1)
R : M1 '→ M2 ∈R	σ ∈ Σ	∃ρ. (⟨M1⟩ρ)σ ≡ M ∧ (⟨M2⟩ρ)σ ≡ M '
(Symbols(σ(BV (R))) ∪ Symbols(R)) ∩ Symbols(σ(FV (R))) = ∅

'

{SPσ | {|SP |} ∈M }, Symbols(σ(FV (R)))
M  −−−−−−−−−−−−−−−−−−−−−−−−−−→ M '



(2)
ξ, ζ
M −−→ M
∀S ∈ ξ. / ∃S' ∈ S. (S · S') ∈ M ''
ζ ∩ Symbols(M
'')= ∅

M ''|M ξ, ζ
M ''|M '

The semantics rules use the concepts of patterns expansion and instantiation. Semantic rule (1) expresses that each occurrence of maximal matching operator,
{|SP |} , in a rewrite rule must be expanded and the instantiation of SP by σ, SPσ, must be recorded as the first label of the transition in the conclusion of the semantic rule. Semantic rule 2 uses, in the parallel composition of terms, the mentioned label to ensure that the operator is instantiated into the multiset of all strings, in the term to be rewritten, prefixed by SPσ.
The second label on the transition is used to ensure that for any rule that contains free variables, the result of applying the rule to a multiset generates always fresh names. This mechanism is similar to the one used for existential quantification in first–order multiset rewriting [4].
As example, given multiset M ≡ a · b · c | a · b · d | b and rules R1 : {|a · x|}X '→ c · y, R2 : {|a · x|}c '→ c we have that FV (R1)= {y}, BV (R1)= {x, X}, Symbols(R1)= Symbols(R2) = {a, c}, FV (R2) = ∅ and BV (R2) = {x}. Given a ρ function such that ρ(X) = 2 the expansion of patterns with respect to ρ is ⟨{|a · x|}X ⟩ρ = a·x·x˜1 | a·x·x˜2 and ⟨{|a·x|}c⟩ρ = a·x·c. Furthermore, given an instantiation function σ ∈ Σ such that σ = {(x, b), (x˜1, c), (x˜2, d), (y, e)} we may have, when applying R1

{a·b}, {e}
to M , the following transition of the semantics M −−−−−−→ b | c · e. Differently,
as regards the application of R2 to M , we have that no possible transitions of the semantics can be done; note that if a · b · d would not be in M then also R2 would be applicable with b | c as a result.

Encoding CLS+ into SMSR
In this section we recall CLS+ and show its encoding into SMSR. At the end of this section we prove correctness and completeness of such an encoding.

The Calculus of Looping Sequences
In this section we recall the Calculus of Looping Sequences (CLS) in one of its variants, CLS+[11,2]. CLS+ is essentially based on term rewriting, hence a CLS+ model consists of a term and a set of rewrite rules. The term is intended to represent the structure of the modeled system, and the rewrite rules the events that may cause the system to evolve.
We start with defining the syntax of terms. We assume a possibly infinite al- phabet E of symbols ranged over by a, b, c,.. ..
Definition 3.1 (Terms) Terms T , Branes B, and Sequences S of CLS+ are given by the following grammar:
T	::= S		 B L ♩ T		T | T B	::= S		B | B
S	::= ϵ		a		S · S
where a is a generic element of E. We denote with T the infinite set of terms, with
B the infinite set of branes and with S the infinite set of sequences.
In CLS+ we have a sequencing operator · , a looping operator  L, a parallel composition operator |  and a containment operator ♩ . Sequencing can be used to concatenate elements of the alphabet E. The empty sequence ϵ denotes the concatenation of zero symbols. A term can be either a sequence, or a looping sequence (that is the application of the looping operator to a parallel composition of sequences) containing another term, or the parallel composition of two terms. By definition, looping and containment are always applied together, hence we can consider them as a single binary operator  L ♩ which applies to one brane and one term. Brackets can be used to indicate the order of application of the operators, and we assume  L ♩ to have precedence over | .
In CLS+ we may have syntactically different terms representing the same struc- ture. The structural congruence relation of CLS+ expresses associativity of both · and |, commutativity of the latter and the neutral role of ϵ with respect to all the operators.

Definition 3.2 (Structural Congruence) The structural congruence relations
≡S, ≡B and ≡T are the least congruence relations on sequences, on branes and on terms, respectively, satisfying the following rules:
S1 · (S2 · S3) ≡S (S1 · S2) · S3	S · ϵ ≡S ϵ · S ≡S S S1 ≡S S2 implies S1 ≡B S2
B1 | B2 ≡B B2 | B1	B1 | (B2 | B3) ≡B (B1 | B2) | B3	B | ϵ ≡B B
S1 ≡S S2 implies S1 ≡T S2	B1 ≡B B2 implies B1 L ♩ T ≡T  B2 L ♩ T
T1 | T2 ≡T T2 | T1	T1 | (T2 | T3) ≡T (T1 | T2) | T3	T | ϵ ≡T T	 ϵ L ♩ ϵ ≡ ϵ
Rewrite rules will be defined essentially as pairs of terms, in which the first term describes the portion of the system in which the event modeled by the rule may occur, and the second term describes how that portion of the system changes when the event occurs. In the terms of a rewrite rule we allow the use of variables. As a consequence, a rule will be applicable to all terms which can be obtained by properly instantiating variables. Variables can be of four kinds associated with terms, branes, sequences, and alphabet elements, respectively. We assume a set of term variables TV ranged over by X, Y, Z,.. ., a set of brane variables BV ranged over by x, y, z,.. ., a set of sequence variables SV ranged over by x, y, z,.. ., and a set of element variables X ranged over by x, y, z,.   All these sets are possibly infinite
and pairwise disjoint. We denote by V the set of all variables, V = TV ∪BV ∪SV ∪X ,
and with ρ a generic variable of V. Hence, a pattern is a term which may include variables and a rewrite rule is a pair of patterns.
Definition 3.3 (Patterns) Patterns P , brane patterns BP and sequence patterns
SP of CLS+ are given by the following grammar:
P	::= SP		 BP L ♩ P	  P | P		X

BP	::= SP
 
	BP | BP		x

SP	::= ϵ
	a		SP · SP	 
x˜		x

where a is a generic element of E, and X, x, x˜ and x are generic elements of
TV, BV, SV and X , respectively. We denote with P the infinite set of patterns.
Definition 3.4 (Rewrite Rules) A rewrite rule is a pair of patterns (P1, P2), written as P1 '→ P2, where P1, P2 ∈ P, P1 /≡ ϵ and such that V ar(P2) ⊆ V ar(P1). We denote with ঩ the infinite set of all the possible rewrite rules.
In CLS+ we have some rules that are applicable everywhere in a term, while others cannot be applied to branes. For instance, a rule such as a | b '→ a L ♩ b cannot be applied to the elements of a looping (as in a | b L ♩ c) because the result
of the application would not be a syntactically correct CLS+ term ( a L ♩ b L ♩ c). The rules that can be applied to elements of a looping sequence are those having the form (B1, B2) with B1, B2 ∈ B. We call these rules brane rules and we denote as

঩B ⊂঩ the infinite set containing all of them. Now, in the semantics of CLS+ we have to take into account brane rules and allow them to be applied also to elements of looping sequences. Hence, we define the semantics as follows.
Definition 3.5 (Semantics) Given a set of rewrite rules R ⊆ ঩, and a set of brane rules RB ⊆ R, such that (R\ RB) ∩ ঩B = ∅, the semantics of CLS is the least transition relation → on terms closed under ≡, and satisfying the following inference rules:


(P1, P2) ∈R	P1σ /≡ ϵ	σ ∈ Σ


P1σ → P2σ
T1 → T2


T | T1 → T | T2
T1 → T2

 B L ♩ T1 → B L ♩ T2



(BP1, BP2) ∈ RB	BP1σ /≡ ϵ	σ ∈ Σ
BP1σ →B BP2σ
B1 →B B2
 B1 L ♩ T → B2 L ♩ T
B1 →B B2


B | B1 →B B | B2

where →B is a transition relation on branes, and where the symmetric rules for the parallel composition of terms and of branes are omitted.
The relation →B is used to describe the application of a brane rule to elements of a looping sequence. As usual, a CLS+ model is composed by a term, representing the initial state of the modeled system, and a set of rewrite rules.

Encoding of CLS+
Firstly we notice that, for the sake of simplicity, we assume a slight restriction on the syntax of CLS+ patterns. In particular, we require that term and brane variables appear always inside the operands of some  L ♩ operator. In other words, we avoid rewrite rules having the following forms: X| ... '→ ... and x| ... '→ .. ..
The reason for this restriction is that, as we shall see, we will use the maximal matching operator of SMSR to encode term and brane variables of CLS+. This means that the translation of a term or of a brane variable will be always instantiated in a maximal way. This is correct with respect to the semantics of CLS+ for variables that appear in the operand of a looping and containment operator (for instance, the only possible instantiation for X in a L ♩ (X | a) '→ d when the rule is applied to a L ♩ (a | b | c) is b | c), but not otherwise (for instance, X in X | a '→ d when the rule is applied to a | b | c can be instantiated either to ϵ, or b, or c, or b | c, so to obtain as results of the application either d | b | c, or d | c, or d | b, or d, respectively). This restriction could be avoided by defining also a non–maximal matching operator in SMSR. The definition of the semantics of such an operator would be quite straightforward.
We will give two encoding functions that map CLS+ terms and patterns into SMSR terms and patterns, respectively. These functions will be used to translate both the rewrite rules and the initial term of a CLS+ model. The encoding functions

are defined recursively on the structure of the CLS+ term or pattern, hence they perform a complete visit of the abstract syntax tree of such a term or pattern from root to leaves (we consider CLS+ sequences and sequence patterns as the leaves). While performing this visit, the encoding functions construct one SMSR string for each path from the root to one leaf and, eventually, they concatenate a string corresponding to the leaf to the string corresponding to its path in the tree. The result of the translation of a CLS+ pattern is hence a multiset of strings. We have a multiset of strings instead of a set because, as we shall see, the encoding will consider only the nodes of the abstract syntax tree corresponding to applications of the looping operator.
We assume that each element e ∈ ECLS+, where ECLS+ is the alphabet of CLS+, is also contained in the alphabet of SMSR. Moreover, we assume that for each element variable x and sequence variable x of CLS+, the same x and x exist in VE and VS , respectively. We assume also that VS contains a special variable Δ that will be used in the encoding of rewrite rules. Finally, for each brane variable x and term variable X of CLS+ we assume the existence of x and X in VM and of infinitely many variables xi and Xi, for all i ∈ N, in VS .
In order to encode paths in the abstract syntax tree of CLS+ terms and patterns we assume that the SMSR alphabet E contains two symbols λ and λ and all the natural numbers N. The two symbols λ and λ are used to distinguish between the branes and the contents in an application of the looping operator, and the natural numbers are used to distinguish two different applications of the looping operator. The two symbols λ and λ will be always followed by either a natural number or an element variable. To simplify the notation we will write λi and λx for λ · i and λ · x, respectively, and the same with λ instead of λ.
We now define the encoding of CLS+ terms into SMSR multisets and of CLS+ patterns into SMSR multiset patterns. In the definitions we will use an auxiliary injection function d : SP × MP → MP that inserts a sequence pattern SP as a prefix of all the elements of a multiset pattern MP . The injection function is represented with infix notation and is recursively defined as follows:
SP1 d SP2  = SP1 · SP2
SP d (M P1 | M P2) = (SP d MP1) | (SP d MP2) SP1 d {|SP2|}X	= {|SP1 · SP2|}X
SP1 d {|SP2|}SP3	= {|SP1 · SP2|}SP3
We define the encoding of CLS+ terms. The encoding technique is the same as the one used in [5,7] to define enhanced semantics for the study of causality properties. Here, the idea is to represent a path in the abstract syntax tree of CLS+ term as a sequence of λi and λi symbols representing applications of the looping operator. We do not use any symbol to represent applications of the parallel composition operator
| of CLS+ as it is directly translated into multiset union of SMSR. The same holds for the sequencing operator · of CLS+ that is directly translated into SMSR string

concatenation.

Definition 3.6 (Encoding of terms) The encoding of CLS+ terms into multisets of strings is given by the function [ ♩ : T → M×℘(N) recursively defined as follows:

[S♩  = (S , ∅)
[T1 | T2♩  = (M1 | M2 , I1 ∪ I2)	where [Ti♩ = (Mi , Ii) and I1 ∩ I2 = ∅

[ B L ♩ T ♩  = (λi d M1 | λi d M2 , I1 ∪ I2)
where [B♩ = (M1 , I1), [T ♩ = (M2 , I2) and i ∈ N \ (I1 ∪ I2)

The encoding of terms translates a CLS+ term T into a pair (M, I) where M is the actual result of the translation, namely the SMSR multiset corresponding to T , and I is the set of natural numbers that occur in M . Such a set of numbers is used in the definition of the encoding to ensure that different applications of the looping operator in T will be translated into occurrences of λi and λi having different indexes. In what follows, we will ignore this set of natural numbers and we will use [T ♩ to denote only the SMSR multiset M .
Now we define the encoding of CLS+ patterns into SMSR multiset patterns. This encoding will be used to translate CLS+ rewrite rules into rewrite rules of SMSR.

Definition 3.7 (Encoding of patterns) The encoding of CLS+ patterns into multiset patterns is given by the function [ ]] : P → MP × VE × VE recursively defined as follows:

[[SP ]] = (SP , ∅ , V ar(SP ))
[[v]] = ({|ϵ|}v , ∅ , {vi | i ∈ N})	∀v ∈ TV ∪ BV
[[P1 | P2]]  = (M P1 | M P2 , Σ1 ∪ Σ2 , Σ' ∪ Σ' )
1	2
where [Pi]] = (M Pi, Σi, Σ') and Σ1 ∩ Σ2 = ∅
[[(BP )L ♩ P ]]  = (λx d MP1 | λx d MP2 , {x}∪ Σ2 , Σ' ∪ Σ' )
1	2
where (|BP |)= (M P1 , ∅ , Σ' ), (|P |)= (M P2 , Σ2 , Σ' ),
1	2
and x ∈ VE \ (Σ1 ∪ Σ' ∪ Σ2 ∪ Σ' )
1	2

where the auxiliary encoding function (| |) : P → MP × VE × VE is recursively

defined as follows:
(|SP |) = ({|ϵ|}SP , ∅ , V ar(SP ))
(|v|) = ({|ϵ|}v , ∅ , {vi | i ∈ N})	∀v ∈ TV ∪ BV
(|P1 | P2|)  = (M P1 | M P2 , Σ1 ∪ Σ2 , Σ' ∪ Σ' )
1	2
where (|Pi|)= (M Pi, Σi, Σ') and Σ1 ∩ Σ2 = ∅
(|(BP )L ♩ P |)  = (λx d MP1 | λx d MP2 , {x}∪ Σ2 , Σ' ∪ Σ' )
1	2
where (|BP |)= (M P1 , ∅ , Σ' ), (|P |)= (M P2 , Σ2 , Σ' ),
1	2
and x ∈ VE \ (Σ1 ∪ Σ' ∪ Σ2 ∪ Σ' )
1	2
The encoding of patterns translates a CLS+ pattern P into a triple (MP, Σ, Σ'), where MP is the actual result of the translation, namely the SMSR multiset pattern corresponding to P , the set Σ contains all the element variables that are used in MP as subscripts of λ and λ symbols, and the set Σ' contains all the other variables that may appear in MP . The set Σ is used to ensure that different applications of the looping operator in P will be translated into occurrences of symbols λ and λ having different subscripts. The set Σ', instead, will be used in the following to translate CLS+ rewrite rules. In what follows, when we do not represent explicitly the triple (MP, Σ, Σ') obtained from the encoding, we will use [T ]] and (|T |) to denote only the SMSR multiset pattern MP .
Now, a CLS+ model consisting in an initial term T and a set of rewrite rules
R = {P1 '→ P ',... , Pn '→ P ' } can be translated into a SMSR model consisting in
1	n
the initial term [T ♩ and in a set of rewrite rules derived from R. The translation of
CLS+ rewrite rules uses the encoding [ ] and is different in the two cases of brane rules and non–brane rules.
The translation of a CLS+ brane rule BP1 '→ BP2 ∈ ঩B is simple as brane rules can be applied everywhere in a CLS+ term. Consequently, the SMSR rule corresponding to BP1 '→ BP2 is
Δ d MP1 '→ Δ d MP2	(1)
where [BP1]] = (M P1, Σ1, Σ' ), [BP2]] = (M P2, Σ2, Σ' ), Σ1 ∩ Σ2 = ∅ and Δ /∈
1	2
Σ1 ∪ Σ' ∪ Σ2 ∪ Σ' .
1	2
Note that, as shown in Figure 1, the instantiation of the special variable Δ added
in M P1 and in M P2 will represent, during the application of R, the path from the root of the abstract syntax tree to the point in the tree in which the rule will be applied.
The case of the translation of a non–brane CLS+ rule, namely of a rule P1 '→ P2 /∈ ঩B, is a bit more complicated as such a rule in CLS+ can be applied only either to the components of a parallel composition at the top level of the term, or to the components of a parallel composition inside some looping sequence. In order to obtain the corresponding result after translation into SMSR, we translate the rule

Δ encodes this common path







Fig. 1. Visual representation of the variable Δ in the application of rewrite rules.


P1 '→ P2 into two SMSR rewrite rules, namely:

M P1 '→ M P2	and	Δ · λx d MP1 '→ Δ · λx d MP2

where [P1]] = (M P1, Σ1, Σ' ), [P2]] = (M P2, Σ2, Σ' ), Σ1 ∩ Σ2 = ∅ and {Δ, x}∩ (Σ1 ∪
1	2
Σ' ∪ Σ2 ∪ Σ' )= ∅.
1	2
The first of the two SMSR rules will be applicable only to strings representing
components of a parallel composition at the top level of the CLS+ term, and the second SMSR rule only to strings representing components of a parallel composition inside some looping sequence in the CLS+ term.


Example
As example we show the encoding and some steps of evolution of a simple CLS+ model where T represents the initial state of the computation and {R1, R2} is the set of CLS+ rules.
T ≡	( a L ♩ (a)) | ( b L ♩ (b)) (R1)	a | b '→ c
(R2)	( a L ♩ (X)) | ( b L ♩ (Y )) '→ a|b L ♩ (X|Y )


The term T represents two cells: one with membrane a and containing the sequence a, the other with membrane b and containing the sequence b. Brane rule R1 states that a parallel composition of sequences a and b is rewritten into a sequence c. Non-brane rule R2 describes the fusion of a cell with membrane a with a neighbor cell with membrane b; the resulting cell will have both a and b on the membrane and its content will be the merge of the content of both cells.

A possible CLS+ evolution for T is
T ≡	( a L ♩ (a)) | ( b L ♩ (b))
→ a|b L ♩ (a|b)	applying rule (R2)
→ a|b L ♩ (c)	applying rule (R1)
→  c L ♩ (c)	applying rule (R1)

As previously defined, we have that T is encoded into the multiset

M ≡	λ1 · a | λ1 · a | λ2 · b | λ2 · b
and rules are encoded into the following rules
Δ · a | Δ · b '→ Δ · c

{|Δ · λw · λx|}a | {|Δ · λw · λx|}X | {|Δ · λw · λy|}b | {|Δ · λw · λy|}Y
'→ {|Δ · λw · λz|}a | {|Δ · λw · λz|}b | {|Δ · λw · λz|}X | {|Δ · λw · λz|}Y
{|λx|}a | {|λx|}X | {|λy|}b | {|λy|}Y '→ {|λz|}a | {|λz|}b | {|λz|}X | {|λz|}Y
where (1) is the result of encoding the brane rule R1 and rules (2) and (3) are the result of encoding the non–brane rule R2. We note that using the maximal matching operator in the encoding of looping operators leads to the fact that rule (2) will not be applicable to the encoding of a term like a|b L ♩ ...
A SMSR computation corresponding to the shown CLS+ computation is

T ≡	λ1 · a | λ1 · a | λ2 · b | λ2 · b
→ λ3 · a | λ3 · b | λ3 · a | λ3 · b	applying rule (3)
→ λ3 · a | λ3 · b | λ3 · c	applying rule (1)

→ λ3 · c | λ3 · c	applying rule (1)

Correctness and Completeness of the Translation
We start with showing how SMSR instantiation functions σ[[·]] can be obtained from a CLS instantiation function σ through the encoding function [ ♩. This can be done as follows:
∀v ∈ SV ∪ EV ⇒ σ[[·]](v)= [σ(v)♩
∀v ∈ TV ∪ BV. [σ(v)♩ = S1| ... |Sn ⇒ ∀i = 1,... , n. σ[[·]](vi)= Si
Note that for a function σ there exist infinite σ[[·]] that satisfy the given construction. We then prove the following lemma that will be used in the proof of equivalence.

Lemma 3.8 For any CLS+ pattern P and any instantiation function σ ∈ Σ a function ρ exists such that [Pσ♩≡ ⟨[[P ]]⟩ρσ[[·]].
Proof. The proof is made by structural induction on CLS+ patterns.
if P ≡ SP , P ≡ x or P ≡ x for any ρ the proof is trivial because encoding and expansion are the identity on P .
If P ≡ v ∈ TV ∪ BV we have to prove that [σ(v)♩ ≡ ⟨[[v]]⟩ρσ[[·]]. Let [σ(v)♩ = S1| ... |Sn then given a ρ such that ρ(v)= n, we have that ⟨[[v]]⟩ρσ[[·]] ≡ ⟨{|ϵ|}v ⟩ρσ[[·]] ≡ σ[[·]](v1)| ... |σ[[·]](vn). The proof follows trivially from the definition of σ[[·]].
If P ≡ P1|P2 for P1 and P2 patterns, we prove that [(P1|P2)σ♩≡ ⟨[[P1|P2]]⟩ρσ[[·]]. As instantiation σ, encoding function [ ♩ and patterns expansion function dis- tribute over | we have that [(P1|P2)σ♩ ≡ [P1σ|P2σ♩ ≡ [P1σ♩|[P2σ♩ and that
⟨[[P1|P2]]⟩ρσ[[·]] ≡ ⟨[[P1]]⟩ρσ[[·]]|⟨[[P2]]⟩ρσ[[·]]; assuming inductive hypothesis on P1 and
P2 yields the proof.

If P ≡  BP L ♩ P we prove that [( BP L ♩ P )σ♩ ≡ ⟨[[ BP L ♩ P ]]⟩ρσ

[[·]]
. We

have that [( BP L ♩ P )σ♩ ≡ [ BPσ L ♩ Pσ♩ ≡ λi d [BPσ♩|λi d [Pσ♩ and that

⟨[[ BP L ♩ P ]]⟩ρσ

[[·]]
≡ ⟨λi d (|BP |)|λi d (|P |)⟩ρσ

[[·]]
≡ ⟨λi d (|BP |)⟩ρσ

[[·]]
|⟨λi d (|P |)⟩ρσ
[[·]].

The definition of (| |) is similar to the one of [ ], hence it could be easily proved that
the lemma holds also when [P ] is replaced by (|P |). By the definition of d and
⟨ ⟩ρ we can write ⟨λi d (|BP |)⟩ρσ[[·]]|⟨λi d (|P |)⟩ρσ[[·]] ≡ λi d ⟨(|BP |)⟩ρσ[[·]]|λi d ⟨(|P |)⟩ρσ[[·]]
and the proof follows from inductive hypothesis on BP and P .

Finally, we prove the correspondence between the semantics of CLS+ and SMSR.


Theorem 3.9 For any CLS+ terms T and T’
T −→ T ' ⇔ ∃ξ, ζ. [T


ξ,ζ


T '♩


Proof. The proof of correctness (⇒) is made by induction on the rules of the semantics of CLS+.

We prove that P1σ −→ P2σ ⇒ [P1σ♩
ξ,ζ
−−→ [P2σ♩ using rule (1) of SMSR. We

assume P1σ −→ P2σ; as (P1, P2) is a CLS+ rule, then (Δ d [[P1]], Δ d [[P2]]) is its encoding in SMSR. Let [P1]] ≡ M1, [[P2]] ≡ M2, [P1σ♩ ≡ M and [P2σ♩ ≡ M '. The SMSR instantiation function σ[[·]] that we need is one out of the infinite that can be built with respect to the σ of CLS+ and is such that σ[[·]](Δ) = ϵ and it also has to satisfy the constraints imposed by SMSR rule (1). Notice that infiniteness of SMSR alphabet guarantees the existence of a σ[[·]] satisfying such constraints. As regards the function ρ we need, its existence is proved by Lemma 3.8.
ξ,ζ
We prove that T |T1 −→ T |T2 ⇒ [T |T1♩ −−→ [T |T2♩. Since [ ♩ distributes over |
rule (2) of SMSR can be applied where M '' ≡ [T ♩, M ≡ [T1♩ and M ' ≡ [T2♩.
ξ,ζ
By inductive hypothesis T1 −→ T2 ⇒ [T1♩ −−→ [T2♩ constraints in (2) are satisfied
because either T1 does not contain term, brain variables or looping operators

hence ξ is empty, or, by the restrictions on the term and brane variables and by the encoding of patterns containing looping operators, we have that all the prefixes in ξ are different from any other prefix in M ''. Finally, as regards constraints on ζ we have that, as in the previous case of the proof, there exist a σ[[·]] such that it generates fresh names.
We prove that  B L ♩ T  −→  B L ♩ T  ⇒ [ B L ♩ T	ξ,ζ	 B L ♩ T ♩. Since
[ ♩ distributes over   L ♩	rule (2) of SMSR can be applied where M '' ≡ [B♩,

M ≡ [T ♩ and M ' ≡ [T ♩. By inductive hypothesis T
−→ T
⇒ [T
ξ,ζ
T ♩ we

1	2	1	2
1♩ −−→[ 2

can notice that constraints on ξ are satisfied. This because, by the definition of
the encoding function, every string in M '' has a prefix λi that is different from any prefix λi in the encoding of T1. As before, constraints on ζ are satisfied by a proper choice of a σ[[·]].

We prove that  B  L ♩ T −→  B  L ♩ T ⇒ [ B  L ♩ T
ξ,ζ
 B  L ♩ T ♩. The

1	2
ξ,ζ
1	♩ −−→ [	2

proof of B1 −→B B2 ⇒ [B1♩ −−→ [B2♩ is given by the first two cases of the proof
of correctness.
In order to prove the completeness (⇐) we define the inverse of the encoding function [ ♩.
[⟨Δ · C1, S1⟩| ... |⟨Δ · Cn, Sn♩−1 = [⟨C1, S1⟩| ... |⟨Cn, Sn♩−1

[⟨ϵ, S1⟩| ... |⟨ϵ, Sn ⟩|⟨λ1, S' ⟩| ... |⟨λ1, S' ⟩|⟨λ1 · C1, S''⟩| ... |⟨λ1 · Cn , S'' ⟩♩−1 =

1	1	n2	1
3	n3

S1| ... |Sn | S' | ... |S'  L ♩ ([⟨C1, S''⟩| ... |⟨Cn , S'' ♩−1)
1	1	n2	1	3	n3
where Si /∈ CS and n1, n2, n3 ≥ 0.
We assume also the inversion of the encoding functions [ ]]. We can now prove completeness by induction on the rules of the semantics of SMSR.

ξ,ζ
We prove that ∃ξ, ζ.M
M ' ⇒ [M ♩−1 −→ [M '♩−1. We assume that (M ,M )

−−→	1	2
is a SMSR rule and we have that its corresponding CLS+ rule (P1, P2) is the one such that σ[[·]](Δ) d [[P1]] ≡ M and σ[[·]](Δ) d [[P2]] ≡ M '. Notice that the value σ[[·]](Δ) represents the encoding of the CLS+ context in which the rule is applied; in other words this corresponds to a series of applications of the rules of the CLS+ semantics that chooses the point of application of the rule (P1, P2) inside the term representing the state of the computation. As regards the instantiation function for CLS+ we can notice that, since we have the one for SMSR, we can built an ad-hoc function σ as follows: ∀v ∈ EV ∪ SV.σ(v) = σ[[·]](v) and
∀V ∈ TV ∪ BV.σ[[·]](V1)= S1,... , σ[[·]](Vn)= Sn ⇒ σ(V )= [S1| ... |Sn♩−1.

We prove that ∃ξ, ζ.M ''|M ξ,ζ
M ''|M ' ⇒ [M ''|M ♩−1 −→ [M ''|M '♩−1. By induc-

ξ,ζ
tive hypothesis M −−→
M ' ⇒ [M ♩−1 −→ [M '♩−1; let [M ♩−1 ≡ T1
and [M '♩−1 ≡

T2. The decoding distributes over | , and hence [M ''|M ♩−1 ≡ [M ''♩−1|[M ♩−1
and [M ''|M '♩−1 ≡ [M ''♩−1|[M '♩−1. We have the proof with [M ''♩−1 ≡ T .


Conclusions
We have proposed String MultiSet Rewriting (SMSR) as an intermediate language for the simulation of biomolecular systems. SMSR is an extension of multiset rewrit- ing with strings as multiset elements and with a maximal matching operator. Higher level formalisms for biological systems descriptions can be translated into SMSR and SMSR descriptions can be simulated by adapting an existing simulator. We have shown the translation of one of these formalisms, CLS+, into SMSR, and we have proven correctness and completeness of the translation.

References
Barbuti, R., A. Maggiolo-Schettini, P. Milazzo and A. Troina. A Calculus of Looping Sequences for Modelling Microbiological Systems. Fundamenta Informaticae 72 (2006), 21–35.
Barbuti, R., A. Maggiolo-Schettini, P. Milazzo, and A. Troina. The Calculus of Looping Sequences for Modeling Biological Membranes. In 8th Workshop on Membrane Computing (WMC8), LNCS, Springer, to appear.
Cardelli L. Brane Calculi. Interactions of Biological Membranes. In Computational Methods in Systems Biology (CMSB’04), LNCS 3082, pages 257–280, Springer, 2005.
Cervesato, I. The Logical Meeting Point of Multiset Rewriting and Process Algebra. Technical Memo CHACS-5540-153, Center for High Assurance Computer Systems, Naval Research Laboratory, Washington, DC, 2004.
Curti, M., P. Degano, C. Priami and C.T. Baldari. Modelling Biochemical Pathways through Enhanced Pi-calculus. Theoretical Computer Science 325 (2004), 111–140.
Danos, V., and C. Laneve. Formal Molecular Biology. Theoretical Computer Science 325 (2004), 69–110.
Degano, P. and C. Priami. Enhanced Operational Semantics: A Tool for Describing and Analyzing Concurrent Cystems. ACM Computing Surveys 33 (2001), 135–176.
Gillespie, D. Exact Stochastic Simulation of Coupled Chemical Reactions. Journal of Physical Chemistry 81 (1977), 2340–2361.
Generic Biological Simulator (GBS) web site http://www.di.unipi.it/∼milazzo/biosims/ .
Martinelli F., Bistarelli S., Cervesato I., Lenzini G., Marangoni R. Representing Biological Systems Through Multiset Rewriting. In Computer Aided Systems Theory (EUROCAST’03), LNCS 2809, pages 415–426, Springer, 2004.
Milazzo, P. “Qualitative and Quantitative Formal Modeling of Biological Systems”. PhD Thesis, University of Pisa, 2007.
Pˇaun, G. “Membrane Computing. An Introduction”. Springer, 2002.
The P Systems web page: http://psystems.disco.unimib.it/ .
Priami, C., A. Regev, W. Silvermann, and E. Shapiro. Application of a Stochastic Name–Passing Calculus to Representation and Simulation of Molecular Processes. Information Processing Letters 80 (2001), 25–31.
The SPiM web page: http://research.microsoft.com/∼aphillip/spim/ .
