Electronic Notes in Theoretical Computer Science 44 No. 4 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 12 pages


On Modifying High Level Replacement Systems *

Francesco Parisi-Presicce
Dip. Scienze dell’Informazione, Univ. di Roma ’La Sapienza’, Rome (ITALY)


Abstract
High Level Replacement Systems generalize the concept of graph transformation systems from graphs to other types of structures. Transformation rules to replace a structure with another structure in the same category are defined using morphisms in that category. As with other specification formalisms, replacement systems are subject to modifications during their development process. These modifications could be local changes (individual rules are modified), modular changes (two re- placement systems are combined to form a larger system) and global changes (the replacement of a replacement subsystem with another one). These different ways are analyzed and some results are presented to express the behavior of the modified system in terms of the behavior of the original one(s). Applications range from graph transformations to diagrams in visual languages and modelling to algebraic high level nets.
Key words: rule-base specifications, algebraic formalisms, evolution.


Introduction
High Level Replacement Systems (HLRS) [4] have been devised as a gener- alization of graph grammars to structures other than graphs. Besides the original motivation of extending to graphs the notion of Chomsky grammar for strings, graph transformations have been used to model the evolution of systems where the state of the system could be described by a graph. The basic idea of the algebraic approach [1] is to use the categorical construction of pushout of graph morphisms to replace, within a graph, a subgraph with another graph. The idea ofreplacing a substructure with another structure of the same kind has been adopted in a rule-based approach to modular system design, in which a rule represents the visible interface of a module and a direct

 Partially supported by the European Community under TMR GETGRATS and Esprit WG APPLIGRAPH
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


derivation the ability of the module to implement the resulting specification using the original one. This, and other attempts at avoiding the duplication of results (and proofs !) already known for graph transformations [2] led to the idea of abstracting away from the particular structures involved [4] and formulate a notion of rule and of transformation in a categorical setting, with objects and morphisms in an appropriate category in place ofgraphs or spec- ifications and their morphisms. The result is one theory, axiomatized over suitable categories, with several results [4] applicable in a variety of different contexts such as software systems, Petri nets, testing, visual languages and diagrams [3]. In all cases, the underlying theory of high level replacement systems provides a conceptual tool for the specification of systems.
As with any other specification formalism, high level replacement systems must evolve during the process of developing, in a stepwise manner, a high level replacement system. Three kinds ofmodifications are investigated:
modular changes: two distinct replacement systems are combined to form a larger system ofwhich the original ones are subsystems
global changes: a high level replacement subsystem is substituted with an- other one using a transformation rule itself.
local changes: individual rules are modified by applying other rules to them
The rest ofthe paper consists ofa section (2) reviewing the main aspects of high level replacement systems, a section (3) dealing with the category ofhigh level replacement systems and its closure under pushouts to model modular changes, a section (4) on rules whose components are high level replacement systems themselves, and a section (5) where rules are applied in different ways to other rules.

High Level Replacement Systems
High Level Replacement Systems (HLRS) have been formalized for an arbi- trary category C in which a distinguished class Mofmorphisms is used in the construction of the rules. In the category of graphs, the morphisms in Mare the injective graph morphisms, in the category ofalgebraic specifications they are injective strict specification morphisms. We review the basic notions of HLR systems, referring to [3] for details.
Definition 2.1 HLR framework
An HLR–framework is a pair (C, M), where C is a category and M is a class of morphisms in C.
Definition 2.2 HLR rule and transformation
A rule over M is a pair (l : K → L; r : K → R) of morphisms in M with the same domain. We let Rule(M) denote the class of all rules over M.

Given a rule p = (L ←l
K →r
R) over M, a direct transformation from

G1 to G2 via p, denoted by p : G1 ⇒ G2 , consists of the double pushout



L	✛l
r
K	✲	R

g1	❄	d ❄	g2

G1 ✛		D
	✲ G2

l'	r'


Given a rule p = (L ←l
K →r
over M and morphism g1 : L → G1, the

rule is applicable to G1 ifand only if 
there exists an object D (pushout complement) and relative morphisms such that the left square in the diagram above is a pushout, and
there exists an object G2 and relative morphisms such that the right square in the diagram above is a pushout.
Depending on the specific high level replacement framework, concrete condi- tions on p and g1 can be given to guarantee the applicability ofa rule [1].
The following is a variation of the definition in [4,3]. Here we add names for the rules and remove the start object.
Definition 2.3 HLR systems
A high level replacement system is a 4-tuple H = (C, M, P, π) where (C, M) is a high level replacement framework, P is a set (of names) and π : P → Rule(M) a function that associates each name to a rule over M.
We can think ofthe framework (C, M) as the ”type” of H and we say that
H is a High Level Replacement System over the framework (C, M).
As shown in [4,3], particular properties of an HLR framework guarantee other properties ofany HLR system over that framework.
Definition 2.4 HLR conditions
In any HLR framework (C, M), the following are called HLR conditions
Existence of semi-M-pushouts
Existence of M-pullback
Inheritance of Munder pushouts and under pullbacks
Existence of binary coproducts and compatibility with M
M–pushouts are pullbacks
M–pushout-pullback decomposition
Any HLR system that satisfies the HLR conditions satisfies:
Local Confluency I If p1 : G ⇒ H1 and p2 : G ⇒ H2 are parallel independent, then there exists an object X such that p2 : H1 ⇒ X and p1 : H2 ⇒ X; furthermore p1 : G ⇒ H1 and p2 : H1 ⇒ X are sequentially independent Local Confluency II	If p1 : G ⇒ H1 and p2 : H1 ⇒ X are sequentially independent, then there exists an object H2 such that p2 : G ⇒ H2 and p1 : H2 ⇒; furthermore p1 : G ⇒ H1 and p2 : G ⇒ H2 are parallel independent Parallelism If p1 : G ⇒ H1 and p2 : H1 ⇒ X are sequentially independent,

then p1 + p2 : G ⇒ X via the parallel rule p1 + p2
We close this section with two examples ofHLR frameworks.
Example 2.5 The first example is the framework of undirected graphs, where each edge is associated with a set of 1 or 2 nodes, its endpoints. An undi- rected graph G is a triple (GE, GN , end), where GE and GN , are the set of edges and the set of nodes, respectively, and end : GE → P2(GN ) is the function associating each edge e to a subset end(e) of GN of cardinality 1 or 2.
Given undirected graphs G = (GE, GN , end), and G' = (G' , G' , end'), a 
E	N
U-graph morphism f : G → G' is a pair (fE : GN → G' , fE : GE → G' )
such that end'(fE(e)) = fN (end(e)) (where the same notation is used to denote the obvious extension of fN to subsets of N). It is immediate to check that U-graphs and U-graph morphisms form a category closed under pushouts.
Undirected graphs can easily be labelled with distinct sets of labels for nodes and edges, and can be typed with an undirected graph: these extensions are orthogonal to the properties presented here.
For undirected graphs, it is easy to extend the original Gluing Conditions
[1] to guarantee the applicability of rules. Given p = (L ← K → R) and
g1: L → G1, let
IDg1 = {x ∈ L : ∃y ∈ L, x /= y, g1(x)= g1(y)}
DANGg1 = {n ∈ LN : ∃e ∈ G1E − g1E(LE) such that g1N (n) ∈ endG1 (e)}
Then the pushout complement D exists if and only if
DANGg1 ⊆ l(K)
IDg1 ⊆ l(K)
With arguments similar to those used for directed graphs [?], it can be shown that with Mthe class of U − morphisms where both fN and fE are injective, (UGraph, M) is an HLR framework satisfying the HLR conditions.
Example 2.6 The second example is a recently [5] revised notion of Algebraic High Level net. An algebraic high level net is given by N = (X, A, SPEC, P, T, pre, post, cond) with
X : a set of variables,
A ∈ |Alg(SPEC)| a SPEC algebra,
SPEC ∈ |SPEC| : an algebraic specification with SPEC = (Σ, E) ,
P : a set of places,
T : a set of transitions,
pre, post : T → (TOP (X) × P )⊕ (defining for each transition with adjacent arcs the arc inscriptions and the weight),
cond : T → Pfin(EQNS(Σ)) (mapping each transition to a finite set of conditions representing the firing conditions).
Morphisms in this revised version of algebraic high level nets allow the

explicit substitution of terms for variables. Given two algebraic high level nets Ni = (Xi, Ai, SPECi, Pi, Ti, prei, posti, condi) for i = 1, 2, an algebraic high level net morphism f : N1 → N2 is given by f = (fX, fSPEC, fA, fP , fT ) with
fX : X1 → TOP2 (X2) maps variables to terms,
fSPEC : SPEC1 → SPEC2 is a specification morphism,
fA : A1 → VfΣ (A2) is a homomorphism in Alg(Spec1),
fP : P1 → P2 maps places to places in Set, and
fT : T1 → T2 maps transitions to transitions in Set,
such that the following diagram commutes componentwise

¸con,d1
 pre1 	⊕

Pfin(EQNS(SIG1))
T1 	 (T OP1 (X1) × P1)
post1

Pfin(f  )
(1)
fT	(2)
 SPEC
×fP )⊕

J 
¸con,d2
J pre2 	J   ⊕

Pfin(EQNS(SIG2))	T2 	 (T OP2 (X2) × P2)
post2
A strict algebraic high level net morphism is an algebraic high level net morphism which additionally has the following properties:
fX : X1 → X2 is an injective mapping of variables,
fSPEC : SPEC1 → SPEC2 is a strict specification morphism,
fA : A1 → VfΣ (A2) is an isomorphism in Alg(Spec1),
fP and fT are injective.
As shown in [5], the category AHL , of algebraic high level nets and mor- phisms, together with strict morphisms forms an HLR framework that satisfies the HLR conditions.

Modular Transformations
A modular transformation on a HLR system consists of adding to it in an appropriate manner another HLR system, after describing what parts of the original system should be shared and not be duplicated. This combination of distinct HLR systems with a common part is obtained via the ”usual” pushout construction. First we need to relate the ”types” ofdifferent HLR systems via an HLR framework morphism, called M–compatible functor in [5].
Definition 3.1 Framework
Given HLR frameworks (CATi, Mi), a framework morphism F : (CAT1, M1) →
(CAT2, M2) is a functor F : CAT1 → CAT2 such that F (M1) ⊆ M2.
Morphisms of HLR systems associate rules to rules that are ‘equal’ up to retyping.
Definition 3.2 HLR morphism
An HLR morphism h : H1 → H2 is a pair (hF , hf ) where hF : (CAT1, M1) →
(CAT2, M2) is a framework morphism and hf : P1 → P2 a function such that

if p ∈ P1 and π1(p)= (l, r) is a rule in H1, then π2(hf (p)) = (hF (l), hF (r)) is a rule in H2.
Being an HLR morphism does not guarantee that the derivations can also be transformed. The following result is essentially the Preservation of Deriva- tions by Functors Theorem in [5].
Theorem 3.3 Derivation through funtors
If hF : CAT1 → CAT2 preserves pushouts, then h : H1 → H2 preserve deriva- tions.
Examples of functors with this property are the Causality and Weight func- tors between Elementary Nets and Place/Transition Nets, and the Data and Skeleton functors between Place/Transition Nets and Algebraic High Level Nets in [5].
HLR morphisms can be composed componentwise and the identity func- tor/function is obviously an HLR morphism. Furthermore,
Theorem 3.4 Category of HLR Systems
HLR systems and HLR morphisms form a category closed under pushouts.
The result oftransforming an HLR system H1 by adding to it another HLR system H2 after specifying the shared part H0 via HLR morphisms h1 : H0 → H1 and h2 : H0 → H2 is the pushout object of h1 and h2 in this category.

Global Transformations
Graph Transformation Systems have been devised to transform graphs by re- placing a subgraph with another graph, that is, by replacing a ”substructure” (determined by a morphism in the appropriate category) with another sub- structure. The same principle can be used to allow the replacement via a rule of a sub-graph grammar within a ‘larger’ graph grammar [8] or the replace- ment of an HLR system. The situation is comparable to that of a (string) grammar for a programming language: sets of rules describe how to generate expressions, declarations, instructions, etc., and wanting to change the con- crete syntax for expressions, the corresponding subgrammar must be replaced with one reflecting the wanted new syntax.
To remain within the same DPO framework, a rule for the replacement of HLR systems consists of a span (l : K → L; r : K → R) of HLR morphisms sharing the same HLR system as domain. Which HLR morphisms should be used ? In general there are no restrictions, but to obtain an HLR frame- work and therefore guarantee that the corresponding HLR system enjoys the properties mentioned earlier, the morphisms must be faithful.
Definition 4.1 Faithful
A High Level Replacement System morphism (hF , hf ) : HLR1 → HLR2 is faithful if hf : P1 → P2 is injective and hF : CAT1 → CAT2 is injective on both objects and morphisms.

This limitation is sufficient for our purpose.
Theorem 4.2 HLR framework
The category of HLR systems with distinguished morphisms M the faithful morphisms of the previous definition forms a HLR framework.
As in the case ofgraphs, it is possible to describe concretely the necessary and sufficient conditions for an HLR rule to be applicable to an HLR system G = (CATG, MG, PG, πG).
Notation For a given category CAT , Obj(CAT ) and M or(CAT ) denote the objects and the morphisms of CAT , respectively.
Theorem 4.3 HLR Gluing Conditions
Given an HLR rule p = (L ← K → R) and an HLR morphism (hF , hf ) : (CATL, PL) → (CATG, PG), let
IDf = {x ∈ PL : ∃y ∈ PL,x /= y, hf (x)= hf (y)}
IDoF = {x ∈ Obj(CATL): ∃y ∈ Obj(CATL),x /= y, hF (x)= hF (y)}
IDmF = {m ∈ M or(CATL): ∃n ∈ M or(CATL),m /= n, hF (m)= hF (n)}
DANGF = {x ∈ Obj(CATL): ∃m ∈ M or(CATG) − hF (M or(CATL)) and
∃y ∈ Obj(CATG) such that m ∈ M or(hF (x), y) or m ∈ M or(y, hF (x))}
Then the pushout complement D exists if and only if
DANGF ⊆ lF (Obj(CATK))
IDoF ⊆ lF (Obj(CATK))
IDmF ⊆ lF (M or(CATK))
IDf ⊆ lf (PK)
Local Transformations
Besides simply replacing a rule ([8]), it is convenient to be able to define new rules by reusing existing rules. There are (at least) three possible ways of reusing a rule
reusing by specialization ofa rule, that consists ofadding properties to the rule and hence to the host object to which it can be applied (this corresponds to subtyping in which a method is refined to take advantage of the added properties ofthe objects ofthe subtype; the less specialized method can be applied whenever the specialized method can, but not viceversa)
reusing by analogy ([9]) where a new rule is needed that ”behaves like the old one” but in a different context which is ‘similar’ to the original (the analogy or similarity is described explicitly by the user)
reusing by inheritance where a class with its methods is located in the object class hierarchy and is adapted by adding or extending methods to provide the desired new behavior
The approach adopted in this paper is to model all three cases of reusing in a uniform way within the same framework of the rules themselves, without

resorting to a metamodel. The idea is to use rules to modify other rules, similar to the way rules modify objects. The way the ”modificator” rule is applied and the part of the rule-to-be-modified to which it is applied determines the different forms ofreusing. The behavior ofthe modified rule can be described in terms ofthe behavior ofthe original rule and the modifying rule.

Specialization
The simplest form ofmodification ofa rule p1 is already present, implicitly, in the basic notion ofapplication ofa rule. When a rule p1 is applied to an object G1 via a matching morphism g1, it produces not only the resulting object G2 (see the definition ofdirect derivation) but also the context object D and the morphisms D → G1 and D → G2. Ifthe morphisms ofthe original rule p1 are in M, then, by the 3rd in the list ofHLR conditions, the induced morphisms D → G1 and D → G2 are also in M. Hence spec(p1)= (G1 ← D → G2) is a new rule obtained from p1 by ”specializing” the context ofapplication via the morphism K → D. Since the middle object (D in this case) represents the part of the trasformed object to be left unchanged, the new rule behaves like the old one (by removing and adding the same elements) but in a different (larger) context.
p1	L1 ✛	 K1 	✲ R1
❄	❄	❄

spec(p1)	G1 ✛	 D
	✲ G2

❄	❄	❄
transformation	G' ✛	 D' 	✲ H'
Ifthe new rule spec(p1) is applicable to G', then there exists a context object D' so that G' is the gluing of G1 and D' along D. By standard properties of pushouts, G' is also the gluing of L1 and D' along K1 and the application of p1 to G' with matching L1 → G1 → G' produces the same object H'.
Theorem 5.1 specialization
If (spec(p1), m'): G' ⇒ H' then (p1,m ◦ m'): G' ⇒ H'.
The converse is not true since there is no guarantee that an arbitrary matching morphism L1 → G' can be decomposed into a composition of mor- phisms L1 → G1 → G'.

Analogy
Another form of modification of a rule is obtained by analyzing the notion of analogy ([9]). While in specialization the objective is to obtain a new rule which behaves like the original one but with a ‘larger’ context (denoted by the morphism from the old context K to the enlarged context D), and therefore in

a smaller number ofcircumstances, with analogy the objective is to transform a rule indicating explicitly the similarity between the old and the new context of application. Using as example the CityTraffic model in [9], we want to express the fact that Cars move on Roads like Trains move on Tracks. It is the end-user responsibility to explicitly indicate that cars correspond to trains and that a road segment corresponds to a track segment. This explicit correspondence can be modelled by a rule q = (L ← K → R) which replaces an occurrence of a train and a track (represented in the left hand side L of the rule) with an occurrence of a car and a road (represented in the right hand side R of the same rule); the interface graph K is used to maintain the information about the direction of the segment (horizontal, for example) or that the moving object is on the appropriate segment. An existing ”move” rule p1 = (L1 ← K1 → R1) can be modified to adapt it to the analogous situation by applying to it the ”analogy” rule q. Since a move rule does not modify the segment of the move or the nature of the moving object, the information about the train and the track is represented in the part K1 left unchanged by the rule p1 and therefore the analogy rule q is applied to K1 via the matching h : L → K1 as in the following diagram
L	(	 K		)	R
h v	v	v



/s
K1 (	 K'
	) K2
/
/s

L1	L'	L2
v
R1 (	 R' 	) R2
The new rule p2 = (L2 ← K2 → R2) is obtained by applying q to K1 via the matching morphism h : L → K1, to L1 via the matching morphism L → K1 → L1 and to R1 via the matching morphism L → K1 → R1. The applicability of q to p1 depends on the existence ofthe pushout complements K', L' and R'. For the extendibility ofthe derivation q : K1 ⇒ K2 to L1 and R1, there are results on the embedding of derivation sequence [1] in larger graphs. In this
case ofgraphs, we can summarize the conditions in the following theorem.
Theorem 5.2 Application conditions

A production q = (L ←l
K →r
R) is applicable to p  = (L ←l1
K →r1
R1) via

h : L → K1 if and only if
DANGh ∪ IDh ⊆ l(K)
DANGl1 ∩ h(L) ⊆ h(l(K))
DANGr1 ∩ h(L) ⊆ h(l(K))

The rewriting ofa production p1 to a production p2 via another production q is reflected in the correspondence between the objects produced by p1 and those produced by p2.
Theorem 5.3
If q : p1 ⇒ p2 via h : L → K1, p1 : G1 ⇒ H1 via g1 : L1 → G1,
q : G1 ⇒ G2 via f = g1 ◦ l1 ◦ h : L → G1 and
p2 : G2 ⇒ H2 via g2 : L2 → G2
then q : H1 ⇒ H2.
Another way ofexpressing the behavior ofthe new rule in terms ofthe old one and the analogy rule is as follows: p2 produces an object H2 from an object
−1
G2 if and only is G2 is transformed by the ”inverse” analogy rule q	into an
object G1 to which p1 is applicable to produce H1 which in turn is transformed into H2 by the analogy rule q. Formally if p2 is the result of applying q to p1
−1
as shown above, then p2 = q	∗ p ∗L q, where ∗ is the operator ofsequential
composition oftwo rules with L determining the overlap ofthe right hand side ofthe first rule with the left hand side ofthe second rule [1,?]

Inheritance
A more general form ofmodification ofa rule is attained via inheritance, with the underlying idea ofreusing existing methods (represented in our framework by rules) by extending them to provide the desired behavior. The focus here is on a modification of a rule and not on a plain overriding. In modifying a given rule p1 = (L1 ← K1 → R1), we may want to reuse its behavior in terms of applicability of the rule and of items removed from the graph to which it is applied, while changing the items to be added: in other words, we want a new rule which coincides with p1 in the left hand side L1, but which has a different R1. A modification of R1 induces (in general) a modification of the interface part K1. The modification of the right hand side R1 is attained via a new rule q = (L ← K → R) applied to R1. The result of the application is illustrated in the following diagram
L (	 K 	) R

v	v	v
R1 (	 C1 	) R2
✻	✻
K1 (	 K2
v
L1 = L2
where:

R2 is the object resulting from the direct derivation via q of R1
K2 is the common part of C1 (left unchanged by the application of q to R1) and K1 (left unchanged by any application of p1); notice that it exists by the second HLR condition
L2 is just the unchanged left hand side of p1
It is possible to express the new rule p2 in terms of the old rule p1 and the ”adjustment” q. If p2 is the rule obtained from the application of q to R1 of p1 as described above, then p2 = p1 ∗L q. In other words, the effect of applying p2 to an object G is the same obtained by first applying the old rule p1 and then the modifying rule q. So the new rule p2 ”reuses” the old rule p1 by first performing the elimination determined by p1 and then performing the new additions.
In a similar way, a rule q can be used to modify the applicability of a rule p1 and the items that it removes, while leaving unchanged the items added by p1: this can be accomplished by applying q to L1, in which case if p2 is the rule obtained from the application of q to the left hand side L1 of p1, then
p = q−1 ∗ p
Note that we have not discussed explicitly the applicability ofa modifying rule q to p1 since it is nothing more then the applicability ofa rule to an object (R1 in the first case, L1 in the second case).

Concluding Remarks
High Level Replacement Systems describe rule based mechanisms for the sub- stitution of a substructure by another, by using exclusively the relationship (morphism) between two objects. The lack of specific requirements on the structure ofthe objects that are replaced makes the theory easily usable in a variety ofapplications.
The specification in the different concrete cases usually evolve, either be- cause of a better understanding of the requirements or because of changing requirements, and so it is useful to have general results at the level of HLR systems to describe the different kinds ofmodifications. We have modelled the integration ofHLR systems by pushouts, global substitution ofsubsystems by rules, and ”in the small” changes by individual rules.
Within the same formal framework used for rules, we have shown how to model specialization, analogy and inheritance by simply applying appropriate rules to pre–existing rules. The behavior ofthe ”new” rules can be described in terms of the behavior of the ”old” rules and the rules describing the mod- ification. The desired adapted system can be obtained by adding to the set of pre–existing rules the ”modifying” rules and by imposing a control on the order of application (described, for example, by rule expressions [6]). Local modifications can easily be viewed as global ones (where the modified rules replace the old ones) while the converse is not always true. The replacement

of a rule with its refinement (in the graph case see [6]) can be viewed as a special case ofa global transformation.
A similar treatment of modifications of High Level Replacement Systems can be carried out in the Single Pushout approach.

References
H.Ehrig, Introduction to the Algebraic Theory of Graph Grammars. in Lect. Notes Comp. Sci. 73, (Springer–Verlag 1979) 1–69.
A.Corradini, U.Montanari, F.Rossi, H.Ehrig, R.Heckel, M.Lo¨we, Algebraic Approaches to Graph Grammars Part I: basic concepts and Double Pushout Approach. in G.Rozenberg ed.: Handbook of Graph Grammars and Computing by Graph Transformations (World Scientific ,1997) 163-246
H. Ehrig, M. Gajewsky, and F. Parisi-Presicce, High-Level Replacement Systems with Applications to Algebraic Specifications and Petri Nets, in: Handbook of Graph Grammars and Computing by Graph Transformations volume 3: Concurrency, Parallelism, and Distribution, (World Scientific, 1999) 341–400.
H. Ehrig, A. Habel, H.-J. Kreowski, and F. Parisi-Presicce, Parallelism and concurrency in high level replacement systems. Mathematical Structures in Computer Science, 1 (1991) 361–404.
M.Gajewsky, F.Parisi-Presicce, Formal Transformations of Petri Nets. Techn.Rep 2000-12 , (Technische Universitat Berlin 2000)
M. Große-Rhode, F. Parisi-Presicce, and M. Simeoni, Refinements of Graph Trasformation Systems via rule expressions. in: H.Ehrig, G.Engels, H.-J.Kreowski, G.Rozenberg, eds., Theory and Applications of Graph

Transformations (selected papers)
Verlag 2000) 368–382.
Lect.
Notes
Comp.
Sci.
1764, (Springer–

R. Helm, and K. Marriot, Declarative Specification of Visual Languages. in Proc. IEEE Workshop on Visual Languages, (IEEE Comp.Sci. Press 199), 98–103.
F. Parisi-Presicce, Trasformations of Graph Grammars, in Proc. 5th Internat. Wksp. on Graph Grammars , Lect. Notes Comp. Sci. 1073, (Springer–Verlag 1996) 426–442.
C. Perrone, and A. Repenning, Graphical Rewrite Rule Analogies: avoiding the inherit or copy&paste reuse dilemma, in Proc. IEEE Symposium on Visual Languages, (IEEE Comp.Sci. Press 1998) 40–46.
