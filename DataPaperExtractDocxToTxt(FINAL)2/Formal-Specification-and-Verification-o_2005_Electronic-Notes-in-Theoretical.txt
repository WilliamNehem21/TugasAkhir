Electronic Notes in Theoretical Computer Science 123 (2005) 5–17	
www.elsevier.com/locate/entcs


Formal Specification and Verification of Multi-Agent Systems
Mustapha Bourahla1
Computer Science Department, University of Biskra, Algeria
Mohamed Benmohamed2
Computer Science Department, University of Constantine, Algeria

Abstract
Multi-agent systems are increasingly complex, and the problem of their verification and validation is acquiring increasing importance. In this paper we show how a well known and effective verification technique, model checking, can be generalized to deal with multi-agent systems. This paper explores a particular type of multi-agent system, in which each agent is viewed as having the three mental attitudes of belief (B), desire (D), and intention (I). We use a multi-modal branching-time logic BDICTL, with a semantics that is grounded in traditional decision theory and a possible-worlds framework. A preliminary implementation of the approach shows promising results.
Keywords: Agents, Multi-Agent Systems, Multi-Modal Branching-Time Logic, Formal Specification and Verification, Model Checking.


Introduction
The design of (in particular safety-critical control) systems that are required to perform high-level management and control tasks in complex dynamic environ- ments is becoming of increasing commercial importance. Such systems include the management and control of air traffic systems, telecommunications net- works, business processes, space vehicles, and medical services. Experience in

1 Email: mbourahla@hotmail.com
2 Email: ibnm@yahoo.fr



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.042


applying conventional software techniques to develop such systems has shown that they are very difficult and very expensive to build, verify, and maintain. Agent-oriented systems, based on a radically different view of computational entities, offer prospects for a qualitative change in this position.
A number of different approaches have emerged as candidates for the study of agent-oriented systems [1,4,8,10,11]. One such architecture views the sys- tem as a rational agent having certain mental attitudes of Belief (beliefs can be viewed as the informative component of system state), Desire (desires can be thought of as representing the motivational state of the system), and In- tention (the intentions of the system capture the deliberative component of the system). Thus BDI represents the information, motivational, and delib- erative states of the agent. These mental attitudes determine the system’s behavior and are critical for achieving adequate or optimal performance when deliberation is subject to resource.
To describe the belief, desire, and intention components of the system state a propositional form is used, based on possible worlds. Thus, the pos- sible worlds model [8] consists of a set of possible worlds where each possi- ble world is a tree structure. A particular index within a possible world is called a situation. With each situation we associate a set of belief-accessible worlds, desire-accessible worlds, and intention-accessible worlds; intuitively, those worlds that the agent believes to be possible, desires and intends to bring about, respectively.
In this paper, we address the problem of verification for such formalisms which is increasingly important. The formalism of multi-agent temporal logic
[8] is introduced towards lifting one of the most successful verification tech- niques, model checking [2], for the validation of multi-agent systems. Multi- agent temporal logic BDICTL combines, within a single framework, the aspects of temporal logic, used to reason about the temporal evolution of finite-state automata, with agent-related aspects such as belief, desire and intention.
The problem of extending the standard temporal logic model checking techniques, and then using the related tools, to deal with the multi-agent aspects of the logic, is the specification of the possible worlds and the relation between them. The essential of our contribution is to present an approach by which we help reducing the specification time. This approach is based on the automatic synthesis of the mental attitudes of agents. Each mental state will be an index to a new created world using the specifications of the different agents. For illustrating our approach, we designed a sub-language for specifying multi-agent systems. The specification will be agent-oriented. A tool is developed for constructing the state space of each agent in the multi- agent system. Then an algorithm is developed for synthesizing the agent


models of the specified multi-agent system. The synthesis result is a possible worlds model. At the end, we have adopted the standard model checking for the analysis of these models of multi-agent systems. A symbolic model checking tool for verifying multi-agent systems has been implemented. The preliminary results are extremely promising.
This paper is structured as follows. In Section 2 we describe the multi- agent temporal logic (BDICTL). In Section 3, we present the specification sub-language and its underlying intuitions, and define the language and the semantics as a temporal logic. In Section 4, we present the algorithm for syn- thesizing the corresponding multi-agent structures. In Section 5, we present the extended general algorithm for model checking. Finally, in Section 6 we outline the results, discuss future work, and draw some conclusions.

Multi-Agent Temporal Logic BDICT L
The temporal logic BDICTL [8] we consider is extension of Computation Tree Logic CTL [5] that has been used extensively for reasoning about concurrent programs. The branching-time logic CTL is extended to represent the mental state or belief-desire-intention state of an agent. This logic can then be used to reason about agents and the way in which their beliefs, desires, and actions can bring about the satisfaction of their desires. The syntax of BDICTL is as follows.
ϕ ::= true | p | ¬p | ϕ ∨ ϕ | ∃Xϕ | ∃Gϕ | ∃ϕU ϕ | Biϕ | Iiϕ | Diϕ.
The primitives of this language include a nonempty set AP of atomic proposi- tions, propositional connectives ∨ and ¬, modal operators B (agent believes), D (agent desires), and I (agent intends), and temporal operators of CTL. The CTL temporal operators are ∃Xϕ (ϕ might hold at next time instant), ∃ϕUψ (it might be the case that ψ holds at a certain time future and until then ϕ holds), and ∃Gϕ (ϕ might hold for all future time instants). Temporal oper- ators are compactly characterized by ∃ϕUψ ⇔ (ψ ∨ (ϕ ∧ ∃X∃(ϕU ψ))) and by ∃Gϕ ⇔ (ϕ ∧ ∃X∃Gϕ). We have operators Biϕ, Iiϕ, and Diϕ which mean that agent i has a belief, desire, and intention of ϕ, respectively. This gram- mar is not given in its most succinct form and there exist equivalence rules to express the same formula with different operators; for example, ∀Fϕ (ϕ is inevitable) is equivalent to ¬∃G¬ϕ. In practice, by using this equivalence rules, a formula can be written such that the negation appears only at the level of atomic propositions. Such a form of a formula is known as Negative Normal Form (henceforth NNF form).
The traditional possible-worlds semantics of beliefs considers each world


to be a collection of propositions and models belief by a belief-accessibility relation B linking these worlds. A formula is said to be believed in a world if and only if it is true in all its belief-accessible worlds [6]. The accessibility relation B is a relation between the world at an index and at a time point to a set of worlds. Intuitively, an agent believes a formula in a world at a particular index if and only if in all its belief-accessible worlds the formula is true. We consider each possible world to be a tree structure with a single past and a branching future [3]. Evaluation of formulas is with respect to a world and a state. Hence, a state acts as an index into a particular tree structure or world of the agent. The belief-accessibility relation maps a possible world at a state to other possible worlds. The desire-, and intention-accessibility relations behave in a similar fashion. More formally, we have the following definition of a Kripke structure.
Definition 2.1 A Kripke structure is defined to be a tuple K = ⟨W, S, {Sw : w ∈ W }, {Rw : w ∈ W }, {Iw : w ∈ W }, L, B, D, I⟩, where W is a set of possible worlds, S is the set of states, Sw is the set of states in each world w ∈ W (S = ∪w∈W Sw), Rw is a total tree relation, i.e., Rw ⊆ Sw × Sw, Iw a set of initial states (Iw ⊆ Sw), L : W × S → 2AP is a function that labels for each world w ∈ W , each state s ∈ Sw with the set of atomic propositions true in that state, and B, D, and I are relations on the worlds W and states S (i.e. O ⊆ W × S × W ), where O is one of B, D, or I.
We also define a world to be a sub-world of another if one of them contains fewer paths, but they are otherwise identical to each other. More formally, we have the following definition.
Definition 2.2 A world w' is a sub-world of the world w, denoted by w' ± w, if and only if
Sw' ⊆ Sw, Iw' ⊆ Iw, Rw' ⊆ Rw,
∀s ∈ Sw' , L(w , s)= L(w, s),
∀s ∈ Sw' , (w , s, v) ∈B iff (w, s, v) ∈ B; and similarly for D and I.
The semantics of BDICTL involves two dimensions: an epistemic and a temporal dimension. The truth of a formula depends on both the epistemic world w and the temporal state s. A pair (w, s) (denoted also sw) is called a situation in which BDICTL formulas are evaluated. The relation between situ- ations is traditionally called an accessibility relation (for beliefs) or a successor relation (for time).
A BDICTL-model M is represented as a Kripke structure. We note a model M in world w as Mw. A trace (path) in a world w ∈ W starting from sw is an infinite sequence of states ρw = swswsw ··· such that sw = sw, and
0 1 2	0


for every i ≥ 0, ⟨sw, sw ⟩ ∈ Rw. The (i + 1)-th state of trace ρw is denoted
i	i+1
ρw[i]. The set of paths starting in state sw of the model Mw is defined by
ΠM (sw)= {ρw | ρw[0] = sw}.
For any BDICTL-model Mw and state sw ∈ Sw, there is an infinite com- putation tree with root labeled sw such that ⟨sw, sw⟩ is an arc in the tree if
i	j

and only if ⟨sw, sw⟩∈ Rw. Satisfaction of formulas, denoted by |=M
, is given

i	j	w
with respect to a model M,a world w, and state s. The expression s |=Mw   ϕ
is read as “model M in world w and state s satisfies ϕ”.
s |=Mw p iff p ∈ L(w, s)
s |=Mw ¬p iff s |=Mw p
s |=Mw ϕ ∨ ψ iff s |=Mw ϕ or s |=Mw ψ
s |=Mw ∃Xϕ iff ∃ρw ∈ ΠMw (s).ρw[1] |=Mw ϕ
s |=Mw ∃Gϕ iff ∃ρw ∈ ΠMw (s).∀j ≥ 0.ρw[j] |=Mw ϕ
s |=Mw ∃ϕUψ iff ∃ρw ∈ ΠMw (s).(∃j ≥ 0.ρw[j] |=Mw ψ) ∧ (∀k, 0 ≤ k < j.ρw[k] |=Mw ϕ)
s |=M Bi(ϕ) iff ∀v, (w, s, v) ∈ B.∀s' ∈ v.s' |=M ϕ
s |=M Di(ϕ) iff ∀v, (w, s, v) ∈ D.∀s' ∈ v.s' |=M ϕ
s |=M Ii(ϕ) iff ∀v, (w, s, v) ∈ I.∀s' ∈ v.s' |=M ϕ
A formula ϕ is said to be valid in Mv, written as |=Mv ϕ, if s |=Mv ϕ for every state s ∈ Sv. A formula is valid if it is true in every state, in every world, in every structure (model).

Specification of Multi-Agent Systems
A multi-agent system contains a finite number of agents. The basic form of an agent is “agent A is init P ”, where A is the name of the agent and P is the program body. Each agent in a multi-agent system is assumed to have a unique name, drawn from a set of agent identif iers. The main part of an agent, which determines its behavior, is the program body P . The basis of program bodies is a simple imperative language, containing iteration (loop loops), sequence (the ; constructor), selection (a form of the if , then, else statement), choice (the | constructor), and assignment operators.
An agent A is allowed to execute by a do instruction any of a set Actions =
{α, ·· ·} of external actions. The simplest way to think of external actions is as native methods in a programming language like Java. They provide a way for agents to execute actions that do not simply affect the agent’s internal state, but its external environment. The basic form of the do instruction is do α, where α ∈ Actions is the external action to be performed. When


we incorporate communication, we do so by modeling message sending as an external action to be performed.
In a conventional programming language, conditions in if statement are only allowed to be dependent on program variables. Unusually, we allow conditions in if statement to be arbitrary formulas of the BDICTL logic (any acceptable formula is allowed as a condition). To make this more concrete, consider the following:
if Bjp then r := p else r := f alse
The idea is that if the agent executing this instruction believes that agent j believes that p, then the agent executing the instruction assigns the value of p to r. If the agent executing the instruction believes it is not the case that agent j believes p but it believes ¬p, then it assigns the value f alse to r. Notice the form of words used here: the agent executing this if instruction must believe that j believes p; the condition does not depend on what j actually believes, but on what the agent executing the statement believes that j believes. As this example illustrates, conditions can thus refer to the mental state of other agents. The general form of a loop construct, as in conventional programming languages, is loop P endloop, where P is a program.
Given a collection {A1, ··· , An} of agents, they are composed into a multi- agent system by the parallel composition operator “  ”: A1  ···  An. Note that, there is no nesting of belief operators and there is no mechanism for generating new agents. Formally, the abstract syntax of multi-agent systems is defined by the grammar below.
Init ::= init p, where p ∈ AP
P ::= do α | p := true or false | if ϕ then P | if ϕ then P else P
| loop P endloop | P ';' P | P '|' P
Agent ::= agent A is Init P MAS ::= Agent  ···  Agent

Example 3.1 To clarify this syntax, let us consider the following scenario involving two agents: a receiver rcv and a sender snd. snd continuously reads news on a certain subject from its sensors (e.g., the standard input). Once read the news, snd informs rcv only if it believes that rcv does not have the correct knowledge about that subject (this in order to minimize the traffic over the network). Once received the news, rcv acknowledges this fact back to snd.
agent snd is	agent rcv is
init ∀p ∈ AP : p := false	init p := false


loop	loop
do read(p);	do getmsg(m);
if p ∧ ¬Brcvp then	if (m = inform(snd, rcv, p)) then
do putmsg(inform(snd, rcv, p));	p := true ∧
if ¬p ∧ ¬Brcv¬p then		do putmsg(inform(rcv, snd, Brcvp)); do putmsg(inform(snd, rcv, ¬p));	if (m = inform(snd, rcv, ¬p)) then
do getmsg(m);	p := false ∧
if (m = inform(rcv, snd, Brcvp)) then	do putmsg(inform(rcv, snd, Brcv¬p));
Brcvp := true ∧ Brcv¬p := false;	endloop if (m = inform(rcv, snd, Brcv¬p)) then
Brcv¬p := true ∧ Brcvp := false;
endloop
agent protocol is
init ∀p ∈ AP : p := false
loop
∀p ∈ AP : p := false;
{
Bsnd ∀F do(putmsg(inform(snd, rcv, p))) := true ∧
Brcv ∀F do(getmsg(inform(snd, rcv, p))) := true
} | {
Bsnd ∀F do(putmsg(inform(snd, rcv, ¬p))) := true ∧
Brcv ∀F do(getmsg(inform(snd, rcv, ¬p))) := true
};
∀p ∈ AP : p := false;
{
Brcv ∀F do(putmsg(inform(rcv, snd, Brcvp))) := true ∧
Bsnd ∀F do(getmsg(inform(rcv, snd, Brcvp))) := true
} | {
Brcv ∀F do(putmsg(inform(rcv, snd, Brcv¬p))) := true ∧
Bsnd ∀F do(getmsg(inform(rcv, snd, Brcv¬p))) := true
}
endloop
We have therefore three agents: snd, rcv, and a network (communication protocol) protocol which allows them to interact. The example above gives the descriptions of snd, rcv and the communication protocol protocol, respectively. In these descriptions, the news subject of the information exchange is the truth value of the propositional atom p. inf orm(snd, rcv, p) returns a message with sender snd, receiver rcv, and content p (inf orm is a FIPA (Foundation for Intelligent Physical Agents) primitive). putmsg and getmsg are the primitives for putting and getting (from the communication channel) a message. read allows for reading from the standard input. Brcv is the operator used to represent the beliefs of rcv as perceived by the other agents, and dually for Bsnd. Notice that the communication protocol has beliefs about rcv and snd and therefore must have a representation of how they behave. We suppose that this representation coincides with what rcv and snd actually are, as described above. This allows us to model the fact that the communication protocol behaves correctly following what snd and rcv do. snd also has beliefs about


rcv. We suppose that snd (which in principle does not know anything about how rcv works) only knows that rcv can be in one of two states, with p being either true or f alse. In the example, Bsnd∀Fdo(< statement >)(Brcv∀Fdo(< statement >)) intuitively means that snd(rcv) will necessarily reach a state in which it will have just performed the action corresponding to <statement >. The agent program protocol codifies the fact that the protocol implements the information flow between snd and rcv, and the fact that it always delivers the messages it is asked to deliver. Some properties that we may want to prove are:
An agent liveness property, e.g., that snd will eventually believe that rcv

believes p or believes ¬p. Its expression is |=
snd
∀F (Brcvp ∨ Brcv¬p).

Where wsnd is the world seen by the agent snd.
An overall system liveness property, e.g., that if it believes p, then in the future snd will believe that rcv will believe p. Its expression is |=M Bsnd(p) ⊃ ∀F Bsnd∀F Brcvp.
Formal Semantics
The semantics of a multi-agent program will be defined as a formula of BDICTL, which characterizes the acceptable computations of the system, and the “men- tal state” of the agents in the system.

[[init p]]Init = Bself p, p ∈ AP
[[do α]]P = Iself α, α ∈ Actions
[[p := e]]P = ∀XBself [[e]]Bexp
[[if ϕ then P ]]P = Bself ϕ ⇒ [[P ]]P
[[if ϕ then P1 else P2]]P = Bself ϕ ⇒ [[P1]]P ∧ (Bself ¬ϕ ∧ ¬Bself ϕ) ⇒ [[P2]]P
[[loop P endloop]]P = [[P ; loop P endloop]]P
[[P1; P2]]P = [[P1]]P ⇒ [[P2]]P
[[P1 | P2]]P = [[P1]]P ∨ [[P2]]P
[[agent A is init P ]]Agent = ( [init]]Init ∧ [[P ]]P )[A '→ self ]
[[A1  ···  An]]MAS = [[A1]]Agent ∧ ··· ∧ [[An]]Agent ∧ ψMAS
The agent program semantic function is defined in terms of the function [[·· ·]]Bexp : Bexp → B, which gives the semantics of Boolean expressions. The four remaining semantic functions are defined above. The idea is that the semantics are defined inductively by a set of definitions, one for each construct in the language.
A declaration “agent A is init P ” binds a name A with the semantics of the init statements and the program body P . We capture the semantics


of this by systematically substituting name A for the place-holder name self in [init]]Init ∧ [[P ]]P . The semantics of a system A1  ···  An is simply the conjunction of the semantics of the component agents Ai, together with some back-ground assumptions ψMAS. The idea of the background assumptions is that these capture general properties of a multi-agent systems that are not captured by the semantics of the language.

Structure Construction for Multi-Agent Systems
We will develop an algorithm to construct a multi-agent structure as defined in Definition 2.1. First we need to build a structure for each agent specification then we will synthesize these structures. At the beginning, a multi-agent system will have a Kripke structure of the form K = ⟨W = {w1, ··· , wn},S =
{Sw1 , ··· , Swn },R = {Rw1 , ··· , Rwn },I = {Iw1 , ··· , Iwn }, L, B = ∅, D = ∅, I =
∅⟩, where n is the number of agents. Then we will compute the sets B, D, and I using the worlds w ∈ W and the labeling function L. At the end, a Kripke structure K will be constructed representing the multi-agent system using the algorithm below. The initial Kripke structure K is generated directly from the agents specifications. In each world, there is a finite set of the BDI operators of the form Oiϕ (where O stands for B, D, or I). This set is considered as a part of the atomic propositions AP .
Let us call TrueBDI(w,v)(s) the set of BDI atoms of world w (of the current agent), of the form Oiϕ, which are true at s (TrueBDI(w,v)(s) = BDI(w,v) ∩ L(w, s)). v is the world of the agent i. A compatibility relation O(w,v) ⊆ BDI(w,v) × Sv, constraints the truth of BDI atoms of a world w to the truth values in the world v. The states of world v compatible with s are those states belonging to the intersection, over the BDI atoms true at s, of the sets of states compatible with TrueBDI(w,v)(s). We extend the compatibility relation to a relation over a set of BDI atoms A⊆ BDI(w,v) as follows.

O(w,v)(A)= 
Oiϕ∈A

O(w,v)(Oiϕ)

Therefore, the set of states of v compatible with a state s of w will be simply denoted by O(w,v)(TrueBDI(w,v)(s)).
Depending on the kind of BDI operator being considered, the compatibility relation may have different properties. What makes M a model of a multi- agent possible world is the particular structure of the compatibility relations among adjacent sub-worlds.
Definition 4.1 A BDICTL model M is a possible world structure if for every


word w, every BDI atom Oiϕ of w and every s ∈ Sw the following conditions hold.
If Oiϕ ∈ L(w, s), then s' ∈ 0(w,v)(TrueBDI(w,v)(s)) implies that s' is reachable in v and s' |=M ϕ.
If Oiϕ /∈ L(w, s), then for some reachable state s' ∈ 0(w,v)(TrueBDI(w,v)(s)), s' |=M чϕ.
Condition 1 tells us what are the states in world v which are compatible with a given state s (satisfying TrueBDI(w,v)(s)), according to the semantics of BDIs, namely that the argument of a BDIs true at a state must be true in all the states reachable from it via compatibility relation. Condition 2, on the other hand, tells us what are the states of world w which actually comply to the semantics of BDIs, i.e. the states which assign truth values to BDI atoms in accordance with the semantics of the BDI operator.

Synthesizing Multi-Agent Structure
In this section we present a synthesis algorithm that automatically constructs the suitable multi-agent Kripke structure ł from a set of independently gen- erated structures for each agent specification and a selected set of BDI atoms, thus leading to significant savings in the modeling phase. The synthesis algo- rithm is reported below. It takes in input a set of agents represented as world structures, and a set of BDI atoms. Intuitively, the algorithm at each world computes as a first step the compatibility relations associated to each BDI operator of the world. This is done according to Condition 1 of Definition 4.1. The second step is to implement Condition 2 of the same definition. The idea is to check whether there are states of the current world where the negation of some BDI atoms conflicts with other BDI atoms true at that state. Con- dition 2 tells us no such state is admissible in a multi-agent structure as they correspond to impossible combination of BDI atoms. Therefore, we need to get rid of all those states in the structure of the world. Once those two steps are performed at each world, the resulting structure is indeed a multi-agent structure.
Algorithm 1 BUILD-MODEL(w, M)
{
for each i ∈ agent identif iers do
Let v be the world structure of the agent i
if BDI(w,v) /= ∅ then
Let wv be the world of the agent i as viewed by the agent of the world w
M← BUILD-MODEL(wv, M)
M← CreateCR(w, v, M) end if
end for return(M)


}
The initial call is BUILD-MODEL(top, ł), where top is the root of the
Kripke structure (in our example, is the protocol agent). At the end of the algorithm, ł will contain the compatibility relations of the structure rooted at w. The algorithm BUILD-MODEL recursively descends depth-first the tree of worlds rooted at w, and builds the compatibility relations (algorithm below) with all the worlds one level below the current world w. The creation of the compatibility relations is using the algorithm MAS-Sat(w, ϕ) (descried in the next section) which computes the set of states satisfying the formula ϕ in the world w.
Algorithm 2 CreateCR(w, v, M)
{
/* Condition 1 of Deﬁnition 4.1 */ for each Oiϕ ∈ BDI(w,v) do
[[ϕ]]v ← MAS-Sat(v, ϕ)
O(w,v)(Oiϕ) ← [[ϕ]]v
end for
/* Condition 2 of Deﬁnition 4.1 */
BadStates ←∅ 
for each Oiϕ ∈ BDI(w,v) do
[[¬ϕ]]v ← MAS-Sat(v, ¬ϕ)
BadBDI ← {A ⊆ BDI(w,v) \ {Oiϕ}| O(w,v)(A) ∩ [[¬ϕ]]v = ∅}
BadStates ← BadStates ∪ {s ∈ Sw | TrueBDI(w,v)(s) ⊆ BadBDI}
end for
' ← Sw \ BadStates
if R' (which is Rw restricted to S' ) is total tree relation then
substitute w with ⟨S' , R' , Iw ∩ S' ⟩ in M
w	w	w
else remove w from M
return(M)
}

BDICT L Model Checking
In this section, we present an extension of the standard CTL model checking algorithm [2]. Given a BDICTL-formula ϕ and a world of BDICTL-model łw with a finite set of states (Sw), the model checking algorithm MAS-Sat(w, ϕ) (presented below) computes the set of states from the world w satisfying the BDICTL formula ϕ. This set is denoted [ϕ]]w, and is computed in a recursive way, i.e. by computing for each sub-formula ψ of ϕ the set [ψ]]w. In order to decide whether s |=Mw ϕ we just have to check whether s ∈ [[ϕ]]w.
Algorithm 3 MAS-Sat(w, ϕ)
{
case ϕ of
p | p ∈ AP : [[ϕ]]w ← {s | p ∈ L(w, s)}
Ojψ | Ojψ ∈ AP : [[ϕ]]w ← {s | Ojψ ∈ L(w, s)}
Ojψ | Ojψ /∈ AP : Let v be the world of the agent j and let wv be the world of the agent j as viewed by the agent of the world w [[ψ]]wv ← MAS-Sat(wv, ψ)

−1
(w,v)
([[ψ]]wv ) ← {A ⊆ BDI(w,v) | O(w,v)(A) ⊆ [[ψ]]wv }



[[ϕ]]w ← {s ∈ Sw | TrueBDI(w,v)(s) ⊆ O−1
([[ψ]]wv )}

¬ψ : [[ϕ]]w ← Sw \ MAS-Sat(w, ψ)
ψ ∨ γ : [[ϕ]]w ← MAS-Sat(w, ψ) ∪ MAS-Sat(w, γ)
∃Xψ : Q ← MAS-Sat(w, ψ)
[[ϕ]]w ← {s ∈ Q | ∃⟨s, s'⟩∈ Rw ∧ s' ∈ Q}
∃Gψ : [[ϕ]]w ← νZ.([[ψ]]w ∩ ∃X Z)
∃(ψUγ) : [[ϕ]]w ← µZ.([[ψ]]w ∪ ([[γ]]w ∩ ∃X Z)) end case
return([[ϕ]]w )
}

Conclusion
We have presented a new approach to the verification of multi-agent systems, based on the use of possible worlds to describe the system, modal tempo- ral logic to specify the properties, and a decision procedure based on model checking technique. One contribution is the presentation of an imperative multi-agent programming language, and a formal semantics for this language in terms of the BDICTL logic. The multi-agent program is used to systemi- cally construct the agents state spaces. Our main contribution is the synthesis of these state spaces using the agents mental attitudes to generate the pos- sible worlds structures. These possible worlds will be used by the decision procedure to solve the problems of verification.
Currently we are investigating the extension in many directions. One is the extension of the language to support the other types of expression in particular the arithmetic expressions by incorporating a tool for abstracting the program using the framework of predicate abstractions. Another problem which is taking our attention is the explosion problem where techniques like the equivalence based reduction or space partition can be investigated. One of the most and interesting extension is to treat the case of functional dependencies between the mental attitudes, where a mental attitude is considered to be a function of one or more other mental attitudes.

References
Bratman, M. E., D. Israel, and M. E. Pollack, Plans and resource bounded practical reasoning, Computational Intelligence, 4 (1988), 349–355.
Clarke, E. M., O. Grumberg, and D. A. Peled, “Model Checking”. MIT Press, (1999).
Cohen P. R., and H. J. Levesque, Intention is Choice with Commitment, Artificial Intelligence,
42 (1990), 213–261.
Doyle J., Rationality and its roles in reasoning, Computational Intelligence, 8(2) (1992), 376– 409.
Emerson E. A., and J. Srinivasan, Branching time temporal logic, Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, Springer-Verlag, 123–172, 1989.


Halpern J. Y., and Y. O. Moses A guide to completeness and complexity for modal logics of knowledge and belief, Artificial Intelligence, 54 (1990), 319–379.
Rao A. S., and M. Georgeff, Decision procedures for BDI logics, Journal of Logic and Computation, 8(3) (1998), 293–344.
Rao A. S., and M. P. Georgeff, Modeling rational agents within a BDI architecture, Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning, Morgan Kaufmann, 1991.
Rao A. S., and M. P. Georgeff, An abstract architecture for rational agents, Knowledge Representation and Reasoning, 439–449, 1992.
Rosenschein S. J., and L. P. Kaelbling, The synthesis of digital machines with provable epistemic properties, Proceedings of the First Conference on Theoretical Aspects of Reasoning about Knowledge, Morgan Kaufmann, 1986.
Shoham Y., Agent0: A simple agent language and its interpreter, Proceedings of the Ninth National Conference on Artificial Intelligence (AAAI91), 704–709, 1991.
Woodridge M., Computationally grounded theories of agency, Fourth International Conference on Multi-Agent Systems (ICMAS-2000), 13–20, 2000.
Woodridge M., and M. Fisher, A decision procedure for a temporal belief logic, Proceedings of the First International Conference on Temporal Logic, 1994.
