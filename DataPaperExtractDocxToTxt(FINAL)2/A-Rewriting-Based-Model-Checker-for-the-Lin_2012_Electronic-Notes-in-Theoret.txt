Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 290 (2012) 19–36
www.elsevier.com/locate/entcs

A Rewriting-Based Model Checker for the Linear Temporal Logic of Rewriting
Kyungmin Bae1 Jos´e Meseguer2
Department of Computer Science University of Illinois at Urbana-Champaign Urbana, USA

Abstract
This paper presents a model checker for LTLR, a subset of the temporal logic of rewriting TLR∗ extending linear temporal logic with spatial action patterns. Both LTLR and TLR∗ are very expressive logics gen- eralizing well-known state-based and action-based logics. Furthermore, the semantics of TLR∗ is given in terms of rewrite theories, so that the concurrent systems on which the LTLR properties are model checked can be specified at a very high level with rewrite rules. This paper answers a nontrivial challenge, namely, to be able to build a model checker to model check LTLR formulas on rewrite theories with relatively little effort by reusing Maude’s LTL model checker for rewrite theories. For this, the reflective features of both rewriting logic and its Maude implementation have proved extremely useful.
Keywords: temporal logic of rewriting, model checking, rewriting logic, reflective transformation


Introduction
In temporal logic and model checking one can distinguish two main camps: a state- based camp, in which all atoms in formulas are state predicates (e.g., LTL, CTL, and CTL∗ [11]); and an event-based camp, where the formulas’ atoms are actions or events (e.g., Hennesy-Milner’s logic [22], or De Nicola and Vaadrager’s A-CTL∗ logic [35]). At the semantic level, state based formulas are evaluated on Kripke structures. Instead, action-based formulas are evaluated on labeled transition systems.
Some properties can be naturally expressed in state-based logics and are dif- ficult to express in action-based logics, whereas the opposite is the case for other properties. This means that, when the property does not fit well a given logic, one has to “cook” in a possibly complex way both the system description (as a Kripke structure or a label transitions system depending on the logic’s semantics) and the

1 Email: kbae4@cs.uiuc.edu
2 Email: meseguer@cs.uiuc.edu

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.11.009

property in order to model check it in the given logic. The situation is even more challenging for mixed properties such as fairness properties (see the discussion [31]), where both state-based predicates and actions are involved.
Reflecting on this situation we can speak, as in [31], of tandems, each given by a pair LS/LP , where LS is a formalism to specify systems (for example, the formalisms of Kripke structures or of label transition systems), and LP is a formalism to describe properties (for example, some state-based or action-based temporal logic). The frequent need for “cooking” both the system and the property in both state-based and action-based tandems is then due to a lack of expressiveness in both cases.

An Example
To illustrate the lack of expressiveness, of either solely state-based or solely action- based systems, we use a variant of a simple parallel language, whose rewriting semantics is presented in [15,18], in which we can define Dekker’s algorithm for mutual exclusion and then model check some of its properties. The parallel language supports processes that execute concurrently on a shared memory machine and communicate with each other through shared variables.
Dekker’s algorithm has two processes with entirely symmetric code. Process 1 sets a Boolean variable c1 to 1 to indicate that it wishes to enter its critical section. Process 2 does the same with variable c2. If one process, after setting its variable to 1 finds that the variable of its competitor is 0, then it enters its critical section right away. In case of a tie (both variable set to 1) the tie is broken using a variable turn that takes values in {1,2}. For example, the code of process 1 is a follows:

repeat
’c1 := 1 ;
while ’c2 = 1 do if ’turn = 2 then
’c1 := 0 ;
while ’turn = 2 do skip od ; ’c1 := 1
fi
od ;
crit ; ’turn := 2 ; ’c1 := 0 ; rem forever

where fragments of code for the critical section and for the remaining part of the program are respectively abstracted as constants crit and rem 3 .
Global states are modeled as pairs, with first component a set of processes, and second component a shared memory. In their Maude rewriting semantics such global states are instances of the pattern {[I,R] | S, M}, where [I,R] is one of the processes with I its process id and R its program code to be executed next by process, | is an associative-commutative parallel process composition operator, S is the remaining set of processes, and M is the shared memory. The language’s operational semantics is then defined by rewriting rules for each language feature.

3 We assume that crit is terminating, but rem may not be. See [15] for a “cooked” version of the example, and [1] for the Maude specification of both the example and is LTLR properties.

A property to be checked (in fact it fails, see Section 5) for Dekker’s algorithm is the strong fairness property that executing infinitely often implies entering one’s critical section infinitely often, expressed as the LTL-like formula
23 exec.p1 ⇒ 23 in-crit.p1.
The predicate in-crit.p1 means that process 1 is in its critical section and can be defined easily by the equation
{[p1, crit ; R] | S, M} |= in-crit.p1= true.
However, the above strong fairness formula is only “LTL-like” and not really an LTL formula, since exec.p1, which asserts the execution of process 1, cannot be deﬁned directly, because there is no way to know which process has executed some statement using the current state description. To express exec.p1 we need to “cook” both the state representation and the operational semantics by adding a third component to the state, indicating the last executed process, and modifying the semantic rules to update such third component. After this “cooking,” we can define exec.p1 as a state predicate by the equation
{[I, R] | S, M, p1} |= exec.p1= true.
This is just a convoluted way to represent what is really an action (exec.p1) indi- rectly as a state predicate. Likewise, there are also natural properties in state-based system that would need a convoluted “cooking” to be represented as actions. For example, a predicate which is true when a process is in its rem part, say in-rem.p1, is nontrivial to define in an action-based system, while it is trivial to define in a state-based system by an equation similar to that for in-crit.p1.
In this paper we describe a new tandem RewritingLogic/TLR∗, first proposed in [31], where the need for cooking both the system and the property disappears. For example, the above strong fairness formula for Dekker can be expressed directly in TLR∗. We also present a Maude-based model checker for the LTLR sublogic of TLR∗, which extends with actions the LTL logic. The point is that rewriting logic
[30] is more expressive than both Kripke structures and labeled transitions systems, since in a rewrite theory state predicates can be equationally specified, and rewrite rules are labeled. The logic TLR∗, called the temporal logic of rewriting, extends CTL∗ with spatial action patterns, which are quite expressive, since they can localize a rewrite rule’s action to a given context and a partial substitution.
The nontrivial challenge answered in this paper is to be able to build a model checker for the RewritingLogic/LTLR tandem with relatively little effort by reusing Maude’s LTL model checker for rewrite theories. For this, the reflective features of both rewriting logic and its Maude implementation [15] have proved extremely useful. In essence, the new model checker design uses a result in [31] by which the model checking of a LTLR formula on a rewrite theory R can be reduced to the model checking of a translated LTL formula on a translated Kripke structure. Using reflection, this is here achieved by a reflective theory transformation associating each rewrite theory R with a new theory such that the given LTLR formula holds for R and a given initial state if and only if its LTL translation holds for the new theory. The paper is organized as follows. Section 2 presents the necessary background

and Section 3 provides the formal foundations, defining and proving correctness of the reflective construction. Section 4 explains the reflective design of a LTLR model checker based on the foundations. Section 5 illustrates the use of the model checker with an example; and Section 6 discusses related work and presents conclusions.
Rewriting Logic and the Temporal Logic of Rewriting
This section explains the concepts of RewritingLogic and TLR∗, constituting the RewritingLogic/TLR∗ tandem, which is the semantic infrastructure of the model checker described in this paper.
Rewriting Logic
A rewrite theory is a formal specification of a concurrent system with static states and concurrent transitions between the states. More precisely, a rewrite theory is a triple R = (Σ, E, R) 4 such that:
(Σ, E) is a many-sorted equational theory. 5 The initial algebra TΣ/E defined by the equational theory (Σ, E) defines the states of the system specified by R.
R is a collection of rewrite rules of the form l : q −→ r, with l a label (which can be duplicated for several rules), q and r Σ-terms of the same sort, and such that the set of variables vars(r) is a subset of the variables vars(q). These rewrite rules define concurrent transitions between states.
More precisely, each state is modeled as an E-equivalence class [t]E of ground terms, and rewriting happens modulo E; that is, rewriting E-equivalence classes [t]E rep- resenting states, not just terms t. A one-step rewrite [t]E −→R [t∗]E exists in R iff there exists u ∈ [t]E such that u can be rewritten to v using some rule l : q −→ r in R in the standard way, 6 denoted u −→R v, and we furthermore have v ∈ [t∗]E.
The most useful rewrite theories satisfy additional executability conditions, be-
cause for arbitrary E and R, whether [t]E −→∗ [t∗]E is undecidable in general. A
rewrite theory R = (Σ,E ∪ A, R) is computable if the following conditions hold:
Equality modulo A is decidable, and there exists a matching algorithm modulo A, producing a finite number of A-matching substitutions or failing otherwise, that can implement rewriting in A-equivalence classes.
(Σ,E ∪ A) is ground terminating and confluent modulo A [16]. That is: (i) there are no infinite sequences of rewritings with E module A; and (ii) for each [t]A ∈ TΣ/A there is a unique A-equivalence class [canE/A(t)]A ∈ TΣ/A called

4 This definition can be extended to the more general rewrite theories in [3,15], which uses a more expressive equational logic, conditional rewrite rules, and frozen function operators.
5 There are various possibilities for the equational theory (Σ,E) such as unsorted, many-sorted, order- sorted, or even membership equational logic. However, to keep the exposition as simple as possible, we will assume that (Σ,E) is a many-sorted equational theory.
6 See [16] for basic notation on term rewriting. Positions in a term are denoted as strings of nonzero natural numbers and represent tree positions when the term is parsed as a tree. Two useful notions are that of a subterm of a given term t at a given position p, denoted t|p, and of replacement in t of such a subterm by another term u at position p, denoted t[u]p. For example, in the term t = x + ((z + 0)+ y), the subterm at position 2.1 is z + 0, and the replacement t[z]2.1 is the term x + (z + y).

the E-canonical form of [t]A modulo A such that the last term, which cannot be further rewritten with E module A, of any terminating sequence beginning at [t]A is necessarily [canE/A(t)]A.
The rules R are ground coherent relative to the equations E modulo A [37]. That is, if [t]A is rewritten to [t∗]A by a rule l in R, [canE/A(t)]A is also rewritten to [t∗∗]A by the same rule l such that [canE/A(t∗)]A = [canE/A(t∗∗)]A
In addition, to make the integration of rewriting logic and TLR∗ smoother, we define the class RWTh0 of rewrite theories as follows.
Definition 2.1 R ∈ RWTh0 when the following condition is satisfied:
R is computable and has a sort State as its chosen sort of states.
If R has a sort named Prop, then it must also have a sort named Bool with constants true and false, and an operator |= : State × Prop → Bool . 7
The subsignature Π ⊆ Σ of its state predicate symbols is the set of all operators in Σ of the form p : A1 × · · · × An → Prop, n ≥ 0. A1,..., An are called the parameter sorts of the atomic state predicate p.
R is deadlock-free, that is, there are no finite sequences
[t1]A −→R [t2]A ... [tn]A −→R [tn+1]A
such that [tn+1]A cannot be further rewritten (i.e., it is a “deadlock state”). This is not at all a strong restriction, since, as explained in [15,33], any rewrite theory R whose rules do not have rewrites in their conditions can be transformed into a semantically equivalent theory R^ that is deadlock-free.
Proof Terms and Computations
The inference rules of rewriting logic derive all concurrent computations in the system specified by R [3,30]. That is, given two states [u], [v] ∈ TΣ/E∪A, one can reach [v] from [u] by some possibly complex concurrent computation if and only if one can prove R ▶ [u] −→+ [v] 8 . In rewriting logic any such complex computation reaching [v] from [u] is witnessed by a proof term [30,31], say λ, written R ▶ λ : [u] −→+ [v].
Proof terms are identified modulo natural equations making any proof term λ al- ways equivalent to an interleaving description as a sequential composition γ1; ... ; γk of one-step proof terms γi [3,30,31], which have a very simple algebraic description.
Definition 2.2 Given rewrite proof R ▶ γ : [u] −→R [v] using a rewrite rule l : q −→ r ∈ R, a one-step proof term γ has the form t[l(φ)]p, where t ∈ [u], p is a position in t where the rule is applied, and φ = {x1 '→ u1,..., xn '→ un} is a substitution such that t|p = φ(q), t[φ(r)]p ∈ [v], where x1,..., xn are variables in q.
In the above definition, if t is an E/A-canonical term, say t = canE/A(u), we say that canE/A(u)[l(φ)]p is a canonical one-step proof term [31]. Canonical one-step

7 Prop is the designated sort of atomic state predicates, and |= is the function defining whether a given state satisfies a given state predicate.
8  [u] −→+ [v] denotes a combination of one or more sequential compositions of concurrent rewrites.

rewrite proofs are the key ingredient to arrive at our desired notion of computa- tion, on which the truth of TLR∗ path formulas will be evaluated. Before defining computation, let us define two useful sets of canonical proof terms. First, the set (CanΣ/E,A)State of all A-equivalence classes of the form [canE/A(t)]A, where t is a ground Σ-term of sort State. Second, we can define the set CanPTerms1(R) of all one-step canonical proof terms in R. In a computable rewrite theory, any proof term is always semantically equivalent to a canonical one [31].
Definition 2.3 An inﬁnite computation in R ∈ RWTh0 is a pair of functions (π, γ), with π : N −→ (CanΣ/E,A)State and γ : N −→ CanPTerms1(R) such that for all
γ(n)
n ∈ N, π(n) −→ π(n + 1) is a canonical one-step rewrite proof in R. Graphically,

γ(0)
γ(1)
γ(n)

π(0) −→ π(1) −→ π(2) ... π(n) −→ π(n + 1) ... 
Comp(R)∞ denotes the set of infinite computations in R, and for each [t] ∈ (CanΣ/E,A)State, Comp(R)∞ denotes the infinite computations starting at [t], that is, those computations (π, γ) such that π(0) = [t]. Given an infinite computation (π, γ) and a number i ∈ N, (π, γ)i denotes the suffix of (π, γ) beginning at position i, that is, the pair of functions (π ◦ si,γ ◦ si) with s the successor function, s0 the identity function, and sn+1 = s ◦ sn.

Spatial Actions
Spatial actions are the action atoms of TLR∗. They generalize one-step proof terms, which can be thought of as ground-instantiated spatial actions. Spatial ac- tions describe patterns, which in general specify not just a single one-step proof term, but a possibly infinite set of such proof terms. Roughly speaking, we can think of spatial actions as “one-step proof terms with variables,” but they are slightly more general than that as we explain below.
Let Ω be the subsignature of constructors 9 and L be the set of labels labeling rules in R, and assume that Ω ∩ L = ∅. The signature Ω(L) extends Ω by adding:
fresh sorts Top and Subst
an associative and commutative operator _;_ : Subst Subst → Subst.
for each rewrite rule l : q −→ r in R with q, r of sort B, and with variables
x1,..., xn in q having sorts B1,..., Bn:
operators l : Subst → B and x1\_ : B1 → Subst, ..., xn\_ : Bn → Subst
a constant l of sort B and an operator top : B → Top,
Let X be a many-sorted set of variables with an infinite set of variables for each sort in Ω. Consider the algebras: (i) TΩ(L)/A(X) of A-equivalence classes of Ω(L)- terms with variables in X; and (ii) TΩ/A(X) of A-equivalence classes of Ω-terms with variables in X. Also, assume that the substitution φ has the form x1\u1; ··· ; xn\un.

9 Ω ⊆ Σ is the subsignature of constructors associated with the ground confluent and terminating (modulo
theory (Σ,E ∪ A), where f ∈ Ω iff there is a ground term t s.t. f is a function symbol in [canE/A(t)]

Definition 2.4 R’s spatial action patterns SP (Ω, L) ⊂ TΩ(L)/A(X) are defined by:
for each l ∈ L, [l]A, [top(l)]A ∈ SP (Ω, L)
[l(φ)]A ∈ SP (Ω, L) if l ∈ L, [l(φ)]A ∈ TΩ(L)/A(X), u1,..., un ∈ TΩ/A(X)
[top(l(φ))]A ∈ SP (Ω, L) if l ∈ L, [top(l(φ))]A ∈ TΩ(L)/A(X), u1,..., un ∈ TΩ/A(X)
[v[l]p]A ∈ SP (Ω, L) if p is not the empty (top) position, l ∈ L, [v[l]p]A ∈ TΩ(L)/A(X), and v ∈ TΩ/A(X).
[v[l(φ)]p]A ∈ SP (Ω, L) if p is not the empty (top) position, l ∈ L, [v[l(φ)]p]A ∈ TΩ(L)/A(X), and v, u1,..., un ∈ TΩ/A(X).
SP (Ω, L) defines Ω(L)-terms that are spatial action patterns. Note that CanPTerms1(R) ⊆ SP (Ω, L), so that any canonical one-step proof term is a ground version of some spatial action pattern.
An action pattern of the form l describes a rule labeled l that can be applied anywhere. An action pattern l(φ) allows l to also be applied anywhere, but con- strains the variable instantiation related to rule l to be itself a further instance of φ. Action patterns of the form top(l(φ)) are needed to cover the case where l is applied at the top of the term. The most fully spatial patterns are those of the form v[l(φ)]p with v a nonempty context and p a position. The instance-of relation be- tween a spatial action pattern and a proof term captures these meanings of spatial
action patterns. Let [u]A ≤A [v]A iff there is a many-sorted substitution θ such that [u]A = [θ(v)]A 10 . In addition, for substitution terms, let us define [φ]A ≤A [ϕ]A iff for all [xi\vi]A ∈ [ϕ]A, there exists [xi\ui]A ∈ [φ]A such that [ui]A ≤A [vi]A.
Definition 2.5 The instance-of relation between a canonical one-step proof term γ and a spatial action pattern δ ∈ SP (Ω, L), denoted γ ±A δ, is a slight variant of the ≤A relation defined as follows:
[v[l(φ)]p]A ±A [l]A
[v[l(φ)]p]A ±A [l(ϕ)]A iff [φ]A ≤A [ϕ]A
[v[l(φ)]p]A ±A [w[l]p∗ ]A iff [v[l( )]p]A ≤A [w[l( )]p∗ ]A
[v[l(φ)]p]A ±A [w[l(ϕ)]p∗ ]A iff [v[l( )]p]A ≤A [w[l( )]p∗ ]A and [φ]A ≤A [ϕ]A
[l(φ)]A ±A [top(l)]A
[l(φ)]A ±A [top(l(ϕ))]A iff [φ]A ≤A [ϕ]A.

Reflection and Metalevel Computation
Rewriting logic is reflective in a precise mathematical way [12], namely, there is a finitely presented rewrite theory U that is universal in the sense that we can represent in U any finitely presented rewrite theory R (including U itself) as a term R, any terms t, t∗ in R as terms t, t∗, and any pair (R, t) asa term ⟨R, t⟩, in sucha way that we have the following equivalence
R ▶ t −→∗ t∗ ⇔ U ▶ ⟨R, t⟩ −→∗ ⟨R, t∗⟩

10 This is a decidable relation by our assumption that there is an A-matching algorithm

Since U is representable in itself, we can achieve a “reflective tower” with an arbi- trary number of levels of reflection [12,13]:
R ▶ t →∗ t∗ ⇔ U ▶ ⟨R, t⟩ →∗ ⟨R, t∗⟩ ⇔ U ▶ ⟨U, ⟨R, t⟩⟩ →∗ ⟨U, ⟨R, t∗⟩⟩ ... 
Key functionality of the universal theory U can be controlled by descent func- tion[15,14]. For example, in Maude, given R = (Σ,E∪A, R), several key constructs of U are defined by the following descent functions:

metaReduce(R, t) metarepresents the E/A-canonical form of term t in R. If R is computable, then [t]E/A = [t∗]E/A iff metaReduce(R, t)= metaReduce(R, t∗).

metaMatch(R, t, t∗) metarepresents the instance-of modulo A relation between terms: t∗ ≤A t iff metaMatch(R, t, t∗)= true.

metaXapply(R, t, l, m) 11 metarepresents the m-th one-step rewrite of term t by rule l in R. R ▶ [v[l(φ)]p]A : t → t∗ iff ∃m s.t. metaXapply(R, t, l, m) = (t∗, v[]p, φ).

The Linear Temporal Logic of Rewriting
TLR∗ is a family of logics parameterized by the spatial actions SP (Ω, L) and the signature of atomic propositions Π. The most general of these logics is TLR∗,a gen- eralization of the state-based CTL∗ logic that allows both spatial actions and state predicates in formulas. It contains various important sublogics of interest, which appear as special cases (see [31]). For our model checking purposes here, where we are interested in extending with support for spatial actions the MaudeLTL model checker for rewrite theories described in [15], we focus on LTLR, the sublogic gen- eralizing LTL, which is parameterized as LTLR(SP (Ω, L), Π) by the spatial actions SP (Ω, L) and the signature of state predicates Π. The following is the syntax for LTLR in BNF-like style, where, instead of using CTL∗-like notation, we adopt the implicitly universally path quantified LTL notation 12 :
δ : SP (Ω, L), p : Prop(Π), ϕ, ϕ∗ : LTLR(SP (Ω, L), Π)
LTLR(SP (Ω, L), Π) : δ | p | ¬ϕ | ϕ ∨ ϕ∗ | ϕ ∧ ϕ∗ | ⃝ϕ | ϕ Uϕ∗ | ϕRϕ∗ | ϕWϕ∗ | 3ϕ | 2ϕ
Smaller and useful sublogics of TLR∗(SP (Ω, L), Π) can be obtained by re- stricting the atomic propositions and/or spatial actions allowed. That is, we can define sublogics of TLR∗ parameterized by a subset W ⊆ SP (Ω, L) of spa- tial actions, and a subset Δ ⊆ Prop(Π) of atomic propositions. Specifically, the sublogic LTLR(W, Δ) ⊆ LTLR(SP (Ω, L), Π) is defined by the set-theoretic for- mula LTLR(W, Δ) = {ϕ ∈ LTLR(SP (Ω, L), Π) | sp(ϕ) ⊆ W ∧ prop(ϕ) ⊆ Δ}, where sp(ϕ) denotes the set of spatial action subformulas of ϕ, and prop(ϕ) de- notes the set of atomic proposition subformulas. In the particular, when W = ∅, and Δ = Prop(Π), we obtain specializations to the state-based logics LTL; that is,

11 This definition of metaXapply describes only part of the actual function. See [15] for the full definition.
12 We assume that all state predicate constants and function symbols are constructors, i.e., that there is a subsignature containment Π ⊆ Ω, and then define the set Prop(Π) of atomic propositions as the set of ground terms Prop(Π) = TΩProp .

LTL(Π) = LTLR(∅, Π). For other specializations of this kind to various state-based and action-based logics see [31].
The semantics of formula ϕ ∈ LTLR(SP (Ω, L), Π) is given by the satisfaction relation R, [t] |= ϕ, where R ∈ RWTh0 has subsignatures of constructors Ω and of state predicates Π, and [t] is a state (i.e., an A-equivalence class [t]A in E- canonical form modulo A and of sort State, where E ∪ A are the equations in
R). By definition, R, [t] |= ϕ holds if and only if for each infinite computation (π, γ) ∈ Comp(R)∞ the path satisfaction relation R, (π, γ) |= ϕ holds. Since one can express all of LTLR(SP (Ω, L), Π) in terms of SP (Ω, L), Prop(Π), and the basic
connectives T, ¬, ∨, ⃝, and U , it is enough to define the semantics for the atoms and for those connectives. Since LTLR generalizes LTL, the semantic definitions are entirely similar to those for LTL (see, e.g., [27]). The key new addition is the semantics of spatial actions; the relation R, (π, γ) |= δ holds if and only if the proof term γ(0) of a current computation is an instance of a spatial action pattern δ.
The path satisfaction relation is defined inductively as follows:
R, (π, γ) |= T
R, (π, γ) |= p ⇔  canE/A(π(0) |= p)= true
R, (π, γ) |= δ ⇔ γ(0) ±A δ
R, (π, γ) |= ¬ϕ ⇔ R, (π, γ) |= ϕ
R, (π, γ) |= ϕ ∨ ϕ∗ ⇔  R, (π, γ) |= ϕ or R, (π, γ) |= ϕ∗
R, (π, γ) |= ⃝ϕ ⇔ R, (π, γ)1 |= ϕ
R, (π, γ) |= ϕ Uϕ∗ ⇔ ∃k ∈ N s.t. R, (π, γ)k |= ϕ∗ ∧ ∀0 ≤ i < k R, (π, γ)i |= ϕ
At the syntactic level, we have seen that LTLR contains LTL. Similar contain- ments exist for pure action logics [31]. This generality has a counterpart at the semantic level: both Kripke structures and labeled transition systems can be seen as very simple special cases of rewrite theories [31].



Reflective Reduction to State-Based Temporal Logics
To make possible the use of standard CTL∗ (or LTL) model checkers to verify TLR∗ (or LTLR) properties of finite-state systems specified by rewrite theories, we need to show that there is a pair of model and formula transformations faithfully map- ping the tandem RewritingLogic/TLR∗ to the tandem Kripke/CTL∗. After briefly describing how such a mapping is mathematically defined in terms of Kripke struc- tures in Section 3.1 (summarizing results in [31,32]), we give in Section 3.2 a new construction of the same mapping at the level of rewrite theories, as a reflective rewrite theory transformation and prove the correctness of this new construction. Section 3.2 provides the theoretical foundations for the reflective design and imple- mentation of the Maude LTLR model checker described in Section 4.

Reduction to State-Based Temporal Logics
The faithful mapping of tandems we seek is a mapping parametric in W
(KW , (˜)) : RewritingLogic/TLR∗(W, Π) −→ Kripke/CTL∗(Π ∪ W )
with W a finite set of spatial actions 13 in the given rewrite theory R, and Π the subsignature of state predicates in R.
Definition 3.1 Given R ∈ RWTh0 and a finite set W ⊆ SP (Ω, L), the construction
KW maps the rewrite theory R to the following Kripke structure 14 KW (R):
Its set of states is (CanΣ/E,A)State × P(W )
Its transition relation is defined by the equivalence: ([t],U ) −→ ([t∗],V ) iff

γ
there is a canonical one-step rewrite proof [t] −→
[t∗] in R, and V is the set

act W (γ)= {δ ∈ W | γ ±A δ}.
Its set of atomic propositions is the set Prop(Π) ∪W , and the labeling function maps a state ([t],U ) to the set of atomic propositions LR([t]) ∪ U , where, by definition, LR([t]) = {p ∈ Prop(Π) | canE/A([t] |= p)= true}.
By the above definition, ([t],U ) |= δ if and only if a spatial action pattern δ ∈ U , where [t] isa state of R and U ⊆ W . Since the condition (ii) asserts that U is the set of all spatial action patterns of which the one-step proof term of a current computation is an instance, this coincides with the semantics of R, (π, γ) |= δ defined in Section 2.2.
Definition 3.2 Given a formula ϕ ∈ TLR∗(W, Π) we can map it to the formula ϕ˜ ∈ CTL∗(W ∪ Π) by systematically replacing each occurrence of a spatial action δ ∈ W in ϕ by the formula Xδ.
The construction KW (R), with the above formula translation (˜), defines a map- ping of tandems (KW , (˜)) : RewritingLogic/TLR∗(W, Π) −→ Kripke/CTL∗(Π∪W ). This mapping is a faithful mapping of tandems preserving the satisfaction relations
|= in TLR∗(W, Π) and |=CTL∗ in CTL∗(Π ∪W ). This is shown by the following the- orem proved in detail in [31], where a complexity-theoretic analysis of the reduction is also given.
Theorem 3.3 Given a rewrite theory R ∈ RWTh0 and a ﬁnite W ⊆ SP (Ω, L), for each state [t] in R, U ⊆ W, and ϕ ∈ TLR∗(W, Π), the following equivalence holds:
R, [t] |= ϕ ⇔ KW (R), ([t],U ) |=CTL∗ ϕ˜
The KW Construction as a Reflective Theory Transformation
The KW (R) construction maps each rewrite theory in RWTh0 to a Kripke structure. However, as pointed out in [31], it is very useful to decompose the mapping R '→

13 Since any TLR∗ formula ξ only involves a finite set sp(ξ) of spatial actions as subformulas, it is always sufficient to consider formulas in TLR∗(W, Π) with W finite.
14 Recall that a Kripke structure on a set AP of atomic propositions is a triple K = (A, R, L), with A a set of states, R ⊆ A × A a total transition relation, and L : A −→ P(AP ) a labeling function assigning to each state a ∈ A the set L(a) ⊆ AP of the atomic propositions that hold in a.

KW (R) into a rewrite theory transformation R '→ RW followed by the general construction R '→ K(R), spelled out in detail in [15,18], which maps each RWTh0 to its underlying Kripke structure. That is, we can decompose the KW (R) construction as KW (R) = K(RW ). This is particularly useful for tool building purposes, since the construction R '→ K(R) is already automated in Maude’s LTL model checker [15]. So, “essentially” all we need to do is to automate the theory transformation R '→ RW . Here is where the reflective properties of rewriting logic summarized in Section 2.1 and efficiently supported in Maude by the META-LEVEL module become extremely useful. In what follows we describe in detail and prove correct a reflective, parametric construction for the R '→ RW transformation in which the parameter R is metarepresented as a term R in the universal rewrite theory U . We can then obtain the R '→ RW construction as a reflective parametric rewrite theory U ( ) which, when instantiated with parameters W and R, yields a theory UW (R) that extends U and provides a correct realization of the theory RW . We explain in detail the parametric UW (R) construction in what follows.
Note that, in particular, the UW (R) construction has to metarepresent the instance-of relation ±A, between a one-step proof term and a spatial action pattern. In the META-LEVEL built-in implementation of U ’s sorts and descent functions, this can be achieved using the metaMatch descent function, which meta-represents the instance-of relation between terms. Since metaMatch is parametric on each rewrite theory, its metarepresentation is also parametric on the given rewrite theory. Let
±R denote the metarepresentation of the instance-of relation between the meta rep- resentations of a one-step proof term and a spatial action pattern in the equational theory (Ω(L), A) associated with the rewrite theory R = (Σ,E ∪ A, R) in Section
2.1. Then, for a one-step proof term γ and a spatial action pattern δ, we have γ ±A δ iff γ ±(Ω(L),A) δ. The UW (R) construction contains the universal theory U and can then be defined as follows.
Definition 3.4 The rewrite theory UW (R) is the following parametric extension of the universal theory U , in which R = (Σ,E ∪ A, R) and W ⊂ SP (Ω, L) are metarepresented as data parameters R and W :
U ⊂ UW (R), where UW (R) includes all the descent functions in the META-LEVEL
module as well as a descent function for the instance-of relation γ ±(Ω(L),A) δ.
UW (R) has sorts State, Prop, and Bool with constants true and false, where the ground terms of sort State are pairs (t, U ), with t a term of sort State in R, and U ⊆ W (that is, U is a meta-term that uses a set union associative and commutative operator to represent a finite set of action patterns contained in W ).
UW (R) has also an act operator with act(W, γ)= {δ ∈ W | γ ±R δ}.

There is a single conditional rewrite rule tr in UW (R) such that tr : (t, U ) −→ (metaReduce(R, t∗), V ) iff there exists a rule label l in R and a natural number m such that metaXapply(R, t, l, m)= (t∗, v[]p, φ) ∧ V = act(W, v[l(φ)]p). The rule’s condition can be equationally expressed using “matching conditions” with extra variables (see [15]). Note that in particular this means that we have a one-step rewrite proof term R ▶ v[l(φ)]p : t −→ t∗.

The ground terms of sort Prop are precisely the metarepresentations of: (i) either the atomic propositions of R, or (ii) the elements of W .
There is a labeling operator	|=	: State × Prop → Bool with conditional equations such that:
(t, U ) |= δ = true iff δ ∈ U
(t, U ) |= p = true iff metaReduce(R, t |= p)= true, i.e., canE/A(t |= p)= true.
The theory UW (R) defined above is meta-level description for KW (R), and so the definition is closely related to Definition 3.1. The correctness of the UW (R) construction is expressed by the following proposition.
Proposition 3.5 Given a rewrite theory R ∈ RWTh0 and a ﬁnite set W  ⊆
SP (Ω, L), for each state [t] in R and U ⊆ W, the following conditions hold:
states ([t],U ) of KW (R) are in one-to-one correspondence with ground terms of sort State of the form (canE/A(t), U ) in UW (R).
For each atomic proposition α of KW (R), ([t],U ) |= α iff (canE/A(t), U ) |=
α = true in UW (R).
There is a transition ([t],U ) −→∗ ([t∗],V ) in KW (R) iff
UW (R) ▶ (canE/A(t), U ) −→ (canE/A(t∗), V ).
Proof (Sketch)
By construction, the terms of sort State in the reflective theory UW (R) ex- tending U are pairs (canE/A(t), U ) metarepresenting states ([t],U ) of KW (R). This metarepresentation is one-to-one because of the computability assump- tions about R (which include confluence and termination of E modulo A).
There are two cases when ([t],U ) |= α is true in KW (R); α ∈ U , or canE/A([t] |= α)= true. Since α ∈ U iff α ∈ U and canE/A([t] |= α)= true iff metaReduce(R, canE/A(t) |= α)= true, in both cases, by the above definition, ([t],U ) |= α iff (canE/A(t), U ) |= α.
If a transition ([t],U ) −→ ([t∗],V ) exists in KW (R), then, by definition, there

γ
exists a one-step rewrite [t] −→
[t∗] in R and V = actW
(U ). But, by the

definition of UW (R), this is equivalent to the existence of a one-step rewrite tr :
(t, U ) −→ (metaReduce(R, t∗), V ) which can happen if and only if there exists a rule label l in R and a natural number m such that metaXapply(R, t, l, m)= (t∗, v[]p, φ) and V = act(W, v[l(φ)]p).
2

In addition to the UW (R) construction, we need to deal with the metarepresen- tation of the LTL formulas ϕ˜ associated to LTLR formulas.
Definition 3.6 Given a formula ϕ, ϕ˜ is the same as ϕ˜, except that each atomic proposition (resp. a spatial action pattern) is replaced by its meta-representation.

Reflective Design of an LTLR Model Checker
Maude supports rewriting based LTL model checking for any computable rewrite theory R [15,18], that is, Maude automates the R '→ K(R) construction and pro- vides an LTL model checker for the underlying Kripke structure K(R). Therefore, the reduction method described in Section 3.1 to reduce model checking of LTLR formulas to that of LTL formulas can be used, thanks to the reflective UW (R) con- struction described in Section 3.2, to reduce the model checking of R with respect to a formula ϕ ∈ LTLR(W, Π) to performing LTL model checking on the rewrite theory UW (R) with respect to the formula ϕ˜.
In a practical model checking system implementation, however, we want to hide all metalevel representations from the user; therefore the reflective UW (R), while being the core of the model checker, is not what the user directly interacts with. In particular, we should support model checking commands in which the LTLR formula and the initial state are specified at the object level. This requires the design of a suitable user interface in addition to the internal reflective commands that perform the actual model checking. All this can be achieved, as we explain in this section, by extending the Full Maude language [17] using reflective methods.
Constructing the LTLR Syntax with Spatial Action Patterns
In the LTLR syntax, the atomic propositions and the spatial action patterns in formulas are not fixed: they depend parametrically on the given computable rewrite theory R. In particular, spatial action patterns can be uniquely characterized as soon as R is specified. The idea is that given R = (Σ, E, R) with a subsignature of constructor Ω and rule labels L, we can define a map
TLR : R −→ R ∪ SP (Ω, L),
and this map can be metarepresented as an equationally defined function
TLR : R −→ R∪ SP (Ω, L)

in an extension of the META-LEVEL module. The function TLR can be integrated into Full Maude [17], and by extending Full Maude’s parser the user can then specify at the object level LTLR properties using the parametric LTLR syntax in TLR(R). The remaining thing we need to do is to define SP (Ω, L) as a rewrite theory. It is not hard, since we can just use the definition of Ω(L) and Definition 2.4. The slightly tricky part is to make actions v[l(φ)]p include only one basic action term l(φ). It is archived by adding the operators
: Action-A1 × A2 × A3 ×· · · × An	→ Action-A
: A1 × Action-A2 × A3 ×· · · × An	→ Action-A
.	.	.
o : A1 × A2 × ··· × An−1 × Action-An → Action-A
for each operator o : A1 × · · · × An → A ∈ Ω with n ≥ 1, where Action-Ai is a related action sort for each sort Ai. Since to yield a spatial action pattern, operators

in Ω can have only one action sub-pattern, the uniqueness of a basic action term
l(φ) as a sub-term is automatically guaranteed.
Reflective LTLR Model Checker Design
Given a computable rewrite theory R ∈ RWTh0, we are now able to define LTLR properties using TLR(R)∪Π, where Π is the set of atomic propositions in R. The next step is to transform the LTLR properties into LTL properties. This is accomplished

by the map ϕ '→
ϕ˜ associated to Definition 3.6, which can be constructed by

reflection using the metarepresented theory TLR(R) ∪ Π. Then, when a user gives
to the LTLR Model Checker system extending Full Maude the command
(tlr check(t, ϕ) .)
the system performs the followings tasks: (i) t and ϕ are parsed and metarepresented
as t and ϕ; (ii) the set W = sp(ϕ) is computed, and the translation ϕ '→ ϕ˜ is
performed; (iii) the Maude LTL model checker is invoked at the metalevel on the


theory UW (R) with initial state (t, ∅) and LTL formula ϕ˜; and (iv) the output of the model checking results (either true or a counterexample) are provided to the user at the object level using Full Maude’s meta-pretty printing features. By the results in Section 3, we are then guaranteed (assuming correctness of the Maude and Full Maude implementations and of the reflective model checker implementation) that the model checker system will answer true to a model checking command (tlr check(t, ϕ) .) if and only if R,t |= ϕ.
The Example Revisited
This section illustrates the use of the above LTLR model checker with Dekker’s algorithm example explained in Section 1.1 15 . A similar definition of this parallel language and the algorithm appeared in [15,18], but since only LTL model checking was available in [15,18], there this required manual “cooking” both the rewrite theory and the formulas, as explained in Subsection 1.1. Instead, here everything can be specified and model checked in the most natural way. The code of algorithm and the system description are the same as before. The global states are of the form {[I, R] | S, M}, with [I,R] a process with id I and code R, S the set of remaining processes, and M the memory. The rewrite rules defining the language’s operational semantics are all labeled with the same label stmt. Hence, the spatial action pattern stmt(I\ p1) asserts the execution of process p1. The predicates in-crit and in-rem, discussed in Section 1.1, are equationally defined as follows.
(mod DEKKER-CHECK is protecting TLR[DEKKER] . subsort MachineState < State .
ops in-crit in-rem : Pid -> Prop . op exec : Pid -> Action .
var M : Memory . vars R : Program . var S : Soup . vars J : Pid . eq exec(J) = [stmt(I\ J)] .
eq {[J, crit ; R] | S, M} |= in-crit(J) = true .

15 For a collection of other examples and the code of the LTLR model checker see the web page [1].


eq {[J, R] | S, M} |= in-crit(J) = false [owise] .
eq {[J, rem ; R] | S, M} |= in-rem(J) = true .
eq {[J, R] | S, M} |= in-rem(J) = false [owise] . endm)

We can then check that the strong fairness property fails, and the model checker returns a counterexample. The result is translated to the same format as that of the LTL model checker.
Maude> (tlr check(initial, []<> exec(1) -> []<> in-crit(1)) .) result : counterexample({{[1,repeat ’c1 := 1 ; while ’c2 = 1 do
if ’turn = 2 then ’c1 := 0 ; while ’turn = 2 do skip od ; ...

Instead, the (somewhat subtle) weaker fairness property satisfied by Dekker’s algo- rithm can be verified as follows.
Maude> (tlr check(initial, []<> exec(1) /\ []<> exec(2) -> []<> ~ in-rem(1) -> []<> in-crit(1)) .)
result : true

If a given property is a LTL formula, the model checker do LTL model checking without transformation, such as the mutual exclusion property like the following:
Maude> (tlr check(initial, [] ~ (in-crit(1) /\ in-crit(2))) .) ltl-result : true


Related Work and Conclusions
There is much related work on both state-based and action-based logics (see [31] for a more thorough discussion). Related temporal logics include: (i) state-based logics; (ii) action-based logics; and (iii) mixed logics supporting both actions and state predicates. Well-known state-based logics such as LTL, CTL, and CTL∗ (see, e.g., [27], [11]), are all special cases of TLR∗. Faithful translations to TLR∗ from well-known action-based logics such as Hennessy-Milner logic [22] and A-CTL∗ [35] are defined in detail in [31]. The mixed action-state logic SE -LTL in [8,9] can also be viewed as special case of the TLR∗. The Spatial Logic for Concurrency of Caires and Cardelli [5,6] is a state-based spatial modal logic for process calculi in the π- calculus spirit with spatial features used only for state predicates (but see the logic in [4], which has an action-labeled diamond). Other action-based temporal and modal logics are discussed in the survey paper [29], including the modal μ-calculus
[25] (μL), which is in some ways more powerful than TLR∗, but lacks spatial action
patterns. Among other logics supporting both actions and state predicates we find several extensions of either A-CTL∗ or A-CTL such as, e.g., [2,19,21,36]. Three other approaches proposing mixed logics with both state-predicates and actions are: (i) the extension of the SE -LTL in [8,9] to a universally path quantified logic involving ω-regular expressions [7]; (ii) the ESTL logic of events and states for Petri

nets of [24]; and (iii) the Kripke modal transition systems of [23], and their use in the verification of safety and liveness properties in the context of the modal μ- calculus. The work most closely related to TLR∗ is that on VLRL [20,28]. The VLRL solution was less general and did not consider model checking aspects. Two other logics that combine actions and state-based formulas are the UNITY logic of Chandy and Misra [10], and Misra’s logic for Seuss [34]; however, actions as such do not appear in temporal logic formulas, which remain state-based. Methodologically and technically, Lamport’s Temporal Logic of Actions (TLA) [26] and TLR∗ are very different. In TLA, there is no division of labor between system and property specification logics: TLA plays both roles simultaneously [26]. Also, actions in TLA are interpreted as binary relations between states, so that one cannot distinguish between two actions having the same outcomes from a given state.
In conclusion, after reviewing background on rewriting logic and the temporal logic of rewriting we have presented the formal foundations of the Maude LTLR model checker and explained its reflective implementation as an extension of the Full Maude language. We have also presented an example illustrating the use of the model checker. The LTLR model checker presented here is a useful prototype that can be used for both teaching and research and that, as mentioned, is available at [1]. The theoretical complexity results given in [31] mean that in practice the growth in the number of states is reasonable. Also, thanks to the efficient implemen- tation of reflective features in Maude, our experience with examples suggest that the performance of the LTLR model checker is acceptable, so that it can be used in both teaching and experimental research. In particular, for pure LTL formulas it has essentially the same performance as that of Maude’s LTL model checker, which is quite good.
We believe, however, that a greater efficiency, obviating even the need for any growth in the state space of the given rewrite theory R, and avoiding any reflective computations can be achieved by a new, native LTLR model checking algorithm. However, the design of such an algorithm and its implementation in Core Maude are both nontrivial tasks than have to be left for future research.

References
Bae, K., Tlr model checker source code, Available at http://www.cs.uiuc.edu/homes/kbae4/tlr/
(2008).
Beek, M., A. Fantechi, S. Gnesi and F. Mazzanti, An action/state-based model-checking approach for the analysis of communication protocols for Service-Oriented Applications, in: Proc. FMICS (2008), to appear.
Bruni, R. and J. Meseguer, Semantic foundations for generalized rewrite theories., Theoretical Computer Science 360 (2006), pp. 386–414.
Caires, L., Behavioral and spatial observations in a logic for the pi-calculus, in: Foundations of Software Sceince and Computation Structures (2004), pp. 72–87.
Caires, L. and L. Cardelli, A spatial logic for concurrency (part I)., Information and Computation 186
(2003), pp. 194–235.
Caires, L. and L. Cardelli, A spatial logic for concurrency - II., Theoretical Computer Science 322
(2004), pp. 517–565.


Chaki, S., E. Clarke, O. Grumberg, J. Ouaknine, N. Sharygina, T. Touili and H. Veith, State/event software verification for branching-time specifications, in: Proc. 5th Intl. Conf. on Integrated Formal Methods (IFM’05) (2005), pp. 53–69.
Chaki, S., E. Clarke, J. Ouaknine, N. Sharygina and N. Sinha, State/event-based software model checking, in: Proc. 4th Intl. Conf. on Integrated Formal Methods (IFM’04) (2004), pp. 128–147.
Chaki, S., E. Clarke, J. Ouaknine, N. Sharygina and N. Sinha, Concurrent software verification with states, events, and deadlocks, Formal Aspects of Computing 17 (2005), pp. 461–483.
Chandy, K. M. and J. Misra, “Parallel Program Design: A Foundation,” Addison-Wesley, 1988.
Clarke, E. M., O. Grumberg and D. A. Peled, “Model Checking,” MIT Press, 2001.
Clavel, M., “Reflection in Rewriting Logic: Metalogical Foundations and Metaprogramming Applications,” CSLI Publications, 2000.
Clavel, M., F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet and J. Meseguer, Metalevel computation in Maude, Proc. 2nd Intl. Workshop on Rewriting Logic and its Applications, ENTCS, Vol. 15, North Holland, 1998.
Clavel, M., F. Dura´n, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer and J. Quesada, Maude: specification and programming in rewriting logic, Theoretical Computer Science 285 (2002), pp. 187– 243.
Clavel, M., F. Dura´n, S. Eker, J. Meseguer, P. Lincoln, N. Mart´ı-Oliet and C. Talcott, “All About Maude – A High-Performance Logical Framework,” LNCS 4350, Springer, 2007.
Dershowitz, N. and J.-P. Jouannaud, Rewrite systems, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Vol. B, North-Holland, 1990 pp. 243–320.
Dur´an, F. and J. Meseguer, Maude’s module algebra, Science of Computer Programming 66 (2007),
pp. 125–153.
Eker, S., J. Meseguer and A. Sridharanarayanan, The Maude LTL model checker, in: F. Gadducci and
U. Montanari, editors, Proc. 4th. Intl. Workshop on Rewriting Logic and its Applications (2002).
Fantechi, A., S. Gnesi, A. Lapadula, F. Mazzanti, R. Pugliese and F. Tiezzi, A model checking approach for verifying COWS specifications, in: Proc. FASE 2008 (2008), to appear.
Fiadeiro, J., N. Mart´ı-Oliet, T. Maibaum, J. Meseguer and I. Pita, Towards a verification logic for rewriting logic, in: D. Bert, C. Choppy and P. D. Mosses, editors, Recent Trends in Algebraic Development Techniques, WADT’99, Springer LNCS 1827 (2000), pp. 438–458.
Gnesi, S. and F. Mazzanti, A Model Checking Verification Environment for UML Statecharts, in:
Proceedings XLIII AICA Annual Conference, University of Udine - AICA 2005, 2005.
URL http://fmt.isti.cnr.it/WEBPAPER/gmaica2005.pdf
Hennessy, M. and R. Milner, Algebraic laws for nondeterminism and concurrency, Journal of the Association for Computing Machinery 32 (1985), pp. 137–172.
Huth, M., R. Jagadeesan and D. Schmidt, Modal transition systems: A foundation for three-valued program analysis, in: Proc. 10th European Symposium on Programming (ESOP’01) (2001), pp. 155– 169.
Kindler, E. and T. Vesper, ESTL: A temporal logic for events and states, in: Proc. 19th Intl. Conf. on Application and Theory of Petri Nets (ICATPN’98) (1998), pp. 365–384.
Kozen, D., Results on the propositional mu-calculus, Theoretical Computer Science 27 (1983), pp. 333– 354.
Lamport, L., A temporal logic of actions, ACM Trans. on Prog. Lang. and Systems 16 (1994), pp. 872– 923.
Manna, Z. and A. Pnueli, “The Temporal Logic of Reactive and Concurrent Systems – Specification,” Springer-Verlag, 1992.
Mart´ı-Oliet, N., I. Pita, J. L. Fiadeiro, J. Meseguer and T. S. E. Maibaum, A verification logic for rewriting logic., J. Log. Comput. 15 (2005), pp. 317–352.
Mateescu, R., Logiques temporelles bas´ees sur actions pour la v´erification des syst`emes asynchrones, Technique et Science Informatiques 22 (2003), pp. 461–495, also, INRIA Report 5032, Dec. 2003.
Meseguer, J., Conditional rewriting logic as a unified model of concurrency, Theoretical Computer Science 96 (1992), pp. 73–155.

Meseguer, J., The temporal logic of rewriting, Technical Report UIUCDCS-R-2007-2815, CS Dept., University of Illinois at Urbana-Champaign (2007), revised November 2007.
Meseguer, J., The temporal logic of rewriting: A gentle introduction, LNCS 5065 (2008), to appear in Festschrift in honor of Ugo Montanari.
Meseguer, J., M. Palomino and N. Mart´ı-Oliet, Equational abstractions, in: Procs. of CADE’03, LNCS (2003).
Misra, J., “A Discipline of Multiprogramming,” Springer-Verlag, 2001.
Nicola, R. D. and F. W. Vaandrager, Action versus state based logics for transition systems, in:
Semantics of Systems of Concurrent Processes, LNCS 469 (1990), pp. 407–419.
Pecheur, C. and F. Raimondi, Symbolic model checking of logics with actions, in: Workshop on Model Checking and Artificial Intelligence (MOCHART) (2006), pp. 113–128.
Viry, P., Equational rules for rewriting logic, Theoretical Computer Science 285 (2002), pp. 487–517.
