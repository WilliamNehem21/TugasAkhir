Electronic Notes in Theoretical Computer Science 118 (2005) 37–55  
www.elsevier.com/locate/entcs


Verification of Scenario-based Specifications using Templates
Girish Keshav Palshikar1	Purandar Bhaduri2
Tata Research Development and Design Centre (TRDDC), 54B, Hadapsar Industrial Estate, Pune 411013, India.

Abstract
Specifying dynamic behaviour of a system by listing scenarios of its interactions has become a pop- ular practice. Message sequence chart (MSC) is a rigorous and widely used notation for specifying such scenarios of system behaviour. High-level MSCs (HMSC) provide hierarchical and modular composition facilities for constructing complex scenarios from basic MSCs. Although the general problem of formal verification of properties of HMSCs is intractable, we propose a framework for restricted verification. We present simple templates for commonly used types of properties and discuss efficient algorithms for verifying them.
Keywords: Scenario-based Specifications, Message Sequence Charts, Formal Verification, Formal Methods.


Introduction
It is important to clearly and precisely state the behavioural requirements when building practical business systems as well as safety-critical real-time, embedded systems (e.g., see our railway system [23]). It is not always easy to communicate dynamic behavioural requirements of a system to the end-users in an easy-to-understand non-mathematical manner, particularly in the early stages of requirements analysis, where the requirements need to be high-level and abstract (removed from design and implementation issues). A simple and intuitive way to describe a system is to list various examples or scenarios of its

1 Email: girishp@pune.tcs.co.in
2 Email: pbhaduri@pune.tcs.co.in



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.12.017


intended behaviour. At the highest level of abstraction, a scenario describes a set of interactions of the system with its environment and other external systems. An interaction includes entities (including system components) that participate in it and event occurrences. An interaction scenario often stands for a set of possible event sequences (episodes). Each interaction scenario is typically classified as either desirable (sunny day) or undesirable (rainy day). Ideally, an implementation should meet all sunny day interaction scenarios and none of the rainy day ones.
There is a need for simple, expressive, intuitive, graphical and standard- ised notations to specify interaction scenarios of systems. Message sequence chart (MSC) is just such a simple, visual and mathematically rigorous no- tation [25,13]. MSCs have been used widely in the telecom domain and are also increasingly being used in many other applications [23]. The sequence diagram and use case notations in UML are semantically and visually close to the MSC notation [12,11,20,8]. The ITU standard for MSC [14] includes a mathematical semantics for it. Other researchers have provided mathemati- cal semantics for MSCs using formalisms such as transition systems, process algebras etc. [16,19,18,9]. In this paper, we use the partial order semantics given by Alur et al [2]. The main use of a formal semantics for a notation is that it can be used to design formal verification and analysis algorithms. For example, a specification written using MSCs can be analysed to detect various problems such as missing scenarios and race conditions. Formal veri- fication algorithms can be designed which check whether a given specification written using MSCs satisfies a given property written in a suitable formal no- tation [2,1,24,17,4,21,22,5]. Model-checking tools have also been applied for formal verification of MSCs [3,10].
This paper presents a set of restricted simple property templates and for- mal verification algorithms to check whether a given High-level MSC (HMSC) satisfies the given property. Since the general problem of formal verification of HMSC specification is intractable when the property is specified in tem- poral logic or equivalent notations, following [7,15,5], we restrict the kinds of properties that can be specified and give specialised algorithms for formal verification of properties specified using each template. We present a compro- mise wherein we sacrifice expressiveness for efficient verification. The MSC notation has been extended in several ways (e.g., [26]); here we focus on the core aspects of the MSC and HMSC notation only.
Section 2 presents an overview of HMSC notation and its formal semantics. Section 3 discusses our approach of property templates and algorithms to verify them. Section 4 provides conclusions and further work.

HMSC Semantics
We assume familiarity with basic MSC notation and its partial order (linear time) semantics [2] (see Appendix A for an overview). Here we summarise the relevant definitions for MSC-graphs and HMSC.
Linear Time Semantics of MSC Graphs
An MSC graph is essentially a directed (not necessarily acyclic) graph in which each vertex refers to a basic MSC.
Definition 2.1 An MSC graph G is a tuple (V, →, vI, vT , µ) where V is a finite set of vertices, → is a binary relation over V (each element of → is a directed edge in G), vI is the initial vertex, vT is the terminal vertex and µ is a labelling function that maps each vertex to a basic MSC m.
When defining the semantics of MSC graphs, there are two ways of inter- preting the concatenation of basic MSCs m1 and m2. In synchronous con- catenation, all the events in m1 precede any event in m2. The asynchronous concatenation corresponds to concatenating two MSCs instance by instance.
Definition 2.2 The partial order associated with the synchronous concate- nation of two basic MSCs m1 and m2 having the same set of instances is the partial order ≤m1 ,m2 on locations(m1) locations(m2) given by
≤m1  ≤m2  locations(m1) × locations(m2)
where locations(m) is the set of locations (events) in basic MSC m and is the operator for disjoint union of two sets. Each location is denoted by a tuple
< i, l > where i is the unique ID for an instance and l is the ID for the event within the visual order of the instance i (see Appendix A).
Definition 2.3 The partial order associated with the asynchronous concate- nation of two basic MSCs m1 and m2 having the same set of instances is the partial order ≤m1 ,m2 on locations(m1) locations(m2) given by the transitive closure of the following relation:
≤m1   ≤m2 ∪ {(< i, l >m1 ,< i,l >m2 ) | < i, l >m1  ∈ locations(m1)
∧ < i, l >m2  ∈ locations(m2)}
Figure 1 shows an MSC graph (initial vertex and terminal vertex are not shown, initial vertex connects to v0 and vertices v2, v3 connect to the terminal vertex). There are an infinite number of paths from the initial to the terminal vertex in this MSC graph (due to the loop in it); e.g., < v0, v1, v3 >, < v0, v1, v0, v1, v3 >, < v0, v1, v0, v1, v0, v1, v3 > etc. The idea in the semantics


v0	v2
s_connect_p1 r_connect_p2
s_fail_p2 s_report_p2 r_report_p3
s_connect1_p1 r_connect1_p2
s_fail1_p2 s_report1_p2 r_report1_p3
s_req_service_p1

r_req_service_p3
Fig. 1. MSC Graph
of MSC graph with synchronous concatenation is to construct a partial order for each such finite path in the MSC graph, by synchronously concatenating the partial orders of the basic MSCs occurring in the path. Figure 1 also shows the precedence graph for walk < v0, v1, v0, v1, v3 > in the MSC graph; this graph is obtained by synchronously concatenating the basic MSCs for v0, v1, v0, v1 and v3. Dashed lines show the edges in the precedence graph added due to Definition 2.2; we omit the edges entailed by transitive closure. Note that the locations (events) are renamed in different instance of v0 (and v1) in the walk (due to the disjoint union).
Definition 2.4 The semantics of an MSC graph G under (a)synchronous con- catenation is the set of all finite and infinite runs obtained by (i) (a)synchronously concatenating each basic MSC along each walk in G and (ii) taking the dis- joint union over all walks, both finite and infinite, of the set of runs obtained from the partial orders in (i).
Since the set of walks in an MSC graph may be infinite (if it has loops), the set of runs is also infinite. The problem of deciding whether a given MSC-graph satisfies a given property P (where P is specified as an automaton) is coNP- complete for synchronous concatenation and is undecidable for asynchronous

concatenation [3].

Linear Time Semantics of HMSC
Essentially, an HMSC is a hierarchical (multi-level) graph whose nodes are either basic MSCs or another HMSC, thus allowing for nesting of graphs.
Definition 2.5 A high-level message sequence chart (HMSC) H is a tuple (N, B, vI, vT , µ, E) where N is a finite set of nodes, B is a finite set of boxes (or supernodes), vI ∈ N ∩ B is the initial node or box, vT ∈ N ∩ B is the terminal node or box, µ is a labelling function that maps each node in N to a basic MSC and each box in B to an already defined HMSC, and E is the set of edges that connect the nodes and boxes to each other.
We omit some HMSC features in the MSC standard such as conditions and inline expressions. What is the meaning of an HMSC H? First, an HMSC is flattened into an MSC-graph, obtained by recursively substituting a box by the corresponding HMSC. The meaning of an HMSC is then the set of all possible finite or infinite runs of this flattened MSC-graph [3]; here it is required that the nesting of HMSCs is not mutually recursive, i.e., if a node of an HMSC H is labelled with another HMSC H’, then a node of H’ cannot be labelled with H (or with any HMSC that refers to H).

HMSC Verification
Given an HMSC H and a property P about the runs of H, the verification problem is to decide whether or not all runs of H satisfy P . P is typically stated using temporal logic like LTL or CTL, an automaton or a template MSC. A na¨ıve verification algorithm would examine some or all runs of H to decide whether or not H satisfies P . The general problem of deciding whether a given MSC-graph satisfies a given property P (where P is specified as an au- tomaton) is undecidable[3]. However, we consider some special classes of prop- erties below and present efficient verification algorithms for such properties. Following [7,15,5], we assume that the properties fall into various pre-defined templates, thus sacrificing generality for ease of use and efficiency of verifica- tion. The properties are stated in terms of the relative ordering of events in the runs of the input HMSC. Although the property templates cannot express all the properties that may be of interest in practice, they do cover broad classes of typical properties. Moreover, we present efficient graph-theoretic algorithms (based on linear time semantics of HMSCs) to verify properties stated using these templates.


Every internal event in an HMSC has a unique ID specified by the unique location in the basic MSC in which it occurs. A user-defined event E cor- responds in general to a non-empty finite set γ(E) of internal events in an HMSC. The properties are specified in terms of user-defined events and their negations. We say that a user-defined event occurs when any of the internal events corresponding to it occur. If a user-defined event E stands for a fi- nite set {e1,... , ek} of internal events, the negative event not(E) stands for not(e1) ∧ ... ∧ not(ek). In Figure 1, a user event “P 2 sends message to P 1” (underscore stands for “don’t care”) corresponds to the two internal events: “P 2 sends approve to P 1” (in basic MSC v2) and “P 2 sends f ail to P 1” (in basic MSC v1).

Note
In this paper, all our verification algorithms assume synchronous concate- nation in the semantics of MSC graphs. This makes the algorithms modular in nature, in the sense that the verification task can be decomposed into smaller tasks that can be verified at each vertex. The verification algorithms for asyn- chronous concatenation are more complex, as they involve the construction of a global reachability graph from the input MSC graph.
Tracing
A tracing property asserts the occurrence of a sequence of events in the spec- ified order in all runs or in at least one run of the input HMSC H. The template for the property is shown below. The terms in bold are given by the user and the terms in bold separated by slashes are alternatives, one of which is chosen by the user. Each ai is a user-defined event or its negation.
Definition 3.1 Let H be an MSC-graph and let σ = u0, u1, u2,... be a run of H, where each ui is an internal event in some MSC M in H. A positive user-defined event a = {e1,... , en} occurs in σ if there is some event e ∈ a and some ui (i ≥ 0) in σ such that ui = e. A negative user-defined event not(a), where a is a positive user-defined event a = {e1,... , en} occurs in σ if a does not occurs in σ i.e., if there is no e ∈ a and there is no ui (i ≥ 0) in σ such that ui = e.
The concept of a user-defined event occurring in a run can be generalised for a sequence X = [a1, a2,... , an] of (positive or negative) user-defined events by means of the inductive Definition 3.2.


Definition 3.2 Let H be an MSC-graph and σ = u0, u1, u2,... be a run of H, where each ui is an internal event in some MSC M in H. A trace X = [a1, a2,... , an] of (positive or negative) user-defined events occurs in σ if x is a prefix of σ, where σ = x • y, such that a1 occurs in x and the remaining trace [a2,... , an] occurs in the remaining run y. Here, • is the concatenation operation on sequences.

Suppose that all events in X are positive user-defined events. Then X occurs in a given finite or infinite run σ of an HMSC H if there is a sequence of internal events B =< b1,... , bk > such that bi ∈ ai and B occurs as a sub-sequence within σ. The sub-sequence B need not be contiguous in σ i.e., there may be other events between bi and bi+1 in σ. Now suppose one or more ai’s in X are negative user-defined events. Then X occurs in a given finite or infinite run σ of an HMSC H if there is a sequence of internal events b1,... , bn (where n = number of positive user-defined events in X) such that (i) each bi is in a positive user-defined event in X (in the order in which they occur in X) and (ii) B is a sub-sequence within σ and (iii) for every pair bi and bi+1 in B such that bi ∈ ap and bi+1 ∈ aq, no internal event from any negative user-defined events between ap and aq occurs between bi and bi+1 in σ.
For example, the following property checks if there is any run in the HMSC of Figure 1 where P 1 sends a connect message but P 1 does not receive an approve message after that. A chief difficulty in checking tracing properties is that the runs of H may be infinite.
The sequence X may include some cycles or repetitions, as shown below.



For simplicity, we assume that X does not include any negative user- defined events. Let H be an HMSC and let S be the set of basic MSCs that occur in the MSC-graph obtained by flattening H. For a given internal event e, let φ(e) denote the set of basic MSCs from S in which e occurs (clearly φ(e) /= ∅ and φ(e) ⊆ S); e.g., φ(“P 2 sends to P 1”) = {v1, v2}. Recall that a positive user-defined event E stands for a finite set γ(E) = {e1,... , ep} of
internal events. Then the function φ can be extended to a user defined event

E as: φ(E)= 

e∈γ(E)
φ(e) = φ(e1) ∪ ... ∪ φ(ep). Here, φ(E) denotes the set

of basic MSCs in H, which contains at least one internal event corresponding

to the user-defined event E. We need some more definitions.
Definition 3.3 Let H be an MSC-graph over a set S of basic MSCs. Then a sequence w =< M1, M2,... , Mm > of basic MSCs in S is called feasible trace of H if (i) there is a directed path from initial node to M1 and (ii) from each Mi to Mi+1 (1 ≤ i < m) and (iii) from Mm to terminal node of H. Specifically,
(ii) needs to hold even if Mi = Mi+1 for any i, in which case there must be a non-empty directed path from Mi to itself (i.e., Mi should be reachable from itself via a non-empty directed path).
Definition 3.4 Let β =< e1, e2,... , ek > be a sequence of positive internal events in a set of basic MSCs S in an MSC-graph H. Let w =< M1, M2,... , Mm > be a feasible trace of H. Then a function f partitions β among w if (i)
f (M ) = β if w consists of a single MSC M and M ∈ φ(β); and (ii) if w =< Mi > • < Mi+1,... , Mm > then f (Mi) = a proper prefix x of β (where β = x • y), Mi ∈ φ(x) and f partitions y among < Mi+1,... , Mm >.
In Figure 1, w =< v1, v3 > is a feasible trace of H. Also, a function f = {v1 '→< r f ail p1,r report p3 >, v3 '→< s req service p1 >} partitions β =< r f ail p1,r report p3,s req service p1 > among w. Note that f asso- ciates a non-empty subsequence of β with every basic MSC in w. A simple algorithm can be designed to construct a function f that partitions given β among w; such an f is unique for given w, β because every event in β is an internal event, which belongs to a unique basic MSC in S.
Algorithm 1 (hmsc tracing a) to check properties stated using the tracing template is as follows (we assume the option some is chosen). We system- atically select a permutation β of internal events from X, form a candidate feasible trace w in H which partitions β through a function f and efficiently check whether β occurs in some linearization of the precedence relation corre- sponding to the synchronous concatenation of basic MSCs in w. The feasible traces have a length of at most k and hence are finite in number.
For the second property above, X = [a1, a2, a3] where a1 = “P 1 sends connect to ”, a2 = “P 1 receives f ail from ”, a3 = “P 1 sends connect to ”. φ(a1) = φ(a3) = {v0}, φ(a2) = {v1} and γ(a1) = γ(a3) = {s connect p1}, γ(a2)= {r f ail p1}. There is only one possible β =< e1, e2, e3 > where e1= s connect p1, e2 = r f ail p1, e3 = s connect p1. Thus w =< M1, M2, M3 > where M1 = v0, M2 = v1, M3 = v0 is a feasible trace of H and the function f = {M1 '→< s connect p1 >, M2 '→< r f ail p1 >, M3 '→< s connect p1 >} partitions β among w. This choice of β, w and f clearly satisfies the inner for loops; hence the property is satisfied. Clearly, the following property is not satisfied by the HMSC in Figure 1.



Algorithm 1 hmsc tracing a
input HMSC H; {actually H is the flattened MSC-graph for an HMSC} input X = [a1,... , ak] {finite sequence of positive user-defined events} output true if X occurs in some run of H; false otherwise
Let S = the set of all basic MSCs in H;
Let φ(ai) = the set of basic MSCs for user-defined events ai; Let γ(ai) = the set of internal events in user-defined event ai; for every sequence β =< e1, e2,... , ek > where ei ∈ γ(ai) do
for every feasible trace w =< M1, M2,... , Ma >, 1 ≤ a ≤ k,
of basic MSCs from S such that a function f partitions β among w do
ok = true;
{do for every MSC in w}
for (x = 1; ok == true && x ≤ a; x++) do
for (j = 2; ok == true && j ≤ |f (Mx)|; j++) do for (i = 1; i < j; i++) do
{RM = precedence order for MSC M }
if precedes(RMx ,f (Mx)j,f (Mx)i) then
ok = false; break;
end if end for
end for end for
if ok == true then
return(true); end if
end for end for return(false);


The complexity of the Algorithm 1 is easily seen to be O(Ak · mk) where A is the maximum number of internal events corresponding to any event ai in X (i.e., A = max{γ(ai)}), m is the number of basic MSCs in H and k is the number of events in X. To reduce the complexity, we enforce an upper bound of k=10, which means that one can use up to 10 user-defined events to state the tracing property, which is acceptable in practice. The earlier work reported in [5] presents a similar algorithm for basic MSCs and


its analysis. The algorithm is efficient and does not explicitly check all possible finite linearizations of H. Clearly, the approach works even when there are repetitions in X. The algorithm can be modified for the situations (a) when X contains negative user-defined events; and/or (b) the option all runs is chosen in the template. For better use in practice, we have extended this approach to provide additional options such as packed subsequences, position of the tracing (only at the beginning, only at the end or anywhere) within the linearization etc.

Consequence
Another useful kind of property is specified using the following template. Here X = {x1,... , xm}, Y = {y1,... , yn} are given sets of user-defined events or their negations.
For example, in Figure 1, the following property states that each occurrence of P 1 sending a connect message is followed by P 1 receiving either f ail or approve message in every run.




As another example, in Figure 1, the following property states that each occurrence of P 1 sending a connect message or P 1 receiving a f ail mes- sage is followed by either P 1 receiving an approve message or P 1 sending a req service message in every run.
For simplicity, we again assume that X,Y do not include any negative user-defined events. Given a set of sets X, we use X to denote the union of the sets in X; e.g., {{a, b}, {a, c}} = {a, b, c}. The meaning of this property template is as follows:
Property pattern: An event from X leads to an event from Y in all runs of HMSC H. Meaning: Is it true that for every run σ of H, if there exists some internal event x ∈  X, then there exists some internal event

y ∈  Y such that the sequence x • y (obtained by concatenating x and
y) is a sub-sequence (tracing) of σ?
Property pattern: An event from X leads to all events from Y in all runs of HMSC H. Meaning: Is it true that for every run σ of H, if there exists some internal event x ∈	X then some ordered permutation Y 1 of internal events in	Y exists such that the sequence x • Y 1 is a sub-sequence (tracing) of σ?
Property pattern: Each event from X leads to an event from Y in all runs of HMSC H. Meaning: Is it true that for every run σ of H, and for every user event a ∈ X, if there exists some internal event x ∈ a then there exists some internal event y ∈  Y such that the sequence x • y is a sub-sequence (tracing) of σ?
Property pattern: Each event from X leads to all events from Y in all runs of HMSC H. Meaning: Is it true that for every run σ of H and every user event a ∈ X, if there exists some internal event x ∈ a then there exists some ordered permutation Y 1 of internal events in Y such that the sequence x • Y 1 is a sub-sequence (tracing) of σ?
The meaning is defined similarly when the first “all events” option is cho- sen. We illustrate the approach by an algorithm to verify the second conse- quence property pattern listed above.
Definition 3.5 Let H be an MSC-graph. Let A be a positive user-defined event in H and let B be a collection of positive user-defined events in H. We say that A must be followed by some event in B, denoted A ► B, if for every finite run σ = e1, e2,... of the MSC graph H, if some internal event a ∈ A
occurs in σ (i.e., ei = a for some i ≥ 1) then (i) there is some event b ∈	B
such that ej = b for some j > i (i.e., a is followed by b); and (ii) A ► B is true in the remaining run ei+1, ei+2,... , ej−1, ej+1,... of σ.
Remark 3.6
If no event from A occurs in some run of an HMSC H then A ► B is vacuously true for that run.
If two internal events e1 and e2 belong to the same bMSC (i.e., φ(e1)= φ(e2)
= M ) then {e1} ► {{e2}} iff e1 precedes e2 in the precedence order of M .
For example, in Figure 1, it is easy to see that {“P 1 send connect to P 2”}
{“P 2 send approve to P 1”’, “P 2 send f ail to P 1”}.
Proposition 3.7 Let H be an MSC-graph, let A be a positive user-deﬁned event and let B be a non-empty collection of positive user events over H. Then A ► B if and only if for every internal event e1 in A, there exists an


internal event e2 in  B with φ(e1) = M1, φ(e2) = M2, such that the following holds:
if M1 = M2 = some bMSC M then e1 precedes e2 in the partial order asso- ciated with M; or
if M1 /= M2 then
M1 is reachable from the start vertex of H, and
M2 is reachable from M1, and
the end vertex of H is reachable from M2, and
every directed path from the start vertex of H to the end vertex of H that passes through M1 also passes through M2 after M1.
The following Algorithm 2 implements Proposition 3.7 to check whether a given vertex u is always followed by another vertex v in a graph G, with respect to special given start and end vertices in G. The algorithm essentially performs a recursive depth-first traversal of the graph G starting at u and backtracking when reaching any vertex in L. The global array visited of Boolean flags marks vertices already visited.
The complexity of Algorithm 2 is clearly the same as depth-first graph traversal viz. O(|V | + |E|). The Algorithm 3 for the consequence property (where the second consequence property pattern listed above is chosen) is as follows.
If each user-defined event in the set Y contains at most N internal events then the algorithm explicitly checks N |Y | combinations. We manage this ex- ponential complexity by putting an upper limit on the number of events in Y (e.g., |Y | ≤ 10), which is satisfactory in practical situations. The earlier pa- per [5] presents similar algorithms for basic MSCs and their analysis. Again, the algorithm is efficient and does not explicitly check all possible finite lin- earizations of H. The algorithm can be modified when X or Y contain negative user-defined events. In addition to tracing and consequence, we have defined other templates to specify more varieties of properties, such as precedence.

Conclusions and Further Work
The approach of specification of system behaviour by listing examples of its interactions is gaining widespread acceptance during the requirements anal- ysis phase. Consequently, it is important to analyse scenario-based system specifications to detect errors early and to gain confidence in the system re- quirements. Message sequence charts and high-level message sequence charts provide a rigorous yet intuitive formalism for specifying such scenarios of sys-



Algorithm 2 must followed by
global Boolean visited[|V |]; {initially each vertex in V is unvisited}
input Graph G = (V, E);
input start, end, u ∈ V ; {u /= start,u /= end}
input L ⊆ V \ {start, end, u};
output true if u is always followed by at least one vertex in L on any path from start to end through u; false otherwise
{assumed: u is reachable from start and end is reachable from u}
visited[u] = true; {mark u as visited}
for every vertex w adjacent to u do
if (visited[w] || w == start || w ∈ L) then continue
end if
if (w == end) then
return(false); {u not always followed by a vertex in L}
end if
visited[w] = true; {mark w as visited}
if (must followed by(G, start, end, w, L) == false) then return(false);
end if end for
return(true);



tem behaviour. HMSCs provide hierarchical and modular composition facili- ties for constructing complex scenarios from basic ones. Other notations like UML use cases and sequence diagrams have been given formal semantics in terms of HMSCs. Several techniques have been proposed for analysing scenar- ios specified by HMSC: race condition detection, missing scenario detection and formal verification. Although the general problem of formal verification of properties of HMSCs is intractable, in this paper, we proposed simple and intuitive templates for stating common types of properties and algorithms for verifying them.
For further work, we need to add more templates for expanding the kinds of properties that can be specified. We can look at using a restricted linear temporal logic (or regular expressions) for stating properties of HMSCs. The approach certainly restricts the expressive power for stating properties of HM- SCs but might gain in efficiency of verification algorithms. Verification of live sequence charts [6] or MSCs with timing properties [26] is also of considerable interest.



Algorithm 3 hmsc consequence b
input HMSC H; {actually H is the flattened MSC-graph for an HMSC} input finite non-empty sets X, Y of positive user-defined events in H output true if for all runs σ of H, there exists an internal event x in	X and some permutation Y 1 of internal events in	Y such that σ contains x • Y 1 as a sub-sequence (tracing); false otherwise
{γ(a) denotes the set of internal events in user-defined event a}
for (i = 1; i ≤ |X|; i++) do
{check every internal-event in	X}
for every internal event x ∈ γ(X[i]) do
{Is x followed by all elements of Y in some order in all runs of H?}
for every combination L =< e1, e2,... , e|Y | > s.t. ei ∈ γ(Y [i]) do if (φ(x)==φ(ei) for every ei ∈ L) then
if (x precedes ei for every ei in L) then return(true);
end if else
if (must followed by(H, startH, endH, x, L)) then
return(true); {x is the one}
end if end if
end for
end for{x is not followed by all elements of Y }
end for return(false);

Acknowledgement
We thank the BMF Tool project team for implementing our ideas and pro- viding valuable feedback. We appreciate the support and encouragement of Prof. Mathai Joseph throughout the duration of this work. The first author would like to thank Dr. Manasee Palshikar.

Linear Time Semantics of Basic MSC Notation
The Basic MSC Notation
We present here only some essential features in the MSC notation; we omit features like actions, inline expressions and gates etc. In an MSC, entities stand for instances (or processes) and events typically represent sending and receiving of messages by processes - there are also other kinds of events such
















Fig. A.1. Basic MSC

as those related to timers. The meanings of an instance and a message depend on the system being described. An instance does not necessarily stand for a computer program; it refers to some active agent or entity. A message does not necessarily represent an actual data message; it may refer to some kind of exchange of information. A message has a name and no further structure or details (in the simplest case). An MSC is not concerned with the actual mechanism or channels of the message transmission, except to assume that the messages are always delivered in the order without any loss or corrup- tion. Further, the send is non-blocking i.e., the sender does not wait until the receiver receives the message.
Figure A.1 shows an MSC that depicts a simple interaction among 3 in- stances named valve, controller and pressure gauge. Each vertical line for an instance denotes the events that happen within the instance; the topmost event is the earliest event (within the instance) and so on downwards in time. This temporal ordering of events for an instance is called its local order. The visual distance between the events within a local order is immaterial. In Fig- ure A.1, the valve and pressure gauge processes send their respective status to the controller using messages named status close and status high pressure respectively. The controller then issues an open command to the valve using the message named cmd open. Note that the MSC depicts only one scenario; many other scenarios are possible e.g., one where the valve is open, pressure is low and the controller issues command to close the valve. The MSC is enclosed in a rectangular frame and has a name (Steam Boiler in this example).
The MSC notation allows one to avoid any particular ordering of a subset of events for a process, by using a construct called co-region. A co-region is indicated by a dotted line segment along the vertical line for the process and the events within this dotted line are unordered. Figure A.1 shows a


co-region for controller in which the controller does not impose any order on the receipt of the status close message from valve and status high pressure message from pressure gauge (these messages may be received in any order).
Many scenarios relate message flows with timing constraints. It is possible to easily specify such scenarios in the MSC notation using three special events: timer set, timer reset and timeout. The timer set event is denoted by an hourglass symbol connected to the timeline of a single process. The timer reset event is denoted by a cross connected to the timeline of a process. The timeout event is denoted by connecting the hourglass symbol of the timer to the process timeline by a bent line. Each timer has a unique name. Naturally, for each timer, the timer reset and timeout events must be preceded by the timer set event. In Figure A.1, the controller starts a timer t1 before waiting for the messages from valve and pressure gauge instances. In this particular scenario, the controller receives both the messages before the timeout and then resets the timer t1.
A condition is an informal descriptive mechanism in the MSC notation used to display a state or situation that must be reached by either a single instance or a group of instances. A condition is written as a text label within a hexagonal box, which is placed either on a single instance or across a group of instances. If a condition C is placed on a single instance P then the execution of P does not proceed to the next event (below the condition on the local order) until the condition is reached. That is, the condition C is a pre-requisite for the next event in the instance. If the condition C is placed across a group of instances P1,... , Pk, then all the k instances must achieve local states in which the condition C is satisfied; only after that state is reached, can any of the k instances proceed further in their respective local orders. In such a case, the condition C can be thought of a synchronisation mechanism useful to ensure that the instances P1,... , Pk reach the same state before proceeding further. In Figure A.1, instances valve and pressure gauge share a condition called status available; only when both these instances reach a state that satisfies this condition, can they proceed further with their local orders.
What exactly is the scenario specified by the basic MSC in Figure A.1? It may appear that the MSC represents only one sequence of events; in fact it represents several actual event sequences each of which captures the intended behaviour. To understand this clearly, we formally define the linear time semantics of a basic MSC.

Linear Time Semantics of Basic MSCs
The MSC notation discussed so far is called a basic MSC to distinguish it from the HMSC defined later. We now formally define the linear time semantics of


a basic MSC in terms of the associated partial order and the set of runs [2,6,5]. With each instance i in a given basic MSC m, we associate an ordered sequence 0..lmax(m, i) of finite number of discrete locations, which are numbered from the top of the instance to the bottom. Each location on an instance i in basic MSC m, denoted < i, l >m, is associated with an event, which may be sending or receiving of a message, a condition, or timer events set, reset, timeout. We drop the subscript m when the basic MSC is clear from the context. The semantics of a basic MSC m is defined in terms of the partial order ≤m induced by m on the set of its locations < i, l >. The partial order is obtained from the following precedence relation Rm:
visual order along an instance line: < i, l > Rm < i, l +1 > unless the two consecutive locations are in a co-region
send of a message precedes its receipt: if < i, l > is a send event and
< i', l' > is the corresponding receive event for the message, then < i, l > Rm < i', l' >
shared condition induces synchronisation barrier: if locations < i, l >
and < i', l' > refer to the same condition c, then < i, l > Rm < i', l' +1 >
events within a co-region have no order among them: suppose < i, l >, < i, l +1 >,... ,< i,l + k > are events in a co-region. If l > 0 (i.e., there is at least one event before the co-region) then < i, l − 1 > Rm < i, l >,
< i, l − 1 > Rm < i, l +1 >, ... ,< i, l − 1 > Rm < i, l + k >. Also, if k < lmax(i, m) (i.e., there is at least one event after the co-region) then < i, l > Rm < i, l + k +1 >,< i, l +1 > Rm < i, l + k +1 >,
... ,< i, l + k > Rm < i, l + k +1 >.
We assume that the basic MSC m is well-formed so that the relation Rm is acyclic. We call Rm the precedence relation of the basic MSC m. The partial order ≤m is the reflexive transitive closure of Rm.
Definition A.1 The semantics of a basic MSC m is the set of all runs (i.e., linearizations) of the partial order ≤m.
This implies that we have interleaving semantics for concurrency: any two events that are incomparable in the partial order can happen in any order. Note also that each run of a basic MSC is a finite sequence of events and each basic MSC has only a finite number of such finite runs. The precedence graph in Figure A.2 depicts the precedence relation Rm among the locations (events) in the basic MSC of Figure A.1. The vertices of this precedence graph stand for events; there is a directed edge from event u to event v if u directly precedes v i.e., uRmv. An event v cannot occur until all preceding events have occurred. If the MSC is well-formed then the corresponding precedence graph


e6

e5	e1 = valve sends status_close to controller
e2 = controller receives status_close from valve
e3 = pressure_gauge sends status_high_pressure to controller
e4 = controller receives status_high_pressure from pressure_gauge e5 = controller sends cmd_open to valve
e8	e6 = valve receives cmd_open from controller e7 = set timer t1
e8 = reset timer t1
c1 = condition correct_status_available

e4




e2




e1	e7	e3




c1

Fig. A.2. Precedence graph for the basic MSC in Figure A.1
is a directed acyclic graph (DAG).

References
Alur, R., K. Etessami and M. Yannakakis, Realizability and veriﬁcation of MSC graphs, in:
Proc. 28th Int. Col. on Automata, Languages and Programming, 2001, pp. 797–808.
Alur, R., G. Holzmann and D. Peled, An Analyzer for Message Sequence Charts, Software Concepts and Tools 17 (1996), pp. 70–77.
Alur, R. and M. Yannakakis, Model Checking of Message Sequence Charts, in: Proceedings of the Tenth International Conference on Concurrency Theory, CONCUR’99, Lecture Notes in Computer Science (1999).
Ben-Abdallah, H. and S. Leue, Syntactic detection of process divergence and non-local choice in message sequence charts, in: E. Brinksma, editor, Tools and Algorithms for the Construction and Analysis of Systems, Lecture Notes in Computer Science 1217 (1997), pp. 259–274.
Bhaduri,   P.,   R.   Venkatesh   and   G.   Palshikar,   Formal techniques for analysing scenarios using message sequence charts, in: ETAPS Workshop on Validation and Implementation of Scenario-based Speciﬁcations, VISS 2002, Grenoble, 2002, appeared in Electronic Notes in Theoretical Computer Science, Volume 65, Issue 7, Elsevier, http://www.elsevier.com/gej-ng/31/29/23/117/50/26/65.7.002.pdf .
Damm, W. and D. Harel, LSCs: Breathing Life into Message Sequence Charts, in: FMOODS’99: Proc. Third IFIP Intl. Conf. on Formal Methods for Open Object-Based Distributed Systems, 1999.


Dwyer, M., G. Avrunin and J. Corbett, Property speciﬁcation patterns for ﬁnite-state veriﬁcation, in: Proceedings of the Second Workshop on Formal Methods in Software Practice, 1998, pp. 7–15.
Feijs, L. M., Natural language and message sequence chart representation of use cases, Information and Software Technology 42 (2000), pp. 633–647.
Gehrke, T., M. Huhn, A. Rensink and H. Wehrheim, An algebraic semantics for message sequence chart documents, in: FORTE, 1998, pp. 3–18.
Genest, B., A. Muscholl, H. Seidl and M. Zeitoun, Inﬁnite-state high-level MSCs: Model- checking and realizability, in: ICALP: Annual International Colloquium on Automata, Languages and Programming, 2002, pp. 657–668.
Graubmann, P. and E. Rudolph, Hypermscs and sequence diagrams for use case modelling and testing, in: A. Evans, S. Kent and B. Selic, editors, UML 2000 - The Uniﬁed Modeling Language. Advancing the Standard. Third International Conference, York, UK, October 2000, Proceedings, LNCS 1939 (2000), pp. 32–46.
Haugen, Ø., From MSC-2000 to UML 2.0 - The future of sequence diagrams, in: SDL 2001: Meeting UML. 10th International SDL Forum Copenhagen, Denmark, June 27-29, 2001, Proceedings, LNCS 2078 (2001), pp. 38–51.
Haugen, Ø., MSC-2000 interaction diagrams for the new millennium, Computer Networks (Amsterdam, Netherlands: 1999) 35 (2001), pp. 721–732.
ITU-T, ITU-T Recommendation Z.120: Message Sequence Chart (MSC) (1996).
Janssen, W., R. Mateescu, S. Mauw, P. Fennema and P. van der Stappen, Model checking for managers, in: Proceedings of the 6th International SPIN Workshop on Practical Aspects of Model Checking (Toulouse, France), 1999.
Jonsson, B. and G. Padilla, An execution semantics for MSC-2000, Lecture Notes in Computer Science 2078 (2001), pp. 365–378.
Levin, V. and D. Peled, Veriﬁcation of message sequence charts via template matching, in: TAPSOFT (FASE)’97, Theory and Practice of Software Development, LNCS 1214 (1997), pp. 652–666.
Mauw, S., The Formalization of Message Sequence Charts, Computer Networks and ISDN Systems 28 (1996).
Mauw, S. and M. A. Reniers, Operational Semantics for MSC’96, Computer Networks (Amsterdam, Netherlands: 1999) 31 (1999), pp. 1785–1799.
Miga, A., D. Amyot, F. Bordeleau, D. Cameron and M. Woodside, Deriving message sequence charts from use case maps scenario speciﬁcations, Lecture Notes in Computer Science 2078 (2001), pp. 268–287.
Muscholl, A. and D. Peled, Analyzing message sequence charts, in: Proc. of SAM’00, Grenoble, 2000.
Muscholl, A., Z. Su and D. Peled, Deciding properties for message sequence charts, in: FoSSaCS, Foundations of Software Science and Computation Structures, Lisbon, Portugal, 1998.
Palshikar, G. K., A. Pavaskar, M. Jadhav, D. Patil and M. Bakshi, An RF-based embedded system for protecting unmanned railway crossings, in: Conference on Information Technology (CIT 2003), Bhubaneshwar, 2003.
Peled, D., Speciﬁcation and veriﬁcation of message sequence charts, in: Proc. IFIP FORTE/PSTV, 2000, pp. 139–154.
Rudolph, E., J. Grabowski and P. Graubmann, Tutorial on Message Sequence Charts, Computer Networks and ISDN Systems 28 (1996), pp. 1629–1641.
Silva, P. S. M., Extended Message Sequence Charts with time-interval semantics, in: 5th Workshop on Temporal Representation and Reasoning, TIME ’98, 1998, pp. 37–44.
