Electronic Notes in Theoretical Computer Science 112 (2005) 77–94  
www.elsevier.com/locate/entcs


Tarzan: Communicating and Moving in Wireless Jungles
Emilio Tuosto
Dipartimento di Informatica, Via F. Buonarroti 2, 56127 Pisa – Italy

Abstract
Wireless networks allow portable/mobile devices (and the related applications) to communicate each other with radio or infrared signals. Computations on those networks are very sensible to many physical variables (e.g., energy consumption, distance, geographic topology, etc.). We propose Tarzan, a framework based on graph rewriting that easily allow one to express many quantitative aspects of wireless networks. Apart from the expressiveness issue, the main advantage of Tarzan is its formal semantics that can be exploited for specifying applications, routing algorithms or coordination aspects of wireless devices considering realistic physical limitations.
Keywords: Wireless network, graph rewriting, edge replacement, synchronization.


Introduction
Networks of wireless devices present peculiarities that result of minor or no importance in wired networks. Among others, dynamism of network topology, energy constraints and transmitting capacity are of great moment. Topology of wireless networks is highly dynamic because nodes in general are portable computational devices (e.g. mobile phones, PDA’s, laptops,...). Nodes can asynchronously disappear because of battery consumption. Apart from the impact on interactions among devices and dynamism of the topology, this is an important issue also because wireless networks typically are peer-to-peer network where any node can act as a gateway. Wireless devices have limited

 This work has been supported by the european EU-FET project PROFUNDIS IST- 2001-33100 and the MIUR project SP4 “Architetture Software ad Alta Qualit`a di Servizio per Global Computing su Cooperative Wide Area Networks”.


1571-0661 © 2004 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.022


transmitting capacity. Therefore, communication is not always guaranteed; moreover, the external environment might cause interferences or interdict com- munications.
Summing up, wireless networks raises many issues that intrinsically involve several quantitative aspects that must be taken into account in the computa- tion. In general, those aspects are considered separately and studied within a mathematical setting that models the physical characteristics of devices and external environment with respect to routing algorithms. As far as we know, a formal framework for expressing the above discussed phenomena in a uniform framework is still lacking.
Graph-based techniques can be adopted for modelling inter-networking sys- tems. Indeed, edges can be used to represent components of the system, while nodes model the synchronisation ports of the components. Two (or more) edges sharing a node represent components connected on a communication port; adjacent edges can synchronise. Graphs can be opportunely synchro- nised by means of an operational semantics. Graph rewriting based on edge replacement and synchronisation was introduced in [2,5] and related to dis- tributed constraint satisfaction problems in [14]. Mobility has been recently considered in [9,10,6,16] where synchronised hyperedge replacement (SHR) has been investigated.
We consider purely local graphs synchronisation obtained by combining graph rewriting and constraint solving. The intuitive idea is that local rewrit- ings depends on the outcome of a constraint satisfaction algorithm. Our framework is a simplification of the SHR approach in [6] and permits in- terconnection modification. Nodes can be exchanged during synchronisations, hence constraint solving must encompass unification in order to fuse node. This amounts to mobility of components, that dynamically can change their connections. On the top of the SHR approach, we describe Tarzan,a semantic model suitable for dealing with those aspects of wireless networks. Interest- ingly, graph rewritings seem to be suitable for describing some phenomena that traditional models of distributed computations cannot apparently cap- ture (at least in a simple manner, see the discussion in Sections 2 and 6). In particular, communication interferences can be simply expressed in a formal way accounting for formal reasoning on wireless networks. This seem to be an interesting and not completely explored field; indeed, quoting [7]:
For ad-hoc networks that share the same spectrum, new methods of coop- eration are required to permit coexistence. Such methods are diﬃcult to research without real-world channel models and simulation methodologies; there is still fundamental work to be done in this area [13].
Apart from a theoretical interest, we suggest Tarzan as a formal language


for expressing computations in wireless networks and modelling the physical environment. As will be more clear later (Section 5) the environment resembles a luxuriant vegetation of a tropical jungle with lianas where Tarzan (a wireless device) swings and yells looking for Jane (his partner). Even though we do not address wireless protocols design, this approach can also help designers in correctly specifying their protocols.

Structure of the paper. Section 2 briefly discusses the difficulties that traditional models of distributed computations have when wireless communi- cations are under consideration. Section 3 gives an intuitive interpretation of SHR. Section 4 reports the formal definitions of hypergraphs and produc- tions; moreover, an intuitive operational interpretation of SHR is given in Section 4.3 by means of an example. In order to maintain the presentation as simple as possible, we relegated the formal definition of SHR in Appendix A. Productions for Tarzan are defined in Section 5. Final remarks are in Section 6.

Wireless Networks and Traditional Models
Differently from wired networks, wireless devices can interact each other with- out a pre-existing communication infrastructure. Indeed, they are typically equipped with both radio and infrared transmitters/receivers.
A semantical framework for modelling and reasoning on wireless systems is inherently much more difficult to define than a framework for “wired-systems”. The main reason being that the communication infrastructure does not per- mit to individuate the position of components by their name (as discussed in Section 1). This is not only problematic for modelling interaction of compo- nents, but also because the semantic model should encompass the concept of distance. In fact, the framework should model the topology (together with its geometrical/physical structure), the structure of the network and distances between two components, their transmitting capacity, etc.
Traditional frameworks like Ambient [1] or Klaim [4] do not seem able
to capture the great part of these aspects in an elegant manner. An Am- bient system is the parallel composition of ambients and that are terms of the form a[P1| ... |Pn|b1[.. .]| ... |bm[.. .]] (a, bi’s are names and Pj’s are sub- systems). Hence the topology of an Ambient system if a forest of trees. Pro- cesses send messages “in the air”, receive them and guide their surrounding ambient through the system topology. The condition for a message being received is that both the message and the receiver must be inside the same ambient. However, this “vicinity” condition does not encompass any distance concept because the parallel composition operator | is commutative, therefore


a[P |Q|R] is equivalent to a[P |R|Q]. In Klaim systems are parallel composi- tion of nodes s :: P1| ... |Pn, where s is the name of the node, Pi’s are either processes running at s or tuple of data allocated at s. Processes can gener- ate tuples, input them via pattern-matching and roam through nodes. Klaim messages “float in the air” of s, however nesting of nodes is not allowed, hence Klaim nets resemble flat graphs.
Recently, Klaim has been equipped with linguistic mechanisms for control- ling links among nodes [3]. Link creation and remotion can be programmed and the language can also express link features that depend from the ap- plications. Indeed, distance between nodes can be easily expressed in this context. However, neither Ambient nor Klaim can easily model an interesting phenomenon of wireless communications, namely the interference on commu- nications caused by third party movements. Indeed, the communication be- tween two wireless devices D1 and D2 can be disturbed by another component (not necessarily a device) that moves trough the space separating them. This phenomenon is difficult to capture in traditional frameworks because even if a link encompass the distance between nodes, it is under the control of the connected nodes and a third entity cannot “break” or modify it.

Hypergraphs: an Overview
Graph grammars [15] have been proposed as an extension of grammars of strings. Similarly to grammars of strings, productions of graph grammars have the form L −→ R where L and R are graphs and specify how graphs can be rewritten. Conditions on L −→ R allow one to introduce the concept of “context-freeness”, e.g. productions with a left-hand-side (lhs) which is either a node or an edge confer a “context-free” flavour to graph grammars; indeed, such productions do not consider the “surroundings” of their lhs.
Hypergraphs are graphs made of nodes and hyperedges, a generalisation of edges; a hyperedge may be thought of as being an edge connecting more than two nodes. An edge in a traditional graph can be intuitively thought of as representing a binary relation between two nodes, while a hyperedge represents a relationships among many nodes.
We will describe a rewriting mechanism based on synchronised hyperedge replacement; indeed, such mechanism will be exploited to constraining graph rewriting. Figure 1 aims at giving an intuition of hyperedge replacement. The hyperedge L in Figure 1(a) is connected to G1 and G2 through its external nodes (or attachment points) 1,... , 5: Figure 1(b) represents the hypergraph obtained by replacing L with hypergraph G. The dashed gray part of the Figure 1(b) represents the initial situation and disappears after L has been


	
(a) A hyperedge L	(b) Replacement of L with G

Fig. 1. Hyperedge replacement
replaced by G; notice that G1 is not involved in the rewriting. Moreover, new nodes can appear (all nodes in G but 1 and 2 are new nodes generated by the transition) and some nodes can be “fused” after the transition (in Figure 1(b) node 4 is fused with 5). As will be shown later, this amounts to mobility of components, that dynamically can change their connections. In fact, notice that, in Figure 1(b), the part of G2 that was connected to node 4 corresponds, in Figure 1(a), to the part of G2' connected to node 5.

Hypergraphs
In the following we consider fixed a set of nodes N and a set of labels L ranked by natural numbers; L : n denotes a label L ∈ L with rank n.
Hypergraphs are built out from hyperedges and nodes. A hyperedge (or simply an edge) labelled by L may connect as many nodes as its rank. We write L(x1, ..., xn) to indicate an edge labelled L connected to the attachment nodes x1,..., xn. For instance, hyperedge L in Figure 1(a) is written as L(1,... , 5). Wires from nodes 1,... , 5 to L are the attachment point of L and are called tentacles.
Formally, hypergraphs are syntactic judgements:
Definition 4.1 Γ ▶ G is a syntactic judgement iff
Γ ⊆N is a finite set of nodes and
G is a term generated by the following grammar
G ::= nil ˛ L(x1,. .., xn) ˛ G | G,
where x1,... , xn are nodes and L ∈ L is such that L : n. We call terms G
hypergraph terms and let n(G) denote the set of nodes that appear in G.
Productions in Definition 4.1 permits generating the empty graph (repre- sented by nil), single edges (using L(x1,... , xn)) and composing terms in


parallel (via G | G). Hereafter, we use ’graph’ as a synonym of ’hyper- graph’ and omit curly brackets in judgements writing x1, ..., xn ▶ G instead of
{x1, ..., xn} ▶ G.



Hypergraph Synchronisation
SHR is obtained by graph rewriting combined with constraint solving. More specifically, we use context-free productions labelled with actions useful for co- ordinating the simultaneous application of productions. Coordinated rewriting allows the propagation of synchronisation all over the graph where productions are applied. Determining the productions to synchronise at a given stage cor- responds to solving a distributed constraint satisfaction problem [14].
The main feature of the SHR approach is that an hyperedge can be replaced when the conditions it imposes on its external nodes are in accordance with the conditions imposed by adjacent hyperedges and with the adopted synchro- nisation policy. Replacements can generate new nodes, exchange nodes and fuse them.
Observation 4.1 Each edge rewriting must synchronise its actions with one or more of its adjacent edges. Depending on the chosen synchronisation alge- bra, the number of edges can vary.
The main and well studied synchronisation mechanisms are a´ la Hoare
(CSP [11], where S(a, a)= a) and a´ la Milner (CCS [12], where S(a, a¯)= τ) synchronisations [17] (conventionally, one can think of a¯ as an output action, while a denotes an input action). The former requires that all participants of a synchronisation perform the same action, while the latter takes two part- ner to synchronise through complementary actions. Hereafter, we consider synchronisations a´ la Milner.
In the following, we assume fixed Cons, a set of actions used for naming the conditions imposed on the external nodes of hyperedges for constraining graph rewritings. Since we use Milner synchronisations, Cons also has two further ingredients:
a complementation operation ¯· : Cons → Cons such that for any a ∈ Cons,
a¯ = a;
a distinguished silent action τ that denotes synchronisations.
Moreover, we assume that any label a ∈ Cons has an arity ; we let |· | :
Cons → ω be the arity function on Cons and, for any a ∈ Cons, |a| = |a¯|.

Productions
A graph rewriting system, G = ⟨Γ0 ▶ G0, P⟩, consists of an initial graph Γ0 ▶ G0 and a set of productions. Before defining productions, we need an auxiliary definition.
Definition 4.2 [Fusion substitution] Let X be a set of nodes. A fusion sub- stitution on X is a function π : X → X such that
∀x, y ∈ X.π(x)= y ⇒ π(y)= y.
A fusion substitution π : X → X induces an equivalence relation  π over
def
X defined as x  π y ⇐⇒ π(x) = π(y). Equivalence  π partitions X into
equivalence classes and each node x ∈ X is mapped to the representative element π(x) of its class, namely the unique element y such that π(y)= y.
Definition 4.3 [Production] Let X ⊆ N be the set {x1,... , xn} and L ∈ L 
such that L : n. A production is a transition of the form
Λ
X ▶ L(x1 ,..., xn) −−→> Γ ▶ G,	(1)
π
where n(G) ⊆ Γ and
Λ ⊆ X × Cons ×N ∗ is a set of constraints which are triples (x, a, y) such that the length of y is |a|.
Given Λ, we say that y are the nodes of the constraint (x, a, y) ∈ Λ and Λ(x) indicates (a, y), while Λ(x) ↑ states that Λ does not imposes constraints on x (i.e. (x', a, y) ∈ Λ implies x /= x'). We let n(Λ) denote the union of the nodes of the constraints in Λ.
π : X → X is a fusion substitution such that n(Λ) ∩ X ⊆ π(X) (namely, the external nodes used in the synchronization must be representative elements according to π );
- Γ = π(X) ∪ (n(Λ) \ X).
Nodes x1,... , xn are the attachment nodes of L to the surrounding en- vironment, namely L can share them with other edges. Productions specify the constraints that the environment must satisfy in order to replace edges. Such constraints are imposed by Λ on the set X of external nodes of L; ar- ities of actions must be equal to the number of nodes of the constraint. Λ associates actions and sequences of nodes to (some of the) external nodes of
L. Intuitively, actions associated to attachment nodes constrain the possi- ble rewritings of a graph; indeed, production (1) can be applied only if the actions on the external nodes synchronize with actions imposed by the pro- ductions of adjacent edges according to the adopted synchronization policy. If


(x, a, y) ∈ Λ then L can synchronize with edges in the environment that have a tentacle connected to x and satisfy condition a.
Let us now consider the structure of the right hand side of production (1). Γ consists of the nodes which are image of x1,... , xn through π and the new nodes used in the synchronization, namely those nodes that appear in Λ and are not in X. In general, G may be any graph (provided that n(G) ⊆ Γ).
In the following we write X ▶ L(x ,... ,x ) −−Λ→> Γ ▶ G, for a prodution
1	n
whose fusion substitution is the identity function.
Once constraints in Λ are satisfied, nodes must be coalesced according to fusion substitution π.
Synchronising productions
This section provides an example of application of SHR. We prefer to leave the presentation as simple as possible, therefore, we give an intuitive description of SHR-based rewritings. The formal machinery is reported in Appendix A. Instead of using the “textual” description of productions, we state them di- rectly in terms of graphs. The following productions represent how an edge can migrate. We will exploit them in the design of the Tarzan framework.
We consider a simple example where two edges, E :3 and D : 1 interact.
The production

¯l⟨•z⟩	
x
•	=⇒	•	•
x

z•	z•
states that an edge E(x, y, z) synchronises on node x with an l-action and com- municates its third node z. After the synchronisation, E remains unchanged. The second production for E-edges is

•	E 	l⟨•u⟩	=⇒	•
u•

x	y	x	y
z• a⟨u⟩	z•
and states that E(x, y, z) simultaneously synchronises on node y and z with
action l and a, respectively. In the rhs of the production the new node u appears. The intuition is that the node from an adjacent E-edge is received with l synchronisation and communicated to an edge connected to z.
Edge D has only one production

	z'
•	=⇒
a¯⟨w⟩
z'	w
•	•



x•	y•
•z	w =•
(a)

u	•z'
x•	y•
z•
(b)


z'•

Fig. 2. Edge moving
stating that, when D(z') synchronises on z' with action a, then a new node w is received; after the synchronisation, the D-edge connected to z' is cancelled and a new instance of D-edge appears connected on the new node w.
Let us consider the following graph (tentacles have been annotated with the actions of the productions):


x•
a⟨u⟩
a¯⟨w⟩ •
z
l⟨u⟩
y• ¯l⟨z'⟩	•

•
z'
(2)

Rewritings of graph (2) are determined by the following steps:
Individuate the adjacent tentacles labelled by complementary actions;
determine the synchronising productions;
replace the (instance of) edges appearing in the lhs of synchronising pro- ductions with the corresponding rhs;
fuse those nodes that are equated by the synchronisations.
Let us apply the previous schema to graph (2). Step (i) is already done in (2); step (ii) is easy: The rightmost and the leftmost instances of E-edge are respectively rewritten by the first and second production of E-edges, while for edge D there is only one possible production. Step (iii) gives rise to the graph in Figure 2(a). Since the synchronisations impose the equations w = u = z', step (iv) simply fuses w and z', determining the graph in Figure 2(b), where D is moved from z to z'.
The intuitive description of SHR given in this section suggests the following design style:
Represent systems as a number of components;
for each component, draw a hyperedge so that its external nodes are ex- plicited (as in the reported example);
then, on the external nodes, write the actions that will constraint the hy- peredge rewriting;
finally, the graph that will be substituted with the hyperedge is specified



x1	
•
x2
•

z•

Environment Edge

Environment graph


Fig. 3. Environment edges and graphs

taking care that the external nodes of the graph satisfy the conditions of Definition 4.3.
In the following we will adopt this design style.

Tarzan
We exploits the graphical calculus reported in the previous sections to model both wireless devices and the “environment” where they run. Our framework, Tarzan, takes advantage of the declarative flavour of SHR since devices are autonomous while mobility is achieved by node fusion. We do not consider all the issues discussed before, but give hints on how they can be modelled in Tarzan.
The environment is built by connecting environment edges E :3 that have three tentacles and can be depicted as in Figure 3(a). Edge E(x1, x2, z) can be thought of the atomic item that composes an ideal “ether” that allows signals to flow from x1 to x2 (and viceversa); node z is the node where edges representing wireless devices will be connected. As suggested by Figure 3(b), one can thought of the environment as a luxuriant vegetation of a tropical jungle with a lot of lianas where Tarzan (a wireless device) swings and yells looking for Jane (his partner).
The productions for signal propagation, wireless devices and environment edges follow.


Productions for signals
The main features of signals that we want to model are: (i ) band frequency, (ii ) intensity and (iii ) direction. In general, other informations should be con- sidered, for instance, signals carry data for routing or applications. However, we want only to define a framework for describing how signals propagate in a given environment. Considering more informative edges is a simple generali-

sation of the following definitions 1 .
We assume the existence of signal edges of arity 1 labelled by Sf,d, where f is a band frequency, d is a direction (commented later) and r is a natural number that abstracts the intensity of the signal. Productions for signal edges are very simple: As far as the intensity is not null, the signal tries to propagate along the assigned direction:


f, d⟨w, z⟩
•
y



=⇒
w
. •
...
•
y



z.

Only signals with non-null intensity can propagate. The intuition is that Sf,d acquires from the environment the node w which is the next node along the direction d and the node z where a device is possibly connected. After the synchronisation, the weaker signal edge Sf,d is attached to w and the informa- tion edge S accounts for interacting with the devices (possibly) encountered in that direction. The productions for S-edges are:

The first production considers the case where the information reach a de- vice connected to z, while the second production states that the message can disappear without being received 2 . This models the case that no device is connected to z. Action m in general depends on the messages that must be ex- changed. Here, we do not consider the informations that are relevant because they depend on the applications one wants to describe.

Productions for devices
Similarly to signal edges, device edges have arity 1. The main character- istics of devices we are interested in are: (i ) the energy level, and (ii ) the transmitting capacity. We consider constant the transmission power of a de- vice 3 , while the energy level is dealt with as done for the intensity of signal edges. Device edges are labelled by Dr; r is the carrier sense radius of the device, and b represents the residual energy of D (for simplicity we can assume that b is a positive integer).

1 Here we do not consider broadcast signals that can be modelled at the cost of some complication with Milner synchronisation, whereas Hoare synchronisations could be more adapt.
2 A similar production can be specified for Sf,d if we want collect garbage signals.
3 This is not always the case, but we want to keep this presentation as simple as possible.
Simple variations of our productions can easily handle the general case.


We first consider productions for handling energy consumption:


=⇒	•
z	z

=⇒	•
z	z
b' ≤ b	(3)


b > 0.	(4)

Production (3) states that the energy level of a device can non-deterministically decrease. Condition b' = b captures the case of D representing a plugged in devices. Production (4) can appear strange at a first glance; it states that a discharged device suddenly acquires some energy. Basically, this models the fact that a device is turned on, at a given time.
Device mobility is modelled similarly to flow of signals:



=⇒	•
z	z
b' ≤ b;
z'

Dr asks for the “next liane” along direction d where to jump to and, when found, the device moves. Notice that also in this case energy level might decrease.
Last production deals with the emission of signals:



em f, d⟨x⟩
r
b
z
=⇒
z	x
•	•
b' ≤ b.

The intuition of the previous production is that device Dr attaches the signal- edge Sf,d to the node x acquired from the environment edge. Such edge will propagate along direction d within a distance rb (that, in general, depends on b) and will behave according to the productions defined for signal edges.

Productions for environment
The environment is modelled by means of edges E : 3 whose main activity is the propagation of signal:


f, 2⟨x2 , z⟩
E	•

=⇒	•	•

x1	x2
z •
x1
x2
z •

If E, on node x1, is asked for the next node (from a signal edge), then it communicates node x2 (as the next node) and z (as the liane where node S- edge must be connected). The dual situation takes place when on x2 a signal wants to propagate toward x1:
•	E  f, 1⟨x1 , z⟩  =⇒	•	•

•
x1	x2
z •
x1
x2
z •


When a device on z wants to emit a signal, E must communicate x1 or x2
depending on the direction:



x1

x2
z • em f, d⟨xd⟩
=⇒	•
x1

x2
z •
d = 1, 2

the environment node communicates x1 or x2, depending d.
Mobility of devices is more involved than signal propagation. Indeed, a device must “swing from liane to liane”. Hence an environment edge must coordinate device action mv and ask to its neighbour environment (depending on the direction it wants to move toward) for the next liane (action l):


•
x1
z •	mv 2⟨u⟩
=⇒	•
x1


z •
• u
x2

•
x2
z •	mv 1⟨u⟩
=⇒	•
x1

z •
• u
x2

The above productions perform such coordination; we comment only the
first one, the second being analogous. If a device attached on z wants to move toward x2, then the environment edge asks for the z-node of its neighbour. On reception, the device will attach itself on that node. Notice that, apart from the labels, this is exactly the same mechanism described in Section 4.3, indeed, in order to commit device movements, environment edges must perform the complementary actions of l:


•	=⇒	•
x2	x1
z •
•
x2
z •

(notice that the z-node of E is communicated). An analogous production is necessary for communicating z on x2 when the device wants move toward x1.

Final remarks
Modern inter-networked systems encompass several physical networks, mul- tiple administration domains and a variety of possible users. Researches on global computing investigate the complex interactions taking place in inter- network computations. Many of those mainly focus on the spatial structure of systems with explicit localities, which model distributed computations and dis- tributed resources and services composition. The main difference with respect to models of traditional distributed systems is network awareness: Localities are under programmer’s control.


Traditional models of distributed systems assume that the addresses im- plicitly contains informations on the position of remote resources with respect to each component. Namely, the address of a resource implicitly describes how to reach it. A paradigmatic example of this addressing mechanism being IP-addressing. This is a strong assumption in wireless communicating systems and probably is one of the main difficulties for formally modelling them. A component that knows the address of a wireless device has no information on the position of that device.
We have shown how SHR can suitably represent those aspects of wire- less communications (that seem difficult to be handled with more traditional approaches as discussed in Section 2). Our framework presents intrinsic pe- culiarities that have a precise counterpart in distributed programming (e.g. “declarativity as autonomy” and “node-fusion as mobility”). Moreover we specified Tarzan that extends the applicability of SHR to wireless communica- tions. Tarzan is very flexible (“agile”). For instance, without any significant change to its basic mechanisms, it is possible to distinguish between radio and infrared (IR) devices; we must simply consider action label f as a metavariable ranging over {radio, IR}. Hence, we can also model “obstacles” that may be present in the environment. For instance a wall is simply an edge (connected to environment edges) having the same productions of E plus the additional condition that f /= radio, which essentially states that a wall permits IR signals to traverse it but blocks radio waves.
All these peculiarities make Tarzan a expressive and extensible formal framework for modelling wireless systems or algorithm for wireless networks. The interesting feature of Tarzan is that routing algorithms can be programmed orthogonally to environment and signal propagation. Indeed, it is sufficient to specify productions like the last one for signal edges by supplying the routing information (informations like routing tables can be represented as suitable edge-labels attributes). As far as we know, the separation of concerns between routing algorithms and mobility or communication models is an innovative feature of our approach.
In this work we do not exploit the full expressiveness of SHR mechanism defined in [16,6]. Indeed, fusion substitutions are a powerful linguistic mech- anism that permits merging communication points. (e.g., nodes of hyper- graphs). This can be very useful for describing routing algorithm and coor- dinating activities of adhoc networks. For instance, a typical dynamic recon- figuration policy of adhoc networks is to collect devices of different subnets into a new net. Fusion substitutions can easily model this reconfiguration mechanism. We leave the formal definition for future investigations.
A final consideration is on the synchronisation policy adopted. Here we


chose synchronisation a la´ Milner, however, we plan to extend SHR for per- mitting both Milner and Hoare synchronisations. This is useful for a better handling of broadcasting. Indeed, Hoare synchronisations are a natural model for broadcasting communications and this would allow Tarzan signals to prop- agate in any direction.

Acknowledgement
The author thanks the anonymous referees for their useful comments and suggestions. The author is particularly grateful to Gianluigi Ferrari, Dan Hirsch and Alessandro Urpi for their useful comments and suggestions on a very preliminary version of this work.

References
Cardelli, L. and A. Gordon, Mobile ambients, TCS: Theoretical Computer Science 240 (2000).
Castellani, I. and U. Montanari, Graph Grammars for Distributed Systems, in: H. Ehrig,
M. Nagl and G. Rozenberg, editors, Proc. 2nd Int. Workshop on Graph-Grammars and Their Application to Computer Science, Lecture Notes in Computer Science 153 (1983), pp. 20–38.
De Nicola, R., G. Ferrari, U. Montanari, R. Pugliese and E. Tuosto, A formal basis for reasoning on programmable qos, in: International Symposium on Veriﬁcation – Theory and Practice – Honoring Zohar Manna’s 64th Birthday, Lecture Notes in Computer Science, Springer-Verlag, 2003 pp. 436–479.
De Nicola, R., G. Ferrari and R. Pugliese, KLAIM: A kernel language for agents interaction and mobility, IEEE Transactions on Software Engineering 24(5) (1998), pp. 315–330.
Degano, P. and U. Montanari, A model of distributed systems based of graph rewriting, Journal of the ACM 34 (1987), pp. 411–449.
Ferrari, G., U. Montanari and E. Tuosto, A LTS semantics of ambients via graph synchronization with mobility, in: 7th Italian Conference on Theoretical Computer Science – ICTCS’01, LNCS 2202 (2001), pp. 1 – 16.
Giordano, S., “Handbook of Wireless Networks and Mobile Computing,” John Wiley & Sons, 2001 pp. 325–343.
Hirsch,  D.,  “Graph  Transformation  Models  for  Software  Architecture Styles,” Ph.D. thesis, Departamento de Computaci´on, Universidad de Buenos Aires (2003), http://www.di.unipi.it/~dhirsch/thesis.pdf .
Hirsch, D., P. Inverardi and U. Montanari, Reconﬁguration of software architecture styles with name mobility, in: A. Porto and G.-C. Roman, editors, Coordination 2000, LNCS 1906 (2000),
pp. 148–163.
Hirsch, D. and U. Montanari, Synchronized hyperedge replacement with name mobility: A graphical calculus for name mobility, in: 12th International Conference in Concurrency Theory (CONCUR 2001), LNCS 2154 (2001), pp. 121–136.
Hoare, C., “Communicating Sequential Processes,” Prentice-Hall, Englewood Cliffs, NJ, 1985, & 0-13-153289-8.
Milner, R., “Communication and Concurrency,” Printice Hall, 1989.


Mobile Man Project, Nfs tetherless t3 and beyond workshop, Interim report (1998).
Montanari, U. and F. Rossi, Graph rewriting and constraint solving for modelling distributed systems with synchronization, in: P. Ciancarini and C. Hankin, editors, Proceedings of the First International Conference COORDINATION ’96, Cesena, Italy, LNCS 1061 (1996), pp. 12 –
27.
Rozenberg, G., editor, “Handbook of Graph Grammars and Computing by Graph Transformation. Vol. 1: Foundations,” World Scientific, 1997.
Tuosto, E., “Non-Functional Aspects of Wide Area Network Programming,” Ph.D. thesis, Dipartimento	di
Informatica, Universit`a di Pisa, Via Buonarroti 2, 56127 Pisa - Italy (2003), Universitario di Pisa. http://www.di.unipi.it/phd/tesi/tesi_2003/PhDthesis_Tuosto.ps.gz .
Winskel, G., Synchronization trees, Theoretical Computer Science (1985).

A  Hypergraphs Rewriting via SHR
Graph semantics is based on productions to specify edge replacement, while inference rules essentially synchronize productions and confer dynamic be- haviour to graphs. We report here only the essential formal definitions; for a deeper presentation, we refer the reader to [16,15,10,8].
A transition is a logical judgment
Λ
Γ1 ▶ G1 −−→> Γ2 ▶ G2	(A.1)
π
where Λ, π, Γ2 and G2 obey the same conditions imposed on productions. Essentially, transitions can be seen as productions having general graphs on their lhs. Hence transitions describe the dynamic evolutions of graphs.
Transition (A.1) states that Γ1 ▶ G1 rewrites according to constraints Λ and determines fusion substitution π. Productions are synchronized via the inference rules in Table A.1. We call idle a prodution having an empty set of conditions and the identity function as fusion substitution.
Definition A.1 [Graph transitions] Let ⟨Γ0 ▶ G0, P⟩ be a graph rewriting system. The set of transitions T (P) is the smallest set that contains P, any idle production and that is closed under the inference rules in Table A.1.
A derivation is obtained by starting from the initial graph and by executing a sequence of transitions, each obtained by synchronizing productions. The synchronization of rewriting rules requires matching of the actions and uni- fication of the third components of the constraints Λ. After productions are applied, the unification function is used to obtain the final graph by merging the corresponding nodes.
In Table A.1 we use notation [v1 ,...,vn /u1,...,un ] (abbreviated as [v/u]) to de- note substitutions that are applied both to graphs and sets of constraints.



Table A.1
Inference rules for graph synchronization

If ρ = [v/u] is a substitution then ρG is the graph obtained by substi- tuting all free occurrences of ui with vi in G for each i = 1, ..., n, while ρΛ = {(x, a, ρy) : (x, a, y) ∈ Λ} where ρy is the sequence ρ(y1),... , ρ(yh) if y = y1,... , yh.
Finally, given a function f : A → B and y ∈ A, f−y : A \ y → B is defined as f−y (x)= f (x), for all x ∈ A \ y.
The most important rules in Table A.1 are (merge1) and (merge2). They regulate how nodes can be fused. Rule (merge1) fuses two nodes provided that no constraint is required on one of them, whereas rule (merge2) handles with nodes upon which complementary actions are required. Finally, rule (par) states how transitions on disjoint graphs can be combined together.
Rule (merge1) fuses nodes x and y provided that no constraint is imposed on y, i.e. Λ(y) ↑. Premise x π y ⇒ π(y) /= y imposes that, in case y is fused with a node x such that x π y (namely x and y are in the same equivalence class) then y must not be the representative element. However, if x / π y fusion [x/y] is possible; indeed, condition x π y ⇒ π(y) /= y trivially holds.


A transition from Γ,y ▶ G may be re-formulated to obtain the transition where y and x are coalesced, provided that fusion of their representative elements, ρ, is reflected on Λ, on π and on continuation Γ' ▶ G'. Indeed, if y is fused with x, also the other nodes equivalent to them are fused; the fusion substitution in the conclusion of (merge1) is π; ρ (restricted to Γ), all occurrences of π(y) are replaced with π(x) in n(Λ) and the final graph is ρG'. It is obtained by merging π(y) and π(x) in G'.
Rule (merge2) synchronizes complementary actions. The rule permits merging x and y in a transition if they offer complementary actions. As for (merge1), x cannot replace the representative element of its equivalence class. Most general unifier ρ takes into account possible equalities due to the transi- tive closure of substitutions [v/u] after [x/y] has been applied substitution. ρ fuses the corresponding nodes of the constraints and propagates previous fu- sions π. The resulting constraints ρΛ∪{(x, τ, ⟨⟩)} does not change constraints offered on nodes different from x and y (up to the necessary fusion ρ). Fusion substitution (π; ρ)−y acts on Γ by applying ρ. Finally, nodes U are those nodes that are neither in (π; ρ)−y (Γ) or generated by ρΛ are restricted in ρG'; this corresponds to the close rule of π-calculus.
Observation A.1 We remark that node x mentioned in rules (merge1) and (merge2) is a node in Γ appearing in the rules. This immediately follows for the condition x π y ⇒ y /= π(y).
Rule (par) simply combines together disjoint judgments. Condition (Γ1 ∪
Γ2) ∩ (Γ' ∪ Γ' ) = ∅; guarantees that π ∪ π' is well defined because it implies
1	2

Γ1 ∩ Γ'
= ∅, moreover such condition states that

graphs Γ1 ▶ G1 and Γ2 ▶ G2 are disjoint;
names generated by the transition of Γi ▶ Gi (for i ∈ {1, 2}) do not occur neither as names of the other graph nor as names generated by its transition.
Function π ∪ π' applied to a node x is π(x) or π'(x) depending on x ∈ Γ'. Note that π ∪ π' is well defined because Γ ∩ Γ' = ∅.
