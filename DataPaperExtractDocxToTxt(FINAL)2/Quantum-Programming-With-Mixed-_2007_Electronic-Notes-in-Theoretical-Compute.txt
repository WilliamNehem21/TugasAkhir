	Electronic Notes in Theoretical Computer Science 170 (2007) 185–199	
www.elsevier.com/locate/entcs

Quantum Programming With Mixed States

Paolo Zuliani1
Department of Computer Science Princeton University
Princeton, NJ 08544, USA

Abstract
In this paper we offer a programming approach to quantum computation using mixed states. Mixed- state quantum systems generalise standard (pure) quantum systems by allowing the state of the system to be a probabilistic distribution of pure states. We build on previous work by Aharonov et al. and generalise their results from quantum circuits to probabilistic (and quantum) programs.
Keywords: Quantum programming, mixed state, probabilistic computation, quantum circuit.


Introduction
Mixed-state systems are a generalisation of standard quantum systems for which the state is best described by a probability distribution over “pure” quantum states. Mixed state systems find application in the description of “real” quantum systems where, due to unavoidable causes (e.g. imperfections in our apparatuses or interactions with the environment), the exact state of the system cannot be specified. On the other hand, the standard model of quantum circuits assumes only pure states [6]. The difficulty in building a scalable quantum computer makes therefore even more important to have a model for quantum computation as close as possible to reality. A recent work by Aharonov et al. [1] extends the standard quantum circuit model by allowing mixed states.

1 Email: pzuliani@cs.princeton.edu




1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.017

The standard approach for dealing with mixed states is the so called dens- ity matrix formalism, and that has been used in Aharonov et al.’s work. In this paper we instead offer a programming approach based on qGCL, a pro- gramming language for quantum computation.

Quantum programming
We give here a short presentation of the features of qGCL (a full introduction can be found in [8]).
Quantum types
, 1}, which we will treat as booleans or bits, depend-
We define the type	=^ {0
ing on convenience. A classical register of size n: is a vector of n booleans.
The type of all registers of size n is then defined to be the set of boolean-valued functions on {0, 1,...,n − 1}:
n = {0, 1,...,n − 1} −→  .
The quantum analogue of n is the set of complex-valued functions on n
whose squared modulus sum to 1:
q(n) = χ:n		χ(x) 2 = 1 .
x:n

An element of q() is called a qubit and that of q(n)a qureg. Classical state is embedded in its quantum analogue by the Dirac delta function:
δ:n −→ q(n)
δx(y) = (y = x) .
The range of δ, {δx | x:n}, forms a basis for quantum states, that is:
χ:q(n)	χ =	χ(x)δx .
x:n

The Hilbert space n    (with the structure making it isomorphic to 2n ) is called the enveloping space of q(n). The usual scalar product becomes the application ⟨·, ·⟩:q(n) × q(n) →  defined by:


⟨ψ, φ⟩ =^
ψ(x)∗φ(x)
x:n



where ∗ denotes complex conjugation. The length of ψ is defined ψ 
Quantum language qGCL
1


ψ, ψ⟩ .

qGCL is an extension of pGCL [5], which in turn extends Dijkstra’s guarded- command language with a probabilistic choice constructor in order to address probabilism. A guarded-command language program is a sequence of assign- ments, skip and abort manipulated by the standard constructors of sequential composition, conditional selection, repetition and nondeterministic choice [3]. A quantum program is a pGCL program invoking quantum procedures and the resulting language is called qGCL. Quantum procedures can be of three different kinds: Initialisation (or state preparation) followed by Evolution and finally by Finalisation (or observation).
Initialisation is a procedure which simply assigns to its qureg state the uniform square-convex combination of all standard states
n	1	Σ
Quantum-mechanical systems evolve over time under the action of unitary transformations. Evolution thus consists of iteration of unitary transforma- tions on quantum state. In qGCL unitary evolution may be introduced in two forms: explicit (unitary) transformations on quantum state and procedures. In this paper we shall use only the former, so for simplicity we do not describe the latter. Evolution of qureg χ under unitary operator U is described via the following assignment:
χ := U (χ).
The no-cloning theorem [9] forbids any assignment χ := U (ψ) if (syntactically)
χ /= ψ.
The content of a qureg can be read (measured) through quantum procedure Finalisation and suitable observables. An observable is defined from a family of pairwise orthogonal subspaces which together span the enveloping space of the qureg being read. The axioms of quantum mechanics assert that the measurement “reduces” the qureg to lie in one of those subspaces with different probabilities. The result of the measurement is a number which uniquely identifies the “target” subspace.
Let  be an observable defined by the family of pairwise orthogonal sub- spaces Si 0 ≤ i < m . In our notation we write Fin( , i, χ) for the measurement of  on a quantum system described by state χ:q(n), where i stores the result determining the subspace to which state χ is reduced. Final- isation is entirely defined using the probabilistic combinator of pGCL (see [8]

for an unabridged treatment); in our notation we write:
Fin (0, i, χ) =^ ⊕   i, χ := j,  Pj (χ)   @ ⟨χ, P (χ)⟩ | 0 ≤ j < m 
j

where Pj is the projector onto subspace Sj.
In general, an observable is represented by a self-adjoint operator and the measurable values are exactly the eigenvalues of that operator. It is a generalisation, since by the well-known spectral theorem the eigenspaces of a self-adjoint operator are pairwise orthogonal and complete the enveloping space. That definition of Fin remains valid when an observable  is defined by a self-adjoint operator O.
The BNF syntax for qGCL is as follows:
⟨qprogram⟩::= ⟨qstatement⟩{ ; ⟨qstatement⟩}
⟨qstatement⟩ ::= χ := ⟨unitary op⟩(χ) |
Fin(⟨identif ier⟩, ⟨identif ier⟩, ⟨identif ier⟩) |
In(⟨identif ier⟩) |
skip | x := e | ⟨loop⟩ | ⟨conditional⟩| 
⟨nondeterministic choice⟩ | 
⟨probabilistic choice⟩ | ⟨local block⟩
⟨loop⟩::= while ⟨cond⟩ do ⟨qstatement⟩ od
⟨cond⟩ ::= ⟨boolean expression⟩
⟨conditional⟩ ::= ⟨qstatement⟩ ⟨cond⟩ D ⟨qstatement⟩
executes the LHS if predicate ⟨cond⟩ holds
⟨nondeterministic choice⟩ ::= ⟨qstatement⟩  ⟨qstatement⟩
⟨probabilistic choice⟩ ::= ⟨qstatement⟩ p⊕ ⟨qstatement⟩
executes (LHS,RHS) with probability (p, 1 − p)
⟨local block⟩::= var  • ⟨qstatement⟩ rav
where unitary op (χ) is just some mathematical expression involving qureg χ
- such expression should of course denote a unitary operator. qGCL supports procedures and specifications, which we omit here since we shall not use them.
prefix notation, in case the branches are more than two. Let [ (PjΣ, rj) | 0 ≤ Both probabilistic and nondeterministic choice may be written using a
then the probabilistic choice in which Pj is chosen with probability rj is written in prefix form: [ Pj @ rj 0 ≤ j < m ]. For nondeterministic choice the notation is similar.

Computing with mixed states
In this Section we compare and extend results of Aharonov et al. [1]. We begin by generalising their Theorem 1, which established that the quantum circuit model with mixed states is as efficient as the “standard” (i.e. unitary) quantum circuit model. We argue that such efficiency extends to any reversible and probabilistic program.
Equivalence of computing models
Aharonov et al. [1] proved that one could use quantum circuits with mixed states, paying only a polynomial slowdown. We generalise this result by means of the following theorem.
Theorem 3.1 Probabilistic (terminating) programs can be eﬃciently simu- lated by reversible probabilistic programs.
Proof It is well known that deterministic computations can be efficiently simulated by reversible machines [2]. In [10] we proved that any terminating probabilistic program can be replaced by an equivalent but reversible (prob- abilistic) program. In particular, one can reverse a binary probabilistic choice using a boolean and a conditional as a reverse statement, as shown in the following table:

where v:D for some data type D and b is a boolean variable.	 
To see that Theorem 3.1 generalises Aharonov et al.’s Theorem 1 we note that a quantum circuit with mixed states Q can be evidently implemented as a probabilistic program PQ. Next, by virtue of Theorem 3.1, PQ can be efficiently simulated by a reversible program, which could then be implemented as a unitary transformation. We also note that Aharonov et al.’s result is for quantum circuits only, while we instead take into account probabilistically terminating programs (i.e. possibly unbounded computations).
It is worth seeing how one could actually simulate a quantum program with mixed states using just unitary evolution. In this case the problem is of course how to simulate a measurement unitarily. The standard approach to the problem uses the “superoperator” approach to Quantum Mechanics, in which the state is no longer a complex vector but rather a particular kind of complex matrix, the so-called density matrix. Then, admissible operations on a quantum system (including measurements) are postulated to be a special

type of linear maps (also called superoperators) over matrices. In particular, any quantum operation is represented by some completely positive and trace- preserving superoperator. Finally, Stinespring-Kraus’ decomposition theorem
[4] establishes that any completely positive map is trace-preserving if and only if it is implemented by a unitary operator over a larger space. Such operator is called a dilation (or unitary embedding).
We now exemplify Stinespring-Kraus’ theorem in the special case of a quantum measurement operator. Consider the measurement 0 represented by the family of orthogonal finite Hilbert spaces {Hi | 0 ≤ i < m} decomposing

the Hilbert space H:

H	0≤ i<m H

where ⊕ here denotes direct sum of subspaces. Such measurement is then described by the following dilation:
D:H → H ⊗ HE
D(v) =  0≤i<m Pi(v) ⊗ δi
where Pi is the projector over  i and  E is a Hilbert space of dimension m. It can be shown that D is indeed unitary.
The Hilbert space E can be thought as the “environment” and in such case we have that any quantum system evolves unitarily together with its environment, leading eventually to a complicated entanglement. Therefore, we see that one of the main problems to the realisation of quantum computers,
i.e. decoherence, is mathematically equivalent to entanglement between the computer and its environment. In the case of quantum computation we also observe that the environment can be used as a “pointer” to the state of the computation, as E may describe the status of some macroscopic apparatus returning visible measurements.
We now give an alternative, programming-oriented approach for unitary finalisation. It cannot fully “simulate” finalisation, but it seems to be adequate for all practical purposes. Suppose measurement  is non-degenerate; we recall that Fin is the probabilistic choice:
Fin (0, r, χ) =^ ⊕  r, χ := j,  Pj (χ)   @ ⟨χ, P (χ)⟩ | 0 ≤ j < m 
j

where Pj is the projector onto subspace j. In Theorem 3.1 we saw how to reverse (binary) probabilistic choice: the multiple choice used by Finalisation can be clearly handled by nested binary choices. Reversibility of assignments

are addressed via stack operations: r is a standard variable and this does not pose any problem (the push operation can be implemented as a copy using the CNOT quantum transformation); χ is a qureg and the no-cloning theorem forbids copying of quregs. However, we show that Finalisation can be performed unitarily by using swap operations and an extra qureg. Without loss of generality we consider diagonal Finalisation, since basic results of linear algebra show that any observation can be unitarily reduced to a diagonal observation. It is possible to prove the following refinement:
Fin(Δ, r, χ)

⊕ [r := j @ |χ(j)|| 0 ≤ j < m ] ;  r = i → ψ, χ := δi,  χ(i) δi | 0 ≤ i < m 
where ψ:q(m). The probabilistic choice over r can be reversed as discussed, and the conditional does not evidently pose problems. For χ we note that

 χ(i)
|χ(i)|
is a complex number of modulus 1 (also known as the global phase) and

Quantum Mechanics’ axioms consider χ and ψ as physically equivalent states,
in the sense that no subsequent measurement is able to distinguish them. Therefore we can unitarily swap χ and ψ and let the computation going on over χ.
A similar argument cannot be applied in the case of degenerate observables.
Suppose 0 is degenerate, then it is easy to show that:
Fin(0, r, χ)
=
⊕ [r := j @ ⟨χ, Pj(χ)⟩ | 0 ≤ j < m ] ;  r = i → χ :=  Pj (χ)   | 0 ≤ i < m 
and since the Pj’s may project over l-dimensional subspaces (l > 1), we can- not substitute χ with a physically equivalent qureg. Also, a projector does not preserve traces, so Stinespring-Kraus’ theorem implies that we cannot unitarily implement each branch of the conditional.
We conclude by giving a unitary version of finalisation which uses the dilation technique. The unitary embedding D can be easily lifted to work with quregs - for simplicity we maintain the same notation. We note that D actually depends on the observable we want to mimic, since the dimen- sion of the enveloping space grows with the number of possible results of the measurements.
Lemma 3.2 Given observable 0 over q(n) and its associated spectral pro-

jectors {Pj | 0 ≤ j < m}, then:
6χ:q( ), j:{0,... ,m − 1}• ⟨Dχ, ( ⊗ Δj)Dχ⟩ = ⟨χ, Pjχ⟩
where Δj is the j-th diagonal projector of appropriate size and D is the unitary embedding.
Proof  We reason:
⟨Dχ, ( ⊗ Δj)Dχ⟩
=	definition of D
⟨	k Pkχ ⊗ δk, ( ⊗ Δj)	i Piχ ⊗ δi⟩
=	linearity of ⟨·, ·⟩
k,i⟨Pkχ ⊗ δk, Piχ ⊗ Δjδi⟩
=	scalar product of tensors
k,i⟨Pkχ, Piχ⟩· ⟨δk, Δjδi⟩
=	definition of Δj
k⟨Pkχ, Pjχ⟩· ⟨δk, δj⟩
=	linear algebra
⟨Pjχ, Pjχ⟩
=	Pj self-adjoint
⟨Pj χ, Pjχ⟩
=	linear algebra
⟨χ, Pjχ⟩


Lemma 3.3 For any observable 0 over q(n) and χ:q(n):
Fin(0, r, χ) ± (χ, ψ := Dχ ; Fin(Δ, r, ψ))
Proof  We reason:
Fin(0, r, χ)
±	definition of Fin and introduce ψ
 Pj (χ) 	≤
Pj (χ)
=	lemma 3.2

⊕	r, χ, ψ := j,  Pj (χ)  ⊗ δj	@ ⟨Dχ, ( ⊗ Δj)Dχ⟩ | 0 ≤ j < m
=	linear algebra
 ( ⊗Δj )Dχ 		≤
( ⊗Δj )Dχ
=	extract assignment Dχ
χ, ψ := Dχ;
⊕	r, χ, ψ := j,  ( ⊗Δj )χ⊗ψ 	@ ⟨χ ⊗ ψ, ( ⊗ Δj)χ ⊗ ψ⟩ | 0 ≤ j < m
=	linear algebra
χ, ψ := Dχ;
⊕	r, χ, ψ := j, χ ⊗  Δjψ 	@ ⟨ψ, Δjψ⟩ | 0 ≤ j < m
=	decompose assignment
χ, ψ := Dχ;
⊕	χ := χ ; r, ψ := j,  Δjψ 	@ ⟨ψ, Δjψ⟩ | 0 ≤ j < m
=	remove vacuous assignment and definition of Fin
χ, ψ := Dχ ; Fin(Δ, r, ψ)


Therefore for each measurement we have to have a “fresh” qureg (ψ), possibly via swapping with an array of quregs.
We conclude by observing that one can always bring finalisation at the end of a computation: this is the so called principle of deferred measurement [6]. In qGCL it translates as the following lemma.
Lemma 3.4 (Principle of deferred measurement) For χ:q(n), r:n, ob- servable 0, and unitary operator U over χ, it holds:
⎛⎝ Fin(0, r, χ); ⎞⎠ = ⎛⎝ χ := U (χ);  ⎞⎠
where 0' is the observable corresponding to the self-adjoint operator UOU −1
(O corresponding to 0).
Proof  Omitted.

Therefore one could in principle avoid irreversible computations until it is absolutely necessary, at the end of the computation (though it remains to be understood if this can be done also for iterating computations, i.e. programs using loops).

Probabilistic subroutines
In this Section we address Aharonov et al.’s [1] solution for the “subroutine problem” in quantum computation: in general, the function computed by a quantum circuit is a probabilistic one, therefore a problem arises when one wants to use such functions as subroutines in a bigger quantum circuit, since the standard theory of quantum circuits allows pure states only. Aharonov et al. first show how to formalise probabilistic function in the mixed-state model and then they show that such model is only polynomially faster than the standard quantum circuit model. In particular, their Theorem 2 establishes that any probabilistic function can be “simulated” by a standard quantum circuit using only a polynomially greater number of gates, with respect to the mixed-state quantum circuit implementation.  Theorem 2 states that F QP FQP = F QP , where F QP is the set of probabilistic functions efficiently computable by quantum circuits.
A probabilistic function is defined as a function which outputs a number with probability depending on the input. More formally:
f :m → [0, 1]p
f (i) = j	with probability pi,j ,	6i:dom(f ) •	j pi,j =1 .

It can be shown that any such function can be represented as a probabilistic choice over a number of deterministic functions:
f = ⊕ [ d @ wd | d:(m → p) ] 
where w  =  i pi,d(i) is of course the probability that (deterministic) function
d gets applied. Aharonov et al. use this decomposition to define a subroutine
gate that implements f as a mixed state in which the unitary version of all the deterministic functions d’s are applied to the initial state with the induced probability wd’s. Next, they show that the subroutine gate can be efficiently implemented unitarily (the result mainly stems from the previous Theorem 1, of course).
We now consider the same problem in qGCL. We argue that in qGCL there is no “subroutine problem”, i.e. probabilistic functions are naturally

manipulated by the language. Let s be a probabilistic subroutine computable by a quantum circuit (possibly using mixed states). Without loss of generality we suppose that s can be implemented by the following quantum program S:
S = (In(χ) ; χ := Uχ ; Fin(0, r, χ))
where of course χ is a qureg of appropriate size and U and 0 are respectively a suitable unitary operator and observable. By lemma 3.3 we can write:
S ± (In(χ) ; χ := Uχ ; χ, ψ := Dχ ; Fin(Δ, r, ψ)) = S'.
Therefore any call to S can be substituted by a call to S'. Any call to S' can be in turn implemented by replacing it with the code of S' into the calling program. Now, since the measurement of Δ affects ψ only, we can postpone it with respect to any other measurements, until the end of the program. Also, if S is efficiently implementable then so is S', since it performs a simpler observation and an initialisation on ψ.
We describe now an alternative approach.	The subroutine gate which implements function f = ⊕ [ fd @ wd | 0 ≤ d < t ] is defined as:
G = ⊕ [ χ := Ud(χ) @ wd | 0 ≤ d < t ]
where Ud is the unitary implementation of function fd. Given the mixed state ρ = (ψi, bi) 0 ≤ i < n it is easy to show that the evolution of ρ by G in qGCL is equivalent to that offered by the subroutine gate. In qGCL it can be proved that:
(⊕ [ χ := ψi @ bi | 0 ≤ i < n] ; G)= 
⊕ [ χ := Ud(ψi) @ biwd | 0 ≤ i < n, 0 ≤ d < t ]
which is exactly the action over ρ of the subroutine gate implementing f .
With respect to the unitary implementation of G we can show the following refinement:
G ± (⊕ [r := d @ wd | 0 ≤ d < t ] ;  [r = d → χ := Ud(χ) | 0 ≤ d < t])
which means that G can be implemented (as intuition suggests) via a classical probabilistic choice and then a conditional. The probabilistic choice can be of course realised as a quantum computation. Without loss of generality we may suppose that k 2k = t and therefore with a qureg of size k we can simulate the probabilistic choice above as the tossing of k biased coins. We can therefore assume that the weights wd’s can be indexed by numbers j’s in



k. We define pi
as the probability that the i-th bit of j is b:

pi =^ Prob(j(i)= b)=   Σ	ws
s: k | s(i)=b


which implies that:
wj =
0≤i<k


j(i).

We now prepare the i-th qubit in state (√pi δ0 + (1 − √pi )δ1), which can be
accomplished via the general Hadamard rotation Hθ defined as:
Hθ:q() → q()
Hθ(χ)(x) = (1 − x)(χ(0) cos θ − χ(1) sin θ)+ x(χ(0) sin θ + χ(1) cos θ).
Hθ can be applied in parallel to all the k qubits, since the coins are inde- pendent. The complexity of this method is parameterised by the number t of deterministic functions composing f .
Therefore an equivalent of Theorem 2 holds for qGCL. Actually, Theorem
allows us to state that:
Theorem 3.5 Probabilistic subroutines do not strengthen reversible compu- tation, since they can be eﬃciently simulated by reversible programs.

Error propagation
Finally, we set the background for studying error propagation in quantum programs with mixed states. Aharonov et al. [1] showed that in quantum circuit with mixed states, errors add linearly. Their Theorem 3 states that if a circuit using L gates, each with at most ϵ error, then the total error of the circuit is at most O(Lϵ). The result is proved within the superoperator approach, by defining an extension of the usual trace norm of operators.
A faulty gate F may be described in qGCL as:
F = (χ := U 'χ δ⊕ χ := Uχ)
where U ' is the unitary “error” operator, and δ is the probability that U ' is applied, instead of the correct operator U . This model might offer some more flexibility over the single-parameter model of Aharonov et al., since F can model the difference between the correct and the perturbed state, but also the probability of this happening. That might result useful when modelling real mixed-state systems: this is actually the model used in Section 11-6 of [7], in the study of the evolution of pure states into mixed states. The U ' being

unitary is an assumption which turns out to be handy in calculations, but we recall that by the Stinespring-Kraus’ theorem we can replace any quantum operation with a suitable unitary operator over a bigger space. This motivates the assumption of unitarity of U '.
An intuitive definition of error for the faulty gate F is the probability of going wrong times the maximum error achievable by the “wrong” operator U '. In our notation the total error for F would be δϵ, where ϵ = supχ  (U −U ')χ  .
calculate the expected value of such distribution. The expected value of gate
F is then:
E[F ]= δ · U 'χ + (1 − δ) · Uχ 
while the expected value of a simple unitary evolution χ := Uχ is:
E[U ]= Uχ .
Next, we define the error of gate F as the distance between the expected values of gates F and U respectively.
Definition 4.1 Let F be the faulty gate (χ := U 'χ δ	χ := Uχ), where U '
and U are unitary operator. The error of F is
e(F ) = sup E[F ] − E[U ]  .
^	χ
It is simple to show that e(F ) is δϵ:


e(F )= sup
χ
 δ · U 'χ + (1 − δ) · Uχ − Uχ  = sup

 δ(U ' − U )χ  = δϵ .

The definition can be of course extended to the sequential composition of faulty gates. Again, the error is the distance between the expectations of respectively the correct computation and the faulty computation.
Definition 4.2 Let Fi be the faulty gate (χ := U 'χ δ  χ := Uiχ), where
i = 1, 2 and U ', Ui are unitary. The error of F1 ; F2 is
e(F1 ; F2) = sup E[F1 ; F2] − E[U1 ; U2]  .
^	χ
We now proceed to the calculation of error for the sequential composition
of two faulty gates.
Proposition 4.3 Let F1 and F2 be two faulty gates. Then:
e(F1 ; F2) ≤ e(F1)+ e(F2)

Proof We suppose that ϵi = supχ  (Ui − U ')χ  for i = 1, 2. For later use we
i
note that:
U ' U ' − U2U1 = U ' (U ' − U1)+ (U ' − U2)U1 .	(1)

2  1
We reason:
e(F1 ; F2)
2	1	2

=	definition 4.2
sup  E[F1 ; F2] − E[U1 ; U2] 
=	sequential composition
sup (δ1δ2(U ' U ' − U2U1)+ δ2(1 − δ1)(U ' U1 − U2U1)+
(1 − δ1)δ2(U2U ' − U2U1))χ 
≤	triangular inequality and unitarity
sup (δ1δ2  (U ' U ' − U2U1)χ  + δ2(1 − δ1)  (U ' − U2)χ  +
(1 − δ1)δ2  (U ' − U1)χ  )
≤	(1), triangular inequality, and unitarity
sup (δ1δ2(  (U ' − U1)χ  + (U ' − U2)χ  )+ δ2(1 − δ1)  (U ' − U2)χ  +
1	2	2
(1 − δ1)δ2  (U ' − U1)χ  )
≤	definition of G1, G2
δ1ϵ1 + δ2ϵ2
=	definition 4.1
e(F1)+ e(F2)


Therefore, the error accumulated by the sequential composition of two faulty gates is at most the sum of the errors of the two single gates. It remains to be studied the effect of gate error on the distribution of outputs (i.e. those obtained by quantum measurements).

Conclusions
We offered a programming approach for a model of quantum computation based on mixed states, and in doing so we obtained some generalisations of previous work. As a future work we hope to use this formalisation to analyse

the propagation of errors in a quantum computation involving mixed states. We aim at proving bounds (and trade-offs, possibly) relating the probability of faulty behaviour and the discrepancy from expected behaviour.

Acknowledgement
This work has been supported by a Marie Curie Outgoing International Fel- lowship within the 6th Framework Programme of the European Commission.

References
D. Aharonov, A. Kitaev, and N. Nisan. Quantum circuits with mixed states. In STOC ’98: Proceedings of the thirtieth annual ACM symposium on Theory of computing, pages 20–30. ACM Press, 1998.
Charles H. Bennett. Logical reversibility of computation. IBM Journal of Research and Development, 17:525–532, 1973.
E. W. Dijkstra. Guarded commands, nondeterminacy and the formal derivation of programs.
CACM, 18:453–457, 1975.
Karl Kraus. State, Effects, and Operations, volume 190 of Lecture Notes in Physics. Springer- Verlag, 1983.
Carroll Morgan and Annabelle McIver. pGCL: formal reasoning for random algorithms. South African Computer Journal, 22:14–27, 1999.
Micheal A. Nielsen and Isaac L. Chuang. Quantum computation and quantum information. Cambridge University Press, 2000.
Asher Peres. Quantum Theory: Concepts and Methods. Kluwer Academic Publishers, 1998.
J. W. Sanders and P. Zuliani. Quantum programming. Mathematics of Program Construction, Springer-Verlag LNCS, 1837:80–99, 2000.
W. K. Wootters and W. H. Zurek. A single quantum cannot be cloned. Nature, 299(5886):802– 803, 1982.
Paolo Zuliani. Logical reversibility. IBM Journal of Research and Development, 45(6):807–818, 2001.
