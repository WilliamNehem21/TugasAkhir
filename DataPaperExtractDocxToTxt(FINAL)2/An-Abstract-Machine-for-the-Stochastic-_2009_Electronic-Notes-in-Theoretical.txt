

Electronic Notes in Theoretical Computer Science 227 (2009) 143–159
www.elsevier.com/locate/entcs

An Abstract Machine for the Stochastic Bioambient calculus
Andrew Phillips1
Microsoft Research 7 JJ Thomson Avenue
Cambridge, UK

Abstract
This paper presents an abstract machine for the stochastic bioambient calculus. The abstract machine is proved sound and complete with respect to a novel stochastic semantics, and is also shown to preserve the reduction probabilities of the calculus. The machine is implemented as an extension to an existing simulator for stochastic pi-calculus.
Keywords: abstract machine, stochastic, bioambient calculus, correctness, implementation.

Introduction
Since the Gillespie algorithm was first introduced in the 1970’s [5], a vast number of chemical and biological models have been simulated using this approach. Even today, many biological models are published as collections of chemical reactions, and the format is supported by modern modelling standards such as the Systems Biology Markup Language. Many published models consist of hundreds of reactions and, as our knowledge of biological systems continues to increase, models consisting of tens of thousands of reactions will soon be commonplace. Clearly, writing a model of this size as a list of reactions is not a scalable solution, for the same reasons that we would not write a large software program as a single list of thousands of instructions. Rather, we need a way of decomposing a large biological model into a collection of smaller modules, to facilitate model readability, maintenance and extension. A promising approach for achieving this decomposition is through the use of concurrent modelling languages. One such language is the stochastic pi-calculus [11], which allows a system of chemical reactions to be written as a collection of parallel processes that interact with each other by message passing.

1 Email: andrew.phillips@microsoft.com

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.109

In addition to enabling modular decomposition, the stochastic pi-calculus sup- ports parameterised processes that can be used to define generic building blocks such as gene gates, which can then be instantiated to build systems of arbitrary complexity [1]. Furthermore, the calculus allows complexes of arbitrary size to be formed by means of dynamically generated channels, where such complexation primitives have been shown to be more expressive than the language of chemical reactions [4]. While the stochastic pi-calculus affords improved modularity and ab- straction of biological models, it is equally important to ensure that these models are accurately simulated. To this end, previous work defined an abstract machine for the stochastic pi-calculus [9,10], which described how a process of the calculus can be exactly simulated in a way that remains faithful to the original Gillespie algorithm [5].
More recently, there has been substantial work on extending the stochastic pi- calculus with constructs that model the complex spatial hierarchy of a biological system. In particular, the bioambient calculus [12] was introduced to model the notion of mobile compartments, and the brane calculus [3] was introduced to model the notion of mobile membranes. As with the stochastic pi-calculus, in order for these abstractions to be useful in practice it is essential that the corresponding models are simulated exactly, in accordance with the principles of the Gillespie algorithm. A simulator of the bioambient calculus has already been developed [12], which continues to be a valuable tool for validating stochastic bioambient models. However, there is a significant gap between the definition of the calculus and the definition and implementation of the underlying simulation algorithm. One could argue that the accuracy of the simulation algorithm is just as important as the calculus itself, and should therefore be treated with the same rigour.
This paper presents an abstract machine for the stochastic bioambient calculus. First we present the stochastic calculus together with a simple example. We then present the bioambient machine, followed by an outline of a proof of correctness.

The Stochastic Bioambient Calculus
The bioambient calculus was presented in [12] as a means of modelling mobile compartments in biological processes. This section presents a compact syntax for the calculus, together with a novel stochastic semantics.

Syntax
The syntax of the stochastic bioambient calculus (SBA) used in this paper is pre- sented in Definition 2.1. A process P can be a choice of actions M , an instance X(n˜) of a definition X with parameters n˜, a parallel composition of processes P | Q, a 
process νx P with a private channel x, or an ambient	consisting of a process P
inside a compartment. A choice M consists of a competition between zero or more actions πi.P , where π is the action that can be performed, after which process P is executed, and i is an index used for identifying individual actions. An action π can





E ::=	∅	Empty
| E, X(m˜ )= P	Process
π ::=	τr	Delay
| γ!x(n˜)	Send
| γ?x(m˜ )	Receive




|
Ambient
|  c2p	Parent
|  p2c	Child

M, N ::=	0	Null
|  πi.P + M	Action
μ ::=	in	Enter
|  out	Leave
| merge	Merge

Definition 2.1 Syntax of SBA. A system E ▶ P consists of a constant environ- ment E of deﬁnitions, together with a process P.


(1)	τi.P + M	r,i	P
r	−→
(2)	!x(n˜)i.P + M | ?x(m˜ )j .P ' + M' ρ(x),(i,j) P | P'



(3)
−→
| Q' | c2p?x(m˜ )j .P ' + M' ρ(x),(i,j)
{n˜/m˜ }

'	'
{n˜/m˜ }



(4)
Q | p2c!x(n˜)i.P + M |
ρ(x),(i,j)
−→  Q | P |



(5)	|
ρ(x),(i,j)
−→	|



(6)
ρ(x),(i,j)
|	−→




(7)
ρ(x),(i,j)
−→	|



(8)
ρ(x),(i,j)
|	−→



(9)
(10)
r,w
P −→ P
r,w
P
⇒
r,w
−→
r,w	'

(11)
P r,w P'	⇒	P | Q	r,w
P' | Q

r,w	r,w
(12)	Q ≡ P	P' ≡ Q'	⇒	Q	Q'
Definition 2.2 Reduction rules of SBA, where a reaction identiﬁer w can be an index i or a pair of indices (i, j).


be a delay τr of rate r, a send γ!x(n˜) of values n˜ on channel x, or a receive γ?x(m˜ )
of values m˜ on channel x, where γ denotes the type of communication. This can be
inside the same ambient (local), from one sibling ambient to another (s2s), from a child ambient to its parent (c2p) or from a parent ambient to a child (p2c). In addition, an action π can be a move μ!x on channel x or an accept μ?x on channel x, where μ denotes the type of movement. This can be an ambient entering one of its siblings (in), a child ambient leaving its parent (out) or a merge of two sibling ambients (merge).
An environment E consists of a set of definitions X(m˜ ) = P , where X is the
name of the definition, m˜ are its parameters and P is the corresponding process.
It is assumed that fn(P ) ⊆ m˜ , where fn(P ) denotes the set of free names of P , given that νx P binds the name x in P and γ?x(m˜ ).P binds the set of names m˜ in P . It is also assumed that recursive definitions in the environment are guarded,
such that for a given definition X(m˜ ) = P , any recursive call to X inside P can only occur after an action π. We abbreviate local!x(n˜) to !x(n˜) and local?x(m˜ ) to ?x(m˜ ), and we also abbreviate πi to π in cases where the index i is unused. Stochastic behaviour is introduced into the calculus by associating each delay τr with a rate r and by associating each channel x with a corresponding rate given by ρ(x). Each rate characterises an exponential distribution, such that the probability of a reaction with rate r occurring within time t is given by F (t) = 1 − e−rt. The average duration of the reaction is given by the mean 1/r of this distribution.




Reduction

The reduction rules of the calculus are presented in Definition 2.2. The notation

r,w
P −→ P
states that the process P can reduce to P'
by performing a reaction w at

rate r. The reaction identifier w can be an index i denoting a particular delay τ i, or a pair of indices (i, j) denoting an interaction between two actions with indices i and j, respectively. A delay τr.P competing with alternative actions M can evolve to a process P at rate r (1). An output γ!x(n˜).P competing with alternative actions M can interact with a corresponding input γ?x(m˜ ).P competing with M', after which
processes P and P' are executed in parallel, where the parameters m˜ are replaced
with the values n˜ in process P , written P{n˜/m˜ }. The communication can be local (2), from a child to a parent (3) or from a parent to a child (4). Similarly, a move μ!x.P competing with alternative actions M can interact with a corresponding accept μ?x.P' competing with M', after which processes P and P' are executed in parallel. The move can be one sibling entering another (6), a child leaving its parent (7) or two siblings merging (8). In addition, all of these reductions can take place inside an ambient (9), inside a parallel composition (10), inside a restriction (11) and up to re-ordering of terms (12). This re-ordering is defined by structural congruence
rules in the standard way, as presented in Definition 2.3.





(13)
(14)
(15)
P | 0 ≡ P
P | Q ≡ Q | P
P | (Q | R) ≡ (P | Q) |R
(18)
(19)
(20)
νx 0 ≡ 0
νx νy P ≡ νy νx P
νx (P | Q) ≡ P |νx Q if x ∈/ fn(P )

(16)
X(n˜) ≡ P{n˜/m˜ } if X(m˜ )= P
(21)
νx	≡

(17)	≡ 0
Definition 2.3 Structural congruence axioms in SBA. Structural congruence is defined as the least congruence that satisfies these axioms. Processes in SBA are also equal up to renaming of bound names and reordering of terms in a choice.


(22)
νx1 ...νxK (M1 | ... | MJ |
| ... |	)

Definition 2.4 A process P is in standard form if it is in the form given by (22), where processes P1,... PN are also in standard form. A process P is in standard index form if it is in standard form and if each unguarded action πi is associated with a unique index i. We write P ∼= P' if the indices of P can be renamed such that P ≡ P'.


(23)


(24)
ρ(P )  X r
r,w
P −→

Pr(P r,w P')   r



(25)
ρ(P )
Pr(P −→ P')	X
r,w
P −→=P


r ρ(P )

Definition 2.5 Reaction Probabilities for a given process P in standard index form.
(23) deﬁnes the total rate ρ(P ) of P, where P  r,w  means that P can perform a

reaction w with rate r. (24) deﬁnes the probability Pr(P r,w
P') that the process

can perform a particular reaction w with rate r and evolve to P'. (25) deﬁnes the probability Pr(P −→ P') that a process P can reduce to P', up to renaming of indices.


Reaction Probability
In order to compute the probability of a given reaction, we need a way of identifying the individual reactions that a process can perform. We do this using a notion of standard index form, given by Definition 2.4.
Proposition 2.6 Every process P in SBA is structurally congruent to a process in standard form.

Proof. The proof is by straightforward application of structural congruence rules (16), (20) and (21).	 

A given process can be converted to standard index form by first converting it to standard form and then renaming the indices of the unguarded actions so they are distinct. Note that the sole purpose of the indices is to identify each individual reaction, and renaming these indices has no effect on the calculus semantics, apart from the structural congruence rule (16). Consider the following system:
{X(n˜)= π1.P1 + π2.P2 + π3.P3}▶ X(n˜) | X(n˜)
1	2	3
If we convert process X(n˜) | X(n˜) to standard form we obtain the following:
π1.P1 + π2.P2 + π3.P3 | π1.P1 + π2.P2 + π3.P3
1	2	3	1	2	3
If we then convert this to standard index form we obtain a process in which each action πi has a unique index i:
π1.P1 + π2.P2 + π3.P3 | π4.P1 + π5.P2 + π6.P3
1	2	3	1	2	3
Now, we can no longer apply rule (16) to contract this process to its original form X(n˜) | X(n˜), since the indices in the second process are no longer the same as the indices in the definition of X(n˜), and processes are not structurally congruent up to renaming of indices. This is important, since if we allowed the contraction we would loose the property that each action has a distinct index, and we would no longer be able to identify each individual reaction. Although we loose the ability to contract certain process definitions, this does not limit the set of reductions that the process P can perform. The result is similar to replacing rule (16) with the standard reduction rule X(n˜) −→ P{n˜/m˜ } where X(m˜ ) = P . Since processes are not structurally congruent up to renaming of indices, we define an additional
equivalence relation P ∼= P', which holds if the indices of P can be renamed such
that P ≡ P'.
We can use the standard index form of a process to compute the probability of individual reactions, as shown in Definition 2.5. Essentially, the probability of each reaction is proportional to its rate. For a given process P in standard index form, the total rate ρ(P ) of the process is defined as the sum of the rates r for each

reaction w of P (23). The probability Pr(P r,w
P') that the process can perform a

particular reaction w with rate r and evolve to P' is given by the rate of the reaction divided by the total rate of the process (24). Similarly, the probability Pr(P −→ P') that the process can reduce to P' is given by the sum of the probabilities of all the reactions w for which P can reduce to P', up to renaming of indices (25). We allow reduction up to renaming of indices in order to group together processes that would otherwise be structurally congruent if their corresponding indices were the same. We can use these definitions to derive a Continuous Time Markov Chain for process P in a straightforward manner, by placing the process in standard index form after each unfolding of the chain, and computing the rate of transitioning to subsequent processes, up to structural congruence. We omit the details here, but they are analogous to [6].

Example
The following example uses the stochastic bioambient calculus to model a reversible reaction between an enzyme and a substrate, assuming that the substrate and prod- uct can also degrade. The system consists of an enzyme, a substrate and a product. The definitions in the environment are given below, together with a possible evolu- tion of the system:


E =in?s1.ES + in?p2.ES ES =out?d3.E + out?k4.E S =in!s5.X + τ 6
X =out!d7.S + out!k8.P P =in!p9.X + τ 10




ρ(s),(5,1)
−→

ρ(k),(7,3)
−→
|	|


|


|	|


The Stochastic Bioambient Machine
A process of the bioambient calculus is simulated by encoding it to a corresponding term of the bioambient machine. The Gillespie algorithm is performed on a machine term by first choosing an ambient with probability proportional to the rate of the ambient, and then choosing a local reaction inside this ambient with probability proportional to the rate of the reaction.

Deﬁnition
A term A of the bioambient machine consists of a store S of reactions, a heap H of species and a tree T of ambients. The store S consists of a set of mappings from reactions θ to records Rθ, where each record contains information about the activity and rate of the reaction. The heap H consists of a set of mappings from species I to triples (i, U, C), where each triple contains information about the population and the behaviour of the species. The tree T consists of a list of child ambients, where each ambient contains a term, recursively. Thus, a term A is of the following form:

A ::= {θ '→ Rθ,...,θ '→ Rθ}, {I '→ (i, U, C),...,I '→ (i, U, C)},
:: ... ::
:: []

The full syntax of the bioambient machine is given in Definition 3.1. The store S records the rates of all the local reactions in the term. By definition, a local reaction corresponds to one of the rules (1)-(8) of the bioambient calculus. A reaction θ can be a delay (τ, r) of rate r or an interaction (ι, x) of type ι on channel x. The interaction type is needed to distinguish between different types of interactions on the same channel, such as in or out. A record Rθ contains the activity and apparent rate of the reaction θ. The activity of a delay of rate r is given by Totτr , which records the total number of local delays τr in the term. The apparent rate a(τ,r) of the delay is defined as r × Totτr . The activity of an interaction (ι, x) is given by the triple Totι?x, Totι!x, Mix(ι,x), which records the total number of local ι?x and ι!x actions in the term, together with the number of pairs of ι?x and ι!x actions



θ ::=	(τ, r)	Delay
|		(ι, x)	 Interaction R(ι,x) ::= Totι?x, Totι!x, Mix(ι,x), a(ι,x)	Activity R(τ,r) ::=	Totτr , ar	 Activity
K(ι,x) ::=	Totι?x, Totι!x	Totals
K(τ,r) ::=	Totτr	Totals

M ::=	0	Null
|  π.P + M	Action
C ::=	νn˜ M	Choice
E ::=	∅	Empty
| E, X(m˜ )= P	Process
| E, X(m˜ )= C	Choice

Definition 3.1 Bioambient Machine Syntax. An interaction type ι ::= γ | μ. The notation S(θ) returns the corresponding values associated with θ in S, as usual. By definition, a(ι,x) = ρ(x) × (Totι?x × Totι!x − Mix(ι,x)) and a(τ,r) = r × Totτr . Assume a global constant environment E, together with a global set of names Z.



that cannot interact, respectively. The apparent rate a(ι,x) of an interaction (ι, x) is defined as ρ(x)×(Totι?x×Totι!x−Mix(ι,x)). For example, Totin!x records the number of in!x actions inside a child ambient of the term, Totin?x records the number of in?x actions inside a child ambient of the term, and Mix(in,x) records the number of pairs of in!x and in?x actions inside the same child ambient, since an ambient cannot enter itself.
The heap H consists of a set of mappings from species I to triples (i, U, C). The counter i denotes the population of the species, the choice C records the set of actions that the species can perform, and the substore U counts the number of each type of action in the choice.
The tree T consists of a list of all the child ambients in the term. Each term is also associated with a global set of names Z and a global constant environment E, which contains a set of process definitions. The syntax of processes P is constrained so that each choice C is associated with a corresponding species definition in the environment. This is necessary in order to group populations of identical species.
Definition 3.2 creates a substore U from a choice C by counting the unguarded actions inside the choice. The definition relies on a matching relation π π', which checks whether an action π matches an action π'. Two actions match if they are equal (31), if they are both an input ι?x on the same channel x (32), or if they are both an output ι!x on the same channel x (33). The matching ignores any values that are sent or received over a channel.
Definition 3.3 creates substores to keep track of all the actions that can partici- pate in a local reaction inside a given ambient. Sub(U ) counts the relevant actions



Sub(C)  {(τ, x) '→ d	|	d = Totτx (C) ∧ d /= 0}
∪ {(ι, x) '→ (i, o)	|	i = Totι?x(C) ∧ o = Totι!x(C) ∧ (i, o) /= (0, 0)
Definition 3.2 Creating a substore from a choice C, where sn(π) denotes the set of channels in π that are used for input or output. The notation {x | Condition} denotes the set of all elements x that satisfy the given Condition, as usual.




Sub(∅)  ∅
(40)
∅⊕ U  U


Sub(I '→ (i, U, C),H)  SubH(U ) ⊕i Sub(H)
(41){U ',θ '→ Kθ}⊕ U  U' ⊕ U{θ '→ (Kθ ⊕ U (θ)}





Sub(
Sub([])  ∅
:: T )  Sub(T )
(42)
(43)
(i', o') ⊕ (i, o)  (i + i',o + o') d' ⊕ d  d + d'




(44)
Sub(
:: T )  SubT(U ) ⊕i Sub(
:: T )


Sub(U )  {(local, x) '→ (i, o) | i, o = U (local, x)}
∪ {(p2c, x) '→ (0, o) | i, o = U (p2c, x)}
∪ {(c2p, x) '→ (i, 0) | i, o = U (c2p, x)}
∪ {(τ, r) '→ (d) | d = U (τ, r)}
SubH(U )  {(ι, x) '→ (i, o) | i, o = U (ι, x) ∧ ι ∈ {in, merge, s2s}}
∪ {(c2p, x) '→ (0, o) | i, o = U (c2p, x)}
∪ {(ι, x) '→ (i, 0) | i, o = U (ι, x) ∧ ι ∈ {p2c, out}}
SubT(U )  {(out, x) '→ (0, o) | i, o = U (out, x)}
Definition 3.3 Creating a substore from a heap H and a tree T inside a child ambient. The function U ⊕i U' adds i copies of the substore U to U'.



inside the heap that are contained in a substore U . Sub(H) counts the relevant ac- tions inside the heap H of a child ambient, and Sub(T ) counts the relevant actions inside the tree T of a child ambient. The function U ⊕ U' adds the substores U and U' by adding the counters for the corresponding elements in both substores.
Definition 3.5 adds a species to a term. The function (I, C) ⊕ (S, H, T ) adds a species I with body C to a term (S, H, T ). If a binding (i, U, C) for I is already present in the heap then the population i of the species is incremented (53). Oth- erwise, a new binding (1, U,C) for I is created, where the substore U counts the



∅⊕ S  S
{U, θ '→ Kθ}⊕ S  U ⊕ S{θ '→ ((θ, Kθ) ⊕ S(θ)}
((ι, x), (i', o')) ⊕ (i, o, m, a)  (i + i',o + o',m + i' · o', ρ(x) · ((i + i') · (o + o') − (m + i' · o'))
((out, x), (i', o')) ⊕ (i, o, m, a)  (i + i',o + o',m + i · o' + i' · o, a + ρ(x) · i' · o')
((τ, r), d') ⊕ (d, a)  (d + d',r · (d + d'))
Definition 3.4 Adding a substore to a store. Note that out is treated as a special case for rule (61), since a child cannot leave a sibling of its parent.


(I, C) ⊕ (S, H, T )  (Sub(U ) ⊕ S),H{I '→ (i + 1, U,C)},T if H(I)= (i, U, C)
(I, C) ⊕ (S, H, T )   (Sub(U ) ⊕ S),H{I '→ (1, U,C)},T if H(I)= ∅,U =Sub(C)
Definition 3.5 Adding a species to a term


0 ⊕ A  A
X(n˜) ⊕ A  P{n˜/m˜ } ⊕ A if X(m˜ )= P
X(n˜) ⊕ A  (X(n˜), C{n˜/m˜ }) ⊕ A if X(m˜ )= C
(P | Q) ⊕ A  P ⊕ Q ⊕ A
(νx P ) ⊕ A  P{y/x} ⊕ A if y fresh and Z ← Z ∪ {y}

⊕ A	⊕ A



⊕ (S, H, T )  (Sub(H') ⊕ Sub(T ')) ⊕ S, H,
:: T

Definition 3.6 Adding a process and an ambient to a term. Assume a global con- stant environment E, and a global set of names Z that can be updated.


(S, H, T ) ⊕ (S',H',T ')  (S ⊕ S'), (H ⊕ H'), (T @T ')
Definition 3.7 Merging two terms. The function T @T' concatenates the lists T
and T ' in the standard manner. The definitions S ⊕ S' and H ⊕ H' are omitted.














ρ(
ρ(S)  X ai if ki, ai = S(θi)
i=1
ρ(S, H, T )  ρ(S)+ ρ(T )
ρ([])  0
:: T )  ρ(A)+ ρ(T )

Definition 3.8 Computing the rate of a term.


actions in the species, given by Sub(C), and the population of the species is set to 1
(54). Note that whenever a new species is added to a term, the local actions inside the substore U , given by Sub(U ), are added to the store S.
Definition 3.6 adds a process or an ambient to a machine term. The function
P ⊕ A adds process P to term A. The null process 0 is discarded (55). If a species

X(n˜) is defined as a process P then the process is added to the term, where the
parameters m˜ are instantiated with the values n˜ (56). If a species X(n˜) is defined
as a choice C then the species is added to the term, where the parameters m˜ are
instantiated with the values n˜ in the choice (57). A parallel composition P | Q
is split so that each process is added separately (58). A restriction νx P is added to a term by replacing x with a fresh channel y and adding this to the global
set of channels Z (59). An ambient	is added to a term by creating a new
machine ambient with an empty term, and adding the process P to this term. The

function
⊕A adds a machine ambient
to a term A. When a child ambient

is added to a term (S, H, T ), the function Sub(H') counts the actions
in the heap of the child ambient that can be involved in a local reaction, and the function Sub(T') counts the actions in the tree of the child ambient that can be involved in a local reaction. These actions are added to the store S (61). For improved efficiency, Sub(H) and Sub(T ) can be cached locally inside each ambient. Definition 3.4 add a substore to a store. The function U ⊕ S adds a substore
U to a store S by adding the corresponding totals for each reaction θ in U , and re-computing the apparent rate aθ accordingly. Note that the number of mixed reactions for a given reaction in the substore is computed by multiplying the number of inputs and outputs. Conversely, the function SgU subtracts the substore U from the store S by subtracting the corresponding totals for each reaction in U , and re- computing the apparent rate accordingly (definition not shown).
Definition 3.7 merges two terms. The function A ⊕ B merges terms A and B by merging their stores, concatenating their trees and merging their heaps. The function H ⊕ H' merges two heaps by taking the disjoint union of the heaps and summing the populations for entries I that occur in both heaps. The function S⊕S' merges two stores by adding the corresponding totals for each reaction θ in S and S' and re-computing the apparent rate aθ accordingly (definitions not shown).
Definition 3.8 computes the rate of a term A. The function ρ(A) computes the sum of the rates of all the reactions in term A. The function ρ(S) computes the sum of the rates of all the reactions in S. For a given term (S, H, T ) the function ρ(S) corresponds to the sum of the rates of all the local reactions in the term. This allows the reactions of a term to be divided up between the different ambients in a hierarchical fashion.
Definition 3.9 executes a single reaction in a given machine term. The relation
r,w
A

−→ A
executes a reaction inside A with rate r and identifier w according to the

Gillespie algorithm, producing a modified term A'. Rule (77) computes the total rate a0 of the term A and then chooses a reaction index a between 0 and a0 in
accordance with the Gillespie algorithm [5], where the function Rand(n) returns a number in the interval [0, n[ following a uniform probability distribution. The global time of the simulation is updated as a side effect in accordance with [5].
The relation A r,w,a A' executes the ath reaction inside A with rate r and iden- tifier w, producing a modified term A'.  Rule (76) uses the reaction index a to





(67)
(I, νz˜(τr .P + M )) ⊕ B
(τ,r)
−→ P ⊕ B



(68)
(I, νz˜(!x(n˜).P + M ))⊕
(I',νz˜' (?x(m˜ ).P ' + M')) ⊕ B
(local,x)
−→ P ⊕ P{n˜/m˜ } ⊕ B



(69)
(in,x)
−→	⊕ B
⊕ B




(70)
(out,x)
⊕ B  −→	⊕	⊕ B





(71)
(merge,x)
−→	⊕ B
⊕ B




(72)
(I',νz˜' (c2p?x(m).P' + M'))⊕

(c2p,x)
−→
⊕ B


'
{n˜/m˜ }




(73)



(74)
(I, νz˜(p2c!x(n).P + M ))⊕
⊕ B





⊕ B

(p2c,x)
−→  P ⊕	⊕ B



(s2s,x)
−→	⊕	⊕ B


θ
Choose(j, θ , (S, H, T ))	A'
μ	−→

j = [ a−a' ♩  a' < a ≤ Pμ  a	k ,a = S(θ ) a' = Pμ−1 a
r = ρ(θ )

(75)
r	i=1 i	i  i	i
i=1 i	μ

r,a' +j·r,a
S, H, T	−→	A'


(76)
S',H',T ' r,w,a '
a' = ρ(S)+ ρ(T )




(77)
r,w,a
A −→ A
a = Rand(a0)  t = (1/a0) · ln(   1	 )  a0 = ρ(A)
r,w
−→ A

time = time + t

Definition 3.9 Bioambient Machine Reduction. Assume a global constant environ- ment E, together with a global set of names Z, which contains all of the restricted names in the system. Also let ρ(τ, r) = r and ρ(ι, x) = ρ(x). For each rule it is assumed that (z˜ ∪ z˜') ∩ Z = ∅ on the left hand side, and Z ← Z ∪ (z˜ ∪ z˜') on the right hand side.


choose an appropriate ambient inside the term. Since each ambient in the term effectively owns a subset of the reactions, the choice of an ambient can be made by

subtracting the total rate of each ambient from the index a until the index is less than zero, at which point we know that the index denotes a reaction somewhere inside the current ambient. Rule (75) then uses the remaining index a to choose a reaction type inside the chosen term, by summing the rates of the reaction types until the index is exceeded. Once a reaction type θμ is chosen, we use the remaining index j to choose the jth reaction of that type, where the function Choose(j, θ, A) re-arranges the term A in order to choose the jth species or pair of species that can perform a reaction of type θ (definition not shown). We compute the index j so that it corresponds to an integer number of reactions of rate ρ(θμ). This allows us to assign a unique number to each individual reaction in the term, given by the sum of the rates of all the reactions that precede it.
Thus, a single index a chosen at the top level is used to chose an ambient, then a reaction type, then a specific reaction. The end result is that the probability of an individual reaction being chosen is proportional to the reaction rate, in accordance with the Gillespie algorithm.  Note that the initial index a is used to pinpoint a single reaction inside the term, while the number w corresponds to a unique reaction identifier, given by the sum of the rates of all the reactions that precede the chosen reaction. Once we have identified each individual reaction in this way using a suitable index w, we define the reaction rate and reaction probabilities as in Definition 2.5, without the need for a standard index form.

Example
The example from the Sec. 2 is encoded to the machine term in Fig. 1, assuming that the definitions in the environment remain unchanged. Each term keeps track of the activity and apparent rate of the local reactions that it can perform. Initially, the top-level term can perform an enter reaction on channel s, written (in, s). The activity of the reaction is stored as the tuple (1, 1, 0, ρ(s)), which records the number of accept actions in?s inside a child ambient, the number of enter actions in!s inside a child ambient, the number of pairs of enter and accept actions on s that occur inside the same child ambient, and the apparent rate of the reaction, respectively. The top-level term can also perform an enter reaction on p, written (in, p), whose activity is recorded in a similar way. In addition, the substrate ambient can perform a local delay reaction of rate r, written (τ, r). The activity of the reaction is stored as the tuple (1, r), which records the number of delay actions τr and the apparent rate of the reaction, respectively. The product ambient can also perform a local delay reaction, whose activity is recorded in a similar way, while the enzyme ambient cannot perform any local reactions. The machine picks one of the four terms in the system with probability proportional to the rate of the term, where the rate of a term is defined as the sum of the rates of all the local reactions in the term. Initially the enzyme term has a rate of 0, since it cannot perform any local reactions, while the top-level term has a rate of ρ(s) + ρ(p), and the substrate and product terms both have a rate of r. For the first reaction, the top-level term is chosen to execute the reaction (in, s). Subsequently, the top-level term is chosen to execute the reaction (out, k). This example was deliberately chosen for its simplicity, in


{(in, s) '→ (1, 1, 0, ρ(s)),  (in, p) '→ (1, 1, 0, ρ(p))} ,  ∅

,

::

::	:: []


ρ(s)
−→ {(out, d) '→ (1, 1, 0, ρ(d)),  (out, k) '→ (1, 1, 0, ρ(k)), (in, p) '→ (1, 1, 0, ρ(p))} ,  ∅


,



Fig. 1. Enzymatic Example in the Bioambient Machine

order to illustrate the primitives of the abstract machine. We are currently using the bioambient machine to simulate a more complex immune system pathway, in which immune cells move in and out of the thymus, where they interact with T-Cells to trigger an immune response.

Correctness
We briefly outline a proof of correctness for the stochastic bioambient machine (SBAM). The function (|E ▶ P|) encodes a system E ▶ P in SBA to a corre- sponding system in SBAM, as described in Definition 3.10. The encoding assumes that each choice of actions in the system E ▶ P is defined as a separate species, which is straightforward to enforce along the lines of [10]. A corresponding decoding from SBAM to SBA is described in Definition 3.11. Theorem 3.12 and Theorem
3.13 ensure that the bioambient calculus and the bioambient machine are reduction equivalent. In order to preserve the correspondence, we define a notion of struc- tural congruence for machine terms, where terms are structurally congruent up to re-ordering of ambients and actions.

Theorem 3.12 ∀E, A ∈ SBAM. E ▶ A r,w' E ▶ A' ⇒ [|E ▶ A|] r,w
[|E ▶ A'|]

Theorem 3.13 ∀E, P ∈ SBA. E ▶ P r,w
E ▶ P' ⇒ (|E ▶ P|) r,w'
(|E ▶ P'|)



(78) (|E ▶ P|)  P ⊕ (∅, ∅, [])
Definition 3.10 Encoding a system from SBA to SBAM.



(79)
(80)
(81)
(82)
[|E ▶ A|]  E ▶ [|A|] [|S, H, T |]  [|H|] | [|T |]
[|∅|]  0
[|H, X(n˜) '→ (i, U, C)|]  X(n˜) | ... | X(n˜) | [|H|]
|	{z	}



(83)	[|[]|]  0

(84)
[|
| T |] 
| [|T |]

Definition 3.11 Decoding a system from SBAM to SBA. The environment E is unchanged (79), and for each mapping X(n˜) '→ (i, U, C) in the heap, i copies of the instance are executed in parallel (82). A tree of ambients T is decoded by applying the decoding function to the terms inside the ambient, recursively (84).


Theorem 3.14 and Theorem 3.15 ensure that the reaction probabilities of the bioam- bient machine correspond to those of the bioambient calculus, and vice-versa. The proofs rely on the fact that each reaction in SBA corresponds to a single reaction in SBAM, and vice-versa.
Theorem 3.14 ∀P ∈ SBA.Pr(P −→ P') = Pr((|P|) −→≡ (|P '|))
Theorem 3.15 ∀A ∈ SBAM.Pr(A −→≡ A') = Pr([|A|] −→ [|A'|])

Discussion
The abstract machine is an extension of the abstract machine for the stochastic pi-calculus presented in [10], where species populations are grouped together for improved efficiency. The definition of the heap H and store S are similar, but the store is extended with many more interaction types, which represent the different interactions between compartments. In order to handle nested compartments, an additional tree T is also defined, where each node in the tree can be viewed as a sep- arate abstract machine. Additional functions are defined for counting the different interactions between compartments in the tree. There are also significantly more reduction rules to implement, which require functions for removing and updating compartments, and for choosing a compartment with the correct probability. When an ambient moves, the reactions of its parent and grandparent ambients need to be updated accordingly, requiring careful tracking of the various dependencies between ambients. The resulting implementation will be made available at [8] as a public resource, and a prototype stochastic simulator has already been released 2 based

2 http://aesop.doc.ic.ac.uk/tools/bam

on the abstract machine presented in this paper. A description of the prototype is presented in [7] together with a biological example, but the definition of the abstract machine has not previously been published.
Section 2 presents a concise syntax and reduction semantics for the stochastic bioambient calculus, in which a unique index is associated with each action in order to identify and count the individual reactions of a process. In [14] a stochastic semantics for the ambient calculus is defined using a labelled transition system, while in [2] a stochastic semantics for the bioambient calculus is defined in terms of a reduction relation, in which the identification of a reaction is determined by placing a number of constraints on the syntax of the choice operator and by keeping track of the total counts of each type of reaction, along the lines of [10].
To the best of our knowledge, this paper presents the first formally defined abstract machine for the stochastic bioambient calculus. In [13], a variant of the stochastic pi-calculus with polyadic synchronisation is used as a basis for encoding this calculus. The encoding requires a number of locks and broadcast mechanisms in order to propagate changes in the topology of the system, which leads to a signif- icant computational overhead. In contrast, this paper presents an abstract machine for the direct implementation of the bioambient calculus, based on principles of efficient simulation previously defined in [10]. The abstract machine has also been adapted for implementing the stochastic brane calculus 3 and the resulting platform provides a flexible means of experimenting with different synchronisation primitives for calculi with mobile compartments.

References
Ralf Blossey, Luca Cardelli, and Andrew Phillips. A compositional approach to the stochastic dynamics of gene networks. Transactions in Computational Systems Biology, 3939:99–122, January 2006.
Linda Brodo, Pierpaolo Degano, and Corrado Priami. A stochastic semantics for bioambients. In
PaCT, pages 22–34, 2007.
Luca Cardelli. Brane calculi. In CMSB’04, pages 257–278, 2004.
Luca Cardelli and Gianluigi Zavattaro. On the computational power of biochemistry. In Algebraic Biology, 2008. To Appear.
Daniel T. Gillespie. Exact stochastic simulation of coupled chemical reactions. J. Phys. Chem., 81(25):2340–2361, 1977.
C´eline Kuttler, C´edric Lhoussaine, and Joachim Niehren. A stochastic pi calculus for concurrent objects. In AB, pages 232–246, 2007.
Vinod Mugathan, Andrew Phillips, and Maria Vigliotti. Bam: Bioambient machine. In ACSD’08, 2008. To Appear.
Andrew Phillips. The Stochastic Pi-Machine, 2007. Available from http://research.microsoft.com/
~{}aphillip/spim/.
Andrew Phillips and Luca Cardelli. A correct abstract machine for the stochastic pi-calculus. In
Concurrent Models in Molecular Biology, August 2004.
Andrew Phillips and Luca Cardelli. Efficient, correct simulation of biological processes in the stochastic pi-calculus. In Computational Methods in Systems Biology, volume 4695 of LNCS, pages 184–199. Springer, September 2007.

3 Extended version available at http://research.microsoft.com/~aphillip


Corrado Priami. Stochastic π-calculus. The Computer Journal, 38(6):578–589, 1995.
Aviv Regev, Ekaterina M. Panina, William Silverman, Luca Cardelli, and Ehud Y. Shapiro. Bioambients: an abstraction for biological compartments. Theor. Comput. Sci., 325(1):141–167, 2004.
Cristian Versari. A core calculus for a comparative analysis of bio-inspired calculi. In ESOP, pages 411–425, 2007.
Maria Grazia Vigliotti and Peter G. Harrison. Stochastic ambient calculus. Electr. Notes Theor. Comput. Sci., 164(3):169–186, 2006.
