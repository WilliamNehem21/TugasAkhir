

Electronic Notes in Theoretical Computer Science 253 (2009) 21–36
www.elsevier.com/locate/entcs

Model-based Kernel Testing for Concurrency Bugs through Counter Example Replay
Moonzoo Kim, Shin Hong, Changki Hong1 ,2
CS Department KAIST Daejeon, South Korea
Taeho Kim3
ETRI
Daejeon, South Korea

Abstract
Despite the growing need for customized operating system kernels for embedded devices, kernel development continues to suffer from high development and testing costs for several reasons, including the high complexity of the kernel code, the infeasibility of unit testing, exponential numbers of concurrent behaviors, and a lack of proper tool support. To alleviate these difficulties, this study proposes the MOdel-based KERnel Testing (MOKERT) framework, which supports detection of concurrency bugs in the kernel by combining both model checking techniques and testing methods. The MOKERT framework was applied to the file systems of the Linux 2.6 kernel and found a data race bug in the proc file system.
Keywords: Model checking, testing, counter example analysis, and model extraction


Introduction
Software testing often requires more than 50% of the total development time and available resources. Among the many different software products, the operating system kernel (henceforth, simply termed the kernel) is one of the most difficult software to develop and analyze. Reasons for this include the following:
Complexity of code
In order to manage various HW and SW components, the kernel contains a large

1 This work was supported by the IT R&D program of MKE/IITA (2006-S-038-01, Development of Device- Adaptive Embedded Operating System for Mobile Convergence Computing), and Engineering Research Center of Excellence Program of Korea Ministry of Education, Science and Technology(MEST)/Korea Science and Engineering Foundation(KOSEF), grant number R11-2008-007-03002-0.
2 Email: moonzoo@cs.kaist.ac.kr, {hongshin,kornin83}@kaist.ac.kr
3 Email: taehokim@etri.re.kr

1571-0661 © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.09.049

number of service routines. In addition, in order to maximize performance, it often uses optimized but complex algorithms.
An exponential number of concurrent behaviors
The kernel is a multi-threaded program in which it is very difficult to detect concurrency bugs, as they occur only when specific scheduling sequences are en- forced. However, there exist exponentially many scheduling scenarios in terms of the number of concurrent threads. Furthermore, for most kernels, a user does not have a fine-grain control over the scheduler, which increases the difficulty involved with analyzing the concurrent behaviors of a kernel.
Difficulty of unit testing
Most kernels utilize a monolithic architecture for the sake of performance. Thus, it is challenging to decompose a kernel into components or units in order to test each independently. For example, to test the proc file system, an environment that contains a virtual file system layer, memory management, and a scheduler is required, as these components are closely involved in the operation of the proc file system. In such a situation, huge effort is inevitable for unit testing, as it is necessary to configure the environment in detail; this environment setup causes more overhead than that involved in the unit testing itself.
Lack of proper tool support
There are few tools that can support kernel testing, as the side effects caused by the testing tool/environment at the kernel space can halt the kernel or cause unexpected behaviors. In addition, testing tools often depend on libraries that cannot be used in the kernel environment. For these reasons, kernel developers continue to use printk() or a kernel log as a main debugging aid.
Considering the high complexity of the kernel, it is essential to analyze the kernel components one-by-one. This, however, is hard to achieve in practice due to the above reasons. Consequently, traditional testing methods do not support kernel development satisfactorily, and the kernel remains an area suitable for only gifted guru developers. However, as embedded systems become more prevalent, the need to create/customize special-purpose operating systems (e.g., operating systems for mobile phones or sensor networks) continues to grow. Therefore, it is important to have a framework that can analyze the kernel unit by unit.
This study proposes a model-based testing framework for concurrency bugs in the kernel by using model extraction [3] and model checking techniques [4]. Con- sidering the difficulties of testing the kernel as mentioned earlier, model checking presents a viable alternative approach for analyzing kernels, since this technique can analyze each component of the complex kernel independently by modeling the component and the related portion of the environment in an abstract manner. In addition, model checking can explore numerous scenarios exhaustively, and gener- ate concrete counter examples, which can be a useful aid to debugging. However, a pure model checking approach alone is problematic in that a developer cannot know whether a counter example detected through model checking is an actual bug or a false alarm due to the gap between the abstract model and target code.

A salient advantage of the MOdel-based KERnel Testing (MOKERT) framework proposed in this paper is the capability of replaying a counter example on the actual kernel code. Through this capability, MOKERT provides benefits of both model checking and testing to kernel developers. This feature can assist kernel developers with bug identification, model refinement, and validation of a bug patch (see Section 3 for more details). Therefore, the MOKERT framework can alleviate the difficulty of analyzing the kernel through pure testing, although it requires human effort to create an abstract model and its environment. The effectiveness of the MOKERT framework was demonstrated by applying it to the file systems of the Linux 2.6 kernel and a hidden data race bug in the proc file system was detected .

The Spin Model Checker and Modex
This section provides an overview of the Spin model checker [4] and Modex [3], which are utilized as the underlying components in the MOKERT framework.

The Spin Model Checker
Promela (a modeling language of the Spin model checker) is similar to the C pro- gramming language in several aspects. First, Promela provides control statements such as if, goto, and do. In addition, Promela models complex data structures using typedef and arrays, although pointer variables are not directly supported. Also, Promela supports inline functions which can simulate C functions.
The Spin model checeker exhaustively explore the state space explicitly gen- erated from a given Promela model and generates a counter example if it finds a violation of a requirement property. A counter example contains the following information:
Step number n
Process ID of the current process
proctype name of the current process
Line number l of the Promela model being executed
Statement of the Promela model at line l
For example, the 45th step of the counter example in Figure 1 indicates that process 1 executes the statement at line 125 of the proc readdir(), which tests whether proc subdir lock==1 or not. Then, process 1 is preempted and process 2 executes the statement at line 156 of remove proc entry(), and so on.
45: proc 1 (proc_readdir)	line 125 [((proc_subdir_lock==1))]
46: proc 2 (remove_proc_entry) line 156 [((proc_subdir_lock==0))]
Fig. 1. Counter example generated from Spin

Modex
Modex automatically translates a C program into a corresponding Promela model. Modex translates the control structure of a target C function, such as if and while, into the corresponding Promela control structure. As a result, the Promela model generated by Modex has the same control structure as the target C program. Other C statements are inserted as embedded C code into the Promela model starting with a keyword c expr{...} for Boolean expressions and c code{...} for assignments and function calls [3]. These embedded C codes are blindly copied from the text of the Promela model into the code of the verifier that Spin generates.
In addition, a user can control the translation by specifying a translation script. A translation script for Modex contains a set of translation tables, each of which specifies translation rules for a function in the target C program. A translation rule specifies that the lines of the target C code starting with a given textual pattern should be replaced by the given Promela statements (see Figure 2(b)). In addition, the translation script contains a user-specified environment of a target model and the requirement properties to verify. Figure 2(a) shows an excerpt of proc readdir() in the proc file system of the Linux 2.6.21 and the Promela code generated by Modex using the translation table of Figure 2(b). Note that Modex indicates which Promela statements are translated from which C statements through comments (i.e.,
/* line  l */) showing the corresponding line numbers of the original C program.



68: do {
C code


123: do
Promela code

69:	spin_unlock(&proc_subdir_lock);
70:	if (filldir(dirent, de->name, de->namelen,
71:	filp->f_pos, de->low_ino, de->mode >> 12) < 0 )
72:	goto out;
73:	spin_lock(&proc_subdir_lock);
74:	 filp->f_pos++; 75:	next = de->next; 76:	de=next;
77: } while (de);
124: ::
125: inlined_spin_unlock(proc_subdir_lock);/* line 69 */
126: if
127: :: false; /* line 70 */ 128: goto out;
129: :: else; /* line 72 */ 130: fi;
131: inlined_spin_lock(proc_subdir_lock); /* line 73 */ 132: i = proc_subdir[i].next; /* line 75 */
133: if
134: :: i != NULL; /* line 77 */ 135: :: else; break; /* line 77 */ 136: fi;
137: od;

proc_readdir() and the corresponding Promela model

A translation table for Modex
Fig. 2. Excerpt of proc readdir()and the corresponding Promela model created by Modex

The Model-based Kernel Testing Framework
This section describes the MOKERT framework, particularly its architecture and instrumentation scheme to replay a counter example.

Overview
The MOdel-based KERnel Testing (MOKERT) framework applies the analysis re- sult (i.e., a counter example) from model checking to the original target program so as to alleviate the difficulties of debugging concurrency bugs in the kernel code. Most model checking frameworks do not suitably consider this issue, although it is crucial for the success of model checking techniques in the software industry.
A traditional model-based testing approach is illustrated in Figure 3(a), in which a formal model is written manually and a counter example obtained from model checking is checked with regard to the target program by a human user. This process requires significant manual effort. The MOKERT framework, as illustrated in Fig- ure 3(b), uses Modex to extract a formal model from a target C program in a (semi) automatic manner with a translation script T ; T maps the statements/lines of the target C program to the statements/lines of the corresponding Promela model. 4 Following this, T is used in a reverse manner (T −1) to map the lines of the Promela model specified in a counter example to the corresponding lines of the original C target program. Therefore, it is possible to understand which sequences of lines of the target program should be executed according to the counter example and instrument the target program to follow the counter example.

Fig. 3. Two different model-based testing approaches
The MOKERT framework has the following advantages:

4 We can consider a translation script T contains a line number mapping from the original C code C to the Promela model P translated from C, since Modex generates this line number mapping information when it generates P from C based on T .

Identiﬁcation of a cause of a bug
MOKERT allows a user to replay one counter example repeatedly. Thus, a user can conveniently identify the genuine cause of the counter example in the kernel code, not merely in the corresponding abstract formal model. This can be a very useful aid for detecting concurrency bugs, as thread scheduling should be controlled manually otherwise.
Model reﬁnement
An initial formal model is highly abstract and the model is refined iteratively by adding more details. When a counter example is generated from model checking, it is possible to check whether the counter example is real or a false alarm at- tributable to abstraction by running the counter example on the actual code (see Section 3.4). If the counter example is a false alarm, it is necessary to refine/fix the formal model.
Validation of a bug patch
Kernel bugs are often reported through manual code inspections, discussions, or artificial scenarios without actual testing, due to the difficulties involved with kernel testing (see Section 1). Thus, for example, the Linux Changelog contains dozens of bug patches that are not necessary or that do not fix a bug correctly. MOKERT can help users validate a bug patch by modifying the model according to the bug patch and model checking it to check whether the bug patch actually removes the bug. If the model checker generates a counter example, MOKERT can replay the counter example to check whether it is due to the incorrect bug patch or a false alarm.
Architecture of the MOKERT Framework
The overall architecture of the MOKERT framework is illustrated in Figure 4. The static phase of the MOKERT framework consists of the following tasks:
Given a target C program and a translation script, Modex translates the tar- get program into a Promela model that contains the target processes, an en- vironment model, and requirement properties. At the same time, the mapping information from the line numbers of the Promela model to the line numbers of the target program is obtained from the intermediate results that Modex generates.
Spin verifies whether the generated Promela model satisfies the requirement properties with the environment or not. 5 If yes, Spin delivers a verification result to a user. Otherwise, Spin generates a counter example.
The portion of the target C code to analyze is automatically instrumented based on the mapping information and the counter example. The instrumented target code contains probes at lines corresponding to the context switch points in the counter example, a controller thread, and a monitor thread. In addition,

5 Requirement properties are given as linear temporal logic formulae or assert statements. Currently, however, MOKERT does not check whether a target program correctly replays a lasso-shaped counter example of a liveness property or not.

a test driver for the target program should be given by a user. The driver contains a testing environment that is equivalent to the environment model used in model checking. This instrumented portion of the target code and the test driver are compiled with the remaining target code to build the executable program.
Inputs	The MOKERT framework	Outputs
























Fig. 4. Architecture of the MOKERT framework
At the run-time phase, the target threads execute with a controller thread and a monitor thread. The controller thread controls scheduling of the target threads via the inserted probes. The monitor thread monitors the target threads and the controller thread, and checks whether the counter example is replayed correctly or not.
Note that if a counter example is generated, MOKERT requires a user to build a test driver. This task is, however, simpler than the task of building a test driver for general test cases, for the following reasons. First, an abstract environment model used for model checking can help a user set up the testbed [7]. Furthermore, a test driver required by MOKERT covers only a specific scenario represented by the single counter example. This reduces a significant amount of effort required to build a general testbed and to run numerous test cases.
Instrumentation of the Target Programs
In order to enforce the target program to follow the scheduling sequence of the counter example, MOKERT inserts probes at the locations corresponding to the context switch points of the counter example based on the mapping information. For example, Figure 1 shows one context switch point occurring immediately after the execution of line 125 of the Promela model. Line 125 of the Promela model corresponds to line 69 of the target C code as indicated in Figure 2(a). Consequently,

a probe is inserted immediately after line 69 of proc readdir().
As a counter example represents concurrent execution in an interleaved manner, the probes inserted in the target program enforce the target threads to execute in a serialized way (i.e., one target thread at a time), strictly following the global schedule table generated from the counter example. Figure 5 describes the basic structure of a probe. To minimize unnecessary side effects, a probe is activated only when the test start flag is set as true by the test driver (see line 1). Since one function can be invoked by multiple threads, a probe should know which thread is executing the probe and perform a context switch accordingly (see line 4 to line 20).
A probe inserted at the statement located at CUR LINE (e.g., line 69 of proc readdir() in Figure 2(a)) of the target program checks whether a context switch should occur now or not (line 5 to line 19), since CUR LINE may be exe- cuted multiple times through a loop but a context switch should occur at n1th, n2th,... and nkth executions only (see line 6 to line 9). For example, line 69 of proc readdir() may be executed 7 times in the scenario of the counter example. However, a context switch may occur at the 3rd (n1) and 5th (n2) executions only. If a context switch should occur, the probe sets its runnable[m pid] as false (line 11), notifies the controller thread (line 12), yields current execution (line 14), and waits until the controller thread allows the thread to run by setting runnable[m pid] as true (line 13). Note that the controller thread keeps only one runnable[i] as true at any given instant.

Run-time Phase
At run-time, the monitor thread observes the target threads and the controller thread, and checks whether the counter example is being replayed correctly or not. When the execution of the target program reaches the last step of the counter example, the monitor thread notifies a user that the counter example is completely replayed. At the same time, as a test result, the test driver shows if the requirement property is violated or not. There are three possible results from replaying a counter example.
The last step of the counter example is reached and the requirement property is violated.
The last step is reached but the requirement property is not violated.
The last step is never reached.
The first case is what we expect from replaying the counter example. The second and the third cases indicate that replaying the counter example fails. If the last step of the counter example is not reached within a given amount of time, the monitor notifies a user of the replay failure with log information such as the status of each target thread and the function call stack. Replay failures can occur for the following reasons:
Imprecise modeling
A model of the target threads is not refined enough and, as a result, the ac-

01:if (test_start == true) {
02:	m_pid = get_model_pid(current_pid) 03:	switch(m_pid) {
04:	case m_pid1 :
05:	switch(executed[m_pid][CUR_LINE]) {
06:	case N_1:	/* Constant N_1, N_2,..., N_k are calculated from 07:			the counter example at the static phase */
08:	...
09:	case N_k:	/* if the statement at CUR_LINE is executed 10:			by the process m_pid1 N_k th time */
11:	runnable[m_pid] = false;
12:	notify_controller();
13:	while (runnable[m_pid]==false) { 14:		sys_sched_yield()
15:	}
16:	default:
17:	executed[m_pid][CUR_LINE]++;
18:	break;
19:	}
20:	break;
21:	case m_pid2 :
22:	...
Fig. 5. Structure of a probe inserted at CUR LINE

tual target threads cannot progress following the counter example. The global configuration of the kernel might unexpectedly change according to numerous causes, which might not be included in the model due to abstraction. For example, the model may assume that the interrupt function is disabled, but the actual kernel execution might enable the interrupt function unexpectedly, which might block the interleaving sequence enforced by the controller thread.
Incorrect test driver
A test driver may be built incorrectly and as a result the test driver does not fully reflect the verification environment used in model checking.
For example, Section 5 describes a case study where the counter example could not be replayed due to imprecise modeling. If a replay failure is detected, the user should refine the abstract model and/or fix the test driver.

Case Study 1: Data Race between proc readdir()and remove proc entry()in Proc File System
Bug Description
The proc file system is a virtual file system in UNIX-like operating systems. This file system allows a user to access process information and communicate with the

kernel modules through the file interface. Linux Changelog 2.6.22 reported that proc readdir() and remove proc entry() had a data race bug in the Linux 2.6.21. This data race scenario is depicted in Figure 6. Before remove proc entry() re- moves de (a directory entry representing a file in proc file system) at line 24b, it checks the read count of de at line 23b to guarantee that no one is using the de now. However, proc readdir() does not increase the read count of de at line 68a before reading de. Thus, remove proc entry() removes de without knowing that proc readdir() is trying to read de. Consequently, proc readdir() tries to read de at line 70a, which was removed by remove proc entry() at line 24b. This may cause a segmentation fault due to an invalid memory access.

Fig. 6. Data race scenario between proc readdir() and remove proc entry()



Replaying the Bug
Through the MOKERT framework, proc readdir() (67 lines long), remove proc entry() (35 lines long), and related sub-functions such as lock- ing functions were modeled in Promela through Modex. Corresponding Promela processes for proc readdir() and remove proc entry() were 68 lines and 36 lines long, respectively. In addition, a verification environment (76 lines long) having four proc directory entries, namely “Jan”, “Feb”, “Mar”, and “Apr”, as depicted in Figure 7, was modeled in the translation script (128 lines long). The environment created two processes for proc readdir() and remove proc entry(), and made remove proc entry() remove the “Feb” directory entry while proc readdir() tried to read the same directory entry.
The requirement property asserted that the directory entry being read at line 70a of proc readdir() must be available (i.e., not removed previously). To check this property, an auxiliary flag removed was added to each directory entry, which was set as true when the directory entry was removed. Note that it took two days for two graduate students to understand the bug description and corresponding portion of the proc file system C code, one day for specifying a translation script, and another day for building the test driver and replaying the counter example.

Spin generated a counter example (59 steps long) in our model, as expected. When the counter example was replayed, the removed de was displayed as if it had not been removed and the directory entries linked from de were not displayed. (note that directory entries form a single linked list in the proc file system). In other words, proc readdir() displayed “Jan” and ”Feb” only, not “Mar” nor “Apr” when remove proc entry() removed “Feb” in the data race scenario in Figure 6. This data race did not cause a segmentation fault, since free proc entry(de)(line 24b) did not fill the memory area occupied by de with null values, but kept the old values of the memory area. 6 This data race bug was fixed in Linux 2.6.22 by adding atomic inc(&de->count) at line 68a of proc readdir(). The Promela model for proc readdir() was modified according to the bug patch and ceased to violate the property.
Removed




Fig. 7. Example of the directory entry structure


Case Study 2:  Model Refinement of ext2 readdir()
and ext2 rmdir() in the Ext2 File System
Bug Description
During the modeling and analysis of the ext2 file system in Linux 2.6.25, a data race between ext2 readdir()(78 lines long) and ext2 rmdir()(15 lines long) was detected through Spin. This data race scenario is depicted in Figure 8. Since de is not protected by any lock at line 67a of ext2 readdir(), ext2 rmdir() can remove de at line 98b. Then, ext2 readdir() tries to read de at line 75a, which was already removed by ext2 rmdir(), thus possibly causing a null pointer dereference.

Replaying the Bug
The corresponding Promela model had two processes for ext2 readdir() and ext2 rmdir(). The processes were 65 lines long and 15 lines long, respectively. The environment (241 lines long) contained two directories, namely, “parent” and “child”; the “parent” directory had the “child” as its sub-directory and “child” di- rectory was empty. The environment made a scenario that ext2 rmdir() removed “child” while ext2 readdir() read “parent”. Each directory entry had an auxil- iary flag removed, which was set as true when the directory entry was removed. The requirement property, similar to that of Section 4, asserted that the flag of the directory entry being read at line 75a of ext2 readdir() should be false.

6 free proc entry(de) only removed the outgoing link of de and updated the incoming link to de correctly. Thus, remove proc entry() updated the outgoing link of “Jan” to point to “Mar” correctly. However, proc readdir() used an old link, not the updated link in the scenario of Figure 6 and printed “Jan” and “Feb” only.


Fig. 8. Data race scenario between ext2 readdir() and ext2 rmdir()

Spin found a counter example (77 steps long) from the model. To replay the counter example, the wrapping functions vfs readdir() and do rmdir() should be invoked instead, since ext2 readdir() and ext2 rmdir() require a sophisticated environmental configuration and could not be invoked directly. The calling se- quences from vfs readdir() to ext2 readdir() and do rmdir() to ext2 rmdir() are illustrated in Figure 9. However, when the counter example was replayed on the kernel, de was not removed.
The monitor thread indicated that the status of the thread executing vfs readdir() was “running”.  However, the detailed log in the monitor showed that the thread was spinning inside the inserted probe at line 74a of ext2 readdir(), i.e., executing sys sched yield() in an infinite while loop (see line 13 to line 15 of Figure 5). Also, the monitor thread indicated that the thread executing do rmdir() continued to sleep even without invoking vfs rmdir()(thus, ext2 rmdir() neither). These observations led to the conclusion that the thread scheduling could not be enforced as directed by the counter example.
By analyzing vfs readdir() and do rmdir() where the execution stalled, it was found that ext2 readdir() was protected by the mutex in vfs readdir(), as indicated at lines 33 and 39 of vfs readdir(), and ext2 rmdir() was pro- tected by the same mutex at lines 2064 and 2072 in do rmdir(). Considering that ext2 readdir() and ext2 rmdir() could be invoked only from vfs readdir() and do rmdir(), the data race detected from our model for ext2 readdir() and ext2 rmdir() was a false alarm. After we refined the model to include vfs readdir() and do rmdir(), Spin did not generate a counter example.

Case	Study	3:	Data	Race	between	Multiple
remove proc entry()’s in Linux Kernel 2.6.28.2
MOKERT was applied to verify the proc file system in Linux 2.6.28.2 (the most latest release at the time of writing). From the generated Promela model, Spin detected a data race bug which had not been discovered before. The correspond- ing data race scenario is depicted in Figure 10. The data race occured when one


22 : int vfs_readdir(struct file *file, filldir_t filler, void *buf) {
…
33:  mutex_lock(&inode->i_mutex);
…

36:  res = file->f_op->readdir(file, buf, filler);
…
39:  mutex_unlock(&inode->i_mutex);
…
ext2_readdir(struct file *filp, void *dirent, filldir_t filldir) {


Calling sequence from vfs_readdir() to ext2_readdir()

Calling sequence from do_rmdir() to ext2_readdir()
Fig. 9. Calling sequence to ext2 readdir() and ext2 rmdir()from vfs readdir()and do rmdir()
thread removed dir1 and another thread removed dir1/dir1 1 at the same time. Although the code of removing a directory was protected by the spin lock (see lines 755b to 764b), the thread removing dir1 might refer to its child directory dir1/dir1 1 (see line 808a) which had been already removed by another thread, thus possibly causing a null pointer dereference.

Fig. 10. Data race scenario between two remove proc entry()’s
The translation script and the environment model for the case study 1 (see Sec- tion 4) were reused to generate a Promela model (81 lines) from the proc file system code. The verification environment (73 lines long) created two proc directory en- tries, namely dir1 and dir1/dir1 1, and two processes for remove proc entry(); one remove proc entry() removed dir1 while the other proc readdir() removed dir1/dir1 1 at the same time.
The requirement specification to detect NULL pointer dereferences was de- scribed as follows. Since Promela does not provide pointer variables, pointers were modeled by index variables for arrays. NULL value was defined as 255 in this verifi-

cation task and the sizes of the arrays in the model were less than 255. Therefore, if a NULL pointer was dereferenced in the target C program, the corresponding Promela model would access the corresponding array through an index variable whose value was beyond the bound of the array. Spin raised an array index violation error and generated a counter example. When the counter example was replayed, the kernel panic message reporting the NULL pointer dereference in remove proc entry() appeared as shown in Figure 11.













Fig. 11. Snapshot of a kernel panic message due to the data race between two remove proc entry()’s

Note that it took only one day for one graduate student to perform this whole debugging task, since the previous experimental setting including the translation script and the test driver could be reused. Although construction of a target model, its environment, and the test driver cost time and manual effort, those initial setting can be reused for other debugging tasks, thus lowering the average cost.

Related Works
Research on testing concurrent programs utilizes both dynamic and static analyses. Eraser [12] proposes an algorithm to detect data race candidates at run-time by observing the operations of locks that protect shared resources. RacerX [2] aims for the same goal, but it detects such data race candidates by analyzing the target pro- gram statically. These approaches try to discover which locks protect shared data. In general, this knowledge is, however, hard to obtain due to the high complexity of the target program. Engler et al. [1] detect the statements in the target program that match user-specified bug patterns by scanning the target program code. For example, pairing operations such as lock/unlock can be checked by this approach. In addition, software model checking is utilized for debugging concurrent pro- grams. Yang et al. [6] modified the kernel to run on top of a model checker and found several errors in the file system. However, this approach is not readily applied to general target systems, since it requires intrusive and non-portable modification of the kernel to a large degree. VeriSoft [10] and CHESS [8] provide a more general framework based on stateless search techniques, which can test a large number of scenarios systematically. However, these approaches require that the target com- ponent as well as its environment be completely executable, and thus suffer from

similar problems to those of the kernel testing. Furthermore, these frameworks de- pend on the underlying execution platform (e.g., WIN32API) and cannot directly test the kernel operating on bare hardware.
Other software model checkers extract a formal model from a given target C program through predicate abstraction or SAT encoding, and then apply model checking. These software model checkers were developed for sequential programs and have been extended for concurrent programs. These extended software model checkers apply new abstraction techniques or explore only partial concurrent exe- cutions to reduce state space. In [14], instead of considering interleaved executions among all concrete thread executions, the model checker considers the interleaving of one concrete thread execution and the abstracted executions of the other threads. In [13], an extended version of Blast abstracts not only data but also control struc- ture of each thread. TCBMC [5] checks a part of the target program’s concurrent executions with a context-switching bound. KISS [11] transforms a given concur- rent program into a sequential program that simulates the concurrent executions with only one context-switch. The goal of these software model checking techniques is to alleviate the state space explosion problem caused by numerous interleaved executions among the concurrent threads. But these software model checkers are still not applicable to automatically analyze the kernel due to the complexity of the kernel. In contrast, MOKERT does not aim at a fully automatic analysis of the target program, but utilizes human expertise to build an abstract model and environment for a real-world application (see [9]). We believe that MOKERT can provide kernel developers a practical platform for the kernel analysis.

Conclusion and Future Work
This paper proposed the MOKERT framework to detect concurrency bugs in the kernel. The framework applies the analysis result of model checking (i.e., a counter example) to the actual kernel code. Thus, the framework increases the level of user confidence, as it confirms the exhaustive model checking result on the real kernel code. We have demonstrated the effectiveness of the framework through three case studies on the the file systems of the Linux 2.6 kernel and found a hidden data race bug in the proc file system.
Through these case studies, it was observed that the model extraction technique should be automated further, since current model extraction techniques, including Modex, still depend on human expertise much. We also plan to continue analyzing the file systems of the Linux kernel through the MOKERT framework.

Acknowledgement
We would like to thank Junhee Lee and Yunho Kim at KAIST for the valuable discussions on the kernel debugging techniques and the data structure of the Linux
2.6 kernel.

References
D.Engler, B.Chelf, A.Chou, and S.Hallem. Checking system rules using system-specific, programmer- written compiler extensions. In Operating System Design and Implementation (OSDI), 2000.
D.Engler and K.Ashcraft. RacerX: Effective, Static Detection of Race Conditions and Deadlocks. In
Symposium on Operating Systems Principles, 2003.
G.J.Holzmann and R.Joshi. Model-driven software verification. In Spin Workshop, April 2004.
G. J. Holzmann. The Spin Model Checker. Wiley, New York, 2003.
I.Rabinovitz and O.Grumberg. Bounded model checking of concurrent programs. In Computer Aided Verification (CAV), 2005.
J.Yang, P.Twohey, D.Engler, and M.Musuvathi. Using model checking to find serious file system errors. In Operating System Design and Implementation (OSDI), 2004.
M.Kim, Y.Kim, Y.Choi, and H.Kim. Pre-testing flash device driver through model checking techniques. In IEEE Int. Conf. on Software Testing, Verification and Validation, 2008.
M.Musuvathi, S.Qadeer, and T. Ball. Chess: A systematic testing tool for concurrent software. Technical report, Microsoft Research, 2007.
P.Camara, M.Gallardo, and P.Merino. Model extraction for arinc 653 based avionics software. In Spin workshop, 2007.
P.Godefroid. The VeriSoft Approach. Formal Methods in System Design, 26(2):77–101, 2005.
S.Qadeer and D.Wu. Kiss: keep it simple and sequential. In Programming Language Design and Implementation (PLDI), 2004.
S.Savage, M.Burrows, G.Nelson, P.Sobalvarro, and T.Anderson. Eraser: A dynamic data race detector for multithreaded programming. ACM Transactions on Computer Systems, 15(4):391–411, 1997.
T.A.Henzinger, R.Jhala, and R.Majumdar. Race checking by context inference. In Programming Language Design and Implementation (PLDI), 2004.
T.A.Henzinger, R.Jhala, R.Majumdar, and S.Qadeer. Thread-modular abstraction refinement. In
Computer Aided Verification (CAV), 2003.
