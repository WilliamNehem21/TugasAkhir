

Electronic Notes in Theoretical Computer Science 250 (2009) 69–84
www.elsevier.com/locate/entcs
CSP-CASL-Prover:
A Generic Tool for Process and Data Refinement
Liam O’Reilly1  Markus Roggenbach1
Swansea University, United Kingdom
Yoshinao Isobe1,2
AIST, Tsukuba, Japan

Abstract
The specification language Csp-Casl allows one to model processes as well as data of distributed systems within one framework. In our paper, we describe how a combination of the existing tools Hets and Csp- Prover can solve the challenges that Csp-Casl raises on integrated theorem proving for processes and data. For building this new tool, the automated generation of theorems and their proofs in Isabelle/HOL plays a fundamental role. A case study of industrial strength demonstrates that our approach scales up to complex problems.
Keywords: Process Algebra, Algebraic Specification, Theorem Proving, Functional Programming.


Introduction
Distributed computer applications like flight booking systems, web services, and electronic payment systems such as the EP2 standard [2], require parallel process- ing of data. Consequently, these systems have concurrent aspects (e.g. deadlock- freedom) as well as data aspects (e.g. functional correctness). Often, these aspects depend on each other.
In [22], we present the language Csp-Casl, which is tailored to the specification of distributed systems. Csp-Casl integrates the process algebra Csp [7,23] with the algebraic specification language Casl [15]. Its novel aspects include the combination
of denotational semantics in the process part and, in particular, loose semantics for

1 This cooperation was supported by the EPSRC Project EP/D037212/1.
2 This work was supported by KAKENHI 20500023.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.018

the data types covering both concepts of partiality and sub-sorting. In [5] we apply Csp-Casl to the EP2 standard and demonstrate that Csp-Casl can deal with problems of industrial strength.
Here, we develop theorem proving support for Csp-Casl and show that our approach scales up to practically relevant systems such as the EP2 standard. Csp- Casl comes with a simple, but powerful notion of refinement. Csp-Casl refinement can be decomposed into first a refinement step on data only and then a refinement step on processes. Data refinement is well understood in the Casl context and has good tool support already. Thus, we focus here on process refinement. The basic idea is to re-use existing tools for the languages Casl and Csp, namely for Casl the tool Hets [13] and for Csp the tool Csp-Prover [8,9,10,11], both of which are based on the theorem prover Isabelle/HOL [19]. This re-use is possible thanks to the definition of the Csp-Casl semantics in a two step approach: First, the data specified in Casl is translated into an alphabet of communications, which, in the second step, is used within the processes, where the standard Csp semantics are applied.
The main issue in integrating the tools Hets and Csp-Prover into a Csp-Casl- Prover is to implement – in Isabelle/HOL – Csp-Casl’s construction of an alphabet of communications out of an algebraic specification of data written in Casl. The correctness of this construction relies on the fact that a certain relation turns out to be an equivalence relation.  [22] shows in terms of a manually proven meta
theorem that the alphabet construction works out for a large class of Casl data
specifications, which is characterised by the static semantics property ‘has local top elements’. In Csp-Casl-Prover, we choose to prove the relation to be an equiva- lence for each Csp-Casl specification individually. This adds an additional layer of trust: complementing the algorithmic check of a static property, we provide a
proof in Isabelle/HOL that the construction is valid. The alphabet construction, the formulation of the justification theorems (establishing the equivalence relation), and their proofs can all be automatically generated.

Closely related to
Csp-Casl
is the specification language μCRL [4].  Here,

data types have loose semantics and are specified in equational logic with total functions. The underlying semantics of the process algebraic part is operational.
[1] presents a μCRL-Prover based on the interactive theorem prover PVS. The
chosen approach is to represent the abstract μCRL data types directly by PVS types, and to give a subset of μCRL processes an operational semantics. Thanks to μCRL’s simple approach to data – neither sub-sorting nor partiality are available – there is no need for an alphabet construction – as it is also the case in Csp-Casl in the absence of sub-sorting and partiality. Concerning processes, Csp-Casl-Prover provides semantics to full Csp.
Our paper is organised as follows: Section 2 introduces the Csp-Casl semantics along with a case study from the EP2 system. Section 3 describes the existing tools which we make use of. The overall architecture of Csp-Casl-Prover is presented in Section 4. First we discuss how to build an alphabet to be used as a parameter for
the process type of Csp-Prover. Then we consider how integration theorems can

lift proof obligations. Finally, we show how to implement our approach in Haskell. Section 5 concludes our paper with a case study on how to prove deadlock freedom of a dialog within the EP2 system.
This paper supersedes our publication [20]. The full technical details of this work can be found in [21].

CSP-CASL
Csp-Casl [22] is a comprehensive language which combines processes written in Csp [7,23] with the specification of data types in Casl [15]. The general idea is to describe reactive systems in the form of processes based on Csp operators, where the communications of these processes are the values of data types, which are loosely specified in Casl. All standard Csp operators are included, such as multiple prefix, the various parallel operators, operators for non-deterministic choice, and operators

for communication over channels. Concerning
Casl
features, the full language

is available to specify data types, namely many-sorted first order logic with sort- generation constraints, partiality, and sub-sorting. Furthermore, the various Casl structuring constructs are included.
Syntactically, a Csp-Casl specification with name N consists of a data part Sp, which is a structured Casl specification, an (optional) channel part Ch to declare channels, which are typed according to the data part, and a process part P written in Csp, within which Casl terms are used as communications, Casl sorts denote sets of communications, relational renaming is described by a binary Casl predicate, and the Csp conditional construct uses Casl formulae as conditions – see Figure 1 for an instance of this scheme:
ccspec N = data Sp channel Ch process P end

EP2 in CSP-CASL
As a running example, we choose a dialog nucleus of the EP2 system [2], see [5] for further details of the modelling approach. The Csp-Casl specification of this dialog can be seen in Figure 1. In this dialog, the credit card terminal and an- other component, the so-called acquirer, are supposed to exchange initialisation information over the channel C SI Init. The messages on this channel can be classified into the groups SessionStart, SessionEnd, ConfigDataRequest and ConfigDataResponse. In the modelling of the EP2 dialog we ensure that mes- sages of type ConfigDataRequest are different from messages of type SessionEnd. The system consists of the parallel composition of the terminal and the acquirer. Should one of these two components be in a deadlock, the whole system will be in deadlock.
The original dialog in EP2 has more possibilities for the data exchange. For simplicity, we present here only the above nucleus. However, we successfully applied our approach to the full dialog.






CSP-CASL semantics
Fig. 1. Nucleus of an EP2 dialog.

Semantically, a Csp-Casl specification is a family of process denotations for a Csp process, where each model of the data part Sp gives rise to one process denotation. The language Csp-Casl is generic in the choice of a specific Csp semantics.
(Sp, P )


Casl
(P ′(A(β(M ))))M∈Mod(Sp)


Csp semantics




(dM )M∈Mod(Sp)

Fig. 2. Csp-Casl semantics.
The semantics of Csp-Casl is defined in a two-step approach 3 , see Figure 2. Given a Csp-Casl specification (Sp, P ), in the first step we construct for each model M of Sp a Csp process P '(A(β(M ))). To this end, we define for each model M , which might include partial functions, an equivalent model β(M ) in which partial functions are totalised. β(M ) gives rise to an alphabet of communications A(β(M )). In the second step we point-wise apply a denotational Csp semantics. This trans- lates a process P '(A(β(M ))) into its denotation dM in the semantic domain of the chosen Csp model. In the following we sketch the alphabet construction:
A many-sorted signature Σ = (S, TF, PF, P ) consists of a set S of sorts, total functions symbols TF, partial functions symbols PF, and predicate symbols P . Given a many-sorted signature Σ = (S, TF, PF, P ), a many-sorted Σ-model M consists of a non-empty carrier set Ms for each sort symbol s ∈ S, a partial function fM for each function symbol f ∈ TF ∪ PF, the function being total for f ∈ TF, and a relation pM for each predicate symbol p ∈ P. Together with the standard definition of first order logic formulae and their satisfaction, this definition yields the institution PFOL=, see [14] for the details.
A sub-sorted signature Σ = (S, TF, PF, P, ≤) consists of a many-sorted signature (S, TF, PF, P ) together with a reflexive and transitive sub-sort relation ≤S ⊆ S×S.

3 We omit here the syntactic encoding of channels into the data part.

With each sub-sorted signature Σ = (S, TF, PF, P, ≤) we associate a many-sorted signature Σˆ = (Sˆ, TˆF, PˆF, Pˆ), which extends the underlying many-sorted signature (S, TF, PF, P ) with a total injection function symbol inj⟨s⟩,s' ∈ TF for each pair of sorts s ≤S s', a partial projection function symbol pr⟨s'⟩,s ∈ PF for each pair of
sorts s ≤S s', and an unary membership predicate symbol ϵs'  '  ∈ P for each pair of
s ⟨s ⟩
sorts s ≤S s'. Sub-sorted Σ-models are many-sorted Σˆ-models satisfying in PFOL= a set of axioms Jˆ(Σ), which prescribe how the injection and projection functions and
membership predicates behave 4 . A typical axiom in Jˆ(Σ) is inj⟨s⟩,s(x) = x for s ∈
e
S. Together with the definition of sub-sorted first order logic formulae and their satisfaction, this definition yields the institution SubPFOL=, see [14] for the details.
Given a sub-sorted model M on carrier sets, its strict extension β(M ) is defined as: β(M )s = Ms ∪ {⊥} for all s ∈ Sˆ, where ⊥ /∈ Ms for all s ∈ Sˆ. We say that a signature Σ = (S, TF, PF, P, ≤) has local top elements, if for all u, u',s ∈ S the following holds: if u, u' ≥ s then there exists t ∈ S with t ≥ u, u'. Relatively to the extension β(M ) of a model M for a sub-sorted signature with local top elements, we define an alphabet of communications

A(β(M )) := (  β(M )s)/∼
s∈S

where (s, x) ~ (s', x') iff either x = x' = ⊥ and there exists u ∈ S such that s ≤ u
and s' ≤ u; or x /= ⊥, x' /= ⊥, there exists u ∈ S such that s ≤ u and s' ≤ u, and for
all u ∈ S with s ≤ u and s' ≤ u the following holds: (inj(s,u))M (x) = inj(s',u)  (x')
for s, s' ∈ S, x ∈ Ms, x' ∈ Ms' . For signatures with local top elements the relation
~ turns out to be an equivalence relation [22].


CSP-CASL reﬁnement
Given a denotational Csp model with domain Ð, the semantic domain of

Csp-

Casl consists of families of process denotations dM ∈ Ð. Its elements are of the
form (dM )M∈I where I is a class of algebras. As refinement ~D we define on these elements
(dM )M∈I ~D (d' ' )M'∈I' iff I' ⊆ I Λ 6M ' ∈ I' : dM' ±D d' ' ,
where I' ⊆ I denotes inclusion of model classes over the same signature, and ±D is the refinement notion in the chosen Csp model Ð, e.g., the traces model 7 , the failures-divergences model U, or the stable-failures model J.
Concerning Csp-Casl refinement, [12] presents the following results:
Theorem 2.1 For all (Sp, P ), (Sp',P') holds:
(Sp, P ) ~D (Sp',P') ⇐⇒ Sp ~ Sp' Λ (Sp',P ) ~D (Sp',P').
Theorem 2.2 There exist (Sp, P ), (Sp',P') such that:
(Sp, P ) ~D (Sp',P') /=⇒ Sp ~ Sp' Λ (Sp, P ) ~D (Sp, P').

4 and also define how overloading works.

Here, Sp ~ Sp' denotes Casl refinement in the form of model class inclusion,
formally, Sig(Sp) = Sig(Sp') and Mod(Sp') ⊆ Mod(Sp).
Theorem 2.1 allows the decomposition of a Csp-Casl refinement (Sp, P ) ~D (Sp',P') into (1) a Casl refinement step from Sp to Sp' and (2) a Csp-Casl re- finement step from (Sp',P ) ~D (Sp',P'), where the data part remains constant, namely Sp'. For (1), the tool Hets already offers tool support. Thus, we con- centrate here on (2). Concrete: we provide an automatic translation of Csp-Casl refinement over constant data parts into the input language of Csp-Prover.

Tools involved


Fig. 3. Diagram of the basic architecture of Csp-Casl-Prover.

Isabelle/HOL [19] is a widely used, interactive theorem prover for Higher Order Logic. Theorems are entered into Isabelle/HOL via commands. Isabelle/HOL then displays proof goals to be discharged. To prove a theorem, proof commands are issued which transform goals into other goals (or possibly many sub-goals). A goal is discharged if it is transformed into the truth value True. A theorem is proven when all of its proof obligations have been discharged. Previously established theorems can be used within further proofs as new proof commands. Proof commands can be combined in various ways to form tactics, which can ease the burden of discharging proof goals. Theory files in Isabelle/HOL consist of scripts of Isabelle commands and proof commands. Commands allow the user to extend the logic, for example, by adding new data structures, types, and function definitions to Isabelle/HOL. This allows the user to accommodate for the particular area of interest.
Hets (the Heterogeneous Tool Set) [13,16] is a parsing, static analysis and proof management tool for various specification languages centred around Casl [15]. One
feature of Hets is the ability to translate a specification from one specification
language to another specification language, whilst preserving the semantics of the specification. Hets implements various specification languages (seen as logics) and translations (so-called comorphisms) between them. One instance of this mechanism
is the translation of Casl specifications into suitable code for use in the theorem prover Isabelle/HOL. Casl views trigger Hets to produce proof obligations which

can be discharged by various theorem provers, such as Isabelle/HOL or SPASS. Hets is written in the functional programming language Haskell [6]. The Hets code base defines a rich type system which captures mathematical notions such as logics, comorphisms, Casl specifications, theories, etc. Hets makes use of monadic programming in order to simulate states within Haskell.
Csp-Prover [8,9,10,11] is an interactive theorem prover built upon Isabelle/HOL. Csp-Prover is dedicated to refinement proofs over Csp processes, where all Csp op- erators are supported, including internal and external choice, the various parallel operators, hiding, renaming, as well as recursion. Csp-Prover is generic in the mod- els of Csp that can be used. It can be instantiated with all main Csp models. The traces model 7 and the stable-failures model J are available, while implementations of the stable-revivals model R and the failure-divergences model U are underway.
Csp-Prover provides a deep-encoding of Csp within Isabelle/HOL. Consequently, it offers a type ’a proc (see Section 4.1.2), the type of Csp processes that are built over the alphabet ’a, where ’a is an Isabelle/HOL type variable. Csp-Prover comes with a large collection of Csp laws and tactics including Csp step laws and distribu- tivity laws. One method of proving process equality or refinement without looking into the semantics of the processes is to syntactically rewrite processes using such laws. Csp-Prover’s tactics combine such laws to provide powerful proof principles. One typical example is the tactic cspF hsf tac, which transforms Csp processes to a ‘head normal form’ over the model J.

Implementation of CSP-CASL-Prover
Csp-Casl-Prover uses the existing tools Hets and Csp-Prover. Its architecture is
shown in Figure 3. Csp-Casl-Prover takes a Csp-Casl process refinement state-
ment as its input. The Csp-Casl specifications involved are parsed and transformed by Csp-Casl-Prover into a new file suitable for use in Csp-Prover. This file can then be directly used within Csp-Prover to interactively prove if the Csp-Casl
process refinement holds. Figure 4 shows the five distinct parts of this file: The first three parts are all automatically generated from the original Csp-Casl speci- fication; the final two parts are dependent on the application. Within the last two parts, Csp-Casl-Prover provides place holder code that the user can fill in and expand.


Automatically generated by CSP-CASL Prover.


Application dependent, to be provided by the user.

Fig. 4. Structure of a translated Csp-Casl specification using Csp-Casl-Prover.




Fig. 5. Hets Encoding for the nucleus of the EP2 specification (Figure 1).

Alphabet construction
In this section we first discuss a Hets translation from Casl to Isabelle/HOL. Then we describe how to encode the Csp-Casl alphabet construction in Isabelle/HOL.


HETS encoding
We use a semantic preserving encoding provided by

Hets

to encode the data

part of a Csp-Casl specification in Isabelle/HOL 5 . Essentially, Hets produces
Isabelle/HOL commands such as typedecl (for declaring new non-empty types) and function declarations, followed by axioms which define the properties of such declared types and functions.  We discuss here only the signature encoding of
SubPFOL= to Isabelle/HOL. Casl sub-sorting and partiality are encoded within
Isabelle/HOL by adding undefined elements ⊥s to each sort s, a definedness func- tion Ds for each sort s and injection and projection functions between sorts in the sub-sort relation. The following axioms are then added which control how the bottom elements and definedness functions behave:
∃x : s • Ds(x) for each s ∈ S,
¬(Ds(x)) ⇔ (x =⊥s) for each s ∈ S,
Ds(f (x1,..., xn)) ⇔ i=1...n Dsi (xi) for each function f⟨s1,...,sn⟩,s ∈ TF ,
Ds(g(x1,..., xn)) ⇒  i=1...n Dsi (xi) for each partial function g⟨s1,...,sn⟩,s ∈ PF ,
p(x1,..., xn) ⇒  i=1...n Dsi (xi) for each predicate symbol p⟨s1,...,sn⟩ ∈ P . Full details of these axioms can be found in [14].
Figure 5 shows part of the encoding 6 that Hets produces for the Csp-Casl
specification for the nucleus of the EP2 dialog in Figure 1. According to the sen-

tence translation of [14] the translated axiom from the
Csp-Casl
specification

with the name of Ax1 has changed slightly from the specification due to the en- coding of undefined elements. Now the axiom states that two messages of types ConfigDataRequest and SessionEnd are never equal if they are both defined.

5 Currently, the chosen encoding of Hets does not allow for the use of free and generated types, however, this difficulty will be over come in future versions of Hets.
6 For presentation purposes, we have slightly adapted the naming scheme of Hets.




Fig. 6. Alphabet construction for the nucleus of the EP2 dialog (Figure 1).
Alphabet construction within Isabelle/HOL
Aim of the alphabet construction is to create an alphabet of communications (the new type Alphabet) in Isabelle/HOL as set out in Section 2.2. We then use this type within Csp-Prover to form the type Alphabet proc of Csp processes over the alphabet of communications.
The alphabet construction of [22] depends on the signature of the data part of
a Csp-Casl specification, e.g., on the set of sorts S, see Section 2.2. Hets, how-
ever, produces a shallow encoding of Casl only, i.e., there is no type available that captures the set of all sorts of the data part of a Csp-Casl specification. Conse-
quently, it is impossible to give a single alphabet definition within Isabelle/HOL which is generic in the data part of a Csp-Casl specification. Instead, we produce an encoding individually crafted for the data part of any Csp-Casl specification. This crafting follows a systematic approach and is automatically produced by Csp- Casl-Prover in multiple stages: a construction section followed by a justiﬁcation section. The construction section introduces a new type PreAlphabet and defines a relation over this type. The justiﬁcation section is a collection of theorems and proofs which make sure that we are allowed to use the code from the construction section in the way we want. The alphabet of communications is then produced
using both the type PreAlphabet and the relation. In the following we illustrate our construction by an extended example.
The PreAlphabet is the disjoint union of all the sorts that Hets produces. The particular code for the creation of the PreAlphabet for the nucleus is:

Next a relation called eq is defined. This relation takes as parameters two elements of the PreAlphabet and checks whether they are equal with respect to the Csp-Casl semantics (this is the relation ~ from Section 2.2).
Figure 6 shows part of the code that is produced for the eq relation of the nucleus. Here, auxiliary functions are used to compare each constructor of the data- type PreAlphabet with every other constructor. Finally the eq relation is defined which makes use of the auxiliary functions. Two elements of the PreAlphabet are equal if they are equal in all super-sorts. This is accomplished using the injection functions to test the elements of the PreAlphabet at the correct sorts.

The Csp-Casl-semantics requires the relation eq to be an equivalence relation. The justiﬁcation section checks that this property holds. The code for checking reflexivity and symmetry is simple. Thus, we focus on the proof of transitivity. The main idea behind this proof is to induct all the variables until only finitely many case distinctions remain. Isabelle/HOL can then automatically solve all of the cases by using some previously proven lemmas which are automatically generated and proven. Figure 7 shows part of the code that is produced to check that the eq relation is transitive. We carefully apply induction to the variables x and y in specific sub-goals by first pulling the sub-goal to the top of the list (using the prefer command) and then applying induction to the variable in the first sub-goal. The numbers associated with each prefer command are systematically generated by our algorithm.


Fig. 7. Proof of transitivity of the eq relation.

We illustrate this proof idea by a concrete example. Consider the sub-sort structure shown in Figure 8 where the functions shown are the injections functions

which
Hets
provides 7 .  After applying all the necessary induction, one of the

resulting proof obligations is x ~ y Λ y ~ z ⇒ x ~ z, where x, y and z are variables of the types S, T and U , respectively. Expanding the definition of x ~ z yields two new sub-goals: inj S U (x) = z and inj S V (x) = inj U V (z). We focus here on proving inj S V (x) = inj U V (z). This equation means that x is equal to z in the sort V . Expanding the definition of x ~ y we obtain the equation inj S V (x) = inj T V (y). From y ~ z we obtain inj T V (y) = inj U V (z). These two facts together yield inj S V (x) = inj U V (z). This proves one part of the goal, the other can be proven in a similar way using the fact that the functions
we use are injections (these axioms are provided by Hets). Isabelle/HOL can carry

7 We use the notation of ∼ in place of the Isabelle function eq.
V


x:S
Fig. 8. Example of a possible sub-sort structure with injection functions.

out all these proofs fully automatically, provided the simplifier is enriched with the right injection lemmas, see the last but one line of Figure 7 i.e. apply(auto simp add: ginj x eq ginj y ... ginj x eq ginj y 3). The ideas presented above are automatised in the form of algorithms, see Figure 9 for an algorithm which produces the theorem and proof of transitivity of the eq relation.


Fig. 9. Algorithm for producing the theorem and proof of transitivity of the eq relation.

Now that the justification theorems have been established and proven, we can construct the alphabet of communications in a general way using the following specification independent code (see Section 4.3):


Integration theorems
Csp processes communicate within the alphabet of communications. As the alpha- bet of communications is a quotient, Csp processes actually communicate equiv- alence classes. Arguing about the elements of the communications alphabet can therefore be difficult. However, the Csp-Casl-semantics asks only three different questions on the alphabet of communications, see [22]. The most prominent is the test whether two elements of the alphabet of communications are equal or not. This test, for example, is used when two processes synchronise.
In order for the end-user to be able to easily argue on the Csp-Casl process part they need to be able to easily test whether two equivalence classes are equal or not. To facilitate this, Csp-Casl-Prover provides integration theorems which allow tests on the alphabet of communications to be lifted back to tests on the data from the Hets encoding. Figure 10 shows an example of one such integration theorem from the nucleus of the EP2 dialog.
The integration theorem of Figure 10 states that two equivalence classes, which are based on the type “data request” (as they have the form C B x), are equal if and only if their underlying elements of the pre-alphabet are equal in their top most sort




Fig. 10. Example of an integration theorem and it’s proof.

(i.e. D SI Init). These data theorems and their proofs are automatically generated by algorithms.
Proof practice shows that with these integration theorems available, reasoning about the behavioural aspects of a Csp-Casl specification becomes as easy (or challenging) as reasoning on data and processes separately, where reasoning on processes usually depends on theorems concerning data.

Dependencies
The following table shows the dependencies of the pre-alphabet construction, jus- tification theorems and the integration theorems on the different elements of the data part of a Csp-Casl specification. C(D) denotes that the construction is de- pendent on the parameter in the column heading. T (D) denotes that formulation of the theorem statement is dependent on the parameter in the column heading, while T (I) expresses that the theorem statement is independent of the parameter in the column heading. Similarly P ( ) expresses the dependencies of the proofs on the parameter in the column heading.

The reflexivity property of the eq relation is completely independent of the specifica- tion whereas the proof of symmetry relies only on the number of sorts and the proof of transitivity relies on the number of sorts and the sub-sort structure (indirectly). The integration theorems are the most dependent on the specification.


A prototypical implementation of CSP-CASL-Prover
In this section we discuss our prototypical implementation of


Csp-Casl-Prover.

[3] provides parser and static analysis support for Csp-Casl within the framework
of Hets. Here, Csp-Casl specifications are represented as values of Haskell data types, for instance processes are represented by the data type:





Fig. 11. Generation of the type PreAlphabet


Fig. 12. Generation of a justification theorem: proof of symmetry.
The result of the static analysis is a Csp-Casl signature and a list of Csp-Casl sentences. Such Csp-Casl sentences are either Casl formulae or process equations in Csp, see [17,18] for the justification to consider Csp-Casl as a logic. This repre- sentation can then be automatically translated into a theory file for Isabelle/HOL using the function:

Here, the type Result is a monad provided by the Hets code base for the purpose of collecting together the various results of code analysis. IsaTheory is a type representing the abstract syntax of Isabelle/HOL, which Hets then pretty prints. The translation of the data part is already implemented in Hets: Sub-sorting and partiality are encoded in Isabelle/HOL as required by the Csp-Casl semantics. Thus, our translation is mainly concerned with the encoding of the Csp-Casl se-
mantics and the translation of process equations, for which we present here selected code examples.
The Haskell implementation of the pre-alphabet construction (described in Sec- tion 4.1.2) is shown in Figure 11. Here, DomainEntry is the type in Hets which represents Isabelle/HOL’s datatype command. Given a list of sort symbols, each sort symbol gives rise to an alternative constructor, where the symbol’s name is used as a part of the respective constructor.
The Haskell code producing a justification theorem and its proof is shown in Figure 12: Given a list of sorts and the current Isabelle/HOL theory we add a new theorem and its proof. Here, we first build the formula to be proven, namely x ~ y =⇒ y ~ x. In the code we represent x ~ y as binEq PreAlphabet x y. To this end we produce variables x and y in the abstract Isabelle syntax, form the lhs




Fig. 13. Csp-Casl specification of a sequential system.
and rhs of the implication and finally state the implication. Then we build up the proof script which consists of one induction on x, which is followed by a sequence of inductions on y and rearranging of the proof goals using the proof command prefer. Finally, the proof command auto is added, and the proof concluded with the proof command done.
The instantiation of type classes as well as the generation of the integration theorems uses the same techniques as demonstrated above.
We conclude with an example from the translation of Csp process definitions:


Here, we perform a case distinction on the form of the process and produce the corre- sponding abstract syntax. cspProver skipOp and cspProver general parallelOp are values in the abstract syntax of Hets representing the Csp-Prover skip and gen- eral parallel operators respectively.

Proof of deadlock freedom of EP2
As an application of Csp-Casl-Prover, we prove deadlock freedom in an in-
dustrial setting. Our approach is to prove that, in the stable failures model J, the nucleus (see Figure 1 and Section 2.1) is a refinement of the sequential system shown in Figure 13. Here, we have an Abstract process that sends a SessionStart value and then enters a loop. The Loop process either sends a SessionEnd mes- sage and terminates, or it sends a ConfigDataRequest message followed by a ConfigDataResponse message and then repeats the loop. Loop chooses internally, which of these two branches is taken. As this system has no parallelism it is impos- sible for it to deadlock. Process refinement within stable failures model preserves deadlock freedom. Hence if we can show that the EP2 nucleus is indeed a refinement of the sequential system, then the EP2 nucleus is guaranteed to be deadlock free.
Figure 14 shows the respective refinement proof in Csp-Casl-Prover (we actu-




Fig. 14. Proof of deadlock freedom of the nucleus (see Figure 1).
ally show more, namely that both systems are equivalent). This refinement proof involves recursive process definitions. These are first unfolded, then (metric) fixed point induction is applied. A powerful tactic provided by Csp-Prover finally dis- charges the proof obligation. This proof also scales up to the full EP2 dialog.

Summary and future work
We have shown how to combine the tools Hets and Csp-Prover into a proof tool for Csp-Casl. The main challenges turned out to be the encoding of Csp-Casl’s alphabet construction in Isabelle/HOL as well as the automated generation of in- tegration theorems. The alphabet construction turns a many-sorted algebra into a flat set of communications. The integration theorems translate questions on the alphabet of communications back into the language of many-sorted algebra. In both cases, we have devised algorithms and Haskell implementations that – tak- ing a Csp-Casl specification as their input – produce the required types, functions, theorems, and proofs in Isabelle/HOL. A case study on the EP2 system, nearly fully automatically translated, demonstrates that our approach scales up on problems of industrial strength. Future work will include the completion of Csp-Casl-Prover’s implementation, analysing further dialogs of EP2 as well as further case studies on distributed computer applications.

Acknowledgement
Thanks to Temesghen Kahsai for his work on decomposition theorems for Csp-Casl refinement and also to Erwin R. Catesbeiana (jr) for his valuable insights into the very nature of electronic payment systems.

References
B. Badban, W. Fokkink, J.F. Groote, J. Pang, and J. van de Pol. Verification of a sliding window protocol in μCRL and PVS. Formal Aspects of Computing, 17(3):342–388, 2005.
eft/pos 2000 Specification, version 1.0.1. EP2 Consortium, 2002.
Andy Gimblett. Tool support for CSP-CASL, 2008. MPhil Thesis, Swansea University.
J.F. Groote and A. Ponse. The syntax and semantics of μCRL. In Algebra of Communicating Processes ’94, Workshops in Computing Series, pages 26–62. Springer, 1995.


A. Gimblett, M. Roggenbach, and H. Schlingloff. Towards a formal specification of an electronic payment system in Csp-Casl. In WADT 2004, LNCS 3423, pages 61–78. Springer, 2005.
Haskell homepage.
http://www.haskell.org/.
C.A.R. Hoare. Communicating Sequential Processes. Prentice Hall, 1985.
Y. Isobe and M. Roggenbach. A generic theorem prover of CSP refinement. In TACAS 2005, LNCS 3440, pages 108–123. Springer, 2005.
Y. Isobe and M. Roggenbach. A complete axiomatic semantics for the CSP stable-failures model. In
CONCUR’06, LNCS 4137, pages 158–172. Springer, 2006.
Yoshinao Isobe and Markus Roggenbach. CSP-Prover - A proof tool for the verification of scalable concurrent systems. JSSST (Japan Society for Software Science and Technology) Computer Software, 25:85–92, 2008.
Yoshinao Isobe and Markus Roggenbach. Proof Principles of CSP – CSP-Prover in Practice. In LDIC 2007, pages 425 – 442. Springer, 2008.
Temesghen Kahsai and Markus Roggenbach. Refinement notions for CSP-CASL. In WADT 2008, LNCS, to appear. Springer, 2009.
T. Mossakowski, C. Maeder, and K. Lu¨ttich. The Heterogeneous Tool Set, HETS. In TACAS 2007, LNCS 4424, pages 519–522. Springer, 2007.
T. Mossakowski. Relating Casl with other specification languages: the institution level. Theoretical Computer Science, 286(2):367–475, 2002.
P. Mosses, editor. Casl Reference Manual. LNCS 2960 (IFIP Series). Springer, 2004.
T. Mossakowski. Heterogeneous specification and the heterogeneous tool set. Technical report, Universitaet Bremen, 2005. Habilitation thesis.
T. Mossakowski and M. Roggenbach. Structured CSP – A Process Algebra as an Institution. In WADT 2006, LNCS 4409, pages 92–110, 2007.
T. Mossakowski and M. Roggenbach. An institution for processes and data. In WADT 2008 – Preliminary Proceedings, TR-08-15. Universita Di Pisa, 2008.
T. Nipkow, L.C. Paulon, and M. Wenzel. Isabelle/HOL. LNCS 2283. Springer, 2002.
L. O’Reilly, Y. Isobe, and M. Roggenbach. CSP-CASL-Prover – Tool integration and algorithms for automated proof generation. In CALCO-jnr 2007. University of Bergen, Febuary 2008.
Liam O’Reilly. Integrating Theorem Proving for Processes and Data, 2008. MPhil Thesis, Swansea University.
M. Roggenbach.  CSP-CASL - A new integration of process algebra and algebraic specification.
Theoretical Computer Science, 354(1):42–71, 2006.
A.W. Roscoe. The Theory and Practice of Concurrency. Prentice Hall, 1998.
