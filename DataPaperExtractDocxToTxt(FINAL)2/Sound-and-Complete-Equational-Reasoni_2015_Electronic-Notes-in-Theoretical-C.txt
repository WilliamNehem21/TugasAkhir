Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 315–331
www.elsevier.com/locate/entcs

Sound and Complete Equational Reasoning over Comodels
Dirk Pattinson1
The Australian National University
Lutz Schr¨oder 2,3
Friedrich-Alexander-Universit¨at Erlangen-Nu¨rnberg

Abstract
Comodels of Lawvere theories, i.e. models in Setop , model state spaces with algebraic access operations. Standard equational reasoning is known to be sound but incomplete for comodels. We give two sound and complete calculi for equational reasoning over comodels: an inductive calculus for equality-on-the-nose, and a coinductive/inductive calculus for equality modulo bisimulation which captures bisimulations syntactically through non-wellfounded proofs.
Keywords: Equational Logic, Comodels, Completeness, Bisimulation

Introduction
Comodels are an algebraic abstraction of the notion of global state, often used in the operational semantics of programming languages [13,15,11]. The most promi- nent example is the modelling of global state in imperative programs, where the explicit modelling of a store as a function that maps locations to values is replaced by algebraic operations that read and manipulate the values of global variables. Equations, in the standard universal-algebraic sense, ensure the intended semantics of these operations. Comodels are attractive for two reasons: first, they abstract implementation of state from the operational semantics, as state is not modelled explicitly, but only manipulated using operations. Second, the operations integrate seamlessly with programming language syntax. Some progress has been made to- wards the development of congruence formats in these settings [2]. While this builds

1 dirk.pattinson@anu.edu.au
2 lutz.schroeder@fau.de
3 Work supported by the DFG under project COAX (SCHR 1118/12-1)

http://dx.doi.org/10.1016/j.entcs.2015.12.019 1571-0661/© 2015 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

the link between operational and denotational semantics, the link with axiomatic semantics is much less understood. Comodels are essentially an algebraic concept, defined in terms of function symbols and equations, but the interpretation of func- tion symbols takes place in the category Setop, the opposite category of the category Set of sets and maps. While a unary function symbol, say wrv for writing a value v, is still interpreted as a unary function Qwrv¢ ∶ C → C on a set (of comodel states), general n-ary function symbols are interpreted as functions Qf ¢ ∶ C → n⋅C = C +⋅⋅ ⋅+C (n times) and so are not understood as constructors, but as a combination of ob- servation and state change. For example, a binary function symbol rd (that we think of as reading a binary value from a memory cell) receives the interpretation Qrd¢ ∶ C → C + C and so indicates the value of the cell being read (by choosing one of the alternatives in C + C) on top of a new state. As a consequence, the standard tools of universal algebra for proving completeness of equational logic, including the construction of free algebras from terms modulo equations, are not available in the setting of comodels. Moreover, it is easy to see that equational reasoning is sound but incomplete over comodels. The easiest example is that of a theory comprising a nullary operation n and no equations: a comodel for this theory interprets n as a function Qn¢ ∶ C → 0⋅C =∅ and therefore is empty, hence validates all equations; but clearly not all equations are derivable from the empty set of equations by standard equational reasoning. Excluding nullary operations does not improve this situation: we give an example below, due to Power, that shows that the same effect happens for a commutative binary operation.
This situation is remedied in the present paper, where we provide sound and complete calculi for equational reasoning over comodels. The overall flavour of comodels is coalgebraic, with a very simple type functor but with added complexity creeping in via the algebraic equations, which, for instance, may relate terms of different lookahead. The semantics of equations over comodels therefore naturally comes in two variants: satisfaction on-the-nose, and satisfaction up to bisimilarity, inducing correspondingly different notions of logical consequence. For reasoning on- the-nose, we give a standard, purely inductive calculus. We formalize this calculus in the style of a labelled sequent system. Key rules of the system express that terms with disjoint sets of free variables can never be equal in the comodel interpretation, and that terms with n free variables are essentially n-fold case statements allowing for a corresponding case distinction. For reasoning modulo bisimilarity, we then extend this inductive calculus by a single coinductive rule that allows us to conclude that two comodel terms are equal if they have the same output and their successors are equal. This rule may be applied in non-wellfounded proofs, resulting in a mixed inductive/coinductive calculus.
Related Work. We have already mentioned [14] where the theory of arrays is devel- oped in terms of comodels, and the use of comodels in the semantics of programming languages [12,15,2]. None of these papers is concerned with axiomatic semantics,
i.e. the equational logic of comodels. The model/comodel duality is investigated in [9,8] on the basis of clones and establishes, in our terminology, a dual equivalence between categories of comodels and certain topological spaces, but does not inves-

tigate the logical aspects. The proof-theoretic analysis of circular coinduction [16] has a goal that is similar to the completeness of equational reasoning modulo bisim- ulation, and blocks the application of the congruence rule in coinductive reasoning steps to achieve soundness. We achieve a similar effect by including substitution (which in our dualized setting plays, for purposes of coinductive proofs, an analo- gous role as congruence does in standard equational reasoning) as an axiom rather than a rule. As the proof calculus of op.cit. is purely inductive, no general com- pleteness result can be established; this is remedied in our setup by using a mixed inductive-coinductive calculus. Mixed inductive / coinductive definitions have been investigated in type theory (e.g. [1,6]), and it appears that the modulo-bisimulation calculus given here can be straightforwardly encoded, thus presenting another exam- ple of the usefulness of these definition principles. An approach that is structurally similar to ours has been put forward for equational reasoning over non-wellfounded terms [7] where coinduction is used to capture non-wellfoundedness, whereas our calculus derives equations between finite terms, and employs coinduction to char- acterize validity modulo bisimulation. Non-wellfounded calculi have also been used in [5,4] to formalize arguments by infinite descent for inductive definitions (rather than up-to bisimulation arguments) where proofs are finite, possibly cyclic graphs subject to an external well-formedness condition.

Preliminaries and Notation
Categorical Notions. We write + for (categorical) coproducts, and given f1,..., fn ∶ Ai → B we write [f1,..., fn] ∶ A1 + ⋅⋅⋅ + An → B for the induced co-tuple. For a set V we write V ⋅ A = ∐v∈V A for the V -th copower of A, injv ∶ A → V ⋅ A for the coproduct injection associated with v ∈ V , and (v, a) for the image injv (a) in the category of sets and functions. We identify every natural number n ∈ ω with the set of its predecessors, i.e. n = {0,...,n − 1}. In particular, inji ∶ A → n ⋅ A is the i-th coproduct injection for i ∈ n.
Algebraic Notions. A signature is a set Σ (of function symbols) equipped with a function ar ∶ Σ → ω assigning arities to operations. We say that f ∈ Σ is n-ary if ar(f ) = n. The set TΣV of Terms over Σ with variables in V is defined in the standard way. If t ∈ TΣ(V ) is a term, and f is unary, we often write f.t for f (t), and if t(x) is a term with a free variable x, we write t.x for t(x). A substitution is a mapping σ ∶ V → TΣ(V ); we write tσ for the result of simultaneously replacing every free variable x in a term t ∈ TΣ(V ) by σ(x).
Fixpoints. If M is a monotone operator on a complete lattice (we only consider lattices of subsets in this paper), we write μM or μX.M (X) for its least fixpoint, and νM , or νX.M (X) for its greatest fixpoint.

Comodels
A comodel of an equational theory T is a model of the Lawvere theory L induced by T in the opposite category Setop of the category Set of sets and functions. That

is, a comodel is a finite coproduct preserving functor Lop → Set. In the area of programming language semantics, comodels are one way to explain the meaning of programs that change state. Given an algebraic signature Σ, a comodel for Σ consists of a carrier set, say C, that we think of as a set of states, and a function Qf ¢ ∶ C → n⋅C for every n-ary function symbol f ∈ Σ. As a consequence, a unary function symbol f ∈ Σ is interpreted as a state-changing operation Qf ¢ ∶ C → C, whereas an n-ary function symbol g is an n-fold branching statement Qg¢ ∶ C → C +⋅ ⋅ ⋅+C = n⋅C, for n ≥ 1. That is, given a state c ∈ C, Qg¢ delivers a new state in one of n alternative branches. The presence of nullary function symbols (or constants) in a signature immediately implies that all comodels are empty, as constants are interpreted as functions C → 0 ⋅ C = ∅. In contrast to the evaluation of terms in universal algebra, the information flows from left to right when interpretation of terms over comodels. For example, when evaluating the term g(f (x), h(y)) over a given algebra A one first determines a0 = ⟦f (x)⟧ and a1 = ⟦h(y)⟧ ∈ A which then gives ⟦g(f (x), h(y))⟧ ∈ A by applying the interpretation of g to the pair (a0, a1). Interpreting the same term over a comodel C in state c ∈ C ﬁrst evaluates Qg¢(c) to give (i, c′)∈ 2 ⋅ C and then applies (the interpretation of) f (x) to c′ in case i = 0, or the interpretation of h(y) to c′ if c = 1. The following definitions make this formal.
Definition 3.1 A comodel for an algebraic signature Σ, or Σ-comodel for short, is a tuple (C, Q⋅¢) where C is a set, and Qf ¢ ∶ C → n ⋅ C is a function for all n-ary f ∈ Σ. Given a set V (of variables), every Σ-comodel engenders an interpretation of terms Q ⋅ ¢V ∶ TΣV → C → V ⋅ C by
Qv¢V = injv and Qf (t1,..., tn)¢V = [Qt1¢V ,..., Qtn¢V ]○ Qf ¢
where TΣV denotes the set of Σ-terms with variables in V . If clear from the context, we will elide the superscript V . A morphism of comodels (C, Q⋅¢C) and (D, Q⋅¢D) is a function h ∶ C → D that commutes with the interpretation of function symbols,
i.e. n ⋅ h ○ Qf ¢C = Qf ¢D ○ h for all n-ary f ∈ Σ.
A comodel (C, Q ⋅ ¢) satisﬁes an equation s = t, where s, t ∈ TΣV are terms over the set V of variables, if Qs¢V = Qt¢V , and if E is a set of equations, we say that (C, Q ⋅ ¢) is a Σ,E-comodel if it satisfies all equations in E.
A simple example of a comodel is the following one-bit memory cell that supports operations for reading and writing.
Example 3.2 Consider a one-bit memory cell, represented by comodels for the signature Σ = {rd, wr0, wr1} where wr0 and wr1 are unary and rd is binary. A comodel for Σ consists of a (state) set C and operations Qwr0¢, Qwr1¢ ∶ C → C that we interpret as writing 0 (resp. 1) to the memory cell, and an operation rd ∶ C → C + C that will branch into the left hand component of the coproduct if evaluated at a cell storing 0, and into the right hand component, otherwise. Note that reading the cell may in general change its state. To ensure the intended behaviour of the memory cell, we stipulate the equations
E = {wr0.rd(x, y)= wr0.x, wr1.rd(x, y)= wr1.y, rd(x, x)= x};

that is, the effect of reading a memory cell immediately after writing is completely determined by the bit written where the effect of writing to the cell is preserved, and reading the cell but ignoring the result is tantamount to doing nothing.
More examples of comodels and their theories, primarily concerned with state, can be found in [14,12].
As mentioned at the beginning of this section, comodels are usually presented as finite coproduct-preserving functors Lop → Set where L is a Lawvere theory. For the purposes of this paper, it is more convenient to work with comodels for equational theories, as the latter determine concrete syntax that can be manipulated in the equational calculi that we are about to give. The equivalence of comodels for a Lawvere theory, and Σ,E-comodels is not relevant for the remainder of the paper, but included to justify our terminology. Recall that the Lawvere theory induced by a signature Σ and a set E of equations between Σ-terms is the category L whose objects are the natural numbers, and whose morphisms Lop(n, m) = Kl(UF )(n, m) are the morphisms in the Kleisli category of the monad UF where U ∶ Alg(Σ,E)→ Set is the forgetful functor and F its left adjoint.
Proposition 3.3 Let E be a set of equations over a signature Σ. Then the category of Σ,E-comodels is isomorphic to the category of comodels for the Lawvere theory induced by Σ and E.
Soundness of equational reasoning over comodels is an immediate corollary.
Corollary 3.4 Let Σ be a signature and E a set of Σ-equations. If an equality s = t is derivable from E in (standard) equational logic, then Qs¢ = Qt¢ in every Σ,E-comodel (C, Q ⋅ ¢).
Labelled Tableau Equality On-The-Nose
We proceed to give a complete system for deriving equalities between comodel terms. The following example due to Power shows that the usual proof systems of equational logic in general fail to be complete over comodels, and the main contribution of this paper is a complete calculus.
Example 4.1 (i) Let Σ be a signature that contains a nullary function symbol c. As pointed out at the beginning of Section 3, the only Σ-comodel is (carried by) the empty set. Therefore, irrespective of the set E of equations, all equations are valid over Σ-comodels, but not all equations are derivable in general, e.g. for E = ∅.
(ii) Consider the theory given by a single, commutative binary operation, i.e. Σ =
{f } with f binary, and E = {f (x, y) = f (y, x)}. If C is a comodel for Σ and E, then necessarily C = ∅: otherwise we could pick c ∈ C, and supposing that Qf (x, y)¢(c) = injx(d) we would obtain injx(d) = Qf (x, y)¢(c) = Qf (y, x)¢(c) = injy (d) whence x = y for distinct variables x and y, contradiction. As the supposition Qf (x, y)(c) = injy (d) leads to a similar contradiction, we obtain C = ∅ and as a consequence, C satisfies s = t for all terms s, t ∈ TΣ(V ). But

clearly not all equations s = t are derivable from E in equational logic (keeping algebraists off the dole).
The complete system we are about to introduce manipulates labelled expressions of the form a.t = b.s where s, t are terms, and a, b are state variables, distinct from the variables from which we build terms. We interpret state variables a, b as elements of (the carrier of) the comodel, and read a.s = b.t as saying that the terms s and t have the same denotation (on the nose) if evaluated in state a and b, respectively, of a given comodel. Throughout the section, we fix a signature Σ comprising terms with associated arities, a countable set V of (term) variables, and a countable set Z of state variables, disjoint from V . We write T for the set of terms built from function symbols in Σ using the variables in V , FV(t) for the set of (free) variables occurring in t, and t(x1,..., xn) to indicate that FV(t)⊆ {x1,..., xn}.
Definition 4.2 A labelled term is a pair (a, t)∈ Z ×T , written a.t, where t is a term and a is a state variable. A labelled equation is a pair of labelled terms, written
a.s = b.t, with (free) state variables FS(a.s = b.t) = {a, b}. A (comodel) sequent is a pair, written Γ ⇒ A, where Γ is a set of labelled equations, and A is a labelled equation. We briefly write A for ∅ ⇒ A and extend the notion of (free) state variables to sets of equations and comodel sequents by FS(Γ) = ⋃{FS(A) ∣ A ∈ Γ} and FS(Γ ⇒ A) = FS(Γ)∪ FS(A). A valuation for a comodel (C, Q ⋅ ¢) is a function θ ∶ Z → C, and we write C, θ ⊧ a.s = b.t if Qs¢(θa) = Qt¢(θb); C, θ ⊧ Γ if C, θ ⊧ B for all B ∈ Γ; and C, θ ⊧ Γ ⇒ A if C, θ ⊧ Γ implies C, θ ⊧ A. Finally, if E is a set of (unlabelled) equations, E ⊧ Γ ⇒ A if C, θ ⊧ Γ ⇒ A for all comodel/valuation pairs C, θ where C satisfies all equations in E. A renaming is a function τ ∶ Z → Z, and we write (a.s = b.t)τ for τ (a).s = τ (b).t and Γτ for {Aτ ∣ A ∈ Γ}. Substitutions extend to labelled terms by (a.t)σ = a.tσ, to labelled equations by (a.t = b.s)σ = (a.tσ = a.sσ), and to sets of labelled equations by Γσ = {Aσ ∣ A ∈ Γ}.
We specifically do not require the antecedent Γ in a comodel sequent to be finite. In the calculus for equality on-the-nose, this enables us to speak about strong com- pleteness, and we will later need infinite sets of assumptions in the calculus for equality modulo bisimulation.
Remark 4.3 State variables could be internalized in the original term language. A state variable is essentially a unary function symbol that only appears at the head of a term. In particular, this overloads the dot-notation for the application of unary functions a.t = a(t) in a consistent way. All rules of the system we are about to introduce remain sound if we relax the interpretation of a state variable to be a unary function on states instead of a single state. (Completeness, proved later, transfers trivially to this more permissive semantics.) What distinguishes state variables from function symbols is that we have an infinite reservoir of state variables allowing us to pick fresh variables when necessary, as well as the possibility of renaming state variables.
As an equation s = t is satisfied by all Σ,E-comodels if and only if C, θ ⊧ a.s = a.t for all Σ,E-comodels C and valuations θ, it suffices to derive all valid comodel sequents.

The system that achieves this comprises the following rules. Substitution takes the form of an axiom
(subst)
Γ, a.s(x1,..., xn)= b.t(x1,..., xn)⇒ a.s(u1,..., un)= b.t(u1,..., un)
where u1,..., un ∈ TΣV are terms, and stipulates that given that a.s and b.t take the same branches and end up in the same poststates, the same will hold if we postcompose with identical terms. Via the identity substitution, this implies in particular that every equation in Γ is derivable.
The fact that every term r(x1,..., xn) evaluates to one of the alternatives x1,
..., xn is captured by the rule
(case){Γ, a.r(x1,..., xn)= b.xi ⇒ c.s = d.t ∣ 1 ≤ i ≤ n}(b ∉ FS(Γ ⇒ c.s = d.t)),
Γ ⇒ c.s = d.t
which employs similar mechanisms as disjunction elimination and existential elim- ination in natural deduction: to conclude c.s = d.t we have to derive c.s = d.t assuming each of the possible outputs xi of some labelled term a.r in turn, in each case giving a fresh name b to the poststate reached by a.r. We have a version of falsum-elimination (on the left) and a rule that asserts validity of all substitution instances of the axioms in E (on the right).


(disj)
Γ ⇒ a.s = b.t
Γ ⇒ c.u = d.v
(FV(s)∩ FV(t)= ∅)	(E)


Γ ⇒ a.sσ = a.tσ
(s = t ∈ E)

The falsum elimination rule (disj) (for disjoint ) reflects the fact that labelled terms
a.s and b.t that do not have any variable in common cannot be equal: if Qs¢(θa) = (x, α) and Qt¢(θb)= (y, β) with x ∈ FV(s), y ∈ FV(t) then x ≠ y as FV(s)∩FV(t)= ∅. From such an impossible equality, the rule therefore allows us to draw arbitrary conclusions c.u = d.v, in analogy to the classical ex-falso-quodlibet principle. Axiom
(E) simply asserts that all substitution instances of equations are valid. These rules are completed with the standard rules for equality


(sym)
Γ ⇒ a.s = b.t


Γ ⇒ b.t = a.s
(trans)
Γ ⇒ a.s = b.t	Γ ⇒ b.t = c.u


Γ ⇒ a.s = c.u
(ref)


Γ ⇒ a.t = a.t

ensuring symmetry, reflexivity and transitivity of equality, and the renaming rule


(ren)
Γ ⇒ A
Γτ ⇒ Aτ

as the only structural rule. We write E ⊢ Γ ⇒ A if Γ ⇒ A can be derived using the above rules.
Remark 4.4 As the antecedent Γ of a comodel sequent Γ ⇒ A may be infinite, an application of (case) could be blocked if Γ contains all state variables. The rule (ren) allows us to free a state variable that we can then use as a fresh variable in (case).

The next example revisits our examples of valid formulas not derivable in standard equational reasoning (Example 4.1), showing that the extended system does handle these examples.
Example 4.5  (i) If Σ contains a nullary function symbol, say n, we have E ⊢
a.n = a.n by (ref) and as FV(n) ∩ FV(n) = ∅ we obtain E ⊢ a.s = b.t for arbitrary labelled terms a.s and b.t using (disj).
(ii) Consider a commutative binary function f , that is,Σ = {f } and E = {f (x, y)= f (y, x)}. We show that E ⊢ c.s = d.t for all c, d ∈ Z and all s, t ∈ T . Let a ∈ Z be arbitrary and pick a fresh b ∈ Z, i.e. b ∉ {a, c, d}. Fix Γ1 = {a.f (x, y) = b.x}. We derive E ⊢ Γ1 ⇒ c.s = d.t, eliding the leading E ⊢, by

		

Γ1 ⇒ a.f (x, y)= b.x
Γ1 ⇒ b.x = a.f (x, y)
Γ1 ⇒ a.f (x, y)= a.f (y, x)	Γ1 ⇒ a.f (y, x)= b.y
Γ1 ⇒ a.f (x, y)= b.y
 Γ1 ⇒ b.x = b.y 
Γ1 ⇒ c.s = d.t

where the leftmost and rightmost leaves are by (subst) and we use (disj) in the last inference step. Taking Γ2 = {a.f (x, y) = b.y} we obtain E ⇒ c.s = d.t by a symmetric derivation. We conclude, expanding the definitions of Γ1 and Γ2,
a.f (x, y)= b.x ⇒ c.s = d.t	a.f (x, y)= b.y ⇒ c.s = d.t
c.s = d.t
using (case).
Soundness is proved by a standard induction over derivations.
Proposition 4.6 (Soundness) The above system is sound for equality on-the- nose over comodels, i.e. E ⊧ Γ ⇒ A whenever E ⊢ Γ ⇒ A.
The following technical preparations are needed for establishing completeness. We formulate substitution as an axiom rather than as a rule, as the substitution axiom (but not the substitution rule, see Remark 5.13) remains sound also for modulo- bisimulation reasoning. However, substitution as a rule is admissible.
Lemma 4.7 (Admissibility of the Substitution Rule) Suppose that E ⊢ Γ ⇒
a.s = b.t and let σ ∶ V → TΣ(V ) be a substitution. Then E ⊢ Γ ⇒ a.sσ = a.tσ.
Moreover, cut is admissible.
Lemma 4.8 (Cut Admissibility) Suppose that E ⊢ Γ ⇒ A and E ⊢ Γ,A ⇒ B. Then E ⊢ Γ ⇒ B.
Although not strictly necessary for the technical development, we show that entail- ment is also closed under substitution for state variables.
Lemma 4.9 Suppose that E ⊢ Γ ⇒ a.si = a.ti for i = 1,...,n and let a ∉ FS(Γ). Then E ⊢ Γ ⇒ c.u(s1,..., sn)= c.u(t1,..., tn) for all n-ary function symbols u ∈ Σ.
The completeness proof for the system is partly similar to the classical Henkin construction. We keep the set E of equations fixed throughout, and show that

every non-derivable sequent has a countermodel. Since sequents can be infinite, we add additional state variables to obtain a Lindenbaum lemma.
Notation 4.10 We fix a second denumerable set Z′ of state variables and call a state variable in Z ∪ Z′ an extended state variable. We call a labelled term a.s extended if a ∈ Z ∪ Z′, and standard if a ∈ Z. An extended labelled equation is a labelled equation between extended terms, and a labelled equation between standard terms is called standard. We write ⊢ext for derivability of extended labelled equations, and (continue to) write ⊢ for derivability of standard labelled equations.
We first establish that derivability in extended system is conservative. This is where we need renaming, as otherwise an application of (case)
Γ, a.s(x1,..., xn)= b.x1 ⇒ A	.. .	Γ, a.s(x1,..., xn)= b.xn ⇒ A
Γ ⇒ A
where b ∈ Z′ and Γ contains all state variables in Z couldn’t be translated back to the standard system. Conservativity follows from the following:
Lemma 4.11 Suppose that E⊢extΓ ⇒ A and τ ∶ Z ∪ Z′ → Z is a bijective renaming. Then E ⊢ Γτ ⇒ Aτ.
Corollary 4.12 (Conservativity) Suppose that E⊢extΓ ⇒ A and Γ,A are stan- dard. Then E ⊢ Γ ⇒ A.
The countermodel construction will be based on witnessed sets of labelled equations.
Definition 4.13 A set Γ of extended labelled equations is witnessed if for all ex- tended labelled terms a.s there exists a variable x ∈ V and an extended state variable b ∈ Z′ such that a.s = b.x ∈ Γ.
Lemma 4.14 (Lindenbaum lemma) Let Γ be a set of standard labelled equa- tions, and A be a standard labelled equation such that E ⊢/ Γ ⇒ A. Then Γ can be extended to a witnessed set Γˆ of (extended) labelled equations that is maximal with the property that E⊬extΓˆ ⇒ A.
Maximal sets are closed under derivation:
Lemma 4.15 (Derivability is containment) Let Γ be a set of (extended) la- belled equations that is maximal with respect to E⊬extΓ ⇒ c.s = d.t. Then E⊢extΓ ⇒ A iff A ∈ Γ.
We now construct a countermodel from a witnessed set of extended labelled se- quents as in the Lindenbaum lemma; the elements of the countermodel are equiv- alence classes of extended state variables. This construction is related to Henkin’s completeness proof of first-order logic.
Lemma 4.16 Let Γ be a witnessed set of labelled equations that is maximal with the property that E⊬extΓ ⇒ c.s = d.t. Then the following hold.
For all labelled terms a.u there exists a unique x ∈ FV(u) and a (not necessarily unique) b ∈ Z′ such that E⊢extΓ ⇒ a.u = b.x.

The relation ∼ on the set Z ∪ Z′ of extended state variables deﬁned by
a ∼ b	iff	E⊢extΓ ⇒ a.x = b.x for some x ∈ V
is an equivalence.
Putting Qf ¢[a]∼ = inji([b]∼) iff a.f (x1,..., xn) = b.xi ∈ Γ yields a well-deﬁned comodel structure on Z′/∼.
For all terms u and all a ∈ Z′ we have Qu¢[a]= (x, [b]) iff E⊢extΓ ⇒ a.u = b.x.
For the valuation θ(a)= [a] we have Z′/∼,θ ⊧ a.u = b.v iff E⊢extΓ ⇒ a.u = b.v.
The comodel Z′/∼ satisﬁes all equations in E.
The first three items are straightforward, and the fourth is by induction on u. The rule (case) is not used in the proof of Lemma 4.16; its role in the completeness proof is to enable the construction of witnessed sets, i.e. the Lindenbaum lemma. Completeness is an immediate consequence of the countermodel construction:
Corollary 4.17 (Completeness for reasoning on-the-nose) Comodel reason- ing is complete for on-the-nose equality over comodels, i.e. if E ⊧ Γ ⇒ a.s = b.t then E ⊢ Γ ⇒ a.s = b.t.
Labelled Tableaux for Equality modulo Bisimulation
We now extend the reasoning system for equality on-the-nose introduced in the previous section to a system for equational reasoning modulo bisimilarity. Consider the following example.
Example 5.1 Recall the signature Σ and equations E describing a one-bit memory cell, introduced in Example 3.2. We intuitively expect that a second write over- writes the first, i.e. the equations wra.wrb.x = wrb.x hold for a, b ∈ {0, 1}. However, a comodel may internally record additional information beyond the content of the cell, for example the number of times the cell has been written to. Consider, for example, C = {0, 1}× N with Qwra¢(c, n) = (a, n + 1) for a = 0, 1 and Qrd¢(c, n) = (c, (c, n)). Clearly Qwr0.wr0.x¢(0, n) = (0,n + 2) ≠ (0,n + 1) = Qwr0.x¢(0, n) for any n ∈ N so that E ⊧/ wr0.wr0.x = wr0.x. On the other hand, we cannot tell wr0.wr0.x and wr0.x apart by (repeatedly) applying operations to both and observing that they give rise to different alternatives, as they behave identically under rd.
This phenomenon of comodel states being different but observationally indistin- guishable is entirely standard, and captured by the established notion of bisimilar- ity. We explicitly instantiate this concept to the particular notation of comodels. For simplicity of notation, we work with bisimilarity on a single comodel; in the comodel setting, this is without loss of generality as bisimilarity across two models is the same as bisimilarity in their coproduct.
Definition 5.2 Let C be a Σ-comodel. A relation B ⊆ C × C is a comodel bisimu- lation if, for all (c, c′) ∈ B and all n-ary f ∈ Σ we have that Qf ¢(c)BnQf ¢(c′) where

Bn = {(i, c), (i, c′) ∣ cBc′ and 0 ≤ i < n}. We say that two comodel states c, c′ are
comodel bisimilar, and write c ≈ c′, if they are related by some comodel bisimulation.
For any two elements (c1, c2) to be bisimilar, they have to branch into the same al- ternative under any f ∈ Σ, producing elements that are again bisimilar. In Example
3.2 we obtain that two states are bisimilar if and only if they store the same bit.
Example 5.3 Let Σ and E be as in Example 3.2 above, and let C be a Σ-comodel
rd
that satisfies E. For c ∈ C and i ∈ {0, 1} we write c —→ i if there exists d ∈ C
such that Qrd¢ = (i, d), that is, c branches to the i-th alternative under rd. Then

the relation B defined by cBc′
rd
iff (c —→ i ⇐⇒ c
rd
—→ i for i = 0, 1) is a comodel

bisimulation: if cBc′ we need to establish that
Qwri¢(c)B1Qwri¢(c′) and Qrd¢(c)B2Qrd¢(c′)
for i = 0, 1. The left hand relationship follows from the equation wri.rd(x0, x1) = 
wri.xi, and the right hand relationship from the equation rd(x, x)= x.
It is clear that unions of comodel bisimulations are again comodel bisimulations, so that the largest bisimulation on a comodel always exists, and coincides with comodel bisimilarity. We can quotient comodels by bisimilarity:
Lemma and Definition 5.4 Let C be a Σ-comodel. Then bisimilarity ≈ is an equivalence relation on C, and putting
Qf ¢([c]≈)= inji([d]≈)	iff	Qf ¢(c)= inji(d)
yields a well-defined comodel structure on C/≈, the bisimulation quotient C/≈ of C.
Continuing Example 5.3 we obtain that the bisimulation quotient of any comodel satisfies the equation wra.wrb.x = wrb.x.
Example 5.5 Let C be a Σ-comodel that satisfies E where Σ and E are as in Example 3.2. Then B as described in Example 5.3 is easily seen to coincide with comodel bisimilarity ≈ on C. Hence, C/≈ ≅ {0, 1} with Qwr0¢(γ) = 0, Qwr1¢(γ) = 1 and Qrd¢(γ)= injγ (γ). In particular, C/≈⊧ wra.wrb.x = wrb.x for all a, b ∈ {0, 1}.
We now extend the labelled deduction system given in the previous paragraph to account for equality modulo comodel bisimulation. We formalize this semantically by replacing on-the-nose satisfaction of (labelled) equations in a comodel by satis- faction of (the same) equations in its bisimulation quotient.
Definition 5.6 Let C be a Σ-comodel and θ ∶ Z → C a valuation. We write C, θ ∣≈ a.s = b.t if C/≈, θˆ ⊧ a.s = b.t where θˆ(a) = [a]≈ (and C/≈ is the bisimulation quotient of C). This extends to comodel sequents so that C, θ ∣≈ Γ ⇒ A iff C, θ ∣≈ A
whenever C, θ ∣≈ B for all B ∈ Γ. We say that a comodel sequent is valid up to
bisimilarity in the class of all comodels that satisfy E up to bisimilarity, in symbols
E ∣≈ Γ ⇒ A, if (C, θ) ∣≈ Γ ⇒ A whenever C/≈ is a Σ,E-comodel and θ is a valuation.

We now extend the derivation system E ⊢ to a derivation system E ∣∼ on comodel sequents to capture validity of equations modulo bisimulation. The ensuing system is a mixed inductive/coinductive proof system where the rules of E ⊢ may be applied inductively, and the following bisimulation rule
(bisim){Γ ⇒ a.f (x1,..., xn)= b.f (x1,..., xn)∣ n ∈ N, f ∈ Σ n-ary}
Γ ⇒ a.x = b.x
is applied coinductively. Formally, we partition the set of rules into
inductive rules comprising (subst), (case), (disj), (sym), (ref), (trans), (ren) and
(E) and say that Γ ⇒ A is an inductive consequence of a set I of comodel sequents if it is the conclusion of an inductive rule with premises in I, and
one coinductive rule (bisim), and say that Γ ⇒ A is a coinductive consequence of a set C of comodel sequents if it is a conclusion of (bisim) with premises in C.
We write Ind(I) and Coind(C) for the set of inductive / coinductive consequences of sets I and C of comodel sequents, respectively. We then take behavioural derivability E ∣∼⊆ S to be the mixed fixpoint
E ∣∼ = νC. μI. (Ind(I)∪ Coind(C))
where we write E ∣∼ Γ ⇒ A if (Γ ⇒ A) ∈ E ∣∼. That is, a sequent is behaviourally derivable if it is the conclusion of a possibly non-wellfounded derivation where the rule (bisim) can be applied infinitely often. The formulation of the proof system as a mixed fixpoint, with an inner inductive part, ensures that the inductive rules are only applied finitely many times between two successive instances of (bisim).
The soundness of the ensuing system is now no longer a simple matter of in- duction on derivations. Instead, we establish soundness in a step-by-step fashion using iterative approximations of behavioural derivability on the syntactic side, and iterative approximations of bisimilarity on the semantic side.
Notation 5.7 Let S be the set of comodel sequents, and consider the monotone operator W ∶ P(S)→ P(S), defined by
W (C)= μI.(Ind(I)∪ Coind(C))
and let ∣∼0= P(S) and ∣∼n+1= W (∣∼n). We say that Γ ⇒ A is n-step derivable if
∣∼n Γ ⇒ A. Similarly, for a comodel C, consider the monotone operator WC ∶ P(V ⋅ C × V ⋅ C)→ P(V ⋅ C × V ⋅ C) defined by
WC(R)= {(x, c), (x, c′)∣ Qf (x1,..., xn)¢(c)RQf (x1,..., xn)¢(c′)for all f ∈ Σ}
for R ⊆ V ⋅C ×V ⋅C, and let R0 = (V ⋅C)2 and Rn+1 = W (Rn). We say that (v, c) and (v′, c′) are n-step bisimilar if (v, c)Rn(v′, c′). If C is a comodel for Σ and Γ ⇒ A is a comodel sequent, we say that C, θ ∣≈n a.s = b.t if Qa.s¢RnQb.t¢, and C, θ ∣≈n Γ ⇒ A if C, θ ∣≈n A whenever C, θ ∣≈ Γ (we explicitly require C, θ ∣≈ Γ, not just C, θ ∣≈n Γ). We say that Γ ⇒ A is n-step valid, and write E ∣≈n Γ ⇒ A, if C, θ ∣≈n Γ ⇒ A for all Σ,E-comodels C and all valuations θ.

This allows us to show soundness by establishing that n-step derivability implies
n-step validity. Bisimilarity is exhaustively approximated by n-step bisimilarity:
Lemma 5.8 For states c, c′ in a Σ-comodel C, c ≈ c′ if and only if (x, c)Rn(x, c′)
for all n ∈ N and all x ∈ V .
It follows immediately that ∣≈ is exhaustively approximated by the ∣≈n:
Lemma 5.9 We have that E ∣≈ = ⋂n∈N E ∣≈n.
For behavioural derivability, one inclusion suffices.
Lemma 5.10 We have that E ∣∼ ⊆ ⋂n∈N E ∣∼n.
The following is the key to soundness of behavioural derivability.
Lemma 5.11 Let n ∈ N and let Γ ⇒ A be a comodel sequent. Then E ∣∼n Γ ⇒ A
implies that E ∣≈n Γ ⇒ A.
Proposition 5.12 Let E be a set of Σ-equations. Then behavioural derivability is sound, i.e. E ∣≈ Γ ⇒ A whenever E ∣∼ Γ ⇒ A.
Proof. Let E ∣∼ Γ ⇒ A. By Lemma 5.10, E ∣∼n Γ ⇒ A for all n, so by Lemma 5.11,
E ∣≈n Γ ⇒ A for all n. By Lemma 5.9, it follows that E ∣≈ Γ ⇒ A	◻
Remark 5.13 The key to soundness, i.e. to Lemma 5.11, is that the substitution axioms (subst) are sound for ∣≈n; the point is that ∣≈n requires the left-hand sides of comodel sequents to hold up to ≈ and not just up to ≈n. In contrast, the substitution rule
(subst′) Γ ⇒ a.s(x1,..., xn)= b.t(x1,..., xn)
Γ ⇒ a.s(u1,..., un)= b.t(u1,..., un)
is sound for ⊧ and ∣≈ but not for ∣≈n. And indeed, including this rule in the proof system for behavioural derivability is clearly unsound, as the following derivation (for Σ = {f1,..., fk})would establish a.x = b.x for arbitrary a, b ∈ Z where —→x is a tuple of variables according to the arity of the preceding function symbol,

(∞)  (subst′) 	a.x = b.x	
a.f1(—→x )= b.f1(—→x )
(∞)

⋯	(subst′) 	a.x = b.x	
a.fk(—→x )= b.fk(—→x )

(bisim)	a.x = b.x
and (∞) indicates a coinductive repeat of the derivation. This would be a legal derivation in the inductive/coinductive format, as it uses only finitely many induc- tive rules between successive applications of (bisim); but of course a.x = b.x should not be derivable for arbitrary a, b.
For completeness, we need to show that the sequents Γ ⇒ A with E ∣≈ Γ ⇒ A are contained in the greatest fixpoint νC.μI.(Ind(I)∪ Coind(C)). If V = {Γ ⇒ A ∣ E ∣≈ Γ ⇒ A} are the comodel sequents that are universally valid modulo bisimulation, this follows (using Knaster-Tarski) if V ⊆ μI.(Ind(I) ∪ Coind(V )), that is, every (Γ ⇒ A)∈ V is inductively derivable from Coind(V ). We follow the same approach

as for completeness on-the-nose and use an additional, countable set of Henkin- constants.
Notation 5.14 As in 4.10, extend the set Z of state variables by a second, count- able set Z′ and consider labelled terms of the form a.t where a ∈ Z∪Z′ and t ∈ TΣ(V ). As before, we call a labelled term (equation, set of equations) standard if they only mention state variables in Z, and extended otherwise.
We write S = {Γ ⇒ A ∣ Γ ⇒ A standard,E ∣≈ Γ ⇒ A} and X = {Γ ⇒ A ∣ Γ ⇒ A extended,E ∣≈ Γ ⇒ A} for the set of standard (resp. extended) comodel sequents that are universally valid modulo bisimulation. Finally, E ⊢S= μI.Ind(I)∪Coind(S) is inductive entailment of standard labelled sequents from Coind(S), and E⊢extX = μI.Ind(I)∪ Coind(X) is inductive derivability of extended labelled sequents from Coind(X).
Using this notation, our proof strategy indicated above is formalized as follows.
Fact 5.15 We have that (E ∣∼ Γ ⇒ A whenever ∣≈ Γ ⇒ A) if S ⊆ μI.(Ind(I) ∪ 
Coind(S)).
That is, to show completeness for the mixed inductive/coinductive system, we have to show completeness for a modified inductive system where we may use Coind(S) as additional assumptions. We proceed as for equality-on-the nose, and re-visit the key lemmas.
Lemma 5.16 Suppose E⊢extX Γ ⇒ A and τ ∶ Z ∪ Z′ → Z is a bijective renaming. Then E ⊢S Γτ ⇒ Aτ.
The proof of Corollary 4.12 translates directly to this new setting and we have:
Corollary 5.17 Suppose that E⊢extX Γ ⇒ A and both Γ and A are standard. Then
E ⊢S Γ ⇒ A.
Using the model construction of Lemma 4.16, we obtain the following.
Lemma 5.18 Suppose that E ⊢/S Γ ⇒ c.s = d.t. Then there exists a witnessed set Γˆ of (extended) labelled equations that is maximal with the property E⊬extX Γˆ ⇒ c.s =
d.t and a comodel structure on Z′/∼ where a ∼ b iff a.x = b.x ∈ Γ for some x ∈ V and a valuation θ deﬁned by θ(a)= [a]∼ such that
Z/∼,θ ⊧ a.s = b.t iff a.s = b.t ∈ Γˆ and Z′/∼,θ ∣≈/ c.s = d.t
If B is a comodel bisimulation on Z/∼ then cBc′ implies that c = c′
The key step to showing that the model Z/∼ only admits the diagonal as a bisimula- tion is to show that any equation A valid in Z/∼ is in fact a behavioural consequence of Γˆ, that is, Γˆ ⇒ A is universally valid modulo bisimulation. This allows us to make use of the additional assumptions, i.e. the coinductive consequences of universally
valid sequents, to establish that A actually holds on-the-nose in Z/∼. From the above, completeness is immediate:
Corollary 5.19 (Completeness modulo bisimulation) Suppose that E ∣≈ Γ ⇒
A. Then E ∣∼ Γ ⇒ A.

Recall from Example 5.5 that E ∣≈ a.wri.wrj.x = b.wri.x under the axiomatization E
defined in Example 3.2. We give an example derivation of this equation.
Example 5.20 Let Σ and E be as in Example 3.2. For α = a0 ... an ∈ {0, 1}+ we write wrα for wra0 ... wran and wrαi stands for wrα.wri. We show, generalizing the original goal, that E ∣∼ a.wrαi.x = b.wrβi.x for all α, β ∈ {0, 1}∗, all i = 0, 1, and all a, b ∈ Z. First note that for substitutions σ and τ , the rule
Γ, a.s = c.u, b.t = d.v ⇒ a.sσ = b.tτ

(†)


Γ, a.s = c.u, b.t = d.v ⇒ c.uσ = d.vτ

is derivable using (subst), (sym) and (trans). We first show that E ⊢ Γ ⇒ a.wrαi.rd(x0, x1) = a.wrαi.xi for i = 0, 1 and all sets Γ of comodel sequents (gen- erally, one can, of course, show that weakening is admissible and then restrict to Γ = ∅), in the derivation D

Γ, a.wrα.x = c.x ⇒ c.wri.rd(x0, x1)= c.wri.xi
Γ, a.wrα.x = c.x ⇒ a.wrαi.rd(x0, x1)= a.wrαi.xi
Γ ⇒ a.wrαi.rd(x0, x1)= a.wrαi.xi
using (E), (†) and (case). We now demonstrate that Γ ⇒ a.wrαi.rd(x0, x1) = b.wrβi.rd(x0, x1) is inductively derivable from Γ ⇒ a.wrαi.xi = b.wrβi.xi. Building on D and a variant D′ obtained by replacing a with b, this is achieved, using symmetry and transitivity, by the derivation E,



(D)


Γ ⇒ a.wrαi.rd(x0, x1) = a.wrαi.xi	Γ ⇒ a.wrαi.xi = b.wrβi.xi
Γ ⇒ a.wrαi.xi = b.wrβi.xi


(D′)


Γ ⇒ b.wrβi.rd(x0, x1) = b.wrβi.xi
Γ ⇒ b.wrβi.xi = b.wrβi.rd(x0, x1)

Γ ⇒ a.wrαi.rd(x0, x1) = b.wrβj .rd(x0, x1)
We finally show that Γ ⇒ a.wrαi.x = b.wrβi.x is behaviourally derivable, writing Γ1 = Γ, a.wrαi.x = c.x	and	Γ2 = Γ1, b.wrβi.x = d.x
to ease notation. If c, d ∉ FS(Γ), we have the following derivation where (∞) indi- cates a coinductive repeat of the same derivation with evident modifications.
(∞)
Γ2 ⇒ a.wrαi.xi = b.wrβi.xi

(E)

(∞)
Γ2 ⇒ c.wr0.x0 = d.wr0.x0
(∞)


Γ2 ⇒ c.wr1.x0 = d.wr1.x0
Γ2 ⇒ c.x = d.x
Γ2 ⇒ a.wrαi = b.wrβi.x
Γ1 ⇒ a.wrαi = b.wrβi.x
Γ ⇒ a.wrαi = b.wrβi.x


Γ2 ⇒ a.wrαi.rd(x0, x1) = b.wrβi.rd(x, y)
Γ2 ⇒ c.rd(x0, x1) = d.rd(x0, x1)

The ternary inference is (bisim), followed by (†) and (case) (twice). This last proof is an infinite derivation where (bisim) is used infinitely often, but only a finite number of applications of the inductive rules are used between two successive applications of (bisim); that is, it fits our inductive/coinductive format. Thus, E ∣∼ Γ ⇒ a.wrαi.x = b.wrβi.x.

Generally, the way one will apply the inductive/coinductive calculus will be to identify a putative postfixed point, i.e. a set W of comodel sequents, and then show in an inductive proof that W can be derived from its coinductive consequences, i.e. that W ⊆ μI. (Ind(I) ∪ Coind(W )). We have treated this principle informally in the above example; formally, we show in the example that the set W of labelled sequents Γ ⇒ a.wrαi.x = b.wrβi.x, where Γ is any set of labelled equations, a, b ∈ Z, and αi, βi ∈ {0, 1}+, is a postfixpoint.
Conclusions
We have given an inductive calculus for on-the-nose equational reasoning over co- models, and a mixed coinductive/inductive calculus for equational reasoning modulo bisimulation. We have done this in a bare bones setup without parametrized op- erations, e.g. using n write operations wr0,..., wrn−1 to modify memory cells that can store n distinct values, or one print operation for every character in a given character set. Similarly, reading (a character or memory location) is expressed by a function of arity equal to the number of alternatives. One natural extension would therefore be to include parametrized operations. An orthogonal direction of fu- ture research is to automate comodel reasoning in the style of the CIRC theorem prover [10]. This requires bisimulations to be either finite, or at least sufficiently well-structured to be analysed automatically. A second topic is to use complete reasoning over comodels to bridge between the operational/denotational and the axiomatic semantics of stateful programs.

References
A. Abel. Mixed inductive/coinductive types and strong normalization. Asian Symposium on Programming Languages and Systems, APLAS 2007, LNCS, vol. 4807, pp. 286–301. Springer, 2007.
F. Abou-Saleh and D. Pattinson. Comodels and effects in mathematical operational semantics. Foundations of Software Science and Computations Structures, FoSSaCS 2013, LNCS, vol. 7794, pp. 129–144. Springer, 2013.
F. Borceux. Handbook of Categorical Algebra. Cambridge University Press, 1994.
J. Brotherston, N. Gorogiannis, and R. L. Petersen. A generic cyclic theorem prover. Asian Symposium on Programming Languages and Systems, APLAS 2012, LNCS, vol. 7705, pp. 350–367. Springer, 2012.
J. Brotherston and A. Simpson. Complete sequent calculi for induction and infinite descent. Logic in Computer Science, LICS 2007, pp. 51–62. IEEE Computer Society, 2007.
N. Danielsson and T. Altenkirch. Mixing induction and coinduction. http://www.cse.chalmers.se/
~nad/publications/danielsson-altenkirch-mixing.html, 2009. Unpublished manuscript.
J. Endrullis, H. H. Hansen, D. Hendriks, A. Polonsky, and A. Silva. A coinductive treatment of infinitary rewriting. CoRR, abs/1306.6224, 2013.
S. Kerkhoff. A general duality theory for clones. Int. J. Alg. Comput., 23(3):457–502, 2013.
S. Kerkhoff. Dualizing clones as models of lawvere theories. Algebraic Complexity Theory, WACT 2013, ENTCS, vol. 303, pp. 79105. Elsevier, 2014
D. Lucanu, E. Goriac, G. Caltais, and G. Rosu. CIRC: A behavioral verification tool based on circular coinduction. Algebra and Coalgebra in Computer Science, CALCO 2009, LNCS, vol. 5728, pp. 433–442. Springer, 2009.
R. Møgelberg and S. Staton. Linear usage of state. Log. Meth. Comput. Sci. 10, 2014.


G. Plotkin and J. Power. Tensors of comodels and models for operational semantics. In Mathematical Foundations of Programming Semantics, MFPS 2008, ENTCS, vol. 218, pp. 295–311. Elsevier, 2008.
G. Plotkin. Adequacy for algebraic effects with state. Algebra and Coalgebra in Computer Science, CALCO 2005, LNCS, vol. 3629, p. 51. Springer, 2005.
J. Power and O. Shkaravska. From comodels to coalgebras: State and arrays. Coalgebraic Methods in Computer Science, CMCS 2004, ENTCS, vol. 106, pp. 297–314. Elsevier, 2004.
J. Power. Semantics for local computational effects. Mathematical Foundations of Programming Semantics, MFPS 2006, ENTCS, vol. 158, pp. 355–371. Elsevier, 2006.
G. Rosu and D. Lucanu. Circular coinduction: A proof theoretical foundation. Algebra and Coalgebra in Computer Science, CALCO 2009, LNCS, vol. 5728, pp. 127–144. Springer, 2009.
