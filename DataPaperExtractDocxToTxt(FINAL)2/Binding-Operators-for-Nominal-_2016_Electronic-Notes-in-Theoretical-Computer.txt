Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 325 (2016) 3–27
www.elsevier.com/locate/entcs
Binding Operators for Nominal Sets
Arthur Azevedo de Amorim1
Department of Computer and Information Science University of Pennsylvania
Philadelphia, PA, United States

Abstract
The theory of nominal sets is a rich mathematical framework for studying syntax and variable binding. Within it, we can describe several binding disciplines and derive convenient reasoning principles that respect α-equivalence. In this article, we introduce the notion of binding operator, a novel construction on nominal sets that unifies and generalizes many forms of binding proposed in the literature. We present general results about these operators, including sufficient conditions for validly using them in inductive definitions of nominal sets.
Keywords: Nominal Sets, Binding, Alpha Equivalence


Introduction
Bound variables have puzzled computer scientists and logicians for decades. Al- though fairly simple to handle in informal pencil-and-paper calculations, they can be surprisingly complex to manage in algorithms and mechanized proofs, where the mostly uninteresting formal details of variable binding cannot be overlooked. Research on the subject has led to various promising approaches for tackling this complexity [6,12,14], among which we can mention the theory of nominal sets [5].
Nominal sets constitute a rich mathematical universe where objects contain vari- ables that can be renamed, allowing various notions of α-equivalence to be defined. In the λ-calculus for example, we stipulate that the term λx. t is equivalent to any other obtained by renaming x to a variable y that does not appear free in t, which corresponds to the operation of name abstraction on nominal sets [5], used for mod- eling objects with a single bound variable. The nominal literature has shown how many other forms of binding can be obtained through similar constructions, such

1 The author thanks Andrew Pitts, Ranald Clouston, and Matthew Weaver for comments on early drafts of this article. This work is supported by NSF award 1513854, Micro-Policies: A Framework for Tag-Based Security Monitors.

http://dx.doi.org/10.1016/j.entcs.2016.09.029
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

as generalized name abstractions [4,3], or the binding declarations of Nominal Is- abelle [17]. Besides serving as a good theoretical foundation for variable binding, nominal techniques have influenced the design of many tools for manipulating syn- tax, such as the FreshML programming language [11,15] and the Nominal package for Isabelle/HOL [16,17].
Although some of the notions above are more general than others, none of them proposes to offer a clear, unified picture of what binding means for nominal sets. In this article, we attempt to look at the problem from a more foundational per- spective, by introducing binding operators: a novel construction on nominal sets that unifies and generalizes many forms of variable binding proposed in the liter- ature. After briefly recalling basic notions of nominal set theory (Section 2), we introduce binding operators in Section 3, showing how to use them for defining a variety of nominal sets representing binders in Section 4. Section 5 gives an al- ternative characterization of these nominal sets defined by binding operators, used in Section 6 to encompass variable scope within our framework. In Section 7, we discuss category-theoretic properties of binding operators, which provide sufficient conditions for defining nominal sets inductively. We conclude and review related work in Section 8.
Preliminaries: Nominal Sets
We begin by recalling basic concepts and results of the theory of nominal sets; for a detailed account on the subject, we refer the reader to the introductory article by Gabbay and Pitts [5] or to Pitts’ book [10].
We fix some countably infinite set A. We refer to elements of A as atoms, and use the variable a to denote them. A permutation of A is a bijective function π : A → A such that π(a)= a for all but finitely many a ∈ A. Permutations form a group under composition, noted perm(A); in particular, π ◦ πj ∈ perm(A) and π—1 ∈ perm(A) for every π, πj ∈ perm(A).
A renaming operation on a set X is a group action of perm(A) on X. Spelled out explicitly, this means a mapping that to each pair (π, x) ∈ perm(A) × X associates an element π · x ∈ X, so that
1 · x = x	(π1 ◦ π2) · x = π1 · π2 · x,
where 1 ∈ perm(A) denotes the identity function. We treat renaming as right associative, reading π1 · π2 · x as π1 · (π2 · x). The above properties imply in particular π—1 · π · x = π · π—1 · x = x for arbitrary π and x.
We say that a set of atoms A supports an element x ∈ X if the atoms in A completely determine the effect of renaming on x. Formally, if π is a permutation such that π(a)= a for every a in A, then π · x = x. Or, equivalently, if π1 and π2 are permutations such that π1(a)= π2(a) for every a in A, then π1 · x = π2 · x. If A is finite, we can show [5] that x has a minimal finite supporting set supp(x), by which we mean that supp(x) is a subset of every finite set Aj supporting x. We say that X is a nominal set if all of its elements have finite support.

Atoms A form a nominal set under the action π · a = π(a), with supp(a) = 
{a}. We can see every set X as a trivial nominal set by posing π · x = x, which implies supp(x)= ∅. We use this structure for sets such as N or Z, whose elements intuitively do not contain variables. A nominal set with such a trivial renaming operation is called discrete. We can also define products and disjoint unions of nominal sets, summarized in the table below.

When working with nominal sets, we want to restrict our attention to functions that are well-behaved with respect to renaming. A function f : X → Y between nominal sets is said to be equivariant if it commutes with renaming; that is, f (π·x)= π · f (x) for every x and π. We write X →eq Y for the set of equivariant functions from X to Y . When Y is the discrete nominal set of booleans B, we sometimes say that f is an equivariant property or relation instead. This is equivalent to saying that f (π· x) holds if and only if f (x) does. Every such property can be alternatively seen as a nominal subset of X; that is, a subset of X that is closed under renaming. Note that equivariant functions cannot add atoms to the support of their arguments: we can show that supp(f (x)) ⊆ supp(x), with supp(f (x)) = supp(x) if f is injective. The next best thing to an equivariant function is a ﬁnitely supported one: a function f between nominal sets X and Y that is almost equivariant, except for a finite set of atoms A; that is, f (π · x) = π · f (x) if π(a) = a for every a ∈ A.
We write X →fs Y for the set of finitely supported functions from X to Y . Every
equivariant function is trivially finitely supported. Finitely supported functions f form a nominal set under the action (π · f )(x)= π · f (π—1 · x). This is equivalent to saying that (π · f )(π · x)= π · f (x) for every π and x, which allows us to depict this renaming operation as acting on a table representation of f :

x1 '→ f (x1)
x2 '→ f (x2)	π
.
π · x1 '→ π · f (x1) π · x2 '→ π · f (x2)
.

Note that the support of a function is not computable in general. We use similar actions for other sets of functions; for instance, perm(A) is a nominal set under the action π·πj = π◦πj ◦π—1, with supp(π)= {a | π(a) /= a}. Seeing a subset Xj ⊆ X as a function X → B results in a renaming operation defined by π·Xj = {π·x | x ∈ Xj}. Let X and Y be two nominal sets, and x and y be elements of X and Y . We say that x and y are fresh with respect to each other, noted x # y, if their supports are disjoint: supp(x) ∩ supp(y)= ∅. If a ∈ A and x ∈ X, then a # x simply means that a ∈/ supp(x). If π ∈ perm(A), π # x is equivalent to π(a)= a for every a ∈ supp(x), which implies π · x = x. In particular, if f is a finitely supported function, π # f
implies f (π · x)= π · f (x) for every x.
Nominal sets and equivariant functions between them form a category Nom.

It is a complete and cocomplete category; in particular, the initial and terminal objects are the empty and singleton discrete nominal sets, while binary products and sums are given as in the above table. It is also a cartesian closed category, with exponentials given by finitely supported functions.
Binding Operators
The most basic form of binding on nominal sets is name abstraction [5]. Given a nominal set X, we define an equivalence relation ≡α on A × X by saying that (a1, x1) ≡α (a2, x2) if and only if
∃a3. a3 # (a1, a2, x1, x2) ∧ (a1 a3) · x1 = (a2 a3) · x2	(1)
Here, (a aj) denotes the transposition of a and aj, which swaps these two atoms while fixing all others. Intuitively, this relation states that a is bound in the pair (a, x) and should be treated up to α-equivalence. If we quotient A × X by this relation, we obtain a new nominal set [A]X, called the set of name abstractions of X, where α-equivalent objects become equal.
Besides name abstraction, we can define nominal sets for representing many other binding disciplines, such as name restriction or ML’s let rec. A common feature of these constructions is that equivalent elements are obtained by renaming bound atoms while fixing those that remain free. For instance, although not immediately obvious, we can rephrase (1) as
(a1, x1) ≡α (a2, x2) ⇐⇒ ∃π. π # supp(x1) \ {a1}∧ (a2, x2)= π · (a1, x1).  (2) Recall that π # supp(x1)\{a1} simply means that π fixes all elements of that set.
If we interpret the singleton {a1} in this formula as the set of bound variables of the
pair (a1, x1), we get a generic method for defining α-equivalence for other binders: it suffices to enumerate which atoms should be bound in an object. Formally, we have the following definition.
Definition 3.1 Let X be a nominal set. A binding operator on X is an equivariant function l : X →eq Pfin(A). Each l gives rise to a relation ≡l on X, defined as
x1 ≡l x2 ⇐⇒ ∃π. π # supp(x1) \ l(x1) ∧ x2 = π · x1.

Thus, we see that α-equivalence for name abstractions corresponds to a binding operator on A × X, defined as lα(a, x) = {a}. We analyze other examples in Section 4, but need to explain first how exactly binding operators are used to encode binders as nominal sets. Concretely, we show here that every binding operator induces a quotient nominal set, a direct generalization of the analogous results for name abstractions. We begin by noting the following simple facts.
Lemma 3.2 Let X be a nominal set with a binding operator l. If x1 ≡l x2, then
supp(x1) \ l(x1)= supp(x2) \ l(x2).

Proof The definition implies that x2 is of the form π· x1, with π # supp(x1) \l(x1); thus, π·(supp(x1)\l(x1)) = supp(x1)\l(x1). The result then follows by equivariance, since the right-hand side is equal to supp(π·x1)\l(π·x1)= (π·supp(x1))\(π·l(x1)) = π · (supp(x1) \ l(x1)).	2
Lemma 3.3 Let X be a nominal set endowed with a binding operator l. The ≡l
relation is an equivariant equivalence relation.
Proof The relation is clearly reflexive: it suffices to take π = 1 in its definition. It is also equivariant, because it is defined with equivariant operations.
To see that it is symmetric, take two elements x and xj of X such that x ≡l xj. By definition, we can find π ∈ perm(A) such that π # supp(x) \ l(x) and xj = π · x.
We must show that π · x ≡l x. Since x = π—1 · π · x, it suffices to show that
π—1 # supp(π · x) \ l(π · x),
which holds by equivariance, because π—1 = π · π—1 = π ◦ π—1 ◦ π—1.
Finally, let’s show transitivity. Take three elements, x1, x2 and x3, such that x1 ≡l x2 and x2 ≡l x3. By unfolding definitions, and using Lemma 3.2, we find π1 and π2 such that x3 = (π2 ◦ π1) · x1 and πi # (supp(x1) \ l(x1)) for i = 1, 2. Since permutation composition is equivariant, we see that supp(π2 ◦ π1) ⊆ supp(π1) ∪ supp(π2); thus, the freshness conditions above yield π2 ◦ π1 # supp(x1) \ l(x1), allowing us to conclude.	2
Because binding operators yield equivariant equivalence relations, they lead to quotients that carry a canonical nominal structure:
Lemma 3.4 Let X be a nominal set with a binding operator l, and let X/l be the quotient of X by the equivalence relation ≡l. This set possesses a nominal structure satisfying
π · [x]= [π · x]	supp([x]) = supp(x) \ l(x),
where [x] denotes the equivalence class of x under ≡l. In particular, the canonical projection into X/l is equivariant.
Proof Any quotient by an equivariant equivalence relation carries a canonical nom- inal structure satisfying the first identity [10, Sections 1.8 and 2.9]. We also have [10, Proposition 2.30]

supp([x]) =
x′≡lx
By Lemma 3.2, the right-hand side equals
supp(xj).	(3)

supp(x) \ l(x) ∪
x′≡lx
l(xj).

We can conclude because the second term of the union is empty. More precisely, given any atom a in l(x), and any atom aj that is not in supp(x), we have (a aj)·x ≡l x, but a = (a aj) · aj is not in l((a aj) · x) by equivariance.	2

As a sanity check, if we instantiate the previous result with lα, the binding operator for name abstractions, we obtain the familiar identities π·⟨a⟩x = ⟨π(a)⟩(π· x) and supp(⟨a⟩x) = supp(x) \ {a}, where ⟨a⟩x denotes the equivalence class of the pair (a, x) in [A]X. By virtue of being defined as a quotient, we also obtain generic elimination principles for such nominal sets. Equivariant functions on them have a particularly simple characterization: they correspond to functions that do not leak bound atoms in their results.

Lemma 3.5 Let X and Y be nominal sets, and l be a binding operator on X. Let f : X →eq Y be a function satisfying l(x) # f (x) for all x. There exists a unique f¯ : X/l →eq Y such that f¯([x]) = f (x) for all x. Conversely, every function
f : X →eq Y that factors through X/l satisﬁes l(x)# f (x).

Proof To build f¯, it suffices to show that, for every x1 ≡l x2, we have f (x1) = f (x2). By the definition of ≡l, we find a permutation π that is fresh for supp(x1) \ l(x1) such that x2 = π · x1. Thus, f (x2)= π · f (x1). Since l(x1)# f (x1), it must
be the case that supp(f (x1)) ⊆ supp(x1) \ l(x1). This implies that π # f (x1), and thus f (x1)= π · f (x1)= f (x2). The last assertion follows because, if f (x)= f¯([x]) for some equivariant function f¯, then supp(f (x)) is contained in supp([x]), which equals supp(x) \ l(x).	2
Later, in Lemma 6.14, we extend this result to describe the finitely supported functions that can be defined on such quotients. It would be possible (and not too difficult) to state this extension right away and prove it directly, but the tools developed in Section 6 provide more structure for attacking the problem.
Notice that the above properties only rely on knowing which atoms are bound in an object, and how these atoms are affected by renaming. This is indeed the only piece of information that we can extract from binding operators, which hide everything else that we might care about in bound atoms—for instance, the order in which they appear. Fortunately, as shown in the rest of this paper, this extra in- formation is irrelevant for deriving the fundamental properties of binding constructs in nominal sets.
Examples
Given the generality of binding operators, it is worth analyzing a few examples of binding disciplines that they can express. We show here how to model a few syntactic constructs that have been extensively studied in the literature. We include an example of common idiom that is not directly supported by our framework— namely, binding atoms in only part of an object. Fortunately, as shown in Section 6, this limitation is not fundamental, and can be overcome by adding a notion of scope to binding operators.

Generalized Name Abstraction
Name abstraction binds a single atom within an object. The simplest way to gen- eralize it is to consider constructions where bound atoms are specified by arbitrary data structures that contain atoms, leading to so-called generalized name abstrac- tions [4]. Specifically, given nominal sets X and Y , we adapt the binding operator lα defining name abstraction to X × Y , by setting lα(x, y) = supp(x). The corre- sponding quotient, noted [X]Y , is known as the nominal set of X-abstractions of Y .
Name Restriction
Processes in the π-calculus [8] communicate through named channels, which can be made private using a form of binding known as name restriction. Concretely, an expression of the form νa. t denotes a computation t that has access to a communi- cation channel a bound by ν, which cannot be used by any other processes defined outside of this expression.
Besides being subject to α-equivalence of bound channel names, π-calculus pro- cesses satisfy certain behavioral identities related to name restriction. For instance, the order in which channels are bound in a process expression is irrelevant:
νa1. νa2.t = νa2. νa1. t.
To represent name restriction, we could be tempted to model π-calculus terms with a nominal set of the form [Pfin(A)]E, where E denotes a nominal set of process expressions. The idea is that an expression of the form νa1. ... νan.t would cor- respond to the element [({a1,..., an}, t)]. Unfortunately, this encoding does not validate another basic property of name restriction: spurious private channels do not affect process behavior. Formally, if a does not occur free in t, then νa. t = t.
We solve this problem by restricting our binding operator to a nominal subset of Pfin(A) × E that excludes spurious atoms. Specifically, we pose
L(E)= {(A, t) ∈ Pfin(A) × E | A ⊆ supp(t)},
and quotient this nominal set by the binding operator l(A, t) , A. The resulting nominal set, noted Res(E), is known as the free nominal restriction set over E [10, Chapter 9]. We can then represent an expression νa1. ... νan.t by the element [({a1,..., an}∩ supp(t), t)]. Besides their application to the π-calculus, free nominal restriction sets yield a monad on Nom that provides an useful model of fresh-name generation.
Mutually Recursive Deﬁnitions
Most programming languages allow mutually recursive function definitions. In the ML family, these usually take the form
let rec a1 = t1 and ··· and an = tn in t,

where the atoms a1,..., an are bound in the expressions t, t1,..., tn. We could repre- sent mutually recursive definitions with a nominal set of the form [List(A)] List(E), where E is some nominal set of expressions, and List(X) is the nominal set of finite lists of elements of X. The idea is that an expression such as the one above would be mapped to the element [([a1,..., an], [t1,..., tn, t])]. The problem, as noted by Pottier [12], is that this nominal set contains elements that do not correspond to any valid expression, such as [([a], [])], where the number of defined atoms does not match the number of definition bodies.
We can use binding operators to model mutually recursive definitions by viewing expressions as the one above as a pair (f, t), where t ∈ E is an expression, and f : A ~fin E is a partial function with finite domain. The term t represents the result of the expression, while the function f maps each atom to the corresponding definition; in the example given above, this would be a function mapping a1 to t1, a2 to t2, etc. (Note that this assumes that the order of the definitions does not matter. We could also have considered a more concrete variant with lists of declarations that have an explicit order.) The bound atoms in (f, t) are exactly those in the domain of f , which leads to the nominal set Mut(E) , ((A ~fin E) × E)/(dom ◦ p1), where p1 designates the first projection function. This solution is similar to others proposed in the literature [12,17].

An Obstacle: Binder Scope
We could try to adapt the previous example to model parallel nonrecursive defini- tions:
let a1 = t1 and ··· and an = tn in t,
where the atoms a1,..., an are bound in t, but not in t1,..., tn. Unfortunately, the tools that we have developed so far cannot take this form of scoped binding into account, because the equivalence derived from binding operators require atoms to be renamed everywhere, including in positions where they should remain free (in this case, the ti). We will see later, in Section 6, how to work around this issue by considering renaming operations that act only on a limited scope within an object.

Binding Functions
It is basic set theory that every surjective function f corresponds to a quotient by an equivalence relation—namely, the one where x1 and x2 are equivalent if and only if f (x1) = f (x2). In this section, we prove an analogous result for binding operators, showing that their quotients can alternatively be characterized as what we call binding functions. This characterization will be useful in Section 6, where we use it to relate a more general class of quotients on nominal sets to binding operators.
Definition 5.1 An equivariant function f between nominal sets is a binding func- tion if it is surjective and, whenever f (x1) = f (x2), we have x1 ≡lf x2, where

lf (x) = supp(x) \ supp(f (x)). 2 This last condition simply means that there exists a permutation π, with π # f (x1), such that x2 = π · x1.
Intuitively, a binding function is one that removes atoms from the support of its argument, but doesn’t discard any other information attached to it. Notice that, by construction, the projection into a quotient by a binding operator is a binding function. However, the converse also holds: every binding function corresponds to a quotient by a binding operator. More precisely, we have the following result.
Lemma 5.2 If f : X →eq Y is a binding function, then there is an isomorphism i : Y ∼= X/lf such that i(f (x)) = [x]. In other words, f is a coequalizer of the equivalence relation ≡lf .
Proof We already know that f is surjective and that f (x1)= f (x2) implies x1 ≡lf x2. Conversely, we can see that x1 ≡lf x2 implies f (x1) = f (x2), since f (x1) = f (π · x1) when π # f (x1). This proves that f is the coequalizer we’re looking for.2
Binding operators can be combined by composing their quotients:
Lemma 5.3 If f and g are binding, then so is h = gf, and lh(x)= lf (x) ∪lg(f (x)).
Proof It is clear that h is surjective, as the composition of two surjections. Now, suppose that g(f (x1)) = g(f (x2)). Since g is binding, we find a permutation π, with π # g(f (x1)), such that f (x2)= π · f (x1)= f (π · x1). But f is also binding, so we get another permutation πj such that πj # f (π · x1) and x2 = πj · π · x1. The freshness assumptions on π and πj imply that πj ◦ π # g(f (x1)), because
supp(g(f (x1))) = supp(g(f (π · x1))) ⊆ supp(f (π · x1)).
This shows that h is binding. The last claim follows because
lh(x) = supp(x) \ supp(g(f (x)))
= (supp(x) \ supp(f (x))) ∪ (supp(f (x)) \ supp(g(f (x))))
= lf (x) ∪ lg(f (x)).

2
Finally, as an aside, we note that every equivariant function can be factored through a quotient by a binding operator. We can compare this result to the more familiar one that says that every function can be factored through its image.
Lemma 5.4 Let f : X →eq Y be an equivariant function. We can factor f through
X/lf as f = f¯ ◦ [−]:
f¯
X  X/lf  Y,

2 Kurz et al. [7, Notation 5.40] refer to this binding operator as the set of “bound variables relative to a map”, and use it to study variable binding in infinite objects.

where f¯ preserves supports, in the following sense:
supp(f¯(x¯)) = supp(x¯).
Furthermore, this factorization is unique up to isomorphism. Speciﬁcally, if f = hg, where g is binding and h preserves supports, there exists an isomorphism i such that the following diagram commutes:
X  X/lf
g	f¯
i
Y j	h	Y
Proof That f can be factored through X/lf follows from Lemma 3.5. Because h
preserves supports, we find that lg = lf , and construct i using Lemma 5.2.	2
The analogy with the image of a function goes even further: we can show that binding functions and functions that preserve supports form a factorization sys- tem [1, Definition 5.5.1] on the category of nominal sets. Spelled out in detail, this means that both classes of functions contain all isomorphisms, are closed under com- position, and can be used to factor uniquely (up to isomorphism) any equivariant function, as shown above.
Atom Scope and Freshening
In Section 4.4, we noted that binding operators cannot express syntactic forms that bind atoms in only part of an object. We show here how to accommodate such constructs by decomposing the renaming operation of a nominal set into smaller independent ones. The idea is that each of these independent operations applies an atom permutation to part of an object without affecting the rest, thus allowing bound atoms to α-vary within their intended scope. The corresponding quotients are not binding functions in the sense of Definition 5.1, but we show here that they still support similar elimination principles to those obtained from Lemma 3.5. Besides allowing us to model more binders, this machinery will be useful for deriving stronger elimination principles that work with finitely supported functions.
Independence
The main technical device that we need is the notion of independence of two re- naming operations.
Definition 6.1 Let X be a set with two renaming operations, ⊙1 and ⊙2. We say that these operations are independent if they commute, in the following sense:
π1 ⊙1 π2 ⊙2 x = π2 ⊙2 π1 ⊙1 x.
We use the ⊙ operator to denote a set of multiple independent renaming operations on a set, whereas · is reserved to its canonical nominal structure. If the elements of

X are finitely supported with respect to these operations, we say that X has two independent nominal structures. We note supp1(x) and supp2(x) the supports of an element x of X with respect to each of the renaming operations.
As an example, if X and Y are nominal sets, we can define two independent renaming operations on the product X × Y by posing
π ⊙1 (x, y) , (π · x, y)	π ⊙2 (x, y) , (x, π · y).

Note that we can express the product nominal set X × Y as the composition of these two operations. As a matter of fact, any set with two independent renaming operations can be endowed with a compound one, as shown in the following results.
Lemma 6.2 Let X be a set with two independent nominal structures. The support of an element with respect to one structure is invariant with respect to the other:
supp1(π ⊙2 x)= supp1(x)	supp2(π ⊙1 x)= supp2(x).

Proof We only need to show one case, the other one following analogously. Given two atoms a and aj, we have
 a aj ⊙1 π ⊙2 x = π ⊙2 a aj ⊙1 x.

Since renaming operations are injective, we see that (a aj) ⊙1 x = x if and only if (a aj) ⊙1 π⊙2 x = π⊙2 x. But a is in supp1(x) if and only if there are infinitely many aj such that (a aj) ⊙1 x /= x, and similarly for π ⊙2 x. This allows us to conclude.2
Lemma 6.3 Let X be a set with two independent nominal structures. We can deﬁne a compound nominal structure on X by setting
π · x , π ⊙1 π ⊙2 x.

Each of the ⊙i is equivariant with respect to this compound operation, in the fol- lowing sense:
π · πj ⊙i x = (π · πj) ⊙i π · x.
Finally, the support of an element is the union of the supports of the constituent parts:
supp(x) = supp1(x) ∪ supp2(x).
Proof By unpacking definitions, we can check directly that this compound opera- tion indeed satisfies the required properties of a renaming operation, and that each
⊙i is equivariant. We can also see that every element is finitely supported: given x
in X and a permutation π such that π # supp1(x) ∪ supp2(x), we have
π · x = π ⊙1 π ⊙2 x = π ⊙1 x = x,

proving that supp(x) exists and that it is contained in supp1(x) ∪ supp2(x). Note that supp1(x) ∪ supp2(x) depends equivariantly on x, thanks to Lemma 6.2:
supp1(π · x) ∪ supp2(π · x)
= supp1(π ⊙1 π ⊙2 x) ∪ supp2(π ⊙2 π ⊙1 x)
= π · supp1(π ⊙2 x) ∪ π · supp2(π ⊙1 x)
= π · supp1(x) ∪ π · supp2(x)
= π · (supp1(x) ∪ supp2(x)).
Thus, supp1(x) ∪ supp2(x) is also contained in supp(x), which proves that both sets are equal.	2
By iterating this process, we can combine any finite number of independent re- naming operations. For simplicity, we restrict ourselves to the case of two indepen- dent operations in what follows, but the theory developed here can be generalized without difficulty to the case of a finite number of renaming operations that are pairwise independent. Whenever a set has multiple nominal structures, we consider the compound one defined in the above lemma as canonical.

Local Equivariance and Binding Operators
If a nominal set can be decomposed into independent renaming operations, we can express the scope of a binder on that set by instantiating the generic notion of α-equivalence in Definition 3.1 to a particular renaming operation. However, if we want the corresponding quotient to behave nicely with respect to the “global” nominal structure, we must require that the corresponding binding operator be independent of the other renaming operations. This leads to local variants of the notions of equivariance and binding operator.
Definition 6.4 Let X be a set with two independent nominal structures, and Y
be a nominal set. We say that a function f is locally equivariant (with respect to
⊙i) if


f (π ⊙j
x) =	π · f (x)	if j = i	. f (x)	otherwise

We note the set of such functions as X →i  Y .
By Lemma 6.2, we see that suppi is locally equivariant with respect to the corresponding nominal structure. Furthermore:

Lemma 6.5 Using the same notations as above, a function f : X →i
Y is also

equivariant with respect to the compound nominal structure of Lemma 6.3.
Proof Assuming i = 1, we have f (π · x)= f (π ⊙1 π ⊙2 x)= π · f (π ⊙2 x)= π · f (x). The other case is similar.	2

Definition 6.6 Let X be a set with two independent nominal structures. A local binding operator (with respect to ⊙i) is a locally equivariant function l : X →i
Pfin(A).
By Lemma 6.5, a local binding operator l for a renaming operation ⊙i is a binding operator for two different nominal structures, and thus gives rise to two different notions of α-equivalence. To distinguish between them, we use x1 ≡l x2 to say that x1 and x2 are α-equivalent with respect to the compound structure, and x1 ≡i x2 to say that x1 and x2 are α-equivalent with respect to ⊙i. If we unfold the definition of α-equivalence for the last case, it simply means that there exists a permutation π fixing suppi(x) \ l(x) such that x2 = π ⊙i x1. Its corresponding quotient is compatible with all the nominal structures of the original set, as shown below.
Lemma 6.7 Let l : X →i  Pfin(A) be a local binding operator. The relation ≡i is
equivariant with respect to the operations ⊙j and with respect to ·. The quotient
X/≡i has the following nominal structures:


π ⊙ [x]= [π ⊙

x]	supp ([x]) =  suppi(x) \ l(x)	if j = i

π · [x]= [π · x]	supp([x]) = suppi(x) \ l(x) ∪ suppi′ (x),
where ij /= i in the last equation. In particular, the renaming operations ⊙j are independent.
Proof We assume i = 1, the other case being symmetric. It suffices to show the result for ⊙1 and ⊙2, since these two cases combined yield the results for ·. Let’s start with equivariance. We already know that ≡1 is equivariant with respect to
⊙1 from Lemma 3.3. To show that it is also the case for ⊙2, suppose that we have a permutation π such that π # supp1(x) \ l(x), so that x ≡1 π ⊙1 x. We want to
show that, for any permutation πj, we have
πj ⊙2 x ≡1 πj ⊙2 π ⊙1 x = π ⊙1 πj ⊙2 x.

This holds because, by local equivariance, π is fresh for supp1(πj ⊙2 x) \ l(πj ⊙2 x)= supp1(x) \ l(x).
Finally, the definition of the renaming operations on X/≡1, and their indepen- dence, follow from equivariance. We already know how to compute supp1([x]) from the earlier Lemma 3.4. Thus, to conclude, we just have to compute supp2([x]). But x1 ≡1 x2 implies supp2(x1) = supp2(x2) by Lemma 6.2, and thus supp2([x]) = supp2(x) (cf. (3) in the proof of Lemma 3.4).	2
To understand how this construction works, let’s revisit the example of parallel definitions of Section 4.4. Once again, if E is some nominal set of program expres- sions, we model raw parallel definitions (that is, before taking the quotient) with the nominal set (A ~fin E) ×E. We can decompose this nominal structure into two

independent ones defined as
π ⊙1 (f, e) , (f ◦ π—1,π · e)	π ⊙2 (f, e) , (a '→ π · f (a), e).
Thus, in a let expression
let a1 = t1 and ··· and an = tn in t,
the operation ⊙1 renames the atoms on the left-hand side of the definitions, as well as the ones in t, whereas ⊙2 only renames those that occur in the ti. We see that the binding operator l(f, e) , dom(f ) is local to ⊙1, and lists precisely the atoms on the left-hand side of the local definitions. Unlike the case of mutually recursive definitions discussed in Section 4.3, the definition of ≡1 guarantees that the bound atoms of a pair (f, e) cannot vary in the bodies of local definitions in f . Thus, we can represent parallel let with the nominal set Par(E)= ((A ~fin E) × E)/≡1.
Elimination Principles
Now that we have quotient nominal sets that correspond to local binding operators, we turn our attention to the functions that can be defined on them. If we want a function that is locally equivariant with respect to the same nominal structure as the local binding operator that we considering, it suffices to apply Lemma 3.5 directly. More generally, however, we want to define functions that are not locally equivariant, but only equivariant with respect the compound nominal structure. Going back to the example of parallel let, the function c(f, e) = | supp(f, e)| that counts the number of variables in an expression is not locally equivariant, since renaming parts of an expression independently may change its result. For instance, the expressions


and
let a1 = a1 in a1

let a1 = a2 in a1

have a different number of variables, but can be obtained from each other by a local renaming.
We cannot describe these functions using the compact elimination principle of Lemma 3.5, since, as stated earlier, projecting into such a quotient is not a binding function. This can be seen, for instance, in the identity supp([x]) = supp1(x) \ l(x) ∪ supp2(x) of Lemma 6.7, which implies in particular that an atom a may appear in the support of [x] even if it occurs in l(x). As it turns out, we can express the quotient by a local binding operator on X as a quotient by a “global” binding operator on a nominal subset of X, where bound atoms are prevented from aliasing the ones that remain free after the quotient by α-equivalence. Specifically, we now

prove that X/≡1 is isomorphic to the quotient X#l/l, where l : X →1
Pfin(A) is a 

l	eq
local binding operator, and
X#l = {x ∈ X | l(x) # supp2(x)}.	(4)

(Note that X#l is a nominal subset of X for its compound nominal structure, but not for any of the ⊙i.) In particular, using Lemma 3.5, this allows us to define equivariant functions X/≡1 →eq Y (with respect to the compound nominal structure of X/≡1) through equivariant functions f : X#l →eq Y that satisfy l(x)# f (x) for any x in X#l. We begin with the following results, showing how to avoid conflicting with sets of “bad” atoms when choosing concrete values for the ones that are bound.
Lemma 6.8 Let X be a nominal set with a binding operator l. Given x¯ ∈ X/l and a ﬁnite set of atoms A, we can ﬁnd x ∈ X such that [x]= x¯ and l(x)# A.
Proof Pick any representative xj of x¯. We cannot choose x to be xj right away, since in principle the set l(xj) may not be fresh with respect to A. We can, however, rename the conflicting atoms to fresh values.
Choose a set of atoms Aj such that |Aj| = |l(xj) ∩ A| and Aj # (xj, A). By a cardinality argument, we can construct a permutation π that sends l(xj) ∩ A to Aj while leaving all other atoms fixed. By construction, π does not affect the free atoms of xj; formally, supp(π) = l(xj) ∩ A ∪ Aj, hence π # supp(xj) \ l(xj). This implies that [π · xj]= [xj]= x¯. We then can choose x to be π · xj, provided that we show that its atoms are completely fresh (that is, π · l(xj)# A). The result follows because the definition of π implies that π · l(xj)= Aj ∪ l(xj) \ A, and both parts are disjoint from A.	2
Lemma 6.9 Let X be a nominal set with a binding operator l, and A a ﬁnite set of atoms. Let x1 and x2 be two elements of X such that x1 ≡l x2, l(x1)# A, and l(x2) # A. There exists a permutation π such that π # A, π # supp(x1) \ l(x1), and x2 = π · x1.
Proof By the definition of ≡l, we can find some permutation πj that is fresh for supp(x1) \ l(x1), and such that x2 = πj · x1. By basic properties of permutations, there exists a permutation π such that
π(a)= πj(a)	if a ∈ l(x1)
supp(π) ⊆ l(x1) ∪ l(x2).
The set l(x1) ∪ l(x2) is disjoint from supp(x1) \ l(x1) and A, implying that π is fresh for supp(x1) \ l(x1) and A. In order to conclude, it suffices to show that π · x1 = πj · x1, which holds because π and πj agree on supp(x1).	2
We can now explain how local binding operators yield binding functions.
Lemma 6.10 Let X be a set with two independent nominal structures, and l a local binding operator on X with respect to the operation ⊙1. There exists an isomorphism X/≡1 ∼= X#l/l making the following diagram commute:

X  X/≡1
X#l  X#l/l
In particular, to build an equivariant function f¯ : X/≡1 →eq Y , it suffices to ﬁnd an equivariant f : X#l →eq Y such that l(x) # f (x) for every x; then, f¯([x]) = f (x) whenever x is in X#l.
Proof Consider the canonical projection into X/≡1 restricted to the nominal sub- set X#l. Call this function f . By Lemma 5.2, it suffices to show that f is binding, and that its corresponding binding operator, lf , is equal to l. The last point follows by unfolding definitions and making use of the freshness constraints on the elements of X#l. Moreover, we can show that f is surjective using Lemma 6.8. The only part that is missing is showing that f (x1)= f (x2) implies x1 ≡l x2 for any x1 and x2 in X#l. Note that f (x1) = f (x2) is equivalent to x1 ≡1 x2. Using Lemma 6.9, we find a permutation π that is fresh for supp2(x1) and supp1(x1) \ l(x1) such that x2 = π ⊙1 x1. We must then show that x ≡l π ⊙1 x. The assumptions on π imply that
x = π ⊙2 x	(5)
π # supp1(x) \ l(x) ∪ supp2(x).	(6)
Thus, showing x ≡l π ⊙1 x is tantamount to showing x ≡l π · x = π ⊙1 π ⊙2 x. We conclude using (6), which, given that l(x) # supp2(x), is equivalent to π # supp(x) \ l(x),	2
By applying this result to the nominal set Par(E), and unfolding definitions, we find that it is isomorphic to
{(f, e) ∈ (A ~fin E) × E | dom(f )# im(f )}/(dom ◦ p1),
where p1 is the first projection. This shows that even if we can construct elements of Par(E) by giving a let expression where some of the free atoms in the bodies of the local definitions are shadowed, when defining functions on that set, we can assume that the locally defined atoms are disjoint from the ones that are free. We can see this fact as a restatement, in nominal terms, of Barendregt’s well-known variable convention, of which Lemma 6.10 is a formal justification.

Multiple Quotients
Although the above results have been stated for quotients by a single local binding operator, they can also be composed to derive elimination principles for quotients by multiple operators. For this, we can make use of the following simple observation, which allows us to combine the freshness constraints arising from multiple quotients.

Lemma 6.11 Let X be a nominal set with a binding operator l. Every nominal

subset X¯
of X/l is of the form

{x ∈ X | [x] ∈ X¯ }/l.

Proof By Lemma 5.2.	2
As an example of elimination principle for multiple quotients, we have the fol- lowing result.
Lemma 6.12 Let X be a set with two independent nominal structures and two

local binding operators, l1 : X →1
Pfin(A) and l2 : X →2
Pfin(A). Let ≡l1,l2 be

the composition of the equivalence relations ≡1
1
and ≡2 . There is an isomorphism
2

X/≡l1,l2 ∼= X#l1,l2 /(l1 ∪ l2) such that the following diagram commutes:
X  X/≡l1,l2

where
X#l1,l2  X#l1,l2 /(l1 ∪ l2)
X#l1,l2 = {x ∈ X | l1(x) # supp2(x), l2(x) # supp1(x)}.

Proof Because both renaming operations are independent, the composition ≡l1,l2 is indeed an (equivariant) equivalence relation. We can express the quotient by this equivalence relation as an iterated quotient, which, thanks to Lemma 6.10, has the form
X/≡l1,l2 ∼= (X#l1 /l1)#¯l /¯l2,
where ¯l2 denotes the lifting of the binding operator l2 to X#l1 /l1, using Lemma 3.5.
By Lemma 6.11, we have
(X#l1 /l1)#¯l ∼= {x ∈ X#l1 | l2(x) # supp1(x) \ l1(x)}/l1	(7) Since l2(x) ⊆ supp2(x) for every x ∈ X, we can see that l1(x) # l2(x) when
x ∈ X#l1 . Thus, the right-hand side of (7) is precisely X#l1,l2 /l1. We conclude
using the fact that
X#l1,l2 /l1/¯l2 ∼= X#l1,l2 /(l1 ∪ l2),
thanks to Lemma 5.3. It is a tedious but straightforward exercise to check that the composition of these isomorphims results in the above commuting diagram.	2
It is worth spelling out explicitly a special case of this result.
Lemma 6.13 Let X, Y be nominal sets and lX, lY be binding operators over them. Deﬁne the separated product to be the following nominal subset of X × Y :
(X, lX ) ⊗ (Y, lY ) , {(x, y) ∈ X × Y | x # lY (y), lX (x)# y}
Let l(x, y) , lX (x) ∪ lY (y). There is an isomorphism
σ : X/lX × Y /lY ∼= ((X, lX ) ⊗ (Y, lY ))/l

satisfying σ([x], [y]) = [(x, y)] for all (x, y) ∈ (X, lX ) ⊗ (Y, lY ).
Proof As pointed out before, we can define two independent renaming structures on X × Y :
π ⊙1 (x, y)= (π · x, y)	π ⊙2 (x, y)= (x, π · y).
We can check that lX and lY can be lifted to local binding operators l1 and l2 on X × Y , and that the separated product (X, lX ) ⊗ (Y, lY ) is just (X × Y )#l1,l2 , as defined in Lemma 6.12. We conclude by noting that the product relation ≡lX × ≡lY

is the composition of ≡1
1
and ≡2 , and that
2

X/lX × Y /lY ∼= (X × Y )/(≡lX × ≡lY ) ∼= (X × Y )#l1,l2 /l,
where the last isomorphism follows from Lemma 6.12.	2
With this result, we can finally state a strong elimination principle for binding operators, which describes finitely supported functions defined on their quotients.
Lemma 6.14 Let X and Y be nominal sets, l be a binding operator on X, and f : X →fs Y a ﬁnitely supported function that satisﬁes the following freshness condition for binders: if x is such that lX (x)# f, then lX (x)# f (x). There exists
f¯ : X/lX →fs Y satisfying f¯([x]) = f (x) for all x such that lX (x)# f.
Proof Roughly, we can use the previous result to express f¯ as the partial applica- tion of a suitable evaluation function. Define the nominal set
F , {g : X →fs Y | ∀x. lX (x)# g ⇒ lX (x)# g(x)}.
Pose lF (g) , ∅ and l(g, x) , lX (x). Let P , (F, lF ) ⊗ (X, lX ) and e : P →eq Y be the evaluation function e(g, x) , g(x). By construction, e satisfies l(g, x)# e(g, x) for every (g, x) ∈ P . Using Lemma 3.5, we can thus construct e¯ : P/l →eq Y

such that e¯([(g, x)]) = g(x). We then pose f¯(x¯) ,
e¯(σ([f ], x¯)), where σ is the

isomorphism of Lemma 6.13.	2
Unlike the case for equivariant functions, the mapping f '→ f¯ defined above is not bijective in general, because it only uses part of the information contained in its argument: in order to have f¯ = g¯, we just have to guarantee that f (x) = g(x)
for all x such that lX (x)# (f, g).
Lemma 6.14 is the analog for binding operators of an earlier result on name

abstractions [9], which says that we can obtain a function
f¯ : [A]X →fs Y by

finding f : A × X →fs Y satisfying a # f (a, x) when a # f —exactly what we
obtain by instantiating our result with the operator lα defining name abstraction.
Functorial Properties
So far, we have used binding operators to define individual syntactic constructs, but still have not determined when such constructs can be combined into valid

complete grammars. Previous results show that this is possible in many cases, such as grammars given by nominal signatures [18]. This allows us for instance to define the set of λ-terms modulo α-equivalence as the solution of the equation
Λ= A + Λ2 + [A]Λ,	(8)
which says that a λ-term is either a variable, a pair of λ-terms representing an application, or the name abstraction of a λ-term, representing a function definition. In this section, we extend these results to a large class of nominal sets defined with binding operators. It is standard to interpret definitions such as the one above as specifying the initial algebra of a certain functor. What makes the definition of Λ valid is that name abstraction can be made into a functor, and that this functor satisfies certain technical conditions needed for the construction of initial algebras. Thus, we want to determine which endofunctors on Nom can be defined through binding operators and to study their properties. The first step is to recast some of the earlier definitions into a more structured form, showing that the process of
quotienting by a binding operator is itself functorial.
Definition 7.1 The category of binding operators Bnd is defined as follows. Ob- jects are pairs (X, lX ), where X is a nominal set and lX is a binding operator over
X. When no ambiguity can arise, we use X to refer to the pair (X, lX ), and we sometimes omit the X index from lX . A morphism from X to Y is an equivariant function f : X →eq Y such that, for every x in X,
lY (f (x)) = lX (x) ∩ supp(f (x)).
We note U : Bnd → Nom the obvious forgetful functor that maps (X, lX ) to X. Intuitively, this definition says that applying a morphism f in Bnd to an argu-
ment x cannot change the status of the atoms in supp(x) from bound to free, or vice versa. Note, however, that applying f may still remove atoms from the support of x entirely, both bound and free. This restriction guarantees that every such f can be lifted to quotients, as shown in the following result.
Lemma 7.2 We can extend quotients by binding operators to a functor Q : Bnd →
Nom satisfying
Q(X)= X/lX	Q(f )([x]) = [f (x)].
Note that the second identity says that the canonical projections form a natural transformation U → Q. This functor has a right adjoint Z : Nom → Bnd, which associates to a nominal set X the constant binding operator l(x)= ∅. Furthermore, the QZ is naturally isomorphic to the identity on Nom, via the canonical projection into the quotient.
Proof We define the action of Q on morphisms by appealing to Lemma 3.5. Specif- ically, let X and Y be two objects in Bnd, and f : X → Y be a morphism be- tween them. We know that f and [−] are equivariant, thus it suffices to show that

lX (x) # [f (x)] for all x in X. Since supp([f (x)]) = supp(f (x)) \ lY (f (x)), this is equivalent to
lX (x) ∩ supp(f (x)) \ lY (f (x)) = ∅,
which readily follows from the fact that f is a morphism in Bnd. It is easy to verify that this construction preserves identities and composition; thus, Q is indeed a functor.
To show that Z is right adjoint to Q, consider an equivariant function f : Q(X) →eq Y , where X ∈ Bnd and Y is a nominal set. The composite g = f ◦ [−] is an equivariant function that satisfies lX (x)# g(x) for every x in X. Thus, g is a morphism X → Z(Y ) in Bnd. Conversely, given a morphism g : X → Z(Y ) in Bnd, we can use Lemma 3.5 to factor it as f ◦ [−], with f : Q(X) → Y . We can readily check that these constructions are mutally inverse, and natural in X and Y . The last assertion follows from Lemma 5.2.	2
We note that the condition on morphisms of Definition 7.1 is not tight, in the sense that the above proof would still work with the weaker assumption
lY (f (x)) ⊇ lX (x) ∩ supp(f (x)),
which intuitively says that f may bind atoms that are free in x. The reason for choosing the stronger variant, as we will see, is that it allows us to characterize Bnd as a category of coalgebras, which will play an important role later on, when studying functors involving quotients.
To define a functor on Nom via binding operators, we can define a functor F : Nom → Bnd, and then consider the composite QF . It is easy to see that the examples discussed so far—name abstractions, name restriction, mutually recursive and parallel definitions—can be extended into functors by following this recipe. For name abstractions, for instance, we can take F (X) to be A × X, endowed with the binding operator lα(a, x)= {a}, which can be extended to a functor in the obvious way.
Strengthening Quotients
Many functors derived from binding operators allow arbitrary finitely supported functions to be lifted, not just equivariant ones. A good example is name ab- straction: given any finitely supported function f : X →fs Y , we can define [A]f : [A]X →fs [A]Y satisfying [A]f (⟨a⟩x) = ⟨a⟩(f (x)) whenever a # f . In category-theory jargon, such functors are known as enriched.
Formally, to enrich a functor G : Nom → Nom means to extend its action on morphisms to a family of equivariant functions (X →fs Y ) →eq (G(X) →fs G(Y )) satisfying the usual functor laws. An equivariant action is compatible with the structure of Nom, which allows us to generalize properties of G to finitely supported functions. For instance, if G has an initial algebra, it supports a recursion scheme that for defining finitely supported functions.
If G is of the form QF , it can be enriched by appealing to the elimination principle of Lemma 6.14, but the quotient structure provides a more direct route.

Indeed, it is well-known that enriching QF is equivalent to giving it a strength: a natural transformation ηX,Y : X × QF (Y ) → QF (X × Y ) satisfying the laws depicted below.



η
1 × QF (A)

QF (1 × A) QF (A)
η
(A × B) × QF (C)

A × (B × QF (C))
A×η
η
A × QF (B × C)
QF ((A × B) × C)

QF (A × (B × C))

Intuitively, η allows us to lift functions by currying the composite

η
(X →fs Y ) × QF (X)
QF ((X →fs Y ) × X)
F (є)
QF (Y ) ,

where ϵ denotes the evaluation function (X →fs Y ) × X →eq Y . The strength laws then guarantee that the resulting action satisfies the required functor laws.
Now, note that the separated product ⊗ of Lemma 6.13 admits a trivial extension into a bifunctor Bnd2 → Bnd, endowing Bnd with the structure of a symmetric monoidal category, with unit Z(1); furthermore, its isomorphism σ : Q(X)×Q(Y ) ∼= Q(X ⊗ Y ) is natural in X and Y , and satisfies all laws required to make Q a strong monoidal functor from (Bnd, ⊗, Z(1)) to (Nom, ×, 1). This allows us to strengthen

QF by composition: it suffices to find a natural transformation ηj
: Z(X) ⊗

F (Y ) → F (X × Y ) in Bnd satisfying laws analogous to the ones above. It is then a simple exercise to check that the composite

~=
X × QF (Y )
~=
QZ(X) × QF (Y )
Q(Z(X) ⊗ F (Y ))
Qη′
QF (X × Y )

is a strength on QF . Indeed, all of the functors arising from binding operators studied here can be trivially strengthened in this fashion.

Preservation of Colimits and Initial Algebras
After analyzing the matter of strength, let’s turn our attention to other properties of quotient functors—namely, which colimits they preserve. Among other things, this is useful for building initial algebras. The initial algebra of a functor G : Nom → Nom is normally constructed as the colimit of the chain diagram

∅	ι	G(∅)
G(ι)
G2(∅)
G2(ι)
··· ,

but this construction only makes sense if G preserves that colimit, which can often be reduced to showing that the individual functors appearing in definition of G preserve colimits of the same shape.
Note that, since Q has a right adjoint, QF preserves all colimits that are pre- served by F . But F takes values in a category of binding operators, which must in principle be taken into account when computing these colimits. We show here is that this is not the case: we can always reduce colimits in Bnd to simpler colimits in

Nom, by characterizing the former as the Eilenberg-Moore category of the following comonad.
Lemma 7.3 The L construction used in Section 4.2 for modeling name restriction can be extended into a functor Nom → Nom by setting
L(f )(A, x)= (A ∩ supp(f (x)),f (x))
This functor has the structure of a comonad, given by natural transformations ρ :
L → 1 and ν : L → L2 deﬁned by
ρ(A, x)= x	ν(A, x)= (A, (A, x))
and satisfying the usual conditions: Lν ◦ ν = νL ◦ ν and Lρ ◦ ν = ρL ◦ ν = 1L.
Proof It is easy to check that the action of L on morphisms is functorial; for instance,
L(f )(L(g)(A, x)) = (A ∩ supp(g(x)) ∩ supp(f (g(x))),f (g(x)))
= (A ∩ supp(f (g(x))),f (g(x)))
= L(f ◦ g)(x),
where we made use of the fact that supp(f (g(x))) ⊆ supp(g(x)). Checking that (L, ρ, ν) forms a comonad is similarly straightforward.	2
Theorem 7.4 The category Bnd is equivalent to the Eilenberg-Moore category of coalgebras of the comonad (L, ρ, ν). We recall that objects of this category are pairs (X, l) of a nominal set X and a map l : X →eq L(X) satisfying the ﬁrst two laws depicted below. A morphism from (X, lX ) to (Y, lY ) is an equivariant function f : X →eq Y making the third diagram below commute.

X	l	L(X)	X	l
ρ	l
L(X)	X	f	Y
ν	lX	lY

X	L(X)
L(l)
L2(X)
L(X)
L(f )
L(Y )

Proof An equivariant function l : X →eq L(X) satisfying the commuting triangle above is of the form l(x)= (lj(x), x), proving that such a function is equivalent to a binding operator on X. The first commuting square is valid for any l satisfying the triangle. The second commuting square is just a restatement of the restriction imposed on morphisms in Bnd.	2

As with every Eilenberg-Moore category, we obtain a right adjoint L¯
to the

forgetful functor U : Bnd → Nom. By unpacking the definitions, we can see this right adjoint as endowing each L(X) with a binding operator l(A, x) , A, exactly what we used to model name restriction in Section 4.2. We now have all the required ingredients to prove the main result of this section.

Theorem 7.5 Let I be a small category and D : I → Bnd a diagram. Suppose that (U (ρi): U (Di) → U (C))i∈£ is a colimiting cocone in Nom. Then so is (Q(ρi): Q(Di) → Q(C))i∈£ . In particular, any functor of the form QF preserves all colimits that are preserved by UF.
Proof As previously noted, since Q has a right adjoint, it suffices to show that (ρi : Di → C) is a colimiting cocone in Bnd. But this holds because U creates colimits, thanks to general results on Eilenberg-Moore categories [2, Props. 4.1.4 and 4.3.1].	2
Remark 7.6 The preceding result does not hold for limits in general. For a coun- terexample, consider the functor S : Nom → Bnd, defined as S(X)= (X, supp), with the obvious action on morphisms. We have (trivially) that US(A2)= US(A)2 = A2. On the other hand, QS(A2) has two elements ([(a, a)] and [(a, aj)], where a /= aj), whereas the product QS(A)2 has only one.
As mentioned previously, one application of Theorem 7.5 is showing that a func- tor of the form QF can be used for defining grammars by initial algebras, which often follows from simple category-theoretic reasons. For instance, suppose that F = (X × (−), lα) is the functor defining generalized name abstractions [X](−), as in Section 4. Then UF = X × (−), which preserves all colimits because Nom is cartesian closed.
Another potential application is providing sufficient conditions for the existence of right adjoints of quotient functors. One of the many corollaries of the adjoint functor theorem says that, for a functor Nom → Nom, preserving arbitrary colimits and having a right adjoint are equivalent, because Nom is a Grothendieck topos. If that functor is of the form QF , then Theorem 7.5 allows us to check only whether UF preserves arbitrary colimits. We immediately conclude, for the same reasons as before, that generalized name abstractions have a right adjoint. Although this par- ticular right adjoint already had a good explicit characterization [3], we think that our construction helps shed light on the relation between binding and adjunctions.
Conclusion and Related Work
Binding operators are an expressive framework for defining binders for nominal sets, encompassing many constructs that have been previously proposed in the literature. Although it is not clear how much expressive power our operators add compared to previous approaches, we believe that they provide a uniform, concise explanation for many of the properties enjoyed by binding constructs, such as their elimination principles, functoriality, compatibility with inductive definitions, etc.
Since the early development of nominal sets, researchers have directed their at- tention to more general forms of binding than name abstraction. The simplest such construction is given by generalized name abstractions, studied by Gabbay [4] and others. Clouston [3] investigated some of their categorical properties, in particu- lar the related notion of separating function, and adjunctions between generalized name abstractions and the so-called freshening function space. That work provides

an explicit construction of this adjunction, which could be interesting to generalize to other quotients by binding operators.
The Nominal Isabelle package features a rich language for defining data types with binders [17], allowing users to specify which atoms are bound in values of a data type. Unlike the present work, their focus is not in offering a foundational definition of binding, but in providing a usable and flexible tool. One point of similarity is that they use a general class of functions to enumerate which atoms are bound. Although such functions are more limited than general binding operators, the mechanism is rich enough to capture interesting binders, including generalized name abstractions and free nominal restriction sets. One way in which Nominal Isabelle goes beyond our framework is by allowing two parts of a term to be renamed independently, and yet share the same set of bound atoms. For instance, assuming that we have two different atoms a and aj, this would allow to equate terms of the form
Foo {a, aj} (a, aj) (a, aj)= Foo {a, aj} (a, aj) (aj, a),
assuming that the definition of Foo is such that it binds the set {a, aj} separately on its second and third arguments; that is, we allow swapping the a and aj in the third argument independently of the second.
To our knowledge, the closest relative of binding operators and their quotients is the operation of simple monoidal sum studied by Schopp [13, Section 3.3.2]; we quickly review that construction here, adapted to our conventions and notations. We start with an arbitrary equivariant function f : X →eq Y ∗A, where Y ∗A denotes the “full” separated product, in which both components are not allowed to share any atoms. We then define a binding operator l on X by posing l(x) = supp(p2(f (x))). By construction, l(x) # p1(f (x)) for every x. Thus, we can lift g = p1 ◦ f to g¯ : X/l →eq Y , which we call the simple monoidal sum of f . Viewed this way, this construction is a small generalization of quotients by binding operators; indeed, we can recover the latter by taking A to be Pfin(A). The main difference between both works is that Sch¨opp uses simple monoidal sums to interpret a form of dependent sum in a nominal type theory, studying properties of that construction that are more relevant in that context, whereas we attempt to provide a more elementary presentation of binding, quotients, and their properties.

References
F. Borceux. Handbook of Categorical Algebra: Volume 1, Basic Category Theory. Cambridge Textbooks in Linguistics. Cambridge University Press, 1994.
F. Borceux. Handbook of Categorical Algebra: Volume 2, Categories and Structures. Cambridge Studies in Philosophy. Cambridge University Press, 1994.
R. Clouston. Generalised name abstraction for nominal sets. In FoSSaCS, volume 7794 of Lecture Notes in Computer Science, pages 434–449. Springer, 2013.
M. J. Gabbay. FM-HOL, a higher-order theory of names. In In Thirty Five years of Automath, Heriot-Watt, 2002.
M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, 13(3-5):341–363, 2002.


R. Harper, F. Honsell, and G. Plotkin. A framework for defining logics. J. ACM, 40(1):143–184, Jan. 1993.
A. Kurz, D. Petri¸san, P. Severi, and F. de Vries. Nominal coalgebraic data types with applications to lambda calculus. Logical Methods in Computer Science, 9(4), 2013.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, I. Inf. Comput., 100(1):1–40, Sept. 1992.
A. M. Pitts. Alpha-structural recursion and induction. J. ACM, 53(3):459–506, May 2006.
A. M. Pitts. Nominal Sets: Names and Symmetry in Computer Science. Cambridge University Press, New York, NY, USA, 2013.
A. M. Pitts and M. J. Gabbay. A metalanguage for programming with bound names modulo renaming. In Mathematics of Program Construction, volume 1837 of Lecture Notes in Computer Science, pages 230–255. Springer-Verlag, 2000.
F. Pottier. An overview of Cαml. Electron. Notes Theor. Comput. Sci., 148(2):27–52, Mar. 2006.
U. Sch¨opp. Names and Binding in Type Theory. PhD thesis, University of Edinburgh, 2006.
P. Sewell, F. Z. Nardelli, S. Owens, G. Peskine, T. Ridge, S. Sarkar, and R. Strnisa. Ott: Effective tool support for the working semanticist. J. Funct. Program., 20(1):71–122, 2010.
M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Programming with binders made simple. In Proceedings of the 8th ACM SIGPLAN International Conference on Functional Programming (ICFP 2003), volume 38, pages 263–274. ACM Press, August 2003.
C. Urban. Nominal techniques in Isabelle/HOL. J. Autom. Reason., 40(4):327–356, May 2008.
C. Urban and C. Kaliszyk. General bindings and alpha-equivalence in nominal Isabelle. Logical Methods in Computer Science, 8(2), 2012.
C. Urban, A. Pitts, and M. Gabbay. Nominal unification. In Computer Science Logic: 17th International Workshop CSL 2003, 12th Annual Conference of the EACSL, 8th Kurt Go¨del Colloquium, KGC 2003, Vienna, Austria, August 25-30, 2003. Proceedings, pages 513–527, Berlin, Heidelberg, 2003. Springer Berlin Heidelberg.
