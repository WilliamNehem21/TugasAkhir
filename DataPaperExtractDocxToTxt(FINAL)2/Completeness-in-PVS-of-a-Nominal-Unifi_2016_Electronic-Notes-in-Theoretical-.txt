Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 323 (2016) 57–74
www.elsevier.com/locate/entcs

Completeness in PVS of a Nominal Unification Algorithm
Mauricio Ayala-Rinc´on a,2 Maribel Fern´andez b,3
Ana Cristina Rocha-Oliveiraa,1
a Departamentos de Matem´atica e Ciˆencia da Computa¸c˜ao Universidade de Bras´ılia
Bras´ılia D.F., Brasil
b Department of Informatics King’s College London London, UK

Abstract
Nominal systems are an alternative approach for the treatment of variables in computational systems. In the nominal approach variable bindings are represented using techniques that are close to first-order logical techniques, instead of using a higher-order metalanguage. Functional nominal computation can be modelled through nominal rewriting, in which α-equivalence, nominal matching and nominal unification play an important role. Nominal unification was initially studied by Urban, Pitts and Gabbay and then formalised by Urban in the proof assistant Isabelle/HOL and by Kumar and Norrish in HOL4. In this work, we present a new specification of nominal unification in the language of PVS and a formalisation of its completeness. This formalisation is based on a natural notion of nominal α-equivalence, avoiding in this way the use of the intermediate auxiliary weak α-relation considered in previous formalisations. Also, in our specification, instead of applying simplification rules to unification and freshness constraints, we recursively build solutions for the original problem through a straightforward functional specification, obtaining a formalisation that is closer to algorithmic implementations. This is possible by the independence of freshness contexts guaranteed by a series of technical lemmas.
Keywords: Nominal terms, binders, α-equivalence, nominal unification, PVS.


Introduction
When one introduces variable binders in a language, one thing to be considered immediately is α-equivalence. For instance, it must be possible to derive the equiv- alence between the formulas ∃x : x > 1 and ∃y : y > 1, despite the syntactical differences. Nominal theories treat binders in a way that is closer to informal prac- tice, using variable names and freshness constraints instead of using indices as in

1 Email: anacrismarie@gmail.com. Author supported by a Ph.D. scholarship from CAPES Brazil.
2 Email: ayala@unb.br. Work partially supported by grant CNPq UNIVERSAL 476952/2013-1.
3 Email: maribel.fernandez@kcl.ac.uk. Work partially supported by grant CsF PVE CAPES 146/2012.

http://dx.doi.org/10.1016/j.entcs.2016.06.005
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

explicit substitutions a` la de Bruijn. In nominal syntax, there are two kinds of variables: atoms, representing object-level variables, and meta-variables, or simply variables. Atoms can be abstracted but not substituted, whereas variables cannot be abstracted but can be substituted. The notion of substitution is first-order in the sense that it allows capture, but freshness constraints are taken into account. Notions such as rewriting (cf. [9]) and unification (cf. [18]) can be directly defined, without having to rely on involved notions such as β-reduction, as in the higher- order and explicit substitutions approaches (cf. [12,8,3]).
Nominal unification problems can be solved (modulo α-equivalence) with first- order substitutions that act over meta-variables, i.e., simply filling the holes marked with meta-variables (X, Y, Z, ... ) and allowing capture of variable names (a, b, c, i, k, . . . ). This can be illustrated by the expressions

7	5	7	5

Σ Σ(i − X)i and
k=0 i=0
Σ Σ(X − Y )k,
i=0 k=0

which admit a most general unifier according to the algorithm in [18], with solution [X '→ k][Y '→ i]. Note that i and k are captured, because these names are bound or abstracted by the sum operator. In a higher-order unification approach, this solution would not be accepted because bound variable capture is forbidden.
On the other hand, the unification problem with the expressions


Σ(i − X)i and
i=0
Σ(X − Y )k
k=0

has no solution in the nominal setting. One could argue that a solution could be obtained instantiating [X '→ i][Y '→ i] and renaming k as i. But this is not possible since i should be a “fresh” name in the scope of the second sum in order to proceed with this renaming, and the chosen substitution contradicts this condition. In other words, the meta-variable X should be instantiated uniformly throughout the problem. We can specify that a name is fresh for a term by writing a freshness constraint, for example, i#t states that the name i is fresh in the term t. In general, if two nominal terms are unifiable, the unifier is a pair consisting of a substitution and a set of freshness constraints.
Translations between nominal unification problems and higher-order pattern uni- fication problems are given in [6,15].

Contribution
In this paper, we present a functional specification of a new nominal unification algorithm and formalise its correctness and completeness in the language of the higher-order proof assistant Prototype Verification System (PVS) [17]. PVS was chosen because it has a large library about term rewriting systems ([11]) and our nominal unification theory extends this background about rewriting.

This paper is accompanied with the whole PVS development for nominal uni- fication, which includes specifications of all notions and definitions as well as for- malisations of the proofs of all lemmas and theorems given in this paper. The development is available for download in the PVS theory for term rewriting sys- tems trs.cic.unb.br.
The style of our specification is close to the functional presentations of Robin- son’s first-order unification algorithm, and the formalisation avoids the use of in- termediate equivalence relations, obtaining in a straightforward manner transitivity and symmetry of the nominal α-equivalence relation. Indeed, in [21], a “weak equiv- alence” is used in order to simplify the proof of transitivity for the standard nominal α-equivalence. However, in this paper, we present an even simpler proof, avoiding formalisations of properties of this weak intermediate relation. This is obtained following the analytic scheme of proof shown in [9].
The nominal unification algorithm given in Isabelle/HOL in [19] is essentially specified as the transformation rule system presented in [18]. These rules transform unification problems with their associated freshness contexts into simpler ones. This approach is very elegant and allows a higher level of abstraction that simplifies the analysis of computational properties such as termination and uniqueness of solu- tions, but it is not so useful in implementations due to its inherent non-determinism (regarding the application of the transformation rules).
Here we present a new nominal unification algorithm that has only two nominal terms (but no freshness context) as inputs, as in [5,14]. However, the algorithms presented in [5,14] focus on efficiency, whereas our goal is to formalise the proof of correctness by specifying the algorithm in PVS as a recursive function “unify” working directly on terms and formalising separately properties of contexts. Al- though the function “unify” does not carry freshness contexts, it builds them at the end of the execution together with the substitution solution. The freshness prob- lems generated during the recursive computation are solved separately due to the independence of solutions for freshness and without involving extra fresh variables as usual in a nominal setting. This differs from the treatment given in [14] where freshness constraints, as well as suspensions, are encoded as equations, that was proved equivalent to the treatment in [5] in [4].

Related work
There are formalisations of nominal theories in other proof assistants. The most relevant formalisation has been implemented in Isabelle/HOL [20], where α- equivalence between terms is effectively obtained by representing terms as “abstrac- tion functions”. Thus, Urban [20] presents some basic conditions that are sufficient to guarantee the equivalence between two representations of terms. Then, an in- duction principle is presented, to obtain proofs by induction over abstracted terms in a more natural way. For instance, the Substitution Lemma (well-known in the context of λ-calculus) was formalised using these techniques.
A similar work was done in Coq [1], but bound variables were encoded by using de Bruijn indices and the terms were defined as having the type of locally nameless

terms. An induction principle was implemented in order to prove properties about well-formed terms without mentioning indices.
Another formalisation in Isabelle/HOL is available in [19], to deal with nom- inal unification following [18]. This formalisation is closer to ours in the sense that α-equivalence is defined under some side-conditions (namely, freshness condi- tions). The properties formalised in this system include the fact that the specified α-equivalence is indeed an equivalence relation, termination and soundness of the unification algorithm and characterisation of the normal forms generated by the algorithm.
In [21], Urban compares the proof of transitivity of the α-equivalence relation presented in [19,9] and [13]. The proof shown in the last citation was then con- sidered the best because it avoids a more complex inductive scheme on the size of terms. However, it requires the implementation of a “weak-equivalence” relation as a workaround. Here, we follow auxiliary lemmas developed in [9], but with a simpler proof of transitivity by induction on the structure of terms obtaining directly the necessary result that the specified α-equivalence relation is indeed an equivalence relation.
The specification of our algorithm, passing as parameters only pairs of terms to be unified, is closer to functional presentations in the style of Robinson’s first-order unification that have been formalised in a variety of proof assistants (e.g., [16,2]).

Organisation
Section 2 presents the basic concepts and grammar used in the nominal context. Section 3 defines freshness and α-equivalence and makes explicit (subsection 3.1) the details about the proof of transitivity of α-equivalence used in previous for- malisations in comparison with the ones strictly necessary in the current approach. Also, this section (subsection 3.2) presents a function that computes the minimal freshness context needed to derive a freshness constraint. This is crucial to obtain a unification algorithm that does not need to carry freshness contexts continuously. Section 4 presents the main contributions of this paper: the specification of a func- tional algorithm to solve nominal unification problems and the formalisation of its soundness and completeness.

Preliminaries
This section presents some basic definitions: permutations, terms and substitutions, which are needed to reason about a nominal unification algorithm.
Definition 2.1 Atoms or names are basic structures in the context of nominal theories. They represent object-level variables; the set A of all atoms is countably infinite. A swapping (a b) is a bijection from A into A that exchanges a and b and that fixes any other atom. Permutations are also bijections of the form π : A→ A, which change a finite number of atoms and that are represented as lists of swappings. Then, the action of a permutation over atoms is recursively defined

as:
id(c)= c , where id is the null list;
((a b) ◦ π)(c)=  a , if π(c)= b;	b , if π(c)= a;	π(c) , otherwise.
The inverse of π is the reverse list of swappings and it is denoted by π—1.
Definition 2.2 Let Σ and V be a signature with function symbols and a countably infinite set of variables, respectively. Then, the set T (Σ, A, V) of nominal terms is generated by the following grammar:
t ::= a¯ | π · X | () | (t1, t2) | [a]t | f t ,
where a¯ is an atom, π · X is a suspension (a permutation π suspended in the variable X ∈ V), () is the unit or empty tuple, (t1, t2) is a pair of terms, [a]t is an abstraction (a term with the atom a abstracted) and f t is an application (a symbol f ∈ Σ applied to a term).
Notice that to encode terms in PVS, we distinguish between the atom a and the term a¯ that consists of the atom a (compare with the constructor at in the following code of the data structure of terms). Also, the function application works for symbols with arity one. To represent a greater arity, one can use pairs to encode tuples with any number of arguments. For instance, if the symbol f has arity 3, then we can describe the term f (t1, (t2, t3)) using the present grammar. The next specification of terms in PVS allows us to have induction schemes generated automatically.
term[atom:TYPE+, perm:TYPE+, variable:TYPE+, symbol:TYPE+ ]:DATATYPE BEGIN
at (a: atom): atom?
* (p: perm, V: variable): susp? unit: unit?
pair (term1: term, term2: term): pair? abs (abstr: atom, body: term): abs? app (sym: symbol, arg: term): app?
END term
Definition 2.3 The depth of a term is computed by the following function:
depth(a¯)= depth(π · X)= depth( ()) = 0	depth([a]t)=1 + depth(t) depth((t1, t2)) = 1 + max(depth(t1), depth(t2))	 depth(f t)=1 + depth(t)
The function depth is used as part of the measure provided to ensure termination of the nominal unification algorithm.
Actions of permutations can be homomorphically extended over terms. This means that permutations only change atoms and are accumulated into suspensions. A precise definition is given below.
Definition 2.4 The action of a permutation π over terms is defined as:

π • a¯ = π(a)	π • (πj · X)= (π ◦ πj) · X	π • () = ()
π • (t1, t2)= (π • t1,π • t2)	π • [a]t = [π(a)]π • t	π • f t = f π • t

One important observation is that the variables in suspensions work as meta- variables, where a substitution that replaces variables by terms is a primitive notion. With this in mind, it is reasonable that nominal variables are not ‘abstractable’. The denomination ‘suspension’ for π · X has to do with the fact that the permutation π cannot indeed apply to X until the instance of this variable is known; so it is suspended.
In PVS, permutations are specified as lists of pairs of atoms. The function act applies a permutation to an atom by the recursive action of the swappings that represent the permutation. On the other hand, the function ext extends the action of permutations to terms homomorphically, i.e., it applies act to atoms and accumulates permutations in suspensions.
perm: TYPE = list[[atom,atom]]
act(pi:perm)(c): RECURSIVE atom =
CASES pi OF
null: c,
cons((a,b),rest): LET d = act(rest)(c) IN
IF d = a THEN b ELSIF d = b THEN a ELSE d
ENDIF
ENDCASES MEASURE pi BY <<

ext(pi:perm)(t:term): RECURSIVE term =
CASES t OF
at(a): at(act(pi)(a)),
*(pm, v): *(append(pi, pm), v), unit: unit,
pair(t1,t2): pair(ext(pi)(t1),ext(pi)(t2)),
abs(ab, bd): abs(act(pi)(ab), ext(pi)(bd)), app(sl, ag): app(sl, ext(pi)(ag))
ENDCASES MEASURE t BY <<

Remark 2.5 The necessity of ‘measure’ functions in PVS recursive functions is for proving termination according to the operational semantics of termination of PVS. This measure on the parameters should decrease after each recursive call. In the previous functions the measure ‘<<’ represents the standard measure on the data structures of permutations and terms; respectively, length of lists and the subterm relation. In some cases, as for these functions, the system can automatically verify the decrement of the measure provided.
Definition 2.6 A nuclear substitution is a pair of the form [X '→ s], where X
is a variable and s is a term, and its action over terms is defined as:


a¯[X '→s]= a¯
(π · Y )[X '→s]= ⎧⎨ π · Y , if X /= Y
⎩ π • s , otherwise

()[X '→s]= ()	(t1, t2)[X '→s]= (t1[X '→s], t2[X '→s])
[a]t[X '→s]= [a](t[X '→s])	(f t)[X '→s]= f (t[X '→s])
A substitution σ is a list of nuclear substitutions, which are applied one-by-one over terms, i.e:
tId = t , where Id is the empty list;	t (σ ◦ [X '→ s]) = (t σ)[X '→ s].

Notation: If σ and γ are two substitutions, then σγ represents the composition of such substitutions, i.e., σ ◦ γ.
Remark 2.7 This notion of substitution is different from the simultaneous appli- cation of nuclear substitutions. This approach is closer to triangular substitutions as explored in [13], with the view to be more space efficient.
Definition 2.8 The set of variables of a term is recursively computed by the function V ars, as follows.
Vars(a¯)= ∅	Vars(π · X)= {X}	Vars( ()) = ∅
Vars((t1, t2)) = Vars(t1) ∪ Vars(t2)	Vars([a]t)= Vars(t)	Vars(f t)= Vars(t)
The next lemma states the invariance of alternating the application of a permu- tation and a substitution on a term.
Lemma 2.9 For any term t, π • (tσ)= (π • t)σ.
Proof. By induction on the structure of t.	2
Freshness and α-equivalence
As mentioned earlier, [18] presented an algorithm to decide α-equivalence of nominal terms, based on a notion of freshness of names in terms, without the necessity of generating new names.
Definition 3.1 (Freshness) A freshness context ∇ is a finite set of pairs of the form a#X. We say that an atom a is fresh in t under ∇ (denoted by ∇ ▶ a#t) if it is possible to build a proof of this judgement using the rules:

Notation: If ∇ and Δ are freshness contexts, then ∇▶ Δ means that Δ ⊆∇ and
∇Δ denotes ∇∪ Δ.
The following two auxiliary lemmas express invariance of derivability in the pre- vious calculus under the action of permutations and weakening of freshness contexts.
Lemma 3.2 ∇▶ a#t ⇔∇▶ π • a#π • t.
Lemma 3.3 If ∇▶ Δ and Δ ▶ a#t, then ∇▶ a#t.

The proofs are by induction on the derivation of Δ ▶ a#t.
Now, with the notions of permutation and freshness, α-equivalence can be de- fined in a formal way.
Definition 3.4 (α-equivalence) The terms t and s are α-equivalent in the con- text ∇, denoted by ∇ ▶ t ≈α s, if there is a proof of this judgement using the rules:

where ds(π, πj) = {b ∈ A | π(b) /= πj(b)} (namely, the difference set between two permutations) and ds(π, πj)#X is the context formed by the pairs b#X, for each b ∈ ds(π, πj).

A direct formalisation of transitivity of α-equivalence
The next four auxiliary lemmas relate α-equivalence, freshness and the action of permutations. The first one expresses preservation of freshness by α-equivalent terms; the second one, alternation of the action of a permutation and its inverse on α-equivalent terms; the third one, invariance of α-equivalence under the action of a permutation; and, the fourth one, preservation of α-equivalence of a term under the action of permutations whose difference set is fresh in the term.
Lemma 3.5 ∇▶ a#s and ∇▶ s ≈α t implies ∇▶ a#t.
Lemma 3.6 ∇▶ s ≈α π • t ⇒∇▶ π—1 • s ≈α t.
Lemma 3.7 ∇▶ s ≈α t ⇔∇▶ π • s ≈α π • t.
Lemma 3.8 ∇▶ ds(π1, π2)#t implies ∇▶ π1 • t ≈α π2 • t.
Lemmas 3.5-3.8 are proved by induction on s, applying Lemma 3.2. For Lemma 3.6, Lemma 3.5 is applied. The treatment is the same as in previous papers ([18,9,21]) and their complete formalisations are available in the accompanying PVS development.
The proof of the next lemma is shown in detail because, at this point, the formalisation differs from the one given in [19] and reported in [21].
Lemma 3.9 (Transitivity of α-equivalence) The relation ≈α is transitive un- der a given context ∇, i.e., ∇▶ t1 ≈α t2 and ∇▶ t2 ≈α t3 imply ∇▶ t1 ≈α t3.
Proof. The proof is by induction on the structure of t1.

t1 = a¯: then by definition of ≈α, t2 = t3 = a¯.
t1 = π1 · X: so t2 = π2 · X and t3 = π3 · X. We need to prove that ds(π1, π3)#X ⊆
∇. So, take c such that π1 • c /= π3 • c. There are two cases: if π1 • c = π2 • c, then π2 • c /= π3 • c and c#X ∈ ∇ for ds(π2, π3)#X ⊆ ∇; if π1 • c /= π2 • c, then c#X ∈∇ because ds(π1, π2)#X ⊆ ∇.
t1 = () implies t2 = () and t3 = ().
t1 = (s1, s2): then t2 = (u1, u2) and t3 = (w1, w2). By induction hypothesis (IH),
∇▶ s1 ≈α w1 and ∇▶ s2 ≈α w2.
t1 = f s: then t2 = f u and t3 = f w. By IH, ∇▶ s ≈α w.
t1 = [a]s: then t2 = [b]u and t3 = [c]w. It is necessary to compare the abstractors:
a = b = c: thus the result follows by IH trivially.
a = b /= c: by definition, ∇▶ s ≈α u and ∇▶ u ≈α (b c) • w and ∇▶ b#w. By IH, ∇ ▶ s ≈α (b c) • w. As a = b, then freshness condition is satisfied to a as well.
a /= b = c: we have ∇ ▶ a#u, ∇ ▶ s ≈α (a c) • u and ∇ ▶ u ≈α w. By Lemma 3.7, ∇ ▶ (a c) • u ≈α (a c) • w and, by IH, ∇ ▶ s ≈α (a c) • w. By Lemma 3.2, ∇▶ c#(a c) • u and ∇▶ c#(a c) • w by Lemma 3.5. Finally, again by Lemma 3.2, ∇▶ a#w.
b /= a = c: it is known that ∇ ▶ s ≈α (b c) • u and ∇ ▶ u ≈α (b c) • w. Then,
∇▶ (b c) • u ≈α w by Lemma 3.6. By IH, ∇▶ s ≈α w.
a /= b /= c /= a: it is necessary to prove that ∇▶ s ≈α (a c)•w and ∇▶ a#w. Let us prove first freshness: by definition of ≈α, ∇ ▶ a#u and ∇ ▶ u ≈α (b c) • w. By Lemma 3.5, ∇ ▶ a#(b c) • w and, by Lemma 3.2(⇐), ∇ ▶ a#w. Now let us prove α-equivalence: by hypothesis, ∇ ▶ s ≈α (a b) • u, ∇ ▶ u ≈α (b c) • w and ∇ ▶ b#w. By Lemma 3.7, ∇ ▶ (a b) • u ≈α (a b)(b c) • w. As ds((a b)(b c), (a c)) = {a, b} and both atoms are fresh in w, then ∇ ▶ (a b)(b c) • w ≈α (a c) • w by Lemma 3.8. Now, applying IH twice, one obtains
∇▶ s ≈α (a c) • w.
2

Note that the critical point in this proof is the abstraction, particularly when all the abstractors differ. This is due to the asymmetry of rule (≈αabsb) in Def- inition 3.4. The previous lemma was also presented in [18,9], but in [21], a weak equivalence notion (Definition 3.10) is used as an intermediate relation to contour the problem with the abstraction case. However, auxiliary lemmas similar to the ones presented here were necessary in [21], in addition to other technical results to deal specifically with this weak equivalence (some of those additional lemmas in [21] are particular cases of transitivity). In the current formalisation, weak equivalence was not needed and the abstractions were treated as given in the five cases in the proof of Lemma 3.9.

Definition 3.10 (Weak-equivalence) Given two terms s, t, they are said to be
weak equivalent (notation: s ∼ t) whenever there exists a derivation of s ∼ t

using the following rules:

In the previous definition, observe that when s ∼ t, then s and t differ only in possible representations of permutations π and πj in suspended variables. Even so, the action of those permutations must be equal. Thus, the relation ∼ actually is closer to syntactic equality than to α-equivalence. To obtain transitivity of ≈α using this definition, several auxiliary steps are necessary, among others, proving that ∼ is invariant under the action of permutations, preservation of freshness by weak-equivalent terms, etc. These lemmas are similar to the previously mentioned for ≈α. In addition, it is necessary to prove that, under a freshness context Δ, (≈α ◦ ∼) ⊆ ≈α, which is the key property for concluding transitivity of ≈α. All this work is unnecessary in our approach.
Lemma 3.11 (Equivalence) ≈α is an equivalence relation under any context ∇.
Proof. Transitivity is guaranteed by Lemma 3.9. Reflexivity (∇ ▶ t ≈α t) and symmetry (∇ ▶ t ≈α s implies ∇ ▶ s ≈α t) are easy to verify through an inductive proof on the structure of t. The interesting case is the proof of symmetry for abstractions with different abstractors. In this case, ∇ ▶ [a]tj ≈α [b]sj means
∇ ▶ tj ≈α (a b) • sj and ∇ ▶ a#sj. Applying (a b) to the freshness, we obtain
∇▶ b#(a b) • sj and, by Lemma 3.5, ∇▶ b#tj. Now, by IH, ∇▶ (a b) • sj ≈α tj and, by Lemma 3.6, ∇▶ sj ≈α (a b) • tj. This proves ∇▶ [b]sj ≈α [a]tj.	2
Notice that, unlike the proofs given in [18,21], this formalised proof of symmetry does not use transitivity. Thus, these two properties are independent from each other.
Minimal Freshness Contexts
A solution for a unification problem is a pair (∇, σ) of a freshness context and a substitution (see Section 4). A nominal unification algorithm should generate “most general solutions” with respect to an ordering “≤” as in the first-order case (see Definition 4.12). In the current formalisation, a function was specified that can compute a minimal freshness context ∇ which derives a freshness problem a#t when possible, i.e., ∇ ▶ a#t and ∇ is a subset of any other context Δ such that Δ ▶ a#t.
In the next function, the measure “<<” denotes the proper subterm relation that is generated by PVS when the abstract data structure specified for terms is type-checked. As for the example in Remark 2.5, termination with respect to this measure can be automatically verified.

Definition 3.12 Let a be an atom and t be a term. Define the function ⟨ # ⟩sol that takes as input the pair (a, t) and outputs a freshness context and a Boolean, as follows:
⟨a#t⟩sol :=	CASES OF t :
¯b : (∅,a /= b),
π · X : ({π−1 • a#X},T rue),
() : (∅,T rue),
(t1, t2): LET (Δ1, b1)= ⟨a#t1⟩sol, (Δ2, b2)= ⟨a#t2⟩sol
IN IF b1 = b2 = True THEN (Δ1Δ2,T rue)
ELSE (∅,False),
[b]tˆ: IF a = b T HEN (∅,T rue) ELSE ⟨a#tˆ⟩sol, f tˆ: ⟨a#tˆ⟩sol
MEASURE <<
The function above was taken from the transformation rules related to the uni- fication algorithm in [18]. The difference is that here the freshness solutions are obtained separately from the substitutions which solve the equational problems in the unification algorithm. In this way, it is clear that the freshness constraints can restrict the validity of a unification problem, but they cannot modify the substitu- tion that solves the problem.
The following lemma formalises the correctness of the previous definition.

Lemma 3.13 (Correctness of	(#
b = True ⇒ Δ ▶ a#t, and
s⟩ol) Take (Δ, b)= ⟨a#t⟩sol. Then,

for any ∇, ∇▶ a#t ⇒ b = True and ∇▶ Δ.
Proof. The proof is by induction on the structure of t. The interesting case is when t = (t1, t2), because to use rule (#pair), we need to have the same context in the derivations ∇ ▶ a#t1 and ∇ ▶ a#t2. However, the function ⟨ # ⟩sol returns minimal contexts Δ1 and Δ2 to t1 and t2, respectively. For this reason, Δ1 and Δ2 have to be joined when computing ⟨ # ⟩sol. Then, using Lemma 3.3, it is possible to enlarge the contexts into the derivations Δ1Δ2 ▶ a#t1 and Δ1Δ2 ▶ a#t2 in order to be able to use the mentioned rule.	2
This function is crucial to build independently a freshness context for a whole nominal unification problem from its partial solutions, and it is used in the recursive treatment for the case of abstractions and pairs as will be explained in the next section.
Notation: The function ⟨·⟩sol can be generalised to sets of freshness constraints. In particular, ⟨∇σ⟩sol = (Δ,True), where Δ is the union of all the freshness contexts computed by ⟨a#(id· X)σ⟩sol, for each a#X ∈ ∇, if every subproblem is consistent, and ⟨∇σ⟩sol = (∅,False) otherwise.
The notation Δ ▶ ∇σ states that Δ ▶ a#(id · X)σ is derivable for all a#X ∈ ∇.
Nominal unification algorithm
In order to construct a nominal unification algorithm as a recursive function in the specification language of PVS, it is necessary to provide a recognisable answer

in cases of failure, because PVS does not allow partial functions. To deal with failure, our algorithm will return triplets of the form (∇, σ, b), which are a freshness context, a substitution and a Boolean, respectively, instead of pairs of the form (∇, σ). The triplet of the form (∅,Id,False) identifies failure cases and triplets of the form (∇, σ,T rue) successful cases with solutions of the form (∇, σ). For the sake of efficiency, in failure cases, the freshness context and the substitution are cleared into ∅ and Id respectively. If any branch fails, then it is not worth to carry partial solutions throughout recursive calls.
Definition 4.1 (Unifiable terms and unifiers) Two terms t, s are said to be unifiable if there exists a context ∇ and a substitution σ such that ∇▶ tσ ≈α sσ. Under these conditions, the pair (∇, σ) is called a unifier of t and s.
Definition 4.2 (Nominal Unification Function) Let t, s be two nominal terms.
Then, we define the function
unify(t, s) := IF s = πs · Xs AND Xs ∈/ Vars(t) THEN (∅, [Xs '→ π−1 • t],T rue)
ELSE
CASES OF (t, s): 
(πt · X, πs · X): (ds(πt, πs)#X, Id, T rue),
(πt · Xt, s): IF Xt ∈/ Vars(s) THEN (∅, [Xt '→ π−1 • s],T rue),
(a¯, a¯): (∅, Id, T rue),
((), ()) : (∅, Id, T rue),
((t1, t2), (s1, s2)) : LET (∇1, σ1, b1)= unify(t1, s1),
(∇2, σ2, b2)= unify(t2σ1, s2σ1),
(∇3, b3)= ⟨∇1σ2⟩sol
IN (∇2∇3, σ1σ2, b1 ∧ b2 ∧ b3),
([a]tˆ, [b]sˆ): IF a = b T HEN unify(tˆ, sˆ)
ELSE LET (∇1, σ, b1)= unify(tˆ, (a b) • sˆ),
(∇2, b2)= ⟨a#sˆσ⟩sol
IN (∇1∇2, σ, b1 ∧ b2),
(f tˆ, f sˆ): unify(tˆ, sˆ),
ELSE : (∅, Id, False) MEASURE lex(|Vars(t, s)|, depth(t))

The measure function provided (see Remark 2.5) is lexicographic, with first com- ponent the number of variables in the unification problem and second component the depth of the first term of the unification problem.
The next remarks explain how the function ⟨ # ⟩sol correctly builds the neces- sary contexts for the abstraction and pair cases avoiding passing as parameter the freshness contexts, as done in unification mechanisms based on transformation rules (cf. [19]). In these remarks, unifiable terms are considered.
Remark 4.3 In case of pairs, (∇2∇3, σ1σ2) has to be a unifier for (t1, t2) and (s1, s2), i.e., ∇2∇3 ▶ t1σ1σ2 ≈α s1σ1σ2 and ∇2∇3 ▶ t2σ1σ2 ≈α s2σ1σ2. Initially, unify builds the unifier (∇1, σ1) for t1 and s1. Afterwards, (∇2, σ2) is computed as a unifier for t2σ1 and s2σ1. If ⟨∇1σ2⟩sol = (∇3,True), then ∇1 ▶ t1σ1 ≈α s1σ1 implies ∇3 ▶ t1σ1σ2 ≈α s1σ1σ2. Finally, since ∇2 ▶ t2σ1σ2 ≈α s2σ1σ2, weakening the contexts we obtain the desired unifier.

Remark 4.4 When unifying two abstractions with different abstractors, the an- swer (∇1∇2, σ) has to be a unifier for [a]t and [b]s. Indeed, initially the recursive call unify(t, (a b) • s) provides a unifier (∇1, σ) for this problem, if it is possible. Hence, ∇1 ▶ tσ ≈α (a b) • sσ, but not necessarily ∇1 would be able to derive a#sσ. Then, ⟨ # ⟩sol computes the minimal context ∇2 which derives a#sσ separately. Joining both contexts, the derivation ∇1∇2 ▶ [a]tσ ≈α [b]sσ can be completed.
Example 4.5 Take the problem of unifying (X, X) and ((a b)·X, a). First, one uni- fies X and (a b) · X. The result is the substitution Id and the context {a#X, b#X}. Then, to unify X Id and aId, we need the substitution [X '→ a] and the empty context ∅. Then, {a#X, b#X} is updated with [X '→ a], and ⟨a#a⟩sol returns failure.
Formalisation of termination of the function unify is not obtained automatically and requires human intervention to show that lex(|Vars(t, s)|, depth(t)) decreases in each recursive call. Observe that there are recursive calls in the cases of pairs, abstractions and applications. In the last two cases one advances on the structure of the first (and second) terms calling recursively a problem with the same number of variables, but smaller depth. The same happens for the first recursive call in the case of pairs. For the second recursive call of the case of pairs, when unify(t2σ1, s2σ1) is computed, if σ1 /= Id, the number of variables in the problem decreases for the nature of the nuclear substitutions generated in suspensions. So it is necessary to prove that the substitutions generated by unify have a special characterisation, as explained in the next lemma.
Definition 4.6 (Type  Subs(s)  substitutions) The substitution [X1  '→
t1] ... [Xn '→ tn] is said to be of type Subs(s) if

  Vars((Xi, ti)) ⊆ Vars(s) and Xi ∈/ Vars(ti), ∀i = 1,..., n.
i=1
Lemma 4.7 (Decrement of variables for substitutions of type Subs(s))
Let σ be a substitution of type Subs(s).
Vars(tσ) ⊆ Vars((t, s)).
σ /= Id implies that |Vars(tσ)| < |Vars((t, s))|.
Proof. By induction on the length of σ.
If σ = Id, then obviously Vars(t) ⊆ Vars((t, s)). If σ = σj[X '→ u], then tσ =

(tσj)[X '→ u]. By IH, Vars(tσj) ⊆ Vars((t, s)). As X
∈/ Vars(u), it is known

that Vars(tσ)= Vars(tσj[X '→ u]) = Vars((tσj, u)) \ {X} ⊆ Vars((t, s)) \ {X} ⊆ 
Vars((t, s)).
From (i), Vars(tσj[X '→ u]) ⊆ Vars((t, s)) \ {X}. Since X ∈ Vars(s), the cardi- nality indeed decreases, i.e., |Vars((t, s)) \ {X}| = |Vars((t, s))|− 1.
2
Lemma 4.8 (Type of subsitutions built by unify) If unify(t, s) = (∇, σ, b),

then the substitution σ is of type Subs((t, s)).
Proof. This is easily checked observing the nuclear substitutions generated in the cases of suspended variables. Note that, one condition to build [X '→ π—1 • u], for instance, is X ∈/ Vars(u).	2
The last two lemmas ensure termination for the function unify:
Corollary 4.9 (Termination of unify) The function unify is total.
Notation: It is said that Δ ▶ σ ≈α γ if, for any Y , Δ ▶ (id · Y )σ ≈α (id · Y )γ.
An auxiliary lemma regarding the action of α-equivalent substitutions over a term is necessary for the formalisation of the completeness of the unification algo- rithm and it is presented below.
Lemma 4.10 Δ ▶ σ ≈α γ implies Δ ▶ tσ ≈α tγ, for all term t.
Proof. By induction on the structure of t.	2
The next results are the most difficult part of the formalisation (fully available at trs.cic.unb.br). Soundness and completeness formalisations follow the same inductive proof technique and the analysis of cases are also analogous. Thus, we focus only on completeness.
Lemma 4.11 (Soundness) Let (∇, σ, b) be the solution for unify(t, s). If b =
True, then (∇, σ) is a uniﬁer of t and s.
Proof. The proof is by induction on lex(|Vars((t, s))|, depth(t)).	2
The previous lemma alone is not enough in the sense that, if the algorithm returns always False, then no unifier is provided, even to unifiable terms. The next theorem guarantees that the algorithm actually gives a unifier whenever the terms are unifiable and that the answer is the most general unifier.
Definition 4.12 (More general solutions) Let ∇, Δ be two contexts and γ, σ
two substitutions. Then (∇, γ) ≤ (Δ, σ) if there exists θ such that
Δ ▶ ∇θ and Δ ▶ γθ ≈α σ.
If (∇, γ) is the least unifier for a unification problem according to “≤”, then it is a
most general unifier (mgu).
Theorem 4.13 (Completeness) Let (∇, γ, b) be the solution for unify(t, s). If there exists any other solution (Δ, σ) for the uniﬁcation problem, i.e., Δ ▶ tσ ≈α sσ, then b = True and (∇, γ) ≤ (Δ, σ).
Proof. The proof is by induction on lex(|Vars(t, s)|, depth(t)). There are some cases to consider: either t or s are suspensions or both have the same structure, that is, t and s are units or abstractions, for instance. That is due to the α-equivalence between tσ and sσ and the fact that σ cannot change the structure of a term, unless when acting over suspended variables. The proof follows distinguishing cases

according to the form (t, s). Below, we present the cases where s is a suspension, both are pairs, and both are abstractions; these are the most interesting cases.
(t, π · X) and X ∈/ Vars(t) : so Δ ▶ tσ ≈α (π · X)σ = π • (Xσ) by Lemma 2.9. We need to prove (∅, [X '→ π—1 • t]) ≤ (Δ, σ). By definition of ≤, it is necessary to provide θ such that ∀Y : Δ ▶ Y [X '→ π—1 • t]θ ≈α Y σ. Instantiate it with σ.
Y /= X implies Δ ▶ Y [X '→ π—1 • t]σ = Yσ ≈α Y σ.
Y = X: Δ ▶ tσ ≈α π • (Xσ) implies Δ ▶ π—1 • (tσ) ≈α Xσ, by Lemma 3.6. As
X[X '→ π—1 • t]σ = π—1 • tσ, the α-equivalence is derivable.
((t1, t2), (s1, s2)) : by hypothesis, Δ ▶ t1σ ≈α s1σ and Δ ▶ t2σ ≈α s2σ. By IH, unify(t1, s1)= (∇1, γ1,True) and (∇1, γ1) ≤ (Δ, σ), i.e.,
there exists θ such that Δ ▶ ∇1θ and Δ ▶ γ1θ ≈α σ.
By Lemma 4.10, transitivity and symmetry, Δ ▶ t2γ1θ ≈α s2γ1θ, that is, (Δ, θ) is a unifier for t2γ1 and s2γ1.
Using IH again, with unify(t2γ1, s2γ1) = (∇2, γ2,True), we obtain Δ ▶ ∇2θ˜
and Δ ▶ γ2θ˜ ≈α θ for some θ˜.
As unify((t1, t2), (s1, s2)) = (∇1γ2∇2, γ1γ2, b), all we need to prove is that Δ ▶
γ1γ2θ˜ ≈α σ and Δ ▶ ∇1γ2θ˜ (because Δ ▶ ∇2θ˜ follows by IH).
By Lemma 4.10, for any variable Y , it is possible to derive
Δ ▶ (id · Y γ1)γ2θ˜ ≈α (id · Y γ1)θ ≈α id · Y σ.
So, by transitivity, Δ ▶ γ1γ2θ˜ ≈α σ holds.
Finally, as Δ ▶ γ2θ˜ ≈α θ and Δ ▶ ∇1θ, then Δ ▶ ∇1γ2θ˜ by Lemmas 3.5 and
4.10.
([a]tˆ, [b]sˆ) : by premisse, Δ ▶ a#sˆσ and Δ ▶ tˆσ ≈α (a b) • (sˆσ); by Lemma 2.9, the latter term is equal to ((a b) • sˆ)σ.
By IH, unify(tˆ, (a b) • sˆ)= (∇1, γ,True) and (∇1, γ) ≤ (Δ, σ), i.e.,
there is θ such that Δ ▶ ∇1θ and Δ ▶ γθ ≈α σ.
By Lemma 3.5, Δ ▶ a#sˆσ implies Δ ▶ a#sˆγθ. As θ cannot eliminate any inconsistency in “a#sˆγ”, then Δ ▶ a#sˆγ.
By Lemma 3.13, as ⟨ # ⟩sol is complete, so ⟨a#sˆγ⟩sol = (∇2,True).
Thus, the algorithm computes unify([a]tˆ, [b]sˆ) = (∇1∇2, γ,True). To show that (∇1∇2, γ) ≤ (Δ, σ), we only need to see that Δ ▶ ∇2θ. Finally, since (∇2,True)= ⟨a#sˆγ⟩sol and Δ ▶ a#sˆγθ, then the result follows by Lemma 3.13.
2
Example 4.14 The notions of β and η-reduction for the λ-calculus can be defined using a nominal rewriting system [9]. In this example, the signature contains term- formers λ of arity 1, and app and subst of arity 2. Below, application is denoted by juxtaposition and subst([a]X, Y ) is written X[a '→ Y ] as usual (syntactic sugar). Freshness contexts are used in rewrite rules to express conditions on the matching

substitutions used to generate the rewrite relation.
(Beta)	▶ (λ[a]X)Y	→ X[a '→ Y ] (Eta) b#Z ▶ λ[b](Z b)	→ Z
(σapp)	▶ (XXj)[a '→ Y ] → X[a '→ Y ]Xj[a '→ Y ] (σvar)	▶ a[a '→ X]	→ X
(σLam) b#Y ▶ (λ[b]X)[a '→ Y ] → λ[b](X[a '→ Y ]) (σє) a#X ▶ X[a '→ Y ]	→ X
To analise one of the overlaps between (Beta) and (Eta), we can compute unify((λ[a]X)Y, Z b) = (∅, [Y '→ b][Z '→ λ[a]X],True) and apply the resulting substitution to the freshness context {b#Z}, obtainig ({b#X},True). In the case that the version a#Z ▶ λ[a](Z a) → Z of (Eta) is chosen, then the solution of unify((λ[a]X)Y, Z a) is (∅, [Y '→ a][Z '→ λ[a]X],True) and ⟨{a#Z}[Y '→ a][Z '→ λ[a]X]⟩soL = (∅,True).
Conclusions and future work
In this work, a nominal unification algorithm that only takes terms as parameters was presented. Unlike other approaches, which use transformation rules and take the corresponding freshness problems as part of the unification problem, here we have designed a function that can compute the freshness contexts separately. Our nominal unification algorithm is more straightforward and closer to the ones that implement first-order unification.
Additionally, we formalised transitivity for ≈α in a direct manner without using a weak intermediate relation as in [21]. Here, the proof was based on elementary lemmas about permutations, freshness and α-equivalence; such lemmas are well- known in the context of nominal unification. In [21], the same auxiliary lemmas to demonstrate transitivity were proved, including some extra lemmas to deal with this weak-equivalence. We believe that the current formalisation of transitivity of ≈α is simpler in the sense that it only uses the essential notions and results. Symmetry of ≈α is also formalised independently from transitivity, diverging from [18,21].
The style of proof formalised here could have been formalised in any higher- order proof assistant; PVS was chosen with the goal of enriching the libraries for term rewriting systems, as mentioned in the introduction. Important fea- tures of PVS such as dependent types can be replaced by other mechanisms in Isabelle/HOL, for instance. For example, the substitution generated in the compu- tation of unify(t, s) must be of type Subs unif(t,s) (this is the PVS specification for the type Subs((t, s)) in Definition 4.6) in order to prove termination. In Is- abelle/HOL, this is overcome by defining substitutions in a slightly different way. PVS also allows to use type variables when defining a theory; those variables can be parameterised when such theory is imported by another one. In Isabelle/HOL,

parameterising theories is not straightforward, but functions can be defined poly- morphically, which provides different feasible solutions for the same kind of formal- isation. Of course, a formalisation in Isabelle/HOL will bring out the possibility of a direct comparison regarding the previous formalisations of unification in [19], but it should be emphasised that the advantages of the current formalisation arise from the differences in the theoretical proofs.
Future work: Although nominal approaches have several advantages in the treat- ment of bound variables, there is still work to be done regarding the study of relevant computational properties. At a first glance, a subsequent study to be done is apply- ing nominal unification for the construction of a nominal completion algorithm `a la Knuth-Bendix as part of a PVS development for nominal rewriting. A completion algorithm for closed nominal rewriting systems is provided in [10].
Another possible application of this formalisation of the nominal unification al- gorithm is in the verification of nominal resolution approaches (as done, for instance, in the propositional case in [7]).

References
B. Aydemir, A. Bohannon, and S. Weihrich. Nominal Reasoning Techniques in Coq (Extended Abstract). Electronic Notes in Theoretical Computer Science, 174(5):69–77, 2007.
A. B. Avelar, A. L. Galdino, F. L. C. de Moura, and M. Ayala-Rinco´n. First-order unification in the PVS proof assistant. Logic Journal of the IGPL, 22(5):758–789, 2014.
M. Ayala-Rinc´on and F. Kamareddine. Unification via the λse-Style of Explicit Substitution. Logic Journal of the IGPL, 9(4):489–523, 2001.

C. Calv`es. Unifying Nominal Unification. In 24th International Conference on Rewriting Techniques and Applications, RTA 2013, volume 21 of LIPIcs, pages 143–157, 2013.
C. Calv`es and M. Ferna´ndez. The first-order nominal link. In Logic-Based Program Synthesis and
Transformation - 20th International Symposium, LOPSTR 2010, Revised Selected Papers, volume 6564 of Lecture Notes in Computer Science, pages 234–248. Springer, 2010.
J. Cheney. Relating nominal and higher-order pattern unification. In Proceedings of the 19th International Workshop on Unification (UNIF 2005), pages 104–119, 2005.
R. Constable and W. Moczydlowski. Extracting the resolution algorithm from a completeness proof for the propositional calculus. Annals of Pure and Applied Logic, 161(3):337–348, 2009.
G. Dowek, T. Hardin, and C. Kirchner.	Higher-order Unification via Explicit Substitutions.
Information and Computation, 157(1/2):183–235, 2000.
M. Ferna´ndez and M. J. Gabbay. Nominal Rewriting. Information and Computation, 205(6):917–965, June 2007.
M. Fern´andez and A. Rubio. Nominal Completion for Rewrite Systems with Binders. In Automata, Languages, and Programming - 39th International Colloquium, ICALP 2012, Part II, volume 7392 of
Lecture Notes in Computer Science, pages 201–213, 2012.
A. L. Galdino and M. Ayala-Rinc´on. A Formalization of the Knuth-Bendix(-Huet) Critical Pair Theorem. Journal of Automated Reasoning, 45(3):301–325, 2010.
G. P. Huet. A Unification Algorithm for Typed λ-Calculus. Theoretical Computer Science, 1:27–57, 1975.
R. Kumar and M. Norrish. (Nominal) Unification by Recursive Descent with Triangular Substitutions. In Interactive Theorem Proving, First International Conference, ITP 2010, volume 6172 of Lecture Notes in Computer Science, pages 51–66. Springer, 2010.


J. Levy and M. Villaret. An efficient nominal unification algorithm. In Proceedings of the 21st International Conference on Rewriting Techniques and Applications, RTA 2010, volume 6 of LIPIcs, pages 209–226, 2010.
J. Levy and M. Villaret. Nominal unification from a higher-order perspective. ACM Transactions on Computational Logic, 13(2):10, 2012.
L.C. Paulson. Verifying the Unification Algorithm in LCF. Science of Computer Programming, 5(2):143–169, 1985.
N. Shankar, S. Owre, J. M. Rushby, and D. W. J. Stringer-Calvert. PVS Prover Guide. Technical report, SRI International, 2001. http://pvs.csl.sri.com/doc/pvs-prover-guide.pdf.
C. Urban, A. M. Pitts, and M. Gabbay. Nominal Unification. Theoretical Computer Science, 323(1- 3):473–497, 2004.
C. Urban. Formalisation of Nominal Unification in Isabelle/HOL. Technical report, TU Munich, 2004. http://www4.in.tum.de/~urbanc/Unification, last visited April 2015.
C. Urban. Nominal Techniques in Isabelle/HOL. Journal of Automated Reasoning, 40(4):327–356, 2008.
C. Urban. Nominal Unification Revisited. In Proceedings 24th International Workshop on Unification, UNIF 2010, volume 42 of Electronic Proceedings in Theoretical Computer Science, pages 1–11, 2010.
