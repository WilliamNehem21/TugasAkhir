	Electronic Notes in Theoretical Computer Science 97 (2004) 3–23	
www.elsevier.com/locate/entcs




Interfaces: A Game-Theoretic Framework for Reasoning About Component-Based Systems
Luca de Alfaro and Mari¨elle Stoelinga1 ,2
Department of Computer Engineering, UC Santa Cruz, USA


Abstract
Traditional type systems specify interfaces in terms of values and domains. When we apply a function to an argument, or when we compose two functions, we have to check that their types match.
Interface models extend type systems with the ability to reason about the dynamic behavior of design components. For instance, interface models are able to capture temporal-ordering constraints on component interaction, such as constraints on the ordering of method calls or protocol messages, timing constraints on a component’s input and output signals, and constraints on the usage of shared resources. Like type systems, interfaces specify both the input assumptions a component makes on its environment and the output guarantees it provides.
Interfaces are based on two-player games in which the system plays against the environment. The moves of the environment (player Input) represent the inputs that the system can receive from the environment, that is, the input assumption of the system. Symmetrically, the moves of the system (player Output) represent the possible outputs that can be generated by the system. Interfaces are built around the concepts of (1) well-formedness, requiring that the input assumptions of an interface be satisfiable; (2) compatibility, asking whether two components can be used in a way that satisfies the input assumptions of both components; (3) composition of compatible interfaces; and
(4) refinement, asking whether one component (being an implementation) correctly implements another one (being the specification).
This paper provides a tutorial-style introduction to interfaces and discusses the basic concepts and ideas. In particular, we elaborate on the automaton-based interfaces from [12] and the timed interfaces from [14]. Due space limitations, we do not treat the notion of interface refinement, but we refer the reader to [12] and [10].
Keywords: Component-based design, behavioral type system, game theory.



1 This research was supported in part by the NSF CAREER award CCR-0132780, the NSF grant CCR-0234690, and the ONR grant N00014-02-1-0671.
2 Email: {luca,marielle}@soe.ucsc.edu


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.030

Introduction

The prevalent trend in software and system engineering is towards component- based design: systems are designed by combining components, some of them off-the-shelf, other application-specific. The appeal of component-based de- sign is twofold: it helps to tame complexity through decomposition, and it facilitates reuse. Components offer the unit in which complex design prob- lems can be decomposed, allowing the reduction of a single complex design problem into smaller design problems, more manageable in complexity, that can be solved in parallel by design teams. Components also provide a unit of design reuse, defining the boundaries in which functionality can be packaged, documented, and reused.
Components are designed to work as parts of larger systems: they make assumptions on their environment, and they expect that these assumptions will be met in the actual environment. For instance, a software component may require its objects to be initialized before any other methods are called. Hence, the effective reuse of software requires adequate documentation of the components’ behavior and the conditions under which it can be used, along with methods for checking that components are assembled in an appropriate way.
We describe here a formal notion of component interfaces that provides a framework for the specification and analysis of component interaction. The interface models we describe are able to capture dynamic aspects of compo- nent interaction, and are in many respects similar to type systems: indeed, they could be termed a “behavioral” type system for component interaction. In previous work, we have introduced interface theories for various aspects of interaction: [12,6,7] consider the temporal order in which method calls (or messages) occur, [14] reasons about timing constraints on a component’s input and output signals, [8] deals with constraints on the resource usage of the com- ponent and [13] presents a general theory of interfaces. This tutorial focuses on two of these models: interface automata [12] and timed interfaces [14], and presents the underlying ideas first in a simple, untimed setting, subsequently extending them to deal with real-time input and output specifications.
Interfaces support component-based design in the following ways.
Interface specification. An interface specifies how a component interacts with its environment. It describes the input assumptions the component makes on the environment and the output guarantees it provides. A simple example of an interface is a type in a programming language. The type int → real specifies that a function expects integers as input (input assumption) and

produces reals (output guarantee). A slightly more complicated type is given in Figure 1(b), where a component produces a real z and expects two integers x and y such that y = 0 whenever x = 0. These types are two examples of static interfaces, i.e. they do not change during the execution of the program. An example of a dynamic type, where the input assumptions and output guarantees can vary with the state of the system, is given in Figure 2(a). This interface automaton models the interface of a 2-place buffer, where state bi represents the buffer containing i messages. In each state, the automaton models the inputs the component can receive (input assumption) and the outputs it can produce (output guarantee). In particular, the input action snd? 3 is not enabled in state b2, modeling that the buffer cannot receive any messages when it is full. Similarly, the buffer does not produce an output rec! in state b0, modeling that it does not create messages out of the blue if it is empty. Thus, the buffer requires its environment not to send a message while it is in state b2 and guarantees that it will not produce one in state b0.
Well-formedness checking. When constructing an interface, we have to make sure that it is well-formed , i.e. that there exists at least one environment that satisfies its input assumptions. Otherwise, the interface is useless, since it cannot be used in any design. While rather straightforward in the untimed case, well-formedness becomes more complicated in the timed case, where time progress requirements have to be taken into account.
Interface Composition. Due to the presence of input assumptions, we have to check for compatibility when we assemble a system from two (or more 4 ) components. That is, when we put together two components P and R, we have to make sure that P ’s output guarantees imply R’s input assumptions and vice versa. Since the composition of two components is generally still an open component, it depends on the environment (of the composite system) whether or not these input assumptions are met. This phenomenon is known as migration of constraints: constraints migrate from the components to the composite system. We are interested in the most liberal assumptions on the composite system that ensures compatibility of the components. For exam- ple, consider again the interface P1 in Figure 1(b), producing a real z and expecting two integers x, y with y = 0 whenever x = 0. Now, we compose P1 with component P2 in Figure 1(a). The latter has no inputs (hence, no

3  Here and in subsequent examples, the marks ? and ! are appended to an action to indicate whether it is input or output, respectively, but they are not part of the action name itself.
4  Since composition is commutative and associative, multi-component composition can
be obtained via binary composition by successively composing a single component with a system that was previously composed from other components.


		

P2.
P1.
Fig. 1. Migration of constraints
P1  P2.

input assumptions) and can output any integer. To ensure that P1’s input assumption x = 0 =⇒ y = 0 is met, we require that the input x is never set to 0. 5 Since x /= 0 is the weakest predicate with this property, the input assumption of the composition P1  P2 is exactly x /= 0. Its output guarantee is y : int and z : real, see Figure 1(c).
Summarizing, the composition of two interfaces yields a new interface for the composite system. The input assumptions of the new interface guarantee that the input assumptions of the composed interfaces are met; the output guarantees of the new interface combine the output guarantees of the com- posed interfaces. The compatibility and composition of interface automata will be explained later in this paper.
Compatibility checking. If the input assumption of the composite system P  R is equivalent to false, i.e. P  R is not well-formed, then no environment can make P and R work together. In this case P and R are called incompatible. In other words, P and R are compatible if and only if there is at least one environment that makes P and R mutually satisfy their input assumptions.
Interfaces as games. An interface is naturally modeled as a game between the players Output and Input. Output represents the component: the moves of Output represent the possible outputs generated by the component (output guarantees). Input represents the environment: the moves of Input represent the inputs accepted from the environment (input assumptions).
Then, an interface is well-formed if the Input player has a winning strategy in the game, i.e., the environment can meet all input assumptions. For timed interfaces, we need the additional well-formedness condition that a player must not achieve its goal by blocking time forever. When two interfaces are com- posed, the combined interface may contain locally incompatible states. These occur when one component interface can generate an output that violates an input assumption of the second. Two interfaces are compatible if there is a way for the Input player, who chooses the inputs of the composite interface, to avoid all local incompatibilities. Interface compatibility is equivalent to

5 If x = 0, then P1’s assumptions may be met, in case P2 happens to provide a non-zero integer, but is not guaranteed to be met, as P2 can set y = 0. To ensure satisfaction of the input assumption for all behaviors of P2, we need x /= 0.

the existence of an environment for the combined interfaces that ensures that the input assumptions of both individual interfaces are satisfied. Component composition thus consists in synthesizing the most liberal input strategy in the composite system that avoid all locally incompatible states. This can be done by classical game-theoretic algorithms.
Consider the interface P1 in Figure 1(b). The Input player chooses values for x and y and the Output player for z. The interface is clearly well-formed, because Input can choose values that meet the input assumptions. When we compose P1 with P2, every state with x = 0, y /= 0 is a locally incompatible state. The Input player of the composite system (who chooses values for x) has a strategy that, irrespective of the Output strategy (in the composite system choosing values for y and z), avoids these states: namely, the strategy that chooses any integer different from 0.
Related work. Models that can encode input assumptions, such as process algebras, usually phrase the compatibility question as a graph, whereas we treat it as a game question. In a graph model, input and output play the same role and two components are considered compatible if they cannot reach a deadlock [16,9,17] In our game-based approach, input and output play dual roles. Two components are compatible if there is some input behavior such that, for all output behaviors, no incompatibility arises. This notion captures the idea that an interface can be useful as long as it can be used in some design. In this respect, interfaces are close to types in programming languages, to trace theory [15], and to game semantics [1,2,4,5]. The reader is referred to [11] for a more elaborate comparison with related work.
Organization of the paper. This paper treats two automaton-based for- malisms for the specification and analysis of interfaces. Section 2 presents interface automata and defines well-formedness, compatibility and composi- tion for these interfaces. In Section 3, we extend interface automata with real-time, yielding timed interface automata. Again, we explore the notions of well-formedness, compatibility and composition. In particular, we explain how timed interfaces deal with time progress conditions, which are needed to ensure that time can advance in every system behavior.

Interface Automata
This section presents an automaton-based interface theory that is capable of expressing assumptions and guarantees on the order in which method calls or signals to the component occur [12]. As one can see from the example in



snd?
b0
rec!
snd?
b1	b2
rec!
rec?
r0	r1
proc!

Buffer B.	(b) Receiver R.


(c) The product B ⊗ R.
(d)
The composition B R.

Fig. 2. Product and composition of interface automata
Figure 2(a), interface automata are similar to normal automata (a.k.a. labeled transition systems or state machines); it is in the notion of composition that interfaces differ from ordinary state machines.
Definition 2.1 An interface automaton P = ⟨SP , Sinit, AI , AO, TP ⟩ consists

of the following elements.
SP is a set of states.
Sinit ⊆ SP is a set of initial states.
P	P	P

I  and AO
are disjoint sets of input and output actions. We denote by

AP = AI ∪ AO the set of all actions.

TP ⊆ SP × AP × SP
is a set of transitions or steps. We write s−→a	t for
P

(s, a, t) ∈ T . If s−→a
P t for some t ∈ SP , then we say that action a is enabled

in state s.
We require that P is deterministic 6 , that is, (1) Sinit contains at most one
a	a	P
state and (2) if s−→P t and s−→P u then u = t.
For s ∈ SP , we let
ΓI (s)= {a ∈ AI | ∃t ∈ S .s−→a	t} and ΓO(s) = {a ∈ AO | ∃t ∈ S .s−→a	t}
P	P	P	P	P	P	P	P
be respectively the sets of Input and Output moves at s. These sets s express the input assumptions and output guarantees of P : at state s, only the actions
in ΓI (s) are accepted as inputs. In particular, no input in AI \ ΓI (s) can be
P	P	P
accepted when P is at s. Symmetrically, when P is at s, only actions actions in
ΓO(s) can be produced. We say that P is well-formed if Sinit /= ∅. Ill-formed
P	P
interfaces correspond to the input assumption false and are not useful: no

6 This requirement is not present in [12], but simplifies the technicalities, while the main concepts are the same.

environment can interact with such interfaces in a meaningful way.
The behavior of a player, i.e. the successive choices being made in the course of the game, is given by a strategy. A strategy is a function that, given the history of the game, i.e. a sequence of states, yields zero or more of the player’s enabled moves.
Definition 2.2 (Strategies and outcomes) An input (resp. output ) strategy

for P is a mapping πI : S+
'→ 2AI
(resp., a mapping πO : S+
'→ 2AO )

such that, for all s ∈ SP and all σ ∈ S∗ , we have πI(σ s) ⊆ ΓI (s) (resp.
P	P
πO(σ s) ⊆ ΓO(s)). We denote by ΠI and ΠO the set of input and output
P	P	P
strategies of P , respectively.
An input and an output strategy jointly determine a set of outcomes in S+: at each step, if the input strategy proposes a set BI of input actions, and the output strategy proposes a set BO, an action from BI ∪ BO is selected nondeterministically. Since our definitions of compatibility and composition do not require the consideration of progress properties, we define the outcomes of strategies in terms of finite traces.
Definition 2.3 (Strategy outcomes) Given a state s ∈ SP , an input strategy
πI ∈ ΠI and an output strategy πO ∈ ΠO, the set OutcP (s, πI, πO) ⊆ S+ is
P	P	P
the smallest set satisfying the following clauses:
s ∈ OutcP (s, πI, πO);
if σt ∈ OutcP (s, πI, πO) for σ ∈ S+ and t ∈ SP , then for all a ∈ πI(σ t) ∪
O	'	P a	'	'	I	O
π (σ t) and for all t ∈ SP such that t→− P t , we have σt t ∈ OutcP (s, π ,π ).
We say that a state s occurs in an outcome s0 ... sn (written by slight abuse of notation s ∈ s0 ... sn) if there is k ∈ [0..n] such that s = sk. A state
s ∈ SP is reachable in P if there are strategies πI ∈ ΠI and πO ∈ ΠO and
a state s0 ∈ Sinit such that s appear some an outcome in Outc(s0, πI, πO); otherwise s is unreachable.

Compatibility and Composition
We define the composition of two interface P and R in four steps. First, we require that P and R are composable, i.e. that their action signatures match. If so, we define the product P ⊗R as the classical automaton-theoretic product, where P and R synchronize on shared actions and evolve independently on others. Within this product, we identify a set of locally incompatible states, where P can produce an output that is not accepted by R, or vice versa. Finally, we obtain the composition P  R from P ⊗R by strengthening the input assumptions of P ⊗ R in such a way that all locally incompatible states are

avoided, thus ensuring that P and R mutually satisfy their input assumptions.
Definition 2.4 (Composability) Two interface automata P and R are com- posable if AO ∩ AO = ∅. We let shared P,R = AP ∩ AR to be the set of shared
P	R
actions of P and R.
The product of two composable interface automata P and R is an interface automaton P ⊗ R that represents the joint behavior of P and R. The state space of P ⊗ R consists of pairs (s, t), reflecting that P is in state s and R is in state t. In the product, the shared actions of P and R are synchronized: whenever an automaton performs a transition involving a shared action, the other automaton should also do so; if it cannot, the transition is not part of the product. The automata interleave asynchronously all non-shared actions: one automaton takes a step, while the other stays in the same state.
Definition 2.5 (Interface product) If P and R are composable interface au- tomata, their product P ⊗ R is the interface automaton defined by
SP ⊗R =SP × SR
Sinit  =Sinit × Sinit
P ⊗R	P	R
AO	=AO ∪ AO
P ⊗R	P	R
AI	=(AI ∪ AI ) \ AO
P ⊗R	P	R	P ⊗R

TP ⊗R
={(s, t)−→a (s', t) | s−→a
{(s, t)−→a (s, t') | t−→a
P s' ∧ a ∈ AP Rt' ∧ a ∈ AR
\ AR}∪ 
\ AP }∪ 

{(s, t)−→a (s', t') | s−→a
s' ∧ t−→a
Rt' ∧ a ∈ AP
∩ AR}.

Example 2.6 The automaton R in Figure 2(b) represents the interface of a receiver component. In state r0, R can receive a message, in which case it moves to the state r1. In r1, it processes the message and moves back to r0. Since R cannot receive a message in state r1, it can hold only one message at the time. The product B ⊗ R is displayed in Figure 2(c). Note that B and R synchronize on rec! and evolve independently on proc! and snd?.
The product P ⊗ R may contain states in which one of the components (say P ) can produce an output action that is an input action of the other automaton (R), but is not accepted. This constitutes a violation of the input assumptions of P , and such states are said to be locally incompatible.
Definition 2.7 (Locally incompatible states) Given two composable interface automata P and R, the set Error (P, R) of locally incompatible states is defined

by
Error (P, R) =  (s, t) ∈ SP × SR ∃a ∈ shared P,R . a ∈ ΓO(s) \ ΓI (t)∨
a ∈ ΓO(t) \ ΓI (s) }.
Example 2.8 The state (b1, r1) is an error state in the product B ⊗ R (Fig-
ure 2(c)), because there is b −r−e→c! b  in B but rec? /∈ ΓI (r ).
1	0	R  1
After forming the product P ⊗ R of P and R, we must strengthen the input assumptions of P ⊗ R to ensure that no local incompatibility is reached. This corresponds to synthesizing the weakest input assumption that ensures that both the original input assumptions of P and R are respected. This is an example of assumption propagation: the original assumptions of P and R propagate and combine into a new, and possibly stronger, assumption for their composition P  R. To this end, we say that a state of P ⊗ R is incompatible if a locally incompatible state can be reached regardless of how we constrain the environment. That is, s is incompatible if there is no input strategy that from s avoids all locally incompatible states. For example, if B ⊗ R is in the state (b2, r0), no matter how we constrain the environment, the system cannot be prevented from taking the rec!-transition, leading to the error state (b1, r1). This is because the environment can only influence the system through its input actions, and rec! is an output action.
Definition 2.9 (Compatible states) A state s of P ⊗ R is called compatible
with respect to Error (P, R) if there is πI ∈ ΠI	such that, for all πO ∈ ΠO	,
all σ ∈ OutcP ⊗R(s, πI, πO), and all w ∈ Error (P, R), we have w /∈ σ. We write Cmp(P, R) for the set of compatible states and Incmp(P, R)= SP ⊗R \ Cmp(P, R) for the set of incompatible ones.
Example 2.10 With reference to Figure 2(c), Incmp(B, R)= {(b1, r1), (b2, r0)}.
Since input strategies can only prevent input actions from occurring, but cannot restrict output actions, we have that a state is incompatible iff it can reach a local incompatibility by following output actions only. This observa- tion provides an efficient criterion for checking the compatibility of states.
Lemma 2.11 A state s ∈ SP ⊗R is compatible in P ⊗ R with respect to
Error(P, R) iff there is no sequence s0s1 ... sn ∈ S∗	with s0 = s, sn ∈

Error(P, R), and such that for all 0 ≤ k < n, there is ak ∈ ΓO
(sk) with

ak
k	P ⊗R  k+1
P ⊗R

If the initial state of P ⊗ R is incompatible, then no environment of P ⊗ R can avoid entering the error state. Therefore such interfaces P and R are incompatible.

Definition 2.12 (Compatibility) Two composable interface automata P and
R are incompatible if Sinit ∩ Cmp(P, R)= ∅. They are compatible if Sinit ∩
Cmp(P, R) /= ∅.
Example 2.13 The interfaces B and R are clearly compatible, as the initial state (b0, r0) is so with respect to Error (B, R). Indeed, in state (b0, r1) the environment can prevent entering error states by not providing the input snd?. Hence, while the state (b0, r1) itself does not have to be avoided, its outgoing snd? action should be avoided. This is achieved automatically by removing the incompatible state (b1, r1), along with the transitions leading to it.
This example illustrates how strengthening the input assumptions to avoid locally incompatible states can be performed by simply pruning all incompat- ible states, along with the transitions leading to them.
Definition 2.14 (Interface composition) For two composable interface au- tomata P and R, the composition P  R is an interface automaton with the

same action sets as P ⊗ R. The states are SP R = Cmp(P, R), Sinit
init P ⊗R

Cmp(P, R), and the steps are TP R = TP ⊗R∩(Cmp(P, R)×AP R×Cmp(P, R)).
Example 2.15 The composition B  R, displayed in Figure 2(d), is obtained by removing the incompatible states (b2, r0) and (b1, r1) from B ⊗ R. Notice how the constraint that R can only hold one message migrates from R to the composition B  R. The input assumptions of B  R require that no message must arrive before the previous one has been processed. In state (b0, r1), where the receiver already holds a message, this is achieved by disabling the snd? action. To prevent entering (b2, r0) (and hence (b1, r1)), the action snd? also has to be disabled in state (b1, r0). Again, the sender should not provide a new message until R has processed the old one, but now the old message is still in the buffer.
Properties of Interface Automata
Let a proper environment for P and R be an interface automaton E such that:
E is well-formed;
E is composable with P ⊗ R;

E synchronizes on every output action of P ⊗ R, i.e. AI
P ⊗R;

if (s, t) ∈ Error (P, R), then (u, s, t) is unreachable in E ⊗ P ⊗ R, for every state u ∈ SE.
The result below shows that two automata are compatible if there exists at least one environment that makes the automata satisfy each other’s input assumptions.

Theorem 2.16 Let P and R be composable interfaces. The following state- ments are equivalent.
P and R are compatible,
P  R is well-formed,
there exists a proper environment for P and R.
The following result states that composition is transitive, i.e. that the order in which we compose multiple components is irrelevant, if we restrict our attention to the reachable states. We write P ≡ R if P and R are identical once we remove all unreachable states.
Theorem 2.17 Let P, R and M be pairwise composable interface automata. Then (P  R)  M ≡ P  (M  R).

Timed Interface Automata
This section extends the interface automaton model with timing constraints, yielding timed interface automata [14]. A timed interface automaton augments an interface automaton with a set of real-valued clocks. Clocks occur in lo- cation invariants and transition guards, respectively specifying deadlines and enabling conditions on the actions of the interface. Timed interface automata are syntactically similar to timed automata [3], except that they have two kinds of invariants, one for input and one for output actions. Semantically, however, the two models differ: timed automata are interpreted as labeled transition systems, while timed interfaces are interpreted as timed games.
The timed interface model
The timed interface automaton B in Figure 3(a) represents a 1-place buffer, which delivers messages within 1 to 4 time units. The clock x measures the time since the last arrival of a message. In location 7 b0, the buffer is empty and can receive a message. Upon receiving a message, it moves to location b1, and it resets the clock x. The output invariant x ≤ 4 in location b1 specifies that the location must be left before x > 4, thus forcing a delivery (action snd!) within 4 time units. The transition guard 1 ≤ x specifies that the action snd! can be taken if 1 ≤ x, thus enabling a delivery after 1 time unit. Note that all time is spent in locations; transitions are instantaneous, i.e. take no time. The timed interface in Figure 3(b) represents a component that must re- ceive a message every 2 to 7 time units: the clock y measures the time between

7 The nodes of timed interface automata are called locations, because the word ‘state’ already refers to a location together with a clock valuation, see below.



b0	snd? rec!
x := 0 	
b1
1 ≤ x
r0 	
I : y ≤ 7
2 ≤ y
rec?
y := 0

(a) Timed buffer B.	(b) Timed receiver R.

(b0 , r0)
snd?	x := 0
O : x ≤ 4
(b ,r )

I : y ≤ 7
	 rec! 1 ≤ x ∧ 2 ≤ y
y := 0
1  0
I : y ≤ 7

The product B ⊗ R.

(b0 , r0)
snd?
x := 0
O : x ≤ 4
(b ,r )

I : y ≤ 3
	 rec! 1 ≤ x ∧ 2 ≤ y
y := 0
1  0
I :1 ≤ 3

The composition B  R.
Fig. 3. Product and composition of TIAs

two consecutive message receipts. The input invariant y ≤ 7 forces the input action rec? to be taken within 7 time units of the previous receipt. The tran- sition guard 2 ≤ y says that this action can be taken after a minimum delay of 2 time units. Thus, invariants express when actions must be taken and guards express when they can be taken. Guards and invariants are specified by clock conditions, that are any boolean combination of formulas of the form x ≺ c or x − y ≺ c, where c is an integer, x, y are clocks in a given set X, and ≺ is either of < or ≤. We denote the set of all clock conditions over X by K[X].
Definition 3.1 (Timed interface automaton) A timed interface automaton
(or TIA) is a tuple P = (QP , qinit, XP , AI , AO, Inv I , Inv O, TP ) consisting of

P
the following components.
QP is a finite set of locations.
P	P	P	P

qinit ∈ QP is the initial location.
XP is a finite set of clocks.
I  and AO are finite and disjoint sets of immediate input and output ac-

tions, respectively. Let AP = AI
∪ AO
denote the set of all immediate

actions of P .
Inv I : QP → K[XP ] maps each location of P to its input invariant.
Inv O: QP → K[XP ] maps each location of P to its output invariant.
TP ⊆ QP ×K[XP ]×AP ×2XP ×QP is the transition relation. For (q, g, a, r, q') ∈ TP , q ∈ QP is the source of transition, q' ∈ QP is the destination, g ∈ K[XP ] is the transition guard , a ∈ AP is an immediate action, and r ⊆ XP is a reset set , containing the clocks that are reset. We require the transition relation to be deterministic: for all q ∈ QP and a ∈ AP , there is at most one tuple of the form (q, g, a, r, q') with (q, g, a, r, q') ∈ TP . We sometimes

g a r
write q−−→P
q' for (q, g, a, r, q') ∈ TP .

The Game underlying an Interface
We unfold a TIA P into a game structure [P ] by explicitly recording the clock values in P and by separating the transition relation −→P into an input
transition relation −→I	and an output transition relation −→O .
A valuation over a set X of clock variables is a function v: X '→ R≥0 that assigns a clock value to every clock in X. We write 0X (or just 0 if X is clear from the context) for the valuation that assigns 0 to all clocks in X . Other clock valuations are often listed as a set of pairs, as in {x = 1,y = 3}. The set of all clock valuations is denoted by Val(X) and for clock valuation v and a clock expression g, we can determine whether g holds for this valuation. If so, we write v |= g. For example, if v(x)= 1 and v(y)= 3, then v |= x − y ≤ 0. For a valuation v ∈ Val(X), we write v + d for the valuation defined by (v + d)(x) = v(x)+ d for all x ∈ X . Given a set r ⊆ X of clocks, we write v[r := 0] for the valuation that maps x to 0 if x ∈ r, and otherwise to v(x).
Let P be a TIA with components (Q, qinit, X, AI, AO, Inv I, Inv O, T). We obtain [P ]] from P as follows. The states (q, v) of [P ] consist of a location q in P and a clock valuation v ∈ Val(X ). Thus, a state records the location of the interface and the values of all its clocks. Initially, all clocks are 0 and the two invariants have to be met. That is, [P ] has an initial state (qinit, 0) if 0 meets the invariants Inv I(qinit) and Inv O(qinit) of the initial location qinit, (i.e. 0 |= Inv I(qinit) ∧ Inv O(qinit)). Otherwise, [P ] has no initial state.

The input and output transition relations −→I
O
[[P ]]
update the lo-

cation and clock values. We distinguish between timed (or delay) transitions,
which are labeled by delay actions d ∈ R≥0, and immediate transitions, labeled by immediate actions a ∈ A. Let γ be one of the players I or O. A timed transition s−→d γs' represents the passage of d time units: writing s = (q, v), we have s' = (q, v + d). The transition s−→d γs' is enabled if the location invariant Invγ(q) of player γ holds at all times between 0 and d. Writing s = ⟨q, v⟩ and s' = ⟨q', v'⟩, the immediate transition s−→a γs' changes the state as specified by a transition q g a r q' in P . This transition is enabled if (1) the guard of the transition involved is met in s, i.e. v |= g, (2) the player γ’s invariant is met both in the source s and in the destination s' i.e. v |= Invγ(q) and v' |= Invγ(q'), and (3) the clock variables in the set r are reset to 0. The precise definition is as follows.
Definition 3.2 (Game structure of timed interface automaton) A TIA P in-

duces a game structure [P ]], which is a tuple ⟨S[[P ]], Sinit, AI
, AO
, −→I  ,

O
[[P ]]
⟩ consisting of the following components.
[[P ]]
[[P ]]
[[P ]]
[[P ]]

The state set S[[P ]] = {⟨q, v⟩| q ∈ QP , v ∈ Val(XP )}.
The initial states Sinit = {⟨qinit, 0X ⟩| 0X  |= Inv I (qinit) ∧ Inv O(qinit)}.
[[P ]]	P	P	P	P	P	P

The actions are AI
= AI
R≥0	O
[[P ]]
= AO ∪ R≥0.

For γ ∈ {I, O} the transition relations of [P ] contains a transition ⟨q, v⟩−→α γ
⟨q', v'⟩

if one of the following two conditions holds:
Time step: α ∈ R≥0, q = q', v' = v + α, and for all 0 ≤ d' ≤ α, we have
v + d' |= Invγ (q);
P	γ	g α r	'

Discrete step: α ∈ AP , and there is a transition q−−→P q
Invγ (q) ∧ g, v' = v[r := 0], and v' |= Invγ (q').
with v |=

P	P

Example 3.3 The states of [B]] are ⟨b0, {x = d}⟩ and ⟨b1, {x = d}⟩, for every clock value d in R≥0. The transitions of [B]] are

d' I	'
⟨b0, {x = d}⟩−→ ⟨b0, {x = d + d }⟩

d' O
⟨b0, {x = d}⟩−→
⟨b0, {x = d + d'}⟩

⟨b , {x = d}⟩−s−nd→? I⟨b , {x = 0}⟩
0	1
d' O	'	'

⟨b1, {x = d}⟩−→ ⟨b1, {x = d + d ⟩,	for d + d
≤ 4,

⟨b , {x = d}⟩−r−e→c! O⟨b , {x = d}⟩,	for 1 ≤ d.

In each state s of the game [P ], both players propose one of their available moves. That is, each player γ proposes an immediate or timed move α such that s−→α γs', for some s'. The moves proposed by both players together deter- mine a successor state. If both players choose timed moves d and d' ∈ R≥0, then global time will advance by min{d, d'}; if one player chooses an imme- diate move a, while the other chooses a timed move d, the immediate move a will be carried out; if both players choose immediate moves, one of them occurs nondeterministically. Formally, the outcome of two moves is a triple (α, γ, s'), where α is the action being taken, γ is the player who took it and s' the destination state.

Definition 3.4 (Moves and move outcomes) For γ ∈ {I, O},a player-γ move
α
in a state s of [P ] is an action α ∈ AP ∪ R≥0 such that s−→γ s' for some s'.

This state s' is unique and we write δ(s, α) for s'. We indicate with Γγ
(s)

the set of all player-γ moves in state s and Γγ
γ
[[P ]]
∪ R≥0 the set of all

γ-moves.
For all states s ∈ S[[P ]] and all moves αI ∈ ΓI
(s) and αO ∈ ΓO
(s), the

outcome outc[[P ]](s, αI, αO) is given by
outc[[P ]](s, αI, αO)= 




or αI, αO ∈ R≥0, αI < αO.
{(αO, O, δ[[P ]](s, αO))}	if αI ∈ R≥0, αO ∈ AP ,
or αI, αO ∈ R≥0, αI > αO.

 {(αI,I, δ[[P ]](s, αI)), (αO, O, δ[[P ]](s, αO))}	otherwise.
As in the untimed case, the successive choices being made by a player in the course of the game, are given by a strategy and the an input and an output strategy jointly determine a set of outcomes in S+. However, unlike in the untimed case, the time progress conditions require us to consider both finite and infinite outcomes here.
Definition 3.5 (Strategies and strategy outcomes) A strategy for player γ ∈

{I, O} is a function πγ: S+
Γγ
'→ 2 [[P ]]
that associates with every sequence

of states s0s1 ... sn ∈ S+
a subset of moves πγ(s0s1 ... sn) ⊆ Γγ
(sn). We

require that πγ(s0s1 ... sn)= ∅ only when Γγ
(sn)= ∅, thus forcing a strategy

to choose at least one move, if any moves are available. For γ ∈ {I, O}, we

denote by Πγ
the set of all strategies for player γ.

Given a state s ∈ S[[P ]], an input strategy πI ∈ ΠI
, and an output strategy

O	O
[[P ]]
, the set of outcomes Outc[[P ]](s, πI, πO) of πI and πO from s consists

of all finite and infinite sequences σ = s0α1pl 1s1pl 1α2pl 2s2 ... such that
s0 = s;
for all n < length(σ), there are βI ∈ πI(s0s1 ... sn) and βO ∈ πO(s0s1 ... sn) such that (αn+1, sn+1, pln+1) ∈ outc[[P ]](sn, βI, βO).

if length(σ) < ∞, then σ ends in a pair (sk, plk ) such that either ΓI
(sk)= ∅

O
[[P ]]
(sk)= ∅.

A state is reachable if there is a combination of strategies for both players that lead to it.
Definition 3.6 (Reachable states) A state s ∈ S[[P ]] is reachable in [P ]] if there

are strategies πI ∈ ΠI
and πO ∈ ΠO
, a state q0 ∈ Sinit, and an outcome

σ = s0, a1, pl 1, s1,... in Outc[[P ]](q0, πI, πO) such that s = sk for some k ≥ 0.
The objective for a player is to play a strategy that ensures that all game outcomes belong to a set of desirable outcomes, called the goal for that player. We are particularly interested in three kind of goals: the set  U containing

all outcomes that stay within a set of good states U ; the set t div of outcomes along which time progresses; and the set blameγ, where Player γ is blamed for monopolizing the game, i.e. for always playing first from a certain point on.
Definition 3.7 (Interface product) For a TIA P , we define
  U = {σ = s0, a1, pl 1, s1,... ∈ Outc[[P]] | ∀k ≤ length(σ) . sk ∈ U }
blameγ = {σ = s0, a1, pl , s1,... ∈ Outc[[P]] |
length(σ)= ∞∧ ∃n. ∀k ≥ n. plk = γ}
length(σ)

t div = {σ = s0, a1, pl 1, s1,... ∈ Outc[[P]] |
Σ
k=0
delay(ak )= ∞}

Here, for a move α, delay(α)= α if α ∈ R≥0, and delay(α)= 0 otherwise.
Well-formedness
Only game outcomes along which time diverges have a physical meaning. Be- haviors such as s0Is0Os0Is0Os ... and s 1 Is 1 Os 1 Is ... in which total amount
of time Σ∞  delay(a ) is finite (where a 2	4	8 action in the sequence) do
not correspond to behaviors of physical systems. Thus, we want to ensure that
a player never becomes “painted into a corner”, unable to let time diverge re- gardless of how she plays. Of course, a player can never ensure time advances, since the other player could be blocking the advancement of time (for instance, by always playing a time-step of length 0). Hence, we call well-formed the states from which both player can ensure time advances, unless prevented from doing so by the other player. Precisely, we say that a state is well-formed if both players γ can win with respect to the goal t div ∪ blame1−γ. A timed interface is well-formed if all reachable states are well-formed. We refer the reader to [14] for an algorithm that decides whether a TIA is well-formed.
Definition 3.8 (Well-formedness) A state s ∈ S[[P ]] is well-formed if both of the following conditions hold:
Input can win the game with goal t div ∪ blameO ; that is, if for all

strategies πO ∈ ΠO
there is a strategy πI ∈ ΠI
such that σ |= t div ∪

blameO for all outcomes σ ∈ Outc[[P ]](s, πI, πO) and
Output can win the game with goal t div ∪ blameI ; that is, if there is a

strategy πO ∈ ΠO
such that for all strategies πI ∈ ΠI
and outcomes

σ ∈ Outc[[P ]](s, πI, πO), we have σ |= t div ∪ blameI .
The interface P is well-formed if [P ] has an initial state, and every reachable state in [P ] is well-formed.

p	q

Fig. 4. An ill-formed TIA.
The order of the quantification (first over output strategies, then over input strategies) makes the game turn-based. i.e. the Output player chooses its move first and Input can use this move to determine its own move. This is due to the asymmetrical causality relation between inputs and outputs in composition, as explained in [14].
Example 3.9 The timed interface in Figure 4 specifies that in location p an input should come before the deadline x = 1, whereas there is no input action to help the automaton out of p. Note that no environment satisfies the input assumptions of this automaton. Bound by the deadline x ≤ 1, the Input player does not have a strategy to let time pass, when the Output player plays moves with a duration 2. Hence, this interface is not well-formed. The receiver R (Figure 3(b)) is well-formed because (1) the Input player can let time pass: it can play the rec? action if y = 7 and timed move with duration 1 otherwise.
(2) the Output player can let time pass: since there are no output actions, Output can for instance always play moves with a duration 1.

Product and Composition
As in the untimed case, the composition of timed interfaces is defined via the notions of composability, product, error states, and uncontrollable states.
Definition 3.10 Two TIAs P and R are composable if AO ∩ AO = ∅ and
P	R
XP ∩ XR = ∅. We denote by shared P,R = AP ∩ AR their shared actions.
As before, the product of two timed interfaces represents the joint behav- ior of the components, which synchronize on shared actions and interleave asynchronously on non-shared actions. The input invariant in location (s, t) is the conjunction the input invariants in s and t, requiring that the prod- uct automaton should satisfy the deadlines expressed by both automata being composed. The output invariants in s and t are' co'njoined as well. For a
shared action a, the two transitions s g a r t and s' g a r t' yields the transition

g∧g' a r∪r'
(s, s )	'
−−→
−−−→
'

−−−−−−→(t, t ) obtained by conjoining the invariants g and g
the union of r ∪ r' of the reset sets.
and taking

Definition 3.11 (Interface product) Given two composable TIAs P1 and P2, the product P1 ⊗ P2 is the TIA with

QP ⊗P
= QP
× QP , and qinit
= (qinit, qinit).

1	2	1	2
P1⊗P2
P1	P2

XP1 ⊗P2 = XP1 ∪ XP2 .



AI
= (AI ∪ AI
) \ shared P ,P , and AO
= AO ∪ AO .

P1⊗P2
P1	P2
1  2	P1⊗P2
P1	P2

Inv I
(p, q)= Inv I (p)∧Inv I
(q) and Inv O
(p, q)= Inv O (p)∧Inv O (q).

P1⊗P2
P1	P2
P1 ⊗P2
P1	P2

(q ,q ) g1∧g2 a r1∪r2 (q' , q' ) is a transition of P ⊗P iff, for i = 1, 2, if a ∈ A ,
1	2 −−−−−−−−→  1	2	1	2	Pi

then there is a transition q
gi a ri
q') in T
; otherwise q
= q', g
= true,

and ri = ∅.
i−−−→Pi i	Pi
i	i	i

Example 3.12 The product B ⊗ R is of B and R is displayed in Figure 3(c).
The composition of two TIAs is again obtained from their product by strengthening the input assumptions to avoid all error states. In TIAs, input strengthening means strengthening the input invariants. 8 A product of two TIAs may contain two kind of locally incompatible states: I/O-incompatible states and timing-incompatible states. A state is I/O-incompatible when one component can preform an output action that is not accepted by the other component, as in the untimed case.
Definition 3.13 (I/O-incompatible states) Given two composable interface automata P and R, the set Error (P, R) of I/O-incompatible states is defined by
Error (P, R) =  (v, u) ∈ S	× S	∃a ∈ shared	.
 a ∈ ΓO(u) \ ΓI (v) ∨ a ∈ ΓO(v) \ ΓI (u) }.
We write Good (P, R) for the set of states in P ⊗R that are not in Error (P, R).
Example 3.14 The state (b1, r0, {x = 1,y = 1}) is an I/O-incompatible state

in B ⊗ R, because rec! ∈ ΓO
(b1, {x = 1}), but rec? ∈/ ΓI
(r0, {y = 1}). The

state (b1, r0, {x = 3,y = 3}) is I/O-compatible, because rec! ∈ ΓO (b1, {x =
3}) and rec? ∈ ΓI  (r0, {y = 3}).
It is an important property that the set of I/O-incompatible states for a certain location is expressible using clock conditions. The (reachable) I/O- incompatible states in location (b1, r0) of B ⊗ R are given by the clock condi- tion 1 ≤ x ≤ 4 ∧ y < 2.
Timing-incompatible states are the states where at least one of the players cannot let time progress. They typically arise when an input deadline is not met. The state ⟨(b1, r0), {x = 0,y = 3.4}⟩ in B ⊗ R is a timing-incompatible state: due to the invariants, we cannot stay in (b1, r0) forever. However, we can only leave the state by the rec!-transition, which is enabled if x ≥ 1. This means that we have to remain in (b1, r0) for at most one time unit, but if we do

8 It would also make sense to strengthen the guards on input transitions, but we do not need this.

so, the input invariant x ≤ 4 is violated. Hence, ⟨(b1, r0), {x = 0,y = 3.4}⟩ is a timing-incompatible state. A timing-incompatible state is simply a state of the product that is not well-formed: we do not need any additional definition of timing incompatibility.
When avoiding I/O-incompatible states, the input player has to let time diverge: it should not avoid those states by blocking time. Thus, we say that a state s in the product is compatible if the input player has a strategy that, at the same time, avoids the I/O-incompatible states and lets time progress (or blames the Output player). Precisely, s is compatible if Input has a strategy that wins with respect to the goal Good (P, R) ∩ (t div ∪ blameO ).
Definition 3.15 (Compatible states) A state s of [P ⊗ R]] is compatible if for

all strategies πO ∈ ΠO
there is a strategy πI ∈ ΠI
such that all outcomes

σ ∈ Outc[[P ]](s, πI, πO) satisfy σ |= Good (P, R)∩(t div ∪blameO ). The states in SP ⊗R that are not compatible are called incompatible.
Example 3.16 Note that the states in which one of the invariants is violated are always incompatible. By reasoning as in Example 3.14, one can show that every state ⟨(b0, r0), v⟩ or ⟨(b1, r0), v⟩ in B ⊗ R with v(x) > 3 is incompatible.
A crucial result is that, given a location q, the set of states ⟨q, x⟩ from which the Input player can win with respect to the goal  Good (P, R) ∩ (t div ∪ blameO ) is expressible as a clock condition, which we denote by CompatP ⊗R(q). The clock conditions CompatP ⊗R(q) can be computed with the game-theoretical algorithms discussed in [14].
Example 3.17 Example 3.16 shows that
CompatB⊗R(b0, r0)= CompatB⊗R(b1, r0)= y ≤ 3.
The composition P  R is obtained by restricting the product P ⊗ R to the states from which player Input can avoid all incompatible states, that is, by
strengthening the input invariants Inv I	(q) to CompatP ⊗R(q).
Definition 3.18 (Interface composition) The composition P  R of two timed interface automata P and R is obtained from the product P ⊗ R by replacing
for each location q ∈ QP ⊗R the input invariant Inv I	(q) with CompatP ⊗R(q).
The two timed interface automata P and R are compatible if their initial state
satisfies the new input assumptions, or 0 |= CompatP ⊗R(qinit ).
Example 3.19 From the product B ⊗ R, we obtain the composition B  R
shown in Figure 3(d).

Properties of Timed Interface Automata
The result below states that if we compose two well-formed and compatible interfaces, we get a well-formed interface. As well-formedness corresponds to the interface being useful in some environment, we see that composing two useful interfaces that can be used together, yields another useful interface. Note that this result trivially holds in the untimed case.
Theorem 3.20 Let P and R be composable TIAs. If P and R compatible and well-formed, then P  R is well-formed as well.
Corollary 3.21 Let P and R be composable TIAs. Then P and R be com- patible if and only if [[P  R]] has an initial state.
As before, we write P ≡ R if P and R are isomorphic once we remove all unreachable states. Then interface composition is commutative and associa- tive upto ≡.
Theorem 3.22 Let P, R, and M be pairwise composable TIAs. Then, P  R ≡
R  P, and (P  R)  M ≡ P  (R  M ).
We remark that, while associativity of composition usually follows imme- diately from the definition of composition in the standard non-game setting, in our game-theoretic setting it is instead a non-trivial result. In fact, Theo- rem 3.22 states that the input assumptions of a system formed by components P, R, M can be computed compositionally in two equivalent ways: either by first computing the requirements that P and R impose on their environment, and then combining these requirements with those of M , or by first comput- ing the requirements that R and M impose on their environment, and then combining these requirements with those of P . In other words, the order in which we migrate the input requirements from the individual components to a composite design does not matter.

References
S. Abramsky. Semantics of interaction. In H. Kirchner, editor, Trees in Algebra and Programming – CAAP’96, Proc. 21st Int. Coll., Linko¨ping, volume 1059 of Lect. Notes in Comp. Sci., page 1. Springer-Verlag, 1996.
S. Abramsky. Games in the semantics of programming languages. In Proc. of the 11th Amsterdam Colloquium, pages 1–6. ILLC, Dept. of Phylosophy, University of Amsterdam, 1997.
R. Alur and D.L. Dill. A theory of timed automata. Theor. Comp. Sci., 126:183–235, 1994.
S. Abramsky, S. Gay, and R. Nagarajan. A type-theoretic approach to deadlock-freedom of asynchronous systems. In TACS’97: Theoretical Aspects of Computer Software. Third International Symposium, 1997.


S. Abramsky, K. Honda, and G. McCusker. A fully abstract game semantics for general references. In Proc. 13th IEEE Symp. Logic in Comp. Sci., pages 334–344. IEEE Computer Society Press, 1998.
A. Chakrabarti, L. de Alfaro, T.A. Henzinger, Marcin Jurdzin´ski, and F.Y.C. Mang. Interface compatibility checking for software modules. In CAV 02: Proc. of 14th Conf. on Computer Aided Verification, Lect. Notes in Comp. Sci. Springer-Verlag, 2002.
A. Chakrabarti, L. de Alfaro, T.A. Henzinger, and F.Y.C. Mang. Synchronous and bidirectional component interfaces. In CAV 02: Proc. of 14th Conf. on Computer Aided Verification, Lect. Notes in Comp. Sci. Springer-Verlag, 2002.
A. Chakrabarti, L. de Alfaro, T.A. Henzinger, and M.I.A. Stoelinga. Resource interfaces. In Proceedings of the Third International Workshop on Embedded Software (EMSOFT 2003), Lect. Notes in Comp. Sci. Springer-Verlag, 2003.
S. Chaki, S.K. Rajamani, and J. Rehof. Types as models: Model checking message-passing programs. In Proc. 29th ACM Symp. Princ. of Prog. Lang., 2002.
L. de Alfaro. Game models for open systems. In Int. Symposium on Verification celebrating Zohar Manna’s 64th Birthday, volume 2772 of Lect. Notes in Comp. Sci. Springer-Verlag, 2003.
L. de Alfaro. Game models for open systems. In Proceedings of the International Symposium on Verification (Theory in Practice), volume 2772 of Lect. Notes in Comp. Sci. Springer-Verlag, 2003.
L. de Alfaro and T.A. Henzinger. Interface automata. In Proceedings of the 8th European Software Engineering Conference and the 9th ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE), pages 109–120. ACM Press, 2001.
L. de Alfaro and T.A. Henzinger. Interface theories for component-based design. In EMSOFT 01: 1st Intl. Workshop on Embedded Software, volume 2211 of Lect. Notes in Comp. Sci., pages 148–165. Springer-Verlag, 2001.
L. de Alfaro, T.A. Henzinger, and M.I.A. Stoelinga. Timed interfaces. In Proceedings of the Second International Workshop on Embedded Software (EMSOFT 2002), volume 2491 of Lect. Notes in Comp. Sci., pages 108–122. Springer-Verlag, 2002.
D.L. Dill. Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. MIT Press, 1988.
S.K. Rajamani and J. Rehof. A behavioral module system for the pi-calculus. In Proc. SAS 01, Static Analysis Symposium, volume 2126 of Lect. Notes in Comp. Sci., pages 375–394. Springer-Verlag, 2001.
S.K. Rajamani and J. Rehof. Conformance checking for models of asynchronous message passing software. In CAV 02: Proc. of 14th Conf. on Computer Aided Verification, volume 2404 of Lect. Notes in Comp. Sci. Springer-Verlag, 2002.
