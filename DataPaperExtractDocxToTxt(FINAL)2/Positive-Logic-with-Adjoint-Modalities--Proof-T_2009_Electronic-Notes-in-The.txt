

Electronic Notes in Theoretical Computer Science 249 (2009) 451–470
www.elsevier.com/locate/entcs

Positive Logic with Adjoint Modalities: Proof Theory, Semantics and Reasoning about
Information
Mehrnoosh Sadrzadeh 1,2
Computer Laboratory, Oxford University, Oxford, England, UK
Roy Dyckhoff 3
School of Computer Science, St Andrews University,
St Andrews, Scotland, UK

Abstract
We consider a simple modal logic whose non-modal part has conjunction and disjunction as connectives and whose modalities come in adjoint pairs, but are not in general closure operators. Despite absence of negation and implication, and of axioms corresponding to the characteristic axioms of (e.g.) T, S4 and S5, such logics are useful, as shown in previous work by Baltag, Coecke and the first author, for encoding and reasoning about information and misinformation in multi-agent systems. For such a logic we present an algebraic semantics, using lattices with agent-indexed families of adjoint pairs of operators, and a cut-free sequent calculus. The calculus exploits operators on sequents, in the style of “nested” or “tree-sequent” calculi; cut-admissibility is shown by constructive syntactic methods. The applicability of the logic is illustrated by reasoning about the muddy children puzzle, for which the calculus is augmented with extra rules to express the facts of the muddy children scenario.
Keywords: positive modal logic, epistemic, doxastic, distributive lattice, Galois connection, adjunction, information, belief, proof theory

Introduction
Modal logics include various modalities, represented as unary operators, used to formalize and reason about extra modes such as time, provability, belief and knowl- edge, applicable in various areas (we have that of security protocols in mind). Like

1 Support by EPSRC (grant EP/F042728/1) is gratefully acknowledged, as are helpful comments by Yde Venema, Kai Bru¨nnler, Rajeev Gor´e, Greg Restall and Alex Simpson.
2 Email: mehrs@comlab.ox.ac.uk
3 Email: rd@st-andrews.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.102

disjunction and conjunction, modalities often come in pairs, e.g. and : one preserves disjunctions and the other conjunctions. According to the intended ap- plication, further axioms such as monotonicity and idempotence can be imposed on the modalities.
As well as relational (or Kripke) models, one may consider as models for such logics various ordered structures, such as lattices with operators. The question then arises as to what is the simplest way of obtaining a pair of these operators. If the lattice is a Boolean Algebra and thus has negation, any join-preserving operator (such as ) immediately provides us with a meet-preserving one (such as ) by de Morgan duality. In a Heyting Algebra, the lack of De Morgan duality will cause one of these operators to preserve meets only in one direction. What if no negation is present, e.g. in a distributive lattice? The categorical notion of adjunction (aka Galois connection) is useful here: any (arbitrary) join-preserving endomorphism on a lattice has a Galois right adjoint, which (by construction) preserves meets. For example, in category Sup of sup-lattices with join-preserving maps, every such map is residuated, i.e. has a right adjoint.
In this paper, we consider a minimal modal logic where the underlying logic has only two binary non-modal connectives—conjunction and disjunction—and where the modalities are adjoint but have no closure-type properties (such as idempo- tence). As algebraic semantics one may consider a bounded distributed lattice, the modalities thereof being residuated lattice endomorphisms. Examples are residu- ated distributive lattice monoids and Heyting algebras when one argument of their residuated multiplication and conjunction (respectively) is fixed. One may also con- sider a relational semantics. In the proof of relational completeness, the absence of negation prohibits us from following standard canonical model constructions, as we can no more form maximally consistent sets. We overcome this by developing an equivalent Hilbert-style axiomatization for our logic and then using the general Sahlqvist results of [10] based on completion of algebras with operators.
We provide a sequent calculus, which contains, in addition to axioms for the logical constants T, ⊥ only the operational left and right rules for each connective and operator. We prove admissibility of the structural rules of Contraction, Weak- ening and Cut by constructive syntactic methods. In the absence of negation and of closure-type properties for the modalities, developing well-behaved sequent calculus rules for the modalities (in particular the left rule for the right adjoint ) was a challenging task; a calculus not obviously allowing cut-elimination was given in [1]. Our sequents are a generalization of Gentzen’s where the contexts (antecedents of sequents), as well as formulae, have a structure and can be nested. For applica- tion, we augment our calculus with a rule that allows us to encode assumptions of epistemic scenarios, and show that Cut is still admissible.
We interpret our adjoint modalities as information and uncertainty and use them to encode and prove epistemic properties of the puzzle of muddy children. Due to the absence of negation, we can only express and prove positive versions of these epistemic properties. But, our proofs are simpler than the proofs of tra- ditional modal logics, e.g. those in [12]. In a nutshell, in just one proof step the

adjunction is unfolded and the information modality is replaced by the uncertainty modality; in the next proof step, the assumptions of the scenario are imported into the logic via the assumption rule. At this stage the modalities are eliminated and the proof continues in a propositional setting. Since our information modality is not necessarily truthful, we are able to reason about more challenging versions of epistemic scenarios, for example when agents are dishonest and their deceitful com- munications lead to false information. Properties of these more challenging versions have not been proved in traditional modal logic in computer science approaches, like that of [12].
From a proof theoretic point of view, it is the first time that a cut-free sequent calculus has been developed for logics where the underlying propositional logic has no negation and implication and where the modalities are adjoint. There is a gap in the literature on proof theory for modal logic for the combination of the two. The calculi specifically designed to deal with adjoint connectives, such as the display calculi [4,11,16] need to have at least one adjoint binary operator and face a challenge in developing cut-free rules for our positive non-adjoint connectives. Perhaps the closest to our proof systems are deep inference systems; but the modal deep inference systems developed so far, e.g. by Brunnler [6] and Kashima [14] include negation and implication. Of these two formalisms, the closest to ours is that for the tense logic of Kashima. Other than differences in logic (presence of negation and two- sided sequents), which lead to different modal rules (based on de Morgan duality), our proof theoretic techniques have a merit over those of Kashima: (1) we formalize deep substitution in the nested sequents and as a result do not need to develop two different versions of the calculus and prove soundness and completeness separately, and (2) our cut-admissibility proofs are done explicitly via a syntactic construction rather than as a consequence of semantic completeness.
Some proof systems encode modalities by introducing semantic labels to encode accessibility and satisfaction relations; these are better placed to produce cut-free systems for adjoint modalities, e.g. the comprehensive work of Negri [17] and [24] for classical and intuitionistic modal logics. The former in particular can be adapted to provide a cut-free labelled sequent calculus for our logic. However, that these systems are strongly based on the relational semantics of modal logic and mix it with the syntax of the logic does not fit well with the spirit of the algebraic motivation behind our minimal logic.
On the application side, adjoint modalities have been originally used to reason about time in the context of tense logics, e.g. in [19,13]. Their epistemic application is novel and was initiated in the dynamic epistemic algebra of [1,23], constituting a pair of an endowed quantale of “actions” and its right module of “propositions” and abstracting over the Dynamic Epistemic Logic of [2]. Our work provides an answer to two open problems in that work: (1) elimination of the cut rule for [a variant of] the calculus corresponding to the propositional part of the algebra, and
(2) complete relational models and representation theorems for the propositional part.

Sequent calculus for positive logic with adjoint modalities
Sequent Calculus
We refer to our logic as APML for “adjoint positive modal logic”, with the suffix Tree when we consider a tree-style sequent calculus. The set M of formulae m of our logic is generated over a set A of agents A and a set At of atoms p by the following grammar:

m ::= ⊥|T| p | m ∧ m | m ∨ m |  A m | ◆A(m)

Items I and contexts Γ are generated by the following syntax:

I ::= m | ΓA	Γ ::= I multiset

where ΓA will be interpreted as ◆A( Γ), for Γ the conjunction of the interpre- tations of elements in Γ.
Thus, contexts are finite multi-sets of items, whereas items are either formulae or agent-annotated contexts. The use of multi-sets rather than sets makes the role of the Contraction rule explicit, with the rules in a form close to the requirements of an implementation. The union of two multi-sets is indicated by a comma, as in Γ, Γ' or (treating an item I as a one element multiset) as in Γ,I.
If one of the items inside a context is replaced by a “hole” [], we have a context- with-a-hole. More precisely, we have the notions of context-with-a-hole Δ and item- with-a-hole J , defined using mutual recursion as follows:

Δ ::= Γ,J	J ::= [] | ΔA

and so a context-with-a-hole is a context (i.e. a multiset of items) together with an item-with-a-hole, i.e. either a hole or an agent-annotated context-with-a-hole. To emphasise that a context-with-a-hole is not a context, we use Δ for the former and Γ for the latter; similarly for items-with-a-hole J and items I.
Given a context-with-a-hole Δ and a context Γ, the result Δ[Γ] of applying the first to the second, i.e. replacing the hole [] in Δ by Γ, is a context, defined recursively (together with the application of an item-with-a-hole to a context) as follows:
(Γ',J )[Γ] = Γ',J [Γ]	([])[Γ] = Γ	(ΔA)[Γ] = Δ[Γ]A
Given contexts-with-a-hole Δ', Δ, and an item-with-a-hole J , the combinations Δ' • Δ and J • Δ are defined as follows by mutual recursion on the structures of Δ' and J :

(Γ,J ) • Δ = Γ, (J • Δ)	([]) • Δ = Δ	(Δ''A) • Δ = (Δ'' • Δ)A

Lemma 2.1 Given contexts-with-a-hole Δ', Δ, an item-with-a-hole J and a context
Γ, the following hold:
(Δ' • Δ)[Γ] = Δ'[Δ[Γ]]	(J • Δ)[Γ] = J [Δ[Γ]]

Proof. Routine.	 
We have the following initial sequents (in which p is restricted to being an atom):

The rules for the lattice operations and the modal operators are:

The two indicated occurrences of p in the Id rule are principal. Each right rule has its conclusion’s succedent as its principal formula; in addition, the ◆AR rule has ΓA as a principal item and Γ' (which is there to ensure admissibility of Weakening) as its parameter. Each left rule has a principal item; these are as usual, except that the  AL rule has the formula  Am principal as well as the principal item ( Am, Γ)A.
Note that the AL rule duplicates the principal item in the conclusion into the premiss; in examples, we may omit this duplicated item for simplicity. This dupli- cation allows a proof of the admissibility of Contraction, and thus of completeness. To see its necessity, note that the following sequent is (according to the algebraic semantics in Section 3) valid:

◆A( A(m ∨ n)) ≤ (m ∧ ◆A( A(m ∨ n))) ∨ (n ∧ ◆A( A(m ∨ n)))

It is, however, not derivable unless the principal item of  AL is duplicated into the rule’s premiss.
As a standard check on the rules, we show the following:

Lemma 2.2 For every formula m and every context Γ, the sequent Γ,m ▶ m is derivable.
Proof. By induction on the size of m. In case m is an atom, or ⊥, or T, the sequent Γ,m ▶ m is already initial. For compound m, consider the cases. Meet and join are routine. Suppose m is ◆A(m'); by inductive hypothesis, we can derive m' ▶ m', and by ◆AR we can derive Γ, m'A ▶ ◆A(m'), whence Γ, ◆A(m') ▶ ◆A(m') by ◆AL. Now suppose m is  Am'.	By inductive hypothesis,	we can derive (Γ, Am')A, m' ▶ m', and by  AL we get (Γ, Am')A ▶ m'; from this we obtain Γ,m ▶ m by AR.			 
Since we use multisets (for contexts) rather than sets or lists, the rules of ex- change and associativity are inexpressible.
To allow induction on the sizes of items, we need a precise definition, with a similar definition for contexts. The size of a formula is just the (weighted) number of operator occurrences, counting each operator ◆A and  A as having weight 2;
the size of an item ΓA is the size of Γ plus 1, and the size of a context is the sum
of the sizes of its items. The size of a sequent Γ ▶ m is just the sum of the sizes of Γ and m. Note that each premiss of a rule instance has lower size than the conclusion, except for the rule AL, whose presence leads to non-termination of a naive implementation of the calculus.
Lemma 2.3 The following Weakening rule is admissible:
Δ[Γ] ▶ m

Δ[Γ, Γ'] ▶ m Wk 
Proof. Induction on the depth of the derivation of the premiss and case analysis (on the rule used in the last step). Suppose the last step is by ◆AR, with m = ◆Am', and with premiss Γ∗ ▶ m' and conclusion Γ'', Γ∗A ▶ m, so Δ[Γ] = Γ'', Γ∗A. To obtain Δ[Γ, Γ'] from this there are two possibilities. In the first case, Γ occurs inside Γ∗A, and we make a routine use of the inductive hypothesis and reapply ◆AR with the same parameter. In the second case, we just use the ◆AR rule with a different parameter. Other cases are straightforward.	 
Lemma 2.4 The ◆AL and  AR rules are invertible, i.e. the following are admis- sible:

Δ[◆A(m)] ▶ m'
Δ[mA] ▶ m'	◆AInv
Γ ▶  Am   Inv
ΓA ▶ m	A

Proof. Induction on the height of the derivation of the premiss.	 
Lemma 2.5 The ∧L, ∨L and ∧R rules are invertible.
Proof. Induction on the height of the derivation of the premiss.	 
Lemma 2.6 The following Item Contraction rule is admissible
Δ[I, I] ▶ m
Δ[I] ▶ m  IContr

Proof. Strong induction on the size of the item I, with a subsidiary induction on the height of the derivation of the premiss, together with case analysis and the above inversion lemmas. Consider the cases of the last step; first, when I is non-principal, we permute the contraction up and (keeping I fixed) apply the subsidiary induction hypothesis; when the premiss is an initial sequent, so is the conclusion; when the step is by ◆AR with I principal (and thus of the form Γ'A) the premiss of that step has antecedent Γ' from which the copy of I is absent, allowing reuse of the
AR rule to yield Δ[I] ▶ m; and, when I is otherwise principal, the last step is one of the four one-premiss left rules. The AL case is handled by the subsidiary inductive hypothesis (for the two cases, where I is an item ( Am', Γ)A and where it is a formula Am' inside such an item), and the other cases (ΛL, VL, ◆AL) are handled by the invertibility lemmas and the main inductive hypothesis.	 
Corollary 2.7 The following Contraction rule is admissible
Δ[Γ, Γ] ▶ m
Δ[Γ] ▶ m	Contr

Proof. Induction on the size of the context Γ, by Lemma 2.6.	 
 
Lemma 2.8 The rule TL− is admissible:
Δ[T] ▶ m
Δ[Γ] ▶ m TL−

Proof. Induction on the depth of the derivation of the premiss and case analysis.
 
Theorem 2.9 The Cut rule is admissible
Γ ▶ m	Δ'[m] ▶ m'

Δ'[Γ] ▶ m'	Cut

Proof. Strong induction on the rank of the cut, where the rank is given by the pair: (size of cut formula m, sum of heights of derivations of premisses).
We give two of the reductions to illustrate the argument; all the cases are con- sidered in the full version [22] of the paper. Note the use of ◆AInv in the first. The second is one of many cases where the first premiss is an instance of  AR.
The first premiss is an instance of ◆AR.

	Γ ▶ m	 ◆AR
Γ', ΓA ▶ ◆A(m)	Δ'[◆A(m)] ▶ m'
Δ'[Γ', ΓA] ▶ m'	Cut

is transformed to


Γ ▶ m

Δ'[◆A(m)] ▶ m'
Δ'[mA] ▶ m'	◆AInv

Δ'[ΓA] ▶ m'	Cut
Δ'[Γ', ΓA] ▶ m' Wk 
The first premiss is an instance of  AR and the second an instance of  AL, principal

ΓA ▶ m
Δ'[(  Am, Γ')A, m] ▶ m'

Γ ▶  A
m  AR
Δ'[( A
m, Γ')A] ▶ m'	 AL


transforms to

ΓA ▶ m
Δ'[(Γ, Γ')A] ▶ m'	Cut


Γ ▶ Am	Δ'[( Am, Γ')A, m] ▶ m'
Δ'[(Γ, Γ')A, m] ▶ m'	Cut
Δ'[(Γ, Γ')A, ΓA] ▶ m'	Cut

Δ'[(Γ, Γ')A, (Γ, Γ')A] ▶ m' Wk 
Δ'[(Γ, Γ')A] ▶ m	Contr

Proposition 2.10 The following rule (the name K is roughly from [16]) is admis- sible:
Δ[ΓA, Γ'A, (Γ, Γ')A] ▶ m
Δ[(Γ, Γ')A] ▶ m	K
Proof. In the simplest case, Γ and Γ' are just multi-sets of formulae. Let γ =  Γ and γ' = Γ'. The proof uses Cut and is as follows, where a superfix ∗ indicates several instances of a rule:


  .. .	

	.. .	
Δ[ΓA, Γ'A, (Γ, Γ')A] ▶ m

Γ, Γ' ▶ γ
ΛR∗
Γ, Γ'
ΛR∗
▶ γ
Δ[(γ)A
, (γ')A
, (Γ, Γ')A
] ▶ m
ΛL∗

Δ[(Γ
, Γ')A, (Γ, Γ')A
, (Γ, Γ')A
] ▶ m
Cut∗

Δ[(Γ
, Γ')A
] ▶ m
Contr∗

 
The more general case can be handled using a syntactic analog of the interpre- tation function given in the next section, and suitable generalisations of the ΛR∗ and ΛL∗ steps used above.
Semantics
Algebraic Semantics
Definition 3.1 Let A be a set, with elements called agents. A DLAM over A is a bounded distributive lattice (L, T, ⊥) with two A-indexed families {◆A}A∈A : L → L

and { A}A∈A : L → L of order-preserving maps, with each ◆A left adjoint to A. Thus, the following hold, for all l, l' ∈ L:

l ≤ l' implies ◆A(l) ≤ ◆A(l')	(1)
l ≤ l' implies  A(l) ≤  A(l')	(2)
A(l) ≤ l'	iff	l ≤  A(l')	(3)
Proposition 3.2 In any DLAM the following hold, for all l, l' ∈ L:

◆A(l V l') = ◆A(l) V ◆A(l')	(4)
 A(l Λ l') =  A(l) Λ  A(l')	(5)
◆A(l Λ l') ≤ ◆A(l) Λ ◆A(l')	(6)
 A(l) V  A(l') ≤  A(l V l')	(7)
A(⊥) = ⊥	 A(T) = T	(8)
A(  A(l)) ≤ l	(9)
l ≤  A(◆A(l))	(10)
Proof. (4) follows from (1) and (3); similarly (5) follows from (2) and (3).  (6)
follows routinely from (1); similarly (7) follows from (1). (8) is routine, using (3),
⊥ ≤  A(⊥) and ◆A(T) ≤ T. (9) follows from (3) and  A(l) ≤  A(l); (10) is similar.	 
Let L be a DLAM. An interpretation of the set M of formulae in L is a map [[−]] : At → L. The meaning of formulae is obtained by induction on the structure of the formulae:

[[m1 V m2]] = [[m1]] V [[m2]],	[[m1 Λ m2]] = [[m1]] Λ [[m2]],
[[◆A(m)]] = ◆A([[m]]),	[[ Am]] =  A[[m]],
[[T]] = T,	[[⊥]] = ⊥ .
The meanings of items and of contexts are obtained by mutual induction on their structure:

[[m]]= as above [[ΓA]] = ◆A([[Γ]])
[[I1, ··· , In]]= [[I1]] Λ· · · Λ [[In]] [[∅]] = T
Note that, since Λ is commutative and associative, the meaning of a context Γ is independent of its presentation as a list of items in a particular order.
A sequent Γ ▶ m is true in an interpretation [−]] in L iff [[Γ]] ≤ [[m]]; it is true in
L iff true in all interpretations in L, and it is valid iff true in every DLAM.

Lemma 3.3 Let Γ, Γ' be contexts with [[Γ]] ≤ [[Γ']] and Δ a context-with-a-hole. Then
[[Δ[Γ]]] ≤ [[Δ[Γ']]].
Proof. Routine induction on the structure of Δ (using also a similar result for items-with-a-hole).	 
Theorem 3.4 (Soundness) Any derivable sequent is valid, i.e. Γ ▶ m implies
[[Γ]] ≤ [[m]] is true in any interpretation [[−]] in any DLAM.
Proof. We show that the axioms of the sequent calculus are valid and that the rules are truth-preserving.
Axioms. These are routine.
The right rules.
ΛR and VR are routine.
◆AR. We have to show
[[Γ]] ≤ [[m ]	implies	[[Γ', ΓA]] ≤ [[◆A(m)]]
Assuming [[Γ]] ≤ [[m]], by definition of [− ] we have to show [[Γ']] Λ ◆A([[Γ]]) ≤
A([[m]]), which follows by monotonicity of ◆A and definition of meet.
AR. We have to show

[[ΓA]] ≤ [[m ]	implies	[[Γ]] ≤ [[ Am]]

This follows directly from the definition of [− ] and property (1) in the definition of a DLAM as follows
A([[Γ]]) ≤ [[m ]	iff	[[Γ]] ≤ A[[m]]
The left rules. These are done by induction on the structure of Δ
ΛL and VL are routine.
◆AL, we have to show
[[Δ[mA]]] ≤ [[m' ]	implies	[[Δ[◆A(m)]]] ≤ [[m']] which easily follows from the definition of [ ]].
AL, we have to show

[[Δ[( Am, Γ)A, m]]] ≤ [[m' ]	implies	[[Δ[( Am, Γ)A]]] ≤ [[m']] for which it is enough to show
[[Δ[( Am, Γ)A]]] ≤ [[Δ[( Am, Γ)A, m]]]

By definition of contexts (and items) with holes this breaks down to three cases

[[( Am, Γ)A]] ≤ [[( Am, Γ)A, m ] which by definition of [ ] is equivalent to the following
A( A[[m]] Λ [[Γ]]) ≤ ◆A( A[[m]] Λ [[Γ]]) Λ m
and follows since by proposition 3.2 and definitions of ◆A and Λ we have
A( A[[m]] Λ [[Γ]]) ≤ ◆A( A[[m]]) Λ ◆A([[Γ]]) ≤ ◆A( A[[m]]) ≤ m
[[Γ',J [( Am, Γ)A]]] ≤ [[Γ',J [( Am, Γ)A, m]]] follows from case 1 by recursively unfolding the definition of an item-with-a-hole.
[[Δ'[(  Am, Γ)A]B ]] ≤ [[Δ'[(  Am, Γ)A, m]B ] follows from case 1 by recursively
unfolding the definitions of a context-with-a-hole and an item-with-a-hole.
 
Theorem 3.5 Completeness. Any valid sequent is derivable, i.e. if [[Γ]] ≤ [[m]]
for every DLAM and every interpretation [[−]] therein, then Γ ▶ m.
Proof. We follow the Lindenbaum-Tarski proof method of completeness (building the counter-model) and show the following
The logical equivalence ∼= defined as ▶E over the formulae in M is an equiva- lence relation, i.e. it is reflexive, transitive (by the admissibility of Cut), and symmetric.
The order relation ≤ defined as ▶ on the above equivalence classes is a partial order, i.e. reflexive, transitive and anti-symmetric.
The operations Λ, V, ◆A, and A on the above equivalence classes (defined in a routine fashion) are well-defined. To avoid confusion with the brackets of the sequents, i.e. Δ[Γ'], we occasionally drop the brackets of the equivalence classes and for example write ◆A(m) for [◆A(m)].
For ◆A[m] := [◆A(m)] we show
[m] ∼= [m'] =⇒ [◆A(m)] ∼= [◆A(m')]
The proof tree of one direction is as follows, the other direction is identically easy
m ▶ m'	◆ R

mA ▶ ◆A
(m')	A
L


◆A(m) ▶ ◆A(m')	A
For  A[m] := [  Am] we show
[m] ∼= [m'] =⇒ [ Am] ∼= [ Am']
The proof tree of one direction is as follows, the other direction is identically easy
m ▶ m'
AL
( Am)A ▶ m'
R
 Am ▶  Am'	A

Similarly for [m1] Λ [m2] := [m1 Λ m2] and [m1] V [m2] := [m1 V m2].
The above operations satisfy the properties of a distributive adjoint lattice (i.e. with binary joins and meets).
The proof tree for one direction of join preservation of ◆A is as follows, the other direction is also easy.
m1 ▶ m1 Id	m2 ▶ m2 Id

AR
mA ▶ ◆ (m )
AR
mA ▶ ◆ (m )

	1	A	1	 VR1
mA ▶ ◆A(m1) V ◆A(m2)
	2	A	2	 VR2
mA ▶ ◆A(m1) V ◆A(m2)

1	2	VL
(m1 V m2)A ▶ ◆A(m1) V ◆A(m2)
◆ (m V m ) ▶ ◆ (m ) V ◆ (m ) ◆AL
A	1	2	A	1	A	2
The proof trees for the adjunction between ◆A and  A are as follows

m ▶  Am'
mA ▶ m'  AInv
A(m) ▶ m'
mA ▶ m'	◆AInv

◆ (m) ▶ m' ◆AL
m ▶  A
m'  AR


Examples of Algebraic Semantics
We point out some examples for the algebraic semantics of our calculus. Example 3.6 The simplest example of a DLAM is a Heyting Algebra: Proposition 3.7 A Heyting Algebra H is a DLAM over an arbitrary set A.
To see this let ◆A(−) be h Λ− for some h ∈ H, then, since Λ is residuated, the Galois right adjoint to ◆A exists and is obtained from the implication. For instance we can set
◆A(−) = TΛ− and we obtain ◆A =  A = id,
◆A(−) = ⊥Λ− = ⊥ and we obtain  A = T,
H = A and we obtain ◆A(−) = A Λ −, hence A− = A ⊃ − where ⊃ is the implication.
Example 3.8 One can argue that in a Heyting Algebra meets are commutative and idempotent but our ◆As generally are not. So a closer match would be a residuated distributive lattice monoid:
Proposition 3.9 A residuated distributive lattice monoid Q is a DLAM over an ar- bitrary set A.
Recall that a residuated distributive lattice monoid Q is a bounded distribu- tive lattice (Q, V, Λ, T, ⊥) with a monoid structure (Q, •, 1) such that the monoid multiplication preserves the joins and has a right adjoint in each argument, i.e. q • − E −/q and −• q E q \ −. Thus if we take ◆A(−) to be either q •− or −• q then it will have a right adjoint in each case. For instance, we can set

◆A(−) = 1 •− or −• 1 and obtain ◆A = A = id,
or set ◆A(−) = ⊥•− or −•⊥ and obtain a A which is a bi-negation operator,
i.e. ¬l− = −/⊥ and ¬r− = ⊥\− respectively for each argument.
Alternatively, we can have L = A	and thus obtain ◆A(−) = A • −, hence
 A− = −/A, and similarly for the other argument.

Relational Semantics
In this section, we develop a Hilbert-style logic APMLHilb for our previous syntax and show that this logic provides an axiomatization for APMLTree. We show that this logic is sound and complete with regard to ordered Kripke Frames, by applying the general Salqhvist theorem for distributive modal logics, developed by Gehrke et al in [10].
The set of formulae M is the same as that of APMLTree. Since the language does not include implication, following Dunn [9], the sequents are of the form m ▶ m' for m, m' ∈ M . The axioms and rules are:


















Proposition 3.10 APMLHilb is sound and complete with respect to DLAMs.
Proof. Soundness is easy. Completeness follows from a routine Lindenbaum-Tarski construction.	 
Proposition 3.11 A sequent of the form m ▶ m' is derivable in APMLTree if and only if it is derivable in APMLHilb.
Proof. Follows from proposition 3.10.	 
A Hilbert-style modal logic is Sahlqvist whenever its modal axioms correspond to first order conditions of a Kripke frame. According to Sahlqvist’s Theorem, these

modal logics are sound and complete with regard to their corresponding canonical Kripke models [3].
Proposition 3.12 APMLHilb is Sahlqvist.
Proof. It suffices to show that the two axioms m ▶ A◆A(m) and ◆A( Am) ▶ m are Sahlqvist. According to the method developed in [10], the former sequent is Sahlqvist if and only if m is left Sahlqvist and A◆A(m) is right Sahlqvist. The former is obvious, the negative generation tree of the latter is as follows
—   ) ( A, −)   ) (◆A, −)   ) (m, −)

This is right Sahlqvist since the only choice node A does not occurs in the scope of the only universal node ◆A. The proof of ◆A( Am) ▶ m being Sahlqvist is similar.
 
For a Kripke semantics, we consider a simplification of that in [10]:
Definition 3.13 A multi-modal Kripke frame for APMLHilb is a tuple (W, ≤
, {RA}A, {R−1}A∈A), where W is a set of worlds, each RA is a binary relation on W and R−1 is its converse, and ≤ is a partial order on W satisfying
≤ ◦R−1◦≤ ⊆	R−1	and	≥ ◦RA◦≥ ⊆	RA
A	A
A Kripke structure for APMLHilb is a pair M = (F,V ) where F is a multi-modal Kripke frame for APMLHilb and V ⊆ W × P is a valuation. Given such a Kripke structure, a satisfaction relation |= is defined on W and formulae of APMLHilb in the routine fashion. The clauses for the modalities are as follows:

From the general Sahlqvist theorem of [10] for distributive modal logics and our propositions 3.12 and 3.11 it follows that
Theorem 3.14 APMLTree is sound and complete with respect to Kripke structures for APMLHilb.

Representation Theorem
We end this section by stating some results about a concrete construction for DLAMs and a representation theorem for perfect DLAMs. They follow from our previous results together with the general results of [10] about representation the- orems for distributive modal logics; the definitions are from [10].
Definition 3.15 The complex or dual algebra of a multi-modal Kripke frame for APMLHilb is the collection of the subsets of W that are downward closed with respect to ≤.

Definition 3.16 A distributive lattice is called perfect whenever it is complete, completely distributive, and join generated by (i.e. each element of it is equal to the join of) the set of all of its completely join irreducible elements.
Lemma 3.17 The complex algebra of a multi-modal Kripke frame for APMLHilb is closed under intersection, union and the modal operators  AZ := {w | ∀v ∈ W, wRv =⇒ v ∈ Z} and  AZ = {w | ∃v ∈ W, wR−1v, v ∈ Z} for Z ⊆ W.
Proposition 3.18 The complex algebra of a multi-modal Kripke frame for
APMLHilb is a perfect DLAM.
Theorem 3.19 Given a perfect DLAM L, there is a frame whose complex algebra is isomorphic to L.
Proof. By the above proposition 3.18, it suffices to construct a frame from L in a way that the complex algebra of the frame is isomorphic to L. As shown in lemma
2.26 and proposition 2.25 of [10], the atom structure of a perfect DLAM is a such a
frame.	 

Epistemic Applications
Following previous work [1,23,21], we interpret ◆A(m) as ‘agent A’s uncertainty about m’, that is, in effect, the conjunction of all the propositions that A considers as possible when in reality m holds. Accordingly, Am will be interpreted ‘agent A has information that m’. We could use the terminology of belief, but wish to avoid this as too suggestive about mental states. Agents can cheat and lie, so “knowledge” is inappropriate.
The intended application of our calculus is scenarios where extra information is available about the uncertainty of agents. This will always be of the form of one or more assumptions of the form: ‘◆A(p) implies m''’, where p is an atom and m'' is a disjunction of atoms, e.g. p1 V p2. Such assumptions express ideas that would, in the relational semantics, be encoded in the accessibility relation, e.g. that such and such a world can access certain other worlds. Such implications are not even formulae of our language; we can however add them as follows, by adding (for each such given assumption) the following evidently sound rule
Δ[(Γ, p)A, m''] ▶ m

Δ[(Γ, p)A] ▶ m	Assn

It is routine to note that the proofs of admissibility of Weakening (2.3) and of Contraction (2.6) still work when these extra rules are considered; it is important for example that the principal item of Assn be of the form (Γ, p)A rather than
A(p). The same applies to the invertibility lemmas.
Proposition 4.1 The Cut rule is admissible in APMLAssn.
Proof. There are three extra cases:

(xii) The first premiss is an instance of Assn:
Δ[(Γ, p)A, m''] ▶ m

Δ[(Γ, p)A] ▶ m	Assn	Δ'[m] ▶ m'
Δ'[Δ[(Γ, p)A]] ▶ m'	Cut

is transformed to
Δ[(Γ, p)A, m''] ▶ m	Δ'[m] ▶ m'

Δ'[Δ[(Γ, p)A, m'']] ▶ m'	Cut
Δ'[Δ[(Γ, p)A]] ▶ m'	Assn .

(xi)(m) The first premiss is an instance of  AR and the second premiss is an instance of Assn, with the cut formula Am non-principal, i.e. not occurring as an element in the principal item of Assn.


ΓA ▶ m
Δ[  Am][(Γ', p)B, m''] ▶ m'

Γ ▶  A
m  AR
Δ[ A
m][(Γ', p)B ] ▶ m'	Assn



is transformed to
Δ[Γ][(Γ', p)B ] ▶ m'	Cut

ΓA ▶ m

Γ ▶  Am

 AR

Δ[  Am][(Γ', p)B, m''] ▶ m'

Δ[Γ][(Γ', p)B, m''] ▶ m'	Cut
Δ[Γ][(Γ', p)B ] ▶ m'	Assn

(xi)(n) The first premiss is an instance of  AR and the second premiss is an instance of Assn, with the cut formula Am principal, i.e. occurring in the principal item of Assn.


ΓA ▶ m
Δ[(Γ',  Am, p)B, m''] ▶ m'

Γ ▶  A
m  AR
Δ[(Γ', A
m, p)B ] ▶ m'	Assn


is transformed to
Δ[(Γ', Γ, p)B ] ▶ m'	Cut

ΓA ▶ m

Γ ▶  Am

 AR

Δ[(Γ',  Am, p)B, m''] ▶ m'

Δ[(Γ', Γ, p)B, m''] ▶ m'	Cut
Δ[(Γ', Γ, p)B ] ▶ m'	Assn

As an example consider the muddy children puzzle. It goes as follows: n children are playing in the mud and k of them have muddy foreheads. Each child can see the other children’s foreheads, but cannot see his own. Their father announces to

them “At least one of you has a muddy forehead.” and then asks them “Do you know it is you who has a muddy forehead?”. After k − 1 rounds of no answers by all the children, the muddy ones know that they are muddy. After they announce it in a round of yes answers, the clean children know that they are not muddy.
To formalize this scenario, assume the children are enumerated and the first k ones are muddy. Consider the propositional atoms sβ for β ⊆ {1, ··· , n} where sβ stands for the proposition that exactly the children in β are muddy and s∅ stands for ‘no child is muddy’. The formula ◆i(sβ) stands for the uncertainty of child i about each of these atoms before father’s announcement. Since child i can only see the other children’s foreheads and not his own, he is uncertain about himself being muddy or not. Let k = the set {1,..., k} (we write s1,··· ,k rather than s{1,··· ,k}), then the assumption for the uncertainty of the muddy child i is ‘◆i(sk) implies sk V sk\i’. This is captured in the calculus by the following instance of the assumption rule
Δ[(Γ, sk)i, sk V sk\i] ▶ m
Δ[(Γ,s)i] ▶ m	Assn
The assumption for the uncertainty of the clean child w is ‘◆w(sk) implies sk Vsk∪w ’ and its Assn rule is similar. For 1 ≤ i, j ≤ k and k + 1 ≤ w we have that before the k − 1’th announcement a muddy child i is uncertain about having a muddy forehead: sk ▶  i(sk V sk\i) (i.e. ◆i(sk) ▶ sk V sk\i). The proof tree of this property is as follows

(s)i,s V s
Id
▶ s V s

k	k	k\i	k	k\i

(s)i ▶ s V s
Assn

k	k	k\i
s ▶  (s V s
)  iR

k	i  k	k\i
The uncertainties of children change after each announcement as follows 4 : the k’s announcements eliminates the sγ disjunct from the uncertainty before the an- nouncement when γ ⊆ {1, ··· , n} is of size k ; father’s announcement eliminates the s∅ disjunct. For example, after the series of 1 to k − 1’th announcements all the disjuncts except for sk will be eliminated from muddy child i’s uncertainty, hence his previous uncertainty assumption rule changes to
Δ[(Γ, sk)i, sk] ▶ m
Δ[(Γ,s)i] ▶ m	Assn
The assumption for the uncertainty of the clean child w changes in a similar way. We have that, after the k− 1’th announcement, a muddy child i obtains information (a) that he is muddy and (b) that other muddy children also obtain information that he is muddy: sk ▶ ( isk) Λ ( i jsk). However, a clean child w will be uncertain about being muddy before and after the k − 1’th announcements: sk ▶  w(sk V sk∪w ).

4 The way the uncertainties change after each announcement is formalized in the sequent calculus of previous work [1,23] via adding a dynamic logic for actions and extra rules for epistemic update; that calculus was not cut-free; Here, we change the assumptions of these uncertainties by hand and defer a full formalization to future work, for more details see next section.

The proof tree of the property for a muddy child i (where child j is also muddy) is as follows:
((s)i,s)j,s ▶ s Id

	k	k	k	k
((sk)i, sk)j ▶ sk
Assn

(s)i,s ▶ s Id
(s)i,s 
▶  s
 jR

  k	k	k
(sk)i ▶ sk
Assn
  k	k	j k
(sk)i ▶  jsk
Assn

s ▶  is
 iR
s ▶  i js
 iR

	
 k		k	k	k ΛR sk ▶ ( isk) Λ ( i jsk)
Consider a twist to the above scenario. Suppose that none of the children are muddy but that the father is a liar (or he cannot see properly) and the children do not suspect this (thus their uncertainties change in the same way as above). After father’s false announcement, any child i will (by reasoning) obtain false information that he is the only muddy child: s∅ ▶  isi. The proof tree is as follows:
(s )i,s ▶ s Id
∅	i	i

 (s )i ▶ si s∅ ▶  isi
Assn
 iR

Conclusion and Future Work
We have developed a tree-style sequent calculus for a positive modal logic where the modalities are adjoints rather than De Morgan duals. We have shown that the structural rules of Weakening, Contraction and Cut are admissible in our calcu- lus. We have also shown that our calculus is sound and complete with regard to bounded distributive lattices with a pair of adjoint operators. Examples of these are complete Heyting Algebras and residuated distributive lattice monoids. Using general results of [10], we have shown that our calculus is sound and complete with respect to ordered Kripke frames, through developing a Hilbert-style calculus that has the same deductive power. We have motivated the applicability of our modal logic by encoding in it partial assumptions of real-life scenarios and proving epis- temic properties of agents in the milestone puzzle of muddy children, but also to a newer mis-information version of it where father’s announcement is not necessarily truthful. Since our box modality is not necessarily truthful, we can as well reason about the settings where agents obtain false information as a result of dishonest announcements. Our proof method of unfolding the adjunction and then renam- ing the left adjoint to its assumed values has made our proofs considerably simpler than the usual proof method of epistemic logics for the muddy children puzzle which uses the fixed point operator of the box. Our calculus has been implemented [15] in Prolog; see this report for details of the (routine) decidability proof.
Our logic may be seen as a positive version of Kt, i.e. tense logic. Thus one can deduce that a proof theory thereof can be obtained by restricting any proof theory of tense logic to rules for conjunction and disjunction, the existential past and the universal future that only satisfy the K axiom.  We are unaware of a tree-style

proof theory for this kind of modal logic in the literature, noting that the presence of T, 4, 5 axioms make the proof theory far easier than their absence in the logic. Thus we believe that our tree-style deep inference proof theory and its automated decision procedure is novel and so is its application to epistemic scenarios.
Future directions of our work include:
A tree-style cut-free sequent calculus that is sound and complete with regard to a residuated monoid with adjoint modalities has been developed in [16], it can easily be extended to a Quantale. We believe that pairing this calculus with what we have in this paper, that is adding to it the rules for the action of the Quantale on its right module such that it remains cut-free, will provide a cut-free sequent calculus. From this one obtains a decision procedure for a distributed version of Epistemic Systems of [1] and thus a negation-free version of Dynamic Epistemic Logic of [2]. This calculus will be an improvement on the algebraic decision procedure of [20], which only implements a sub-algebra of the algebra of Epistemic Systems (namely one that allows ◆A only on the right and A only on the left hand side of the partial order).
A representation theorem for perfect DLAMs follows from general results of [10]. But DLAMs need not be complete and completion involves introduction of, in principle, infinitary lattice operations. In [7] similar results are obtained for positive modal logics where and come from the same relation; it might be possible to alter their duality theorem and make it suitable for our adjoint modal logic. However, those results, similar to that of [10], are with respect to the less intuitive ordered frames. At the moment, we are more inclined towards working with the usual non-ordered frames, along the lines of [9], that is by using theory and counter-theory pairs to build our canonical frames.
As shown in propositions 3.7 and 3.9, Heyting algebras and residuated distributive lattice monoids are examples of DLAMs. So in principle our nested tree sequents might be adapted to provide a new sound and complete cut-free proof system for the logics based on these algebras, i.e. for intuitionistic and linear logics where the conjunction and tensor (respectively) are treated as adjoint operators. In the former case, we will need extra rules to take care of the commutativity of con- junction, but in the latter case we hope to obtain a new cut-free proof theory for non-commutative intuitionistic multiplicative linear logic. It is also worth inves- tigating how logics with classical negation and thus de Morgan dual connectives can be formulated in this context.

References
Baltag, A., B. Coecke, and M. Sadrzadeh, Epistemic actions as resources, Journal of Logic and Computation 17 (3) (2007), 555-585 arXiv:math/0608166.
Baltag, A., and L.S. Moss, Logics for epistemic programs, Synthese 139 (2004), 165–224.
Blackburn, P., M. de Rijke, and Y. Venema, “Modal Logic”, Cambridge, Cambridge University Press, 2001.
Belnap, N., Display Logic, Journal of Philosophical Logic 11 (1982), 375–417.


Bonette, N., and R. Gor´e, A labelled sequent system for tense logic Kt, Australian Joint Conference on Artificial Intelligence, Lecture Notes in Computer Science 1502 (1998), 71–82.
Bru¨nnler, K., Deep Sequent Systems for Modal Logic, Advances in Modal Logic 6 (2006), 107–119.
Celani, S., and R. Jansana, Priestley duality, a Sahlqvist theorem and a Goldblatt-Thomason theorem for positive modal logic, Logic Journal of IGPL 7 (1999), 683–715.
Davey, B.A., and H. A. Priestley, “Introduction to Lattices and Order”, Cambridge, Cambridge University Press, 1990.
Dunn, M., Positive modal logic, Studia Logica 55 (2005), 301–317.
Gehrke, M., H. Nagahashi and Y. Venema, A Sahlqvist theorem for distributive modal logic, Annals of Pure and Applied Logic 131 (2005), 65–102.
Gor´e, R., Substructural Logics on Display, Logic Journal of the IGPL, 6 (1998), 451–504.
Huth, M. and M. Ryan, “Logic in Computer Science”, Cambridge, Cambridge University Press, 2000.
von Karger, B., Temporal Algebras, Mathematical Structures in Computer Science 8 (1998), 277–320.
Kashima, R., Cut-Free Sequent Calculi for Some Tense Logics, Studia Logica 53, pp. 119-135, 1994.
Kriener, J., M. Sadrzadeh and R. Dyckhoff, Implementation of a cut-free sequent calculus for logics with adjoint modalities, University of St Andrews, School of Computer Science Research Report, from the third author, 2009.
Moortgat, M., Multimodal linguistic inference, Bull. IGPL 3, (1995), 371–401.
Negri, S., Proof analysis in modal logic, Journal of Philosophical Logic 34 (2005), 507–544.
Ono, H., and Y. Komori, Logics without the contraction rule, Journal of Symbolic Logic 50 (1985), 169–201.
Prior, A., “Time and Tense”, Oxford University Press, 1968.
Richards, S., and M. Sadrzadeh, Aximo: Automated Axiomatic Reasoning for Information Update, Proceedings of the 5th workshop on Methods for Modalities, to appear in Electronic Notes in Theoretical Computer Science.
Sadrzadeh, M., Ockham’s Razor and Reasoning about Information Flow , Synthese, October 2008, DOI: 10.1007/s11229-008-9414-7.
Sadrzadeh, M., and R. Dyckhoff, Positive Logic with Adjoint Modalities: Proof Theory, Semantics and Reasoning about Information [full version] , arXiv:0903.2448.
Sadrzadeh, M., “Actions and Resources in Epistemic Logic”, PhD Thesis, Universit´e du Qu´ebec `a Montr´eal, 2006. http://eprints.ecs.soton.ac.uk/12823/01/all.pdf.
Simpson, A., “The Proof Theory and Semantics of Intuitionistic Modal Logic”, PhD Thesis, University of Edinburgh, 1993.
Troelstra, A. and H. Schwichtenberg, “Basic Proof Theory”, CUP 2001.
