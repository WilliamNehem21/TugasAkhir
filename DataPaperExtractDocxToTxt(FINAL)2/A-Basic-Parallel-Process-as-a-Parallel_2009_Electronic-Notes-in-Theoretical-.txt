

Electronic Notes in Theoretical Computer Science 242 (2009) 35–48
www.elsevier.com/locate/entcs

A Basic Parallel Process as a Parallel Pushdown Automaton
J.C.M. Baeten1	P.J.L. Cuijpers1	P.J.A. van Tilburg1
Division of Computer Science, Eindhoven University of Technology,
P.O. Box 513, 5600 MB Eindhoven, The Netherlands

Abstract
We investigate the set of basic parallel processes, recursively defined by action prefix, interleaving, 0 and 1. Different from literature, we use the constants 0 and 1 standing for unsuccessful and successful termination in order to stay closer to the analogies in automata theory.
We prove that any basic parallel process is rooted branching bisimulation equivalent to a regular process communicating with a bag (also called a parallel pushdown automaton) and therefore we can regard the bag as the prototypical basic parallel process.
This result is closely related to the fact that any context-free process is either rooted branching bisimulation equivalent or contrasimulation equivalent to a regular process communicating with a stack, a result that is the analogy in process theory of the language theory result that any context-free language is the language of a pushdown automaton.
Keywords: automata theory, process algebra, basic parallel process, parallel pushdown automaton


Introduction
In this paper, we study the class of basic parallel processes. This class was in- troduced in [7] as the class of all processes that have a finite guarded recursive specification over the small process algebraic language with 0, action prefix, choice and parallel composition without communication (just interleaving). More work about this class can be found in e.g. [8,11]. Some results correspond to analogous results in formal language theory, such as the fact that every basic parallel language can be presented as a parallel pushdown automaton (a pushdown automaton not with a stack but with a bag, a multiset of variables).
However, there is an important difference between automata theory on the one hand and process algebra (CCS style) on the other hand that has been mostly neglected so far. In an automaton, for instance a non-deterministic finite automaton, any subset of the set of states can be marked as final, and for the definition of the

1 Email: {j.c.m.baeten,p.j.l.cuijpers,p.j.a.v.tilburg}@tue.nl.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.012

language of an automaton only sequences that lead from the initial state to a final state count. In this sense, successful termination in an automaton is observable. In process algebra CCS style, the only observables are executions of actions, with 0 being the process characterized by allowing no actions at all. Sequential composition can be defined, nevertheless, by having special ‘tick’ actions that by synchronization turn into internal actions. In process algebra ACP style, observables are action executions and action executions leading to termination. Sequential composition then becomes a basic operator. In both the CCS and ACP approaches, however, termination occurring in a choice context (a terminating state with an outgoing edge) cannot be presented accurately. This can be achieved with the introduction of the 1 process (characterizing a process that can only terminate), resulting in a full analogy with automata theory. Using this analogy, we can say that a regular process is the bisimulation equivalence class of a non-deterministic finite automaton, and the set of regular processes is exactly the set of processes given by a finite guarded recursive specification over 0, 1, action prefix and choice.
We investigated the set of context-free processes (defined with 1) in [4]. There, the addition of 1 makes an essential difference: a process can be defined that has unbounded branching, something that cannot be done without 1. Furthermore, we established in [4] under what conditions a context-free process can be presented as a pushdown automaton. In this paper, we investigate a similar result for the class of basic parallel processes. For basic parallel processes, the added expressivity is less spectacular (a corollary of our main theorem is that basic parallel processes have bounded branching, even those including 1), but still, without 1 a bag process expressed as a basic parallel process cannot be tested for being empty. In general, adding 1 makes that the theory becomes more challenging, and in our opinion also more interesting.
Another difference between automata theory and process theory is that pro- cess theory allows us to make communication explicit and abstract from it modulo branching bisimulation. In a setting with explicit communication, a pushdown au- tomaton can be seen as a regular process communicating with a stack. Since every context-free process can be realized in this way, and the stack is a context-free process itself, we can look upon the stack as the prototypical context-free process. Similarly, we show in this paper that every basic parallel process can be presented as a regular process communicating with a bag, a multiset of data elements. Since the bag is a basic parallel process itself, it can be seen as the prototypical basic parallel process.
Thus, the result of [11] that every basic parallel process can be given by means of a parallel pushdown automaton is given here in an extended setting, with the process 1 and with explicit communication.

Regular Processes
Before we introduce the basic parallel processes, we first consider the notion of a regular process and its relation to regular languages in automata theory. We start

with the definition of the notion of transition system from process theory. A finite transition system can be thought of as a non-deterministic finite automaton. In order to have a complete analogy, the transition systems we study have a subset of states marked as final states.
Definition 2.1 [Transition system] A transition system M  is a quintuple (S, A, →, ↑, ↓) where:
S is a set of states,
A is an alphabet,
→ ⊆ S × A × S is the set of transitions or steps,
↑ ∈ S is the initial state,
↓ ⊆ S is a set of final states.
For (s, a, t) ∈ → we write s −a→ t. For s ∈ ↓ we write s↓. A ﬁnite transition system or non-deterministic ﬁnite automaton is a transition system of which the sets S and A are finite.
In accordance with automata theory, where a regular language is a language equivalence class of a non-deterministic finite automaton, we define a regular pro- cess to be a bisimulation equivalence class of a finite transition system. Contrary to automata theory, it is well-known that not every regular process has a determin- istic finite transition system (i.e. a transition system for which the relation → is functional). The set of deterministic regular processes is a proper subset of the set of regular processes.
Next, consider the automata theoretic characterization of a regular language by means of a right-linear grammar. In process theory, a grammar is called a recursive speciﬁcation: it is a set of recursive equations over a set of variables. A right-linear grammar then coincides with a recursive specification over a finite set of variables in the Minimal Algebra MA. (We use standard process algebra notation as propagated by [2,3].)
Definition 2.2 The signature of Minimal Algebra MA is as follows:
There is a constant 0; this denotes inaction, a deadlock state; other names are
δ or stop.
There is a constant 1; this denotes termination, a final state; other names are
ε, skip or the empty process.
For each element of the alphabet A there is a unary operator a. called action preﬁx ; a term a.x will execute the elementary action a and then proceed as x.
There is a binary operator + called alternative composition; a term x + y will either execute x or execute y, a choice will be made between the alternatives.
The constants 0 and 1 are needed to denote transition systems with a single state and no transitions. The constant 0 denotes a single state that is not a final state, while 1 denotes a single state that is also a final state.

Definition 2.3 Let V be a set of variables. A recursive speciﬁcation over V with initial variable S ∈ V is a set of equations of the form X = tX, exactly one for each X ∈ V, where each right-hand side tX is a term over some signature, possibly containing elements of V. A recursive specification is called finite, if V is finite.
We find that a finite recursive specification over MA can be seen as a right- linear grammar. Now each finite transition system corresponds directly to a finite recursive specification over MA, using a variable for every state. To go from a term over MA to a transition system, we use structural operational semantics [1], with rules given in Table 1.


	



x −a→ x'
1↓	a.x −a→ x
y −a→ y'	x↓	y↓
		

x + y −a→ x'
x + y −a→ y'
x + y↓
x + y↓



tX −a→ x	X = tX X −a→ x
 tX↓	X = tX 
X↓



Table 1
Operational rules for MA and recursion (a ∈ A,X ∈ V ).


Basic Parallel Processes
The class of basic parallel processes introduced by Christensen in [7] contains pro- cesses that can interleave actions of parallel components. In [4], we established that context-free processes can be given by recursive specifications over the Sequential Algebra SA, which extends MA with the sequential composition operator · . In this paper, we give parallel processes, a superset of the basic parallel processes, by recursive specifications over the Communication Algebra CA, which extends MA with the parallel composition operator  .
Now, consider the notion of a parallel pushdown automaton. A parallel push- down automaton is a finite automaton, but at every step it can insert a number of elements into a bag by communicating along port i, or it can remove a single item from the bag by communicating along port o, and take this information into account in determining its next move. Thus, making the interaction explicit, a par- allel pushdown automaton is a regular process communicating with a bag. In order to model the interaction between the regular process and the bag, again we use the Communication Algebra CA. We use a particular communication function, that will only synchronize actions !cd and ?cd (for the same channel c ∈ {i, o} and data element d ∈ D). The result of such a synchronization is denoted ?!cd. Furthermore, CA contains the encapsulation operator ∂io( ), which blocks actions !id, ?id, !o d and
?o d, and the abstraction operator τio( ) which turns all ?!id and ?!o d actions into the

x −a→ x'
x	y −a→ x'	y
y −a→ y'
x	y −a→ x	y'
x↓	y↓



x −?c→d
x'	y −!c→d y'
x −!c→d
x'	y −?c→d y'


x  y ?!cd x'   '

x −a→ x'	a /∈ {! d, ? d}
x	y ?!cd
x'  y'

x↓

∂io(x) −a→ ∂io(x')
∂io(x)↓



?!cd	'
x −a→ x'	a /= ?! d	x↓

		x −→ x	 τio(x) −τ→ τio(x')
c
τio(x) −a→ τio(x')


τio(x)↓



Table 2
Operational rules for CA (a ∈ A, c ∈ {i, o}).

internal action τ . For CA, we extend the operational rules of MA (see Table 1) with operational rules in Table 2.
Consider the following specification:
P = 1 + P  a.1.
Our first observation is that, by means of the operational rules, we derive an infi- nite transition system, which moreover is infinitely branching. All the states of this transition system are different in bisimulation semantics, and so this is in fact an infinitely branching process. Our second observation is that this recursive specifica- tion has infinitely many different (non-bisimilar) solutions in the transition system model. This is because the equation is unguarded, the right-hand side contains a variable that is not in the scope of an action-prefix operator, and also cannot be brought into such a form. So, if there are multiple solutions to a recursive specifica- tion, we have multiple processes that correspond to this specification. This causes additional difficulties.
These two observations are the reason to restrict to guarded recursive specifi- cations only. It is well-known that a guarded recursive specification has a unique solution in the transition system model (see [6,5]), and we show later on that this solution is also finitely branching. This restriction leads to our following definition of the basic parallel processes, a subclass of the parallel processes given by recursive specifications over CA.
Definition 3.1 A basic parallel process is the bisimulation equivalence class of the transition system generated by a finite guarded recursive specification over the Com- munication Algebra CA such that the process only interleaves actions and synchro- nizes termination, but does not allow for communication to happen. That is, only the operational rules on the top line in Table 2 are used.

In this paper, we use equational reasoning to manipulate recursive specifications. Our finite axiomatization of transition systems of CA modulo rooted branching bisimulation [9] uses the auxiliary operators  ß  and  |  [6,10]. See Table 3. See [3] for an explanation of the axioms.



x  y	= x ß y + y ß x + x | y

ß x	= 0
ß x	= 0
a.x ß y	= a.(x  y)
(x + y) ß z  = x ß z + y ß z
0 | x	= 0
(x + y) | z  = x | z + y | z
1 | 1	= 1
a.x | 1	= 0
!c d.x | ?c d.y = ?!c d.(x  y)
a.(τ.(x + y)+ x)= a.(x + y)
x | y	= y | x
x  1	= x
1 | x + 1	= 1
(x  y)  z	= x  (y  z)
(x | y) | z	= x | (y | z)
(x ß y) ß z	= x ß (y  z)
(x | y) ß z	= x | (y ß z)
x ß τ.y	= x ß y
x | τ.y	= 0

Table 3
Equational theory of CA (a ∈ A ∪ {τ }, c ∈ {i, o}).

Besides these axioms we use the Cluster Fair Abstraction Rule for (rooted) branching bisimulation CFARb, introduced in [5,12]. For a guarded recursive spec- ification E and the set of abstractions I ⊆ A we want to abstract from, a subset C of the variables V is called a cluster of I in E if for all X ∈ C, the equation of X
in E is of the form

X = Σ
1≤k≤m
ik.Xk + Σ
1≤j≤n
Yj,

where i1,... , im ∈ I ∪ {τ }, X1,... , Xm ∈ C, and Y1,... , Yn ∈ V − C. We call the set of variables {Y1,... , Yn} the exits of X, denoted with U (X), and use U (C) to refer to the exit set of the cluster C. The cluster C is called conservative if every exit from U (C) is reachable from every variable in the cluster by doing a number of steps from I ∪ {τ }. Now, CFARb is the following rule:
E guarded	X ∈ C	I ⊆ A 
  C is a finite conservative cluster of I in E  .

τ.τI (X)= τ.  Σ
Y ∈U (C)
τI (Y )

Furthermore, we often use the aforementioned principle that guarded recursive spec- ifications have unique solutions [5].
The given equational theory is sound and ground-complete for the model of transition systems modulo rooted branching bisimulation [9,3]. This is the preferred model we use, but all our reasoning in the following takes place in the equational

theory, so is model-independent provided the models preserve validity of the axioms, unique solutions for guarded recursive specifications and CFARb.
Using the axioms, any guarded recursive specification can be brought into
Greibach normal form [7]:
X = Σ ai.ξi (+ 1).
i∈IX
In this form, every right-hand side of every equation consists of a number of sum- mands, indexed by a finite set IX (the empty sum is 0), each of which is 1, or of the form ai.ξi, where ξi is the parallel composition of a number of variables (the empty multiset is 1). For a recursive specification in Greibach normal form, every state of the transition system is given by a multiset of variables just like in [11]. Note that we can take the index sets associated with the variables to be disjoint. As an example, we consider the important basic parallel process bag. Suppose D is a finite data set, then we define the following actions in A, for each d ∈ D:
?id: insert (push) d into the bag over the input channel i;
!o d: remove d from the bag over the output channel o.
Now the recursive specification in Greibach normal form is as follows:
B = 1 + Σ ?id.(B  !o d.1).
d∈D
In order to see that the above process indeed defines a bag, define processes Bμ, denoting the bag with contents μ ∈ D∗, as follows: the first equation for the empty bag, the second for any nonempty bag, with isolated element d and rest bag μ (denoted with {d} μ, but abbreviated with the notation dμ from here on):
B∅ = B,
Bdμ = !o d.1  Bμ.
Then it is straightforward to derive the following equations:
B∅ = 1 + Σ ?id.Bd,
d∈D
Bdμ = !od.Bμ +	?ie.Bedμ.
e∈D
Finally, we define the forgetful bag, which can terminate even if it is not empty, as follows:
B = 1 + Σ ?id. B  (!od.1 + 1) .
d∈D
Note that while the bag is given by a recursive specification of CA, it is a basic parallel process, since no communication is possible between !o d and ?id for any d ∈ D.

Parallel Pushdown Automata
The main goal of this paper is to prove that every basic parallel process is equal to a regular process communicating with a bag. Thus, if P is any basic parallel process, then we want to find a regular process Q such that
P = τio(∂io(Q  B)),
where B is a (partially) forgetful bag process specified below.
Without loss of generality, we assume in this section that P is given in Greibach normal form. The data set D we use for our solution is the set of variables V of
P . We call a variable transparent if its equation has a 1-summand. We denote the set of transparent variables of P with V+1. Furthermore, we define the conditional process 1ξ as 1 if all variables in set or multiset ξ are transparent and as 0 otherwise. Now, we prove the main theorem by first stating the specification of our solution, then proving necessary lemmas related to this specification before finally giving the
main proof.
Theorem 4.1 For every basic parallel process P there exists a process Q given by a ﬁnite guarded recursive speciﬁcation over MA such that P = τio(∂io(Q  B∅)) = [Q  B∅]io 2 where B is the (partially) forgetful bag.
Proof Let E be a finite recursive specification of P in Greibach normal form. Now, let F be a recursive specification that defines a parallel pushdown automaton. This specification contains the following equations for every variable X ∈ V of the specification E:

Xˆ = Σ ai.Push(ξi)+ 1X ,
i∈IX
where Push(ξ) is recursively defined as
Push(∅)= Ctrl, Push(Xξ')= !iX.Push(ξ').
where X is a variable that is in the original multiset ξ and ξ' is the multiset that is left over when X has been removed.
Additionally, let F contain the following equations of a partially forgetful bag
and a (regular) finite control:

B = 1 + Σ
V ∈V
V /∈V +1
?iV.(!o V.1  B)+ Σ
V ∈V
V ∈V+1
?iV. (!oV.1 + 1)  B ,

Ctrl = Σ ?o V.(Vˆ + !iV.Ctrl).
V ∈V

2 From here on, [p]io is used as a shorthand notation for τio(∂io(p)).

The specification of each Xˆ
in F mimics the behavior of each X in E by per-

forming the same actions ai and subsequently inserting each variable of the parallel composition ξi in the (partially) forgetful bag B. If X has a 1-summand, Xˆ mimics this by allowing for termination given that the bag is empty or contains transpar-
ent variables. Once the insertions are done, the process Ctrl arbitrarily removes a variable V from the bag (which is the multiset of variables that can be executed in parallel at this moment) and executes Vˆ . Note that Ctrl itself does not make a
choice. The choice is defered to the point when the first action is performed by one of the variables that Ctrl can remove from the bag.
We interpret the multisets in Greibach normal forms as parallel compositions. In Greibach normal form, every state in P is labeled with a parallel composition of variables ξ. Substituting the Greibach normal form for the variables X1,... , Xn gives us the following derivation:

ξ = X1  ...  Xn
= X1 ß (X2  ...  Xn)+ ... 
+ Xn ß (X1  ...  Xn−1)+ (X1 | X2 | ... | Xn)

= Σ
i∈IX1
ai.(ξi  X2  ...  Xn)+ ... 

+ Σ
i∈IXn
ai.(ξi  X1  ...  Xn−1)+ 1{X1,...,Xn}

= Σ Σ ai.(ξiξ − {V })+ 1ξ.
V ∈ξ i∈IV


Introducing a fresh variable P (ξ) for each possible multiset ξ, we obtain the following equivalent infinite recursive specification.
P (ξ)= Σ Σ ai.P (ξiξ − {V })+ 1ξ.
V ∈ξ i∈IV

Now that we have an indication of the relationship between the process P and suitable contents of the bag B, we propose the following equation:


P (ξ)= Σ Vˆ ß Bξ−{V } 
V ∈ξ

+ 1 | Bξ.	(1)


Equation 1 expresses the relationship between a state in a basic parallel process, given by a parallel composition of variables, and our regular process communicating with a bag. Given that X is the initial variable of E, we can instantiate the general

case and use the definition of B and the axioms of Table 3 to show that

P (X)= Xˆ ß B∅
io

+ 1 | BX

= Xˆ ß B + B ß Xˆ 
= Xˆ ß B + B ß Xˆ 
= Xˆ ß B + B ß Xˆ
io
+ 1 | (!o X.1 + 1X ) | B∅ 
+ 1X | B∅
+ Xˆ | B∅

= Xˆ  B	.
io

So, we define Q = Xˆ and we show that P = Xˆ

B∅
io

. This means that we have

to prove equation 1 for any multiset of variables ξ. But first we prove a lemma and
corollary relating the definition of the conditional process to communication with the partially forgetful bag.
Lemma 4.2 For all sets or multisets of variables ξ it holds that 1 | Bξ = 1ξ. Proof By induction over the contents of ξ.
If ξ = ∅, then 1 | B∅ = 1 | B = 1 = 1∅.
If ξ = Xξ', then
if X ∈ V+1, then 1 | BXξ'  = 1 |  (!oX.1 + 1)  Bξ'  = 1 | !oX.1 + 1 | Bξ' = 1 | Bξ' . Because, by induction hypothesis, 1 | Bξ' = 1ξ' , we have that 1 | Bξ = 1ξ' given that X ∈ V+1 and therefore 1 | Bξ = 1ξ.
if X /∈ V+1, then 1 | BXξ' = 1 | (!oX.1  Bξ' ) = 1 | !o X.1 | Bξ' = 0 = 1ξ
because ξ contains the non-transparent variable X.

Corollary 4.3 For all sets or multisets of variables ξ and every variable X it holds that 1X | Bξ−{X} = 1ξ.
Proof By Lemma 4.2, we have that 1X | Bξ−{X} = 1 | BX | Bξ−{X}. By the definition of B, it follows that BX | Bξ−{X} = Bξ. Therefore, again by Lemma 4.2, 1X | Bξ−{X} = 1 | Bξ = 1ξ.	 
Now we prove the following lemma, which is crucial for the main proof. This lemma expresses that if the finite control is at a point where it can choose a variable from the bag, it does not make the actual choice. The choice is determined by the first action that is performed by a candidate variable. It also shows that when this has happened, this particular variable has also been removed from the bag.
Lemma 4.4 For any non-empty multiset ξ contained in a bag, it holds that

τ. [Ctrl  Bξ]io = τ. ΣV ∈V Vˆ
Bξ−{V }	.
io

Proof We use the following definitions: C = ∂io(Ctrl  Bξ), YV = ∂io(Vˆ
 Bξ−{V }),

and XV = ?!iV.C + YV for all V ∈ V. Let us now consider C: C = ∂io( Σ ?oV.(!iV.Ctrl + Vˆ )  B)
V ∈V
=	?!oV.∂io((!iV.Ctrl + Vˆ )  Bξ−{V })
V ∈V
=	?!oV.∂io(!iV.Ctrl ß Bξ−{V } + Vˆ ß Bξ−{V } + Vˆ | Bξ−{V })
V ∈V

= Σ ?!oV. ?!iV.∂io(Ctrl  Bξ)+ ∂io(Vˆ
V ∈V
=	?!oV.(?!iV.C + YV )
V ∈V
=	?!oV.XV .
V ∈V
 Bξ−{V }) 

If we apply the CFARb rule on the specification containing C = ΣV ∈V ?!o V.XV +0 and XV = ?!iV.C + YV for each V ∈ V, which forms a cluster of {?!id, ?!od} in this specification, we obtain: τ.τio(C)= τ.  V ∈V τio(YV ). Hence,

τ. [Ctrl  Bξ]io = τ.τio(C)= τ. Σ τio(YV )= τ. Σ Vˆ

Bξ−{V }	.
io

V ∈V	V ∈V


Now that all prerequisites are in place, we can deal with the main proof which requires us to prove the following statement:

P (ξ) =?
Σ Vˆ ß B
V ∈ξ


ξ−{V }

+ 1 | Bξ
io



First, apply the definition of Vˆ
and get rid of the left merges.

= Σ Σ ai. Push(ξi)  Bξ−{V } io + 1 | Bξ
V ∈ξ i∈IV
Perform |ξi| pushes by repeatedly applying the definition of Push(ξ).

= Σ Σ ai.τ |ξi|. Ctrl  Bξ ξ−{V } 

+ 1 | Bξ

V ∈ξ i∈IV
Remove all but one τ -step that follows ai or introduce one τ -step if ξi is empty and apply Lemma 4.4 on τ. Ctrl  Bξiξ−{V } io.

= Σ Σ ai.τ.	Σ
 Wˆ

Bξiξ−{V,W }
io

+ 1 | Bξ

V ∈ξ i∈IV	W ∈ξiξ−{V }

Remove the τ -step and perform expansion on the merge operator and remove

the summand  Bξiξ−{V } ß Wˆ
io
encapsulated action.
since its left-hand side cannot perform any non-

= Σ Σ ai.	Σ
  Wˆ

ß Bξiξ−{V,W }
io
+ Wˆ

| Bξiξ−{V,W }  + 1 | Bξ

V ∈ξ i∈IV	W ∈ξiξ−{V }


Now, consider the summand Wˆ
| Bξiξ−{V,W }. Since Wˆ
cannot perform any action,

only the summand 1W remains of the specification of Wˆ .

= Σ Σ ai.	Σ
  Wˆ

ß Bξiξ−{V,W }
io

+ 1W | Bξiξ−{V,W }  + 1 | Bξ

V ∈ξ i∈IV	W ∈ξiξ−{V }

Because 1W | Bξiξ−{V,W } = 1ξiξ−{V } by Corollary 4.3 and 1ξiξ−{V } does not depend on W , we can move it outside of the summation.

= Σ Σ ai.	Σ
 Wˆ

ß Bξiξ−{V,W }
io

+ 1ξiξ−{V } + 1 | Bξ

V ∈ξ i∈IV	W ∈ξiξ−{V }

Use the definition of P (ξiξ − {V }) and apply Lemma 4.2 on 1 | Bξ.
= Σ Σ ai.P (ξiξ − {V })+ 1ξ.
V ∈ξ i∈IV
This concludes our proof that there exists a recursive specification over CA that, in parallel with a partially forgetful bag, is equivalent to a basic parallel process P . 
A corollary of this theorem strengthens the result found in [8], that basic parallel processes have finite branching. In fact, the branching is bounded (i.e. there is a fixed maximum branching for all reachable states).
Corollary 4.5 Every basic parallel process has bounded branching.
Proof By Theorem 4.1 there exists a regular process Q (given by a finite guarded recursive specification over MA) for every basic parallel process P such that P = [Q  B∅]io. Because Q is regular, it is boundedly branching. The process B is also boundedly branching. Because the parallel composition leads to the Cartesian product of both boundedly branching components plus the result of communica- tion [5], P is also boundedly branching.	 

Concluding Remarks
We have proved that every basic parallel process is rooted branching bisimilar to a regular process communicating with a bag. A regular process communicating with a bag can be seen as a parallel pushdown automaton, and so this result extends the result of [11] by adding the process 1 and making the internal communication

explicit. As a result, we can see the bag as the prototypical basic parallel process. As a corollary, we established that every basic parallel process has bounded branching. This is in contrast to the situation with context-free processes. We saw in [4] that context-free processes can show unbounded branching. For a context-free pro- cess with unbounded branching, we cannot show it is rooted branching bisimilar to a regular process communicating with a stack. We could only show this in con- trasimulation. Here, for basic parallel processes, the situation is simpler, and we
can establish the full result in rooted branching bisimulation.
The reverse direction, to see if any regular process communicating with a bag is actually a basic parallel process is open as far as we know. Of course, in order to achieve this result, we should allow τ -steps in the definition of basic parallel process, but that is no problem as long as we make sure we retain guardedness. Note that [11] shows the reverse direction is not true in the absence of 1, but here, with 1, it might still be true.
In addition, it is open whether the result of [8] that bisimulation equivalence is decidable for basic parallel processes is still valid with the addition of 1.
An interesting extension of basic parallel processes is allowing communication in the definition of processes. Probably, expressive power will increase, but we do not know examples of processes that can be defined with the addition of communication but not without communication.
Finally, note that the addition of 1 allows termination exactly when a bag is empty. This check on emptiness is not possible without 1. This is different from the situation with a stack, where a check on empty is also possible in an ACP-style language.
Having looked at stacks and bags, it is interesting to look at queues next. Thus, it is interesting to see which set of processes can be realized as a regular process communicating with a queue.
Acknowledgement
The research of Van Tilburg was supported by the project “Models of Computation: Automata and Processes” (nr. 612.000.630) of the Netherlands Organization for Scientific Research (NWO).

References
Aceto, L., Fokkink, W.J. and Verhoef, C., Structural operational semantics, in: J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, North-Holland, 2001 pp. 197–292.
Baeten, J.C.M., Basten, T. and Reniers, M.A., “Process Algebra: Equational Theories of Communicating Processes,” Cambridge University Press, 2008.
Baeten, J.C.M. and Bravetti, M., A ground-complete axiomatization of finite state processes in process algebra, in: M. Abadi and L. de Alfaro, editors, Proceedings of CONCUR 2005, number 3653 in LNCS (2005), pp. 246–262.
Baeten, J.C.M., Cuijpers, P.J.L. and Tilburg, P.J.A. van, A context-free process as a pushdown automaton, in: F. v. Breugel and M. Chechik, editors, Proceedings of CONCUR 2008, number 5201 in LNCS (2008), pp. 98–113.

Baeten, J.C.M. and Weijland, W.P., “Process Algebra,” Cambridge University Press, 1990.
Bergstra, J.A. and Klop, J.W., Process algebra for synchronous communication, Information and Control 60 (1984), pp. 109–137.
Christensen, S., “Decidability and decomposition in process algebras,” Ph.D. thesis, University of Edinburgh (1993).
Christensen, S., Hirshfeld, Y. and Moller, F., Bisimulation equivalence is decidable for basic parallel processes, in: E. Best, editor, Proceedings of CONCUR 1993, number 715 in LNCS (1993), pp. 143–157.
Glabbeek, R.J. van and Weijland, W.P., Branching time and abstraction in bisimulation semantics, Journal of the ACM 43 (1996), pp. 555–600.
Moller, F., The importance of the left merge operator in process algebras, in: M. Paterson, editor,
Proceedings of ICALP’90, number 443 in LNCS (1990), pp. 752–764.
Moller, F., Infinite results, in: U. Montanari and V. Sassone, editors, Proceedings of CONCUR ’96, number 1119 in LNCS (1996), pp. 195–216.
Vaandrager, F.W., Verification of two communication protocols by means of process algebra, Technical Report CS-R8608, CWI, Amsterdam (1986).
