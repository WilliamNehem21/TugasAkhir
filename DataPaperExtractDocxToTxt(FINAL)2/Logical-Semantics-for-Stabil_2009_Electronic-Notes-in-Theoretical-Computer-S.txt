

Electronic Notes in Theoretical Computer Science 249 (2009) 429–449
www.elsevier.com/locate/entcs

Logical Semantics for Stability 

Luca Paolinia,1	Mauro Piccoloa,b,2 Simona Ronchi Della Roccaa,3
a Dipartimento di Informatica Universita` di Torino
Torino, Italy
b Laboratoire PPS , Universit`e de Paris VII Paris, France

Abstract
Type assignment systems for λ-calculus based on intersection types are a general framework for building models of λ-calculus (known as filter-models) which are useful tools for reasoning in a finitary way about the denotational interpretation of terms. Indeed the denotation of a term is the set of types derivable for it and a type is a “finite piece” of information on such a denotation. This approach to the λ-calculus semantics is called in the literature logical semantics, and it has been intensively studied in relation with λ-models in the Scott’s domain setting. In this paper we define two intersection type assignment systems for λ-calculus, parametric with respect to a coherence relation between types. We prove that, when the instantiation of the parameter satisfies a given condition, our two type systems induce models of λ-calculus, that we call clique-models. Lastly we show that such systems give a logical characterization of two classes of models built on the category of Girard’s coherence spaces and stable functions.
Keywords: λ-calculus, logical semantics, intersection type assignment systems, coherence spaces.


Introduction
In the general framework of denotational semantics for programming languages, logical semantics is a tool for building models of various kinds of λ-calculus, and for reasoning in finitary way about the interpretation of terms. Logical semantics is based on intersection type assignment systems [8]. Namely, an intersection type assignment system assigns types to terms of λ-calculus, and typing rules are closed under a pre-order relation. If the pre-order satisfies some constraints then the system gives rise to a λ-model, where the interpretation of a term is the set of types derivable for it. Such constraints are designed for assuring that the interpretation

٨ Paper partially supported by MIUR-PRIN’07 CONCERTO Project.
1 Email: paolini@di.unito.it
2 Email: piccolo@di.unito.it
3 Email: ronchi@di.unito.it

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.101

of a term enjoys the good properties we expect, like the closure under beta-equality, the closure under contexts, and so on. In all the known instances, the constraints can be expressed by few, very easy, syntactical rules.
Logical semantics has been intensively studied in connections with denotational model based on Scott’s domains which are ω-algebraic complete lattices (Scott- models). Indeed, the constraints can be formalized in such a way that the induced model is isomorphic to a Scott-model. The models built in this way are called ﬁlter λ-models. The isomorphism between filter λ-models and Scott-models can be view as a particular instance of domain theories in logical form [2]. The isomorphism re- lates types with compact elements of the complete lattice on which the Scott-model is based, in particular arrow-types correspond to Scott-continuous step-functions. The pre-order between types reflects the partial order of the domain. The construc- tion is made by using the intersection connective between types for mimicking the join operation in domains. Moreover, the type assignment system provides a logical description of the interpretation function, i.e. to assign a type (say σ) to a term M is the logical counterpart of the fact that the compact element corresponding to σ is less than or equal to the interpretation of M. Examples of filter models designed in order to study particular properties of λ-calculus are in [5,10,11,23]. This ap- proach has been applied also to the call-by-value λ-calculus in [12]. For the study of the isomorphism between filter λ-models and Scott-models the reader can see [9,18,22], behind other. In [23] a notion of parametric ﬁlter model has been defined, which can generate models of various kinds of λ-calculus, when the parameter has been specified in a suitable way (particular choices generate the classical and the call-by-value λ-calculus).
In this paper we want to extend the above approach to the λ-models based on coherence spaces defined by Girard [13] (originally they was named binary qualita- tive domains, their renaming in coherence spaces has been given in [14]). Coherence spaces are based on Berry’s stable functions [7]. We call such models stable λ-models. We consider two particular classes of stable λ-models, the linear and the lazy one. In order to describe such classes, let us recall that a stable λ-model is based on a coherence space X containing as retract the space X ⇒ X, where ⇒ denotes the stable functions constructor. A stable model is linear if both the functions realizing the retraction are linear (and so they are strict, since they map the empty set into itself). Lazy stable models are particular cases of stable models where one of the functions realizing the retraction is not strict. This difference in the space on which the models are based is reflected in the λ-theories that they induce. In fact, the λ-theory induced by a linear λ-model is always such that, if a term M is interpreted as the empty set, then also the interpretation of λx.M is the empty set. So the the- ory cannot be lazy, in the sense of [3]. While lazy stable models can generate lazy λ-theories. We want to stress the fact that these two classes are not too restricted: indeed, in our knowledge, all stable λ-models considered in literature belong to one of them [6,13,17].
We define two type assignment systems, parametric with respect to two relations

between types, an equivalence and a strict coherence relation. We provide a legality condition, and we prove that every choice of such relations satisfying this condition gives rise to a λ-model. We call respectively clique models and lazy clique models the λ-models obtained by the two type assignments. Then, we prove that the class of clique models is isomorphic to the class of linear stable models, while the class of lazy clique models is isomorphic to that one of lazy stable models. Such isomorphisms are based on the fact that types can be put in correspondence with tokens, in such a way that the equivalence and strict coherence relation between types reflect respectively the equality and the strict coherence relation in the space on which the (lazy) stable model is based, when the legality condition is satisfied. Lastly, the type assignment system is a logical description of the interpretation function. In fact, if a type σ is derivable for a term M, then it turns out that the token corresponding to the equivalence class of σ belongs to the clique which is the interpretation of M in the isomorphic stable model.
The main difference between our type assignments and the classical intersection type assignments reflects the difference between continuous and stable functions. Classical intersection types represent compact elements of complete lattices, where all elements are consistent. In fact the join is a total operation on Scott domains, and so the intersection is a total constructor on types. In coherence spaces the join is a partial operation, defined only between coherent elements, so we need to introduce in types a notion reflecting this fact, which is the strict coherence relation. Moreover, we choose to not use explicitly the intersection constructor on types, but our types are of the shape [σ1, ..., σn] → σ where the left-hand side of the arrow contains types which are pairwise strictly coherent (morally, in intersection). The fundamental difference between clique models and lazy clique models is the introduction of a particular type constant ν denoting the least functional behaviour. So, in order to type an application, we ask that the term in functional position can be assigned both the type ν and the type describing its correct functionality.
We want to stress the fact that the definition of (lazy)-clique models is given in
a completely syntactical way, so they can be built without any acquaintance with stable functions and stable models.
In the literature some works has been done to connect intersection type assign- ment systems and stable λ-models, namely [6,17]. In the last section we will discuss the relation between the results of the present paper and the previous ones.

Outline of the paper.
The paper is organized as follows. In Section 2 the notion of model of λ-calculus is recalled. In Section 3 the two parametric type assignment systems and the re- lated clique models are defined. Section 4 contains a short survey on the principal notions about coherence spaces and stable functions. In Section 5 we prove the isomorphism between (lazy) clique-models and linear (or lazy) stable λ-models re- spectively. Finally Section 6 contains a comparison between the present paper and the papers [6,17].

λ-models
In this section we will briefly recall the definition of λ-calculus and λ-model.
Definition  2.1	(i) Terms of λ-calculus are defined by the following syntax:
M ::= x | λx.M | MM

where x belongs to a countable set Var of variables. Variables are ranged over by x, y, z and terms by M, N, P.
(ii) The β-reduction is the contextual closure of the following rule:
(λx.M)N →β M[N/x]
where M[N/x] denotes the capture free substitution of all occurrences of x in M
by N. =β is the minimal equivalence induced by →β.
We will use notations from [4]. ≡ denotes the syntactical identity between terms. FV(M) denotes the set of variables occurring free in M. As usual terms are considered up to α-equivalence, i.e. bound variables renaming avoiding variable clashes.
Let us recall two particular classes of λ-terms, the head normal form and the weak head normal forms. A term M has head normal form if M =β λx1...xn.zM1...Mm, (n, m ≥ 0) while it has weak head normal form if either M =β λx.N or M =β zM1...Mm, for some z, M1, ..., Mm, N (m ≥ 0).
In the next definition, we will give the properties that a structure must satisfy in order to be used as denotation space for λ-calculus, or, equivalently, to be a model for λ-calculus [4,16,19,20]. In particular, we use the definition given in [23] which is a light equivalent variant of the one in [16].
Definition 2.2 A λ-model is a triple M = ⟨D, ◦, .)⟩, such that D is a set and ◦ is a map from D2 to D. Moreover, if E is the collection of functions (environments) from Var to D, ranged over by ρ, ρ', then the interpretation function .) : Λ× E → D satisfies the following conditions:
x)ρ = ρ(x),
MN)ρ =  M)ρ ◦ N)ρ,
λx.M)ρ ◦ d = M)ρ[d/x],
if M)ρ[d/x] = M')ρ'[d/y] for each d ∈ D, then λx.M)ρ = λy.M')ρ' , where ρ[d/x](y)= if y ≡ x then d else ρ(y).
This definition ensures that a λ-model respects some elementary key properties, namely the interpretation of a term depends only on the behaviour of the environ- ment on the free variables of the term itself, the α-rule is respected, the syntactical substitution is modeled by the environment and the interpretation is contextually closed.
Proposition 2.3 Let ⟨D, ◦, .)⟩ be a λ-model.

If ρ(x)= ρ'(x), for all x ∈ FV(M), then  M)ρ = M)ρ';
If y /∈ FV(M) then  M)ρ[d/x] = M[y/x])ρ[d/y];
If y /∈ FV(M) then  λx.M)ρ = λy.M[y/x])ρ;
M[N/x])ρ = M)ρ[ N)ρ/x];
If  M)ρ =  N)ρ then, for every context C[.],  C[M])ρ =  C[N])ρ.
As consequence of the previous proposition, condition (iii) of Definition 2.2 is the semantics counterpart of the β-reduction rule, so the interpretation of a term is closed under =β.
Corollary 2.4 Let ⟨D, ◦, .)⟩ be a λ-model. If M =β N then  M)ρ = N)ρ, for all ρ.
Given a λ-model M, the interpretation function .)M induces a denotational semantics on Λ. Namely, two terms M and N are denotationally equivalent in M (and we write M ∼M N) if and only if:
 M)M =  N)M, for all environments ρ.
ρ	ρ
Corollary 2.4 ensure us that ∼M is a λ-theory, i.e., a congruence relation on terms closed under =β.

Clique Models
In this section we will define two classes of type assignment systems, and we will prove that both give rise to λ-models, under particular conditions.
In order to present the systems in a clean way, we first define a superset of types (row types) which enable us to formalize some relations on them needed to define well-formed types.
Definition 3.1  (i) Let C be a non-empty countable set of type constants, ranged over by p, q, r. The set Row(C) of row types, ranged over by σ, τ, π, μ, is defined as follows:
σ ::= p | [σ1,... , σn] → σ	(n ≥ 0)
where p belongs to C. The identity relation on Row(C) is denoted by =.
A stable type theory on Row(C) is a congruence  (i.e. a reflexive, symmetric, transitive and contextual equivalence) on row types, satisfying
∀i∃j σi  τj	∀i∃j τi  σj	σ  τ	n, m ≥ 0 [σ1, ..., σn] → σ  [τ1, ..., τm] → τ

We denote by Row(C)/ the set of equivalence classes induced by  on Row(C). By abuse of notation, a row type will denote also its class mem- bership.
Let C be a set of type constants and  a stable type theory on Row(C). A
typing relation is a binary endorelation on Row(C)/ . We define four typing

relations, denoted by -, ˇ, ¨, ˚. - (strict coherence) is symmetric and antire- flexive (equivalent types are not put in relation), and it is defined as follows:


σ - τ


[σ1, ..., σn] → σ - [τ1, ..., τm] → τ

(a)
∃i ≤ n, ∃j ≤ m such that σi ˇ τj


[σ1, ..., σn] → σ - [τ1, ..., τm] → τ

(b)

σi ˇ τj (strict incoherence) is defined as σi / τj and σi /- τj. ¨ (coherence) is the reflexive closure (all equivalent types are put in relation) of -, finally ˚ (incoherence) is the reflexive closure of ˇ.
If ® is either a typing relation or  , then we write ®{σ1, ..., σn} to denote that
σi®τj, for i /= j (1 ≤ i, j ≤ n).
The previous definition deserves some comments.
We define row types only in order to provide a coarse syntax on which to define useful tools, as type theory and typing relations, that will be used in order to define types. A non constant row types has always the shape [σ1, ..., σn] → σ, where [σ1, ..., σn] is a sequence of row types, that can be empty and can contain repetitions. For instance, both [ ] → σ and [σ, τ, σ] → σ are row types. A stable type theory imposes an equivalence on row types, in particular sequences on the left-side of an arrow are managed up to set-theoretical equivalence. So, for instance τ '  τ implies that [σ, τ, σ] → σ  [τ ', σ] → σ. We could have done a different choice, denoting directly the left hand of an arrow as a set, but we chose to use sequences (denoted by square brackets) in place of sets (usually denoted by curly bracket) in order to emphasize the difference between the syntax of row types and the metalanguage.
Strict coherence will be used in type formation, since it formalizes what bits of type-information are consistent (in classical sense of domain theory 4 ). We remark that strict coherence is given up to equivalence between types, thus if σ  τ and τ - π then σ - π. Let us observe that, in Definition 3.1.(iii), rules (a) and (b) together require that, given two not constant row types, either their right hand are strictly consistent or they have at least two inconsistent elements in the left hand side. So, for instance [ ] → σ is incoherent with all not constant row types having σ in the right hand side.
Definition 3.2  (i) A stable type system ∇ is a triple ⟨C∇, ∇, -∇⟩, where C∇ is a set of type constants, ∇ is a stable type theory on Row(C∇) and -∇ is a strict coherence relation on Row(C∇)/ ∇ .
A lazy stable type system ∇ is a quadruple ⟨C∇, ∇, -∇, ν∇ ⟩ which extends the stable type system ⟨C∇, ∇, -∇⟩ by selecting a special type constant ν∇ ∈ C∇ such that ν∇ -∇ σ, for all σ ∈ Row(C∇) \ {ν∇ }. We will call ν∇ the pivot of ∇.
It should be clear that a stable type system can contain zero, one or many type constants that can be used as pivot. Hence, a stable type system can induce zero, one or many lazy type systems.

4 Remember that for classical filter model a consistence relation is not necessary, since they live in the world of complete lattices [23] where all elements are consistent.



Fig. 1. The Type Assignment Systems ▶∇.
Given a stable type system (possibly lazy), the definition of row types can be refined in order to obtain types. Hence, a type assignment system can be designed by formalizing rules assigning such types to terms of λ-calculus.
Definition 3.3 Let ∇ be a stable type system (possibly lazy).
The set of types T∇ is the subset of Row(C∇) such that


p ∈ C∇
p ∈ T∇
τ, τ1, ..., τn ∈ T∇	-∇{τ1, ..., τn}
[τ1, ..., τn] → τ ∈ T∇


A type assignment is a pair of the shape x : σ, where x is a variable and σ ∈ T∇. A ∇-basis B is a finite set of type assignments such that, if x : σ1, ..., x : σn ∈ B then -∇ {σ1, ..., σn}. Let dom(B)= {x | ∃σ.x : σ ∈ B}.
If B = B' ∪ {x :σ1, ..., x :σn} and x /∈ dom(B') then B(x)= {σ1, ..., σn}. Let Bi be a basis for 1 ≤ i ≤ n; we write ★(B1, B2, ..., Bn) meaning that if x : σ ∈ Bi and x : τ ∈ Bj, for some i /= j (1 ≤ i, j ≤ n) then either σ -∇ τ or σ = τ .
A stable intersection type assignment system ▶∇ is a formal system proving statements of the shape:
B ▶∇ M : σ where M is a term, σ ∈ T∇ and B is a ∇-basis. The rules of the system are in Figure 1.
Let ∇ be lazy and let ν∇ be its pivot. A lazy stable intersection type assignment

system ▶l
is a formal system proving statements of the shape:



B ▶l
M : σ

where M is a term, σ ∈ T∇ and B is a ∇-basis. The rules of the system are in Figure 2.
Differently from the syntax of row types, square brackets on the left-side of an arrow contain a sequence of types without multiple occurrences of equivalent elements. Note, for instance, that if σ  ∇ σ' then [σ, σ'] → τ /∈ T∇.


Fig. 2. The Type Assignment Systems ▶Æ .

Note that a basis cannot assign equivalent types to the same variable. If Bi are bases, then it is easy to check that ★(B1, B2, ..., Bn) implies that 1≤i≤n Bi is a well-defined basis. In particular, we note that this would be no longer true replacing
= by  ∇ in the definition of ★.
Both the type assignment systems are linear, in the sense that weakening does not hold. As we will see in a formal way, a basis contains the minimal information necessary for the typing.
In rule (→E) types in all bases need to be strictly coherent to each other, and this

is essential for preserving the correct syntax of types. The lazy system ▶l
uses all

the rules of ▶∇, but a modified (→E) rule, and a new rule (Lazy), the latter assigning ν∇ to all abstractions and the former asking that only terms for which the type ν∇ is derivable can be used in functional position. So ν∇ characterizes terms with a functional behaviour.
Notation 3.1 Let ∇ be a stable type system and let ® be a typing relation.
{σ1, ..., σn}®{τ1, ..., τm} is an abbreviation for ∀i∃j σi®τj, ∀i∃j τi®σj. Moreover
B1®B2 shortens B1(x)®B2(x), for all x.

Lastly, we use ▶∗
to denote both type assignment systems.

Note that B1  ∇ B2 implies that the cardinality of the set B1(x) is the same as the set B2(x), for all variables x.
The legality condition given in the next definition characterizes (lazy) stable type systems that give rise to models of λ-calculus.
Definition 3.4 A (lazy) stable type system ∇ is legal whenever, if [σ1, ..., σn] →
σ ∈ T∇ and [τ1, ..., τm] → τ ∈ T∇ then both:
[σ1, ..., σn] → σ  ∇ [τ1, ..., τm] → τ implies both σ  τ and {σ1, ..., σn}  ∇
{τ1, ..., τm},
[σ1, ..., σn] → σ -∇ [τ1, ..., τm] → τ implies either σ -∇ τ or ∃i.1 ≤ i ≤ n,
∃j.1 ≤≤ m such that σi ˇ∇ τj.
We remark that point (i) and (ii) of legality correspond to reversibility of the

rules of Definition 3.1.(ii) and (iii), respectively. In particular, if ∇ is legal, then both [τ1, ..., τn] → τ, [σ1, ..., σm] → σ ∈ T∇ and [τ1, ..., τn] → τ  ∇ [σ1, ..., σm] → σ imply n = m.
Lemma 3.5 (Generation) Let ∇ be a legal stable type system.

B ▶∗
B ▶∗
x : σ implies B = {x : τ } and σ  ∇ τ.
M : σ implies dom(B) ⊆ FV(M).

• B ▶∇ λx.M : σ implies σ  [σ1, ..., σn] → τ;
B ▶l λx.M : σ implies either σ = ν∇ or σ  [σ1, ..., σn] → τ.
• B ▶∇ MN : σ implies B' ▶∇ M : [σ1, ..., σn] → σ, Bi ▶∇ N : σi, where
B = ( 1≤i≤n Bi) ∪ B';
B ▶l MN : σ implies B' ▶l M : [σ1, ..., σn] → σ, B'' ▶l M : ν∇ and Bi ▶l N : σi,
where B = ( 1≤i≤n Bi) ∪ B' ∪ B''.

B ▶∗ M : σ and B  ∇ B' imply B' ▶∗
M : σ.

B ▶∗
λx.M : [σ1, ..., σn] → τ if and only if B ∪ {x : σ1, ..., x : σn} ▶∗
M : τ and x /∈ dom(B).

Proof. The first five points follow easily by induction on derivation.
Note that in point (ii), the inclusion can be strict either in case of an application
MN, where M has type [ ] → σ, or in case rule (Lazy) has been applied.
Let us consider first the system ▶∇. If the last applied rule is (→I), then the proof is immediate. Otherwise, the derivation proving B ▶∇ λx.M : [σ1, ..., σn] → τ ends in the following way:


B ∪ {x : π1, ..., x : πn} ▶∇ M : μ
B ▶∇ λx.M : [π1, ..., πn] → μ

(→I)

B ▶∇ λx.M : [σ1, ..., σn] → τ
( )

where [π1, ..., πn] → μ ∇ [σ1, ..., σn] → τ , by transitivity of  ∇. Moreover, since the system is legal, {π1, ..., πn} ∇ {σ1, ..., σn} and μ ∇ τ. Then the proof follows by point (v) and by rule ( ).
In case of system ▶l , if the derivation proving B ▶∇ λx.M : [σ1, ..., σn] → τ is as before, then the same proof applies. The derivation cannot end by an application of rule (Lazy), since by definition ν∇ -∇ σ (and thus ν∇ / ∇ σ), for all σ ∈ Row(C∇) \ {ν∇ }, so ν∇ / [σ1, ..., σn] → τ .	 
We remark that Lemma 3.5 holds only under the legality hypotheses. The property stated by following theorem, namely that in a derivation the basis collects the minimal information on the premises necessary for the typing, is crucial for building a model starting from a type assignment system.
Theorem 3.6 Let ∇ be a legal stable type system.

If B0 ▶∗
If B0 ▶∗
M : σ0, B1 ▶∗
M : σ0, B1 ▶∗
M : σ1 and B0 ¨∇ B1 then σ0 ¨∇ σ1.
M : σ1, σ0  ∇ σ1 and B0 ¨∇ B1 then B0  ∇ B1.

If B0 ▶∗
M : σ, B1 ▶∗
M : σ and B0 ⊆ B1 then B0 = B1.

Proof. The proof of first two points is given by mutual induction on M.
If M ≡ x then the proof follows by Lemma 3.5.(i).
If M ≡ PQ then the proof follows by Lemma 3.5.(iv) and by induction, taking into account the following obvious property:
★(B1, ..., Bn) and {p1, ..., pk}⊆ {1, ..., n} imply ★(Bp1 , ..., Bpk )	(1)
Let M ≡ λx.N. If σ0 = ν∇ or σ1 = ν∇ then the proof follows definition of lazy stable type system, namely ν∇ -∇ σ, for all σ ∈ Row(C∇) \ {ν∇ }. Let us assume σi ≡ [τ i, ..., τ i ] → τ i where ni ≥ 0 (0 ≤ i ≤ 1). In case there are
1	ni
μ0 ˇ∇ μ1 such that μi ∈ {τ i, ..., τ i } then by rule (b) of Definition 3.1.(iii)
1	ni
the proof follows. Otherwise, assume that B' = Bi ∪ {x : τ i, ..., x : τ i } and
i	1	ni
B' ¨∇ B' . Since, by Lemma 3.5.(vi), B' ▶∗ M : τ i and x /∈ dom(Bi), τ 0 ¨∇ τ 1
0	1	i	∇
by induction. If τ 0 -∇ τ 1 then the proof follows by rule (a) of Definition
3.1.(iii). The case τ 0  ∇ τ 1 follows by mutual induction, since B'  ∇ B'
implies {x : τ 0, ..., x : τ 0 }  ∇ {x : τ 1, ..., x : τ 1 }.
1	n0	1	n0
If M ≡ x then the proof follows by Lemma 3.5.(i). If M ≡ PQ then B'	∗
P : [τ i, ..., τ i ] → σi, Bi ▶∗ Q : τ i (and B''i ▶∗ P : ν	if the system is lazy)
1	ni	j	∇	j	∇	∇
where Bi = (	Bi) ∪ B' ∪ B''i, by Lemma 3.5.(iv). But [τ 0, ..., τ 0 ] →
σ0 ¨∇ [τ 1, ..., τ 1 ] → σ1 by mutual induction and property stated in equation
1	n1
(1). By Definition 3.4.(ii) (legality), [τ 0, ..., τ 0 ] → σ0 -∇ [τ 1, ..., τ 1 ] → σ1

1
is not possible, since the hypothesis σ0
n0
∇ σ1
1
and since τ i ¨∇
n1
i  where

0 ≤ i, i' ≤ 1, 1 ≤ j ≤ ni and 1 ≤ j' ≤ ni' , by mutual induction. Hence,
[τ 0, ..., τ 0 ] → σ0  ∇ [τ 1, ..., τ 1 ] → σ1. Thus the proof follows by legality and
1	n0	1	n1
induction.
Let M ≡ λx.N. If σ0 = ν∇ or σ1 = ν∇ then σ0 = σ1 by definition of lazy stable type system. Hence B0 = B1 = ∅, since there is a unique rule assigning to an abstraction a non-arrow type. Otherwise, let us assume σi ≡ [τ i, ..., τ i ] → τ i
1	ni
for 0 ≤ i ≤ 1. Thus Bi ∪ {x : τ i, ..., x : τ i } ▶∗ M : τ i where ni ≥ 0 by Lemma
1	ni	∇
3.5.(vi). The legality implies that τ 0  ∇ τ1 and {τ 0, ..., τ 0 }  ∇ {τ 1, ..., τ 1 },

so the proof follows by induction.
1	n0
1	n1

Easy, in fact B0  ∇ B1 by applying the point (ii) of this Theorem. Since
B0 ⊆ B1 the proof is done.
 
Now we will prove that a legal stable type system induces a λ-model. We call this kind of model clique model for its relation with coherence spaces, which will be proved in Section 5. Indeed, Theorem 3.6 formalizes a crucial ingredient of such a correspondence.
Definition 3.7 Let ∇ be a legal stable type system.
A typing clique on ∇ is a set of types, pairwise coherent, closed under ∇. Typing cliques are ranged over by s, t. Let S(∇) be the set of typing cliques on ∇.

◦∇ is a binary operation defined on S(∇) in the following way:
s1 ◦∇ s2 = {τ | [σ1, ..., σn] → τ ∈ s1 and σi ∈ s2(1 ≤ i ≤ n)}.

Let ∇ be lazy. ◦l
is a binary operation defined on S(∇) in the following way:

s1 ◦l
s2 = {τ | ν∇ ∈ s1, [σ1, ..., σn] → τ ∈ s1 and σi ∈ s2(1 ≤ i ≤ n)}



We use ◦∗
to denote both compositions. Typing cliques play in this paper a

role similar to filters in filter models (see [9,18]).


Lemma 3.8 Let ∇ be a legal stable type system.
If s1, s2 ∈ S(∇) then both s1 ◦∇ s2 ∈ S(∇) and s1 ◦l

s2 ∈ S(∇).


Proof. We check that the elements of s1 ◦∇ s2 are pairwise coherent. Let τ1, τ2 ∈

s1 ◦∇ s2.  Thus, there are [σ0,... , σ0 ] → τ1, [σ1,... , σ1 ] → τ2 ∈ s1, σ0
∈ s2

1	n0	1	n1	i

(1 ≤ i ≤ n0) and σ1
∈ s2 (1 ≤ i ≤ n1). Since s1 and s2 are typing cliques (so

their elements are pairwise coherent) τ1 ¨∇ τ2. The closure under equivalence is immediate.

To prove s1 ◦l
s2 ∈ S(∇), just note that if ν∇ /∈ s1 then s1 ◦l
s2 = ∅. Otherwise

the composition is as the previous one.	 
The interpretation function associates to a term all types that can be assigned to it. If ∇ is a legal stable type system and ρ : V ar −→ S(∇), then we define

 M)∇ = {σ ∈ T∇ | ∃B.∀x.B(x) ⊆ ρ(x) ∧ B ▶∇ M : σ}.

Moreover, if ∇ is lazy then


 M)∇l = {σ ∈ T∇ | ∃B.∀x.B(x) ⊆ ρ(x) ∧ B ▶l
M : σ}.

ρ	∇

Observe that, by Theorem 3.6, the two interpretations map λ-terms into typing cliques.

Theorem 3.9 Let ∇ be a legal stable type system.
If ∇ = ⟨C,  ∇, -∇⟩ then M∇ = ⟨S(∇), ◦∇, .)∇⟩ is a λ-model.
If ∇ = ⟨C,  ∇, -∇, ν∇ ⟩ then M∇l = ⟨S(∇), ◦∇, .)∇l⟩ is a λ-model.

Proof. In both cases we need to check that the four conditions required to be a
λ-model, given in Definition 2.2, are respected.

Easy, in fact {σ ∈ T∇ | ∃B.(∀y.B(y) ⊆ ρ(y)) ∧ B ▶∗
x : σ} = ρ(x), by Lemma

3.5.(i).

By Lemma 3.5.(iv), it is easy to check that
 MN)∇ = {σ ∈ T∇ | ∃B.(∀y.B(y) ⊆ ρ(y)) such that B ▶∇ MN : σ}

⎧⎪⎨
B' ▶∇ M : [σ1, ..., σn] → σ, ⎫⎪⎬

=	σ ∈ T∇ ∃B.(∀y.B(y) ⊆ ρ(y)) such that
⎪	 
Bi ▶∇ N : σi,

⎩	B =( 
1≤i≤n Bi) ∪ B'	⎭

= {σ ∈ T∇ | [σ1, ..., σn] → σ ∈ M)∇ ∧ σi ∈ N)∇} = M)∇ ◦∇ N)∇
ρ	ρ	ρ	ρ
The lazy case is similar.
Let s ∈ S(∇). By Lemma 3.5.(vi), it is easy to check that
 λx.M)∇ ◦∇ s = {σ ∈ T∇ | σi ∈ s and [σ1, ..., σn] → σ ∈  λx.M)∇} =
ρ	ρ
= ⎧⎨σ ∈ T∇|∃B.(∀y.B(y) ⊆ ρ(y)) s.t. σi ∈ s for all i and	⎫⎬
⎧⎩	B ▶∇ λx.M : [σ1, ..., σn] → σ ⎭	⎫
= ⎨σ ∈ T∇|∃B.(∀y.B(y) ⊆ ρ(y)) s.t. σi ∈ s for all i and x /∈ dom(B)	⎬
⎩	and B ∪ {x : σ1, ..., x : σn} ▶∇ M : σ ⎭
= {σ ∈ T∇|∃B'.(∀y.B'(y) ⊆ ρ[s/x](y)) s.t. B' ▶∇ M : σ} =  M)∇


The lazy case is similar, since ν∇
∈ λx.M)∇l.

Let s ∈ S(∇) and let  M)∇
' ∇
ρ'[s/y]
. Thus, for all σ ∈ T∇:

∃B.(∀y.B(y)  ⊆  ρ[s/x](y)) s.t. B  ▶∇  M  :  σ  iff ∃B'.(∀y.B'(y)  ⊆
ρ'[s/x](y)) s.t. B' ▶∇ M' : σ.  B ▶∇ λx.M : [σ1, ..., σn] → τ if and only
if B ∪ {x : σ1, ..., x : σn} ▶∇ M : τ and x /∈ dom(B) by Lemma 3.5.(vi).
So ∃B'.(∀y.B'(y) ⊆ ρ'[B(x)/x](y)) such that B' ▶∇  M' : σ.  Likewise
∃B∗.(∀y.B∗(y) ⊆ ρ[B'(x)/x](y)) such that B∗ ▶∇ M : σ therefore B(x) ⊆ B'(x) ⊆ B∗(x). Hence B(x)= B'(x), since B(x)= B∗(x) by Theorem 3.6.(iii). The proof follows by Lemma 3.5.(vi). The lazy case is similar by Definition

3.7.(iii), since ν∇
∈ λx.M)∇l.


In such a way we defined two meta-models of λ-calculus, which can become models by choosing particular legal stable type systems. Some instances of such meta-models has been studied in [17] and in [6].
Definition 3.10
M∇ = ⟨S(∇), ◦∇, .)∇⟩ is the clique model induced by the legal stable type system ∇.
M∇l = ⟨S(∇), ◦∇, .)∇l⟩ is the lazy clique model induced by the lazy legal

stable type system ∇.
The two meta-models give a non empty interpretation to two interesting classes of terms.
Theorem 3.11 Let ∇ be a legal stable type system.
If M has head normal form then there are B, σ such that B ▶∇ M : σ.

If M has weak head normal form then there are B, σ such that B ▶l
M : σ.

Proof.	(i) The type assignment is closed under =β, since ▶∇ induces a λ-model. So we need to prove just that every term in head normal form can be typed.
Let M be λx1...λxm.xM1...Mn and let B = {x :[ ] → [ ] → ...[ ] → σ}, for a given
n
σ. Then B ▶∇ xM1...Mn : σ, by repeatedly applying (→E) rule.
m
If x /∈ {x1, ..., xm} then B ▶∇ M : ¸[ ] → [ x]`→ ...[ ˛] → σ by m applications of rule
(→I). Otherwise, if x = xh then
h−1	m	m−h
B ▶∇ M : [¸ ] → [ x]`→ ...[ ˛] → (¸[ ] → [ x]`→ ...[ ˛] → σ) → ¸[ ] → [ x]`→ ...[ ˛] → σ.
(ii) The case of an abstraction is immediate, by rule (Lazy). Otherwise, let M be
i
xM1...Mn, Bi = {x : [¸ ] → [ x]`→ ...[ ˛] → ν∇ } (1 ≤ i ≤ n − 1), and B = {x :
[ ] → [ ] → ...[ ] → σ}, for a given σ. By rule (→E), j<i Bj ▶l xM1...Mi : ν∇ and
`	 ˛n¸	lx	l
`	n˛−¸i	x
since it is easy to check that ★(B, B1, ..., Bn−1).

Theorem 3.11 is a necessary ingredient in order to prove that a clique model is adequate with respect to some well-studied operational semantics of λ-calculus (see Property 10.1.15 in page 117 of [23]).

Coherence Spaces
Coherence spaces are a simple framework for Berry’s stable functions [7], developed by Girard [14]; in this section their basic definitions and properties are stated. Proof details can be found in [15].
First, some basic definitions are necessary. A partial order or poset is a pair
⟨D, ±⟩ where D is a set and ± is an order relation, often noted simply as D. An element of D is bottom and denoted ⊥ if and only if ⊥ ± d for each d ∈ D. A nonempty subset X of D is directed if ∀x, x' ∈ X ∃x'' ∈ X such that x ± x'' and x' ± x'', namely for each pair of elements of X there is an upper bound in X. A cpo is a poset D with bottom ⊥ ∈ D such that if X ⊆ D is directed then there is HX ∈ D which is the least upper bound of X. Let A, B be cpos; a function f : A → B is monotone if and only if ∀x, x' ∈ A if x ±A x' then f (x) ±B f (x').

Definition 4.1  (i) A coherence space X is a pair ⟨|X|, ¨X ⟩ where |X| is a set called the web, its elements are called tokens and ¨X (the coherence relation on X) is a binary, reflexive and symmetric relation between tokens.
The set of cliques of X is Cl(X) = {x ⊆ |X| | ∀a, b ∈ x , a ¨X b}. Clfin(X) denotes the set of finite cliques of Cl(X).
The strict incoherence ˇX is the complementary relation of ¨X; the incoher- ence ˚X is the union of relations ˇX and =; the strict coherence -X is the complementary relation of ˚X.
If X is a coherence space then Cl(X) is a poset with respect to the relation ⊆.
Lemma 4.2 Let X be a coherence space.
∅∈ Cl(X).
{a}∈ Cl(X), for each a ∈ |X|.
If y ⊆ x and x ∈ Cl(X) then y ∈ Cl(X).
If D ⊆ Cl(X) is directed then ∪D ∈ Cl(X).
Hence, cliques of a coherence space with set-inclusion form a cpo.
Let x, x' be sets; x ⊆fin x' means that x ⊆ x' and x is finite.
Definition 4.3 Let X and Y be coherence spaces and f : Cl(X) −→ Cl(Y ) be a monotone function.
f is continuous whenever ∀x ∈ Cl(X) ∀b ∈ f (x) ∃x0 ⊆fin x such that b ∈ f (x0).
f is stable whenever ∀x ∈ Cl(X) ∀b ∈ f (x) ∃x0 ⊆fin x such that b ∈ f (x0) and
∀x' ⊆ x, if b ∈ f (x') then x0 ⊆ x'.
Continuity asks for the existence of a finite amount of input for which some amount of output is produced, while stability asks for a minimum finite amount input for which some amount of output is produced. Equivalent formulations of continuity and stability are formalized in the following Lemmas.
Lemma 4.4 (i) Let X and Y be coherence spaces and f : Cl(X) −→ Cl(Y ) be a monotone function. Then f is continuous if and only if f (∪D)= ∪{f (x) | x ∈ D}, for each D ⊆ Cl(X) directed.
(ii) Let X and Y be coherence spaces and f : Cl(X) −→ Cl(Y ) be a continuous function. Then f is stable if and only if ∀x, x' ∈ Cl(X), x ∪ x' ∈ Cl(X) implies f (x ∩ x')= f (x) ∩ f (x').
Stable functions can be represented as cliques of a coherence space.
Definition 4.5 Let X and Y be coherence spaces.
The trace tr(f ) of the stable function f : Cl(X) −→ Cl(Y ) is the set of pairs (x0, b) ∈ Clfin(X) × |Y | such that b ∈ f (x0) and ∀x ⊆ x0, b ∈ f (x) implies x = x0.
Definition 4.6 Let X and Y be coherence spaces.
X ⇒ Y is the coherence space having |X ⇒ Y | = Clfin(X) × |Y | as web, while

if (x0, b0), (x1, b1) ∈ |X ⇒ Y |, then (x0, b0) ¨X⇒Y (x1, b1) under the following conditions:
x0 ∪ x1 ∈ Cl(X) implies b0 ¨Y b1;
x0 ∪ x1 ∈ Cl(X) and b0 = b1 imply x0 = x1.
The previous definition can be reformulated in term of strict coherence as follows.
Proposition 4.7 (x0, b0) -X⇒Y (x1, b1) iff x0 ∪ x1 ∈ Cl(X) implies b0 -Y b1.
The bridge between stable functions and cliques follows.
Lemma 4.8 If f : Cl(X) −→ Cl(Y ) is a stable function then tr(f ) ∈ Cl(X ⇒ Y ). Let X, Y be coherence spaces and t ∈ Cl(X ⇒ Y ) and x ∈ Cl(X). Let us define
F(t): Cl(X) −→ Cl(Y ) be the function such that
F(t)(x)= {b ∈ |Y || ∃x0 ∈ Cl(X) (x0, b) ∈ t ∧ x0 ⊆ x}.
Lemma 4.9 If t ∈ Cl(X ⇒ Y ) then F(t): Cl(X) → Cl(Y ) is a stable function.
Coherence spaces and stable functions form a cartesian closed category, which will be denoted with Coh. It is a full subcategory of the categories of qualitative domains and dI-domains endowed with stable functions. All these categories con- tain objects and morphisms in the range of the standard interpretation of PCF, so without ambiguity they will be called stable models.
We conclude with an interesting sub-class of stable function, given by the fol- lowing definition
Definition 4.10 A stable function f : Cl(X) → Cl(Y ) is linear whenever, f (∅)= ∅ and for all x1, x2 ∈ Cl(X) such that x1 ∪ x2 ∈ Cl(X) we have that f (x1 ∪ x2) = f (x1) ∪ f (x2).
It is easy to see that if f : Cl(X) → Cl(Y ) is a linear function, then its trace
tr(f ) can be expressed as a subset of |X|× |Y |.

Stable λ-models
Let X be a reflexive object in the category Coh, namely a coherent space X such that X ⇒ X is a retract of X (noted X d X ⇒ X) through a retraction pair (φ, ψ), where φ and ψ are two stable functions such that φ : Cl(X) → Cl(X ⇒ X), ψ : Cl(X ⇒ X) → Cl(X) and φ · ψ = idX⇒X . We call φ an immersion morphism and ψ a projection morphism. The following categorical diagram summarizes the previous notions.

φ	id

X ¸ ¸
d	X ⇒ X
ψ

A retraction through (φ, ψ) on a coherence space X gives rise to the model for
λ-calculus M = ⟨Cl(X), ◦, .)⟩, where:
x ◦ y = F(φ(x))(y)
.) :Λ → Env → Cl(X) is defined as:
·  x)ρ = ρ(x);
λx.M)ρ = ψ(tr(λλy ∈ Cl(X). M)ρ[y/x]))
MN)ρ =  M)ρ ◦ N)ρ;
where Env = {ρ | ρ : V ar → Cl(X)} and λ denotes the meta-theoretic abstrac- tion.
Here we will define two particular classes of such models, putting some restric- tions on the retraction pair. If X = ⟨|X|, ¨X ⟩ and Y = ⟨|Y |, ¨Y ⟩ are two coherence spaces, then a function i : |X| → |Y | is iso-coherent when a ¨X b if and only if i(a) ¨Y i(b), for all a, b ∈ |X|. Note that an iso-coherent function is a map from tokens to tokens.
Definition 5.1 Let X be a coherence space and let i : |X ⇒ X|→ |X| be a total injective iso-coherent function. The pair ⟨X, i⟩ is a coherence lambda-structure.
A linear λ-model is the λ-model M induced by the retraction pair (φi, ψi) defined as
φi(x)= {a|i(a) ∈ x}	ψi(y)= {i(a)|a ∈ y}
Let X be such that |X| contains a distinguished token j such that it is coherent with all other tokens and j /∈ i(|X ⇒ X|). A lazy stable λ-model is the λ-model
Mj induced by the retraction pair (φj, ψj) defined as

i	i
φj(x)= ⎧⎨ {a | i(a) ∈ x}	if j ∈ x


ψj(y)= {i(a)|a ∈ y}∪ {j}

⎩ ∅	otherwise
It is routine to check that linear λ-models and lazy λ-models defined in the
previous definition are well-given λ-model in the sense of Definition 2.2, since φi, ψi, φj and ψj are stable functions and both (φi, ψi) and (φj, ψj) are retraction pairs.
i	i	i	i
The class of linear λ-models (first defined in [13]) collects all models in the category
Coh whose immersion-projection morphisms (φ, ψ) are linear functions, hence the adjective “linear”. The class of lazy λ-models collects instead a sub-class of those models whose projection morphism ψ is not strict, i.e. ψ(∅) /= ∅.
Let ∇ be a legal stable type system. In the following of this section, we denote

respectively by [τ ]∇
and T∇/ ∇ the equivalence class {σ ∈ T∇ | σ  ∇ τ } and

the whole set of such classes, i.e., {[τ ]∇
| τ ∈ T∇}. The next lemma proves that

types are names for tokens. The type theory formalizes the homonymy under which tokens are represented. Yet, an arrow is a special name denoting that the subjecting token is in the image of the projection of an opportune retraction.
Lemma 5.2 If ∇ be a legal stable type system then X∇ = ⟨T∇/ ∇ , ¨∇⟩ is a co-

herence space.
Proof. Easy, since the relation ¨∇ is reflexive and symmetric by construction.	 
So, by Definition 4.6, X∇ ⇒ X∇ = ⟨|X∇ ⇒ X∇|, ¨X∇⇒X∇ ⟩ is the coherence space, where:
|X∇ ⇒ X∇| = ({[σ1]∇ ,... , [σn]∇ }, [τ ]∇ )  ¨∇ {σ1,... , σn} , ,
({[σ1]∇ ,... , [σn]∇ }, [σ]∇ ) ¨X∇⇒X∇ ({[τ1]∇ ,... , [τm]∇ }, [τ ]∇ ) whenever,

if ¨∇ {[σ1]∇ ,... , [σn]∇ , [τ1]∇ ,... , [τm]∇ } then [σ]∇
¨∇ [τ ]∇
and [σ]∇
= [τ ]∇

implies {[σ1]∇ ,... , [σn]∇ } = {[τ1]∇ ,... , [τm]∇ }.
Definition 5.3 Let ∇ be a legal stable type system. The legal-structure induced by ∇ is the pair ⟨X∇, i∇⟩ where X∇ = ⟨T∇/ ∇ , ¨∇⟩ and i∇ : |X∇ ⇒ X∇|→ |X∇| is the map such that:
i∇ {[σ1]∇ ,... , [σn]∇ }, [τ ]∇  = [[σ1,... , σn] → τ ]∇ .

Note that we denote sets by sequences of their elements without repetitions. We can show that legal-structures induce coherence lambda-structures.
Lemma 5.4 Let ⟨X∇, i∇⟩ be a legal-structure.
⟨X∇, i∇⟩ is a coherence λ-structure, so it induces a linear λ-model.
If ∇ is lazy then ⟨X∇, i∇⟩ induces also a lazy λ-model by putting j = [ν∇ ]∇ .


Proof.	(i) Let x = {[σ1]∇ ,... , [σn]∇ }, y = {[τ1]∇ ,... , [τm]∇ }, a = [σ]∇
and b =

[τ ]∇ . We want to check that i∇ is injective. Suppose i∇((x, a)) = i∇((y, b)). By definition of i∇, this means that [σ1,... , σn] → σ  ∇ [τ1,... , τm] → τ . Since the type system is legal then {σ1,... , σm} ∇ {τ1,... , τn}, m = n and σ  ∇ τ .
Thus (x, a)= (y, b). Moreover, it is easy to check that i∇((x, a)) -∇ i∇((y, b)) if and only if (a, x) -X∇⇒X∇ (y, b) by Definition 3.1.(iii).
(ii) The proof follows easily, since j = [ν∇ ]∇ trivially enjoys the required coherence
constraints.

We are now able to state a soundness result proving that all our clique mod- els correspond to linear and lazy models.  Let us say that two λ-models M =
⟨D, ◦, .)M⟩ and M' = ⟨D', ◦', .)M' ⟩ coincide if D and D' are isomorphic through a
bijection h : D' −→ D, and  M)M = h( M)M' ), where ρ(x)= h(ρ'(x)).
ρ	ρ'
Theorem 5.5 (Soundness) Let ∇ be a legal stable type system.
The clique model M∇ and the linear λ-model induced by ⟨X∇, i∇⟩ coincide.
If ∇ is lazy with pivot ν∇ then the lazy clique model M∇l and the lazy λ-model induced by ⟨X∇, i∇⟩, with j = [ν∇ ]∇ , coincide.

Proof.  (i) Let us recall that the clique model induced by ∇ is M∇  =
⟨S(∇), ◦∇, .)∇⟩. The model induced by ⟨X∇, i∇⟩, is X ∇ = ⟨Cl(X∇), ◦, .)X∇ ⟩, where x ◦ y = F(φi∇ (x))(y), and the interpretation function is defined as at the beginning of this section. The isomorphism between S(∇) and Cl(X∇) fol- lows from the definition of X∇, namely, for each s ∈ S(∇) the corresponding element of Cl(X)∇ is {[τ ]∇ | τ ∈ s}. Then it is boring but easy to check, by

cases, that  M)X∇ =  M)∇ / 
where ρ∗(x)= 
[τ ]∇ , for all M.

(ii) The proof is similar to the previous point.

In order to prove completeness we need to recall some basic property of coherence spaces.
Proposition 5.6 Let X and Y be object of Coh, I be the set of all (possible) iso- morphisms between X and Y and T be the set of all (possible) iso-coherent bijective maps between |X| and |Y |. A biunivocal correspondence can be established between I and T .
Proof. Isomorphisms of Coh between X and Y are all and only bijective linear func- tions [14] whose trace univocally determines an iso-coherent bijective maps between
|X| and |Y |. For the other direction, an iso-coherent bijective map between |X| and
|Y | defines univocally a trace of a bijective linear function, i.e. an isomorphism (the hypothesis of iso-coherence is crucial in order to have a well-defined linear function). So there exists a biunivocal correspondence between I and T .	 
Now we will prove that, given a (lazy) linear λ-model induced by a coherence space we can define a type system inducing a (lazy) clique model coinciding with it. Then the completeness follows.
Lemma 5.7 Let ⟨X, i⟩ be a coherence lambda-structure.
There is a legal stable type system ∇ inducing the legal-structure ⟨X∇, i∇⟩ and there are two iso-coherent bijections (·)b : |X| −→ |X∇| and (·) : |X ⇒ X| −→
|X∇ ⇒ X∇| such that the following diagram commutes
|X ⇒ X| 	i	 |X |

(·) 
J	i∇
(·)b
J 

|X∇ ⇒ X∇|
 |X ∇|

Let X be such that |X| contains a distinguished token j coherent with all its other tokens and j /∈ i(|X ⇒ X|). Then there is a legal lazy stable type system
∇ such that the previous diagram commutes.
Proof. Let C∇ be a set in bijection with the set |X| through the map (·)b : |X|→ C∇. Let ∇ be the least stable type theory on Row(C∇) such that, if (x, a) ∈ |X ⇒ X|,
x = {a1, ..., an} and i((x, a)) = b ∈ |X| then [ab , ..., ab ] → ab  ∇ (b)b. Since i is
1	n
injective, (·)b induces an injection from |X| to Row(C∇)/ ∇ , i.e. if a, b ∈ |X| and

ab  ∇ bb then a = b. Let -∇ be the least binary relation on Row(C∇)/ ∇ satisfying Definition 3.1.(iii) and such that, if a -X b then [(a)b]∇ -∇ [(b)b]∇ , for all a, b ∈ |X|.
We will prove that ∇ = ⟨C∇, -∇,  ∇⟩ is the desired stable type system.
We already proved that (·)b induces a bijection between |X| and T∇/ ∇ . Injec- tivity follows since T∇/ ∇ ⊆ Row(C∇)/ ∇ . We can easily prove by induction that if σ ∈ T∇ then σ ∇ ab for a a ∈ |X|. Thus surjectivity follows.
We show that the type system so obtained is legal. We begin by the point (i) of Definition 3.4. Suppose that {σ1,... , σn} / ∇ {τ1,... , τm} or σ / ∇ τ . Let x, y, a, b such that x = {a1,... , an} with (aj)b  ∇ σj for all j ∈ [1, n], y = {b1,... , bm} with (bk)b ∇ τk for all k ∈ [1, m], (a)b ∇ σ, (b)b ∇ τ . Since (·)b induces a bijection between |X| and T∇/ ∇ , either σ / ∇ τ implies a /= b or {σ1,... , σn} / ∇
{τ1,... , τm} implies that there is aj /= bk. Then (x, a) and (y, b) are two different
tokens of |X ⇒ X|. Since i : |X ⇒ X|→ |X| is an injective function, we conclude [σ1,... , σn] → σ / ∇ [τ1,... , τm] → τ as required. To prove the remaining point, we just observe that (x, a) -X⇒X (y, b) if and only if either a -X b or there exist c1 ∈ x, c2 ∈ y such that c1 ×X c2. Thus point (ii) can be proved by using a reasoning similar to that for point (i).
Legality implies that X∇ = ⟨T∇/ ∇ , ¨∇⟩ is a coherence space. Hence, the map (·)  : |X ⇒ X| −→ |X∇ ⇒ X∇| is induced by the bijection between |X| and
|X∇|. If ({a1, ....an}, b) ∈ |X ⇒ X|, then -∇ {[(a1)b]∇ , ..., [(an)b]∇ } and we define
({a1, ....an}, b) = ({[(a1)b]∇ , ..., [(an)b]∇ }, [(a)b]∇ ). It is easy to see that such a map
is bijective, since (·)b is. Last, we choose as i∇ exactly that of Definition 5.3. It is easy to check that (i((x, a)))b = i∇((x, a) ), for all (x, a) ∈ |X ⇒ X|. So, the proof is done.
The proof of point (ii) is similar, taking (j) = [ν∇ ]∇ .	 
Corollary 5.8 (Completeness)
Let M and Mj be respectively a linear λ-model and a lazy λ-model.
There is a legal type system ∇ inducing a clique model that coincides with M.
There is a legal lazy type system ∇ inducing a lazy clique model that coincides with Mj.
Proof. By Lemma 5.7 we can build a legal type system ∇ inducing a linear model coinciding with M. Thus, the proof follows by Theorem 5.5. The proof of point (ii) is similar.	 

Conclusions and comparison with related works
Logical semantics in the setting of coherence spaces and stable functions has been previous studied in [6] and [17]. In [17] a class of stable λ-models is considered, containing as proper subclass the linear stable models. More precisely, in [17] stable models are considered, based on a space X containing as retract any subset of X ⇒ X, where the retract is realized by linear functions. Thus our linear models

are a proper subset of them. Starting from a λ-model M of this kind, a formal system is designed, assigning to λ-terms tokens of the coherence space on which M is based. This formal system provides a logical description of the interpretation function of the model M: the fact that the token a belongs to the interpretation of a term M is logically equivalent to the fact that the formal system is able to assign a to M. From this formal system, three type assignment systems are designed, in order to study three particular stable λ-models. All these models are built as an inverse limit solution of a domain equation, which is X ≈ X ⇒ X for two of them and X ≈ N ⊗ (X ⇒ X) for the remaining one, where N is the coherence space of natural numbers.
The rules of our type assignment system ▶ are in some sense inspired by this work. But in [17] the formal system is guided by the semantics, since it manipulates directly tokens of a coherence space, while we define the type assignment system in a completely syntactical manner, and then the legality condition assure us that the resulting clique model is isomorphic to a stable model. So we prove an isomorphism between clique models and stable models, while in [17] an isomorphism is proved between denotational interpretation and “token” assignment.
In [6] a general definition of a model of the lazy λ-calculus (in the sense of [1,3,21]) is given, and two particular stable models for it are built, through two type assignment systems. Both these models are built as an inverse limit solution of the domain equation X ≈ I&(X ⇒ X), where I denotes the coherence space with just one token. One of the systems defined in [6] is an instance of our system ▶l .
In conclusion we want to point out that (lazy) clique models have a very easy syntactical definition, and they can be used for studying different denotational se- mantics of λ-calculus, without any acquaintance with coherence spaces and stable functions. The results in Section 5 assure that reasoning on a legal clique model corresponds to reasoning in a well established mathematical category.

Acknowledgement
The authors would like to thank the anonymous referees for their fruitful sugges- tions.

References
Samson Abramsky. The lazy lambda-calculus. In David N. Turner, editor, Research Topics in Functional Programming, pages 65–117. Addison-Wesley Publ. Co., 1990.
Samson Abramsky. Domain theory in logical form. Annals of Pure and Applied Logic, 51(1-2):1–77, 1991.
Samson Abramsky and Luke Ong. Full abstraction in the lazy lambda calculus. Information and Computation, 105(2):159–267, 1993.
Henk Barendregt. The Lambda Calculus: Its Syntax and Semantics, volume 103 of Studies in logic and the foundation of mathematics. North-Holland, Amsterdam, revised edition, 1984. (First edition, 1981).

Henk Barendregt, Mario Coppo, and Mariangiola Dezani-Ciancaglini. A filter lambda model and the completeness of type assignment. The Journal of Symbolic Logic, 48(4):931–940, December 1983.
Olivier Bastonero, Alberto Pravato, and Simona Ronchi Della Rocca. Structures for lazy semantics. In Gries de Roever, editor, Programming Concepts and Methods, pages 30–48. Chaptman & Hall, 1998. International Conference on Programming Concepts and Methods - PROCOMET’98, 8-12 June 1998, Shelter Island, New York, USA.
G´erard Berry. Stable models of typed λ-calculi. In Giorgio Ausiello and Corrado B¨ohm, editors, Fifth International Colloquium on Automata, Languages and Programming - - ICALP’78, Udine, Italy, July 17-21, 1978, volume 62 of Lecture Notes in Computer Science, pages 72–89. Springer-Verlag, 1978.
Mario Coppo and Mariangiola Dezani-Ciancaglini. An extension of the basic functionality theory for the λ-calculus. Notre Dame Journal of Formal Logic, 21(4):685–693, October 1980.
Mario Coppo, Mariangiola Dezani-Ciancaglini, Furio Honsell, and Giuseppe Longo. Extended type structure and filter lambda models. In G. Lolli, G. Longo, and A. Marcja, editors, Logic Colloquim’82, pages 241–262. Elsevier Science Publishers, Amsterdam, 1984.
Mario Coppo, Mariangiola Dezani-Ciancaglini, and Maddalena Zacchi. Type theories, normal forms, and D∞-lambda-models. Information and Computation, 72(2):85–116, 1987.
Mariangiola Dezani-Ciancaglini, Silvia Ghilezan, and Silvia Likavec. Behavioural inverse limit lambda- models. Theoretical Computer Science, 316(1–3):49–74, 2004.
Lavinia Egidi, Furio Honsell, and Simona Ronchi Della Rocca. Operational, denotational and logical descriptions: a case study. Fundamenta Informaticæ, 16(2):149–170, 1992.
Jean-Yves Girard. The System F of variable types, fifteen years later. Theoretical Computer Science, 45(2):159–192, 1986.
Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
Jean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and Types. Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, Cambridge, 1989.
J. Roger Hindley and Giuseppe Longo. Lambda calculus models and extensionality. Zeitschrift fu¨r mathematische Logik und Grundlagen der Mathematik, 26:289–310, 1980.
Furio Honsell and Simona Ronchi della Rocca. Reasoning about interpretation in qualitative lambda- models. In M. Broy and C.B. Jones, editors, Proceedings of Working Conference on Programming Concepts and Methods - IFIP 2.2, pages 505–521, Sea of Galilee, Israel, 1990. North-Holland.
Furio Honsell and Simona Ronchi Della Rocca. An approximation theorem for topological lambda models and the topological incompleteness of lambda calculus. Journal of Computer and System Sciences, 45(1):49–75, August 1992.
C. P. J. Koymans. Models of the lambda calculus. Information and Computation, 52(3):306–323, 1982.
Albert Meyer. What is a model of the lambda calculus? Information and Computation, 52(1):87–122, 1982.
C.-H. Luke Ong. Fully abstract models of the lazy lambda calculus. In Proceedings of the 29th Annual Symposium on Foundations of Computer Science - FOCS’88, pages 368–376, White Plains, New York, 24–26 October 1988. IEEE Computer Society Press.
Gordon D. Plotkin. Set-theoretical and other elementary models of the λ-calculus. In Mariangiola Dezani-Ciancaglini, Simona Ronchi Della Rocca, and Marisa Venturini-Zilli, editors, Theoretical Computer Science, volume 121(1-2), pages 351–409. Logic, Semantics and Theory of Programming, 6 December 1993. A Collection of Contributions in Honour of Corrado Bhm on the Occasion of his 70th Birthday .
Simona Ronchi Della Rocca and Luca Paolini. The Parametric λ-Calculus: a Metamodel for Computation. Texts in Theoretical Computer Science: An EATCS Series. Springer-Verlag, Berlin, 2004.
