Electronic Notes in Theoretical Computer Science 45 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume45.html 22 pages


Typing Correspondence Assertions for Communication Protocols

Andrew D. Gordon
Microsoft Research, Cambridge

Alan Jeffrey
DePaul University, Chicago


Abstract
Woo and Lam propose correspondence assertions for specifying authenticity proper- ties of security protocols. The only prior work on checking correspondence assertions depends on model-checking and is limited to finite-state systems. We propose a de- pendent type and effect system for checking correspondence assertions. Since it is based on type-checking, our method is not limited to finite-state systems. This paper presents our system in the simple and general setting of the π-calculus. We show how to type-check correctness properties of example communication protocols based on secure channels. In a related paper, we extend our system to the more complex and specific setting of checking cryptographic protocols based on encrypted messages sent over insecure channels.

Introduction
Correspondence Assertions To a first approximation, a correspondence assertion about a communication protocol is an intention that follows the pattern:
If one principal ever reaches a certain point in a protocol, then some other principal has previously reached some other matching point in the protocol.
We record such intentions by annotating the program representing the protocol with labelled assertions of the form begin L or end L. These assertions have no effect at runtime, but notionally indicate that a principal has reached a certain point in the protocol. The following more accurately states the intention recorded by these annotations:
If the program embodying the protocol ever asserts end L, then there is a distinct previous assertion of begin L.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


Woo and Lam [27] introduce correspondence assertions to state intended properties of authentication protocols based on cryptography. Consider a protocol where a principal a generates a new session key k and transmits it to b. We intend that if a run of b ends a key exchange believing that it has received key k from a, then a generated k as part of a key exchange intended for b. We record this intention by annotating a’s generation of k by the label begin ⟨a, b, k⟩, and b’s reception of k by the label end ⟨a, b, k⟩.
A protocol can fail a correspondence assertion because of several kinds of
bug. One kind consists of those bugs that cause the protocol to go wrong without any external interference. Other kinds are bugs where an unreliable or malicious network or participant causes the protocol to fail.

This Paper We show in this paper that correctness properties expressed by correspondence assertions can be proved by type-checking. We embed corre- spondence assertions in a concurrent programming language (the π-calculus of Milner, Parrow, and Walker [18]) and present a new type and effect system that guarantees safety of well-typed assertions. We show several examples of how correspondence assertions can be proved by type-checking.
Woo and Lam’s paper introduces correspondence assertions but provides no techniques for proving them. Clarke and Marrero [4] use correspondence assertions to specify properties of e-commerce protocols, such as authoriza- tions of transactions. To the best of our knowledge, the only previous work on checking correspondence assertions is a project by Marrero, Clarke, and Jha [17] to apply model-checking techniques to finite state versions of security protocols. Since our work is based on type-checking, it is not limited to finite state systems. Moreover, type-checking is compositional: we can verify com- ponents in isolation, and know that their composition is safe, without having to verify the entire system. Unlike Marrero, Clarke, and Jha’s work, however, the system of the present paper does not deal with cryptographic primitives, and nor does it deal with an arbitrary opponent. Still, in another paper [9], we adapt our type and effect system to the setting of the spi-calculus [1], an extension of the π-calculus with abstract cryptographic primitives. This adaptation can show, moreover, that properties hold in the presence of an arbitrary untyped opponent.
A technical report [10] includes proofs omitted from this paper.

Review of The Untyped π-Calculus Milner, Parrow, and Walker’s π- calculus is a concurrent formalism to which many kinds of concurrent com- putation may be reduced. Its simplicity makes it an attractive vehicle for developing the ideas of this paper, while its generality suggests they may be widely applicable. Its basic data type is the name, an unguessable identifier for a communications channel. Computation is based on the exchange of mes- sages, tuples of names, on named channels. Programming in the π-calculus is based on the following constructs (written, unusually, with keywords, for the

sake of clarity). The rest of the paper contains many examples. An output process out x⟨y1,..., yn⟩ represents a message ⟨y1,..., yn⟩ sent on the channel
x. An input process inp x(z1,..., zn); P blocks till it finds a message sent on
the channel x, reads the names in the message into the variables z1,..., zn, and then runs P . The process P | Q is the parallel composition of the two pro- cesses P and Q; the two may run independently or communicate on shared channels. The name generation process new(x); P generates a fresh name, calls it x, then runs P . Unless P reveals x, no other process can use this fresh name. The replication process repeat P behaves like an unbounded parallel array of replicas of P . The process stop represents inactivity; it does nothing. Finally, the conditional if x = y then P else Q compares the names x and y. If they are the same it runs P ; otherwise it runs Q.

Correspondence Assertions, by Example
This section introduces the idea of defining correspondence assertions by an- notating code with begin- and end-events. We give examples of both safe code and of unsafe code, that is, of code that satisfies the correspondence assertions induced by its annotations, and of code that does not.
A transmit-acknowledge handshake is a standard communications idiom, easily expressed in the π-calculus: along with the actual message, the sender transmits an acknowledgement channel, upon which the receiver sends an acknowledgement. We intend that:
During a transmit-acknowledge handshake, if the sender receives an ac- knowledgment, then the receiver has obtained the message.
Correspondence assertions can express this intention formally. Suppose that a and b are the names of the sender and receiver, respectively. We annotate the code of the receiver b with a begin-assertion at the point after it has received the message msg . We annotate the code of the sender a with an end-assertion at the point after it has received the acknowledgement. We label both assertions with the names of the principals and the transmitted message, ⟨a, b, msg ⟩. Hence, we assert that if after sending msg to b, the
sender a receives an acknowledgement, then a distinct run of b has received
msg .
Suppose that c is the name of the channel on which principal b receives messages from a. Here is the π-calculus code of the annotated sender and receiver:


Rcver (a, b, c) = inp c(msg, ack ); begin ⟨a, b, msg ⟩; out ack ⟨⟩
Snder (a, b, c) =
new(msg ); new(ack );
out c⟨msg, ack ⟩; inp ack ();
end ⟨a, b, msg ⟩

The sender creates a fresh message msg and a fresh acknowledgement channel

ack , sends the two on the channel c, waits for an acknowledgement, and then asserts an end-event labelled ⟨a, b, msg ⟩.
The receiver gets the message msg and the acknowledgement channel ack
off c, asserts a begin-event labelled ⟨a, b, msg ⟩, and sends an acknowledgement on ack .
We say a program is safe if it satisfies the intentions induced by the begin- and end-assertions. More precisely, a program is safe just if for every run of the program and for every label L, there is a distinct begin-event labelled L preceding every end-event labelled L. (We formalize this definition in Sec- tion 5.)
Here are three combinations of our examples: two safe, one unsafe.


new(c);
Snder (a, b, c) |
Rcver (a, b, c)
(Example 1: safe)

Example 1 uses one instance of the sender and one instance of the receiver to represent a single instance of the protocol. The restriction new(c); makes the channel c private to the sender and the receiver. This assembly is safe; its only run correctly implements the handshake protocol.


new(c);
Snder (a, b, c) |
Snder (a, b, c) |
repeat Rcver (a, b, c)
(Example 2: safe)

Example 2 uses two copies of the sender—representing two attempts by a single principal a to send a message to b—and a replicated copy of the receiver— representing the principal b willing to accept an unbounded number of mes- sages. Again, this assembly is safe; any run consists of an interleaving of two correct handshakes.


new(c);
Snder (a, b, c) |
Snder (a', b, c) |
repeat Rcver (a, b, c)
(Example 3: unsafe)

Example 3 is a variant on Example 2, where we keep the replicated receiver b, but change the identity of one of the senders, so that the two senders represent two different principals a and a'. These two principals share a single channel c to the receiver. Since the identity a of the sender is a parameter of Rcver (a, b, c) rather than being explicitly communicated, this assembly is unsafe. There is a run in which a' generates msg and ack , and sends them to b; b asserts a begin-event labelled ⟨a, b, msg ⟩ and outputs on ack ; then a' asserts an end-event labelled ⟨a', b, msg ⟩. This end-event has no corresponding begin- event so the assembly is unsafe, reflecting the possibility that the receiver can

be mistaken about the identity of the sender.

Typing Correspondence Assertions
Types and Effects
Our type and effect system is based on the idea of assigning types to names and effects to processes. A type describes what operations are allowed on a name, such as what messages may be communicated on a channel name. An effect describes the collection of labels of events the process may end while not itself beginning. We compute effects based on the intuition that end- events are accounted for by preceding begin-events; a begin-event is a credit while an end-event is a debit. According to this metaphor, the effect of a process is an upper bound on the debt a process may incur. If we can assign a process the empty effect, we know all of its end-events are accounted for by begin-events. Therefore, we know that the process is safe, that is, its correspondence assertions are true.
An essential ingredient of our typing rules is the idea of attaching a latent effect to each channel type. We allow any process receiving off a channel to treat the latent effect as a credit towards subsequent end-events. This is sound because we require any process sending on a channel to treat the latent effect as a debit that must be accounted for by previous begin-events. Latent effects are at the heart of our method for type-checking events begun by one process and ended by another.
The following table describes the syntax of types and effects. As in most versions of the π-calculus, we make no lexical distinction between names and variables, ranged over by a, b, c, x, y, z. An event label, L, is simply a tuple of names. Event labels identify the events asserted by begin- and end-assertions. An effect, e, is a multiset, that is, an unordered list, of event labels, written as [L1,..., Ln]. A type, T , takes one of two kinds. The first kind, Name, is the type of pure names, that is, names that only support equality operations, but cannot be used as channels. We use Name as the type of names that identify principals, for instance. The second kind, Ch(x1:T1,..., xn:Tn)e, is a type of a channel communicating n-tuples of names, of types T1, ..., Tn, with latent effect e. The names x1, ..., xn are bound; the scope of each xi consists of the types Ti+1, ..., Tn, and the latent effect e. We identify types up to the consistent renaming of bound names.
Names, Event Labels, Effects, and Types:
a, b, c, x, y, z	names, variables
L ::= ⟨x1,..., xn⟩	event label: tuple of names
e ::= [L1,..., Ln]	effect: multiset of event labels
T ::=	type
Name	pure name

Ch(x1:T1,..., xn:Tn)e	channel with latent effect e
For example:
Ch()[], a synchronization channel (that is, a channel used only for synchro- nization) with no latent effect.
Ch(a:Name)[⟨b⟩], a channel for communicating a pure name, costing [⟨b⟩] to senders and paying [⟨b⟩] to receivers, where b is a fixed name.
Ch(a:Name)[⟨a⟩], a channel for communicating a pure name, costing [⟨a⟩] to senders and paying [⟨a⟩] to receivers, where a is the name communicated on the channel.
Ch(a:Name, b:Ch()[⟨a⟩])[], a channel with no latent effect for communicating pairs of the form a, b, where a is a pure name, and b is the name of a syn- chronization channel, costing [⟨a⟩] to senders and paying [⟨a⟩] to receivers.
The following is a convenient shorthand for the lists of typed variable decla- rations found in channel types:
Notation for Typed Variables:

→x:T→ =∆ x :T ,...,x :T
where →x = x ,...,x  and T→ = T ,...,T 

1	1	n	n
∆
1	n	1	n

ϵ = ()	the empty list
The following equations define the the sets of free names of our syntax

as follows: variable declarations, fn(ϵ:ϵ) =
∅ and fn(→x:T→ , x:T ) =
fn(→x:T→ ) ∪

(fn(T )−{→x}); types, fn(Name) =∆ ∅ and fn(Ch(→x:T→ )e) =∆ fn(→x:T→ )∪(fn(e)−{→x});

event labels, fn(⟨x1,..., xn⟩) fn(L1) ∪· · · ∪ fn(Ln).
= {x1,..., xn}; and events, fn([L1,..., L1]) =

For any of these forms of syntax, we write −{x←y} for the operation of capture-avoiding substitution of the name y for each free occurrence of the name x. We write −{→x←→y}, where →x = x1,..., xn and →y = y1,..., yn for the iterated substitution −{x1←y1}··· {xn←yn}.
Syntax of our Typed π-Calculus
We explained the informal semantics of begin- and end-assertions in Section 2, and of the other constructs in Section 1.
Processes:
P, Q, R ::=	process
out x⟨y1,..., yn⟩	polyadic asynchronous output
inp x(y1:T1,..., yn:Tn); P	polyadic input
if x = y then P else Q	conditional
new(x:T ); P	name generation
P | Q	composition
repeat P	replication

stop	inactivity
begin L; P	begin-assertion
end L; P	end-assertion
There are two name binding constructs: input and name generation. In an input process inp x(y1:T1,..., yn:Tn); P , each name yi is bound, with scope consisting of Ti+1, . . . , Tn, and P . In a name restriction new(x:T ); P , the name x is bound; its scope is P . We write P {x←y} for the outcome of a capture-avoiding substitution of the name y for each free occurrence of the name x in the process P . We identify processes up to the consistent renaming of bound names. We let fn(P ) be the set of free names of a process P . We sometimes write an output as out x⟨→y⟩ where →y = y1,..., yn, and an input

as inp x(→y:T→ ); P , where →y:T→
is a variable declaration written in the notation

introduced in the previous section. We write out x⟨→y⟩; P as a shorthand for
out x⟨→y⟩ | P .
Intuitions for the Type and Effect System
As a prelude to our formal typing rules, we present the underlying intuitions. Recall the intuition that end-events are costs to be accounted for by begin- events. When we say a process P has effect e, it means that e is an upper bound on the begin-events needed to precede P to make the whole process safe. In other words, if P has effect [L1,..., Ln] then begin L1; ··· ; begin Ln; P is safe.

Typing Assertions  An assertion begin L; P pays for one end-event labelled L in P ; so if P is a process with effect e, then begin L; P is a process with effect e−[L], that is, the multiset e with one occurrence of L deleted. So we have a typing rule of the form:
P : e	⇒	begin L; P : e−[L]
If P is a process with effect e, then end L; P is a process with effect e+[L], that is, the concatenation of e and [L]. We have a rule:
P : e	⇒	end L; P : e+[L]
Typing Name Generation and Concurrency The effect of a name gen- eration process new(x:T ); P , is simply the effect of P . To prevent scope con- fusion, we forbid x from occurring in this effect.
P : e, x ∈/ fn(e)	⇒	new(x:T ); P : e
The effect of a concurrent composition of processes is the multiset union of the constituent processes.
P : eP , Q : eQ	⇒	P | Q : eP +eQ
The inactive process asserts no end-events, so its effect is empty.

stop :[] 
The replication of a process P behaves like an unbounded array of repli- cas of P . If P has a non-empty effect, then its replication would have an unbounded effect, which could not be accounted for by preceding begin- assertions. Therefore, to type repeat P we require P to have an empty effect.
P :[]  ⇒  repeat P :[] 
Typing Communications We begin by presenting the rules for typing communications on monadic channels with no latent effect, that is, those with types of the form Ch(y:T )[]. The communicated name has type T . An output out x⟨z⟩ has empty effect. An input inp x(y:T ); P has the same effect as P . Since the input variable in the process and in the type are both bound, we may assume they are the same variable y.
x : Ch(y:T )[], z : T  ⇒  out x⟨z⟩ :[] 
x : Ch(y:T )[], P : e, y ∈/ fn(e)	⇒	inp x(y:T ); P : e
Next, we consider the type Ch(y:T )el of monadic channels with latent effect el. The latent effect is a cost to senders, a benefit to receivers, and is the scope of the variable y. We assign an output out x⟨z⟩ the effect el{y←z}, where we have instantiated the name y bound in the type of the channel with z, the name actually sent on the channel. We assign an input inp x(y:T ); P the effect e − el, where e is the effect of P . To avoid scope confusion, we require that y is not free in e − el.
x : Ch(y:T )el, z : T	⇒	out x⟨z⟩ : el{y←z}
x : Ch(y:T )el, P : e, y ∈/ fn(e − el)	⇒	inp x(y:T ); P : e − el
The formal rules for input and output in the next section generalize these rules to deal with polyadic channels.

Typing Conditionals  When typing a conditional if x = y then P else Q, it is useful to exploit the fact that P only runs if the two names x and y are equal. To do so, we check the effect of P after substituting one for the other. Suppose then process P {x←y} has effect eP {x←y}. Suppose also that process Q has effect eQ. Let eP ∨ eQ be the least upper bound of any two effects eP and eQ. Then eP ∨ eQ is an upper bound on the begin-events needed to precede the conditional to make it safe, whether P or Q runs. An example in Section 4.2 illustrates this rule.
P {x←y} : eP {x←y}, Q : eQ	⇒	if x = y then P else Q : eP ∨ eQ
Typing Rules
Our typing rules depend on several operations on effect multisets, most of which were introduced informally in the previous section. Here are the formal definitions.

Operations on effects: e + e', e ≤ e', e − e', L ∈ e, e ∨ e'

[L1,..., Lm]+ [Lm+1,..., Lm+n] = [L1,..., Lm+n]
e ≤ e' if and only if e' = e + e'' for some e''
e − e' =∆  the smallest e'' such that e ≤ e' + e''
L ∈ e if and only if [L] ≤ e
e ∨ e' =∆  the smallest e'' such that e ≤ e'' and e' ≤ e''

The typing judgments of this section depend on an environment to assign a type to all the variables in scope.
Environments:

E ::= →x:T→
environment

dom(→x:T→ ) =∆ {→x}	domain of an environment

To equate two names in an environment, needed for typing conditionals, we define a name fusion function. We obtain the fusion E{x←x'} from E by turning all occurrences of x and x' in E into x'.
Fusing x with x' in E: E{x←x'}

(x :T ,...,x :T
){x←x'} =∆

1	1	n	n
(x1{x←x'}):(T1{x←x'}); ... ; (xn{x←x'}):(Tn{x←x'}) where E; x:T =∆	E	if x ∈ dom(E)
E, x:T otherwise
The following table summarizes the five judgments of our type system, which are inductively defined by rules in subsequent tables. Judgment E ▶ ⬦ means environment E is well-formed. Judgment E ▶ T means type T is well-formed. Judgment E ▶ x : T means name x is in scope with type T . Judgment E ▶ ⟨→x⟩ : ⟨→y:T→ ⟩ means tuple ⟨→x⟩ matches the variable declaration
→y:T→ . Judgment E ▶ P : e means process P has effect e.
Judgments:
E ▶ ⬦	good environment
E ▶ T	good type T
E ▶ x : T	good name x of type T
E ▶ ⟨→x⟩ : ⟨→y:T→ ⟩	good message →x matching →y:T→
E ▶ P : e	good process P with effect e

The rules defining the first three judgments are standard.

Good environments, types, and names:

(Env ∅)

∅ ▶ ⬦ 
(Env x)
E ▶ T	x ∈/ dom(E)
E, x:T ▶ ⬦ 
(Type Name)
E ▶ ⬦ 
E ▶ Name

(Type Chan)
E, →x:T→ ▶ ⬦	fn(e) ⊆ dom(E) ∪ {→x}
E ▶ Ch(→x:T→ )e
(Name x)
E', x:T, E'' ▶ ⬦ 
E', x:T, E'' ▶ x : T


The next judgment, E ▶ ⟨→x⟩ : ⟨→y:T→ ⟩, is an auxiliary judgment used for typing output processes; it is used in the rule (Proc Output) to check that the message ⟨→x⟩ sent on a channel of type Ch(→y:T→ )e matches the variable declaration →y:T→ .
Good message:

(Msg ⟨⟩)
E ▶ ⬦ 
E ▶ ⟨⟩ : ⟨⟩
(Msg x) (where y ∈/ {→y}∪ dom(E)) E ▶ ⟨→x⟩ : ⟨→y:T→ ⟩	E ▶ x : (T {→y←→x}) E ▶ ⟨→x, x⟩ : ⟨→y:T→ , y:T ⟩


Finally, here are the rules for typing processes. The effect of a process is an upper bound; the rule (Proc Subsum) allows us to increase this upper bound. Intuitions for all the other rules were explained in the previous section.
Good processes:
(Proc Subsum) (where e ≤ e' and fn(e') ⊆ dom(E))
E ▶ P : e
E ▶ P : e'
(Proc Output)
E ▶ x : Ch(→y:T→ )e	E ▶ ⟨→x⟩ : ⟨→y:T→ ⟩

E ▶ out x⟨→x⟩ : (e{→y←→x})
(Proc Input) (where fn(e − e') ⊆ dom(E))
E ▶ x : Ch(→y:T→ )e'	E, →y:T→ ▶ P : e E ▶ inp x(→y:T→ ); P : e − e'
(Proc Cond)
 E ▶ x : T	E ▶ y : T	E{x←y} ▶ P {x←y} : eP {x←y}	E ▶ Q : eQ 
E ▶ if x = y then P else Q : eP ∨ eQ

(Proc Res) (where x ∈/ fn(e)) E, x:T ▶ P : e

E ▶ new(x:T ); P : e
(Proc Par)
E ▶ P : eP	E ▶ Q : eQ E ▶ P | Q : eP + eQ



(Proc Repeat)
E ▶ P :[] 

E ▶ repeat P :[] 
(Proc Stop)
E ▶ ⬦ 

E ▶ stop :[] 

(Proc Begin) (where fn(L) ⊆ dom(E))
E ▶ P : e

E ▶ begin L; P : e − [L]
(Proc End) (where fn(L) ⊆ dom(E))
E ▶ P : e

E ▶ end L; P : e + [L]

Section 5 presents our main type safety result, Theorem 5.2, that E ▶ P :[] implies P is safe. Like most type systems, ours is incomplete. There are safe processes that are not typeable in our system. For example, we cannot assign the process if x = x then stop else (end x; stop) the empty effect, and yet it is perfectly safe.




Applications

In this section, we present some examples of using correspondence assertions to validate safety properties of communication protocols. For more examples, including examples with cryptographic protocols which are secure against ex- ternal attackers, see the companion paper [9].




Transmit-Acknowledge Handshake

Recall the untyped sender and receiver code from Section 2. Suppose we make the type definitions:




∆	∆
Msg = Name	Ack (a, b, msg ) = Ch()[⟨a, b, msg ⟩]
∆	∆
Host = Name	Req (a, b) = Ch(msg :Msg, ack :Ack (a, b, msg ))[]

Suppose also that we annotate the sender and receiver code, and the code of Example 1 as follows:




Snder (a:Host , b:Host , c:Req (a, b)) =
new(msg :Msg );
new(ack :Ack (a, b, msg ));
out c⟨msg, ack ⟩;
inp ack ();
end ⟨a, b, msg ⟩
Rcver (a:Host , b:Host , c:Req (a, b)) =
inp c(msg :Msg, ack :Ack (a, b, msg ));
begin ⟨a, b, msg ⟩;
out ack ⟨⟩

∆

Example1 (a:Host , b:Host ) =
new(c:Req (a, b));
Snder (a, b, c) |
Rcver (a, b, c)


We can then check that a:Host , b:Host ▶ Example1 (a, b) : []. Since the system has the empty effect, by Theorem 5.2 it is safe. It is routine to check that Example 2 from Section 2 also has the empty effect, but that Example 3 cannot be type-checked (as to be expected, since it is unsafe).






Hostname Lookup

In this example, we present a simple hostname lookup system, where a client b wishing to ping a server a can contact a name server query , to geta network address ping for a. The client can then send a ping request to the address ping , and get an acknowledgement from the server. We shall check two properties:
When the ping client b finishes, it believes that the ping server a has been pinged.
When the ping server a finishes, it believes that it was contacted by the ping client b.
We write “a was pinged by b” as shorthand for ⟨a, b⟩, and “b tried to ping a” for ⟨b, a, a⟩. These examples are well-typed, with types which we define later in this section.

We program the ping client and server as follows.

PingClient (a:Hostname, b:Hostname, query :Query ) =
new(res : Res(a));
out query ⟨a, res⟩;
inp res(ping : Ping (a)); new(ack : Ack (a, b)); begin “b tried to ping a”; out ping ⟨b, ack ⟩;
inp ack ();
end “a was pinged by b”
PingServer (a : Hostname, ping : Ping (a)) =
repeat
inp ping (b : Hostname, ack : Ack (a, b));
begin “a was pinged by b”; end “b tried to ping a”; out ack ⟨⟩

If these processes are safe, then any ping request and response must come as matching pairs. In practice, the name server would require some data structure such as a hash table or database, but for this simple example we just use a large if-statement:

NameServer (
query :Query,
h1:Hostname,..., hn:Hostname,
ping 1:Ping (h1),..., pingn:Ping (hn)
) =
repeat
inp query (h, res);
if h = h1 then out res⟨ping 1⟩ else ··· 
if h = hn then out res⟨ping n⟩ else stop
To get the system to type-check, we use the following types:

Hostname = Name
Ack (a, b) = Ch()[“a was pinged by b”]
Ping (a) = Ch(b:Hostname, ack :Ack (a, b))[“b tried to ping a”]
Res(a) = Ch(ping :Ping (a))[]
∆
Query = Ch(a:Hostname, res:Res(a))[]

The most subtle part of type-checking the system is the conditional in the name server. A typical branch is:
hi : Hostname, pingi : Ping (hi),h : Hostname, res : Res(h)
▶ if h = hi then out res⟨ping i⟩ else ··· :[] 
When type-checking the then-branch, (Proc Cond) assumes h = hi by apply- ing a substitution to the environment:
(hi : Hostname, pingi : Ping (hi),h : Hostname, res : Res(h)){h←hi}
= (hi : Hostname, pingi : Ping (hi), res : Res(hi))
In this environment, we can type-check the then-branch:
hi : Hostname, pingi : Ping (hi), res : Res(hi)
▶ out res⟨ping i⟩ :[] 
If (Proc Cond) did not apply the substitution to the environment, this example could not be type-checked, since:
hi : Hostname, pingi : Ping (hi),h : Hostname, res : Res(h)
b out res⟨ping i⟩ :[] 

Functions
It is typical to code the λ-calculus into the π-calculus, using a return channel k as the destination for the result. For instance, the hostname lookup example of the previous section can be rewritten in the style of a remote procedure call. The client and server are now:
PingClient (a:Hostname, b:Hostname, query :Query ) =
let (ping : Ping (a)) = query ⟨a⟩;
begin “b tried to ping a”;
let () = ping ⟨b⟩;
end “a was pinged by b”
PingServer (a : Hostname, ping : Ping (a)) =
fun ping (b:Hostname) { begin “a was pinged by b”; end “b tried to ping a”; return ⟨⟩
}

The name server is now:
NameServer (
query :Query,
h1:Hostname,..., hn:Hostname,
ping 1:Ping (h1),..., pingn:Ping (hn)
) =
fun query (h:Hostname) {
if h = h1 then return ⟨ping 1⟩ else ··· 
if h = hn then return ⟨pingn⟩ else stop
}
In order to provide types for these examples, we have to provide a function type with latent effects. These effects are precondition/postcondition pairs, which act like Hoare triples. In the type (→x:T→ )e → (→y:U→ )e' we have a precondition e which the callee must satisfy, and a postcondition e' which the caller must satisfy. For example, the types for the hostname lookup example are:
Ping (a) = (b:Hostname)[“b tried to ping a”] → ()[“a was pinged by b”]
∆
Query = (a:Hostname)[] → (ping :Ping (a))[]
which specifies that the remote ping call has a precondition “b tried to ping a” and a postcondition “a was pinged by b”.
This can be coded into the π-calculus using a translation [18] in continu- ation passing style.
fun f (→x:T→ ) {P } =∆ repeat inp f (→x:T→ , k:Ch(→y:U→ )e'); P
let (→y:U→ )= f ⟨→x⟩; P = new(k:Ch(y→:U→ )e'); out f ⟨x,→ k⟩; inp k(y→:U→ ); P
∆
return ⟨→z⟩ = out k⟨→z⟩
(→x:T→ )e → (→y:U→ )e' =∆ Ch(→x:T→ , k:Ch(→y:U→ )e')e
This translation is standard, except for the typing. It is routine to verify its soundness.

Formalizing Correspondence Assertions
In this section, we give the formal definition of the trace semantics for the π-calculus with correspondence assertions, which is used in the definition of a safe process. We then state the main result of this paper, which is that effect-free processes are safe.
We give the trace semantics as a labelled transition system. Following Berry and Boudol [3] and Milner [18] we use a structural congruence P ≡ Q, and give our operational semantics up to ≡.

Structural Congruence: P ≡ Q

P ≡ P	(Struct Refl)
Q ≡ P ⇒ P ≡ Q	(Struct Symm)
P ≡ Q, Q ≡ R ⇒ P ≡ R	(Struct Trans)
P ≡ Q ⇒ inp x(→y:T→ ); P ≡ inp x(→y:T→ ); Q (Struct Input) P ≡ Q ⇒ new(x:T ); P ≡ new(x:T ); Q	(Struct Res) P ≡ Q ⇒ P | R ≡ Q | R	 (Struct Par) P ≡ Q ⇒ repeat P ≡ repeat Q	 (Struct Repl)
P | stop ≡ P	(Struct Par Zero)
P | Q ≡ Q | P	(Struct Par Comm)
(P | Q) | R ≡ P | (Q | R)	(Struct Par Assoc)
repeat P ≡ P | repeat P	(Struct Repl Par)
new(x:T ); (P | Q) ≡ P | new(x:T ); Q	(Struct Res Par) (where x ∈/ fn(P ))

new(x1:T1); new(x2:T2); P ≡
new(x2:T2); new(x1:T1); P
(Struct Res Res)
(where x1 /= x2, x1 ∈/ fn(T2), x2 ∈/ fn(T1))


There are four actions in this labelled transition system:

begin L
P −−−−→ P
when P reaches a begin L assertion.

P −e−nd−→L
P ' when P reaches an end L assertion.

gen ⟨x⟩
P −−−−→ P
when P generates a new name x.

P →−τ
P ' when P can perform an internal action.

For example:


(new(x:Name); begin ⟨x⟩; end ⟨x⟩; stop)
gen ⟨x⟩
−−−−→ (begin ⟨x⟩; end ⟨x⟩; stop)
begin ⟨x⟩
−−−−−→ (end ⟨x⟩; stop)
end ⟨x⟩
−−−−→ (stop)


Next, we define the syntax of actions α, and their free names and generated names.
Actions:
α, β ::=	actions
begin L	begin-event
end L	end-event
gen ⟨x⟩	name generation
τ	internal

Free names, fn(α), and generated names, gn(α), of an action α:
fn(τ ) = ∅  fn(begin L) = fn(L)	fn(end L) = fn(L)	fn(gen ⟨x⟩) = {x}
gn(τ ) = ∅ gn(begin L) = ∅	gn(end L) = ∅	gn(gen ⟨x⟩ = {x}



The labelled transition system P
−→α
P ' is defined here.

Transitions: P −→α  P '

out x⟨→x⟩ | inp x(→y); P
→−τ
P {→y←→x}	(Trans Comm)

if x = x then P else Q →−τ
if x = y then P else Q →−τ
begin L
(Trans Match)
(Trans Mismatch) (where x /= y)

begin L; P −−−−→ P	(Trans Begin)

end L; P −e−nd−→L
(Trans End)

new(x:T ); P
gen ⟨x⟩
−−−−→ P	(Trans Gen)

P −→α
P ' ⇒ P | Q −→α
P ' | Q	(Trans Par) (where gn(α) ∩ fn(Q)= ∅)

P −→α
P ' ⇒ new(x:T ); P
−→α
new(x:T ); P ' (Trans Res) (where x ∈/ fn(α))

P ≡ P ',P ' −→α
Q', Q' ≡ Q ⇒ P −→α
(Trans ≡)

From this operational semantics, we can define the traces of a process, with
reductions P →−s  P ' where s is a sequence of actions.
Traces:
s, t ::= α1,..., αn	trace

Free names, fn(s), and generated names, gn(s), of a trace s:
fn(α1,..., αn) = fn(α1) ∪· · ·∪ fn(αn)
gn(α1,..., αn) = gn(α1) ∪· · · ∪ gn(αn)

Traced transitions: P −→s  P '

P ≡ P ' ⇒ P →−ε
P '	(Trace ≡)

α	''	''  s	'
α,s	'

P −→ P ,P 
→− P
⇒ P −→ P
(Trace Action) (where fn(α) ∩ gn(s)= ∅)


We require a side-condition on (Trace Action) to ensure that generated names are unique, otherwise we could observe traces such as


gen ⟨x⟩,gen ⟨x⟩
(new(x); new(y); stop) −−−−−−−−→ (stop)

Having formally defined the trace semantics of our π-calculus, we can define when a trace is a correspondence: this is when every end L has a distinct,

matching begin L. For example:
begin L, end L is a correspondence
begin L, end L, end L is not a correspondence
begin L, begin L, end L, end L is a correspondence
We formalize this by counting the number of begin L and end L actions there are in a trace.
Beginnings, begins (α), and endings, ends (α), of an action α:
∆	∆
begins (begin L) = [L]	ends (begin L) = [] 
∆	∆
begins (end L) = []	ends (end L) = [L]
∆	∆
begins (gen ⟨x⟩) = []	ends (gen ⟨x⟩) = [] 
∆	∆
begins (τ ) = []	ends (τ ) = [] 
Beginnings, begins (s), and endings, ends (s), of a trace s:

begins (α1,..., αn) = begins (α1)+ ··· + begins (αn)
ends (α1,..., αn) = ends (α1)+ ··· + ends (αn)

Correspondence:
A trace s is a correspondence if and only if ends (s) ≤ begins (s).
A process is safe if every trace is a correspondence.
Safety:
A process P is safe if and only if for all traces s and processes P '

if P →−s
P ' then s is a correspondence.


A subtlety of this definition of safety is that although we want each end- event of a safe process to be preceded by a distinct, matching begin-event, a trace st may be a correspondence by virtue of a later begin-event in t match- ing an earlier end-event in s. For example, a trace like end L, begin L is a correspondence.
To see why our definition implies that a matching begin-event must precede each end-event in each trace of a safe process, suppose a safe process has a trace s, end L, t. By definition of traces, the process also has the shorter trace s, end L, which must be a correspondence, since it is a trace of a safe process. Therefore, the end-event end L is preceded by a matching begin-event in s.
We can now state the formal result of the paper, Theorem 5.2, that every effect-free process is safe. This gives us a compositional technique for verifying the safety of communications protocols. It follows from a subject reduction result, Theorem 5.1. The most difficult parts of the formal development to check in detail are the parts associated with the (Proc Cond) rule, because of

its use of a substitution applied to an environment.
Theorem 5.1 (Subject Reduction) Suppose E ▶ P : e.

If P →−τ
P ' then E ▶ P ' : e.

If
begin L
P −−−−→ P
then E ▶ P '
: e + [L].

If P −e−nd−→L
P ' then E ▶ P ' : e − [L], and L ∈ e.

If
gen ⟨x⟩
P −−−−→ P
and x ∈/ dom(E) then E, x:T ▶ P '
: e for some type T.

Theorem 5.2 (Safety) If E ▶ P :[] then P is safe.

Related Work
Correspondence assertions are not new; we have already discussed prior work on correspondence assertions for cryptographic protocols [27,17]. A contribu- tion of our work is the idea of directly expressing correspondence assertions by adding annotations to a general concurrent language, in our case the π- calculus.
Gifford and Lucassen introduced type and effect systems [11,16] to man- age side-effects in functional programming. There is a substantial literature. Early work on concurrent languages includes systems by Nielson and Niel- son [19,20] and Talpin [24]. Recent applications of type and effect systems include memory management for high-level [26] and low-level [5] languages, race-condition avoidance [7], and access control [23].
Early type systems for the π-calculus [18,22] focus on regulating the data sent on channels. Subsequent type systems also regulate process behaviour; for example, session types [25,12] regulate pairwise interactions and linear types [15] help avoid deadlocks. A recent paper [6] explicitly proposes a type and effect system for the π-calculus, and the idea of latent effects on channel types. This idea can also be represented in a recent general framework for concurrent type systems [14]. Still, the types of our system are dependent in the sense that they may include the names of channels; to the best of our knowledge, this is the first dependent type system for the π-calculus. Another system of dependent types for a concurrent language is Flanagan and Abadi’s system [7] for avoiding race conditions in the concurrent object calculus of Gordon and Hankin [8].
The rule (Proc Cond) for typing name equality if x = y then P else Q checks P under the assumption that the names x and y are the same; we formalize this by substituting y for x in the type environment and the process
P . Given that names are the only kind of value, this technique is simpler than the standard technique from dependent type theory [21,2] of defining typing judgments with respect to an equivalence relation on values. Honda, Vasconcelos, and Yoshida [13] also use the technique of applying substitutions to environments while type-checking.

Conclusions
The long term objective of this work is to check secrecy and authenticity prop- erties of security protocols by typing. This paper introduces several key ideas in the minimal yet general setting of the π-calculus: the idea of expressing correspondences by begin- and end-annotations, the idea of a dependent type and effect system for proving correspondences, and the idea of using latent effects to type correspondences begun by one process and ended by another. Several examples demonstrate the promise of this system. Unlike a previous approach based on model-checking, type-checking correspondence assertions is not limited to finite-state systems.
A companion paper [9] begins the work of applying these ideas to crypto- graphic protocols as formalized in the spi-calculus of Abadi and Gordon [1], and has already proved useful in identifying known issues in published proto- cols. Our first type system for spi is specific to cryptographic protocols based on symmetric key cryptography. Instead of attaching latent effects to channel types, as in this paper, we attach them to a new type for nonces, to formalize a specific idiom for preventing replay attacks. Another avenue for future work is type inference algorithms.
The type system of the present paper has independent interest. It intro- duces the ideas in a more general setting than the spi-calculus, and shows in principle that correspondence assertions can be type-checked in any of the many programming languages that may be reduced to the π-calculus.
Acknowledgements We had useful discussions with Andrew Kennedy and Naoki Kobayashi. Tony Hoare commented on a draft of this paper. Alan Jeffrey was supported in part by Microsoft Research during some of the time we worked on this paper.

References

M. Abadi and A.D. Gordon. A calculus for cryptographic protocols: The spi calculus. Information and Computation, 148:1–70, 1999.
H. Barendregt. Lambda calculi with types. In S. Abramsky, D.M. Gabbay, and
T.S.E. Maibaum, editors, Handbook of Logic in Computer Science, Volume II. Oxford University Press, 1992.
G. Berry and G. Boudol. The chemical abstract machine. Theoretical Computer Science, 96(1):217–248, April 1992.
E. Clarke and W. Marrero. Using formal methods for analyzing security. Available at http://www.cs.cmu.edu/∼marrero/abstract.html, 2000.
K. Crary, D. Walker, and G. Morrisett. Typed memory management in a calculus of capabilities. In 26th ACM Symposium on Principles of Programming Languages, pages 262–275, 1999.


S. Dal Zilio and A.D. Gordon. Region analysis and a π-calculus with groups. In Mathematical Foundations of Computer Science 2000 (MFCS2000), volume 1893 of Lectures Notes in Computer Science, pages 1–21. Springer, 2000.
C. Flanagan and M. Abadi. Object types against races. In J.C.M. Baeten and
S. Mauw, editors, CONCUR’99: Concurrency Theory, volume 1664 of Lectures Notes in Computer Science, pages 288–303. Springer, 1999.
A.D. Gordon and P.D. Hankin. A concurrent object calculus: Reduction and typing. In Proceedings HLCL’98, ENTCS. Elsevier, 1998.
A.D. Gordon and A. Jeffrey. Authenticity by typing for security protocols. In 14th IEEE Computer Security Foundations Workshop, pages 145–159. IEEE Computer Society Press, 2001. An extended version appears as Microsoft Research Technical Report MSR–TR–2001–49, May 2001.
A.D. Gordon and A. Jeffrey. Typing correspondence assertions for communication protocols. Technical Report MSR–TR–2001–48, Microsoft Research, May 2001.
D.K. Gifford and J.M. Lucassen. Integrating functional and imperative programming. In ACM Conference on Lisp and Functional Programming, pages 28–38, 1986.
K. Honda, V. Vasconcelos, and M. Kubo. Language primitives and type discipline for structured communication-based programming. In European Symposium on Programming, volume 1381 of Lectures Notes in Computer Science, pages 122–128. Springer, 1998.
K. Honda, V. Vasconcelos, and N. Yoshida. Secure information flow as typed process behaviour. In European Symposium on Programming, Lectures Notes in Computer Science. Springer, 2000.
A. Igarashi and N. Kobayashi. A generic type system for the pi calculus. In 28th ACM Symposium on Principles of Programming Languages, pages 128– 141, 2001.
N. Kobayashi. A partially deadlock-free typed process calculus. ACM Transactions on Programming Languages and Systems, 20:436–482, 1998.
J.M. Lucassen. Types and effects, towards the integration of functional and imperative programming. PhD thesis, MIT, 1987. Available as Technical Report MIT/LCS/TR–408, MIT Laboratory for Computer Science.
W. Marrero, E.M. Clarke, and S. Jha. Model checking for security protocols. In DIMACS Workshop on Design and Formal Veriﬁcation of Security Protocols, 1997. Preliminary version appears as Technical Report TR–CMU–CS–97–139, Carnegie Mellon University, May 1997.
R. Milner. Communicating and Mobile Systems: the π-Calculus. Cambridge University Press, 1999.


F. Nielson and H. Riis Nielson. From CML to process algebras. In CONCUR 93—Concurrency Theory, volume 715 of Lectures Notes in Computer Science, pages 493–508. Springer, 1993.
H. Riis Nielson and F. Nielson. Higher-order concurrent programs with finite communication topology. In 21st ACM Symposium on Principles of Programming Languages (POPL’94), pages 84–97, 1994.
B. Nordstr¨om, K. Petersson, and J. Smith. Programming in Martin-Lo¨f ’s Type Theory: An Introduction. Oxford University Press, 1990.
B. Pierce and D. Sangiorgi.	Typing and subtyping for mobile processes.
Mathematical Structures in Computer Science, 6(5):409–454, 1996.
C. Skalka and S. Smith. Static enforcement of security with types. In P. Wadler, editor, 2000 ACM International Conference on Functional Programming, pages 34–45, 2000.
J.-P. Talpin. Aspects th´eoretiques et pratiques de l’inf´erence de types et d’effets. Th´ese de doctorat, Universit´e Paris VI and Ecole des Mines de Paris, May 1993.
K. Takeuchi, K. Honda, and M. Kubo. An interaction-based language and its typing system. In Proceedings 6th European Conference on Parallel Languages and Architecture, volume 817 of Lectures Notes in Computer Science, pages 398–413. Springer, 1994.
M. Tofte and J.-P. Talpin. Region-based memory management. Information and Computation, 132(2):109–176, 1997.
T.Y.C. Woo and S.S. Lam. A semantic model for authentication protocols. In
IEEE Symposium on Security and Privacy, pages 178–194, 1993.
