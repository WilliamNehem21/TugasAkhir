	Electronic Notes in Theoretical Computer Science 199 (2008) 107–128	
www.elsevier.com/locate/entcs

Ensuring the Correctness of Lightweight Tactics for JavaCard Dynamic Logic
Richard Bubel1	Andreas Roth2	Philipp Ru¨mmer3
Institut fu¨r Logik, Komplexita¨t und Deduktionssysteme Universita¨t Karlsruhe, Germany
Department of Computer Science and Engineering Chalmers University of Technology & G¨oteborg University, Sweden

Abstract
The interactive theorem prover developed in the KeY project, which implements a sequent calculus for JavaCard Dynamic Logic (JavaCardDL) is based on taclets. Taclets are lightweight tactics with easy to master syntax and semantics. Adding new taclets to the calculus is quite simple, but poses correctness problems. We present an approach how derived (non-axiomatic) taclets for JavaCardDL can be proven sound in JavaCardDL itself. Together with proof management facilities, our concept allows the safe introduction of new derived taclets while preserving the soundness of the calculus.
Keywords: taclets, lightweight tactics, dynamic logic, theorem proving


Introduction
Background
Taclets are a new approach for constructing powerful interactive theorem provers [4]. First introduced as Schematic Theory Speciﬁc Rules [9], they are an efficient and convenient framework for lightweight tactics. Their most important advantages are the restricted and, thus, easy to master syntax and semantics com- pared to an approach based on meta languages like ML, and their seamless integra- tion with graphical user interfaces of theorem provers which they can be efficiently compiled [7] into.
Taclets contain three kinds of information, the logical content of the rule to be applied, information about side-conditions on their applicability, and pragmatic information for interactive and automatic use. Due to their easy syntax and intuitive

1 Email: bubel@ira.uka.de
2 Email: aroth@ira.uka.de
3 Email: philipp@chalmers.se

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.11.015

operational semantics, a person with some familiarity in formal methods should be able to write own taclets after a short time of study.
The interactive theorem prover developed in the KeY project [5,1] is based on taclets implementing a sequent calculus for JavaCard Dynamic Logic (Java- CardDL) [3]. JavaCard is a subset of Java lacking multi-threading, garbage collec- tion and graphical user interfaces, but with additional features like transactions.
JavaCardDL has around three hundred axiomatic rules, this means taclets that capture the JavaCard semantics. Correctness of rules is crucial since new taclets can be introduced quite easily. The work presented here ensures the correctness of derived taclets for JavaCardDL by providing means to prove them correct relatively to the core set of JavaCardDL axioms (possibly enriched with further axioms for certain theories). The soundness of taclets can be proven in the calculus itself by
showing the validity of an appropriately constructed proof obligation. This report extends the respective approach for classical first-order logic described in [9] to JavaCardDL.

Related Work
Related to our approach are other projects for program verification like Bali [16,17], where consistency and correctness of rules that cover the Java se- mantics are ensured using Isabelle, or the LOOP project [11] where PVS is used as foundation, and the calculus rules are thus obtained as higher order logic theorems. Complementary to the presented approach—ensuring correctness of derived taclets—further work has been carried out in the KeY project in order to cross-
validate selected axiomatic rules against the Java axiomatisation of Bali [13,15,18]
covering assignment rules (esp. for arrays) and KeY’s improved while-invariant rule
as introduced in [6]. Further, [2] describes the automatic verification of an impor- tant subset of the JavaCardDL calculus rules against a Maude rewriting semantics of Java.

Structure of this Paper
In Sect. 1.1 we repeat the most important concepts of classical dynamic logic and JavaCardDL. A formal description of taclets and a definition of the basic vocabulary used throughout the paper is given in Sect. 2. The different steps to be performed
in order to prove the correctness of derived taclets are described in Sect. 3–5. In Sect. 6 we give a justification of the complete procedure as main theorem. Finally, in Sect. 7 we discuss the current and future work to be done.

Dynamic Logic
Classical Dynamic Logics
The family of dynamic logics (DL) [10] belongs to the class of multi-modal logics. As programs are first-class citizens in DL formulas, DL is well-suited for program analysis and reasoning purposes. For the sake of simplicity and as a consequence of



Γ ▶ ⟨ if (ψ) {p; while (ψ) {p} } else {}⟩φ, Δ Γ ▶ ⟨while (ψ) {p}⟩φ, Δ
(1)

Γ,ψ ▶ ⟨p⟩φ, Δ	Γ, ¬ψ ▶ ⟨q⟩φ, Δ Γ ▶ ⟨ if (ψ) {p} else {q}⟩φ, Δ
(2)

Γ ▶ ⟨p⟩⟨q⟩φ, Δ
Γ{x←z}
.	{x←z}
{x←z}

(3)
, x =t 
▶ φ, Δ
(4)

Γ ▶ ⟨p;q⟩φ, Δ	Γ ▶ ⟨x=t⟩φ, Δ

Table 1
DPDL/DQDL Axiomatisation (excerpt). z is a new variable.

using a non-concurrent and real world programming language, we will only consider deterministic programs.
Let p be an arbitrary program and φ a first-order or dynamic logic formula, then
⟨p⟩φ (“diamond p φ”): p terminates and after the execution of p formula φ holds
[p]φ (“box p φ”): if p terminates then after the execution of p formula φ holds
are typical representatives of DL formulas. Deterministic propositional dynamic logic (DPDL) is defined over a signature Σ = (At0, Prg 0, Op), where At0, Prg 0 are enumerable sets of propositional variables and atomic programs (resp.). Besides the classical propositional operators ¬, → the operator set Op contains box [p] and diamond ⟨p⟩ modalities for each program p. The set of formulas is the smallest set defined inductively over At0 and Prg 0:
all classical propositional formulas are formulas in DPDL
if φ, ψ are DPDL formulas then φ → ψ and ¬φ are DPDL formulas
if p ∈ Prg is a program and φ a formula in PDL then ⟨p⟩φ and [p]φ are DPDL formulas
the set Prg of programs is the smallest set satisfying
Prg 0 ⊆ Prg
if p, q ∈ Prg and ψ ∈ DPDL then
‘p;q’ (concatenation), ‘ if (ψ) {p} else {q}’ and ‘while (ψ) {p}’ are programs.
The semantics can be defined in terms of Kripke frames (S, (ρp)p∈Prg ) with a set S of states, and transition relations ρp : S → S which define the semantics of each program p ∈ Prg . The relations ρp have to adhere to certain conditions w.r.t. the program constructors (;, if −else, etc.) from the definition above, for example, program composition ρp;q = ρq ◦ ρp.
An excerpt from an axiom system for DPDL in terms of sequent calculus rules is given in Table 1.
DPDL is useful to reason about program properties induced by the program

constructors. However, as a consequence of constructing programs from atomic programs without any fixed semantics, they lack possibilities to talk about individ- ual programs and, thus, about functional properties.
Like the step from propositional to first-order logic, one extends DPDL to deter- ministic quantified dynamic logics (DQDL). DQDL extends the propositional part to full first-order logic (with equality and a universe D), and on the program side it replaces the atomic programs with assignments of the form v=t, where v is a vari- able and t an arbitrary term. In general, each program state s ∈ S is assigned a first order structure (D, I) and a variable valuation σ : Var → D respecting ρx=t(s)= s' with σ' = σt(D,I),σ .
Again a relatively 4 complete calculus can be given, the corresponding assign- ment rule is shown in Table 1.

Example 1.1 For the universe D	=	N
.	. ∗
.	(close)

of  natural	numbers,	the  DQDL  formula
.
⟨x=3;y=x;⟩y =x can be proven valid with the
rules of Table 1 as shown on the right.
x = 3, y = x ▶ y =x 
  .	.	
x =3 ▶ ⟨y=x;⟩y =x 
	.	 (4)
▶ ⟨x=3;⟩⟨y=x;⟩y =x 
	.	 (3)
▶ ⟨x=3;y=x;⟩y =x 


JavaCardDL
The step from academic languages as described in the previous paragraphs to real world programming languages like JavaCard [8,14] leads to several complications. In the next few paragraphs, we introduce some features of JavaCardDL [3]. First some preliminaries:
Formulas must not occur in JavaCardDL programs, instead Java expressions of type boolean are used as guards.
The set of variables Var = PVar LVar is the disjoint union of program vari- ables PVar and logical variables LVar. In contrast to logical variables, program variables can occur in programs as well as in formulas, but cannot be bound by
.
quantifiers. For instance, let x ∈ LVar and o, u ∈ PVar, then ∀x.⟨o=u;⟩x =u is a
well-formed JavaCardDL formula, whereas ∀x.⟨o=x;⟩x =. u is not.
All states have the same universe D, and predicates are assumed to have the same meaning in all states (they are rigid ).
A sequent calculus covering JavaCard has to cope with aliasing, side-effects, abrupt termination as result of thrown exceptions, breaks, continues or returns and more. The KeY approach follows the symbolic execution paradigm, thus a majority of the calculus rules realises a JavaCard interpreter reducing expressions
and statements stepwise to side-effect free assignments.
Example 1.2 An easy-to-use decomposition rule similar to (3) is not available in
JavaCardDL due to abrupt termination. For example
.
▶ ⟨l :{ if (v == 0) { break l; } else { v = 0; } v = 3;} ⟩v =3 

4 Usually DQDL is interpreted in an arithmetic structure.

cannot be decomposed to
.
▶ ⟨l :{ if (v == 0) { break l; } else { v = 0; } }⟩⟨v = 3⟩v = 3,

as this is obviously not equivalent for v= 0.
Decomposition was essential for DPDL and DQDL in order to reduce the com- plexity of programs stepwise to atomic programs or assignments, which can be handled by calculus rules without the need of a dedicated rule for each program.
JavaCardDL therefore introduces the notion of a ﬁrst active statement to which
a rule applies, and a program context ‘ .. ◦1 ...’ whose inactive prefix ‘ .. ’ matches
on all preceding labels, opening braces or try blocks. Consider the following rule:
.	.

#b = true ▶ ⟨ .. {#sta1} ...⟩φ	#b = false ▶ ⟨ .. {#sta2} ...⟩φ
▶ ⟨ .. if (#b) {#sta1} else {#sta2} ...⟩φ
(5)

where #b is a side-effect free boolean expression and #sta1, #sta2 are arbitrary
JavaCard statements.
Example 1.3 (Example 1.2 continued) Applying rule (5) to
.
▶ ⟨l :{ if (v == 0) { break l; } else { v = 0; } v = 3;}⟩v=3

where ◦1 corresponds to the program between ‘ l :{’ (inactive program preﬁx) and ‘v = 3;}’ (suffix of the program context) now yields the two sequents
.	.
(v==0) = true ▶ ⟨l :{ { break l; } v = 3; }⟩v=3 and
.	.
(v==0) = false ▶ ⟨l :{ { v = 0; } v = 3; }⟩v=3

Taclets
Taclets are lightweight, stand-alone tactics with simple syntax and semantics. Their introduction was motivated by the observation that only few basic actions in proof construction are sufficient to implement most rules for first-order modal logic. These are:
to recognise sequents as an axiom, and to close the according proof branch,
to modify at most one formula per rule application,
to add a finite (and fixed) number of formulas to a sequent,
to let a proof goal split in a fixed number of branches,
to restrict the applicability according to context information.
These are the only actions which taclet constructs are provided for. This restriction turns out to reduce the complexity for users of a proof system significantly [4].

Taclets by Example
Taclets describe rule schemas in a concise and readable way. A simple example rewrites terms 1 + 1 with 2. In taclet notation such a rule schema is written as:
find(1 + 1) replacewith(2)
In a taclet—in addition to the logical content of the described rule—an opera- tional meaning is encoded: If a user of a taclet-based prover selects the term of the find-part (i.e. 1+ 1) of a taclet and chooses the taclet for application, the find-part is replaced with (an instantiation of) the replacewith-term (i.e. 2).
In this simple form, the rule schemas described by taclets are not expressive enough for practical use; schema variables and more constructs besides find and replacewith make them powerful enough to fulfil the requirements posed above.

Schema Variables and Instantiations
Expressions 5 in taclets may contain elements from a set SV of schema variables. An instantiation ι(v) of a schema variable v ∈ SV is a concrete expression that must fulfil certain conditions depending on the kind of the schema variable (see below). We may, e.g., define a schema variable i such that ι(i) must be a term of an integer sort.
Expressions e in taclets containing schema variables from SV are called schematic expressions over SV . The instantiation map ι can canonically be ex- tended to schematic expressions:

ι(op(e ,... ,e )) = ⎧⎨ ι(op)	if n =0 and op ∈ SV

(6)

1	n
op(ι(e1),... , ι(en))  otherwise
Thus, e describes a set of concrete expressions:
{ι(e) | ι is an instantiation map for every v ∈ SV }
For instance, a taclet find(i + i) replacewith(2 ∗ i) contains schematic terms over
{i}. Applied on a sequent containing the term 3 + 3, i is instantiated with ι(i)= 3 and the taclet replaces ι(i + i)=3 + 3 with ι(2 ∗ i)= 2 ∗ 3 in the new goal.

Taclet Syntax
The clause replacewith(2) is an example of a goal template, this means the description of how a goal changes by applying the taclet. More than one goal template may be part of a taclet, separated by semicolons, which describes that a goal is split by the taclet. If there is no goal template in a taclet, applications close the proof branch. Additionally, goal templates may contain the following clauses:

5 By expression we denote syntactic elements like terms or formulas, but in the context of JavaCardDL
also Java programs.

While in the example taclets above the find- and replacewith-parts consisted of terms, they can also be sequents. All find- and replacewith-parts of a taclet must either be terms or sequents. These sequents indicate that the described expression must be a top-level formula in either the antecedent or succedent, e.g. a taclet find( ▶ φ → ψ) replacewith(φ ▶ ψ) (over the schema variables {φ, ψ}) is applicable only to top-level formulas in the succedent. A sequent in the find-part must have either an empty antecedent or succedent.
Taclet applications can add formulas to the antecedent or succedent.  This is denoted by the keyword add followed by a schematic sequent (similarly to replacewith).
Taclets support the dynamic enlargement of the taclet rule base by adding new taclets using the keyword addrules. We omit this feature in the present paper, although a treatment similar to what is shown here is possible.
Often, more requirements on the sequents that a taclet should be applicable to is needed. Such side conditions are described by the following optional taclet con- stituents:
A taclet that contains an if followed by a schematic sequent context is only directly applicable if context is a “sub-sequent” of the sequent the taclet is applied to. If this is not the case, the taclet is however still applicable but, by an automatic cut, it is required to show the if-condition.
Predefined clauses in a varcond-part describe conditions on the instantiations of schema variables. The most important ones are:
v not free in s, which disallows logical variables ι(v) to occur unbound in
ι(s).
v new depending on s, which introduces a new skolem symbol ι(v) (possibly depending on free “meta variables” occurring in ι(s)).
The complete syntax of taclets is reiterated here as an overview:


[if (context)] [find (f )] [varcond (c1,. .. ,ck)] [replacewith (rw1)] [add (add1)];

(7)

.	.
[replacewith (rwn)] [add (addn)]
For i = 1 ... n, context and addi stand for a schematic sequent, f and rwi for a schematic term, formula, or sequent but all of the same kind. c1,... , ck are variable conditions.
Additionally—though out of scope of this paper—taclets can be assigned to one or several rule sets, which makes them available to be automatically executed by strategies. For a homogenous treatment in this paper f and rwi are declared to be never empty: we assume that skipping replacewith is a shorthand for rwi = f , a skipped find means f = ▶ false, and false always occurs in succedents of sequents.

A skipped if- or add-part means context = ▶ or addi = ▶ (resp.).

Schema Variable Types
While the above definitions have been general enough to be applied to every first- order modal logic, we are now focusing on special schema variables for JavaCardDL. Let SVtac denote the schema variables contained in a taclet tac. Schema variables v ∈ SVtac are assigned to one out of a predefined list of types, each having special
properties concerning admissible instantiations ι(v). An instrument to define these properties is to introduce preﬁx sets (denoted by Πl(v), Πpv(v), and Πjmp(v)) for schema variables v. A selection of the most relevant schema variable types is given below. If v is of type
Variable, then v is assigned a sort, ι(v) must be of that sort. Moreover, ι(v) must be a logical variable. For v /= v' ∈ SV : if v' is a Variable schema variable then ι(v) /= ι(v'). ι(v) must not occur bound in ι(v'') for all v'' ∈ SV .
Term, then v is assigned a sort, ι(v) must be of that sort.
v is assigned a set Πl(v) ⊆ SV of schema variables. Πl(v) is defined to be the smallest set with, for all constituents of tac, if v occurs in the scope of a Variable schema variable v' ∈ SV then v' ∈ Πl(v) except there is a variable condition v' not free in v declared in t. v is assigned a set Πpv(v) which is the smallest set of program variables that occur but are not declared in tac or are declared above 6 every occurrence of v.
We require from instantiations ι: If, for some v' ∈ SVtac, ι(v') is a logical variable that occurs unbound in ι(v) then v' ∈ Πl(v); if ι(v') is a program variable that occurs undeclared in ι(v) then v' ∈ Πpv(v).
Formula, then as for Term, v is assigned Πl(v) and Πpv(v). v must fulfil the same conditions concerning these sets.
Statement, then ι(v) is a JavaCard statement. Again, v is assigned Πpv(v) and it must satisfy the same conditions as above concerning this set.
v is assigned a set Πjmp(v) consisting of JavaCard statements break, continue,
break l, continue l for all labels l, if v is enclosed with a suitable jump target. If jst is a break or continue statement of ι(v) with a target not in ι(v) then jst ∈ Πjmp(v). 7 Usually Statement schema variables have names starting with #
to distinguish them from regular Java elements.
ProgramVariable, then ι(v) is a local program variable or class attribute of Java. v is assigned a Java type and ι(v) must be of that type. Again, names of this kind of variable start with #.
ProgramContext, then ι(v) is a program transformation 8 pt that takes a Java program element α and delivers a new program element pt(α), such that pt(α) is a sequence of statements of which the first one contains α and has only opening

6 If we consider tac as abstract syntax tree.
7 For a complete treatment of JavaCardDL it is furthermore necessary to consider return-statements, which are left out in this paper
8 Thus being an exception from the statement above that ι(v) must be an expression.

braces, opening try blocks, etc., in front. For this case, the continuation of the instantiation map (6) is then modified to
ι(op(e1,... , en)) := pt(ι(e1)) if n =1 and op is a ProgramContext schema variable.
Usually, v is denoted by .. e1 ... containing the schematic Java program e1,
as introduced in Sect. 1.1.
Example 2.1 The following taclet performs a cut with the condition that the fo- cused term (t) equals 0 and replaces it in the respective goal by 0. We declare t as Term schema variable of an integer sort.


find(t)	replacewith(0)
.
add(t =0 ▶ );
.

(8)

replacewith(t)	add( ▶ t = 0)
As an example that represents a rule of JavaCardDL, we take a taclet that re- places the postﬁx increment operator applied to a program variable (x) behind a statement (#sta) with an equivalent statement using assignment and the + opera- tor, and leaves the formula (φ) behind the diamond unchanged. #sta is a Statement schema variable and φ a Formula schema variable.
find(⟨#sta x++;⟩φ)	replacewith(⟨#sta x=x+1;⟩φ)	(9)
Finally, the following taclet splits a proof for an if statement with the condition x==0 (where x is a concrete local variable) and produces goals, reducing the formula to the statements of the appropriate branch and the if condition put to the correct side of the sequent. #sta1 and #sta2 are Statement schema variables and φ is a Formula schema variable.
find(⟨l: if (x==0) #sta1 else #sta2⟩φ)

replacewith(⟨l: #sta1 ⟩φ)
replacewith(⟨l: #sta2 ⟩φ)
.
add(x =0 ▶ );
.
add( ▶ x = 0)
(10)


Semantics
Taclets have a precise operational semantics, which is described in detail in [4], and which we have sketched informally above. For the purposes of this paper it is sufficient to fix the logical meaning of a taclet in the traditional rule schema notation.
We denote the union of two sequents and the subset relation between two se- quents as follows:
 Γ1 ▶Δ1 ∪ Γ2 ▶Δ2 := Γ1, Γ2 ▶Δ1, Δ2
 Γ1 ▶Δ1 ⊆ Γ2 ▶Δ2 iff Γ1 ⊆ Γ2 and Δ1 ⊆ Δ2

First, we assume that f is a schematic sequent, i.e. the taclet tac can only be applied to top-level formulas. By the operational semantics of taclets [4], tac represents the rule schema:
rw1 ∪ add1 ∪ (Γ ▶Δ)	...	rwk ∪ addk ∪ (Γ ▶Δ)
f ∪ (Γ ▶Δ)	(11)
where Γ ▶Δ is an arbitrary sequent with context ⊆ f ∪ (Γ ▶Δ).
Similarly, if f is a schematic term or formula (seq[e] denotes a sequent with an arbitrary but for a rule fixed occurrence of an expression e):
seq[rw1] ∪ add1 ∪ (Γ ▶Δ)	...	seq[rwk] ∪ addk ∪ (Γ ▶Δ)
seq[f ] ∪ (Γ ▶Δ)
where Γ ▶Δ is an arbitrary sequent with context ⊆ seq[f ] ∪ (Γ ▶Δ).
In Sect. 4, the notion of meaning formulas is derived that makes the meaning of these rule schemas induced by taclets more precise.
Due to their simplicity and operational meaning, taclets can be schematically compiled into the GUI of taclet-based interactive theorem provers: In the KeY system a mouse click over an expression displays only those taclets whose find-part can be matched with the expression in focus. This drastically reduces the cognitive burden on the user. For an extensive account on user interaction see [4].

Outline of Bootstrapping Taclets
After having introduced basic notions and notations, we can focus on the task of how to ensure correctness of derived taclets. We aim to prove their soundness within the JavaCardDL calculus itself. Our approach is based on [9] which has already
provided this kind of bootstrapping for classical first-order logic.
Given a taclet tac, we first derivea meaning formula M (tac) (see Sect. 4), which is supposed to be valid if and only if all possible applications of tac are correct proof steps. For example, consider the following taclet tac0:
find(true ∧ φ ▶ )	replacewith(φ ▶)
with a Formula schema variable φ. The corresponding meaning formula is
M (tac0)= ¬φ → ¬(true ∧ φ)	or equivalently	(true ∧ φ) → φ

Intuitively, the meaning formula states that if a formula in an antecedent is replaced, the new formula must be at most as strong as the old one. If this can be proven for all instantiations of φ, i.e. for all formulas, then obviously tac0 is sound. Unfortunately, meaning formulas contain schema variables (here: φ) and are
thus no JavaCardDL formulas. Moreover, we have to quantify somehow over all
formulas. Skolemisation of schema variables (see Sect. 5) helps us, however, not

having to leave our original logic and not having to employ higher order logics on the object level. Skolemisation of meaning formula M (tac0) leads to
MSk(tac0)= (true ∧ φSk) → φSk,

where φSk is a new nullary predicate. We call these formulas MSk(tac) taclet proof obligations. MSk(tac) is a JavaCardDL formula (with a slightly extended vocabu- lary) and can be loaded into our interactive theorem prover. If the proof obligation
can be proven successfully then correctness of the taclet is ensured for all possible applications according to the definition of the meaning formula. The proof of the corresponding theorem is given in [12] and sketched in Sect. 6.
On a semantic level, this theorem can be justified by arguing that if an ap- plication of the taclet tac leads to an incorrect proof, a suitable interpretation D can be constructed such that the meaning formula M (tac) is not satisfied under D (which is a direct consequence of the definition of meaning formulas) and thus M (tac) could not have been proven. This semantic argumentation works fine for
first-order logics [9], but when JavaCardDL comes into play, the complete complex
JavaCard semantics would have to be incorporated in the reasoning.
Instead, we take a syntactic approach getting the JavaCard semantics via the JavaCardDL calculus for free. The basic idea is to show that an application of a taclet tac can always be replaced by a transformed proof of MSk(tac).

Meaning Formulas of Taclets
The basis for our reasoning about the correctness of taclets is a meaning formula [9] derived in this section. It is declared to be the meaning of a taclet independently from concrete taclet application mechanisms, thus providing a very flexible way to address soundness issues. In fact we define a taclet application mechanism to be correct if (and only if) taclets with valid meaning formulas are translated into sound rules. 9 To show that a taclet is correct it is thus sufficient to prove the validity of its meaning formula.
For the whole section we define (Γ ▶Δ)∗ :=  Γ →  Δ, in particular ( ▶ φ)∗ = φ and (φ ▶)∗ = ¬φ. Furthermore, in this section by the validity of a sequent we mean the validity of (Γ ▶Δ)∗. We define a (sequent) calculus C to be sound if only valid sequents are derivable in C. We conceive rules
P1	.. .	Pn Q

as relations between tuples of sequents (the premisses) and single sequents (the conclusion) and define that a rule R ∈ C is sound if for all tuples (⟨P1,... , Pk⟩, Q) ∈ R:
if P1,... , Pk are valid, then Q is valid.	(12)

9 As a schematic formula, the meaning formula is by definition valid iff all instances of the formula are valid.

For the calculus C we can state:
Lemma 4.1 C is sound if all rules R ∈ C are sound.
The rules Rtac we are interested in are defined through taclets tac over a set SV of schema variables in the form as defined in (7). Assuming first that the find- part is a sequent, taclets induce the rule schema (11). To apply Lem. 4.1, for each instantiation ι of SV , (12) must be shown for k = n, Pi = ι(rwi ∪ addi ∪ Γ ▶ Δ) (i = 1 ... n), and Q = ι(f ∪ Γ ▶ Δ). Since the formulas of Γ ▶ Δ which are not in context are arbitrary and not influenced by the rule application we can simply omit them and show the lemma for Pi = ι(rwi ∪ addi ∪ context ) (i = 1 ... n) and Q = ι(f ∪ context ). We assume that tac does not introduce skolem functions,
i.e. does not contain such a variable condition. Then by the deduction theorem, the global condition (12) can be strengthened to the local implication, namely that
P ∗ ∧ ... ∧ P ∗ → Q∗ must be valid.
n
Since ι, as defined by (6), treats propositional junctors as a homomorphism
and the operator (·)∗ is a homomorphism regarding the union of sequents up to propositional transformations, this formula can now be simplified as follows:

n
i=1
n
= ι  (rw∗ ∨ add∗) → (f ∗ ∨ context ∗) .	(14)

If (14) is proven for all instantiations ι, then the rule Rtac represented by tac is sound.
In the next definition our previously made assumptions are revoked: the variable condition svi new depending on... introduces new skolem functions. If P1,... , Pn contain skolem symbols that do not occur in Q, the interpretation of the symbols can be regarded as universally quantified in (12) by the usual definition of ‘valid’. Because of their negation in (13), they are existentially bound in the meaning for- mula. Moreover, taclets that have terms or formulas instead of sequents as find-part and replacewith-parts are reduced to a rule that adds an equivalence f ↔ rwi or equation f = rwi to the antecedent.
Definition 4.2 (Meaning Formula) Each taclet tac, as declared in (7), is as- signed an unquantified meaning formula tac∗, which is deﬁned by:

⎧⎪  n

(rw∗ ∨ add∗) → (f ∗ ∨ context ∗)	if f is a sequent

tac∗ :=
i=1	i	i
⎨  n	.	i	∗	∗

⎪⎪⎩  n
 (f ↔ rwi) → add∗ → context ∗	if f is a formula

Suppose sv1,... , svk ∈ SVtac are all schema variables, which tac contains a variable condition svi new depending on... for. M (tac) := ∃x1 ... ∃xk.φ is deﬁned to be the meaning formula of tac where φ is obtained from tac∗ by replacing each svi with

a new Variable schema variable xi with the same sort as svi.
Example 4.3 (Example 2.1 continued) The taclets tac1, tac2, and tac3 deﬁned through (8), (9), and (10), resp., have (after applying some propositional equivalence transformations) the following meaning formulas:
.	.	.	.
1


M (tac3)=  (⟨l: if (x==0) #sta1 else #sta2⟩φ ↔ ⟨l: #sta1 ⟩φ)
(17)

∧ x =0 
∨ (⟨l: if (x==0) #sta1 else #sta2⟩φ ↔ ⟨l: #sta2 ⟩φ)
.


Construction of Proof Obligations
Except for trivial taclets, the meaning formula M (tac ) of a taclet tac contains schema variables, which is at least inconvenient for proving M (tac ). Variables of these types, however, do not occur bound within the formula (resp., when consid- ering validity, they can be regarded as implicitly universally quantified), and hence it is possible to replace them in a suitable way without altering the validity of the meaning formula:
Schema variables for logical variables or program variables can simply be replaced with new concrete variables. It has to be taken in account, however, that when instantiating a schematic expression it is possible that two different schema vari- ables of type ProgramVariable are instantiated with the same concrete variable (which is not possible for Variable schema variables by the definitions of Sect. 2). By the presence or absence of such collisions, the set of instances of a schematic expression is divided into (finitely many) classes, which all have to be considered to capture the meaning of the schematic expression.
Schema variables for terms, formulas or Java statements can be replaced with suitable “skolem” symbols, which are similar to the atomic programs of DPDL for Statement schema variables. To model the notion of abrupt termination, which does not exist in DPDL, tuples of Java jump statements are attached to occurrences of symbols for statements.
Schema variables for program contexts can be replaced with a surrogate Java
block containing atomic programs.
From now on, we only consider the replacement of schema variables for logical variables, terms, formulas and statements, and we also assume that the concerned taclets only contain schema variables of these kinds. Other kinds of schema variables are treated in a similar way in [12].

Skolem symbols
We define two syntactic domains that consist of symbols for the skolemisation of schema variables:
Symbols that are placeholders for terms and formulas, and which are similar to ordinary function and predicate symbols
Symbols that are placeholders for Java statements, similar to the atomic programs of DPDL.
As usual, the elements of both domains are assigned signatures that determine syntactically well-formed expressions. Their shape is described in more detail as follows.

Skolem Symbols for Terms and Formulas
The sets of symbols for terms and formulas are denoted with FuncSk and PredSk
(resp.). The signature


α(sSk
)=	(S, S1,... , Sn, T1,... , Tk)	for sSk ∈ FuncSk
(S1,... , Sn, T1,... , Tk)	for sSk ∈ PredSk

of a symbol sSk ∈ FuncSk ∪ PredSk consists of
a result sort S, if sSk ∈ FuncSk,
a finite sequence S1,... , Sn of sorts that determines the number and kinds of term arguments; this sequence corresponds to the signature of ordinary predicate symbols,
a finite sequence T1,... , Tk of Java types, which are the component types of a tuple of program variables that sSk is applied to.
Accordingly, the inductive definition of well-formed terms and formulas is extended by:
If sSk ∈ FuncSk ∪ PredSk is a symbol with the signature α(sSk) as above, t1,... , tn are terms of the sorts S1,... , Sn and pv1,... , pvk ∈ PVar are program variables of the types T1,... , Tk, then
sSk(t1,... , tn; pv1,... , pvk ) is a term of sort S or a formula (resp.).
Skolem Symbols for Statements
The set of skolem symbols used for statements is denoted with StatementSk. The signature α(stSk)= (T1,... , Tk, m) of a symbol stSk ∈ StatementSk consists of
a finite sequence T1,... , Tk of Java types (analogously to the symbols for terms or formulas),

a natural number m that gives the size of the jump table; this is a tuple of Java
statements that are arguments of occurrences of stSk within programs.
The symbols StatementSk extend the definition of well-formed Java programs, i.e. the following (informal) rule is added to the Java grammar [8]:
Given stSk ∈ StatementSk of signature α(stSk) = (T1,... , Tk, m), program vari- ables pv1,... , pvk of the types T1,... , Tk and let jst 1,... , jst m be Java statements of the following kinds 10
return-statements, with or without an argument (a plain program variable).
break- and continue-statements, with or without a label.
throw-statements whose argument is a program variable. Then


is a statement.
stSk(pv1,... , pvk ; jst 1; ... ; jst m)

From Meaning Formula to Proof Obligation
From now on we suppose that a taclet tac with meaning formula M (tac ) is fixed. Let SVtac be the set of schema variables that M (tac ) contains. We define an instan- tiation ιSk over SVtac that replaces each schema variable either with a JavaCardDL
variable or with an appropriate skolem expression. The definition refers to the
properties of schema variables as introduced in Sect. 2:
If x ∈ SVtac is of type Variable, then ιSk(x) ∈ LVar is a new logical variable that has the same sort as x.
If sv ∈ SVtac is of type Term, Formula or Statement, then let {pv1,... , pvk } = Πpv(sv) be the program variables that can occur undeclared in instantiations of sv. Let T1,... , Tk be the Java types of pv1,... , pvk .
If sv ∈ SVtac is of type Term, then
ιSk(sv)= fSk(v1,... , vl; pv1,... , pvk )
is a term, where
v1,... , vl with vi = ιSk(xi) are the instantiations of x1,... , xl ∈ SVtac, which are distinct Variable schema variables determined by the prefix Πl(sv)= {x1,... , xl} of sv in tac
and fSk ∈ FuncSk denotes a new skolem symbol with signature
α(fSk)= (S, S1,... , Sl, T1,... , Tk)
where S is the sort of sv and S1,... , Sl are the sorts of v1,... , vl.
Analogously, if sv ∈ SVtac is a schema variable of type Formula, then
ιSk(sv)= pSk(v1,... , vl; pv1,... , pvk)

10 Which are exactly the reasons that can lead to an abrupt termination of a statement, see [8].

is a formula containing a new skolem symbol pSk ∈ PredSk for formulas.
If sv ∈ SVtac is a schema variable of type Statement, then two additional (and new) program variables are needed: tsv of Java type Throwable, and dsv of Java type int (the latter variable is used in Sect. 5.3). Let {jst 1,... , jst m} = Πjmp(sv) be jump statements that can occur uncaught in instantiations of sv.
The instantiation ιSk(sv) of sv is the statement 11
ιSk(sv)= stSk(pv1,... , pvk, tsv, dsv; jst 1; ... ; jst m; throw tsv)
where stSk denotes a new skolem symbol for statements with signature
α(stSk)= (T1,... , Tk,m + 1).
Finally, the taclet proof obligation of tac is defined to be the formula
MSk(tac ) := ιSk(M (tac ))
Example 5.1 (Example 4.3 continued) The proof obligations listed below can be constructed from the meaning formulas of taclets tac1, tac2 and tac3:

MSk(tac1)=  tSk .	Sk .
 Sk .
Sk ∧ ¬(tSk .
	(18)

MSk(tac2) =	(19)
⟨staSk(v, t#sta, d#sta; throw t#sta); v++;⟩pSk(v) ↔
(20)
⟨staSk(v, t#sta, d#sta; throw t#sta); v=v+1;⟩pSk(v)
MSk(tac3) =	(21)

 (⟨l: if (x==0) β1
Sk
.
Sk

 (⟨l: if (x==0) β1
else β ⟩p
Sk
(x) ↔ ⟨l: β ⟩p
Sk
(x)) ∧ x =0 ∨
.	 
(22)

where we use the abbreviations
β1 = sta1Sk(x, t#sta1, d#sta1; break l; throw t#sta1);
β2 = sta2Sk(x, t#sta2, d#sta2; break l; throw t#sta2);

Decomposition Rules
Calculus rules for JavaCardDL programs always modify the leading statements within a program block (see Sect. 1). Unfortunately, the addition of skolem symbols for statements would destroy the (relative) completeness of a set of rules: If a skolem symbol turns up as the first active statement of a program block, no JavaCardDL
rule will be applicable to that block.
As we have stated in Sect. 1.1 that a “naive” decomposition rule for JavaCardDL cannot be posed due to abrupt termination, we define a family of decomposition

11 We always add a throw-statement, as instantiations of sv may always terminate abruptly through an exception regardless of Πjmp(sv).

rules specifically for statement skolem symbols. These rules cope with abrupt ter- mination by applying a transformation to the statement α = stSk(.. .). This trans-

formation splits α in two parts α1 = st'
(.. .) and α2, such that the concatenation

α1; α2 is equivalent to the original statement α. Furthermore, the first program fragment α1 is constructed in a way that prevents abrupt termination, and thus, the equivalence


⟨.. stSk(.. .); β ...⟩φ ↔ ⟨st'
(.. .)⟩⟨.. α2; β ...⟩φ	(23)

holds. The remaining statement α2 does no longer contain any skolem symbols,
i.e. it is a pure JavaCard program, and hence it is possible to handle α2 by the application of regular JavaCardDL rules.
We assume that for each statement skolem symbol stSk ∈ StatementSk that occurs within ιSk a second new skolem symbol Dec(stSk) is introduced, which has the same signature as stSk except for the jump table:
α(stSk)= (T1,... , Tk, m)	=⇒	α(Dec(stSk)) = (T1,... , Tk, 0).


Following equivalence (23), two decomposition taclets Do
and D▢
Sk
for dia-

mond and box modalities (resp.) are introduced for each statement skolem sym-

bol stSk that occurs in ιSk. We only give the definition of Do
, as the taclet for

boxes is obtained analogously:


o
stSk
:	{	find ( ⟨.. stSk(p1,... , pk; #jst1; ... ; #jstm); ...⟩φ )
replacewith ( ⟨Dec(stSk)(p1,... , pk);⟩⟨.. ic ...⟩φ ) }


where p1,... , pk are schema variables for program variables, #jst1,... , #jstm are variables for statements corresponding to the signature α(stSk) and φ is a schema variable for formulas. Furthermore the taclet contains an if-cascade ic, which is denoted by α2 in equivalence (23):
{	if  ( pk == 1 ) #jst1
else  i f  ( pk == 2 )	... 
else  i f  ( pk == m ) #jstm  }
In this statement at most one of the jump statements represented by the schema variables #jst1,... , #jstm is selected and executed, depending on the value of the last program variable argument pk (note that the type of pk is int by the definitions of the last section).
Example 5.2 An application of the decomposition rule for diamond modalities could look as follows:
▶ ⟨st'  (t, d)⟩⟨try { if  (d == 1) throw t; } catch (Exception e) {...}⟩φ
	Sk	
▶ ⟨try { stSk(t, d; throw t); } catch (Exception  e) {...}⟩φ

Main Result
To show that tac is derivable, which is by Sect. 4 equivalent to the derivability of all instances of M (tac ), we assume that there is a closed proof H of MSk(tac ) using the sequent calculus for JavaCardDL (extended by the skolem symbols and
the decomposition taclets of Sect. 5). It is possible to transform H into a proof Hφ
for each instance φ of M (tac ):
Theorem 6.1 (Main Result) Suppose that a proof H of MSk(tac ) exists. Then for each instance φ = κ(M (tac )) of the meaning formula M (tac ) there is a proof Hφ.
In the following we will sketch a proof of Theorem 6.1. Due to lack of space we skip most of the details of the proof; a more detailed account can be found in [12].
The proof obligation MSk(tac ) = ιSk(M (tac )) differs from other instances φ = κ(M (tac )) of the meaning formula in the instantiation of schema variables for terms, formulas and statements: In MSk(tac ) such variables are replaced with skolem symbols as introduced in Sect. 5.1. 12 Hence it is possible to obtain a “proof” H' of φ by replacing each occurrence of a skolem symbol sSk(.. .)= ιSk(sv) in H with the instantiation κ(sv) from φ. In general, the tree H' cannot be expected to be a proof, as it is possible that the replacement of skolem symbols leads to in- valid rule applications. But by a slightly more complex transformation, as sketched below, it is possible to obtain a legal proof:

For the replacement of skolem symbols we define an appropriate kind of substi- tutions: We assume that a mapping σ of the skolem symbols
SymSk := FuncSk ∪ PredSk ∪ StatementSk
to terms, formulas and Java statements “with holes” is given. Namely, we al- low that for a symbol sSk with signature α(sSk) = ([S, ]S1,... , Sn, T1,... , Tk) (or α(sSk)= (T1,... , Tk, m) for statement symbols), the value σ(sSk) containsa number
of holes ◦i labelled with natural numbers i ∈ {1,... ,n + k} (or i ∈ {1,... ,k + m}, resp.).
Example 6.2 For a predicate skolem symbol pSk ∈ PredSk, an example of a substi- tution is given by the following mapping:
σ(pSk)= r(◦2, a) ∧ q(◦1) ∧ ⟨◦2=1;⟩φ	for pSk ∈ PredSk,  α(pSk)= (S, int).
The mapping σ is extended to terms, formulas, Java programs, sequents, proof trees and taclets as a morphism, and by the replacement of skolem symbols. Holes are replaced with the arguments of occurrences of skolem symbols: 13
σ(sSk(r1,... , rl)) := {◦1/r1,... , ◦l/rl} σ(sSk) 

12 Schema variables for logical variables are in both cases simply instantiated with logical variables.
13 Extensive considerations about possible collisions are omitted in this document; see [12] for details.

Example 6.3 (Example 6.2 continued) The mapping σ is applied in the fol- lowing way to a formula containing the symbol pSk:
σ ∀x.pSk(x; i) = ∀x. r(i, a) ∧ q(x) ∧ ⟨i=1;⟩σ(φ) 

Treatment of Taclets
The most important observation to prove Theorem 6.1 is the following lemma:
Lemma 6.4 (Lifting of Taclet Applications) Suppose that Rtac'  is a rule schema that is described by a taclet tac', and that tac' does not contain skolem symbols (as introduced in Sect. 5.1). If an instance of Rtac' is given by
P1	·· ·	Pn
Q

and σ is a substitution of skolem symbols, then there is a proof tree with root se- quent σ(Q), whose open goals are exactly the sequents σ(P1),... , σ(Pn).
Proof. First suppose that the considered rule application is not the application of a rewrite taclet within an argument of a skolem symbol occurrence. Then it can be shown that
σ(P1)	···	σ(Pn)
σ(Q)
is an instance of Rtac' .
Otherwise, if a rewrite taclet is applied to a term t within an argument of a skolem symbol occurrence, it is possible that a single occurrence of t in Q produces more than one occurrence of σ(t) in σ(Q) (like in example 6.3, where a single occur- rence of the program variable i in the original formula yields multiple occurrences after the application of σ). Provided that the cut-rule and rules treating equations
.
are available, it is then possible to perform a cut with the equation σ(t) = σ(t) and

apply tac'
.
to one side of the equation. Afterwards the equations σ(t) = σ(ti) can

be used to replace all occurrences of σ(t) successively. This is illustrated by the following proof tree fragment, in which we use the notation (Γ ▶Δ) = σ(Q):


σ(P1)
.
σ(Pn )
.

. .	. .

Γ1, σ(t) = σ(t1) ▶ Δ1	·· ·
.
Γn, σ(t) = σ(tn ) ▶ Δn
tac'	∗	.

Γ, σ(t) = σ(t) ▶ Δ
Γ ▶ Δ
Γ ▶ Δ, σ(t) = σ(t)



Corollary 6.5 Suppose that the proof H of MSk(tac ) = ιSk(M (tac )) only con- sists of applications of taclets tac', and that the concerned taclets tac' do not con- tain skolem symbols. Then for each instance φ = κ(M (tac )) of the meaning for- mula M (tac ) there is a proof Hφ.

Proof. W.l.o.g. we may assume that ιSk and κ are equal w.r.t. the instantiations of schema variables of type Variable. Each taclet application within H can then be replaced with the proof tree fragment that is obtained from Lem. 6.4, for a σ that substitutes skolem expressions sSk(.. .) = ιSk(sv) with the concrete instantia- tion κ(sv), i.e. in a way such that σ(MSk(tac )) = φ.	 

Treatment of Decomposition Rules
Lem. 6.4 of the last section is not directly applicable to applications of the

taclets Do
▢
sSk
(Sect. 5.3), as these taclets contain statement skolem symbols sSk

and Dec(sSk). If these symbols are replaced with arbitrary Java statements by the
application of a substitution σ (as introduced in the previous section), then the
obtained taclet will furthermore be unsound in general.
We circumvent these problems by constructing particular substitutions σ of the

symbols sSk and Dec(sSk) with the property that σ(Do
), σ(D▢
) are sound taclets,

so that subsequently Lem. 6.4 can be applied for obtaining a proof tree.
Lemma 6.6 Suppose that σ is a substitution that replaces all skolem symbols of a formula ψ, and sSk is a skolem symbol for statements. Then there is a substitution σ' that differs from σ only in the symbols sSk, Dec(sSk), such that

σ'(Do
), σ'(D▢
) are sound taclets

There is a proof tree (fragment) whose root is ▶ σ(ψ), such that the only goal left is ▶ σ'(ψ).
Referring to this lemma it is possible to formulate an analogue of Lem. 6.4 for decomposition taclets:
Lemma 6.7 (Lifting of Decompositions) Suppose that RD is a rule that is de-

scribed by a decomposition taclet D (D = Do
or D = D▢
). If an instance of RD

is given by
P Q
and σ' is a substitution of skolem symbols as in Lem. 6.6 w.r.t. D, then there is a proof tree of σ'(Q), whose only goal left is the sequent σ'(P ).
Proof. First the application of D is replaced with an application of the taclet σ'(D), which is sound by Lem. 6.6, (i) (this substitutes certain occurrences of sSk, Dec(sSk) within P and Q). Subsequently Lem. 6.4 can be applied to the resulting rule application w.r.t. σ'.	 
Corollary 6.8 Suppose that the proof H of MSk(tac )= ιSk(M (tac )) only consists of applications of taclets tac' that do not contain skolem symbols, and of applications of decomposition taclets. Then for each instance φ = κ(M (tac )) of the meaning formula M (tac ) there is a proof Hφ.
Proof. σ is chosen as in the proof of Cor. 6.5.  By repeated application of Lem. 6.6, (ii) it is possible to construct a proof tree with root sequent ▶ φ and

a single goal ▶ σ'(MSk(tac )), with a substitution σ' that is chosen according to Lem. 6.6 for each skolem symbol sSk for statements.
It is then possible to construct a closed proof tree of ▶ σ'(MSk(tac )) by trans- forming H: Each taclet application within H is replaced with the proof tree frag- ment that is obtained from Lem. 6.4 or Lem. 6.7 (according to the kind of the taclet).	 

Conclusions
In this paper, we have outlined how to ensure correctness of derived taclets. Because of limited space, we have only sketched the basic idea and covered only some few kinds of schema variables. The presented concept is completely integrated in the
taclet-based KeY prover, which also supports a bigger class of possible JavaCardDL
taclets.
As future work, it remains
to generalise the concept of skolemisation of meaning formulas,
to study quantified first-order logics with skolemised statements as ‘atomic’ pro- grams, and
to explore further areas of application, as for example, proofs of program trans- formation properties.
Taclets are a simple but powerful concept. By their syntactic and semantic simplicity, users are enabled to write new rules and add them to the system easily.
We have shown that, despite this fact, the correctness of the rule base can be efficiently ensured—even for a special purpose logic like JavaCardDL.
Acknowledgement
We would like to thank Martin Giese and Steffen Schlager for useful comments on earlier versions of this paper, as well as Bernhard Beckert and P.H. Schmitt for fruitful discussions. Also we want to thank the anonymous referees and workshop organisers.

References
Ahrendt, W., T. Baar, B. Beckert, R. Bubel, M. Giese, R. H¨ahnle, W. Menzel, W. Mostowski, A. Roth,
S. Schlager and P. H. Schmitt, The KeY tool, Software and System Modeling 4 (2005), pp. 32–54.
Ahrendt, W., A. Roth and R. Sasse, Automatic validation of transformation rules for Java verification against a rewriting semantics, in: G. Sutcliffe and A. Voronkov, editors, Proceedings, 12th International Conference on Logic for Programming, Artificial Intelligence and Reasoning, Montego Bay, Jamaica, LNCS 3835 (2005), pp. 412–426.
Beckert, B., A Dynamic Logic for the Formal Verification of Java Card Programs, in: I. Attali and
T. Jensen, editors, Java on Smart Cards: Programming and Security. Revised Papers, Java Card 2000, International Workshop, Cannes, France, LNCS 2041 (2001), pp. 6–24.
Beckert, B., M. Giese, E. Habermalz, R. H¨ahnle, A. Roth, P. Ru¨mmer and S. Schlager, Taclets: a new paradigm for constructing interactive theorem provers, Revista de la Real Academia de Ciencias


Exactas, F´ısicas y Naturales, Serie A: Matem´aticas 98 (2004), special Issue on Symbolic Computation in Logic and Artificial Intelligence.
Beckert, B., R. H¨ahnle and P. H. Schmitt, editors, “Verification of Object-Oriented Software: The KeY Approach,” LNCS 4334, Springer-Verlag, 2007.
Beckert, B., S. Schlager and P. H. Schmitt, An improved rule for while loops in deductive program verification, in: K.-K. Lau, editor, Proceedings, Seventh International Conference on Formal Engineering Methods (ICFEM), Manchester, UK, LNCS 3785 (2005), pp. 315–329.
Giese, M., Taclets and the KeY prover, in: C. Lu¨th and D. Aspinall, editors, Intl., Workshop on User Interfaces for Theorem Provers, UITP 2003, Rome, Italy, Electronic Notes in Theoretical Computer Science (2004), to appear.
Gosling, J., B. Joy, G. Steele and G. Bracha, “The Java Language Specification,” Addison Wesley, 2000, 2nd edition.
Habermalz, E., “Ein dynamisches automatisierbares interaktives Kalku¨l fu¨r schematische theoriespezifische Regeln,” Ph.D. thesis, Universit¨at Karlsruhe (2000).
Harel, D., Dynamic Logic, in: D. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, Vol. II, Reidel, 1984 pp. 497–604.
Jacobs, B., J. van den Berg, M. Huisman, M. van Berkum, U. Hensel and H. Tews, Reasoning about Java classes, in: Proceedings, Object-Oriented Programming Systems, Languages and Applications (OOPSLA’98), Vancouver, Canada, 1998, pp. 329–340.
Ru¨mmer, P., Ensuring the soundness of taclets – Constructing proof obligations for Java Card DL taclets, Studienarbeit, Fakult¨at fu¨r Informatik, Universita¨t Karlsruhe (2003).
Sasse, B., Formal correctness of a program logic calculus for the deductive verification of Java programs, Studienarbeit, Fakult¨at fu¨r Informatik, Universita¨t Karlsruhe (2002).
Sun Microsystems, Inc., Palo Alto/CA, “Java Card 2.0 Language Subset and Virtual Machine Specification,” (1997).
Trentelman, K., Proving correctness of javacard dl taclets using bali., in: SEFM, 2005, pp. 160–169.
von Oheimb, D., Axiomatic semantics for Javalight , in: S. Drossopoulou, S. Eisenbach, B. Jacobs,
G. T. Leavens, P. Mu¨ller and A. Poetzsch-Heffter, editors, Proceedings, Formal Techniques for Java Programs, Workshop at ECOOP’00, Cannes, France, 2000.
von Oheimb, D., “Analyzing Java in Isabelle/HOL,” Ph.D. thesis, Institut fu¨r Informatik, Technische Universit¨at Mu¨nchen (2001).
Widmann, F., “Crossverification of While Loop Semantics,” Diplomarbeit, Universit¨at Karlsruhe, Fakult¨at fu¨r Informatik (2006).
