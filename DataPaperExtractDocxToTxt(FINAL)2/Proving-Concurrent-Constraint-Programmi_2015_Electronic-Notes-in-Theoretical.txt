Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 312 (2015) 179–195
www.elsevier.com/locate/entcs

Proving Concurrent Constraint Programming Correct, Revisited
Carlos Olarte1
ECT, Universidade Federal do Rio Grande do Norte. Natal, Brazil.
DECC, Pontificia Universidad Javeriana Cali. Colombia.
Elaine Pimentel 2
DMAT, Universidade Federal do Rio Grande do Norte. Natal, Brazil.

Abstract
Concurrent Constraint Programming (CCP) is a simple and powerful model of concurrency where processes interact by telling and asking constraints into a global store of partial information. Since its inception, CCP has been endowed with declarative semantics where processes are interpreted as formulas in a given logic. This allows for the use of logical machinery to reason about the behavior of programs and to prove properties in a declarative way. Nevertheless, the logical characterization of CCP programs exhibits normally a weak level of adequacy since proofs in the logical system may not correspond directly to traces of the program. In this paper, relying on a focusing discipline, we show that it is possible to give a logical characterization to different CCP-based languages with the highest level of adequacy. We shall also provide a neater way of interpreting procedure calls by adding fixed points to the logical structure.
Keywords: Linear Logic, Concurrent Constraint Programming, Proof Systems, Focusing, Fixed Points.


Introduction
Reasoning about concurrent programs is much harder than reasoning about se- quential ones. Programmers often find themselves overwhelmed by the many subtle cases of thread interactions they must be aware of to decide whether a concurrent program is correct or not, and by the need of finding the right level of thread atomic- ity of concurrent programs, avoiding race conditions, coping with mutual exclusion requirements, and guaranteeing deadlock freeness to ensure program reliability.
Concurrent Constraint Programming (CCP) [22,21] is a simple and powerful model of concurrency where agents interact by telling constraints (i.e., formulas in

1 Email: carlos.olarte@gmail.com
2 Email: elaine.pimentel@gmail.com

http://dx.doi.org/10.1016/j.entcs.2015.04.011
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

logic) into a shared store of partial information and synchronize by asking if a given information can be deduced from the store.
The logical characterization of constraint systems in CCP has allowed the devel- opment of more powerful systems by simply replacing the underlying logical frame- work. For instance, in linear CCP (lcc [5]), constraints are formulas in Girard’s intuitionistic linear logic (ILL) [8] and ask agents are allowed to consume tokens of information from the store. Moreover, in [16,17] it is shown that considering ILL with subexponentials [3] as constraint systems allows for the specification of concurrent systems where epistemic, spatial and temporal modalities are involved.
The logical foundations of CCP makes it an ideal language for the specification of concurrent systems: complex synchronization patterns can be expressed declar- atively by means of constraint entailment. Moreover, the dual view of processes as computing agents and as formulas in logic allows for the use of techniques from both process calculi and logic to reason about the behavior of processes.
The connection between logic and CCP processes (and constraint systems) has been studied since its inception: in [22] a closure operator semantics is given to deterministic CCP programs that was later related to the logic of constraints in [19]. In [4] a calculus for proving properties of CCP programs is defined where properties are expressed in an enriched logic of the constraint system. The works in [20,5] relate operational steps of CCP and lcc with derivations in ILL. We can also mention the works in [13,4] that give logical semantics to timed CCP languages and provide calculi to verify temporal properties of programs. The reader may find a survey of all these developments in [18].
The relation of CCP programs and derivations in logic studied so far, unfor- tunately, exhibits a weak level of adequacy: proofs in the logical systems may not correspond to an operational derivation. This paper contributes to close this gap by showing that it is possible to exhibit a stronger level of adequacy for different flavors of CCP calculi. In order to do that, we interpret lcc agents as ILL formulas using a focusing discipline [1]. By using focusing, we can classify actions in lcc (and then in CCP) as positive or negative, depending on the polarity of the outermost connec- tive obtained in their translation as formulas in ILL. The positive actions need to interact with the environment, either for choosing a path to follow, or for waiting for a guard to be available. Negative actions do not need any interaction with the context, and can be executed anytime and concurrently, not altering the final result of the computation. We prove that the translation from lcc to focused intuitionistic linear logic (ILLF) is adequate, in the sense that a focused phase in ILLF corre- sponds exactly to an operational step in lcc, and vice-versa. The results in this paper not only extend the ones in [5] (since we present a stronger adequacy result), but also the ones in [10], with a better understanding of operational derivability.
The idea of using focusing for ensuring a higher level of adequacy is not at all new. In fact, [14] shows how to use focusing, fixed points and delays in order to specify sequential programs: this can be achieved only by using subexponentials. In this work, we deal with concurrent instead of sequential programs and, differently from [14] and our previous work in [16], we do not make use of subexponentials. We

interpret lcc processes using pure linear logic. Hence, the encoding is more natural and direct, and we can use all the rich and already stablished meta-theory developed for linear logic to help in drawing conclusions about CCP systems. Moreover, we study different notions of observables not considered in [16] (see Definition 4.6). Particularly, we show that there are lcc computations that cannot be mimicked by the standard encoding of processes as ILLF formulas. Then, by introducing delays in the encoding, we recover the one-to-one correspondence between ILLF derivations and lcc computations. We also study the behavior of non-deterministic processes with blind and guarded choices not present in [16].
Finally, we give to procedure calls a more modern presentation using fixed points. Although this idea is already present in [20], here we exploit better the use of intuitionistic linear logic with fixed points (μILL) for adding the greatest fixed point operator to ILL. On doing that, we open the possibility of using co-induction to study in CCP more interesting properties of concurrent system such as bisimilarity, liveness properties, or to reason about non-terminating computations.
The rest of this paper is organized as follows. We start in Section 2 by pre- senting the base CCP language, determinate-CCP with tell, ask, parallel, locality and recursion operators. We then introduce in Section 3 a focused system for intu- itionistic linear logic (ILLF). We show in Section 4 that ILLF allows us to capture precisely the behavior of CCP ask processes: they can be triggered if and only if its guard can be inferred only by the present store and the non-logical axioms. Next, we introduce the indeterminate-CCP language with two kinds of choice operators: blind choice (aka internal choice) and one-step guarded choice. We show that a simple adjust in our encoding suffices to capture such behaviors keeping the level of adequacy. We also show how to interpret procedure calls using fixed points. Section 5 concludes the paper.
CCP calculi
Concurrent Constraint Programming (CCP) [22,21] (seea survey at [18]) is a model of concurrency that combines the traditional operational view of process calculi with a declarative view based on logic. This allows CCP to benefit from the large set of reasoning techniques of both process calculi and logic.
Processes in CCP interact with each other by telling and asking constraints (pieces of information) in a common store of partial information. The type of constraints processes may act on is not fixed but parametric in a constraint system. Such systems can be formalized as a Scott information system [23] as in [22], or they can be built upon a suitable fragment of logic [24,5,13].
The store in CCP grows monotonically, this means that agents are only allowed to add new information but it is not possible to delete constraints from the store. In order to have a better resource control, the Linear CCP (lcc) language was proposed in [5], where constraints are seen as formulas in a fragment of intuitionistic linear logic (ILL) [8]. More precisely, the linear constraint system is redefined as follows.
Definition 2.1 [Linear Constraint Systems [5]] A linear constraint system is a pair

(C, ▶Δ) where C is a set of formulas (linear constraints) built from a first-order signature and the grammar
G := 1 | A | ! G | G ⊗ G | ∃x.G
where A is an atomic formula, ⊗ is the multiplicative conjunction, 1 is its neutral element, ∃ is the existential quantifier and ! is the bang exponential of ILL. We shall use c, cJ, d, dJ, etc, to denote elements of C. Moreover, let Δ be a set of non-logical axioms of the form ∀x[c−◦cJ] where ( is the linear implication and all free variables in c and cJ are in x. We say that d entails dJ, written as d ▶Δ dJ, iff the sequent
! Δ,d −→ dJ is provable in ILL.
As it was shown in [5], it is trivial to recover the monotonic behavior of CCP from lcc by requiring that every constraint in the constraint system is marked with “!”, i.e., all constraints are seen as unbounded resources. For this reason, we shall keep our discussion on lcc having in mind that it extends straightforwardly to CCP.
The syntax of lcc processes (without the choice operator for the moment) is given next.
Definition 2.2 [Syntax of lcc] Processes are built from constraints in the under- lying constraint system as follows:
P, Q ::= tell(c) | ask c then P | P  Q | (local x) P | p(x)
The process tell(c) adds c to the current store d producing the new store d ⊗ c. The process ask c then P evolves into P if the current store entails c. In this case, c is consumed from the store. In other case, the process remains blocked until enough information is added to the store. This provides a powerful synchronization mech- anism based on constraint entailment. Following [5], the free variables occurring in c, denoted as fv (c), are assumed to be universally quantified. To keep simpler the syntax, we shall omit the “∀x” in ∀x.(ask c then P ) if x ∈ fv (c).
The process P  Q represents the parallel (interleaved) execution of P and Q. The process (local x) P behaves as P and binds the variable x to be local to it.
Given a process definition p(y) =Δ P where all free variables of P are in the set of pairwise distinct variables y, the process p(x) evolves into P [x/y].
lcc Programs are of the form D.P where D is a set of process definitions and P a process. It is assumed that every process name p(·) has a unique definition in D. The structural operational semantics (SOS) of lcc is given by the transition relation γ −→ γJ satisfying the rules in Figure 1. These rules are straightforward realizing the operational intuitions given above. Here we follow the semantics pre- sented in [5] where the local variables created by the program appear explicitly in the transition system. More precisely, a conﬁguration γ is a triple of the form (X; Γ; c), where c is a constraint (a logical formula specifying the store), Γ is a mul- tiset of processes, and X is a set of hidden (local) variables of c and Γ. The multiset Γ= P1, P2,..., Pn represents the process P1  P2...  Pn. We shall indistinguishably
use both notations to denote parallel composition of processes.

(X; Γ; c) ∼= (XJ; ΓJ; cJ) −→ (Y J; ΔJ; dJ) ∼= (Y ; Δ; d) (X; Γ; c) → (Y ; Δ; d)

REQUIV



(X; tell(c), Γ; d) −→ (X; Γ; c ⊗ d) RT
d ▶Δ c[y/x] ⊗ e,	x = fv (c)
(X; ask c then P, Γ; d) −→ (X; P, Γ; e) RA



x ∈/ X ∪ fv(d) ∪ fv(Γ)
(X; (local x) P, Γ; d) −→ (X ∪ {x}; P, Γ; d) RL
p(x) =Δ P
(X; p(y), Γ; d) −→ (X; P [y/x], Γ; d) RC



Fig. 1. Operational semantics of lcc. In rule RA, e is the most general constraint to avoid weakening the store (see [9])
Processes are quotiented by a structural congruence relation ∼= satisfying:
(local x) P ∼= (local y) P [y/x] if y ∩ fv(P )= ∅; – alpha conversion
P  Q ∼= Q  P ;
P  (Q  R) ∼= (P  Q)  R.
Furthermore, Γ = {P1, ..., Pn} ∼= {PJ, ..., PJ } = ΓJ iff Pi ∼= PJ for all 1 ≤ i ≤ n.
1	n	i
Finally, (X; Γ; c) ∼= (XJ; ΓJ; cJ) iff X = XJ, Γ ∼= ΓJ and c ≡Δ cJ (i.e., c ▶Δ cJ and
cJ ▶Δ c).
We conclude here with the notion of observables that will play a central role in the adequacy theorems in Section 4.
Definition 2.3 [Observables] Let −→∗ be the reflexive and transitive closure of
−→. If (X; Γ; d) −→∗ (XJ; ΓJ; dJ) and ∃XJ.dJ ▶Δ c we write (X; Γ; d) ⇓c. If X = ∅
and d = 1 we simply write Γ ⇓c.
Intuitively, if P is a process then P ⇓c says that P outputs c under input 1.
ILLF: a focused system for intuitionistic linear logic
Focusing is a discipline on proofs that was first proposed for Linear Logic in [1], in the context of logic programming, aiming at reducing the non-determinism during proof search. Focused proofs can be interpreted as the normal form proofs for proof search.
The focused intuitionistic linear logic system (ILLF) is depicted in Figure 2.
This system is based on the system LJF proposed in [11].
ILL connectives are separated into two classes, the negative ones: (, &, T, ∀ and the positive ones: ⊗, ⊕, ∃, !, 1. The polarity of non-atomic formulas is inherited from its outermost connective and positive bias is assigned to atomic formulas. 3 ILLF contains four types of sequents:

3 Observe that the system ILLF, as presented in Figure 2 induces a positive polarity to atoms. Although the bias assigned to atoms does not interfere with provability [12], it changes considerably the shape of proofs. In the present work, it is extremely important, for the sake of guaranteeing the high level of adequacy, that atoms have a positive behavior.

Negative Phase

[Υ : Γ], Θ −→ T TR
[Υ: Γ], Θ −→ R
1L
[Υ : Γ], Θ, 1 −→ R
[Υ: Γ], Θ,F −→ G	(
[Υ : Γ], Θ −→ F ( G	R



[Υ : Γ], Θ, F,G −→ R
⊗L
[Υ : Γ], Θ,F ⊗ G −→ R
[Υ: Γ], Θ −→ F	[Υ : Γ], Θ −→ G
[Υ: Γ], Θ −→ F & G	&R



[Υ: Γ], Θ −→ G[y/x]
[Υ : Γ], Θ −→ ∀x.G  ∀R
[Υ: Γ], Θ, G[c/x] −→ R
[Υ : Γ], Θ, ∃x.G −→ R ∃L



[Υ: Γ], Θ,F −→ R	[Υ : Γ], Θ,H −→ R
⊕L
[Υ: Γ], Θ,F ⊕ H −→ R
Positive Phase
[Υ,F : Γ], Θ −→ R
[Υ : Γ], Θ, ! F −→ R !L

[Υ: Γ1]−H→	[Υ : Γ2]−G→ ⊗
[Υ : Γ1]−F→	[Υ: Γ2] −H→ [G]
(L

[Υ : Γ1, Γ2]−H⊗G→
R	[Υ : Γ , Γ ] −F (H→ [G]



[Υ : Γ]−G[t/x]→
F [t/x]
[Υ : Γ] −−−−→ [G]
∀

[Υ : Γ]−
∃x.G→ ∃R
[Υ : Γ] ∀x.F
L
[G]



[Υ: Γ] −F→i
[G]
&Li	[Υ : Γ]−Gi→	⊕
[Υ : ·] −→ G
!

[Υ: Γ] −F−1−&−F→2
[G]
[Υ : Γ]−
G1⊕G2→
R
[Υ : ·]−
! G→  R

[Υ : ·]− → 1R	[Υ: Γ]− → IR given A ∈ (Γ ∪ Υ) and (Γ ⊆ {A})
Structural Rules

[Υ : Γ, Na], Θ −→ R []
[Υ: Γ], Θ −→ [P ]
[]

[Υ : Γ], Θ, Na −→ R	L	[Υ : Γ], Θ −→ P	R


[Υ,F : Γ] −→F  [G]
[Υ: Γ] −N→ [G]
[Υ: Γ]−G→

[Υ,F : Γ] −→ [G] DL
[Υ : N, Γ] −→ [G] DL
[Υ : Γ] −→ [G] DR



[Υ: Γ], Pa −→ [F ]
R
[Υ: Γ] −→ N

[Υ : Γ] −P→a
L
[F ]
[Υ : Γ]−N
→  RR


Fig. 2. Focused Proof System for ILLF. R stands for either a bracketed formula, [F ], or an unbracketed formula. A is an atomic formula; P is a positive formula; Pa is a positive or atomic formula; N is a negative formula; and Na is a negative or atomic formula. Variable y in [∀] rule does not occur elsewhere.


[Υ : Γ], Θ −→ R is an unfocused sequent, where R is either a bracketed formula [F ] or an unbracketed one. Here Γ contains only atomic or negative formulas, while Υ is the classical context.
[Υ : Γ] −→ [F ] is a sequent representing the end of a negative phase.

L[[tell(c)]]	= c	L[[P  Q]] = L[[P ]] ⊗ L[[Q]]
L[[ask c then P ]] = ∀x(c ( L[[P ]])	L[[∃x(P )]] = ∃x.(L[[P ]])
L[[p(x) =Δ P ]]	= ∀x.p(x) ( L[[P ]]	L[[p(y)]]	= p(y)
Fig. 3. Interpretation of lcc processes and processes definitions as ILL formulas.
[Υ : Γ]−F→ is a sequent focused on the right.

[Υ : Γ] −→F
G is a sequent focused on the left.

Observe, in Figure 2, that the negative connectives have invertible right rules, while the positive connectives have invertible left rules. This separation induces a two phase proof construction: a negative, where no backtracking on the selection of inference rules is necessary, and a positive, where choices within inference rules can lead to failures for which one may need to backtrack.
In the negative phase, sequents have the shape (i) above and all the negative non-atomic formulas on the right and all the positive non-atomic formulas on the left are introduced. Also, atomic and negative formulas on the left and positive formulas on the right are stored in the respective contexts using the bracket rules []L and []R. When this phase ends, sequents have the form (ii).
The positive phase begins by choosing via one of the decide rules ([DL] or [DR]) a formula on which to focus, enabling sequents of the forms (iii) or (iv). Rules are then applied on the focused formula until either an axiom is reached (in which case the proof ends), the right promotion rule !R is applied (and focusing will be lost) or a negative subformula on the right or a positive subformula on the left is derived (and the proof switches to the negative phase again).
This means that focused proofs can be seen (bottom-up) as a sequence of alter- nations between negative and positive phases.
From lcc processes to ILLF formulas
In CCP-based calculi, processes are not only agents that evolve according to the rules of the underlying operational semantics: they also can be seen as formulas in intuitionistic linear logic. The logical interpretation of lcc is defined with the aid of a function L[[· ] defined in Figure 3 [5]. We will call p the head of the process definition
∀x.p(x) ( L[[P ] while c will be the guard of the ask formula ∀x(c ( L[[P ]]).
The following result states that the interpretation L[[·]] is faithful.
Theorem 4.1 (Adequacy – ILL [5]) Let P be a process, Ψ be a set of process deﬁnitions and Δ be a set of non-logical axioms. Then, for any constraint c, P ⇓c iff there is a proof of the sequent ! L[[Ψ]], ! Δ, L[[P ]] −→ c ⊗T in ILL. 4
The adequacy of this interpretation is on the level of proofs [15], meaning that

4 The top (T) erases the formulas corresponding to blocked processes. We will denote by ! L[[Ψ]] the mapping of ! L[[· ] to elements in Ψ.

there may be logical steps not corresponding to any operational step and vice versa. For instance, consider the case where the last rule applied on a proof of an ILL sequent is the implication left
π1	π2
Γ1, b −→ c	Γ2 −→ a (L
Γ1, Γ2,a ( b −→ c
In this case, π2 could contain sub-derivations that have nothing to do with the proof of a. For instance, processes definitions could be unfolded or other processes could be executed. This would correspond, operationally, to the act of triggering an ask ask a then P with no guarantee that its guard a will be derivable only from the set of non-logical axioms Δ and the store d: it may be the case that a will be later produced by a process PJ such that L[[P J]] ∈ Γ2, for example. Observe that this is not allowed by the operational semantics of lcc (see rule RA in Figure 1).
A simple inspection on the interpretation in Figure 3 shows that the fragment of ILL needed for encoding lcc processes and processes definitions is given by the following grammar for guards/goals G, processes P and processes definitions PD.

G	:= 1 | A | ! G | G ⊗ G | ∃x.G
P	:= G | P ⊗ P | P & P | ∀x.G ( P | ∃x.P | p(t) PD := ∀x.p(x) ( P.
where A is an atomic formula in C (see Definition 2.1) while p is also atomic but p ∈/ C. The process corresponding to the formula P & P is the non-deterministic choice that we later introduce in Section 4.3.
Note that, due to this syntax, we will use only a small fragment of ILLF. In fact, we will only use the negative rules 1L, ⊗L, ∃L, !L and the positive rules ⊗R, (L
, ∃R, !R, &L. The formulas also have special forms and behavior, as described bellow.
Formulas on the right (guards/goals G, heads p). The correspondent logical frag- ment of lcc in ILLF have strictly positive formulas on the right. There are three cases to consider.
The formula on the right is the head p of a process definition. Thus it has to be focused (since it will come from a focused implication formula on the left), it is positive and atomic. Hence the proof must end immediately with the initial axiom IR.
Goals have no occurrences of !: hence, focusing cannot be lost on the right, and a focused formula will be decomposed entirely and at once into its atomic subformulas. At this point, since the only possible action on focused atomic formulas on the right is to apply the axiom IR, the derivation must end.
Focusing on a goal of the form ! G is only possible if the linear context is empty (see rule !R in Figure 2). In this case, focus will be lost but only classical constraints, non-logical axioms and procedure calls can be in the context. See Lemma 4.2 for a detailed behavior in this case.

Formulas on the left (programs P). On the other hand, it is possible to have positive or negative formulas on the left.
Positive formulas on the left (that cannot be focused) come from the interpre- tation of one of the actions: tell, parallel composition and locality that do not need any interaction with the context. We call these actions negative. As an example, the parallel composition P  Q is translated in ILLF as L[[Q]] ⊗ L[[P ]]. Notice that ⊗ is a positive connective, decomposing it on the left side of a sequent will be done in a negative phase.
Negative formulas on the left (that can be chosen for focusing) come from one of the actions: ask, non-deterministic choice (to be presented later – see Defini- tion 4.11) and procedure calls. They do need to interact with the environment, either for choosing a path to follow (in non-deterministic choices), or for waiting for a guard to be available (in asks or procedure calls). We call these actions positive. Consider, for example, an ask process ∀x(c ( L[[P ]]). Note that both
∀ and ( are negative, hence decomposing them on the left side of a sequent will be done in a positive phase.
The next lemma clarifies better the above cases when formulas on the right are focused. In particular, we show how is the shape of the derivations in a proof involving banged guards and goals: such formulas are derivable by other guards and non-logical axioms only. Actually, we may state a stronger result: there is no proof of banged guards and goals if a process definition is chosen to be focused on.

Lemma 4.2 Let G be a guard, G be a set of guards, Ψ be a set of process deﬁnitions and Δ be a set of non-logical axioms. Then, the sequent [L[[Ψ]], G, Δ : ·]−! G→ is provable if and only if [G, Δ: ·]−! G→ is provable. Moreover, if ∀x.p(x) ( L[[P ]] ∈ L[[Ψ]] then the sequent

6x.p(x)(L[[P ]]
[L[[Ψ]], G, Δ: ·] −−−−−−−−−→ [G]
is not provable.

Proof. Note that all sequents in a derivation of [L[[Ψ]], Δ: ·], L[[P ]] −→ c will have the shape [L[[Ψ]], Δ, G : Γ], Θ −→ GJ, where G is a set of classical constraints, Γ has only atomic or negative formulas and Θ has only encoded processes. Note also that proving [L[[Ψ]], Δ, G : Γ], Θ −→ ! G by focusing on the banged formula on the right is possible only if Γ = Θ = ∅. Finally, observe that a proof of [L[[Ψ]], G, Δ: ·]−! G→ has necessarily the shape:

π
[L[[Ψ]], G, Δ: ·] −→ G
[L[[Ψ]], G, Δ: ·]−	!R

Now, π either continues by focusing on G or on some formula in L[[Ψ]], G, Δ. Assume that ∀x.p(x) ( L[[P ]] ∈ Ψ is chosen for focusing. Since ∀ and −◦ are negative, focus

will not be lost and π must have the shape


L[[P ]]
[L[[Ψ]], G, Δ: ·] −−−→ [G]	[L[[Ψ]], G, Δ: ·]−p(t)→


6x.p(x)(L[[P ]]
[L[[Ψ]], G, Δ: ·] −−−−−−−−−→ [G]
[L[[Ψ]], G, Δ: ·] −→ [G]	[]R, DL

∀L, −◦L


But the sequent [L[[Ψ]], G, Δ : ·]−p(t) → is not provable since p is atomic, positive and not a constraint, hence focus cannot be lost and the proof cannot finish with the initial axiom since p is not in L[[Ψ]] ∪G ∪ Δ.	2
We are now able to show how focusing in ILL allows us to prove that every logical step in ILLF corresponds exactly to an operational step in lcc.
Theorem 4.3 (Adequacy – ILLF) Let P be a process, Ψ be a set of process deﬁnitions and Δ be a set of non-logical axioms. Then, for any constraint c,
P ⇓c iff there is a proof of the sequent [L[[Ψ]], Δ: ·], L[[P ]] −→ c ⊗T 
in ILLF. Moreover, the adequacy from lcc to ILLF is at the level of proofs, while from ILLF to lcc the adequacy is at the level of derivations, that is, one focused logical phase corresponds exactly to one operational step.
Proof. Since the focused system ILLF is complete w.r.t. ILL, the first part of the proof is an immediate corollary of Theorem 4.1. The proof of the adequacy level from ILLF to lcc is by straightforward case analysis. We will illustrate it by showing the case for the ask process. Suppose that P = ask a then PJ. Hence focusing on L[[P ] would produce the derivation
π1
L[[P ′]]	π2
[Υ : Γ1] −−−→ [d]	[Υ : Γ2]−a→ ∀ , (
6x.a(L[[P ′]]	L	L
[Υ: Γ1, Γ2] −−−−−−−−→ [d]
[Υ : ∀x.a ( L[[P J]], Γ , Γ ] −→ [d] DL
1	2
Observe that a is guard. If it does not have banged subformulas, it cannot be unfo- cused on the right, and it will be decomposed entirely into its atomic subformulas, and the subproofs should finish with the initial axiom on those formulas. This means that we can only focus on L[[P ] if all atomic subformulas needed to prove a are already in the context. On the other hand, if a have banged subformulas, Lemma 4.2 states that a will be proved by using constraints and non-logical axioms only, matching exactly the semantics given by rule RA: the guard a can be inferred by the context, possibly using non-logical axioms in Δ.	2
We note that the result above is not at the full level of derivations, though, since there are operational steps that do not have any logical correspondent as shown in the next section.

Maximal derivations and interleaving in ask agents
In this section we study the cases when the operational steps cannot be followed by the derivations in the logical system. Then, we show how to obtain the highest level of adequacy in such cases. Let us start by presenting some examples illustrating these situations.
Example 4.4 [Traces, proofs and focusing] Consider the lcc process
P = tell(a⊗b)  ask a then ask b then tell(a⊗b)  ask b then ask a then tell(ok).

We denote the second and the third ask agents in P as A1 and A2 respectively. The SOS of lcc dictates that there are two possible transitions leading to the store ok. Both of such transitions start with the negative action tell(a ⊗ b):
Derivation 1: ⟨∅; P ; 1⟩ −→ ⟨∅; A1  A2; a ⊗ b⟩ −→ ⟨∅; ask b then tell(a ⊗ b)  A2; b⟩
−→ ⟨∅; tell(a ⊗ b)  A2; 1⟩ −→ ⟨∅; A2; a ⊗ b⟩ −→∗ ⟨∅; ·; ok⟩ /−→
Derivation 2: ⟨∅; P ; 1⟩ −→ ⟨∅; A1  A2; a ⊗ b⟩ −→ ⟨∅; A1  ask a then tell(ok); a⟩
−→ ⟨∅; A1  tell(ok); 1⟩ −→ ⟨∅; A1; ok⟩ /−→
These transitions correspond exactly to a different focused proof of the sequent
L[[P ]] −→ ok: one focusing first on L[[A1 ] and the other focusing first on L[[A2]].
On the other hand, there is also an interleaved execution of A1 and A2 that does not lead to the final store ok:
Derivation 3: ⟨∅; P ; 1⟩ −→ ⟨∅; A1  A2; a ⊗ b⟩ −→ ⟨∅; ask b then tell(a ⊗ b)  A2; b⟩
−→ ⟨∅; ask b then tell(a ⊗ b)  ask a then tell(ok); 1⟩ /−→
The above trace does not have any correspondent derivation in the ILLF system. In fact, since ( is a negative connective, focusing on L[[A1 ] will decompose the formula a ( b ( (a ⊗ b), consuming a and producing the focused formula b ( (a ⊗ b), which is still negative. Hence focusing cannot be lost and the inner ask has to be triggered.
Remark 4.5 This last example shows something really interesting: although the formulas A⊗B −◦ C and A −◦ B −◦ C are logically equivalent, they are operationally different when concurrent computations are considered.
Observe that the last derivation in Example 4.4 does not produce any observable store (see Definition 2.3). Hence a good question is whether it is possible to restrict the behavior of ask agents to avoid interleaved executions when we are interested in observing a given constraint, i.e., when the system exhibits an output. Fortunately, the answer is positive as shown below.
As we know, once the guard c in ask c then P is entailed, the operational se- mantics dictates that P is enabled for execution (rule RA). The semantics, however, does not enforce the immediate execution of P . Next definition gives an alternative semantics to ask agents in order to force the execution of P avoiding interleaved derivations as the ones in Example 4.4.

Definition 4.6 [Standard and Maximal Derivations and Observables] We say that a derivation in lcc using the relation −→ as in Figure 1 is standard. We define the maximal -ask transition relation ~ on configuration similar to −→ but replacing the rule RA with the rule RAM below:
d ▶Δ c1[y1/x1] ⊗ ... ⊗ cn[yn/xn] ⊗ e,	xi = fv (ci)	 R
(X; P, Γ; d) ~ (X; Q, Γ; e)	AM
where the side condition  means that P is a process of the shape:
ask c1 then ask c2 then ...ask cn then Q	(1) and Q is not an ask agent. We define the observables of a process under the ~
relation, notation (X; Γ; d) M c, similarly as in Definition 2.3.
Intuitively, in a standard derivation of the shape γ −→ γJ, interleaved executions of ask agents are allowed as in Derivation 3 above. On the contrary, in a maximal derivation γ ~ γJ, an ask as the one in Equation 1 has to wait until all the guards c1, ..., cn can be entailed from the store and then executes Q in one step as in Derivation 1 and Derivation 2 above.
The next theorem shows that if there is an output using the semantics −→, then such output can be also computed by using the semantics ~.
Theorem 4.7 Let P be a process. Then, for any constraint c,
(X; P ; e) ⇓c if and only if (X; P ; e) M c
Proof. The (⇐) part of the proof is immediate since ~ is a particular scheduling for a −→ derivation. As for the (⇒) part we proceed as follows. If the current store is able to entail d, then a process of the shape
P = ask d then (ask dJ then PJ)
evolves into ask dJ then PJ not producing any constraint. Then either P will remain blocked and hence it will not be used for producing c, or dJ will be produced by some other process R and P will reduce to PJ. But in this last case, R does not depend on P , and it can be executed before. Hence the nested asks can be executed at once.	2
We can now state a stronger adequacy result, restricted to maximal derivations in lcc.
Theorem 4.8 (Strong adequacy – maximal derivations) Let P be a process, Ψ be a set of process deﬁnitions and Δ be a set of non-logical axioms. Then, for any constraint c,
P M c iff there is a proof of the sequent [L[[Ψ]], Δ: ·], L[[P ]] −→ c ⊗T 
in ILLF. Moreover, the adequacy is at the level of derivations, that is, one focused logical phase corresponds exactly to one operational step and vice-versa.

Proof. Observe that, in the process ask c then P , the only possibility of L[[P ]] being a negative formula is if P is also an ask. Hence maximal derivations in lcc correspond exactly to focused derivations in ILLF.	2

Interleaving and delays
Interleaving can be handled in a focused system by the use of logical delays. In fact, since the formula c ( L[[P ] is negative, focusing on it on the left side of the sequent will produce a focused L[[P ]]. If this formula is also negative, focusing will not be lost and this operationally means that P should be executed right away. However, for any formula A, A is logically equivalent to A ⊗ 1, which is a positive formula. Hence, we can easily force the focusing phase to end by substituting L[[P ]] by L[[P ]] ⊗ 1. More precisely, we define the encoding L[[·]]1 as L[[· ] but replacing the cases for the ask agents and process definitions as follows:
L[[ask c then P ]]1 = ∀x.c ( (L[[P ]]1 ⊗ 1)
L[[p(x) =Δ P ]]1   = ∀x.p(x) ( (L[[P ]]1 ⊗ 1)
In this case, we can have a stronger adequacy theorem for the whole lcc system.
Theorem 4.9 (Strong adequacy – standard derivations) Let P be a process, Ψ be a set of process deﬁnitions and Δ be a set of non-logical axioms. Then, for any constraint c,
P ⇓c iff there is a proof of the sequent [L[[Ψ]]1, Δ: ·], L[[P ]]1 −→ c ⊗T 
in ILLF. The adequacy is at the level of derivations.
Remark 4.10 Observe that Theorem 4.8 gives a canonical trace to lcc success- ful computations via focusing. In this case, the guards of nested ask agents are evaluated at once to decide whether the process continues blocked or not. On the other hand, Theorem 4.9 shows that traces of a derivation in logic have a one-to-one correspondence with traces of a computation in a lcc program.

Indeterminate CCP languages
Non-determinism is introduced in CCP by means of the choice operator. Let us then extend the syntax and the operational semantics given in Section 2. 5
Definition 4.11 [Indeterminate CCP] Indeterminate CCP processes are obtained from the syntax in Definition 2.2 extended with the constructor
P, Q ::= Σ Pi
I

5 Note that lcc, without choices, is also non-deterministic since ask agents may compete for the same token.



⟨x; Σ P , Γ; c⟩ −→ ⟨x; P , Γ; c⟩ RBCH
⟨x; Pi, Γ; c⟩ −→ ⟨xJ; ΓJ; cJ⟩
⟨x; Σ P , Γ; c⟩ −→ ⟨xJ; ΓJ; cJ⟩ RGCH

i	i
I
Blind Choice
i
I
One-step guarded choice

Fig. 4. Operational Rules for the Non-Deterministic Choice
Given a finite set of indexes I, the process Σ Pi chooses one o the Pj for execu-
I
tion. The choice of one of the processes precludes the others from execution. When
|I| = 2, we shall write P1 + P2 instead of Σ Pi.
I
We can give at least two possible interpretation of the non-deterministic choice as shown in Figure 4. The Rule RBCH corresponds to the blind (or internal) choice (BC). This rules says that a process Pi is chosen for execution regardless whether the process Pi can evolve or not. In the Rule RGCH, the chosen process Pi must not block, i.e., it must exhibit at least one transition. Since the only blocking agent in Syntax 2.2 is the ask agent, this kind of non-deterministic choice is written as a
summation of ask agents as in Σ ask ci then Pi. Thus, rule for one-step guarded
i
choice (GC) can be read as Pi is chosen for execution whenever its guard ci can be entailed from the current store. We note that a BC can be seen also as a GC where all guard ci is the constraint 1.
The logical clauses representing blind and guarded choice are, respectively:
L[[Σ Pi]]BC = &I (L[[Pi]] ⊗ 1)	L[[Σ Pi]]GC = &IL[[Pi]]
I	I
Observe that, this way, we capture well the behavior of choosing one process from the choices we have. At the same time, forcing formulas to be positive in the BC case implies that the chosen process will not block on the positive phase. On the other hand, Pi being a negative formula in the case GC, assures that the choice will be triggered only if the guard is already in the context. Hence, we continue having a neat logical control corresponding to the operational semantics and Theorem 4.9 is also valid for indeterminate CCP.

Procedure calls as ﬁxed points
We conclude this section by explaining how procedure calls can be seen as (greatest) fixed points. It turns out that we can give meaning to procedure calls as formulas in μILL (ILL with fixed points 6 ). Assuming that p(y) =Δ P , the encoding L[[·]]μ is the same as L[[·]]1 (see Section 4.2) but
L[[p(t)]]μ = ν(L[[P ]]μ[t/y] ⊗ 1)

6 The system presented here is an adaptation, for the intuitionistic case, of the system μMALL presented in [2]. We note that, although μMALL do not have exponentials, it is possible to encode exponentials using fixed points. In fact, [! P ] can be encoded as ν(λp.1& (p ⊗ p)& [P ]).

where ν is the greatest fixed point operator with rules
B(νBt)
[Υ : Γ] −−−−→ [G] νL	[Υ: Γ], Θ −→ St	[Υ: Γ], Θ, Sx −→ B(Sx)
νBt	R
[Υ : Γ] −−→ [G]	[Υ : Γ], Θ −→ νBt

In the above rules, x are fresh variables, t are terms, S is a closed formula of the same type as B (called the co-invariant), and B has the form λpλx.Ppx with p a predicate constant. Observe that ν is defined here as a negative operator and that B can be unfolded indefinitely, since it is applied to νB in the rule νL. For having completeness of the focusing system, it would be necessary to add frozen formulas and restrict the system to quasi-inﬁnite proofs [2], but all this machinery will not be needed here, since we use only a small fragment of μMALL.
First of all, we do not use co-induction, since fixed points do not appear in the right side of sequents. In fact, our base grammar for guards/goals G and processes P now is the following
G := 1 | A | ! G | G ⊗ G | ∃x.G
P := G | P ⊗ P | P & P | ∀x.G ( P | ∃x.P | νP [t/x]
Secondly, higher-order procedure calls are not present in our encoding. Hence the application of the rule νL matches exactly the behavior of focusing on ∀x.p(x) ( L[[P ]]1 ⊗ 1, where p(x) is substituted by P [t/x]:


L[[P ]]1[t/x]⊗1
L[[P ]]μ[t/x]⊗1
IR	[Υ: Γ] −−−−−−−−→ [G] νL

[Υ : Γ] −−−−−−−−→ [G] [Υ : p(t)]−p(t)→
∀ , (
ν(L[[P ]]μ[t/x]⊗1)
[Υ : Γ]

6x.p(x)−◦(L[[P ]] ⊗1)	L	L
−−−−−−−−−−→ [G]
D

[Υ: Γ, p(t)] −−−−−−−−−−−−→ [G]
~	[Υ : Γ,ν(L[[P ]]μ[t/x] ⊗ 1)] −→ [G]	L

Observe that focus will be lost due to the delay.
Finally, we observe that we could have followed [14] and simply unfold fixed points. Then, in order to verify properties of the systems, one can adopt a two level approach as in [7] and use a meta-level tool, like Abella [6], in order to prove properties by co-induction.
Theorem 4.12 (Adequacy – fixed points) Let P be a process and Δ be a set of non-logical axioms. Then, for any constraint c,
P ⇓c iff [Δ : ·], L[[P ]]μ −→ c ⊗T is provable in μILL.
The discussion of the levels of adequacy is the same as done in the precedent sections.
Related work and concluding remarks
We presented a new translation of CCP systems into linear logic. We showed that, by using a focusing discipline, one is able to have a complete control of concur- rent processes via logic, closing for good the connection between proof theory and constraint systems.

The chosen translation is simpler than the one presented in [16]. In fact, here we do not make use of subexponentials [3], and we show that focusing is responsible, alone, for the strongest possible level of adequacy. However, it is not possible to deal with different CCP-flavors (e.g., epistemic, spatial and temporal extensions of CCP) using only focusing: for that the subexponentials are needed. Also, differently from [16], here we have explored different aspects of computation. In particular, we dealt with non-determinism and we showed how to control the traces due to the interleaving of processes. We also studied in a deeper detail how the synchronization of agents can be better controlled, as well as how to deal with procedure calls via fixed points.
It is worthy noticing that in [14] the authors used subexponentials for reason- ing about sequential programs, while in [16] we used subexpontentials for handling modalities in CCP systems. Here we do not use subexponentials, keeping the trans- lation simpler and more natural.
We plan to use the logical semantics presented here to derive optimization pro- cedures for CCP interpreters. In particular, our characterization of positive and negative actions in lcc may allow us to “sequentialize” part of the code. This is useful to reduce the number of suspended threads in an execution of a CCP- program. We also plan to extend the encodings presented here for timed extensions of CCP [13]. Finally we want to make the full use of fixed points, adding verification of properties that can be proved using co-induction. Since μMALL is implemented in the system Bedwyr (http://slimmer.gforge.inria.fr/bedwyr/), we can use all its machinery in order to specify and verify properties of lcc systems.
Another research direction would be to consider higher-order processes as those in [20]. This can be handled by fixpoints characterization of procedure calls as done in Section 4.4. For completeness of the resulting focusing system, however, we need to restrict the system to quasi-ﬁnite derivations: derivations having a finite height and using a finite number of different co-invariants, as done in [2]. This shall allow us to deal with properties like bisimulation and liveness in lcc.

References
Jean-Marc Andreoli. Logic programming with focusing proofs in linear logic. J. Log. Comput., 2(3):297– 347, 1992.
David Baelde. Least and greatest fixed points in linear logic. ACM Trans. Comput. Log., 13(1):2, 2012.
Vincent Danos, Jean-Baptiste Joinet, and Harold Schellinx. The structure of exponentials: Uncovering the dynamics of linear logic proofs. In Kurt G¨odel Colloquium, pages 159–171, 1993.
Frank S. de Boer, Maurizio Gabbrielli, Elena Marchiori, and Catuscia Palamidessi. Proving concurrent constraint programs correct. ACM Trans. Program. Lang. Syst., 19(5):685–725, 1997.
Fran¸cois Fages, Paul Ruet, and Sylvain Soliman.	Linear concurrent constraint programming: Operational and phase semantics. Inf. Comput., 165(1):14–41, 2001.
Andrew Gacek.  The Abella interactive theorem prover (system description).  In A. Armando,
P. Baumgartner, and G. Dowek, editors, Proceedings of IJCAR 2008, volume 5195 of Lecture Notes in Artificial Intelligence, pages 154–161. Springer, August 2008.
Andrew Gacek, Dale Miller, and Gopalan Nadathur. A two-level logic approach to reasoning about computations. J. Autom. Reasoning, 49(2):241–273, 2012.

Jean-Yves Girard. Linear logic. Theor. Comput. Sci., 50:1–102, 1987.
R´emy Haemmerl´e. Observational equivalences for linear logic concurrent constraint languages. TPLP, 11(4-5):469–485, 2011.
Radha Jagadeesan, Gopalan Nadathur, and Vijay A. Saraswat. Testing concurrent systems: An interpretation of intuitionistic logic. In Ramaswamy Ramanujam and Sandeep Sen, editors, FSTTCS, volume 3821 of Lecture Notes in Computer Science, pages 517–528. Springer, 2005.
Chuck Liang and Dale Miller. Focusing and polarization in linear, intuitionistic, and classical logics.
Theor. Comput. Sci., 410(46):4747–4768, 2009.
Dale Miller and Alexis Saurin. From proofs to focused proofs: A modular proof of focalization in linear logic. In Jacques Duparc and Thomas A. Henzinger, editors, CSL, volume 4646 of Lecture Notes in Computer Science, pages 405–419. Springer, 2007.
M. Nielsen, C. Palamidessi, and F. Valencia. Temporal concurrent constraint programming: Denotation, logic and applications. Nordic Journal of Computing, 9(1):145–188, 2002.
Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Ant´onio Porto and Francisco Javier L´opez-Fraguas, editors, PPDP, pages 129–140. ACM, 2009.
Vivek Nigam and Dale Miller. A framework for proof systems. J. of Automated Reasoning, 45(2):157– 188, 2010.
Vivek Nigam, Carlos Olarte, and Elaine Pimentel. A general proof system for modalities in concurrent constraint programming. In Pedro R. D’Argenio and Herna´n C. Melgratti, editors, CONCUR, volume 8052 of Lecture Notes in Computer Science, pages 410–424. Springer, 2013.
Carlos Olarte, Vivek Nigam, and Elaine Pimentel. Dynamic spaces in concurrent constraint programming. Electr. Notes Theor. Comput. Sci., 305:103–121, 2014.
Carlos Olarte, Camilo Rueda, and Frank D. Valencia. Models and emerging trends of concurrent constraint programming. Constraints, 18(4):535–578, 2013.
Prakash Panangaden, Vijay A. Saraswat, Philip J. Scott, and R. A. G. Seely. A hyperdoctrinal view of concurrent constraint programming. In J. W. de Bakker, Willem P. de Roever, and Grzegorz Rozenberg, editors, REX Workshop, volume 666 of Lecture Notes in Computer Science, pages 457–476. Springer, 1992.
Vijay Saraswat and Patrick Lincoln. Higher-order Linear Concurrent Constraint Programming. Technical report, 1992.
Vijay A. Saraswat. Concurrent Constraint Programming. MIT Press, 1993.
Vijay A. Saraswat, Martin C. Rinard, and Prakash Panangaden. Semantic foundations of concurrent constraint programming. In David S. Wise, editor, POPL, pages 333–352. ACM Press, 1991.
Dana S. Scott. Domains for denotational semantics. In Mogens Nielsen and Erik Meineche Schmidt, editors, ICALP, volume 140 of LNCS, pages 577–613. Springer, 1982.
Gert Smolka. A foundation for higher-order concurrent constraint programming. In J.-P. Jouannaud, editor, Proceedings of Constraints in Computational Logics, volume 845 of LNCS, pages 50–72. Springer-Verlag, 1994.
