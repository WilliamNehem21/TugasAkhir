

Electronic Notes in Theoretical Computer Science 260 (2010) 243–259
www.elsevier.com/locate/entcs

Automated Computing of the Maximal Number of Handled Clients
for Client-Server Systems
P. Vaˇrekov´a, I. Vaˇrekov´a and I. Cˇern´a 1 ,2
Faculty of Informatics, Masaryk University Brno, Czech Republic

Abstract
In many real software systems like Client-Server systems, one can identify a stable part (server, instance handler, control component) and a number of uniform components of the same type (clients, instances, users). When analysing performance and correctness of these systems we need to answer questions like ”What is the maximal possible number of clients which can be handled simultaneously?” or more generally ”What is the maximal possible number of clients which are in the some special situation when the control component is in a particular state?”. In the paper we propose an automated technique solving such questions. For Client-Server systems we reduce the problem of finding the upper bound on the number of handled clients to the formal verification of reachability properties in infinite state transition systems.
For the verification task we propose an efficient and fully automated algorithm which combines several techniques proposed in existing literature. Applying the algorithm we verify models of several previously published systems.
Keywords: Client-Server systems, formal verification, infinite state systems, component-based system analysis.


Introduction
The Client-Server computing model is a popular concept and many Internet and database applications are based on this model. Although this concept can be applied to many different kinds of applications, the architecture remains fundamentally the same. It distinguishes client applications from server applications where a client can communicate only with the server. In Client-Server systems the number of clients changes in time but the number of servers is fixed. This fact causes that there can be large differences between the behaviour of the system with different number of clients. Therefore it is important to understand how the behaviour of

1 Email: {xvareko1,xvareko2,cerna}@fi.muni.cz
2 The authors have been supported by grant No. 1ET400300504 and No. 1ET408050503.

1571-0661 © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.041

the system depends on the number of deployed clients. One of the many important questions is What is the maximal possible number of clients which are in the same special situation when the control component is in a particular state? From this information we can deduce which features of the system will be affected when the number of deployed clients increases or how many servers are necessary in a system if the expected number of clients is known.
In the paper we propose an algorithm which answers the type of questions which is mentioned above. The algorithm comes out from formal verification. The Client- Server system under the study is described using a formal language. We model separately the client part and the server part of the system. The model of the server can be composed from any fixed number of subparts modelling individual servers in the original system. The algorithm works with the model composed of an arbitrary number of client models and one model of the server. For this model, in the literature called parameterised system model, the problem of finding the maximal number of clients can be reduced to the problem: Compute the maximal k such
that a state in which k clients and the control component are in a specific states simultaneously is reachable in the model. Note, that our algorithm can be used for any system consisting of two types of components – a stable component and an unknown number of uniform components of the same type.
The proposed algorithm is based on techniques from the parametrised systems verification, consequently we use the terminology from this field [13,10]. Therefore the systems which we study in the paper are denoted as control-user systems. The part of the system which is unique (server in Client-Server systems) we call control component and the parts of the system with an identical model (clients in Client- Server systems) we denote user components or users. The algorithm is based on an over-approximation of the set of reachable states in a similar way as the algorithm presented in [22]. The main improvement comparing to [22] is a reduction of the computational time and space required by the algorithm. In the paper we demon- strate its efficiency on a case study. Section 2 introduces the Control-User model. Section 3 presents and formalises the problem which we solve. Section 4 describes the algorithm while the following section its evaluation. Section 7 summarises the results and outlines the aims for future work.

The Control-User System Model
In the paper we consider systems which consist of a unique control component and an arbitrary number of user components with an identical model. An example of such a system with n users (Tokens) is in Figure 1. Components in the systems are executing concurrently with the interleaving semantics, capturing that a com- ponent can communicate with another component using the pairwise rendezvous synchronisation (a component can send a message iff the receiver is enabled). As a formal model of a Control-User system we use a labelled Kripke structure. A labelled Kripke structure is a model underlying many formalisms capturing interac- tions between parts of the system like I/O automata [17], Component-Interaction

Automata [24,6], or Extended Behavior Protocols [16].
Definition 2.1 (LKS). A labelled Kripke structure (LKS ) is a 6-tuple (Q, I, Ap, L, Σ, δ) where Q is a set of states, I ⊆ Q is a set of initial states, Ap is a set of atomic propositions, L : Q → 2Ap is a state-labelling function, Σ is a finite set of actions and δ ⊆ Q × Σ × Q is a transition relation.
We suppose that Σ = Σint ∪ Σout ∪ Σinp, where Σout = Σ′out × {!}, Σinp = Σ′inp × {?}. The alphabets Σout resp. Σinp represent output resp. input actions which can be used for pairwise rendezvous communication between LKSs. The alphabet Σint represents internal actions. We write q → q′ if there is a label l ∈ Σ such that (q, l, q′) ∈ δ, →∗ is the transitive and reflexive closure of →. A state q is reachable iff in →∗ q for some in ∈ I. Let q = (q0, . . . , qn) be an n + 1-tuple. Then pri(q), i = 0, . . . , n, denotes its i+1-th projection, pri(q) = qi.
In this paper we restrict ourselves to systems in which the models of the control and user component are finite and have one initial state. Thus LKSs C  = (QC, {inC }, ApC , LC, ΣC , δC), U  = (QU , {inU }, ApU , LU , ΣU , δU ) form a
Control-User model (or C-U model for short) if and only if QC, QU , ΣC, and ΣU are finite.
LKSs can be composed and their composition models the pairwise rendezvous synchronisation of the LKSs. The full composition models such a system without any additional restriction of communication.
Definition 2.2 (Full composition). Let n ∈ N0 and for each i = 0, . . . , n let Ki = (Qi, Ii, Api, Li, Σi, δi) be an LKS. Then K0 ⊗ · · · ⊗ Kn denotes the full com- position of K0, . . . , Kn which is modelled by the LKS
(Q0 × · · · × Qn, I0 × · · · × In, (Ap0 ×{0}) ∪ · · · ∪ (Apn×{n}), L, Σ, δ),
where the state-labelling function L assigns to each state (q0, . . . , qn) the set

n
i=0
Li(qi) × {i}.	The set of atomic propositions Σ = Sn
Σi	∪	{l | l ∈

n i=0
Σ′i,inp
∧ l ∈ Sn
Σ′i,out
}. The transition (q, l, q′) ∈ δ iff it holds

(internal step of Ki) ∃i ∈ {0, . . . , n}: ∀j ∈ {0, . . . , n}, j /= i :
prj(q) = prj(q′), and (pri(q), l, pri(q′)) ∈ δi, or
(rendezvous step of Ki and Ki′ )
∃i, i′ ∈ {0, . . . , n}, i /= i′ : ∀j ∈ {0, . . . , n}, i /= j /= i′ : prj(q) = prj(q′),
(pri(q), (l, ?), pri(q′)) ∈ δi, and (pri′ (q), (l, !), pri′ (q′)) ∈ δi′ .
In many systems we use the handshake composition. This composition capture that: a composed component can not make an external action satysfying that, another composed component is able to offer a counterpart of the external action.
Definition 2.3 (Handshake composition). Let n ∈ N0 and for each i = 0, . . . , n let Ki = (Qi, Ii, Api, Li, Σi, δi) be an LKS. Then K0  . . . Kn denotes the handshake composition modelled:
(QK0⊗···⊗Kn , IK0⊗···⊗Kn , ApK0⊗···⊗Kn , LK0⊗···⊗Kn , Σ, δ), where



Fig. 1. Internet payment system with n Tokens, modelled by Cex Un .
Σ = ΣK0⊗···⊗Kn \ Handshake, here
Handshake = {(l, !), (l, ?) | ∃i1, i2 ∈ {0, . . . , n} : l ∈ Σ′Ki ,out ∧ l ∈ Σ′Ki ,inp}
1	2
(q, l, q′) ∈ δ iff (q, l, q′) ∈ δK0 ⊗···⊗Kn and l ∈ Σ.
A C-U system with n clients is modelled as the composition of n + 1 LKSs where the first LKS stands for the control component while the others are identical and represent the users. A Control-User system with arbitrary many clients is modelled as the union of LKSs modelling systems with n clients, for all n ∈ N.
Definition 2.4 (C  Un, C U ∞). Let C, U be a C-U model, n ∈ N. Then C  Un
denotes the composition C U  · · · U of C and n copies of U . C  U ∞ is an infinite state LKS defined
C  U ∞ = ( S QC  Un , S {inC  Un }, S ApC  Un, S LC  Un, S ΣC  Un, S δC  Un ).
n∈N	n∈N	n∈N	n∈N	n∈N	n∈N
Remark 2.5 For simplicity we allow that there can be a communication between clients. The proposed algorithm can be used for such systems, but we did not find any interesting example of a CU-system which uses this type of communication.
Example 2.6 As a running example we present a part of a model of the prototype implementation of a payment system for public Internet access on airports [1]. It models a system where clients (represented as instances of the component Token) of several air-carriers can have access to the Internet. Clients have to authenticate themselves or pay for the service before the system permits them to establish com- munication with the Internet. There are two types of sessions - the prepaid session and free session (for clients with a valid fly ticket for first class or business class).
In the model, to each method, e.g. createPrepaidToken(), is assigned a tu- ple of action names: createPrepaidToken denotes the call of the method, and createPrepaidToken’ the return from the method. These two determine the beginning and the end of the method’s execution. In the models we abbreviate the name of the method tokenInvalidated() to tI, adjustPrepaidTime() to aPT, createPrepaidToken() to cPT, invalidateAndSave() to iAS, and createFreeToken() to cFT.
The payment system (control component) models three independent methods and hence its model consists of three independent parallel parts. The first of them is able to receive an information that a Token is invalid (the terminating phase of an Internet session is successfully finished). The second is for changing the prepaid time during the invalidation of the Token. The last is for creating a Token (it represents the start of an Internet session) and for starting of invalidation of the Token (it represents termination of the session). An LKS model of the control component



(cPT,!
J,r˜¸,, `21z,
(cPT′,?)


(cPT,!
J,r˜¸,, `24z,
(cPT′,?)

J,p˜¸`2z,¸,
(tI,?)	// ,J¸˜p:`,\
	J,q˜¸`2z,¸,
(aPT,?)	// ,J¸˜q:`,\
		//J,r˜¸`2 J z,,¸
(iAS,!)	//J,r˜¸`2 J z,

,,0
(tI′,!)
1	,,0
1
(aPT′,!)
,, 0
(iAS′,?)
,, 2

(cFT′,?
(cFT,!)
J,r˜¸`23 J z,
(cFT′,?
(cFT,!)
J,r˜¸`25J z,

Fig. 2. LKS Cex modelling Internet payment system.

,J¸’*-,z (tI,!) //,J¸’*-,z(tI′,?)//,J¸’*-,z
,J¸’*-,z¸,(tI′,?),J¸’*-,z¸,
(tI,!)
,J¸’*-,z

¸,E	F
G,,	A	9
8 ,¸¸¸	′

ııı
ııı
,,,
,,
(iAS′,!)ııı
ııı
¸ (aPT ,?)
¸¸¸

(iAS,?) ı
6¸,J¸’D*-,z¸
′  ,,
ıı ,J¸’5*-,z,¸
,J¸’4*-,z¸,
,J¸’3*-,z
,J¸’7*-,z

ıı	,,,
¸¸¸ (iAS ,!) ,
ı	}	(tI,!)
(aPT′,?)
,¸¸¸
¸,¸¸

ıı	,,,,,
¸¸¸¸¸	,,	ıı }}}
¸¸¸(aPT,!)
¸¸¸(aPT,!)

ıı ,,,(tI,!)
,J¸’C*-,z,¸,
,J¸’B*-,z¸,
(tI′,?) ¸¸¸¸ ,,tz J ıı,s ı}}}(tI′,?)
0	1
¸¸¸
//,J¸’2*-,z
¸¸¸
//,J¸’6*-,z

(cFT′,!)
(cFT,?)
(cPT,?)
(cPT′,!)
(iAS,?)

Fig. 3. LKS Uex modelling Token.
Cex is depicted in Figure 2. Its set of atomic propositions ApCex is {active}. The only state in which the atomic proposition does not hold is (p0, q0, r0).
The Token (user component) models a client of the system. At first a client must be initialised and then it models an initialised Internet session. There are two possi- bilities how to terminate an existing session - a client (Token) terminates the session or the system terminates the session (because the prepaid time is used up or fly ticket becomes invalidated). If the client terminates the session, then after some time the control component detects it and sends to the Token the action InvalidateAndSave. After that, if the session is prepaid, the Token changes the prepaid time (actions adjustPrepaidTime, adjustPrepaidTime’). Subsequently the Token announces that it is invalidated (actions tokenInvalidated, tokenInvalidated’) and re- turns InvalidateAndSave’. If the system terminates the session, if the session is prepaid, the system changes the prepaid time (actions adjustPrepaidTime, adjustPrepaidTime’. Subsequently the Token announces that it is invalidated (actions tokenInvalidated, tokenInvalidated’).
The user component Uex is depicted in Figure 3.  Its atomic propositions are ApUex  = {finishing Session, free Session, prepaid Session, served}.  For each q ∈ {C−G} the set LUex (q) contains free Session, for q ∈ {2−A} it moreover contains prepaid Session, for q ∈ {3 − 5, 7 − A, D − G} it moreover contains finishing Session, for q ∈ {0, 2, 4, C} it moreover contains unserved ( the method A was called, but the complement A′ has not been received yet).  For example LUex (C) =
{free Session, unserved} and LUex (7) = {prepaid Session, finishing Session}.
Remark 2.7 Note that systems with more than one type of users can be modelled as C-U models as well. More precisely, the C-U model can represent an arbitrary system with a control part and a finite number of distinct types of users. The model of a user is an LKS which in the initial state non-deterministically chooses one of the given behaviours and after that it behaves like the choosen type of user. For example in the model of Internet payment system a Token (user component) first chooses whether it will behave as a client with prepaid or free access to Internet.

The bounding problem
In this section we formally describe the problem which we solve in the paper and we show its motivation on the model of a payment system which is introduced in the previous section.


Motivation

During analysis of C-U systems we are often interested in the maximal possible number of users which can be simultaneously in the same state when the control component is in a particular situation.

Example 3.1 For the model of payment system from Example 2.6 we show several interesting properties of the described form.
It is clear that this C-U system should satisfy that the number of clients which can be connected to the Internet simultaneously is not bounded, or it is bounded by an integer greater than a number of possible clients (e.g. 1010).
If the number of Tokens which use an initialised session increases, than obviously the amount of time that is necessary for finishing the session (from starting to accomplishing the finishing phase) may increase too. It is because the number of initialised Tokens which want to finish their session at the same time may increase and thus the time necessary for starting the finishing phase may increase too.
The interesting question is: If a client successfully starts the finishing phase, then the time necessary to accomplishing the finishing phase may increase too? This time may increase iff the number of clients which can be in the middle of a session is not bounded. It can happen that the other clients in the finishing phase can be served before the selected client and thus the selected client must wait.
Because there is always a possibility that for some unpredictable reason the payment system shuts down without any log message, it is important to know how many Tokens can be in the middle of a communication with the payment system simultaneously. A Token is in the middle of a communication if it has sent a request and is waiting for a respond or if the system sent a request to the Token and it is waiting for a response.
Consequently for the model of the payment system it is interesting to know the maximal number of Tokens which are simultaneously in the following situations:
are using (arbitrary/prepaid/free) session?
started finishing of their (arbitrary/prepaid/free) session, but the finishing phase is not completed?
are in the middle of a communication with the payment system?

l-symmetric reachability properties
In this part we define auxiliary terms which are used in the formal definition of the problem solved in the paper - reachability properties of C-U model and l-symmetric reachability properties.
Formulae of the propositional logic are defined over a set of atomic propositions with the help of standard Boolean operators ∧, ∨, ¬. A propositional formula is interpreted over a state of an LKS. A formula is true in a state iff after evaluating all atomic proposition assigned to the state as true and all others as false the result formula is true. A reachability property (or RP for short) is a property capturing that a state satisfying a given propositional formula is reachable in the system. The general reachability problem for C-U models can be formulated as:
Instance (reachability):
a C-U model C, U
{ϕn}n∈N, where ϕn is a formula of the propositional logic over ApC  Un .
Problem:
Is there n ∈ N such that a state satisfying ϕn is reachable in C  Un?
There are special sets of reachability properties which make no distinction among users – so called 0-symmetric RP, 1-symmetric RP, etc. For fixed l ∈ N0 and any n ∈ N, an l-symmetric RP (or l-SRP) guarantees that if a state q ∈ QC  Un satisfies ϕn, then there are l users which together with the control component ensure that the state q satisfies ϕn. An instance of the l-symmetric reachability problem is:
Instance (l-symmetric reachability):
a C-U model C, U, a number l ∈ N0
a sequence of l-symmetric formulae {ϕn}n∈N, where for each n ∈ N:

ϕn =	_
f :{1,...,l}→{1,...,n}

ψ(1,f (1)),...,(l,f (l)).


Here ψ is a formula of the propositional logic over atomic propositions LC ×
{0} ∪ LU × {1} ∪ · · · ∪ LU × {l}, f is an injective function, and ψ(1,f (1)),...,(l,f (l)) is the formula which results from ψ if we substitute each atomic proposition (a, i) by (a, f (i)) leaving (a, 0) untouched. We say that ψ is the propositional formula underlying {ϕn}n∈N.
Example 3.2 l-symmetric RPs of the C-U model from Example 2.6 (inspired by the properties from Example 3.1) are e.g. properties describing reachability of a state satisfying:
m (or more) Tokens are connected to the payment system simultaneously. It is an m-SRP with the underlying formula ψ = (prepaid Session, 1) ∨ (free Session, 1) ∧ · · · ∧ (prepaid Session, m) ∨ (free Session, m).
m Tokens are finishing their free session simultaneously and the payment system is active.  It is an m-SRP and the underlying formula ψ  =

(active, 0)∧(finishing Session, 1)∧(free Session, 1)∧· · ·∧(finishing Session, m)∧
(free Session, m).
m Tokens can be finishing their prepaid session simultaneously and the pay- ment system is active. It is an m-SRP and the underlying formula ψ = (active, 0) ∧ (finishing Session, 1) ∧ · · · ∧ (finishing Session, m).
m Tokens are serviced by the payment system simultaneously. It is an m-SRP and the underlying formula ψ = ¬(unserved, 1) ∧ · · · ∧ ¬(unserved, m).
m prepaid Tokens are serviced by the payment system simultaneously. It is an
m-SRP and the underlying formula ψ = ¬(unserved, 1) ∧ (prepaid Session, 1) ∧
· · · ∧ ¬(unserved, m) ∧ (prepaid Session, m).

Instance of the problem
The question ”what is the maximal possible number of users which can be simulta- neously in the same state when the control component is in a particular situation” can be described using a sequence of l-symmetric properties {Pm}m∈N such that for each m the property Pm = {ϕm}n∈N is an m-symmetric RP expressing that: It is
possible to reach a global state in which at least m users are simultaneously in the same state when the control component is in a particular situation.
If for some j > i it holds that j users together with the control component are in the specified setting, it usually means that i of the j users are together with the control component in the particular setting to. Thus the sequence of underlying formulae ψ1, ψ2, ... of P1, P2, ... often satisfies that ψj ⇒ ψi is true for every j > i. The next lemma clearly follows from the definitions:
Lemma 3.3 Let {Pm}m∈N be a sequence where every Pm is an m-symmetric RP with an underlying formula ψm. Let the implication ψj ⇒ ψi be true for every j > i. Then if C  U ∞ satisfies Pj then it also satisfies Pi for each j > i.	(*)
Note that an equivalent to the condition (*) is the requirement: if C  U ∞ does not satisfy Pi then it does not satisfy Pj for any j > i. Consequently if a sequence of RP {Pm}m∈N satisfies the assumption of Lemma 3.3 then maximally one number b satisfies that Pb holds and Pb+1 does not hold. Thus in such cases one of the following conditions is fulfilled:
none of properties {Pm}m∈N holds,
there exists b ∈ N such that Pm for m ≤ b holds and Pm for m > b does not hold
each of properties {Pm}m∈N holds,
Thus the problem which we solve in the paper can be transformed to the task to find the number b such that Pb is satisfied and Pb+1 is not satisfied (if it exists) for a given sequence of RPs. We call this value bound. In practise we often have a number Max and the question is whether bound is at most Max. Only if this is true we want to know the exact value of bound. The task which we study can be described as
Instance:
— a C-U model C, U, number Max ∈ N

— a sequence {Pm}m∈{1,...,Max}, where Pm is an m-symmetric RP satisfying (*)
Problem: Compute
0	if  P1 is not  satisfied ,
Max	if  PMax is satisfied .

Verification algorithm
Verification of k-symmetric properties is decidable [3,4,11,13] and there are several algorithms for verification of k-symmetric properties. Thus it is possible to solve the bounding problem using some of the previously published verification algorithms and iteratively verify properties P1, P2, . . . , Pmin(Max,bound+1). If the algorithm is based on backward reachability [3,14,15,18,21] the number of steps used for verifi- cation of an k-symmetric RP is linear in k and the number of conditions needed for describing the set of backward reachable states is exponential in k. In case of al- gorithms based on cutoffs [13,9,22], invisible invariants [5,12,19,20], or abstractions [7,8,23] the space complexity of verification of a satisfied k-symmetric RP is expo- nential in k. Thus the proposed solution based on iterative verification of properties is acceptable only when bound or Max is small. In other cases the approach is not efficient.
The main purpose of this paper is to propose an algorithm which efficiently finds bound for C-U models of real Client-Server systems. The algorithm which we describe is an improved version of the algorithm from [22]. For a comparison of the two algorithms see Related work.
To describe the algorithm we first define so called k+1-tuples. k+1-tuples serve as an abstraction of a C-U model state where the local states of exactly k chosen users in an arbitrary order are maintained.
Definition 4.1 (k+1-tuple assigned to q). Let C, U be a C-U model, and k ∈ N0. Then a k +1-tuple (qC , q1, . . . , qk) ∈ QC  Uk is assigned to the state q ∈ QC  U∞ iff the local state of C in q is qC and there are k different users in q with local states q1, . . . , qk.
In a similar way we can assign a k+1-tuple to a (k+i)+1-tuple t.
Example 4.2 For example to the tuple ((p1, q0, r3), 0, 2, D, G, 1, A, B) where Cex , Uex is described in Example 2.6 are assigned 3 + 1-tuples ((p1, q0, r3), 0, 2, D), ((p1, q0, r3), D, 0, G), ((p1, q0, r3), B, A, D), etc.
The paper [22] proposes the procedure Reachable l+1-tuples which for input parameters C, U, k computes all k + 1- tuples reachable in C  U ∞. For the space reasons we do not describe the procedure here.
Verification using k + 1-tuples
Let Pk = {ϕn}n∈N be a fixed sequence describing a k-symmetric RP, with the underlying formula ψ. For an arbitrary i ∈ N0 a state q ∈ QC  Ui satisfies ϕi iff



Fig. 4. The sets of b+1-tuples All b, Unreach b, Reach b, and Unreach b k.
there is a k+1-tuple t assigned to q such that t (which is a state of C  Uk) satisfies ϕk = ψ. Hence if we find all k+1-tuples assigned to the reachable states of C  U ∞ (so called reachable k+1-tuples of C  U ∞ denoted Reach k) we can easily verify the validity of a given k-symmetric RP. Consequently we can easily make the procedure Is k − 1 Bound which from the sets of all reachable states Reach k, Reach k + 1 computes whether k is bound.

Procedure 1 Is k − 1 Bound(Reach k, Reach k+1, Pk, Pk+1, k)
Reach k = Reachable l + 1-tuples (k)
if not exists t	Reach k satisfying Pk then return false Reach k = Reachable l + 1-tuples (k + 1)
if exists t	Reach k +1 satisfying Pk+1 then return false
return true

Over-approximation of reachable k+1-tuples
The computational time and space used in Reachable l + 1-tuples for computa- tion of the set Reach b is exponential in b. Thus it is inefficient for a high integer b. On the other hand as it is written in [22] the set can be efficiently over-approximated. The main idea is that if we have a high integer b, we can choose a small integer k and under-approximate the set Unreach b of all unreachable b+1-tuples of C  U ∞ by the set Unreach b k of all b+1-tuples to which is assigned an unreachable k+1- tuple of C  U ∞ (see Figure 4). The profit is that to compute Unreach b k instead of Unreach b it is necessary to find Reach k instead of Reach b. The set Unreach b k can also be used for computing an over-approximation of all reachable b + 1-tuples of C  U ∞. Let us denote All b the set of all possible b + 1-tuples of C  U ∞. Then the set of all reachable b + 1-tuples of C  U ∞ can be over-approximated using the set Reach b k = All b \ Unreach b k of all b+1-tuples to which is not assigned an unreachable k+1-tuple of C  U ∞ (see Figure 4).
This over-approximation of Reach b can be used to over-approximate bound and to compute a candidate for the bound - the minimal number x such that that Reach x k contains an x+1-tuple satisfying Px and Reach x+1 k does not contain an (x+1) + 1-tuple satisfying Px+1. From the fact that Reach x+1 ⊆ Reach x+1 k it follows that bound must be smaller or equal to x. This idea is used in the procedure Last Satisfied. Several optimisations of the procedure are possible and are employed in our implementation.

Verification of a candidate for bound
In some cases we need to check whether a k-symmetric property (where k is a high number) is satisfied and we know that it is highly probable that the property is satisfied. In these cases, verification using the set of all k+1-tuples is inefficient and



Procedure 2 Last Satisfied(Unreach k , k, Max, {Pi}k≤i≤Max )	
x := k + 1
repeat
Reach k x := all tuples which does not contain a tuple in Unreach k
if does not exists t Reach k x satisfying Pk then return x	1
x := x + 1 until x	Max return Max
verification using an over-approximation of the reachable k+1-tuples is inapplicable. We propose an efficient algorithm for this task. The algorithm is based on the following observation:
A state q to which is assigned (qC, q1, . . . , qk) ∈ Reach k is often reachable by a path, which has k+1 parts such that for some injective function i : {1, . . . , k} →
{1, . . . , k} it holds:
1: In the first part, only user 1 and the control component perform actions. User 1 is in the state qi(1) after this part of the path.
2:  In the second part, only user 2 and the control component perform actions.

...
User 2 is in the state qi(2) after this part of the path.

k: In the k − th part, only user k and the control component perform actions.
User k is in the state qi(k) after this part of the path.
k+1:	In the k + 1 − th part, only the control component and users k + 1, . . . ,
perform actions. The control component is in the state qC after this part of the path.
p1 → p2 → · · · → pi1 → pi1 +1 → · · · → pi2 → · · · → pik−1 +1 → · · · → pik → pik+1 → · · · → pik+1 = q
` user 1 and c˛o¸ntrol comp. x `user 2 and c˛o¸ntrol comp.x	` user k and c˛o¸ntrol comp. x u`sers k+1, ..., a˛n¸d control comxp.
Example 4.3 Consider the C-U model from Example 2.6. A state to which is assigned 3+1-tuple ((p1, q0, r1), 2, 0, D) is reachable by the path:

cFT
cFT′
iAS

((p0, q0, r0), 0, 0, 0, 0) → ((p0, q0, r1), 0, 1, 0, 0) → ((p0, q0, r0), 0, 2, 0, 0) →

tI	tI′
cFT

((p0, q0, r3), 0, 2, B, 0) → ((p0, q0, r0), 0, 2, C, 0) → ((p1, q0, r0), 0, 2, D, 0) →
((p1, q0, r1), 0, 2, D, 1)
We generalise this observation.	For a value parallel ∈ {1, . . . , k} the sign

k parallel
denotes the set of all paths in C  U ∞ such that each path in Pathk

has k + 2 − parallel parts (see Figure 5):
1:  In the first part, only users 1, . . . , parallel and the control component perform

...
actions.

k + 1 − parallel: In the k + 1 − parallel-th part, only users k + 1 − parallel, . . . ,
k and the control component perform actions.
k + 2 − parallel: In the k + 2 − parallel-th part, only users k + 2 − parallel, . . .
and the control component perform actions.
Example 4.4 Consider	the	C-U	model	from	Example	2.6	and	2 + 1- tuple ((p1, q0, r3), B, 0).		No state of the form ((p1, q0, r3), B, 0, q1′ , . . . , qf′ ) or
((p1, q0, r3), 0, B, q1′ , . . . , q′ ) is reachable by a path in Path2. It is because Path2
f	1	1



Fig. 5. Illustration of parts of a path in Pathk	.
contains only paths which can be divided into three parts – in its first part only user 1 and the control component perform actions, in its second part only user 2 and the control component perform actions, and in the third part only users 3, . . . , and the control component perform actions. Thus if it exists a path in Path2 satysfyig these conditions, then the first state of its third part satisfies that the user 1 is in state B and the user 2 is in the state 0 (or vice versa), all other users are in state 0, and the control component is in state (p0, q0, r3) or (p0, q0, r5). Consequently in the next steps of the path no user with name greater than 1 is able to start its prepaid or free session. Hence the control component can not move to the state (p1, q0, r3). On the other hand, ((p1, q0, r3), 0, B, D) is reachable by the finite path in Path2:

cFT
cFT′	tI

((p0, q0, r0), 0, 0, 0) → ((p0, q0, r3), 0, 0, B)
((p , q , r ), 0, 0, D) c→FT ((p , q , r ), 0, B, D)
→ ((p0, q0, r0), 0, 0, C) →


For a given value parallel we denote Reach k parallel the set of all k + 1- tuples (qC, q1, . . . , qk) such that for some f ≥ k and an injective function i :
{1, . . . , k} → {1, . . . , k} a state (qC, i(q1), . . . , i(qk), q1′ , . . . , qf′ ) is reachable by a

path in Pathk
. This set is an under-approximation of the set Reach k and

therefore it can be used for verification that a k-symmetric formula is satisfied. A computation of the set Reach k parallel can be divided into steps:
1-st step: A computation of all possible states (qC, i(q1), . . . , i(qk), q1′ , . . . , qf′ ) reach-

able after the first part of a path in Pathk
we traverse the state space of C Uparallel.
. This part can be computed if

i-th step for i ∈ {2, . . . , k + 1 − parallel}: A computation of the set of all possible states (qC, i(q1), . . . , i(qk), q1′ , . . . , qf′ ) reachable after the i-th part of a path

k parallel
from the set of states computed in the i − 1-th step. It can

be computed if we several times traverse the state space of C  Uparallel with changed sets of initial states.
k + 2 − parallel-th step: A computation	of	the set	of	all	possible states (qC, i(q1), . . . , i(qk), q1′ , . . . , qf′ ) reachable after k + 2 − parallel-th part of a path

k parallel
from the set computed in the previous step. It can be computed

if we find all reachable parallel+1-tuples in C  U ∞ with a different set of initial

states.
To sum it up, in the computation it is enough for each q ∈ QC  Uparallel to generate the state space in C  Uparallel reachable from q and to compute Reach (parallel − 1) in a model C  U ∞ with a different set of initial states. Thus the number of traversed states during this computation is constant in k and exponential in parallel. The number of traversed states during a computation of Reach k is exponential in k, thus for parallel ≪ k the required space necessary for computing Reach k parallel is smaller that the required space necessary for computing Reach k. Thus in cases described at the beginning of this subsection it is effective to search whether a tuple satisfying the k-symmetric property is in Reach k 1, then in Reach k 2, . . . , Reach k k. All these facts are is used in the procedure Is Satisfied. Several optimisations of the procedure are possible and are employed in our implementation.

Procedure 3 Is Satisfied(C, U , Pk, k)
i := 1; n := Cutoff For l+1 Tuples(C, U , 0)
repeat
if a tuple satisfying Pk is in Reach kbi then return true i := i + 1
until i > k
Reach k := Reachable l + 1-tuples(C, U , k)

if exists t	Reach k satisfying Pk then return true
else return false


algorithm Bound

Procedure 4 Bound(C, U, Max, {Pi}1≤i≤Max )

1: k:= 0; Unreach k : = ; Reach k 1 := 2: repeat
3:	k := k+1
4:	Reach k 1 := Reach k
	
5:	Reach k := Reachable l + 1-tuples(C, U , k) 6:	Unreach k −1 := Unreach k
7:	Unreach k := all k + 1-tuples \ Reach k
8:	if Is k − 1 Bound(Reach k −1 , Reach k , Pk−1, Pk, k) then return k − 1 9:	Changes = Unreach k \ Generate Possible New(Unreach k −1 )
10: until (Changes = ∅) ∨ (k ≥ Max )
11: b := Last Satisfied(Unreach k −1 , k, Max, {Pi}k≤i≤Max ) 12: return ValidateBound(C, U , {Pi}1≤i≤Max , k, b)


Procedure 5 ValidateBound(C, U , {Pi}1≤i≤Max , k, b)

if Is Satisfied(C, U , Pb, b) then return b x := k
repeat
if	(Is Satisfied(C, U , Px, x)) then return x	1

x := x + 1 until x ≥ b return b − 1

The bounding algorithm which we propose using the previously described proce- dures computes for an input C-U system, a sequence of formulas, and Max bound. This algorithm has two main parts. In the first part the algorithm (lines 1-10) computes all reachable k + 1-tuples for increasing k until it decides that the k is large enough and the over-approximations {Reach b k}b∈{1,...,Max} of the sets
{Reach b}b∈{1,...,Max}  are sufficient.	During each iteration after computing the



Fig. 6. The value k such that Changes = ∅.

Fig. 7. Evaluation of the verification algorithm.
set Reach k for any k > 1 it computes whether k − 1 is bound (using the pre- viously computed set of reachable states Reach k−1, Reach k).  The situation in which the algorithm decides that k is large enough is when all unreachable k-tuples contain an unreachable k − 1-tuple. In other words it is exactly when Unreach k k−1 = Unreach k and this is exactly when Reach k k−1 = Reach k.
If bound is not found in the first phase of the algorithm (bound is greater than the value of k after the repeat-until cycle) then the algorithm continues (lines 11, 12). It uses the previously computed set of unreachable k-tuples and from the sets Reach k k, Reach k + 1 k, ..., Reach Max k the procedure Last Satisfied com- pute an over-approximation and a candidate for bound b. After that the procedure ValidateBound computes, which of the numbers {k+1, ..., b} is bound. Validate- Bound firstly checks whether b is bound and if it is not bound then it iteratively checks whether bound is k + 1, k + 2, ..., b − 1.

Evaluation
Table in Figure 7 displays characteristics of the proposed algorithm Bound for the model of the payment system from Example 2.6, properties from Example 3.2 and a comparison with the original algorithm published in [22]. These characteristics are: Max, bound, the number States-RT of states generated by Reachable l + 1- tuples in the procedure Bound, the number States-VB of states generated by ValidateBound in the procedure Bound (sign ”0” appears iff the procedure is not called), the number States-VB[22] of states generated by the original procedure ValidateBound from [22] 3 ( sign ”-” appears iff if the value is greater than 1020, sign ”0” appears iff the procedure is not called).
We applied the algorithm on several other C-U models of Client-Server systems and another types of component-based systems from [2]. Based on the experimental evaluation we conclude:

3 The original procedure ValidateBound uses on-the-fly method based on breadth-first search.

lines 1-10: Computational time and space of lines 1-10 of the procedure Bound is very similar to the complexity of computing Reach k, where k is the highest number for which the set Reach k is computed in the procedure Bound. For all models from [2] the value k is less then or equal to 3. Thus computational time and space of this part of the algorithm is for all studied models similar as the computational time and space of Reachable l + 1-tuples for input parameter less then or equal to 3. If bound is less then 3 the procedure Bound computes bound in the repeat-until cycle.
line 12: For all studied models the time and space required by the procedure Val- idateBound are much smaller than the time and space required by the pro- cedures in lines 1-10. Moreover an optimisation of the procedure enables us to compute whether for a given C-U model and a property the value bound is in all cases equal to Max, for all studied models and properties.
Generally, for all studied examples the time and space used in Bound is similar to the time and space of computing Reach 3 no matter how big bound is.

Example 5.1 Consider properties from Example 3.1. From their verification we can conclude:
The number of clients which can be connected via prepaid session (resp. free session) simultaneously is more than 1010.
Maximally 1 client can be finishing its free session simultaneously, and number of clients which can be finishing its prepaid session simultaneously is more than 1010.
Maximally 4 clients can be it the middle of an communication with the payment system.



Comparison with the original algorithm

The algorithm proposed in Section 4 is an extension of the algorithm [22]. The orig- inal technique uses the same algorithm for computing of the over-approximation of bound as the algorithm described in this paper (lines 1-11 of the Algorithm Bound), but for computing of bound from the over-approximation (Algorithm Validate- Bound, line 12) it does not use any optimised technique. Thus the original algo- rithm effectively solves only a part of the problem – finding the over-approximation of bound. The second part of the problem – to prove that the over-approximation is bound – is ineffective in the original algorithm. Experiments show that the computa- tional space of the original algorithm is usually exponential in bound (see Figure 7). Thus if the result bound is small (above 5 in case of Payment system) then the orig- inal algorithm from [22] and the modified algorithm proposed in this paper behave similarly. For largest bounds the original algorithm is inefficient, but the proposed algorithm behaves similarly as for small bounds.

Related work
As it is discussed in Section 4 there are several techniques which can be used for solving the problem studied in this paper (e.g. [15,12,20,7,9]). However our experi- ence shows that the computational space of those algorithms is exponential in the value bound and thus their usage for the problem described in this paper is ineffec- tive. To the best of our knowledge, there is no algorithm which can be effectively used for computing of the exact solution of the presented problem. The technique
[22] is discussed in Section 4.5.

Conclusions
In the paper we propose an automated technique for the analysis of Client-Server systems solving questions like ”What is the maximal possible number of clients which can be handled simultaneously?” or ”What is the maximal possible number of clients which want to be handled simultaneously and are in some special situation?”. The algorithm first finds an over-approximation of the maximal number and then using this approximation efficiently computes the correct result. Using the algorithm we verified models of several previously published systems and for all the systems the over-approximation found in the first part of the algorithm was the correct bound. In future, we aim to finish the implementation of the presented algorithms and evaluate the approach on a large number of realistic case studies. We also aim at
studying whether the proposed technique can be used for another problems.

Acknowledgement
The authors thank Tom´aˇs Poch for valuable comments. The authors would also like to acknowledge Pavel Moravec and Jan Hutaˇr for their contributions.

References
http://kraken.cs.cas.cz/ft/public/public_index.phtml, Accessed May 2008.
http://anna.fi.muni.cz/coin/CUmodels/, Accessed May 2008.
Abdulla, P. A., K. Cerans, B. Jonsson and Y. Tsay, General decidability theorems for infinite-state systems, in: LICS’96 (1996), pp. 313–321.
Abdulla, P. A. and A. Nyl´en, Better is better than well: On efficient verification of infinite-state systems, in: LICS’00, 2000, pp. 132–140.
Arons, T., A. Pnueli, S. Ruah, J. Xu and L. D. Zuck, Parameterized verification with automatically computed inductive assertions, in: CAV’01, LNCS 2102, 2001, pp. 221–234.
Brim, L., I. Cˇern´a, P. Vaˇrekov´a and B. Zimmerova, Component-Interaction Automata as a Verification- Oriented Component-Based System Specification, ACM SIGSOFT Software Engineering Notes 31 (2006), pp. 1–8.
Calder, M. and A. Miller, An automatic abstraction technique for verifying featured, parameterised systems, Theoretical Computer Science (2008), to appear.
Calder, M. and A. Miller, An automatic abstraction technique for verifying featured, parameterised systems, Theoretical Computer Science (2008), to appear.


Clarke, E. M., M. Talupur and H. Veith, Proving ptolemy right: The environment abstraction principle for model checking concurrent systems, in: TACAS’08, LNCS, 2008, pp. 33–47.
Emerson, E. A. and V. Kahlon, Model checking guarded protocols, in: LICS’03 (2003), pp. 361–370.
Emerson, E. A. and K. S. Namjoshi, On model checking for non-deterministic infinite-state systems, in: LICS ’98 (1998), p. 70.
Fontaine, P. and E. P. Gribomont, Decidability of invariant validation for paramaterized systems, in:
TACAS’03, LNCS 2619, 2003, pp. 97–112.
German, S. M. and A. P. Sistla, Reasoning about systems with many processes, J. ACM 39 (1992),
pp. 675–735.
Jonsson, B. and M. Nilsson, Transitive closures of regular relations for verifying infinite-state systems, in: TACAS’00, LNCS 1785, 2000, pp. 220–234.
Kesten, Y., O. Maler, M. Marcus, A. Pnueli and E. Shahar, Symbolic model checking with rich assertional languages, Theor. Comput. Sci. 256 (2001), pp. 93–112.
Kofronˇ, J., “Behavior Protocols Extensions,” Ph.D. thesis, Charles University in Prague (2007).
Lynch, N. A. and M. R. Tuttle, An introduction to input/output automata, CWI Quarterly 2 (1989),
pp. 219–246.
Maidl, M., A unifying model checking approach for safety properties of parameterized systems, in:
CAV’01, LNCS 2102, 2001, pp. 311–323.
Pnueli, A., S. Ruah and L. D. Zuck, Automatic deductive verification with invisible invariants, in:
TACAS’01, LNCS 2031, 2001, pp. 82–97.
Pnueli, A. and L. D. Zuck, Model-checking and abstraction to the aid of parameterized systems, in:
VMCAI’03, 2003, p. 4.
Rybina, T. and A. Voronkov, Using canonical representations of solutions to speed up infinite-state model checking, in: CAV ’02 (2002).
Vaˇrekov´a, P. and I. Cˇern´a, Model checking of control-user component-based parametrised systems, in:
CBSE’08, LNCS 5282, 2008.
Vaˇrekov´a, P., B. Zimmerova, P. Moravec and I. Cˇern´a, Formal verification of systems with an unlimited number of components, To appear in IET Software (2008).
Zimmerova, B., P. Vaˇrekov´a, N. Beneˇs, I. Cˇern´a, L. Brim and J. Sochor, “The Common Component Modeling Example: Comparing Software Component Models, Component-Interaction Automata Approach (CoIn),” LNCS 5153, 2008 pp. 146–176.
