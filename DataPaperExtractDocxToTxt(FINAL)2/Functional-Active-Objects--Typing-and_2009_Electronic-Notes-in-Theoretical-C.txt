

Electronic Notes in Theoretical Computer Science 255 (2009) 83–101
www.elsevier.com/locate/entcs

Functional Active Objects: Typing and Formalisation
Ludovic Henrio1
CNRS – I3S – INRIA, Sophia-Antipolis, France
Florian Kammu¨ller2
Technische Universita¨t Berlin, Germany

Abstract
This paper provides a sound foundation for autonomous objects communicating by remote method invo- cations and futures. As a distributed extension of ς-calculus, we define ASPfun, a calculus of functional objects, behaving autonomously and communicating by a request-reply mechanism: requests are method calls handled asynchronously and futures represent awaited results for requests. This results in a well structured distributed object language enabling a concise representation of asynchronous method invoca- tions. This paper first presents the ASPfun calculus and its semantics. Secondly we provide a type system for ASPfun, which guarantees the “progress” property. Most importantly, ASPfun and its properties have been formalised and proved using the Isabelle theorem prover, and we consider it as a good step toward formalisation of distributed languages.
Keywords: Theorem proving, object calculus, futures, distribution, typing.


Introduction
This paper presents a functional active object language, featuring first class fu- tures that has been formalised in the Isabelle/HOL theorem prover. ASPfun is a distributed extension of the ς-calculus [1] where objects are distributed into sev- eral activities, and activities are the units of distribution. Communications toward activities are asynchronous (remote) method calls; and futures are identifiers for the result of such asynchronous invocations. A future represents an evaluation-in- progress in a remote activity. We call those futures “first class” because they can be transmitted between activities as any object: several activities may use the same future. The calculus is said to be functional because method update is realised

1 Email: Ludovic.Henrio@inria.fr
2 Email: flokam@cs.tu-berlin.de

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.026

on a copy of the object: there is no side-effect. The calculus is called distributed because it ensures absence of sharing between activities (processes) allowing them to be placed on different machines, and features asynchronous RMI-like commu- nications. From the original actor paradigm [16,2], several languages have been designed. Some languages directly feature actors, distributed active objects (like the ProActive [6] library), or other derived paradigms. The calculus ASPfun pro- vides a simple model for such languages. We can prove strong properties about it and, since the calculus is abstract, our semantics and mechanisation can be a basis for the analysis of related languages. For example, ASPfun enables the correlation with the imperative ASP [7] with respect to communication strategies and static analysability. Typing is a well studied technique [22]; we prove here a classical typing property, progress, in unusual settings, distributed active objects.
The language, its type system and all properties have been completely for- malised (www-sop.inria.fr/oasis/Ludovic.Henrio/misc.html) and proved in Isabelle/HOL [21]. Our main contributions are:
A functional active object calculus with futures, and its properties.
A proposal for a type system for active object languages.
An investigation on how to provide a type-safe calculus featuring active objects and futures, where typing ensures progress.
A formalisation of those features in a theorem prover, that will allow further investigations on futures, typing, and active objects paradigms.
Section 2 presents ASPfun, its semantics and properties. Section 3 provides a sound type system for ASPfun. Some details on the formalisation are given in Section 4. Our results are compared with related works in Section 5.

ASPfun: A Functional Active Object Calculus
Syntax
We use three sets of identifiers: the labels of ς-calculus methods (li), the activities (α,β,. . . ), and the futures (fi). Like in ς-calculus, in ASPfun, every term is an object, either given by its definition, or returned by a term evaluation like a method call. The syntax of ASPfun includes object deﬁnition, method invocation, and method override inherited from ς-calculus. An object consists of a set of labelled methods. A method is a function with two formal parameters, one represents self, i.e., the object in which the method is contained, the other is an actual parameter given at invocation time. Object fields are not defined as they are considered as degenerate methods not using the parameters. A method call is addressed to an object and receives an object as parameter. A method update acts on an object, providing a new value for one method, possibly defining it. ς-calculus terms are identified modulo renaming of variables. One of the basic principles of ASPfun is to perform a minimal extension of the syntax of ς-calculus. ASPfun programs only use one additional primitive, Active, for creating an active object. The syntax of ASPfun

s, t ::= x	variable
| [lj = ς(xj, yj)tj]j∈1..n (6j, xj /= yj) object definition
| s.li(t)	(i ∈ 1..n) method call
| s.li := ς(x, y)t	(i ∈ 1..n, x /= y) update
| Active(s)	Active object creation
| α	active object reference
| fi	future reference
Table 1 ASPfun syntax

is shown in Table 1; the static syntax (the programs) consists of only underlined constructs; future and active object references are created at runtime.

Informal Distributed Semantics of ASPfun
The semantics of object definition and method invocation is natural: a method invocation reduces to the method body where formal parameters are replaced by actual ones: [l = ς(x, y)a].l(b) reduces to a where x is replaced by [l = ς(x, y)a] and y is replaced by b [1], and a field update returns a new object replacing the original method by the one on the right side of ’:=’. We focus now on the distributed features of ASPfun.
A conﬁguration is a set of activities. Each activity possesses a single active object, which is a ς-calculus term. Activating an object, Active(s), means creating a new activity with the object s to be activated becoming an active object. 3 It is immutable. A request sent to an activity is an invocation to the active object; it is processed by the activity. The set of requests processed by an activity is called request queue by similarity with the active object model but, here, as the calculus is functional, requests can be treated in an unordered fashion.
Every message sent toward an activity is a method call to the activated object. Such a remote method invocation (also called request ) is asynchronous: the effect of this method call is – both – to create a new request in the request queue of the destination and to replace the original method invocation by a reference to the result of the created request. A reference to a (promised) result is called a future. In ASPfun, futures are entities that can be passed to other activities, e.g. as arguments or results of requests; several activities may use the same future. Trying to access the result referenced by a future (e.g. invoking a method on it) is not possible until the future has been received. The current term of any request (even partially evaluated) can be returned at any moment: the current term for the request replaces the corresponding future. This operation is called a reply. We chose to allow replies with a partially evaluated term because it fits well with the functional nature of the calculus; but we will see in Section 6 that a more classical semantics returning

3 In the ς-calculus every term is an object.

only requests entirely evaluated is also dead-lock free under reasonable conditions. Future values must be stored forever.
Reduction can occur in any request of any activity. The only restriction is that an object cannot be sent to another activity (e.g. as a request parameter) if this object has free variables. Fortunately, the type system can ensure that any term typed in an empty environment has no free variable, which is the case for all requests and some of their sub-terms (the ones in evaluation contexts).
It is difficult to give a natural semantics to the update of an active object because this would in general create an additional way of communicating with an active object. However, the functional nature of the calculus (updating an object creates a copy) oriented us toward the following solution: a method update on an active object creates a new activity with the method updated.
Proving determinism for ASPfun is difficult and out of the scope of this paper. Informally, depending on the execution, the set of created activities and the number of requests may vary, but the result of the computation is deterministic.
As a tiny example of the semantics, Active([l = ς(x, y)[]]).l([]) first creates an activity with the object [l = ς(x, y)[]], then performs a remote invocation on the method l of this activity (which creates a future), and finally replies, replacing the future by the result of the invocation, [].
Practically, implementing strictly the semantics presented here is not very rea- sonable, because of the inefficiency of some execution paths. However, we consider this work as a reliable basis for further studies on stateless objects, and as an in- teresting proposal for a semantics for autonomous services, which in case they are stateless can be implemented such that they never dead-lock.
This model also represents component-like distributed systems interacting by invocation of services: an active object exposes its methods to the external world, and holds references to required external services provided by other active object. Active objects act as the unit of both distribution and composition.

Small-Step Operational Semantics
The semantics of ASPfun necessitates to define some structures that will be used for the dynamic reduction. First, we define a configuration C as an unordered set of activities: a configuration is a mapping from activity identifiers to activities. Each activity is composed of a request queue (mapping from future identifiers to terms), and an active object (term).
C ::= αi[(fj '→sj)j∈Ii , ti]i∈1..p	where {Ii} are disjoint subsets of N
As futures are referenced from anywhere, two requests must correspond to two different futures; uniqueness is ensured in this paper by indexing futures over disjoint families. We call local semantics, the semantics expressing the execution local to each activity, where an activity is the unit of distribution. In [1], the authors present various ς-calculi that only consider objects and their manipulation as primitive; local semantics of ASPfun is just an adaptation of this work. More precisely, local

semantics of ASPfun extends ς-calculus, with a second parameter for methods.
Classically we define contexts as expressions with a single hole (•). E[s] denotes the term obtained by replacing the single hole by s.
E ::= •| [li = ς(x, y)E, lj = ς(xj, yj)tj∈(1..n)−{i}] | E.li(t) |
s.li(E) | E.li := ς(x, y)s | s.li := ς(x, y)E| Active(E)
For generality of results, we allow the reduction inside binders, like in the general semantics of ς-calculus (Definition 6.2.1 of [1], or even example page 62 showing a reduction inside binders). Then for their “operational semantics” (Section 6.2.4 of [1]) the authors use reduction contexts that do not allow reduction inside binders: F ::= •| F.li(t) | F.li := ς(x, y) s | Active(F ). Those reduction contexts would avoid using noFV requirement in the reductions. We chose to specify the most general semantics – allowing reduction inside binders – thus proving that our properties are valid for both kind of reduction contexts. Properties presented in this paper are also valid for “classical” reduction contexts (replacing E by F ), however, we kept the most general formalisation. Reformulating our results for “classical” contexts would be trivial.
For a better integration with the distributed calculus, we choose a small-step semantics (→ς ) for the ς-calculus. It is composed of the two first rules of Table 2; one invokes a method (using the invoked object as first parameter), the other replaces a method definition, producing a new object with the updated method.
To simplify the reduction rules we let Q, R ::= (fij '→ sij)j∈1..np range over request queues and identify mappings modulo reordering: α[fi '→ si :: Q, b] :: C is a configuration containing the activity α which contains a request fi '→ si, where C is the remainder of the configuration that cannot contain an activity α. Now, α[Q, s] ∈ C means: α is an activity of C with request queue Q and active object s: α[Q, s] ∈ C ⇔ ∃ C'.C = α[Q, s] :: C'. Similarly, (fi '→ s) ∈ Q stands for: a request of Q associates s to the future fi. The empty mapping is ∅; the domain of a mapping is dom; e.g. dom(C) is the set of activities defined by C. Predicate noFV(s) is true if s has no free variables (the only binder being ς this definition is classical). The parallel reduction →  on configurations is defined in Table 2.
Classically, the substitution s{x ← t} is capture avoiding (renaming is performed
to avoid free variables in t to be captured by binders in s), whereas the replacement of • by a term in a context is not.
local performs a local reduction inside an activity: one step of the reduction
→ς is performed on one request.
active creates an activity, the term s passed as argument to the Active primitive is the active object. The newly created activity receives a fresh activity identifier γ. Initially, the new activity has an empty request queue, and γ replaces the activation instruction: Active(s), thus allowing future invocations to this activity.
request sends a request from the activity α to the activity β, with α /= β. A new



call

li ∈ {lj}j∈1..n



E [lj = ς(xj, yj)sj]j∈1..n.li(t) →ς E si{xi ← [lj = ς(xj, yj)sj]j∈1..n, yi ← t} 
update
li ∈ {lj}j∈1..n

E [lj = ς(xj, yj)sj]j∈1..n.li := ς(x, y)t →ς E [li = ς(x, y)t, lj = ς(xj, yj)sj∈(1..n)−{i}] 


local
s →ς s'



α[fi '→s :: Q, t] :: C → α[fi '→s' :: Q, t] :: C


active
γ ∈/ (dom(C) ∪ {α})	noFV(s)


α[fi '→E[Active(s)]:: Q, t] :: C →  α[fi '→E[γ]:: Q, t] :: γ[∅, s] :: C


request
fk fresh	noFV(s)	α /= β



α [fi '→E[β.l(s)]:: Q, t] :: β[R, t'] :: C →  α [fi '→E[fk] :: Q, t] :: β fk '→t'.l(s):: R, t' :: C
self-request
fk fresh	noFV(s)
α [fi '→E[α.l(s)]:: Q, t] :: C →  α [fk '→t.l(s) :: fi '→E[fk] :: Q, t] :: C
reply
β[fk '→s :: R, t'] ∈ α[fi '→E[fk] :: Q, t] :: C
α[fi '→E[fk] :: Q, t] :: C →  α[fi '→E[s]:: Q, t] :: C
update-AO
γ ∈/ dom(C)∪{α}	noFV(ς(x, y)s)	β[R, t'] ∈α[fi '→E[β.l:=ς(x, y)s]:: Q, t] :: C
α[fi '→E[β.l := ς(x, y)s] :: Q, t] :: C →   α[fi '→E[γ] :: Q, t] :: γ[∅, t'.l := ς(x, y)s] :: C

Table 2 ASPfun semantics

request is created at the destination, invoking the method l on the active object (t'); a fresh future fk is associated to this request, and replaces the invocation on the sender side. Freshness is defined classically: fk is fresh in C if 6 α[Q, t] ∈ C, fk ∈/ dom(Q).
self-request is the request rule when the destination is the sender, α = β.
reply updates a future: it picks the request calculating a value for the future fk, and sends the current value of this request (s) to an activity that refers to the future. The request may be partially evaluated. Necessarily noFV(s) holds. The structure of the rule avoids introducing a separate rule for α = β.
update-AO updates a method of an activity β[R, t']. It creates a new activity

whose active object performs a (local) update on t': t'.l := ς(x, y)s. It requires that the new method definition for l has no free variable.
The requirement noFV(s) for the communicated terms is necessary. Indeed, com- municating a term with free variables would cause variables to escape the scope of their binder. Giving an alternative semantics to communicated free variables without entailing shared memory is out of the scope of this paper [24].

An Example
The following example illustrates some of the advantages of futures for the imple- mentation of services. Here a customer wants to make a hotel reservation. He uses a broker for this service. The example further illustrates how futures can be em- ployed to provide some confidentiality. The broker does not need to give away his data base of hotel references: he can instead return just a reference to the result of his negotiations; the booking reference. We omit the actual search of the broker in his database and instead hardwire the solution always to “hotel”. Also the internal administration of hotel is omitted. The example shows the flow of control given by the requests, replies, and the passing on of the futures: the booking reference can flow directly to the customer, possibly without passing by the broker. This shows that futures allow the implementation of efficient communication flows.
customer[f0 '→broker.book(date, limit), t]
broker[∅, [book = ς(x, (date, limit))hotel.room(date),.. .]] hotel[∅, [room = ς(x, date)bookingreference,.. .]]
→∗ customer[f0 '→f1, t]	(request, local) broker[f1 '→hotel.room(date),.. .]
hotel[∅, [room = ς(x, date)bookingreference,.. .]]
→∗ customer[f0 '→f1, t]]	(request, local) broker[f1 '→f2,.. .]
hotel[f2 '→bookingreference,.. .]
→∗ customer[f0 '→bookingreference, t]	(reply∗) broker[f1 '→f2,... ]
hotel[f2 '→bookingreference,.. .]



Properties of ASPfun
This section presents two major properties of ASPfun: the semantics is well-formed; and reduction does not create cycles of futures and activity references.

Well-formed Conﬁguration
To show correctness of the semantics, we define a well-formed conﬁguration as ref- erencing only existing activities and futures; then we prove that reduction preserves well-formedness.
Definition 2.1 [Well-formed configuration] A configuration C is well-formed, de-

noted wf (C), if and only if for all α, fi, s, Q, and t each of the following holds:
α[Q, E[β]] ∈ C ∨ α[fi '→E[β] :: Q, t] ∈ C ⇒ β ∈ dom(C)
α[Q, E[fk]] ∈C ∨ α[fi '→E[fk] :: Q, t] ∈ C ⇒ ∃ γ, R, t'. γ[R, t'] ∈C ∧ fk∈ dom(R)

We have shown that, starting from a well-formed configuration, the reduction shown in Table 2 always reaches a well-formed configuration.
Property 1 (Reduction preserves well-formedness) (s →  t ∧ wf (s)) ⇒ wf (t) This can be considered as a correctness property for the semantics of ASPfun:
no ill-formed configuration can be created by the reduction.
Absence of Cycles
Informally, ASPfun avoids blocking method invocations because a not fully evaluated future can be returned to the caller at any time. The natural question arises whether there is the possibility for live-locks: a cycle of communications (here, a cycle of replies in fact) in which no real progress is made apart from the actual exchange of communication. However, we can show that, given a configuration with no cycle, any possible configuration that may be derived from there has no cycle either. By cycles we mean cycles of activity references and futures.
We say that an activity or a future knows another one if it holds a reference to it. An activity holds a reference if it has this reference inside its active object. A future holds a reference if the request computing this future contains this reference. Table 3 shows the rules defining the knowsC relationship for a configuration C together with the nocycle property. It is necessary to interleave references to futures and activities in the definition of knowsC because, for example, a reference from an active object becomes a reference from a future when a request rule is evaluated.


α[Q, E[β]] ∈ C


α knowsC β
α[fi '→E[β] :: Q, t] ∈ C fi knowsC β
α[Q, E[fk]] ∈ C α knowsC fk



α[fi '→E[fk] :: Q, t] ∈ C fi knowsC fk
nocycle(c) ⇔ ¬∃r. r knows+ r


Table 3
The nocycle property

We proved that the reduction defined in Table 2 maintains the absence of cycles for a well-formed configuration.
Theorem 2.2 Reduction does not create cycles:
nocycle(C) ∧ wf(C) ∧ C → C'	⇒	nocycle(C')

The proof is by rule analysis. The theorem also relies on the fact that domains of request queues are disjoint, which is enforced by the definition of a configuration in ASPfun. Absence of cycles ensures that there are no live-locks related to the distributed aspects of ASPfun, i.e. no infinite cycle of replies. Live-locks that can exist in ASPfun are inherited from ς-calculus: they are either infinite loops inside a ς-calculus term, or infinite sequences of method calls (distributed or not).
Absence of cycle is a limit to the expressiveness of the language (no cross- references), but this restriction is inherited from the functional nature of the lan- guage. Indeed, functional languages have no references, whereas active objects and futures create some kind of references; preventing cycles and modification is neces- sary to still consider ASPfun as a functional language.
Initial Conﬁguration
This section shows how a reasonable initial configuration can be built from a pro- gram, i.e. a term without future or active object reference (as defined in Section 2.1). In most distributed languages, programmers do not write configurations, but usual programs invoking some distribution or concurrency primitives (in ASPfun Active is the only such primitive). This is reflected by the ASPfun syntax given in Sec- tion 2.1. A “program” is a term a given by this static syntax (it has no future or active object reference). In order to be evaluated, this program must be placed in an initial configuration. The initial configuration has a single activity single request consisting of the user program:
initConf(s0)= α[f0 '→s0, []]
where s0 is a static term without free variables as defined in Section 2.1. Note, that this configuration is necessarily well-formed, and the activity α will never be accessible. Consequently, any reachable configuration is well-formed. We can also immediately see that the initial configuration has no cycles, and using Theorem 2.2, we can show that any reachable configuration has no cycles.
Property 2 Any conﬁguration reachable from an initial conﬁguration is well-formed and has no cycles (→∗ is the reflexive transitive closure of →  ).
initConf(s0) →∗ C	⇒	wf(C) ∧ nocycle(C)
Typing Active Objects
This section provides a type system for ASPfun. This first involves typing the Active primitive, but also type-checking an ASPfun configuration. After the classical subject-reduction property, we show that the type system ensures type uniqueness, and well-formedness of configurations, and more importantly progress. We will see that typing ensures that no method can be invoked on a term that is unable to handle it; the semantics ensures that no invocation or update on a future or an activity can be indefinitely blocked.

A Local Type system
We first adapt the simple type system that Abadi and Cardelli devised as Ob1 in [1]. Object types are of the form [li : Bi ⭢ Di]i∈1..n. The syntax of ASPfun is extended by adding type information on both variables under the binder (ς(x, y)
becomes ς(x:A, y:B)). As highlighted in [1], adding type information on the binders ensures type uniqueness.


Val x
x : A :: T ▶ x : A
Type Object
A = [li : Bi⭢Di]i∈1..n	6i ∈ 1..n, xi : A :: yi : Bi :: T ▶ ti : Di

T ▶ [l = ς(x : A, y : B )t ]i∈1..n : A

i	i	i	i  i


Type Call
T ▶ s : [li : Bi⭢Di] i∈1..n
j ∈ 1..n	T ▶ t : Bj


T ▶ s.lj(t): Dj
Type Update
A = [li : Bi⭢Di]i∈1..n	T ▶ s : A j ∈ 1..n	x : A :: y : B :: T ▶ t : Dj

T ▶ s.lj := ς(x : A, y : B)t : A

Table 4
Typing the local calculus

Table 4 defines the typing of local ASPfun terms as presented in 2.1. It is strongly inspired by the typing of Ob1. A, B, and D range over types. The variable T represents a type environment containing type assumptions for variables, and is identified modulo reordering. Its extension by a new assumption stating that the variable x has type A is denoted by x : A :: T . We now authorise :: to update a mapping entry: (x : A) :: T associates the type A to x, even if an entry

for x existed in T . The first rule of Table 4 accesses the type environment.
Type

Object describes how an object’s type is checked from its constituents: an object of type [li : Bi⭢Di]i∈i..n is formed from bodies ti of types Bi using self parameter xi of type A, and additional parameter yi of type Bi. When a method lj is invoked
on an object s of type [li : Bi⭢Di]i∈i..n the result s.lj(b) has type Dj provided s has type Bj (Type Call). A method update requires that the updated object has the same type as self in the new method (Type Update).
In [1], additional rules ensure that the typing environment is well-formed. We simplified it here by defining environment as a mapping. Also, a rule for correct formation of object types is introduced in [1], mainly ensuring that there is no infinitely nested object type. This last assumption has been omitted here as it did not seem necessary and, indeed, the properties shown below have been mechanically proved without any additional assumptions on type formation.
A Type System for ASPfun
The type system for ASPfun is based on an inductive typing relation on ASPfun terms; it is defined in Table 5. From local typing (Table 4), in addition to types of variables, we need to refer to types for futures and activities. Thus, we add a pair of parameters ⟨Γact, Γfut⟩ in the assumptions of a typing statement, we write



Type Active
⟨Γact, Γfut⟩,T ▶ a : A

⟨Γact, Γfut⟩,T ▶ Active(a): A
Type Activity Reference
β ∈ dom(Γact)
⟨Γact, Γfut⟩,T ▶ β : Γact(β)

Type Future Reference
fk ∈ dom(Γfut)
⟨Γact, Γfut⟩,T ▶ fk : Γfut(fk)
Type Configuration
dom(Γact) = dom(C)	dom(Γfut)=	{dom(Q) |∃ α, a. α[Q, a] ∈ C} 6 α[Q, a] ∈ C.  ⟨Γact, Γfut⟩, ∅ ▶ a : Γact(α)	∧
6 fi ∈ dom(Q). ⟨Γact, Γfut⟩, ∅ ▶ Q(fi): Γfut(fi)
▶ C : ⟨Γact, Γfut⟩

Table 5 Typing configurations


⟨Γact, Γfut⟩,T ▶ x : A instead of T ▶ x : A. These parameters consist of a mapping Γact from activities to the type of their active object, and another one Γfut from future identifiers to the type of the corresponding request value. Thus, we first
adorn each rule of Table 4 with those two additional parameters.
Then, we add to these rules the three first rules of Table 5 that define the local typing of ASPfun. These rules allow the typing of references to activities and futures, and define typing of the Active primitive: the type of an activated object is the type of the object.
The last rule of Table 5 incorporates into a configuration the local typing asser- tions. This rule states that a configuration C has the configuration type ⟨Γact, Γfut⟩ if the following conditions hold.
The same activity names are defined in C and in Γact;
the same future references are defined in the activities of C and in Γfut;
for each activity of C, its active object has the type defined in Γact;
and each request has the type defined in Γfut for the corresponding future.
Similarities can be found between typing of activity or future references, and refer- ence types [22]. A closer work seems to be the typing rules for futures [20].


Basic Properties of the Type System
Let us start by a couple of simple properties of the typing system. First, type- uniqueness existing for Ob1 is also verified by our type system.

Property 3 (Unique Type) Each expression in ASPfun has a unique type.
⟨Γact, Γfut⟩,T ▶ a : A ∧ ⟨Γact, Γfut⟩,T ▶ a : A' =⇒ A = A'
Well-typed configurations are well-formed. Indeed, if an activity or a future is referenced in the configuration, it must have a type, and thus be defined in Γact or Γfut, and also in the configuration.
Property 4 (Typing ensures well-formedness)	▶ C : A ⇒ wf (C)

Subject Reduction
Subject reduction ensures that reduction preserves the typing relation. Therefore, it is often also called preservation. We prove subject reduction of ASPfun with respect to the type system given in the previous section.
We prove first the subject reduction property for the local reduction:
Property 5 (Local Subject Reduction)
⟨Γact, Γfut⟩,T ▶ t : A ∧ t →ς t' ⇒ ⟨Γact, Γfut⟩,T ▶ t' : A
Then, we prove subject reduction for the full typing relation of configurations.
Theorem 3.1 (Subject Reduction)
▶C : ⟨Γact, Γfut⟩ ∧ C →  C' ⇒∃ Γ'act, Γ'	. ▶C' : ⟨Γ'act, Γ'	⟩
where Γact ⊆ Γ'act, and Γfut ⊆ Γ'	.
Note that activities and futures may be created by the reduction and thus the typing environment may have to be extended.

Progress and Absence of Dead-locks
Finally, we can prove progress for well-typed configurations. Progress states that any expression of the language is either a value, or can be reduced. In ASPfun, we prove progress for each request of a configuration. A term is a value, i.e. a totally evaluated term, if it is either an object (like in [1]) or an activity reference.
isvalue (s) ⇔ ∃li, ti, A. s = [li = ς(xi : A, yi : B)ti]i∈1..n ∨ ∃α, s = α
The type system is useful for ensuring that every accessed method exists on the invoked object. In fact, local typing ensures progress of local reduction. Typing for configurations extends the typing relation to distributed objects, ensuring for example that a method invocation on a future will be possible once the result is returned. Absence of dead-locks for the distributed semantics is only ensured by the functional nature of ASPfun, by the absence of loops, and by the particular semantics of the calculus. This can be simply formulated as follows:
Property 6  ▶ C : ⟨Γact, Γfut⟩ ∧ α[fi '→s :: Q, t] ∈ C ⇒ isvalue(s)∨∃C' . C →   C'

More precisely, we prove that the term s in the theorem above can be reduced. Unfortunately, as already shown in [1], ς-calculus does not ensure that a reduced term is different from the source one, but this is an issue related to the local re- duction which is not the concern of this paper. We proved that on the distributed side, the term really always progresses and that no reduction loop is induced by the distributed features of ASPfun. We can reformulate the preceding theorem:
Theorem 3.2 (Progress)
nocycle(C) ∧ ▶ C : ⟨Γact, Γfut⟩ ∧ α[fi '→s :: Q, t] ∈ C  ⇒ isvalue(s) ∨∃ C' .C →  C'
where C' can be chosen to verify: α[fi '→s' :: Q, t] ∈ C' ∧ (s' /= s ∨ s →ς s) .
By proving progress we also show that ASPfun is dead-lock free: as any term that is not already a value must progress, this ensures the absence of dead-lock.
As configurations reachable from the initial configurations have no cycle, a vari- ant of the progress theorem can be stated by replacing the nocycle hypothesis, by the reachability from a well-typed initial configuration:
Property 7 (Progress from initial configuration)
initConf(a) →∗ C ∧ ∅ ▶s : A ∧ α[fi '→s :: Q, t] ∈C ⇒ isvalue(s) ∨ ∃C'.C →  C'
where C' can be chosen to verify: α[fi '→s' :: Q, t] ∈ C' ∧ (s' /= s ∨ s →ς s) .
Formalisation in Isabelle/HOL
Isabelle/HOL offers a classical higher order logic as a basis for the modelling of application logics. Inductive definitions and datatype definitions can be defined in a way close to programming language syntax and semantics. We adapted the semantics for the ς-calculus defined in [15] in order to use reduction contexts; we proved that both models are equivalent. As our purpose is to demonstrate the modelling of typing and distribution concerns, the operational semantics is simply based on DeBruijn indices. We are currently investigating the use of locally nameless techniques [3] instead.
Crucial Aspects of the Proofs
This section details some of the parts of the formalisation that seem the most important to us, it gives proof sketches and is not much coupled Isabelle/HOL.
Finiteness When considering language semantics we often implicitly assume finite- ness of programs and configurations. In fact, the implicit assumption is worth men- tioning: for programs it grants induction over the recursive datatype of ς-terms, and for configurations, it permits the assumption that there are always fresh activity and future names available. Our formalisation relies on this assumption. We show that initial configurations and configurations reduced from them are all finite.
Absence of Cycles Proving the absence of cycles (Theorem 2.2) required us several steps, we first defined a datatype for future or activity reference, and then speci- fied the knowsC and knows+ relations defined in Section 2.5.2. In order to handle

the proofs, we refine the knows+ relation by remembering the list of intermediate activities: r knows+(L) r' iff r knows+ r', passing by the references in L.
C	C
We first prove lemmas relating cycles, knows+ and paths. E.g., if r knows+(L) r',
C	C
and C' is obtained from C by just modifying the request corresponding to fk; then r knows+' (L) r' provided fk ∈/ L, and fk /= r.Consequently, it is sufficient to prove that no cycle is created by the modified activities and requests. We also show that when r knows+(L) r', L can be chosen to include neither r nor r'. The remainder of the proof is a long case study on the reduction rules that uses lemmas presented above, well formedness of the initial configuration, and shows that if there is a cycle in the obtained configuration, there was necessarily one in the original configuration.
Proving Progress Proving progress relies on a long case analysis on the reduction rule. We focus first on one crucial argument: how can the absence of free variable be ensured in order to communicate an object between two activities. Each request can be typed in an empty environment (for variables); thus it does not have any free variable, and thus each sub-term of a request that is not under a binder has no free variable. We prove that one can reduce at least the part of the request under the evaluation context F . Indeed, in F the term in the position of the hole has no free variables: ⟨Γact, Γfut⟩, ∅ ▶F [a] : A ⇒ noFV(a)
Considering the other arguments of the proof, the absence of cycles ensures that
an application of a reply rule cannot return a future value which is the future itself, in which case the configuration would be reducible to itself. This ensures that no live-lock exists because of the distributed semantics. Of course, the proof also massively uses the fact that well-typed configurations are well-formed.

Summary of the Formal Model
The formalisation of functional ASP is constructed as an extension of the base Isabelle/HOL theory for the ς-calculus [15]. The term type of the ς-calculus is represented by an Isabelle/HOL datatype definition called dB. In this datatype definition, objects are represented as finite maps Obj (Label ⇒f dB) type. We formalised finite maps in the first argument of Obj using the abstract concept of axiomatic type classes. It is crucial to have finite maps as a basic Isabelle/HOL type to be able to employ the recursive datatype construction here. The second argument of the constructor Obj is a type annotation. The type of configurations relies on partial functions expressed by the type constructor ⇒| .
futmap = FutureRef ⇒|  dB
configuration = ActivityRef ⇒| (futmap × dB)
The parallel semantics of ASPfun is given as an inductive relation over this type of configurations encoding the reduction relation →  (see Table 2).
In our model we developed a simple mechanisation of a reduction context using datatype and an operator to “fill” the “hole” enabling a fairly natural notation of E↑t for E[t] (remember this substitution is not “capture avoiding” contrarily to the variable substitution). We can illustrate the benefits of our context concept most directly by the representation of the configuration rule for requests.

request:  ∀ A ∈ dom C. fn ∈/ dom(C .A A); C A’ = Some(m’,a’);
m’(fk) = Some(E↑(Call(ActRef B) li p); C B = Some(mb, a);A’/= B; noFV p )
=⇒ C →  C (A’ '→ (m’ (fk '→ E↑(FutRef(fn))), a’)) (B '→ (mb (fn '→ (Call a li p)), a))
The theorem progress ASP reach below is a particular instance of the progress theorem employing the previous results that all reachable configurations are finite and have no cycles; it corresponds to Property 7.
theorem progress_ASP_reach:
 reachable C; ▶ C: CT; A∈ dom C; fi ∈ C.RA; ¬(isvalue C.F A<fi>) )
=⇒ ∃ C’. (C →  C’) ∧ ( C’.F A<fi>/=C.F A<fi>∨ C.F A<fi> →ς C.F A<fi>)
Experience The entire development takes around 14000 lines of code. The most difficult and crucial step is certainly the definition of the right model for the calculus, its semantics, but also for the additional constructs used in intermediate lemmas. Even if the length and form of the proof is far from optimal, the development for formalising such a theory is really consequent; and it becomes difficult to keep a proof minimal and well-structured when it grows to several thousands of lines in length. Handling simplification steps in such a complex and rich theory becomes tricky. Additionally, making modular proofs for subject reduction and equivalent properties is difficult in a theorem prover because useful lemmas are tightly coupled with the numerous and complex hypotheses involved by the case analysis.

Related Works and Positioning
Actors [16] are widely used for distributed autonomous entities, and their interac- tions by messages. They are rather functional entities but their behaviour can be changed dynamically, giving them a state.
Agents and Artifacts with simpA, concentrating on the higher-level of modelling concurrent agent based systems, also presents a calculus [23]. Based on Feather- weightJava its agent concept resembles ASPfun’s activities but the calculus has no type system and proofs. ASPfun may be used to provide formal support.
Obliq [5] is based on the ς-calculus; it expresses both parallelism and mobility. It relies on threads communicating with a shared memory. Like in ASPfun, calling a method on a remote object leads to a remote execution but this execution is performed by the original thread. Øjeblik, e.g. [4], a subset of Obliq, equally differs from ASPfun by thread execution. The authors investigate safety of surrogation meaning that objects should behave the same independent of migration.
Jeffrey’s distributed object calculus [17] is based on Gordon and Hankin’s con- current object calculus [13] extended with explicit locations. The main objective is to avoid configurations where one object at one location is being accessed by another. A type system enforces these restrictions. Because migrating objects can carry remote calls, in order to ensure subject-reduction, Jeffrey introduces serialis- able objects, which are non-imperative. Compared to our calculus the most decisive difference is that activities abstract away the notion of location, and are remotely accessible thanks to a request queue. The concept of futures somehow explicitly supports mobility and serialisation.

Futures have been studied several times in the programming languages literature, originally appearing in Multilisp [14] and ABCL [25].
λ(fut) is a concurrent lambda calculus with futures. It features non determin- ism primitives (cells and handles). In [20], the authors define a semantics for this calculus, and two type systems. They use futures with explicit creation point in the context of λ-calculus; much in the same spirit as in Multilisp. Alice [19] is an ML-like language that can be considered as an implementation of λ(fut).
In [9], the authors provide a language with futures that features “uniform multi- active objects”: roughly each method invocation is asynchronous because each ob- ject is active. Thus, compared to ASPfun, the calculus has no Active primitive. Each object has several current threads, but only one is active at each moment. Their futures are also explicit: a get operation retrieves their value. The authors also provide an invariant specification framework for proving properties. This work also formalises the Creol language [18].
ASP [8] is an imperative distributed object calculus; it is based on the ςimp- calculus [1]. It features asynchronous method calls and transparent first class futures, no instruction deals directly with futures. Activities in ASP are mono- threaded: one request is served at each moment, and a primitive can be used to select the request to serve. Some confluence properties for ASP have been studied in [8,7]. ProActive [6] is an implementation of the ASP calculus.
More recently, in [11], the authors suggest a communication model, called Am- bientTalk, based on an actor-like language, and adapted to loosely coupled small devices communicating over an ad-hoc network. The communication model is quite similar to the ASP calculus, but with queues for message sending, handlers in- voked asynchronously, and automatic asynchronous calls on futures. The resulting programming model is slightly different from ASP and ASPfun because there is no blocking synchronisation in AmbientTalk. In AmbientTalk, the flow of control might be difficult to understand for complex applications, because one can never ensure that a future has been returned at a precise point of the program. AmbientTalk should be dead-lock free, but unfortunately as no formalisation of the language has been proposed to our knowledge, this has not been formally proved. Our framework could be relatively easily adapted to prove the absence of dead-locks in AmbientTalk by transferring our progress property.
Futures have been formalised in several settings, generally functional-based [20,9,12]; those developments rely on explicit creation of futures by thread creation primitives,
in a concurrent but not distributed setting. They are getting more and more used in real life languages; for example, explicitly created futures are also featured by the java.util.concurrency library. ASP’s [7,8] particularities are: distribution, ab- sence of shared memory, and transparent futures, i.e. futures created transparently upon a remote method invocation.
This paper presented a distributed evaluation of the functional ς-calculus, using transparent futures and active objects. It can also be seen as a study of the func- tional fragment of ASP. That is why we consider this calculus as complementary to the preceding ones. Futures can be passed around between different locations in

a much transparent way; thanks to its functional nature and its type-system, this calculus ensures progress. Progress for active objects means that evaluation cannot lead to dead-locks. ASPfun is called “functional” because objects are immutable. In ASPfun, activities are organised in an actor-like manner, that is why we consider our language as a form of “functional actors”, or “functional active objects”. The main novelty of ASPfun is that it is simple enough to allow for a mechanised specification and mechanised proofs of typing properties.

Conclusion
We presented a functional calculus for communicating objects and its type system. This work can be seen both as a distributed version of ς-calculus and as an investiga- tion on the functional fragment of ASP. It has been entirely formalised and proved in the Isabelle theorem prover. The functional nature of ASPfun should make it influence directly stateless distributed systems like skeleton programming [10]. Our approach could be extended to study frameworks where most of the services are stateless, and the state-full operations can be isolated (access to a database), e.g. workflows and SOA. Our formalisation in a theorem prover should also impact other developments in the domain of semantics for distributed languages.
A calculus of communicating objects The calculus is an extension of ς-calculus with only the minimal concepts for defining active objects and futures. Syntactically the extension only requires one new primitive: Active creates a new activity from a term. The absence of side-effects and the guarantee of progress make the program easy to reason about and easy to parallelise. ASPfun is distributed in the same sense as ASP: it enables parallel evaluation of activities while being oblivious about the concrete locations in which the execution of these activities takes place. The actual deployment is not part of the programming language, and should be provided by an application deployer rather than by the application programmer.
Well-formed terms and absence of cycle We proved that ASPfun semantics is correct: no reference to non-existing activities or futures can be created by the reduction. Also, no cycle of future or activity references can be created. Thus, starting from an initial configuration, we always reach a well-formed configuration without cycle.
A type system for functional active objects We extended the simple type system for ς-calculus: Active returns an object of the same type as its parameter; activities are typed like their active objects; and futures are typed like the request calculating their value. The type system ensures progress and preservation. Preservation states that the types are not changed during execution. Progress states that a program does not get stuck. In ASPfun, this is due to the following facts:
The type system plus the subject reduction property ensure that all method calls will access an existing method.
Well-formedness ensures that all accessed activities and futures exist.
Absence of cycles prevents cycles of mutually waiting synchronisations.

As partially evaluated futures can be replied, any chosen request can be reduced.
All operations are defined for both local and active objects avoiding “syntactical” dead-locks like updating a method of an activity.
Terms under evaluation contexts can be safely communicated between activities.
Can we ﬁnd a better progress property? Let us analyse the limitations of the progress property. First, though a reduction is possible, the reduced term can sometimes be identical to the original one. The absence of cycle ensures that such a situation can only occur in the local semantics. This is inherent to the ς-calculus and is out of the scope of this paper. Second, the reduction can occur in any chosen request but not at any chosen place. Indeed objects can only be sent between activities if they do not have free variables that otherwise would escape their binder.
Alternative semantics It is possible to restrict the reply rule to only return com- pletely evaluated futures. Then, if one picks a request, there is no more any guar- antee that it can evolve, but the absence of cycle ensures that some request in the conﬁguration can always be reduced. Some intermediate reductions have to be added to guarantee the progress property. Finally, returning only completely evaluated fu- tures leads to a more efficient semantics, and still ensures a form of progress.

References
M. Abadi and L. Cardelli. “A Theory of Objects”. Springer, New York, 1996.
Gul Agha, Ian A. Mason, Scott F. Smith, and Carolyn L. Talcott. A foundation for actor computation.
Journal of Functional Programming, 7(1):1–72, 1997.
B. Aydemir, A, Chargu´eraud, B. C. Pierce, R. Pollack, and S. Weirich. Engineering formal metatheory.
Princ. of Programming Languages, POPL’08, ACM, 2008.
S. Briais and U. Nestmann. Mobile objects “must” move safely. Formal Methods for Open Object-Based Distributed Systems, FMOODS’02. Kluwer Academic Publishers, 2002.
L. Cardelli. A language with distributed scope. In POPL 1995. ACM.
D. Caromel, C. Delb´e, A. di Costanzo, and M. Leyton. ProActive: an integrated platform for programming and running applications on grids and P2P systems. Computational Methods in Science and Technology, 12(1):69–77, 2006.
D. Caromel, L. Henrio, and B. Serpette. Asynchronous and deterministic objects. Princ. of Programming Languages, POPL’04, pages 123–134. ACM Press, 2004.
D. Caromel and L. Henrio. “A Theory of Distributed Objects”. Springer, 2005.
F. S. de Boer, D. Clarke, and E. B. Johnsen. A complete guide to the future. Eur. Symposium on Programming, ESOP’07. LNCS 4421:316–330, Springer, 2007.
M. Cole, Bringing skeletons out of the closet: a pragmatic manifesto for skeletal parallel programming, Parallel Computing 30 (3) (2004) 389–406.
J. Dedecker, T. Van Cutsem, S. Mostinckx, T. D’Hondt, and W. De Meuter. Ambient-oriented programming in ambienttalk. ECOOP’06. LNCS 4067, Springer.
C. Flanagan and M. Felleisen. The semantics of future and an application. Journal of Functional Programming, 9(1):1–31, 1999.
A. D. Gordon, P. D. Hankin, and S. B. Lassen. Compilation and equivalence of imperative objects.
Proceedings FST+TCS’97, LNCS. Springer, 1997.
R. H. Halstead, Jr. Multilisp: A language for concurrent symbolic computation. Transactions on Programming Languages and Systems (TOPLAS), 7(4), 1985.


L. Henrio and F. Kammu¨ller. A mechanized model of the theory of objects. Formal Methods for Open Object-Based Distributed Systems, . LNCS 4468 Springer, 2007.
C. Hewitt, P. Bishop, and R. Steiger. A universal modular actor formalism for artificial intelligence. IJCAI, 1973.
A. Jeffrey. A distributed object calculus. ACM SIGPLAN Workshop on Foundations of Object Oriented Languages, FOOL’00, 2000.
E. B. Johnsen, O. Owe, and I. C. Yu. Creol: A type-safe object-oriented model for distributed concurrent systems. Theoretical Computer Science, 365(1–2), 2006.
J. Niehren, D. Sabel, M. Schmidt-Schauß, and J. Schwinghammer. Observational semantics for a concurrent lambda calculus with reference cells and futures. Conference on Mathematical Foundations of Programming Semantics, ENTCS, 2007.
J. Niehren, J. Schwinghammer, and G. Smolka. A concurrent lambda calculus with futures. Theoretical Computer Science, 364(3):338–356, 2006.
T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL – a proof assistant for Higher-Order Logic, volume 2283 of LNCS. Springer-Verlag, 2002.
B. C. Pierce. Types and Programming Languages. MIT Press, March 2002.
A. Ricci, M. Viroli, and M. Cimadamore. Prototyping Concurrent Systems with Agents and Artifacts: Framework and Core Calculus. Foundations of Coordination Languages and Software Architectures, FOCLASA’07. ENTCS, Elsevier 2007.
A. Schmitt. Safe dynamic binding in the Join calculus. In R. Baeza-Yates, U. Montanari, and
N. Santoro, editors, Proceedings of IFIP TCS 2002, Kluwer.
A. Yonezawa, E. Shibayama, T. Takada, and Y. Honda. Modelling and programming in an object- oriented concurrent language ABCL/1. Object-Oriented Concurrent Programming. MIT Press, 1987.
