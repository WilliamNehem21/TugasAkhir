

Electronic Notes in Theoretical Computer Science 250 (2009) 171–186
www.elsevier.com/locate/entcs
Counter Abstraction in the CSP/FDR setting
Tomasz Mazur1	Gavin Lowe2
Oxford University Computing Laboratory Wolfson Building, Parks Road, Oxford OX1 3QD, UK

Abstract
In this paper we consider an adaptation of counter abstraction for the CSP/FDR setting. The technique allows us to transform a concurrent system with an unbounded number of agents into a finite-state abstrac- tion. The systems to which the method can be applied are composed of many identical node processes that run in parallel with a controller process. Refinement checks on the abstract state machine can be performed automatically in the traces and stable failures models using the FDR model checker. We illustrate the method on an example based on a multiprocessor operating system.
Keywords: Counter abstraction, model checking, parameterised verification, CSP.

Introduction
One subclass of a Parameterised Model Checking Problem can be specified as follows:
Given a concurrent system System(N ), consisting of N identical and independent processes, and a speciﬁcation Spec, is it true that System(N ) satisﬁes Spec for all N?
It has been shown by Apt and Kozen [1] that this problem is in general undecidable. The best we can do is to restrict the verification to a particular class of systems and provide a method that is sound (but not necessarily complete) for this class. The systems that we are going to consider consist of a number of identical node processes. Given N , the number of node processes present in the system, the general form of such systems is
System(N )= F (N odes(N )), where F () is any CSP context,

N −1
N odes(N )= 
i=0
N ode,



1 Email: tomasz.mazur@comlab.ox.ac.uk
2 Email: gavin.lowe@comlab.ox.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.012

and N ode models a single node process.
We do not allow node process identifiers anywhere in the definition of N ode: otherwise, the size of the alphabet of the implementation process would depend on N , and, because counter abstraction does not change alphabets, the abstraction of the system would also depend on N , contrary to our requirements. In addition, for the same reasons, we assume that the specification process Spec and the CSP context F () are independent of N .
In most practical situations we can expect the context F to describe some con- troller process that is put in parallel with the nodes. The uniform verification of the family of problems with such a context has been proven by German and Sistla to be decidable [7]. However, the algorithm provided is double exponential and therefore the verification is only possible for very small instances of a problem.
Counter abstraction is already a well-known abstraction method, probably best presented by Pnueli et al. in [14]. It is an application of the more general predicate abstraction [4,6,12], which in turn is a special case of ﬁnitary abstraction [10], a method which transforms an infinite-state parameterised concurrent system into a finite-state abstraction. Counter abstraction aims to create an abstraction of the system that is independent of the number of node processes, to ensure that a single refinement check will prove a given result for all values of N . The main idea is to replace the concrete state space representing a concurrent system consisting of many similar processes by an abstract state space; each abstract state is a tuple of integer counters (c0, c1,... , ck−1), where each cj counts how many node processes are currently in the j-th state. The counters are also given a threshold z and we interpret cj = z to mean that there are z or more processes in state j.
In the past, counter abstraction has been successfully applied to systems where the verification property has been given in the form of a temporal formula [2,14,18,19]. In [2], Clarke and Gru¨mberg show that if System(k)  Abstr(System) and System(k + 1)  Abstr(System) are equivalent under an appropriate relation, then it is enough to consider only the instances of the systems of size less than or equal to k in order to verify whether a given ICTL∗ formula holds for all sizes of the system. A method similar to counter abstraction with a threshold z = 1 is used to construct Abstr(System). However, in order for the method to work, the user needs to provide two functions that match three special conditions. This task usually requires some ingenuity, so the scope for automation is limited.
Pnueli et al. in [14] and Xu in [19] show how to verify a general temporal formula in a concurrent system with unboundedly many similar processes running in parallel. The model used is Fair Transition Systems [13] where the processes are interleaved and communicate with each other via shared variables only. Each process may also be given its own local variables (whose values may depend on the process’s identity). However, this destroys the full symmetry of the system. Before the verification procedure is performed, the user has to replace the local variables by some appropriate global variables that will model the same behaviour. Again, this task may require quite a lot of ingenuity. In the paper it is shown how, given a concrete state space and a temporal formula, to create a corresponding abstract

machine and abstract temporal formula. Also some heuristics are provided for extending the abstract formula so that liveness can be proven.
The work that is probably the closest to ours is [18]. It considers systems of a similar structure to the one we use, and uses a model with synchronous communica- tion between processes. The verification algorithm consists of two parts. The first creates a finite abstraction, which is independent of the number of processes present in the concrete system. This is similar to our method, but instead of using a fixed threshold z (introduced in Section 4), it determines appropriate thresholds on-the- fly (at the expense of compilation complexity). The second part of the algorithm evaluates the CTL-X specification on the abstract state machine.
The novelty of our work is the application of the pure counter abstraction method (rather than more general predicate or finitary abstraction) to concurrent reactive systems where:
interaction between any processes present in the system occurs through commu- nication of events (the node processes are interleaved so they share no events between themselves; however, there is shared communication between these pro- cesses and the rest of the system as well as the environment);
the specification is provided as a process definition (as opposed to a formula of temporal logic) and is verified through a refinement check;
failures are used in system analysis in order to allow verification of specifications that talk not only about safety of the implementation (i.e. what the system can do), but also about the availability of events (i.e. what the system cannot refuse to do); and
the node processes are put in a general context.
Even though counter abstraction has already been applied to some extent to systems with processes interacting by communication [2,18], we are not aware of any application of the method where model checking occurs via a refinement check. Refinement checking allows for a different range of properties to be verified compared to verification using temporal formulae. Additionally, our system needs to counter abstract only the implementation process: the specification side remains unchanged. We choose our language to be the process algebra CSP with two semantic models, traces and stable failures. We give a brief overview of the syntax and semantics of CSP and the idea of refinement in the next section; more details can be found in [9,16]. For simplicity, we assume that all the processes in our system are non-
divergent and do not contain termination events.
Our overall goal, given a CSP specification process Spec and a CSP implementa- tion process System(N )= F (N odes(N )), is to verify whether Spec ± System(N ) for all values of N . The model checker FDR [15,5] can perform this refinement check for small, fixed N ; however, it is unable to do so when N is large and clearly it cannot help much with proving the refinement for all N . This is where we will use the full potential of counter abstraction: we construct a process Abstr such that Abstr ± N odes(N ) by construction, and hence F (Abstr) ± F (N odes(N )) = System(N ); then the refinement check Spec ± F (Abstr) can be easily performed

by FDR.
The rest of the paper is structured as follows. In the next section we give a brief overview of CSP. In Section 3 we describe the idea of counter abstraction with unbounded integer counters, and introduce our running example. It is observed that, even though this may dramatically reduce the number of states in the state machine representation of the system, the state space may be still unbounded in size. We prove that such a modified system is bisimilar, and hence traces and stable- failures equivalent, to the original one. The abstraction is improved further by adding thresholds to the counters in Section 4. We show that this operation creates an anti-refinement of the original system, which is independent of the number of node processes. This allows us to perform a single refinement check against Spec in order to conclude that System(N ) refines Spec for all N . We also briefly talk about a tool that automates the process of creating counter abstraction models, suitable for checking using FDR. In addition, we present time comparison results between explicit model checking and model checking using counter abstraction with thresholds, based on the example used throughout the paper. We conclude the paper in Section 5 with a short discussion of possible directions of further development of the method.
Introduction to CSP
Syntax
The CSP process algebra was introduced by Hoare in 1978 [8] and then modified into its current form in 1985 [9]. Roscoe’s book [16] is probably the most complete description of the language.
For any process we define its alphabet, Σ, to be the set of all observable com- munication events that this process can engage in, either with the environment or with other processes. There are also a special event: the internal event τ , which a process can communicate invisibly, without any interaction from the environment. We write Στ to mean Σ ∪ {τ }.
The partial CSP syntax that we use in this paper is the following.

P ::= STOP | a → P | P  P | P H P | P [[b/a]] | b & P | P
 P | P ||| P.
X

The process STOP is a synonym of deadlock, i.e. it is the process that cannot engage in any communication with the environment. a → P is a process that can initially communicate the event a and then behave like process P . For two processes P and Q, P  Q (external choice) is a process that offers the environment the choice of performing any initial event of P or Q: if an initial event of P is performed, then the choice is resolved to P , and if an initial event of Q is performed, then the choice is resolved to Q. P H Q, on the other hand, represents an internal or nondeterministic choice, where the process behaves either like P or like Q: the choice is made by some mechanism that we do not model, and cannot be influenced by the environment.
P [[b/a]] (renaming ) is a process that behaves like P except that whenever the

process would normally perform a, it now performs b.
The processes b & P is equivalent to if b then P else STOP : P is enabled only if the guard b is true.
The notion of parallel composition of processes plays an important role in CSP.

The process P
 Q is the parallel composition of P and Q, with handshaken syn-
X

chronisation on all the events from the set X. We also write  s∈S [A(s)]P (s) to mean the parallel composition of processes P (s) indexed over S, where each P (s) is only allowed to perform events from A(s) and the processes synchronise on common
events. P ||| Q is the interleaving of P and Q: the process are in parallel, but do not synchronise on any event.
It is important to note that here we have presented only a subset of the CSP syntax. However, since all our results are derived using operational semantics, they all apply to the full CSP language provided the processes are non-divergent and contain no termination events. The syntax presented in this section is only used for our running example.


Semantics
In this paper we use the standard operational semantics for CSP (as defined in [16,
e
chapter 7]). Given two processes P and Q and an event e, we write P −→ Q to
tr
mean that P can perform an event e and then behave like Q. Also we write P =⇒ Q
to mean that the process P can perform the trace tr of visible events (and possibly some number of τ events) and then behave like process Q.
In this paper we consider CSP processes in two different denotational semantic models: traces and stable failures. In the former each process P is described by its set of traces (written traces(P )), which contains all the finite sequences of events that P can communicate to the environment. In the stable failures model a pro- cess P is represented by the set of its traces (defined as above) together with the set of its failures (written f ailures(P )). A failure is a pair (s, X), which represents that the process can perform the trace s to reach a stable state (i.e. where no inter- nal events are possible), where it can refuse the whole of X (i.e. none of the events of X is available).
Central to the idea of model checking using CSP is the concept of refinement. In the traces model, we say that a process P is reﬁned by Q (or that Q reﬁnes P ) if whenever Q can perform a trace tr, then so can P . Formally
P ±T Q ⇔ traces(Q) ⊆ traces(P ).
In the failures model, we also require the failures of Q to be in the failures of P :
P ±F Q ⇔ traces(Q) ⊆ traces(P ) ∧ f ailures(Q) ⊆ f ailures(P ).
FDR can test whether such refinements hold, for finite state processes.



Fig. 1. State diagram of the basic model for processes within an operating system
Counting the processes
In this section we present a transformation method, which generates a system that is bisimilar to N odes(N ). Each state in the new system is a tuple of integer counters, each counting how many node processes are in a given concrete state. We start by introducing our running example, and then describe the transformation itself.

Multiprocessor operating system example
We will model a process scheduling mechanism in an operating system for a multi- processor machine. Our implementation will consist of a number of nodes, each representing a single operating system process requesting CPU access, and a sched- uler.
We adopt the common model of process states [17], as shown in Figure 1. We model a node as below.
N ode(new)= load → N ode(runnable), N ode(runnable)= run → N ode(running),
N ode(running)= deschedule → N ode(runnable)
  block → N ode(blocked)
  terminate → STOP,
N ode(blocked)= interrupt → N ode(runnable).
The task of the scheduler is to divide the CPU time between the different pro- cesses. Let cores be the number of processors present in the system. Then the scheduler, below, consists of cores interleaved processes Core, each representing a single processor resource. We abstract away the details of the algorithm that the scheduler uses to decide which process should be given access to the CPU next (letting it pick any available process nondeterministically), and hence our analysis

holds for all scheduling algorithms.
cores−1

Scheduler =
i=0
Core(idle)

The process Core, below, models a single CPU resource. When Core is idle it can run and become busy; and when busy, any of the events that imply that a process no longer needs CPU time (i.e. deschedule, block or terminate) brings it back to the idle state.
Core(idle)= run → Core(busy)
Core(busy)= deschedule → Core(idle)
  block → Core(idle)
  terminate → Core(idle).
To create our implementation, we interleave all the node processes and put them in parallel with the scheduler process, synchronising on the common events. Finally we rename all the events that imply that a process no longer needs CPU time (i.e. deschedule, block or terminate) to a single event stopRun since, for specifica- tion verification purposes, we need not to distinguish why a process no longer needs a CPU.

N −1
N odes(N )= 
i=0
N ode(new),

System(N )= (N odes(N )


Alpha
Scheduler)

[[stopRun,stopRun,stopRun/deschedule,block,terminate]], Alpha = {|run, deschedule, block, terminate|}.


Finally we would like our specification to say that we never have more than cores processes in the running state, i.e. the number of run events minus the number of stopRun events is never more than cores. Further, if there is at least one process running, then it can stop running, so the event stopRun is not refused. Finally, the events load and interrupt may or may not be available. Hence we define
Spec = Spec'(0),
Spec'(x)= x < cores & (run → Spec'(x + 1) H STOP )
  x > 0& stopRun → Spec'(x − 1)
  (load → Spec'(x) H interrupt → Spec'(x) H STOP ).
We fix the value of cores. Our verification problem is then:
∀ N ≥ 1 • Spec ±F System(N ).

Counter abstraction with unbounded counters
Counter abstraction works by transforming an (unbounded) concrete state machine into a finite abstract state machine. The CSP language is equipped with full opera-

tional semantics [16, chapter 7], which allows us to convert a definition of any CSP process into an explicit state machine. We will represent each such state machine by a tuple

(S, s0, Στ
, {−→ | e ∈ Στ
}),

where: S is the set of states that the process can be in; s0 is the initial state; Στ is the set of events the process is allowed to communicate, extended with the internal
e
action τ ; and −→ ⊆ S × S is the transition relation specifying the e-successors of
each state.
We represent a single node process N ode as the state machine

S	= (S
,n , Στ	e
τ	}),

Node
Node	0
Node, {−→ | e ∈ ΣNode

where SNode = {n0, n1,... , nk−1} (so that the number of states each of the node processes can be in is k).
Each state of the state machine for N odes(N ) can be represented as a tuple of
N −1
the form (nj0 , nj1 ,... , njN−1 ), which corresponds to the process |||	nji (i.e. the
i-th node process is in the state nji ).
We define an abstraction method that, using only SNode, automatically generates an abstract state machine

A∞	∞
τ	e A	τ

= (A
, a0, ΣA, {−→ ∞ | e ∈ ΣA})

that is bisimilar to N odes(N ). Each a in A∞ is a k-tuple of integer counters
(c0, c1, c2,... , ck−1),
which corresponds to a concrete state
(nj0 , nj1 ,... , njN−1 ) where each cj counts the number of nodes in state nj, i.e.
∀ j ∈ [0..k) • cj = #{i ∈ [0..N ) | nji = nj}.
The abstract initial state a0 is then the tuple (N, 0,... , 0). This naturally cor- responds to the situation where all the node processes are in their initial states.

To define the alphabet of the abstract machine, Στ
it is enough to observe that

the abstract machine can only perform events that a node process could. Hence
τ	τ
A	Node
e	τ
Finally, we define the abstract transition relation −→A∞ . Let e ∈ ΣA be given.
Then

(c ,c ,... ,c 
e	(c' , c' ,... , c'	)

0  1	k−1) −→A∞	0  1
⇔
e
k−1

∃ i, j ∈ [0..k) • ni −→ nj ∧ ci > 0 ∧
((i /= j ∧ c' = ci − 1 ∧ c' = cj +1 ∧ ∀ h /= i, j • c'

= ch)

i	j	h
∨ (i = j ∧ ∀ h • c' = ch)).
This is to say that there is an e-transition between two states in the abstract state machine if and only if there is an e-transition of some node process from state ni

to state nj, with ci > 0 (so at least one node process is in state ni); and the corresponding counters in the abstract state changed correctly: if ni and nj are different states then counter i is decreased by 1, counter j increased by 1 and all the other counters remained unchanged; if ni and nj are the same state then all the counters remain unchanged.
For the rest of the paper, we let CANodes ∞(N ) be a process whose state machine is the abstract state machine A∞ generated from £Node as above.
Proposition 3.1 CANodes∞(N ) and N odes(N ) are strongly bisimilar.
Proof: These two systems are strongly bisimilar by construction, with bisimulation relation:

  |||N −1 n
, (c ,c ,... ,c 
)  6 j ∈ [0..k) • c
= #{i ∈ [0..N ) | n
= n }, .


Corollary 3.2 CANodes ∞(N ) ≡F N odes(N ).

Counter abstraction with thresholds
In the previous section we showed how to create an abstraction of a concurrent system by using unbounded integer counters. Even though such an abstraction offers a dramatic decrease in the number of states by factoring the states with respect to bisimulation, it is likely that the state space will still be unbounded in size. More importantly, its size will still depend on N . In this section we present an improved abstraction method, where we introduce a threshold z for the values each of the counters can take.
Constructing the state machine
Let z be a positive integer. Our aim is to create the abstract model
Az = (Az,a , Στ	e A  | e ∈ Στ })
0	Az , {—→ z	Az
by defining its set of states, the initial state, the alphabet and the transition rela- tions.
For each state (c0, c1,... , ck−1) ∈ A∞ we define a state a ∈ Az such that
a = (z H c0,z H c1,... ,z H ck−1),
where x H y = min(x, y). The purpose of the variable z is to put an upper bound on the values that each of the integer counters can attain. This allows us to count the processes in the domain {0, 1, 2,... ,z — 1,z or more}.
The addition of the threshold z requires a new definition for the initial state. Throughout this section, assume N ≥ z (the value of z is usually small, so all the refinement checks for N < z can be performed directly). Then
a0 = (z, 0,... , 0).
The alphabet of the abstract state machine stays unchanged. Hence
τ	= Στ .

Suppose s1 = (c0, c1,... , ck−1) and s2 = (d0, d1,... , dk−1) are two states in A∞ and Az, respectively. Then we say that s1 and s2 are corresponding, written cor(s1, s2), if for all j ∈ [0..k) we have dj = z H cj.
Now, let e ∈ Στ  be given. Intuitively, we want two states in Az to be related by
e	e
—→Az if and only if there exist two corresponding states in A∞ related by —→A∞ .
Formally we define
e	'	'	'	'	e	'
d —→Az d e E c, c ∈ A∞ • cor(c, d) Λ cor(c ,d ) Λ c —→A∞ c .
For the rest of the paper, we let CANodesz be a process whose state machine is the abstract state machine Az generated as above.
We can easily generate CANodesz for our running example. The counter ab- straction will contain five counters, one for each of the states that a single node process can be in. Below are the first two branches of the definition; the other branches are similar and can be found in Appendix A.
CANodesz = CANodes' (z, 0, 0, 0, 0)
CANodes ' (c0, c1, c2, c3, c4)= 
c0 > 0 & load → (if c0 = z
then CANodes ' (c0 — 1,z H (c1 + 1), c2, c3, c4)
H CANodes ' (c0,z H (c1 + 1), c2, c3, c4) else CANodes ' (c0 — 1,z H (c1 + 1), c2, c3, c4))

c1 > 0 & run → (if c1 = z
then CANodes ' (c0, c1 — 1,z H (c2 + 1), c3, c4)
H CANodes ' (c0, c1,z H (c2 + 1), c3, c4) else CANodes ' (c0, c1 — 1,z H (c2 + 1), c3, c4))

... 
The nondeterminism present above comes from the fact that whenever one of the counters cj is equal to z, it can mean there are either exactly z or strictly more than z node processes in state nj.
It is intuitive to expect that counter abstracting a process using the threshold creates an anti-refinement of a counter abstraction of the same process without the threshold. The rest of the section proves this formally.


Lemma 4.1 Suppose that
CANodes ∞(N ) =t⇒r

(c ,c ,... , ck−1).

0  1

Then

CANodesz =t⇒r

(z H c0,z H c1,... ,z H ck−1).

Proof: This follows from the definition of CANodesz, by induction on the number of transitions corresponding to tr.	 
Lemma 4.2 Let z ≥ 1 and suppose that 6 j ∈ [0..k) • z H cj = z H c' . Then for all

events e:

(c ,c ,... ,c 

e	e (c' , c' ,... , c'	e	.

0  1	k−1) —→A∞	0  1	k−1) —→A∞
Proof: From each state, the event e is available if and only if there is at least one node process in a state nj where it can perform e (since there is no synchronisation
between the nodes). This will be true if, respectively, cj > 0 or c' > 0, for some
such j. However, z ≥ 1 and 6 j ∈ [0..k) • z H cj = z H c' , so 6 j ∈ [0..k) • cj > 0 e
' > 0. Hence e is available from the two states under the same circumstances.
 
Proposition 4.3  CANodesz ±F CANodes ∞(N ).
Proof: By Lemma 4.1 we have that traces(CANodes ∞(N )) ⊆ traces(CANodesz).
Let (tr, X) ∈ f ailures(CANodes ∞(N )).	Then for some (c0, c1,... , ck−1),

CANodes ∞(N ) =t⇒r
(c ,c ,... , ck−1) and (c ,c ,... ,c 
) refuses X. Then for each

0  1	0  1
k−1

e ∈ X ∪ {τ }, (c ,c ,... ,c	e	.
0  1	k−1) /—→A∞

By Lemma 4.1 we have that CANodesz =t⇒r
(z H c ,z H c ,... ,z H c
). Let

0	1	k−1

c' , c' ,... , c'	be such that z H ci = z H c'
for all i.	Then by Lemma 4.2,

0  1	k−1	i

(c' , c' ,... , c'
e
A , for each e ∈ X ∪ {τ }. Hence (z H c ,z H c ,... ,z H ck−1)

0  1	k−1) —→ ∞	0	1
e
/—→Az , by definition of the transition relation in Az, for each e ∈ X ∪ {τ }. Therefore
(tr, X) ∈ f ailures(CANodes z).	 
Corollary 4.4 CANodesz ±F N odes(N ).
Proof: This follows from Corollary 3.2, Proposition 4.3 and transitivity of refine- ment.	 
Theorem 4.5 If F () is any CSP context, and Spec is any process, then
Spec ± F (CANodesz) ⇒ 6 N ≥ z • Spec ± F (N odes(N )),
where the reﬁnements are either both in the traces or both in the failures model.
Proof: By Corollary 4.4 and monotonicity of the CSP operators, we have F (CANodesz) ±F F (N odes(N )), and hence F (CANodesz) ±T F (N odes(N )), for all N ≥ z. The result then follows from transitivity of refinement.	 

Tool support
We have created a simple automated tool called TomCAT 3 that, given an appro- priate CSP script and the value of z, automatically produces the CSP definition

3  Available from http://web.comlab.ox.ac.uk/people/tomasz.mazur/ .

of the counter-abstracted process CANodesz. Most of the parsing work is done by FDR: given a CSP script, it produces the concrete state machine of a single node process. Then the tool produces an output CSP script identical to the original one with the exception that the original definition of the process N odes is replaced by its counter-abstracted version.
The definition from Section 4.1 is inefficient to compile in FDR, as it uses a single sequential process with (z + 1)k states. TomCAT produces a CSP-equivalent, but more efficient definition, using a parallel composition of k separate processes, one for each counter, giving a total of k(z + 1) states to compile.
The CSP script produced by TomCAT for the running example is below. Here States and Transitions define the set of states and transitions of the abstract state machine, respectively. Given a state s, incoming(s), self loops(s) and outgoing(s) are sets of transitions for which s is the end state only, both the start and the end state and the start state only, respectively. Each member of these sets is defined
e
to be a tuple (s0, e, s1) and represents the corresponding transition s0 —→ s1.
Counter(s, x) represents a single counter for the state s storing its value in x. Further, Counters is the parallel composition of all the counters; the alphabets alpha(s), are chosen to ensure that each counter Counter(s, x) participates in those events coresponding to state s. Finally, CANodesz is the process whose state machine is the abstract state machine generated from the process N ode using the counter abstraction method with threshold (Section 4.1). It is obtained by hiding the events TAU  that represent internal actions in order to achieve the true τ ’s, and then replacing the events representing other transitions by the labels of these transitions.
Most of the definitions below are common for all outputs. The only parts that change are the definitions of the threshold z (supplied by the user on the command line) and States and Transitions (both of which are generated by FDR).




z = cores +1 
States = {0..4}
initState =0 
Transitions = {(0, load, 1), (1, run, 2), (2, terminate, 4), (2, deschedule, 1),
(2, block, 3), (3, interrupt, 1)}

incoming(s)= {(s0, e, s1) | (s0, e, s1) ∈ Transitions, s0 /= s Λ s1= s} selfloops(s)= {(s0, e, s1) | (s0, e, s1) ∈ Transitions, s0= s Λ s1= s} outgoing(s)= {(s0, e, s1) | (s0, e, s1) ∈ Transitions, s0= s Λ s1 /= s}

Counter(s, x)= 
do?t : incoming(s) → Counter(s, min(x + 1, z))
  x > 0 & do?t : selfloops(s) → Counter(s, x)
  x > 0 & do?t : outgoing(s) →
if x = z then Counter(s, x) H Counter(s, x — 1) else Counter(s, x — 1)
alpha(s)= {do.t | t ∈  {incoming(s), self loops(s), outgoing(s)}}
Counters =  s∈States [alpha(s)] Counter(s, if s = initState then z else 0)
CANodesz =
(Counters \ {do.(s0, e, s1) | (s0, e, s1) ∈ Transitions, e = T AU }) [[e/do.(s0,e,s1) | (s0, e, s1) ∈ Transitions, e /= T AU ]]

Experimental results
Going back to our example, let

F (P )= (P


Alpha
Scheduler)[[stopRun,stopRun,stopRun/deschedule,block,terminate]],

with Alpha as before. We can use FDR to verify that
Spec ± F (CANodesz).
In this case we need to take z to be at least cores + 1 for the refinement to hold. Then, by Theorem 4.5, we can deduce
6 N ≥ z • Spec ± System(N ).
Table 1 shows the time it takes to model check the concrete and abstract state machines for our example, with cores = 1, 2,... , 5 and N = 5, 6,... , 10. FDR completed all the checks with counter abstraction models in less than 1 second.
The number of states for the concrete state machine grows exponentially 4 in N . The number of abstract states, on the other hand, remains constant for all values of N .
More generally, the abstraction of the nodes has O((z + 1)k) states, which is exponential in the size of the concrete state machine of a single node process; how- ever, in most practical situation many of these states are unreachable so the typical case is much better.

4 The exact number of states that FDR checks is in fact Pcores `cores´`N´4N−k.


Table 1
Time comparison (in seconds) for explicit model checking.



Future work
An important question to ask is what value to choose for the threshold z. If it is too low, then if the refinement Spec ± CANodesz does not hold, it is likely that we get a spurious counterexample that does not occur in the concrete system. We can automate the processes of finding the smallest possible z (if one exists) for which our final refinement check holds, or produces a counterexample that occurs in the original system, using techniques similar to counterexample-guided abstraction refinement [3], as below:
Step 1: Let z = 1.
Step 2: If Spec ± F (CANodesz), then done.
Step 3: Else check if the counterexample for the refinement is also a counter- example for Spec ± F (N odes(N )).
Step 4: If yes then conclude that Spec /± F (N odes(N )). Step 5: Else let z = z + 1 and go to Step 2.
This procedure is not guaranteed to terminate, but if it does, then it gives us the z
we want.
Another possibility is to replace the single threshold z by a tuple of thresholds, one for each of the integer counters. In this way each of the counters could have a different cut-off value.
Another possible area of improvement is the family of systems allowed for the application of our method. At the moment we do not allow the node processes to use the node identifiers inside their definitions, for otherwise the state space of the node processes would be dependent on N . This limits the number of systems that could be analysed using counter abstraction and FDR. We intend to address this problem using techniques from data independence [11,16] to collapse, within each node process, the type [0..N ) of node identifiers to some fixed finite type T , and then to proceed using the methods described in this paper.

Acknowledgement
We would like to thank Bill Roscoe, Michael Goldsmith, Jo¨el Ouaknine and the anonymous referees for helpful comments on this work. The research was partially supported by a grant from the EPSRC.

References
Apt, K.R., and D.C. Kozen, Limits for automatic verification of finite-state concurrent systems, Information Processing Letters, 22(6) (1986), 307–309.

Clarke, Edmund M., and Orna Grumberg, Avoiding the state explosion problem in temporal logic model checking, PODC ’87: Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing, ACM Press, New York (1987), 294–303.
Clarke, Edmund M., Orna Grumberg, Somesh Jha, Yuan Lu, and Helmut Veith, Counterexample-guided abstraction refinement, CAV’00, Springer-Verlag, London (2000), 154–169.
Das, Satyaki, Predicate abstraction, Ph.D. thesis, Stanford University, 2003.
Formal Systems (Europe) Ltd., Failures-Divergence Refinement — FDR 2 user manual, 1999, URL:
http://www.fsel.com/fdr2 manual.html.
Graf, Susanne, and Hassen Sa¨ıdi, Construction of abstract state graphs with PVS, CAV’97, Springer- Verlag, London (1997), 72–83.
German, Steven M., and A. Prasad Sistla. Reasoning about systems with many processes, J. ACM,
39(3) (1992), 675–735.
Hoare, C. A. R., Communicating sequential processes, Commun. ACM, 21(8) (1978), 666–677.
Hoare, C. A. R., “Communicating sequential processes”, Prentice Hall Europe, 1985.
Kesten, Yonit, and Amir Pnueli, Verification by augmented finitary abstraction, Information and Computation, 163(1) (2000), 203–243.

Lazi´c, R. S., A semantic study of data independence with applications to model checking, Ph.D. thesis, Oxford University Computing Laboratory, 1999.
Lahiri, S., and R. Bryant, Constructing quantified invariants via predicate abstraction, Conference on Verification, Model Checking and Abstract Interpretation (VMCAI ’04), LNCS, 2937 (2004), 267–281.

Manna, Zohar, and Amir Pnueli, “Temporal verification of reactive systems: safety”, Springer-Verlag, New York, 1995.
Pnueli, Amir, Jessie Xu, and Lenore D. Zuck. Liveness with (0, 1, ∞)-counter abstraction, CAV’02, Springer-Verlag, London (2002) 107–122.

Roscoe, A. W., Model-checking CSP, “A Classical Mind, Essays in Honour of C. A. R. Hoare”, Prentice- Hall, 1994.
Roscoe, A. W., “The Theory and Practice of Concurrency,” Prentice Hall Series in Computer Science, Prentice-Hall, London, New York (1998). With associated web site http://www.comlab.ox.ac.uk/oucl/publications/books/concurrency/ .

Tanenbaum, Andrew S., Operating systems: design and implementation, Prentice-Hall, Upper Saddle River, 1987.
Vernier, Isabelle, Parameterized evaluation of CTL-X formulae, Proceedings of the 1st International Conference on Temporal Logic workshop, 1994.
Xu, Jessie, Automatic verification of parameterized systems, Ph.D. thesis, New York University, 2005.

A	Full definition of CANodesz for the running example
CANodesz(c0, c1, c2, c3, c4)= 
c0 > 0 & load → (if c0 = z
then CANodesz(c0 — 1,z H (c1 + 1), c2, c3, c4)
H CANodesz(c0,z H (c1 + 1), c2, c3, c4) else CANodesz(c0 — 1,z H (c1 + 1), c2, c3, c4))
 
c1 > 0 & run → (if c1 = z
then CANodesz(c0, c1 — 1,z H (c2 + 1), c3, c4)
H CANodesz(c0, c1,z H (c2 + 1), c3, c4) else CANodesz(c0, c1 — 1,z H (c2 + 1), c3, c4))
 
c2 > 0 & deschedule → (if c2 = z
then CANodesz(c0,z H (c1 + 1), c2 — 1, c3, c4)
H CANodesz(c0,z H (c1 + 1), c2, c3, c4) else CANodesz(c0,z H (c1 + 1), c2 — 1, c3, c4)
 
c2 > 0 & block → (if c2 = z
then CANodesz(c0, c1, c2 — 1,z H (c3 + 1), c3)
H CANodesz(c0, c1, c2,z H (c3 + 1), c4) else CANodesz(c0, c1, c2 — 1,z H (c3 + 1), c4))
 
c2 > 0 & terminate → (if c2 = z
then CANodesz(c0, c1, c2 — 1, c3,z H (c4 + 1))
H CANodesz(c0, c1, c2, c3,z H (c4 + 1)) else CANodesz(c0, c1, c2 — 1, c3,z H (c4 + 1))
 
c3 > 0 & interrupt → (if c3 = z
then CANodesz(c0,z H (c1 + 1), c2, c3 — 1, c4)
H CANodesz(c0,z H (c1 + 1), c2, c3, c4) else CANodesz(c0,z H (c1 + 1), c2, c3 — 1, c4)).
