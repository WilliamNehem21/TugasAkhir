

Electronic Notes in Theoretical Computer Science 242 (2009) 3–20
www.elsevier.com/locate/entcs

A Complete Symbolic Bisimilarity for an Extended Spi Calculus
Johannes Borgstro¨m1
Department of Software Engineering and Theoretical Computer Science, Technische Universita¨t Berlin, Germany

Abstract
Several symbolic notions of bisimilarity have been defined for the spi calculus and the applied pi calculus. In this paper, we treat a spi calculus with a general constructor-destructor message algebra, and define a symbolic bisimilarity that is both sound and complete with respect to its concrete counterpart.
Keywords: Cryptographic Protocols, Formal Verification, Bisimulation, Symbolic Techniques

The spi calculus, proposed by Abadi and Gordon [4] for the modelling and formal verification of cryptographic protocols, is an extension of the pi calculus [18] with cryptographic operators and operations. In this paper, we work in an extended spi calculus where the message algebra permits arbitrary constructors, and destructors with unique applicability.
As seen in for instance [4,13], many correctness properties for cryptographic pro- tocols are naturally expressed through equivalences between certain process terms.
To verify security properties expressed in this style, we need to choose a notion of equivalence. Contextual equivalences—two terms are related if they behave in the same way in all contexts—are attractive because the quantification over all con-
texts directly captures the intuition of an unknown attacker expressible within the spi calculus.
Direct proofs of contextual equivalences are notoriously hard [4] due to the re- quirement of infinitary quantifications (usually quantifications over infinitely many process contexts). Unfortunately, labelled bisimilarity is too strong a notion of equivalence for spi processes: It intuitively renders encryption (E·(·)) useless, by dis- tinguishing  between  the  (barbed  equivalent)  processes  (νk) a⟨Ek(M )⟩  and
(νk) a⟨Ek(N )⟩ whenever M /= N . This problem was adressed [3,9] by explicitly

1 Email: borgstrom@acm.org

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.078

taking into account the knowledge of an environment about a process. Hedged bisimularity [12], defined along the same lines, is the starting point for this paper. There is an inherent problem with the operational semantics of message-passing process calculi: The possibility to receive arbitrary messages gives rise to an infinite number of “concrete” transitions. Using a symbolic semantics, the substitution of received messages for input variables never takes place. Instead, an input prefix produces a single “symbolic” transition, where the input variable is only indirectly
instantiated by means of constraints.
In [11], we proposed a symbolic structural operational semantics and a symbolic bisimulation for the spi calculus. In this paper, we define decompositions [8,15] of symbolic environments and update symbolic bisimulation to account for this, yielding both soundness and completeness with respect to concrete bisimilarities. Compared to work on symbolic (bisimulation) semantics [14,17] for the applied pi calculus [2], we give a complete proof method in a setting where the operational semantics are finitely branching.

The Spi calculus
The pi calculus [18] is a small language for modelling communicating and distributed systems, where communication channels can be generated and passed around. In contrast to the pi calculus, the spi calculus offers next to mere names another kind of transmissible messages, namely ciphertexts, which are provided by the addition of primitive constructs to encrypt (Ek(M )) and decrypt (Dk(M )) data using shared- key cryptography. In this paper, we generalize the message language further, per- mitting arbitrary constructors with corresponding destructors, but not more general equations. Apart from the extended message language, we use the same syntax and semantics as in our original paper [11] on symbolic bisimilarity in the spi calculus.
We use the lower case letters a, b, c, k, l, m, n to range over the infinite set N of names. Names are untyped, meaning that the same name can be used as a channel, a key or the clear-text of a message. We use x, y, z to range over the infinite set V of variables, and let u, v, w range over N ∪ V. When s1,..., sk−1 and sk are terms (where k may be 0), we write “s” as a shorthand for “s1,..., sk”.
We assume a fixed finite signature Σ, containing constructors f and destructors
g. While expressions F ∈ E are formed arbitrarily using both constructors and destructors, messages M ∈ M are the expressions not containing destructor sym- bols. There is exactly one rewrite rule for every destructor g, that is of the form g(f (M ), N ) → M' where M , N don’t contain any names and M' ∈ {M , N }. We let
→H be rewriting at the top level of the term, and write G ≺ F iff G is a subterm of
F . In keeping with the operational flavor of this constructor-destructor language, we define term evaluation as the partial function e(F ) := F↓ whenever G↓ ∈ M for all G ≺ F , i.e., we require all destructors in F to succeed.
Logical formulae φ generalize the usual matching operator of the pi calculus by conjunction and negation. The predicate [ F : N ] tests if F evaluates to a name, so that it can be used as a channel.  The semantics [· ] of the base predicates are as

follows: [[[ F = G ]]] is true iff e(F ) = e(G) /=⊥ and [[[ F : N ]]] is true iff e(F ) ∈ N . Conjunction and negation have their usual meaning.
Processes P are composed of the halted process 0, the input F (x).P , output F⟨F⟩.P and replicated input !F (x).P prefixes, choice P + P , parallel composition P | P , restriction (νa) P and boolean guard φP .
F, G ::= u |	f (F )	| g(F )
φ, ψ ::= tt | [ F = F ] | [ F : N ] | φ ∧ φ | ¬φ
P, Q ::= 0 | F (x).P  | F⟨F⟩.P | ! F (x).P | P + P | P | P | (νa) P | φP
The names n(·) resp. variables v(·) of a term are the names resp. variables occuring in the term. Free and bound names and variables of process terms are inductively defined as expected: the name a is bound in “(νa) P ” and the variable x is bound in “F (x).P ” and “!F (x).P ”. Two processes are α-equivalent if they can be made equal by conflict-free renaming of bound names and variables. We generally identify α-equivalent processes.
Substitutions are idempotent functions  F/x} from variables x to expressions F ,
and are applied to processes, expressions and guards in the straightforward way, obeying the usual assumption that capture of bound names and variables is avoided
through implicit α-conversion. For example, P F/x} replaces all free occurrences
of x in P by F , renaming bound names and variables in P where needed. Below, we give some representative transition rules for the late input semantics of the spi calculus.
In Table 1, we give the transition rules for the late input semantics for closed processes (fv(P ) = ∅).
Constructor-Destructor Languages
Constructor-destructor languages, as defined above (cf. [7]), are subterm conver- gent [1]. As a comparison, the data term languages of [5] constrain rewrite rules to be of the form g(M ) → x (where x ∈ v(M )), yielding a special case of (possibly non-convergent) subterm languages.
We chose the format and unicity of the destructor rules for constructor-destructor languages to ensure a well-defined (deterministic) notion of evaluation, a smooth extension of the notions of synthesis and analysis and a strong correspondence be- tween the concrete and symbolic operational semantics.
Example 1.1 The nondeterministic choice rules either((x . y)) → x and either((x . y)) → y cannot both be present in a constructor-destructor language, but are permitted in a data term language. They also do not in general yield a convergent rewrite system.
On the other hand, the limited inverse rule f(g(h(x))) → h(x) can be part of a constructor destructor language (if g and h are constructors and f a destructor), but is not permitted in a data term language.
The idempotent rule f(f(x)) → f(x) or the self-inverse rule f(f(x)) → x can be part of a subterm-convergent rewrite system, but are not permitted in a constructor-




(out)
e(G) = a	e(F ) = M


a⟨M⟩
G⟨F⟩.P −−−→ P

(inp)
e(G) = a


a(x)
G x .P −−→ P



(ν˜b) a⟨M⟩
P
a(x)	'

(com-r)
τ	˜	'	' 
}  if {˜b}∩ fn(Q)= ∅




(rep)
e(G) = a
a(x)

(guard)
P −→ P'
μ


if [[φ]]

! G(x).P −−→ P | ! G(x).P	φP −→ P'


Q μ	'	μ	'

(par-r)	μ
P | Q −→
if bn(μ) ∩ fn(P )= ∅
P | Q'
(sum-r)
P + Q −→ Q'





(open)
(ν˜b) a⟨M⟩
P −−−−−−→ P
(νc˜b) a⟨M⟩

c ∈ n(M )
if c /∈ {a, ˜b}


(res)

μ
−→ P
μ


if c /∈ n(μ)

(νc) P −−−−−−→ P'	(νc) P −→ (νc) P'


Table 1 Operational Semantics

destructor language nor a data term language.
The parameterized choice rules pick((x . y), 1) → x and pick((x . y), 2) → y are permitted in a data term language and yield a convergent rewrite system, but are not permitted in a constructor-destructor language (but see the definition of π1 and π2 below).
Constructor-destructor languages can express standard formal cryptography.
Example 1.2 We let ΣDY = ({E, E+, E−, H, pub, (· . ·), D, D+, D−, π1, π2}, ar) where 1 = ar(H) = ar(pub) = ar(π1) = ar(π2) and
2 = ar(E) = ar(E+) = ar(E−) = ar((· . ·)) = ar(D) = ar(D+) = ar(D−). Here E+ (resp. E−) denotes public (private) key encryption, and D+ (D−) the
corresponding decryption. The rewrite system is given by D+(E+	(x)) → x,
y	pub(y)
D−	(E−(x)) → x, D (E (x)) → x, π1(x . y) → x and π2(x . y) → y.
pub(y)	y	y	y
Hedged Bisimilarity, Revisited
Hedged bisimilarity was introduced in [12] in order to clarify the differences between other notions of environment-sensitive bisimulation for the spi calculus. For the simpler message language used in the original paper, hedged bisimulation yielded a sound and complete (for structurally image-finite processes) approximation of

barbed equivalence. The basic data structure to represent the knowledge of an at- tacker is sets of pairs of messages, called hedges. Since we compare two processes, the message pairs in a hedge relate corresponding messages where the first message in a pair arises from interactions with the first process; the second message is re- lated to the second process. An environment is consistent if there is no noticeable difference between the two messages of any message pair. Since we use a richer message language than in previous work, we will also need to extend the operations on hedges that were defined there. The set of messages that can be generated using the knowledge of a hedge is called its synthesis (S, cf. [19]). The notion of analy- sis (A) becomes slightly more complicated in the current setting, since we do not constrain the arguments of destructors (“keys”) to be names. Here, the rule ana attempts to apply g to both sides of a pair in the analysis, constructing “keys” from the material that already has been analyzed. As a compact representation targeted towards implementations, we work with irreducible hedges (I), i.e., where no more mutual decryptions within projections of the hedge are possible.
Definition 2.1 A hedge is a subset of E × E . The synthesis S (h) of a hedge h is the smallest hedge containing h and satisfying the rule
(Fj, Gj) ∈ S (h) for j ∈ {1,..., ar(f )}

(syn)


(f (F˜),f (G˜)) ∈ S (h)

Let S+(h) := {(f (F˜),f (G˜)) | (Fj, Gj) ∈ S (h) for j ∈ {1,..., ar(f )}}.
The analysis A(h) of a hedge h is defined by mutual induction with an auxiliary set SA(h) by the following rules.



(ana-known)
(F, G) ∈ h


(F, G) ∈ A(h)
(f (F˜),f (G˜)) ∈ A(h)

(ana-s-known)
(F, G) ∈ A(h)


(F, G) ∈ SA(h)

(F', G') ∈ SA(h) for l ∈ {1,... ar(g) − 1}
e  e'	H

l	l	if g(f (F ), F ) → F

(ana)
(F, G) ∈ A(h)
and g(f (Ge), Ge') →H G




(ana-s)
(Fj, Gj) ∈ SA(h) for j ∈ {1,..., ar(f )} (f (F˜),f (G˜)) ∈ SA(h)

The irreducibles I (·) of a hedge are defined as I (h) := A(h) \ S+(A(h)).
If S is a set of expressions, we let IdS = {(F, F ) | F ∈ S}. We write h ▶ F ↔ G for (F, G) ∈ S (h). If h is a hedge, we let ht := { (G, F ) | (F, G) ∈ h } and πi(h) := { Fi | (F1, F2) ∈ h } when i ∈ {1, 2}. A hedge h is irreducible iff h = I (h).
The only purpose of the set SA is to ensure that A(h) is well-founded. If we replaced SA(h) by S (A(h)) in ana the definition would no longer be inductive, since we would a priori need to argue about the presence of certain expression pairs in A(h) before applying the rule. Indeed, for all hedges h, SA(h) = S (A(h)).

Example 2.2 We work with the constructor-destructor language ΣDY and let h =
{(pub(k), pub(k)), (E−((n . m)), E−((n . n))), (E−(n), E−(n))}.
k	k	k	l
Applying Definition 2.1 to h with this language, we get
A(h) = h ∪ {((n . m), (n . n)), (n, m), (n, n)} and I (h) = h ∪ {(n, m), (n, n)}.
In order to define a notion of consistency for concrete hedges, we use the notion of a pattern for a rewrite rule, intuitively a more abstract version of the left-hand side of the rule. As an extension of patterns, σ-patterns also track the possibilities to generate subterms of messages in range(σ) (cf. [1]).
Definition 2.3 An expression g(M ) is a pattern if there is ρ : V → (M\ V) with
g(M )ρ = F , where F is the left-hand side of the rewrite rule for g.
If g(M ) is a pattern and σ, ρ : V ~ M, then g(M ρ) is a σ-pattern whenever range(ρ) ⊆ {M /∈V | n(M ) = ∅∧ v(M ) ⊆ dom(σ) ∧ ∃N ∈ range(σ) Mσ ≺ N}.
Example 2.4 Modulo renaming of variables, the patterns for our example rewrite

system are π1(x), π2(x), Dy (x), D+(x), D−(x), D+(E+(y)), D−(E−(y)) and D−
(y).

y	y	x	z	x	z
pub(x)

A hedge is consistent if, inuitively, the same operations performed on both sides give indistinguishable results. Here, we give a more operational definition of this condition 2 .
Definition 2.5 We denote by H = Pfin(M × M) the set of all finite concrete hedges. An irreducible hedge h ∈ H is left consistent iff
if (a, N ) ∈ h with a ∈N then N ∈ N ; and
if (M, N ), (M',N') ∈ h such that M = M' then N = N'; and
if (M, N ) ∈ h there is no N' with (M, N') ∈ S+(h); and
Take σ1, σ2 with h = {(σ1(x), σ2(x)) | x ∈ dom(σ1)} and
dom(σ1) = dom(σ2).	If g(M˜) is a σ1-pattern and there is N1 such that
g(M˜)σ1 → N1 then there is N2 such that g(M˜)σ2 → N2.
h is consistent iff h and ht are both left consistent.
Since there are only finitely many σ-patterns (up to renaming) for any given σ, consistency is decidable.
Example 2.6 Continuing Example 2.2, we let
h = {(pub(k), pub(k)), (E−((n . m)), E−((n . n))), (E−(n), E−(n))},
k	k	k	l
h' = I (h) = h ∪ {(n, n), (n, m)} and h'' = I (h' ∪ {(k, k)}).
Then h' violates condition 2 for consistency since {(n, n), (n, m)} ⊂ h'. h' also violates condition 4 for consistency since (E−(n), E−(n)) ∈ h' and E−(n), but
k	l	k
not E−(n), can be decrypted by pub(k). Moreover, h'' violates condition 3, since
(E−(n), E−(n)) ∈ h'' and (E−(n), E−(n)) ∈ S+(h'').
k	l	k	k
Now that the environment and notions of consistency are defined, the definition of hedged bisimulation is straightforward. A hedged relation R is a subset of H ×

2 For a logical characterization of hedge consistency, see Chapter 3 of [10].

P × P, where we write h ▶ P R Q for (h, P, Q) ∈ R. We say that R is consistent
if h ▶ P R Q implies that h is consistent.
Definition 2.7 A consistent hedged relation R is a hedged simulation if whenever
h ▶ P R Q we have that

If P −→τ
P' then there exists Q' such that Q −→τ
Q' and h ▶ P' R Q'.

If there are a, b, x, B, M, N, P' such that P  a(x)
P',  h ▶ a ↔ b, B ⊂ N is

finite, B ∩ (fn(P, Q) ∪ n(h)) = ∅, M, N ∈ M, and  h ∪ IdB ▶ M ↔ N , then
there exists Q' such that Q b(x) Q' and h ∪ Id	▶ P' M/ } R Q' N/ }.
If there are a, b, ˜c, M, P' such that P (νc˜) a⟨M⟩ P', h ▶ a ↔ b and {c˜}∩(fn(P )∪
n(π1(h))) = ∅ there are Q', N, d˜ with {d˜}∩ (fn(Q) ∪ n(π2(h))) = ∅

such that Q (νd˜) b⟨N⟩
Q' and I (h ∪ {(M, N )}) ▶ P' R Q'.

R is a hedged bisimulation if both R and R−1 are hedged simulations. We write
∼h for the union of all hedged bisimulations.
On process output we use I (·) to construct the new hedge after the transition. This entails applying all decryptions that the environment can do, producing the minimal extension of the hedge h with (M, N ). This extension may turn out to be inconsistent, signifying that the environment has detected a difference between the messages received from the process pair.

Symbolic Semantics
The idea behind the symbolic operational semantics, as previously described in [11], is to record the necessary conditions for a transition as it is derived. A symbolic

transition is written P μs
φ
P', where μs


∈ {(νc˜) τ, (νc˜) G(x), (νc˜) G⟨F⟩} and φ is the

accumulated conditions for the transition. We let bv(a(x)) := {x} and bn((νc˜) τ ) := bn((νc˜) G⟨F⟩) := bn((νc˜) G(x)) := {c˜}.
Due to the more general message language than in [11], we here introduce a two- stage semantics, where the second stage is responsible for closing the restrictions of names that will only be present in the transition guard. We begin by defining the first stage as a SOS (Table 2). Compared to the concrete semantics, we simply record the sideconditions for the transition in the rules (Sout) and (Sinp). We do not close the resulting process term after a communication in the rule (Scom-r), since the expression that is communicated may contain fresh names that are not extruded in any corresponding concrete transition (cf. Example 3.1).
We intend to use the symbolic semantics to verify if certain assignments to in- put variables, represented by a substitution σ, enable a concrete transition. We do this by comparing the effects of applying the substitution before and after a tran- sition, both on the resulting processes and the transition constraints. However, the single-stage semantics are not sufficient for this purpose, as we see in the following examples.




G⟨F⟩
(Sout) G⟨F⟩.P −−−−−−−−−−→ P
[ G : N ]∧[ F : M ]
G(x)
(Sinp) G x .P −−−−→ P
[ G : N ]



(Srep)
! G(x).P	G(x)
[ G : N ]
P | ! G(x).P



(ν˜b) G⟨F⟩	'	(νc˜) G'(x)	'


(Scom-r)
P −−−−−−→ P
φ1
(ν˜bc˜) τ
P | Q
Q −−−−−−→ Q
φ2
P' | Q' F/ }
if {c˜}∩ fn(P )= ∅ and {˜b}∩ fn(Q)= ∅ and {c˜}∩ {˜b} = ∅

−−−−−−−−−−→	x
φ1∧φ2∧[ G=G' ]


Q μs	'
μs	'

−→ Q
φ
Q −→ Q
φ

(Spar-r)	μs
P | Q −→
φ
P | Q' if (bn(μs)) ∩ fn(P )= ∅


(Ssum-r)	μs
P	Q −→ Q
φ





(Sres)
−→ P'
φ
μs


' if a /∈ n(μs) ∪ n(φ)
−→ P'
φ
(Sguard) φ'P	μs	'

(νa) P −→ (νa) P
φ
−−−→ P
φ∧φ'





(Sopen)
−→ P'
φ


if (fn(μs) ∪ n(φ)) $ a /∈ bn(μs)

(νa) P (νa) μs  P'
φ
Table 2
Symbolic Operational Semantics

Firstly, the resulting processes after concrete resp. symbolic transitions differ in which names are restricted.
Example 3.1 Let	P	:=	(νb) a⟨π1(a. b)⟩.P '	for	some	P'.	Concretely,

a⟨a⟩
P
(νb) a⟨π1(a. b)⟩	'

−−→ (νb) P . Symbolically we have that P
−−−−−−−−−−−−−→
[ a : N ]∧[ π1(a. b): M ]
P , where the

processes after the step only differ in the restriction of the name b. Also note that the scope of the binder for b in the symbolic transition extends to both the transition constraint and the resulting process.
Secondly, the symbolic semantics allow the communication of non-message terms, which after substitution need to be evaluated to coincide with the messages that are communicated in the concrete semantics.
Example 3.2 Now consider Q := a⟨π1(x)⟩| a(y).a⟨y⟩. We can derive

Q −→τ
φ
0 | a⟨π1(x)⟩ =: Q' with φ := [ a : N ] ∧[ π1(x): M ] ∧[ a : N ] ∧[ a = a ].

We do not have [φ]], but the substitution σ :=  (a. a)/x} enables the transition.

Concretely, Q (a. a)/x} −→τ
0 | a⟨a⟩, but 0 | a⟨a⟩ /= 0 | a⟨π1(a. a)⟩ = Q'σ.

As seen in Example 3.1, the symbolic semantics may extrude the scope of more names than the concrete semantics. However, when working with a constructor- destructor expression language, we can compute exactly which names would be extruded by the concrete semantics, using a notion of “abstract evaluation”. This abstract evaluation, ea : E → E , intuitively reduces a term wherever possible, without checking that e.g. decryption and encryption keys correspond.
Definition 3.3 We define	as follows: For each  , if  ( (	)	)	H	',
are pairwise different, σ = Mf/xe} Ne/ye} and M' = σ(z), then g(f (x˜), y˜) →A z. We
then let ea(F ) d=ef F↓ .
A
We let the extruded names of an expression en(F ) be defined inductively by en(a) = {a}, en(x) = ∅, en(g(G˜)) = ∅ and en(fi(G˜)) = ∪j en(Gj).
Example 3.4 Let F := π1(x) and σ :=  (a. a)/x}. We have
ea(F ) = π1(x), ea(F )σ = π1(a. a) and ea(Fσ) = a.
We then have e(F ) = ea(F ) for all F ∈ dom(e), or in other words, ea extends e to the entire set of expressions. Moreover, abstract evaluation commutes with substitution (modulo concrete evaluation). Using abstract evaluation, we define a version of the symbolic transition system that adds back restrictions to the resulting process, yielding a stronger correspondence.
Definition 3.5 We define the transition relation μs	by
φ




CDtau
(ν˜b) τ
P −−−→ P
φ


CDinp
(ν˜b) F (x)
P −−−−−→ P
φ


if {˜b}∩ en(e (F )) = ∅

(ν˜b) τ	˜	'	(ν˜b) F (x)	˜	'

P −−−→ s (νb) P
φ
P −−−−−→ s (νb) P
φ






CDout
(νc˜) F⟨G⟩
P −−−−−−→ P
φ
if	˜b are pair-wise different and {˜b} = {c˜}\ en(ea(G))

(νc˜) F⟨G⟩
P
˜	' and {c˜}∩ en(ea(F )) = ∅

−−−−−−→ s (νb) P
φ

Note that all restrictions are put back at the top level. To cope with this, as well as with the problems outlined in Example 3.2, we introduce the partial order
>a (“more abstract than”), which would be a subset of structural equivalence in an
applied pi-style semantics [2].
Definition 3.6 We let >a be the least reflexive and transitive precongruence on expressions, guards and processes satisfying
F >a M whenever e(F ) = M ; and
(νa) (νb) P >a (νb) (νa) P ; and
(νa) (P | Q) >a ((νa) P ) | Q when a /∈ fn(Q); and

(νa) (P | Q) >a P | ((νa) Q) when a /∈ fn(P ).
Example 3.7 Relating the effects of substituting before and after the transition in Example 3.2, we have Q'σ = (0 | a⟨π1((a. a))⟩. 0) >a (0 | a⟨a⟩. 0).
The relation >a is a (concrete) labelled bisimulation.
Lemma 3.8 If P >a Q then

If P μ
P' then there is Q' such that Q μ
Q' and P' >a
Q'; and

if Q μ
Q' such that bn(μ) ∩ fn(P ) = ∅ then there is P' such that P μ
P' and

P' >a Q'; and
Pσ >a Qσ for all substitutions σ : V ~ M.
Theorem 3.9

If P μs
φ
P1 and σ is idempotent and satisﬁes n(range(σ)) ∩ bn(μs) = ∅, [[φσ]]

and μ := e(μ σ) is deﬁned, then there is P  with Pσ μ  P
and P σ > P .

s	2	−→  2
1	a	2

If σ is idempotent and Pσ μ  P  with n(range(σ)) ∩ bn(μ) = ∅ then there are
1
φ, μ ,P such μ = e(μ σ), [[φσ]], P μs	P  and P σ > P .

s	2	s
−→ s	2
φ
2	a	1

We now have a symbolic operational semantics that is sound and complete with respect to the concrete one (modulo >a, which is a labelled bisimulation) and is finitely branching (modulo choices of bound names and variables).

Symbolic Environments
A symbolic environment is a concise description of a set of hedges, differing only in the instantiations of variables. Here, a variable instantiation is a pair of substitu- tions, that must respect the symbolic environment. The hedges that we get from instantiating variables in an environment-respecting way are called concretizations. The symbolic environments used in this paper are very similar to the ones in [11], with the only difference that we keep explicit track of fresh names. A symbolic environment consists of the following three elements.
A timed hedge th : E × E ~ N containing pairs of messages considered equal by the environment and the time they were received.
A timed variable set tv : V ~ N+ containing input variables and the time they were input.
A pair of restricted formulae ((νC) φ, (νD) ψ) representing the accumulated transition constraints and sets of fresh names.
As mentioned above, the original version of symbolic environments did not include
C and D; they facilitate environment decomposition (Def. 3.15).
Definition 3.10 We write se for the environment (th, tv, ((νC) φ, (νD) ψ)). By abuse of notation, we write φ for (ν∅) φ and (νa) φ for (ν{a}) φ in environments. We let tht := {(F, G)'→th(G, F ) | (G, F ) ∈ dom(th)} in order to swap the sides of a

timed hedge. We let n1(se) := n(π1(dom(th)))∪C∪n(φ), n2(se) := n(π2(dom(th)))∪
D ∪ n(ψ) and n(se) := n1(se) ∪ n2(se).
Intuitively, if the environment knows the pair (F, G) it must have learned about it with the help of the processes at time th(F, G); if this pair contains an input variable x, then the process must have performed this input at the strictly earlier time tv(x).
Definition 3.11 The  environment  se  is  well-formed if  dom(th)  is  finite, 0 ∈ range(th), v(range(th), φ, ψ) ⊆ dom(tv), and whenever (F, G) ∈ dom(th) such that x ∈ v(F, G) then tv(x) < th(F, G).
From here on we only consider well-formed symbolic environments, the set of which is denoted SE. By instantiating the input variables of the symbolic envi- ronment, we can get a concrete (non-timed) hedge. However, such an instantiation must be subject to several constraints, e.g., timing, guard satisfaction and freshness of invented names. For instance, an input performed at time t must be synthesizable from the knowledge of the environment at that time. Similarly to the symbolic early input semantics, we define environment respectfulness for substitutions. Naturally, with the bisimulation environments we need two (possibly different) substitutions, one for each process. We also create some fresh names B.
Definition 3.12 A substitution pair (σ, ρ) is se-respecting with B ⊆ N , written
se ▶ σ ↔B ρ iff (i) to (iv) below hold.
dom(σ) = dom(ρ) = dom(tv)
[φσ]] and [[ψρ]]
if tv(x) = t then (σ(x), ρ(x)) ∈ S (I ({(Fσ↓, Gρ↓) | th(F, G) ≤ t}∪ IdB))
B is fresh and minimal in the sense that (n(range(th)) ∪ C ∪ D) ∩ B = ∅ and if a ∈ B then a ∈ n(range(σ)) or a ∈ n(range(ρ)).
If  se ▶ σ ↔B ρ we can concretize the knowledge th of the symbolic environment
se by letting CB (th) := I ({(e(Fσ), e(Gρ)) | (F, G) ∈ dom(th)}∪ IdB).
In condition iii of the above definition we use Fσ↓ rather than e(Fσ) since the latter
may be undefined. Indeed, CB (th) may be undefined, signifying that a received
message was in fact a non-message expression. This cannot happen when using the symbolic semantics, since the requirement for the transmitted expression to be a message is always added to the transition constraint. This yields a concretizable
symbolic environment (defined below), that always has well defined concretizations.
Example 3.13 Let th := {(x, x) '→ 2}, tv := {x '→ 1} and
σ := ρ :=  Ea(a)/x}. Then we have (th, tv, (tt, tt )) ▶ σ ↔{a} ρ, and

C{a}(th) = {(a, a)} is consistent. If the definition of C·
(·) did not use I (·), then

σ,ρ
·,·

C{a}(th) = {(E (a), E (a)), (a, a)} would not be consistent.
σ,ρ	a	a
Since the se-respecting substitution pairs describe all admissible (with respect to the knowledge and constraints of se) instantiations of input variables, it is interesting

to apply all of them to a pair of formulae (e.g., transition constraints) and study the results. If the formulae are only satisfied simultaneously, they are equivalent from the point of view of the environment. For an environment to be consistent, we require any concretization of its knowledge to be a consistent hedge. We also require that the accumulated constraints are satisfied simultaneously on both sides (the second condition below).
Definition 3.14 We write se ▶ φ' ⇔ ψ' if for all B, σ, ρ : se ▶ σ ↔B ρ im- plies that [φ'σ]] iff [[ψ'ρ]]. se is concretizable if when (F, G) ∈ dom(th) we have se ▶ [ F : M ] ⇔ tt and se ▶ tt ⇔ [ G : M ].

A concretizable symbolic environment se is consistent if CB
whenever se ▶ σ ↔B ρ, and (th, tv, ((νC) tt, (νD) tt )) ▶ φ ⇔ ψ.
(th) is consistent

Note that if se is concretizable and  se ▶ σ ↔B ρ then CB (th) is always defined
and σ and ρ are both idempotent.
When simulating a transition, we often need to consider different cases. In order to split a symbolic environment according to these cases, we may decompose the constraints [8,15]. Since we keep constraints for both sides of the environment we may require that the split is consistent, following [17].
Definition 3.15 Let se = (th, tv, ((νC) φ, (νD) ψ)) be a concretizable symbolic environment. The set {sei}i∈I is a decomposition of se if each sei is of the form (th, tv, ((νC) φi, (νD) ψi), and whenever se ▶ σ ↔B ρ there is i ∈ I such that sei ▶ σ ↔B ρ. A decomposition {sei}i∈I is concretizable/consistent if each sei is concretizable/consistent.
Example 3.16 Let seφ := ({(a, a) '→ 0}, {x '→ 1}, (φ, φ)). {se[ x=a ], se¬[ x=a ]} is a decomposition of sett . Moreover, {se} is a decomposition of any se.
We can fully decompose a consistent environment into an infinite set of environ- ments with unique solutions as follows.
Lemma 3.17 Let se = (th, tv, ((νC) φ, (νD) ψ)) be a consistent environment and
I = {(σ, ρ, B) | se ▶ σ ↔B ρ}. Then {se(σ,ρ,B)}(σ,ρ,B)∈I where
φ(σ,ρ,B) =  x∈dom(tv)[ x = σ(x)] and ψ(σ,ρ,B) =  x∈dom(tv)[ x = ρ(x)] 
is a decomposition of se.
Moreover, for each (σ, ρ, B) ∈ I, se(σ,ρ,B) ▶ σ' ↔B' ρ' iff (σ', ρ', B') = (σ, ρ, B).
In the pi calculus, it is always sufficient to consider a finite number of cases in the decomposition [8]. However, in a spi calculus an infinite split may be needed when treating processes with replication.
Example 3.18 We take a simple expression language that allows us to encode integers. Let Σ = ({s, p}, {s '→ 1, p '→ 1}) with the rewrite rule p(s(x)) → x. This language is a constructor-destructor language, and would also be admissible as a data term language. We write na for the message sn(a).
We define processes P and Q with the same behavior (i.e., P ∼ Q where ∼ is strong labelled bisimulation, as commonly defined). Upon input of a message na,

P non-deterministically decides to diverge or to perform an output on a after n more steps. On the other hand, upon input of na Q non-deterministically decides to become either Q1 or Q2, where Q1 performs an output on a after n steps if n is odd and diverges if n is even, while Q2 performs an output on a after n steps if n is even and diverges if n is odd.
P = a(x).Ω+ a(x).(νc) (P '(x) | !c(y).P '(y))
P'(x)= x⟨a⟩ + c⟨p(x)⟩
Q = (νc) ((a(x).Q1(x)+ a(x).Q2(x)) | !c(y).Q2(y))
Q1(x)=[ x : N ]Ω + c⟨p(x)⟩

Q2(x)= x⟨a⟩ + (νd) (d⟨p(x)⟩| d(z).Q1(z)) Ω= (νc) (c⟨c⟩| !c(z).c⟨c⟩)
After the choice of the first process we need to make a choice in the second process, dependent on whether n is even or odd. Symbolically, in order to make the choice in the second process we need to describe the condition “n is even (odd)” using a disjunction of formulas. We conjecture that this cannot be done with a finite disjunction (of finite formulas) in this guard and expression language.
The question then arises if it would be possible to extend the logical language used in environments to always enable a finite decomposition. However, a more sophisticated version of this example would use that the (finite-control) spi calculus is Turing-complete [16]. We could then let P receive an encoding of a Turing machine and its input and choose between diverging or simulating the machine, signalling failure or success upon termination. Q would make an initial choice and simulate the machine in both cases, diverging on failure (resp. success) and signalling success (resp. failure). A finite decomposition would then require a finite disjunction representing the predicate
“t ∈ {(M . N ) where M codes for a Turing machine that accepts (rejects) N}”. This is clearly also an issue for automated verification. However, in our experiments with simple security protocols we have not had use for any decomposition, suggesting that the actual impact of this issue is highly domain-dependent.

Symbolic Bisimulation
In [11], we defined a notion of symbolic bisimulation that was sound with respect to hedged (concrete) bisimulation, and thus with respect to barbed equivalence. In this section, we extend this definition with environment decompositions, also yielding completeness. The main ingredient of this definition is the symbolic environments seen above, that keep track of the accumulated transition constraints and the time relationships between inputs and outputs in order to make a proper accounting of the knowledge of the adversary.
A symbolic relation R is a subset of SE ×P × P. We write  se ▶ P R Q for (se, P, Q) ∈ R.  R is symmetric if whenever  se ▶ P R Q we have that (tht, tvt, ((νD) ψ, (νC) φ)) ▶ Q R P .  R is consistent if se is consistent and fv(P, Q) ⊆ dom(tv) whenever se ▶ P R Q.

Intuitively, for two processes to be bisimilar under a given environment every possible and detectable transition of one of the processes must yield a decomposition of the resulting environment such that every element in the decomposition has a simulating transition of the other process on a corresponding channel such that the updated environment is consistent. The consistency of the updated environment implies that the simulating transition is also possible and detectable.
Definition 3.19 A symmetric consistent symbolic relation R is a symbolic bisim- ulation if whenever se ▶ P R Q with se = (th, tv, ((νC) φ, (νD) ψ)) and t = max(range(th) ∪ range(tv)) then

(νc˜) τ
P −−−→ s φ'
P' with {c˜}∩ n1(se) = ∅, and there are σ, ρ, B with se ▶ σ ↔B ρ,

[[φ'σ ] and ({c˜}∪ fn(P, Q)) ∩ B = ∅,
then there is a decomposition {sei}i∈I of (th, tv, ((νC ∪ {c˜}) φ ∧ φ', (νD) ψ)) such that for each i	∈	I, there are {e˜}, ψ', Q' with Q	(νe˜) τ
ψ'


Q',

{e˜}∩ (n2(se) ∪ B) = ∅ and (th, tv, ((νC ∪ {c˜}) φi, (νD ∪ {e˜}) ψi)) ▶ tt ↔ ψ'.
Finally, we require (th, tv, ((νC ∪ {c˜}) φi, (νD ∪ {e˜}) ψi)) ▶ P' R Q'.

(νc˜) F (x)
P −−−−−→ s φ'
P' with {c˜}∩ n1(se) = ∅ and x /∈ dom(tv), and there are σ, ρ, B

with se ▶ σ ↔B ρ, [[φ'σ]], e(Fσ) ∈ π1(CB (th)) and ({c˜}∪ fn(P, Q)) ∩ B = ∅,
then there are y /∈ (dom(tv) ∪ {x}) and a decomposition {sei}i∈I of (th, tv', ((νC ∪ {c˜}) φ ∧ φ' ∧ [ y = F ], (νD) ψ)) where
tv' = tv ∪ {x '→ t+1,y '→ t+1}

such that for each	, there are  ˜
'	'	' with
(νe˜) F'(x)	',

i ∈ I
{e˜}∩ (n2(se) ∪ B) = ∅ and
{e},ψ ,Q ,F 
Q −−−−−−→ s Q
ψ'

(th, tv', ((νC ∪ {c˜}) φi, (νD ∪ {e˜}) ψi)) ▶ tt ↔ ψ' ∧ [ y = F' ]. Finally, we require
(th, tv', ((νC ∪ {c˜}) φi, (νD ∪ {e˜}) ψi)) ▶ P' R Q'.



(νc˜) F⟨G⟩
P −−−−−−→ s φ'
P' with {c˜}∩ n1(se) = ∅, and

there are σ, ρ, B with se ▶ σ ↔B ρ, [[φ'σ]], e(Fσ) ∈ π1(CB (th)), x /∈ dom(tv)
and ({c˜}∪ fn(P, Q)) ∩ B = ∅,
then there are y /∈ dom(tv) and a decomposition {sei}i∈I of
(th, tv', ((νC ∪ {c˜}) φ ∧ φ' ∧ [ y = F ], (νD) ψ)) where tv' = tv ∪ {y '→ t+1}

such that for each
, there are	˜
'	'	'
' with
(νe˜) F'⟨G⟩'	',

i ∈ I
{e˜}∩ (n2(se) ∪ B) = ∅ and
{e},ψ ,Q ,F ,G 
Q −−−−−−−→ s Q
ψ'

(th', tv', ((νC ∪ {c˜}) φi, (νD ∪ {e˜}) ψi)) ▶ tt ↔ ψ' ∧ [ y = F' ] where th' = th ∪ {(G, G') '→ i+1} if G, G' /∈ dom(th), th' = th otherwise. Then (th', tv', ((νC ∪ {c˜}) φi, (νD ∪ {e˜}) ψi)) ▶ P' R Q'.
Symbolic bisimilarity, written ∼s, is the union of all symbolic bisimulations.
Symbolic bisimilarity is sound with respect to concrete bisimilarity. The struc- ture of the soundness proof was described in [11], details can be found in [10].

Theorem 3.20 For all processes P, Q, and symbolic environments se such that
se ▶ P ∼s Q we have that CB (se) ▶ Pσ ∼h Qρ for all B ⊂N with fn(P, Q)∩B = ∅
and substitution pairs (σ, ρ) satisfying se ▶ σ ↔B ρ.
By virtue of allowing decompositions, symbolic bisimilarity is complete with respect to concrete hedged bisimilarity.
Theorem 3.21 Assume that se, P, Q  are such that se  is consistent and

B
σ,ρ
(se) ▶ Pσ ∼h Qρ whenever se ▶ σ ↔B ρ with B ∩ fn(P, Q) = ∅. Then

se ▶ P ∼s Q.
Proof. The set R = {(se, P, Q) | se is consistent and CB

(se) ▶ Pσ ∼h Qρ

whenever se ▶ σ ↔B ρ with B ∩ fn(P, Q) = ∅} is a symbolic bisimulation. The
proof uses Lemma 3.17 at every transition.	 

Examples
The processes in the following examples are taken from [11], where they were given as examples of the incompleteness of the earlier version of symbolic bisimilarity (lacking distinctions) proposed in that paper. All these examples start from the same symbolic environment se := ({(a, a) '→ 0}, ∅, (tt, tt )). Since se has no vari-
ables, it has the unique solution h := C∅ ({(a, a) '→ 0}) = {(a, a)}. We assume that
x, y, z, a, k, n are pair-wise different wherever they occur below. The first example shows how decompositions permit a simple case split.
Example 4.1 Let P1 := a(x).a⟨a⟩ and Q1 := a(x).Q' with
' := ([ x = a ]a⟨a⟩ + ¬[ x = a ]a⟨a⟩).	Then se ▶ P1 ∼s Q1.  Specifically, the
symmetric closure of the set
R := {(se, P1, Q1), (se1, a⟨a⟩, Q' ), (se2, 0, 0), (se3, 0, 0) | x, y, z ∈ V} where
se1 := ({(a, a) '→ 0}, {x '→ 1,y '→ 1}, ([ y = a ], [ y = a ]))
se2 := ({(a, a) '→ 0}, {x '→ 1,y '→ 1,z '→ 2}, ([ x = a ] ∧ [ y = a ] ∧ [ z = a ], [ x = a ] ∧ [ y = a ] ∧ [ z = a ]))
se3 := ({(a, a) '→ 0}, {x '→ 1,y '→ 1,z '→ 2}, ((¬[ x = a ]) ∧ [ y = a ] ∧ [ z = a ],
(¬[ x = a ]) ∧ [ y = a ] ∧ [ z = a ]))
is a symbolic bisimulation. We consider (se1, a⟨a⟩, Q' ). The symbolic transition

a⟨a⟩
P
0 is possible and detectable: Letting σ =  a/ } a/ } we have

−−−−−−−−−→ s
[ a : N ]∧[ a : M ]
se1 ▶ σ ↔∅ σ, a ∈ π1(C∅
x	y
(se1)) = {a} and [[([ a : N ] ∧ [ a : M ])σ]].

We choose {se2, se3} as a decomposition of ({(a, a) '→ 0}, {x '→ 1,y '→ 1,z '→ 2}, ([ y = a ] ∧ [ a : N ] ∧ [ a : M ] ∧ [ z = a ], [ y = a ])): se2 and se3 are both consistent since they are symmetric, and for all ρ : {x, y, z} → M we have either [[[ x = a ]ρ]] or [¬[ x = a ]ρ]].

Considering se , Q'
a⟨a⟩
0 where trivially

2	2 −−−−−−−−−−−−−−→ s
[ a : N ]∧[ a : M ]∧[ x=a ]
se2 ▶ tt ↔ [ a : N ] ∧ [ a : M ] ∧ [ x = a ] ∧ [ z = a ].

Similarly, Q'
a⟨a⟩
0 with

2 −−−−−−−−−−−−−−−→ s
[ a : N ]∧[ a : M ]∧¬[ x=a ]
se3 ▶ tt ↔ [ a : N ] ∧ [ a : M ] ∧ (¬[ x = a ]) ∧ [ z = a ].
In general, symbolic bisimulations let us postpone the “instantiation” of input variables until the moment they are actually used. In the following example, the variable x is instead constrained through use of decomposition.
Example 4.2 Let
P2 := a(x).P'	P' := (νc) (c⟨c⟩| c(z) | c(z).[ x = a ]a⟨a⟩)
Q2 := a(x).Q'	' := (νc) (c⟨c⟩| c(z) | [ x = a ]c(z).a⟨a⟩).
Then se ▶ P2 ∼s Q2. Similarly to before, the symmetric closure of the set
R := {(se, P1, Q1)}
∪{(se1, a⟨a⟩, Q' ) | x, y ∈ V}
∪{(se2, 0, 0 | ¬[ x = a ]a⟨a⟩) | x, y, z ∈ V}
∪{(se3, 0, [ x = a ]a⟨a⟩| 0) | x, y, z ∈ V}
where
se1 := ({(a, a) '→ 0}, {x '→ 1,y '→ 2}, ([ y = a ], [ y = a ]))
se2 := ({(a, a) '→ 0}, {x '→ 1,y '→ 2,z '→ 3}, ([ x = a ] ∧ [ y = a ] ∧ [ z = a ], [ x = a ] ∧ [ y = a ] ∧ [ z = a ]))
se3 := ({(a, a) '→ 0}, {x '→ 1,y '→ 2,z '→ 3}, ((¬[ x = a ]) ∧ [ y = a ] ∧ [ z = a ],
(¬[ x = a ]) ∧ [ y = a ] ∧ [ z = a ])) is a symbolic bisimulation.
Orthogonally to the possibility to decompose, the symbolic bisimilarity now also imposes the necessary and sufficient constraints for the environment to detect the process action.
Example 4.3 Let
P3 := a(x).(νk) a⟨Ek(x)⟩.(νn) a⟨EE (a)(n)⟩.n⟨a⟩
Q3 := a(x).(νk) a⟨Ek(x)⟩.(νn) a⟨EE (a)(n)⟩.[ x = a ]n⟨a⟩.
Then se ▶ P3 ∼s Q3: After the first three transitions we have the symbolically hedged process pair (se', n⟨a⟩, [ x = a ]n⟨a⟩) where
se' := (th', tv', ((ν{k}) φ', (ν{k}) φ')
th' := ({(a, a) '→ 0, (Ek(x), Ek(x)) '→ 2, (EE (a)(n), EE (a)(n)) '→ 3}
tv' := {x '→ 1, y1 '→ 1, y2 '→ 2, y3 '→ 3}
φ' := [ y1 = a ] ∧ [ y2 = a ] ∧ [ y3 = a ]
The symbolic transitions of n⟨a⟩ and [ x = a ]n⟨a⟩ are

n⟨a⟩		n⟨a⟩
n⟨a⟩ −−−−−−−−−→ s 0	[ x = a ]n⟨a⟩ −−−−−−−−−−−−−−→ s 0
[ n : N ]∧[ a : M ]	[ n : N ]∧[ a : M ]∧[ x=a ]

Let σ :=  a/x}. As se' ▶ σ ↔∅ σ and C∅ (th') = {(a, a), (E (a), E (a)), (n, n)},
σ,σ	k	k
we have that n ∈ π1(C∅ (th'))), so the transition of n⟨a⟩ must be simulated by
[ x = a ]n⟨a⟩. The environment after the step is
se'' := (th', tv' ∪ {z '→ 5}, ((ν{k, n}) φ' ∧ [ z = n ], (ν{k, n}) φ' ∧ [ z = n ])).
We need to show that se'' ▶ tt ↔ [ n : N ] ∧ [ a : M ] ∧ [ x = a ], i.e., that ρ'(x) = a whenever se'' ▶ σ' ↔B ρ'. First note that [[(φ' ∧ [ z = n ])ρ]] iff
a = ρ(y1) = ρ(y2) = ρ(y3) and ρ(z) = n; we let ρ = a/y } a/y } a/y } n/z}.

Assume that
=	} and
=	}
1	2	3
. We let

h' = {(a, a), (Ek(M ), Ek(N )), (EE (a)(n), EE (a)(n))}. In order to have ρ(z) = n we
k	k
must have (n, n) ∈ S (CB '	' (th')) = S (I (h' ∪ IdB)). Since {k, n} is restricted we
cannot have k, n ∈ B.
Then the only way to derive (n, n) ∈ A(h' ∪ IdB) is by generating
(Ek(a), Ek(a)) ∈ SA(h' ∪ IdB) to analyze (EE (a)(n), EE (a)(n)). Since we cannot
k	k
derive (k, k) ∈ SA(h' ∪ IdB) we must have (Ek(a), Ek(a)) ∈ A(h' ∪ IdB). This is the case iff M = a = N , yielding σ' = a/x  = ρ'.
Finally, se'' is concretizable since dom(th') ⊂M × M and consistent since it is symmetric.

Conclusions
We have given a smooth extension of the message algebra of the spi calculus, treating complex keys and public-key cryptography in a uniform fashion. We have also extended our pre-existing notion of symbolic bisimilarity for the spi calculus [11], making it sound and complete with respect to concrete hedged bisimilarity.
However, the issues of finding appropriate decompositions and deciding symbolic consistency still remain. A promising step in this direction is due to Baudet [6], who studied the symbolic consistency problem in the setting of subterm-convergent rewrite theories, giving an NP algorithm for symbolic consistency for the case of guards without disjunction and negation.

References
Abadi, M. and V. Cortier, Deciding knowledge in security protocols under equational theories, Theoretical Computer Science 367 (2006), pp. 2–32.
Abadi, M. and C. Fournet, Mobile values, new names, and secure communication, in: Proceedings of POPL ’01, 2001, pp. 104–115.
Abadi, M. and A. D. Gordon, A bisimulation method for cryptographic protocols, Nordic Journal of Computing 5 (1998), pp. 267–303.
Abadi, M. and A. D. Gordon, A calculus for cryptographic protocols: The Spi calculus, Journal of Information and Computation 148 (1999), pp. 1–70.
Baldamus, M., J. Parrow and B. Victor, A fully abstract encoding of the pi-calculus with data terms, in: Proceedings of ICALP ’05, LNCS 3580 (2005), pp. 1202–1213.
Baudet, M., “S´ecurit´e des protocoles cryptographiques : aspects logiques et calculatoires,” Ph.D. thesis, E´cole Normale Sup´erieure de Cachan (2007).

Blanchet, B., An efficient cryptographic protocol verifier based on Prolog rules, in: Proceedings of CSFW’01 (2001), pp. 82–96.
Boreale, M., “Process Algebraic Theories for Mobile Systems,” Ph.D. thesis, Universit`a degli Studi di Roma “La Sapienza” (1995).
Boreale, M., R. De Nicola and R. Pugliese, Proof techniques for cryptographic processes, in: Proceedings of LICS ’99, IEEE (1999), pp. 157–166.
Borgstr¨om, J., “Equivalences and Calculi for Formal Verification of Cryptographic Protocols,” Ph.D. thesis, EPFL (2008).
Borgstr¨om, J., S. Briais and U. Nestmann, Symbolic bisimulation in the spi calculus, in: Proceedings of CONCUR ’04, LNCS 3170 (2004), pp. 161–176.
Borgstr¨om, J. and U. Nestmann, On bisimulations for the spi calculus, Mathematical Structures in Computer Science 15 (2005), pp. 487–552.
Delaune, S., S. Kremer and M. D. Ryan, Coercion-resistance and receipt-freeness in electronic voting, in: Proceedings of CSFW’06 (2006), pp. 28–39.
Delaune, S., S. Kremer and M. D. Ryan, Symbolic bisimulation for the applied pi-calculus, in:
Proceedings of FSTTCS’07, LNCS 4855 (2007), pp. 133–145.
Hennessy, M. and H. Lin, Symbolic bisimulations, Theoretical Computer Science 138 (1995), pp. 353– 389.
Hu¨ttel, H., Deciding framed bisimilarity, in: Pre-proceedings of INFINITY ’02, 2002, pp. 1–20.
Johansson, M. and B. Victor, A fully abstract symbolic semantics for the applied pi-calculus (2007), unpublished manuscript.
Milner, R., J. Parrow and D. Walker, A calculus of mobile processes, part I/II, Journal of Information and Computation 100 (1992), pp. 1–77.
Paulson, L. C., The inductive approach to verifying cryptographic protocols, Journal of Computer Security 6 (1998), pp. 85–128.
