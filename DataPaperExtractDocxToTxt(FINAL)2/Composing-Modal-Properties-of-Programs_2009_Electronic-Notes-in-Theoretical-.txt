

Electronic Notes in Theoretical Computer Science 203 (2009) 87–101
www.elsevier.com/locate/entcs

Composing Modal Properties of Programs with Procedures
Marieke Huisman1 ,2
INRIA Sophia Antipolis, France

Dilian Gurov3 ,4
Royal Institute of Technology, Stockholm, Sweden

Abstract
In component based software design, formal reasoning about programs has to be compositional, allowing global, program-wide properties to be inferred from the properties of its components. The present paper addresses the problem of compositional verification of behavioural control flow properties of sequential programs with procedures, expressed in a modal logic. We use as a starting point a maximal model based method previously developed by the authors, which assumes the local properties to be structural (rather than behavioural). To handle local behavioural properties, we propose the combination of the above method with a translation from behavioural properties to sets of structural ones. The present paper presents a direct solution for the logic, and prepares the ground for a translation for the considerably more expressive logic
obtained by adding greatest fixed-point recursion.
Keywords: Program Behaviour, Program Structure, Compositional Verification


Introduction
Background
Component based software design is a design paradigm where several software components, each with their own well-described functionality, are combined into a single application. This technique is becoming increasingly widespread as a means of constructing advanced, complex software systems. However, to ensure the well- functioning and security of the application as a whole, one needs compositional

1 Partially funded by the IST FET programme of the EC, under the IST-2005-015905 MOBIUS project.
2 Email: Marieke.Huisman@sophia.inria.fr
3 Partially funded by the IST FP6 programme of the EC, under the IST-FP6-STREP-27004 S3MS project.
4 Email: dilian@csc.kth.se

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.028

verification techniques that allow to conclude this from the functionality and se- curity properties of the components. Such guarantees are in particular necessary when the different components in the system can communicate and collaborate with each other. In the context of mobile code, development of a compositional verifica- tion techniques becomes even more pertinent, because here new applications can be downloaded post-issuance on a running system.
In general, the problem of compositional verification that we study is the follow- ing: if we wish to ensure that a composed application has global property ψ, can we find local properties φ for the different components, that are sufficient to ensure that the composed application has property ψ. This idea can be described by the following proof principle (where X is a component variable):
▶ A : φ	X : φ ▶ X ⊗ B : ψ
▶ A ⊗ B : ψ
This principle reduces the problem of showing that the composition of A and B
satisfies ψ to the following tasks:
decompose the global property ψ by finding a local property φ of A,
prove correctness of the decomposition, i.e., verify that, for any X satisfying φ, X composed with B satisfies ψ (second premise), and
when a concrete implementation of A has been chosen, verify that it satisfies the local property φ (first premise).
In our work, we focus on applets, that are components described in a sequential pro- cedural language. Applets come equipped with an applet interface I that describes the methods that are defined and required by its implementation.

Compositional verification with maximal models
In earlier work we proposed an approach to compositional verification based on maximal models [9], provided tool support, and evaluated its practical applicability by means of an industrial, electronic purse case study provided by smart card pro- ducer Gemplus [3]. To show that a local property φ is sufficient to ensure a global property ψ, we compute a so-called maximal model w.r.t. φ. This model is max- imal in the sense that it simulates all applets having property φ. We have shown how maximal models can be computed for our simulation logi c, a fragment of the modal μ-calculus with box modalities and greatest fixed-points only. We distinguish two kind of properties: structural and behavioural. Structural properties restrict the set of possible applet implementations, while behavioural properties restrict the possible behaviours. For structural property φ and applet interface I, we can define a maximal applet θI (φ) that simulates exactly all applets with interface I, having property φ. Therefore we can prove that the following proof principle is sound and complete (Theorem 3.11 in [9]):


(structure) A |=s φ	θI(φ)  B |=b ψ
A B |=b ψ
A : I

This principle should be understood as follows. Suppose we have a local structural assumption φ, describing applets with interface I 5 . If we wish to show that any applet having this property can safely interact with some already known applet B, and in particular that this respects some global behavioural safety property ψ, we do this by constructing the maximal applet θI(φ) for φ and I, compose it with B, and model check (using a suitable algorithm, see for a survey [1]) that the resulting applet satisfies ψ. To safely compose applets A and B, one has then also to model check that applet A indeed satisfies the local structural assumption φ.
However, for local behavioural properties the situation is more problematic. In general, given behavioural property φ and interface I, there does not exist a unique maximal applet that simulates all applets (with interface I) with property φ. Sup- pose we have the following behavioural formula [a call b] r, meaning that immediately after a call from method a to method b (that is, at the entry point of b), the atomic proposition r should hold. Even for this simple formula there are two maximal ap- plets (providing and requiring the methods a and b): the first is ’maximal’ but has no call edges labelled b with source an entry node of a (unless this entry node is also a return node, meaning that the call will never be reached), while the second is ’maximal’ but has no entry point of b which is valuated r. Every applet satisfying the formula is simulated by one of these two applets; however, the two applets do not simulate each other.

Characterising behavioural properties with applet structure
There are several ways of addressing this problem. A first possibility is to over– approximate the behaviour with a model which is not necessarily a behaviour. The maximal model of the behavioural formula gives one such approximation. A better approximation can be obtained through a standard product construction between the applet PDA induced by the maximal applet for the given interface and this max- imal model. However, this inherently results in an incomplete verification principle. Therefore, we take another approach and we aim at computing the whole set of maximal applet structures, by characterising a behavioural formula by a set of struc- tural formulae. This paper describes how behavioural modal logic formulae using box modalities only can be characterised by a set of structural formulae. We call this fragment of simulation logic modal simulation logic. It is ongoing work to extend this work to greatest fixed-points; this requires the use of a tableau construction and
a global discharge condition.
We show that in case the formula does not contain disjunctions, this character- isation is exact. Below, we present a translation Π from behavioural modal simu- lation logic formulae into (equivalent) sets of structural properties. This is a first step towards the possibility to apply our compositional verification techniques also when local assumptions are behavioural properties. If a behavioural property can be characterised by a set of structural properties, we can apply our maximal applet construction defined for structural properties (see [9]) to obtain a set of maximal

5 Interfaces will be defined formally below. They specify the set of methods that is known by the applet.

models for the behavioural property. The compositional verification principle then becomes the following:
A |=b φ	{θI(σ) B |=b χ}σ∈ΠI (φ) A: I
A B |=b χ	A
Notice that instead of showing A |=b φ it suffices to show A |=s σ for some σ ∈ ΠI (φ). Apart from filling up a gap in our compositional verification method, this charac- terisation also has a more general interest in itself, as it reveals the relation between structure and behaviour. In particular, in our translation we exploit that a beha- vioural property is trivially satisfied by an applet if the applet structure does not
allow this behaviour.

Related work
Compositional verification of concurrent programs has been studied extensively, especially in the form of assumption/commitment based reasoning about processes with synchronous message passing, and in the form of rely/guarantee based reas- oning for shared-variable concurrency; see e.g. De Roever et al. [7] for a system- atic overview of these and related proof methods. However, these techniques do not address programs with recursive procedures. The use of maximal models for algorithmic compositional verification is due to Grumberg and Long [2] for the uni- versal fragment of CTL, later extended to CTL* by Kupferman and Vardi [5]. These works study synchronous parallel compositions of sequential processes under fairness assumptions. We adopt this approach to simulation logic in the present context of compositional verification of control-flow properties of sequential programs with pro- cedures in [9]. To the best of our knowledge, the present work is the first to address the characterisation of behavioural control-flow properties in terms of structural ones.

Structure of the paper
Section 2 gives a short overview of our earlier results, in particular the program structure and behaviour, the logic and the definition of maximal model. It also in- troduces useful notations. Section 3 defines the translation from behavioural modal simulation logic formulae to structural formulae, and proves its correctness. Sec- tion 4 proves soundness and completeness of a compositional verification principle for behavioural properties without disjunctions, provided the local assumptions are described by behavioural modal simulation logic. Finally, Section 5 gives conclusions and discusses future work.

Preliminaries: model and logic
We briefly recall some definitions and results that form the basis for our composi- tional verification method. For a full overview, the reader is referred to [8,9].

Modal simulation logic
We use a subset of modal logic as our specification language. In our work on compos- itional verification, we exploited that formulae in this logic, extended with greatest fixed-points can be characterised by simulation, and vice versa; therefore we call that logic simulation logic. The subset of simulation logic that we consider in this paper is modal simulation logic. Throughout, we fix a set of labels L and a set of atomic propositions A.
Definition 2.1 (Modal Simulation Logic) The formulae of modal simulation logic are inductively defined by:

φ ::= p | ¬p | φ1 ∧ φ2 | φ1 ∨ φ2 | [a] φ
where p ∈ A and a ∈ L.
The semantics of the logic is standard for modal logics and is given in terms of models (Kripke structures). In particular, formula [a] φ holds of a state (“possible world”) if φ holds in all states accessible from the former state via an edge labelled a. Notice that the constant formulae true and false are definable; they shall be denoted tt and ff, respectively. For convenience, we shall use φ1 ⇒ φ2 to abbreviate ¬φ1 ∨ φ2.
Next, we define a general notion of model and specifications.
Definition 2.2 (Model) A model is a structure M = (S, L, →, A, λ), where S is a set of states, →⊆ S × L × S a labelled transition relation, and λ : S → P(A) a valuation, assigning to each state s the atomic propositions that hold in s. A specification S is a pair (M, E), where M is a model and E ⊆ S is a set of states.
Intuitively, one can think of E as the set of entry states of the model. We define the usual notions of satisfaction (M, s) |= φ and simulation (M1, s1) ≤ (M2, s2) (where related states satisfy the same atomic propositions). A specification satisfies a formula if all its entry states satisfy the formula. A specification is simulated by another specification if for all its entry states there exists an entry state in the other specification, that simulates this first entry state. This simulation relation preserves (backwards) logical properties.
Theorem 2.3 S1 ≤ S2 and S2 |= φ implies S1 |= φ
Proof Corollary 2.16 in [9]	 

Applet structure and behaviour
Our program model, inspired by [4], is control–flow based and thus over–approxi- mates actual program behaviour. It defines two different views on applets: a struc- tural and a behavioural view. Both views are instantiations of the general notions of model and specification. Notice in particular that these instantiations yield a structural and a behavioural version of simulation and simulation logic. Again, we refer to [8,9] for more detail.

Applet Structure
Since we abstract away from all data, applet structure is defined as a collection of call graphs for the methods that the applet implements. Let Meth be a countably infinite set of method names. A method specification is an instance of the general notion of specification.
Definition 2.4 (Method specification) A method graph for m ∈ Meth over a finite set M ⊆ Meth of method names is a finite model

Mm = (Vm, Lm, →m, Am, λm)

where Vm is the set of control nodes of m, Lm = M ∪ {ε}, Am = {m, r}, and λm : Vm → P(Am) is so that m ∈ λm(v) for all v ∈ Vm ( i.e. each node is tagged with its method name). The nodes v ∈ Vm with r ∈ λm(v) are called return points. A method specification for m ∈ Meth over M is a pair (Mm, Em), where Mm is a method graph for m over M and Em ⊆ Vm is a non–empty set of entry points of m.
Next we define the notion of applet interface.
Definition 2.5 (Applet interface) An applet interface is a pair I = (I+,I−), where I+,I− ⊆ Meth are finite sets of names of provided and required methods, respectively. The composition of two interfaces I1 = (I+,I−) and I2 = (I+,I−) is

defined by I1 ∪ I2 = (I+ ∪ I+,I− ∪ I−).
1	1	2	2

1	2	1	2
To formally define the notion applet with interface, we use the notion of disjoint union of specifications S1  S2, where each state is tagged with 1 or 2, respectively,

and
a
(s, i) −→S1 S2
(t, i), for i ∈ {1, 2}, if and only if
a
s −→Si t.

Definition 2.6 (Applet) An applet A with implementation interface I, written
A : I, is defined inductively by
(Mm, Em): ({m},M ) if (Mm, Em) is a method specification for m ∈ Meth over
M, and
A1  A2 : I1 ∪ I2 if A1 : I1 and A2 : I2.
An applet is closed if I− ⊆ I+, i.e. it does not require any external methods.
Simulation and satisfaction, instantiated to this particular type of models are called structural simulation ≤s, and structural satisfaction |=s, respectively.
Example 2.7 As an illustration of properties in structural modal simulation logic, consider first formula a ⇒ [b] ff (which, as explained above, abbreviates ¬a ∨ [b] ff). It holds of a control node v if either v |= ¬a (that is, a /∈ λ(v), meaning v does not

belong to method a) or else all nodes v' such that
b
v −→a
v' satisfy ff, meaning no

such nodes v' exist (since no node satisfies ff). The formula holds of an applet if it holds for all its entry nodes; it hence specifies that from any entry node of method
a, there is no call edge to method b. Similarly, the formula b ⇒ r specifies that no entry node of method b is a return node.

Modal logic is not capable of expressing general invariant or reachability proper- ties such as “no call edge to method b is reachable from an entry node of method b”; however, such properties are easily expressed in full structural simulation logic (see [9]).
Applet behaviour
Next we instantiate specifications on the behavioural level.
m ∈ I+	v →m v'	v |= ¬r

(transfer)
(v, σ) −→τ
(v', σ)



m ,m 
∈ I+
m2	v'
v |= ¬r

1	2	v1 −−→m1 1	1
v2 |= m2	v2 ∈ E

(call)
m1call m2	'

(v1, σ) −−−−−−→ (v2, v1 · σ)

(return)

m1, m2 ∈ I+	v2 |= m2 ∧ r	v1 |= m1


m2 ret m1
(v2, v1 · σ) −−−−−−→ (v1, σ)
Figure 1. Applet Transition Rules


Definition 2.8 (Behaviour) Let A = (M, E) : I be a closed applet where M = (V, L, →, A, λ). The behaviour of A is described by the specification b(A)= (Mb, Eb), where Mb = (Sb, Lb, →b, Ab, λb) is such that Sb = V × V ∗, i.e. states (also called configurations) are pairs of control points and stacks, Lb = {m1 k m2 | k ∈
{call, ret}, m1, m2 ∈ I+}∪ {τ }, →b is defined by the rules of Figure 1, Ab = A, and λb((v, σ)) = λ(v).
The set of initial states Eb is defined by Eb = E × {ϵ}, where ϵ denotes the empty sequence over V .
Note that applet behaviour defines a pushdown automaton. We exploit this by using a model checker for PDAs to verify behavioural properties (see, e.g., [1] for a survey of verification techniques for infinite process structures).
Also on the behavioural level, we instantiate the definitions of simulation ≤b and satisfaction |=b: A1 ≤b A2 ⇔ b(A1) ≤ b(A2) and A |=b φ ⇔ b(A) |= φ. Any two applets that are related by structural simulation, are also related by behavioural simulation (Theorem 3.9 in [9]), but the converse is not true (since behavioural simulation only requires reachable states to be related).
Example 2.9 As an example of a property in behavioural modal simulation logic, consider formula [a call b] r. A configuration (v, σ) satisfies the formula if all config- urations that are reached from (v, σ) by performing a call from method a to method b satisfy r (that is, have a return node as control point). The formula holds of an applet if it holds of all its initial configurations; it hence specifies that if the first ac- tion of the applet is a call from method a to method b, then immediately afterwards

we should be at a return node.
Again, invariant behavioural properties such as “method a never calls method b” are beyond the expressive power of modal logic, but are easily expressed in full behavioural simulation logic.
Clean applet structures
Notice that method specifications allow return points to have outgoing edges. How- ever, the characterisation of behavioural properties by a set of structural formulae defined later is only correct if the applet has no outgoing edges in return nodes; such applets are referred to as clean. We define a unary operation of cleaning returning a clean applet having the same behaviour.
Definition 2.10 [Cleaning] Given a method specification Mm = (Vm, Lm, →m
, Am, λm), the unary operation of cleaning is defined by:
M• = (Vm, Lm, {s −→l m t | s −→l m t ∧ r /∈ λm(s)}, Am, λm)
It is easy to see that cleaned applets are clean. We list several useful properties of cleaning.
(A•)• = A•
A |=b φ ⇔ A• |=b φ
(A•, s) |=s r ⇒ ∀l, σ. (A•, s) |=s [l] σ
Thus, cleaning is idempotent and preserves behavioural properties. And any state that is a return point, trivially satisfies any box formula at the structural level. Below, in the correctness proof of the characterisation, we will define a notion of reachability (the set of nodes that can be reached by a behaviour), and we will use that on clean applets this coincides with the satisfaction of box formulae.
Compositional verification using maximal applets
Our compositional verification method, presented in [9], is based on the computation of maximal models for a property φ. A model is said to be maximal for property φ, if it simulates all other models having property φ. However, when we have a property φ over applet structure (or applet behaviour), we can not be sure that the maximal model of φ is also a legal applet structure (or applet behaviour). For applet structures, this problem can be solved, because we can precisely characterise legal applet structures w.r.t. an interface I as a formula in simulation logic (instantiated at the structural level). If φI is the characteristic formula for an applet with interface I, and φ is an arbitrary structural formula, then the maximal model of the formula φ ∧ φI precisely characterises all applets with interface I satisfying φ. Thus, if we define the maximal applet w.r.t. φ and I, denoted θI(φ), to be the maximal model of the property φ ∧ φI , then we can prove that the following compositional verification principle is sound and complete for full simulation logic (Theorem 3.11 in [9]):



(structure) A |=s φ	θI(φ)  B |=b ψ
A B |=b ψ
A : I

For our subset modal simulation logic, we can only prove soundness of this rule. To establish completeness for full simulation logic, we use that every model can be characterised with a characteristic formula. But, since specifications can contain loops, the availability of greatest fixed-points is essential here.
As explained above, there is no such way to precisely characterise applet beha- viour, thus we cannot establish soundness and completeness of the same composi- tional verification principle for local formulae over applet behaviour. Below we will define a translation of behavioural formulae into sets of structural formulae, which will allow us to exploit the compositional verification principle for applet structure to perform compositional verification of applet behaviour properties.

Notational conventions
We use label ε for transfer edges in applet structures, and label τ for silent behavi- oural transitions.
For sequences σ, we use σ to denote the top element (head), and σb to denote the sequence with the top element removed (tail), i.e. (v · σ) = v and (v · σ)b = σ. The empty sequence is denoted as ϵ, where ϵ and ϵb are undefined.
In our translation of modal simulation logic formulae we allow sequences α of labels to appear in box modalities, with the obvious translation ˆ· to standard for- mulae:
[ϵ] ψ = ψ
^	^
[l · α] ψ = [l] [α] ψ

Characterising behavioural properties
We shall assume throughout this section that applets are clean; if they are not, they can be cleaned as explained above without changing the behaviour. We define a mapping Π from behavioural properties to sets of structural properties, for which we can prove that
A |=b φ ⇐ ∃σ ∈ Π(φ).A |=s σ
The reason for this not being an equivalence is that (unlike the remaining con- nectives of the logic) disjunction cannot be treated compositionally: the validity of A |=b φ ∨ ψ cannot be inferred just from the validity (or invalidity) of A |=b φ and A |=b ψ, since A |=b φ ∨ ψ may hold because some initial configurations of A satisfy φ while the rest satisfy ψ. However, if behavioural property φ does not contain disjunction, the mapping is exact, and we obtain an equivalence (i.e. we find the precise set of structural formulae characterising a behavioural property).
A |=b φ ⇔ ∃σ ∈ Π(φ).A |=s σ	(φ disjunction-free)	(1)


π(i,F )·H (p) = {i ⇒ [F ] p}∪ {i' ⇒ [F '] ff | (i',F ') ∈ H}
π(i,F )·H(¬p) = {i ⇒ [F ] ¬p}∪ {i' ⇒ [F '] ff | (i',F ') ∈ H}
π(i,F )·H (φ1 ∧ φ2) = {σ1 ∧ σ2 | σ1 ∈ π(i,F )·H (φ1), σ2 ∈ π(i,F )·H (φ2)}
π(i,F )·H (φ1 ∨ φ2) = π(i,F )·H (φ1) ∪ π(i,F )·H (φ2)
π(i,F )·H ([τ ] φ) = π(i,F ·ε)·H (φ)
⎧ {tt}	if i /= a
π(i,F )·H([a call b] φ) = 
⎩⎧ π(b,є)·(i,F ·b)·H (φ)	if i = a
π(i,F )·H ([a ret b] φ) = 
⎩ {i ⇒ [F ] ¬r} ∪ πH(φ)	if i = a ∧ π1(H )= b

Figure 2. The mapping πH

Mapping behavioural properties into structural properties
Our translation is based on a symbolic execution of the behavioural property. First, we define the (auxiliary) mapping πH : Behform → P(Structform ), parametrised by a non-empty history stack H. Each element in the history stack is a tuple containing the current method name and a sequence (called frame) of edge labels, i.e.: H : (I+ × (I− ∪ {ε})∗)+.
The mapping π is initially applied with an initial history stack containing a single element with an empty frame. We use ∅H,m to denote this single element sequence (m, ϵ).
The history stack is updated as follows:
when the behavioural property prescribes a call from a to b, and the top element of H is in method a, we add b at the end of this frame, and we push a new element (b, ϵ) onto H;
when the behavioural property prescribes a return from a to b, the top element of H is in method a and the previous element is in method b, we pop the top element from H; and
when the behavioural property prescribes an internal transfer, we append ε to the end of the frame of the top element of H.
The mapping π is defined in Figure 2 by induction on the structure of the formula. The mapping symbolically executes the formula, and for every box modality that it encounters labelled with a return, it generates one structural formula capturing the possibility that this behaviour cannot happen. The recursive call will then generate other structural formulae, that will have to hold in case the described behaviour actually took place. Symbolic execution of the box modality labelled with a call or an internal transfer does not produce any explicit structural formula

(capturing the possibility that this transition is not possible), because such a formula would always be subsumed by the structural formulae generated by the remaining formula. When the translation encounter (the negation of) an atomic proposition, it generates a formula characterising the case that the atomic proposition holds in the current frame. In addition, it generates formulae characterising the possibility that the applet does not satisfy one or more of the structural constraints collected in the history stack (in which case the current atomic proposition would never be evaluated). Notice that πH(tt) = {tt}. Notice further that non-emptiness of the history stack is an invariant of the construction.
Finally, we can define the mapping of φ w.r.t. a given interface I:

ΠI (φ) = {  m∈I+ σm | σm ∈ π∅H,m (φ) }
This last expression gives rise to an explosion in the number of formulae, but note that for the compositional verification we only need the weakest structural formulae of this set. In particular, as soon as a set contains tt, all other elements can be removed from the set, because any applet will satisfy the local assumption tt.

Examples
The working of this mapping is best explained with some examples. Throughout we assume I = ({a, b, c}, {a, b, c}).
Example 3.1 Consider the following translations.
π∅H,a ([a call a] r)= π(a,є)·(a,a)(r)= {a ⇒ r, a ⇒ [a] ff}
π∅H,a ([a call b] [b call a] [a call b] r)= {b ⇒ r, a ⇒ [b] ff,b ⇒ [a] ff} π∅H,a ([a call b] [b ret a] [a call c] r)= {c ⇒ r, a ⇒ [b · c] ff,b ⇒ ¬r} π∅H,a ([a call b] [b ret d] ff)= {tt}
The first property concerns a selfcall, the second a callback and the third a return. The last property shows how nonsense returns (causing formulae to be vacuously true) are detected.
The next example shows a computation for the whole interface with a call behaviour.
Example 3.2 We examine the property from Example 2.9.

π∅H,a ([a call b] r) = {b ⇒ r, a ⇒ [b] ff}
π∅H,b ([a call b] r) = {tt}
π∅H,c ([a call b] r) = {tt}

ΠI ([a call b] r) = {b ⇒ r ∧ tt ∧ tt,a ⇒ [b] ff ∧ tt ∧ tt}

And finally, the last example shows a computation for the whole interface with only internal behaviour.
Example 3.3

π∅H,a ([τ ] ff) = {a ⇒ [ε] ff}
π∅H,b ([τ ] ff) = {b ⇒ [ε] ff}
π∅H,c ([τ ] ff) = {c ⇒ [ε] ff}

ΠI ([τ ] ff) = {a ⇒ [ε] ff ∧ b ⇒ [ε] ff ∧ c ⇒ [ε] ff}

Correctness of the Translation
To show the correctness of the translation, we generalise the notion of satisfaction by relativising it on the history stack. As for the translation, in the proof we also assume applet A to be clean.
Intuitively, the generalised notion of satisfaction, relativised w.r.t. H, can be understood as follows: A |=H φ holds for applet A and formula φ if for any node v in method i that can be reached by following the path described by the frame in the top element of H and for any callstack σ that corresponds to the rest of the history stack we have (v, σ) |=b φ.
To define this formally, we need several auxiliary definitions. First we define a function reach, that computes given applet A, a set of nodes V and sequence of labels L, which nodes are reachable in A from the nodes in V , following edges with the labels in L.
reachA(V, ϵ) = V
reach (V, l · L) = reach ({v' | v ∈ V ∧ v −→L	v'}, L)
The correspondence between concrete callstack σ and history stack H is defined as follows: if σ = v and H = (i, F ) then we require that v ∈ reachA(Ei,F ) and that σb and Hb correspond. Formally this is defined as follows:
γA(ϵ, ϵ) = tt	γA(v · σ, ϵ)= ff	γA(ϵ, (i, F ) · H)= ff
γA(v · σ, (i, F ) · H) = v ∈ reachA(Ei,F ) ∧ γA(σ, H)
Notice that γA(v · σ, ∅H,i) holds whenever v ∈ Ei and σ = ϵ, since v ∈ Ei whenever
v ∈ reachA(Ei, ϵ).
We are now ready to define formally the generalised notion of satisfaction.
Definition 3.4 Given applet A and history stack H, we define generalised satisfac- tion w.r.t. H by:
A |=H φ ⇔ ∀v, σ.(γA(v · σ, H) ⇒ (v, σ) |=b φ)

A |=(i,F )·H [a call b] φ
⇔ ∀v, σ.(v ∈ reachA(Ei,F ) ∧ γA(σ, H) ⇒ (v, σ) |=b [a call b] φ)	{Def. 3.4, γA}
⇔ ∀v, σ.(v ∈ reachA(Ei,F ) ∧ γA(σ, H) ⇒	{Def. |=b}
b
∀v1, v2.(v −→i v1 ∧ v2 ∈ Eb ⇒ (v2, v1 · σ) |=b φ))
⇔ ∀v, v1, v2, σ.(v ∈ reachA(Ei,F ) ∧ γA(σ, H) ∧ v −→b i v1 ∧ v2 ∈ E ⇒	{Logic}
(v2, v1 · σ) |=b φ)
⇔ ∀v1, v2, σ.(v1 ∈ reachA(Ei,F · b) ∧ γA(σ, H) ∧ v2 ∈ Eb ⇒	{Def. reachA}
(v2, v1 · σ) |=b φ)
⇔ ∀v1, v2, σ.(v2 ∈ Eb ∧ γA(v1 · σ, (i, F · b) · H) ⇒ (v2, v1 · σ) |=b φ)	{Def. γA}
⇔ ∀v1, v2, σ.(v2 ∈ reachA(Eb, є) ∧ γA(v1 · σ, (i, F · b) · H) ⇒ (v2, v1 · σ) |=b φ) {Def. reachA}
⇔ ∀v1, v2, σ.(γA(v2 · v1 · σ, (b, є) · (i, F · b) · H) ⇒ (v2, v1 · σ) |=b φ)	{Def. γA}
⇔ A |=(b,c)·(i,F ·b)·H φ	{Def. 3.4}
⇔ ∃σ ∈ π(b,c)·(i,F ·b)·H (φ). A |=s σ	{Ind. hyp.}
⇔ ∃σ ∈ π(i,F )·H ([a call b] φ). A |=s σ	{Def. π}

Figure 3. Correctness proof for case [a call b]φ

The standard notion of satisfaction can be related to this relativised notion of sat- isfaction as follows.
Proposition 3.5 A |=b φ ⇔ ∀m ∈ I+. A |=∅	φ
We can now state the main theorem that allows us to show the correctness of the translation.
Theorem 3.6 Let A be an applet, H be a history stack, and φ be a disjunction-free behavioural formula. Then:
A |=H φ ⇔ ∃σ ∈ πH (φ). A |=s σ

Proof This theorem has been formalised and proven correct with the PVS theorem prover [6] by using induction on the structure of φ. The two main properties used in the proofs are the following:
(∀v.v ∈ reachA(Ei, L) ⇒ v |= σ) ⇔A |= [L] σ
(∃σ.γA(σ, H)) ⇔ (∀φ ∈ {i ⇒ [F ] ff | (i, F ) ∈ H}.A |= φ)
The rest of the proof is a careful rewriting of definitions, case analysis and use of logic. Figure 3 shows the complete derivation for one of the most interesting cases, namely case [a call b] φ when i = a.	 
Equivalence (1) is a straightforward corollary of Theorem 3.6 and Proposition 3.5.

Compositional verification for behavioural properties
The results in the preceding section justify the following compositional verification principle where φ is a behavioural formula of modal simulation logic.
A |=b φ	{θIA(σ) B |=b χ}σ∈Π(φ)I
	A  A: IA
A B |=b χ

Notice that instead of showing A |=b φ it suffices to show A• |=s σ for some
σ ∈ Π(φ)ΙA .
Soundness of this rule follows from equation (1) and the soundness of the com- positional verification principle for structural formulae (structure). Since the com- positional verification principle is not complete if we restrict ourselves to modal simulation logic, we do not get completeness. However, since the characterisation of behavioural formulae described in this paper is exact, provided the formula does not contain disjunctions, once it has been extended with greatest fixed-points, we can exploit the fact that satisfaction and simulation characterise each other, to also get a complete compositional verification principle for behavioural formulae.

Conclusion
This paper describes a translation from behavioural to structural properties. The translation is defined for so-called modal simulation logic, which corresponds to modal logic with box modalities only. In earlier work, we defined a compositional verification principle where local properties have to be structural properties. Based on this principle, we developed a compositional verification method, provided ma- chine support by means of a tool set, and evaluated the practical applicability of the method on an industrial case study. By having a translation from behavioural to structural properties, we extend the compositional verification principle to behavi- oural properties. The translation proceeds by symbolic execution of the behavioural formula: each modality in this formula gives rise to a constraint on the structures that satisfy the behavioural formula. It has been implemented in Ocaml and in- cluded in the tool set.
The logic fragment for which we have defined the translation is quite restricted, but the work described in this paper forms part of a bigger project, where we are extending the translation to greatest fixed-points. This extension requires that the translation is recast into a tableau construction, unfolding the greatest fixed-point operator until some global discharge condition holds, meaning that the fixed-point has been sufficiently unfolded to capture all structural properties. However, we feel that the translation of the modal logic fragment in itself merits a detailed description, because this is the point in the translation where the interplay between behaviour and structure is the most prominent.
In a different line of work, we are currently investigating whether we can ex- tend the translation to also take diamond modalities into account. However, since diamond modalities cannot be characterised by simulation of standard models, this would not contribute further to our work on compositional verification.

References
Burkart, O., D. Caucal, F. Moller and B. Steffen, Veriﬁcation on inﬁnite structures, in: J. Bergstra,
A. Ponse and S. Smolka, editors, Handbook of Process Algebra, North Holland, 2000 pp. 545–623.
Grumberg, O. and D. Long, Model checking and modular veriﬁcation, ACM TOPLAS 16(3) (1994),
pp. 843–871.


Huisman, M., D. Gurov, C. Sprenger and G. Chugunov, Checking absence of illicit applet interactions: a case study, in: M. Wermelinger and T. Margaria, editors, Fundamental Approaches to Software Engineering, FASE’04, number 2984 in LNCS (2004), pp. 84–98.
Jensen, T., D. L. Métayer and T. Thorn, Veriﬁcation of control flow based security policies, in: IEEE Symposium on Research in Security and Privacy (1999), pp. 89–103.
Kupferman, O. and M. Vardi, An automata-theoretic approach to modular model checking, ACM TOPLAS 22 (2000), pp. 87–128.
Owre, S., J. Rushby, N. Shankar and F. v. Henke, Formal veriﬁcation for fault-tolerant architectures: Prolegomena to the design of PVS, IEEE Transactions on Software Engineering 21 (1995), pp. 107–125.
Roever, W.-P. d., F. d. Boer, U. Hannemann, J. Hooman, Y. Lakhnech, M. Poel and J. Zwiers, “Concurrency Verification: Introduction to Compositional and Noncompositional Methods,” Number 54 in Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, Cambridge, UK, 2001.
Sprenger, C., D. Gurov and M. Huisman, Simulation logic, applets and compositional veriﬁcation, Technical Report RR-4890, INRIA (2003).
Sprenger, C., D. Gurov and M. Huisman, Compositional veriﬁcation for secure loading of smart card applets, in: Formal Methods and Models for Co-Design (Memocode 2004) (2004), pp. 211–222.
