

Electronic Notes in Theoretical Computer Science 270 (1) (2011) 41–57
www.elsevier.com/locate/entcs

Game Semantics for Quantum Data
Yannick Delbecquea,1 ,2
a School of computer science McGill University Montreal, Canada

Abstract
This paper presents a game semantics for a simply-typed λ-calculus with qbits constants and associated quantum operations. The resulting language is expressive enough to encode any quantum circuit. The language uses a notion of extended variable, similar to that seen in functional languages with pattern matching, but adapted to the needs of dealing with tensor products. The game semantics is constructed from classical game semantics using quantum interventions as questions and measurements results as answers. A soundness result for the semantics is given.
Keywords: Game semantics, quantum programing languages, quantum games.


Introduction
An important problem in the development of higher-order quantum programming languages is to find an appropriate structure to define a denotational semantics. Previous works on quantum λ-calculi were based on the idea that quantum data should be used linearly since it cannot be duplicated. This idea was implemented by adding a quantum tensor type operation and typing rules to forbid duplication. This approach may seem natural, but the often counterintuitive behavior of classical- quantum interactions makes difficult the construction of the appropriate syntax and typing rules. Since no denotational semantics could be found for a complete quantum λ-calculus, we still lack a soundness result for a complete language that would validates the choices made. For example, there was no denotational semantics given in the first presentations of the quantum λ-calculus developed by Selinger and Valiron [14,16]. They proposed in [15] a denotational semantics for the linear part of the quantum λ-calculus; their interpretation is in the category of completely positive maps on finite dimensional Hilbert spaces. Working with this restricted

1 This research was supported by a grant from NSERC (Canada)
2 Email: yannick@delbecque.org

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.005

language allows them to avoid the problem of finding a structure which can model completely the possible interactions between quantum data and classical data in higher order quantum programming languages.
In this paper we introduce a new λ-calculus equipped with extra structure to al- low it to represent manipulation of quantum data. The proposed language was build with the goal of proving soundness using a denotational semantics where quantum states and operations are represented represented as strategies which makes some- one choose the actions according to the laws of quantum mechanics. Our proposed model is built upon ideas from game semantics augmented with quantum strategies which describe the behavior of quantum states and quantum operations.
The language we define in this paper introduces new features and ideas. Perhaps one of the most important one is the fact that we forbid abstraction over part of a tensor of unknown qbits of the form x ⊗ y. This is motivated by the fact that ab- straction should intuitively be interpreted using a correspondence between programs of type qbit ⊗ qbit ( qbit ⊗ qbit with those of type qbit ( (qbit ( qbit ⊗ qbit). This seems problematic, since this should be a correspondence between functions with two input qbits, which may be in some entangled state, with functions using only separated qbits. A consequence of this is that there is no tensor type operation
in the proposed language, only types qbit⊗n for n qbits. We use extended variables, which are tensor of variables, to keep track of possible entanglements between qbit variables. Finally, the model forces us to distinguish between tensor of known and unknown qbits, leading to three different typing rules for the tensor operations.




Simply typed λ-calculus with quantum data

Syntax

We now introduce a λ-calculus with quantum data language (QDL). The syntax of QDL is that of a classical simply typed λ-calculus with pairing and conditionals, with extra constructs that give the language enough expressiveness to encode usual manipulations of quantum data as can be described with the low level formalism of quantum circuits.
We first need to introduce a syntax which allows one to refer to specific qbits in a tensor product. An extended variable is an expression of the form x1 ⊗ ··· ⊗ xn, where the xi are variables such that xi /= xj if i /= j. Two extended variables x1 ⊗··· ⊗ xn and y1 ⊗···⊗ ym are disjoint if xi /= yj for all i, j. Two such extended variables can be joined to form a new extended variable x1 ⊗··· ⊗ xn ⊗ y1 ⊗··· ⊗ ym. Note that when we use x1 ⊗ ··· ⊗ xn to refer to an arbitrary extended variable, the case n = 1 is also possible. To simplify the notation, we use x instead of x1⊗·· ·⊗xn, leaving the number n implicit.



Table 1 QDL typing rules.

Γ, Δ, x : A ▶ x : A	Γ, Δ ▶ ∗: T	Γ, Δ ▶ 0: bool	Γ, Δ ▶ 1: bool

Γ, Δ, x : A ▶ M : B
Γ, Δ ▶ λx. M : A ⇒ B
Γ, Δ1 ▶ M : A ⇒ B	Γ, Δ2 ▶ N : A
Γ, Δ1, Δ2 ▶ MN : B

Γ, Δ1 ▶ M1 : A1	Γ, Δ2 ▶ M2 : A2
Γ, Δ1, Δ2 ▶ ⟨M1, M2⟩ : A1 × A2
Γ, Δ ▶ M : A × B
Γ, Δ ▶ fst M : A
Γ, Δ ▶ M : A × B
Γ, Δ ▶ snd M : A

Γ, Δ1 ▶ P : bool	Γ, Δ2 ▶ M : A	Γ, Δ2 ▶ N : A		
⊗n
Γ, Δ1, Δ2 ▶ if P then M else N : A	Γ, Δ ▶ ρ : qbit

Γ, Δ1 ▶ Q : qbit⊗(n+1)	Γ, Δ2,b : bool, x : qbitn ▶ M : A
Γ, Δ1, Δ2 ▶ let b, x = measi Q in M : A
Γ, Δ ▶ M : qbit⊗n Γ, Δ ▶ U M : qbit⊗n

Γ, Δ ▶ Q : qbit⊗n	Γ, Δ1 ▶ M1 : qbit⊗n	Γ, Δ2 ▶ M2 : qbit⊗m

Γ, Δ ▶ meas Q : bool
Γ, Δ1, Δ2
▶ M1
⊗ M : qbit⊗n ⊗ qbit⊗m	FV(Mi) ∩ |Δi| = ∅

Γ, Δ1, x1 : qbit⊗n ▶ M1 : qbit⊗n	Γ2, Δ2, x2 : qbit⊗m ▶ M2 : qbit⊗m

Γ, Δ , Δ , x
⊗ x : qbit⊗n ⊗ qbit⊗m ▶ M
⊗ M : qbit⊗n ⊗ qbit⊗m	FV(Mi) \ |Δi| = {xi}

1	2  1	2	1	2

Γ, Δ1, x : qbit⊗n ▶ M1 : qbit⊗n	Γ, Δ2 ▶ M2 : qbit⊗m Γ, Δ1, Δ2, x : qbit⊗n ▶ M1 ⊗ M2 : qbit⊗n ⊗ qbit⊗m
FV(M1) \ |Δ1| = {x1}
FV(M2) ∩ |Δ2| = ∅



The terms of QDL are defined recursively as follows:
M, N, P := x |∗ | 0 | 1 | ρ | ⟨M, N ⟩ | fst M | snd M |
MN  | λx. M | if M then N else P |
let b, x = measi M in N | meas Q |U M,
where b, x, y are extended variables as defined above, i > 0 is a natural number, ρ can be any density matrix and U is a superoperator corresponding to a unitary transformation U . Most of the syntax consist of standard λ-calculus operations. The term U M is the operation that correspond to applying a unitary transformation to the state described by the term M . The measurement operation syntax let b, x = measi M in N means that the qbit i of the term M is measured and thereafter the measurement result is accessible in N as b and the resulting state is accessible as
x. Note that the variable b and x are bound in N . To measure a single qbit, we use instead the simpler syntax meas Q. The set of free variables in M is denoted FV(M ).
The types of QDL are the following:
A, B := bool |T | qbit⊗n | A × B | A ⇒ B.
where n > 0. The type bool is the type of boolean constants, A  B and A  B are respectively the types of pairs and functions. The type qbit⊗n is the type of quantum states on n qbits. The notation qbit⊗n stands implicitly for the product qbit⊗·· ·⊗qbit; we use the notation qbit⊗n⊗qbit⊗m to denote qbit⊗(n+m), although there is no ⊗ type operation.
The typing rules of QDL are given in table 1. We assume that contexts Γ contain



Table 2
QDL probabilistic reduction.
		M ⇓p λx. M ′	N ⇓q V	M1 ⇓p V1	M2 ⇓q V2

V ⇓ V
MN ⇓pq M [V/x]
M ⇓p ⟨V1, V2⟩

fst M ⇓p V1
P ⇓p 0	M ⇓q V

if P then M else N ⇓pq V


⟨M1, M2⟩ ⇓pq ⟨V1, V2⟩
M ⇓p ⟨V1, V2⟩

snd M ⇓p V2
P ⇓p 1	N ⇓q V

if P then M else N ⇓pq V

Q ⇓q ρ	M hb/m, x/  1  [m]ρ[m] ⇓r V

pm
let b, x = measi Q in M ⇓pmqr V
q
pm = tr
[m]iρ
, m = 0, 1

Q ⇓ ρ
p  = tr [m]iρ , m = 0, 1



M1 ⇓p V1	M2 ⇓q V2 M1 ⊗ M2 ⇓pq V1 ⊗ V2
M ⇓p ρ
U M ⇓p U(ρ)



no qbit variables and contexts Δk contain only qbits variables. This convention will be used throughout this paper. Rules involving classical operations correspond are direct adaptation of the standard typing rules of a typed λ-calculus. The rules for quantum constants, quantum measurements and unitary operations are straightfor-
ward. The three tensor rules allow one to take two terms of type qbit⊗n and qbit⊗m and create a term of type qbit⊗(n+m). The distinction between the three cases is due to the fact that known or unknown qbits must be dealt with differently. If Γ, Δ ▶ M : qbit⊗n, M is a known qbit when it has no dependency on some quantum state variable in Δ, i.e. if FV(M ) ∩ |Δ| = ∅. If instead FV(M ) ∩ |Δ| contains only an extended variable x, then the quantum state represented by M depends on the value of the quantum variable x and is thus unknown. The typing rules do not allow an unknown quantum state to depend upon more than one other quantum state. Note also that the term x ⊗ x is not well-typed because it is no a valid extended variable. We also have to ban duplicating terms like λx. x ⊗ x, so we require that
qbit variables are used linearly.
Example 2.1 Quantum teleportation can be implemented in the quan- tum  data  λ-calculus.   Consider  the  following  QDL  teleportation  term:
teleport :
λx. let bx,y ⊗ z = meas1cnot12 ((H x) ⊗ [β00]) in let by, zj = meas1 y ⊗ z in
if bx then
if by then U00 zj else U01 zj
else
if by then U10 zj else U11 zj
where the unitary superoperators Ubxby are the usual correction unitary operations of the teleportation protocol and [β00] is the Bell state (|00⟩ + |11⟩)/ 2 . 
Using the type inference rules, we can derive that ▶ teleport: qbit ⇒ qbit.
Any quantum circuit can be implemented as a QDL term in a similar manner.

The input qbits are represented as a qbit variable x which is tensored with ancilla qbits if necessary. The unitary transformation can then be applied to the resulting term. Finally, measurements operations are used to extract the result.
The operational semantics of the λ-calculus with quantum data is given as a big-step probabilistic reduction relation M ⇓p V between terms and values. Values are the terms defined recursively by
V, W := 0 | 1 |∗ | ρ | λx. M | ⟨V, W ⟩| V ⊗ W.

The reduction relation is defined by the rules given in table 2. The operational semantics of classical operations is defined using standard reduction rules. The quantum operations reduction rules makes reduction of quantum terms follow the rules of quantum mechanics.
Example 2.2 The term teleport ρ reduces with probability 1 to ρ.

Denotational semantics
Probabilistic game semantics
The game semantics presented in this paper is constructed using the definitions of probabilistic games semantics introduced by Danos and Harmer [3]. We give here an overview of the basic definitions and facts of probabilistic game semantics.
Definition 3.1 An arena A is a triple (MA, λA, ▶A) where MA is a set of moves, the function λA : MA → {O, P}×{Q, A}×{I, N} is a labeling which assigns moves to the two players Opponent and Player, and tells us which moves are Questions and which are Answers, and whether they are Initial or Noninitial moves, and finally
▶A⊆ MA × MA is a relation, called the enabling relation, such that
(A1) if a ▶A b, then λOP(a) /= λOP(b), λ  (a) /= λ  (b),
(A2) if λIN(a)= I, then λA(a) = OQI,
(A3) if a ▶ b and λQA(b)=A then λQA(a)= Q,
where the functions λOP, λQA and λin are λA composed with the projections on the
A	A	A
sets {O, P}, {Q, A} and {I, N}.
We use the convention that MX, where X is some list of superscripts taken from the set of move labels {O, P, Q, A, I, N} denote the set of moves labeled with these labels. Moves in an arena are thus of various types, and the constraints on the enabling relation ▶A limits the possible interactions in the arena by limiting which moves can be made at a certain point given the past interactions. The condition (A1) forces that only Player moves to enable Opponent moves and vice versa, (A2) asks for all initial moves to be questions by Opponent and finally (A3) says that answers can only be enabled by questions.
A play in A is a sequence of moves s ∈ M ∗ . This does not take into account the enabling relation; we define a justiﬁed play to be a play where each occurrence of a

non-initial move b has a pointer to a previous occurrence of a move a with a ▶A b. We finally need to enforce alternation of the two players. A legal play is a justified play where Opponent and Player alternate with; we denote the set of legal plays in A by LA. Note that because all initial moves are Opponent moves, Opponent is always making the first move. The sets of odd and even length legal plays are respectively denoted by Lodd and Leven.
Example 3.2 The bool arena is defined with Mbool = {?, 0, 1} λbool(?) = (O, Q, I) and λbool(0) = λbool(1) = (P, A, N) and with the enabling relation
? ▶bool 0, 1.
Example 3.3 The empty arena I is the arena with no moves at all. The only legal play in I is the empty play ε.
Suppose sa ∈ LA. Starting from a and following the justification pointers will always lead to an occurrence of an initial move b, which we call the hereditary justiﬁer of a in sa. We can see that every legal play will be partitioned in subplays, each one consisting of all occurrences of moves hereditarily justified by a given initial move. These subplays are called threads. The current thread of a legal play sa ending with an opponent move, denoted by [sa|, is the thread of sa where a occurs. If sa ends with a Player move, the current thread is then defined by [s|a. We want the current thread to be a legal play, so it is necessary to impose an extra condition on legal plays: a legal play s is well-threaded if for every subplay ta ending with a Player move, the justifier of a is in [t|. In a well-threaded play, player always plays in the last thread where Opponent played.
Given arenas A, B, the product A ⊙ B and arrow A ( B operations are defined respectively as follows:

MA⊙B = MA + MB (disjoint
union)
MA(B = MA + MB
λA(B	=

h⟨OP	QA IN

λA⊙B = [λA, λB] (copairing)
m ▶A⊙B n iff m ▶A n or m ▶B
n.
λA , λA  , λA ⟩, λB
m A(B n iff m  A n or m  B
n or λIN(n)= λIN(m)= I.

B	A
OP	IN
where λA  inverts the roles of the two players and λA makes all moves of A non-
initial. The product arena A ⊙ B is intuitively understood as the arena where at each of Opponent’s turn she can choose to play a move in either A or B, and where Player must answer in the last component where Opponent played. In the arena A ( B, after Opponent makes an initial move in B, at each of his turns Player can choose to play either one of his moves in B or an Opponent move in A.
Given a legal play s in an arena A, let nextA(s)= {a ∈ MA|sa ∈ LA} be the set of all moves that can be legally made after the play s.
Definition 3.4 A probabilistic strategy for Player is a function σ : Leven → [0, 1]

such that
σ(ϵ)=1	and	σ(s) ≥	Σ
b∈next(sa)
σ(sab)

The set of traces of a strategy σ in A is the set of even length legal plays which are assigned a non-zero probability by σ: it is denoted Tσ. A strategy σ is deterministic if σ(s) = 1 for all s ∈ Tσ.
It is possible to describe a probabilistic strategy σ in conditional form. The
probability σ(b | sa) = σ(sab) is the probability of Player choosing to play b after
the play sa.
Composition of strategies is the way interactions between parts of a program are encoded in game semantics. Given two strategies σ : A ( B and τ : B ( C, we define a new strategy σ; τ : A ( C obtained by letting σ and τ “interact” on B. Before giving the definition of composition, it is necessary to formalise this notion of interaction. The set of interactions for A, B, C is
IA,B,C = {u ∈ (MA + MB + MC) | u|AB ∈ LA(B, u|BC ∈ LB(C, u|AC ∈ LA(C}

where u|AB is the sub sequence of u obtained by deleting the moves of C, and similarly for u|BC . The case of u|AC is a bit different because deleting from u the moves of B and their associated pointers might leave the moves of A or C that are justified by B-moves without justifiers. In this case, we define the justifiers of u|AC to be as follows: a move a in C justified by a move b in B will be justified by the first move of either A or C we get to by following back the justification pointers from a in u. The set of witnesses wit(s) of s ∈ LA(C in an interaction IA,B,C is the set of interactions u ∈ IA,B,C such that u|AC = s. The composition of two strategies σ : A  B and τ : B  C can now be defined as follows:

[σ; τ ](s)=	Σ
u∈wit(s)
σ(u|AB)τ (u|BC ).

The identity strategy (or so-called “copycat strategy”) idA : A ( A is neutral with respect to composition. It is defined as the strategy which makes Player copy Opponent moves between corresponding components. Formally, this is defined as the deterministic strategy with trace
T (1A(s)) = s ∈ LA (A | ∀sj ±even s. sj|A = sj|A } .
Using all the structure defined so far it is possible to define a category of arenas and probabilistic strategies. Taking arenas as objects, a morphism A  B is a strategy in A ( B. Composition of strategy is the needed composition, with the identity strategies as identity morphisms. It is associative, and it is shown in [3] that probabilistic strategies are closed under composition. This category is also symmetric monoidal. The operation ⊙ is a tensor product, which acts on
morphisms as follows. Given σ : A → C and τ : B → D and s ∈ Leven	′	′ , we
(A⊙B)((A ⊙B )
set [σ ⊙ τ ](s)= σ(s|A(C )τ (s|C(D). All coherence isomorphisms are easily defined
using variants of the copycat strategy.
Threads have an important role in game semantics as a way to characterize the strategies that encodes programs with side-effects, like stores. This is achieved by

forcing Player to use only the limited information available in the current thread instead of using all the information that can be extracted from the whole previous plays, including move made in other threads.
A strategy σ is well-threaded if Tσ consists only of well-threaded plays. Note that this condition forces Player to answer in the last thread where Opponent played.
Given two well-threaded plays sab ∈ Leven and ta ∈ Lodd with [sa| = [ta|, we
define match(sab, ta) to be the unique legal play tab with b justified as in [sa|. A well-threaded strategy σ is said to be thread independent if sab ∈ Tσ, t ∈ Tσ, a ∈ next(t) and [sa| = [ta| implies that


σ(sab)


σ(s)
σ((match(sab, ta))
=	.
σ(t)

The meaning of this condition is that if Player plays according to σ, Player chooses his answers with probabilities that only depend on the current thread, i.e. σ(b | sa)= σ(b | ta).
The diagonal st rategy ΔA : A → A ⊙ A is defined as the determini,stic strat-
				
similar to the definition of the identity strategy: Δ instructs Player to use copy-
ing strategies between A and its two copies Al and Ar. Possible conflicts in A are resolved by separating in different threads moves made according to the left or the right copy plays. There is also a unique strategy 3A ( I, namely the trivial strategy with trace {ε}.
The pairing of two thread independent strategies σ : A ( B and τ : A ( C
is defined by ⟨σ, τ ⟩ = ΔA; σ ⊙ τ . Thus when Player plays using the pair strategy
⟨σ, τ ⟩, he plays using σ after an initial move in B, and using τ after an initial move in C.
For each arena A, (A, ΔA, 3A) is a comonoid. It is shown in in [8] thata strategy σ : A ( B is thread independent if and only if σ is a comonoid homomorphism. Using a known fact in category theory[9], this implies that the restriction of the category of arena and probabilistic strategies to thread independent strategies is a Cartesian closed category. Note that projections strategies like πA : A ⊙ B ( A are defined as copying strategies which makes Player copies Opponent’s moves between the two A component arenas.

Quantum arenas
To model the quantum part of QDL, we have to define an arena where quantum data can be represented as a strategy. This arena is defined in a similar way as the bool arena. A play begin with Opponent asking Player about the measure- ment result of a quantum measurement performed on the current quantum state. Player’s answers are the possible measurements results and each answer can be cho- sen with a probability consistent with quantum mechanics. The type of quantum measurement which can be used by Opponent is the general description of quantum measurements called intervention operators introduced by Peres [11]. The measure-

ment process is conceived of as a unitary interaction of a measurement apparatus with the quantum system to be measured, followed by a projective measurement on the combined system. Let D(H) be the set of density matrices on H and SD(H) be set of Hermitian positive operators of trace less than one. A quantum intervention on a Hilbert space H is a collection of superoperators E = {Em : SD(H) → SD(Hm)} indexed by measurement results m, such that we have m tr (Em(ρ)) = 1 for any state ρ. If the system is initially in state ρ, performing the quantum intervention yields result m with probability pm = tr (Em(ρ)) and leaves the system in state Em(ρ)/pm. Note that the space HBm may depend on the measurement outcome.
Let H be an Hilbert space. The arena [H] is the arena where questions are quantum interventions of the form
E? =  E? : SD(H) → SD(Hm), .

The possible answers to E? are the possible measurements results m. A play in this arena is a sequence of moves E?[1]m1 ··· E?[n]mn where the quantum interventions E?[k] may all be different.
A quantum state ρ is modeled by a probabilistic strategy [ρ] in [H]. The strat-
egy [ρ] is defined by the weights [ρ] E	m ... E	m  = tr E ?[1] ... E ?[n] (ρ) .
Superoperators are composed as usual, but we use a convenient convention: if the domain of E does not match the codomain of F we put EF = 0. This conven- tion is consistent with the quantum mechanical interpretation of superoperators: an impossible operation is assigned probability zero. Note that the strategy [ρ] is thread independent : the answer to the last question always depend of the previous questions which in general have modified the initial state [ρ].
Using these strategies, we can now represent any trace-preserving superoperator F taking states in HA to states in HB as a strategy. This strategy is denoted [F]; it makes Player answers questions about the output state by measuring the input state in the way described by the following typical play:
[E]
[HA]	◦[HB]
E?
E?F
m
The quantum intervention E?F is the quantum intervention E? F} obtained by composing each intervention Em with F. All the quantum operations of QDL are interpreted using variants of this basic scheme. In particular, the unitary strategy is a special case of the above with F being the superoperator U associated to a unitary operation U . The way a new quantum intervention is created from the initial one E? motivate the use of quantum intervention: implementing a similar scheme with other quantum measurement formalisms like projective measurements would not allow to represent quantum operations as general as trace-preserving superoperators.

There is a similarity between consistent histories approach to quantum mechan- ics [5,10,7] and the scheme used to define the strategy [ρ]. There is a clear connection in “spirit” in the sense that both are based on sequences of measurement results. In this perspective, the above idea used to represent a quantum operation F is new and could be a structured way to think about quantum operations in that context.
Deﬁnition of the denotational semantics
We now use the quantum arena defined in the last section to define a denotational semantics for QDL. First, the types are interpreted as follows:
[[bool]] = bool	[[T]] = T	 qbit⊗n = qbit⊗n
[[A ( B]] = [[A]] ( [[B]]	[[A ⊙ B]] = [A]] ⊙ [[B]]
The arena qbit⊗n is the arena C2n corresponding to the state space of n qbits. The other arenas are operations are taken directly from classical game semantics. The arena T has one possible even-length play: ?∗, and there is thus only one
possible strategy aside from the empty one. We denote this strategy ∗. The type operations × and ⇒ correspond respectively to the arena operations ⊙ and (. Given a context Γ = x1 : A1,... , xn : An, we set [Γ]] to be [[A1]] ⊙ ··· ⊙ [[An]].
We now turn to the definition of the interpretation [M ]] of a term Γ ▶ M : A. The definition is by induction on the derivation of Γ ▶ M : A.
In the base case we must deal with variable and constant terms. For vari- ables, the interpretation of Γ, x : A ▶ x : A is defined using the projection strategies πA : [Γ ] ⊙ [[A]] → [[A ]. The denotations of the constants 0, 1, and ∗ are the stan- dard constant strategies. A quantum state constant ρ : qbit is interpreted as the quantum strategy [ρ] in qbit⊗n.
We describe the inductive cases involving quantum operations or new ideas. The
other cases are interpreted using the standard ideas of classical game semantics.
The definition of [Γ, Δ1, Δ2 ▶ if P then M else N : A ] differs from the usual defi- nition for conditionals used in game semantics because of the linearity constraint.
Assume that
[[P ]] : [[Γ]] ⊙ [[Δ1]] ( bool and [M ]] , [[N ]] : [[Γ]] ⊙ [[Δ2]] ( [[A]]
are already defined. Using the symmetry strategy associated to ⊙ and the dupli- cating strategy Δ, we can define a strategy
r : ( [Γ ] ⊙ [[Δ1]] ⊙ [[Δ2]]) ( ([[Γ ] ⊙ [[Δ1]]) ⊙ ([[Γ]] ⊙ [[Δ2]])
which reorganize the input arena.	With this strategy,	we can define [[if P then M else N ] to be the composition r; [[P ]] ⊙ id; cond([[M ]] , [[N ]]), where
cond([[M ]] , [[N ]]) : bool ⊙ ([[Γ]] ⊙ [[Δ2]]) ( [[A]]
is defined using a conditional strategy operation defined in general by the following idea. Given any two arenas A and B and two strategies σ, τ : A → B, the strategy

cond(σ, τ ): (bool ⊙ A) ( B is the strategy that makes Player answer an initial move in B by asking for a Boolean b in the bool component and then makes Player play in the components A and B using the strategy σ if b =1 and τ if b = 0.
The first quantum operation we deal with is the measurement case. Suppose that

[[Q]] : [[Γ]] ⊙ [[Δ1]] ( qbit⊗(n+1) and [M ]] : [[Γ]] ⊙ [[Δ2]] ⊙ bool ⊙ qbit⊗n

are already defined. We can define [let b, x = measi Q in M ] as the composition r; [[Q]]; measi; [[M ] where measi is the strategy described as follows. Let C be the quantum intervention corresponding to a projective measurement in the canonical basis and be the identity quantum intervention. If the first move is a question in the qbit⊗n arena, Player use the left scheme and if the first move is in the bool
arena, then Player use the right scheme.


qbit⊗(n+1) 	measi	/bo/ol  ⊙  qbit⊗n
E?
E? ⊗C 
(m, b)
m
?
b
qbit⊗(n+1)  measi /bo/ol ⊙ qbit⊗n
?
I ⊗ C
b
b
E?
E? ⊗ Ii
m

m

where E ⊗ F stands for the quantum intervention {Em1 ⊗ Fm2 }(m1 ,m2). It is im- portant to point out that in the right scheme, Player must question Opponent two times. Since the first intervention I ⊗ C alter the state, Opponent’s answer to the
second question E? ⊗Ii depends on the first answer given. This is the only instance in the semantics described in this paper where more than one thread is necessary the qbit⊗n arena. Because of the side effects of measurements, we are forced to use thread dependent strategies to describe quantum states. This is the point where we
are forced to assume that qbit types are linear, since thread dependent strategies cannot be duplicated using the usual Δ duplicating strategy. In contrast, previ- ous work on quantum λ-calculi justified the need of the linearity hypothesis by no-cloning theorem.
There are three tensor cases to deal with. In the first case, we tensor two known qbits. Suppose that the strategies

 Γ, Δ1, x1 : qbit⊗n ▶ M1 : qbit⊗n  and  Γ, Δ2, x2 : qbit⊗m ▶ M2 : qbit⊗m 

are already defined, where FV(Mi) \ |Δi| = ∅, i = 1, 2. The strategy [M1 ⊗ M2]] is defined as the composition r; [[M1]] ⊗ [[M2 ], where the strategy [M1]] ⊗ [[M2]] is

defined by the following scheme:


([[Γ ] ⊙ [[Δ1]]) ⊙ ([[Γ]] ⊙ [[Δ2]])

a1
.
an
[[M ]]⊗[[M ]]
qbit
⊗ qbit E?

b1
.
bk
m

where the probability that Player answers m to E? after the interactions s = a1 ... an and t = b1 ... bk is tr (Em ρs ⊗ ρt). Note that while we take the tensor product of the two output quantum arenas, we must take the classical game product of the classical input arenas.
In the second case, we tensor two qbits each constructed from unknown qbits.
This case is similar to the first one: suppose that
 Γ, Δ1 ▶ M1 : qbit⊗n  and  Γ, Δ2 ▶ M2 : qbit⊗m 
are already defined and that FV(Mi) ∩ |Δi| = {xi}. The strategy [M1 ⊗ M2]] is defined to be the composition r ⊙ id; [M1]] ⊗ [[M2 ], but this time the strategy [M1]] ⊗ [[M2 ] must be defined using the scheme that follows :

([[Γ ] ⊙ [[Δ ]]) ⊙ ([[Γ]] ⊙ [[Δ ]]) ⊙ qbit⊗n ⊗ qbit⊗m [[M1]]⊗[[M2]] ◦qbit⊗n ⊗ qbit⊗m
1	2
E?
a1
.
an
b1
.
bm
E? (Fs ⊗ Gt)
m
m

where Fs and Gt are the two trace-preserving superoperators used by Player respec- tively in [M1]] and [[M2]].
The third tensor rule is for cases where known and unknown states are ten- sored. In this case we have to use a conditional preparation strategy defined using

a combination of schemes used in the first two cases. Assume that
 Γ, Δ1, x : qbit⊗n ▶ M1 : qbit⊗n  and  Γ, Δ2 ▶ M2 : qbit⊗m 
are already defined and that FV(M1) \ |Δ1| = {x} and FV(M2) ∩ |Δ2| = ∅. The strategy [M1 ⊗ M2 ] is defined as the composition r; [[M1]] ⊗ [[M1]] where this time the tensor strategy [M1]] ⊗ [[M2 ] is defined with the scheme
([[Γ]] ⊙ [[Δ ]])	⊙	qbit⊗n	⊙	([[Γ]] ⊙ [[Δ ]]) [[M1]]⊗[[M2]] ◦qbit⊗n ⊗ qbit⊗m
1	2
E?
a1
.
ak
b1
.
bl
E? (Fs ⊗ Gt)
m
m
Player determines how to answer the initial question E? by first playing in the [Γ]] ⊙ [[Δ2 ] arena to determine which state ρs, s = a1 ... ak, to prepare; we assume this state is prepared by a superoperator Fs. After this, Player will start an interaction in [Γ]] in order to learn how the state represented by the term M1 is build from its input. In this case, we assume that this construction corresponds to a superoperator Gt, where t = b1 ... bl is the interaction in the [[Γ]] part. The initial question is
then transformed into the question (Fs ⊗ Gt) E? in the input arena qbit⊗n, and the answer is copied back to the output arena.

Soundness
We now turn to the problem of proving a soundness result for the denotational semantics defined in the last section. First, we need a substitution lemma.
Lemma 4.1 For any λ-calculus with quantum data terms Γ, Δ1, x : A ▶ M : B and
Γ, Δ2 ▶ N : A with x ∈ FV(M ), we have that
Γ, Δ1, Δ2 ▶ M [N/x]: B and [[M [N/x]]] = r; id ⊙ [[N ]] ; [[M ]]
Proof. This is proven by structural induction on the construction of M .	 
The following proposition states that when a term M reduce to some value V with probability p, the corresponding strategies [M ]] and [V ] makes Player play in the same way with probability p.

Proposition 4.2 If M ⇓p V , then for all well-opened sab ∈T ([[V ]]) we have that
[[M ]] (b | sa)= p [[V ]] (b | sa).
Proof. By structural induction on the derivation of M ⇓p V . Most of the proof follow the usual argument for the classical case. We skip these to focus on the cases involving quantum operations.
For measurement operations, consider first the single qbit case. Suppose that [[M ] behaves as [[ρ ] with probability p. Assume that meas M reduces to 0 with prob- ability p tr(|0⟩⟨0| ρ). The strategy [meas M ] is the composition [M ]]; meas and, by induction hypothesis, any interaction using this strategy will behave as an inter- action using the strategy [ρ]; meas. By definition of [ρ], this strategy behaves as the constant strategy 0 in bool with probability tr (|0⟩⟨0| ρ), and thus [meas M ]] behaves as [[0]] with probability p tr (|0⟩⟨0| ρ).
The general measurement case is similar.
To deal with the tensor operation reduction rule, suppose that the proposition holds when M1 ⇓p V1 and M2 ⇓q V2 and assume that M1 ⊗ M2 ⇓pq V1 ⊗ V2. Since the definition of [M1 ⊗ M2 ] is in three cases, these must be considered separately. In the first case, M1 and M1 are both terms with no free variables of type qbit appearing in the type context. By definition [M1 ⊗ M2]] = r ⊙ id; [M1]] ⊗ [[M2]] and by the induction hypothesis this will behaves as [M1 ⊗ M2]] = r ⊙ id; [V1]] ⊗ [[V2]] with probability pq. The other two cases are similar, except that the definition of [[M1]] ⊗ [[M2 ] is different in each case.	 
The next result is adequacy, the converse of the previous one. As for classical λ-calculus, we use a computability predicate to prove adequacy for QDL. The main difference between the following definition and the usual definition of computability is the use of extended variables. Note that neither the presence of extended variables or linearity have any significant impact on this definition.
Definition 4.3 A QDL term M is computable if
M is closed with M : A and A = bool, T or qbit, and if for all sab ∈T ( b | sa) we have that [M ]] ( b | sa )= p [[V ]] ( b | sa ), then M ⇓p V ,
x1 : A1,... , xn : An  ▶  M : A and for all computable closed terms Γ ▶
N1 : A1, ... , Γ ▶ Nn : An we have that M [N1/x1, ... , Nn/xn] is computable,
M is closed with ▶ M : A ⇒ B and for all closed N with ▶ N : A the term
MN is computable.
Lemma 4.4 All QDL terms are computable.
Proof. By induction on the construction of M . The part of the proof involving classical constructs is follows the usual pattern as in classical game semantics, so we focus here on the quantum operations. Using the definition of computability, we can assume that the building components of M are computable closed terms.
The most interesting case is measurement since it involve an argument specific to QDL. We begin by the one qbit measurement case. Suppose that M = meas N

where N is a closed computable term of type qbit. Assume that V is a boolean value and that [M ]] ( b | sa )= p [[V ]] ( b | sa ) for all well-opened sab ∈T ([[V ]]).
When Player uses [M ]], a typical play is

[[N ]]	meas
I	○qbit	○bool
?
C?
m
m
where C? is the quantum intervention corresponding to a projective measurement in the canonical basis. Let p be the probability that using [N ]] the answer is 0 and 1 − p the probability that the answers is 1. Although it is not possible to infer which state ρ is used to answer C? using these probabilities, we know that if player was using ρj = p|0⟩⟨0| + (1 − p)|1⟩⟨1| instead of ρ, we would get the same play as above.
Since meas ρj ⇓p 0, we get that meas ρ ⇓p 0 as required.
We use a similar argument to deal with the general measurement case. For unitary operations, the above problem does not occur since the strategy [U M ]] = [[M ]]; [U ] provides the measurement probabilities for all quantum interventions E?. This allow one to find, via the Gleason theorem, a state ρ such that [M ]] behaves like [ρ] with probability p. Using this and the induction hypothesis on M , we get the desired result.	 
Adequacy is a direct corollary to the last lemma.
Theorem 4.5 Let M be a closed term of type bool, T or qbit⊗n. If for all well- opened sab ∈T ([[V ]]) we have that [[M ]] ( b | sa )= p [[V ]] ( b | sa ), then we have that M ⇓p V .
To give the final result, we need to introduce the necessary concept of contextual equivalence for QDL. A context C[−] of type B with a hole of type A is a term C[−] with a special variable “−” (possibly an extended variable) such that −: A ▶ C[−]: B. Capture-free substitution of a term N ina context C[−] is denoted C[N ].

Definition 4.6 Two closed terms ▶ M1 : A and ▶ M2 : A are contextually equivalent
if for every ground-type context C[−] with a hole of type A we have that
C[M1] ⇓p V ⇐⇒ C[M2] ⇓p V.

The following soundness result follows from consistency and adequacy using a standard argument.
Theorem 4.7 (Soundness) Let M1 and M2 by two closed QDL terms. If [[M1]] = [[M2]], then M1 ∼ M2.

Conclusion and future work
We introduced a new quantum λ-calculus and, using tools from game semantics, we obtained a soundness result which validated its syntax and the structure of its type system. Some important features of the language, like linearity and the different form of the tensor operation, were motivated directly using the properties of the quantum strategies used to model the language. The game semantics approach al- lowed us to model directly the classical and quantum constructs of the language and could be extended to languages with extra features, like recursion, using ideas from classical game semantics. Usually game semantics is used to get full-abstraction results by putting appropriate restrictions on the strategies. Here the main goal was instead to introduce a new kind of model for quantum programming languages. While the soundness result we obtained confirms the usefulness of using quantum games to model quantum types, it is a natural next step to seek a full-abstraction result for QDL. The main difficulty is that there is no known characterisation of the probabilistic strategies of the form [F] in [HA] ( [HB] among all possible proba- bilistic strategies in this arena. Gleason’s theorem [6] is one result in this spirit, but there is no similar result for the case of superoperators. A full abstraction result here would thus be a major advance in understanding how to characterize quantum processes. In this case the obstacle has nothing to do with the usual subtleties associated with higher-type languages.
We did not explore fully the categorical properties of quantum arenas introduced in this paper. For example, one could consider the category of the category of arenas of the form [H] and probabilistic strategies that correspond to quantum operations. This category or some of its subcategories could provide new models for the categorical structures associated to quantum mechanics [1,2,13].
Finally, note that there is a way to relax the definition of quantum arena given in this paper by dropping the condition that the question in [H] consists of quantum intervention on H. The resulting arena allow Opponent to use quantum inter- ventions over any space. This possibility was useful in [4] to model a λ-calculus equipped quantum stores which can contain quantum states of variable size. In that language, quantum data can only used though references in the language; this makes the linearity constraint unnecessary since having multiple references to a qbit is not forbidden by the no-cloning theorem. In this case also the properties of quan- tum strategies were used as a guide in the construction of the language, a further demonstration of the usefulness of quantum strategies in the study of higher-order quantum programming languages.

References
Abramsky, S. and B. Coecke, A categorical semantics of quantum protocol, in: Proceedings of the 19th IEEE conference on Logic in Computer Science: LICS 2004 (2004), pp. 415–425.
Coecke, B. and D. Pavlovic, Quantum measurements without sums (2006).
Danos, V. and R. Harmer, Probabilistic game semantics, in: ACM Transactions On Computational Logic, Special Issue for LICS’00, Association For Computing Machinery (2002), pp. 359–382.

Delbecque, Y. and P. Panangaden, Game semantics for quantum stores, in: A. Bauer and M. Mislove, editors, Mathematical Foundations of Programming Semantics (2008), pp. 119–139.
Gell-Mann, M. and J. Hartle, Classical equations for quantum systems, Physical Review D 47 (1993),
pp. 3345–3382.
Gleason, A. M., Measures on the closed subspaces of a Hilbert space, Journal of Mathematics and Mechanics (1957), pp. 885—893.
Griffiths, R., Consistent histories and quantum reasoning, Physical Review A 54 (1996), pp. 2759–2774.
Harmer, R., “Games and Full Abstraction for Nondeterministic Languages,” Ph.D. thesis, Imperial College (1999).
Jacobs, B., Semantics of weakening and contraction, Annals of Pure and Applied Logic (1994), pp. 73– 106.
Omn`es, R., “The Interpretation of Quantum Mechanics,” Princeton Univ. Press, 1994.
Peres, A., Classical interventions in quantum systems. I. The measuring process, Physical Review A
61 (2000).
Selinger, P., Towards a semantics for higher-order quantum computation, Proceedings of the 2nd International Workshop On Quantum Programming Languages, Turku, Finland. (2004), pp. 127–143.
Selinger, P., Dagger compact closed categories and completely positive maps, in: Proceedings of the 3rd International Workshop on Quantum Programming Languages, number 170 in Electronic Notes in Theoretical Computer Science, 2007, pp. 139–163.
Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, Mathematical Structures in Computer Science 16 (2006), pp. 527–552.
Selinger, P. and B. Valiron, On a fully abstract model for a quantum linear functional language, in: Proceedings of the 4th International Workshop on Quantum i Programming Languages, Oxford, July 17-19, 2006.
Valiron, B., “A functional programming language for quantum computation with classical control,” Master’s thesis, Department of Mathematics, University of Ottawa (2004).
