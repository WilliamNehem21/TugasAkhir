

Electronic Notes in Theoretical Computer Science 253 (2009) 111‚Äì126
www.elsevier.com/locate/entcs

Refinement of Interface Automata Strengthened by Action Semantics
Sebti Mouelhi, Samir Chouali, Hassan Mountassir 1
Laboratoire d‚ÄôInformatique de l‚ÄôUniversit¬¥e de Franche-Comt¬¥e - LIFC 16, route de Gray - 25030 Besanc¬∏on cedex, France

Abstract
Interface automata are light-weight models that capture the temporal interface behavior of software compo- nents. They have the ability to model both the input requirements and the output behavior of a component. They support the compatibility check between interface models to ensure a correct interaction between com- ponents and they adopt an alternating simulation approach to design refinement. In this paper, we extend our previous works on checking interface automata interoperability by adapting their alternating refinement relation to the action semantics. We show the relation between pre and post-conditions of transitions in the abstract version of an interface and their corresponding ones in its concrete version. We illustrate our extensions by a case study of the CyCab car component-based system.
Keywords: Component-based systems, interface automata, alternating refinement.


Introduction
Interface formalisms play a central role in the conception of component-based sys- tems. They are increasingly used thanks to their ability to describe, in terms of communicating interfaces, how the components of a system can be connected to each others. Two principles have to be satisfied to design properly component in- terfaces. First, an interface should describe enough information about the way to make two or more components ‚Äùworking together correctly‚Äù by looking only at their interfaces. Second, more information than is required by the first principle should not be exposed. Essentially, component interoperability have to satisfy the type compatibility of operations (the number, order, and types of the parameters). In addition of type check, component composition requires protocol information about how a component must be used in a system design and the order in which their interacting events are enabled. Interfaces that expose protocol information of com-

1 Email: {sebti.mouelhi, samir.chouali, hassan.mountassir}@lifc.univ-fcomte.fr

1571-0661 ¬© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.09.031

ponents can be specified naturally in an automaton-based language like interface automata [1,2].
Interface automata have been introduced as a formalism that captures the tem- poral Input/Output behavior of a software component. Similarly to Input/Output automata [12], they are specified by automata labeled by input, output, and internal
actions. The approach of interface automata adopts an optimistic or environment-
constraining view where the
composition of two compatible interfaces can be used together in at least one design thanks to the non-input-enabled property, which means that at every state, some input actions may not be enabled contrarily to I/O automata and CSP [12]. There interaction is made by synchronizing shared input an output actions, while the internal actions of concurrent automata are interleaved asynchronously. Automatic compatibility verification and refinement checking can be made. The formalism of interface automata has been applied in several cases as a formal model to specify the interface behaviors of software components [4,9]. A path often taken in the lit- erature is to check the interface compatibility of components at the semantic level of operations. In our previous work [6], we improve the model of interface automata to ensure a more reliable verification of components interoperability by taking into account the semantics of actions. The proposed method enrich transitions of inter- face automata by pre and post-conditions of actions which are atomic prepositions over a set of variables. The scope of our previous work do not cover the totality of interface automata by treating refinement. This paper is essentially written to expose the refinement our extended interface automata.
The role of refinement relation is to formalize the relationship between the ab- stract and the concrete versions of the same component. For I/O automata, refine- ment is usually defined as trace containment or simulation [10]; this ensures that the output behaviors of the refined automaton are behaviors that are allowed by the abstract one. Such definitions of refinement do not hold for non-input-enabled setting, such as interface automata: if the set of legal inputs of the refined interface is a subset of the inputs allowed by the abstract one, then the refined interface could be used in fewer environments than the interface abstraction. While a new approach is adapted to compose interface automata, an alternating approach is used to refine them.
Alternating refinement simulation is defined to study refinement between al- ternating transition systems [13]. They are introduced as a general model for component-based systems which allow the study of adversarial relationships be- tween individual system components. Unlike in labeled transition systems where each transition represents a possible step of the system, each transition of an alter- nating transition system corresponds to a possible move in a game between different components. The proposed refinement of interface automata is based on this ap- proach by viewing them as alternating transition systems. Explicitly, a refinement of an interface automata expresses that the refined component can offer more ser- vices (input actions) and fewer service demands (output actions). In this article, we adapt the alternating refinement simulation of interface automata by taking into

account the relation between pre and post-conditions among the input and output transitions of an automaton and their correspondent refinements. In other word, a refined version uses more variables to formulate pre and post-conditions of the refined and added input actions. We suppose that the pre and post-conditions of the remaining output actions do not change. Intuitively, while the offered services are local in the component, we have to strengthen their semantics constraints if which is not the case for demanded services because the component ignore if the demanded service was refined or not in the environment.
Concretely, we strengthen the alternating simulation between states of a refined interface and its correspondent abstract one by establishing equivalence and impli- cations between their similar input and output actions. After this introduction, in section 2 and 3, we will give an overview of interface automata and we will present our contribution of considering action semantics to verify their interoperability. In section 4, we will detail our adaptation of the alternating refinement simulation of interface automata to the semantics of actions and we will illustrate our works by a case study of the CyCab car component-based system.

Preliminary
I/O automata have been introduced by Nancy A.Lynch and Mark.Tutle [12] as labeled transition systems. Commonly, they are used to model distributed and concurrent systems. Labels of I/O automata fall into three categories of actions: input, output, and hidden actions where input actions are enabled at every state of an automaton.
Defintion 2.1 An I/O automaton A = ‚ü®SA, IA, Œ£I , Œ£O, Œ£H, Œ¥A‚ü© consists of

a Ô¨Ånite set SA of states;
a subset of initial states IA ‚äÜ SA;
three disjoint sets Œ£I , Œ£Oand Œ£H
A	A	A




of inputs, output, and hidden actions. All

A	A	A
actions, as a whole, are denoted by Œ£A = Œ£I  ‚à™ Œ£O ‚à™ Œ£H;
A	A	A
a set Œ¥A ‚äÜ SA √ó Œ£A √ó SA of transitions. It gives a transition relation with the property that for every state s and an input action a there is a transition (s, a, s) in Œ¥A.
Interface automata have been defined by L.Alfaro and T.Henzinger [1], to model the temporal behavior of software component interfaces.  These models are non-input-enabled I/O automata, as previously said, where it is not necessary to enable input actions at every state of one automaton. Every component interface is described by one interface automaton where input actions are used to model methods that can be called, and the end of receiving messages from communication channels, as well as the return values from such calls. Output actions are used to model method calls, message transmissions via communication channels, and exceptions that occur during the method execution. Output actions describe the required actions of a component (represented by the symbol ‚Äù!‚Äù), input actions

describe the provided actions of a component (represented by the symbol ‚Äù?‚Äù), and internal (or hidden) actions inside the component itself describe its local operations (represented by the symbol ‚Äù;‚Äù). Both for I/O automata (IOAs) and interface automata (IAs), the input and output actions of an automaton A are called
external actions uniformly (Œ£ext= Œ£I  ‚à™ Œ£O) while output actions and internal
A	A	A
actions are called locally-controlled actions (Œ£loc= Œ£O ‚à™ Œ£H ). We define by Œ£I (s),
A	A	A	A
Œ£O(s), Œ£H (s) the input, output, and internal actions enabled at the state s.
A	A
Definition 2.2 An interface automaton A = ‚ü®SA, IA, Œ£I , Œ£O, Œ£H, Œ¥A‚ü© consists of

a Ô¨Ånite set SA of states;
A	A	A

an subset of initial states IA ‚äÜ SA. It contains at most one state. If IA = ‚àÖ, then A is called empty;
three disjoint sets Œ£I , Œ£O and Œ£H of inputs, output, and hidden actions;
A	A	A
a set Œ¥A ‚äÜ SA√óŒ£A√óSA of transitions between states. Contrarily to I/O automata, the input actions are not necessarily enabled at every state.
For an IA A, we define two type of actions a ‚àà Œ£A and ax ‚àà Œ£ext, and two type

of action sequences Œ± = a1a2...an ‚àà (Œ£A)n
A
and Œ≤ = b1b2...bn ‚àà (Œ£ext)n
. Given two

states s1 and s2, we define the following relations.
s1 ‚àía‚ÜíA s2 iff (s1, a, s2) ‚àà Œ¥A;

s1 ‚àíœÑ‚ÜíA s2 iff s1 ‚àí‚Üíb
A s2 for some b ‚àà Œ£int;

s1 ‚àíŒ±‚Üí s2 iff s1 ‚àía‚Üí1	‚àía‚Üí2	... ‚àía‚Üín	s2;

s1
=Œµ‚áíA s2
iff s1(‚àíœÑ‚Üí
)‚àós
(* is reflexive and transitive closure and juxtaposition

of transitions);
s1 =a‚áíx A s2 iff s1 =Œµ‚áíA‚àía‚Üíx A s2 (this relation is called input or output sequence of steps according to the type of the action ax and states between the two extremities s1 and s2 are called internal states);
The optimistic view of interface automata incorporates a notion of interface com- position that leads to smaller compound automata than the input-enabled view. When we compose two interface automata, the resulting composite automaton may contain illegal states, where one automaton issues an output that is not acceptable as input in the other one. The proposed approach to compute compatibility between interface automata based on the fact that each interface expects the environment to provide only legal inputs. The compound interface expects the environment to pass over transitions leading only to legal states. The existence of a such legal en- vironment for the composition of two interfaces indicates that there is a way to use their corresponding components together by ensuring the encounter of their envi- ronment assumptions. The composite interface automaton combines the behaviors of the two component interfaces and the environment assumptions under which the components can work together properly.

Interface automata strengthened by action semantics

Our approach presented in [6] extends interface automata by considering the action semantics to ensure a more reliable verification of component interoperability. In [1], the checking of the component compatibility uses only action signatures, which are not sufficient to decide if two interfaces are compatible or not. Our contribution uses pre and post-conditions over a set of variables to annotate the actions of in- terface automata. These constraints on actions show their semantic effects which can be useful to strengthen the compatibility checking. The proposed algorithm to verify the composition and the compatibility between interface automata takes into account of pre and post-conditions of actions.
We introduce a finite set of variables x ‚àà V with their respective domain Dx. These variables are used to represent the effect of actions by updating there values. The variable updates are modeled by pre and post atomic formulas over V.

Definition 3.1 Let A = ‚ü®SA, IA, Œ£I , Œ£O, Œ£H,PreA, PostA, Œ¥A‚ü© be an IA strength-

ened by action semantics where
a Ô¨Ånite set SA of states;
an initial state IA ‚äÜ SA;
A	A	A

three disjoint sets Œ£I , Œ£Oand Œ£H of inputs, output, and hidden actions;
A	A	A
Pre and Post are the set of pre and post-conditions of actions, they are atomic formulae over the set of variables V;
a set Œ¥A ‚äÜ SA √ó PreA √ó Œ£A √ó PostA √ó SA of transitions.
For a ‚àà Œ£A, we denote by PreAa and PostQa respectively the precondition and post-condition of the action a in the automaton A.

The composition condition is the same as the preexisting approach. The compo- sition of two automata may take effect only if their actions are disjoint, except shared input and output actions between them. When we compose them, shared actions are synchronized and all the others are interleaved asynchronously.
Definition 3.2 Two interface automata A1 and A2 are composable if

I	I
A1	A2
= Œ£O
1
O  = Œ£H
2	1
‚à© Œ£A2
= Œ£H
2
‚à© Œ£A1 = ‚àÖ

Shared (A1,A2) = (Œ£I  ‚à© Œ£O ) ‚à™ (Œ£I  ‚à© Œ£O ) is the set of shared input and output
A1	A2	A2	A1
actions between A1 and A2. We can now define the product automaton A1 ‚äó A2
properly. We mention that some transitions in A1 and A2 may not occur in the product.

Definition 3.3 Let A1 and A2 be two composable interface automata. The product
A1 ‚äó A2 is deÔ¨Åned by
SA1‚äóA2 = SA1 √ó SA2 and IA1‚äóA2 = IA1 √ó IA2 ;

I
A1‚äóA2
= (Œ£I
1
I ) \ Shared(A1, A2);

O
A1‚äóA2
= (Œ£O
1
‚à™ Œ£O ) \ Shared(A1, A2);

H
A1‚äóA2
= Œ£H
1
H  ‚à™ Shared(A1, A2);

((q1, q2), Pre, a, Post, (q' , q' )) ‚àà Œ¥A ‚äóA  if
1  2	1	2

¬∑ a /‚àà Shared(A1, A2)  ‚àß  (q1,Pre1, a, Post1, q' ) ‚àà Œ¥A
‚àß q2 = q'
‚àß  Pre ‚â°

Pre1 ‚àß Post ‚â° Post1
¬∑ a /‚àà Shared(A1, A2)  ‚àß  (q2,Pre2, a, Post2, q' ) ‚àà Œ¥A
‚àß q1 = q'

‚àß  Pre ‚â°

Pre2 ‚àß Post ‚â° Post2
¬∑ a ‚àà Shared(A1, A2)	‚àß	((q1,Pre1, a, Post1, q' )  ‚àà  Œ¥A

‚àß	a ‚àà Œ£I  )	‚àß

((q2,Pre2, a, Post2, q' ) ‚àà Œ¥A	‚àß a ‚àà Œ£O ) ‚àß Pre ‚â° Pre2 ‚àß Post ‚â° Post1

such that Pre2 ‚áí Pre1 ‚àß Post1 ‚áí Post2
¬∑ a ‚àà Shared(A1, A2)	‚àß	((q1,Pre1, a, Post1, q' )  ‚àà  Œ¥A

‚àß	a ‚àà Œ£O )	‚àß

((q2,Pre2, a, Post2, q' ) ‚àà Œ¥A	‚àß a ‚àà Œ£I  ) ‚àß Pre ‚â° Pre1 ‚àß Post ‚â° Post2
such that Pre1 ‚áí Pre2 ‚àß Post2 ‚áí Post1
Illegal states are the states at which the shared actions do not synchronize. We distinguish two different cases: (i) a component requires a shared action which is not provided by the environment, or (ii) they synchronize on a shared action between them but the required action and the provided one are not compatible at the semantic level.

Definition 3.4 Given two composable interface automata A1 and A2, the set of illegal states Illegal (A1,A2) ‚äÜ S1 √ó S2 of A1 ‚äó A2 is deÔ¨Åned by {(q1, q2) ‚àà SA1 √ó S2 | ‚àÉ a ‚àà Shared(A1, A2). such that the following conditions hold } .

‚éõ	a ‚àà Œ£O(q1) ‚àß a /‚àà Œ£I (q2)	‚éû	‚éõ	a ‚àà Œ£O(q2) ‚àß a /‚àà Œ£I (q1)	‚éû
1	2	2	1
‚éú	‚à®	‚éü	‚éú	‚à®	‚éü
‚éú	(a ‚àà Œ£O(q1) ‚àß a ‚àà Œ£I (q2)	‚éü or ‚éú	(a ‚àà Œ£O(q2) ‚àß a ‚àà Œ£I (q1)	‚éü
1	2	2	1
‚éú	‚àß	‚éü	‚éú	‚àß	‚éü
‚éù (Pre1 /‚áí Pre2) ‚à® (Post2 /‚áí Post1)) ‚é†	‚éù (Pre2 /‚áí Pre1) ‚à® (Post1 /‚áí Post2)) ‚é†


The set of illegal states in the product A1 ‚äó A2 describes the possibility that one of the two automata may produce an output action that is an input action of the other, but it is not accepted. In our contribution, we extend the previous definition by the possibility that, for some states (q1, q2) in the set of illegal states, an output action issued from q1 in A1 can be synchronized with the same action enabled as input at q2 in A2 but the precondition of the output action does not imply the the precondition of the input action or its post-condition is not implied by the post-condition of the input one.
Compatible states,  denoted by Comp(A1,A2),  are states from which the

environment can prevent entering illegal states. The compatibility can be defined differently, A1 and A2 are compatible iff their initial state is compatible.

Definition 3.5 Given two composable interface automata A1 and A2. The com- postion A1  A2 is an interface automaton deÔ¨Åned by: (i ) SA1  A2 = Comp(A1,A2), (ii ) the initial state is IA1  A2 = IA1‚äóA2 ‚à© Comp(A1,A2), (iii ) Œ£A1  A2 = Œ£A1‚äóA2 , and (iv ) the set of transitions is Œ¥A1  A2 = Œ¥A1‚äóA2 ‚à© (Comp(A1,A2) √ó PreA1‚äóA2
√ó Œ£A1  A2 √ó PostA1‚äóA2 √ó Comp(A1,A2)).

The verification steps in this approach are the same as [1] except that we consider the action semantics. The proposed algorithm [6] verify the compatibility of two interface automata by checking if their composition is nonempty. We mention that our approach does not increase the linear complexity of the previous proposed one. Finally, we add that the associative criterion of the composition operator  between three automata is undefined when some of them are not composable.

Adapting the alternating refinement relation
The aim of the refinement relation is to concretize an abstract version of a compo- nent interface. It permits to move a component or an interface from a high-level understanding to a more concrete specification. Contrarily to traditional types of I/O automata, refinement is defined as trace containment, the refinement of in- terface automata is based on an alternating refinement relation in the spirit of simulation. A more concrete version of an interface have to be used in stronger environments than its abstraction. In other words, the refinement of an interface must allow more legal inputs, and fewer outputs than the abstract version.
By taking the fact that the internal actions are independent, an interface au- tomaton Q refines another P if all input transitions of the second one can be sim- ulated by the first one, and contrarily for output transitions.

Preliminary
We recall the preliminary notions used to define the alternating simulation relation between interface automata. The Œµ-closure of a state s is the set of all reachable states from s by transiting only internal steps. The environment cannot distinguish between s and all states of Œµ-closure(s).
Definition 4.1 Given an interface automaton P and a state s ‚àà SP , Œµ-closureP (s) is the smallest set R ‚äÜ SP such that (1) s ‚àà R and (2) for s' ‚àà R, if there exists s‚Äù such that s' =Œµ‚áíP s'' is a sequence of internal steps, then s'' ‚àà R.

An interface automaton P must be able to accept an output action a issued from the environment if a is accepted at all states in Œµ-closure(s). Contrarily, P can issue an output action b at least from one state in Œµ-closure(s) to the environment.

Definition 4.2 The sets of externally enabled output and input actions at a state s
‚àà SP are deÔ¨Åned as follow
ExtEnO(s) = {a | ‚àÉ r ‚àà Œµ-closure(s). a ‚àà Œ£O(r)}
P	P
ExtEnI (s) = {a | ‚àÄ r ‚àà Œµ-closure(s). a ‚àà Œ£I (r)}.
P	P

We redefine also the set of all reachable states from a state s by transiting steps labeled by externally enabled actions.

Definition 4.3 The set ExtDestP (s, a) of externally reachable states from a state s in an interface automaton P for an externally enabled action a ‚àà ExtEnO(s) ‚à™
ExtEnI (s) is deÔ¨Åned by the set {r' | ‚àÉ r ‚àía‚ÜíP r'. r ‚àà Œµ-closure(s)}

Alternating simulation
Let us consider now pre and post-conditions to establish properly the new definition of the alternating simulation between the states of an interface automaton P and its refined version Q. We extend the set of variables V by adding some others, so we define V‚Äô as a set that includes the set V. We assume that pre and post-conditions of the refined interface automaton Q are defined over the set V‚Äô.
Defining pre and post-conditions of actions of the refined interface must obey to some variant constraints. On the one hand, when we refine a component, we add to their provided services (input actions) some other new services by defining new signatures of actions and on the other hand, we strengthen their former operations by adding some other constraints on their pre and post-conditions. We take into account the principle that, in the refined interface, an old input action must have a fewer precondition than the precondition of the same corresponding action in the abstract one and its post-condition must be stronger than the corresponding post-condition in the abstraction.
Things change for required services, constraints on the required services (output actions) in the abstract interface still unchanged in the refinement. In more details, it is assumed that there is less output actions in the refinement and the required computing results of extinct actions become internal. So, refining remaining ones has no sense. More concretely, the pre and post-conditions of a remaining output action in the abstract interface are equivalent to their correspondents in the refined one. For the requirements of internal actions, we apply the same rules as input actions. We can now define our manner to adapt alternating simulation to the action semantics formally.

Definition 4.4 A binary relation ‚â§ ‚äÜ SP √ó SQ from Q to P is an alternating simulation if for all s ‚àà SP , r ‚àà SQ such that r ‚â§ s the following conditions holds
ExtEnI (s) ‚äÜ ExtEnI (r);
P	Q
ExtEnO(r) ‚äÜ ExtEnO(s);
Q	P

‚àÄ a ‚àà  ExtEnI (s) ‚à™ ExtEnO(r) and ‚àÄ r‚Äô ‚àà  ExtDestQ(r, a):	‚àÉ s‚Äô ‚àà
P	Q
ExtDestP (s, a) such that r‚Äô ‚â§ s‚Äô and
if a ‚àà ExtEnI (s) then PreP,a ‚áí PreQ,a and PostQ,a ‚áí PostP,a.
else if a ‚àà ExtEnO(r) then PreP,a ‚áî PreQ,a and PostP,a ‚áî PostQ,a.
over the set of variables V‚Äô.

The first condition of the second part of the definition ensures that all externally enabled inputs of s are also externally enabled in r, and conversely, all externally enabled outputs of r are also externally enabled in s.


u
PreQ,a
a?
PostQ,a u'
‚â§
v
‚áê	PreP,a a?
‚áí	PostP,a
‚â§
v'
u
PreQ,a
a!
PostQ,a u'
‚â§
v
‚áî	PreP,a a!
‚áî	PostP,a
‚â§
v'

Fig. 1. The extended condition 2 of the alternating simulation definition.

The second one ensures that each input (resp. output) sequence of steps labeled by an externally enabled action a from r in the refinement must be matched by an input (resp. output) sequence of step labeled by the same action a from s in the abstraction except that the equivalences and the implications between pre and post-conditions must be checked as it is shown in Figure 1. We can now define the refinement between two interface automata P and Q as follow

Definition 4.5 The interface automaton Q refines the interface automaton P, writ- ten Q ‚â§ P according to the set of variables V‚Äô if
Œ£I ‚äÜ Œ£I and Œ£O ‚äá Œ£O;
P	Q	P	Q
there is an alternating simulation ‚â§ from Q to P such that IQ ‚â§ IP .
As in [1], we can easily verify that refinement between interface automata in our contribution is reflexive an transitive. But, when we want to establish the relation between the refinement and the compatibility between automata things have to be more detailed: a more refined version Q of P can replace P in a system design such that Q ‚â§ P if the environment does not provide some input actions (calls of some offered services) for Q that are not in P. Alternatively, new incompatibilities may be arise when we compose Q with the environment, namely all new input actions in the refined version Q must not be required as output actions by the environment.
Also, another conditions must be verified when we consider pre and post- conditions. A refined version of an interface P remains consistent with the en- vironment if the abstraction is compatible with it under the hypothesis seated pre-
viously. As shown in the Figure 2, the step x ‚àía‚Üí! Env y of Env is compatible with

final step of the input sequences of steps 1 =a‚áí? P 2 of P , then it is compatible also with the final step of 1' =a‚áí? Q 2' of the refinement Q of P such that 1' ‚â§ 1 and 2' ‚â§ 2 because PreEnv,a ‚áí PreQ,a and PostQ,a ‚áí PostEnv,a. Things do not change when we consider output steps in the refinement Q. Based on the fact that
pre and post-conditions of the remaining actions in the refinement are equivalent to their corresponding ones in the abstraction, the implications PreEnv,a ‚áí PreQ,a and PostQ,a ‚áí PostEnv,a are also satisfied. The dashed edges in the previous and the following figure represent input or output sequences of steps between states 1 and 2 in P and between 1‚Äô and 2‚Äô in Q. We can easily deduce that the substitution
of an automaton by a more refined one preserve the compatibility between them.

Env:	Env:


‚áì	‚áë

P:	P:
‚áì	‚áë

Q:	Q:
‚áë	‚áì



üÖò	üÖò



Fig. 2. Relation between the environment and the refined version Q of P

We can now rise the following theorem properly as in [1] without having hindsight.
Theorem 4.1 Consider three interface automata P, Q, and R such that Q and R are composable and Œ£Q ‚à© Œ£R ‚äÜ Œ£P ‚à© Œ£R. If P and R are compatible and Q ‚â§ P,
I	O	I	O
then Q and R are compatible and Q  R ‚â§ P  R.
From the hypothesis of this theorem, we can extract the following important corollary establishing that if two interface automata are compatible then their refinements are compatible and the composition of their refinement refines them.
Corollary 4.1 Consider four automata P, Q, R, and S such that
Q and R are composable;
Œ£Q ‚à© Œ£R ‚äÜ Œ£P ‚à© Œ£R ;
I	O	I	O
S and Q are composable;
Œ£S ‚à© Œ£Q ‚äÜ Œ£R ‚à© Œ£Q;
I	O	I	O
If P and R are compatible, Q ‚â§ P, and S ‚â§ R then Q is compatible with R and S is compatible with Q and Q  S ‚â§ P  R.
To check that Q ‚â§ P , we should compute the maximal alternating simulation

between the two initial states of P and Q thanks to the algorithm proposed in [1]. Our approach does not increase the complexity of the algorithm.

Case study of the CyCab car
We illustrate our works by applying refinement to the component vehicle of the CyCab car component-based system studied in [6]. The CyCab [7] car is a new electrical means of transportation conceived essentially for free-standing transport services. It is totally manipulated by a computer system and it can be driven automatically according to many modes.


Fig. 3. A UML-like model of the CyCap components.
The goal of the CyCab car system design is to allow for users the displacement of the vehicle from one station to another. As an illustration of its concept, we consider the following requirements and functionalities of the CyCab car and its environment:
(i) a CyCab has and appropriate road where stations are equipped by sensors, (ii) the driving of the CyCab is guided by information received from the station allowing to position of the CyCab from the stations, (iii) there is no obstacle in the roads,
(vi) the vehicle has a starter and also an emergency halt button.
The CyCab car and its environment can be seen as an abstract system composed of four components: the vehicle, the emergency halt button, the starter, and the station. The Figure 3 represents the UML 2 component model of our system. The emergency halt button can be activated at every moment during the running of the vehicle. It is specified by sending a signal emergency!. The starter allows the starting of the vehicle. The station is materialized by a sensor that receives signals position? from the vehicle to know its position. The station sends as consequence a signal far! or halt! to the vehicle to indicate if it is far from the station or not.
In this section, as shown in Figure 3, we apply our proposed contribution of refinement of the interface automaton of the component vehicle. Assume that Av is the interface automaton associated to the component vehicle and V = { carstrd, isknpos, isacstr, isrcstn, isnuldist } be the set of five boolean variables used to define pre and post-conditions of actions.

2 The component diagram showed in Figure 3 do not respect exactly the UML 2 notation. It is simply used




start emrg
far halt pos
reset
VPrH,halt?,VPsH


pos far halt


Fig. 4. The IAs Av and As of the Vehicle and the Station
The variable carstrd indicates if the vehicle is started or not, the variable isknpos in- dicates if the vehicle knows its position from the station, isacstr equals to true when the starter is active, isrcstn equals to true when the station is reached, and finally the variable isnuldist indicates if the distance between the vehicle and the station is null or not. The automaton Av is given by the tuple ‚ü®Sv, Iv, Œ£I, Œ£O, Œ£H,Prev, Postv, Œ¥v‚ü©

where
v	v	v

Prev = {V PrH, V PrS, V PrE, V PrF, V PrP, V PrR} where
VPrH ‚â° carstrd = true ‚àß isrcstn = false ‚àß isknpos = true ‚àß isnuldist = true;
VPrS ‚â° isknpos = false ‚àß carstrd = false ‚àß isacstr = true;
VPrE ‚â° carstrd = true;
VPrF ‚â° carstrd = true ‚àß isrcstn = false ‚àß isknpos = true ‚àß isnuldist = false;
VPrP ‚â° carstrd = true ‚àß isknpos = false;
VPrR ‚â° carstrd = false ‚àß isacstr = false;
Postv = {V PsH, V PsS, V PsE, V PsF, V PsP, V PsR} where
VPsH ‚â° carstrd = false ‚àß isrcstn = true;
VPsS ‚â° carstrd = true;
VPsE ‚â° carstrd = false ‚àß isacstr = false;
VPsF ‚â° carstrd = true ‚àß isrcstn = false;
VPsP ‚â° carstrd = true ‚àß isknpos = true;
VPsR ‚â° isacstr = true.
A possible refinement of this abstract interface of the vehicle component is an au- tomaton that guards all output actions of the abstraction and allows more services (input actions). We can add the requirement that the vehicle functions according to two modes: the station mode where the vehicle runs while communicating with stations and the other is the free-running mode where the vehicle displace freely without interaction with stations.
A new input action fstart? allowing the free-starting of the vehicle. The sepa- ration between the starting of the vehicle and its moving off can be interesting as a new refinement requirement. We add the two internal actions move; and stop;

to clarify the CyCab system

permitting respectively to move off the vehicle and to stop it. The internal action move; can be enabled by taking as precondition the proposition that a vehicle can be started without moving from its place.


fstart
halt?



Fig. 5. The refinement automaton A' of the Vehicle

The set of variables V is extended by adding two new variables carmovg and frunmode.  The new set of variables V‚Äô = V ‚à™ { carmovg, frunmode } is used to define pre and post-conditions of the refined automaton A'v. The first variable carmovg is used to make the difference between the act to start the vehicle and the act to move it. The second variable is used to position the two different modes of the vehicle running. The refined automaton Vehicle‚Äô 3 is showed in the right part of Figure 5. Assuming that atomic formulas are defined now over V‚Äô, we define the pre and post-conditions of the automaton A'v as follow
Pre'v	=	{VPrH',V PrS',V PrE',V PrF',V PrP',V PrR',
PrM, PrStp, V PrFS'} where
VPrH' ‚â° carstrd = true ‚àß isnuldist = true;
VPrS' ‚â° isknpos = f alse ‚àß carstrd = f alse ‚àß isacstr = true;
VPrE' ‚â° carstrd = true;
VPrF' ‚â° carstrd = true ‚àß isrcstn = f alse ‚àß isnuldist = f alse;
VPrP' ‚â° carstrd = true ‚àß isknpos = f alse;
VPrR' ‚â° carstrd = f alse ‚àß isacstr = f alse;
PrM ‚â° carstrd = true ‚àß carmovg = f alse;
PrStp ‚â° carstrd = true ‚àß carmovg = true;
VPrFS' ‚â° frunmode = true ‚àß carstrd = f alse ‚àß isacstr = true;
Post'v	=	{VPsH',V PsS',V PsE',V PsF',V PsP',V PsR',
PsM, PsStp, V PsFS'} where
VPsH' ‚â° carstrd = f alse ‚àß carmoving = f alse ‚àß isrcstn = true;
VPsS' ‚â° carstrd = true ‚àß carmovg = f alse;
VPsE' ‚â° carstrd = f alse ‚àß carmovg = f alse ‚àß isacstr = f alse;
VPsF' ‚â° carstrd = true ‚àß isrcstn = f alse;

3 The actions of the automaton A' are not annotated by pre and post-conditions in order to alleviate the
automaton.

VPsP' ‚â° carstrd = true ‚àß isknpos = true;
VPsR' ‚â° isacstr = true;
PsM ‚â° carstrd = true ‚àß carmovg = true;
PsStp ‚â° carstrd = false ‚àß carmovg = false;
V PsFS' ‚â° carstrd = true ‚àß carmovg = false.
According to our new definition of the alternating simulation between states, the reader can remark that, for example, the precondition of the input action halt? in the abstraction implies the precondition its correspondent one in the refinement and vice versa for post-conditions (VPrH ‚áí VPrH' and VPsH' ‚áí VPsH). We suppose that the two automata Av and As are compatible. The automaton Av can
be substituted in the product Av ‚äó As by the automaton A' by applying Theorem
4.1.



















Fig. 6. The composite automaton A'  As

The verification that A'v ‚â§ Av can be easily made using the proposed algorithm in [1] by taking into account the extended third condition of Definition 4.4. The algorithm permits to compute the unique maximal alternating simulation from A'v to Av.

Algorithm
Input: Interface automata P and Q extended by pre and post-conditions
Output: The maximal alternating simulation from Q to P .
Let ‚â•0 = SP √ó SQ
repeat
For i ‚â• 0, define ‚â•i+1‚äÜ‚â•i by v ‚â•i+1 u if v ‚â•i+1 u and the conditions 1, 2, and 3 of Definition 4.4 hold for v and u where ‚â• = ‚â•i
until ‚â•i+1 = ‚â•i
return ‚â•i

The complexity of the alternating simulation check between our extended IAs is linear like the original model.  The unique difference is the consideration of the

semantics of actions modeled by relations between pre and post-conditions which can be computed in linear time. Consequently, our approach does not increase the PTIME-complete complexity of the classical refinement checking between IAs.

Related works
Luca de Alfaro and al. [11] propose ‚Äùsociable‚Äù interfaces as a different formalism to specify component interfaces from that of interface automata. Their formalism communicates via both actions and shared variables and the synchronization be- tween actions is based on on two main principles: (i) the first principle is that that same action can label both input and output transitions, and (ii) the second is that global variables can be updated by multiple interfaces. The authors show that the compatibility and the refinement check of sociable interfaces can be made thanks to efficient symbolic algorithms. Their tool called TICC [5] (Tool for Interface Compatibility) implements these algorithms.
Ivana CÀáern¬¥a and al. [8] had been founded an automata-based formalism to
capture component interactions in hierarchical component-based systems. Their ‚ÄùComponent-interaction automata‚Äù language represents a flexible model to com- pose components by respecting the architectural assembly of a system design. Other works are published that extend component-interaction automata by checking LTL temporal properties.
In [3], the authors propose concurrent automata to model component behaviors. The described model consists of a pair: a component signature which captures the static view of a component as depicted in UML 2.0, and a language of component vectors over this signature which describe the behaviour of the component. There is similarity between the notion of a component signature and the static structure of interface automata. The major difference with our model is that whereas in con- current automata ports are associated to a set of operation calls/signals, thereby ports in our model correspond to individual operations/signals which are further- more assumed to be sent or received sequentially. So, in our model concurrency is no allowed between ports of the same component.

Conclusion and perspectives
In this paper we adapt the alternating refinement relation between interface au- tomata to the semantics of actions. We have improved these automata by pre and post-conditions of component required or provided actions in order to integrate the action semantics in the verification of interface compatibility and interoperability. We strengthen the alternating simulation between states of an abstract version of an interface automaton and its refined version. Equivalence and implications be- tween input and output actions of the refinement and their correspondent ones in the abstraction are established. The compatibility between the refined version of an abstract interface automaton and the environment is preserved in the case when the abstract one is compatible with same environment. These results are applied

to the case study of the component-based system of the CyCab car.
As future works, we are interested in implementing a verification tool which takes into account pre and post conditions of actions to check compatibility and refinement between interface automata.

References
L. Alfaro and T. A. Henzinger. Interface automata. ACM Press, 9th Annual Aymposium of FSE (Foundations of Software Engineering), pages 109‚Äì120, 2001.
L. Alfaro and T. A. Henzinger. Interface-based design. NATO Science Series : Mathematics, Physics, and Chemistry, Engineering Theories of Softwareintensive Systems, 195:83104, 2005.
J. K. F. Bowles and S. Moschoyiannis. Concurrent logic and automata combined: A semantics for components. Electron. Notes Theor. Comput. Sci., 175(2):135‚Äì151, 2007.
S. Brookes, C. Hoare, and A. Roscoe. A theory of communicating sequetial processes. Journal of the ACM (JACM), (31):560‚Äì599, 1984.
L. D. d. S. M. F. A. L. V. R. B.T. Adler, L. de Alfaro and P. Roy. Ticc: A tool for interface compatibility and composition. In Computer Aided Verification (CAV06) in Seattle, WA, pages 59‚Äì62.
S. Chouali, H. Mountassir, and S. Mouelhi. An i/o automata based approach to verify component compatibility: application to the cycab car. LNCS, Springer-Verlag - FESCA of the European joint conference on Theory and Practice of Software (ETAPS‚Äô08), March 2008.
B. Grard, G. Philippe, M. Herv, and P.-G. Roger. The inria rhÀÜone-alpes cycab. INRIA technical report, 1466, Avril 1999.
P. V. Ivana CÀáern¬¥a and B. Zimmerov¬¥a. Component-interaction automata modelling language. Brno, Czech Republic : Faculty of Informatics, Masaryk University, 2006. Technical report FIMU-RS-2006- 08.
Y. Jin, R. Esser, C. Lakos, and J. Janneck. Modular analysis of dataflow process networks. International conference on Fundamental Approaches to Software Engineering (FASE‚Äô03 - ETAPS 2003) - Springer- Verlag, 2621(31):184‚Äì199, 2003.
T. H. L. Alfaro. Interface theories of component-based design. In Proceedings of the First International Workshop of Embedded Software (EM-SOFT) - LNCS., Springer-Verlag, 2211:148‚Äì165, 2001.
M. F. A. L. P. R. L. de Alfaro, L. Dias Da Silva and M. Sorea. Sociable interfaces. In FROCOS 2005: 5th International Workshop on Frontiers of Combining Systems, Springer-Verlag, LNAI 3717, 2005.
N. Lynch and M. Tuttle. Hierarcical correctness proofs for distributed algorithms. In Proc. 6th ACM Symp. Principles of Distributed Computing, pages 137‚Äì151, 1987.
R. Milner. An algebraic definition of simulation between programs. In Proc. 2nd International Joint Conference on Artificial Intelligence, The British Computer Society, pages 481‚Äì489, 1971.
