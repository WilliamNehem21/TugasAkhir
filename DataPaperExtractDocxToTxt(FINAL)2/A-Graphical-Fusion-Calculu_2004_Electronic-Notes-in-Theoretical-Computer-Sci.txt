Electronic Notes in Theoretical Computer Science 104 (2004) 199–215 
www.elsevier.com/locate/entcs


A Graphical Fusion Calculus *
Ivan Lanese1
Dipartimento di Informatica Universit`a di Pisa
Pisa, Italy
Ugo Montanari2
Dipartimento di Informatica Universit`a di Pisa
Pisa, Italy

Abstract
We analyze the relationship between Fusion Calculus and graph transformations defined in the Synchronized Hyperedge Replacement (SHR) style. In particular we show that the underlying al- gebraic structure is the same when the synchronization used in SHR is Milner synchronization. The main difference we see is that Fusion Calculus has an interleaving behaviour while SHR is inherently concurrent. In the paper we introduce the interleaving semantics for SHR with Mil- ner synchronization and show that there is a complete correspondence between the operational semantics of Fusion Calculus and of SHR systems.
Keywords: Fusion Calculus, graph transformation, Synchronized Hyperedge Replacement, mobility


Introduction
In this paper we compare two different kinds of models which are useful for studying concurrent, distributed and mobile systems. This kind of systems is very important in practice since it includes the Internet, which interconnects

  Research supported in part by MIUR project COMETA and EU-FET project AGILE
IST-2001-32747.
1 Email: lanese@di.unipi.it
2 Email: ugo@di.unipi.it



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.026


hundreds of millions of users, but also other kinds of nets, such as LANs and wireless communication networks. The problem of developing large systems, as often required, in this kind of environments is complex since the traditional computational aspects interact in new ways with issues such as coordination, synchronization, security and mobility. So powerful formal models and tools able to deal with this scenario at a suitable level of abstraction are needed.
Several proposals have appeared in literature, and some of them are widely used, but no single formalism has emerged as the best model for this kind of systems. In this scenario, it is very important to analyze and understand the relationships that hold between different models, in order to find out which features are required to deal with this kind of systems, which are the possible choices and which are merits and drawbacks of each of them. In the paper, we study the relationships between Fusion Calculus [11] and Synchronized Hyperedge Replacement [1,3]. The Fusion Calculus follows the approach of process-calculi, where, as in CCS [9], a system is modeled by a term in a suit- able algebra and the operational semantics is specified by structural induction. A successor of CCS, the π-calculus [10], allows the study of a wide range of mobility problems in a simple mathematical framework. Fusion Calculus is an evolution of π-calculus which is interesting since it is obtained by simplifying and making more symmetric the π-calculus. In fact, the input prefix of the π- calculus has been decomposed into a new input prefix which is symmetric with respect to the output prefix and a standard π-calculus restriction. Further- more Fusion Calculus has a new kind of actions, fusion actions, which merge names and thus allow modeling some aspects of mobility that the π-calculus can not handle.
One of the known limitations of the process-calculi approach when applied to distributed systems is that process-calculi lack an intuitive representation because they are equipped with an interleaving semantics and they use the same constructions for representing both the agents and their configurations. A different approach that solves this kind of problems is based on graph trans- formations [12]. In this case, the configuration is explicitly represented by a graph which offers both a clean, inherently concurrent mathematical semantics and a suggestive representation. Among the various proposals for graph trans- formations we choose Synchronized Hyperedge Replacement (SHR) [2,1,6,3]. In our approach we represent computational entities such as processes or hosts with hyperedges (edges connected to an arbitrary number of nodes) and chan- nels between them as shared nodes. As far as the dynamic aspect is concerned, we use productions to specify the behaviours of single hyperedges which are synchronized by exposing actions on nodes. Actions exposed by different hy- peredges on the same node must be compatible. What exactly compatible


means depends on the choice of the synchronization model. For instance, we can have Hoare synchronization, where all the edges must expose the same ac- tion (in the CSP style), and Milner synchronization where two corresponding actions (“input” and “output”) are synchronized (in the CCS style). We use the extension of SHR with mobility [5,3], that allows hyperedges to send node references together with actions. Nodes whose references are matched during the synchronization are fused. This approach is very expressive as shown in [4], since it can employ multiple synchronizations to define a global rewrit- ing step using only local rules. In literature SHR has already been used as a meta-model to study other formalisms such as π-calculus [4,5] and Ambient calculus [3,8]. Our work in particular extends the work of [5] on π-calculus to cope with the expressiveness of Fusion Calculus.
We show that Fusion Calculus (with guarded sum and recursion) is in strict correspondence with a subset of SHR. The correspondence is based on the existence in both models of two analogous operators, i. e. a parallel com- position operator for building systems and a restriction operator for declaring local names. Furthermore we recognize close relationships between the respec- tive mechanisms for mobility. The main difference is that Fusion Calculus has an interleaving semantics and allows just one synchronization at each step, whereas SHR is a concurrent model and allows multiple synchronizations. Thus in order to have a complete correspondence we have to force an inter- leaving semantics also for SHR, what we do using a particular set of inference rules. By using the normal inference rules, we have transitions that correspond to many Fusion Calculus steps.
Section 2 contains the required background, in particular syntax and se- mantics of Fusion Calculus (2.1), the algebraic representation for graphs and the rules for SHR (2.2). Section 3 contains the main contributions of this paper, that is the rules for interleaving Milner SHR (3.1) and the mapping from Fusion Calculus into interleaving Milner SHR (3.2). Finally Section 4 contains some conclusions and traces for future work.

Background
The Fusion Calculus
The Fusion Calculus [11] is a calculus for modeling distributed and mobile systems which is based on the concepts of fusion and scope. It is an evolu- tion of the π-calculus [10], and the interesting point is that it is obtained by simplifying the calculus. In fact, the two action prefixes for communication are symmetric whereas in the π-calculus they are not and we have just one binding operator called scope whereas the π-calculus has two (restriction and


input). As shown in [11] the π-calculus is syntactically a subcalculus of the Fusion Calculus (the key point is that the input of π-calculus is obtained using input and scope). In order to have these properties fusion actions have to be introduced.
We will present in detail the syntax and the SOS semantics of Fusion Calculus. In our work we consider only a subcalculus of the Fusion Calculus, which has no match (but we will later discuss how to reintroduce it) and no mismatch operator, and has only guarded summation and recursion. In our discussion we distinguish between sequential agents (which have a summation as topmost operator) and general agents.
We suppose to have an infinite set N of names ranged over by u, v,..., z. Names represent communication channels. We use x to denote a vector of names and φ to denote an equivalence relation on N which can be represented by a finite set of equalities (we denote with 1 the identity relation).
Definition 2.1 The free actions are defined by:
α ::= ux (Input)
ux (Output)
φ (Fusion)
Definition 2.2 The agents are defined by:
S ::= Σ αi.Pi (Guarded sum)
i
P : : =	0	(Inaction)
S	 (Sequential Agent) P1|P2 (Composition) (x)P	(Scope)
rec X.P (Recursion)
X	(Agent variable)
The scope operator is a binder for names thus x is bound in (x)P .
Similarly rec is a binder for agent variables, furthermore we only consider agents which are closed with respect to agent variables and where in rec X.P each occurrence of X is within a sequential agent (guarded recursion).
We define the functions fn, bn and n that given an agent or an action compute the set of free, bound and all names respectively (the names in a fusion are the names in non singleton equivalence classes).
Processes are agents considered up-to structural axioms defined as follows.


Definition 2.3 The structural congruence ≡ between agents is the least con- gruence satisfying the α-conversion law (both for names and for agent vari- ables), the abelian monoid laws for summation and composition (associativity, commutativity and 0 as identity), the scope laws (x)0 ≡ 0, (x)(y)P ≡ (y)(x)P , the scope extension law P |(z)Q ≡ (z)(P |Q) where z ∈/ fn(P ) and the recursion law rec X.P ≡ P {rec X.P/X}.
Note that fn can be trivially extended to processes.
Definition 2.4 A bound action is of the form (z)ax where |z| > 0 and all elements in z are also in x. Names in z are bound names. The actions consist of the free actions and the bound actions.
For convenience we define φ \ z to mean φ ∩ (N \ {z})2 ∪ {(z, z)}. We can now present the SOS semantics.
Definition 2.5 [SOS semantics for Fusion Calculus]
—

PREF


α.P −→α  P

SUM
P →−α  P '
α

P + Q −→ P '

PAR

COM


P −u→x
P →−α
P |Q →−α
P ',Q uy
P '
P '|Q
Q', |x| = |y|

{x=y}
P |Q −−−−→
P '|Q'

SCOPE
φ
P →−
P ', zφx,z /= x

φ\z
(z)P −−→
P '{x/z}

PASS
P →−α P ',z ∈/ n(α)

α


(y)ax
P
(z)P →−
'
(z)P '

OPEN
−−−→ P ,z ∈ x \ y,a ∈/ {z, z}



(zy)ax
(z)P −−−−→ P '

STRUCT
P −→α
P '	P ≡ Q	P ' ≡ Q'
α

Q →− Q'
We show here a useful decomposition that can be defined for fusion agents.

Definition 2.6 The standard decomposition of an agent P is defined as:
P = σP Pˆ
where σP is the standard substitution and Pˆ is the standard agent of P . This decomposition satisfies:
P = σQ implies Pˆ = Qˆ ∧ σP = σσQ

We denote with fnarray(P ) the array of the free name occurrences in P , or- dered according to some fixed order dictated by the structure of P . In partic- ular σP = {fnarray(P )/ fnarray(Pˆ)}.
The standard decomposition can be easily extended to processes.

Synchronized Hyperedge Replacement
Synchronized Hyperedge Replacement [2,1,3] is an approach to (hyper)graph transformations that allows the definition of global transformations using local productions that describe how a single hyperedge can be rewritten and the constraints that the rewriting imposes on the surrounding nodes. Thus the global transformation is obtained by combining different productions whose conditions are compatible. What exactly compatible means depends on which synchronization model we use. Possible models are for instance the Hoare [7] and the Milner [3] synchronization models. Furthermore the rewriting system also use node mobility, that is during a transformation some references to nodes can be transmitted and corresponding nodes are merged.
We give a formal description of SHR in terms of labelled transition sys- tem, but first of all we need an algebraic representation for hypergraphs. A hyperedge, or simply an edge, is an atomic item with a label (from a ranked alphabet LE = {LEn}n=0,1,...) and with as many ordered tentacles as the rank of its label. A set of nodes, together with a set of such edges, forms a hyper- graph (or simply a graph) if each edge is connected, by its tentacles, to its attachment nodes. A graph is equipped with a set of external nodes identified by distinct names. External nodes can be seen as the connecting points of a graph with its environment (i. e. the context). We consider graphs up-to isomorphisms that preserve connections between edges and nodes, external nodes and edge labels. Now, we present a definition of graphs as syntactic judgements, where nodes correspond to names, external nodes to free names and edges to basic terms of the form L(x1,... , xn), where xi are arbitrary names and L ∈ LEn.


Definition 2.7 [Graphs as syntactic judgements] Let N be a fixed infinite set of names and LE a ranked alphabet of labels. A syntactic judgement is of the form Γ ▶ G where:
Γ ⊆N is a finite set of names (the external nodes of the graph).
G is a term generated by the grammar
G ::= L(x) | G|G | νy G | nil
where x is a vector of names, L is an edge label with rank(L)= |x| and
y is a name.
We define ν as a binder, so in νy G all occurrences of y (also the ones in G) are bound occurrences. We define as usual the functions fn, bn and n.
We demand that fn(G) ⊆ Γ.
We use the notation Γ,x to denote the set obtained by adding x to Γ, assuming x ∈/ Γ. Similarly, we write Γ1, Γ2 to state that the resulting set of names is the disjoint union of Γ1 and Γ2.
Definition 2.8 [Structural congruence]
We define the structural congruence ≡ on syntactic judgments which obeys the following axioms:
(AG1) (G1|G2)|G3 ≡ G1|(G2|G3) (AG2)	G1|G2 ≡ G2|G1
(AG3)	G|nil ≡ G
(AG4)	νx νy G ≡ νy νx G
(AG5)		νx G ≡ G if x ∈/ fn(G) (AG6)	νx G ≡ νy G[y/x] if y ∈/ fn(G)
(AG7) νx (G1|G2) ≡ (νx G1)|G2 if x ∈/ fn(G2)
Axioms (AG1), (AG2) and (AG3) define respectively the associativity, commutativity and identity over nil for operator |. Axioms (AG4) and (AG5) state that nodes of a graph can be hidden only once and in any order. Axiom (AG6) defines α-conversion of a graph with respect to its bound names. Axiom (AG7) defines the interaction between hiding and parallel composition.
Thanks to axiom (AG4), we can write νX, with X = i=1...n{xi}, to abbreviate νx1 νx2 ... νxn. Note that by using the axioms, we can always put any judgement in the normal form Γ ▶ νX G, where G is a subterm containing
only compositions of edges. We can also make Γ and X be disjoint sets of nodes. Note that n(G) ⊆ Γ ∪ X. We can state the following correspondence theorem.
Theorem 2.9 (Correspondence of graphs and judgements)
Well-formed judgements up to structural axioms are isomorphic to graphs up

to isomorphisms.
We present here the steps of an SHR computation.
Definition 2.10 [SHR transition] Let Act be a ranked set of actions. The rank of a ∈ Act is ar(a).
A SHR transition is of the form:


Γ ▶ G −−→
Φ ▶ G'

where Λ ⊆ Γ × Act ×N ∗ such that Λ is a total function in its first argument (that is Λ(xi) = (ai, yi), and we denote yi as nΛ(xi)) and we demand that ar(ai)= |yi| and π :Γ → Γ is an idempotent substitution. We define:
n(Λ) = {z|∃x.z ∈ nΛ(x)}
Φ= π(Γ) ∪ (n(Λ) \ Γ)
We require that ∀x ∈ n(Λ).π(x)= x (what means that we communicate only the representatives of the equivalence classes defined by π).
We may drop π if it is the identity. We usually have a trivial action ϵ of arity 0, thus when not otherwise stated we suppose Λ(x) = (ϵ, ⟨⟩) (we write Λ= Λє if this happens for all x).
We derive SHR transitions from basic productions which define the be- haviour of a single hyperedge using some inference rules which depend on the choice of the synchronization model.
Definition 2.11 [SHR production] A production is an SHR transition of the form:
x1,... , xn ▶ s(x1,... , xn) −−→ Φ ▶ G
where all xi are distinct.
Productions have to be considered as schemas, that is if we have a produc- tion we also have all productions obtainable from it by applying an injective renaming.
We present here the set of inference rules for Milner synchronization model.
Definition 2.12 [Rules for Milner synchronization]


Γ ▶ G
Λ,π
Φ
'	'  Λ',π'	'	'

(par)
	1 −−→	▶ G2	Γ ▶ G1 −−−→ Φ ▶ G2

Γ, Γ' ▶ G |G'
Λ∪Λ',π∪π'
Φ, Φ' ▶ G |G'

1
where (Γ ∪ Φ) ∩ (Γ' ∪ Φ')= ∅.
1 −−−−−−→	2	2




(merge)
Γ ▶ G −−→
Λ',π'
Φ ▶ G'

σ(Γ) ▶ σ(G) −−−→ Φ' ▶ νU ρ(σ(G'))
where σ :Γ → Γ is an idempotent substitution and:
σ(x)= σ(y) ∧ Λ(x) /= (ϵ, ⟨⟩) ∧ Λ(y) /= (ϵ, ⟨⟩) ∧ x /= y ⇒
(∀z ∈ N \ {x, y}.σ(z)= σ(x) ⇒ Λ(z)= (ϵ, ⟨⟩))
∧Λ(x)= (a, v) ∧ Λ(y)= (a, w) ∧ a /= τ
ρ = mgu({σ(v)= σ(w)|σ(x)= σ(y) ∧ Λ(x)= (a, v) ∧ Λ(y)= (a, w)}
∪{σ(x)= σ(y)|π(x)= π(y)})
⎧ (τ, ⟨⟩)	if σ(x)= σ(y)= z ∧ x /= y ∧ Λ(x), Λ(y) /= (ϵ, ⟨⟩)
Λ'(z)=	ρ(σ(Λ(x))) if σ(x)= z ∧ Λ(x) /= (ϵ, ⟨⟩)
⎪⎪ (ϵ, ⟨⟩)	otherwise
π' = ρ|σ(Γ)
U = ρ(σ(Φ)) \ Φ'


(res)
Λ,π
Γ,x ▶ G −−→
Γ ▶ νx G Λ|Γ,π|Γ
Φ ▶ G'
Φ' ▶ νZ G'

where:
(π(x)= π(y) ∧ x /= y) ⇒ π(x) /= x
Λ(x)= (ϵ, ⟨⟩) ∨ Λ(x)= (τ, ⟨⟩)
Z = {x} if x ∈/ n(Λ|Γ),Z = ∅ otherwise


(idle)	Γ ▶ G Λc,id
Γ ▶ G


Rules for Milner synchronization model suppose that actions can be normal actions (“input”) or coactions (“output”, denoted as a). Furthermore we have two special actions ϵ (no action) and τ (internal action) of arity 0.
Rule (par) allows the composition of transitions which use disjoint sets of names. Rule (merge) deals with non injective renamings, rule (res) restricts a name where no communication occurs and rule (idle) guarantees that each edge can always make an explicit idle step.

Mapping Fusion Calculus into Synchronized Hyper- edge Replacement
In this section, we present a mapping from Fusion Calculus to SHR that ex- tends the work of [5] for the π-calculus and maps Fusion Calculus into a par- ticular kind of SHR which uses Milner synchronization and has special rules in order to force an interleaving behaviour. This is necessary since the seman- tics of Fusion Calculus is itself interleaving. This mapping has the advantage of being natural (there is a one-to-one mapping that maps parallel composi- tion into parallel composition and scope into restriction) and of realizing a complete correspondence between the two models.

Interleaving Milner SHR
In order to define the inference rules for Milner interleaving SHR we need to restrict ourselves to two kinds of transitions:
communication transitions: they have π = id and Λ(x)= (ϵ, ⟨⟩) for each x
but one (we denote this kind of Λ with act);
fusion transitions: they have Λ = Λє.
We present now the particular set of inference rules used in this case.
Definition 3.1 [Rules for interleaving Milner synchronization]


(ren)
Λ,π
Γ ▶ G −−→
Λ' ,π'
Φ ▶ G'

Γ', σ(Γ) ▶ σ(G) −−−→ Γ', ρ(σ(Φ)) ▶ ρ(σ(G'))
where σ :Γ → Γ is an idempotent substitution and:
ρ = mgu({σ(x)= σ(y)|π(x)= π(y)})
ρ(σ(Λ(x))) if σ(x)= z ∧ Λ(x) /= (ϵ, ⟨⟩)
Λ'(z)= 
(ϵ, ⟨⟩)	otherwise
π' = ρ|σ(Γ)


Γ ▶ G
−a−ct−1 ,→id
Φ ▶ G'
Γ ▶ G
−a−ct−2 ,→id
Φ' ▶ G'

(com/close)
	1	1	2	2

Γ ▶ G |G
Λc,π
ρ(Γ) ▶ νU ρ(G' |G' )

1	2 −−→	1	2
where:


act1 = (x, a, y1) and act2 = (x, a, y2) for some node x and pair action- coaction a and a
ρ = mgu({y1 = y2})
π = ρ|Γ
U = ρ(Φ ∪ Φ') \ ρ(Γ)


Γ ▶ G
Λ,π
Φ ▶ G'
Γ ▶ G

(par)
	1 −−→	1	2

Γ ▶ G |G −−→ Φ ▶ G' |π(G )
1	2	1	2





where:
(res)
Λ,π
Γ,x ▶ G −−→
Γ ▶ νx G Λ|Γ,π|Γ
Φ ▶ G'
Φ' ▶ νZ G'

(π(x)= π(y) ∧ x /= y) ⇒ π(x) /= x
Λ(x)= (ϵ, ⟨⟩)
Z = {x} if x ∈/ n(Λ|Γ),Z = ∅ otherwise

Rule (ren) deals with renamings of names in the interface and allows also the creation of new isolated nodes, rule (com/close) synchronizes two commu- nication transitions exposing complementary actions on the same node to give a fusion transition, rule (par) adds an idle part of the system to the transition and rule (res) deals with restriction.
Note that with respect to the transition system obtained using rules in
2.12 we drop the τ action (which is substituted by the ϵ action) and that all the transitions that we obtain starting from a set of communication and fusion productions are either communication ones or fusion ones, that is they all have just one effect. This makes the semantics interleaving.
We can state the following correspondence theorem between normal SHR and interleaving SHR.
Theorem 3.2 Given a set of communication and fusion productions P and
a starting graph Γ ▶ G we can derive a transition Γ ▶ G −−→ Φ ▶ G' using the
Λ' ,π
inference rules in deﬁnition 3.1 iff we can derive the transition Γ ▶ G −−→ Φ ▶
G' where Λ(x) = (ϵ, ⟨⟩) if Λ'(x) = (τ, ⟨⟩) and Λ(x) = Λ'(x) otherwise using the rules in deﬁnition 2.12 and either one production or two communication productions which synchronize on some node.

Mapping Fusion into interleaving SHR
One of the differences between Fusion Calculus and SHR is that in one case fusions are represented by equivalence relations, whereas in the other one substitutions are used. The relation between the two representations is the following one.
Definition 3.3 A substitutive effect of a fusion φ is an idempotent substitu- tion σ agreeing with φ (i. e. σ sends all members of each equivalence class of φ to one representative in the class).
We define now the translation between Fusion Calculus and interleaving SHR with Milner synchronization.
Definition 3.4 [Translation of actions] We define now the relation between the actions of Fusion Calculus and the synchronizations of SHR. This relation is a function that we denote with −) in the case of communication actions (we have a free action when y = ∅):
 (y)ux) = (u, inn, x), id where n = |x|
 (y)ux) = (u, outn, x), id where n = |x|
We define inn and outn as complementary actions, i. e. inn = outn and
outn = inn.
A φ action of Fusion Calculus corresponds in the SHR setting to any substi- tution π which is a substitutive effect of φ.
Note that in the translation the distinction between free names and bound
names vanishes, but for any transition P −→α  P ' bn(α)= n(α) \ fn(P ), thus we
can retrieve the set of bound names when necessary.
Since we want a finite number of productions that describe the evolution of each process we use edges and productions only for sequential processes in standard form. In particular, each edge has a label which encapsulate the corresponding process.
Definition 3.5 [Translation of agents] We define now the translation on agents:
 0) = nil
 S) = LSˆ(fnarray(S)) where Sˆ is the process that corresponds to the standard agent for S
 P1|P2) =  P1)| P2)
 (x)P ) = νx  P )
 rec X.P ) = P {rec X.P/X})
We have no need to translate agent variables since they occur only inside sequential processes.


The translation is well-defined also on equivalence classes, i. e. on processes, since if P1 ≡ P2 then P1) ≡ P2). Note that if a congruence rule is applied inside a sequential agent then the translation of the two agents is the same since the edge is labelled by the process itself. Furthermore abelian monoid laws for | correspond to rules (AG1), (AG2) and (AG3), (x)0 = 0 corresponds to an instance of (AG5), (x)(y)P = (y)(x)P corresponds to (AG4) and the scope extension law corresponds to (AG7). Finally α-conversion for names is (AG6). The recursion law holds since the translation of a recursively defined agent coincides with the translation of its expansion using recursion law. Note that even if this part of the definition is not by structural induction, still the termination is granted because we use only guarded recursion. Thus, after one application of the rule, we get a sequential agent, whose translation is directly defined. Finally laws for + and α-conversion for agent variables can be applied only inside sequential agents.
Note also that rule (AG5) corresponds to a rule that can be obtained from P |0= P , the scope extension law and (x)0 = 0. Thus both formalisms have the same underlying structure, that is a parallel composition operator and a binder for names, ruled by equivalent congruences.
As a last step we need to show the productions used in the SHR system.
Definition 3.6 We define productions only for standard sequential agents
i αi.Pi. Let Γ be fn(  i αi.Pi)).
The productions are of the following forms:
Γ ▶ Σ α .P )  αi) Γ ▶ P )
i	i  −−→	i
i
if αi is a communication action (note that this is a communication production) and
Γ ▶ Σ α .P ) →−π π(Γ) ▶ π(P ))
i	i	i
i
if αi = φ and π is a fusion effect of φ (note that this is a fusion production).
Note that since, in SHR computations, nodes are never deleted, the graphs that we obtain during the computation have some more unused nodes.
The correspondence between the different methods used for computing fusions in the two systems is given by the following lemma.
Lemma 3.7 Let S be a set of equalities representing a fusion φ and σ be a substitution. Then the following two propositions are equivalent:
σ is a substitutive effect of φ;
σ is an mgu of S.


An important characteristics of graphs obtained from Fusion Calculus is that we have no generation of new names as shown by the following lemma (but we can have extrusions of bound names), we can however have infinite many names since the axiom for recursion allows a finite representation of an infinite agent (which may contain infinitely many names).

Lemma 3.8 For each process P if P
−→α
P ' for some action α then all the

free names that appears in α are also free names of P ).
We can now state the two theorems that show the correctness and the completeness of the translation.
Theorem 3.9 (Correctness) For each fusion process P and each Γ ⊇ fn( P ))
if P −→α P ' and Γ ∩ bn(α)= ∅ then:

 α)
Γ ▶  P ) −−→
Γ, ΓE
▶  P ') where ΓE
= bn(α) if α is a communication

action;
Γ ▶  P ) →−π

π(Γ) ▶  π(P ')) for each substitutive effect π of α if α is a

fusion action.
Theorem 3.10 (Completeness) For each fusion process P if Γ ▶  P ) −−→
Γ ▶ G for some Γ ⊇ fn( P )) then there exists P ' such that:

either P
→−α
P ',  α) = (Λ, id), π = id,  P ') = Γ' ▶ G and Γ' = Γ, ΓE

where ΓE = bn(α);

or P  →−
P ', π is a substitutive effect of φ, Λ = Λє,  π(P ')) = G and

Γ' = π(Γ).
We can also handle the match operator by distributing it on sequential agents and then adding to SHR a special rule for dealing with edges that correspond to sequential processes with match.
We show an example on how the translation can be used.
Example 3.11 Let us consider the fusion transition:
{y=w}
(z)(P |uxy.Q|uzw.R) −−−−→ (P |Q|R){x/z}.
The translation of the starting process into a graph is:
νz LP |Lx1 x2x3.Q(u, x, y)|Lx1x2 x3.R(u, z, w) and we can choose Γ = u, x, y, w. Furthermore we have the following productions:
(x1,out2 ,⟨x2,x3⟩)
x1, x2, x3 ▶ Lx1 x2x3.Q(x1, x2, x3) −−−−−−−−−→ x1, x2, x3 ▶ LQ
(x1 ,in2,⟨x2,x3⟩)
x1, x2, x3 ▶ Lx1 x2x3 .R(x1, x2, x3) −−−−−−−−−→ x1, x2, x3 ▶ LR
By applying rule (ren) we can derive:


(u,out2 ,⟨x,y⟩)
u, x, y, z, w ▶ Lx1 x2x3.Q(u, x, y) −−−−−−−→ u, x, y, z, w ▶ LQ
(u,in2,⟨z,w⟩)
u, x, y, z, w ▶ Lx1x2 x3.R(u, z, w) −−−−−−−→ u, x, y, z, w ▶ LR
We can then apply rules (com/close), (par) and (res) to have:
u, x, y, z, w ▶ Lx1 x2x3.Q(u, x, y)|Lx1x2 x3.R(u, z, w)
{x/z,y/w}
−−−−−−→ u, x, y ▶ (LQ|LR){x/z, y/w}
u, x, y, z, w ▶ LP |Lx1x2 x3.Q(u, x, y)|Lx1x2x3 .R(u, z, w)
{x/z,y/w}
−−−−−−→ u, x, y ▶ (LP |LQ|LR){x/z, y/w}
u, x, y, w ▶ νz LP |Lx1 x2x3.Q(u, x, y)|Lx1x2 x3.R(u, z, w)
{y/w}
−−−→ u, x, y ▶ (LP |LQ|LR){x/z, y/w}
as desired since {y/w} is a substitutive effect of {y = w}.
Here we show how SHR can be used to execute many Fusion Calculus transitions in one step.
Example 3.12 Let us consider the fusion process (xy)(ux.P |yx.Q|yz.R). We can have the two following computations:
(x)ux
(xy)(ux.P |yx.Q|yz.R) −−−→ (y)(P |yx.Q|yz.R)
{x=z}
−−−→ (y)(P |Q|R)

(xy)(ux.P |yx.Q|yz.R)
→−1
−u→z
(y)((ux.P |Q|R){z/x})
(y)((P |Q|R){z/x})

Using the translation and the inference rules of definition 3.1 we have the two corresponding sequences of transitions:
u, z ▶ νx, y Lx1 x2.P (u, x)|Lx1x2 .Q(y, x)|Lx1x2 .R(y, z)
(u,in1,x)
−−−−−→ u, z, x ▶ νy LP |Lx1x2.Q(y, x)|Lx1x2.R(y, z)
{z/x}
−−−→ u, z ▶ νy (LP |LQ|LR){z/x}
u, z ▶ νx, y (Lx1 x2.P (u, x)|Lx1x2 .Q(y, x)|Lx1x2 .R(y, z))
→	u, z ▶ νy (Lx1 x2.P (u, x)|LQ|LR){z/x}
(u,in1,z)
−−−−−→ u, z ▶ νy (LP |LQ|LR){z/x}
Note that in this case the two results are equal, even if the observations are different because of the different ordering on the transitions. Furthermore if we choose the set of inference rules of definition 2.12 we can also have the transition:

u, z ▶ νx, y (Lx1 x2.P (u, x)|Lx1x2 .Q(y, x)|Lx1x2 .R(y, z))
(u,in1,z)
−−−−−→ u, z ▶ νy (LP |LQ|LR){z/x}
which corresponds to the concurrent execution of the two transitions.
We end this section with a simple schema on the correspondence between the two models.


Conclusions
We have analyzed the relationships between Fusion Calculus and SHR, show- ing that they both rely on the same underlying algebraic structure and on Milner synchronization (but SHR can also use other kinds of synchronization models) and that the main difference is the interleaving behaviour of Fusion Calculus with respect to the concurrent nature of SHR. Thus we have de- vised an interleaving version of SHR with Milner synchronization and proved a correspondence theorem between the two models.
In literature we have two similar works, which map respectively π-calculus
[5] and Ambient calculus [3] into SHR. With respect to [3] we use the same mobility mechanism (that is we allow fusions of any node) but we do not need multiple synchronizations. Furthermore ambients have poor communication mechanisms and use only tree-structured processes, whereas we have general graphs. With respect to [5] and the π-calculus we allow general fusions of names. This is important since this is the same kind of mobility used in logic programming, as shown in [7], and thus this work is a first step from process-calculi with fusions towards logic programming.
As future work we want to go ahead in this direction, in particular ana- lyzing the relationship between Hoare synchronization (which is used in logic programming) and Milner synchronization (which is used in the most popular process-calculi). This will bridge the gap between Fusion Calculus and logic programming.
Another direction for future developments is the transfer of techniques between Fusion Calculus and SHR. In particular it would be interesting to


extend the concept of hyperequivalence to SHR (keeping the property of being a congruence) and, in the opposite direction, using SHR in order to provide a concurrent semantics to Fusion Calculus.

References
Pierpaolo Degano and Ugo Montanari. A model for distributed systems based on graph rewriting. Journal of the ACM (JACM), 34(2):411–449, 1987.
H. Ehrig, H.-J. Kreowski, U. Montanari, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformation, Vol.3: Concurrency, Parallellism, and Distribution. World Scientific, 1999.
GianLuigi Ferrari, Ugo Montanari, and Emilio Tuosto. A lts semantics of ambients via graph synchronization with mobility. In Simona Ronchi Della Rocca Antonio Restivo and Luca Roversi, editors, Proc. of ICTCS’01, volume 2202 of LNCS, pages 1–16. Springer, October 2001.
Dan Hirsch. Graph Transformation Models for Software Architecture Styles. PhD thesis, Departamento de Computacio´n, Facultad de Ciencias Exactas y Naturales, Universidad de Buenos Aires, Argentina, 2003.
Dan Hirsch and Ugo Montanari. Synchronized hyperedge replacement with name mobility. In Springer Verlag, editor, Proc. of CONCUR’01, LNCS, 2001.
Barbara Ko¨nig and Ugo Montanari. Observational equivalence for synchronized graph rewriting. In Springer Verlag, editor, Proc. TACS’01, volume 2215 of LNCS, January 2001.
Ivan Lanese. Process synchronization in distributed systems via Horn clauses. Master’s thesis, University of Pisa, Computer Science Department, 2002. Downloadable from http://www.di.unipi.it/~lanese/tesi.ps .
Ivan Lanese and Ugo Montanari. Software architectures, global computing and graph transformation via logic programming. In Leila Ribeiro, editor, Proc SBES’2002 - 16th Brazilian Symposium on Software Engineering, pages 11–35. Anais, 2002.
Robin Milner. A calculus of communicating systems. In Lect. Notes in Comp. Sci., volume 92. Springer, Berlin, 1989.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes. Inform. and Comput., 100:1–77, 1992.
Joachim Parrow and Bjo¨rn Victor. The fusion calculus: Expressiveness and symmetry in mobile processes. In Proceedings of LICS ’98. IEEE, Computer Society Press, June 1998.
G. Rozenberg, editor. Handbook of graph grammars and computing by graph transformations, vol. 1: Foundations. World Scientific, 1997.
