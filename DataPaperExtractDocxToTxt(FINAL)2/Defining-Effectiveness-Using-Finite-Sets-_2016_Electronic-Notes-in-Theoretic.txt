Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 324 (2016) 91–106
www.elsevier.com/locate/entcs

Defining Effectiveness Using Finite Sets A Study on Computability
Hugo D. Macedo a,b,1
a DTU Compute Technical University of Denmark
2800 Kongens Lyngby DENMARK
Edward H. Haeusler 2
b Departamento de Inform´atica – PUC-Rio Rua Marquˆes de S˜ao Vicente 225
22451-900 G´avea Rio de Janeiro BRAZIL
Alex Garcia 3
Instituto Militar de Engenharia – IME Pra¸ca General Tibu´rcio 80
22290-270 Urca
Rio de Janeiro BRAZIL

Abstract
This paper studies effectiveness in the domain of computability. In the context of model-theoretical ap- proaches to effectiveness, where a function is considered effective if there is a model containing a repre- sentation of such function, our definition relies on a model provided by functions between finite sets and uses category theory as its mathematical foundations. The model relies on the fact that every function between finite sets is computable, and that the finite composition of such functions is also computable. Our approach is an alternative to the traditional model-theoretical based works which rely on (ZFC) set theory as a mathematical foundation, and our approach is also novel when compared to the already existing works using category theory to approach computability results. Moreover, we show how to encode Turing machine computations in the model, thus concluding the model expresses at least the desired computational behavior. We also provide details on what instances of the model would indeed be computable by a Turing machine.
Keywords: Effectiveness, Finite sets, Models of computation.


1 Email: hmacedo@inf.puc-rio.br
2 Email: hermann@inf.puc-rio.br
3 Email: garcia@ime.eb.br

http://dx.doi.org/10.1016/j.entcs.2016.09.009
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Introduction
Together with the arrival of advanced computing machinery, the first half of the 20th century presented us with the concept of computability. Nowadays, a stan- dard course on the subject should discuss models and results on computation and in particular the Church-Turing thesis, which equates what can be effectively com- puted, and what can be computed by a machine running an algorithm. In what follows, the term algorithm is to be taken according to its current meaning. Effec- tiveness, on the other hand, will be defined building upon its intuitive meaning of what “is computable”.
Despite its apogee in the 20th century, effectiveness was already present in many fields of the human knowledge in Ancient times. In our daily lives there are routines we perform due to cultural heritage, while others are pervasive and encountered in every culture. Such pervasive routines may be considered as universal or natural aspects of our lives. Arithmetic is an example of such an universal aspect, it is present in all known civilizations 4 , and (historically) a great part of our cognitive life (was and) is dedicated to learn and develop algorithms on the basic operations used to calculate with natural numbers and other number systems.
Besides arithmetic, the field of geometry has its realm of algorithms too. For example, proposition I.1, in Book I of Euclid’s Elements, showing that given a line segment, an equilateral triangle exists that includes the segment as one of its sides, is obtained by describing an algorithm that constructs an equilateral triangle on a (given) straight line, together with its own correctness proof. Many propositions in Euclid’s Elements are proved in this way, i.e., the description of an algorithm and its correctness companion argument.
Classical problems as squaring the circle or trisecting an angle using a finite number of straightedge and compass operations can be understood as the search of a method to solve a problem by means of a specialized algorithm. Both problems were proved impossible to solve and it seems that only in mathematics such impos- sibility proofs appear in a definite form. Posterior investigations have shown that constructions with straightedge and compass together with the usual algorithms on the four basic arithmetical operations are not sufficient as the representatives of effectiveness in such problems.
Archimedes’ method of exhaustion provided a way to escape from these impos- sibility proofs sacrificing perfection, namely exact results, in favor of feasibility (see the quadrature of the parabolic segment [1]). Thus, since the ancient classical pe- riod, it is known that the nature of the objects involved in the chosen method to attack a problem determines the effectiveness of the respective method itself. Nowa- days, such rule-of-thumb finds its place in the manual of best-practices of computer programmers when deciding and designing the datatypes that the program manip- ulates.
It took a pair of millenniums for us to realize that effectiveness should be firstly considered as a kind of property on functions, and, that functions should be consid-

4 Furthermore, also primates, lions, and dolphins have arithmetical capabilities [2]

ered as a relationship between inputs and outputs. The last century was successful in characterizing which functions from a set of inputs A into a set of outputs B are effective. A pair of decades after its beginning, partial functions instead of total ones were admitted in the realm of effective functions. Furthermore, realizing that the set of Natural Numbers, presented as a numeral system, should be considered as the universe for the subsets A and B mentioned previously, was also a recent development.
Historically, investigations on effectiveness followed mainly two non-exclusive tracks. In the model-theoretical approach, a “model” M is presented and any (partial) function f : N → N is called M-effective if and only if there is an instance of the model M, written as Xf , that represents f . The meaning of the “instance Mf represents f ” is given informally by stating that whenever an input i submitted to fM produces an output o then f (i)= o must be true. The meaning of “submitting” and of “producing” is also, at least informally, defined when introducing the “model” M.
In the proof-theoretical approach, a logical theory T is defined and f , a function from A ⊆ N into B ⊆ B, is said to be T -effective if and only if f ∈ T . Of course T is presented by a set of axioms and inference rules for deriving propositions on membership to the theory T and on equivalences between functions f and g, i.e., of the form g ∈T and f ≡ g respectively.
A typical example of a model-theoretic approach is the Turing machine based effectiveness definition, whereas G¨odel partial recursive functions exemplifies the proof-theoretical one. The approaches for defining effectiveness are not exclusively model-theoretical or proof-theoretical. One can consider lambda-calculus as a purely proof-theoretical example if one ignores the underlying evaluation model provided by the identity relationship. On the other hand, we can consider the lambda calculus as a model-theoretical approach if one focus on the λ-terms evaluation model. Roger’s theorem on the abstract axiomatization for the proof-theoretical approach on effec- tiveness provides stronger 5 evidence for Church-Turing thesis (see [12] and mainly [10] for a very appraisal discussion). Roger axiomatization is a proof-theoretical attempt to precisely express the models for effectiveness in a truly abstract way. Programs are numbers and models are families of Natural Number valued functions indexed by the formers.
To the best of our knowledge, beyond its similarities it is worth mentioning that almost all the model-theoretical approaches for effectiveness lie inside ZFC 6 . Category Theory (CT), although an alternative that is not completely dissociated from the ZFC and other set theoretical approaches to the foundation of mathemat- ics, provides, nevertheless, an alternative ontology 7 . In CT, classes of objects and morphisms form a category. Morphisms are typed by domain and co-domain. For example let A and B be objects in a category C with f : A → B a morphism in C, f has domain A and co-domain B.

5 Stronger than evidence provided by some concrete models, as those raised since Turing’s work
6 Zermelo Fraenkel set theory with the axiom of Choice
7 Terminology, in philosophical sense

However, the meta-theory CT, apart from the parcel of ZFC that it uses, does not provide meaning to propositions of the form A = B in C. Such theory only provides meaning to assertions of the type f = g whenever f and g are morphisms. Given that, one concludes that in SETS, the archetypal category of the class of all sets and all functions between them, only the identity on functions have a precise semantics 8 . Moreover, about the objects of SETS, i.e., the sets themselves, it cannot be stated that any two sets are equal or not equal. The most that can be said is that they are isomorphic or not 9 . This change of perspective is quite interesting since it provides more ways to compare models of certain concepts than if the concepts were formalized on top of ZFC.
This article follows the model-theoretical approach for defining effectiveness by providing an alternative way to present effective functions using category theory. Our proposal is different from the effective topos ([7]) and from the work presented in a series of articles by prof. Robert Walters (see [16] for a brief and easy introduction on the subject). In the next section we discuss the main motivation of our alternative to the study of effectiveness.
Effectiveness and their categorical models
Higher-order logic (HOL) has been generally used to express and formalize con- cepts in computer science ([9,14,15]). As a typed language, it is well suited to the ubiquitous typing discipline in formal specification and validation. Contrary to ZFC specifications that are usually untyped and use first-order logic, this typ- ing discipline has deeper consequences than the simple fact of avoiding paradoxes. Because of lack of space, we cannot discuss this here. The reader can see [5,8] for a comprehensive presentation. From the model-theoretic counterpart, higher-order logic theories have special categories, called Toposes, that serve as abstract mod- els for these theories, the same way Heyting algebras serve as algebraic models for Intuitionistic Propositional Logic.
Although having a simple definition, a topos describes an entire mathematical universe of discourse for HOL theories. Any provable HOL formula is true in every topos, and consequently in SETS. On the other hand, any topos has an internal logic, such that, if a HOL formula is true in this topos, the formula is provable in intuitionistic logic. The category SETS is a topos that has Classical HOL as internal language, since every valid classical HOL formula is true in SETS. On the other hand, the category of functors from the pre-ordered category ω =
{0, 1, 2, n,.. .} into SETS validates only the intuitionistically valid HOL formulas. In this article the sub-category of finitely valued functors from ω into SETS is central. This category is denoted by FinSetω.
What is the appropriate universe of discourse for effectiveness? Technically speaking, we would like to know what is the adequate topos for studying effective- ness. Our motivation for studying FinSetω comes from concluding that there is no

8 Equalizing functions is a known issue
9 A is isomorphic to B, iff, there are f : A → B and g : B → A, such that, f ◦ g = IdB and g ◦ f = IdA

topos that satisfies the law of the excluded middle, has only computable functions as morphisms, and has a Natural Numbers object. Thus, the universe of discourse for effectiveness has to dropout at least one of these three properties, but let us first examine such result.
The argument that follows can be found in [13] and specifically in [11] using the language of CT. Firstly, take the Strong Church Thesis (SCT) “Every function from N in N is computable” into account. Considering that a function is computable if and only if there is a program that computes it, and, any program can be expressed by its code that by its turn can be viewed as a natural number. Thus, STC can be expressed by the following first-order formula:
∀f ∃p ∀n ∃y · (T (p, n, y) ∧ Out(y)= f (n)),
where T (p, n, y) is Kleene’s T predicate and Out(y) is Kleene’s output function. Using the theory of Peano Arithmetic we can obtain T and Out as primitive recursive predicate and function respectively. Thus, in any topos with a Natural Number object, T and Out are primitive recursive too. Thus, in the typed HOL language, SCT is of form:

∀f NN ∃pN∀nN∃yN(T (p, n, y) ∧ Out(y)= 
f (n)).

Considering an arbitrary topos having a Natural Numbers object, and having classical logic as internal logic, it can be shown that SCT is inconsistent with this situation, namely, in this topos SCT cannot hold. Using the fact that classical logic satisfies the law of excluded middle, the definition for g as follows:
m +1 if	∃jN(T (n, n, j) ∧ Out(j)= m)
g(n)= 
⎩ 0	otherwise
is provable to be defined for every n. Thus g is a total function, and hence by SCT has a program p. However, any program p ∈ N that implements g is such that g(p) = (g(p)) + 1, since there is j, such that, T (p, p, j) and Out(j) = m and (g(p)) = m + 1. This is not possible, so SCT is inconsistent with the law of the excluded middle in a topos having a Natural Numbers object.
Let us analyze the remaining alternatives when defining a topos. A topos may have the following properties:
The internal logic of the topos is classical;
Every morphism in the topos is effective, i.e., SCT holds in the topos;
The topos has a Natural Numbers object.
We’ve just shown that ii is inconsistent with i and iii, so either we drop out classical logic or the existence of Natural Numbers object. If we define a topos with a non-classical internal logic we end up revisiting the well studied effective topos. On the other hand, if we drop out item ii, we obtain with i and iii the also well studied classical theory of recursive functions. The last alternative is to drop out the existence of a Natural Numbers object. In a naive setting, i and ii together entail finite sets and first-order finite domain logic. In the category-theoretic setting, FinSetω represents this alternative which we claim to deserve more study.

Particularities of finite sets (FinSet)
The first step in defining the model of computation is the clarification of what is a finite set. Such endeavour avoid misunderstandings in the following development and due to its intuitive character one usually steps over formalities losing insight. Finite set is defined in terms of finite which means limited and mathematically:
Definition 3.1 The empty set is finite. A non-empty set S is finite if there exists a bijection from S to a prefix of the natural numbers, {1, ··· , n}⊂ N. The number n is usually termed the cardinality of the set.
Note that by relying on natural numbers to define finite sets we do not introduce a Natural Numbers Object (NNO) in our computability model. One could easily use a definition of finiteness using other alternatives as the ones studied in [6], nevertheless the usage of N simplifies our characterization of finite sets.
Definition 3.2 The category with finite sets as objects and all functions between such sets, denoted as FinSet, is the full subcategory of SETS where objects are restricted to finite sets.
Our definition of FinSet sieves the category of all functions between sets and drops every function that has an infinite set as domain or range, the following proposition shows that the functions remaining in FinSet are finite.
Proposition 3.3 A function f : A → B with a ﬁnite domain, i.e. A is a ﬁnite set, is ﬁnite, i.e. the cardinality of the set {(a, f (a)) | a ∈ A} is ﬁnite.
Proof. Let f be a function with type f : A → B where A is a finite set. As f is a function, for each a ∈ A there must be only and only one element b ∈ B such that b = f (a), therefore there are at most as many elements f (a) as elements in a. As the number of elements in A is finite, so are the number of elements
{(a, f (a)) | a ∈ A}.	2
As a corollary, every function in FinSet is finite. Let us now study the cardi- nality of the hom-sets in FinSet, of functions between finite sets.
Proposition 3.4 Given ﬁnite sets A = {a1, ··· , an} and B = {b1, ··· , bm} the function space BA is a ﬁnite set with mn elements.
We are now in a position where we can prove the following:
Proposition 3.5 For ﬁnite sets A and B every function f : A → B is computable.

Proof. Suppose A and B are finite sets, thus by (3.4) the space of functions BA is finite. Therefore let us pick a function f : A → B. Let us show it is computable. Because f is a function for each a ∈ A there exists a unique b ∈ B s.t. f (a)= b. As A is finite by (3.1) it has some cardinality n and there is a bijection which we can use to assert A = {a1, ··· , an}. Now one can apply f to each element of A obtaining

input x; output y; parallel
: if x <> r1 then t2;
: if x <> r2 then t2;
: if x <> r3 then t1; end
Fig. 1. Program computing K
the set {f (a1), ··· ,f (an)}, the image of f usually written as f (A). Thus we devise a program P computing f as a simple table lookup for the input x.	2
As there is a pattern matching inherent to the table lookup argument in the previous proof, one needs to study the cases where the elements pose problems to the equality decision, for instance infinite sets, or undistinguishable sets.
Pattern matching finite sets with undistinguishable elements.
Let us start with possibly undistinguishable elements. When defining a function of a finite set A with two elements, we assume the elements are distinguishable. Such argument can be derived from the fact that isomorphic objects are considered equal, thus as every finite set A with n elements can be put in bijection with the set {1,  , n}. In practice, we abstract away the nature of the elements and work
with the natural number labels. In the pattern matching process elements e and ej that are not distinguishable outside FinSet will not be distinguishable inside as well. In any case, given the fact that sets have no repeated elements, that is if a ∈ A then {a}∪ A = A, the set built with two indistinguishable elements {e, ej} cannot be a two element set, as it would demand a bijection f : {e}→ {0, 1}, but the cardinalities differ.
Pattern matching finite sets containing infinite elements.
Proposition 3.5 holds even if the elements of A and B belong to a recursive enumerable set that is not recursive. Let’s illustrate such case, we know that there is no recursive identity relationship in R. We also known that the difference in R is recursively enumerable. Let A = {r1, r2, r3}⊆ R, B = {t1, t2}⊆ R and K : A → B, such that, K(r1)= K(r2)= t1 and K(r3)= t2. We can assume that real numbers are represented by the processes/program that compute them. For example π can be represented by any program that given a precision p provides π expanded until this precision. Equivalently, we can consider the real numbers as programs that list the decimal expansion of them. In this last case, π is any program that prints 3.141593..... and never stops. Using, this last representation of (computable) real numbers, the function K is computed by the program in Figure 1. Where the command parallel :< cmd1 >;    < cmdn >; end runs all < cmdi >, i = 1, n, in
parallel, and stops whenever some of < cmdi > stops. The output of the parallel
command is the output of the < cmdi > that firstly stops. Programs like these, entail the fact that any function between finite sets is computable, even in the case

that the elements of the domain belong to a recursively enumerable data-type that is not recursive.
Now that we solved the issues arising from the usage of pattern matching we can proceed to prove how to build complex behaviours using finite functions as atomic and computable steps.
Proposition 3.6 Let A, B, and C be ﬁnite sets and f and g be ﬁnite functions with types f : A → B and g : B → C. The composition g · f is a ﬁnite and computable function.
Proof. The composition g · f is a function, and has type A → C. As A and C are finite sets, proposition 3.4 holds, meaning that g · f is member of the finite set of functions CA, as a function it must map each element of A to an element of C, as there are finite elements in A, g · f maps at most finite elements, thus it is a finite function, thus by proposition 3.5 the composition g · f is computable.	2
Thus, extending the previous argument we can prove that every morphism in FinSet is computable, thus every finite composition of finite functions is com- putable. To make such statement precise let us define finite composition of func- tions.
Definition 3.7 Let n ∈ N be a fixed number. From n we obtain the pre-ordered category with objects the numbers 1 to n, and all morphisms a → b when a ≤ b, denoted as ↓ n, and depicted as:

The category ↓ n is a finite linear pre-order .
Any functor from ↓ n into FinSet can is as a representation of finite composi- tions of finite functions.
Thus, by Proposition 3.6 and fixing n, the functorial category FinSet↓n is a category of computable functions. Despite such fact, the expressiveness of FinSet↓n is not enough to capture all computations, for instance the computation of π. To capture infinite behaviours we will study the case where ↓ n is substituted by ω, thus studying FinSetω as model for computations. The limit just mentioned and the reason why ω allows the capture of infinite behaviors is made clear in the following section.
Expressing computations in FinSetω
In this section we define our base category FinSetω, we show that such category is at least as expressive as the universal Turing machine model of computation, and we observe that FinSetω also includes non-computable behaviours. Such final observation leads to conjectures on what restriction should be applied to FinSetω to restrict its expressive power to computable functions.

Encoding computations as functors in FinSetω
Our standard model of computation is the Turing machine which is an automaton with a non-empty finite set of states Q, a finite set of reading/writing symbols from an alphabet Γ, a distinguished blank symbol b, a partial transition function δ de- scribing the behaviour of the machine, a distinguished state qo which is corresponds to the initial state of the machine and F ⊆ Q a set of final states.
Thus the tuple M = (Q, Γ, b, Γ \b, δ, q0,F ) corresponds to a Turing Machine, the universal model of computation. To complete the model of computation the machine M is usually coupled with a unbounded tape containing cells with symbols from Γ, more precisely at each instant of time the machine has access to a cell and is allowed to either move to the left(−1)/right(1) cell in the tape. Such movement is ruled by δ as recorded in its type:
δ : (Q \ F ) × Γ → Q × Γ × {−1, 1}
Turing machines stop when final (F) state is reached, thus the type of δ reads as “for each defined non-final state and symbol the machine state changes, a new symbol is written in the current cell and the machine positions itself to the right or the left of the current cell.
To each machine M and tape the behaviour of the machine is well-defined and is expressed in terms of sequences of configurations Ci where i a natural number tracking the number of transitions that occurred. Thus the behaviour of a machine M with a given tape is equivalent to a infinite sequence of configurations C0 · C1 · C2 ··· which encodes the stepwise execution of the machine. Such a sequence is commonly termed a computation.
Thus, let us explain how to encode computation in our model. The configura- tion behaviour is easily encoded in the FinSetω. Before any formal explanation on why that is a fact, let the following drawing do the illustration of the infinite configuration sequence. In fact it provides a geometrical perspective on the just mentioned sequence.


 C0¸
 ¸	 ¸

 ¸	 ¸
 ¸	 ¸

 ,


0	 1  ¸	 2  ¸	 n ¸	 ¸
Fig. 2. Computation in FinSetω



Let us now make the configurations Ci concrete, providing thus a rigorous state- ment on the encoding using FinSetω. A configuration consists of a finite set con- taining the state q ∈ Q in which the machine is, the current position (p) in the tape and a finite string w ∈ Σ∗ with the contents of the tape. Thus each configuration is a finite set indexed by a natural number, without further ado define T ∈ FinSetω

as 10 :

(1)
⎧ T0(i)	= Ci = (q, p, w)
T1(i → i + 1) = λ(q, p, w).(qj,p + off, wj)
⎪⎪⎩ T1(i → j)	= T1((j — 1) → j) · T1(i, (j — 1))

where (qj, γ, off )= δ(q, wp) and wj is a copy of w except in position p the content
is wj = γ
Therefore our definition of effectiveness can be used to prove one of the im- plications of the SCT thesis, Every Turing machine has a corresponding effective computation model. It corresponds to the unfolding of the dynamic system cor- responding to the machine executions. Therefore, the interesting question is the contrapositive of the implication. What are the elements of FinSetω that corre- spond to computations, i. e. the elements that could have been generated by a Turing machine?
Before answering that question let us highlight an interesting join point between our functorial expression of computations and the folk knowledge on computability that expresses that computable functions should necessarily satisfy the following condition: “to produce a finite amount of output only the inspection of a finite amount of the input is necessary”. That statement can be observed in the con- travariant functor definition of T1 in (1). Note how it states that given a time span (i → j), to observe the outputed behaviour one needs only evaluate a finite amount (in fact j — i + 1 steps of applications of T1.
Which subcategory of FinSetω corresponds to computations?
Given that we have proved a result stating that functions between finite sets are computable, and that composition of such functions are computable as well, one would expect that given Figure 2 frames computations in terms of stepwise transi- tions between finite sets, given that the framework is FinSetω, one could conjecture that the functors of FinSetω are indeed the computable entities. But that is not the case, the reason for that is that when substituting ↓ n by ω the argument of finite function composition being again a finite function is lost.
We will now present a counterexample that evidences that more structure must be present in the functor of FinSetω for it to be computable. The argument is based in the following reasoning.
Assume for each i we attribute a finite set containing truth values T and ⊥. We also assume an enumeration of Turing Machines. Then for each i attribute the finite function

f (i)= 
⎧⎨ T if the ith machine halts
⎩ ⊥ otherwise

The function f is a member of FinSetω, but as it solves the halting problem, it

10 We adopt the T = (T0, T1) functor notation where T0 is an object mapping, and T1 a morphism mapping

should not be computable. Therefore one should add more requirements to FinSetω
in order for it to correspond to a category of computations.
One interesting point to note is that f as described could be tabled into batches, precomputed, or partialy-evaluated. For instance, for each i we could store the results of the ith and following i + 1th machine in a table. Furthermore, we could batch (table) enormous finite amounts of results of f , precomputing and storing the results, but despite that one cannot precompute the whole function. It is like the program running the algorithm must be infinite to be able to compute the function to the whole domain of the input. Keeping that in mind we will develop the notion of batching using natural transformations.


Encoding computations as natural transformations
An alternative view on the previous encoding of computations is to go higher in ab- straction and use natural transformations between FinSetω functors, thus elements η typed as η : FinSetω → FinSetω.
Let C and Cj be functors in FinSetω where C corresponds to the computations of some Turing machine and similar for the Cj case. One is able to define a natural transformation η : C → Cj such that for each i ∈ ω we have ηi : C(i) → Cj(i). Take C represented graphically:

 C0¸	 ¸	 ¸
 ¸	 ¸

 ,


0	 1  ¸	 2  ¸	 n ¸	 ¸
and Cj represented graphically:
0	 1  ¸	 2  ¸	 n ¸	 ¸


vjz
vjz
vjz
vjz

C0 	 C1¸
 C2¸
 Cn¸	 ¸

Then a natural transformation η : C → Cj is depicted as:

 C1¸
 C¸
 ¸
 ¸	 ¸

 ¸


0	 1  ¸	 2  ¸	 n ¸	 ¸



0	 C1¸
η2
vz r
 C2¸

ηn
vz r
 Cn¸	 ¸

a structure transforming each element of C into and element of Cj satisfying the naturallity condition.
Before delving into naturality, let us present a simple example. Choose C as the execution of some arbitrary Turing machine T and Cj the execution configurations

of a Turing machine that executes two steps of T at each time interval.

 ¸	 ¸
	
 ¸	 ¸
 ¸	 ¸

 ,


0	 1  ¸	 2  ¸	 n ¸	 ¸

η1
vz 
C2	 C3¸
η2
vz 
 C4¸

ηn
z 
 Cn¸+2	 ¸

The fact that η is a natural transformation expresses the known fact that it is possible to group the computation in batches. To realize that just pick the morphism h : ω → ω in the ω category, where h(i)= i+2, which intuitively groups consecutive elements of ω, that is, it creates covers in the topology of the departing ω, and it is depicted as:
0	 1  ¸	 2  ¸	 n ¸	 ¸



h(0) = 2 	 h(1¸) = 3 	 h(2¸) = 4 	 h(n¸) = n + 2	 ¸
The property arising from naturality states that the following diagram commutes:
 C0¸	 ¸	 ¸	 C¸n,	 ¸

0	 1  ¸	 2  ¸	 n ¸	 ¸
h

	 ¸ 
 ¸ 
 ¸ 	 ¸

2	4
η0
v z 
6
η1
v z 

η2
v z 
n +2 

ηn

z 

C2 	 C3¸
 C4¸
 Cn¸+2 	 ¸

and encodes the property which states one is able to compute an arbitrary number of steps of computation and then look two states ahead. Or compute the same arbitrary number of steps in batches.
The intuition behind the necessary condition to be able to model computable functions is that the number of steps needed to perform a computation should be finite. That is to say the inherent logic involved in the production of output is finite. That corresponds to find a limit in the batching of steps.
lim ηn = ηt
n→ω
Such condition is again necessary but not sufficient, if understood in the sequence of configurations of the Turing machine it states that at some point in time t the δ function is completely defined and can be stored as a finite table.

Which elements of FinSetω are computable?
Let us now look at it in the reverse direction: What are the functors that indeed may be computed, or put in other words, that have a Turing machine associated?

Our conjecture is that such functors are the ones for which there exists a cover of the topology induced by F on ω. In other words, only functors F that are compact should be considered effective.
To observe such cover and analyse the topology of FinSetω stepwise evolution (computation steps) we augment the model by adding another layer of ω to track batching, thus obtaining a functor (FinSetω)ω = FinSetω×ω as depicted in Fig.
3. By convention we assume the vertically growing ω encodes stepwise machine execution, and that the horizontally growing ω encodes the batching transitions. Using that encoding a transition of a Turing machine is a natural transformation between FinSetω functors. Therefore, each horizontal step prescribes a morphism η between Fi and Fi+1.



,,


m,,

2,,
,,

F 0(,m,)

F 0(,,2),

F 0(,,1),
,,

 F1¸(,m,)

 F1¸(,2),

 F1¸(,1),

 F1¸(0)
,,

 F2¸(,m,)

 F2¸(,2),

 F2¸(,1),

 F2¸(0)
,,

 Fn¸(,m,)	 ¸

 Fn¸(,2),	 ¸

 Fn¸(,1),	 ¸

 Fn¸(0)	 ¸


 2  ¸	 n ¸	 ¸

Fig. 3. The FinSetω×ω model.

We characterize the augmented model as a manifold, the computational mani- fold, where each element Fn ∈ FinSetω, each (n — 1)-step computation trace is a projection (a map in the usual manifold terminology) from the whole maifold (at- las) FinSetω×ω satisfying the compatibility condition. Intuitively, such condition ensures that maps depicting common points in the manifold should be compatible, this is, the intersection of the maps in the neighbourhood of such point should have the same shape. 5the characterization we will use the notion of bundle, sieve, and the
Proposition 5.1 The category FinSetωω can be put in correspondence with a sheaf on the site (ω × ω, FinSetω)
Proof. Let T be a Turing machine, and the functor FT : FinSetsω×ω defined as above. Equip ω × ω with the Grothendieck topology. Then FT satisfy the compatibility condition, thus FT is a sheaf.	2
As hinted, there is an injective mapping each Turing machine T into a member of FinSetω×ω, with such T '→ FT injective mapping one is able to prove the objects

of FinSetω×ω of the form FT for some Turing machine T form a subcategory Tur. Thus, the question: What about computable elements in FinSetω×ω? What are they?
Proposition 5.2 (Conjecture/Goal:) Is Tur a reflective subcategory of (FinSetsω)ω?  If yes we have that every computational sheaf C is essentially FT for some T.M. T .

Effective functions as manifolds with programs as projections
In the tradition of Local/Global approaches for describing mathematical objects where a “global” (non-functional) object as a sphere is studied using “local” (func- tional) projections as maps of the whole atlas, we present a computational model that we term a computational manifold Such modle is a manifold with extra struc- ture as:
Topological manifolds are objects that are locally continuous, i.e., each point has a neighbor whose chart is a continuous function.
Differential (Ck) manifolds are objects that are locally (Ck) differentiable, i.e., each point of the it has an open neighbour whose chart is Ck.
Our computational model is a manifold where objects are locally computable.

Conclusion
The status of our current approach to a model of effectiveness based on finite sets is still ongoing, but as an outcome we already established some important steps. We show how to encode Turing machine behaviors as a functor in FinSetω. We related the functoriality to the necessary condition that to produce a finite amount of input a Turing machine must consume only a finite amount of input. We express n-steps (batches) of computation as a natural transformation, and use the notion of batches to devise a restriction on the elements of FinSetω that are indeed computable by a Turing machine.

Related work
We built a model realizing a model-theoretical approach for effectiveness using CT that is different from the Effective Topos Eff and from [16]. It is different from Eff, the topos emerging from a category of sets equipped with a symmetric and transitive relation and equivalence classes of functional relations between such sets, since it does use a simpler intuitionist topos without Natural Numbers Object (NNO), while Eff uses a non-classical one and has a NNO. It is also different from the approach described by [16] since it uses NNO too. Our framework has no infinite object inside the category. We think that this can be seen as an advantage over [16] that strongly depends on free objects, such as monoids for input and output data. These input/output data are not essential in our approach.

In [4], a categorical presentation of recursiveness is provided using CT. It ax- iomatizes categories able to define primitive recursive morphisms in a completely abstract way. Using the internal language of the category it is possible to precisely define any primitive recursive function. This work is very interesting, since, it joins in a quite harmonious way a model-theoretic definition with a proof-theoretic one. The identity present in the meta-theory provides meaning for a theory of equality between intentionally distinct ways of defining the primitive recursive functions. Besides that no mention on a concrete numerical system of even richer definition of natural number is needed, but the one need to define primitive recursiveness.
Recently there were attempts to change the status of the Church-Turing from a unprovable thesis to a formal proof [3]. Our goal is not a proof such a huge result, but first steps into the definition of effectiveness.

Future work
The model of computations presented does not model environmental input, the input tape content is fixed at the beginning of computation. Even though the tape content is passible of growing by action of the machine execution one cannot accept infinite input that is being generated by another machine, for instance one machine is producing an infinite decimal expansion of π while other machine is processing such output as input. For that reason future work could address that issue either by enriching the model or just reinterpreting FinSetω×ω. We also envision a better and formalized proof of the claim equating turing machines with locally computable sheaves in FinSetω×ω.
Another path for further study is the comparison and modeling of of other paradigms of computability. For instance recursive functions on sequences of nat- urals. And how our topological structure relates to the topologies arising from domain theoretical studies, e.g. the Scott topology.
Acknowledgement
The present work was supported by a grant from the CNPq, Conselho Nacional de Desenvolvimento Cient´ıfico e Tecnol´ogico - Brasil

References
Archimedes and T. L. Heath, “The Works of Archimedes with the Method of Archimedes,” Dover Publications, New York, 1953.
Dehaene, S., N. Molko, L. Cohen and A. J. Wilson, Arithmetic and the brain, Current opinion in neurobiology 14 (2004), pp. 218–224.
Dershowitz, N. and Y. Gurevich, A natural axiomatization of computability and proof of church’s thesis, Bulletin of Symbolic Logic 14 (2008), pp. 299–350.
Eilenberg, S. and C. C. Elgot, “Recursiveness,” Academic Press, 1970.
Goldblatt, R., “Topoi: the categorial analysis of logic,” Dover, 2006.

Haeusler, E. H., Finiteness and computation in toposes, Preliminary Proceedings of the 11th International Workshop on Developments in Computational Models (DCM 2015) http://dcm-workshop. org. uk/2015 (2015), p. 27.
Hyland, J. M. E., The effective topos, Studies in Logic and the Foundations of Mathematics 110 (1982),
pp. 165–216.
Johnstone, P. T., Sketches of an elephant: A topos theory compendium-volume 1, Sketches of an Elephant: A Topos Theory Compendium-Volume 1, by Peter T Johnstone, pp. 562. Foreword by Peter T Johnstone. Oxford University Press, Nov 2002. ISBN-10: 0198534256. ISBN-13: 9780198534259 1
(2002).
Lambek, J. and P. Scott, “Introduction to Higher Order Categorical Logic,” Number 7 in Cambridge Studies in Advanced Mathematics, Cambridge University Press, 1986.
Machtey, M. and P. Young, “An introduction to the general theory of algorithms,” North-Holland, 1978, vii, 264 p. ; pp.
McLarty, C., “Elementary categories, elementary toposes,” Oxford University Press, 1992.
Rogers, H., “Theory of Recursive Functions and Effective Computability,” MIT Press, 1987, 141–146 pp.
Shapiro, S., Varieties of pluralism and relativism for logic, A companion to relativism (2011), pp. 526– 552.
Smith, D. R., Mechanizing the development of software, NATO ASI SERIES F COMPUTER AND SYSTEMS SCIENCES 173 (1999), pp. 251–292.
Srinivas, Y. V. and R. Ju¨llig, Specware: Formal support for composing software, in: Mathematics of Program Construction, Springer, 1995, pp. 399–422.
Walters, R. F. C., “Categories and computer science,” Cambridge University Press, 1991.
