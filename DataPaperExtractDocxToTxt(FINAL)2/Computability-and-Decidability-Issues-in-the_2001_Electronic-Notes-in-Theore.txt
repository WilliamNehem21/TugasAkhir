Electronic Notes in Theoretical Computer Science 42 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume42.html 23 pages


Computability and Decidability Issues in the Theory of Consistency Enforcement

Sebastian Link 1 and Klaus-Dieter Schewe 2
Massey University, Department of Information Systems,
Private Bag 11222 Palmerston North, New Zealand


Abstract
Consistency enforcement provides an alternative to common program verification within formal program specification languages. The existing approach uses a partial order on semantic equivalence classes of program specifications, called specialization, and aims to replace a given specification S by the greatest consistent specialization SI which is provably consistent with respect to the given static invariant I.
The underlying logic is arithmetic logic which allows computability and decidabil- ity issues in connection with the constructive generation of SI to be investigated.
In this paper we justify the axiomatic approach to Dijkstra’s calculus with re- spect to arithmetic logic and develop a new theory on top of that basis for which the construction problem of the greatest consistent specialization of a complex spec- ification can be reduced to the involved basic commands and the investigation of a precondition. In addition, we are now even able to show that this construction is computable under mild restrictions concerning recursive program specifications and that the occuring precondition is decidable for common classes of invariants.


Introduction
It has become fairly standard within almost all formal specification languages to provide at least static invariants. On the one hand this allows to describe the semantics of a system in a sufficent way, but the other side of the coin is the task to guarantee consistency. For a program specification S and an invariant I this means that every execution of S starting in a state that satisfies I should always lead to a state satisfying I, too. However, we can

1 Email: S.Link@massey.ac.nz
2 Email: K.D.Schewe@massey.ac.nz
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


restrict ourselves to terminating executions of S and can therefore handle the problems of termination and consistency separately.
For a general treatment we consider the axiomatic approach to program semantics using predicate transformers which lead to weakest (liberal) precon- ditions. It is well known in this context that we may express consistency by the proof obligation I ⇒ wlp(S)(I), but the verification efforts normally get out of hand.
The search for alternatives brings us to the idea of consistency enforcement. In particular, in the field of databases, where the complexity of the invariants— usually called integrity constraints in this context [9]—is much higher than the complexity of the programs themselves, the trigger approach has become very popular, but it can be shown that triggers cannot solve the problem in general [7].
A different approach, which indeed suggests itself, deals with greatest con- sistent specializations (GCSs) [6,8]. Considering a given program specification S and a given static invariant I we try to replace S by a slightly modified program specification SI that is provably consistent with respect to I. Fur- thermore, all “effects” of the original S should be preserved within SI. This can be formalized by the introduction of a specialization order on semantic equivalence classes of program specifications. The existing theory on GCS in
[6] is based on infinitary logic Lω .
In order to shift the GCS approach from a somehow purely theoretical framework to an applicable theory we have to investigate computability of GCSs and decidability of preconditions that must be built. For these purposes it is preferable to obtain a tight connection with classical recursion theory [1]. This will be done in this paper.
At the beginning of Section 2 we introduce our notations for arithmetic logic. Then we are up to define what predicate transformers should be with respect to this logic, especially we want this axiomatical approach to become equivalent with the relational semantics. Therefore, we have to guarantee some slightly modified characteristic properties of predicate transformers, namely the universal conjunctivity and the pairing condition. Being so far, the stan- dard semantics of guarded commands carries over and we are even able to show in Section 3 that recursion theory can be extended to the arithmetic case, at least, if we are restricted to certain WHILE-loops.
With this background we can develop the GCS approach on top of arith- metic logic. This will be done in Section 4. Many of the proofs follow the ideas of their classical counterparts in [6]. Computability cannot be achieved in general, since the building of least fixpoints requires to test for semantic equivalence, which is undecidable. If restricted to FOR-loops, however, GCSs become computable. This will be shown in Section 5. Furthermore, we show that preconditions that naturally occur in GCSs are not decidable in general, but we also indicate conditions which guarantee decidability.
We argue that at least for one application field, i.e. databases as already


mentioned, the restrictions are tolerable. For the general case some other pragmatic solutions must be applied [5]. We conclude with a short summary and outlook.
For more details we refer the reader to the thesis [3].

Programming Semantics based on Arithmetic Logic
Our study is based on first-order arithmetic logic [1, Ch.7], i.e. our logical language contains just the function symbols 0, s, + and ∗ of arity 0, 1, 2 and
2. The informal meaning is as usual: the constant 0, the succesor function, addition and multiplication. By convenience + and ∗ are written as infix operators. The only predicate symbol is the equality symbol =. Variables in
our language will be x1, x2, x3,... .
We use the notation T for the set of terms and F for the set of formulae. In addition, let V denote the set of variables. We allow all standard abbreviations including formulae true and false.
Semantically, we fix a structure with domain N, the set of non-negative integers. Then 0, s, +, ∗ and = are interpreted in the usual way. For an interpretation it is then sufficient to consider a function σ : V → N. By the coincidence theorem it is even sufficient to be given the values σ(xi) for the free variables xi in a term or a formula. In particular, we may always write σ as a k-tuple, if the number of free variables is k.
Finally, a k-ary relation R ⊆ Nk is called arithmetical iff it can be repre- sented by a formula Q ∈ F in arithmetic logic (with free variables x1,..., xk),
i.e. (a1,..., ak) ∈ R holds iff |=σ Q holds for the interpretation defined by
σ(xi) = ai (i = 1,..., k).

Axiomatic approach and its justiﬁcation
In accordance with the existing theory on consistency enforcement in [6] each finite subset X ⊆ V is called a state space. Each function σ : X → N is called a state on X. Equivalently, a state is always representable by a k-tuple. For a fixed X let Σ (= Σ(X)) denote the set of all states over X.
A formula ϕ ∈ F with free variables fr(ϕ) in X is then called an X-formula or an invariant on X. In order to emphasize the variables we sometimes write ϕ(x) with a vector x of the state variables involved.
Then any pair of formulae (∆(S), Σ0(S)) with 2k and k free variables, re- spectively, may be considered as defining the relational semantics of a program specification S. For convenience assume the first k free variables in ∆(S) to coincide with the free variables of Σ0(S).
According to our notation we sometimes write ∆(S)(x, y) and Σ0(S)(x). So ∆(S) can be interpreted by state pairs, whereas Σ0(S) allows an interpre- tation by states. We interpret (σ, τ ) with |=(σ,τ) ∆(S) as an execution of S with start state σ and a final state τ . Similarly, a state σ satisfying Σ0(S) is


considered as a start state for S, in which a non-terminating execution of S
exists.
Note that the model of relational semantics comprises daemonic non- determinism, non-termination and partial undefinedness.
In order to come to an axiomatic semantics based on the introduced logic of arithmetic, we associate with S two predicate transformers wlp(S) and wp(S)—i.e., functions from (equivalence classes) of formulae to (equivalence classes) of formulae—with the standard informal meaning:
wlp(S)(ϕ) characterizes those initial states σ such that each terminating execution of S starting in σ results in a state τ satisfying ϕ.
wp(S)(ϕ) characterizes those initial states σ such that each execution of S
starting in σ terminates and results in a state τ satisfying ϕ.
The notation wlp(S)(ϕ) and wp(S)(ϕ) corresponds to the usual weakest (lib- eral) precondition of S with respect to the postcondition ϕ. In order to save space we shall often use the notation w(l)p(S)(ϕ) to refer to both predicate transformers at a time. If this occurs in an equivalence, then omitting every- thing in parentheses gives the wp-part, whereas omitting just the parentheses results in the wlp-part.
From our introduction of ∆(S) and Σ0(S) the following definition becomes straightforward.
Definition 2.1 The predicate transformers associated with a program spec- ification S on a state space X are defined as

wlp(S)(ϕ(x)) ⇔ ∀y.∆(S)(x, y) ⇒ ϕ(y)	and
wp(S)(ϕ(x)) ⇔ (∀y.∆(S)(x, y) ⇒ ϕ(y)) ∧ ¬Σ0(S)(x)

for arbitrary X-formulae ϕ.	✷
The next step is to show that predicate transformers satisfying some nice conditions are sufficient for the definition of program specifications S. The conditions are the pairing condition and a slightly modified universal con- junctivity property. This gives the equivalence between the relational and the predicate transformer semantics, the so called inversion theorem.
We use the standard notation w(l)p(S)∗(ϕ) ⇔ ¬w(l)p(S)(¬ϕ) and refer to wlp(S)∗ and wp(S)∗ as the dual predicate transformers.
Proposition 2.2 The predicate transformers w(l)p(S) satisfy the following conditions:
wp(S)(ϕ) ⇔ wlp(S)(ϕ) ∧ wp(S)(true)	and
wlp(S)(∀y.Q(y) ⇒ ϕ(x, y)) ⇔ ∀y.Q(y) ⇒ wlp(S)(ϕ(x, y))	.

Conversely, any pair of predicate transformers satisfying these two conditions deﬁnes ∆(S)(x, y) ⇔ wlp(S)∗(x = y) and Σ0(x) ⇔ wp(S)∗(false).

Proof. (sketch) It is straightforward to show that both conditions hold, i.e., it remains to show w(l)p(S) = f(l)p(S) for further predicate transformers f(l)p. The main idea is use the equivalence of an arbitrary X-formula ϕ(x) to
∀y.(x = y ⇒ ϕ(y)) and to apply the universal conjunctivity property of flp provided. For the wp-case we make use of pairing conditions as well as of the first equation already been proved.	✷
The next result gives a normal form representation of the predicate trans- former wlp(S), which will be useful in many proofs.
Lemma 2.3 It is always possible to write wlp(S)(ϕ) in the form
wlp(S)(ϕ(x)) ⇔ ∀z.wlp(S)∗(x = z) ⇒ ϕ(z)	.
Proof. Obviously, we have ϕ(x) ⇔ ∀z.x = z ⇒ ϕ(z) ⇔ ∀z.¬ϕ(z) ⇒ x /= z. Then the lemma follows immediately by applying the universal conjunctivity property.	✷
Guarded Commands afreshed
We now introduce the familiar language of guarded commands [4], for which we use standard basic commands and standard constructors. To define the se- mantics we simply have to define the predicate transformers since the inversion theorem is now available. These definitions are given as follows:
w(l)p(skip)(ϕ) ⇔ ϕ
w(l)p(fail)(ϕ) ⇔ true w(l)p(loop)(ϕ) ⇔ false(∨true)
w(l)p(xi1 := ti1  ... xik := tik )(ϕ) ⇔ {xi1 /ti1 ,..., xik /tik }.ϕ
w(l)p(S1; S2)(ϕ) ⇔ w(l)p(S1)(w(l)p(S2)(ϕ))
w(l)p(S1✷S2)(ϕ) ⇔ w(l)p(S1)(ϕ) ∧ w(l)p(S2)(ϕ)
w(l)p(S1 ☒ S2)(ϕ) ⇔ w(l)p(S1)(ϕ) ∧ (wp(S1)∗(true) ∨ w(l)p(S2)(ϕ)) w(l)p(@xj • S)(ϕ) ⇔ ∀xj.w(l)p(S)(ϕ)
w(l)p(P → S)(ϕ) ⇔P ⇒ w(l)p(S)(ϕ)
Here {xi1 /ti1 ,..., xik /tik } denotes the simultaneous substitution of the vari- ables xij by the terms tij . It is easy to verify the pairing condition and the universal conjunctivity property for these predicate transformers.
We say that S is an X-command for some state space X iff w(l)p(S)(ϕ) ⇔ ϕ hold for each Y -formulae ϕ, where X ∩ Y = ∅, and X is minimal with this property.

Recursive Guarded Commands
In the last section we introduced the language of guarded commands together with an axiomatic semantics expressed via predicate transformers in arith-


metic logic. So far, this language covers straightline non-deterministic partial programs extended by unbounded choice. We would like to go a bit further and investigate recursive programs expressed as least fixpoints µT.f (T ) with respect to a suitable order ≤. This order will be the standard Nelson-order [4].
Unfortunately, we are not able to carry over the very general recursion theory from [4]. We have to restrict ourselves to simple WHILE-loops, i.e., f (T ) = P → S; T✷¬P → skip, where the variable T does not occur within
S. For convenience, we introduce command variables T1, T2,... .

The Nelson-Order
The idea of the Nelson-order is that whenever S1 ≤ S2 holds, then each terminating execution of S1 is preserved within S2, but a terminating execution in S2 may be “approximated” in S1 by a non-terminating execution. This leads to the following definition.
Definition 3.1 The Nelson-order is defined by
S1 ≤ S2 ⇔ (wlp(S2)(ϕ) ⇒ wlp(S1)(ϕ)) ∧ (wp(S1)(ϕ) ⇒ wp(S2)(ϕ))

for all ϕ.	✷
We are specially interested in the chain {fi(loop)}i∈N with respect to ≤. Therefore, we take a G¨odel numbering g of guarded commands, which ex- tends a G¨odel numbering h of terms and formulae for our logic ([1, p.327f.]). With this G¨odel numbering g we may express all formulae w(l)p(fi(loop))(ϕ) by two arithmetic predicates Q1 and Q2.
Lemma 3.2 There are k + 2-ary arithmetic predicates Q1 and Q2 such that Q1(i, j, x) ⇔ wlp(fi(loop))(ϕ(x))	and	Q2(i, j, x) ⇔ wp(fi(loop))(ϕ(x)) hold for h(ϕ(x)) = j and x = xi1 ,..., xik .
Proof. (sketch) For arbitrary program specifications S and arithmetic pred-

icates ϕ, it is straightforward to define inductively formulae Q'
such that

Q' (i, j, x) ⇔ wlp(S)(ϕ(x)) with g(S) = i and h(ϕ) = j holds. In particular, using our G¨odel numbering g we obtain a primitve recursive function g¯ such that
Q' (g¯k(g(loop)), j, x) ⇔ wlp(fk(loop))(ϕ(x))
is satisfied.	Then, we define predicates Q1(k, j, x) ⇔ Q' (g¯k(g(loop)), j, x)
and an extension of Q¯(h(ψ), h(ϕ), x) ⇔ (P ⇒ wlp(T )(ψ) ∧ ¬P ⇒ ϕ) with
ψ,ϕ ∈ F. We conclude
Q1(k, j, x) ⇔ Q' (g¯k(g(loop)), j, x) ⇔ Q¯(h(ψ), h(ϕ), x)	,


where h(ϕ) = j and ψ(x) = wlp(fk−1(loop))(ϕ(x)) = Q1(k − 1, j, x). In summary, we receive
Q1(0, j, x) ⇔ true	and
Q1(k + 1, j, x) ⇔ Q¯(h(Q1(k, j, x)), j, x).
Since Q¯ is arithmetic, so Q1 is as recursive predicates are closed under primitve recursion. The statement for Q2 is completely analogous.	✷
We now define a limit operator S = limi∈N fi(loop) with help of the predicates
Q1 and Q2:
wlp(S)(ϕ(x)) ⇔ ∀i.Q1(i, h(ϕ(x)), x)	and
wp(S)(ϕ(x)) ⇔ ∃i.Q2(i, h(ϕ(x)), x)	.
Lemma 3.3 The limit S = limi∈N fi(loop) is well-deﬁned.
Proof. (sketch) By definition, it is obvious that
wlp(S)(ϕ(x))	⇔	∀i.i ∈ N ⇒ wlp(fi(loop))(ϕ(x))	(1)
holds. From this we derive the universal conjunctivity property by direct calculation. Furthermore, the wp-part of the limes definition gives
wp(S)(ϕ(x))	⇔	∃i.i ∈ N ∧ wp(fi(loop))(ϕ(x))	.	(2)
Under the assumption that wp(S)(ϕ) holds we use equivalence (2), the pairing conditions of the fi(loop)’s and the fact that {fi(loop) | i ∈ N} is indeed a chain with respect to the Nelson-order in order to verify that wlp(S)(ϕ) ∧ wp(S)(true) holds. For the reverse direction one can use the pairing condition of some fi0 (loop) and both equivalences (1) and (2).   ✷
Least Fixpoints
Now, we are going to show how to obtain the semantics for WHILE-loops. It is easy to see that the function f on guarded commands is monotonic in the Nelson order [4]. Then an immediate consequence of the last lemma is the existence of a least upper bound, which is just given by the limit operator. To see this one only has to apply equations (1) and (2) as well as the idea of a least upper bound.
Lemma 3.4 The chain {fi(loop) | i ∈ N} has a least upper bound, namely
limi∈N fi(loop).	✷
In the following we use the notation µTj.f (Tj) to denote the least fixpoint of
f provided it exists.
Proposition 3.5 Let f (Tj) = P → S; Tj✷¬P → skip. Then f has a least ﬁxpoint with respect to ≤, which is µTj.f (Tj) = limi∈N fi(loop).

Proof. (sketch) According to Lemma 3.4, {fi(loop) | i ∈ N} has the least upper bound S = lim fi(loop). Then we can make use of the universal con-
i∈N
junctivity property and apply equation (2) and the fact that S ≤ f (S) holds
to derive that w(l)p(f (S))(ϕ) ⇔ w(l)p(S)(ϕ) are valid. Hence, S is indeed a fixpoint and each further fixpoint T is an upper bound for {fi(loop) | i ∈ N}, which gives S ≤ T .	✷

Greatest Consistent Specializations
Now the foundations are laid to develop the theory of consistency enforce- ment on top of first-order arithmetic logic. This will then form the basis for investigations concerning computability and decidability.

Consistency and Specialization
First we have to define consistency and the specialization preorder. This can be done in complete analogy to the classical case in [6].
Definition 4.1 Let I be an invariant on the state space X. Let S and T be commands on the state spaces Z and Y , respectively, with Z ⊆ Y ⊆ X.
S is consistent with respect to I iff I ⇒ wlp(S)(I) holds.
T specializes S (notation: T ± S) iff w(l)p(S)(ϕ) ⇒ w(l)p(T )(ϕ) holds for all Z-formulae ϕ.	✷
Due to the pairing condition it is sufficient to consider only ϕ = true for the wp-part in the specialization definition. The wlp-part can also be simplified in the known way.
Next we introduce the central notion for consistency enforcement, the GCS.
Definition 4.2 Let S be a Y -command and I an invariant on X with Y ⊆ X. The greatest consistent specialization (GCS) of S with respect to I is an X- command SI with SI ± S, such that SI is consistent with respect to I and each consistent specialization T ± S satisfies T ± SI.	✷
First we show the existence of GCSs and their uniqueness up to semantic equivalence. Furthermore, GCSs with respect to conjunctions can be built successively and independently from the order of the given invariants. In both cases, the classical proofs from [8,6] carry over without significant changes. Nevertheless, we will give the proofs in Appendix A.
Proposition 4.3 The GCS SI of S with respect to I always exists and is unique up to semantic equivalence. We can always write
SI = (I → S; @z' • z := z'; I → skip) ☒ (¬I → S; @z' • z := z') ,
where z refers to the free variables in I not occurring in S.

Furthermore, for two invariants I and J we always obtain that I∧ J →
SI∧J and I∧ J → (SI)J are semantically equivalent.	✷
From the form of the GCS Proposition 4.3 we may derive wp(SI)(true) ⇔
wp(S)(true), which allows to concentrate on the predicate transformer wlp(S).

An Upper Bound for GCSs
For practical applications the form of the GCS derived in Proposition 4.3 is almost worth nothing, since it involves testing the invariant after non- deterministic selection of arbitrary values. However, the form is useful in proofs.
A suitable form of the GCS should be built from GCSs of the basic com- mands involved in S. Let the result of such a naive syntactic replacement

be denoted by S' . In general, however, S'
is not the GCS. It may not even

I	I
be a specialization of S, or it may be a consistent specialization, but not the
greatest one. An example for the latter case is S = x := x−a; x := x + a with some constant a ≥ 0 and I ≡ x ≥ 0.
We now formulate a technical condition which allows to exclude this sit-

uation. Under this condition it will be possible to show that SI ± S'
holds.

The corresponding result will be called the upper bound theorem.
We need the notion of a deterministic branch S+ of a command S, which re- quires S+ ± S and wp(S)∗(true) ⇔ wp(S+)∗(true) as well as wlp(S+)∗(ϕ) ⇒ wp(S+)(ϕ) to hold for all ϕ.
Furthermore, we need the notion of a δ-constraint for an X-command S. This is an invariant J on X ∪ X' with a disjoint copy X' of X, for which
{x'/x}.wlp(S')(J ) holds, where S' results from S by renaming all xi to x'.
Finally, we write Pσ for the characterizing formula of state σ.
Definition 4.4 Let S = S1; S2 be an Y -command such that Si is a Yi- command for Yi ⊆ Y (i = 1, 2). Let I be some X-invariant with Y ⊆ X. Let X − Y1 = {y1,..., ym}, Y1 = {x1,..., xl} and assume that {x' ,..., x'}
1	l
is a disjoint copy of Y1 disjoint also from X. Then S is in δ-I-reduced form
iff for each deterministic branch S+ of S1 the following two conditions—with
x = (x ,...,x ), x0 = (x' ,..., x')—hold:
1	l	1	l
For all states σ with |=σ ¬I we have, if Pσ ⇒ {x/x'}.(∀y1 ... ym.I) is a 
δ-constraint for S+, then it is also a δ-constraint for S+ ; S2.
1	1
For all states σ with |=σ I we have, if Pσ ⇒ {x/x'}.(∀y1 ... ym.¬I) is a 
δ-constraint for S+, then it is also a δ-constraint for S+ ; S2.	✷
1	1
We have to extend this definition to arbitrary commands other than sequences.
Definition 4.5 Let S be an X-command and I some Y -invariant with X ⊆
Y . S is called I-reduced iff the following holds:
If S is one of fail, skip, loop or an assignment, then S is always I-reduced.
If S = S1; S2, then S is I-reduced iff S1 and S2 are I-reduced and S is


δ-I-reduced.
If S is one of P → T , @ y :: #y • T , S1✷S2 or S1 ☒ S2, then S is I-reduced iff S1 and S2 or T respectively are I-reduced.
If S = µT.f (T ), then S is I-reduced iff fn(loop) is I-reduced for each
n ∈ N.	✷
With these technical preliminaries we may now state and prove the upper bound theorem. Notice, that a simple replacement of some S1 ☒ S2 by (S1)I ☒ (S2)I within a recursive operation would destroy the required result.
Theorem 4.6 Let I be an invariant on X and let S be some I-reduced

Y -command with Y ⊆ X. Let S'
result from S as follows:

Each restricted choice S1 ☒ S2 occurring within S will be replaced by S1✷ wlp(S1)(false) → S2.
Then each basic command will be replaced by their GCSs with respect to I.

Then T ± S'
holds for each consistent specialization T ± S with respect to I.

Proof. (sketch) The proof is done by (lengthy) structural induction on S. There are no great ideas hidden behind the cases for preconditioning, choice, restricted choice and unbounded choice, but the proofs require a huge technical effort, nevertheless. Therefore, we refer to the classical proofs [6, p.120-122] which only have to be changed slightly.
For sequences we can also keep the classical proof [6, App.C] with minor changes. The most important idea is to exploit the normal form of the GCS from Proposition 4.3 for S = S1; S2 to compute both wlp(SI)(x = a) and
wlp((S1)I ; (S2)I )(x = a). Then we distinguish the two cases x = a ⇒ ¬I and
x = a ⇒ I. We may assume without loss of generality that S1 is deterministic
such that we are able to use an advanced technical characterization of δ-I- reduceness.
In the first case we assume that the required implication for specialization is violated in at least one state x '→ b. From this we obtain a δ-constraint for S1 and by δ-I-reducedness a δ-constraint for S in the form x = b ⇒ {x/x'}.I. This leads to a contradiction. The second case is quite similar.
For recursive guarded commands—restricted to WHILE-loops, for which we know the existence of least fixpoints—we shift the proof to Appendix B.✷


The general form of a GCS
Theorem 4.6 has a flavour of compositionality, but it does not yet give the

GCS. The idea of the main theorem on GCSs is to cut out from S'
those

executions that are not allowed to occur in a specialization of S. This leads to the following theorem. The proof is shifted to Appendix C.

Theorem 4.7 Let I, S and S'
be as in Theorem 4.6. Let Z be a disjoint

copy of the state space Y . With the formulae
P(S, I, x') ≡ {z/y}.wlp(S''; z = x' → skip)(wlp(S)∗(z = y))	,
where S'' results from S' by renaming the Y to Z, the GCS SI is semantically

I
equivalent to
I


@x' • P(S, I, x') → S' ; y = x' → skip	.✷

Note that if we consider deterministic branches as a pragmatic approach sug- gested in [6], then the unbounded choice in Theorem 4.7 disappears. We omit further details.
The charaterization of GCSs according to Theorem 4.7 makes it formally possible to reduce consistency enforcement to a simple syntactical replacement (the forming of S' ) and to an investigation of a guard, namely P (S, I, x'). The following results from section 5 will heavily depend on this reduction and will support the theorys practical relevance.

Computability and Decidability
We have now reached the stage, where we can say that the GCS approach could have been succesfully developed with respect to arithmetic logic. Thus, we can turn to the original intention of this paper: computability and decidability issues.
Taking the general form of the GCS in Theorem 4.7 we may now ask, whether we can find an algorithm to compute the GCS. We may further ask, whether the result is effective. The answer to both questions is negative in general, but we will identify subcases, for which effective GCSs can be computed.
The Computability of GCSs
First consider the computability problem. Taking our Go¨del numberings h for terms and formulae and g for commands, we have already exploited their inversibility. From this we obtain the following immediate consequence.
Lemma 5.1 For each n ∈ N it is decidable, whether n is the G¨odel number of a term, a formula or a guarded command.	✷

Next we consider the upper bound S'
that occurs in the GCS. Since this is

only a syntactic transformation, we may now conclude that (S, I) '→ S' is
computable. Hence it is sufficient to investigate the computability for the precondition P(S, I, x') for arbitrary x'.
These conditions involve the predicate transformers wlp(S) and wlp(S' ). According to our definition of axiomatic semantics for commands, we know that building these predicate transformers is simple done by syntactic replace- ment operations. By exploiting our Go¨del numbering h again, we conclude


that for recursion-free S the mapping

(S, I, x') '→ P(S, I, x')

—and hence (S, I) '→ SI, too—is computable.

However, if S involves a loop, then S'
also involves a loop. In order to

determine wlp(S) and wlp(S' ) we have to use the limit operator. For a loop µTj.f (Tj) this means to build wlp(fi(loop)) for all i ∈ N. This is only possible, if there is some n ∈ N such that wlp(fn(loop)) = wlp(fm(loop)) holds for all m ≥ n, m ∈ N. This means that we have a bounded loop (or equivalently a FOR-loop).
Proposition 5.2 If recursive guarded commands are restricted to bounded loops, then GCSs are computable, i.e., the function (S, I) '→ SI is computable. In general, howver, the GCS cannot be computed.	✷

An Undecidability Result
Even, if the GCS SI can be computed from the given command S and the invariant I, the result still contains the preconditions P(S, I, x'). If such a precondition is undecidable, then the GCS will not be effective. In the proof of the next proposition we exploit the arithmetic hierarchy [1, Ch.8].
Proposition 5.3 In general, the preconditions P(S, I, x') involved in the general form of a GCS SI are not decidable.
Proof. (sketch) As a simple counterexample we take
S ≡ x1 := t1; R(x1, x2) → @y • Q(x1, x2, y) → x2 := t2
` ˛S¸1	x	` ˛S¸2	x
with an underlying state space X = {x1, x2} and consider a decidable I such that S is I-reduced. Then we use Proposition 4.3 in order to compute the GCS SI. After a complex calculation and some simplifying steps we receive
P(S, I, (u1, u2))	⇔
∀z' .∀y'.∃y.(({x1/t1, x2, z' }.(I∧ R ∧ Q) ∧ {x1/u1, x2/u2}.I)∨
2	2
(¬I ∧ {x1/t1, x2/z' }.(¬I ∧ R ∧ {y/y'}.Q))) ⇒ ({x1/u1}.(R ∧ Q) ∧ u2 = t2)  .
This result is a formula in Π0 (provided R and Q are recursive).	✷
It is easy to see that undecidability results from the unbounded choice oper- ator used in the counterexample. This produced the universal quantifier for the predicate transformer wlp(S'') and the existential quantifier for the dual predicate transformer wlp(S)∗. Consequently we had to climb up two levels in the arithmetic hierarchy.
However, all classes Σ0, Π0 and ∆0 in the arithmetic hierarchy are closed
i	i	i
under bounded quantification. So, if we restrict unbounded choice to bounded

selection, i.e., @y • P(y) → S with finite {y ||= P(y)}, then we achieve decidability.
Proposition 5.4 If S is a command, in which unbounded choice only occurs in the form of bounded selection, then for I ∈ Σ0 the preconditions P(S, I, x') involved in the general form of a GCS SI are decidable.	✷

Conclusion
In this article we considered the GCS approach to consistency enforcement presented in [6]. We could show that the underlying theory of predicate trans- formers could be carried over from an infinitary logic to first-order arithmetic logic. We were even able to do this for recursive program specifications by ex- ploiting G¨odel numberings for terms, formulae and guarded commands. How- ever, the used recursive program specifications are slightly restricted with respect to the more general classical theory in [4].
Then we could show that the existence and uniqueness of GCSs, the com- mutativity result from [8] and the fundamental compositionality result carry over to the new logic. This allows to study computability and decidability issues. We could show that both properties do not hold in general, but for reasonable subclasses of program specifications.
There are at least three more problems we would like to approach next. Firstly, we would like to study the Goldfarb classification [2] and its impact to GCS construction. Secondly, we would like to look at weakened approaches to consistency enforcement, e.g., the one presented in [5] and to discuss com- putability and decidability for this approach as well. Thirdly and finally, we would like to address the problems of GCSs—and weakened approaches—with respect to basic commands. In particular, it would be nice to see how GCSs for various classes of relational constraints (see [9]) would look like.

Acknowledgement
The authors would like to thank Cris Calude and Rod Downey for helping to correct a proof in an earlier version of the paper.

References
J. Bell, M. Machover. A Course in Mathematical Logic. North-Holland 1977.
E. B¨orger, E. Gr¨adel, Y. Gurevich. The Classical Decision Problem. Springer 1997.
S. Link. Eine Theorie der Konsistenzerzwingung auf der Basis arithmetischer Logik . M.Sc. Thesis (in German). TU Clausthal 2000.


G. Nelson. A Generalization of Dijkstra’s Calculus. ACM TOPLAS . vol. 11 (4): 517-561. 1989.

K.-D. Schewe. Fundamentals of Consistency Enforcement. In H. Jaakkola, H. Kangassalo, E. Kawaguchi (eds.). Information Modelling and Knowledge Bases X: 275-291. IOS Press 1999.

K.-D. Schewe, B. Thalheim. Towards a Theory of Consistency Enforcement.
Acta Informatica. vol. 36: 97-141. 1999.

K.-D. Schewe, B. Thalheim. Limitations of Rule Triggering Systems for Integrity Maintenance in the Context of Transition Specifications. Acta Cybernetica. vol. 13: 277-304. 1998.

K.-D. Schewe, B. Thalheim, J. Schmidt, I. Wetzel. Integrity Enforcement in Object Oriented Databases. In U. Lipeck, B. Thalheim (eds.). Modelling Database Dynamics: 174-195. Workshops in Computing. Springer 1993.

B. Thalheim. Dependencies in Relational Databases. Teubner 1991.


Existence, normal form representation and commu- tativity of GCSs
In the appendix we give a detailed proof of Proposition 4.3.
Proposition 4.3 The GCS SI of S with respect to I always exists and is unique up to semantic equivalence. We can always write

SI = (I → S; @z' • z := z'; I → skip) ☒ (¬I → S; @z' • z := z') ,

where z refers to the free variables in I not occurring in S.
Furthermore, for two invariants I and J we always obtain that I∧ J →
SI∧J and I∧ J → (SI)J are semantically equivalent.
Proof. First we show the existence and uniqueness up to semantic equiva- lence of GCS. We set

T = {T | T ± S and T ist consistent with respect to I}	.

If the least upper bound SI of T with respect to the specialization ± exists, then this must be the GCS. Therefore, we have the uniqueness up to semantic equivalence.
We now verify the conditions from Definition 4.2 for the program specification


SI above. Let ϕ be an arbitrary state formula on Y . Then we receive

wlp(SI)∗(ϕ)  ⇔  (I∧ wlp(S)∗(∃z'.{z/z'}.(I∧ ϕ)))∨
(¬I ∧ wlp(S)∗(∃z'.{z/z'}.ϕ))
⇔ (I∧ wlp(S)∗((∃z'.{z/z'}.I) ∧ ϕ)) ∨ (¬I ∧ wlp(S)∗(ϕ))
⇒ (I∧ wlp(S)∗(ϕ)) ∨ (¬I ∧ wlp(S)∗(ϕ))
⇔  wlp(S)∗(ϕ)	.
Doing this we have made use of the dual predicate transformers’ monotonicity property and the fact that variables zi do not occur within ϕ. Then the asserted specialization SI ± S follows from the same computation for wp instead of wlp.
Next we consider

wlp(SI)(I)	⇔	(I ⇒ wlp(S)(∀z'.{z/z'}.(I ⇒ I)))∧
(¬I ⇒ wlp(S)(∀z'.{z/z'}.I))
⇔	(¬I ⇒ wlp(S)(∀z'.{z/z'}.I))	.
Due to ¬wlp(SI)(I) ⇔ ¬I ∧ ¬wlp(S)(∀z'.{z/z'}.I) we obtain I ⇒ wlp(SI)(I) which means that the above SI is indeed consistent with respect to I.
Let x = y be a characterizing state formula and T ± S an arbitrary, but
I-consistent specialization of S. Then we ditinguish two cases.
Case 1. We assume x = y ⇒ ¬I and therefore, we conclude wlp(T )∗(x = y) ⇒ wlp(T )∗(¬I) ⇒ ¬I using the monotonicity of wlp(S)∗ and consistency of T . Moreover, it follows

wlp(T )∗(x = y)	⇒	¬I ∧ wlp(S)∗(x = y)
⇒	¬I ∧ wlp(S)∗(∃z'.{z/z'}.x = y)
⇒	wlp(SI)∗(x = y)	.
For the first implication we simply use the specialization T ± S, for the second we refer to the monotonicity applied to x = y ⇒ ∃z'.{z/z'}.x = y and the last one follows from the first line of the computation of wlp(SI)∗
Case 2. Now we start out from x = y ⇒I and we derive wlp(T )∗(x = y) ⇔ wlp(T )∗(I ∧ x = y), consequentely. With T ± S and the monotonicity of wlp(S)∗ we conclude
wlp(S)∗(∃z'.{z/z'}.(I∧ x = y)) ∧ wlp(S)∗(∃z'.{z/z'}.(x = y)) .  (∗) Obviously, we have (wlp(T )∗(x = y) ∧ I) ∨ (wlp(T )∗(x = y) ⇒ ¬I) and


together with (∗) we receive

This first step has brought us to wlp(T )∗(x = y) ⇒ wlp(SI)∗(x = y), i.e., wlp(SI)(x /= y) ⇒ wlp(T )(x /= y). For arbitrary state formula ϕ we have ϕ(x) e 6y.чϕ(y) ⇒ x /= y and therefore

using the universal conjunctivity property of wlp. We obtain wlp(T )∗(ϕ) ⇒ wlp(SI)∗(ϕ) for all ϕ and on top of that wp(T )∗(false) ⇒ wp(S)∗(false) ⇒ wp(SI)∗(false) holds as well, due to the specialization T ± S and the first line of the computation of wlp(SI)∗ above. Indeed, we have proved that T is a specialization of SI.
Let us now consider the asserted commutativity result. Since (SI1 )I2 is f2- consistent of definition we have
f2 ⇒ wlp((SI1 )I2 )(f2)  .
On the other side we can use the definition of GCS and consistency as well as (SI1 )I2 ± SI1 in order to receive
f1 ⇒ wlp(SI1 )(f1) ⇒ wlp((SI1 )I2 )(f1)  .
In summary, this results in
f1 л f2 ⇒ wlp((SI1 )I2 )(f1) л wlp((SI1 )I2 )(f2) e wlp((SI1 )I2 )(f1 л f2)	,
so we have proved the consistency of (SI1 )I2 with respect to f1 л f2. From
SI1 ± S and (SI1 )I2 ± SI1 we derive
wlp(S)(ϕ) ⇒ wlp(SI1 )(ϕ) ⇒ wlp((SI1 )I2 )(ϕ)	,
i.e., the specialization (SI1 )I2 ± S. Consequentely, this together with defini- tion 4.2 yields (SI1 )I2 ± SI1∧I2 and we obtain



for arbitrary ϕ which means (f1 л f2 → (SI1 )I2 ) ± (f1 л f2 → SI1∧I2 ). Thus, it remains to show the reverse specialization.
From SI1∧I2 ± S follows
(f1 л f2 → SI1∧I2 ) ± S	.	(A.1)
In addition, SI1∧I2 is consistent with respect to f1 л f2 of definition, so we have not only f1 л f2 ⇒ wlp(SI1∧I2 )(f1) but also f1 л f2 ⇒ wlp(SI1∧I2 )(f2).
Next we consider
(f1 ⇒ wlp(f1 л f2 → SI1∧I2 )(f1)) e (f1 л f2 ⇒ wlp(SI1∧I2 )(f1))	(A.2) and
(f2 ⇒ wlp(f1 л f2 → SI1∧I2 )(f2)) e (f1 л f2 ⇒ wlp(SI1∧I2 )(f2))	.  (A.3)
From equation (A.2) we obtain the consistency of f1лf2 → SI1∧I2 with respect to f1 and using equation (A.1) yields
(f1 л f2 → SI1∧I2 ) ± SI1	.	(A.4)
From equation (A.3) follows the consistency of f1 л f2 → SI1∧I2 with respect to f2 and using equation (A.4) we conclude
(f1 л f2 → SI1∧I2 ) ± (SI1 )I2	.	(A.5)
Finally, we compute


w(l)p(f1 л f2 → (SI1 )I2 )(ϕ) e f1 л f2 ⇒ w(l)p((SI1 )I2 )(ϕ)
⇒ f1 л f2 ⇒ w(l)p(f1 л f2 → SI1∧I2 )(ϕ) e f1 л f2 ⇒ (f1 л f2 ⇒ w(l)p(SI1∧I2 )(ϕ)) e f1 л f2 ⇒ w(l)p(SI1∧I2 )(ϕ)
e w(l)p(f1 л f2 → SI1∧I2 )(ϕ)
the specialization f1 л f2 → SI1∧I2 ± f1 л f2 → (SI1 )I2 , where we just make use of equation (A.5) in the appearing implication. This completes the proof.✷

Proof of the upper bound theorem in the recursive case
In this appendix we prove the upper bound theorem for recursive operations restricted to simple WHILE-loops in the form of f (S) = P → T ; S✷чP →


skip for which we know the existence of least fixpoints according to subsection
3.2. For this we need some additional lemmata.
For recursive guarded commands the monotonicity of all operation con- structors with respect to the Nelson-order ≤ is fundamental [4]. Unfortu- nately, a similiar result does not hold for the specialization order ±. More precisely, the result is false for the ☒-constructor in its first component.
Lemma B.1 Let f (S) be a guarded-command expression with the program variable S in which restricted choice ☒ does not occur. Then f is monotonic with respect to the specialization order ±.
Proof. (sketch) The proof is done by structural induction. For each con- structor it is completely analogous to the corresponding proof for the Nelson- order in [4]. We omit the details.	✷

In [6, Proposition 20, p.120] we have seen that S'
may contain the choice-

constructor instead of restricted choice, provided we include some guard. Re- placing within a recursive operation some S1 ☒ S2 by (S1)I ☒ (S2)I would destroy the required result.
The next lemma follows from taking together the cases in the upper bound theorem for preconditionings →, choices ✷, unbounded choices @ and re- stricted choices ☒.
Lemma B.2 Let T be a consistent specialization of some f-reduced f (S') with respect to f, where f (S) is an expression built from the constructors of guarded commands. Construct fI(S) from f (S) as follows:
Each restricted choice S1 ☒ S2 occuring within f (S) will be replaced by
S1✷wlp(S1)(false) → S2.
Then each basic operation, i.e., skip and assignments will be replaced by their GCSs with respect to f.
Then we have T ± fI(S' ).	✷
As in the classical we must now face the main difficulty to bring together two different partial orders, namely the specialization order ± which is fundamen- tal for GCSs and the Nelson-order ≤ required for recursion.
Lemma B.3 Let T und S be Y -operations and {fi(loop) | i ∈ N} the chain of Y -operations with respect to the Nelson-order. Furthermore, let f be an invariant on X for Y ⊆ X. Then we have:
If T ≤ S holds, then TI ≤ SI follows.
(limi∈N fi(loop))I ± limi∈N(fi(loop))I.
Proof. (i) Here we use the normal form of a GCS given in Proposition 4.3. The first result follows immediately, because all constructors are monotonic in the Nelson-order ≤.
(ii) First, limi∈N fi(loop) is the least upper bound of {fi(loop) | i ∈ N}
with respect to the Nelson-order according to Lemma 3.4, i.e., especially


fi(loop) ≤ limi∈N fi(loop) holds for arbitrary i ∈ N. From this and (i) we get (fi(loop))I ≤ (limi∈N fi(loop))I . Using Lemma 3.4 again, limi∈N(fi(loop))I is obviously the least upper bound of the chain {(fi(loop))I | i ∈ N} which means that limi∈N(fi(loop))I ≤ (limi∈N fi(loop))I must hold. Therefore, we receive
wp  lim(fi(loop))I  (ϕ) ⇒ wp   lim fi(loop)   (ϕ)

i∈N
i∈N	I

according to the definition of the Nelson-order.
Once again we make use of Proposition 4.3 in order to compute

wlp	lim(fi(loop))I	(ϕ) e
i∈N
6i.i ∈ N ⇒ wlp (fi(loop))I (ϕ) e 6i.i ∈ N ⇒ wlp((f → fi(loop); @z' • z := z'; f → skip)☒
(чf → fi(loop); @z' • z := z'))(ϕ) e 6i.i ∈ N ⇒ ((f ⇒ wlp(fi(loop))(6z'.{z/z'}.f ⇒ ϕ))л
(чf ⇒ wlp(fi(loop))(6z'.{z/z'}.ϕ))) e
(f ⇒ 6i.i ∈ N ⇒ wlp(fi(loop))(6z'.{z/z'}.f ⇒ ϕ))л
(чf ⇒ 6i.i ∈ N ⇒ wlp(fi(loop))(6z'.{z/z'}.ϕ)) e
(f ⇒ wlp	lim fi(loop)	(6z'.{z/z'}.f ⇒ ϕ))л
i∈N

(чf ⇒ wlp	lim fi(loop)	(6z'.{z/z'}.ϕ)) e
i∈N
wlp((f → lim fi(loop); @z' • z := z'; f → skip)☒
i∈N
(чf → lim fi(loop); @z' • z := z'))(ϕ) e
i∈N


wlp	lim fi(loop)
i∈N

(ϕ)	,
I



i.e.,


wlp  lim(fi(loop))I  (ϕ) ⇒ wlp   lim fi(loop) 

  (ϕ)	,

i∈N
i∈N	I

supplies the asserted specialization.	✷
We are now able to give the main proof.
Proposition B.4 Let S' = µTj.f (Tj) with f (Tj) = P → T ; Tj✷чP → skip be an f-reduced Y -operation and T ± S' a consistent specialization with respect to some X-invariant f with Y ⊆ X. Then we have T ± µTj.fI(Tj), where fI(Tj) is built as in Lemma B.2.
Proof. Since S' is a fixpoint we have S' = f (S'). T is an f-reduced consistent


specialization of S' by assumption, so the specialization

T ± fI(S' ) = fI   lim fi(loop)	.
I	i∈N
I
follows by Lemma B.2. Due to the monotonicity of fI and because of Lemma
B.3 (ii) we derive further
   ¸	Tx1`i	˛

fI	lim fi(loop)
i∈N	I
± fI	lim fi(loop) 
`	˛T¸1
I 	.

We set T2i = fi (loop) and show T1i ± T2i for all i ∈ N by induction. The case i = 0 gives T10 = loopI = loop = T20. In the case i > 0 we can assume T1j ± T2j for all j < i. T1i is an f-consistent specialization of fi(loop) = f (fi−1(loop)), hence we conclude

T1i ± fI  fi−1(loop) 

 = fI T1(i−1) .

by Lemma B.2. Now, we apply the induction hypothesis and the monotonicity of fI in order to obtain fI T1(i−1) ± fI T2(i−1) = T2i, i.e., together T1i ± T2i as asserted.
For T2 = limi∈N fi (loop) follows

wlp(T2)(ϕ)	e	(6i.i ∈ N ⇒ wlp(T2i)(ϕ))
⇒	(6i.i ∈ N ⇒ wlp(T1i)(ϕ))
e	wlp(T1)(ϕ)
and

wp(T2)(ϕ)	e	(Ei.i ∈ N л wp(T2i)(ϕ))
⇒	(Ei.i ∈ N л wp(T1i)(ϕ))
e	wp(T1)(ϕ)	,
thus the specialization T1 ± T2. Finally, we receive by applying Lemma B.1
T ± fI(T1) ± fI(T2) = T2 = µTj.fI(Tj)	,
where we use the fact that T2 is a fixpoint.	✷

A detailed proof of the compositionality result
We still need an additional proposition which gives a normal form for special- ization. The proof is completely the same as in the classical case [6, App.B] and omitted, therefore.


Proposition C.1 Let S and T be commands on the state spaces Z and Y , respectively, with Z ⊆ Y . Then wlp(S)(ϕ) ⇒ wlp(T )(ϕ) holds for all Z- formulae iff
{z'/z}.wlp(T')(wlp(S)∗(z = z'))
holds, where z' is a disjoint copy of z and T ' results from T by renaming each
zi into z'.	✷
Now we can show the main result with respect to the GCS-construction.

Theorem 4.7 Let f, S and S'
be as in Theorem 4.6. Let Z be a disjoint copy

of the state space Y . With the formulae
P(S, f, x') ≡ {z/y}.wlp(S''; z = x' → skip)(wlp(S)∗(z = y))	,
where S'' results from S' by renaming the Y to Z, the GCS SI is semantically

I
equivalent to
I

@x' • P(S, f, x') → S' ; y = x' → skip	.

Proof. We take the form claimed in the theorem as a definition and verify the conditions in the definition of the GCS. First let ϕ be an arbitrary Y -formula.
For this we get by assistance of Proposition C.1

wlp(SI)∗(ϕ) e (Ex'.P(S, f, x') л wlp(S' )∗(y = x' л ϕ)) ⇒ wlp(S)∗(ϕ)	,

which gives the specialization condition SI ± S. The wp-part follows analo- gously.

Consistency can be verified easily, since S'
is already consistent with respect

to f, namely

f	⇒	wlp(S' )(f)
⇒	wlp(S' )(y = x' ⇒ wlp(skip)(f))
e	wlp(S' )(wlp(y = x' → skip)(f))
e	wlp(S' ; y = x' → skip)(f)
⇒	6x'.P (S, f, x') ⇒ wlp(S' ; y = x' → skip)(f)
e	wlp(@x' • P (S, f, x') → S' ; y = x')(f)
e	wlp(SI)(f)	.
Therefore, we have the consistency of SI with respect to f. Note, that the second implication in the computation above holds due to the monotonicity of wlp(S' ) applied to f ⇒ (y = x' ⇒ f).
Finally, let T be an arbitrary consistent specialization of S. We assume with- out loss of generality that wp(T )(true) e true holds. From Theorem 4.6 we


already get T ± S' . From this we compute

w(l)p(S' ; y = x' → skip)(ϕ) e w(l)p(S' )(w(l)p(y = x' → skip)(ϕ))

I		
x'
I
I


⇒ w(l)p(T )(w(l)p(y = x' → skip)(ϕ))
e w(l)p(T ; y = x' → skip)(ϕ)	,
`	T˛x¸'	x

i.e., T x' ± Sx' . At this point it suffices to show wp(T x' )∗(true) ⇒ P (S, f, x'),
because


w(l)p(P (S, f, x') → Sx' )(ϕ) e P (S, f, x') ⇒ w(l)p(Sx' )(ϕ)
I	I
⇒ wp(T x' )∗(true) ⇒ w(l)p(Sx' )(ϕ)
⇒ wp(T x' )∗(true) ⇒ w(l)p(T x' )(ϕ)
e w(l)p(wp(T x' )∗(true) → T x' )(ϕ)
`	⇔˛T¸x'	x
implies immediately T x' ± P (S, f, x') → Sx' and we obtain 6x' • T x' ±
6x' • P (S, f, x') → Sx' , consequently. The formula on the left-hand side is equivalent to T , whereas the one on the right-hand side is equivalent to SI.
Assume there is a state a, in which У(S, f, x') does not hold. From Proposi- tion C.1 we get the existence of a state b with


|=a
ч (wlp(S)(y /= b) ⇒ wlp(S' ; y = x' → skip)(y /= b))	,

which is equivalent to


|=a
wlp(S)(y /= b) л чwlp(S' )(y = x' ⇒ y /= b)

and this, finally, to


|=a
wlp(S)(y /= b) л wlp(S' )∗(y = x' л y = b)	.


Hence x' = b must hold by definition of characterizing state formulae. On the other hand we receive |=a wlp(T )(y /= b) due to T ± S and together with




we conclude |=a
wlp(T x' )(false). The pairing condition wp(T x' )(false) e

wlp(T x' )(false) л wp(T x' )(true) and
wp(T x' )(true) e wp(T )(y = x' ⇒ true) e wp(T )(true) e true
give |=a wp(T x' )(false), which is equivalent to |=a чwp(T x' )∗(true).	✷
