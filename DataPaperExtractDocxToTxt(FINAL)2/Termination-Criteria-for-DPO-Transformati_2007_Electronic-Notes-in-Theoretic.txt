	Electronic Notes in Theoretical Computer Science 175 (2007) 87–100	
www.elsevier.com/locate/entcs

Termination Criteria for DPO Transformations with Injective Matches
Tiham´er Levendovszky1
Department of Automation and Applied Informatics Budapest University of Technology and Economics Hungary
Ulrike Prange2 Hartmut Ehrig2
Department of Software Engineering and Theoretical Computer Science Technical University of Berlin
Germany

Abstract
Reasoning about graph and model transformation systems is an important means to underpin model-driven software engineering, such as Model-Driven Architecture (MDA) and Model Integrated Computing (MIC). Termination criteria for graph and model transformation systems have become a focused area recently. This paper provides termination criteria for graph and model transformation systems with injective matches and finite input structure. It proposes a treatment for infinite sequences of rule applications, and takes attribute conditions, negative application conditions, and type constraints into account. The results are illustrated on case studies excerpted from real-world transformations, which show the termination properties of the frequently used ”transitive closure” and ”leaf collector” transformation idioms. An intuitive comparison with other approaches is also given.
Keywords: Termination Criteria, Graph Transformation, Model Transformation, DPO Approach


Introduction
Statements about termination of graph and model transformation systems have been proven recently, and a few transformation tools already support checking ter- mination criteria [12]. This issue has mainly arisen for the following reason. When graph transformation is used for model transformation, the objective is to create an output mode either from the ground up or modifying existing models. If an output model must be achieved, a transformation must provide it within a finite number of

1 Email: tihamer@aut.bme.hu
2 Email: {uprange,ehrig}@cs.tu-berlin.de

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.04.019

steps. Therefore, examining the termination properties of the transformation can help to find an error in the model transformation. Taking into account that one of the most important applications of graph transformation is model transformation, well-developed termination criteria can be useful support for this application area. When transforming a model, one or more input graph, a set of rules and con- straints are available along with a control structure. The nontermination can be caused by the (i) input graph or (ii) the executed sequence of the rules. In the first case several examples can be constructed that illustrate nontermination. Assume a transformation rule takes an attribute of a node, and decrements it each time when the rule is fired. The rule has a constraint that it cannot be applied for zero attribute value. When infinity is allowed as the initial value of the attribute, this rule can be applied forever. A more obvious example is an input graph with infinite size. However, in practical model transformation applications, the input model is stored on a computer or on a distributed computer system. Therefore, assuming
finite input graphs does not restrict the practical scope of the results.
The nontermination caused by a sequence of finite rules is more interesting for model transformation and its tool support. In this case the transformation either becomes stagnant or starts consuming the available system resources. An example for the stagnation case would be a transformation consisting of two rules executed in a loop after each other. The first rule creates an element, the second one deletes it. The transformation does not consume all the available system resources, but never stops. In our experience, the most prevalent reason is that the designer must have forgotten a constraint from the rules, and it is really useful to warn him of this fact. When a transformation needs a growing amount of system resources, the underlying reason can be twofold. (i) This transformation needs a stronger execution environment, or (ii) the transformation is nonterminating in nature, thus, there is no execution environment strong enough to perform this transformation. For instance, if a rule creates a node and can be executed exhaustively, it never stops creating nodes. Termination analysis can be a basis to prove that a stronger computational environment is needed, or the transformation suffers from an unintended side effect. We use the formal framework of Adhesive High-Level Replacement (AHLR) Systems [6] applied to typed attributed graphs. We assume finite input structures and rules. Since this problem is algorithmically undecidable, we prove termination properties which can be used to examine the termination properties of the individual
transformations analytically.
The main line of thought in this paper is as follows. The sequential rule appli- cations are substituted with the composition of the rules. If one can show for the infinite rule sequences that the left-hand side of their composition tends to infinity, then the rule sequence terminates, since only finitely many elements are available in the start graph. This does not necessarily hold if one element in the rule can be matched to multiple elements in the host graph. Therefore, injective matches are assumed.

Backgrounds
Since we use the formalism and the results of the AHLR approach, we summarize the necessary definitions and results, based on [6]. In these definitions, we always mean typed, attributed graphs by mentioning graphs, which are defined as follows.
Definition 2.1 An E-graph EG = (VG, VD, EG, ENA, EEA, (srcj, tarj)j∈{G,NA, EA}) consists of graph and data nodes VG and VD, and graph, node attribute and edge attribute edges EG, ENAand EEA, respectively. The domains and codomains of the source and target functions srcj and tarj for the corresponding edges Ej are depicted below.
V ¸¸c  srcG	 E

G,,
srcNA

EN A¸¸¸
tarG
,G ,
srcEA

EEA
   

tarN¸A¸¸	ta rEA
z , s
VD
Given a signature DSIG = (S, OP ) with attribute value sorts SD ⊆ S, an attributed graph AG = (EG, D) is an E-graph EG together with a DSIG-algebra
 •
D such that VD =	Ds.
s∈SD
Given an attributed graph TG as type graph, a (typed attributed) graph G = (AG, t) is an attributed graph AG together with a typing morphism t : AG → TG. Typed attributed graphs and the corresponding morphisms form the category
AGraphsATG.
We define a function to measure the size of a graph G.
Definition 2.2 Given a graph G  =  ((VG, VD, EG, ENA, EEA, (srcj, tarj)j∈{G, NA,EA}), D), the size of G is denoted by |G| and calculated as follows: |G| =
|VG| + |EG| + |ENA| + |EEA|. G is finite if |G| < ∞.
We do not count the data nodes, since there may be infinitely many of them, but those relevant for the actual graph are linked by the attribute edges, which we do count. Moreover, the data part cannot be changed by applying a production.

Definition 2.3 A production p = (L ←−l
K −→r
R) consists of finite graphs L, K

and R, called left hand side, gluing graph and right hand side respectively, and two injective graph morphisms l and r that preserve the data part.
For practical purposes, it is important to restrict the applicability of a production by application conditions. In particular, we use negative application conditions, which forbid the existence of a certain subgraph.
Definition 2.4 A negative application condition of a production p = (L ←−l  K −→r
R) is of the form N AC(x), where x : L → X is an injective graph morphism. A graph morphism m : L → G satisfies N AC(x) if there does not exist an injective graph morphism p : X → G with p ◦ x = m.



X ¸x,  L ¸,l
¸¸
pc¸¸ m
zJ 
G
r	 R 

Two graph productions (rules) are presented in Figure 1. The upper rule is applied first, as long as it can be matched against the input graph. A negative application condition ensures that at most one dashed arrow can be created between two vertices. The rule below ”short-circuits” a dashed path with a length of two edges as long as possible. The resulted construct is referred to as transitive closure.

Fig. 1. Two productions computing the transitive closure


Definition 2.5 Given a graph production p = (L ←−l
K −→r
R) and a graph G with

a graph morphism m : L → G, called match. If m satisfies all negative application conditions of p, a direct graph transformation G p,m  Hz from G toa graph H is given by the following double pushout (DPO) diagram, where (1) and (2) are pushouts.


X ¸x,  L ¸,l	K
¸¸
r	 R 

pc¸¸¸ m	(1)	k	(2)	n
zJ	J	J 
G ¸f,  D   g H 
A sequence G0 ⇒ G1 ⇒ ... ⇒ Gn of direct graph transformations is called a graph

transformation and is denoted as  G0
∗ zG  . For n = 0 we have the identical

graph transformation  G0
id zG  .

We say p is applicable to G via m, if m satisfies the NACs of p, pushouts (1) and (2) exist, and the resulting graph H satisfies additional constraints given by the system. In this paper we assume injective matches m and comatches n.
Definition 2.6 A graph transformation system GT S = (P ) consists of a set of graph productions P with or without negative application conditions. For a graph transformation system, there may be given a set of finite input graphs.
Remark 2.7 In Definition 2.6, we do not take arbitrary constraints into account. However, the results in this paper can treat all sorts of constraints, including those that are not formally defined, since their satisfaction is contained in the applicability

of a production, therefore, they have been integrated into the definition dealing with the applicability of a production, and thus, it appears in Definition 3.1.
Primarily, we need a definition for the termination of a graph transformation system. We extend the definition used in [10]. In [5], the treatment of a layering control structure is added to this definition. We extend the definition in such a way that an arbitrary control structure can be handled.
Definition 2.8 A graph transformation system GT S = (P ) terminates if there is no infinite sequence of direct graph transformations G0 ⇒ G1 ⇒ ... applying rules from P starting from any input graph G0, with respect to the control structure of the given graph transformation system.
Up to now, the following definition of E-concurrent productions and the Concur- rency Theorem have not been extended to productions with some kind of application conditions. Therefore we consider only plain productions in the following definition and theorem, as given in [6]. The results contributed in Section 3 are also valid when the rules contain negative application conditions.
Definition 2.9 Given two productions p1 = ( 1 l1	1 r1	1) and p2 = ( 2 l2

←− K
r2
−→ R
L  ←−

K2 −→ R2), an E-dependency relation (E, e1, e2) is given by a graph E and injective morphisms e1 : R1 → E, e2 : L2 → E, which are jointly surjective.  The E-

concurrent production p1 ∗E p2 is a production p = (L
←−l
K −→r
computed

based on the following diagram, where double squares (1)(2) and (3)(4) form double pushouts, and (5) is a pullback. Note that the injectivity of e1 and e2 implies that of k1, m1, k2, and n2.


L1 ¸l,1 K1
r1 R 1
,,
L2 ¸l,2 K2
    
r2 R 2

m1  (1)	k1
(2)
e1,,,
 e2
k2
n2

J¸ ,
J' 
,vz j 
J'	J 

L ¸¸¸_l' ¸ K
¸¸¸
 E ¸,	 K¸r' ,, _R 

¸¸¸¸¸ 1
¸¸¸¸
,,,,	2,,,,,

¸¸¸¸ ¸ ¸¸ '
¸¸¸¸¸¸¸¸

K
k' ,,,r,,,,,
, ,
,,,

This definition can be applied recursively, using an E-concurrent production for
p1.
A transformation G p1,m1 Hz p2,m2 Gz' is called E-related to p ∗ p if there exist

morphisms h : E → H, c1 : K1 → D1 and c2 : K2 → D2 such that h ◦ e1
= n1,

h ◦ e2 = m2, (6) and (7) commute and (8) and (9) are pushouts.


L1 ¸l,1 K1
k1
r1 R 1
,,
e1,,,
L2 ¸l,2 K2
    
 e2	k2
r2 R 2

J' 
,vz j 
J' 

m1	(6)K1 	 E ¸,	 K2(7)	n2
n1		m1
c1	(8)	h	(9)	c2

J¸ ,
zJz	 zJ z 
J  j 
  '

G	D1	H	D2	G

Theorem 2.10 (Concurrency Theorem) Let (E, e1, e2) be an E-dependency re- lation for the productions p1 and p2 leading to the E-concurrent production p1 ∗E p2.
Synthesis: Given an E-related transformation sequence G ⇒ H ⇒ G' via p1 and p2, then there is a synthesis construction leading to a direct transformation G ⇒ G' via p1 ∗E p2.
Analysis: Given a direct transformation G ⇒ G' via p1 ∗E p2, then there is an analysis construction leading to an E-related transformation G ⇒ H ⇒ G' via p1 and p2.
Bijective correspondence: The synthesis and analysis constructions are inverse to each other up to isomorphism.
.... _H,¸¸¸¸¸¸

..p1 ..
..
¸p2¸¸¸¸
¸¸ zz _

G 	p1∗Ep2	 G'

A General Criterion for Injective Matches
In this section, we provide a general approach for termination within the scope of the DPO approach. These results also apply when the rules contain negative application conditions and other constraints.
Definition 3.1 An E-concurrent production p∗ is an E-based composition if there

is at least one input graph G0
with an E-related transformation G0
p∗  z. 

This definition is required, because for the DPO approach, the definition of E-concurrent productions and the Concurrency Theorem have not been extended to handle negative application conditions and other constraints. Moreover, this definition guarantees, among others, that the constraints enforced by p1 do not contradict to the constraints necessary for the application of p2. Typical exam- ples for constraints are attribute constraints, negative application conditions, type conformance for metamodels, constraints from the control flow branches, but other constructs are also possible.
In most of the practical cases it is simple to find such an input graph for an E-concurrent production, when there is no contradiction between the rules. Then, the left hand side of this rule is already an input graph, or it can be extended with regard to possible constraints.
An example for composing the bottom rule in Figure 1 with itself via a chosen
E1 is depicted in Figure 2.
Definition 3.2 Consider a possibly infinite sequence of graph productions pi, (i = 1, 2, ...) and a sequence of E-dependency relations ((Ei, e∗, ei+1)) leading to a sequence of their E-based compositions (p∗ = (L∗ ← K∗ → R∗)) with p∗ = p1

and p∗ = (p1 ∗E
p2) ∗E2
... ∗En
pn.
i	i	i	i	1

A cumulative LHS series of this sequence is the graph series L∗ consisting of
the left-hand side graphs of p∗ . Moreover, a cumulative size series of a production



Fig. 2. An E-based composition of Rule 2 with itself
sequence is the nonnegative integer series |L∗ |.
It is possible that there are several cumulative LHS series of a given production sequence, since, in general, two rules can be composed in different ways, choosing different E-dependency relations. For instance, if we want to compute p∗ for our example, then we take the cumulative rule p∗, and compose it with the bottom rule from Figure 1. There are several possibilities to choose E2: (i) we can short-circuit the path 1 − 2 − 3' , (ii) 1 − 3 − 3' , or (iii) R∗ and L do not fully overlap. It is easy to see that in the first two cases L∗ is isomorphic to L∗, but in the third case L∗ must
3	2	2
be extended to obtain L∗. However, there is no case, when L∗ is smaller than L∗.
3	3	2
If we consider injective matches only, this is true for the DPO approach in general.
Lemma 3.3 The sequence |L∗| (Def. 3.2) is monotonic nondecreasing. If Ei ∼= R∗,

i
∗	∗	∗
i
∗	∗	∗

 Li  remains unchanged, thus, |Li | =
Li+1 . Otherwise, Li   Li+1 and |Li | <

∗
i+1
 , but L∗
always contains an isomorphic subgraph of L∗.

Proof. Since there is an injective morphism m∗ : L∗ → L∗
, we have |L∗|≤ L∗  ,

and L∗
i	i
contains an isomorphic subgraph of L∗.
i+1
i	i+1

Pushouts along isomorphisms are pullbacks, and pushouts and pullbacks are closed under isomorphism. Therefore, if Ei ∼= R∗, we have isomorphisms k∗ and

∗	∗ ∼	∗
i	i
∗	∗ 

If E
  R∗, there are items x ∈ E \e∗(R∗), which have preimage in K∗'
but

i	i	i	i	i
i+1

not in K∗, because (2) is a pushout. For (1) being a pushout, these items have to
i
∗	∗	∗	∗	∗	∗



L∗ ¸,l∗	K∗ r∗   R ∗
L	¸li,+1 K

ri+1 R 

i	i	i	i
m∗	k∗
i ¸¸¸
∗
i+1
   
e
i+1
i+1

i	(1)
i	(2)
ei ¸¸¸¸
 i+1
(3)
(4)

∗J  '	J'
z , s
'J  '
∗J 

Li+1 ¸¸¸¸l,_∗
K∗	¸¸¸
 Ei ¸,
, K¸
ri+1, ˛R i+1

¸i ¸¸¸¸ i+1
¸¸¸
,,	i+1,,,,,

¸¸¸¸l∗	¸¸
,,,,
,,,,,,

i+1¸¸ k1i¸¸
(5)
,k2i ,,r∗

¸¸¸¸¸¸¸¸¸¸
∗
i+1
,	,
,,,,,,,
i+1

Theorem 3.4 A GT S = (P ) (Def. 2.6)terminates if for all inﬁnite cumulative LHS sequences (L∗) of the graph productions created from the members of P, it
holds that
lim |L∗| = ∞.
i→∞	i
Note that we assume ﬁnite input graphs and injective matches.
Proof. We rely on the fact that if the constraints are satisfied, the E-based com- positions are E-concurrent productions as well. Therefore, we can apply Theorem
2.10 for the topological part of the transformation, when we can assume that the constraints hold, which means the existence of the E-based composition.
In AGraphsATG, Theorem 2.10 holds.	Suppose there is an infinite trans-
p1
formation G0  zG 1  z.. . . Then there is a sequence of E-concurrent produc-
p∗

tions p∗
leading to the transformations	G0
zG i
(Theorem 2.10).	All these

productions are also E-based compositions with cumulative LHS series L∗. Since limi→∞ |L∗| = ∞, there exists an N ∈  with |G0| < |L∗ |. But this means that

i
there is no injective match m∗
: L∗
→ G0, i.e. p∗
N
is not applicable to G0.	 

The opposite direction of Theorem 3.4 does not hold in general, but for a finite number of input graphs. In this case, no infinite sequences of E-based compositions can be constructed.
Theorem 3.5 If a GT S = (P ) (Def. 2.6) terminates and we have only a ﬁnite number of input graphs up to isomorphism, then there are no inﬁnite cumulative LHS sequences (L∗) of graph productions created from the members of P.
Proof. Assume that GT S terminates and there is an infinite sequence (p∗) of E-
based compositions.
For each p∗ there exists an input graph Gi with an E-related transformation
p∗,mi z . Since there are only finite many input graphs, at least one of them
Gi i	Hi
has to appear infinitely many often. This means we have an input graph G with
∗
∀N ∈ ∃j > N : G	j  Hzj . From Theorem 2.10 it follows that all p∗ are applicable
to G leading to an infinite transformation sequence.	 
From Theorem 3.4 the next statement follows:
Lemma 3.6 If L∗  L∗  , ∀i for every cumulative LHS series (Def. 3.2), then the
i	i+1
GTS terminates. If each graph appears only ﬁnitely many times in all cumulative LHS series, the GTS still terminates.
Proof. Considering the first statement of the lemma, if two subsequent graphs in the cumulative LHS sequence are not isomorphic, they must grow in size because of Lemma 3.3. According to Theorem 3.4, this means that the GTS terminates.
Taking a cumulative LHS series at any position i, it grows in size within finite number of steps if there are only finite number of graphs in the series that are

isomorphic to L∗. The series must grow because of Lemma 3.3. Then we have limi→∞ |L∗| = ∞, and the GTS terminates because of Theorem 3.4.	 

Case Studies
To show the practical relevance of the presented termination criteria, two case studies are provided. We take two transformation idioms from [1], and analyze their termination properties. Obviously, there are other proofs for these case studies, but we would like to illustrate how the technique contributed in this paper works for practical software model transformations, where the tool supports strict control flow constructs.

Transitive Closure
Using Theorem 3.4, we show that the transitive closure terminates. This is a fre- quently used transformation pattern. In case of variation of the ’class model to relational database management system (RDBMS) model’ transformation [12] (also referred to as object-relational mapping), the traversal of the inheritance hierarchy and the association chains are performed using the transitive closure pattern.
Lemma 4.1 The injective application of the transitive closure rule (the bottom rule in Figure 1) terminates for all ﬁnite input graphs.
Proof. There are two cases. (i) When constructing Ek, it is not isomorphic to R∗.
This means that in this case L∗ must be extended to obtain L∗	by Lemma 3.3.
k	k+1
Therefore, in these steps, the cumulative LHS series grows. (ii) The other case needs more attention, since the cumulative LHS series does not grow in every step this time. We show that at a given stage of the transformation, this is possible finite
times only. Suppose Ek ∼= R∗ when constructing p∗	from p∗ and the original rule
k	k+1	k
p. This leads only to a valid E-based composition if there is no dashed edge between
ek+1(1) and ek+1(3) in Ek.  In R∗	no new nodes are added, but an additional
edge (compared with R∗). Thus, after finite many steps we can only construct E- concurrency relations not isomorphic to the right hand side. This stems from the fact that the negative application condition forbids creating dashed edges between the nodes where there is one already. This means that an LHS can appear only a finite number of times in the cumulative LHS sequence, therefore, according to Lemma 3.6 the GTS terminates.	 

Leaf Collector
The Leaf Collector pattern is used to find the leaf elements in a tree structure. This idiom has been distilled from the transformation flattening a hierarchical data flow diagrams to a flat data flow representation [1]. In fact, Leaf Collector does not modify the input graph, but finds a place where the next rule can be applied. Therefore, Leaf Collector is a useful idiom of many software model transformations, and it is worth examining its termination properties.



Fig. 3. The Leaf Collector Transformation Idiom

A possible formulation of the pattern is depicted in Figure 3. This idiom is particularly interesting, because it strongly builds on a sophisticated control struc- ture of the transformation tool. The diamond in the figure can be implemented in several ways. In GReAT [1], it is implemented as test rule, whereas it is a branch condition in VIATRA [13] and VMTS [11]. The other required feature is param- eter passing. This means that host graph nodes and edges matched in one of the previous rules can be passed to a subsequent rule. The matching algorithm con- siders these elements already bound. This can accelerate the matching process, and facilitates the separation of complex rules. If there are no passed parameters, the matching algorithm starts to match with unbound elements. In our example, the rule is bound to any of the suitable places in the input graph on the first ex- ecution. On the subsequent runs, the graph node matched to the rule node 2 is passed to the rule node 1. Therefore, the matching algorithm finds a node adjacent to the one passed as a parameter. The output of this idiom is node1 when it is a leaf. Therefore, node1 is passed further along the branch where the ellipses are depicted. The parameter passing mechanism is implemented with different syntax in the aforementioned tools, thus, we focus on the notion only without formalizing it. From the mathematical point of view, this construct is modeled as a restriction on the possible E-based compositions.
Since the idiom is obviously not concerned with self-loops, injective matches are assumed. Then we compute the E-based composition of the rule with itself. In this case it is rather simple, because the parameter passing reduces the number of the possible E-dependency relations to one.

Fig. 4. E-based Composition for Leaf Collector - Acyclic Case

Lemma 4.2 The transformation Leaf Collector (depicted in Figure 3) terminates if and only if the input graph does not contain a directed cycle.
Proof. Firstly, we compute the E-based composition of the rule with itself.

Because of the parameter passing, the Ei is created as follows: R∗ contains only one node ni that is a target of an incoming edge and it is not a source of any outgoing edge. Then the node 1(i) in Li+1 is mapped to ni in Ei, the others are mapped to different vertices and edges.
1(i) in Li+1 can either be mapped to an Ei element that is not mapped to any R∗ element, or otherwise. Based on that, there are two possible categories of E- dependency relations. The first option is depicted in Figure 4 for p∗. Since there are only control conditions, it is the same as the E-concurrent production, where the E1 is determined by the parameter passing. The control structure limits the number of the composed productions only. Obviously, L∗, Ki∗, and R∗ are the same, because
i	i
the rule does not change the input graph: it searches for a specific element.
Pushouts along isomorphisms are pullbacks, and pushouts and pullbacks are

closed under isomorphism.  Therefore, Ei ∼= L∗
.  Thus, L∗
is a directed path

consisting of i edges. This means that in this case the transformation terminates according to Theorem 3.4.
When 1(i) in Li+1 is mapped to an Ei element that is mapped to any R∗ element,
it automatically creates a directed cycle. An example for this structure is depicted in Figure 5. In this case it is possible that we have a nonincreasing cumulative size series. According to Theorem 3.5, it is possible that this structure does not terminate.	 

Fig. 5. E-based Composition for Leaf Collector - Cyclic Case

According to Lemma 4.2, if the input graph does not contain directed cycles, the transformation terminates, otherwise it is possible that the transformation does not terminate. In practice, this condition can be guaranteed in model transformation systems. (i) Most of the modeler tools offer a containment hierarchy, and along this hierarchy it is ensured by the tool that there are no directed cycles. (ii) Directed cycles in inheritance hierarchy causes semantical problems, it may also be forbidden by the tool.
If there are no such constraints in the model, the Leaf Collector should be extended with additional construct in order to avoid nontermination. A possible solution is to add an isP rocessed attribute to the nodes, which is false by default, and set by the rule if it is matched. Another solution is to introduce helper edges between the processed nodes, and introduce NACs to forbid the match at the same place again.
This case study illustrates that with the proposed termination analysis method, we could obtain the structure that causes the nontermination. Therefore, this tech-

nique is suitable for constructive analysis besides the decision issues.


Related Work
In [2], termination criteria have been developed for graph rewriting applied to pro- gram transformation. The criteria aim at this specific problem domain. The ap- proach assumes that there can be no parallel edges with the same labels between two nodes. This leads to a termination criteria for specific (edge-accumulative) rules if the label and node sets are finite. Moreover, subtractive rules are investigated, which are conceptually similar to deletion layers examined in [5]. These results assume more restricted types of rules, compared to those analyzed in this paper.
In [3], a theory has been developed for the DPO approach. It provides abstract termination criteria by a measure function F . The paper also shows concrete ter- mination criteria such as the number of nodes, the number of edges. Based on this assumption, it proves termination criteria for other control structures. However, these criteria are violated in the second case study with respect to the concrete criteria of edge and node numbers. However, no explicit relationship has been es- tablished between the proposed definition of a termination criterion and the notion that the transformation stops within a finite number of steps.
In [5], results have been developed for layered grammars. These results formalize and extend the contributions provided in [7] [4]. The provided criterion ensures that the creation of all objects of a type should precede the deletion of the object of this type. Therefore, a layer deleting an object of a given type cannot create such an object, nor the subsequent rules. This means that the productions in a deletion layers terminate for the reasons detailed above if the types are taken into consideration.
A nondeletion layer cannot contain rules that delete a node. It is ensured by a negative application condition that a rule cannot be applied twice at the same match. Furthermore, if a rule creates an object of a given type, it is not allowed to match any object of that type in that or any subsequent layers. Since Layer 0 uses the finite input graph, and there cannot be a match at the same place, and the rules in Layer 0 cannot create elements of a type whose instances they match, the rules can be executed only a finite number of times. The next layer terminates for similar reasons: it can only use elements of a type whose instances have already been created. Since Layer 0 has terminated, Layer 1 is passed a finite graph, thus, the situation is similar to that in case of Layer 0.
In our context, this means that only a finite fully overlapping (Ei ∼= R∗) se-
quences are possible, since the the NAC forbids the E-based composition at a given position more than once. Otherwise |L∗| must increase. Unfortunately, there are situations, where these criteria do not hold. In our first case study, the second rule matches and creates an element of the same type.
The methods discussed as related work are not restricted to injective matches as opposed to our approach.

Conclusions
A novel contribution of this paper is to provide termination criteria for general pro- ductions allowing recursion within the scope of DPO and typed attributed graph transformation, assuming injective matches. This can be a theoretical basis to prove that certain control flows of rules are terminating, where the other - algorithmically underpinned - criteria cannot be applied. In general, however, it is hard to find all the possible sequences of graph productions, and prove that the corresponding series |L∗| exceeds all limits. This is expected, since the termination of a GT S is undecidable [10]. However, the stricter and the more deterministic the ordering of the rules is, the higher is the chance that we can deal with the sequences. For example, in the tool Visual Modeling and Transformation System (VMTS) [11], the control structures are as strict as possible, and nondeterminism is avoided if possible. Moreover, parameter passing between the rules (external causalities) de- crease the number of the possible Ek graphs, since the nodes and edges connected by a morphism from R∗ to Lk+1 must be mapped to the same nodes and edges in Ek. We have also contributed two case studies, which solve the termination issue of two frequently used transformation idioms called ”transitive closure” and ”leaf collector”.
Another contribution is that in the composition of the productions in Defini- tion 3.1, attributes are also considered, and the proposed method is open to other constraint specification approaches. Furthermore, it regards control structures and parameter passing.
Future work includes the extension of these results to noninjective matches. Furthermore, constraint checking to decide whether a composition rule exists is not simple in the general case, when not only the attributes set by the transformation steps are considered. Also, we would like to analyze more idioms and frequent building blocks. A library of building blocks with proven termination properties may help the tools to overcome the algorithmic undecidability. Since where the algorithms fail, the structural investigation can offer a solution.
Acknowledgments
The activities described in this paper were supported, in part, by the SegraVis Training Network and by the National Office for Research and Technology (Hun- gary).

References
Agrawal, A., Vizhanyo, A., Kalmar, Z., Shi, F., Narayanan, A., Karsai, G: Reusable Idioms and Patterns in Graph Transformation Languages 2004. Proc. 2nd International Workshop on Graph Based Tools (GraBaTs 2004). Satellite workshop of ICGT 2004, Rome, Italy, 2004.
Assmann, U., Graph rewrite systems for program optimization, ACM TOPLAS 22, 2000, pp. 583-637
Bottoni, P., Koch, M., Parisi-Presicce, F., Taentzer, G.: “Termination of High-Level Replacement Units with Application to Model Transformation”, VLFM 2004, Electronic Notes of Theoretical Comp.Sci. (ENTCS) vol.127, no.4 (2005), Elsevier, pp. 71-86.


Bottoni, P., Taentzer, G., Schuerr, A. Efficient Parsing of Visual Languages based on Critical Pair Analysis and Contextual Layered Graph Transformation. In Proc. Visual Languages 2000 IEEE Computer Society. pp.: 59-60.
Ehrig, H., Ehrig, K., de Lara, J., Taentzer, G., Varr´o, D., Varr´o-Gyapay,Sz.: “Termination Criteria for Model Transformation”, FASE 2005, LNCS, pp. 49-63.
Ehrig, H., Ehrig, K., Prange, U., Taentzer, G.: “Fundamentals of Algebraic Graph Transformation”,
EATCS Monographs in Theoretical Computer Science, Springer, 2006
de Lara, J., Taentzer, G. 2004. Automated Model Transformation and its Validation with AToM3 and AGG. In DIAGRAMS2004 (Cambridge, UK). Lecture Notes in Artificial Intelligence 2980, pp.: 182198. Springer.
Lengyel, L., Levendovszky, T., Charaf, H.: “Eliminating Crosscutting Constraints from Visual Model Transformation Rules”, ACM/IEEE 7th International Workshop on Aspect-Oriented Modeling, Montego Bay, Jamaica, October 2, 2005.
Levendovszky, T., Lengyel, L., Mezei, G., Charaf, H.: “A Systematic Approach to Metamodeling Environments and Model Transformation Systems in VMTS”, Electronic Notes in Theoretical Computer Science, International Workshop on Graph-Based Tools (GraBaTs) Rome, 2004.
Plump, D.: “Termination of graph rewriting is undecidable”, Fundamenta Informaticae, 33(2):201209, 1998
VMTS Web Site, http://avalon.aut.bme.hu/∼tihamer/research/vmts

Taentzer, G., Ehrig, K., Guerra, E., de Lara, J., Lengyel, L., Levendovszky, T., Prange, U., Varr´o, D., Varr´o-Gyapay, Sz.: Model Transformation by Graph Transformation: A Comparative Study,ACM/IEEE 8th International Conference on Model Driven Engineering Languages and Systems, Montego Bay,
Jamaica, 2005
Varr´o, D.: Automated Model Transformations for the Analysis of IT Systems. PhD thesis, Budapest University of Technology and Economics, Department of Measurement and Information Systems (2004)
