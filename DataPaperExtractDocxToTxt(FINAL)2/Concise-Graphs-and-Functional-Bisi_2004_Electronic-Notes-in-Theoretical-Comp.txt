Electronic Notes in Theoretical Computer Science 100 (2004) 5–29	
www.elsevier.com/locate/entcs


Concise Graphs and Functional Bisimulations
Ling Cheung
Department of Computer Science, University of Nijmegen
P.O. Box 9010, 6500 GL Nijmegen, The Netherlands Email: lcheung@cs.kun.nl

Jesse Hughes1
Section of Philosophy and Ethics of Technology Technical University of Eindhoven
P.O. Box 513, 5600 MB Eindhoven, The Netherlands Email: J.Hughes@tm.tue.nl


Abstract
We investigate the conditions under which least bisimulations exist with respect to set inclusion. In particular, we describe a natural way to remove redundant pairs from a given bisimulation. We then introduce the conciseness property on process graphs, which characterizes the existence of least bisimulations under the aforementioned method.
Subsequently, we consider the category of process graphs and functional bisimulations. This cate- gory has all coequalizers. Binary products and coproducts can be constructed with some further assumptions. Moreover, the full subcategory of concise graphs is a reflective subcategory of the category of process graphs.
Keywords: Functional bisimulation, process graph, least bisimulation, concise graph, product, quotient graph



Introduction
In [1], Zena M. Ariola and Jan Willem Klop investigated structural features of term graphs and functional bisimulations. There they defined an order

1 This work was largely completed while the second author was employed at Department of Computer Science, University of Nijmegen.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.09.003


relation ≤FB on the collection of term graphs:
G ≤FB H ⇔∃ functional bisimulation f : G	 H .
It was shown that ≤FB is a partial order (up to graph isomorphism). More surprisingly, for any term graph G, the collection of all term graphs bisimilar to G form a complete lattice with respect to ≤FB.
The research in this paper began as an exercise to generalize these results to process graphs. We follow Ariola and Klop in taking functional bisimu-
lations as our morphisms (although, unlike them, we do not investigate the related skeletal category). This yields the category P. Functional bisimula- tions seem to be an interesting (if non-traditional) choice, because they are closely related to history relations. Indeed, the ≤FB relation of ibid corre- sponds to the opposite of ≤H in [9]. In fact, a direct application of Lynch and
Vaandrager’s Proposition 5.4 yields: There is a functional bisimulation A	 B iff A is essentially obtained by adding a history variable to B. The function A	 B is the effect of “forgetting” that variable.
Having taken history relations as our starting point, we investigate the basic features of the resulting category. Our aim is to define a product (with respect to functional bisimulations) of two process graphs via minimal bisim- ulation, and a coproduct via a quotient of the corresponding coproduct in Set (the category of sets and functions).
Since the structure of process graphs is much more flexible than that of term graphs, we encounter some non-trivial difficulties, among which the exis- tence of a suitable minimal bisimulation between two bisimilar process graphs. These graphs may fail to have any minimal bisimulation between them (Fig. 1), or there may be non-isomorphic minimal bisimulations (Fig. 2).


x,,
0,¸¸¸¸¸

a sss ,,a
a s , ¸¸ ¸¸¸ a ¸ ... 

ss	,,
s	a,,
a ¸¸¸
¸¸¸¸

  rs tz	 rs  t z ¸z ¸¸z˛ 

y ,¸ z ,¸ 1	b	 2 
        
b	b

b	b

Fig. 1. No minimal bisimulation.
We solve this problem by introducing the notion of concise graphs (Sect. 3). If G is concise, then one can construct the least bisimulation between G and H for any bisimilar H (which need not be concise). More precisely, we start with any bisimulation R between G and H and remove the pairs that are not reachable when R is given the transition structure described in [1].





Fig. 2. Non-isomorphic minimal bisimulations: R (indicated by dotted lines) and the identity relation ∆.
We devote Sect. 4 to understanding basic features of P. This category has all coequalizers; hence, given a bisimulation R on process graph G, we can construct the quotient process G/R, using the least equivalence relation generated by R. We use this fact to construct binary coproducts of bisim-
ilar graphs, provided one of the graphs is concise. Lastly, we move to the subcategory of restricted graphs and construct binary products under similar assumptions.
In Section 5, we prove that the full subcategory of concise graphs is a reflective subcategory of P. Given an arbitrary process graph G, there is a “best” way to identify nodes in G so that the result is concise. This operation can be viewed as a closure operator on (the skeleton of) P and the subcategory
of concise graphs corresponds to the closure system generated by this operator. In general, a reflective subcategory is the categorical generalization of closure systems in posets (see discussion in [12]).
Section 6 explores the situation without conciseness. We show, by Zorn’s lemma, that minimal bisimulations exist between image finite process graphs. However, there is no uniqueness guaranteed.
Section 7 discusses briefly the prospects of checking conciseness. We pro- pose a modified definition called obvious conciseness, which allows for more efficient checking.

Preliminaries
Process graphs are labeled transition systems. (We assume an alphabet A of action labels.) Explicitly, a process graph is a triple
G = ⟨G, eG :G	 P (G)A , roots(G) ⊆ G⟩.
Elements of the set G are the nodes of process graph, denoted s, t, u, v, etc.
We denote the actions (elements of A) by a, b, c, etc. and write s →a  t if
t ∈ eG(s)(a).
A bisimulation between two process graphs G and H is a relation R ⊆
G × H satisfying:



For all ⟨s, s'⟩∈ R, if s →a
and ⟨t, t'⟩ ∈ R.
For all ⟨s, s'⟩ ∈ R, if s' →a
and ⟨t, t'⟩ ∈ R.
t in G then there is a t' ∈ H such that s' →a t' t' in H then there is a t ∈ G such that s →a t

For all r ∈ roots(G), there is an r' ∈ roots(H) such that ⟨r, r'⟩ ∈ R.
For all r' ∈ roots(H), there is an r ∈ roots(G) such that ⟨r, r'⟩ ∈ R.
We say that G and H are bisimilar just in case there is a bisimulation between them. An interested reader can refer to [5] for an introduction to various semantics of concurrency including bisimilarity.
Process graphs are evidently coalgebras for the functor FX = P(X)A, together with the extra structure of designated roots. Viewed in this way, a bisimulation is the same as an F -bisimulation (in the coalgebraic sense)
satisfying (iii) and (iv). Note: one may be tempted to use the isomorphism between subsets of a set G and arrows G  2 to represent a process graph G as a coalgebra


G 	[eG,roots(G)]	 P (G)A × 2,




that is, as a coalgebra for the functor F 'X = P(X)A × 2. However, our definition of bisimulation is not the same as F '-bisimulations in the coalgebraic sense. The latter requires (in place of (iii) and (iv) above)
For all ⟨s, t⟩ ∈ R, we have s ∈ roots(G) iff t ∈ roots(H).
It is well-known that bisimulation relations are closed under arbitrary union. We use the symbol ↔ to denote the union of all bisimulations, i.e., the greatest bisimulation with respect to set inclusion. A bisimulation R is
said to be minimal if no proper subset of R is again a bisimulation. It is said to be functional if it coincides with the graph of some function f . We write
Φ(f ) for the graph of f . For a given set map f : G  H , we have that Φ(f ) is a functional bisimulation iff f is an F -homomorphism (in the coalgebraic sense) satisfying
f preserves roots, i.e., if r ∈ roots(G), then f (r) ∈ roots(H);
f Troots(G) : roots(G)	 ro ots(H) is surjective, i.e., for each r' ∈ roots(H), there is an r ∈ roots(G) such that f (r) = r'.
We also call f a functional bisimulation whenever Φ(f ) is a functional bisim- ulation.


Paths and Reachability
The letters p, q, etc., are used to denote paths in a process graph. We write s ~ t for “the path p starts at s and ends at t.” Note the distinction between paths and traces: a path p has trace σ if σ is the sequence of action labels from edges in p (in the appropriate order).
Any relation on nodes of process graphs gives rise to a relation on paths in a natural way:
Definition 2.1 Let R be any relation between process graphs G and H. Let p = s0a1s1 ... sn−1ansn and q = t0a1t1 ... tn−1antn be two paths in G and H, respectively. Then p and q are said to be R-related if, for all 0 ≤ i ≤ n,
⟨si, ti⟩ ∈ R.
Notice that R-related paths necessarily have the same length and trace. Using this induced relation, we observe that bisimulations can be defined in terms of paths (instead of single steps).
Lemma 2.2 Let R be a relation between process graphs G and H such that each root of G is related to some root of H and vice versa. Then R is a
bisimulation if and only if, for all ⟨s, t⟩ ∈ R and s ~ s', there is path t ~q  t'
in H such that p and q are R-related and vice versa.
Proof. The “if” part is trivial by taking a single step as a path with length
1. The converse can be proven easily by induction on the length of p.
 
The following definition of access paths is adapted from [1]. In the litera- ture, they are also referred to as runs or executions.
Definition 2.3 Let s be a node in G. A path p in G is called an access path of s if r ~ s, where r is a root of G. The set of access paths of G is denoted AccPath(G). A node s is said to be reachable if it has an access path. Let reach(G) denote the set of reachable nodes in G (with transitions inherited from G).
Here we state a few basic facts about functional bisimulations and minimal bisimulations.
Lemma 2.4 Let f : G	 H be a functional bisimulation.
If H = reach(H), then f is surjective.
If G = reach(G), then Φ(f ) is a minimal bisimulation.
Lemma 2.5 Let R be a minimal bisimulation between G and H. Then we have ⟨s, t⟩ ∈ R if and only if there exist R-related access paths p and q of s


and t, respectively.
Proof. Define R' to be the set of pairs ⟨s, t⟩ ∈ R satisfying the condition in the statement of this lemma. By minimality of R, it suffices to show that R' is also a bisimulation. We omit the details.
 
Corollary 2.6 If R is a minimal bisimulation and ⟨s, t⟩ is in R, then s is reachable in G and t is reachable in H.

Transition Structures on Bisimulations
The following is a well-known characterization of bisimulation.
Theorem 2.7 Let G and H be process graphs and R ⊆ G × H. Then R is a bisimulation iff there is a transition structure on R (i.e., a function eR :R	 P (R)A and a subset roots(R) ⊆ R) such that the projections π1 :R	 G and π2 :R	 H are functional bisimulations.
Notice, if R itself is functional, then π1 is a bijection. In that case, R is isomorphic to its domain.
Lemma 2.8 Let R be any bisimulation between G and H and ﬁx a transition structure on R making the projections functional bisimulations, as in Theo- rem 2.7. Then reach(R) is again a bisimulation between G and H.
Proof. The projections π1 :reach(R)	 G and π2 : reach(R)	 H are functional bisimulations. Apply Theorem 2.7.			 
Theorem 2.7 implies that, for any bisimulation, there is a transition struc- ture making the projections homomorphisms. We are particularly interested in the largest such structure, explicitly defined here.
Definition 2.9 Let R be any bisimulation between G and H. Define the
maximal labeled transition system on R as follows:
⟨r1, r2⟩ is a root of R if and only if r1 is a root of G and r2 is a root of
H;

⟨s, t⟩ →a
⟨s', t'⟩ if and only if s →a
s' in G and t →a
t' in H.

The next theorem states that the maximal LTS on R satisfies the condi- tion of Theorem 2.7. (This result is also noted in [1].) It is routine to verify this is in fact the largest such structure. In the special case that R is func-
tional, the maximal LTS is the only LTS making both projections functional
bisimulations.


Theorem 2.10 Let R be any bisimulation between G and H. The projec- tions π1 : R  G and π2 : R  H are functional bisimulations with respect to the maximal LTS on R.
Hereafter, we shall always impose the maximal LTS on a bisimulation R, unless stated otherwise. We should emphasize the distinction between this definition and the synchronous product of two transition systems (cf. [3]): the
synchronous product is uniquely determined between each pair of graphs G and H (not necessarily bisimilar), whereas each bisimulation R between G and H (necessarily bisimilar) yields its own maximal LTS.
Lemma 2.11 Let R be any bisimulation between G and H. Then ⟨s, t⟩ ∈ reach(R) if and only if there exist R-related access paths p and q of s and t, respectively.
Combined with Lemma 2.5, we can see that R is a minimal bisimulation implies R = reach(R). If R is not minimal, then it’s possible (but not nec- essary) to have unreachable pairs. For example, one can safely augment a
bisimulation R with all pairs ⟨s, t⟩ such that s and t are termination nodes (i.e., those without out-going edges). Call the resulting bisimulation R'. De- pending on the histories of s and t, the pair ⟨s, t⟩ may or may not be reachable in R'.

Concise Graphs
Conciseness is a condition on the branching structure of a process graph. As we shall see in Theorem 3.8, conciseness limits branching flexibility just enough to guarantee existence of the least bisimulation under the construction in Lemma 2.8. This least bisimulation is crucial in subsequent categorical developments.
Definition 3.1 A process graph G is said to be concise if G contains no distinct but bisimilar roots and for all s, t1, t2 in reach(G),


(s →a
t and s →a
t2 and t1 ↔ t2) ⇒ t1 = t2.


Diagram (1) illustrates the forbidden situation. The intuition here is that “redundant” branches are not allowed in a concise graph (hence the name).


a s,,a
(1)

cc ,
t ↔  czz
1	t2


In practice, this situation may arise in the following way: a program per- forms a boolean test “if bexp then A else B,” where A and B exhibit the same behaviors (i.e., they are bisimilar states). An algorithm to suppress such useless boolean tests is presented in [2].
Conciseness is much weaker than determinism, because we are still allowed to take two different a-steps from the same node, as long as the target nodes are not bisimilar. Note also that for a graph to be concise, it is not necessary to identify all bisimilar nodes. In other words, with conciseness we can have distinct but bisimilar nodes, provided those nodes are not reachable via ↔- related paths.
We give an alternative characterization of conciseness. It takes the form of a proof principle on AccPath(G): the relation “↔-related” coincides with identity. This proof principle is valid for AccPath(G) iff G is concise. This
is analogous to coinduction for coalgebras: the relations ↔ and identity on a coalgebra C coincide iff C is a subcoalgebra of the final coalgebra.
Lemma 3.2 A process graph G is concise if and only if, for all access paths
p and q in G, we have p is ↔-related to q iff p = q.
Notice that a functional bisimulation can be viewed as an operation that identifies certain bisimilar nodes in the domain, hence it can never create a non-concise situation. I.e., functional bisimulations preserve conciseness.
Lemma 3.3 Let f : G	 H be a functional bisimulation. If G is concise, then so is H.
Proof. Let r1 and r2 be bisimilar roots of H. Since Φ(f ) is a bisimulation, we
can choose r' and r' in roots(G) such that f (r' ) = r1 and f (r' ) = r2. Hence
1	2	1	2
r' and r' are bisimilar. By conciseness of G, r' = r' , therefore r1 = r2.

1	2
Now suppose we have (in reach(H)) s →a
1	2
t and s →a
t2 with t1
and t2

bisimilar. By Lemma 2.4, all of these nodes are in the range of f . Choose
s' ∈ G such that f (s') = s. Since Φ(f ) is a bisimulation, we may choose t'
1
'  a	'	'

with s
→ t1 and f (t1) = t1. Similarly for t2. Since t1 and t2 are bisimilar, so

are t' and t' . By conciseness of G, we conclude that t' = t' ; hence t1 = t2. 
1	2	1	2
The following lemma will be used to construct coproducts in Sect. 4.
Lemma 3.4 Let G, H and S be process graphs with S concise. Suppose g : G S and h : H S are functional bisimulations and R ⊆ G × H is a minimal bisimulation. Then for all ⟨s, t⟩ ∈ R, g(s) = h(t).
Proof. Let ⟨s, t⟩ ∈ R be given. By Lemma 2.5, we have R-related access paths p and q of s and t, respectively. Since Φ(g) is functional, there must be access path l of g(s) such that l and p are Φ(g)-1-related. Similarly there


is access path l' of h(t) such that q and l' are Φ(h)-related. Therefore l and l' are Φ(h) ◦ R ◦ Φ(g)-1-related; here ◦ denotes relational composition. By conciseness of S, this implies g(s) = h(t).

·	·	·	·
,t	,t	,t	,t

,t
,t.
,t
, 
g
,t
,t.
,t.
s, 
,t	,t
,t.	,t
,t
,	, 

(s)
Φ(g)
R	t Φ(h) h(t)



There is an alternative proof of Lemma 3.4 using Theorem 3.8. We can view Φ(h) ◦ R ◦ Φ(g)-1 as a relation on reach(S). It’s easily shown to be minimal, hence must coincide with ∆reach(S).

Existence of the Least Bisimulation
For the first step, we observe the following universal property.
Theorem 3.5 Let R be any bisimulation between G and H. Suppose either G or H is concise. Let S be any process graph with functional bisimulations g :S G and h : S H . Then the restrictions of g and h to reach(S) factors (necessarily uniquely) through reach(R), as shown in Diag. (2).

reach(R)	(2)

π,1,,
,
G ¸¸¸
,,¸¸¸π2
¸z˛
 H¸

g†	¸¸¸¸¸¸
,,,,,,

reach(S)
,
reach(S)
h†reach(S)

Proof. Without loss of generality, we assume that G is concise.
Let s ∈ reach(S) be given. Choose an access path p of s. By Lemma 2.2 and the fact that Φ(h) is a bisimulation, there must be an access path q in H such that p and q are Φ(h)-related. Similarly, there is an access path l in G such that l and p are Φ(g)-1-related.
On the other hand, since R is a bisimulation, there must be an access path l' such that l' and q are R-related. Hence l and l' are (R-1 ◦ Φ(h) ◦ Φ(g)-1)- related. By Lemma 3.2, we have that g(s) = end(l) = end(l'), so ⟨g(s), h(s)⟩ =
⟨end(l'), end(q)⟩∈ R. Apply Lemma 2.11 to conclude ⟨g(s), h(s)⟩ is reachable in R.	 
As we will see in Theorem 4.8, the map reach(S) R is in fact a functional bisimulation.


Consider the exemplary non-concise graph G, as shown in Diag. (1). Let R be the identity relation ∆G. There are two functional bisimulations from G to itself: the identity function g = idG and the swap function h mapping s to
s, t1 to t2, and t2 to t1. The conclusion of Theorem 3.5 fails for this example,
because ⟨g(t1), h(t1)⟩ = ⟨t1, t2⟩ /∈ R. This suggests that, for a pair of non- concise graphs, the binary product cannot be constructed in a straightforward way using an arbitrary minimal bisimulation.
The following is an immediate consequence of Theorem 3.5.
Corollary 3.6 If G is concise and H is bisimilar to G, then reach(R) =
reach(S) for any bisimulations R and S between G and H.
Corollary 3.6 implies that reach(R) (for any R) is included in the inter- section of all bisimulations between G and H. Combined with Lemma 2.8, this intersection must be exactly reach(R). In summary, we have the following theorem.
Theorem 3.7 If G is concise, then for any H bisimilar to G and any bisim- ulation R between G and H, reach(R) is the least bisimulation between G and H (with respect to set inclusion).
This gives a rather strong hint on the extent to which conciseness restricts the branching structure of process graphs; i.e., there is essentially only one way to construct a bisimulation between a concise graph and any other bisimilar graph.
Consider the special case in which H coincides with G and R is the identity relation ∆G. Then Theorem 3.7 says every bisimulation from G to itself must include reach(∆G). (Notice reach(∆G) is just ∆G restricted to the reachable
nodes of G.) This fails easily when G is not concise: in (1), the identity relation is not included in the swap relation {⟨s, s⟩, ⟨t1, t2⟩, ⟨t2, t1⟩}.
Moreover, in the same graph G, the relation R := ∆G ∪ {⟨t1, t2⟩} is a bisimulation and reach(R) = R; but clearly R is not a minimal bisimulation. Hence Theorem 3.7 fails in a different way.
We now strengthen Theorem 3.7 by showing its converse. This gives yet another characterization of conciseness.
Theorem 3.8 Let G be a process graph. The following are equivalent:
G is concise;
for any process graph H bisimilar to G and any bisimulation R between them, reach(R) is the least bisimulation between G and H.
Proof. The forward implication is Theorem 3.7. Conversely, suppose G is not concise. Let ↔G be the greatest bisimulation from G to G. We claim that


we can find ⟨t1, t2⟩ in reach(↔G) such that t1 is distinct from t2:
If G has distinct but bisimilar roots, then we set ⟨t1, t2⟩ to be a pair of such roots. By definition, this is a root of ↔G; therefore it must be reachable.
a
Otherwise, we choose witnesses s, t1 and t2 (in reach(G)) such that s → t1,
s →a t , and t and t are distinct but bisimilar. Let p be any access path
2	1	2
of s. Then pat1 and pat2 are ↔G-related access paths. By Lemma 2.11,
⟨t1, t2⟩ is reachable in ↔G.
Now consider the bisimulation ∆G. Certainly ⟨t1, t2⟩ is not in ∆G. This implies reach(↔G) is not a subset of ∆G and hence not the least bisimulation from G to G.	 
Before concluding this section, we raise the following question: when is the least bisimulation R in Theorem 3.8 a functional bisimulation?
Definition 3.9 We say that a process graph H is a forest if each node in H
has exactly one access path. (In particular, this implies that reach(H) = H.)
Intuitively, if t in H has more than one access paths, then a bisimulation R
may be required to relate t to multiple nodes in G, because each access path in H must have an R-related counterpart in G. Therefore, in order to prove existence of functional bisimulations, we require reach(H) to be a forest. The
corollary which follows is immediate.
Theorem 3.10 Assume G is concise and H is bisimilar to G, Moreover, assume that every node in H has at most one access path (i.e., reach(H) is a forest). Then the least bisimulation R (from Theorem 3.7) between G and H is a partial function from H to G, total on reach(H).
Proof. Let t ∈ reach(H) be given. Then t must be related (by R) to some node in G. Let s1 and s2 be two such nodes. It suffices to show that s1 = s2.
By assumption on H, there is a unique access path p of t. Since R is minimal, we can apply Lemma 2.5, to get access paths q1 and q2 of s1 and s2, respectively. Furthermore, q1 and q2 are (R-1 ◦ R)-related. Now applying conciseness of G and Lemma 3.2, we can conclude that s1 = s2, hence R is the graph of a partial function from reach(H) to G.
 
Corollary 3.11 Let G ↔ G', where G' is concise, and H ↔ H', where H ' is a forest. Then G ↔ H iff there is a functional bisimulation H'   G ' . In particular, this applies when H ' is the unfolding of H, and G' is the canonical concise graph for G (constructed in Section 5).

Categories of Process Graphs

In this section, we define four closely related categories of process graphs. The most fundamental of these is the category P of process graphs and functional bisimulations. The category CP is the full subcategory of P consisting of concise process graphs.
Call a process graph G restricted if reach(G) = G. We denote the full subcategory of restricted process graphs by RP and the full subcategory of concise, restricted process graphs by CRP.
We shall explore the relationship between these four categories in more detail in Section 5. Presently, we show that each of these categories inherits coequalizers from the category Set. Coequalizers will be used to construct
coproducts (Sect. 4.2) and the reflection P  CP  (Section 5). We postpone
the treatment of binary products until the end of this section, because it requires that we work in (subcategories of) RP.



Coequalizers
In this section, we consider a common categorical construction: coequalizers, the standard generalization of quotients by equivalence relations in the cate- gory Set. Since we will explicitly use the construction of coequalizers in Set to show that we have coequalizers in our categories, we review that construction here.
  f 
Let X	g  Y be given (in Set.). Define a relation ∼ on Y by


∼ = Φ(g) ◦ (Φ(f ))-1 ,

i.e., y ∼ y' iff there is an x ∈ X such that f (x) = y and g(x) = y'. Let ≡ be the least equivalence relation containing ∼. Then, the map Y   Y / ≡ is a coequalizer of f and g.
In order to show that the same construction yields a coequalizer in our settings, we rely on the following.

Lemma 4.1 Let G be a process graph and R a bisimulation on G. Let ≡ be the least equivalence relation containing R. Then ≡ is also a bisimulation.


Proof. For this, we explicitly construct ≡ in the usual way. Namely,

≡0 = R ∪ R-1 ∪ ∆,
≡n+1 = ≡n◦≡n,
≡ =  ≡n .

Since ∆ and R-1 are also bisimulations, and bisimulations are closed under unions, ≡0 is a bisimulation. Bisimulations are closed under composition, and
so each ≡n is a bisimulation. Again, we appeal to closure under unions to conclude that ≡ is a bisimulation.	 
Theorem 4.2 The category P has all coequalizers and these coequalizers are preserved by the forgetful functor taking a graph to its set of nodes. In other words, the forgetful functor P Se t create coequalizers. Similarly for the categories CP, RP and CRP.
Proof. We prove the result for the category P of process graphs. For the remaining categories, it suffices to show the operation taking G to G/ ≡ preserves restrictedness and conciseness. We omit those easy proofs.
  f 
Let H	g  G be functional bisimulations. Define ∼ and ≡ as relations
on G as above. Since bisimulations are closed under composition, ∼ is a bisimulation, and hence so is ≡.
We impose an LTS structure on G/ ≡ by first defining
roots(G/ ≡) = {[r] | r ∈ roots(G)} ,
where [r] denotes the coset (i.e., equivalence class) of r. We define a transition
[s] →a [t] just in case there is a transition s →a  t' in G for some t' ≡ t. This is
well-defined, since ≡ is a bisimulation. Furthermore, it is easy to see that the quotient map [−]: G  G / ≡ is a bisimulation under this definition.
Suppose that k : G K is a functional bisimulation making the top row of the diagram below commute. We must show that there is a unique functional bisimulation, shown as a dashed arrow, making the triangle commute.


f
H	g	 G 
[−]
G/ ≡
k	 K ,


Clearly, it is necessary and sufficient to show that the set function G/≡	 K 
defined by [s] '→ k(s) is a functional bisimulation. The graph of this function


is the relational composition Φ(k) ◦ Φ([−])-1, and hence is a bisimulation.

Given a bisimulation R on G and a functional bisimulation f : G	 H , we say that f respects R if, whenever sRt, we have f (s) = f (t).
Corollary 4.3 Let R be a bisimulation on a process graph G. There is a process graph G/R and a functional bisimulation q : G  G /R such that every functional bisimulation f : G H respecting R factors through q uniquely, as shown.
G 	f	 H 
q
G/R
Proof. We regard R as a process graph, with its maximal LTS (Sect. 2). Note that f respects R iff f coequalizes the projections R  G . On the other hand, these projections are functional bisimulations, so we may apply Theorem 4.2 to obtain their coequalizer q. Let G/R be the codomain of q. Therefore, there is a unique functional bisimulation from G/R to H making the diagram commute.

  π1	
R	π2	 G 
q

G/R
f	 H 


Remark 4.4 Explicitly, G/R is constructed as follows. Take ≡ as the equiv- alence relation generated by R. Then the nodes of G/R are the cosets of ≡. A coset is a root of R if it contains some root of G. For each s, t in G, there
is a transition [s] →a [t] iff there is a transition s →a t' for some t' ≡ t.

Binary Coproduct
We now turn to binary coproducts of bisimilar process graphs. We approach this by first taking the coproduct G + H in Set (i.e., disjoint union) for bisimilar G and H. There is an evident process graph structure on G + H, but
the resulting graph is not the coproduct of G and H in P (or its subcategories
RP, CP, CRP). Instead, we define a bisimulation R on G + H and show

that (G + H)/R (as given in Corollary 4.3) satisfies the universal property of coproducts. For this, we assume that at least one of G and H is concise.
Let’s first make precise the evident transition structure on G + H:
roots(G + H) = roots(G) ∪ roots(H);



in (s) →a
in (t) if and only if s →a
t in G;

similarly for in (s) →a
inH(t).

Note that the inclusions inG : G G + H and inH : H G + H are not bisim- ulations in general, and so G + H cannot be the coproduct of G and H in P.
Consider the least bisimulation R between G and H as given by Theo- rem 3.8. It can be viewed as a relation RG+H on G + H in the obvious way. Namely,
RG+H = Φ(inH) ◦ R ◦ (Φ(inG))-1 ,
where inG and inH are the canonical inclusions of G and H, respectively, in
G + H. Let R denote the relation
RG+H = RG+H ∪ (RG+H )-1 ∪ ∆	.

In order to construct (G + H)/RG+H , we need to verify that RG+H is a bisim- ulation on G + H.

Lemma 4.5 Let R be any bisimulation between G and H. Then R, deﬁned as above, is a bisimulation on G + H.



Proof. Clearly, R relates every root of G + H to itself. Suppose s →a
G + H and ⟨s, s'⟩∈ R. We consider three cases.
t in

⟨s, s'⟩∈ RG+H : Then s ∈ G and s' ∈ H and ⟨s, s'⟩ ∈ R.  Since R is a
bisimulation, there is a t' ∈ H such that s' →a  t' and ⟨t, t'⟩ ∈ R. Hence,
⟨t, t'⟩∈ RG+H ⊆ R and s' →a t' in G + H.
⟨s, s'⟩∈ (RG+H)-1: Similar.
⟨s, s'⟩∈ ∆G+H : Then s = s' and ⟨t, t⟩ ∈ R.


Hereafter, we will simplify our notation and use R in place of RG+H . Let κ1 :G	 (G + H)/RG+H be the composite

G	 G + H	 (G + H)/R,

and κ2 :H (G + H)/R the analogous map for H. The lemma below (stated without proof) establishes that these maps are in fact morphisms in P. We then prove that ⟨(G + H)/R, κ1, κ2⟩ form a coproduct of G and H in P.
Lemma 4.6 The maps κ1 and κ2 are functional bisimulations.


Theorem 4.7 Let G and H in P(RP, CP, CRP, resp.) be bisimilar. Assume either graph is concise. Then the coproduct of G and H exists in P (RP, CP, CRP, resp.).
Proof. We first prove the result for P. Let ⟨(G + H)/R, κ1, κ2⟩ be given as above. Let S be a graph with functional bisimulations g : G	 S and h :H	 S . 

We show that there is a (necessarily unique) map k : (G + H)/R	 S making the following diagram commute.

(G + H)/R

κ,1,, ¸
,,
¸¸¸¸κ¸¸2¸¸

G ¸¸¸¸¸¸	k
,,,,, H

g ¸¸¸¸¸ J ,,,,,h
zS˛   ,
Let m : G + H  S be the unique Set map such that m ◦ inG = g and m ◦ inH = h. It is easy to check that m is a functional bisimulation. We will show that m respects the bisimulation R. By Corollary 4.3, this gives the
desired unique map k :(G + H)/R      S . 
We prove m respects RG+H. The proof is similar for ⟨s, t⟩ ∈ (RG+H)-1, and trivial for ⟨s, t⟩ ∈ ∆G+H. By definition, ⟨s, t⟩ ∈ RG+H implies s ∈ G, t ∈ H and ⟨s, t⟩ ∈ R. By Lemma 3.4, g(s) = h(t), i.e., m(s) = m(t).
We have completed the proof that this construction yields a coproduct in
P. Suppose, now, that G and H are in RP (CP, CRP, resp.). Then, (G + H)/R is also in RP (CP, CRP, resp.). By fullness and faithfulness of the inclusion, (G + H)/R is a coproduct in RP (CP, CRP, resp.).	 
This coproduct construction may fail without conciseness. Consider again the graph G in Diag. (1) and let R be the swap relation. Then, in (G + G)/R, the two leaf nodes are identified. This is not the coproduct, because there is no functional bisimulation from (G + G)/R to G.

Binary Product
The naive way to construct a product of two process graphs is to start with the Cartesian product G × H and try to define a transition structure so that the projections are functional bisimulations. Very quickly, one realizes this plan is
not feasible. If the projections π1 and π2 were functional bisimulations, then
s ↔ ⟨s, t⟩ ↔ t for all s, t in G. Clearly, that is not the case in general. We arrive at the conclusion that binary product in RP should not contain pairs of
non-bisimilar nodes. Naturally, bisimulation relations become candidates for products.


The situation with products is different from those with coequalizers and coproducts, namely that our construction works only in RP and its subcategory CRP.
Theorem 4.8 Let G and H be restricted process graphs. Assume that G is concise and H is bisimilar to G. Then the binary product of G and H exists in RP.
Proof. By Theorem 3.8, we have the least bisimulation R between G and H. By Theorem 2.10, the projections π1 and π2 are functional bisimulations. We will show that ⟨R, π1, π2⟩ forms a product of G and H.
Let S be any restricted process graph and let g : S G and h : S H be functional bisimulations. By Theorem 3.5, we can define m(s) = ⟨g(s), h(s)⟩ for every reachable s in S. Since S is restricted, m is a total function. We claim that Φ(m) is a bisimulation.
Indeed, let ⟨r, r'⟩ be a root in R. Then r ∈ roots(G) and r' ∈ roots(H). Since Φ(h) is a bisimulation, we can choose r'' ∈ roots(S) such that h(r'') = r'. Notice that g(r'') ∈ roots(G). Moreover, g(r'') ↔ r'' ↔ r' ↔ r. By conciseness of G, we conclude that g(r'') = r; hence there is a root r'' of S such that
m(r'') = ⟨g(r''), h(r'')⟩ = ⟨r, r'⟩.

The proof that Φ(m) satisfies the transition conditions (i) and (ii) from Section 2 proceeds similarly using conciseness of G and definition of the max- imal LTS on R.
Uniqueness of m follows from the fact that π1 and π2 are jointly monic in
Set.
 
In the proof of Theorem 4.8, we used the assumption that S = reach(S) to establish totality of m. Without this assumption, g(s) may be unreachable in G, in which case ⟨g(s), h(s)⟩ must not be in R (due to minimality of R). In other words, m may not be well-defined for unreachable nodes in S. This is the reason for considering only restricted graphs.
It is easy to check that the least bisimulation R between two concise graphs is a concise graph; hence the construction in Theorem 4.8 also works in CRP.

A Categorical Comparison
In this section, we discuss the relationship between the various categories: P (process graphs), CP (concise process graphs), RP (restricted process graphs) and CRP (concise, restricted process graphs). Our main aim is to show that CP

is a reflective subcategory of P. This gives a canonical means of constructing, for each process graph G, a bisimilar concise graph H. This construction should be viewed as an analogue to closure operators on partial orders, with one caveat: The graph H is constructed by taking a quotient of G, not by enlarging G. Following this task, we comment on the categories of restricted process graphs.
We will define a functor conc taking a process graph G to G/∼G, where ∼G
is the least bisimulation such that G/∼G is concise. We begin by describing the bisimulation ∼G.
Let G be a process graph. We define a relation ∼G on G as follows.

∼G = ↔ ∩(roots(G) × roots(G))

G
n+1
= {⟨s, t⟩ | ∃v, u, a u →a
s, v →a
t, u ∼G v and s ↔ t}

∼G =  ∼G

Pictorially, the second clause says that, in a situation


u∼Gv
a J  Ja 
t
(3)

we require s ∼G	t. Note, in particular, that s ∼G t implies both s and t are
reachable.
We omit the proof of the lemma below. It involves induction on the con- struction of ∼G.
Lemma 5.1 For each process graph G, the relation ∼G is a bisimulation.
The process graph G/∼G is constructed according to Corollary 4.3. For each G ∈ P, we define conc(−) = G '→ G/∼G and ηG to be the surjection G G /∼G . As we will see in Lemma 5.3, conc(G) is concise. Note that G is essentially obtained by adding a history variable to conc(G), its “concisifica- tion”. Put another way: conc(G) is constructed by “forgetting” a (fictional)
history variable in G.
First, we show that conc is functorial and η is natural.
Lemma 5.2 Let f : G  H be a functional bisimulation. For each s, t in G, if s ∼G t, then f (s) ∼H f (t). Consequently, the operator conc is functorial and η is a natural transformation IdP   zco nc .
Proof. The first statement can be proved by an easy induction on the defi- nition of ∼G.


For the second, we must define, for each functional bisimulation f : G  H , a functional bisimulation conc(f ): G/∼G   H / ∼H. By Corollary 4.3, it suf- fices to show that the composite

G   f  H ηH H / ∼H
respects ∼G. This is equivalent to the first statement of the present lemma: for all s and t, s ∼G t implies f (s) ∼H f (t).
Naturality of η follows trivially from our definition of conc(f ).

Lemma 5.3 The graph G/∼G is concise.
Proof. If [r], [r'] are roots of G/∼G with [r] ↔ [r'], then r ↔ [r] ↔ [r'] ↔ r'
and hence r ∼G r', i.e., [r] = [r']. We must prove that for every [s] reachable
in G/∼G, if [s] →a  [t] and [s] →a  [t'] and [t] ↔ [t'], then [t] = [t']. It suffices

to show, for any s reachable in G with transitions s →a
t ↔ t' implies t ∼G t'.
p
t and s →a
t', we have

Let r ~ s be given, where r ∈ roots(G). A simple proof by induction

shows that s ∼G
s, where n is the length of p. Thus, t ∼G
t' and hence

t ∼G t'.

Theorem 5.4 CP is a reflective subcategory of P. Explicitly, the functor
conc : P  CP  is left adjoint to the inclusion CP ,˛ P. 
Proof. Let H be concise. By [10, §IV.3], it suffices to show that every func- tional bisimulation f : G  H factors through ηG, i.e., that ηG is universal from G to conc.
By Corollary 4.3, it is enough to prove such f respects the bisimulation
∼G: for all s and t, s ∼G t implies f (s) = f (t). We proceed by induction on the definition of ∼G.

If s ∼G
t, then s and t are bisimilar roots, and the result follows by

conciseness of H. Suppose that s ∼G

t.  Then we have u, v, as in (3).  By inductive

hypothesis, f (u) = f (v), and so we have

f (u)

a c
  jc
,,,a
zz

f (s)  ↔ f (t)

in H. Since u ∼G v, we have u and v are reachable; hence f (u) reachable. Now we apply conciseness of H to conclude f (s) = f (t).	 


One can check that the category RP is a co-reflective subcategory of P via the functor reach : P  RP . Because coequalizers in RP are inherited from P, the reflection conc : P  CP  restricts to a reflection RP  CR P. Similarly, the coreflection reach restricts to a coreflection CP  CR P. Thus, we have the
following commutative square of adjoint functors.
  conc	 

,P ,¸,⊥
E reach
CP
rz
E reach

,r J conc  ,r J 

RP ¸,⊥
CRP
rz

The General Case: Without Conciseness
In this section we prove that minimal bisimulations exist provided both graphs are image finite. Unlike the situation with concise graphs, these minimal bisimulations are not necessarily unique (and hence not least).
We use a variation of Zorn’s Lemma, listed as M'2 in [11].
Lemma 6.1 Let и be a transitive relation on the set S such that every T ⊆ S well-ordered by и has an upper bound and let s ∈ S. Then there is a maximal s' ∈ S such that s и s' or s = s'.
The relevant order here is reverse inclusion. Therefore, we will show that any ordinally-indexed, decreasing chain {Rβ | β ; α} of bisimulations has a lower bound and conclude that there exists a minimal bisimulation. In fact, the situation here is stronger: Any ordinally-indexed, decreasing chain of bisimulations between image finite graphs has a greatest lower bound, given by their set-intersection. Of course, this claim is trivial for chains indexed by successor ordinals. We therefore concentrate on limit ordinals. We begin with some preliminary facts about such ordinals.
Definition 6.2 Let α be a limit ordinal. Let ξ = (xβ | β ; α) be a sequence with range X. Then x ∈ X is said to occur coﬁnally in the sequence ξ if for every β ; α, there is γ such that β ; γ ; α and xγ = x.
It is easy to see that, if we have an α-sequence (α a non-zero limit ordinal) with a finite range, then at least one element in the range must occur cofinally in α in that sequence. This is used to prove the following lemma.
Lemma 6.3 Let α be a limit ordinal. Let S0 ⊇ S1 ⊇ ... ⊇ Sβ ⊇ ... be a decreasing chain of sets indexed by the ordinals below α. Let ξ = (xβ | β ; α) be a sequence such that xβ ∈ Sβ for every β ; α. If ξ has a ﬁnite range then
there is β such that xβ ∈	{Sβ | β ; α}.

Proof. Write x1,... , xn for the elements of the range of ξ. There must be 1 ≤ i ≤ n such that xi occurs cofinally in ξ. Choose such i. Then for each β ; α, we can find β ≤ γ ; α such that xγ = xi (thus xi ∈ Sγ).  Since
{Sβ | β ; α} is a decre asing chain, this impliesxi ∈ Sβ. Therefore, xi ∈ Sβ
for all β ; α, i.e., xi ∈	{Sβ | β ; α}. Now let β be any β such that xβ = xi.
 
In fact, this lemma holds for any sequence ξ whose range has a cardinality strictly below the cofinality of α. For our purposes, a finite range is appro- priate. This allows us to prove that the intersection of a decreasing chain of bisimulations is still a bisimulation.
Lemma 6.4 Let G and H be image ﬁnite process graphs. Let α be a limit ordinal. Let {Rβ | β ; α} be a decreasing chain of bisimulations between G
and H. Then Rα :=	{Rβ | β ; α} is a bisimulation.

Proof. Let r ∈ roots(G) be given. For each β ; α, there exists r'
such that

⟨r, r' ⟩ is in Rβ. Notice that H has finitely many roots (because H is image
finite). Hence {r' | β ; α} is also finite. Be Lemma 6.3, we can choose β
β
'	'

such that ⟨r, rβ ⟩ ∈	{Rβ | β ; α} = Rα. Therefore, there exists r
(namely

r' ) such that ⟨r, r'⟩∈ Rα.

Now suppose we have u →a v in G and ⟨u, u'⟩ in R
α
. For all β ; α, there

exists v' such that u' →a  v' and ⟨v, v' ⟩ is in R
. Since H is image finite,

β	β	β	β

we have {v' | u' →a
v'} is finite; hence {v'
| β ; α} is also finite. By an

argument similar to that in the root case, there exists v' such that u' →a  v'
and ⟨v, v'⟩∈ Rα.
The direction from H to G follows by symmetry.
 
In this lemma, it is necessary that both graphs are image finite. The following illustrates a counterexample in which one of the graphs is not image finite. For each n ∈ N , define Rn to be
{⟨0, 0⟩} ∪ {⟨y, i⟩ | i ∈ N}∪ {⟨z, i⟩ | i ≥ n} .

This defines a decreasing ω-chain of bisimulations, but its intersection is the set {⟨0, 0⟩} ∪ {⟨y, i⟩ | i ∈ N}, which is not a bisimulation.

x,	0,¸¸¸¸¸
a sss ,,,a	a s , ¸¸ ¸¸¸ a ¸ ... 

ss	,,
s	a,,
a ¸¸¸¸ ¸¸¸¸

y rs
ztz
1 rs tz
z  ¸¸z˛


Lemmas 6.4 and 6.1 yield the following.
Theorem 6.5 Let G and H be image ﬁnite process graphs. Suppose R is a bisimulation between them. Then there is R' ⊆ R such that R' is a minimal bisimulation between G and H.
Again it is necessary for both graphs to be image finite. We have already seen a counterexample in Fig. 1.
It is not hard to find examples in which minimal bisimulations are not unique. Figure 2 and Diag. (1) give two such examples. Figure 3 provides another.
cc· ,,,

cc· ,,,,
cc· ,,,cc
,,,,

cccc
,,,
cccc · cc j,,,c,
,z· z

· c jc
,z· z

·J 

J 
.
 c jc
,¸
·J 

J 
.
,z· z	,¸

·J 

J 
.

Fig. 3. Non-isomorphic minimal bisimulations: the identity relation ∆ and the relation R indicated by the dotted lines

Notice that in Diag.(1), although the identity relation and the swap re- lation are different sets of ordered pairs, the maximal LTS’s on them are isomorphic. However, in Figs. 2 and 3, the minimal bisimulations differ in an irreparable way (i.e., the maximal LTS’s on them are not isomorphic).
Unfortunately, since these minimal bisimulations are not least, we cannot extend directly the results in Sect. 3 about binary products and coproducts. However, our conjecture is that there is always a suitable minimal bisimulation that will give rise to product. A bisimulation R on G and H is “suitable” if, for
every bisimulation R' on G and H, there is a (necessarily unique) functional
bisimulation R'   R making the diagram (in Set) below commute.


R' ¸¸
¸¸¸¸¸
 R 

¸¸zJ 
G × H
Here, we are viewing R and R' as process graphs with maximal LTS’s, as in Sect. 2. In other terms, R is suitable iff it is the “greatest” bisimulation under
≤FB (which is quite different than the greatest bisimulation under ⊆).


In every example we have considered so far, such a suitable minimal bisim- ulation does exist. Thus we aim to produce a proof (or preferably an algorithm to search for such a bisimulation) as we continue this line of work.

Checking Conciseness
Finally, we consider a practical issue, namely how to decide whether a given graph is concise. For that end, one can modify the definition of conciseness in the following way:
Definition 7.1 Let I(s) denote the set of initial actions of node s in G. A graph G is said to be obviously concise if
for distinct roots r1 and r2 of G, I(r1) /= I(r2);
given s, t1 and t2,


(s →a
t and s →a
t2 and t1 /= t2) ⇒ I(t1) /= I(t2).


With the original definition, deciding conciseness has the same complexity as deciding bisimilarity. This modified definition eliminates the need to check t1 — t2; instead, the checking algorithm needs only look up and compare the
two records I(t1) and I(t2). In other words, the modified definition is a local
property of the individual nodes, whereas the original definition is much more global.
Assuming the action alphabet is finite, there is an algorithm to traverse a finite graph and perform the local check described above. This algorithm will be linear in the size of the graph.
It is clear that obviously concise graphs are concise. In practice, the spec- ification of a concurrent system often generates a relatively small state graph; hence it will be feasible to check whether the specification is (obviously) con- cise. This raises hope that we can apply our results about least bisimula- tions to prove properties between a specification and its implementation, even though the latter may not be concise.

Conclusions and Future Work
To begin, it is clear that our work here is preliminary. We offer an introductory investigation into what seems a natural category of process graphs. The final judgment on whether concise process graphs are useful or interesting requires more investigation. For example, we are hopeful that constructions involving concise graphs will lead to proof principles for history relations.


Aside from such broad aims, our work here leaves open a number of specific questions. First of all, we are not completely satisfied with Theorem 3.8. It says that conciseness characterizes the existence of least bisimulations under the reachable part construction. However, it is unclear whether conciseness is also a characterization for general existence, i.e., without reference to any particular construction. It would be nice to find a necessary and sufficient condition on G so that the least bisimulation between G and H exists for any bisimilar H.
Moreover, as mentioned at the end of Section 6, it is not known to us whether there is always a greatest (with respect to ≤FB) bisimulation. If that answer is positive, we can extend the binary product and coproduct
constructions to image finite bisimilar graphs.
Another natural extension of this work is to incorporate τ steps and to study some form of weak functional bisimulations. The definition of concise- ness needs to be reformulated to take into account nodes on a τ -path (i.e., internal states). For example, we may consider functional branching bisimula- tion and require, in addition to conciseness, that a process graph contains no inert τ -steps. In order to reuse our proofs, we must also find an appropriate notion of path correspondence analogous to Lemma 2.2. A good candidate is that of index relations, introduced by Griffioen and Vaandrager in [7].
Finally, we would like to compare our categories of process graphs to the well-developed models of parallel computation in [8]. On the one hand, one may ask whether conciseness leads to useful subcategories in their setting. That is, whether conciseness yields interesting constructions if we take our morphisms to be (generalizations of) functional simulations as in [8]. On the other hand, we can use the approach taken in [4] as a guideline for our consideration of weak bisimulations.




Acknowledgments

We thank Jan Willem Klop, whose ideas initiated this exercise, for many useful discussions. We also thank Frits Vaandrager for reading a draft of this paper and providing valuable suggestions. The definition of obviously concise graphs and subsequent observations in Sect. 7 are also due to him.
Finally we thank the anonymous referees of this paper and those mem- bers of the concurrency mailing list (available at concurrency@cwi.nl) who responded to our questions regarding this paper.

References
Ariola, Z.M., Klop, J.W., Equational term graph rewriting. Fundamenta Informaticae 26
(1996) 207–240
Caspi, P., Fernandez, J.C., Girault, A., An algorithm for reducing binary branchings. In: FST-TCS Bangalore. Lecture Notes in Computer Science, Springer Verlag (1995)
Fernandez, J.C., Jard, C., J´eron, T., Mounier, L., “On the fly” verification of finite transition systems. Formal Methods in System Design (1992)
Fiore, M.P., Cattani, G.L., Winskel, G.: Weak bisimulation and open maps. In: Logic in Computer Science. (1999) 67–76
Glabbeek, R.v., The linear time – branching time spectrum I; the semantics of concrete, sequential processes. In Bergstra, J., Ponse, A., Smolka, S., eds.: Handbook of Process Algebra. Elsevier (2001) 3–99 Available at http://boole.stanford.edu/pub/spectrum1.ps.gz .
Glabbeek, R.v., Weijland, W., Branching time and abstraction in bisimulation semantics.
Journal of the ACM 43 (1996) 555–600
Griffioen, W., Vaandrager, F., A theory of normed simulations. Technical Report CSI-R0013, Computing Science Institute, University of Nijmegen (2000)
Joyal, A., Nielsen, M., Winskel, G., Bisimulation from open maps. Technical Report RS-94-7, BRICS (1994)
Lynch, N., Vaandrager, F.,  Forward and backward simulations part I: Untimed systems.
Information and Computation 121 (1995) 214–233
Mac Lane, S., Categories for the Working Mathematician. Graduate Texts in Mathematics. Springer-Verlag (1971)
Rubin, H., Rubin, J., Equivalents of the Axiom of Choice. North-Holland Publishing Company (1963)
Taylor, P., Practical Foundations of Mathematics. Cambridge University Press (1999)
