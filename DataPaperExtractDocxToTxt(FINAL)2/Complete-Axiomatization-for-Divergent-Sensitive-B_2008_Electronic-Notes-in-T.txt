Electronic Notes in Theoretical Computer Science 212 (2008) 55–70	
www.elsevier.com/locate/entcs

Complete Axiomatization for Divergent-Sensitive Bisimulations in Basic
Process Algebra with Prefix Iteration 1
Taolue Chen2
CWI, Department of Software Engineering,
PO Box 94079, 1090 GB Amsterdam, The Netherlands
Jian Lu3
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China, 210093

Abstract
We study the divergent-sensitive spectrum of weak bisimulation equivalences in the setting of process alge- bra. To represent the infinite behavior, we consider the prefix iteration extension of a fragment of Milner’s CCS. The prefix iteration operator is a variant on the binary version of the Kleene star operator obtained by restricting the first argument to be an atomic action and allows us to capture the notion of recursion in a pure algebraic way. We investigate four typical divergent-sensitive weak bisimulation equivalences, namely divergent, stable, completed and divergent stable weak bisimulation equivalences from an axiomatic perspective. A lattice of distinguishing axioms is developed and thus pure equational axiomatizations for these congruences are obtained. A large part of the current paper is devoted to a considerable complicated proof for completeness. This work, to some extent, sheds light on distinct semantics of divergence.
Keywords: Concurrency, Process Algebra, Axiomtization, Prefix Iteration, Divergence, Bisimulation


Introduction
Labeled transition systems constitute a widely used model of concurrent computa- tion. They model processes by explicitly describing their states and their transitions from state to state, together with the actions that produce these transitions. Sev- eral notions of behavioral semantics have been proposed, with the aim to identify

1 This work is partially supported by the Dutch Bsik project BRICKS, the Chinese national 863 program (2007AA01Z178), NSFC (60736015) and JSNSF (BK2006712).
2 Email: chen@cwi.nl
3 Email: lj@nju.edu.cn

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.053

those states that afford the same observations. The lack of consensus on what con- stitutes an appropriate notion of observable behavior for reactive systems has led to a large number of proposals for behavioral semantics for concurrent processes. In light of this, one of the main tasks of concurrency theory is to provide a uniform classification of system (or process) behavior. This forms the study of comparative concurrency semantics, which has, in a large sense, cumulated in van Glabbeek’s celebrated linear time-branching time spectrum [6][7]. Technically speaking, his spectrum has two parts, one deals with concrete processes (without silent moves)
[6] while the other explores processes with abstraction (silent moves) [7]. The cur- rent paper focuses on the latter. Basically, the spectrum in [7] enjoys two-dimension structure: the “vertical” dimension spans between trace equivalence and branching bisimulation, which identifies different ways to discriminate processes according to their linear or branching structure. Due to the presence of silent moves, this spec- trum is spread in “horizontal” dimension as well, determined by the semantics of divergence. In a nutshell, a process is divergent if the associated labeled transition system exhibits infinite silent move loops. A distinct characteristic of traditional weak bisimulation [12] lies in that it is possible for two processes, exactly one of which is divergent, to be bisimulation equivalent. However, this incurs some criti- cism since it may be useful and appropriate in circumstances not to disregard the presence of such silent move loops. In light of this, in the fragment spanning from weak bisimulation to branching bisimulation, several different criteria to distinguish divergence are proposed, which induces a “horizontal” lattice, and this lattice ap- pears for all the bisimulation relations.
To give further insight into the identifications made by the respective behavioral equivalences in the spectrum, one of the classical research topics in concurrency theory is to study them in the setting of the process algebra, which often provides an elegant way to compare semantics, by presenting distinguishing axioms that capture the essence of the semantics. For instance, van Glabbeek [6] studied his spectrum axiomatically in the setting of process algebra BCCSP, which contains only the basic process algebraic operators from CCS and CSP. For the “vertical” dimension of the spectrum, the distinguishing axioms are well-known (see, e.g. [12][8]). However, it is fair to say that the “horizontal” dimension receives relatively less attention. We believe that this is mainly due to the fact that divergence only makes sense in the presence of recursion, while recursion is often hard to tackle axiomatically. With this in mind, the current paper aims at investigating the divergent-sensitive spectrum of weak bisimulation equivalences from an axiomatic perspective and thus enriches the research on this aspect to some extent.
Note that for this purpose, BCCSP does not suffice any more, since it lacks the silent moves, which prevents us from studying weak semantics and lacks operators expressing infinite behavior, which impedes the characterization of divergence. In light of this, we consider the iteration-like extension of some basic process languages which paves the way to bring an axiomatic treatment into the “vertical” dimension of the spectrum. Generally, Kleene [10] defined a binary operator -*- in the context of finite automata, called Kleene star or iteration. Intuitively, the expression P∗Q

can choose to execute either P , after which it evolves into P∗Q again, or Q, after which it terminates. An advantage of the Kleene star is that on the one hand it can express recursion in a very natural way, but that on the other hand one can capture this operator by equational laws, thus can take an pure algebraic theory into account (see [2] for thorough discussions). Hence, one does not need meta-principles, such as Unique Fixpoint Induction Principle [11] (a.k.a. Recursive Speciﬁcation Principle). Unfortunately general Kleene star operator is so powerful that it often obstructs a complete finite equational axiomatization even under very mild assumptions, c.f. [13]. In light of this, one way to obtain an equational axiomatization is to restrict the range of the terms that might occur at the left-hand side of the binary Kleene star. We consider the preﬁx iteration, introduced by Fokkink [4], a variant on the binary version of the Kleene star operator obtained by restricting the first argument of P∗Q to be an atomic action. We think the prefix iteration provides us a suitable context to explore the divergent-sensitive bisimulation equivalences since it is a tradeoff between the expressive power of the underlying language and the axiomatizability of interesting bisimulation congruences. For more works on prefix iteration and Kleene star in general, we refer the readers to [4][1][2] and the references therein.
This paper develops a lattice of distinguishing axioms to characterize four typical semantics of divergence in the “horizontal” dimension of weak bisimulation equiva- lences, namely, divergent, stable, completed and divergent stable weak bisimulations. A large part of the paper is devoted to a considerable complicated proof for com- pleteness w.r.t. a fragment of CCS with prefix iteration. This work helps us with in-depth understanding on distinct semantics of divergence.
The rest of paper is set up as follows: Section 2 presents basic notions regarding the language of basic CCS with prefix iteration and its operational semantics. Sec- tion 3 provides the definition of four divergent-sensitive bisimulation equivalences. The axiomatization and the completeness proof are given in Section 4. The paper is concluded in Section 5, where related works are also discussed.
Preliminaries
We assume a non-empty, countable set A of observable actions not containing the distinguished symbol τ . Following Milner, the symbol τ will be used to denote an internal, unobservable action (silent move) of a system. We write Aτ for A ∪ {τ }, and use a, b to range over A and α, β to range over Aτ . Note that we follow this convention strictly, so for any a ∈ A, a /= τ . We also assume a countably infinite set of process variables V , ranged over by x, y, z, that is disjoint from Aτ .
The language of basic CCS with prefix iteration, denoted by BCCSp∗(Aτ ), is given by the following BNF grammar:
P ::= x | 0 | α.P | P + P | α∗P

where x ∈ V and α ∈ Aτ . The set of closed terms, i.e. terms that do not contain occurrences of process variables, generated by the above grammar will be denoted by T(BCCSp∗(Aτ )). We shall use P, Q (possibly subscripted and/or superscripted)



P →α P'
Q →α Q'
P →α P'

α.P →α P


P + Q →α P'
P + Q →α
Q'	α∗P →α
α∗P


β∗P →α P'


Fig. 1. Operational Semantics.

to range over T(BCCSp∗(Aτ )).
The operational semantics for the language BCCSp∗(Aτ ) is given by the labeled
transition system < T(BCCSp∗(Aτ )), {→α | α ∈ Aτ } >, where →α satisfies the rules
in Fig. 1. Following Milner [12], the derived transition relation ⇒ is defined as the

reflexive, transitive closure of →τ
as follows:
⇒α d=ef ⇒→α ⇒, and
→  ), and ⇒, ⇒
are defined in the standard way

⇒αˆ d=ef ⎧⎨
⇒	if α = τ

⎩ ⇒α
o.w.



We also write P
→/ τ
if P can not issue a τ transition; and P /→ if P does not

have any transition (a.k.a. deadlock).
Definition 2.1 [Weak Bisimulation] A binary relation Y over T(BCCSp∗(Aτ )) is
a weak bisimulation if it is symmetric and whenever PYQ and P →α P', then Q'

exists s.t. Q ⇒αˆ
Q' and P'YQ'. Two process terms P, Q are observation equivalent,

denoted by P ≈ Q, if there exists a bisimulation Y s.t. PYQ.

Divergent-Sensitive Weak Bisimulations
To lift the standard definition of weak bisimulation (Definition 2.1) to divergent- sensitive variants, we first define a few properties that a term may or may not have. We shall use a suffix notation for these properties. Namely, for any term P and
  a property of P , we write P  . We shall define the properties ⇑, σ, ⊥ and F
respectively, as follows. Note that in the remainder of this paper,   ranges over
{⇑, σ, ⊥, F} unless stated otherwise.
Definition 3.1 For any term P ,

P ⇑ (P is divergent) if there exist Pi for i ∈ N such that P →τ
Pσ (P is stable) iff P /→τ ;
P⊥ (P is complete) iff P /→; and
P1 →τ
P2 ··· ;

P F (P is divergent stable) if P ⇑ or there exists some P' such that P ⇒ P' with
P'⊥.
We are now in a position to introduce the divergent-sensitive bisimulation equiv- alences studied in this paper.

Definition 3.2 [Divergent-Sensitive Weak Bisimulation] We say that a symmetric relation Y preserves a property  , if

if (P, Q) ∈Y and P  , then ∃Q'.Q ⇒ Q' 

A weak bisimulation Y is a  -weak bisimulation if it preserves  .
As usually, two process terms P, Q are  -observation equivalent, denoted by
P ≈  Q, if there exists a  -bisimulation Y  s.t. PY Q, where  ∈ {⇑, σ, ⊥, F}.
≈⇑ (resp. ≈σ, ≈⊥, ≈F) is called a divergent (resp. stable, completed, divergent stable)-observation equivalent.
The following theorem states the relationship among the four divergent-sensitive bisimulation equivalences.
Theorem 3.3 ≈⇑ ⊂ ≈σ ⊂ ≈⊥ ⊂ ≈ and ≈⇑ ⊂ ≈F ⊂ ≈.
As is well-known [12], ≈ is an equivalence relation. However, it is not a congru- ence w.r.t. summation operator or preﬁx iteration operator. The same applies to
≈ . A standard solution is to introduce the so called rooted conditions, thus the
coarsest congruence which is contained in ≈ (≈  ) can be obtained, respectively.
Definition 3.4 [Observation	Congruence]	For	all	process	terms	P, Q	∈
T(BCCSp∗(Aτ )), P  Q iff for any α ∈ Aτ ,

If P →α
If Q →α
P', then Q' exists s.t. Q ⇒α
Q', then P' exists s.t. P ⇒α
Q', s.t. P' ≈ Q'.
P', s.t. P' ≈ Q'.

In the same vein, we define P   Q iff for any α ∈ Aτ ,

If P →α
If Q →α
P', then Q' exists s.t. Q ⇒α
Q', then P' exists s.t. P ⇒α
Q', s.t. P' ≈  Q'.
P', s.t. P' ≈  Q'.

Axiomatization and Completeness
One of main aims of the current paper is to give complete equational axiomatizations for divergent-sensitive observation congruences introduced in previous section. We first present a lattice of axiomatic systems. The axiomatic system F is the one that is shown in [4] to characterize strong bisimulation, which is given in Fig. 2. In addition, [1] extends it with two of Milner’s standard τ -laws and three auxiliary equations that describe the interplay between the silent nature of τ and prefix iterations, part of which is reported in Fig. 3. Moreover, we provide new axioms for different divergent-sensitive observation congruences, which are reported in Fig. 4. For  ∈ {⇑, σ, ⊥}, we let E denote the system F and those axioms in Fig. 3 plus axiom  from Fig. 4. For  =F, EF consists of E⇑ plus axiom F from Fig. 4.
For an axiomatic system T , we write T ▶ P = Q iff the equation P = Q is provable from the axiomatic system T using the rules of standard equational logic.
Often for convenience, we omit T and abbreviate it as ▶ P = Q. We write P =X Q




Fig. 4. Distinguishing laws.

as a short-hand for A1, A2,X ▶ P = Q. We use P =AC Q to denote that P and Q
are equal modulo associativity and mutativity of +, i.e. A1, A2 ▶ P = Q.
Some remarks are in order: In [1], among others, the traditional weak bisimula- tion [12] is considered where along with the axioms in Fig. 3, an important axiom τ∗x = τ.x is also introduced. This is an equational formulation of Koomen’s Fair Abstraction Rule, representing Milner’s “fair” setting, where divergence is never distinguished. However, it does not hold in our setting, which is the tenet of divergent-sensitive bisimulations. This has a far-reaching effect on the axiomati- zation, since we have to provide distinguishing axioms ⇑, σ, ⊥ and F to make up the lose of it. And as we will see later, this complicates the completeness proof in a large extent.
The soundness of all these axiomatic systems is obvious. The remainder of the section is devoted to the proof of completeness.

Completeness
Lemma 4.1 If Pn α⇒n Pn+1 for n = 0, 1, ··· , then there exists some N such that
αn = αN for n > N.
Proof. By structure induction on terms.	 
Remark 4.2 This lemma crucially depends on the simplicity of prefix iteration. It fails in presence of some more complicated construction, say, flat iteration, where (a + τ )∗P is allowed.
The following lemma is essentially [1, Lemma 2.11], which is for traditional weak bisimulation, since ≈ ⊂≈ for any  ∈ {⇑, σ, ⊥, F}.
Lemma 4.3 Let a, b ∈ A. If a∗P ≈  b∗Q, where  ∈ {⇑, σ, ⊥, F}, then a = b.
Lemma 4.4 The following properties hold:
If τ∗P ≈⇑ a∗Q, then P ⇑.
If τ∗P ≈σ a∗Q, then P →τ .
If τ∗P ≈F a∗Q, then P F.
Proof. [Sketch] First, we note that according to Lemma 4.1, for any term P and
a ∈ A, it can not be the case that

P ⇒τ ⇒a ⇒τ ⇒a
· · ·

Namely, P can not exhibits an infinite sequence where a and τ alternate.
Since τ∗P ⇑ and τ∗P ≈⇑ a∗Q, a∗Q ⇑ and thus Q ⇑. Namely, there exists

Q = Q0 →τ
Q1 ··· . Since τ∗P ≈⇑ a∗Q, there exists τ∗P ⇒ P1 ··· such that for

each i, Qi ≈⇑ Pi. Assume, towards a contradiction, that P /⇑. Then it must be the case that for any i ≥ 1, Pi = τ∗P . Namely, Qi ≈⇑ τ∗P ≈⇑ a∗Q for each
i. It follows easily that there exists some N , such that for any n > N , τ∗R =
Qn = Qn+1 = ··· for some R. Namely, Q ⇒τ τ∗R with τ∗R ≈⇑ τ∗P ≈⇑ a∗Q.

Furthermore, since a∗Q →a
a∗Q →a
a∗Q ··· and τ∗R ≈⇑ a∗Q, it must be the

case that R ⇒a
R1 ⇒a
R2 ··· such that for any i ≥ 1, a∗Q ≈⇑ Ri. Then there

exists some N such that for any n > N , a∗S = Rn = Rn+1 = ··· . Hence
a∗S ≈⇑ a∗Q ≈⇑ τ∗P , and Q ⇒τ  τ∗R ⇒a a∗S.
Applying the aforementioned argument on τ∗P ≈⇑ a∗S, we can construct

a sequence of transitions from Q such that Q ⇒τ ⇒a ⇒τ ⇒a
contradiction.
··· , which leads to a

Since τ∗P
→τ , a∗Q →τ , and thus Q →τ . Namely, there exists Q = Q0 →τ
Q1.

Since τ∗P ≈σ a∗Q, there exists τ∗P ⇒ P1 such that Q1 ≈σ P1. Assume, towards a contradiction, that P /→τ . Then it must be the case that P1 = τ∗P . Namely, Q1 ≈σ τ∗P ≈σ a∗Q. Repeat the same argument, we can build a
sequence of transitions such that Q0 →τ  Q1 →τ  Q2 ··· and for each i, Qi ≈σ
τ∗P ≈σ a∗Q. Now we can reuse the similar argument as in the previous case and the conclusion follows.

Similar to Case (i).

Lemma 4.5 (Absorption Lemma) For any P, Q ∈ T(BCCSp∗(Aτ )), if P ⇒α
then S  ▶ P = P + α.P' for  ∈ {⇑, σ, ⊥, F}.

 
P',

Proof. By induction on the length of the derivation P ⇒α
P'.  The details are

standard.	 
Following a long-established tradition of the literature on process theory, we first identify a subset of process terms of a special form, namely the normal forms (nfs in short).
Definition 4.6 The definitions of ⇑-nf, σ-nf, ⊥-nf and F-nf are in order:
The set of ⇑-nfs is the smallest subset including process terms having one of the following two forms:
α .P , where the term P are themselves ⇑-nfs; or
α∗(  i∈I αi.Pi), where the term Pi are themselves ⇑-nfs and if α = τ , Pi /⇑
for each i ∈ I.
The set of σ-nfs is the smallest subset including process terms having one of the following two forms:
α .P , where the term P are themselves σ-nfs; or
α∗(	i∈I αi.Pi), where the term Pi are themselves σ-nfs and α = τ , for each
i ∈ I, αi /= τ .
The set of ⊥-nfs is the smallest subset including process terms having one of the following three forms:


a∗(
τ∗0.
i∈I αi.Pi) for some a ∈ A where the term Pi are themselves ⊥-nfs; or

The set of F-nfs is the smallest subset including process terms having one of the following two forms:
Σi∈I αi.Pi, where the term Pi are themselves F-nfs; or

α∗(Σ

i∈I
αi.Pi), where the term Pi are themselves F-nfs and if αi = τ , Pi /⇒τ 0

or Pi /⇑ for each i ∈ I.
Note that below I, J are often used to denote finite index sets and recall that the empty sum represents 0.
Lemma 4.7 Each term can be proven equal to a  -nf using axioms in S .
Proof. [Sketch] By induction on the structure of the term. We only present some interesting case.
(⇑) The only interesting case is P = τ∗P'. Then by induction we can rewrite P'
as a ⇑-nf, which is, still, denoted by P'. If P' /⇑, then we are done; Otherwise
P' ⇑, then there exists some P' →τ  P1 →τ  P2 ··· . Clearly, it must be the case

that for some n, Pn is of the form Pn = τ∗S, with P' ⇒τ S⇑ ▶ P' = P' + τ.τ∗S. It follows that
S⇑ ▶ τ∗P' = τ∗(P ' + τ.τ∗S)
= τ∗(P ' + τ.τ∗S + τ∗S)
=⇑ τ.(P ' + τ.τ∗S + τ∗S)
= τ.(P ' + τ.τ∗S)
= τ.P '
Note that τ.P ' is a ⇑-nf, since P' is a ⇑-nf. We are done.
τ∗S. By Lemma 4.5,

(σ) The only interesting case is P = τ∗P'. Then by induction we can rewrite P' as a
⇑-nf, which is, still, denoted by P'. If P' /→τ , then we are done; Otherwise P' →τ , then it must be the case that Sσ ▶ P' = P' + τ.S.

Sσ ▶ τ∗P' = τ∗(P ' + τ.S) =σ τ.(P ' + τ.S) = τ.P '

(⊥) The only interesting case is P = τ∗P'. Then by induction we can rewrite P' as a
⊥-nf, which is, still, denoted by P'. If P' /⇒a for any a ∈ A, then we are done; Or
P' ⇒a S for some a, then by Lemma 4.5, S⊥ ▶ P' = P' + a.S. It follows that

S⊥ ▶ τ∗P' = τ∗(P ' + a.S) =⊥ τ.(P ' + a.S) = τ.P '

The only interesting case is P = τ∗P'. Then by induction we can rewrite P' as a F-nf, which is, still, denoted by P'. If P' /F, then we are done; Otherwise, either P' ⇒ P '' with P ''⊥ or P' ⇑. We distinguish these two cases:
P' ⇑. Then following the argument in case (⇑), we can obtain that SF ▶ P =
τ.P ', which is what we desire.
P' ⇒ P '' with P ''⊥.  Clearly, SF ▶ P '' = 0.  By Lemma 4.5, SF ▶ P' =
P' + τ.P '' = P' + τ.0. It follows that

S ▶ τ∗P' = τ∗(P ' + τ.0) =F τ∗.(P ' + τ∗0) =⇑ τ.(P ' + τ∗.0) =F τ.(P ' + τ.0) = τ.P '
 
In the proof of the completeness result to come, we shall make use of a weight function w : T(BCCSp∗(Aτ )) → N . This is defined by structure induction on terms as follows:

Proposition 4.8 For all P, Q ∈ T(BCCSp∗(Aτ )), if P ≈  Q, then S  ▶ τ.P =
τ.Q.
Proof. First note we shall separate the proof for each  when it is necessary. And
▶ P = Q denotes generically S  ▶ P = Q.  By Lemma 4.7, it is sufficient to assume that P and Q are  -observation equivalent normal forms and we show that

τ.P = τ.Q by induction on w(P )+ w(Q). Recall that  -nfs can take the following two forms:
Σ αi.Pi	or	α∗(Σ αi.Pi)
i∈I	i∈I
where the Pi are themselves  -nfs. So, in particular, P and Q have one of these forms. By symmetry, it is sufficient to deal with the following three cases:
P = Σi∈I αi.Pi and Q = Σj∈J βj.Qj.
P = α∗(Σi∈I αi.Pi) and Q = β∗(Σj∈J βj.Qj).
P = Σi∈I αi.Pi and Q = α∗(Σj∈J βj.Qj). We treat these three cases separately.
CASE: P = Σi∈I αi.Pi and Q = Σj∈J βj.Qj. Consider a summand αi.Pi of

P , it gives rise to a transition P
→αi
Pi, and hence since P ≈
Q, we can

distinguish two subcases in the proof:
αi• α /= τ . Then we have Q ⇒ Q' and P ≈

Q'. Since both Pi

and Q' are in

normal form and w(Pi)+ w(Q') < w(P )+ w(Q), by induction, ▶ τ.Pi = τ.Q'. It follows that
▶ Q = Q + αi.Q'	(Lemma 4.5)
T=1 Q + αi.τ.Q'
= Q + αi.τ.Pi
T=1 Q + αi.Pi
Thus we can obtain that ▶ Q = Q + Σαi/=τ αi.Pi.
αi = τ .  Then either Q ⇒τ  Q' or Q = Q', in both cases, Pi ≈  Q'.  By
induction, ▶ τ.Pi = τ.Q'.  For the first case, it can be easily shown that
▶ Q = Q + τ.Pi. In the second case one has ▶ τ.Pi = τ.Q.
In summary, for i ∈ I, we have either τ.Q = αi.Pi or Q = Q+αi.Pi. It follows
that ▶ Q+ P = Q+	{i|αi/=τ} αi.Pi +	{i|αi=τ} αi.Pi = Q+	k∈K τ.Q for some index set K = {k | αk = τ and Pi ≈  Q and k ∈ I}. Consequently we have

▶ τ.(P + Q) = τ.(Q +
therefore ▶ τ.P = τ.Q.

k∈K
τ.Q)	=	τ.Q. Symmetrically ▶ τ.(P + Q) = τ.P ,

CASE:P =AC α∗(	i∈I αi.Pi) and Q =AC β∗(	j∈J βj.Qj). We have the fol- lowing subcases:
α, β ∈ A. Then by Lemma 4.3, it must be the case that a = b. For conve- nience, we write P1 = Σi∈I αi.Pi and Q1 = Σj∈J βj.Qj, then P = a∗P1 and

Q = a∗Q1. For each transition P
three cases in the proof:
→αi
Pi, since P ≈
Q, we can distinguish

· P1
→αi
Pi and αi
/= a, τ . Then it must be Q1
⇒αi
Q' and Pi ≈
Q'.  By

induction, ▶ τ.Pi = τ.Q'. Following the same lines as in CASE (1), we have
▶ Q1 = Q1 + αi.Pi. Thus we can obtain that ▶ Q1 = Q1 + Σ{i|αi/=τ,a} αi.Pi.

· P1 →a
Pi. Then there are three subcases:

Q1 ⇒a
Q' and Pi ≈  Q'. Then by induction, ▶ τ.Pi = τ.Q', it follows that

▶ Q1 = Q1 + a.Pi;
Q →a  Q, Q1 ⇒τ  Q' and Pi ≈  Q'.  Then by induction, ▶ τ.Pi = τ.Q'.
Moreover, we have ▶ Q1 = Q1 + τ.Pi. Thus we can show that ▶ Q1 =
Q1 + Σk∈K1 τ.Pk for some index set K1 ⊆ {k | αk = a and k ∈ I};
Q →a  Q and Pi ≈  Q. Then by induction, ▶ τ.Pi = τ.Q, thus ▶ a.Pi =
a.τ.Pi = a.τ.Q = a.Q.
Therefore, from (i)(ii)(iii), we can conclude that ▶ Q +	a.P = Q1 +  {i|αi=a} a.Pi for the index set K1 and some index set K2, where K1, K2 ⊆ {k | αk = a and k ∈ I} and K1 ∩ K2 = ∅. Moreover, ▶ Q1 = Q1 +  k∈K1 τ.Pk and ▶ τ.Pk = τ.Q for k ∈ K2. Note that in the sequel, we
write K = K1 ∪ K2.

· P1 →τ
Pi. Then either Q1 ⇒τ
Q' or Q = Q' (note that a /= τ ). In both cases,

Pi ≈ Q'. By induction, ▶ τ.Pi = τ.Q'. For the first case, it can be easily shown that ▶ Q1 = Q1 + τ.Pi. In the second case one has ▶ τ.Pi = τ.Q. Thus we have ▶ Q1 +  l∈L τ.Q = Q1 +  {i|αi=τ} αi.Pi for some index set L = {l | αl = τ and Pl ≈  .Q and l ∈ I}.
Combining the above three cases, actually we have ▶ Q1 + P1 = Q1 +
Σl∈L τ.Q + Σk∈K1∪K2 a.Pk. Moreover
▶ Q1 = Q1 + Σ τ.Pk	(1)
k∈K1
▶ τ.Pk = τ.Q	for k ∈ K2	(2)
It follows that
▶ a∗(P1 + Q1) = a∗(Q1 + Σ τ.Q +	Σ	a.Pk)
l∈L	k∈K1∪K2

(=1) a∗(Q
+ Σ τ.Q + Σ a.Pk
+ Σ a.Pk
+ Σ τ.Pk)

l∈L
k∈K1
k∈K2
k∈K1

P=T3 a∗(Q1 + Σ τ.Q + Σ τ.Pk + Σ a.Pk)

l∈L
k∈K1
k∈K2

(=1) a∗(Q + Σ τ.Q + Σ a.P )
k

l∈L

Now, we have to distinguish two cases:
· If K2 /= ∅, then we have
k∈K2

▶ a∗(P1 + Q1) = a∗(Q1 + Σ τ.Q + Σ a.Pk)
l∈L	k∈K2

(=2) a∗(Q
+ Σ τ.Q + a.Q)
l∈L

P=A1 a∗(Q + Σ τ.Q)
l∈L
We proceed by considering the following two subcases:

L = ∅. Then ▶ a∗(P1 + Q1) = a∗Q P=B1 Q. L /= ∅. Then it follows that
▶ a∗(P1 + Q1) = a∗(Q + Σ τ.Q)
l∈L
T=2 a∗(τ.Q)
= a∗(τ.a∗Q1)
P=T2 τ.Q
· If K2 /= ∅, then actually ▶ a∗(P1 + Q1) = a∗(Q1 +	l∈L τ.Q). Similarly, we also proceed by considering the following two subcases:
L = ∅. Then ▶ a∗(P1 + Q1) = a∗Q1 = Q.
L /= ∅. Then it follows that
▶ a∗(P1 + Q1)	=	a∗(Q1 + Σ τ.Q)
l∈L
A3=,T2 a∗(Q + τ.Q + a∗Q )

P=A1
a∗(Q1 + τ.Q + a.a∗Q1 + Q1)

A3=,PA1 a∗(τ.Q + Q)

T=2 P=T2
a∗(τ.a∗Q1) τ.Q

From above, we can conclude that either ▶ τ.Q = a∗(P1 + Q1) or ▶ Q =
a∗(P1 + Q1). Symmetrically ▶ τ.P = a∗(P1 + Q1) or P = a∗(P1 + Q1). For each of four combinations, clearly, we have ▶ τ.P = τ.Q, possibly using T1.
α = τ and β ∈ A. The proof is parametric by ⇑, σ, ⊥ and F.
(⇑) Since P and Q are in ⇑-nfs, for each i ∈ I, αi.Pi /⇑.	According to Lemma 4.4(i), this case is actually vacuous.
(σ) Since P and Q are in σ-nfs, for each i ∈ I, αi /= τ .	According to Lemma 4.4(ii), this case is actually vacuous.
(⊥) Since P and Q are in ⊥-nfs, for each a ∈ A, P /⇒a . However, since β∗Q β

β∗Q where β ∈ A, τ∗P β
P' for some P' with P' ≈
β∗Q. This is clearly

a contraction, and thus this case is actually vacuous.
(F) Since P and Q are in F-nfs, (	i∈I αi.Pi) /F. According to Lemma 4.4(iii), this case is actually vacuous.
α = β = τ . The proof is parametric by ⇑, σ, ⊥ and F. For brevity, let P1
denote Σi∈I αi.Pi and Q1 denote Σj∈J βj.Qj.
αi
(⇑) Since P and Q are in ⇑-nfs, P1 /⇑ and Q1 /⇑. For each i ∈ I, P1 → P , clearly,

it must be the case that Q
αi Q'
with P ≈	Q' . Since w(P + Q' ) <

1 ⇒	1
i	⇑	1	i	1

w(P )+ w(Q). By induction, S⇑ ▶ τ.Pi = τ.Q' . By Lemma 4.5, S⇑ ▶ Q1 =
Q1 + αi.Q' .  It follows that S⇑ ▶ Q1 = Q1 + αi.τ.Q' = Q1 + αi.τ.Pi =
1	1

Q1 + αi.Pi. Hence S⇑ ▶ Q1 = Q1 + P1. By symmetry, S⇑ ▶ P1 = P1 + Q1, and thus we obtain S⇑ ▶ P1 = Q1. It follows that S⇑ ▶ τ.P = τ.Q.

(σ) Since P and Q are in σ-nfs, P1 /→τ
and Q1
/→τ . For each i ∈ I, P  α  P ,
i

clearly, it must be the case that Q1
→αi ⇒ Q'
with Pi ≈⇑ Q' . By the same

argument as in the previous case, we can obtain that Sσ ▶ τ.P = τ.Q.
(⊥) Since P and Q are in ⊥-nfs, it must be the case that P1 = Q1 = 0. The conclusion follows trivially.
(F) This case is similar to the case (⇑) and we can obtain, again that SF ▶ τ.P =
τ.Q.
CASE: P =ACΣΣi∈I αi.Pi and Q =AC β∗(Σj∈J βj.Qj). For convenience, we
β /= τ . We discuss according to the two directions of bisimulation.
· For each transition from P , we consider three subcases in the proof:
P →αi P  and α  /= τ, a. Since P ≈	Q, this transition from P must be
i	i	 
matched by a transition Q1 ⇒ Q and Pi ≈ Q'.
P →a  Pi.  Since P ≈  Q, this transition from P must be matched by
transitions Q →a Q, Q1 ⇒τ  Q' and Pi ≈  Q', or Q →a Q and Pi ≈  Q, or
Q1 ⇒a Q' and Pi ≈  Q'.
P →τ  Pi.  Since P ≈  Q, this transition from P must be matched by
transitions Q1 ⇒τ Q' or just Q = Q', in both cases, Pi ≈  Q'.
Following the same lines of CASE (2), we can conclude that either ▶ τ.Q =
a∗(P + Q1) or ▶ Q = a∗(P + Q1).
· For the transition from Q, we only need consider the following two situa- tions:

Q1 → Qj, since P ≈  Q, it must be matched by a transition P
βˆj
⇒ P'

and P' ≈  Qj.  Following the same line of CASE (1), we obtain that
▶ τ.(P + Q1) = τ.P .
Q →a  Q, since P ≈  Q, it must be matched by a transition P ⇒a  P' and
P' ≈  Q. By induction, we have ▶ τ.P ' = τ.Q. Clearly, it follows that
▶ P = P + a.Q.
Then because ▶ P = P + a.Q = P + a.a∗(P + Q1) or ▶ P = P + a.Q =
P + a.τ.Q = P + a.a∗(P + Q1), we have ▶ P + Q1 = P + Q1 + a.a∗(P + Q1) P=A1
a∗(P + Q1). It follows that ▶ τ.Q = τ.(P + Q1) = τ.P .
β = τ . The proof is parametric by ⇑, σ, ⊥ and F.
(⇑) Then for each j ∈ J , βj.Qj /⇑. And since Q ⇑, there exists some i ∈ I, such that αi.Pi ⇑. Let K = {i ∈ I | αi.Pi ⇑}. Then K /= ∅. For each i ∈ K,
clearly αi = τ , and since P →τ Pi, Pi ⇑ and for each j ∈ J , βj.Qj /⇑, it must
be the case that Q ⇒ Q such that Pi ≈ Q. By induction, ▶ τ.Pi = τ.Q. It follows that
S⇑ ▶ P = Σ αi.Pi + τ.Q
i∈/K

Moreover, for i ∈/ K, P αi
Pi with Pi
/⇑. Since P ≈
Q, it must be the

case that Q
⇒αi
Q' 4 with P ≈
Q' .  By induction, S
▶ τ.P
= τ.Q' .

1	1	i	1	⇑	i	1
By Lemma 4.5, S⇑ ▶ Q1 = Q1 + αi.Q' = Q1 + αi.τ.Q' = Q1 + αi.τ.Pi =
Q1 + αi.Pi. It follows that
S⇑ ▶ Q1 = Q1 + Σ αi.Pi
i∈/K
Hence we obtain
S⇑ ▶ τ.Q = τ.Q + Q1 = Q + Q1 + Σ αi.Pi = τ.Q + Σ αi.Pi = P
i∈/K	i∈/K


(σ) Since Q is in σ-nf, for each j ∈ J , βj /= τ . Since Q →τ
and P ≈σ Q, there

exists some i ∈ I, αi = τ , for which, it must be the case that Q ⇒ Q with
Pi ≈σ Q. By induction Sσ ▶ τ.Pi = τ.Q. It follows that
Sσ ▶ P = Σ αi.Pi + τ.Q
αi/=τ


For i ∈ I with α
/= τ , it must be the case that Q αi	Q' with P ≈
Q' .

i	1 →⇒	1
i	σ	1

By Lemma 4.5, ▶ Q1 = Q1 + αi.Q'
= Q1 + αi.τ.Q'
= Q1 + αi.τ.Pi =

Q1 + αi.Pi. It follows that
Sσ ▶ Q1 = Q1 + Σ αi.Pi
αi/=τ
Hence we obtain
Sσ ▶ τ.Q = τ.Q + Q1 = τ.Q + Q1 + Σ αi.Pi = τ.Q + Σ αi.Pi = P
αi/=τ	i∈/K

(⊥) Since Q is in ⊥-nf, it must be the case that Q1 = 0 and thus for each i ∈ I, αi = τ . Moreover, Pi ≈⊥ τ∗0 for each i ∈ I. Clearly S⊥ ▶ τ.Pi = τ.Q. It follows that S⊥ ▶ P = τ.Q and thus S⊥ ▶ τ.P = τ.Q.
(F) The proof is similar to the case (⇑).
The proof is complete.	 
Theorem 4.9 (Completeness) If P  Q, then ▶ P = Q.
Proof. Consider two process terms P and Q that are observation congruent. We shall show that P + Q is provably equal to Q. Of course, by symmetry, P + Q is also provably equal to P . Hence we obtain completeness.
To this end, note that by Lemma 4.7, P and Q may be proven equal to some normal forms using A4, PA1 and PA2. Possibly using equation PA1 again, we may

4 Note that here Q' can not be Q1 itself, so the transition can not be empty.

therefore derive that ▶ P = Σi∈I αi.Pi and ▶ Q = Σj∈J βj.Qj for some finite index
αi
sets I, J . Consider a summand αi.Pi of P . It gives rise to a transition P → P

and hence, since P  Q, there exists some Q' such that Q ⇒αi Q' and P
Proposition 4.8, we have ▶ τ.Pi = τ.Q'. It follows that
▶ Q = Q + αi.Q'	(Lemma 4.5)
T=1 Q + αi.τ.Q'
= Q + αi.τ.Pi
T=1 Q + αi.Pi
= Q'. By

Consequently, we have ▶ Q = Q +  i∈I αi.Pi = Q + P . By symmetry, ▶ P = P + Q. Thus ▶ P = P + Q = Q. The proof is complete.	 

Conclusion
In this paper, we have studied the equational theory of divergent-sensitive spectrum of weak bisimulation equivalences. We work in the setting of a fragment of Milner’s CCS extended by prefix iteration, which allows us to express infinite behavior in a pure algebraic way. We developed pure equational axiomatization for four typical divergent-sensitive observation congruences, namely, the divergent, stable, completed and divergent stable observation congruences. A lattice of distinguishing axioms are presented and the completeness of these axiomatizations is shown. This work deepens our understanding on distinct semantics of divergence largely.
Related Works. [9] carried out similar research as in the current paper. Instead, the authors considered the general recursive (fixpoint) operator in [11] to express the infinite behavior. Admittedly, this mechanism is more general than the prefix iteration operator. However, the price to be paid is that the axiomatization can not be given in an algebraic way, since the unique fixpoint induction has to be exploited. In our work, it suffices only to resort to pure equational reasoning. In our point of view, our work is complementary to the work presented in [9]. As for the proof techniques, [9] mainly adapted the standard proof by Milner [11], which is completely different from ours. Another closely related work is [1], which deals at once with weak, branching, delay and η-bisimulation. In a nutshell, the authors worked within the scope of “vertical” dimension while we deal with “horizontal” dimension. Note that in the current paper, although we restrict ourselves to weak bisimulation and ground-completeness, these are not real shortcomings: We claim that the results reported in the current paper can be adapted to branching (also to delay and η) bisimulations smoothly and by the same way as [1], the ω-completeness can also be obtained. Moreover, the proof technique exploited in the current paper, actually provides an alternative proof for the completeness of axiomatization in [1] for traditional weak bisimulation. It has independently interests since the previous proof in [1] is only achieved by reduction to branching bisimulation which is indirect. For more details, see [3].
An immediate future work includes extending the current work to Kleene star

operator (note that some care is necessary to circumvent the impossibility result in [13]). This is very challenging though, since we even do not know whether such an axiomatization exists, let along that even for strong case (without divergence), the completeness proof is staggering enough.
Acknowledgement
We are grateful to Tingting Han who read a draft of this paper carefully and pro- vided valuable comments.

References
L. Aceto, R. van Glabbeek, W. Fokkink and A. Ing´olfsd´ottir. Axiomatizing prefix iteration with silent steps. Information and Computation, 127(1):26–40, 1996.
J. Bergstra, W. Fokkink and A. Ponse. Process algebra with recursive operations, in Handbook of Process Algebra, pp. 333-389, Elsevier, 2001.
T. Chen, T. Han, J. Lu. On the complete axiomatization for prefix iteration modulo observation congruence. Acta Cybernetica, 17(3): 471-483, 2006.
W. Fokkink. A complete equational axiomatization for prefix iteration. Information Processing Letter, 52(6):333–337, 1994.
W. Fokkink. On the completeness of the equations for the Kleene star in bisimulation. In Proc. AMAST’96, LNCS 1101, pp. 180-194, Springer, 1996.
R. van Glabbeek. The linear time – branching time spectrum I. The semantics of concrete, sequential processes. In Handbook of Process Algebra, pp. 3–99, Elsevier, 2001.
R. van Glabbeek. The linear time – branching time spectrum II. The semantics of sequential systems with silent moves. In Proc. CONCUR’93, LNCS 715, pp. 66–81, Springer, 1993.
R. van Glabbeek and W. P. Weijland. Branching time and abstraction in bisimulation semantics.
Journal of ACM, 43(3):555–600, 1996.
M. Lohrey, P. D’Argenio and H. Hermanns. Axiomatising divergence. Information and Computation, 203(2): 115–144, 2005.
S. Kleene. Representation of events in nerve nets and finite automata. In Automata studies, pages 3–41. Princeton University Press, 1956.
R. Milner. A complete inference system for a class of regular behaviours. Journal of Computer System and Science. 28(3): 439–466, 1984.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
P. Sewell. Nonaxiomatisability of equivalences over finite state processes. Annual of Pure and Applied Logic, 90(1-3):163–191, 1997.
