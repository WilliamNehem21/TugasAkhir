Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 323 (2016) 253–270
www.elsevier.com/locate/entcs
Classical Resolution for Many-Valued Logics
Joao Marcos1
LoLITA & Department of Informatics and Applied Mathematics, UFRN, Brazil
Claudia Nalon
Departament of Computer Science, University of Bras´ılia, Brazil

Abstract
We present a resolution-based proof method for finite-valued propositional logics based on an algorithmic reduction procedure that expresses these logics in terms of bivalent semantics. Our approach is hybrid in using some elements which are internal and others which are external to the many-valued logic under consideration, as we embed its original language into a more expressive metalanguage to deal with the satisfiability problem. In contrast to previous approaches to the same problem, our target language is fully classical, what turns the design of the resolution-based rules for a specific many-valued logic into a straightforward task. Correctness results, which are proved in detail in the present study, follow easily from results on classical resolution. We illustrate the application of the method with examples, and comment on its implementation, readily achievable by direct translation into classical propositional logic, making use of reliable existing automated provers.
Keywords: Multiple-valued Logics, Bivalent Semantics, Resolution Method

Introduction
Many-valued logics have just celebrated their centennial jubilee, and the computa- tional proof method known as resolution is now commemorating its semicentennial birthday. While a competent extensive overview of the applicability of many-valued logics may be found in [2], and references therein, different automatic proof meth- ods for such logics have been covered in depth elsewhere (see [12] and [6]). Among the variegated proof procedures available for dealing with many-valued logics, the resolution-based methods detailed in [1] and [7] are of particular interest and stand as close neighbours to the method introduced in the present paper. Briefly, both of the latter papers present clausal resolution-based procedures, taking as inputs a formula in the language of a particular many-valued logic and transforming it into a

1 The research reported in this paper falls within the scope of the EU FP7 Marie Curie PIRSES-GA-2012- 318986 project GeTFun: Generalizing Truth-Functionality. The first author further acknowledges partial support of CNPq.

http://dx.doi.org/10.1016/j.entcs.2016.09.001
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

labelled formula. Labels are used to mirror truth-values at the syntactic level, and are intended to represent the semantic conditions under which a formula is satisfied. The resolution inference rule is applied to clauses containing complementary literals and whose labels are unifiable (in the sense that they represent consistent semantic conditions). The main difference between those proof methods reside on the form of the labels: in [1] labels are singletons whilst in [7] labels are sets of signs.
In the present investigation, we take a similar route. Formulae to be tested for (un)satisfiability are also transformed into labelled clauses, that is, the inference rules are applied to a more expressive language in which the semantic notions are made explicit. However, labels take in all cases a very simple format, just one out of two possible signs. Thus, differently from the approaches in [1,7], unification on labels can be easily seen as equivalent to the ordinary application of classical propo- sitional resolution. Also, the search for inconsistency (in the language of a given many-valued logic) takes the form of hyper-resolution inference rules in the classi- cal metalanguage, allowing for a uniform classic-like approach to be algorithmically constructed for dealing with any finite-valued logic. The transformation of formu- lae into the labelled language relies on previous results by one of the authors [4,5], which are briefly surveyed here in order to make the presentation self-contained.
The paper is organised as follows. Section 2 introduces logics in abstract and from a semantic viewpoint, explains that they can all be characterised by bivalent semantics, and then focuses on the class of finite-valued truth-functional logics. Emphasis is put on the standard (two-sided) notion of logical consequence, rather than on approaches to many-valued logics that are based on mere combinatorial manipulation of finite-valued algebras. Section 3 explains the algorithm that allows one to describe finite-valued logics in terms of statements written in a fully classical metalanguage in which only two signs are employed. Providing a proof-theoretical perspective on this requires a generalisation of the way that syntactical complex- ity is measured, in order to allow for analytic calculi to be extracted from such a description. The subsequent section contains our main contribution. Section 4 is dedicated to setting up a generic resolution-based proof method for an arbitrary given finite-valued logic. Subsection 4.1 shows how to transform the mentioned bivalent descriptions into a clausal format that is more appropriate for applying resolution. The corresponding transformation adds new variable symbols that help encoding the structure of the original statements, preserving and reflecting their sat- isfiability. As output we obtain object-level expressions that take better advantage of the above mentioned generalised notion of complexity. Subsection 4.2 introduces the inference rules of a hyper-resolution proof method that applies to the clauses produced by the latter transformation. This method lies in between internal proof systems that capitalise on syntactic features of the original logics and external proof systems that formalise reasoning about the logics in a classical logical framework. We finish by some comments on what has been achieved and on how the present investigation may be further extended.

Every Many-valued Logic is Bivalent
This section contextualises our present study, and explains what we mean by a ‘logic’, from both an abstract and a semantic perspective. Special focus is put on the truth-functional case. We also introduce here an appropriate classical meta- language for describing a collection of valuations, and in the following section we discuss how to use it in implementing a computationally useful account of the so- called Suszko’s Thesis (check [3] and references therein), according to which “every logic has but two logical values”.
Definition 2.1 [Syntax] Let a (propositional) signature Σ be the union of a fam- ily tΣmumPN of constructors, where each set Σm contains only function symbols of arity m, and where Σi and Σj are assumed disjoint whenever i ‰ j. Let A be a denu- merable collection of symbols called (atomic) variables, assumed to be disjoint from
the signature Σ. The nullary symbols in Σ0 are sometimes called truth symbols.
A (propositional) language S is recursively generated in the usual way, by consider- ing its composite formulae to be of the form pϕ0, ϕ1,..., ϕmq, for some  P Σm`1. In the latter case, the symbol  is said to be the head connective and the formu- lae ϕk, for 0 ď k ď m, are dubbed the immediate subformulae of pϕ0, ϕ1,..., ϕmq. The formulae in A Y Σ0 are said to be noncomposite, and have no proper subfor- mulae. A canonical notion of formula complexity cp : S ÝÑ N may then be defined by setting cppϕq“ 0 if ϕ is noncomposite, and cppϕq“ 1 ` Max0ďkďm cppϕkq if ϕ is composite and the ϕk, for 0 ď k ď m, are its immediate subformulae. A uniform substitution is an endomorphism on the set of formulae that maps each constructor into itself; it is uniquely defined as soon as the variables of the language are mapped
into formulae. By ϕrp ÞÑ ψs we will denote the result of uniformly substituting ψ
for each occurrence of the variable p in the formula ϕ.	l
In the present study we will only consider languages generated by finite signatures.
Definition 2.2 [Logic] For a fixed propositional language S, a logic L is here de- fined as a structure xS, ąLy, where the relation ąL Ď 2S ˆ S respects the following four abstract axioms, for arbitrary Γ Y Δ Y tϕuĎ S:
(C1) if ϕ P Γ, then Γ ąL ϕ
(C2)  if Γ ąL ϕ, then Γ Y Δ ąL ϕ
(C3) if Γ ąL δ, for every δ P Δ, and Δ ąL ϕ, then Γ ąL ϕ
(C4) if Γ ąL ϕ, then εpΓq ąL εpϕq, for any uniform substitution ε
Any ąL respecting the first three axioms is called a Tarskian consequence relation. We call substitution-invariance the property described by the last axiom. We say that the formulae α and β are L-equivalent, and denote this by α «L β, if both α ąL β and β ąL α. The following replacement property may or may not be respected by a given logic, where ϕ denotes an arbitrary formula to be used as
context, and p denotes an arbitrary variable taken as placeholder:

(C5)  if α «L β, then ϕrp ÞÑ αs «L ϕrp ÞÑ βs
Logics that respect the latter axiom are called congruential.	l
A very natural kind of denotational semantics for a logical language is one that employs certain distinctive collections of truth-values in defining the associated notions of entailment:
Definition 2.3 [Semantics] A valuation for a language S is a mapping w : S ÝÑ Vw, where Vw denotes a nonempty collection of truth-values containing a subset Dw of designated values. The values in Vw\Dw are called undesignated. As usual, a valuation w is said to satisfy a formula ϕ if the former assigns a designated value to the latter; otherwise, we say that w falsifies ϕ. We will call Vp2q “ tF, T u the set of logical values, for which we fix Dp2q“ tT u. Any valuation over V2 is referred to as a bivaluation. The restriction w|A of the valuation w to A Ď S is called an assignment of truth-values to the variables. A semantics for S is here simply a family Sem of valuations. A valid formula (a.k.a. tautology ) of a given semantics
is one that is not falsified by any valuation from this semantics; a formula is called unsatisfiable by a given semantics if all the corresponding valuations falsify it. For a fixed semantics Sem and given some Δ Ď S, denote by ModpΔq the set of valuations of Sem that map all formulae of Δ into designated values. A canonical entailment relation |ùSem Ď 2S ˆS is then defined by setting Γ |ùSem ϕ iff ModpΓqĎ Modptϕuq, i.e., we say that Γ entails ϕ iff there is no valuation in Sem that simultaneously satisfies all formulae in Γ and falsifies the formula ϕ.	l
It is easy to check that an entailment relation always respects axioms (C1), (C2) and (C3) of a Tarskian consequence relation.
Semantics may come in different flavours, differing on the way they happen to collect the appropriate valuations for a given language. It is interesting to observe that there is a precise sense in which all semantics of the kind entertained above may be said to have a ‘bivalent character’. Indeed, fix a semantics Sem, and for each w P Sem define the total mapping bw : S ÝÑ Vp2q such that bwpϕq “ T iff wpϕq P Dw. Let Semp2q denote the family tbwuwPSem of bivaluations. It is straightforward now to check that Γ |ùSemp2q ϕ iff Γ |ùSem ϕ. This means that
every ‘multiple-valued logic’ may also be given a characteristic bivalent semantics. Hereupon, we shall call Semp2q the bivalent reduction of Sem.
The following definition takes advantage of structural features of the language in defining the associated semantics:
Definition 2.4 [Truth-functionality] For some fixed signature Σ and some fixed set V of truth-values, a Σ-algebra over V is a structure in which each  P Σm, with
m
m P N, is interpreted as an operation	: V	ÝÑ V with the same arity. The very
	
If a semantics Sem is given by the set of all homomorphisms from a given term algebra into a fixed Σ-algebra V with carrier V, mapping each constructor  into

entailment relation |ùSem is immediately defined, as before, as soon as a certain set D Ď V of designated values is fixed throughout the valuations constituting the semantics Sem.	l
Note that each valuation of a truth-functional semantics is uniquely defined by some assignment of truth-values to the atomic variables in A, and the value of a composite formula ϕ under a valuation w is defined by the values given by the same valuation to the immediate subformulae of ϕ, so that wppϕ0, ϕ1,..., ϕmqq “ pwpϕ0q, wpϕ1q,..., wpϕmqq. This is indeed the way in which a truth-functional
semantics implements the so-called ‘Principle of Compositionality of Meaning’.
It is clear that a truth-functional semantics gives rise to a substitution-invariant consequence relation. We shall call a logic xS, ąy genuinely κ-valued if κ is the cardinality of the smallest set of truth-values V over which a truth-functional se- mantics Sem may be based to the effect that |ùSem and ą are coextensional. A finite- valued logic is any genuinely κ-valued logic for which the cardinal κ is finite. It is
clear that the bivalent reduction described above still applies in this particular con-
text, and that any logic with a truth-functional semantics may be characterised thus by a collection of bivaluations. In case a logic L is genuinely κ-valued, for some κ ą 2, it is clear, though, that its bivalent reduction cannot be a truth-functional semantics.
To associate a convenient proof system to a logic described in semantic terms, a wise choice of a metalanguage can make a great difference. One rather straightfor- ward way of describing a truth-functional semantics proceeds by the use of labelled formulae, and a corresponding extension of the associated interpretation: given
ϕ P S, we say that a valuation w : S ÝÑ V satisfies X:ϕ if wpϕq “ X (do bear
in mind, though, that while the X in wpϕq“ X denotes a value from V, the same
symbol plays the role of a purely syntactical sign in X:ϕ). This is the approach taken by the so-called ‘singletons-as-signs’ labelling discipline; according to an al- ternative discipline called ‘sets-as-signs’, w is said to satisfy X :ϕ if wpϕqP X , where
X Ď V. In such a metalanguage we will also introduce a meta-conjunction repre- sented by &, a meta-disjunction represented by ||, a meta-implication represented by ùñ , all with the expected Boolean interpretations, and statements such as pXa:ϕa & Xb:ϕbq ùñ pXc:ϕc || Xd:ϕdq will then have their obvious reading as ax- ioms imposing restrictions on the class of valuations in Sem, namely: if a valuation w P Sem happens to satisfy both Xa:ϕa and Xb:ϕb, then this valuation should satisfy Xc:ϕc or Xd:ϕd. The meta-conjunctions and the meta-disjunctions are generalised in the standard way to give support to any finite number of arguments.
We introduce in the metalanguage the symbols j and k, respectively, for meta- verum (standing for an arbitrary labelled tautology, or a 0-ary conjunction) and meta-falsum (standing for an arbitrary labelled antilogy, or a 0-ary disjunction), and write a statement such as X:ϕ ùñ k to say that X:ϕ is unsatisfiable, and a statement such as j ùñ X:ϕ to say that X:ϕ is unfalsifiable. Metalinguistic
statements in which all labels are restricted to one of only two possible signs are said to be bivalent. As we will see, any finite-valued logic may be semantically characterised in terms of bivalent statements. We will assume Vp2q“ tF, T u to be

the set of labels used in case we are talking about bivalent statements, and shall write Xc to denote the conjugate of X, defined by setting F c “ T and T c “ F . A natural classical meta-negation may also be introduced as we are working with
bivalent statements: we will write D to say that statement D fails to be the case. In particular, on what concerns the interaction between the meta-negation and the labelled formulae, we will assume that X:ϕ “ Xc:ϕ. For a bivalent semantics, whose valuations are all total functions on tF, T u, it should be clear that the following statements are always satisfied: j ùñ pX:ϕ || Xc:ϕq and pX:ϕ & Xc:ϕq ùñ k.
Example 2.5 Let ΣA “ tKu and ΣA “ tĄu. Let VpQq be the set of all rational
0	2
numbers in the real-valued interval [0,1], and let D “ t1u. Assume Kp “ 0 and
Ąpx, yq“ minp1, 1 ´x `yq. As a side effect of such truth-functional interpretations, one might venture describing the behaviour of the implication Ą by various meta-
linguistic statements such as 0:ϕ || 1:ψ ùñ 1:pϕ Ą ψq or 1 :ϕ & 1 :ψ ùñ 3 :pϕ Ą ψq.
2	4	4
Note, however, that a labelled composite statement such as j ùñ 1:pϕ Ą pϕ Ą
ψqq Ą pϕ Ą ψq is satisfied iff wpϕq “ 0 or wpϕq “ 1. Now, the original signature may be extended by considering ΣB “ tid, ¬, θa, θbu and ΣB “ t^, vu and taking
1	2
these new symbols to be abbreviations of formulae written in the original signature,
namely: ¬ϕ d“ef ϕ Ą K; idpϕq d“ef ¬K Ą ϕ; θ pϕq d“ef ¬ϕ Ą ϕ; θ pϕq d“ef ϕ Ą ¬ϕ;

ϕ v ψ d“ef
pϕ Ą ψq Ą ψ; ϕ ^ ψ d“ef
¬p¬ϕ v ¬ψq. As illustrations, notice, that

while the metalinguistic statement X:pϕ ^ ψq & 1:ϕ ùñ X:ψ is satisfied for every
X P Q X r0, 1s the statement pX:θapϕq || Y:θbpϕqq ùñ pX:ϕ & Y:¬ϕq is satisfied only for X, Y P t0, 1u. One way of enforcing the validity of the latter statement is by replacing VpQq by t0, 1u (restricting thus the set of undesignated values to the singleton t0u). L- ukasiewicz’s logics L- n, for n ě 2, are obtained if we replace VpQq by Vpnq“  m  :0 ď m ď n ´ 1 . Equivalently, to the same effect one could impose
on the semantics the bivalent axiom j ùñ 1:ϕ || 1:¬ϕ. In the above hierarchy of logics, Classical Logic (CL) corresponds to L- 2 — thus, it not only has a bivalent semantics (one may set bwpϕq “ T if wpϕq “ 1, and bwpϕq “ F otherwise) but is indeed a genuinely 2-valued logic.	l
It is interesting to notice how, in the case of L- 2, every bivalent statement may be rewritten in a useful way with the help of the negation connective: to that effect one just has to substitute ‘1:¬’ for every ‘0:’ that appears as prefix of a labelled formula, and confirm by induction that the resulting metalinguistic expression is satisfied iff the original metalinguistic expression is satisfied — so, in particular, p0:ϕ || 1:ψq ùñ 1:pϕ Ą ψq becomes p1:¬ϕ || 1:ψq ùñ 1:pϕ Ą ψq. This could give support to a natural argument for claiming that the addition of signs containing ‘semantic information’ to formulae is ‘superfluous’ (in the above example, one might consider just omitting the prefix ‘1:’ that now appears in front of every object language expression), in view of the expressivity that the classical object language displays in internalising the classical metalinguistic information given by the labels. In general, of course, this argument runs unaltered only for CL. At any rate, there is nothing really special about negation in the preceding argument: the exact same impression of superfluity would in fact be caused by invoking the connective θb,

whose interpretation only happens to coincide with that of negation over Vp2q.
It is not too hard to provide a combinatorial argument to show that L- ukasiewicz’s logics are so related that |ùL- m Ď |ùL- n iff n ´ 1 divides m ´ 1. From the above example, however, it might be hard to tell the exact difference, say, between the
3-valued implication and the 5-valued implication just by looking at the statements that describe them, not least because of the use of different collections of labels to describe the semantics of L- 3 and of L- 5. A clever and generic way of solving this particular difficulty, in fact, would be by describing both logics under a classic-like logical framework, using a common signature and a bivalent semantics. The real problem, in that case, would then be how best to use our metalanguage to describe the corresponding non-truth-functional semantics in a computationally useful way. There is a well-studied algorithmic approach ([4,5]) to producing a description of the ‘bivalent reduction’ of any finite-valued logic and to using the latter description so as to provide uniform tableau-theoretic characterisations of such a logic, with associated proof strategies that ensure, in each case, termination of the proof-search tasks, constructing either a proof or a counter-example to any given conjecture.
This consists in a mechanised procedure in four steps that receives as input the full specification (syntax and semantics) of a finite-valued logic L and:
(A1) check if the object language of L is sufficiently expressive for the task; (A2) produce a sufficiently expressive conservative extension of L, if necessary; (A3) axiomatise the semantics of L using bivalent statements expressed in the
classical metalanguage under a particular (disjunctive) normal form;
(A4) use the bivalent statements to produce a sound and complete (tableau) proof system for L.
In the present paper we will have our logics presented already in a language that is expressive enough for our purposes, thus bypassing steps (A1) and (A2), where we have no contribution here to make. Next, we will import the original step (A3), and then introduce a transformation function that helps in massaging the bivalent statements into a ‘clause form’ that is more appropriate to the use by the resolution method. Finally, we will redesign step (A4) in order to produce sound and complete uniform classic-like resolution calculi for all finite-valued logics.
The Bivalent Reduction
We briefly describe, in what follows, the bivalent statements produced by the above mentioned algorithm that outputs the bivalent reduction of any finite-valued logic. The key to the procedure is to find, first, a way of using the language of the given logic to distinguish between each pair of designated truth-values, and similarly to distinguish between each pair of undesignated truth-values. In that way, each value of the original truth-functional semantics will turn out to have a unique ‘binary print’ that sets it apart from all the other values. Such binary print will be expressed in terms of a suitable combination of logical values.
For the following definitions we fix a (sufficiently expressive) genuinely κ-valued

logic L, for finite κ, whose semantics Sem has V and D, respectively, as its sets of truth-values and designated values. We recall that bw denotes the bivaluation induced by the valuation w P Sem.

Definition 3.1 [Binary print] A separating sequence
ÝÑ
θ “ xθ0, θ1,..., θsy for L is

a sequence of unary connectives (to be referred to as separators) with the prop-
erty that for every pair of distinct valuations w1, w2 P Sem, that is, every pair
of valuations such that w1ppq ‰ w2ppq for some variable p, there is some θr, for 0 ď r ď s, such that bw1 pθrppqq ‰ bw2 pθrppqq. Given some x P V assigned by some
ÝÑ

valuation w to a given formula ϕ, by the binary print
ÝÑ
θ pxq we mean the unique
s`1

sequence X “ xbwpθ0pϕqq, bwpθ1pϕqq,..., bwpθspϕqqyP tF, T u	. If an ps ` 1q-long
sequence of F ’s and T ’s does not coincide with any binary print of a truth-value in V, we say that such sequence represents an absurd.	l
Intuitively, an absurd corresponds to a semantically unobtainable scenario: an al- leged logical description of an ‘algebraic value’ that is not to be found among the available truth-values of the Σ-algebra interpreting the language.
The following should be read having Ex. 2.5 on the background.
Example 3.2 Very short separation sequences are promptly available for Classical Logic. There are indeed in this case no pair of (un)designated values to distinguish. Thus, one could consider 1-long sequences made of any connective  P ΣA Y ΣB,
1	1
in view of the fact that bw1 pppqq ‰ bw2 pppqq whenever w1ppq“ 0 and w2ppq“ 1.
Note, however, that xidy is by itself not a separating sequence for L- 3, for it does not tell the two undesignated values apart. Any 2-long sequence of distinct unary connectives from our extended signature would however do the job equally well for L- 3. Separating sequences for other L- n’s are forcibly longer. For L- 5, for instance, one could make do with the 4-long sequence xid, ¬, θa, θby.	l
To simplify matters, we will choose henceforth to set θ0ppq“ p. Strictly speak- ing, in this case θ0 will not really denote a unary connective, but it will be just as good, as its interpretation coincides in fact with the interpretation of the ‘iden- tity connective’ id. Obviously, bw1 pθ0ppqq ‰ bw2 pθ0ppqq whenever w1ppq denotes a designated value, and w2ppq denotes an undesignated value. Thus, the other θr’s (for r ą 0) in the separating sequence have the role of allowing us to distinguish between two truth-values that are both designated, or between two truth-values that are both undesignated. The very existence of a separating sequence means that congruentiality (axiom (C5) in Def. 2.2) always fail for sufficiently expressive non-boolean truth-functional logics. Indeed, one can in general only be assured that two equivalent formulae may be replaced one by another salva veritate when every valuation assigns to them exactly the same truth-value, for otherwise there will be some sentential context that distinguishes these equivalent formulae. However, the replacement property is obviously fully enjoyed by our classical metalanguage, and we will in the future be using it often, at the meta-level, in replacing a labelled formula by any classically equivalent labelled formula.
The above definitions lead us now very naturally to an extension of the notion

of formula complexity (contrast with the canonical complexity in Def. 2.1):
Definition 3.3 [Generalized measure of complexity] Formulae of the form θrpϕq, where θr is a separator and ϕ is noncomposite, are called basic. A generalised notion of formula complexity gcp : S ÝÑ N is defined by setting gcppϕq“ 0 if ϕ is basic, and gcppϕq“ 1 `Max0ďkďm gcppϕkq, if ϕ has the form θrppϕ0, ϕ1,..., ϕmqq,
for  P Σm`1 and 0 ď r ď s. Formulae with positive complexity gcp are said to be analysable. Such complexity measure may be extended to labelled formulae by setting gcppX:ϕq“ gcppϕq.	l
Note that, in the present approach, neither labels nor separators contribute to an increase in formula complexity, and in general we have that gcppϕqď cppϕq.
ÝÑ
Let θ pXq “ xX0, X1,..., Xsy be the binary print of some truth-value X P V.
Note that there is a sense in which the generic metalinguistic statement X:ϕ may be
assumed to be described by the bivalent statement &s	Xr:θrpϕq. Indeed, the for-
mer statement is satisfied iff the latter is satisfied, modulo the respective labellings.
In other words: wpϕq“ X iff bwpθrpϕqq “ Xr for every 0 ď r ď s. We shall refer

s r“0
Xr:θrpϕq as V p
ÝÑ
ϕ, X q. Considering next an analysable formula ϕ of the

form θrppϕ0, ϕ1,..., ϕmqq and a logical value X, we shall call Rθr
the set of all

tuples of values from V that the subformulae ϕ0, ϕ1,..., ϕm may be assigned by a valuation w P Sem in order to guarantee that bwpϕq“ X.
Aided by the separators, we now set ourselves the goal of describing the be- haviour of analysable formulae in terms of formulae with lower generalised com- plexity measure. In particular, to each label X P tF, T u, each separator θr P Σθ and each m-ary non-separator connective  from the signature of L we will associate
the following B-statement:

X:θ ppp ,p ,...,p 
qq	ùñ	||
θ  p&m  V p
ÝÑ x qqq	(Bθr)

r	1	2	m
xx1,x2...,xmyPR r	k“1
pk, θ p k	X

In addition to the above, we should note that all the ps ` 1q-long binary sequences of F ’s and T ’s that do not correspond to binary prints of truth-values in V in fact describe impossible semantic scenarios. As it happens, however, it is often the case that partial knowledge about a given binary sequence provides enough information for us to conclude that it represents an absurd. In other words, maybe we do not know all elements of a given binary sequence at a certain stage of development of our reasoning, but we know enough to be able to conclude that any way of completing this sequence leads to an absurd. Accordingly, it is useful to entertain certain ‘minimal unobtainable partial binary sequences’. The idea is to add a symbol for

an ‘undefined’ logical value Ò
ÝÑ
and call some sequence Y P tF, T, Òu	unobtainable

already when any ps ` 1q-long fully defined sequence of F ’s and T ’s that coincides
with the former sequence in all positions that do not contain undefined symbols
ÝÑ
represents an absurd, that is, when no extension of Y represents an algebraic value
from the original semantics. As expected, a minimal unobtainable such sequence is one that does not properly extend another unobtainable sequence.
Example 3.4 To illustrate the issue about partial binary sequences, note that

if L- 5 is considered over the separating sequence xid, ¬, θa, θby, as in Ex. 3.2, its truth-values will be individualised by 5 out of 16 possible tuples of F ’s and T ’s. One (minimal) description of the 11 unobtainable tuples might be given by the following partial binary sequences: xÒ, Ò, F,F y, xÒ,T, Ò,F y, xÒ,T,T, Òy, xT, Ò, F, Òy, and xT,Ò,Ò,T y.	l

ÝÑ
Given a minimal unobtainable sequence Y P tF, T, Òu
s`1
, by dom ÝÑ we denote

the set t0 ď r ď s : Yr ‰ Òu
U-statement:
ÝÑ
. To any such sequence Y we will associate the following

&	ÝÑ
rPdomp Y q
Yr:θrpp0q	ùñ	k	(UY )
ÝÑ

We may say that a minimal unobtainable binary sequence Y covers any ps `1q-
ÝÑ	ÝÑ	ÝÑ
long binary sequence X such that domp Y qĎ dompX q.
The above B-statements and U -statements allow us to describe a very convenient list of bivalent statements to use in characterising a given finite-valued logic.
Definition 3.5 [Bivalent statements induced by L] Let L be a finite-valued logic
ÝÑ
over a signature Σ and a set of truth-values V, let θ be a separating sequence for L,

call Σθ Ď Σ1
the set of separators in
ÝÑ
θ , and let
tYjujPλ, for some λ P N, be a family

of minimal unobtainable binary sequences that jointly cover all the binary prints
that do not correspond to truth-values in V. The bivalent semantics that we shall

call Bp
ÝÑ
L, θ q
is described by the collection of all B-statements Bθr
, for each label

X P tF, T u, for each θr P Σθ and each  P Σ\Σθ, together with the collection of all
UYj -statements, for j P λ.	l

Note that Rθr
Y Rθr
“ Vm`1, for  P Σm (and also that Rθr
X Rθr
“ ∅),

but it may occur that one of these two sets is empty. In that case, we will have an

empty disjunction on the right-hand side of a B-statement Bθr
, and this obviously

amounts to a ‘degenerate’ B-statement that looks more like a U -statement, given
that it describes a semantically unobtainable scenario.

Fig. 1. Set of bivalent axioms for L- 3.
The following are among the main results of [5]:
Theorem 3.6 (Soundness & Completeness) The bivalent semantics described

by Bp
of L.
ÝÑ
L, θ q
contains the same bivaluations included in the bivalent reduction Semp2q

Theorem 3.7 (Effectiveness) Let b P Semp2q, and let ϕ be an analysable for- mula. Let Apϕq be the set of variables that occur in ϕ. Then the value of bpϕq is uniquely determined from the values of bpθrppqq for 0 ď r ď s and p P Apϕq. More-

over, the value of bpϕq may be effectively computed using the Bp
ÝÑ
L, θ q
statements.

The perspicacious reader will surely have suspected that this provides a way of

extracting from Bp
ÝÑ
L, θ q
the rules characterising an analytic tableau system. In

the next section we will show how such description may be transformed into a description that is more appropriate for working with resolution calculi.
The following illustration builds on previous examples, and will be further ex- plored in the next section.
Example 3.8 Fig. 1 contains a set of bivalent axioms for L- 3 produced by the
above described algorithm, using xθ0, θay as a separating sequence. For the sake of legibility, we omit the subscript in θa.	l
Resolution Calculus
This section introduces a proof method for finite-valued logics through backward reasoning in the form of a clausal resolution-based proof method, a refutational pro- cedure applied to formulae written in a specific Conjunctive Normal Form. Standard implementations of clausal resolution take a suitable normal form for the classical negation of a formula to be tested for satisfiability and then (a set of) rules based on the Resolution Principle are applied until the empty clause is found or no new clauses can be generated. If the empty clause is found, the original formula is unsatisfiable; otherwise, the formula is satisfiable and we can build a model that witnesses its satisfiability. We also take here the clausal approach, but instead of working from the original semantics of a given finite-valued logic, we use the bi- valent semantics for such a logic, described in Section 3, to produce the normal form. This way, the calculus we shall present here works over a set of clauses in the metalanguage representing the bivalent semantics. The calculus is parametrised by the language and the separating sequence used to produce the metalinguistic

statements for a given logic. We will denote by RESBp
ÝÑ
L, θ q
our resolution calculus

for the bivalent statements Bp
ÝÑ
ÝÑ
L, θ q
that describe the many-valued logic L with the

separating sequence θ .
Normal Form
Let L “ xS, ąLy, where S is recursively defined over a finite signature Σ “ ŤkPN Σk,
be the description of the bivalent semantics Semp2q corresponding to our bivalent reduction of Sem.
From Def. 3.5 we note that the bivalent statements describing a given semantics have their right-hand side in Disjunctive Normal Form. However, clausal resolution works over meta-conjunctions of clauses (meta-disjunctions of labelled basic formu- lae) representing the Conjunctive Normal Form of a formula. More precisely, the

normal form that is obtained from our bivalent statements, henceforth to be called

CNFBS, consists in metalinguistic statements of the form &a
bi j“0
Xij:ϕijq where

a, bi P N, Xij P tT, F u and each ϕij is a basic formula. We note from Def. 3.3 that
the disjuncts Xij:ϕij cannot be further analysed, and play thus the role of ‘literals’ in classical resolution. Furthermore, as the meta-conjunction is associative, com- mutative and idempotent, we may treat a formula in CNFBS more simply as a set of clauses.
There are alternative ways of producing the conjunctive normal form starting

from the B-statements Bθr
. One of these is to apply the usual distribution rules to

such a metalinguistic formula, but that might give rise to an exponential increase in
the size of the formula. Another way of transforming a formula into CNFBS is to ap-

ply the meta-negation to formulae in Bθrc
followed by applications of De Morgan at

the level of the metalanguage. However, it has been shown that ‘language-preserving
transformations’ like these might lead to larger sets of clauses (cf. Ex. 4.6 in [2]) than the so-called ‘structure-preserving transformations’. In contrast, the latter kind of transformations introduce abbreviations, in the form of new atomic vari- ables and bi-implications, in order to help producing a normal form. This is the main approach chosen, for instance, in [7], and also entertained in [2]. In the present study, we combine both kinds of transformation, but taking advantage of the struc- ture of B-statements, where the right-hand side of meta-implications are already meta-disjunctions, and we use renaming to replace analysable formulae appearing as disjuncts. Applying at the metalinguistic level the results from [9], if a formula ϕ is a subformula of ψ, that is, if ψ has the form ψrp ÞÑ ϕs, then the labelled formula X:ψ1 & X:ptϕ ùñ ϕq & X:pϕ ùñ tϕq, where ψ1 “ ψrp ÞÑ tϕs for some fresh atomic variable tϕ, can be used to replace the formula X:ψ whilst preserving satisfiability. The ‘meta-bi-implication’ X:ptϕ ùñ ϕq & X:pϕ ùñ tϕq is often referred to as the
definition of ϕ. In the present study, as in [7], we restrict renaming to formulae ϕ
of positive polarity, that is, formulae that occur in the scope of an even number of
meta-negations. Thus, only one side of the definition of ϕ is needed, namely the meta-implication X:ptϕ ùñ ϕq. Again, satisfiability is preserved and the resulting normal form is shorter (cf. [9]). Differently from [7] and [2], the transformation into CNFBS does not produce many-valued labelled formulae (either following the effi- cient labelling discipline ‘sets-as-signs’, or the straightforward ‘singletons-as-signs’), but directly produces classic-like two-signed formulae. To some extent, our ap- proach is closer to that in [8], where the satisfiability problem for many-valued logics is reduced to the satisfiability problem in classical propositional logic, but we confine our signs to the two labels that represent the underlying logical values. As a pleasant consequence, existing satisfiability procedures may be used to test a set of clauses without further ado. We note, however, that here we also need to take into consideration the U -statements, which provide the restrictions under which a meta-conjunction of labelled-formulae is meaningful. The U -statements will origi- nate appropriate resolution-based rules, in Section 4.2, and the latter will turn out to be essential for the completeness of our method. In what follows we define the necessary prior transformation into CNFBS.

Our transformation function τ takes a labelled formula X:ϕ as input and con- verts it into a normal form through recursive applications of rewriting and renaming.

To each B-statement of the form X0:ϕ0 ùñ p||n
Xi:ϕiq we associate the following

rewrite rule: τ pX0:ϕ0q ÞÝÑ τ p||n
Xi:ϕiq. If  is the head connective in ϕ0, we

indicate the corresponding rewrite rule as τX0
. The transformation distributes over

meta-conjunctions and over meta-disjunctions, as follows:


n i“1
τ p||n
Xi:ϕiq ÞÝÑ &n
Xi:ϕiq ÞÝÑ ||n
τ pXi:ϕiq.	(τ &)
τ pXi:ϕiq.	(τ ||)

The next rule renames meta-conjunctions that appear within meta-disjunctions:


τ pψ || &n
Xi:ϕiq ÞÝÑ τ pψ || T :tq & τ pT :t ùñ &n
Xi:ϕiq	(τren)

where ψ is a labelled formula, &n	Xi:ϕi is a meta-conjunction and t is a fresh
atomic variable. Note that meta-disjunctions are associative and commutative. Thus, τren applies to any disjunct that is not a labelled basic formula. Meta-con- junctions on the right-hand side of meta-implications are rewritten as usual:


τ pT :t ùñ &n
Xi:ϕiq ÞÝÑ &n
τ pT :t ùñ τ pXi:ϕiqq	(τ ùñ &)



The final rewrite rule transforms meta-implications into meta-disjunctions:
τ pT :t ùñ Dq ÞÝÑ	F :t || D,	if D is a clause
τ pT :p ùñ τ pDqq,	otherwise


(τ ùñ )

As the base case for the transformation function, we set:
τ pX:ϕq ÞÝÑ X:ϕ, if ϕ is a basic formula.	(τb)
Clauses are kept in simplified form, i.e. the following simplification rules apply at all steps of the transformation (where D is a clause and ϕ is a basic formula):
σpD || X:ϕ || X:ϕq	ÞÝÑ	σpD || X:ϕq	σpD || jq	ÞÝÑ	j
σpD || X:ϕ || Xc:ϕq	ÞÝÑ	j	σpD || kq	ÞÝÑ	σpDq
The following lemma shows that the transformation into CNFBS is correct.

Lemma 4.1 Let L be a ﬁnite-valued logic and S be its language. Let Bp
ÝÑ
L, θ q be
ÝÑ

the set of bivalent statements associated with L and the separating sequence θ , and
let ϕ be a formula in S. Then, ϕ is satisﬁable if, and only if, τ pT :ϕq is satisﬁable.
Proof. The rewrite rules given by τ are based on the equivalences given in [5] (case
&	||	ùñ &
of τX0 ), on classical equivalences for all other rewrite rules (τ , τ , τ	, and
τ ùñ), and on classical renaming for the transformation rule τren. As both kinds of
transformation, namely replacement and renaming, preserve satisfiability (cf. [9]), we conclude that ϕ is satisfiable if and only if τ pT :ϕq is also satisfiable.	l

T :t1 || T :t9
F :t1 || T :t2 || T :t8 || T :p
F :t1 || F :p
F :t2 || T :t3 || T :t6
F :t2 || T :θppq
F :t3 || T :p
F :t3 || T :t4 || T :t5
F :t4 || T :p
F :t5 || θppq
F :t6 || θppq
F :t6 || T :t7
F :t7 || T :p
F :t8 || T :p
F :t8 || T :t7
F :t9 || T :t3 || T :t6 || θppq
F :t9 || F :θppq where



Fig. 2. The clausal form of pppp Ą pp Ą KqqĄ pqĄ pq.
Example 4.2 The formula ϕ0 “ pppp Ą pp Ą KqqĄ pqĄ pq is valid in L- 3. Fig. 2 shows the set of clauses resulting from the transformation of F :ϕ0 into CNFBS, where the transformation function is based on the set of bivalent statements for L- 3 with separating sequence xθ0, θay, given in Fig. 1. Tautologies have been suppressed. On the right-hand side, we present the definitions of the new atomic variables in- troduced along the translation.	l

Inference Rules

Let Bp
ÝÑ
L, θ q
be the bivalent description of a finite-valued logic L on a language S,

and let tUjujPλ, for some λ P N, be the family of U -statements in this description.
Let X:ϕ be a labelled formula with ϕ P S. Let Φ be the set of clauses obtained by

transforming X:ϕ into the corresponding CNFBS based on Bp
ÝÑ
L, θ q. The resolution

calculus for L will comprise a binary resolution rule (RES), which is a syntactical variation of the usual classical (binary) resolution rule [11], and a set of hyper- resolution inference rules, named (RESUj ), for j P λ, to deal with the valuation restrictions related to the corresponding Uj-statements. Hyper-resolution (cf. [10]) is a refinement of the resolution method, which combines several binary resolution steps, thus avoiding the generation of intermediate clauses (and the interaction between them) when searching for a proof. Recall that U -statements express the binary sequences which are unobtainable as binary prints of the original truth- values of L. Hence, the meta-conjunction of labelled formulae on the left-hand side of the meta-implication in a U -statement corresponds to a logical absurdity in the semantics of the metalanguage. The resolution rules are given in Fig. 3, where Di is a clause, Xi P tT, F u, and ϕ, ϕi are basic formulae (where 1 ď i ď nj, j P λ, and nj is the number of meta-conjuncts in Uj). Premises of the resolution-based inference
rules are called parent clauses. Conclusions in such rules are called resolvents. Also,
we refer to tT :ϕ, F :ϕu (resp. tX1:ϕ1,..., Xnj :ϕnj u) occurring in the parent clauses of (RES) (resp. (RESUj )) as an inconsistent set of formulae. Labelled formulae in an inconsistent set of formulae are said to be resolved by the respective inference rule.





Fig. 3. Resolution-based Rules for RESBp
ÝÑ .
L, θ q

Definition 4.3 [Derivations & Refutations] Let Φ be a set of clauses in CNFBS. A derivation for Φ is a sequence Φ0, Φ1,... of sets of clauses in CNFBS, with Φ0 “ Φ and for all i ą 0, Φi`1 “ Φi Y tDu, where D is a clause (in simplified form)

obtained by an application of either (RES) or (RESUj ) in RESBp
ÝÑ
L, θ q
to clauses in

Φi. Repeated formulae are not added to the next step in a derivation, i.e. we require that pΦi`1\Φq‰ H, and that D is not a tautology. A refutation for a set of clauses Φ is a finite derivation for Φ, Φ0,..., Φm, with m P N, such that kP Φm.   l
Next, we show an example of the application of the method.
Example 4.4 The formula pppp Ą pp Ą Kqq Ą pqĄ pq is valid in L- 3. Fig. 4 shows a refutation for the set of clauses resulting from the transformation of F :pppp Ą pp Ą Kqq Ą pqĄ pq into CNFBS given in Example 4.2. As shown in Table 1, there is only one U -statement for the bivalent semantics of L- 3, namely, pT :ϕ & F :θpϕqq ùñ k. Thus, the corresponding hyper-resolution rule has the form: from D || T :ϕ and D1 || F :θpϕq infer D || D1, where D and D1 are clauses and ϕ is a formula of L- 3. In the following, we only show the clauses that are relevant in the refutation. Justification is given on the right-hand side: Numbers refer to the corresponding parent clauses and the application of the hyper-resolution rule is indicated by U (otherwise, pRESq is applied). We also indicate in each case the list of labelled formulae being resolved.
A derivation terminates iff either the empty clause is derived or no new clauses

can be derived by further application of the resolution rules of RESBp
ÝÑ . From

Def. 4.3, recall that we do not add repeated clauses nor tautologies to the gener-
ated set of clauses. These restrictions, together with simplification, are usual in resolution-based proof methods and help to establish termination, as follows.
Theorem 4.5 (Termination) Let Φ be a set of clauses in CNFBS. Then any

derivation for Φ in RESBp
ÝÑ
L, θ q
terminates.

Proof. Firstly, note that none of the inference rules introduce new labelled basic formulae in the clause set. As there are only a finite number of such formulae occurring in Φ, only a finite number of CNFBS clauses may be built. Formally, if n is the number of basic formulae occurring in Φ, there are only 3n possible different meta-disjunctions (modulo reordering) that can be built: either the labelled basic formula X:ϕ does not occur in the clause, or it occurs in the form T :ϕ, or else it occurs in the form F :ϕ (as meta-disjunctions are in simplified form). Also, for any derivation Φ0, Φ1,... for Φ, by the definition of a derivation, we have that Φi`1 must contain a new clause as compared to Φi. Thus, there must be some m P N


l
Fig. 4. A refutation for pppp Ą pp Ą KqqĄ pqĄ pq.
such that either the empty clause is in Φm, or |Φm|ď 3n and no new further clauses

can be generated. Therefore, any derivation for Φ in RESBp
ÝÑ
L, θ q
terminates.	l

The next result establishes soundness of the resolution method.
ÝÑ

Theorem 4.6 (Soundness) The resolution calculus RESBp
ÝÑ
L, θ q
for BpL, θ q based

on the rules (RES) and (RESUj ), for each Uj-statement in Bp
ÝÑ
L, θ q, is sound.

Proof. We start by establishing the soundness of each inference rule in RESBp
ÝÑ
L, θ q

Soundness of (RES) follows from the results in [11]. For the soundness of (RESUj ),
assume all premises hold. Then, by definition of satisfiability, the meta-conjunction of those premises is also satisfiable. It is a straightforward exercise to show that

nj
  i“1
pDi || Xi:ϕiq is semantically equivalent to p&nj
Diq ùñ p&nj
Xi:ϕiq, where

Di is the meta-negation of Di.	From the results in [5], by the Uj-statement

nj
i“1
Xi:ϕi ùñ k, we have that &nj
Xi:ϕi is unsatisfiable. Thus, by the semantics
nj

of the meta-implication, we conclude that &i“1 Di is unsatisfiable, and by the se-
mantics of the meta-conjunction and meta-negation, we obtain that ||nj	Di, the
resolvent of (RESUj ), is satisfiable. Now, let Φ be a satisfiable set of clauses and let Φ0, Φ1,... be a derivation for Φ. As all inference rules are sound, by an easy induction on the length of a derivation, every Φi, i ě 0, is also satisfiable. Thus, the resolution calculus based on (RES) and (RESUj ) is sound.	l
As expected, the completeness result only depends on showing that the hyper- resolution rule can be simulated by binary resolution.

Lemma 4.7 Let Bp
ÝÑ	ÝÑ
L, θ q be the bivalent semantics of L with separating sequence θ
ÝÑ

and RESBp
ÝÑ
L, θ q
the resolution calculus based on BpL, θ q. Let (RESUj ) be the hyper-

resolution rule corresponding to the Uj-statement &nj
Xi:ϕi ùñ k in Bp
ÝÑ
L, θ q.

Then, (RESUj ) can be simulated by binary resolution.

Proof. The proof is straightforward.	Assume Φ is the set of clauses tpD1 ||
X1:ϕ1q, pD2 || X2:ϕ2q,..., pDnj || Xnj :ϕnj qu, i.e. the premises in (RESUj ). Note that
the meta-negation of &nj  Xi:ϕi corresponds to the unfalsifiable meta-disjunction

nj	c
i“1
1

||i“1 Xi :ϕi. Call the latter statement D. Take Φ “ Φ Y tDu. Construct a deriva-

tion Φ1 , Φ1 ,... for Φ1 by taking Φ1 “ Φ1, Φ1 “ Φ1 YtD1 u, where D1
is the resolvent

0	1	0	1	0	1	1
of D and pD1 || X1:ϕ1q by (RES). For the remainder of the construction, take

Φ1	“ Φ1 Y tD1
u, where D1
is the resolvent of D1
and pDi`1 || Xi`1:ϕi`1q

i`1	i
i`1
i`1	i

by (RES). Thus, Φ1
contains ||nj
Di, the same clause as the resolvent of (RESUj )

applied to Φ.	l

Theorem 4.8 (Completeness) Let Bp
ÝÑ
ÝÑ
L, θ q
be the bivalent semantics of L with

separating sequence θ . The resolution calculus, RESBp
ÝÑ , based on (RES) and

the family of rules (RESUj ), for each Uj-statement in Bp
ÝÑ
L, θ q, is complete.

Proof. Immediate from Lemma 4.7 and the completeness of the resolution calculus for propositional logic [11].	l

Final Remarks
We have developed a sound, complete, and terminating resolution-based proof method for finite-valued logics. In particular, the correctness results were easily achieved as they rely on the satisfiability preservation of the normal form based on bivalent semantics, and on syntactical variations of usual resolution-based rules. Also, the fact that a set of formulae Γ “ tγ0, γ1,..., γnu entails ϕ in the particular many-valued logic under consideration can be translated into the unsatisfiability of

n i“0
τ pT :γiq & τ pF :ϕq in our metalanguage. Hence, strong completeness of our

method easily follows from the results offered in the present study.

From our correctness results, a proof in RESBp
ÝÑ
L, θ q
may be simulated by ordi-

nary propositional resolution, by using the unfalsifiable formulae originated from the
unobtainable partial binary sequences (see Lemma 4.7) and the translation of the set of clauses into the ordinary propositional language, and by then removing labels from metalinguistic formulae and introducing classical meta-negations where appro- priate. Also, formulae of the form θpϕq, where θ is a separator and ϕ is basic, are not analysable and may be regarded as ground terms, translatable into new atomic

symbols. It should thus be clear that automatisation of RESBp
ÝÑ
L, θ q
only requires

representation into the language of an existing propositional theorem-prover.
The efficiency of our transformation procedure, as compared, for instance, to those of [1] and [7], depends strongly on the size of the B-statements, which in turn depends on the set of separating sequences chosen to generate such statements as well as the number and arities of connectives in the object-language. Like the transformation of many-valued formulae into singleton-as-signs given in [1], the pro- cedure given here leads to a clause set that is exponential on the size of the original formula. On the bright side, as argued above, the transformation we present pro- duces truly classical formulae in the metalanguage and there is no need to perform unification on labels. The more parsimonious set of clauses obtained in [7] un-

der the discipline sets-as-signs takes advantage of the ‘inverse tableau’ procedure (where a branch represents the disjunction of formulae occurring therewith) in order to generate the clausal form. Believing that such procedure can be derived from the optimized linear cut-based tableau construction given in [5], we leave this here as matter for further investigation. The main distinguishing feature of the method introduced in the present paper lies in the target language to which the formu- lae are translated. As noted before, the resolution-based procedure presented here might produce clauses which turn out inconsistent in the many-valued logic given as source, but which are satisfiable in the target classical metalanguage. Accordingly, our method requires the hyper-resolution rules corresponding to the U -statements in order to make the proof method complete. The procedures presented in [1,7] do not produce such clauses, as unification on labels ensures that resolvents are always labelled by “meaningful” sets.
The extension of the above study to first-order logics endowed with distribution quantifiers does not seem so much of a technical challenge, but rather depends on previously extending the underlying reduction algorithm to the first-order case. A more interesting challenge —which we know how to solve, but the solution does not fit here in the margin— is the extension of the above study to cover logics with finite-valued nondeterministic matrices.

References
Baaz, M. and C. G. Fermu¨ller, Resolution for many-valued logics, Lecture Notes in Computer Science
624 (1992), pp. 107–118.
Baaz, M., C. G. Fermu¨ller and G. Salzer, Automated deduction for many-valued logics, in: J. A. Robinson and A. Voronkov, editors, Handbook of Automated Reasoning, II, Elsevier Science, 2001
pp. 1355–1402.
Caleiro, C., W. A. Carnielli, M. E. Coniglio and J. Marcos, Suszko’s Thesis and dyadic semantics, Research report, CLC/IST, 2003.
URL  http://sqig.math.ist.utl.pt/pub/CaleiroC/03-CCCM-dyadic1.pdf
Caleiro, C. and J. Marcos, Many-valuedness meets bivalence: Using logical values in an effective way, Journal of Multiple-Valued Logic and Soft Computing 19 (2012), pp. 51–70.
Caleiro, C., J. Marcos and M. Volpe, Bivalent semantics, generalized compositionality and analytic classic-like tableaux for finite-valued logics, Theoretical Computer Science 603 (2015), pp. 84–110.
H¨ahnle, R., “Automated Deduction in Multiple-Valued Logics,” Oxford University Press, 1993.
H¨ahnle, R., Short conjunctive normal forms in finitely valued logics, Journal of Logic and Computation
4 (1994), pp. 905–927.
Kova´cs, L., A. Mantsivoda and A. Voronkov, The inverse method for many-valued logics, in: F. Castro,
A. Gelbukh and M. Gonza´lez, editors, Advances in Artificial Intelligence and Its Applications, Lecture Notes in Computer Science 8265, Springer Berlin Heidelberg, 2013 pp. 12–23.
Plaisted, D. A. and S. A. Greenbaum, A Structure-Preserving Clause Form Translation, Journal of Logic and Computation 2 (1986), pp. 293–304.
Robinson, J. A., Automatic deduction with hyper-resolution, International Jounal of Computer Mathematics 1 (1965), pp. 227–234.
Robinson, J. A., A Machine–Oriented Logic Based on the Resolution Principle, Journal of the ACM
12 (1965), pp. 23–41.
Zach, R., “Proof Theory of Finite-Valued Logics,” Ph.D. thesis, TU-Wien (1993).
