Electronic Notes in Theoretical Computer Science 176 (2007) 39–63	
www.elsevier.com/locate/entcs

Structure and Properties of Traces for Functional Programs
Olaf Chitil and Yong Luo
Computing Laboratory University of Kent Canterbury, United Kingdom

Abstract
The tracer Hat records in a detailed trace the computation of a program written in the lazy functional language Haskell. The trace can then be viewed in various ways to support program comprehension and debugging. The trace was named the augmented redex trail. Its structure was inspired by standard graph rewriting implementations of functional languages. Here we describe a model of the trace that captures its essential properties and allows formal reasoning. The trace is a graph constructed by graph rewriting but goes beyond simple term graphs. Although the trace is a graph whose structure is independent of any rewriting strategy, we define the trace inductively, thus giving us a powerful method for proving its properties.
Keywords: Tracing, debugging, augmented redex trail, Haskell.

Introduction
Usually, a computation is treated as a black box that performs input and output actions. However, we have to look into the black box when we want to see how the different parts of the program cause the computation to perform the input/output actions. The most common need for doing this is debugging: When there is a disparity between the actual and the intended semantics of a program, we need to locate the part of the program that causes the disparity. Other reasons for observing how a program works are checking internal consistency properties (cf. assertions), reverse-engineering of an insufficiently documented program, and learning to pro- gram. Tracing is the process of obtaining additional information about the internal workings of a computation.
Tracing Functional Programs
Conventional forms of tracing are the introduction of specific statements in a pro- gram for logging information about the computation progress and the use of debug-

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.032

gers for stepping through a computation and inspecting the computation state. For lazy functional languages different tracing methods have been developed for two rea- sons. First, conventional methods are unsuitable, because intermediate terms with large unevaluated subterms are hard to read and the lazy reduction strategy is too complex for human programmers to follow. Second, conventional tracing methods reflect only the computational model of imperative programs: a long sequence of state transformations. In contrast, functional programmers want to ignore low-level operational details, in particular evaluation order, but take advantage of properties such as explicit data flow and absence of side effects.

What is a Trace?
A trace is a structure that consists of information about a computation. It (par- tially) describes how the computation of a program obtained its outputs from its inputs. If computation is deterministic (as we assume here), then the complete computation is already determined by the program and its inputs. So is a trace hence superfluous? No. Any detail of a computation can be reconstructed from program and inputs by rerunning the computation, but that would be expensive. The purpose of a trace is to provide quick and easy access to any desired informa- tion. Most viewing tools are interactive; hence they have to provide demanded bits of information quickly, in particular independent of the length of the computation. Operational semantics provide descriptions of computations. Both a sequence of terms M0 → M1 → M2 → ... of a small-step operational semantics and the proof tree of a big-step natural semantics are descriptions of computations. However, they are unsuitable as traces not just because they do not provide quick access to all desired information, but more obviously because they are full of redundancies.
In both these descriptions most parts of terms are replicated many times. A trace has to be as compact as possible to describe long computations.

Existing Tracing Systems
Several tracing systems for lazy functional languages are available, all for Haskell [26,19,12,27,22]. All systems take a two-phase approach to tracing:
During the computation information about the computation is recorded in a data structure, the trace.
After termination of the computation the trace is used to view the computation. Usually an interactive tool displays fragments of the computation on demand. The programmer uses their knowledge of the intended behaviour of the program to locate faults.
A trace is a complex graph of term components; most trace structures also incor- porate links to the source program. The trace as concrete data structure liberates the viewer from time and the sequential evaluation strategy.
Each tracing method gives a different view of a computation; in practice, the views are complementary and can productively be used together [7]. Hence the

Haskell tracer Hat integrates several methods [27]. During a computation a single unified trace, the augmented redex trail (ART), is generated. Separate tools provide different views of the ART, for example algorithmic debugging [23,19,22], following redex trails [26] and observing functions [12].

The Aim: A Theory of Tracing
Hat transforms a Haskell program into a new Haskell program. When the compiled new program is executed, it writes the ART to a file in addition to any normal I/O the original program would perform. This indirect definition of the ART through program transformation makes it hard to determine the ART of even a simple computation by hand. Because two programs are involved, the original and the transformed one, it is hard to disentangle which assumptions about the semantics of each are made. The ART also includes many special constructs, because Haskell is a large and complex language.
Therefore our aim is to give a direct and simple definition of the ART that captures its essential properties and will enable us to formally relate a view to the semantics of a program. Thus viewed information has a clear meaning and can be used correctly to understand a program and locate program faults.
The need for formalising tracing systems has been recognised:
“Programmers rely on the correctness of the tools in their programming envi- ronments. In the past, semanticists have studied the correctness of compilers and compiler analyses, which are the most important tools. In this paper, we make the case that other tools, such as debuggers and steppers, deserve semantic models, too, and that using these models can help in developing these tools.” [9]
We concentrate on the ART because it was already distilled as a unified trace from several other traces. This focus on the ART does not preclude revisions of its definition in the light of new insights. We are aware of several shortcomings (lack of information) that we intend to remove. Although the ART is only used for Haskell, it is suitable for both strict and non-strict pure functional languages, as our definition shall clarify.

Structure of the Paper
We first motivate our choice of programming language in Section 2. Then we give in Section 3 an informal introduction to the ART based on its origin in graph rewriting implementations of functional languages. Sections 4 and 5 define ARTs. In Section 6 we prove some simple properties of ARTs to get a better understanding and to demonstrate that our definitions allow relatively simple proofs. We prove in Section 7 that ARTs are acyclic directed graphs and in Section 9 that their structure is independent of any particular evaluation order. Section 8 establishes a property central to using ARTs for producing views of computations. Section 10 shows how ARTs can express runtime errors. We discuss related work in Section 11 and conclude in Section conclusion.

Programs
Operational semantics for functional languages that describe sharing, in particular the widely used semantics of Launchbury [15] and its variations, are defined for a subset of the λ-calculus plus a case construct for basic pattern matching. The con- structs of this core calculus were chosen to optimise the simplicity of the operational semantics. Any functional program can be translated into this core calculus and hence the core calculus is suitable for compilers. However, programs written in the core calculus look rather different from programs written by a programmer as the core calculus does not contain programming constructs mostly used in programs. Because a trace supports a programmer in understanding how a program works, it is essential that the trace relates to the program as originally written. Hence we choose a calculus that contains the most frequently used program language fea- tures: named functions and pattern matching. Our programs are applicative term rewriting systems [14].
function symbol f, g, h
data constructor C, D
atom	a, b := f	function symbol
| C	data constructor
variable x, y, z
program term M, N := a	atom
| x	variable
| M N application pattern	P := x	variable
| Q	constructor pattern
constructor pattern	Q := C	constructor
| QP  constructor application
We write M N1 ... Nn for the program term (...((M N1) N2) .. .)Nn and say that it is an application of M to n arguments. Each atom is associated with a natural number, its arity. Function symbols of arity 0 are sometimes called constant symbols.
Definition 2.1 If f is a function symbol of arity n and P1 ... Pn are patterns and R is a program term such that the variables of R are a subset of the variables of f P1 ... Pn, then f P1 ... Pn = R is a rewrite rule. A program is a finite set of rewrite rules.
The following example program implements insertion sort. We write applications of function symbols in infix or mixfix notation where this is common practice.
sort [] = []
sort (x:xs) = insert x (sort xs)


insert x [] = [x]
insert x (y:ys) = if x <= y then x:y:ys else y : insert x ys if True then x else y = x
if False then x else y = y
We do admit higher-order programs. For example, we could use the following alternative definition of sort:
sort = foldr insert []
The definition of programs lists all the constraints we need for the properties we prove. It is more general than required for writing functional programs. The definition does not require that all data constructors in patterns are fully applied, that is, the number of their arguments is equal to their arity. This constraint would only be needed for establishing a completeness of the operational rewriting seman- tics with respect to a denotational semantics. Our programs are not orthogonal rewriting systems [14]. We do not require rules to be left-linear; a variable may occur repeatedly in the left-hand side of the rule. In term rewriting left-linearity is already desirable to avoid an equality check of arbitrarily large terms, but in term graph rewriting there is no such expensive equality check anyway, because a variable is matched with a graph node. An orthogonal term rewriting system is confluent. We explicitly allow the left-hand sides of two rules to have a common instance and thus overlap. Thus we can leave the choice between these rules either to a separate evaluation strategy whose definition we leave open or we can model non-deterministic functions as they appear in functional logic programs. However, a left-hand side of a rule cannot overlap with a proper subterm of the left-hand side of a rule. Hence our programs are not subcommutative but almost subcommutative (Corollary 9.3).




The Origin of the Augmented Redex Trail

Term graph rewriting [21] provides an operational semantics for functional pro- grams that is abstract and closely related to standard term rewriting semantics. In contrast to terms, graphs allow the sharing of common subterms as it happens in real implementations of functional languages, such as the G-machine [13] or the more efficient STG-machine [20]. Term graph rewriting can correctly model the asymptotic time and space complexity of real implementations [1]. For us sharing is the key for a space efficient trace structure and closeness to the implementation also promises easy creation of a trace.
Consider the representation of the Haskell term sort [’t’] as term graph ([’t’] is syntactic sugar for (:) ’t’ []):




The function sort is defined by the following two rewrite rules:
sort [] = []
sort (x:xs) = insert x (sort xs)
We perform a reduction step with the second equation:

For this reduction step we have added new graph nodes that represent the right- hand side of the used rewrite rule. We have a new root node denoting the top of the term. To ensure that the new top node is correctly shared (when the redex is only part of a larger term), implementations actually overwrite the top node of the redex with the top node of the reduct. Some graph nodes become unreachable from the root and are removed by a garbage collector:


It is vital for the efficiency of graph rewriting that each reduction step only adds a small number of new nodes; subterms that are bound to the variables of the rewrite rule are shared with the redex graph and hence need not be added.
For tracing a computation we simply do not overwrite the redex with the reduct, but construct the reduct separately (sharing subterms with the redex as above) and connect the top nodes of redex and reduct by a special reduction edge.
Using also the rewrite rules
sort [] = []
insert x [] = [x]
we obtain the following trace of a complete computation (dotted arrows are reduc- tion edges):

This is the augmented redex trail (ART) of the computation. It is a compact but detailed representation of the computation; in particular, it directly relates each redex with its reduct. Its creation in both practise and theoretical model is greatly simplified by the fact that each reduction step only adds to the trace but never modiﬁes the already existing parts.
As described here the ART has no information about the order of reduction steps. It does not say that sort [] → [] happened before insert ’t’ [] → [’t’]. This information is irrelevant for most views provided by Hat. This observation agrees with our idea that functional programmers abstract from time. Because Hat writes the nodes of the ART into file in the order of their creation, timing information is actually available. If it later proves necessary, we can easily add it to our model.

Defining Term Graphs
Graphs have the disadvantage that the choice of node and edge elements is usually irrelevant because we are mostly interested in the labels. The notion of graph mor- phism becomes central, because we do not want to distinguish isomorphic graphs. Isomorphism classes of graphs are inconvenient to handle. Hence we choose a stan- dard representation of graphs where a node describes the path from the root of the graph to the node. A node is a (possibly empty) string of the letters f, a and r,

where f means going to the function component of an application, a means going to the argument component of an application, and r means following a reduction edge to the reduct.
node letter	i, j := f | a | r
node n, m, o ∈ {f, a, r}∗

Because of sharing, several paths may lead to the same node in the graph. However, in our term graphs there exist canonical paths. Every node is first introduced as part of an unshared representation of a term, either the initial term of the computation or a right-hand side of a rewriting rule. In the first case the canonical path of the node is the unique path within the initial term. In the second case the canonical path of the node consists of the canonical path of the redex node plus the unique path from the redex node through the right-hand side to the node itself. So a node contains useful information in that it describes its position within a reduct (or initial term) and the sequence of redex nodes that lead to its creation.
Here our previous example with node identities:

Each node of a term graph has a label, which may point to further nodes. We define a term graph such that it is as simple as possible. Then we discuss some design decisions in detail.

Definition 4.1
label T := a	atom
| nm application
| n	indirection
A term graph is a partial function from nodes to labels, G : n '→ T . The domain dom(G) of term graph G is the set of nodes for which the function is defined. We sometimes regard a term graph G as a set of tuples {(n, G(n)) | n ∈ dom(G)}.
Let the free nodes of a term graph be the nodes that occur in its labels but not its domain. A term graph is closed if it has no free nodes.

Our example graph pictured before is formally defined by

G(ε) = f a	G(f) = sort	G(a) = af aa	G(af) = aff afa


So dom(G) = {ε, f, a, af, aff, afa, aa, r, rf, rff, ra, raf, rar, rr, rrf, rrff, rra} and the set of labels of G is {f a, sort, af aa, aff afa, :, ’t’, [],.. .}.
We do not explicitly include reduction edges in the graph, because they are already implicitly given through our choice of nodes. A reduction edge always points from a node n to the node nr. If and only if node nr exists in the graph, there is a reduction edge from node n to node nr.
So to record a reduction we have to add at least one new node. This requirement causes a problem when we reduce with a projection, such as id x = x, because we do not want to copy any node. For this very purpose we have the indirection label; it appears only as reduct of a projection.



ε	r







The solution of using an indirection node was inspired by graph machines for func- tional languages that use indirection nodes for similar purposes. The existence of an indirection node is also vital for traversing a term graph backwards, from (parts of) reducts to redexes [25].
Later we will often need the last node of a chain of edges where each edge is either a reduction edge or an edge from an indirection node:

Definition 4.2 Let G be a term graph and n ∈ dom(G). Then

[n|G = if nr ∈ dom(G) then [nr|G else if ∃m.G(n)= m then [m|G else n

For example, in the term graph G above [ε|G = ar and [f|G = f.

Defining Augmented Redex Trails
Labels are not nested. Labels do not include variables, because in rewriting variables will be replaced by nodes. Program terms do not include nodes. To describe rewriting we will need terms that include nodes.
Definition 5.1
term M, N := a	atom
| n	node
| x	variable
|  M N application
Terms contain both nodes and variables. A label term is a term that does not contain variables. A program term is a term that does not contain nodes (as defined before). A computation term is a term that contains neither variables nor nodes.
Not every term graph represents a computation. Augmented redex trails (ARTs) are defined inductively. The graph representation of an initial term M , graph(ε, M ), is an ART. If G is an ART and G reduces in one step with program P to G', that is, G →P G', then G' is an ART. Even shorter:
Definition 5.2 Let P be a program and M a computation term. A term graph G

with graph(ε, M ) →∗
G is an augmented redex trail (ART) for initial term M and

program P .
An ART is constructed by a finite number of reduction steps. The definition of ARTs could be extended to cover infinite, non-terminating computations, but then it would no longer be an inductive definition that enables simple proofs. In practice we can produce a trace only for a finite number of steps; we cannot produce some limit of an infinite number of steps.
To correctly describe sharing of subterms between the redex and the reduct of a reduction step, we have to substitute nodes (instead of terms) for the variables of a rewrite rule. Hence several subsequent definitions handle label terms.
First we have to define what the graph for a given label term is.
Definition 5.3

graph(n, a)= {(n, a)}
graph(n, m)= {(n, m)}
{(n, M N )}	, if M , N are nodes


graph(n, M N )= 
{(n, nf N )}∪ graph(nf,M )	, if only N is a node
{(n, nf na)}∪	, otherwise
⎪

⎩	graph(nf,M ) ∪ graph(na,N )

There is no optimisation to share common subterms of the given label term; for example, we do not share the common subterm f 42 of the term if g fa then f
42 else (f 42) + 1.
Lemma 5.4 Let n, m and o be any nodes, i a letter and M a label term. Let
G = graph(n, M ).
G is a term graph.
dom(G) ⊂ n{f, a}∗.
mi ∈ dom(G) implies m ∈ dom(G) or mi = n.
The free nodes of G are a subset of the nodes occurring in M.
If M contains no node ending in r, then the labels of G contain no node ending in r.
o ∈ dom(G) ∧ G(o)= m =⇒ o = n ∧ M = m.
nf ∈ dom(G) =⇒ ∃m.G(n)= nf m and
na ∈ dom(G) =⇒ ∃m.G(n)= m na.
Proof. By induction on M . To show that graph(n, M ) is a term graph we show that there is only one tuple for each node in the set representation.	 
The central part of a reduction step is matching a node in the graph with the left-hand side of a rewrite rule. The predicate matchG(n, M ) checks whether node n matches label term M in term graph G.
Definition 5.5 Matching is defined inductively over the structure of the matched label term:
matchG(o, a)= (G(o)= a)
matchG(o, M N )= ∃m, n.(G(o)= m n) ∧
matchG(if M is a node then m else [m|G ,M ) ∧
matchG(if N is a node then n else [n|G,N ) matchG(o, m)= (o = m)
Before we discuss this definition of matching we define also what a reduction step is:
Definition 5.6 The reduction relation →P on term graphs for program P is defined as follows. If
G is a term graph with n ∈ dom(G) and nt ∈/ dom(G),
L = R is a rewrite rule of the program P ,
σ is a substitution replacing variables by nodes,
matchG(n, Lσ),
then G →P,n G ∪ graphG (nr, Rσ) with rewrite rule L = R and substitution σ.

Matching has been defined with care to ensure that a node in the label term matches a node in the graph only if it appears directly as part of an application node in the graph. Consider the ART



ε







and the rewrite rule id x = x.  We find that the label term id x[a/x] = id a
matches at node ε:



matchG(ε, id a)
=(G(ε)= f a) ∧ matchG(if id is a node then f else [f|G , id)∧
matchG(if a is a node then a else [a|G , a)
=true ∧ matchG([f|G, id) ∧ matchG(a, a)
=matchG(f, id) ∧ matchG(a, a)
=true


So in one step the ART can be rewritten to the ART shown in the previous section. However, label term id x[ar/x]= id ar does not match at node ε:



matchG(ε, id ar)
=(G(ε)= f a) ∧ matchG(if id is a node then f else [f|G , id)∧
matchG(if ar is a node then a else [a|G, ar)
=true ∧ matchG([f|G, id) ∧ matchG(a, ar)
=matchG(f, id) ∧ matchG(a, ar)
=true ∧ false
=false


So our graph cannot be rewritten to the term graph




ε	r







Indeed this term graph is not an ART. Why do we explicitly exclude it? Well, otherwise we would have several structurally different graphs representing the same reduction step. Multiple representations just cause confusion and would later lead us to give a complex definition of an equivalence class of graphs. Instead we choose a canonical representation: in a reduction step we only replace a variable by a node that is the start node of a possibly long sequence of reduction and indirection edges. Thus a substitution for matching a program term is basically uniquely defined:
Lemma 5.7 Let G be a term graph with matchG(m, Mσ) and matchG(m, Mσ') for a program term M and substitutions σ and σ' replacing variables by nodes. Then σ(x)= σ'(x) for all variables x occurring in M.
Proof. Induction on M .
M = x: matchG(m, xσ) ⇒ m = σ(x). matchG(m, xσ') ⇒ m = σ'(x). Hence
σ(x)= σ'(x).
M = a: Trivial, because there are no variables occurring in a.
M = N O: matchG(m, (N O)σ) and matchG(m, (N O)σ') imply that there exist n,o, n' and o' such that G(m) = no and matchG(n',Nσ), matchG(o', Oσ), matchG(n',Nσ') and matchG(o', Oσ'). With the induction hypothesis follows that σ(x)= σ'(x) for all variables in N and O, that is, all variables in N O.

Why did we choose the start node of a sequence of reduction and indirection edges instead of, for example, the last one? If we chose a different node the graph would contain some partial (but not complete) information about the evaluation order and term graph reduction would no longer be almost subcommutative. These properties will be expressed in Proposition 9.2 and Corollary 9.3. In the practical implementation of Hat it also turned out that the choice of the start node is the easiest to implement.
Lemma 5.8 Let G be a closed term graph with matchG(n, Lσ) for a left-hand side
L of a rewrite rule and a substitution σ replacing variables by nodes. Then:
n is an application or a constant symbol node.
The nodes occurring in Lσ are a subset of the nodes appearing in labels of G.
The nodes occurring in Lσ are a subset of dom(G).

Proof.
L is an application or a constant symbol, thus so is Lσ. Then the property follows straight from the definition of match.
By induction on the definition of match.
Follows from ii because G is closed.
 
Definition 5.9 Let G be an ART with n ∈ dom(G) and nr ∈ dom(G). Then we call n a redex node and nr a reduct node of G.

Simple Properties of the ART
In this section we list a number of properties of the ART that give a feeling for the structure of an ART and the constraints it meets compared to an arbitrary term graph. Such simple properties can also be of practical value: Hat comprises a tool called hat-check that performs a number of sanity checks on an ART generated by Hat. This testing tool proved very valuable for discovering faults in the Hat tracer. The checks of hat-check are relatively low-level and implementation dependent, but should be extended to include most of the properties listed here. The proof of each property takes advantage of the inductive definition of an ART and uses some related properties of matching and graph construction.
Definition 6.1 A set of nodes S is prefix-closed if nm ∈ S =⇒ n ∈ S.
Lemma 6.2 A node set S is preﬁx-closed if and only if for all nodes n and letters
i, ni ∈ S =⇒ n ∈ S.
Proof. By induction on the node length.	 
Proposition 6.3 The domain of an ART G is prefix-closed.
Proof. We prove by induction on the definition of ARTs that for all nodes n and letters i, ni ∈ dom(G) =⇒ n ∈ dom(G). In both base and inductive case we need Lemma 5.4.iii. Finally prefix-closedness follows with Lemma 6.2.	 
Proposition 6.4 An ART is closed.
Proof. Induction on the definition of ARTs. Either G = graph(ε, M ) for an initial term M ; then, according to Lemma 5.4.iv, G has no free nodes. Otherwise we assume G is closed and have to prove that G ∪ graph(nr, Rσ) is closed. We know from matchG(n, Lσ) and Lemma 5.8.iii that the nodes occurring in Lσ are a subset of dom(G). Because R contains no nodes and the variables of R are a subset of the variables of L, the nodes occurring in Rσ are a subset of dom(G). With Lemma 5.4.iv follows that the free nodes of graph(n, Rσ) are a subset of dom(G). So G∪ graph(nr, Rσ) is closed.	 
Proposition 6.5 No label of an ART contains a node ending in r.

Proof. Induction on the definition of ARTs. Consider G = graph(ε, M ). The initial term M contains no nodes and thus according to Lemma 5.4.v G contains no node ending in r. Otherwise let G be an ART such that no label contains a node ending in r. With matchG(n, Lσ) follows according to Lemma 5.8.ii that Lσ contains no node ending in r. Because the variables of R are a subset of the variables of L and R contains no nodes, Rσ contains no node ending in r. With Lemma 5.4.v follows that the labels of graph(n, Rσ) contain no node ending in r. So the labels of G∪ graph(n, Rσ) contain no node ending in r.	 
Proposition 6.6 In an ART only a node ending in r can be an indirection. That is, if G(n)= m, then n ends in r.
Proof. Induction on the definition of ARTs. Case G = graph(ε, M ): The initial term M is not a node, so according to Lemma 5.4.vi there is no n with G(n) = 
m. Case G = G' ∪ graph(or, Rσ): Let n ∈ dom(G) such that G(n) = m. Either n ∈ dom(G') and then according to the induction hypothesis n ends in r. Or n ∈ dom(graph(or, Rσ)). Then according to Lemma 5.4.vi n = or, so n ends in r. 
Proposition 6.7 If n is a redex node of an ART G, then it is either an application or a constant symbol node, that is, G(n)= mo or G(n)= f.
Proof. Induction on the definition of ARTs. Case G = graph(ε, M ): Because of Lemma 5.4.ii G contains no node ending in r, hence no redex node. Case G = G' ∪ graph(mr, Rσ): Let n be a redex node of G. Because mr is the only node ending in r in dom(graph(mr, Rσ)) according to Lemma 5.4.ii, n ∈ dom(G'). If n = m, then according to Lemma 5.8.i n is an application or a constant symbol node. Otherwise n is a redex node of G' and according to the induction hypotheses it is an application or a constant symbol node.	 
Proposition 6.8 Let G and G' be ARTs with G →∗  G' and n ∈ dom(G). Then
[n|G' = [[n|G|G' .
Proof. By induction on the definition of [n|G.
nr ∈ dom(G): So nr ∈ dom(G'). Hence [n|G' = [nr|G' and [n|G = [nr|G and with the induction hypothesis [nr|G' = [[nr|G|G' the property follows.
nr ∈/ dom(G) and G(n) = m: Then G'(n) = m and because of Proposition 6.7
nr ∈/ dom(G').  So [n|G'  = [m|G'  and [n|G = [m|G and with the induction
hypothesis [m|G' = [[m|G|G' the property follows.
nr ∈/ dom(G) and G(n) /= m: Then [n|G = n and the property holds trivially.

Proposition 6.9 Let G be an ART. If nf ∈ dom(G), then G(n) = nf m for some node m. If na ∈ dom(G), then G(n)= m na for some node m.
Proof. Induction on the definition of ARTs, using Lemma 5.4.vii.	 

No Cycles in an ART
For rewriting a constant symbol our definition deviates from real implementations and the real Hat ART. There a constant symbol is only reduced once during a whole computation and the reduct is shared by all use occurrences of the constant symbol. Modelling this behaviour would add substantial complexity; in particular, because constant symbols can be recursive, it would lead to cyclic ARTs and infinite (regular) terms. Hence we leave this extension and a comparison with the simpler model defined here for future work.
To express that an ART is acyclic we first have to define reachability of nodes:
Definition 7.1 The direct reachability relation for a term graph G is the least binary relation on nodes ~G with
G(n)= m =⇒ n ~G m
G(n)= mo =⇒ n ~G m and n ~G o n, nr ∈ dom(G) =⇒ n ~G nr
Proposition 7.2 An Art G is acyclic, that is, for all n ∈ dom(G) we have n /~+ n.
Proof. Induction on the definition of ARTs using Lemma 7.3.	 
Lemma 7.3 Let G be an ART with node m and M a label term that is not a node with matchG(m, M ). For all nodes o in M we have m ~+ o.
Proof. Induction on the definition of match.	 
Because any ART has only a finite number of nodes we immediately get:
Corollary 7.4 Reachability is terminating in an ART G, that is, there is no inﬁnite sequence n0 ~G n1 ~G n2 ~G .. ..
Because an ART G is terminating, the last node of a chain, [m|G, is defined for all nodes m, and so is matchG(m, M ).

Reconstructing Reduction Steps
A reduction step producing a new ART from an old ART uses a rewrite rule of the program, similar to any graph rewriting based abstract machine for implementing a functional language. This property does not yet indicate that the ART is an ex- pressive representation of the whole computation history from initial term to final result (or abortion), suitable for fault localisation and program comprehension. It is a central property of the ART that every reduction step performed in its construc- tion can easily be reconstructed from it, without having to rerun the computation, simply by traversing a small part of the graph.
Because of reduction edges, a single node of a term graph usually represents many computation terms. We obtain the most evaluated form of node n of graph G, mefG(n), by always following reduction and indirection edges:

Definition 8.1 Let G be an ART with redex node n.
mefG(n)= mefTG(G([n|G)) mefTG(a)= a
mefTG(m n)= mefG(m) mefG(n)
In the following we apply mefG not just to a node but use its homomorphic extension for a label term. We write such an application in postfix notation, for example M mefG, like the application of a substitution.
We can also reconstruct other computation terms from a node. From a redex node we can reconstruct a redex:
Definition 8.2 Let G be an ART with redex node n.
redexG(n)=	mefG(m) mefG(o)	, if G(n)= mo 
a	, if G(n)= a

Redex, matching and most evaluated form are closely related. Note though that the definitions of redexG and mefG follow the graph structure whereas matchG is defined on the structure of the matched label term.
Proposition 8.3 Let G be an ART with node m and M a label term that is not just a node.
matchG(m, M )  =⇒  redexG(m)= M mefG
Proof. Case analysis.
G(m)= a: matchG(m, M ) ⇒ M = G(m)= a ⇒ redexG(m)= a = M mefG.
G(m) = n o: If M is an atom or node, then matchG(m, M ) = false. So let M = N O. matchG(m, N O) =⇒ matchG(if N is a node then n else [n|G,N ) ∧ matchG(if O is a node then o else [o|G , O). With Lemma 8.4 follows mefG(n) = N mefG ∧ mefG(o)= O mefG. Hence mefG(m)= mefG(n) mefG(o)= (N O) mefG.
 
Lemma 8.4 Let G be an ART with node m and M a label term.
matchG(if M is a node then m else [m|G,M )  =⇒  mefG (m)= M mefG

Proof. Induction on M .
M = a: matchG([m|G , a) ⇒ G([m|G)= a ⇒ mefG(m)= a = a mefG.
M = n: matchG(m, n) ⇒ (m = n) ⇒ mefG(m)= mefG(n)= n mefG.
M = N O: matchG([m|G ,N O) ⇒ ∃n, o.(G([m|G )= n o)∧matchG(if N is a node then n else [n|G ,N ) ∧ matchG(if O is a node then o else [o|G , O). With the in- duction hypothesis follows ∃n, o.(G([m|G) = n o) ∧ (mefG(n) = N mefG) ∧ (mefG(o)= O mefG). So mefG(n)= (N O) mefG.


The opposite direction of Proposition 8.3 does not hold for reasons already discussed in Section 5. In the example given there mefG(ε) = (id ar) mefG, but matchG(ε, id ar)= false.
The real Hat ART also includes so-called parent edges that we have not yet mentioned. Each node has a parent edge that points to the top node of the redex that caused its creation. Parent edges are the key ingredient for the redex trail view of locating program faults [26,25]. In this paper we will only use them to reconstruct a reduct from an ART. In our ART model parents are encoded in the nodes:
Definition 8.5
parent(nr)= n parent(nf)= parent(n) parent(na)= parent(n) parent(ε) = undefined
For example, the parent of node t is node ε. The parent of node rt is node r.
It is easy to recognise in a term graph all nodes that form a right-hand side of a rule: they all have the same parent. So using parent edges we can easily reconstruct a reduct from a reduct node:
Definition 8.6 Let G be an ART with redex node n. reductG(n) = reductPG(n, nr)
reductPG(p, n)= if parent(n)= p then reductTG(p, G(n)) else mefG(n)
reductTG(p, a)= a reductTG(p, m)= mefG(m)
reductTG(p, n o) = reductPG(p, n) reductPG(p, o)

Lemma 8.7 Let G be an ART with node m and M a label term with nodes none of whose parents is m. Then graph(mr,M ) ⊆G =⇒ reductG(m)= M mefG .
Proof. Follows from the following more general lemma.	 
Lemma 8.8 Let G be an ART with nodes m and p and M a label term with nodes none of whose parents is p.
parent(m)= p ∧ graph(m, M ) ⊆G =⇒ reductPG(p, m)= M mefG

Proof. Induction on M .
M = a: graph(m, a) ⊆ G ⇒ G(m) = a ⇒ reductPG(p, m) = reductTG(p, a) = 
a = a mefG.

M = n: graph(m, n) ⊆ G ⇒ G(m) = n ⇒ reductPG(p, m) = reductTG(p, n) = mefG(n)= n mefG(n).
M = N O: W.l.o.g. let N = n be a node and O not a node. graph(m, n O) ⊆ G ⇒ G(m) = N ma ∧ graph(ma, O) ⊆ G. With the induction hypothesis fol- lows reductPG(p, ma) = O mefG. Thus reductPG(p, m) = reductTG(p, n ma) = reductPG(p, n) reductPG(p, ma)= mefG(n) (O mefG)= (N O) mefG.

The preceding definitions of mef, redex and reduct are all total on their specified domain, because reachability in ARTs is terminating.
Proposition 8.9 Let G' →P,n G'' with rewrite rule L = R ∈ P and node substitu-
tion σ. For all G with G'' →∗ G
redexG(n)= LσmefG  and  reductG(n)= RσmefG .
Proof. This follows from Lemmas 9.2, 8.3 and 8.7 and the fact that graph(nr, Rσ) ⊆
G.	 

Evaluation Order
Our rewriting is non-deterministic. We have not defined any reduction strategy. All properties given in this paper hold without reference to any particular reduction strategy. This generality proves that the ART can be used for different reduction strategies, in particular for optimising implementations of non-strict functional lan- guages that mix eager and lazy evaluation [11,18,10]. For a language with strict semantics we would need to disallow some reduction steps, but otherwise all def- initions and properties carry over as well. For using an ART to locate a fault it is only important that every reduction step is correct with respect to the language semantics. 1
Our programs are almost non-overlapping. For generality we do allow for non- deterministic functions; we do permit the left-hand sides of two rewrite rules for the same function symbol to have common instance. There may be different computa- tions for the same program and initial term. Hence normal rewriting and thus also ART rewriting cannot be confluent. However, rewriting on ARTs is almost sub- commutative, which means that whenever an ART has several unreduced redexes, these can be reduced in any order always yielding the same ART.
We first need a lemma that says that no rewriting can take place in the part of the term graph representing a proper subterm of a left-hand side of a rewrite rule.
Lemma 9.1 Let G be a term graph with node n, L the left-hand side of a rewrite rule of program P and σ a substitution replacing all variables of L by nodes. Let V

1 For analysing the ART of a non-terminating computation we will have to make some assumptions about the completeness of the reduction strategy.

be a proper subterm of Lσ that is not just a node. Then
matchG(n, V ) ∧G →P G' =⇒ [n|G' = n

Proof. Suppose nr ∈ G'. Because matchG(n, V ), nr ∈/ G. So there exists a left-hand side L' of a rewrite rule and a substitution σ' with matchG(n, L'σ'). With Propo- sition 8.3 follows both redexG(n) = L'σ'mefG and redexG(n) = V mefG. However, L'σ'mefG = V mefG contradicts the definition of rewrite rules and in particular the definition of patterns.
Suppose G'(n)= m for a node m. Then G(n)= m. However, according to the definition of matching this contradicts with matchG(n, V ).
Altogether nr ∈/ G' and G'(n) is not a node. So [n|G' = n.	 
When a left-hand side of a rewrite rule or a proper subterm of it matches a term graph, then it will do so in the future:
Proposition 9.2 Let G be a term graph, L the left-hand side of a rewrite rule of program P and σ a substitution replacing all variables of L by nodes. Let N be a subterm of Lσ (including N = Lσ).
matchG(n, N ) ∧G →P G' =⇒ matchG' (n, N )
Proof. Induction on N .
N = m for some node m.
matchG(n, m) ⇒ n = m ⇒ matchG' (n, m).
N = a for some atom a.
Then G(n)= a. Because of G ⊆ G', G'(n)= a. So matchG' (n, a).
N = M O for some proper subterms M and O of a left-hand side instance. Then there exist m and o with G(n)= mo ∧ matchG(if M is a node then m else [m|G ,M ) ∧ matchG(if O is a node then o else [o|G , O). With the induction hy- pothesis follows matchG' (if M is a node then m else [m|G ,M ) ∧ matchG' (if O is a node then o else [o|G , O). According to Lemmas 9.1 and 6.8, if M is a node, then [m|G' = [[m|G|G' = [m|G. Similarly, if O is a node, then [o|G' = [[o|G|G' = [o|G. So matchG' (if M is a node then m else [m|G' ,M ) ∧ matchG' (if O is a node
then o else [o|G' , O). Because of G ⊆ G', G'(n)= m o. Altogether matchG' (n, M O).
 
Corollary 9.3 Rewriting on ARTs is almost subcommutative, that is, if G →P,n1 G1 and G →P,n2 G2 with n1 /= n2, then there exists an ART G' with G1 →P,n2 G' and G2 →P,n1 G'.
Proof. G →P,n1 G1 and G →P,n2 G2 implies by definition of rewriting that there exist rewrite rules L1 = R1 and L2 = R2 and substitutions σ1 and σ2 with

matchG(n1, L1σ1) and matchG(n2, L2σ2) and n1r, n2r ∈/
dom(G). With Proposi-

tion 9.2 follows matchG2 (n1, L1σ1) and matchG1 (n2, L2σ2). With n1 /= n2 follows

n1r ∈/
dom(G2) and n1r ∈/
dom(G1). Hence G2 →P,n1 G' and G1 →P,n2 G' where

G' = G ∪ graph(n1, L1σ1) ∪ graph(n2, L2σ2).	 
If a program is actually non-overlapping, not just almost non-overlapping, then rewriting on ARTs is subcommutative and thus also confluent.

Runtime Errors
The main aim of tracing is to support locating the cause of an observed faulty behaviour. For functional programs there are three types of faulty behaviour: an incorrect result, a runtime error or non-termination. As currently defined an ART is useful for locating the cause of an incorrect result and it may also be used to consider an interrupted non-terminating computation. However, we have not yet modelled any runtime error. A runtime error may be raised by a built-in function, but for our programs the most natural source of a runtime error is pattern match failure. The left-hand sides of rewrite rules for a function symbol may not be complete, for example for a function determining the head element of a (non-empty) list.
We extend our data constructors by a special one called error that does not appear in the pattern of any rewrite rule. We extend our term graph reduction relation:
Definition 10.1 We extend Definition 5.6 of the reduction relation →P on term graphs for program P as follows: If
f is a function symbol of arity n and P1,... , Pn patterns,
for all substitutions of computation terms for variables σˆ and all rewrite rules
L = R ∈ P we have Lσˆ /= (f P1 ... Pn)σˆ,
G is a term graph with n ∈ dom(G) and nr ∈/ dom(G),
σ is a substitution replacing variables by nodes,
matchG(n, (f P1 ... Pn)σ), then G →P G ∪ {(nr, error)}.
So if in a term graph all arguments of a full application are fully evaluated, then this full application can be reduced.
Because error does not appear in the pattern of any rewrite rule, a reduction step yielding error will usually start a chain of pattern match failure reduction steps that promote the runtime error to the outermost reduction.

Related Work
The first papers on semantical foundations for tracing [3,2,9] describe methods where stepping through a computation and viewing information are firmly linked. In con- trast, we study here a tracing method that relies on the decoupling of computation and viewing through the generation of a trace as self-contained data structure. Ex- isting indirect definitions of traces through descriptions of their generation [12,22,8]

and even the simplified definition in [19] are too complex to prove theorems and make it hard to distinguish incidental implementation features from essential links to the semantics of the traced program.
The redex trail trace was introduced in [26,25] for a particular viewing method. The programmer explores a computation backwards, from an effect — such as output or a runtime error — to its cause. Hence the most important component of a redex trail are the parent edges, which point from each part of a reduct to its redex. The redex trail has no reduction edges. These were added in [27] to obtain the augmented redex trail (ART) which thus supports several different views of a computation.
The first author sketched a semantics for ARTs in [6]. This semantics is only for a small core language into which the full language has to be translated and it is still too complex for proving interesting properties. A formal definition of an ART- like trace for a functional-logic language has been given by extending an abstract machine to generate the trace [4]. This paper also uses a small core language and proofs are hard. Although the trace is very similar to the ART, it differs in two respects (besides small extensions for logical variables and non-determinism): First, parent edges have a different meaning; the parent edge of an expression points to the dynamic redex that forced its evaluation, not the static redex that produced it. Second, the trace only contains expressions that were needed for the computation, that is, that were matched against in a reduction or that are part of the final result. In contrast we defined the ART here so that a reduction step always adds the full right-hand side of the rewrite rule to the trace, even if parts of that will never be used. In [24] we consider a variant of our definition that allows for non- deterministically adding only a part of a right-hand side. We intend to explore this variant further.
Algorithmic debugging is a semi-automatic method for locating a faulty rewrite rule in a program [23,19,22]. [5] prove that algorithmic debugging is correct for functional logic programs, that is, if a computation yields an incorrect result, then algorithmic debugging correctly locates the faulty rewrite rule. The paper does not use a trace data structure but describes algorithmic debugging abstractly through a non-deterministic big-step semantics. However, algorithmic debugging is based on a tree-based representation of the computation, the evaluation dependency tree (EDT). We showed in [16] how the EDT can easily be constructed from the ART and using the ART we proved the correctness of algorithmic debugging. Recently we extended this correctness result to ARTs from which some parts that represent unevaluated expressions have been removed [17]. With our definition of runtime errors the correctness result also applies to computations that abort with a runtime error whereas [5] only handles computations that produce incorrect results, because unevaluated expressions (replaced by ⊥) and runtime errors are not distinguished.

Conclusions and Further Work

We have motivated and presented a theory of tracing for functional programs. We have given a formal definition of the augmented redex trail (ART). The ART is a complex structure that encodes a wealth of information about a computation such that it can easily be retrieved but the ART is still compact. Nonetheless our definition is relatively simple and can be used for formal proof as numerous exam- ples demonstrate. Although the ART is a graph that takes advantage of sharing, we have given an inductive definition, thus making the powerful inductive proof method available for proofs about ARTs. Despite this inductive definition, the ART is inde- pendent of any particular evaluation order, demonstrating that we really abstract from such low-level details. It was non-trivial to prove that the ART is acyclic. Most importantly we have shown how each reduction step of a computation can easily be reconstructed from the ART. These reconstructed reductions are used in nearly all views of computations based on the ART.
Future work goes in two orthogonal directions. First, we have to determine and prove essential properties of various views based on ARTs. We have already proved the correctness of the algorithmic debugging method based on ARTs and intend to prove similar results for other views, in particular the redex trailing method for locating faults.
Second, we intend to extend the programming language and make our model of the real ART even more realistic. Currently we are studying two extensions. We add local rewrite rules to the programming language. Information about the value of a free variable, such as variable x of function f in the definition
g x y z = f y + f z where
f v = v + x
needs to be available in the trace. The current ART is acyclic, but implementations of lazy functional languages actually create cyclic graphs for constants such as
ones = 1 : ones
The real ART produced by Hat also contains cycles in such cases and it is well known that these cause problems for example for algorithmic debugging. We in- tend to compare definitions of ARTs with and without cycles to determine which information is lost.



Acknowledgements

The work reported in this paper was supported by the Engineering and Physical Sciences Research Council of the United Kingdom under grant EP/C516605/1.

References
Adam Bakewell. Using term-graph rewriting models to analyse relative space efficiency. In TERMGRAPH 2002 International Workshop on Term Graph Rewriting, volume 72 of Electronic Notes in Theoretical Computer Science. Elsevier Science Publishers, 2002.
K. Bernstein and E. W. Stark. On formally defining debuggers: A comparison of three approaches. In
2nd International Workshop on Automated and Algorithmic Debugging, St. Malo, France, May 1995.
Karen L. Bernstein and Eugene W. Stark. Operational semantics of a focusing debugger. In Proceedings of the Eleventh Conference on the Mathematical Foundations of Programming Semantics, ENTCS 1. Elsevier, 1995.
Bernd Braßel, Michael Hanus, Frank Huch, and German Vidal. A semantics for tracing declarative multi-paradigm programs. In Proceedings of the 6th ACM-SIGPLAN International Conference on Principles and Practice of Declarative Programming, pages 179–190. ACM Press, 2004.
Rafael Caballero, Francisco J. L´opez-Fraguas, and Mario Rodr´ıguez-Artalejo. Theoretical foundations for the declarative debugging of lazy functional logic programs. In Functional and Logic Programming, FLOPS 2001, LNCS 2024. Springer, 2001.
Olaf Chitil. A semantics for tracing. In Thomas Arts and Markus Mohnen, editors, Draft Proceedings of the 13th International Workshop on Implementation of Functional Languages, IFL 2001, pages 249–254, A¨ lvsjo¨, Sweden, September 2001. Ericsson Computer Science Laboratory.
Olaf Chitil, Colin Runciman, and Malcolm Wallace. Freja, Hat and Hood — A comparative evaluation of three systems for tracing and debugging lazy functional programs. In Markus Mohnen and Pieter Koopman, editors, Implementation of Functional Languages, 12th International Workshop, IFL 2000, LNCS 2011, pages 176–193. Springer, 2001.
Olaf Chitil, Colin Runciman, and Malcolm Wallace. Transforming Haskell for tracing. In Proceedings of the 14th International Workshop on Implementation of Functional Languages (IFL 2002), LNCS 2670, pages 165–181, 2003.
John Clements, Matthew Flatt, and Matthias Felleisen. Modeling an algebraic stepper. In David Sands, editor, 10th European Symposium on Programming, ESOP 2001, LNCS 2028, pages 320–334. Springer, 2001.
Robert Ennals and Simon Peyton Jones. Optimistic evaluation: an adaptive evaluation strategy for non-strict programs. In ICFP ’03: Proceedings of the eighth ACM SIGPLAN international conference on Functional programming, pages 287–298, New York, NY, USA, 2003. ACM Press.
Karl-Filip Fax´en. Cheap eagerness: speculative evaluation in a lazy functional language. In ICFP ’00: Proceedings of the fifth ACM SIGPLAN International Conference on Functional programming, pages 150–161, New York, NY, USA, 2000. ACM Press.
Andy Gill. Debugging Haskell by observing intermediate data structures. Electronic Notes in Theoretical Computer Science, 41(1), 2001. 2000 ACM SIGPLAN Haskell Workshop.
Thomas Johnsson. Efficient compilation of lazy evaluation. In Proceedings of the SIGPLAN ’84 Symposium on Compiler Construction, pages 58–69. ACM Press, 1984.
J.W. Klop. Term rewriting systems. In S. Abramsky, M. Gabbay, and T.S.E. Maibaum, editors,
Handbook of Logic in Computer Science, volume 2, pages 1–116. Oxford University Press, 1992.
John Launchbury. A natural semantics for lazy evaluation. In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 144–
154. ACM Press, 1993.
Yong Luo and Olaf Chitil. Proving the correctness of algorithmic debugging for functional programs. In Draft Proceedings of the Seventh Symposium on Trends in Functional Programming, TFP 2006, Nottingham, UK, April 2006.
Yong Luo and Olaf Chitil. Replacing unevaluated parts in the traces of functional programs. In Draft Proceedings of the 18th International Symposium on Implementation and Application of Functional Languages, IFL 2006, pages 304–325, Budapest, Hungary, 2006. E¨otv¨os Lor´and University. Technical Report No: 2006-S01.
Jan-Willem Maessen. Eager Haskell: resource-bounded execution yields efficient iteration. In Haskell ’02: Proceedings of the 2002 ACM SIGPLAN workshop on Haskell, pages 38–50, New York, NY, USA, 2002. ACM Press.
Henrik Nilsson. Declarative Debugging for Lazy Functional Languages. PhD thesis, Linko¨ping, Sweden, May 1998.
Simon L. Peyton Jones. Implementing lazy functional languages on stock hardware: The spineless tagless G-machine. Journal of Functional Programming, 2(2):127–202, April 1992.


Detlef Plump. Term graph rewriting. In H. Ehrig, G. Engels, H.-J. Kreowski, and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation, chapter 1, pages 3–61. World Scientific, 1999. Volume 2: Applications, Languages and Tools.
B. Pope and Lee Naish. Practical aspects of declarative debugging in Haskell-98. In Fifth ACM SIGPLAN Conference on Principles and Practice of Declarative Programming, pages 230–240, 2003.
E. Y. Shapiro. Algorithmic Program Debugging. MIT Press, 1983.
Josep Silva and Olaf Chitil. Combining algorithmic debugging and program slicing. In PPDP ’06: Proceedings of the 8th ACM SIGPLAN symposium on Principles and practice of declarative programming, pages 157–166, New York, NY, USA, 2006. ACM Press.
Jan Sparud and Colin Runciman. Complete and partial redex trails of functional computations. In C. Clack, K. Hammond, and T. Davie, editors, Selected papers from 9th Intl. Workshop on the Implementation of Functional Languages (IFL’97), pages 160–177. Springer LNCS Vol. 1467, September 1997.
Jan Sparud and Colin Runciman.  Tracing lazy functional computations using redex trails.  In
H. Glaser, P. Hartel, and H. Kuchen, editors, Proc. 9th Intl. Symposium on Programming Languages, Implementations, Logics and Programs (PLILP’97), pages 291–308. Springer LNCS Vol. 1292, September 1997.
Malcolm Wallace, Olaf Chitil, Thorsten Brehm, and Colin Runciman. Multiple-view tracing for Haskell: a new Hat. In Preliminary Proceedings of the 2001 ACM SIGPLAN Haskell Workshop, UU-CS-2001-
23. Universiteit Utrecht, 2001. Final proceedings to appear in ENTCS 59(2).
