Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 284 (2012) 23–34
www.elsevier.com/locate/entcs


Towards Abstraction-Based Verification of Shape Calculus
F. Buti, M. Callisto De Donato, F. Corradini, M.R. Di Berardini,
E. Merelli, L. Tesei1
School of Science and Technology, Computer Science Division University of Camerino
Via Madonna delle Carceri 9, 62032 Camerino, Italy

Abstract
The Shape Calculus is a bio-inspired timed and spatial calculus for describing 3D geometrical shapes moving in a space. Shapes, combined with a behaviour, form 3D processes, i.e., individual entities able to bind with other processes on compatible spatial channels and to split over previously established bonds. Due to geometrical space, timed behaviours, a wide degree of freedom in defining motion laws and usual non- determinism, 3D processes typically exhibits an infinite behaviour that prevents any decidable analysis. Shape Calculus models are currently used only for simulation and, thus, validation of models and hypothesis testing. In this work we introduce a complementary, and synergetic, way of using the calculus for systems biology purposes: we define a first abstract interpretation that can be used to verify untimed and unspatial safety properties of a given model. Such an abstraction focuses on the possible interactions that, during the evolution of the system, can occur among processes yielding new composed processes and, thus, new species. Other possible abstract domains for the verification of more expressive properties are also discussed.
Keywords: Abstract interpretation, Process algebra, Spatiality, Systems Biology


Introduction
In the context of the challenges raised by Systems Biology to several disciplines, com- puter scientists, among others, have started to contribute trying to adapt models and languages designed originally for the design and the analysis of hardware/software systems to biological systems. This adaptation process has revealed that some of the languages, although general-purpose, needed to be expanded with concepts and characteristics typical of biological modelling. One of these features is surely space, considered both in a topological and a geometrical way. For instance in [3], authors outline a modelling and simulation approach which covers not only the simulation of individual entities moving in space but also the stochastic spatial simulation at the

1 Email: {federico.buti,massimo.callisto,flavio.corradini,mariarita.diberar- dini,emanuela.merelli,luca.tesei}@unicam.it

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.05.013

population level and the combination of the two. In [11], instead, the rule-based ap- proach is extended to take in account position, orientation and geometric structure of molecules in combinatorially complex chemical reaction systems.
In this context, the Shape Calculus [2,1] was proposed as a very rich language to describe mainly, but not only, biological phenomena. The main characteristics of this calculus are that it is spatial - with a geometric notion of a 3D space - and it is shape-based, i.e., entities have geometric simple or complex shapes that affect
the possible interactions with other entities. In the Shape Calculus we consider 3D
processes consisting of entities with a 3D shape and a dynamic behaviour, situated in a 3D virtual environment. 3D processes move accordingly to a personalized (to each process) motion law, collide and possibly bind each other and compound new 3D processes. Thus, a network of interacting 3D processes typically exhibits infinite behaviours. On the one hand the expressive power of the calculus is very high and it embeds natively features that are typical of biomodels. On the other hand, this richness and infiniteness prevents any application of analysis techniques existing for untimed and/or unspatial systems. Currently, Shape Calculus models are used as a base for a related simulation environment, called BioShape [5], that is used for model definition, simulation and validation [4,7] as well as for hypothesis testing and uniform multi-scale simulations [6].
Orthogonal to simulation-based analysis techniques, a more formal, and possibly synergetic with simulation, approach to the study of Shape Calculus models is that of formal verification. In this work we investigate the application of the abstract interpretation framework [9,8] on the Shape Calculus to reduce the complexity of dynamics and, thus, to obtain the decidability of verification of properties. As a first step, we consider an abstract domain in which time, movements and space are abstracted in order to focus only on all possible bounds and splits that can occur among processes. This permits to prove, by performing a finite fixpoint iteration, untimed and unspatial safety properties such as “a species formed by the binding of glucose and ATP can never be generated in the evolution of the system”.
The paper is structured as follows: Section 2 introduces the main concepts of the Shape Calculus, Section 3 describes the proposed abstract interpretation, finally Section 4 discusses other possible abstractions to verify more expressive properties.


Shape Calculus: a calculus for moving shapes
Let P, V = R3 be the sets of positions and velocities, resp., in a global three di- mensional coordinate system. We also assume relative coordinate systems, the local coordinate system, that will always be w.r.t. a certain shape S with origin in a refer- ence point p (the centre of S). The local coordinate system allows us to express parts of the shape independently from its actual global position. Given p ∈ P expressed in global coordinates and V ⊆ P a set of points expressed in a local coordinate system whose origin is p, the function global(V, p) = V + p = {x + p | x ∈ V } denotes V
w.r.t. the global coordinates.

Shapes
Any 3D shape can be approximated - with arbitrary precision - by composing basic shapes i.e. “glueing” shapes on common surface. Basic shapes can be spheres, cones, cylinders or convex polyhedra.
Definition 2.1 (3D shapes) The set S of 3D shapes, ranged over by S, Sj, ··· , is
generated by the grammar:  S ::= σ  S ⟨X⟩ S where σ is a basic shape.  A
basic shape is defined by the tuple σ = ⟨V, m, p, v⟩ where V ⊆ P, m ∈ R+ is the mass, p ∈ P the centre of mass and v ∈ V the velocity of σ.  If S = σ =
⟨V, m, p, v⟩, we define P(S) = V , m(S) = m, R(S) = p, v(S) = {v} to be, resp., the set of points, mass, reference point and velocity of σ.  B(S) ⊂ V is
the set of points on the surface of σ.  S = S1 ⟨X⟩ S2 is a compound shape 2
where X ⊆ P. We let P(S) = P(S1) ∪ P(S2), m(S) = m(S1)+ m(S2), R(S) = 
 m(S1) · R(S1)+ m(S2) · R(S2) / m(S1)+ m(S2)  3  and v(S)= v(S1) ∪ v(S2) 4 .
Finally we define the boundary of a compound shape S as the set of global points
B(S)= (B(S1) ∪ B(S2))\{x ∈ P | x is interior of P(S1) ⟨X⟩P(S2)}.
Continuous trajectories of shapes are approximated with a polygonal chain [10] and velocities are updated on the vertices of the chain, instead of continuously update them. Let T ∈ R+ be the time domain. We divide T into an infinite sequence of time steps ti s.t. t0 =0 and ti ≤ ti—1 +Δ for all i > 0, where Δ is called movement time step and depends on the desired degree of approximation. The updating of velocities is performed by exploiting a function steer : T → (S ‹→ V) 5 that describes how the velocity of all existing shapes, at each time t, is changed. Both velocity update and evolution of shapes are represented as an update of the shape tuples.
In some situations, the duration of a time step can be shorter than Δ since collisions can occur before the end of the time step. These collisions must be resolved and the whole system must re-adapt itself to the new situation through a collision response mechanism (see [2] for more details).

Behaviour of shapes
The internal behaviour of a shape is described as a variant of TCCS [12] where basic actions provide information about binding capabilities and split possibilities. Let Λ = {a, b, ···} be a countably infinite set of channels names and Λ = {a | a ∈ Λ} the corresponding co-channels names with a = a for each a. Elements in A = Λ ∪ Λ are ranged over by α, β, ··· .
Binding capabilities are represented by channels, i.e. pairs ⟨α, X⟩ where α ∈ A is a name and X is a surface of contact. Intuitively, X is a subset of the boundary of a shape where the channel is active and, thus, bindings are enabled on it. Names introduce a notion of compatibility: if β = α and X ∩ Y /= ∅ then ⟨α, X⟩ and ⟨β, X⟩

2 In this paper we consider only compound shapes that are well-formed according to [1].
3 Again for simplicity, we use the centre of mass as the reference point.
4 Well-formed shapes must have a singleton as set of velocities.
5 Given a time instant t ∈ T, steer tS is undefined iff shape S does not exist at time t.




Table 1
Functional and Temporal behaviour of B’s terms

are compatible, otherwise they are incompatible. Compatibility is used to determine if a collision between two shapes is elastic (channels not compatible) or inelastic (otherwise).
We also introduce two different kinds of actions, ω(α, X) and ρ(α, X), to repre-
sent weak and strong splits of shape bonds, respectively. With an abuse of notation, two strong-split actions ρ(α, X) and ρ(β, Y ) are compatible if so are the channels
⟨α, X⟩ and ⟨β, Y ⟩.  We will see that a synchronization between multiple pairs of
compatible strong-split actions correspond to a strong-split operation. Split opera- tions behave differently w.r.t. time passing: enabled strong-splits forbid time passing, while weak-splits can be arbitrarily delayed.
Let C be the set of all channels, ω(C) = {ω(α, X) | ⟨α, X⟩ ∈ C} and ρ(C) =
{ρ(α, X) | ⟨α, X⟩∈ C} be the sets of weak-split actions and strong-split actions, resp. Our processes perform atomic actions belonging to the set Act = C ∪ ω(C) ∪ ρ(C) whose elements are ranged over by μ, μj, ··· . We finally assume a countably infinite collection K of process name or process constants.
Definition 2.2 (Shape behaviours) The set of shape behaviours, denoted by B, is generated by the following grammar:
B ::= nil  ⟨α, X⟩.B  ω(α, X).B  ρ(L).B  ϵ(t).B  B + B  K
where ⟨α, X⟩ ∈ C, L ⊆ C (non-empty) whose elements are pairwise incompatible,
t ∈ T and K ∈ K.
As usual the nil operator can only let time pass without limits 6 . ⟨α, X⟩.B and ω(α, X).B are (action-)prefixing known from CCS. ⟨α, X⟩.B exhibits a binding capability along the channel ⟨α, X⟩, while ω(α, X).B models the behaviour of a shape that, before evolving in B, wants to split a single bond established via the channel ⟨α, X⟩. ρ(L).B is the strong-split operator; it can evolve in B only if all strong split actions ρ(α, X) with ⟨α, X⟩∈ L can be performed simultaneously. The other operators are the same as given in [12].
Rules in Table 1 define a weak 7 temporal transition relation ~t ⊆ (B × B) for

6 A trailing nil will often be omitted; e.g. ⟨α, X⟩.ω(α, X) abbreviates ⟨α, X⟩.ω(α, X).nil.
7 This weak relation is used when giving temporal semantics to 3D processes. It will become a real time passing if and only if a strong split of a compound process, which is considered urgent, is not enabled.




Table 2
Functional and temporal behaviour of 3DP-terms

t ∈ T and the action transition relation →⊆ (B × B) for μ ∈ Act. Most of the temporal rules are those provided in [12]. In our case rules Preft and Strt state that processes like ⟨α, X⟩.B, ω(α, X).B and ρ(L).B can be arbitrarily weak-delayed.

Regarding functional rules, the only worth noting are
Str1 and
Str2, defining

strong-split behaviours. If ⟨α, X⟩ ∈ L then ρ(L).B can do a ρ(α, X)-action and evolves either in B (if L = {⟨α, X⟩}) or in ρ(L\{⟨α, X⟩}).B (otherwise). Rule Str3 is needed to handle arbitrarily nested terms, e.g. ρ({⟨a, X}).ρ({⟨b, Y }).B. Other
rules are as expected. For brevity, symmetric rules and rules for process variables have been omitted.

3D processes and their semantics
Behaviours and shapes are compounded to create 3D processes, the basic building blocks of a Shape Calculus network.
Definition 2.3 (3D processes) The set 3DP of 3D processes is generated by the grammar P ::= S[B] P ⟨a, X⟩ P , where S ∈ S, B ∈ B, a ∈ Λ and X ⊆ P non-empty. The shape of each P ∈ 3DP is defined by induction as follows: shape(S[B]) = S, shape(P ⟨a, X⟩ Q)= shape(P ) ⟨X⟩ shape(Q).
We also write steer tP to denote P |[steer t shape(P )]|.
Rules in Table 2 define the temporal transition relation ~t ⊆ (3DP × 3DP) for t ∈ T and the functional transition relation −→⊆ (3DP × 3DP) for μ ∈ Act. Es- sentially, a 3D process inherits its behaviour from the B-terms defining its internal behaviour, but now sites of binding capabilities and split actions are expressed w.r.t. a global coordinate system (see rules Basicc and Basics). Note that rule Basicw, omitted, is similar to Basics replacing the ρ()-action with the ω()-action. Other symmetric rules are omitted. Rules StrSync and StrPar define the transition

relations ρ(a,X)
(3DP × 3DP) for strong-split of compatible channels 8 . Recall that




8 Replacing ρ(—) with ω(—) we obtain ω(a,X)
(3DP × 3DP).

strong-split operations require that all the enabled strong-splits have been performed together before time passes further. In such a case we say that a process P ∈ 3DP is able to complete a reaction, written P  . According to [1] we restrict the timed

operational semantics of 3D processes and we say that P −→t
ρ
Q iff P ~t
Q and either

P −→/	or P / .
Definition 2.4 (Networks of 3D processes) The set N of networks of 3D processes
(3D networks, for short) is generated by the grammar N ::= Nil  P  N  N .
We now provide a sketch of 3D networks semantics. A full description can be found in [1]. 3D networks can perform actions ρ, ω, κ and t. ρ, ω represent strong- and weak-split operations, κ corresponds to a collision detection and response event
and t is time passing.  The first two actions define transitions N −→ν  Nj 9 where
ν ∈ {ρ, ω} after which new 3D processes are created from the splitting of bounds 10 .
A transitions N −→κ  M represents collision response, executed when collisions are
detected within the current Δ. Note that all collisions, elastic and inelastic, are re-
solved simultaneously in N . We assume that an inelastic collision always replaces the original pair of processes with the resulting 3D compounded process. The new con-

figuration will be Nj = M   P ⟨a, X⟩Q
if ∃ P, Q ∈ N s.t. P ⟨α,Xa⟩
P ,Q ⟨α,Xb⟩

1	1	−−−−→ 1	−−−−→
Q1,α ∈ {a, a},X ∈ Xa ∩ Xb,X /= ∅. We used M to denote the rewriting of N

without P and Q. From the considerations above, the time step N −→t
Nj with t ∈ T

and 0 ≤ t ≤ Δ can be either t = Δ if no collision is detected or t = tj < Δ where
tj is the time of collision detection. After each such time step, the steer function updates shape velocities.
We now give a very simple example that has only the purpose of showing the features of the calculus without any particular biological outcome. Note that, by now, the more promising biological applications of the Shape Calculus is at the cell/tissue level [4].
Example 2.5 (First Glycolysis step) The glycolysis pathway is part of the process by which individual cells produce and consume nutrient molecules. Here we focus on the first reaction:
glucose, ATP −7−~− glucose-6-phosphate, ADP, H+
The 3D processes SGLC[GLC], SAT P [ATP] and SHEX [HEX] represents the reactants. Their shapes are approximations of public available 3D models and their behaviours are defined as follows:
HEX = ⟨atp, Xha⟩.HA + ⟨glc, Xhg⟩.HG,
HA = ω(atp, Xha).HEX + ϵ(th).⟨glc, Xhg⟩.ρ({⟨atp, Xha⟩, ⟨glc, Yhg⟩}).HEX,
HG = ω(glc, Xhg).HEX + ϵ(th).⟨atp, Xha⟩.ρ({⟨atp, Xha⟩, ⟨glc, Yhg⟩}).HEX,



9 If ν = ρ, N —→ν
N′ represents strong-split operations from P contained in N and P \.

10 In [1] the function split : 3DP × ℘(C) → N is used to “physically” finalize splitting of 3D processes. split is inductively defined on a process P ∈ 3DP and a set of channels C ∈C as split(P, C)= split(R, C)||split(Q, C) if P = R⟨a, X⟩Q and ⟨a, X⟩∈ C, P otherwise.

ATP = ⟨atp, Xah⟩.(ϵ(ta).ρ({⟨atp, Xah⟩}).ADP + ω(atp, Xah).ATP)
GLC = ⟨glc, Xgh⟩.(ϵ(tg).ρ({⟨glc, Xgh⟩}).G6P + ω(glc, Xgh).GLC
The Hexokinase process evolves by binding with one instance of each metabolite. Once it has connected with both of them and all delays are consumed, a strong-split action is possible, i.e., the reaction occurs. Glucose and ATP evolves to glucose-6- phosphate and ADP, which we assume to be, for simplicity, nil.

Abstract interpretation of Shape Calculus
Let us consider a 3D network whose components are several (a finite number) in- stances of the processes described in Example 2.5, i.e., they are 3D processes located in different positions and with different velocity vectors. Such a network evolves in many different configurations due to the steer function, the timing behaviour and the non-determinism of interactions and splittings. In this section we provide an abstraction of the Shape Calculus where a set of 3D networks is abstracted to a set of 3D abstract processes. The concrete domain that we consider is the power set of the set of all 3D networks.
Definition 3.1 (Concrete Domain) The concrete domain is the complete lattice (℘(N), ⊆, ∪, ∩, {}, N) where ℘ is the power set operator, set union is the least upper bound (lub), set intersection is the greatest lower bound (glb), {} is the bottom element and N is the top element.
We deal with abstract 3D processes, i.e., 3D processes without position and velocity. In the following we use the notation S , B , and 3DP to denote the set of abstract shapes, abstract behaviours and abstract 3D processes, respectively. A basic shape σ = ⟨V, m, p, v⟩ is abstracted to σ = ⟨V, m, ⊙, ⊙⟩ where ⊙ represents any set of points in the global coordinate system. Inductively on the syntactic structure, S⟨X⟩S is abstracted to S ⟨⊙⟩S  and a 3D processes P⟨a, X⟩Q is abstracted to P ⟨a, ⊙⟩Q . In a similar fashion, all time delays ϵ(t) are collapsed to ϵ(·) which represents a zero delay.
As usual, the abstraction is formalised by means of abstraction functions α and concretization functions γ. In Table 3 we define the abstraction functions αS : S → S , αB : B → B and αP : ℘(N) → ℘(3DP ) to abstract shapes, be- haviours and 3D processes, respectively. Note that αB does not abstract from local binding sets X. In fact, in the abstraction we are only interested in all possible binding capabilities between abstract 3D processes. The abstract semantics intro- duced later on will consider a pair of channel compatible if they belong to the same type, abstracting from the region of contact. Thus, retaining X does not effect the abstract interpretation in any case. Also note that temporal delays are zeroed since we are considering all the possible bindings at any time. Finally, the abstraction function of a network or a set of networks returns a set of abstract 3D processes. It is important to remark that several instances of the same entity can be contained in a network. For instance, in the Example 2.5 we would have several HEX as well as




Table 3 Abstraction functions

several GLC and ATP to represent different concentrations over the space. After abstracting from space and velocity, all the instances of a same 3D process collapse to a unique abstract 3D process. Hence, elements of the abstract domain are sets of abstract 3D processes.

Definition 3.2 (Abstract Domain) The abstract domain is denoted A and it is the complete lattice (℘(3DP ), ⊆, ∪, ∩, {}, 3DP ).
Table 4 shows the corresponding concretization functions that produce all the possible elements of the concrete domain in terms of absolute position in space, velocity and number of processes instances in the environment.
For γS we assume to limit the velocity of shapes by a maximal velocity vmax. This
is needed to guarantee the consistency of the collision detection system. We remark that γS generates from a compounded abstract shape a set of concrete compounded shapes such that the intersection of their boundaries is not empty. Although the set contains also interpenetrating shapes, i.e. not well-formed [1], this does not affect the correctness of the abstraction. The same assumptions are used in γP (P ⟨a , ⊙⟩Q )
in order to obtain the set of instances of a compounded abstract 3D process. Finally,
γ ({P ,...,P }) generates the set of all possible sets of concrete 3D networks. Each
P	1	n
set differs in its cardinality and in the number of concrete instances of each abstract 3D process. Note that the cardinality can be zero, thus in some of the generated concrete networks some species are not present.
Proposition 3.3 (Galois insertion) Let a ∈ 3DP and C ∈ ℘(N). α and γ forms a Galois insertion: i) α and γ are monotonic, ii) C ⊆ γ(α(C)), iii) α(γ(a)) = a.
The abstract semantics is given substituting each concrete rule with its abstract version. Because of their similarity, we use the same rules defined in the previous section, except those refined in Table 5. In such a case the concrete syntax is substituted by the abstract one introduced before. Accordingly, the abstract rules will define abstract transition relations that are the same given in the concrete semantic but marked with symbol . We remark that rules in Table 5 are needed




Table 4 Concretization functions

to abstract away from space and velocity. Rules Basic and Basic simply return
a channel without information on the region of contact. Indeed, rule StrSync2
now considers two channels compatible if and only if they belong to the same name type. Symmetric rules and rules for weak-split have been omitted. In the latter case, it is enough to replace ρ-action with ω-action. Finally, note that timing rules are retained although time is zeroed. These rules are only used for the proof of local correctness. They will not create circularities because, generating the same abstract processes once applied, they do not affect the abstract fixpoint iteration. Other rules that are similar to the concrete semantics behave as expected.
The interactions of abstract 3D processes are the focus of our abstraction. An abstract network N  = {P ,...,P } performs the same type of transitions of a
1	n
corresponding concrete one. Thus, we consider similar transition relations −→t , −→ν and −→κ . In the abstract domain temporal transitions do not change the network, i.e., for each generic abstract network N we have that N −→t N . The transition relation −→ν remains the same for ν = ω as well as in case of strong-splits. However, given the semantics of −→t  (see Section 2), in the abstract domain a process is always able to complete a reaction, i.e. P  , if all the involved splits are enabled, no matter
of delays. In case of interactions due to collisions, N −→κ  N , we define
1	2


N = N ∪ {R | ∃ P , Q ∈ N : P  ⟨α,⊙⟩
P , Q  ⟨α,⊙⟩
Q ,α ∈ {a, a} ∧ 

2	1	1
−−−→	1
−−−→	1

R = P ⟨a, ⊙⟩Q }
1	1
It can be proven that for each local operator, that is to say, for each rule defining the concrete semantics, the abstract version is a correct approximation of the concrete one. Thus, by the general results of abstract interpretation, we get that the defined abstraction is globally correct. In order to perform a verification we need to instruct a fixpoint iteration. Let N be the network we want to test:







F ↑0 (N )= α({N})
Table 5
Abstract Rules for B and 3DP terms

F ↑n (N )= 
M ∈{N |F↑n−1(N )−→x  N , x∈{ω,ρ,κ,t}} M

Note that even if the behaviours of the involved abstract 3D processes are finite state processes, then the possible number of different abstract networks is not guaranteed to be finite. Indeed, some processes can be defined that mimic unbounded polymers, for instance a compound process that can always be compounded with an existing species and then continues to do so. Thus, it is not always guaranteed that the fixpoint iteration stops in a finite number of steps. If this happens, however, we can look at the obtained set of abstract processes and can conclude that if a species is not present, then it can never appear in any of the actual concrete traces. Further abstractions are required to guarantee the termination in the general case.
Example 3.4 (Glucose/ATP bond) Consider again Example 2.5. We are now in- terested in verifying if it is possible for a glucose and an ATP molecule to interact, i.e., bind. Considering any concrete network with some instances of the 3D processes defined in the example, the abstraction will always be the set of the following three abstract processes:
ATP = S [ATP ] , GLC = S [GLC ] and HEX = S [HEX ]
The contained behaviour is almost identical to the concrete one due to the definition of αB. We can now apply the abstract transition relations presented above. At each step only the changing or newly created processes are shown for the sake of brevity. First step is the execution of a collision transition. We obtain the possible combination of the Hexokinase with the two metabolites:

{HEX [XG ] ⟨glc, ⊙⟩ GLC [ϵ(·).ρ({⟨glc, Xgh⟩}).nil + ω(glc, Xgh).GLC ],
HEX [XA ] ⟨atp, ⊙⟩ ATP [ϵ(·).ρ({⟨atp, Xah⟩}).nil + ω(atp, Xah).ATP ]}
Now both processes can weakly split on the newly created bold and get back to original unbound processes (see XG /XA ) or execute a delay. Since time is ab- stracted away, we can execute the subsequent actions. Thus, at this stage we can weakly split the current enable bond or bind with ATP (glucose respectively). In both cases we obtain the same compound:


	
{GLC [ϵ(·).ρ({⟨glc, Xah⟩}).nil + ω(glc, Xah).GLC ] ⟨glc, ⊙⟩
HEX [ρ({⟨atp, Xah⟩, ⟨glc, Xgh⟩})] ⟨atp, ⊙⟩
ATP [ϵ(·).ρ({⟨atp, Xah⟩}).nil + ω(atp, Xah).ATP ]}
According to the concrete domain glc-hex-atp would not be able to complete a reaction, i.e. glc-hex-atp / due to the delays of both GLC and ATP. This is not the case of the abstract domain in which the strong-split action can be executed. Thus we obtain also {GLC [nil ], AT P [nil ]}. No further transition for these processes can be executed, so fixpoint is reached. Hence, we can conclude, for instance, that GLC and ATP processes cannot interact directly between each other.

Conclusions and Future work
In this paper we have applied abstract interpretation to the Shape Calculus, a bio- inspired calculus, with the aim to check properties that would be impossible to check in the concrete algebra, due to the variability induced by motion laws, space, time and interaction-related non-determinism. In particular we were interested in proving untimed and unspatial safety properties. The use of the abstract interpretation framework is based on the abstraction of spatial information from the shapes and on the temporal abstraction of shapes behaviours. This extension simplifies the semantics of the calculus and drastically reduces the state space of a given 3D network. Concerning future work, on the one hand a further abstraction must be defined in order to always guarantee the termination of the current abstraction when processes behaving like unbounded polymers are present. On the other hand, a refinement of the current abstraction in which time is retained is certainly of interest. This would permit the verification of quantitative timed safety properties like “glucose-6-phosphate will never be produced before 20 milliseconds”. The long- term objective is to construct a lattice of abstract domains permitting the checking of a large variety of different possibly quantitative properties, maybe sometimes abstracting only time and not space, or abstracting behaviours, but not motion.


References
Bartocci, E., D. R. Cacciagrano, M. R. D. Berardini, E. Merelli and L. Tesei, Timed operational semantics and well-formedness of shape calculus, Sci. Ann. Comp. Sci. 20 (2010), pp. 32–52.

Bartocci, E., F. Corradini, M. R. D. Berardini, E. Merelli and L. Tesei, Shape calculus. a spatial mobile calculus for 3d shapes, Sci. Ann. Comp. Sci. 20 (2010), pp. 1–31.

Bittig, A. T., M. Jeschke and A. M. Uhrmacher, Towards modelling and simulation of crowded environments in cell biology, AIP Conference Proceedings 1281 (2010), pp. 1326–1329.
URL http://link.aip.org/link/?APC/1281/1326/1

Buti, F., D. Cacciagrano, F. Corradini, E. Merelli, L. Tesei and M. Pani, Bone Remodelling in BioShape, Electronic Notes in Theoretical Computer Science 268 (2010), pp. 17–29, Proc. of CS2Bio 2010.

Buti, F., D. R. Cacciagrano, F. Corradini, E. Merelli and L. Tesei, BioShape: a spatial shape-based scale-independent simulation environment for biological systems, Procedia Computer Science 1 (2010),
pp. 827–835, Proc. of 7th Int. Workshop on Multiphysics Multiscale Systems, ICCS 2010.


Buti, F., D. R. Cacciagrano, F. Corradini, E. Merelli and L. Tesei, A uniform multiscale meta-model of BioShape, Electronic Notes in Theoretical Computer Science (To appear 2011), Proc. of Cs2Bio 2011, June 9th, Reykjavik, Iceland.
Cacciagrano, D., F. Corradini and E. Merelli, Bone Remodelling: A Complex Automata-Based Model Running in BioShape, in: ACRI 2010, LNCS 6350, 2010, pp. 116–127.
Cousot, P., Abstract interpretation, ACM Comput. Surv. 28 (1996), pp. 324–328.
Cousot, P. and R. Cousot, Abstract interpretation frameworks, J. Log. Comput. 2 (1992), pp. 511–547.
Ericson, C., “Real-time collision detection,” Elsevier North-Holland, Inc., 2005.
Gruenert, G., B. Ibrahim, T. Lenser, M. Lohel, T. Hinze and P. Dittrich, Rule-based spatial modeling with diflusing, geometrically constrained molecules, BMC Bioinformatics 11 (2010), p. 307.
URL  http://www.biomedcentral.com/1471-2105/11/307
Yi, W., Real-time behaviour of asynchronous agents, in: CONCUR, 1990, pp. 502–520.
