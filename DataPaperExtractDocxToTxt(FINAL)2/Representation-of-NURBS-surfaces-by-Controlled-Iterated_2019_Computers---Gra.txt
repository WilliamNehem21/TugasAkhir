Computers & Graphics: X 2 (2019) 100006

		


Special Section on SMI 2019
Representation of NURBS surfaces by Controlled Iterated Functions System automata
Lucas Morlet∗, Christian Gentil∗, Sandrine Lanquetin, Marc Neveu, Jean-Luc Baril
Laboratoire Informatique de Bourgogne (LIB), Univ. Bourgogne Franche - Comté, 8 avenue Alain Savary, 21000 Dijon, France


a r t i c l e	i n f o	a b s t r a c t

	

Article history:
Received 9 March 2019
Revised 24 May 2019
Accepted 24 May 2019
Available online 7 June 2019

Keywords:
Geometric modeling Iterative modeling
Non-Uniform Rational B-Splines Iterated Functions Systems
CIFS automata
Iterated Function Systems (IFS) are a standard tool to generate fractal shapes. In a more general way, they can represent most of standard surfaces like Bézier or B-Spline surfaces known as self-similar sur- faces. Controlled Iterated Function Systems (CIFS) are an extension of IFS based on automata. CIFS are basically multi-states IFS, they can handle all IFS shapes but can also manage multi self-similar shapes. For example CIFS can describe subdivision surfaces around extraordinary vertices whereas IFS cannot. Having a common CIFS formalism facilitates the development of generic methods to manage interactions (junctions, differences...) between objects of different natures.
This work focuses on a CIFS approach of Non-Uniform Rational B-Splines (NURBS) which are the main used representation of surfaces in CAGD systems. By analyzing the recursive generating process of basis functions, we prove the stationarity of NURBS computation. This implies that NURBS can be represented as a finite automaton: a CIFS. Subdivision transformations implied in the generating process are directly deduced from blossoming formulation and are expressed as a function of the initial nodal vector. We pro- vide a method to construct the CIFS automata for NURBS of any-degree. Then NURBS-surfaces automata are deduced using a “tensor-product” of NURBS automata. This new representation of NURBS allows us to build a bridge between them and other surfaces already represented in CIFS formalism: fractals and subdivision surfaces.

© 2019 The Authors. Published by Elsevier Ltd. This is an open access article under the CC BY-NC-ND license. (http://creativecommons.org/licenses/by-nc-nd/4.0/)



Introduction

Iterative processes based on fractal geometry is a common way to produce complex objects like terrains, clouds, trees, tex- tures [1,2]. Generally, these processes used stochastic parameters to model natural objects with non-strict repetition of the same pat- tern. These algorithms are widely used in Computer Graphics but few in Computer Aided Geometric Design (CAGD), even if result- ing shapes present interesting properties like, for example, rough surfaces to improve heat exchange, porous volumes needing less material or simply for their aestetic value. The purpose of our re- search is to develop a generic iterative geometric modeler for in- dustrial applications associated to additive manufacturing. A first application, related to energy saving which is a crucial issue for industry, consists of designing lighter objects while maintaining high mechanical properties. To address this challenge we suggest to consider multiscale controlled lacunary structures which fill a

∗ Corresponding authors.
E-mail addresses: lucas.morlet@u-bourgogne.fr (L. Morlet), christian.gentil@u- bourgogne.fr (C. Gentil).
given geometric hull, with imposed functional surface. A second application is tree-like structures support design for additive man- ufacturing or for reinforcing a given functional surfaces (see Fig. 1). In both cases, imposed geometric inputs, geometric hulls or func- tional surfaces, come from a CAGD software and are generally rep- resented by Non-Uniform Rational B-Splines (NURBS). From the past decades, NURBS imposed themselves into CAGD. They are a powerful tool to construct smooth surfaces while respecting usual constraints of industrial conception. Our iterative modeler have to interact with CAGD software and needs to integrate NURBS repre- sentation.
From a theoretical point of view, it could be interesting to have a common representation for fractals, subdivision surfaces and NURBS to identify possible interactions. From a practical point of view, we could take advantage of each representation, without conversions and approximations.
Few generic representations were proposed for iterated pro- cesses. Most of the time, an iterative process is translated in a specific algorithm with a specific data structure and implemented in a specific software for a specific application. The two main generic representations are L-system [3] and Iterated Function


https://doi.org/10.1016/j.cagx.2019.100006
2590-1486/© 2019 The Authors. Published by Elsevier Ltd. This is an open access article under the CC BY-NC-ND license. (http://creativecommons.org/licenses/by-nc-nd/4.0/)




Fig. 1. Original creations of CIFS-based CAGD-modeling. From left to right: a wooden overlapping structure which is smooth in one direction and fractal in the second direction (©IBOIS, laboratory of EPLF), a lacunar structure build by 3D printing, a lacunar structure whose edges are B-Splines using topological optimization ( ≈ 88% of material saved compared to a filled structure) and an arborescent fractal structure that support a bi-quadratic Bézier surface.


System (IFS) [4] which are quasi-equivalent [5]. L-system repre- sentation is based on rewriting rules while IFS representation is based on a self-similarity property. For our purpose we believe that IFS are more suitable according to their formulation which is easier for formal manipulation associated to CAGD. Iterated Func- tion Systems (IFS) have been introduced by Hutchinson [4] and developed by Barnsley [6] to study self-similar shapes. Even if they are initially created for fractals, they can represent other types of objects: Goldman [7] and Schaeffer et al. [8] used this formalism to respectively generate Bèzier and B-Spline tensor-surfaces. In previous works, Zaïr and Tosan [9] introduce fractal modeling using free-form techniques which includes Bèzier and uniform B-spline curves and surfaces. Due to the presence of irregular vertices, subdivision surfaces are not self-similar and cannot be handled by IFS. To overpass this constraint, Morlet et al. [10] used Controlled Iterated Function Systems (CIFS) to generate low-degree uniform subdivision surfaces in an iterative way. CIFS are an extension of IFS based on automata whose states can represent different objects, self-similarities are no longer required. Every IFS can be described as a one-state CIFS-automaton.
In addition, to bring together usual CAGD representations in a
common formalism, CIFS-representation provides specific tools. For instance, Podkorytov et al. [11] proved that interactions between two objects of different natures can be performed since they are both represented as CIFS-automata.
At this point, our CIFS-based CAGD-modeler does not handle NURBS, and this is the main purpose of this paper. We prove that NURBS tensor-surfaces of any degree can be represented as CIFS- automata and so can be integrated in our iterative modeler. Then we avail this integration for new applications.

Overview

First of all, we introduce in Section 3 all the notations and mathematical background that will be used in the paper. We ex- plain two usually separate research fields: IFS and their extension CIFS in a first part and NURBS and their blossoming representa- tion in a second one. Our work is placed at the cross of these two research fields.
In Section 4, we present how to create NURBS CIFS-automata. The automata for quadratic and cubic cases are fully described and a method to generate any-degree automaton is proposed.
Furthermore we explain how to generate “tensor-products” of complete automata in Section 5. Following this method we create bi-quadratic and bi-cubic NURBS tensor-surfaces CIFS-automata. Then we prove that any NURBS tensor-surfaces can be represented as a CIFS automaton.
In Section 6, we present several solutions that our formalism brings to CAGD-industry usual challenges. First, we use the for- malism of Section 5 to generate blending tensor-surfaces (i.e. the two generative curves are of different natures). Then we show how to create a junction that respects constraints between a NURBS



Fig. 2. IFS of Sierpinski triangle and its attractor. Transformations T0 , T1 , and T2 as- sociate the black triangle to one of the three sub-triangles (respectively red, green, and blue). These transformations are homotheties of scale factor 0.5 where the cen- ter is one of the vertices of the initial triangle.


tensor-surface and a surface already defined as a CIFS-automaton. To finish we present the application of this formalism to the topological optimization field: we create a lacunar NURBS tensor- surface and an arborescent structure that support a NURBS tensor- surfaces.
To conclude, all contributions are summarized and research tracks for extension to any-degree non-tensor NURBS surface are proposed in Section 7.

Background

Iterated Functions Systems (IFS)

According to Huchinson [4], an IFS is a set of n contracting transformations of a complete metric space (X , d): {Ti }i∈Σ with Σ = {0, 1, . . . , n − 1}. Let K be a compact (i.e. a subset of an Eu-
clidean space which is both closed and bounded), the Hutchinson
operator H is defined by:
n−1
H(K) =  Ti (K)
i=0
In a same way as a contractive transformation owns a unique fixed-point, there is a unique compact, A, referred as the attractor of the IFS, which is defined as:
H(A) = A	(1)
Due to the contractivity of the Huchinson operator, the attractor can be computed as the result of an infinite application of Hutchin- son operator on any starting compact K.
A = H ◦ . . . ◦ H(K)
∞
An usual example of IFS is the Sierpinski triangle presented in Fig. 2.
Every point belonging to the attractor can be indexed by at least one infinite word σ = σ0σ1 ··· σ4 ··· of Σ (σ ∈ Σ∞) such that:
lim Tσ0 ◦ Tσ1 ◦ ··· ◦ Tσ4 (p) = pσ , ∀ p ∈ X .
4−→∞

















Fig. 3. Example of a CIFS automaton composed of two states: “blue hexagon” and “green triangle”. On the left, the decomposition rules of each state. On the center, the CIFS automaton deduced from decomposition rules. On the right, the resulting attractor.


In other words, the infinite composition of the corresponding transformations leads to the point pσ . σ is referred as an address of the point pσ .
To any infinite word σ ∈ Σ∞ corresponds a point of A. In partic- ular, the address iω (composed of an infinite number of repetition
of i), corresponding to the fixed point of Ti belongs to A, piω ∈ A. This property is important, because if Ti are aﬃne or linear trans- formations (which will be the case in the following) we can di-
rectly compute a point belonging to A in a finite time by calculat- ing the fixed point of Ti by eigen-analysis. Furthermore, according to Eq. (1), T j piω belongs to A too. This means that we can com- pute a tesselation of A with all vertices belonging to A in finite
time. The tesselation is calculated from a finite number of itera-



Fig. 4. CIFS automaton corresponding to Chainkin algorithm.

vector composed of the list of control points. The projection in the modeling space is included in the automaton by adding an initial state and a transition with P as the associated transformation. For example a quadratic uniform spline is defined by the automaton of Fig. 4, where P = [ p0 p1 p2 ] (the three control points), T q and T q

0	1

tions of the Hutchinson operator. The starting compact K is set as a list of vertices of a 1D, 2D or 3D mesh, each vertex being a fixed
represent the two Chaikin matrices and K is composed of the fixed
points of T q and T q:

points of a tranformation Ti, i ∈ Σ. This approach is equivalent to
Halstead et al. [12] and Stam [13] methods which directly com- pute a piece of subdivision surface from a given patch of control
1

2
K = ⎝ 1
0	1
0⎞
1 ⎠.

mesh.

Controlled Iterated Functions Systems (CIFS)

CIFS are an extension of IFS that provides more control. Instead of defining the attractor as all points Pσ , σ ∈ Σω , the attractor is restricted to points whose addresses are accepted by a given au-
tomaton.
A CIFS is defined by:
an automaton (Σ, Q, δ, q), where Σ is an alphabet, Q a set of states, δ a transition function (δ: Q × Σ → Q), q the initial state and all states of Q are final states;
a set of spaces associated to the states : (X q )q∈Q ;
a set of transformations associated to the transitions T x :
1
2
The attractor associated to state q is the quadratic uniform spline basic functions and the Spline curve is Aq = PAq. A tesselation of the curve is obtained by computing, for a given level of iteration (approximation) 4: {PTσ0 ◦· · · ◦ Tσ4 K, σi ∈ Σ}.
By using different states, CIFS provides more control than IFS.
For example, B-Spline tensor surfaces can easily be represented by an IFS [8] whereas subdivision surfaces, around extraordinary ver- tices, cannot. Indeed, management of extraordinary patches is im- possible with IFS formalism because an irregular patch is subdi- vided into several regular and irregular patches. At least two states are necessary: regular and irregular. More generally, transforma- tions that change the nature of the object can only exist in CIFS formalism because different objects are simply represented by dif-

Eδ(x,i)
→ Ex.
i	ferent states. Morlet et al. [10] prove that any low-degree uniform subdivision schemes can be represented by a CIFS automaton in-

To each state is associated an attractor Aq defined by:
Aq =	T q (Aδ(q,i) )	(2)
i∈Σq
where Σq = {i ∈ Σ, δ(q, i) ∈ Q }.
The attractor of the CIFS is the attractor of the initial state, i.e.
A = Aq.
From Eq. (2), we understand that a transformation associated to a transition copy the attractor of the destination state into the attractor of the starting state. Then interpretation and design of an automaton is intuitive. An example can be found in Fig. 3.
The last step to complete the needed material, is the introduc- tion of free-form shapes modeling with CIFS. It is straightforward by building the attractors in barycentric space and then project it into the modeling space according to a set of control points. The final modeled shape is F = PA, where P = [ p0 p1 . . . pk ] is a line
stead of a set of rules. They propose a generic eﬃcient visualiza- tion of subdivision surfaces on GPU, based on tesselation of attrac- tors.

Non-Uniform Rational B-Splines

B-Splines are a user-friendly tool to define smooth parametric curves by a list of points called control points that form the control polygon. A B-Spline curve C of degree d is defined from a control polygon composed of d + 1 points P = [ p0 . . . pd ].
A B-Spline curve can also be defined by pieces: a curve com-
posed of m pieces is defined by P = [ p0 . . . pd+m−1] where every sub-polygon [ pi . . . pi+d−1] defines a B-Spline of degree d. Even if B-Splines are built to be defined by pieces, each piece is inde-
pendently computed; so only one-piece curves are treated in this article.



B-Splines basis functions are computed given a knot vector. For a one-piece B-Spline curve of degree d, the knot vector is T = [t0 =
0 ≤ · · · ≤ t(2d−1) = 1]. Every point of the curve C(t) is computed by
the well-known Cox–De-Boor formula [14].
What is important for curves computation is not the knot val- ues but differences between two consecutive knots and the ra- tio between these differences. Thus, the nodal vector T is often replaced by the inter-nodal vector U = [u0 . . . u(2d−2) ] where ui =
ti+1 − ti . In this article, the most convenient is used according to
each situation.
Uniform B-Splines are often used (in this case it is conve- nient to set T = [t0 = 0, t1 = 1, < ··· < t(2d−1) = 2d − 1] and then



Fig. 5. On the left, the blossoming computation of the curve point C(tib ) where tib =
(ti + ti+1 )/2. From this blossoming representation the influence of control points

u = ··· = u
= 1).
pi−1 , pi , pi+1 are deduced: 1 ·    ui   , 1 ·   2ui−1 +ui  + 1 ·   ui +2ui+1  , and 1 ·    ui   .

0	(2d−2)
2  2(ui−1 +ui )
2  2(ui−1 +ui )
2  2(ui +ui+1 )
2  2(ui +ui+1 )

Non-Uniform B-Splines (NUBS) offer more control over the curve. In this case ui is computed according to user defined con-
straints (centripetal, chord length, . . .)
The main problem NUBS have to face is their impossibility to handle conic shapes (i.e. circles, ellipses. . .). To overpass this is- sue a new concept is added: the rationality. NUBS then become Non-Uniform Rational B-Splines (NURBS) and a new coordinate is added to every control points. These coordinates increase or de- crease points influence in a way similar to weight points. This ra- tionality modifies the shape of the curves by adding an extra step in the computation which is independent from the non-uniformity. The rationality can be achieved simply by using control points with homogeneous coordinates. But it is not out purpose here, our work focuses only on the non-uniformity step and the term NURBS is used in a generic way.

Blossoming

NURBS are usually computed with the Cox-De-Boor formula
[14] but Ramshaw [15] introduced an other way to understand
NURBS called blossoming. A blossom of a curve of degree d is represented by a label composed of d arguments: {ti . . . ti+d−1}. Blossoming  is  completely  characterized  by  three  properties:
symmetry, diagonal, and multi-aﬃnity. From the three previous properties, another one is deduced: the consecutivity.

Symmetry:
The order of arguments in a label have no consequence on blos- soms. Thus, they can and will be always written in ascending or- der:
{. . . ti . . . t j . . .} = {. . . t j . . . ti . . .}	( j < i)
Diagonal:
Every point of the limit curve is defined by a label composed of identical arguments. This repeated argument is also the curve parameter.
C(t) = {t . . . t}
On the right, the application of this result to compute this point of a quadratic
NURBS (red) from a control polygon (blue). An intermediate polygon (green) that defines the same NURBS as the original one can also be computed according to the coeﬃcients of the bottom branches of the blossoming. (For interpretation of the ref- erences to colour in this figure legend, the reader is referred to the web version of this article.)


Following these four properties, we can compute every point of the curve as a function of the control polygon. First, the diago- nal property is used to create the label corresponding to the point of the curve and this label is placed as the root of the blossom- ing. Each label that does not respect the consecutive property have to be split into two new labels with respect to multi-aﬃnity. The weights of aﬃne combination are written on the branches that link the parent label to its two sons. A consecutive label is a leaf of the tree: it corresponds to a point of the control polygon. The weight of a path that links the root to a leaf is the product of branches weight it passes through. The influence of a control polygon point (leaf) on the curve point we compute (root) is the sum of paths weights joining the root to the leaf. An example of blossoming where a point of quadratic NURBS is computed is given in Fig. 5.

Representation of NURBS by CIFS-automata

In this section, we prove that NURBS with any-degree can be represented as a CIFS-automaton. The number of states is di- rectly related to the degree of the NURBS. First the simplest cases (quadratic and cubic) are presented, then the generalization to any degree is explained and mathematically proven by generating words provided grammar rules.

NURBS and self-similarity

Let a NURBS be defined by a pair composed of a control poly- gon P and a knot-vector T. If a new knot is inserted into T, the new knot-vector Tr can be associated to a new control polygon Pr which defines the same NURBS as (P; T). An example can be found in Fig. 5 where the same curve is defined by the two pairs:

½ [ pi−1, pi, pi+1]	½ [ pi−1, pr , pr , pi+1]

Multi-affinity:
Every label can be defined as an aﬃne combination of two oth-
i−1  i
i+1
i+2
i−1 , ti, tib, ti+1
i+2

ers if these three labels only differ by one argument. Weights of the labels combination correspond to weights of the arguments aﬃne combination:
{. . . t . . .} = b − t {. . . a . . .} + t − a {. . . b . . .}
The usual way to exploit this property is the mid-knot inser-
tion strategy [16,17]: a new knot is inserted in the middle of each consecutive knots of T. Then all knots of Tr are multiplied by two because there are not the knots but the ratios between them that influences the shape of the curve. To finish, extreme knots are

b − a
Consecutivity:
b − a
dropped because they do not influence the curve anymore. The mid-knot insertion strategy is equivalent to inter-node doubling: each inter-node of U is written twice in a row. Due to modification

A label whose arguments are consecutive nodes of the knot-
vector corresponds to a control point; its index is the first index of
on knot/inter-node vector, the control polygon P has to be modi- fied to Pr. For instance:

arguments:
p : {t , t

. . . t	}
T = [a, b, c, d] → Tr =
·a,
a + b

, b,
b + c

, c,
c + d
, d¸

i	i  i+1
i+d−1
2	2	2


→ Tr = [2a, a + b, 2b, b + c, 2c, c + d, 2d]
→ Tr = [a + b, 2b, b + c, 2c, c + d]
U = [b − a, c − b, d − c] → Ur = [b − a, c − b, c − b, d − c]
P = [ p0, p1, p2] → Pr = [ pr , pr , pr , pr ]
0	1	2	3

This new pair (P’ ; U’) defines the same NURBS as (P ; U) but the curve is no longer a one-piece curve: it is now composed of two pieces. These two pieces are both one-piece curves with the same degree as the original one: there is a self-similarity. To avail this self-similarity, we define two transformations, L and R, which associate the original NURBS to the left and the right part of the new NURBS. These transformations map a NURBS to another one. This implies they transform both the control polygon and the inter- nodal vector into new ones.
L : (P ; U) '→ (PL ; UL )
R : (P ; U) '→ (PR ; UR )

Quadratic NURBS CIFS-automaton

The length of the control polygon and the inter-nodal necessary to define a one-piece NURBS vector depends on the degree and so L and R have to be defined for every degree. For instance, in quadratic case, they are defined by this way:
L : (P ; [a, b, c]) '→ (PML (a, b, c) ; [a, b, b])
R : (P ; [a, b, c]) '→ (PMR (a, b, c) ; [b, b, c])
where ML and MR are the matrices defined below. Starting from an inter-node vector U = [v, w, x], the two transformations L and R create two new inter-node vector configurations [v, w, w] and [w, w, x] which are both centered on the same inter-node value (the center value of the parent configuration: w). Each new config- uration can be associated with a piece of the two-pieces NURBS, or for self-similarity reason two one-piece NURBS. Both new configu- rations produce two configurations: themselves (that already exist) and another new uniform configuration: [w, w, w]. At this point, no more configuration can be found: every built configuration is transposed as a state of the quadratic NURBS CIFS-automaton (see Fig. 6).
Transformations are always labeled in a same way but the co- eﬃcients of the associated matrices are not always the same: they are parameterized by the three inter-nodes of U relatively to the starting state of the transition.
These matrices are directly deduced from the weights of branches between the two bottom rows of Fig. 5:












Fig. 6. The quadratic NURBS CIFS-automaton whose starting inter-node vector is [v,w,x]. The states are labeled as states of the corresponding configuration of inter- node vector. Below, the control polygon P is colored in black. After one iteration, the left and the right parts of the resulting polygons are respectively colored in red for the state vww and in green for the state wwx. For the second iteration, the two middle parts colored in brown define uniform B-Splines. (For interpretation of the references to colour in this figure legend, the reader is referred to the web version of this article.)

  u1 +2u2 
2(u1 +u2 )
   u2	
2(u1 +u2 )

ML (u1, u2, u3 ) = ⎝    u1	
  2u1 +u2 
2(u1 +u2 )
  u2 +2u3 
2(u2 +u3 )
   u2	
2(u2 +u3 )
Fig. 7. The automaton used to generate cubic NURBS. Starting internode vector is [u,v,w,x,y] and states are labeled as states of the corresponding internode vector.

   u2	
2(u1 +u2 )
0	0	⎞

MR(u1 , u2 , u3 ) = ⎝   2u1 +u2 



  u2 +2u3 
2(u2 +u3 )
   u2	
2(u2 +u3 )
   u3	
2(u2 +u3 )
  2u2 +u3 
2(u2 +u3 )
Cubic NURBS CIFS-automaton

Cubic NURBS are handled quite in the same way. They

Notice the two matrices have two rows in common. This
ensures the continuity of the junction between two pieces of quadratic NURBS.
From both matrices, we can directly compute the position of
the fixed-point and the tangent at this point using the following barycentric combinations B and τ :
B =   u2  ;   u1  ; 0 T
τL = (−1 ; 1 ; 0)T
½B  = ¡0 ;   u3  ;   u2   ¢T
are at least defined by P = [ p0 . . . p3 ] and T = [t0 . . . t5 ] or U = [u0 . . . u4]. The automaton used to generate cubic NURBS is pre- sented in Fig. 7. The transformation matrices, which are given in Appendix B are deduced from the blossoming form in Fig. 8.


High-degree NURBS CIFS-automaton

In CAGD-engineering, surfaces can be subject to constraints such as interpolating some points, continuity of junctions between

τR = (0 ; −1 ; 1)T
degree elevation. This elevation involves a management of NURBS




Fig. 8. The computation by blossoming of Pr as a function of P. The convention is tjb = (tj + t j+1 )/2.


of any-degree, in particular of high-degree because a surface can be subject to many constraints.
A CIFS-automaton is available if and only if its number of states is finite. For NURBS CIFS-automata, each state corresponds to a possible configuration of inter-nodal vector. Before any iteration, this inter-nodal vector is composed of any values. Every iteration duplicates all inter-nodes and then deletes the extreme ones. Ev- ery sub-sequence of values (of a fixed length) is a possible state of the inter-nodal vectors. After some iterations, there only remains sub-sequences composed of at most two different values repeated several times. At this point, no more additional states can be found. High-degree automata are directly generated according to this al- gorithm. Mathematical proofs about the number of states based on a combinatorial approach of the generated words can be found in Appendix A.
Extension to NURBS tensor-surfaces

NURBS tensor-surfaces are created by a tensor-product of NURBS. They lie on a regular control grid and own two “orthog- onal” inter-nodal vectors U and V. The automaton used to gen- erate these surfaces can be viewed as a “tensor-product” of two curves-automata. In this section, the tensor-product of automata is explained and then used to generate NURBS tensor-surfaces CIFS automata.
Tensor-product of finite automata

Let A and B two finite automata whose states are respectively
{α0 . . . αm} and {β0 . . . βn} and whose transitions are respectively
{a0 . . . ap} and {b0 . . . bq}. Let C be the automaton which is the
“tensor-product” of A and B. The initial state of C is defined as the composition of the initial states of A (α0) and B (β0) and is labeled (α0; β0). For every pair of transitions ai (that links α0 to αk) and bj (β0 to βl), a new transition of C, c(i,j) is created be- tween the initial state (α0; β0) to a potentially new state (αk; βl). If this state already exists, the transition is just added to the
automaton; otherwise this new state is added to the automaton and its transitions are studied by the same process as the initial state.
From this generation, two properties are straightforward:
C is finite and its numbers of states and transitions are respec- tively upper-bounded by (m.n) and (k.l).
If A and B are complete (i.e. every transition is defined for every state), C is also complete.
NURBS-tensor surfaces CIFS automata

In the case where A and B are CIFS-automata that gener- ate a curve and C an automaton of tensor-surface, the term
“tensor-product” makes all its sense. Indeed, in this particular case, transformation matrices are tensor-products Mc(i, j) = Mai Mbj . Furthermore, the left-eigenvector of matrices Mc(i, j) are also tensor-product of left-eigenvectors of Mai and Mbj . In particular, the fixed point and its associated main-tangents and normal of a transformation γ defined as the tensor-product of two transformations α and β are:
Bγ = Bα Bβ τγ = Bα τβ τ r = Bβ  τα
Let A be an “horizontal” NURBS CIFS-automaton whose transfor- mations are L and R and B a “vertical” NURBS automaton whose transformations are respectively changed to D and U . Four trans- formations are defined by the tensor-product of A and B:

By using the tensor-product of automata presented in the pre- vious sub-section, the bi-quadratic and bi-cubic automata are gen- erated (see Fig. 9). Some examples of NURBS tensor-surfaces gen- erated from this CIFS automata are given in Fig. 10.
Even if only low degree automata are presented, this method applies to any degree NURBS tensor-surfaces. The only pitfall to face is the explosion of the number of states that comes when the degree increases. This issue is inherent to NURBS: the recur- sive process of generation always implies diﬃculties related to the degree.
By generating several tensor automata from curves-automata of different degree, some properties appear. The first one is once a state is leaved, it is impossible to turn back to it. The second one is the number of stationary states (i.e. states that own at least one transition to themselves) is always 3 for curves-automata (la- beled as left, right, and uniform); other states are transitory: they are active only once. The number of stationary states of a tensor- automaton is the product of the number of stationary states of the two original automata: it is 3 for curves, 9 for surfaces, 27 for vol- umes. Whatever the number of stationary states, there is always only one state, called the uniform state, which loops to itself for all transformations. This uniform state is the IFS that generates uni- form B-Splines shapes (curve, surface, volume).

Applications

The representation of NURBS as CIFS-automata permits to push further some previous works. In this section, several CIFS-based


 

Fig. 9. On the left, the construction of bi-quadratic NURBS CIFS-automaton by tensor product of two quadratic NURBS CIFS-automata A and B. On the right the bi-cubic NURBS CIFS-automaton (without the input curve automata). Transformations T0 , T1 , T2 , T3 are respectively represented by red, green, blue, and purple arrows. Brown arrows represent any of these transformations. (For interpretation of the references to colour in this figure legend, the reader is referred to the web version of this article.)


Fig. 10. Three examples of bi-quadratic NURBS tensor-surfaces with the same control grid but with different associated inter-nodal vectors. From left to right: (1, 2, 3) × (0, 3, 2), (0, 1, 0) × (1, 3, 8) and a uniform one (1, 1, 1) × (1, 1, 1).


Fig. 11. From left to right: a tensor-surface generated from a NURBS and a Takagi curve, a junction between a NURBS bi-cubic tensor-surfaces and a Takagi tensor-surfaces, a lacunar volume with highlight subdivision process, and a tree iteratively defined such that its leaves correspond to the NURBS surface of Fig. 10 (left). All were designed using the iterative modeler MODITERE – LIB.


applications, currently limited to uniform B-Splines, are henceforth extended to non-uniform case.

Tensor surfaces with blending natures

Once CIFS-automaton tensor-product is defined, it can be used to generate tensor-surfaces from two generative curves which are not of the same nature, with the only condition that both are de- fined as CIFS-automata. For instance, in Fig. 11(a) is presented a tensor-surface generated from a cubic NURBS and a Takagi curve. Thanks to the overlaps of Takagi curve, the surface is mechanically more resistant than an usual NURBS tensor-surface while keeping its smoothness in one direction to evacuate fluids.
Junctions between surfaces of different natures

Podkorytov et al. [11] proves that a junction J between surfaces of different natures (A and B) is always possible since they are both represented as CIFS automata. These two surfaces are both bounded by a curve which is defined by a subset of the con- trol mesh. For instance bi-quadratic NURBS tensor-surfaces, which are defined at least by a (3 × 3)-grid, are bounded by a quadratic NURBS which is defined by a (3 × 2)-grid. Both bounding-curves meshes are merged in a new CIFS of six transformations: two of them map the new mesh to a mesh of type A, two others map the mesh to a mesh of type B, and the two last ones map the mesh to a mesh of the new type J (see Fig. 12).




	  

Fig. 12. Generic junction J between two surfaces of different types A and B. On left side, the CIFS automaton where A and B states are the usual CIFS automata of corresponding surfaces. On right side, the topological subdivision of J into six sub- surfaces of the three types.


The transformations that create surface of type A or B are con- strained to conserve the continuity at the junction with bound- ing surfaces. Central transformations are created depending on the four others in order to ensure a maximum continuity around the junction. If the central transformations are over-constrained, some phantom points can be added in the central mesh in order to release these constraints. An example can be found in Fig. 11(b) where a NURBS tensor-surface is joined to a Takagi tensor-surfaces.

Topological optimization

Some CAGD-pieces are subject to optimization while respecting constraints. For instance, they should be as light as possible and must eﬃciently evacuate heat without affecting their strength. A solution that directly proceeds on surfaces is the creation of lacu- nar surfaces (an example of lacunar NURBS-tensor surfaces is given in Fig. 11(c)). Another challenge that needs topological optimiza- tion is the creation of a support subject to the same constraints as described before. Arborescent structure that join a CIFS automaton have been proposed by Sokolov et al. [18] as a solution for uniform B-Splines tensor-surfaces. For instance, the tree in Fig. 11(d) is de- fined as a volumic subdivision bordered by a bi-quadratic NURBS tensor-surface. Constrains are defined to ensure that the subdivi- sion of the volume is compatible with the subdivision of the sur- face.

Conclusion

In the present article, we show that NURBS curves and tensor- surfaces can be represented with a Controlled Iterated Function System (CIFS). As most of CAGD-systems are NURBS-based, adding these new surfaces to the CIFS-model is an important progress to a transition from usual CAGD-engineering to a CIFS-modeling.
We show the associated automaton is finite, and composed of limited number of stationary states. Furthermore, we provide two methods: the first one generates CIFS-automata that correspond to NURBS of any degree and the second one explains how to trans- pose tensor-product from curves to automata.
Once NURBS tensor-surfaces defined as CIFS automata, many in- teractions between them and object that are already defined in the formalism (fractals, subdivision surfaces...) become possible or eas- ier.
The main issue NURBS have to face is the management of extraordinary vertices that are usually unavoidable in CAGD- engineering. Sederberg et al. [19] and Müller et al. [20] proposed another solution which is Non-Uniform Rational Subdivision Sur- faces but have been restricted to low-degree (quadratic or cubic) surfaces. Thereafter, Cashman et al. [21] found a way to generalize
[19] to high-degree surfaces but only for odd degree.
For this purpose, we need to manage non-tensor NURBS sur- faces. Corresponding CIFS-automata should handle the evolution of both knot-vectors (which are no longer limited to two “orthogo- nal” ones) and the topology of the mesh. For quadratic and cubic
management of extraordinary vertices. Coeﬃcients of matrices associated with transitions should be deduced from [19].
Even if low-degree cases may be quite direct to integrate, a real issue will take place with higher degree. This comes from the fact that the neighborhood of vertices needed to compute a piece of surface is composed of a central vertex (for quadratic case) or a central face (for cubic case) and a unique ring of vertices that sur- rounds it. This ring is composed of vertices that share a face with the central vertex or a vertex of the central face. In these cases, the possibilities of irregularities are very limited and can be all listed. For higher degree, the patch owns several nested rings; thus the possibilities of irregularities are subject to combinatorial explosion. The solution proposed by Cashman et al. [21] for any odd-degree should be closely studied to find a solution to fill this gap.

Declaration of Competing Interest

The authors declare that they have no known competing finan- cial interests or personal relationships that could have appeared to influence the work reported in this paper.

Aknowledgments

We would like thank Gilles Gouaty for the implementation of automata, and Dominique Michelucci for his helpful comments and suggestions for scientific coherence and English correctness.

Appendix A. Mathematical proof

We fix n = 2d − 1 for d ≥ 1. Let Mn be the set of words of length n ≥ 1 over the alphabet {1, 2, . . . , n}, i.e., all words w = w1 w2 . . . wn with wi ∈ {1, 2, . . . , n} for 1 ≤ i ≤ n. wi corresponds to the ith let- ter of the word w and ∀i, wi ≤ wi+1 The conjugate of a word w = w1 . . . wn is the word w = n + 1 − wn, n + 1 − wn−1 , . . . , n + 1 − w1 .
From a word w ∈ Mn, we construct the word W ∈ M2n defined by W = w1 w1 w2 w2 . . . wnwn. Note that Wn = Wn+1 = wd . Also, we define the maps L and R on Mn as follows:
L(w1 . . . wn ) = Wn−d+1 . . . Wn−2Wn−1WnWn+1 . . . Wn+d−1,
R(w1 . . . wn ) = Wn−d+2 . . . Wn−1WnWn+1Wn+2 . . . Wn+d.
For instance, whenever n = 7 (or equivalently d = 4) and w = 1234567, we have W = 11223344556677, L(w) = 2334455, R(w) = 3344556, L(L(w)) = 3334444 and R(L(w)) = 3344445.
For n ≥ 1, let us consider the set Sn of words obtained from 12 ... n after all possible combinations of L and R. For instance, S7 = {1234567, 2334455, 3344556, 3334444, 3344445,  3444455,
4444555, 3444444, 3344444, 4444445, 4444455, 4444444}.
It is straightforward to check the following properties:
Fact 1. Any word w in Sn satisfies wd = d.
Fact 2. For 1 ≤ i ≤ n − 1, two consecutive letters wi and wi+1 in a word w ∈ Sn satisfy 0 ≤ wi+1 − wi ≤ 1.
Fact 3. For any w ∈ Sn, its conjugate w also lies in Sn.
Fact 4. (i) dn is the unique word w where L(w) = R(w) = w.
(d − 1)d−1dd is the unique word w where L(w) = w and
R(w) /= w.
dd (d + 1)d−1 is the unique word w where R(w) = w and
L(w) /= w.
Fact 5. For any w ∈ Sn, the number of letters d in L(w) (resp.
R(w)) is at least that of w.

cases, the shape (states and transitions) of automata seems to be at the cross of this paper for the non-uniformity and [10] for the
Lemma 1. Any word w ∈ Sn
1)2k n2k for some k ≥ 0.
is a subword of mk
= 1  2  . . . (n −



Proof. Let w be a word obtained after applying r ≥ 0 consecutive transformations L and/or R, and let us prove by induction on r
the subwords w of length n in mk, k ≥ 0, satisfying wd = d. From
k = 0 to r − 1, the number of such subwords in mk is 2k since such

that w is a subword of mk = 12
22k
. . . (n − 1)2k
n2k
for some k. Ob-
a word contains exactly 2k letters d, and we have 2k ways to fix

viously, if r = 1 then w is one of the two words L(12 ... n) and R(12 ... n), which are subwords of m1 = 1122 . . . nn (by definition of L and R). Let us assume that w is subword of mk with wd = d, and let us prove that L(w) and R(w) are some subwords of mk+1.
By definition, wr = L(w) (resp. wr = R(w)) is obtained as a sub-
word of W = w1w1w2w2 . . . wnwn after matching wr with Wn = w
wd = d.
Now, let us count the subwords having exactly α letters d for
α > 2r−1. It is straigthforward to see that such a word is a subword of mr and for α < n, there are two ways to choose such a word
(either wd = d is the leftmost d in mr or wd = d is the rightmost
d in mr). Then there are 2(n − 1 − 2r−1) possible words whenever

d	d
2r−1 < α < n. Finally, for α = n, there is only one subword, that is
(resp. Wn+1 = wd ). Since w is a subword of mk such that wd = d,

this implies that W = w1w1 . . . wnwn is a subword of m
k+1
, and
dn.

thus wr = L(w) (resp. wr = R(w)) is a subword of mk+1.  ¤
Lemma 2. Let w be a subword of length n of mk, k ≥ 0, such that wd = d. Then, w belongs to Sn.
Proof. The proof is obtained by induction on k. Obviously, when k = 0 the unique length n subword of 12 . . . (n − 1)n is 12 . . . n, and it belongs to Sn. For k = 1, w is a subword of W = 1122 . . . dd . . . nn with wd = Wn = Wn+1 = d. In the case where wd matches Wn, w = L(12 . . . n); otherwise wd matches Wn+1 and we have w =
R(12 . . . n). In the two cases, w lies into Sn.
Now, let us assume the statement holds for i ≤ k, and let us prove it holds for k + 1. Let w be a length n subword of mk+1 such that wd = d. Let r ≥ 1 so that wd matches the rth value
Combining all these subcases, the number of words in Sn is:
r−1
2k + 2(n − 1 − 2r−1) + 1 = 2r − 1 + 2(n − 1) − 2r + 1	(A.1)
k=0

= 2(2d − 2) = 4(d − 1)	(A.2)
¤
Corollary 1. From 12 . . . n, we can reach any word in Sn in at most
「log2(n)e transformations L and/or R. We need 「log2(n)e transfor- mations to reach the word dn.
Proof. Let r ≥ 0 be the integer such that 2r−1 < n < 2r. We have

of m
k+1
. Since wd
= d we necessarily have r ≥ (d − 1)2k+1 ≥ n,
r = 「log2 (n)e. Using the fact that dn is obtained as a subword of 2r,

and r ≤ n2k+1 − (d − 1)2k+1 < n2k+1 − n. These two last inequali-
ties ensure that there is a length 2n subword W of mk+1 such that Wn or Wn+1 matches wd . In the case where wd matches Wn, then we define the subword v of length n by deleting all values of odd ranks in W, and v satisfies L(v) = w. In the case where wd matches Wn+1, then we define the subword v of length n by deleting all val- ues of even ranks in W, and v satisfies R(v) = w. By construction, v is a subword of mk with vd = d and after applying the recurrence
hypothesis, v belongs to Sn. As w is either R(v) or L(v), we de-
duce that w also is in Sn. We conclude by induction.  ¤
Theorem 1. For d ≥ 1, the cardinality of the set S2d−1 is 4(d − 1).
Proof. Let r ≥ 1 be the integer such that 2r−1 < n = 2d − 1 < 2r, i.e. r = 「log2(n)e. Using the previous two lemmas, it suﬃces to count
we need r transformations to reach it. From the proof of Theorem
1, all others words can be reached with at most r transformations, which gives the results. ¤
Corollary 2. Let w be a word in Sn such that w ∈/ {dn, (d − 1)d−1dd, dd(d + 1)d−1}. It is impossible to find a sequence ξ of L and R such as w = ξ (w).
Proof. Since w does not belong to {dn, (d − 1)d−1dd, dd(d + 1)d−1}, Fact 4 proves that R(w) and L(w) differ from w. Let r be the num-
ber of letters d in w. Then, L(w) (resp. R(w)) has at least one let- ter d more than w, and since L and R cannot decrease the number of d (see Fact 5), the proof is completed. ¤


Appendix B. Cubic matrices




ML(u0 . . . u4 )
   u1 + 2u2	
2(u0 + u1 + u2 )

   u2	u1 + 2u2		0	0
2(u1 + u2 ) 2(u0 + u1 + u2 )

   2u0 + u1	
   u2	2u0 + u1	 +   2u1 + u2  u1 + 2u2 + 2u3 
   u2 + 2u3	
   u3	u2 + 2u3	

2(u0 + u1 + u2 )
=
2(u1 + u2 ) 2(u0 + u1 + u2 )	2(u1 + u2 ) 2(u1 + u2 + u3 )
2(u1 + u2 + u3 )
2(u2 + u3 ) 2(u1 + u2 + u3 )

⎜	0	  2u1 + u2	u1	
   2u1 + u2	
   u3	2u1 + u2		  2u2 + u3  u2 + 2u3 + 2u4 
+

⎜⎝	2(u1 + u2 ) 2(u1 + u2 + u3 )
2(u1 + u2 + u3 )
2(u2 + u3 ) 2(u1 + u2 + u3 )	2(u2 + u3 ) 2(u2 + u3 + u4 ) ⎟⎠



MR(u0 . . . u4 )
⎛

   u2	u1 + 2u2	
2(u1 + u2 ) 2(u0 + u1 + u2 )

0	0	0	⎞

   u2	2u0 + u1		  2u1 + u2  u1 + 2u2 + 2u3 
+
   u2 + 2u3	
   u3	u2 + 2u3		0	⎟

2(u1 + u2 ) 2(u0 + u1 + u2 )
⎜
2(u1 + u2 ) 2(u1 + u2 + u3 )
2(u1 + u2 + u3 )
2(u2 + u3 ) 2(u1 + u2 + u3 )
⎟

⎜	2(u + u ) 2(u + u + u )
2(u + u + u )
+
2(u + u ) 2(u + u + u )	2(u + u ) 2(u + u + u )
2(u + u + u ) ⎟

1	2	1	2	3
⎜
1	2	3
2	3	1	2	3
2	3	2	3	4
2	3	4
⎟

⎝	0	0	


2(u + u ) 2(u + u + u )
2(u + u + u ) ⎠



References

Peitgen H-O, Richter P. The beauty of fractals: Images of complex dynamical systems. Springer-Verlag, Heidelberg; 1986.
Zhou H, Sun J, Turk G, Rehg JM. Terrain synthesis from digital elevation mod- els. IEEE Trans Vis Comput Graph 2007;13(4):834–48.
Prusinkiewicz P, Lindenmayer A. The algorithmic beauty of plants. New York, NY, USA: Springer-Verlag New York, Inc.; 1990. ISBN 0-387-97297-8.
Hutchinson JE. Fractals and self similarity. Indiana Univ Math J 1981;30(5):713–47.
Prusinkiewicz P, Hammel M. Language-restricted iterated function systems, koch constructions, and l-systems. In: Proceedings of the SIGGRAPH’94 course notes; 1994.
Barnsley M. Fractals everywhere. Academic Press; 2014.
Goldman R. The fractal nature of Bézier curves. In: Proceedings of the geomet- ric modeling and processing, 2004. IEEE; 2004. p. 3–11.
Schaefer S, Levin D, Goldman R. Subdivision schemes and attractors. In: Pro- ceedings of the symposium on geometry processing. Citeseer; 2005. p. 171–80.
Zair CE, Tosan E. Fractal modeling using free form techniques. Comput Graph Forum 1996;15:269–78.
Morlet L, Neveu M, Lanquetin S, Gentil C. Barycentric combinations based sub- division shaders. Plzen, Czech Republic. J WSCG 2018;25.
Podkorytov S, Gentil C, Sokolov D, Lanquetin S. Joining primal/dual subdivi- sion surfaces. In: Proceedings of the eighth international conference math- ematical methods for curves and surfaces, MMCS 2012, Oslo, Norway, June 28–July 3, 2012, Revised Selected Papers; 2012. p. 403–24. doi:10.1007/
978- 3- 642- 54382- 1_23.
Halstead M, Kass M, DeRose T. Eﬃcient, fair interpolation using Catmull–Clark surfaces. In: Proceedings of the twentieth annual conference on computer graphics and interactive techniques. ACM; 1993. p. 35–44.
Stam J. Exact evaluation of Catmull–Clark subdivision surfaces at arbitrary pa- rameter values. In: Proceedings of the twenty-fifth annual conference on com- puter graphics and interactive techniques SIGGRAPH ’98. New York, NY, USA: ACM; 1998. p. 395–404. ISBN 0-89791-999-8. doi:10.1145/280814.280945.
Cox MG. The numerical evaluation of B-splines. IMA J Appl Math 1972;10(2):134–49.
Ramshaw L. Blossoming: A connect-the-dots approach to splines. Digital Equipment Corporation Palo Alto; 1987.
Boehm W. Inserting new knots into b-spline curves. Comput Aided Des 1980;12(4):199–201.
Cohen E, Lyche T, Riesenfeld R. Discrete b-splines and subdivision techniques in computer-aided geometric design and computer graphics. Comput Graph Image Process 1980;14(2):87–111.
Sokolov D, Gouaty G, Gentil C, Mishkinis A. Boundary controlled iterated function systems. In: Boissonnat J-D, Cohen A, Gibaru O, Gout C, Lyche T, Mazure M-L, et al., editors. Curves and surfaces. Cham: Springer International Publishing; 2015. p. 414–32.
Sederberg TW, Zheng J, Sewell D, Sabin M. Non-uniform recursive subdivision surfaces. In: Proceedings of the twenty-fifth annual conference on Computer graphics and interactive techniques. ACM; 1998. p. 387–94.
Müller K, Reusche L, Fellner D. Extended subdivision surfaces: building a bridge between NURBS and Catmull–Clark surfaces. ACM Trans Graph (TOG) 2006;25(2):268–92.
Cashman TJ, Augsdörfer UH, Dodgson NA, Sabin MA. NURBS with extraordinary points: high-degree, non-uniform, rational subdivision schemes. ACM Trans Graph (TOG) 2009;28(3):46.
