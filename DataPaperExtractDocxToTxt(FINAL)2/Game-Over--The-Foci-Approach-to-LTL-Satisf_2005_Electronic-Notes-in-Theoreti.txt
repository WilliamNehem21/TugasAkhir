Electronic Notes in Theoretical Computer Science 119 (2005) 33–49  
www.elsevier.com/locate/entcs


Game Over: The Foci Approach to LTL Satisfiability and Model Checking
Christian Dax Martin Lange
Institut fu¨r Informatik, University of Munich

Abstract
Focus games have been shown to yield game-theoretical characterisations for the satisfiability and the model checking problem for various temporal logics. One of the players is given a tool – the focus – that enables him to show the regeneration of temporal operators characterised as least or greatest fixpoints. His strategy usually is build upon a priority list of formulas and, thus, is not positional. This paper defines foci games for satisfiability of LTL formulas. Strategies in these games are trivially positional since they parallelise all of the focus player’s choices, thus resulting in a 1-player game in effect. The games are shown to be correct and to yield smaller (counter-)models than the focus games. Finally, foci games for model checking LTL are defined as well.
Keywords: Verification, Temporal Logic, Tool Support

Introduction
Verification is strongly linked with logics and in fact is nowadays a broadly accepted and active area of research in logics for computer science. This is because logical formulas express properties and, therefore, can be used to express correctness in particular. The question of whether or not a piece of hardware or software obeys a certain correctness property is often reduced to the satisfiability or model checking problem for a temporal logic.
In both cases, games provide an advantageous mechanism for carrying out the verification task. A game-based algorithm deciding one of these problems computes a winning strategy for a player in a certain 2-player game. This strategy can then be used not only to report to the user of a verification tool that the examined formula is or is not satisfied/satisfiable, but also to show to her why this is the case. This is done by letting the user play against the


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.07.007


winning strategy. By its very definition, the user is bound to lose any resulting play. Since the rules of such games usually follow the semantics of formulas closely, this provides the user with insight into where exactly a transition system fails to satisfy the formula at hand for example.
Here we deal with Linear Time Temporal Logic (LTL) [10]. It has been well studied since and enjoys various decision procedures for both its model check- ing and its satisfiability problem. They include tableau methods [10,8,1,12], resolution [5], reductions [4], automata-theoretic procedures [13,14] as well as symbolic methods [2].
Satisfiability games for LTL have been defined in [6] in terms of focus games. They work on sets of formulas but equip the universal player (refuter) with a simple tool that allows him to neatly show the regeneration of least fixpoint constructs – one possible source of unsatisfiability. This makes them suitable for making the user of a verification tool understand unsatisfiability of a given formula as described above.
Focus games were first used to give a game-theoretical characterisation of the model checking problem for the full branching time logic CTL∗ [7]. It is well known that this is very closely related to LTL’s model checking problem. Thus, [7] also provides a game-based approach to LTL model checking.
These focus games have nice theoretical properties. For example, refuter’s strategies can explicitly be given in terms of priority lists, and refuter’s moves of the focus can be determinised at no further complexity-theoretic costs. However, when it comes to implementing these games a few obstacles have to be dealt with. The main problem is to decide which formula refuter should focus on in case there is no least fixpoint construct in the actual configuration. Other difficulties arise when trying to recognise the right moment a focused formula is fulfilled and the refuter has to react. Furthermore, the priority list needs to be constantly maintained because formulas in the corresponding configurations change shape during a play.
Their main disadvantage however, is the fact that refuter’s winning strate- gies are not positional but Least Appearance Record strategies [9]. This means that the tree of plays cannot simply be stored as a directed acyclic graph which would be much better for efficiency.
Here we propose foci games to overcome these issues. They extend the focus approach by letting the refuter focus on all possible least fixpoint con- structs in parallel.
This has several implications: On the positive side, foci games provide a game-theoretical characterisation of LTL’s satisfiability problem which is better suited for tool support. They also improve the small model property gained from focus games by a linear factor, thus yielding shorter models of


satisfiable formulas. On the negative side, foci games are degenerated games – strictly speaking. In (satisfiability) focus games, all that refuter does is set the focus which he is completely deprived of in the foci games. However, we do not propose the use of foci games directly for interacting with the user of a verification tool. Instead we show how (rather simply) winning strategies for focus games can be obtained from those of foci games. Then, focus games can be used as an interface between a user and the foci games. This combines advantages of both approaches in a verification tool.
It it well known that LTL’s satisfiability problem is closely related to its model checking problem. We also define foci games for LTL model checking. The same discussion about pros and cons holds for them as well.
The paper is organised as follows. Section 2 recalls the definition of LTL. Section 3 gives a short summary and discussion of focus games for satisfiability of LTL formulas. Section 4 defines foci games for this problem, proves them correct, sketches an algorithm that decides their winners and shows how to use their winning strategies back in focus games. Finally, Section 5 defines model checking foci games for LTL.


Preliminaries
Let P be a set of monadic second-order propositions which is closed under complementation, i.e. for every q ∈ P there is a q ∈ P with q = q. Furthermore let P contain two distinguished propositions tt and ff that are complementary to each other.
A linear time structure is a tuple π = (S, <, Iπ) where S is a set {s0, s1,.. .} of order type ω. We usually call them states. < is a total order on the set of states. Iπ is an interpretation function that maps every proposition q to the set of states satisfying q.
Interpretations have to obey complementation as well as true and false, i.e. for every Iπ, every q ∈ P and every i ∈ N we have si ∈ Iπ(tt), and si ∈ Iπ(q) iff si /∈ Iπ(q).
We write πk for the k-th suffix of π. Its universe is sksk+1 ... and its interpretation is defined by si ∈ Iπk (q) iff si+k ∈ Iπ(q) for every q ∈ P.
Formulas of LTL in positive normal form are given by the following gram- mar.
ϕ	::=	q  | ϕ ∨ ϕ  | ϕ ∧ ϕ  | Xϕ  | ϕUϕ  |  ϕRϕ
The temporal operators U and R can be characterised as fixpoints of certain equivalences. The rules in Sections 3, 4 and 5 will make use of this. In order

to do so, we need to define unfoldings of these operators given by
unf(ϕUψ)  :=  {ϕUψ, X(ϕUψ),ϕ ∧ X(ϕUψ),ψ ∨ (ϕ ∧ X(ϕUψ))}
unf(ϕRψ)  :=  {ϕRψ, X(ϕRψ),ϕ ∨ X(ϕRψ),ψ ∧ (ϕ ∨ X(ϕRψ))}
The set Sub(ϕ) of subformulas of an LTL formula ϕ is defined as usual except for the cases
Sub(ϕUψ) := unf(ϕUψ) ∪ Sub(ϕ) ∪ Sub(ψ) Sub(ϕRψ)  :=  unf(ϕRψ) ∪ Sub(ϕ) ∪ Sub(ψ)
Note that the number of subformulas of a formula is at most linear in its syn- tactical length. Thus, we define the size of ϕ as |ϕ| := |Sub(ϕ)|. Furthermore, we define for arbitrary formulas χ the set of all until/release unfoldings of formulas in χ as
UNT(χ)  :=    { unf(ϕUψ) | ϕUψ ∈ Sub(χ) }
REL(χ)  :=    { unf(ϕRψ) | ϕRψ ∈ Sub(χ) }
LTL is interpreted over linear time structures π. For any π with universe
s0s1 ... we have

Approximants of U and R formulas are defined for any k ∈ N as
ϕUk+1ψ  := ψ ∨ (ϕ ∧ X(ϕUkψ))
ϕRk+1ψ  := ψ ∧ (ϕ ∨ X(ϕRkψ))
The next lemma is a standard result about least and greatest fixpoints.
Lemma 2.1 For any linear time structure π, any LTL formulas ϕ and ψ we have:
π |= ϕUψ iff there is a k ∈ N s.t. π |= ϕUkψ
π |= ϕRψ iff for all k ∈ N: π |= ϕRkψ
Since the underlying set of propositions is supposed to be closed under com- plementation and every LTL operator has a dual one we also get that LTL


is closed under negation. Then we can assume that for any LTL formula ϕ there is also an LTL formula ¬ϕ. Furthermore, we will use the abbreviations ϕ → ψ := ¬ϕ ∨ ψ as well as Fϕ := ttUϕ and Gϕ := ffRϕ. Finally, we write Xkϕ to denote X ... X ϕ.
k times

Focus Games for Satisfiability of LTL Formulas
Focus game for satisfiability of LTL formulas as presented in [6] work as fol- lows. Two players called ∃ and ∀ play on sets of subformulas of a given formula ϕ in order to determine whether or not ϕ is satisfiable. Player ∃ believes that it is whereas player ∀ wants to show that it is not.
Note that a temporal formula can be unsatisfiable because of two reasons. Either it contains a propositional contradiction or a least fixpoint formula that does not get fulfilled in a possible model. The first case of unsatisfiability is easy to handle since it always breaks down to atomic propositions. The second case is slightly more difficult when configurations are sets of formulas. It is not enough to stop a play or a tableau branch once a repeat of a configura- tion occurs and to check whether a least fixpoint construct occurs in it. It is not immediately clear whether this construct really has not been fulfilled or actually was regenerated by a greatest fixpoint construct. Therefore player ∀ is equipped with a tool called focus which highlights one formula in a config- uration. He can use it to show that a least fixpoint construct does not get fulfilled along a play.
The set of configurations of the game Γ(ϕ0) is Sub(ϕ0) × 2Sub(ϕ0 ). A con- figuration is written ψ , Φ which means that ψ is the one formula that player
∀ currently focuses on.
The game rules are presented in Figure 1. They are to be read top-to- bottom. For example, if a configuration contains a disjunction then player
∃ has to choose one of the disjuncts that replaces the disjunction. Fixpoint formulas are unfolded. At any moment, player ∀ can reset the focus to another formula. If every formula present in the current configuration begins with an X or is an atomic proposition then all the X’s are stripped off and the atomic propositions are discarded unless one of the following winning conditions holds beforehand.
Player ∀ wins the play C0,... , Cn iff
ff ∈ Cn or there is a q ∈ P s.t. q ∈ Cn and q ∈ Cn, or
there is an i < n s.t. Ci = Cn = ϕUψ , Φ for some ϕ, ψ, Φ and between
Ci and Cn player ∀ has not used rule (FC).
Player ∃ wins the play C0,... , Cn iff



Fig. 1. The rules of the LTL satisfiability focus games.
Cn = q1 ,... , qk and for all i = 1,..., k: qi /∈ Cn,
there is an i < n s.t. Ci = Cn = ϕRψ , Φ for some ϕ, ψ, Φ, and between
Ci and Cn player ∀ has not used rule (FC),
there is an i < n s.t. Ci = Cn = ϕ , Φ for some ϕ, Φ, and between Ci
and Cn player ∀ has used rule (FC).
Lemma 3.1 [6]  Every play of the game Γ(ϕ) has length at most O(|ϕ|· 2|ϕ|).
This is mainly because there are only |ϕ|· 2|ϕ| many different configurations in the game Γ(ϕ).
Theorem 3.2 [6]  Player ∃ has a winning strategy for the game Γ(ϕ) iff ϕ
is satisﬁable.
The winning strategies can be given explicitly: player ∃ has to preserve sat- isfiability whenever she chooses disjuncts. A winning strategy for player ∀ is conceptually more difficult but easier from a complexity-theoretic point of view. Note that all he does is to set the focus in these games. Thus, a winning strategy must tell him how to do this sensibly. Also note that because of the way the winning conditions are defined, “sensibly” means that he must try to minimise focus changes with rule (FC). This is accomplished by maintaining a priority list of U formulas s.t. he
always focuses on the first one in the list that is present in the current configuration,


only changes focus when player ∃ discards an unfolding of an U with the rule for a disjunction,
moves formulas that were previously focused on to the end of the list.
Positional strategies. It is not hard to see that player ∃’s winning strate- gies are positional, i.e. her moves only depend on the actual configuration. This is not the case for player ∀. At any moment in a play, the maintained list is a compact representation of the part of the play’s history that matters to player ∀.
Complexity.  In order to measure the asymptotic complexity of deciding the winner of a game it is often helpful to design an alternating algorithm and then to employ results about alternating complexity classes from [3]. This is because an alternating algorithm only follows a single play. Here, a single play can be played using polynomial space only, see [6] for details. This would naturally lead to an EXPTIME procedure for deciding the winner because EXPTIME equals alternating PSPACE. However, player ∀’s moves can be determinised using the above described strategy at no further (complexity- theoretic) costs. This leaves a game in which only player ∃ makes choices which is nothing more than a nondeterministic procedure. Luckily, NPSPACE equals PSPACE according to [11]. Hence, deciding the winner of these games is in PSPACE.
Small model property. The soundness part of Theorem 3.2 can be proved by constructing a model for ϕ from a winning strategy for player ∃ and the game Γ(ϕ). Then, the small model property for LTL is a consequence of Lemma 3.1 and yields an upper bound of O(|ϕ|· 2|ϕ|) for the size of a model for ϕ.

Foci Games
Given a ϕ ∈ LTL, the satisfiability foci game G(ϕ) parallelises and, hence, eliminates all possible choices to be made by player ∀ in the game Γ(ϕ). There- fore, it is rather a tableau than a game. These tableaux (for unsatisfiability) are nothing more than representations of winning strategies for player ∀ in the games of the previous section. They are also similar to non-deterministic automata for LTL. It is the winning conditions which makes the difference between a game and an automaton. Here, the winner is determined by what happens between two repeating configurations which is not exactly the same as a Bu¨chi acceptance condition.
Despite the similarities to tableaux and automata we will continue to call
G(ϕ) a game even though one of the players in it is left with nothing to do.



Fig. 2. The rules of the LTL foci games.
We will also speak of a play rather than a branch or a run in order not to lose the connection to focus games. Note that a play won by player ∃ is an unsuccessful branch in a tableau for unsatisfiability.
Configurations of the game G(ϕ) are subsets of formulas, in which several formulas are highlighted with individual foci; plus an additional counter c ∈ N. Formally, a configuration is an element of 2Sub (ϕ), where Sub∗(ϕ) is defined as Sub(ϕ) except for the case
Sub∗(ϕUψ) := {ϕUψ, [ϕUψ]i, [X(ϕUψ)]i, [ϕ ∧ X(ϕUψ)]i, [ψ ∨ (ϕ ∧ X(ϕUψ))]i}
∪ Sub∗(ϕ) ∪ Sub∗(ψ),	where i ∈ N.


A configuration is written

 ϕ1 i1 ,... , ϕm im, Φ; c

which means that formula ϕj is currently highlighted with focus ij. The counter value is c.
For two configurations Ci and Cj in the game G(ϕ0) we write Ci ≈ Cj if
(1) they are equal as sets of formulas disregarding the foci and the counters, and (2) for every χ ∈ UNT(ϕ0): χ has a focus in Ci and in Cj.
Every play of G(ϕ0) starts with the configuration ϕ0; 0. The rules are presented in Figure 2. Player ∃ chooses disjuncts. Conjunctions are flattened and fixpoint constructs are unfolded. An occurring χ ∈ UNT(ϕ0) is highlighted with a new focus. Note that foci on conjunctions and disjunctions are always


passed to the right assuming that boolean junctions are ordered pairs. The reason for this is: a ϕUψ occurs rightmost in the unfolding of itself. Rule (X) strips off trailing X operators and satisfiable sets of propositions. Finally, the same formula must not occur twice with different foci. In this case, the older one replaces the newer one. We will assume that the rules introducing new and collapsing two existing foci will always be played immediately if possible.
Let foc(Φ) := { i | there is a ψ with ψ i ∈ Φ } be the set of all focus indices occurring in Φ.
Player ∃ wins the play C1,... , Cn iff
Cn = q1,... , qk and for all i = 1,..., k: qi /∈ Cn and qi /= ff,
there is an i < n, s.t. Ci ≈ Cn and foc(Ci) ∩ foc(Cn)= ∅.
Player ∀ wins the play C1,... , Cn iff
ff ∈ Cn or there is a q ∈ P s.t. q ∈ Cn and q ∈ Cn, or
there is an i < n, s.t. Ci ≈ Cn and foc(Ci) ∩ foc(Cn) /= ∅.
Note that the definition of ≈ ensures that only configurations are compared in which all U formulas and their unfoldings have a focus.
Lemma 4.1 Every play of G(ϕ) has length at most 2|ϕ|+1.
Proof. Note that there are only 2|ϕ|+1 = 2 · 2|ϕ| many different configurations modulo foci indices since there are only 2|ϕ| many different sets of subformulas of ϕ. Moreover, introducing foci can at most double the length of a play. 
Lemma 4.2 Every play of G(ϕ) has a unique winner.
Proof. According to Lemma 4.1, every play has a winner. Furthermore, winning conditions (i) and (iii), as well as (ii) and (iv) are mutually exclusive. Besides, if a play is won with condition (i) or (iii), then the last configuration Cn cannot have a companion Ci as in winning condition (ii) or (iv). Otherwise the play would have been finished at Ci already.	 
Definition 4.3 Let P = C0, C1,... , Cn be a play of a game G(ϕ0). Take a
ϕUψ ∈ Sub(ϕ0). It is called persisting for P iff there is an i with 0 ≤ i ≤ n,
s.t. for all j < i: Cj ∩ unf(ϕUψ)= ∅ and for all j ≥ i: Cj ∩ unf(ϕUψ) /= ∅.
Lemma 4.4 A play P of G(ϕ0) is won by player ∀ with his winning condition
(iv) iff there is a ϕUψ ∈ Sub(ϕ0) which is persisting for P.
Proof. Suppose that there is a persisting U in P . Then the moment it becomes top-level in a configuration it will receive a focus i. Furthermore, since it persists, it retains its focus. Note that another unfolding of it can obtain a different focus index j later on. But then j > i. Moreover, before rule (X) can


be applied, both unfoldings will have been unified and index j will be replaced by i. Therefore, whenever a repeat on a configuration occurs, focus i will have survived and, hence, player ∀’s winning condition (iv) will apply.
Conversely, if it applies then there is a focus index which has survived. But this can only be if once it was given to an U formula or one of its unfoldings and then remained on it. Note that it is always the right path in a syntax tree of an U’s unfolding which leads back to it. Furthermore, the focus is always passed on to the right successor in its syntax tree. Thus, this U is persisting in the play at hand.	 
Theorem 4.5 (Soundness) If player ∃ has a winning strategy for G(ϕ0)
then ϕ0 is satisﬁable.
Proof. If player ∃ has a winning strategy then there is at least one play won by her. A model π for ϕ0 can easily be extracted from this play. Its states are sets of configurations separated by applications of rule (X). A simple induction on the structure of formulas shows that every formula in a configuration is fulfilled by the suffix of π beginning with its corresponding state. In particular, π |= ϕ0. Lemma 4.4 shows that every occurring U formula becomes fulfilled eventually. By assumption, no U is persisting for this play. Hence, for every ϕUψ, player ∃ must have chosen ψ at some point. By hypothesis, it is fulfilled on the corresponding suffix.	 
Theorem 4.6 (Completeness) If ϕ0 is satisﬁable then player ∃ has a win- ning strategy for G(ϕ0).
Proof. Suppose π is a model for ϕ. Then player ∃ can follow the game G(ϕ0) in π. I.e. starting with π(0) she annotates configurations with a state. Each time rule (X) is played, she moves to the next state in π. If a disjunction comes up she chooses the disjunct which is fulfilled by the suffix of π beginning with the actual state. If both are fulfilled she chooses the smaller one.
The following invariant holds: in a configuration Φ annotated with π(i) we have πi |= ϕ for all ϕ ∈ Φ. Suppose now that the resulting play is won by player ∀. This cannot be with winning condition (iii) since no suffix of π can satisfy both q and q for some q ∈ P. Suppose he wins it with winning condition (iv). According to Lemma 4.4, the play must have a persisting formula of the form ϕUψ. While it persisted, player ∃ has never chosen ψ in its unfolding. By the definition of her strategy, ψ was never satisfied by any suffix of π so far. Note that this play of G(ϕ0) could be continued ad infinitum showing that ψ is never fulfilled on any suffix of π. Thus, ϕUψ cannot have been satisfied contradicting the invariant.	 
Corollary 4.7 (Small model property) If ϕ ∈ LTL is satisﬁable then it

has a model of size O(2|ϕ|).
Proof. Directly from Theorem 4.5 and Lemma 4.1.	 
Theorem 4.8 (Complexity) Deciding the winner of G(ϕ) is in PSPACE.
Proof. A nondeterministic algorithm only needs to store two configurations – the actual one that gets overwritten with each application of a game rule, and a Ci s.t. player ∃ believes that a Cj will occur later on with Ci ≈ Cj. Furthermore, the algorithm needs to store a counter in order to abort the play in case it has not found a repeat. The size of a configuration is polynomial in the size of the input – note that Lemma 4.1 bounds the value of the foci index component by 2|ϕ|+1 – and so is the size of the counter. Applying Savitch’s Theorem [11] yields the claim.	 
Example 4.9 We will define a family ϕn,k of unsatisfiable LTL formulas for every n, k ≥ 1 exhibiting the foci games’ advantage over focus games. The length of a longest play in the game tree for ϕn,k will be longer by a factor O(n) for the focus games compared to the foci games. Thus, n measures the
gap between the two sorts of games; k acts as a an amplifier.

Let P = {p0,... , pn} and define abbreviations P !n :=  n—1(pi ∧ 

j/=i
¬pj)

and P¯n :=  n
none holds. Let
¬pi saying that exactly one proposition other than pn, resp.




1
n,k
k—1
:= ( (P !n ∧	XiP¯n) → XkP !n ) ∧
k—1
( XiP !n ∧	XjP¯n → XkP¯n )

i=1
i=1
j/=i

say: if among k successive states there is only one in which one of the propo- sitions P \ {pn} holds, then this pattern gets repeated ad infinitum, i.e. only every k-th state satisfies one of these propositions. Finally, let



0
n,k
k—1
:=	XiP¯n ∧ XkP !n
i=0

say that the first k − 1 states of a linear time structure are labelled with no proposition and the k-th state is labelled with one of P \ {pn}. Note that ψ0 ∧ Gψ1 expresses that one of these propositions holds exactly in every k-th state. Now we are able to define



ϕn,k  := ψ0
∧ G(ψ1


∧  Fpi)
i=0


Note that ϕn,k is unsatisfiable for every n, k ∈ N because ψn,k,0 ∧ Gψn,k,1
requires that pn holds nowhere, i.e. Fpn can never become fulfilled.
The game trees for both Γ(ϕn,k) and G(ϕn,k) are too big to be depicted here – even for small n and k. However, note that the maximal nesting depth of X operators in ϕn,k is k. This plus the fact that the outermost G regenerates the pattern defining ψn,k,1 and all the formulas Fpi after each application of rule
(X) ensures that after O(k) applications of rule (X), a repeat on a configuration is found if the position of the focus is ignored.
Since the foci game G(ϕn,k) focuses on all U formulas – i.e. all F formulas in this case – in parallel, it is able to show that Fpn does not get fulfilled. Thus player ∀ wins each play after at most k applications of rule (X).
Now consider the focus game Γ(ϕn,k). W.l.o.g. assume that at the begin- ning player ∀ has fixed his priority list as [Fp0, Fp1,... , Fpn]. Then he will focus on each of them in this order. The game tree for player ∀ will contain all of player ∃’s possible choices, in particular those she takes after every k applications of rule (X) in order to choose a proposition out of P\{pn}. Thus, there is a play in which she chooses p0 after k applications of rule (X), p1 after 2k applications, etc. until pn—1 after n · k applications. But then player
∀ will have focused on Fp0 for k steps, then on Fp1 for another k steps, etc. Eventually, after n · k applications of rule (X) he will focus on Fpn which does not get fulfilled and win the play after k steps.
Retrieving winning strategies for focus games. We will explain how to obtain winning strategies for Γ(ϕ) from those of G(ϕ). This is easy for player
∃. She simply makes the same choices in both games.
The situation is different for player ∀. He cannot simply leave the focus on a formula and change it to the U that makes him win a play in the moment it becomes top-level because it is player ∃ who chooses the play subsequently. Thus, he cannot know which play is going to be played.
Definition 4.10 A formula of the form ϕUψ is called winning for a play P if P is won by player ∀ with his winning condition (iv), and ϕUψ is persisting in P and has the least focus index among the persisting ones.
Take the full tree of all plays in G(ϕ0) for a ϕ0 ∈ LTL. Every configuration C can be annotated with the set of U formulas that are winning for a play containing C. In Γ(ϕ0) player ∀ can now set the focus to the ϕUψ in C that is contained in C’s annotations and has least focus index there.
Note that a configuration can have several U formulas in its annotation and the one chosen by player ∀ might be winning for a different play than the one that player ∃ reveals later on. In this case, player ∀ has to change focus in this moment. This can prolong the play P at hand in Γ(ϕ0) compared to


the one in G(ϕ0). Thus even if P repeats on C in G(ϕ0) it might not in Γ(ϕ0). However, continuing to play according to the rules will ultimately result in a win for player ∀. Each time the play in G(ϕ) needs to be prolonged in this way, the set of annotated U formulas gets smaller which eventually means that player ∀ does not have to change focus in Γ(ϕ) anymore.

Foci Games for LTL Model Checking
The model checking problem for LTL is usually defined via transition systems rather than linear time structures. A (labelled) total transition system T over a set P of atomic propositions is a tuple (S, →− , λ) where (S, →− ) is a graph
s.t. for every s ∈ S there is at least one t ∈ S with s →− t.
λ : S → 2P labels the vertices (also called states) in a maximally consis- tent manner. Note that every infinite path through T induces a linear time structure π. Then the model checking problem for LTL and transition systems is: given an LTL formula ϕ and a T with state s, does π |= ϕ hold for every linear time structure π from T starting in s? We will write this succinctly as T ,s |= ϕ or even s |= ϕ if the underlying transition system can be derived from the context.
Remember that LTL satisfiability and its model checking are closely re- lated: both are complete for PSPACE, both can be reduced to the emptiness problem for nondeterministic Bu¨chi automata and both have similar game- theoretic characterisations in terms of focus games. However, they are dual to each other: satisfiability focus games naturally lead to a nondeterministic [6], model checking games to a universal procedure [7]. From a complexity- theoretic point of view, this is of course the same [11].
From a game-theoretic point of view, the roles of the players are swapped. It is player ∀ who becomes active while player ∃ is left with nothing to choose. The intuition behind this is as follows. Note that in the satisfiability foci games conjunctions are preserved and disjunctions are chosen because the latter is satisfiable iff one of its disjuncts is satisfiable. The former however is satisfiable if both conjuncts do not contradict each other. In the model checking game player ∀ wants to refute s |= ϕ. Hence, he has to name a path π in the underlying transition system T s.t. π /|= ϕ. Since the number of paths in a transition system can easily become exponential in the number of its states we want player ∀ to select this path pointwise, i.e. reveal a new state only when the formula requires to do so. But then player ∃ cannot choose disjuncts anymore. The choice of which disjunct is fulfilled depends on which path player ∀ chooses. However, he would only do this after player ∃ has committed to a particular disjunct. Thus, the games would not be sound



Fig. 3. The rules for the LTL model checking foci games.

anymore. For a detailed example cf. [7].
Given a transition system T = (S, −→, λ), a distinguished state s0 and an LTL formula ϕ0, the LTL model checking foci game GT (s0, ϕ0) is played by players ∀ and ∃ in order to determine whether or not s0 |= ϕ0 holds. Configurations are written as t ▶ Φ; c where t ∈ S, Φ ⊆ Sub∗(ϕ0) possibly equipped with foci and c ∈ N. Φ is interpreted disjunctively. The starting configuration is s0 ▶ ϕ0; 0, and the rules are presented in Figure 3.
We redefine the relation ≈ on configurations as: Ci ≈ Cj if (1) they are equal as sets of formulas disregarding the states, the foci and the counters, and (2) for every χ ∈ REL(ϕ0): χ has a focus in Ci and in Cj. The following is not hard to see.
Lemma 5.1 ≈ is an equivalence relation.
Player ∃ wins the play C0, C1,... iff
there is an n ∈ N s.t. Cn = t ▶ q, Φ; c and q ∈ λ(t), or
there are infinitely many ij ∈ N s.t. for all j, k ∈ N: Cij ≈ Cik and
j∈N foc(Cij ) /= ∅.

Player 6 wins the play C0, C1,... iff
there is an n ∈ N s.t. Cn = t ▶ q1,..., qk; c and for all i = 1,..., k: qi /∈ λ(t), or
there are infinitely many ij ∈ N s.t. for all j, k ∈ N: Cij ≈ Cik and
j∈N foc(Cij )= ∅.
Lemma 5.2 Every play has a unique winner.
Proof. This is proved in the same way as Lemma 4.2 but uses Lemma 5.1 as well since the foci of infinitely many configurations are taken into account. 
Theorem 5.3 If 7 , s0 |= ϕ0 then player E wins GT (s0, ϕ0).
Proof. We call a configuration t ▶ Φ true if for all paths π starting with t there is a ϕ ∈ Φ s.t. π |= ϕ. Note that the starting configuration of GT (s0, ϕ0) is true. Furthermore, the rules preserve truth. The only exception is rule
(X) which only preserves truth if the formula satisfying a given path is not an atomic proposition. However, if this is the case then rule (X) will not get played since player E’s winning condition (i) would apply beforehand. Thus, we can assume every configuration of GT (s0, ϕ0) to be true.
We call a formula ϕ a witness for a true configuration t ▶ Φ if it is syntac- tically smallest among those that are satisfied by a path starting in t. Note that only the rules for unfolding a R or an U do not decrease the size of a witness. However, if the witness in a configuration is an U then its size will eventually get decreased – recall the semantics of U.
Thus the witness becomes smaller and smaller until it finally is either a proposition or remains a R, resp. its unfoldings. In the first case, the play is won by player E with her winning condition (i). In the second case the R will get a focus index and keep it, according to a variant of Lemma 4.4. Hence, the play will be won by player E with her winning condition (ii). Altogether, player E has a winning strategy.	 
Theorem 5.4 If 7 , s0 /|= ϕ0 then player 6 wins GT (s0, ϕ0).
Proof. Suppose 7 , s0 /|= ϕ0, i.e. there is a path π starting with s0 s.t. π /|= ϕ0. Player 6’s strategy consists of two parts. Each time rule (X) is played he selects the next state of π. If a conjunct needs to be chosen he picks the one that is not satisfied on the remaining suffix of π. This guarantees that the following invariant holds in all configurations of the outlined play: In a configuration π(k) ▶ Φ we have πk /|= ϕ for all ϕ ∈ Φ.
Suppose now that player E wins this play. Winning condition (i) is im- possible since it immediately contradicts this invariant. But in order for her to win with winning condition (ii) there would have to be a persisting ϕRψ


according to a variant of Lemma 4.4. But then we can replace the first oc- currence of ϕRψ by ϕRmψ according to Lemma 2.1. Since the game rules follow the approximants the play would contain a configuration in which ϕRψ is interpreted as ϕR0ψ which also contradicts the invariant. Hence, player 6’s strategy is winning.	 
Theorem 5.5 For ﬁnite 7 deciding the winner of GT (s0, ϕ) is in PSPACE.
Proof. The proof is similar to the proof of Theorem 4.8. Note that configu- rations of the model checking games extend those of the satisfiability games by a state. This only needs additional logarithmic space. Furthermore, if 7 is finite then the winner of a play is already determined after |7 | · 2|ϕ|+1 steps since this is an upper bound on the number of different configurations possibly occurring in GT (s0, ϕ). Then the winner can be decided by a nondeterministic algorithm using polynomial space only. With Savitch’s Theorem [11], it is in PSPACE.	 

References
G. Bhat, R. Cleaveland, and O. Grumberg. Efficient on-the-fly model checking for CTL∗. In Proc. 10th Symp. on Logic in Computer Science, LICS’95, pages 388–397, San Diego, CA, USA, June 1995. IEEE.
A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu. Symbolic model checking without BDDs. In R. Cleaveland, editor, Proc. 5th Int. Conf. on Tools and Algorithms for the Analysis and Construction of Systems, TACAS’99, volume 1579 of LNCS, Amsterdam, NL, March 1999.
A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer. Alternation. Journal of the ACM, 28(1):114–133, January 1981.
E. Clarke, O. Grumberg, and K. Hamaguchi. Another look at LTL model checking. LNCS, 818:415–427, 1994.
M. Fisher. A resolution method for temporal logic. In J. Mylopoulos and R. Reiter, editors, Proc. 12th Joint Conf. on Artiﬁcial Intelligence, pages 99–104, Sydney, Australia, August 1991. Morgan Kaufmann.
M. Lange and C. Stirling. Focus games for satisfiability and completeness of temporal logic. In Proc. 16th Symp. on Logic in Computer Science, LICS’01, Boston, MA, USA, June 2001. IEEE.
M. Lange and C. Stirling. Model checking games for branching time logics. Journal of Logic and Computation, 12(4):623–639, 2002.
O. Lichtenstein and A. Pnueli. Checking that finite state concurrent programs satisfy their linear specification. In Proc. 12th Symp. on Principles of Programming Languages, POPL’85, pages 97–107, New York, January 1985. ACM.
R. McNaughton. Infinite games played on finite graphs. Annals of Pure and Applied Logic, 65(2):149–184, December 1993.
A. Pnueli. The temporal logic of programs. In Proc. 18th Symp. on Foundations of Computer Science, FOCS’77, pages 46–57, Providence, RI, USA, October 1977. IEEE.
W. J. Savitch. Deterministic simulation of nondeterministic Turing Machines. In Symp. on Theory of Computing, STOC’69, pages 247–248, New York, May 1969. ACM.


P. H. Schmitt and J. Goubault-Larrecq. A tableau system for linear time temporal logic. In Proc. 3rd Workshop on Tools and Algorithms for the Construction and Analysis of Systems, TACAS’97, volume 1217 of LNCS, pages 130–144. Springer, Enschede, Netherlands, April 1997.
A. P. Sistla, M. Y. Vardi, and P. Wolper. Reasoning about infinite computation paths. In Proc. 24th Symp. on Foundations of Computer Science, FOCS’83, pages 185–194, Los Alamitos, Ca., USA, November 1983. IEEE.
M. Y. Vardi. An Automata-Theoretic Approach to Linear Temporal Logic, volume 1043 of
LNCS, pages 238–266. Springer, New York, NY, USA, 1996.
