Electronic Notes in Theoretical Computer Science 41 No. 2 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume41.html 16 pages


A Distributed π-Calculus with Local Areas of Communication

Tom Chothia and Ian Stark
Laboratory for Foundations of Computer Science Division of Informatics, The University of Edinburgh Mayfield Road, Edinburgh EH9 3JZ, Scotland, UK
{stark,tpcc}@dcs.ed.ac.uk


Abstract
This paper introduces a process calculus designed to capture the phenomenon of names which are known universally but always refer to local information. Our system extends the π-calculus so that a channel name can have within its scope several disjoint local areas. Such a channel name may be used for communication within an area, it may be sent between areas, but it cannot itself be used to transmit information from one area to another. Areas are arranged in a hierarchy of levels, distinguishing for example between a single application, a machine, or a whole network. We give an operational semantics for the calculus, and develop a type system that guarantees the proper use of channels within their local areas. We illustrate with models of an internet service protocol and a pair of distributed agents.

Introduction
Most computer programs make assumptions about the environment in which they operate: the facilities available, and how to use them. A C programmer will freely use the function printf, and expect that wherever their compiled code is executed an appropriate library will be loaded to print formatted text. The Java model of lightweight applets travelling over the web relies on ev- ery browser supporting a standard interface to a large collection of known libraries. Even more dynamically, the notion of “mobile agents” [9] has pro- grams hopping from place to place: and everywhere they land, interrogating local directories and using local services through known access methods.
The common theme here is using globally-known names to access local re- sources. But how do names become globally known, and what counts as local? Typically this is a very static and non-computational affair: user manuals list library calls, or services are offered at “well-known” addresses. In this paper we offer a calculus that begins an investigation of the interaction between the scope over which a name is known and the local areas in which it operates.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

Our system is based around the π-calculus, which provides an established framework for reasoning about names and communication. Specifically, we work with a variant that is polyadic (channels carry tuples rather than single values [10]) and asynchronous (output actions always succeed [3]). To this we add a couple of novel extensions, which we motivate here with a brief example. One of the original observations behind the π-calculus is that many issues associated with mobile code can be studied by looking simply at mobile names. So it is here, and our example is the operation of a service protocol that directs the internet. When a browser contacts a web server to fetch a page, or a person operates finger to list the users on a machine, both connect to a numbered “port” on the remote host: port 80 for the web page, port 79 for the finger listing. Of course, this only works if both sides agree; and a port number
becomes “well-known” when enough systems do agree on it [8].
Under Unix, the file /etc/services holds a list mapping numbers to services 1 . There is also a further level of indirection: most machines run only a general meta-server inetd, the Internet daemon, which listens on all ports. When inetd receives a connection, it looks up the port in /etc/services, and then consults a second file which identifies the program to provide that service. The inetd starts the program and hands it a connection to the caller. A π-calculus model of the procedure might look like this.
Client	Carp = νc.(pike⟨finger, c⟩| c(x).print⟨x⟩)
Server	Pike = !pike(s, r).s¯⟨r⟩ | !finger (y).y¯⟨PikeUsers⟩
| !daytime(z).z¯⟨PikeDate⟩
System	(Carp | Pike)
Here a client machine Carp wishes to contact a server Pike with a finger request. The client has two components: the first transmits the request, the second prepares to print the result. Server Pike comprises three replicating processes: a general Internet daemon, a Finger daemon, and a time-of-day daemon. Channel pike is the internet address of the server machine, while the free names finger and daytime represent well-known port numbers. In operation, Carp sends its request to Pike naming the finger service and a reply channel c. The Internet daemon on Pike handles this by retransmitting the contact c over the channel named finger . The Finger daemon collects this and passes information on PikeUsers back to the waiting process at Carp.
This is a fair model, very much in the π-calculus style, but it has some shortcomings. Because the names finger and daytime are visible everywhere, even when the Internet daemon on Pike has collected the request there is no protection against a Finger daemon on some different server actually handling it — perhaps even one back on the “client” Carp itself. If, however, we restrict

1 This usually includes an abundant litter of port numbers which never became sufficiently “well-known”.

the scope of finger to host Pike, then Carp cannot formulate the request because it must know the name of the service. We break this Catch-22 by extending the π-calculus with local areas and assigning each channel a level of operation. Our system is now
net [ host [Carp] | host [Pike]] 
which represents the fact that Carp and Pike are separate hosts residing on a single network. Each of the names in the system is identified as operating at net or host level:
c@net, pike@net, finger @host, daytime@host, print @host .
Thus communication on the finger , daytime or print channels can span only a single host, while channels c and pike operate over the whole network. This is distinct from the scope of names, given by ν-binding; that determines where a name is known, not how it is used. In particular, the finger name in this example has a wide scope, but identical Finger daemons on different hosts will never interfere.
Introducing levels distinguishes between the different uses of concurrency and communication in a single system. For example, within a host there might be several applications, represented by areas at level app; or between host and net there could be a subnet level. Communication between two threads within an application will typically have a very different character to that between two hosts on a network, and a total order of levels allows us to express this concisely.
Overview
In Section 2 we develop a formal description of this local area π-calculus. We give an operational semantics, and prove that it correctly limits communica- tion to the appropriate local areas. We expand on the Internet service example, and present an illustration of agent-based programming in the calculus.
This operational semantics incorporates several dynamic checks to make sure that channels are used correctly. In Section 3 we propose a type system that captures this information statically. For example, our finger channel has type (string @net )@host ; this indicates that it is a host-level channel carrying values that themselves name net-level channels for communicating strings. We prove that “well-typed processes cannot go wrong”, and deduce that we can omit most of the dynamic checks in the operational semantics. Section 4 of the paper concludes.

Related work
In earlier work, Vivas and Dam [15] investigate the behaviour of a blocking operator in the π-calculus: essentially CCS restriction P \ a, which blocks communication on the single channel a without binding it.	Their specific observation is that this breaks Sangiorgi’s reduction of the higher-order π- calculus to the first-order π-calculus. One contribution of our local areas and levels is to provide a systematic framework for this kind of static restriction. There are a range of projects addressing locations in the π-calculus, with some similarities to our local areas. On the whole their aims are comple- mentary: for example, Sangiorgi investigates non-interleaving semantics and causality using locations [11], and Amadio models local failure in distributed
systems [1]. Neither of these limit the range of communication.
Systems proposed for mobile agents often use locations to curtail com- munication very strictly: agents may interact only with agents at the same location, and must move to talk to others. This is the case for Cardelli and Gordon’s mobile ambients [4] and the system Dπ of Hennessy and Riely [7,6]. Approaches to distributed systems sometimes select particular disciplines for local and global communication. Sewell proposes a type system to dis- tinguish between these, where channels either have universal reach or are restricted to a single local area [14]. The Join calculus requires all channels to be located : while anyone may transmit data, only a chosen process at a single site can receive it [5]. Sangiorgi’s notion of uniform receptiveness is
similar [12].
The use of types to structure the “expected” use of π-calculus channels is well-established: the survey paper by Sangiorgi [13] gives a good overview.


A π-calculus with local areas
Syntax
The calculus is built around two classes of identifiers:

channels	a, b, c, x, y, query, reply,... ∈ Chan
and levels	l, m, app, host, net,... ∈ Level.

Channel names are drawn from a countably infinite supply, Chan. Syntacti- cally, they behave exactly as in the π-calculus. Levels are rather more con- strained: we assume prior choice of some finite and totally ordered set Level. The examples in this paper all use app < host < net . In the formal description of calculus, we take l and m as metavariables for these levels.
Processes are given by the following syntax, based on the asynchronous

polyadic π-calculus.

Most of these are entirely standard. The last two constructions are particular to the local area calculus: thus l[P ] represents a process P running in a local area at level l, and the name binding νa@l.P specifies at which level channel a operates. Areas, like processes, are anonymous; this is in contrast to systems for locations, which are usually tagged with identifiers.
Definition 2.1 An agent is any process of the form l[P ]: that is, a single enclosed area.
Channel names may be bound or free in any process. The binding prefixes are as usual the input prefixes a(→b), !a(→b) and restriction νa@l. We write fn(P ) for the set of free names of process P .
We identify process terms up to a structural congruence ‘≡’, defined as the smallest congruence relation containing the following equations:





(Q)
Here P{→c/→b} stands for capture-avoiding simultaneous substitution. This con- gruence allows for alpha-conversion of bound names, algebraic properties of parallel composition ‘|’, and flexible scope for channel names. This last point means that we can freely expand and contract the scope of any ν-binding, provided of course that it always includes every use of the name it binds.
Scope and areas
One point of interest in the structural congruence above is the equation l[νa@m.P ] ≡ νa@m.(l[P ]), commuting name binding and area boundaries. A consequence of this is that the scope of a channel name, determined by ν-binding, is quite independent from the layout of areas, given by l[−]. Scope determines where a name is known, and this will change as a process evolves: areas determine how a name can be used, and these have a fixed structure.

For a process description to be meaningful, this fixed structure of nested areas must accord with the predetermined ordering of levels. For example, a net may contain a host , but not vice versa; similarly a host cannot contain another host . Writing <1 for the one-step relation in the total order of levels, we require that every nested area must be <1-below the one above.
Definition 2.2 The top-level agents of a process P are all the subterms m[Q] not themselves contained in any intermediate area l[−].
For example, in the process a¯b | m[Q] | a(b).m[R] the top-level agents are
m[Q] and m[R].
Definition 2.3 A process P is well-formed at level l if for every top-level agent m[Q], level m <1 l, and Q is itself well-formed at level m, recursively. An agent l[P ] is well-formed if P is well-formed at level l.
We can now make formal the distinction between the scope of a name and its area of operation. Consider some occurrence of a bound channel name a in
a well-formed process P , as the subject of some action: a¯⟨−⟩, a(−), or !a(−).
The scope of a is the enclosing ν-binding νa@l.(−). The local area of this occurrence of a is the enclosing level l area l[−].
A single name may have several disjoint local areas within its scope. It is also possible for a name to occur outside any local area of the right level; in this case it can only be treated as data, not used for communication. We shall see how the operational semantics, and later the proposed type system, enforces this behaviour.
Operational semantics
We give the local area calculus a late-binding, small-step operational seman- tics. Much of this is standard from the regular π-calculus; the only refinement is to make sure that communication on any channel is contained within the appropriate local area.
Just what area is appropriate depends on the operating level of every channel, and we capture that information in a level context Λ: a finite partial map from channel names to levels. We write down level contexts using the a@l notation from name binding. For example:
Λ= {pike@net, finger @host, daytime@host, print @host} or, more simply:
Λ= pike@net ; finger, daytime, print @host .
This declares that pike is a channel used for remote communication over the net , while finger , daytime, and print , even when globally known, are restricted to host -level interaction.

OUT	Λ ▶l
a¯⟨→b	a¯⟨→b⟩
0	l ≤ Λ(a)

IN	Λ ▶l
a(→b).P a(→b)
l ≤ Λ(a)	→b ∩ dom(Λ) = ∅

IN!	Λ ▶l
!a(→b).P a(→b)
P | !a(→b).P	l ≤ Λ(a)	→b ∩ dom(Λ) = ∅

PAR
α
Λ ▶l P −→ P '



α
Λ ▶l P | Q −→ P ' | Q

Λ ▶	P
a¯⟨→c⟩
P '	Λ ▶
a(→b)
Q'

COMM
	l	−→	l	−→	

r
Λ ▶l P | Q −→ P ' | Q'{→c/→b}

BIND
α
Λ, a@m ▶l P −→ P '
a ∈/ fn(α)

α
Λ ▶l νa@m.P −→ νa@m.P'

AREA
Λ ▶l P −→ P '


αΛ ▶	l[P ] −→ l[P ']
if α is a¯⟨→b⟩ or a(→b) then m ≤ Λ(a)


Fig. 1. Operational semantics for the local area calculus
Given some level context Λ, we write Λ ▶l P to denote that process P is well-formed at level l with fn(P ) ⊆ dom(Λ). When the process is in fact a single agent we can omit the annotation on the turnstile and write this as Λ ▶ l[P ]
Our operational semantics is given as an inductively defined relation on well-formed processes, indexed by their level l and context Λ. Transitions take the form
Λ ▶	P −α→ Q
where Λ ▶l P and α is one of the following.


Transition α ::=
a¯⟨→b⟩ output

|	a(→b) input
|	τ	silent internal action
Transitions themselves have free and bound names, given by functions fn(α) and bn(α) respectively, where as usual
fn(a¯⟨→b⟩)= {a} ∪ →b	fn(a(→b)) = fn(!a(→b)) = {a}
bn(a¯⟨→b⟩)= ∅ = fn(τ )= bn(τ )	bn(a(→b)) = bn(!a(→b)) = →b . 
Valid transitions are derived using the rules of Figure 1. We make several observations of these rules and the side-conditions attached to them.
Active use of the structural congruence ‘≡’ is essential to make full use of the rules: a process term may need to be rearranged or α-converted before

it can make progress. For example, there is no symmetric form for the PAR rule (and no need for one).
In order to apply the COMM rule it may be necessary to use structural con- gruence to expand the scope of communicated names to cover both sender and recipient.
Late binding is enforced by the side-condition →b ∩ dom(Λ) = ∅ on the input rules; this ensures that input names are chosen fresh, ready for substitution Q{→c/→b} in the COMM rule. Again, we can always α-convert our processes to achieve this.
All of these comments are simple (and well-known) tidying of the standard
π-calculus. The following are specific to local areas.
The side-condition l ≤ Λ(a) on the OUT, IN and IN! rules prevent channels being read or written at too high a level. For example, trying to transmit on an application-level name in a host -level process. Any process that attempts this becomes stuck.
The side-condition m ≤ Λ(a) on the AREA rule prevents communications escaping from their local area. Notice that necessarily l <1 m here, because of the requirement that the left-hand side l [P ] be well-formed at level m.
The following results show that this operational semantics does successfully capture the intuition behind areas and levels: areas retain their structure over transitions, and actions on a channel are never observed above their operating level.
Proposition 2.4 If we can derive the transition Λ ▶ P −α→ Q then
the process Q is well-formed at level l with fn(Q) ⊆ dom(Λ) ∪ bn(α);
if the transition α is a¯⟨→b⟩ or a(→b) then l ≤ Λ(a).
Proof. Structural induction on the derivation of Λ ▶ P −α→ Q.

In particular if Λ ▶l P
further transitions.
−r→ P ' then Λ ▶ P ' and P ' might itself make

Corollary 2.5 If we can derive the sequence of transitions
Λ ▶	P −r→ P −r→ · · · −r→ P −α→ Q
then the same properties hold of Q as in Proposition 2.4
Proof. Repeated application of the preceding Proposition.

Examples
In the introduction we met a small model of Internet service provision. Fig- ure 2 formulates this system as a term of the local area calculus, with the

Carp = host [νc@net.(pike⟨finger, c⟩| c(x).print⟨x⟩)]
Pike = host [Inet | Finger | Daytime]

Inet = !pike(s, r).s¯⟨r⟩
Finger = !finger (y).y¯⟨PikeUsers⟩
Daytime = !daytime(z).z¯⟨PikeDate⟩
Λ= pike@net ; finger, daytime, print @host
Λ ▶net (Carp | Pike)
Fig. 2. Example of processes using local areas: an Internet server daemon
following structure:
Λ ▶net (Carp | Pike) .
Recall that the host Carp wishes to contact a Finger daemon running on host Pike, through a general Inet daemon. We can now apply our operational semantics to see this in action.
Λ ▶net (Carp | Pike) ≡ (host [νc@net.(pike⟨finger, c⟩| c(x).print⟨x⟩)]
|host [Inet | Finger | Daytime])

extend scope of νc@net
≡ νc@net. (host [pike⟨finger, c⟩| c(x).print⟨x⟩]
|host [Inet | Finger | Daytime])

expand Inet	≡ νc@net. (host [pike⟨finger, c⟩| c(x).print⟨x⟩]
|host [!pike(s, r).s¯⟨r⟩| Finger | Daytime])

communication on pike@net
−r→ νc@net. (host [c(x).print⟨x⟩]
|host [finger⟨c⟩| Inet | Finger | Daytime])

expand Finger	≡ νc@net. (host [c(x).print⟨x⟩]
|host [finger⟨c⟩| Inet | !finger (y).y¯⟨PikeUsers⟩| Daytime])

communication on finger @host
communication
on c@net
−r→ νc@net. (host [c(x).print⟨x⟩]
|host [Inet | c¯⟨PikeUsers⟩| Finger | Daytime])
−r→ νc@net. (host [print⟨PikeUsers⟩]
|host [Inet | Finger | Daytime])

After a sequence of internal communications at the net and host level, the first host Carp is ready to print the information PikeUsers, and host Pike is restored to its original configuration.
Even this small example exhibits interesting scalability.
Pike can support multiple simultaneous finger or daytime requests, because

Main = app[νc@host.(load⟨c⟩| c(y).link (z).print⟨y/z⟩)] Probe = app[νc@host.(load⟨c⟩| c(w).link⟨w⟩)]
Load = app[!load (x).x¯⟨LocalLoad ⟩]
Λ= load @host, link @net, print @host
Λ ▶net host [Main | Load ] | host [Probe | Load ]
Fig. 3. Example of processes using local areas: load management agents
freshly-created channels like c provide private communication links.
The system can support Finger and Daytime servers on several hosts, with exactly the same agent code and protocol, because the finger and daytime names are known globally but act locally.
Figure 3 presents another example, this time a very simple model of agent-style programming. Two hosts both carry a load-monitoring agent Load , which will report the current system load to any other agent on the same host. A Main program on one host wants to compare the load on the two machines, and does this using a Probe agent with which it shares a private channel link .
The processes execute with the following result:
Λ ▶net host [Main | Load ] | host [Probe | Load ]
−r→∗ host [print⟨k⟩| Load ] | host [Load ]
where k is the numerical ratio of the load on the two hosts. Output print⟨k⟩
is the residue of the Main agent, and the Probe is discharged entirely.
One purpose of a system arranged like this is the simplifications it allows in the Load agent:
The two Load agents are actually identical: no parameters, no distinguishing identifiers.
Both are addressed using the same globally-known channel name load .
They only require host -level communication capabilities, and can operate independently of firewalls or authentication.
These are the kind of advantages put forward for agent-based programming: the example shows how the local area calculus can represent them. Of course, they really take off when agents become mobile, but we can begin to evaluate their properties even in static systems like these.

Types for areas
The results at the end of Section 2.3 showed that local communications do remain local: an action on a channel is never observed above its level of

operation. However, this relies on several side-conditions in the operational semantics of Figure 1, of the form l ≤ Λ(a), which are essentially runtime level checks. In this section we show that a suitable type system can provide enough static information to make these checks unnecessary.
The rule AREA of Figure 1 deals with propagating actions once they have happened, and its side-condition remains essential. The level tests accompa- nying OUT, IN and IN! are different: they check to see if an action should be attempted at all. For example, the process a(→b).P should not proceed if it is above a’s level of operation. Arguably, such processes should never be written; the reason it is not entirely trivial to eliminate them is that they can arise during execution as a result of substitution. For example, consider the following system:


a@host, b@app ▶ host [ app[a¯⟨b⟩] | a(x).x¯⟨⟩ ]
−r→ host [ ¯b⟨⟩ ] −→

Here an application sends name b to a host-level process; this is fine as data, but the host then tries to transmit on it, and the process halts as b is only intended for communication within an application.
The type system we propose handles this by specifying not just the oper- ating level of a channel, but also the levels of the channel names passed over it, and so on recursively.
Type system
Types are given by the following rather simple grammar.
Type σ ::= →σ@l
A type declaration of the form a : →σ@l states that a is an l-level channel carry- ing tuples of values whose types are given by the vector →σ. The base types are those with empty tuples: a channel of type ()@l is for synchronisation within an l-area. In concrete examples we shall assume additional base datatypes like int or string as convenient; these can be incorporated without difficulty into the formal presentation.
The only syntactic change required to introduce types into processes is at
ν-binding:
Process P, Q ::= ··· | νa:σ.P  fresh channel a of type σ.
The other binding operation, input prefix a(→b).P , does not need any explicit type annotation, as the types of the →b are fixed by the type of the channel a. We also replace level contexts Λ with type contexts Γ, finite partial maps from channel names to types. With these alterations, Figure 4 presents the rules for deriving type assertions of the form Γ ▶l P , which states that pro-
cess P is well-typed at level l in context Γ.

Γ ▶l 0
Γ ▶l P	Γ ▶l Q
Γ ▶l P | Q
Γ,→b : →σ ▶l P
Γ ▶l a(→b).P
Γ(a)= →σ@m and l ≤ m

Γ ▶l P	l < m
Γ ▶	l[P ]	1
Γ,a : σ ▶l P
Γ ▶l νa:σ.P
Γ,→b : →σ ▶l P
Γ ▶l !a(→b).P
Γ(a)= →σ@m and l ≤ m

Γ ▶l a¯⟨→b⟩	Γ(a)= →σ@m, Γ(→b)= →σ and l ≤ m

Fig. 4. Types for processes in the local area calculus
To connect the typed calculus to the untyped one we use a notion of erasure. If σ = →σ@l is a type, then its erasure [σ♩ is just the level l. If P is a typed process, then its erasure [P♩ is the same process with all types replaced by their erased versions: in particular name binding νa:→σ@l.Q is replaced by νa@l.Q. This throws away the detail of type information, but keeps the basic level declaration. Finally, erasing a type context Γ gives a level context [Γ♩.
Proposition 3.1 If P is a well-typed process at level l in type context Γ, then its erasure [P♩ is well-formed at level l in the level context [Γ♩.
Γ ▶l P	=⇒	[Γ♩ ▶l [P♩
Proof. Structural induction on the type derivation Γ ▶l P .
Examples
We can give types to both of our examples from Section 2.4, which sensibly reflect their operation. First, for the internet daemon of Figure 2.
c : string @net	pike : (service, response)@net finger : service
daytime : service		service = response@host print : string @host	response = string @net
The type service for finger and daytime expands to (string @net )@host . This means that the channels can be used only for host -level communication, but the values carried will themselves be net -level names. The host -level commu- nication is between Inet and Finger or Daytime; the net -level communication is the response sent out to the original enquirer, in this case machine Carp.
Channel pike has a net -level type that acts as a gateway to this, reading the name of a service and a channel where that service should send its reply.
The second example, of agents comparing the load on two hosts, has the following typing.
c : int @host		load : (int @host )@host link : int @net	print : int @host

The most interesting type here is that for load : it captures the fact that not only must requests to load come from agents on the same host, but replies are also host-limited. This characterises a purely local procedure call used within a larger distributed environment.
Correctness
The operational semantics for well-typed processes replaces Λ with Γ in all the rules of Figure 1 and omits the side-condition l ≤ Λ(a) from OUT, IN, and IN! What we show in this section is that it is safe to make these omissions. The first step is to show that this operational semantics preserves types.
Proposition 3.2 If P is a well-typed process at level l in context Γ and we
α
can derive the transition Γ ▶l P −→ Q, then Q is well typed:
if α = a¯⟨→b⟩ or τ then Γ ▶l Q
if α = a(→b) then Γ,→b : →σ ▶l Q where Γ(a)= →σ@m
Proof. Structural induction on the derivation of the transition Γ ▶ P −α→ Q.
As expected, there is an extremely tight connection between the behaviour of typed process terms and their untyped erasures.
Proposition 3.3 Suppose that Γ ▶l P is some well-typed process.

If Γ ▶l
P −α→ P ' then [Γ♩▶ [P♩ −α→ [P '♩.

If [Γ♩▶ [P♩ −α→ Q for some untyped Q, then there is a typed process P '
α
such that Q = [P '♩ and Γ ▶l P −→ P '.
Proof. Structural induction on the derivation of the transitions.
Combining Propositions 3.2 and 3.3(i) with Corollary 2.5, we obtain a demonstration that “well-typed terms cannot go wrong”.
Theorem 3.4 For any well-typed process P, if we can derive the sequence of transitions
r	r	α
Γ ▶l P −→ ... −→−→ Q
where α is a¯⟨→b⟩ or a(→b) and Γ(a)= →σ@m then level l ≤ m.
This establishes that a well-typed process will never attempt to use a channel above its level of operation, without the need for explicit checks in the operational semantics.
Conclusion and further work
The local area calculus provides a reasonable setting to explore the use of names that are known globally but act locally. We have given an operational semantics and proved that it correctly captures this intuition. Illustrative examples include an internet service protocol and a pair of distributed agents.

We propose a type system for channels in the calculus, and prove that it removes the need for some run-time locality checks.
A further area of application that we are exploring is layered network protocols: where each level communicates with the next on a local name, and only the outermost layer engages in actual long-distance communication. For example, TCP/IP is often used with an ordering of levels as application < transport < network < link .
We have an encoding of local areas into the pure π-calculus, using an explicit apparatus of controller processes to enforce level constraints: every communication is marshalled through routers, one for each local area. We have also built components of an implementation in MLj [2], which has provided useful insight on various design choices for the calculus.
With channels operating at distinct levels — network, host, application
— the possibility arises of tuning observations of a process to inspect a single level of interest. We are working on a corresponding notion of bisimulation that filters out actions at some levels and focuses attention on others. Local areas give an opportunity for this to capture spatial information too.
The fact that communication in the calculus may be restricted to certain areas provides a form of security, though rather a weak one, and it may be possible to make a connection here to relevant versions of the π-calculus. For example, if encryption and decryption of messages are represented by commu- nication on channels named by a private key, then carrying these out within a small “sandbox” area prevents eavesdropping. See Vivas and Dam [15] for an illustration of this using blocking.
The ordering of levels immediately suggests notions of subtyping on chan- nels: for example, a net -level name might be used in place of a host -level name. However, even if this were desirable, it breaks down as soon as we pass around names themselves. The type constructor ‘@’ in →σ@l turns out to be invariant in its left argument, essentially because channels are used for both input and output.
One direction that is certainly worth pursuing is the step from static agents to properly mobile ones, and we are looking at various ways to incorporate these into the calculus while retaining the separate handling of scope and area. The π-calculus encoding mentioned above provides some hints: in classic π- calculus style, it can be subverted to emulate mobile areas by dynamically rewiring the attendant router processes.

References
Roberto Amadio. On modelling mobility. Theoretical Computer Science, 240:147–176, 2000.
P. Nick Benton, Andrew Kennedy, and George Russell. Compiling Standard ML to Java bytecodes. In ICFP ’98: Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming. ACM Press, 1998.
G´erard Boudol. Asynchrony and the π-calculus. Rapport de recherche 1702, INRIA, Sophia Antipolis, 1992.
Luca Cardelli and Andrew D. Gordon. Mobile ambients. In Foundations of Software Science and Computation Structure: Proceedings of FoSSaCS ’98, Lecture Notes in Computer Science 1378, pages 140–155. Springer-Verlag, 1998.
C´edric Fournet and Georges Gonthier. The reflexive CHAM and the join- calculus. In Conference Record of POPL ’96: 23rd ACM Symposium on Principles of Programming Languages, pages 372–385. ACM Press, 1996.
Matthew Hennessy and James Riely. Resource access control in systems of mobile agents. In Proceedings of HLCL ’98: High-Level Concurrent Languages, Electronic Notes in Theoretical Computer Science 16.3, pages 3–17. Elsevier, 1998.
Matthew Hennessy and James Riely. A typed language for distributed mobile processes. In Conference Record of POPL ’98: 25th ACM Symposium on Principles of Programming Languages. ACM Press, 1998.
IANA, the Internet Assigned Numbers Authority. Protocol numbers and assignment services: Port numbers. http://www.iana.org/numbers.html#P.
Danny B. Lange and Mitsuru Oshima. Seven good reasons for mobile agents.
Communications of the ACM, 42(3):88–89, March 1999.
Robin Milner. The polyadic π-calculus — a tutorial. Technical Report ECS- LFCS-91-180, Laboratory for Foundations of Computer Science, University of Edinburgh, 1991.
Davide Sangiorgi. Locality and non-interleaving semantics in calculi for mobile processe. Theoretical Computer Science, 155:39–83, 1996.
Davide Sangiorgi. The name discipline of receptiveness. In Automata, Languages and Programming: Proceedings of the 24th International Colloquium ICALP ’97, Lecture Notes in Computer Science 1256. Springer-Verlag, 1997.
Davide Sangiorgi. Reasoning about concurrent systems using types. In Foundations of Software Science and Computation Structure: Proceedings of FoSSaCS ’99, Lecture Notes in Computer Science 1578, pages 31–40. Springer- Verlag, March 1999.

Peter Sewell. Global/local subtyping and capability inference for a distributed π-calculus. In Automata, Languages and Programming: Proceedings of the 25th International Colloquium ICALP ’98, Lecture Notes in Computer Science 1442. Springer-Verlag, 1998.
Jos´e-Luis Vivas and Mads Dam. From higher-order π-calculus to π-calculus in the presence of static operators. In CONCUR ’98: Concurrency Theory. Proceedings of the 9th International Conference, Lecture Notes in Computer Science 1466. Springer-Verlag, 1998.
