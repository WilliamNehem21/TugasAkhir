Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 337 (2018) 135–154
www.elsevier.com/locate/entcs

Stochastic-based Semantics Of Attack-Defense Trees For Security Assessment
Karim Lounis1,2
Interdisciplinary Centre for Security, Reliability and Trust (SnT) University of Luxembourg
Luxembourg, Luxembourg

Abstract
Losses caused by cyber-attacks are considerably increasing each year. The need for an optimal security assessment methodology that combines mathematical foundations with practical and user-friendly repre- sentations has become imperatively crucial. In this paper, we propose a stochastic security assessment methodology that adopts attack-defense trees model to represent security scenarios, and stochastic models to perform both qualitative and quantitative assessment. We illustrate our approach with a simple but realistic example study.
Keywords: Graphical Security Models, Attack-Defense Trees, Attack-trees, Security Assessments, CTMCs, Stochastic Petri-nets.


Introduction
Cyber-attacks are becoming more and more complex, distributed, sophisticated, and organized. Most businesses and industries are well aware of the figurative need to have a financially affordable, reliable, and powerful security assessment methodology that provides visualization of security scenarios, and conveys security information to non-experts in a very intuitive way. Over the last decade, a great research effort has been devoted to design the best security assessment methodology, where several graphical security models have been proposed in the literature [3,4,10]. The optimal methodology should combine mathematical foundations with practical and intuitive representation features. We found the attack-defense trees methodology [3] to bea favorable candidate which responds to such criteria.

1 The research leading to the results presented in this work received funding from the European Com- mission’s Seventh Framework Programme (FP7/2007-2013) under grant agreement number 318003 (TREs- PASS) and Fonds National de la Recherche Luxembourg under the grant C13/IS/5809105 (ADT2P).
2 Email: karim.lounis@uni.lu

https://doi.org/10.1016/j.entcs.2018.03.038
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

ADTrees (Attack-Defense Trees) [3] are defined as a formal, and graphical method- ology used for representing security scenarios by systematically enumerating the different actions that an attacker might undertake to perform a security breach, as well as the different actions that a defender might apply to stop, mitigate or delay attacker’s actions from being successfully realized. The existing semantics for ADTrees (e.g Propositional, De Morgan Lattice, Equational, and Multisets) are purely denotational and do not express any notion of execution, or actions order- ing. Therefore our main and first contribution will rely on proposing an operational semantics based on stochastic Petri-nets for ADTrees in order to be able to handle aspects like action ordering and dependencies.
Moreover, there is a considerable paucity of qualitative underpinnings supporting ADTrees analysis. Thus, our second contribution in this work will consist in inter- preting the behavioral qualitative properties of Petri-nets in the context of security in general, and ADTrees in particular. Thanks to the isomorphic relation between finite continuous time Markov chains and bounded stochastic Petri-nets [16], we can perform both quantitative and qualitative security analysis by shifting from one model to another. In fact, to perform qualitative security analysis, we apply the well-known structural and behavioral analysis of Petri-nets. For quantitative analysis, we generate the corresponding finite CTMC (Continuous Time Markov Chain) of a given bounded Petri-net model and apply the classical analytical ap- proach for probabilistic and time-based security analysis. Finally, to our knowledge, ADTrees do not specify any refinement operator describing actions to be performed in parallel. Therefore, we propose a new refinement operator expressing parallel actions, which we call disjunctive parallel refinement. In addition to that, coun- termeasures in ADTrees are quite abstract and general from the execution aspect, inspired by [18], who proposed one class of countermeasure called delayed-type coun- termeasure, we propose an other class of countermeasures that we call blocking-type countermeasures.
The main contributions of this paper are the four folds:
We propose a stochastic operational semantics in terms of stochastic Petri-nets for attack-defense trees as well as attack-trees.
We extend the existing attack-defense trees’ refinement operators with a new type of refinement operator expressing parallelism.
We extend the existing attack-defense trees’ countermeasure types with a new type of countermeasure called blocking-type countermeasure.
We interprete the behavioral qualitative properties of Petri-net models in the context of security to perform qualitative analysis of attack-defense trees as well as attack-trees.
The remainder of the paper is organized as follows: in sections 2 we give an overview on attack-defense trees, and extend the formalsim with respect to refine- ments operator, and countermeasures. In section 3, we briefly present stochastic Petri-nets. In section 4, we introduce the operational semantics for attack-defense

trees, and provide formal framework for it. In section 5, we present then report the results of the qualitative and quantitative analysis performed on a simple but realistic example study. We discuss related works in section 6, and conclude the paper in section 7.

Basic concepts
Given that our goal is to improve the analysis of attack–defense scenarios, modeled using ADTree, in this section we first introduce the ADTree methodology, then extend the ADTree refinement specification. Finally, we present the concept of countermeasures in ADTrees, then propose a classification for it.

Attack–Defense Trees
We consider an attack–defense scenario to be a game between two players, the pro- ponent (denoted by p) and the opponent (denoted by o), and represent the scenario using Attack–Defense Trees. An ADTree is a node-labeled rooted tree where the root node represents the main goal of the proponent. When the root of an ADTree is an attack node, the proponent is an attacker and the opponent is a defender. Conversely, when the root is a defense node, the proponent is a defender and the opponent is an attacker. The children of a given node represents its refinement into sub-goals. The refinement of a node is typically either disjunctive, conjunctive. or sequential-conjunctive. The goal of a disjunctively refined node is achieved when at least one of its children’s goals is achieved and the goal of a conjunctively refined node is achieved when all its children’s goals are achieved. Finally, a sequential- conjunctive refinement allows us to model that a certain goal is reached if and only if all its subgoals are reached in a precise order. Each node can have one child of the opposite type, representing the node’s counteraction, which can be refined and countered again. Thus, an attack node may have several children which refine the attack and one child which defends against the attack. The defending child in turn may have several children which refines the defense and one child that is an attack node and counters the defense. The leaves of an ADTree represent the basic actions which need not be refined any further. Graphically, the attacker actions are depicted with red circles, and defender actions with green squares. We depict a conjunctive refinement of a node by connecting the edges going from this node to its children of the same type with an arc. We depict attack nodes by circles and defense nodes by rectangles, as shown in Figure 1. Refinement relations are indicated by solid edges between nodes and countermeasures are indicated by dotted edges.
Example 2.1 Figure 1 illustrates an ADTree which models a security scenario in which one attacker tries to perform attacks on a LTE-network subscribers. The attacker runs two compound attacks in parallel, a denial of service over the infras- tructure, and tries to remotely control the users equipments. We model this using a parallel disjunction refinement (∨). In order to launch the denial of service, the attacker conjunctively exhaust RAN connexions and (∧) overload the DNS infras-



Fig. 1. Attack-Defense tree for attacking LTE-subscribers, where red circles are attacker actions, and green squares are defender actions
tructure. Meanwhile, to control the users equipments he sequentially tries to install
−→a malware on the users equipments the    abuse the equipments by running some
dangerous commands. To installing malware on users equipments, the attacker runs either phishing attack through application stores, or (∨) phishing through emails. From the other side, the defender set up an anomaly-based IDS, which by detecting dangerous commands, turns the user equipments off preventing further damages (CB). He also have a malware detector, which by detecting a malware signature deletes it (CD).
We now introduce some notation in order to formally represent ADTrees. Let

S			s	s
−→s

= {p, o} be a set of types where p = o and o = p, and ∨k, ∧k and ∧k be unranked
functions representing the disjunctive, conjunctive, and sequential conjunction re- finement operators respectively. The binary function cs (s ∈ S) connects an action of type s with action of the opposite type s. Finally, let B = Bp ∪ Bo where the elements of Bp and Bo be typed constants, which we refer to as the basic actions of
the proponent (p) and the opponent (o) respectively. The signature of an ADTree

can then be denoted as Σ = (S, F) where F
s	s −→s	s	B.

= {∨k, ∧k, ∧k,c } ∪
Definition 2.2 An Attack–Defense Tree is a typed-term defined over Σ, and gen- erated by the following BNF-grammar, where s ∈ S, and k ∈ N:

t ::= bs
| ∨s
(t,..., t) | ∧s (t,..., t) | −→
(t,..., t) | cs(t, t)


Extending Attack-Defense Trees reﬁnements
It has been widely recognized that parallel actions are crucial in security, as they constitute the main key of cyber-attacks performed on large scaled systems. How- ever, abide the different existing types of refinements operator used in ADTrees, there is no refinement operator expressing parallel actions execution. Moreover, the use of only disjunctive refinement is not enough to capture such security scenarios.

Recent works [5, 9, 12, 13] considered disjunctive refinement as a refinement op- erator where an attacker has to execute at least one refinement action among many, which means that the attacker may have all the refinements executed. This sounds to be a kind of parallel refinement operator, however, we define the disjunction as a choice operator, where among all refinements, only one will be executed by the attacker. In fact, the disjunction operator assumes the refinement actions to be mutually exclusive.
Therefore, we introduce a new type of refinement operator to represent parallel execution of actions. We name this operator parallel disjunction refinement. This new type of refinement will allow an attacker/defender to perform more than one action at the same time, expecting that the successful termination of at least one action is enough to proceed to the next action. We use dots to graphically represent this type of refinement.
Definition 2.3 Let k ∈ N, let t1,..., tk ∈ TΣ, and let ∧, and ∨ be the conjunction and disjunction reﬁnement operators. Then a parallel disjunction operator is a refinement operator defined by an unranked function ∨˜k, such that:
∨ (t1,..., tk)= ∨ (t1,..., tk−1) ∨ (tk ∧ ∨ (t1,..., tk−1)) ∨ tk
Example 2.4 Let us consider three basic actions b0, b1, b2 ∈ B that a player plan to run in parallel. The goal of the player will be achieved if at least one of the following successful combination happens {b0, b1, b2, b0b1, b0b2, b1b2, b0b1b2}.

Countermeasures in Attack-Defense Trees
An ADTree consists of two types of nodes: one representing attacker’s actions and the other corresponding to the defender. The original definition of ADTree [3] does not distinguish between various types of defense nodes. Relatively recently, to improve modeling capabilities and security analysis, studies have considered classi- fication of defense nodes. For example, [5, 9, 12, 13] consider defenses that instan- taneously negate the effect of an attack whereas [18] study defenses that delay the success of an attack. The former have been considered largely implicitly where the corresponding attacker’s action are removed from the model. In this paper, we distinguish between the following two types of defense nodes.
Delaying-type defense node: Similarly to [18], we consider these types of coun- termeasures to model situations where the defender, for example, changes the IP address of a host to act against a scanning attack. The attacker in this case is forced to re-perform the reconnaissance step of her attack.
Blocking-type defense nodes: These types of countermeasures are a generaliza- tion of the ones proposed in [5, 9, 12, 13]. An attacker is prevented (blocked) from executing an action if the corresponding defense is either in place or ap- plied successfully before the attacker’s action is completed. For example, an attacker cannot transfer files via ftp if the defender has stopped running the ftp service on the target host. In contrast to the delayed-impact countermeasures, this type of defenses do not allow the attacker to re-perform the same attack

is forced to choose an alternative.

Let cs
and cs
refer to the delayed-impact and blocking-impact countermeasures

respectively. The signature of an ADTree (see Definition 2.2) can then be defined as
s	s −→s	s	s	s
Σ= (S, F) where F = {∨k, ∧k, ∧k, ∨k, cD , cB } ∪ B and the ADTree can be defined as follows.
Definition 2.5 An Attack–Defense Tree is a typed-term defined over Σ, and gen- erated by the following BNF-grammar, where s ∈ S, and k ∈ N:

s	s	s
−→s
s	s	s

t ::= b | ∨ (t,..., t) |∧ (t,..., t) | ∧ (t,..., t) | ∨˜ (t,..., t) | cB (t, t) | cD (t, t)
Example 2.6 By labeling the basic actions of the ADTree in Figure 1 as; ‘Down- load untrusted application’ bp, ‘Get infected by email’ bp ‘Abuse UE’ bp, ‘Exhaust
p	0	p	1	2	o
RAN connexion’ b3, ‘Overload DNS infrastructure’ b4, ‘IDS anomaly detection’ b1,
and ‘Anti-Malware’ bo. The resulting ADTerm of the ADTree in Figure 1 is:

t = ∨˜p −→  p  ∨p (bp, bp), bo , cp bp, bo)  , ∧p bp, bp 

Stochastic Petri Nets
Petri-nets are mathematical yet graphical models that are widely used to represent systems that exhibit concurrency, parallelism, synchronization and nondetermin- ism [20]. They have been used to study qualitative security properties such as the take-grant model [1] and lattice-based structures describing access control poli- cies [2]. Several complex systems have been modeled [6, 8] using various extensions of using Petri-nets [11, 14–16]. To ensure that the semantics of ADTrees presented in this paper are consistent with the semantics in [18], we focus here on bounded stochastic petri-nets (SPNs) since they are isomorphic to finite continuous time Markov chains (CTMCs) [16].
Graphically, SPNs are composed of two main components: places that represent resources (depicted as circles ⃝) and transitions that represent actions on resources (depicted by bars []). Places contain tokens that denote the number of resources available. Places and transitions are connected by directed arcs (→), where the places which feed a transition with tokens are defined as its preset and the places which are fed by a transition are defined as its postset. In a stochastic Petri- net, transitions are controlled by an exponentially distributed firing time i.e., each transition is attributed an exponential rate that determines the mean time before the transition is fired.
Definition 3.1 A stochastic Petri-net is a 6-tuple (P, T, I, O, M0, Λ), where P is a ﬁnite set of places, T a finite set of transitions, I = {(p, t) | p ∈ P, t ∈ T} a finite set of input arcs (preset), O = {(t, p) | t ∈ T, p ∈ P} a finite set of output arcs (postset), M0 the initial marking indicating the amount of tokens initially available in each place, and Λ: T → R+ a function which associates an exponential rate with each transition.

Stochastic Petri-Nets semantics for ADTrees
In this section we define SPNs-based semantics for ADTrees. First, we formulate
s	s  −→s	s
each element of an ADTree – basic actions B, refinements ∨k, ∧k, ∧k, ∨˜k, and
provides the SPN representing the entire ADTree. This approach first models each
leaf node representing a basic action in the ADTree using a 1-transition SPN. Fol- lowing the standard bottom-up procedure [4], the SPN representing all other nodes are derived by composing the SPNs corresponding to their children. This recur- sive process terminates at the root node where an SPN that represents the entire attack–defense scenario modeled by the ADTree is obtained. The SPNs semantics of ADTrees can therefore be defined as follows.
Definition 4.1 Let TΣ be the set of all ADTrees defined over the signature Σ, and let T be the set of all SPNs. The SPNs semantics J·)SPN : TΣ → Y is a function which provides a SPNs representation for each ADTree.
To enable fine-grained modeling of the elements of ADTrees, similarly to [18], we explicitly distinguish between three types of places within SPNs. We consider that each SPN has a set of initial places denoted by P0, a set of transitive places denoted by Pt, and a set of final places denoted by P∗. The original definition of a stochastic Petri-net (see Definition 3.1) is then adapted in order to explicitly enumerate the set of places as P = P0 ∪ Pt ∪ P∗ and the set of input and output arcs as K = I ∪O. In our context, the markings in a SPN is driven by the following principle: the number of tokens in a place denotes the number of actions that an agent (attacker/defender) can perform in that place.
In what follows, we denote by ys, ..., ys ∈ Y stochastic Petri-nets, and by bs ∈ B
1	k
basic actions for a given player s ∈ S, and let ΓP denotes a property that we call linkability. We write (p, t) |= ΓP or (t, p) |= ΓP to say that a pair (p, t) ∈ I, or (t, p) ∈ O is indeed an input, or output arc in a given stochastic Petri-net with a
given set of places P.
Semantics for basic actions
We start by defining the semantics of the basic actions of ADTrees. When t = bs, where t ∈ TΣ, bs ∈ B and s ∈ S, the function J·)SPN : TΣ → Y interprets the attack tree t (irrespective of attacker’s or defender’s action) as a SPN having a
single stochastic transition tys	ys
b  with rate λb . This SPN has two places – an initial
place P0 and a final place P∗. The initial marking is (1, 0) and denotes that agent
s can execute one action bs with rate λys from place P . Successful execution of
0
this action provides the final marking (0, 1) in the SPN. Formally, Jbs)SPN = Ψ0(bs)
such that:

s	ys
ys	ys	ys

Ψ0(b )= (P0 ∪ P∗, {tb }, {(p0, tb ), (tb , p∗)}, {λb }, (M0(P0), M0(P∗)))	(1)
ys	ys	ys	ys
= ({p0, p∗}, {tb }, {(p0, tb ), (tb , p∗)}, {λb }, (1, 0))	(2)
Example 4.2 Let us consider an ADTree t = bs, where bs ∈ Bs is a basic actions.
1	1

Then applying the function Ψ0(bs) will produce a SPN ys ∈ Y depicted in Figure 2-
1	1
a. The SPN is composed of 2 places, one initial p0, and one final p∗, linked together
using one transition of rate λ1 ∈ R+.
Semantics for conjunction reﬁnement
We define the semantics of conjunction refinement of ADTrees. Basically, when t = ∧s(t1,..., tk), where t ∈ TΣ, t1≤i≤k ∈ TΣ, k ∈ N and s ∈ S. The function J·)SPN : TΣ → Y interprets the attack tree t (irrespective of the type of player) as a SPN composed using the Cartesian product of all SPNs y1,..., yk ∈ Y representing the refinements t1≤i≤k ∈ TΣ. This composed SPN has |Py1 | + ... + |Pyk | places, where |Pyi | is the cardinality of the set of place P of a given SPN y1≤i≤k ∈ Y. The involved SPNs are joined together in such a way that all of them will be executed in an irrelevant order. The initial marking is (1,..., 0) and denotes that agent s can execute one of the refinements t1≤i≤k ∈ TΣ from place P0. Successful execution of all refinements (involved SPNs) provides the final marking (0,... 1) in the SPN.
Formally, J∧s(t1,..., tk))SPN = Ψ1(ys,..., ys)= (P, T, K, Λ, M0) such that:


⎧⎪	⎧
1	k

ys	ys	⎫

P0 = {(p 1 ,...,p k )}

k
⎪ P =	Py =
0	0
ys	ys	ys
ys	⎬

i	P = P − {(p 1 ,...,p k ), (p 1 ,...,p k )}
⎪	⎪

i=1
⎪


0	0	∗	∗
⎪⎩	ys	ys	⎪⎭


		




ys	ys
ys′
ys′

0	k	0	k
⎪
M0 = (M0(p0),..., M0(p∗)) = (1,..., 0)
Example 4.3 Let us consider an ADTree t = ∧s(b1, b2), where bs, bs ∈ Bs are two
1  2
basic actions, and let ys, ys ∈ Y be their corresponding SPNs with rates λ1, λ2 ∈ R+
1	2
respectively. Then applying the function Ψ1(ys, ys) will produce the SPN depicted
1	2
in Figure 2-b. The SPN is composed of 4 places, one initial p0, one final p∗, and
two transient places p1 and p2.

Semantics for disjunction reﬁnement
We define the semantics of disjunction refinement of ADTrees. Basically, when t = ∨s(t1,..., tk), where t ∈ TΣ, t1≤i≤k ∈ TΣ, k ∈ N and s ∈ S. The func- tion J·)SPN : TΣ → Y interprets the attack tree t (irrespective of the type of player) as a SPN composed of k SPNs y1≤i≤k ∈ Y in such a way that only one SPN can independently succeed. This is realized by merging together the initial place of all involved SPN into one common initial place. The initial marking is (1,..., 0) and denotes that agent s can execute one of the refinements t1≤i≤k ∈ TΣ from place P0. Successful execution of the ith SPN provides one final marking

(0,..., M0(pi),..., 0), where M0(pi) = 1, and pi is the final place of the ith SPN. Formally, J∨s(t1,..., tk))SPN = Ψ2(ys,..., ys)= (P, T, K, Λ, M0) such that:



⎧⎪	⎧⎪
1	k



ys	ys	⎫⎪

P0 = {(p 1 ,...,p k )}


⎪ P =
  ⎪⎨ Pt =
⎪



i =1
0

Pyi ×
0


 j/=i
P j ⎪⎬
⎪

⎪⎪⎨
⎪ P∗ = 
Pyi ×
Pyj ⎪

⎩	i=1	j/=i	⎭

ys	ys

	

ys′


ys′





s	s	ys′
ys′

0	k	0	k
⎪
⎪⎩ M0 = (M0(p0),..., M0(p∗)) = (1,..., 0)


Example 4.4 Let us consider an ADTree t = ∨s(b1, b2), where bs, bs ∈ Bs are two
1  2
basic actions, and let ys, ys ∈ Y be their corresponding SPNs with rates λ1, λ2 ∈ R+
1	2
respectively. Then applying the function Ψ1(ys, ys) will produce the SPN depicted
1	2
in Figure 2-b. The SPN is composed of 3 places, one initial p0, and two final p1,
and p2.





Semantics for sequential conjunction reﬁnement

We define the semantics of sequential conjunction refinement of ADTrees. Basically,
−→s
when t = ∧ (t1,..., tk), where t ∈ TΣ, t1≤i≤k ∈ TΣ, k ∈ N and s ∈ S. The
function J·)SPN : TΣ → Y interprets the attack tree t (irrespective of the type of player) as a SPN composed of k involved SPNs y1≤i≤k ∈ Y sequentially linked together one after the other. This is realized by merging together the final place
of the k − 1th SPN with the initial place of the kth SPN. The initial marking is (1,..., 0) and denotes that agent s can execute one of the refinements t1≤i≤k ∈ TΣ from place P0. Successful execution of the all refinements (involved SPNs), in
a sequential right-to-left order, provides the final marking (0,... 1) in the SPN.
−→s	s	s
Formally, J ∧ (t1,..., tk))SPN = Ψ3(y1,..., yk)= (P, T, K, Λ, M0) such that:



⎧⎪	⎧
ys	ys	⎫

P = {(p 1 ,...,p k )}
⎪

⎪	 ⎪⎨
0	0
k−1	⎪⎬

P =	Pt =
Pyi × Pyi+1	Pyi × Pyi+1	Pyi × Pyi+1

∗	0	t	0	∗	t
i=1
⎪	⎪	s	s	⎪
⎪⎨	⎩  ∗	y1	yk	⎭

0	k	0	k
⎪	 

K = {(p, t) |= ΓP }
⎪
{(t, p) |= ΓP },p ∈ P, and t ∈ T

ys	ys
ys′
ys′

0	k	0	k
⎪

Example 4.5 Let us consider an ADTree t = ∧ (b1, b2), where b1, b2 ∈ B are two
basic actions, and let ys, ys ∈ Y be their corresponding SPNs with rates λ1, λ2 ∈ R+
1	2
respectively. Then applying the function Ψ3(ys, ys) will produce the SPN depicted
1	2
in Figure 2-d. The SPN is composed of 3 places, one initial p0, one final p∗, and
one transient places p1.
Semantics for parallel disjunction reﬁnement
We define the semantics of parallel disjunction refinement of ADTrees. Basically,
s
when t = ∨˜ (t1,..., tk), where t ∈ TΣ, t1≤i≤k ∈ TΣ, k ∈ N and s ∈ S. The
function J·)SPN : TΣ → Y interprets the attack tree t (irrespective of the type of player) as a SPN composed by the Cartesian product of all SPNs y1,..., yk ∈ Y representing each attack tree t1≤i≤k ∈ TΣ of the refinement. The involved SPNs are joined together in such a way that all of them will be executed in an irrelevant
order. The initial marking is (1,..., 0) and denotes that agent s can execute one of the refinements t1≤i≤k ∈ TΣ from place P0. Successful execution of at least one refinements (involved SPNs) provides one final marking (0,..., M0(pi),..., 0), where M0(pi) = 1, and pi is a final place encompassing at least one final place of the
s	s	s
k involved SPN. Formally, J∨ (t1,..., tk))SPN = Ψ4(y1,..., yk) = (P, T, K, Λ, M0)
such that:

⎧⎪	⎧⎪
ys	ys	⎫⎪

P = {(p 1 ,...,p k )}
0	0
⎪	⎪	⎪
⎪ P =  ⎨ Pt = P − P0	P∗	⎬
⎪	⎪ P∗ =	P∗  × P
ys	s






ys	ys
ys′
ys′

0	k	0	k
⎪

s	s	s	s
Example 4.6 Let us consider an ADTree t = ∨˜ (b1, b2), where b1, b2 ∈ B are two
respectively. Then applying the function Ψ3(ys, ys) will produce the SPN depicted
1	2
in Figure 2-e. The SPN is composed of 3 places, one initial p0, one final p∗, and one
transient places p1.

Semantics for blocking-type countermeasure
We define the semantics of the blocking-type countermeasure. Basically, when t = cs (ts, ts), where ts, ts ∈ TΣ, and s ∈ S. The function J·)SPN : TΣ → Y interprets the attack tree t (irrespective of the type of player) as a SPN composed by the Cartesian product of the two involved SPNs ys, ys ∈ Y representing respectively attack tree ts and ts. The involved SPNs are joined together in such a way that both actions (attack/defense) evolve in parallel. The countermeasure influences on the succession of the countered-action as follows: If the countered-action is executed, then a set of assets are gained e.g. password for Gmail-account, then if the countermeasure is executed before the previously gained assets are used (there is a chance to use the assets), those assets are blocked from being used (e.g. got disconnected from the Intranet after applying an IP-filter rule as countermeasure). However, if the countermeasure is executed before the countered-action, then the execution of the later is assumed to be successful with blocked assets i.e. there is no chance to use the assets as there was in the previous scenario (e.g. got the Gmail-password, but the attacker should be connected to the Intranet). Note that when both SPNs for the proponent and opponent reach their final places, they actually reach some special and common final places (dead places) that we denote by Pd , such that
P = Pys × Pys and P ⊂ P . These places represent sink places to the countered-
d	∗	∗	d	t
player. Formally, Jcs (ts, ts))SPN = Φ0(ys, ys)= (P, T, K, Λ, M0) such that:
⎧⎪	⎧⎪ P = Pys × Pys	⎫⎪
⎪	  ⎪⎨ 0	0	0	⎪⎬
⎪ P =	⎪ Pt = P − P0  P∗	⎪
⎪	⎪⎩ P = Pys × Pys  Pys × Pys ⎪⎭




ys	ys	ys	ys
⎪
Λ= {λ0 ,..., λk , λ0 ,..., λk }
M0 = (M0(p0),..., M0(p∗)) = (1,..., 0)

Example 4.7 Let us consider an ADTree t = cs (bs, bs), where bs ∈ B and bs ∈ B are two basic actions for two opposite players, and let ys, ys ∈ Y be their corre- sponding SPNs with rates λs, λs ∈ R+ respectively. Then applying the function Φ0(ys, ys) will produce the SPN depicted in Figure 2-f. The SPN is composed of 4 places, one initial p0, one final p∗, and two transient places p1 and p2, where p2 is a dead place (black state).

Semantics for delaying-type countermeasure
We define the semantics of the delaying-type countermeasure. Basically, when t = cs (ts, ts), where ts, ts ∈ TΣ, and s ∈ S. The function J·)SPN : TΣ → Y in- terprets the attack tree t (irrespective of the type of player) as a SPN composed of two opposite SPNs, ys ∈ Y and ys ∈ Y , in such a way that the countermeasure cancels the achievement of the countered-action if the late was executed i.e. if the attack is executed, the system reach a final place, then if the countermeasure is executed, the system is brought back to the initial place (canceling the achievement of the attacker). Contrary to the previous countermeasure (i.e. blocking-type), the delaying-type countermeasure allows the countered-player to re-start his ac- tion again, which is not possible in the blocking-type countermeasure. Formally, Jcs (ts, ts))SPN = Φ1(ys, ys)= (P, T, K, Λ, M0) such that:
⎧⎪	⎧⎪ P = Pys × Pys	⎫⎪
⎪	  ⎪⎨ 0	0	∗	⎪⎬

P =	P
= Pys × Pys

Pys

⎪	⎪⎪⎩ P



= Pys × Pys

	
⎪⎪⎭






ys	ys	ys	ys
⎪
Λ= {λ0 ,..., λk , λ0 ,..., λk }
⎪ M0 = (M0(p0),..., M0(p∗)) = (1,..., 0)

Example 4.8 Let us consider an ADTree t = cs (bs, bs), where bs ∈ B and bs ∈ B are two basic actions for two opposite players, and let ys, ys ∈ Y be their corre- sponding SPNs with rates λs, λs ∈ R+ respectively. Then applying the function Φ0(ys, ys) will produce the SPN depicted in Figure 2-g. For a givne player s ∈ S, the SPN is composed of 2 places, one initial p0, and one final p∗.

Security Assessment of the ADTree Example
We report the analysis conducted to evaluate the qualitative as well as the quantita- tive security aspect of the scenario discussed in Section 2. We considered two misuse cases, the ADTree in Figure 1, and the ATree (Figure 1 modulo defense nodes). We have particularly generated the whole stochastic Petri-nets for the previous two trees using a java-code that we have developed for this purpose, and performed security assessment. In the following we start by performing the qualitative analysis, we present the general approach, then show how to apply it in the security context in general, and on ADTrees in particular. The second part will consist in quantitative analysis of both cases to show numerically the impact of countermeasures.








λti

(a)








λti

λtj







λti



(c)
(d)

Fig. 2. Stochastic Petri-nets for a basic actions, countermeasures, and refinement, blue places are final places, black place is a dead place, and the places with a token are initial places.



0.6
0.5



0.4
0.4
0.3

0.2
0.2
0.1


0
0	50	100  150  200  250  300
Time (Minutes)
0
0	50	100  150  200  250  300
Time (Minutes)

Fig. 3. Probability of breaching the network over time for each attack-path

·10−2
0.15

4
0.1

5 · 10−2	2


0
0	10	20	30	40
Time (Minutes)
0
0	10	20	30	40
Time (Minutes)

Fig. 4. Probability of breaching the network over half an hour for each attack-path




Fig. 5. RMG of the stochastic Petri-net model represneting the ADTree modulo defenses of Figure 1.


Fig. 6. Attack-paths elicited from structural analysis of ADTree modulo defenses of Figure 1.
Qualitative Security Assessment
Performing qualitative analysis on Petri-net models basically consists in two main phases, the first phase, called structural analysis, consists in generating either the covering-tree or the RMG (Reachable Markings Graph) of the used Petri-net model to extract the different transition sequences (e.g. cut sets), in our case attack-paths. The second part, called behavioral analysis, consists in checking a set of behavioral properties on the RMG.
Structural analysis: This phase consists in generating the RMG of the Petri-net model [19]. Using dedicated algorithms, we can extract the different attack-paths

that the attacker might undertake. We have generated the RMG from the con- structed stochastic Petri-nets (see Figure 5). The RMG for the ADTree contains 36 markings with a big number of transitions from the attacker and the defender. However, the RMG for the ATree is more clear and simple to illustrate. It con- tains 20 markings and only attackers’ transitions. Note that, either we take the RMG of the ADTree or the RMG of the ATree, the attack-paths are the same. The structural analysis revealed more than 49 possible attack-paths (see Figure 6). Because of space restriction and clarity in presenting the results, we report only 20 attack-paths (see paths-column of the table in Figure 7) just to show the ap- plicability of the analysis. In general, attack-paths differ mainly in the order in which the basic actions were performed. The SAP (Shortest Attack-Paths) are
{{bp; bp}, {bp; bp}, {bp; bp}, {bp; bp}}. They represent the minimum number of basic
4  3	3  4	0  2	1  2
actions to be performed by an attacker to reach his final goal.
Behavioral analysis: We define each behavioral property, provide an interpreta- tion in the context of ADTrees, then check the satisfaction over the RMG.
Boundedness. Let A denote the set of reachable markings, then a Petri-net is said to be bound when there exists an upper bound for the number of tokens available in every marking i.e. ∀M ∈ A, ∀p ∈ P: ∃k ∈ N | M (p) ≤ k. In security context, this property might be interpreted as follows: The presence of a token in a given place, represents the ability of the attacker and/or the defender to perform a particular action in a specific marking. It might also represent the number of attackers or defenders that are ready to attack and/or defend the system. Since there is only one token shared between the defender and the attacker as the ability to perform an action at a specific marking, our system is 1-bounded. We can also say that only one attacker with a specific profile (skills, knowledge) is enough to perform a security breach on our system i.e. a mono-hacking system.
Quasi-Liveness. A system is said to be quasi-alive if for every given reachable marking, there exists at least one transition that can be fired from that marking. We formally express this property as: ∀M ∈ A : ∃t ∈ T | M [> t. Therefore, in the context of ADTrees, a player is quasi-alive if for a given reachable marking M ∈ A, there exists at least one transition ts ∈ T from the player type that can be fired from that marking. For example, the proponent is quasi-alive if and only if: ∀M ∈ A : ∃tp ∈ T | M [> tp. From the RMG mapping the ADTree execution, the attacker is considered to be quasi-alive since for every given marking, the attacker has always the ability and opportunity to perform an action. However, the defender is not quasi-alive since there exist some markings where the defender has nothing to perform i.e. ∃M ∈ A, ∄to ∈ T | M [> to. Thus, the attack surface of the attacker is larger than the defender attack surface.
Pseudo-Liveness. A system is said to be pseudo-alive if for every given tran- sition, there exists at least one reachable marking where the transitions can be fired. Formally we write: ∀t ∈ T: ∃M ∈ A | M [> t. Therefore, in the context of ADTrees, a player is pseudo-alive if there is always a reachable marking where he can execute one of his actions. For example, if the budget of the attacker is


Fig. 7. Attack-paths, and expected number of steps for each group Gr.


less than 50$, then the attacker cannot perform an action which requires more than 100$. In the RMG, the attacker is considered to be pseudo-alive since for every possible attack action, the attacker/defender has the necessary resources to perform attacks/defenses specified by the ADTree.
Deadlock-freeness. If a system contains a sink marking from where no transi- tion can be fired, the system is not free of deadlocks: ∃M ∈ A : ∀t ∈ T | M [t />. In the context of security, if a marking is a dead-marking for the attacker and it is not referring to attacker goal, then the attacker can be stopped. Meanwhile, if it is a dead-marking for the defender, then the system will remain in a breached state after the attack. In our case, there is no dead-marking for the attacker, which means that the attacker will always have the opportunity to perform an attack. However, there are so many dead-marking for the defender since he is not quasi-alive. This means that if the system is found in a marking where the attacker is taking advantages, the system is considered to be paralizable.
Host-marking. A reachable marking is qualified by a host-making if there exists a sequence of transition such that, once executed from any given marking, takes the system to that host-marking. Namely, if the initial marking is the host marking, the system is said to be recoverable. Formally, if Ma ∈ A is a host- marking then: ∀M ∈ A : ∃σ ∈ T∗ | M [> σ Ma. In ADTrees, if the initial marking is a host-marking, then the system can always recover after a breach. Because of the defender who is not quasi-alive, there is no sequence of defender action that takes the system from a breached state to the initial non-breached state. Thus, the system is not recoverable.

Quantitative Security Assessment
Thanks to the isomorphic relation between bounded SPNs and finite CTMC, the quantitative analysis of stochastic Petri-nets consists in transforming the Petri-net model into its corresponding finite CTMC. This is done by merely transforming places into states, or by transforming each marking into a state of the CTMC. The markings where the attacker has achieved his goal will be represented by final states. Then, we apply the same quantitative approach described in [18]. We first estimate a mean time t for each basic action in the ADTree. This mean time will represent the inverse of the exponential rate. We have arbitrary chosen minutes as our time unit. Following the notation of basic action given in section 2, we arbitrary affect the following rates: λ(bp) = 1/60, λ(bp) = 1/30, λ(bp) = 1/20,
0	1	2
p	p	o	o
λ(b3)= 1/120, λ(b4)= 1/60, λ(b5)= 1/5, and λ(b6)= 1/5.
Probabilistic analysis: The CTMC mapping the ATree of Figure 1 mod- ulo defense nodes can be seen as the previously generated RMG of the ATree, where the markings are changed to states (e.g. M0 to s0). We have identified 11 final states, where the attacker has achieved his goal. Each final state can be reached through a group of attack-paths (see the table in Figure 7, column 1, and 5). Remember that we have considered only 20 attack-paths among 49. We have plotted the variation of the success probability of each group of attack-paths over time for ATtree in Figure 3-left. In the plot of Figure 3-left, except group 7 and 11, all other groups of attack-paths have a decreasing probability which converges to null. That is because the final states represented by both 7, and 11, are absorbing final states, which means that after a certain time spent (e.g. 10h), the system will reach a steady state, and the whole amount of probability will be shared between these two groups. However, we can zoom in inside the graph and try to analyse what was happening within the first 30 minutes (Figure 4-left). We can see that group 4 is the fastest growing probability function, this will correspond to the most probable group of attack-paths, in this case {bp; bp} with a likelihood of 0.145. At
p1 p2
this stage, we can qualify the attack-path {b1; b2} as the MPAP (Most Probable
Attack-Path). In the second case, the CTMC was bigger, it consisted of 36 states, among them 15 final states. This is because the execution of a countermeasure after the attacker has finished achieving his attack (already realized his goal), will take the system to another final state (i.e. the defense has no impact). The additional final states (i.e. 4 new final states) are merged to the final state that proceed them since countermeasures actions are not part of the attack paths. We can see from the plot of Figure 3-right, that groups of attack-paths 2, 5, and 7 are increasing in likelihood over time. This is because these groups corresponds to absorbing states (except for 11, which is this time decreasing). In order to understand the impact of the countermeasures that we have set, we zoom in the plot, and scrutinize what happened in the first 30 minutes (Figure 4-right). We remark that in the first 25 minutes, the attacker was most likely interested in undertaking the group of attack-paths 4, but at t = 26, it was equi-probable for the attacker to choose between group 1, and 4. Then, because the countermeasures are having a great

impact upon attack-paths of group 4, the attacker is most likely interested in undertaking attack-paths of group 1, which corresponds to the right-side of the ADTree. In long term, and as the attacker might exert his actions in parallel, he might be able to achieve (i.e. if no countermeasure executed) some parts of the left-side of the tree as can be confirmed by the graph of group 2, and 5. We can conclude that the countermeasures represented in the ADTree have a considerable impact on the security of the system, as it decreased the likelihood of breaching the system. Finally, and after identifying the most probable group of attack-paths, we can perform a ranking of attack-paths in a given group to identify the MPAP. This is done by computing the expected number of steps for each attack-path [18]. The results are illustrated in the table of Figure 7. If we consider the ADTree, and the group 2 as the MPG (Most Probable Group), the MPAP={bp; bp; bp}.
1  4  3
Time-based analysis: In this analysis, we mainly compute the mean time to breach a system. The approach is well explained in [18]. The computed MTTSF (Mean Time To Security Failure) revealed that that attacking the first configuration (ATree) takes in average half an hour (36’). However, the second configuration (ADTree) requires almost two hours (119’) to be breached.


Related work
In 2010, the well-known attack-trees model [4] was extended to attack-defense trees [3], allowing security engineers to represent defense actions besides attacks ac- tions in one tree-based layout. The later model allows a list of possible denotational semantics to be used [3]. However, non of these semantics allow the expression of actions ordering, which is practically the most used aspect in cyber-attacks. In [18], the authors proposed a CTMC-based semantics for attack-defense trees, which al- lows the expression of action ordering, and perform quantitative security analysis. However, besides security quantitative analysis, and to our knowledge, there is a considerable paucity of qualitative underpinnings supporting attack-defense trees analysis. From an overall picture, there have been a great number of security graphical models proposed in the literature years before attack-defense tree, such as attack-graphs [10]. Proposing security assessment techniques was the second face of this research immersion period, approaches based on Markov chains [5, 9], or Petri-nets [12, 13] were applied. However, none of the previously mentioned works [5, 9, 12, 13] have provided a classification for countermeasures or at least considered countermeasures in a more realistic way. This limitation was deeply discussed in [18], and the authors have given a first attempt to overcome this limi- tation by proposing two classes of countermeasures, immediate-impact, and delayed- impact. However, there still a large variety of countermeasures which have a differ- ent model, and belong to other classifications. Finally, and to our knowledge there is no type of refinement in the attack-defense tree specification expressing parallel actions [3, 4, 9, 18].

Conclusion
In this work, we have presented a stochastic operational semantics for ADTrees based on stochastic Petri-nets. This allowed us to perform both qualitative and quantitative security analysis. We have shown through a simple example that the proposed solution is useful in the sens it can help system designers to start security by design, or strengthening already existing infrastructure. This is a first attempt, that of course needs further improvements. In particular we plan to extend the framework to consider new types of countermeasures, qualitative properties to out- put a complete security assessment tool [17].

References
Marc, Dacier., A Petri Net Representation of the Take-Grant Model, ”Computer Security Foundations Workshop VI”, 1993.
Yixin, Jiang,. Chuang L., Hao, Y., and Zhangxi, T., Security analysis of mandatory access control model, ”International Conference on Systems, Man & Cybernetics”, 2004.
Kordy, Barbara., Mauw, S., Radomirovi´c, S., and Schweitzer, P., Foundations of attack–defense trees, ”International Workshop on Formal Aspects in Security and Trust”, 2010.
Mauw, Sjouke., and Oostdijk, M., Foundations of attack trees, ”International Conference on Information Security and Cryptology” , 2005.
Madan, Bharat., Gogeva-Popstojanova, K., Vaidyanathan, K., and Trivedi, K., Modeling and quantification of security attributes of software systems, ”International Conference onDependable Systems and Networks”, 2002.
Jonathan Billington., Geoffrey R. W., and Michael C. W., PROTEAN: A High-Level Petri Net Tool for the Specification and Verification of Communication Protocols, ”IEEE Transactions on Software Engineering”, 1988.
Abraham, Subil., and Nair, Suku., Predictive Cyber-security Analytics Framework: A non-homogenous Markov model for Security Quantification, Computing Research Repository, abs/1501.01901 (2015).
Wil van der Aalst., The Application of Petri Nets to Workflow Management, Journal of Circuits, Systems, and Computers, 8 (1998).
Arnold, Florian., Guck, D., Kumar, R., and Stoelinga, Mari¨ele., Sequential and parallel attack tree modelling, ”International Conference on Computer Safety, Reliability, and Security”, 2015.
Hughes, Todd., and Sheyner, O., Attack scenario graphs for computer network threat analysis and prediction, Wiley Online Library: Journal of Complexity, 9 (2003).
Balbo, Gianfranco., Introduction to Generalized Stochastic Petri Nets, ”Formal Methods for Performance Evaluation: 7th International School on Formal Methods for the Design of Computer, Communication, and Software Systems”, 2007.
Pudar, S., and Manimaran, G., and Liu, C., PENET: A practical method and tool for integrated modeling of security attacks and countermeasures, In Computers & Security Journal, 28 (2009).
Dalton, GC., Mills, Robert, F., Colombi, John, M., and Raines, Richard, A., and others, Analyzing attack trees using generalized stochastic Petri nets, ”Information Assurance Workshop”, 2006.
Jensen, Kurt., Coloured Petri nets: basic concepts, analysis methods and practical use, ”Springer Science & Business Media”, 1995.
Ramchandani, C., Analysis of asynchronous concurrent systems by timed Petri nets, ”Massachusetts Institute of Technology”, 1974.
Molloy, Michael, K., Performance analysis using stochastic Petri nets, ”IEEE Transactions on computers”, 1982.
Gadyatskaya, Olga., Jhawar, R., Kordy, P., Lounis, K., and Mauw, S., and Trujillo-Rasua, R., Attack trees for practical security assessment: ranking of attack scenarios with ADTool 2.0, ”Proceedings of the 13th International Conference on Quantitative Evaluation of Systems”, 2016.


Lounis Karim., Jhawar, R., and Mauw, S., A Stochastic Framework for Quantitative Analysis of Attack- Defense Trees, ”Proceedings of the 12th International Workshop on Security and Trust Management”, 2016.
Chiola, Giovanni., Carvajal-Schiaffino, R., A reachability graph construction algorithm based on canonical transition firing count vectors, ”Proceedings of the 9th international Workshop on Petri Nets and Performance Models”, 2001.
Peterson, James, L., Petri net theory and the modeling of systems, ”Prentice Hall PTR”, 1981.
