Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 261–280
www.elsevier.com/locate/entcs

The Construction of Set-Truncated Higher Inductive Types
Niels van der Weide 1,2 Herman Geuvers3
Institute for Computation and Information Sciences Radboud Universiteit
Nijmegen, The Netherlands

Abstract
We construct finitary set-truncated higher inductive types (HITs) from quotients and the propositional truncation. For that, we first define signatures as a modification of the schema by Basold et al., and we show they give rise to univalent categories of algebras in both sets and setoids. To interpret HITs, we use the well-known method of initial algebra semantics. The desired algebra is obtained by lifting the quotient adjunction to the level of algebras and adapting Dybjer’s and Moeneclaey’s interpretation of HITs in setoids. From this construction, we conclude that the equality types of HITs are freely generated and that HITs are unique. The results are formalized in the UniMath library.
Keywords: higher inductive types, homotopy type theory, category theory, setoids, intuitionistic type theory, Coq

Introduction
Homotopy type theory (HoTT) is a form of intensional type theory. It has semantics in the simplicial sets model [28], and types represent spaces, terms represent points, and equalities represent paths, and so on. Furthermore, equality is proof relevant and we frequently talk about homotopies: paths between paths.
One of the main features of HoTT is higher inductive types (HITs) [41]. These are types generated by constructors for their points, paths, homotopies, and so on. HITs have been used in numerous applications among which are homotopical patch theory [10], synthetic homotopy theory [31,32,41], defining type theory within type theory [6,7], constructive finiteness [22], and the partiality monad [5]. To get a feeling for what HITs are, let us look at some examples.

1 The authors would like to thank Dan Frumin and Andrej Bauer for inspiring discussions. The authors also thank the reviewers for their helpful comments to improve the readability of this paper. Work on this article was supported by a grant from the COST Action EUTypes CA15123.
2 Email: nweide@cs.ru.nl
3 Email: herman@cs.ru.nl

https://doi.org/10.1016/j.entcs.2019.09.014
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).


Inductive S1 :=
| base : S1

Inductive A :=
| |·| : A → A

Inductive Z2 :=
| Z : Z2
| S : Z2 →Q Z2

| Ztrunc : isaset(Z2)
The first one, S1, is the circle. It has a point base and a path loop : base = base. Since neither the point nor path constructors uses arguments from S1, this HIT is non-recursive. The second, A  , is the propositional truncation of A. This type is A with all its points identified. Note that the path constructor p uses arguments from  A  , which means this HIT is recursive. The last one, Z2, is the integers modulo 2 and note that both the point constructor S and path constructor mod are recursive. A HIT is called ﬁnitary if its point constructor is described by a finitary polynomial and it is called set-truncated if it is a set.
In this paper, we show that all finitary set-truncated HITs can be constructed with quotients and propositional truncations. This briefly means that all higher inductive types exist if a small number of simple ones exist. The main idea of the proof is to take advantage that the quotient is left adjoint functor from setoids to sets [38]. To relate this to HITs, we first define schemes, which are an internalized version of the schema by Basold et al. [12], and categories of algebras on them. Then we lift the quotient adjunction to an adjunction from algebras in setoids to algebras in sets. Since initiality implies induction, it suffices to construct the initial setoid algebra for which we adapt the construction by Dybjer and Moeneclaey [20,36]. Note that from our construction we can conclude that all finitary set-truncated HITs can be constructed from non-recursive ones. Since quotients can be constructed from coequalizers and set truncations, we only need coequalizers and propositional/set truncations for this construction [37].

Background and Related Work
The HITs we study in this paper, are set-truncated and recursion is allowed for both the point and path constructors. It is a variation of the scheme by Basold et al. [12], which does not allow constructors for higher paths. Other schemata of higher inductive types have already been defined. W-suspensions, developed by Sojakova [39], allow defining HITs without recursive constructors, but these are not necessarily truncated. The scheme by Dybjer and Moenclaey is similar to the one by Basold et al., as it allows recursion for both the points and paths, but in addition, it supports constructors for homotopies. Since types are ω-groupoids [42,33], a type-theoretical version of these also provide a semantic specification of HITs [24]. At the moment, the definition which encompasses all these options, are higher inductive-inductive types (HIITs) [26] where induction-induction and paths in arbitrary dimensions are permitted. These are a generalization of quotient inductive-inductive types (QIITs) developed by Altenkirch et al. [4]. Furthermore, Cavallo and Harper extend computational cubical type theory with a scheme for indexed cubical inductive types [9,15].
In addition to the schemata, some meta theory also has been developed. Here we internally provide initial algebra semantics for our scheme meaning that we show

initial implies induction. Awodey et al. showed a stronger result for inductive types in intensional type theory [11,19], namely that initiality is equivalent to induction, and Sojakova proved this for W-suspensions [39]. For QIITs, initial algebra seman- tics has also been given [4]. Beside initial algebra semantics, Cavallo and Harper shows that computational cubical type theory, with cubical inductive types, satisfies canonicity [9,15].
The main result of this paper is about constructing a class of higher inductive types from simple ones. Both Kraus and Van Doorn show that the propositional truncation can be constructed from non-recursive HITs [29,43] and Rijke shows that every truncation can be constructed via non-recursive HITs [37]. Note that these all are about truncations instead of a more general scheme. However, contrary to our result, they do not rely on the restriction to set-truncated types. Kaposi et al.
[27] show that can finitary QIITs can be constructed from one specific QIIT, but their construction relies on UIP. From our construction, we deduce that the path space of each HIT is freely generated. Kraus and Von Raumer obtained a similar property for the coequalizer by providing a nicer induction principle for its path types [30].
Reducing the existence of HITs to the existence of a small number of them, gives an approach to defining the semantics of HITs. Other approaches to this problem have also been considered. Coquand et al. interpret various higher inductive types, such as spheres, the torus, the truncation, and the pushout, in cubical type theory [13,17,18]. All of these examples are not set-truncated and thus not covered by our scheme. On the other hand, Lumsdaine and Shulman also study the semantics of higher inductive types using a semantic scheme (cell monads with parameters) and they prove existence in sufficiently nice Quillen model categories [34]. Dybjer and Moeneclaey give an interpretation of their scheme in the groupoid model [20,25].


Overview
We start in Section 2 by recalling some definitions from HoTT and category theory required for the remainder of the paper. In Section 3, we define signatures for higher inductive types and give a couple of examples. Next we define algebras in both the categories of sets and setoids for such signatures in Section 4. We define the induction principle of HITs via displayed algebras in Section 5 and we show that initial objects satisfy this principle. Section 6 contains the main result of this paper and there we construct an adjunction between algebras in sets and setoids, and we use it to construct the initial algebra in sets via the initial algebra in setoids. We study the consequences of this construction in Section 7 and in Section 8, we conclude and discuss further work.
All material in this paper are formalized over the UniMath library [44]. The proof of the main theorem is 4060 lines of code and the additional examples are 3278 lines of code. The formalization can be found on https://github.com/nmvdw/ SetHITs.

Preliminaries
We start by recalling some definitions and notations from homotopy type theory and the basics of category theory in HoTT [2,35,41]. The first notion we need, is the dependent equality type.
Definition 2.1 Given a type X, inhabitants x, y : X, a type family Y on X, and a path p : x = y, we define by path induction a function transportY p : Y x → Y y, which is the identity function for the reflexivity path. If we have a path p : x = y and inhabitants z1 : Y x and z2 : Y y, we write z1 =p z2 for transportY p z1 = z2.
One of the core features of HoTT, is that equality is proof relevant. This means that not all inhabitants of x = y are necessarily equal. Some types might actually have proof irrelevant equality, and we call such types sets. More precisely, we define
Definition 2.2 A type X is a (mere) proposition if for all x, y : X we have x = y. A type X is a set if for all x, y : X the type x = y is a proposition. We write isaprop(X) and isaset(X) to say that X is a proposition and set respectively.
Our goal is to construct all higher inductive types from two specific ones, namely the quotient type and the propositional truncation. We only give their introduction rules here, and for their elimination and computation rules, we refer the reader to the literature [41].
Definition 2.3 Let X be a type and let R be an equivalence relation on X. The
quotient type X/R is the higher inductive type generated by

	x : X	
class x : X/R
x, y : X	r : Rx y
classeq r : class x = class y
isaset(X/R)

Definition 2.4 Let X be a type. The propositional truncation  X  is the higher inductive type generated by

  x : X	
|x| : X
isaprop( X )

Next we briefly discuss category theory in univalent foundations [2,41]. We start by recalling the definition of categories. This is almost the same as the usual definition in mathematics, but there is a slight discrepancy between the objects and arrows. While the objects can be any type, the arrows have to form a set. Proof relevant equality on arrows would induce the structure of a higher category instead of an ordinary one.
Definition 2.5 A category C consists of a type C0 of objects and a set X → Y of morphisms for each X, Y : C0 together with identity morphisms idX : X → X for each X : C0 and a compositions g ◦ f : X → Z for all mophisms f : X → Y and g : Y → Z such that the usual associativity and identity laws holds.
We define isomorphisms in categories the usual way and we denote the type of isomorphisms from X to Y by X ∼= Y . In the remainder, we also make use of univalent categories. These are categories in which equality on objects is equivalent

to isomorphisms between them. For the definition of equivalence of equivalences, we refer the reader to the literature [41]. More precisely, we define
Definition 2.6 Let C be a category. Note that for all objects X and Y we have a map idtoisoX,Y : X = Y → X ∼= Y sending the reflexivity path to the identity isomorphism. Then we say C is univalent if idtoisoX,Y is an equivalence for each X and Y .
The primary example of a univalent category is hSet, whose objects are sets and morphisms are functions. Another example of a univalent category which we use frequently, is the category of setoids.
Definition 2.7 A setoid is a set X together with an equivalence relation on X. A setoid morphism between two setoids is a map between the underlying sets which preserves the equivalence relation. The category Setoid of setoids is the category with setoids and setoid morphisms as objects and morphisms.
Recall that, If R is an equivalence relation on X, each Rx y has to be a propo- sition. Note that in the usual category of setoids, one would take a quotient of the setoid morphisms. However, we refrain to do so, because in our construction, we do not need any additional equality. If X is a set and R is an equivalence relation on X, then we write (X, R) for the setoid with this data. If no confusion arises, we write x ≡ y for Rx y.
We finish this section by giving some operations of functors and natural trans- formations, which we need in Definition 4.2. Functors and natural transformations are defined the usual way [35], and we write C −→ D and F =⇒ G for the type of functors from C to D and transformations from F to G respectively.
Notation 2.8 We have the following functors.
For each category C, we have the identity idC : C −→ C.
For F : C1 −→ C2 and G : C2 −→ C3, we have a composition G ◦ F : C1 −→ C3;
If D has binary products, then for F, G : C −→ D, we have a product F × G :
C −→ D;
If D has binary sums, then for F, G : C −→ D, we have a sum F + G : C −→ D;
For each object X : D, we have a constant functor CX : C −→ D.
Notation 2.9 We have the following natural transformations.
Given F, G : C −→ D, we have
inl : F =⇒ F +G	inr : G =⇒ F +G	pr1 : F×G =⇒ F	pr2 : F×G =⇒ G

Given two transformations η1 : G1 ◦ F =⇒ G2 ◦ F and η2 : G1 ◦ F =⇒ G3 ◦ F, we have a pairing
(η1, η2): G1 ◦ F =⇒ G2 × G3 ◦ F.
Given functors F : C1 −→ C2 and G1.G2 : C2 −→ C3, and a transformation

η : G1 =⇒ G2, we have
η D F : G1 ◦ F =⇒ G2 ◦ F
Given a functor F : C −→ hSet,a set X : hSet, and x : X, we have a transfor- mation cx : F =⇒ CX
The type of (η1, η2) might seem unnatural. However, it is precisely this type we need for the constructions in Definition 4.2..
Signature of HITs
Before we study the construction of set truncated HITs, we first give a precise definition of those. We describe HITs by saying how to construct points and paths. For example, the integers modulo 2, which we considered in the introduction, has two constructors for points, namely Z ad S, and one for the paths, namely mod. The signature of this type would thus indicate that we have one nullary and one unary operation, and a path of the required type. In this section, we define a type of signatures as internalized variation of the one by Basold et al. [12], and then in the upcoming sections, we define HITs for a signature.
The first ingredient of the signature, is the arity of the point constructor. This is described by a ﬁnitary polynomial functor, and we define those as the following type.
Definition 3.1 We define the type P of codes of ﬁnitary polynomials as the induc- tive type generated by the following constructors.

 X : hSet 
C X : P
I : P	P : P	Q : P
P + Q : P
P : P	Q : P


P × Q : P

In the next section, we show that each code P : P gives rise to a functor

JP ) :
hSet −→
hSet. Each higher inductive type H has a point constructor

c : JP ) H → H, which represents the introduction rule for points.
HITs also have an introduction rule for paths, and for those, we need to give the possible endpoints of paths. Each path is given by a universally quantified equation, which can possibly make use of the point constructor. For this reason, the type of endpoint must depend on the data of the point constructor. We also indicate the source and target of the equation, and both of them depend polynomially on the HIT being defined. The type of endpoints is defined inductively.
Definition 3.2 Given polynomials, A, P, Q : P, the type EA(P, Q) of endpoints is inductively generated by the following constructors.

	P : P	
idA : EA(P, P )
P, Q, R : P		e1 : EA(P, Q)	e2 : EA(Q, R) e1 · e2 : EA(P, R)

P, Q : P
inl : EA(P, P + Q)
P, Q : P
inr : EA(Q, P + Q)
P, Q : P
pr2 : EA(P × Q, Q)
P, Q : P
pr1 : EA(P × Q, P )

constr : E (A, I)	 P : P	X : hSet	x : X 
c x : EA(P, C X)
P, Q, R : P	e1 : EA(P, Q)	e2 : EA(P, R)
(e1, e2): EA(P, Q × R)
In the formalization, we also include for each f : X → Y an endpoint fmap f : EA(C X, C Y ), which we do not discuss here. The polynomial A represents the point constructor and that explains the endpoint constr. The polynomials P and Q represent the source and target of the equation respectively. If we have a set X with a map c : JA) X → X, each endpoint e : EA(P, Q) gives rise to a natural morphism from the functor JP ) to JQ) where constr is interpreted using c. These maps are the left- and right-hand side of the equations.
Now we put it all together to define signatures of HITs. Note that we index the path constructors by a type meaning that we could possibly have infinitely many path constructors.
Definition 3.3 A HIT signature S consists of
A polynomial Spt : P representing the point constructor;
A type Spth representing the names of path constructors;
A family Sarg : Spth →P representing the arguments of the paths;
Maps Slhs, Srhs :	(j : Spth), ESpt (Sarg j, I) representing the left- and right-hand side of the equations.
Briefly, the signature S represents the following HIT
Inductive H :=
| c : JQSpt) H → HQ
| p :	(j : Spth),  (x : JSarg j) H), JSlhs j) H x = JSrhs j) H x 
| s : isaset(H)
Since our goal is to interpret set-truncated HITs, we require the constructor s. To illustrate the possibilities of this definition, we define two examples from the introduction as HIT signatures. The first one is the integers modulo 2 and the second one is the propositional truncation of a set.
Example 3.4 Recall Z2 from the introduction. We represent it by the signature
mod defined as follows
modpt := I + (C 1)	modpth := 1	modarg := I
modlhs j := inl · constr · inl · constr   modrhs j := idI
Intuitively, this signature represents a HIT H with operation H + 1 → H rep- resenting the successor and zero. Note that the endpoint inl · constr takes the successor, so, the equation says that S(S x)= x for all x : X. Since signatures can depend on types, we can also define the propositional truncation.
Example 3.5 Let A be a set. We represent its truncation by the following signa- ture.
truncpt := C A	truncpth := 1	truncarg := I × I

trunclhs j := pr1	truncrhs j := pr2
Other examples, such as the integers, free algebras, and the ring of polynomials, can be found in the formalization. This signature represents a HIT H with a map A → H and for which all inhabitants are equal, which is precisely the propositional truncation from Definition 2.4 for sets A.
Algebras
Algebras in Sets
To define HITs on a signature, we need to give the introduction, elimination, and compuation rules. Let us start with the introduction rule, which we define via algebras. Note that this rule comes in two flavors: one for the points and one forthe paths. For this reason, we define algebras in two steps.
We start by saying how to interpret the point constructors.
Definition 4.1 For each P : P, we define a functor JP ) : hSet −→ hSet as follows
JCX) := CX	JI) := idhSet	JP +Q) := JP )+JQ)	JP×Q) := JP )×JQ)

We write FAlg(F ) for the category of algebras on the functor F : C −→ C. Its objects are pairs X : C together with an arrow C1(F X, X). The morphisms from (X, f ) to (Y, g) consist of maps h : C1(X, Y ) such that h ◦ f = g ◦ F (h). Note that we always have a forgetful functor UF : FAlg(F ) −→ C.
Now we define the category PreAlghSet(S) to be FAlg(JSpt)). Since the ob- jects do not satisfy the equations in S, we call this the category of prealgebras. To obtain actual algebras of S, we need to interpret the equations. For that, we first give a semantics of endpoints as natural transformations, which are defined using the transformations from Lemma 2.9. Besides, we use for each polynomial P the transformation constrP : JP ) ◦ UP =⇒ JI) ◦ UP whose components are given by the prealgebra map.
Definition 4.2 For each endpoint e : EA(P, Q), we define a natural transformation
Je) : JP ) ◦ UA =⇒ JQ) ◦ UA
JidP ) := id  Je1·e2) := Je2)◦Je1)  Jinl) := inl D UA  Jinr) := inr D UA  Jct) := ct
Jpr1) := pr1 D UA  Jpr2) := pr2 D UA  J(e1, e2)) := (Je1), Je2))  Jconstr) := constrA
Note that Jconstr) is required to have type JP ) ◦ UP =⇒ JI) ◦ UP . Since the functors JI) ◦ UP and UP are only equal up to propositional equality, we defined constrA to be of that type instead of the expected JP ) ◦ UP =⇒ UP , Now we have everything in place to define algebras on S. An algebra on S consists of a prealgebra together with proofs that the equations in S are satisfied. Since the carrier of each prealgebra is a set, the equations form a proposition. Hence, we define the category of S-algebras as a full subcategory of PreAlghSet(Spt).

Definition 4.3 Let S be a HIT signature. Then we define the category AlghSet(S) of S-algebras as the full subcategory of PreAlghSet(Spt) such that each object X satisfies
  (j : Spth),   (x : JSarg j) X), JSlhs j) X x = JSrhs j) X x.
For an algebra X, we denote its operation by pointX : JSpt) X → X. The path witnessing the equalities of the algebra is denoted by pathX : (j : Spth), (x : JSarg j) X), JSlhs j) x = JSrhs j) x. Note that the category of S-algebras is univalent. This follows from the fact that the category of algebras on a functor is univalent and that univalence is preserved under taking full subcategories.
Proposition 4.4 The category of S-algebras in sets is univalent.
Before we look at algebras in setoids in more detail, we recall the examples in the previous section and look what algebras on those signatures are.
Example 4.5 Recall the signature mod from Example 3.4. A prealgebra of mod consists of a set X and a map f : X + 1 → X. We define SX x := f (inl x) and ZX = f (inr tt). An algebra of mod consists of a prealgebra X such that for all x : X, we have SX (SX x)= x.
Example 4.6 Recall trunc from Example 3.5. For a set A. an algebra of trunc A consists of a set X and a map f : A → X such that for all (x, y): X × X, we have x = y. In particular, this means X is a proposition.
Algebras in Setoids
Our goal is to construct HITs as a quotient of a certain setoids. To guarantee that the resulting quotient has the right introduction rule, we require extra structure from the setoid. This is given by an algebra structure on the setoid.
To interpret the action of P on setoids, we first define its action on equivalence relations, and we need some preliminary operations for that. Note that for each set T , we have an equivalence relation Path T on T such that Path T x y := x = y. Furthermore, given types X and Y with equivalence relations RX and RY on them, we can define equivalence relations RX + RY and RX × RY on X + Y and X × Y respectively. These are defined as follows
RX × RY (x1, y1) (x2, y2) := (RX x1 x2) × (RY y1 y2)
RX + RY (inl x1) (inl x2) := RX x1 x2	 RX + RY (inr y1) (inr y2) := RY y1 y2 RX + RY (inl x) (inr y) := 0	RX + RY (inr y) (inl x) := 0
Definition 4.7 Let R be an equivalence relation on a set X and let P : P be a polynomial. By induction, we define an equivalence relation P^ R on JP ) X.
(^C T )R := PathT	IR := R	(P^+ Q)R := (P R)+(QR)	(P^× Q)R := (P R)×(QR)
Now we define the functor ⟨P⟩ : Setoid −→ Setoid by ⟨P⟩(X, R)= (JP ) X, P^ R).

The functor ⟨P⟩ could also be defined by using that the category of setoids is Cartesian closed. However, we chose this definition, because it was more convenient in the formalization. This is because the underlying set of ⟨P⟩(X) can be computed definitionally.
With these definitions in place, we obtain a category PreAlgSetoid(S) of setoid prealgebras on S. To define algebras on S, we also need to interpret endpoints for which we use setoid morphisms instead of natural transformations.
Definition 4.8 Let e : EA(P, Q) be an endpoint and let X be a setoid prealgebra on A. Then we define ⟨e⟩ to be the setoid morphism from ⟨P⟩(X) to ⟨Q⟩(X) whose carrier is Je).
The requirement for ⟨e⟩ to be a setoid morphism, is that for x, y : ⟨P⟩ X with r : x ≡ y, we have Je) x ≡ Je) y. The category of algebras on S is defined differently for setoids than for sets. While for sets, the equations of algebras are witnessed by actual equalities, the equations for setoids are witnessed by the equivalence relation. Note that such relations are families of propositions meaning again this gives rise to a proposition and thus we define it as a full subcategory.
Definition 4.9 Let S be a HIT signature. Then we define the category of S- setoid-algebras as the full subcategory of PreAlgSetoid(Spt) such that each object satisfies
  (j : Spth),   (x : Sarg j), JSlhs j) x ≡ JSrhs j) x.

Since the category of setoids is univalent, the category of S-setoid-algebras is univalent as well.
Proposition 4.10 The category of S-setoid-algebras is univalent.

The Induction Principle
With the introduction rules covered by the algebra structure, we now take a look a the elimination and computation rules. For this, we use displayed algebras [26,39]. These represent the input of the elimination rule. For the output, we define displayed algebra maps, also known as sections. The elimination rule says that we have a displayed algebra map to every displayed algebra, while the computation rule says that the algebra in place. Once we have this machinery in place, we define higher inductive type on a signature.
Since our goal is to construct HITs, we need to find an algebra for which the elimination rule holds, and for that, we use initial algebra semantics [4,11,39]. More specifically, we show that the initial algebra satisfies the induction rule. Hence, to obtain a HIT, it suffices to construct the initial algebra, which is more convenient in the language of category theory.

Displayed Algebras
A displayed algebra is the input of the elimination rule. This means that we have a dependent family and a dependent map over the point constructor. Further- more, dependent versions of the equations in the signature need to hold. Displayed algebras are similar to displayed categories [3].
To formulate these requirements precisely, we need two preliminary definitions. The first one is the action of polynomials on families of sets while the second one interprets endpoints as dependent maps.
Definition 5.1 Given are P : P and Y : X → hSet. We define P Y : JP ) X →
hSet by induction
C X Y x := X	I Y x := Y x	P × QY x := P Y (pr1 x) × QY (pr2 x)
P + QY (inl x) := P Y x	P + QY (inr x) := QY x
Definition 5.2 Let A be a polynomial, X be a prealgebra on A, and let e : E (P, Q). Suppose, we have a family Y on X and a map c :  (z : JA)X), P Y z → Y (pointX z). We define a map ec :  (z : JP )X), P Y z → QY (Je) z) by induction on e

idP czy := y	e1 · e2czy := e2c(Je1)Xz)(e1czy)	inlczy := y	inrczy := y	c tczy := t

pr1czy := pr1y	pr2czy := pr2y	(e1, e2)czy := (e1czy, e2czy)	constrc := c
With this in place, we define displayed algebras. Note that since we are working in a family of sets, we need to use the dependent equality type from Definition 2.1 instead of the ordinary one.
Definition 5.3 Give are a signature S and an algebra X on S. Then a displayed algebra over X consists of
A type family Y : X → hSet;
An operation cY :	(z : JSpt)X), Spt Y z → Y (pointX z);

For each j : Spth, x : JSarg) X, and y : Sarg Y x, a path pY : Slhs cY xy =pathX j x 
Srhs cY x y.
Now we got the input for the elimination rule in place and the next step is to look at the output. This is a dependent map which preserves the algebra structure. To state this preservation property, we need yet another operation on polynomials.
Definition 5.4 Let P be a polynomial, let X be a set, and let Y be a family of sets on X. Given a map f :  (x : X),Y x, we define a map P f :  (x : JP ) X), P Y x by induction
C X f x := x	I f := f	P × Qf x := (P f (pr1 x), Qf (pr2 x))
P + Qf (inl x) := P f x	P + Qf (inr x) := Qf x

Definition 5.5 Let Y be a displayed algebra over X. Then a displayed algebra map to Y consists of a map f : (x : X),Y x such that for each x : JSpt)X, we have f (pointX x)= cY x (Spt f x).
With all this in place, we can define the notion of a higher inductive type on a signature. Note that a HIT needs to be an algebra so that we have the correct intro- duction rules and note that we use displayed algebras to formulate the elimination principle.
Definition 5.6 Let S be a HIT signature. A higher inductive type on S consists of an algebra H such that for each displayed algebra Y on H, we have a displayed algebra map to Y .
Note that HITs of S satisfy analogous rules to those defined by Basold et al. [12]. As usual, the induction rule only guarantees the existence of a dependent map. This obtained map is unique, which is again proven by induction. Furthermore, HITs on the signatures we discussed before, the integers modulo 2 in Example 3.4 and the propositional truncation in Example 3.5, satisfy the induction rule given in Basold et al. [12].
There are only two differences: the computation rule only holds propositionally rather than definitionally. In addition, we can only map HITs into sets. This is because it also has constructors, which guarantee it is a set. The algebra structure gives the right introduction rules and the existence of the displayed algebra map gives the required elimination and computation rules.
Obtaining Induction from Initiality
Next we show how to obtain the induction principle from initiality. This way it suffices construct an initial algebra of the signature to obtain a HIT, which is more convenient in category theory. To this end, we first define the total algebra  Y of
a displayed Y on X together a projection πY to X.
We define the ca∫rrier of ∫ Y by the dependent sum Σ(x : X),Y x and for brevity,
c, Y : JSpt) ( Y ) →	Y . The main idea is that we use the algebra map of X for the first component and the displayed algebra map of Y for the second one. We
introduce an intermediate definition, which allows us to access the right data.
Definition 5.7 Let P be a polynomial and let Y be a family of sets on X. We define a map
πP : JP ) (Σ(x : X),Y x) → JP ) X	πP x := JP ) pr1 x
We also define a map πP : Q(x : JP ) (Σ(x : X),Y x)), P Y (πP x) by induction on
2	1
P .
πC T x := x	πI x := pr2 x	πP ×Q x := (πP (pr1 x), πQ (pr2 x))
2	2	2	2	2
πP +Q (inl x) := πP x	πP +Q (inr x) := πQ x
2	2	2	2

Now let z : J£pt) (∫ Y ).  The first coordinate of point, Y z is defined to be
point (πSpt x). The second coordinate of point, z is defined by cY (πSpt x) (πSpt x).
X	1	Y	1	2
The main challenge lies within proving the equations. To do so, we compute the
valuation of endpoints in the total algebra via those in X and Y .
Lemma 5.8 For every endpoint e : SSpt (P, Q), we have
epr1 : Je) X (πP x)= πQ(Je) (∫ Y ) x)	epr2 : e cY (πP x) =epr πQ (Je) (∫ Y ) x)
All in all, given a displayed algebra Y on some algebra X, we get the total
algebra ∫ Y . We also define an algebra homomorphism πY : ∫ Y → X, which sends
z to its first projection pr1 z. The reason why we care about this construction, is the following proposition.
Proposition 5.9 From an algebra homomorphism f : X → ∫ Y such that πY ◦ f
is the identity, we obtain a displayed algebra map from X to Y .
Now suppose X is an initial object in the category of algebras. Then, due to initiality, we always have a map f : X →  Y , and the composition πY ◦ f : X → X must be the identity because initiality ensures uniqueness of homomorphisms. Hence, we conclude
Corollary 5.10 If X is an initial object in the category of algebras on £, then X
is a HIT for £.
Constructing the Initial Algebra
To construct the initial algebra, we first lift the quotient to a left adjoint functor from algebras in setoids to algebras in sets. Such functors preserve initial objects, and thus it suffices to construct the initial setoid algebra. For that, we use an adaption of Dybjer’s and Moeneclaey’s interpretation of HITs in the setoid model [20,36]. In the remainder of this section, we work with a fixed signature £.


Quotient Adjunction
We start by defining a left adjoint functor Q : Setoid —→

hSet. On objects, we

define Q (X, R)= X/R and its action on morphisms is defined by recursion on the quotient type. The laws are proven by quotient induction. The right adjoint is the path setoid functor π0 : hSet —→ Setoid. For sets X, we define the functor π0 X to be (X, Path X). Note that this action is functorial and that this gives rise to an adjunction.
Lemma 6.1 (Theorem 2.20 from [38]) We have an adjunction QE π0.
The Adjunction on Prealgebras
With this adjunction in place, our first step is to lift it to the level of prealgebras. For this, we use a result from Hermida and Jacobs [23]. Note that this is also related

to the fact that the 2-functor from the bicategory of endofunctors to the bicategory of categories preserves adjunctions [40].
The first step, is to lift the functors for which we use the following lemma.
Lemma 6.2 Given are categories C and D, functors A1 : C —→ C, A2 : D —→ D, and F : C —→ D, and a natural transformation n : A2 ◦ F =⇒ F ◦ A1. Then we get a functor F PreAlg : FAlg(A1) —→ FAlg(A2).
For algebras (X, f ) : FAlg(A1), we define F PreAlg(X, f ) = (F X, F f ◦ n X).
To lift the quotient and the path setoid, we need a lemma.
Lemma 6.3 The functors π0 and Q commute with sums and products. This gives rise to two natural isomorphisms nP : ⟨P⟩◦ π0 =⇒ π0 ◦ JP ) and nP : ⟨P⟩◦Q =⇒
1	2
Q◦ JP ).
Proving that Q commutes with products makes essential use of the double recur- sion principle of the quotient type, which allows defining functions QX ×QY → Z. Using Lemmata 6.2 and 6.3, we lift both the quotient and the path setoid functors to obtain.
QPreAlg : PreAlgSetoid(£) —→ PreAlghSet(£)
πPreAlg : PreAlghSet(£) —→ PreAlgSetoid(£).
This gives the required functors for the adjunction on the level of algebras, and the next step is to obtain the new unit and counit. The main idea is to show that the unit and counit are algebra homormophisms.
Proposition 6.4 Given are categories C and D, functors A1 : C —→ C, A2 : D —→ D, and L : C —→ D, and a natural transformation n : A2 ◦ L =⇒ L ◦ A1. In addition, suppose we a functor R : D —→ C together with a natural transformation m : A1 ◦ R =⇒ R ◦ A2 and an adjunction L E R with unit η and counit ε. We also assume that for each X : C and Y : D the following diagrams commute


A2(L(R X))
n(R X)



A2(є X)
A1 Y
A1 (η Y )  A¸(R(LY ))
m(L X)
  

L(A1(R X))
L(m X)
	z"
η (A1 X)
R(A2(L X))
R(n X)
z " 

R(L(A2 X))
є(A1 X)
 A¸X
R(L(A1
Y ))

Then the maps εX and ηY are algebra homomorphisms for each X : C and Y : D. Furthermore, we have an adjunction LPreAlg E RPreAlg.
For the verification of the conditions of this proposition for the path setoid and quotient, we refer the reader to the formalization. Now we conclude
Lemma 6.5 We have an adjunction QPreAlg E πPreAlg.

Algebras
If C is a category and P is a family of propositions on C, then we write full(C,P ) for the full subcategory of C in which each object satisfies P . First, we look at a way to obtain adjunctions between full subcategories.
Lemma 6.6 Let C and Ð be categories, let P1 and P2 be families of propositions on C and Ð respectively, and suppose we have a functor F : C —→ Ð. If for each object x : C we have P1 x → P2(F x), then we get a functor Fsub : full(C, P1) —→ full(Ð, P2).
Proposition 6.7 Let C and Ð be categories, let P1 and P2 be families of propo- sitions on C and Ð respectively, and suppose we have an adjunction L E R with L : C —→ Ð. If for each object x : C we have P1 x → P2(L x) and for each y : Ð we have P2 x → P1(R x), then we get an adjunction Lsub E Rsub.
Now we would like to apply this proposition to the adjunction obtained from Lemma 6.5. For that, we first need to calculate the action of the endpoints. This is done by the following lemma.
Lemma 6.8 Given is an endpoint e : SA(P, Q). For every set prealgebra X, we have the following equality
π0 (Je) X) ◦ nP X = nQ X ◦ ⟨e⟩ (πPreAlg X).
1	1	0
For every setoid prealgebra X, we have the following equality.
Q (⟨e⟩ X) ◦ nP X = Je) (QPreAlg X).
For the quotient, a similar lemma is required and for its precise formulation, we refer the reader the formalization. With all this in place, we obtain the desired adjunction.
Theorem 6.9 We have an adjunction QAlg E πAlg.
Initial Setoid Algebra
The initial setoid is constructed in two steps. First we define its carrier as the initial algebra on £pt and then we define the equivalence relation as the least con- gruence relation containing the equations in £ and preserving equality of the point constructor.
Lemma 6.10 The category PreAlghSet(£pt) has an initial object.
This follows from Ad´amek’s theorem and the fact that the functor JP ) is ω- continuous for each P . The colimits required for this theorem are constructed from quotient types. We denote the initial object of this category by (F,f ). The carrier of the desired setoid is F and the next step is to define the equivalence relation on
F . The main difficulty of defining this relation, is that we need to be able to lift f to a setoid morphism meaning that J£pt)F must be defined correctly. For that reason, we first define a relation on JP ) F for P : P.

Definition 6.11 Given is P : P and a signature £. The relation R∗ P on JP ) F is inductively generated by the constructors

x : JP ) F
refl x : R∗ P x x
r : R∗ P x y
sym r : R∗ P y x
r1 : R∗ P x y	r2 : R∗ P y z
trans r1 r2 : R∗ P x z

r : R∗ P1 xy 
inl r : R∗ (P1 + P2) (inl x) (inl y)
r : R∗ P2 xy 
inr r : R∗ (P1 + P2) (inr x) (inr y)

r1 : R∗ P1 x1 x2	r2 : R∗ P2 y1 y2
pair r1 r2 : R∗ (P1 × P2) (x1, x2) (y1, y2)

j : £pth	x : J£arg j) F
path j x : R∗ I (J£lhs j) F x) (J£rhs j) F x)
r : R∗ £pt xy 


cong r : R∗ I (f x) (f y)

The extra argument P represents the sort of x, and we leave the signature
£ implicit when talking about this relation. Now we define a relation on F by R xy = R∗ I xy  . Because of the truncation, each R xy is a proposition. Note that R is an equivalence relation, because of the constructor refl, sym, and trans. In addition, all equations in £ are validated in R by path. Finally, with the constructors pair, inl, inr, and cong, we can show that f preserves R. Hence, we obtain a setoid I := (F, R∗) together with a setoid morphism ϕ : ⟨P⟩ I → I. To show that this is the initial setoid algebra, we first need a property of R, which allows us to construct maps from I to algebras.
Lemma 6.12 If g is a prealgebra morphism from F to an algebra, then g preserves
R.
Now we show that I is an initial object in AlghSet(£). To show that we always have a homomorphism from I to an algebra X, we use that F is the initial prealgebra and Lemma 6.12. Furthermore, note that two setoid morphisms are equal if their underlying carriers are equal and two algebra morphisms are also equal if their underlying carrier is equal. Hence, the uniqueness also follows from initiality of R∗. All in all, we get
Theorem 6.13 The algebra I is the initial object of AlgSetoid(£).
From Theorems 6.9 and 6.13 we conclude
Corollary 6.14 For each signature £, there is a HIT on £.

Consequences
Uniqueness of HITs
Now we discuss two consequences of this construction. A first property of higher inductive types, is that they are unique up to equality. For that, we first show that higher inductives are initial algebras. This requires the well-known result that induction implies initiality [11,39]. Note that in Section 5 we used the converse statement, namely that initiality implies induction.

To show a HIT H is initial, we must show that for each algebra X the set of morphisms from H to X is contractible. This means that there is precisely one homomorphism from H to X. To show the existence, we use the following two lemmata.
Lemma 7.1 Let X and Y be algebras on £. Then there is a displayed algebra
const Y on X of which the underlying type family is Y on each point of X.
Lemma 7.2 Let X be Y be algebras on £. If we have a displayed algebra map from
X to const Y , then we have an algebra homomorphism from X to Y .
Corollary 7.3 If X is a HIT for £, then for each algebra Y we have an algebra map from X to Y .
To show uniqueness, we use an alternative induction principle for families of propositions. More specifically, we use the following lemma.
Lemma 7.4 Let H be a HIT of £ and suppose Y is a family of propositions on H.
If we have an operation

c :   (z : J£pt)H), £pt Y z → Y (pointX z),
then we have a map Q(x : H),Y x.
To prove the uniqueness of the map, we use function extensionality and the previous lemma. This is sufficient to conclude that higher inductive types are initial objects.
Proposition 7.5 If H is a HIT for £, then H is an initial £-algebra.
Now we take advantage of Proposition 4.4 where we proved that the category of algebras is univalent. Since initial objects in a univalent category are unique up to equality, we can immediately conclude that HITs are actually unique up to equality. All in all, we get
Corollary 7.6 If H1 and H2 are HITs for £, then the underlying £-algebras of H1
and H2 are equal.
Path Spaces of HITs
The construction of HITs also allows us to characterize the path space up to equiva- lence. For this, we first recall the characterization of the path space of the quotient type.
Proposition 7.7 (Lemma 10.1.8 from [41]) Let X be a type and let R be an equivalence relation on X. Then for each x, y : X, we have an equivalence Rx y class x = class y.
Now we specialize this theorem to HITs constructed according to Theorem 6.14. This allows us to conclude that the path space of set truncated HITs is freely generated.

Corollary 7.8 Let £ be a signature. Then for each x, y : F we have an equivalence
R xy  class x = class y using F and R as deﬁned in the previous section.
Hence, since HITs are unique, they must be equal to the HIT we constructed in the previous section, and this determines the path spaces of HITs. Note that this corollary gives an induction principle for the type class x = class y, because R is defined as the propositional truncation of an inductive type, For this reason, we conclude that the path space of higher inductive types are freely generated.
Conclusion and Further Work
We have shown how to construct finitary set-truncated higher inductive types using the quotient and propositional truncation in Theorem 6.14. Since truncations and the quotient can be constructed from non-recursive HITs, this proves that all finitary set-truncated HITs can be constructed from non-recursive ones. Besides that, we took advantage of this construction to show uniqueness of HITs in Corollary 7.6 and to characterize their path space in Corollary 7.8.
The method used in this paper crucially relies on the polynomials being finitary. To show that Infinitary polynomials commute with quotients, one needs the axiom of choice [16]. Furthermore, Lumsdaine and Shulman gave an infinitary HIT which cannot be constructed from pushouts, and thus this result cannot be extended to infinitary polynomials.
However, a possible extension would be by allowing the arguments of point con- structors to depend on previous ones [4]. For a construction of all finitary HITs, higher path constructors need to be allowed and the HITs need to be interpreted in some higher category. A first step towards that goal, would be adapting this construction to bicategory theory [1,14] and constructing higher inductive 1-types using Dybjer’s and Moeneclaey’s interpretation of those in groupoids [20]. For non-truncated types, a type theoretic definition of ω-groupoid would be required [8,14,21,24]. In both cases, one also needs to interpret the endpoints of homotopies. In addition, the path computation rules become relevant. Proving the induction principle from initiality is more difficult then, because equality becomes proof rele- vant giving nontrivial transports. In this setting, Corollary 7.8 is more interesting, because the computation rules of path constructors become nontrivial.

References
Benedikt Ahrens, Dan Frumin, Marco Maggesi, and Niels van der Weide. Bicategories in Univalent Foundations. arXiv preprint arXiv:1903.01152, 2019.
Benedikt Ahrens, Krzysztof Kapulkin, and Michael Shulman. Univalent Categories and the Rezk Completion. Mathematical Structures in Computer Science, 25(5):1010–1039, 2015.
Benedikt Ahrens and Peter LeFanu Lumsdaine. Displayed Categories. Logical Methods in Computer Science, 15(1), 2019.
Thorsten Altenkirch, Paolo Capriotti, Gabe Dijkstra, Nicolai Kraus, and Fredrik Nordvall Forsberg. Quotient Inductive-Inductive Types. In Foundations of Software Science and Computation Structures
- 21st International Conference, FOSSACS 2018, Held as Part of the European Joint Conferences on


Theory and Practice of Software, ETAPS 2018, Thessaloniki, Greece, April 14-20, 2018, Proceedings, pages 293–310, 2018.
Thorsten Altenkirch, Nils Anders Danielsson, and Nicolai Kraus. Partiality, Revisited - The Partiality Monad as a Quotient Inductive-Inductive Type. In Foundations of Software Science and Computation Structures - 20th International Conference, FOSSACS 2017, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2017, Uppsala, Sweden, April 22-29, 2017, Proceedings, pages 534–549, 2017.
Thorsten Altenkirch and Ambrus Kaposi. Type Theory in Type Theory using Quotient Inductive Types. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2016, St. Petersburg, FL, USA, January 20 - 22, 2016, pages 18–29,
2016.
Thorsten Altenkirch and Ambrus Kaposi. Normalisation by Evaluation for Type Theory, in Type Theory. Logical Methods in Computer Science, 13(4), 2017.
Thorsten Altenkirch and Ondrej Rypacek. A Syntactical Approach to Weak ω-Groupoids. In Computer Science Logic (CSL’12) - 26th International Workshop/21st Annual Conference of the EACSL, CSL 2012, September 3-6, 2012, Fontainebleau, France, pages 16–30, 2012.
Carlo Angiuli, Robert Harper, and Todd Wilson. Computational Higher-Dimensional Type Theory. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, Paris, France, January 18-20, 2017, pages 680–693, 2017.
Carlo Angiuli, Edward Morehouse, Daniel R. Licata, and Robert Harper. Homotopical Patch Theory.
J. Funct. Program., 26:e18, 2016.
Steven Awodey, Nicola Gambino, and Kristina Sojakova. Inductive Types in Homotopy Type Theory. In Proceedings of the 27th Annual IEEE Symposium on Logic in Computer Science, LICS 2012, Dubrovnik, Croatia, June 25-28, 2012, pages 95–104, 2012.
Henning Basold, Herman Geuvers, and Niels van der Weide. Higher Inductive Types in Programming.
J. UCS, 23(1):63–88, 2017.
Marc Bezem, Thierry Coquand, and Simon Huber. A Model of Type Theory in Cubical Sets. In 19th International Conference on Types for Proofs and Programs, TYPES 2013, April 22-26, 2013, Toulouse, France, pages 107–128, 2013.
Paolo Capriotti and Nicolai Kraus. Univalent Higher Categories via Complete Semi-Segal Types.
Proceedings of the ACM on Programming Languages, 2(POPL):44, 2017.
Evan Cavallo and Robert Harper. Higher Inductive Types in Cubical Computational Type Theory.
PACMPL, 3(POPL):1:1–1:27, 2019.
James Chapman, Tarmo Uustalu, and Niccol`o Veltri. Quotienting the Delay Monad by Weak Bisimilarity. Mathematical Structures in Computer Science, 29(1):67–92, 2019.
Cyril Cohen, Thierry Coquand, Simon Huber, and Anders M¨ortberg. Cubical Type Theory: a Constructive Interpretation of the Univalence Axiom. CoRR, abs/1611.02108, 2016.
Thierry Coquand, Simon Huber, and Anders M¨ortberg. On Higher Inductive Types in Cubical Type Theory. In Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2018, Oxford, UK, July 09-12, 2018, pages 255–264, 2018.
Peter Dybjer. Inductive Families. Formal aspects of computing, 6(4):440–465, 1994.
Peter Dybjer and Hugo Moeneclaey. Finitary Higher Inductive Types in the Groupoid Model. Electr. Notes Theor. Comput. Sci., 336:119–134, 2018.
Eric Finster and Samuel Mimram. A Type-Theoretical Definition of Weak ω-Categories. In 32nd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2017, Reykjavik, Iceland, June 20-23, 2017, pages 1–12, 2017.
Dan Frumin, Herman Geuvers, L´eon Gondelman, and Niels van der Weide. Finite Sets in Homotopy Type Theory. In Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2018, Los Angeles, CA, USA, January 8-9, 2018, pages 201–214, 2018.
Claudio Hermida and Bart Jacobs. Structural Induction and Coinduction in a Fibrational Setting.
Information and computation, 145(2):107–152, 1998.
Andr´e Hirschowitz, Tom Hirschowitz, and Nicolas Tabareau. Wild ω-Categories for the Homotopy Hypothesis in Type Theory. In 13th International Conference on Typed Lambda Calculi and Applications, TLCA 2015, July 1-3, 2015, Warsaw, Poland, pages 226–240, 2015.


Martin Hofmann and Thomas Streicher. The Groupoid Model Refutes Uniqueness of Identity Proofs. In Proceedings of the Ninth Annual Symposium on Logic in Computer Science (LICS ’94), Paris, France, July 4-7, 1994, pages 208–212, 1994.
Ambrus Kaposi and Andr´as Kov´acs. A Syntax for Higher Inductive-Inductive Types. In 3rd International Conference on Formal Structures for Computation and Deduction, FSCD 2018, July 9-12, 2018, Oxford, UK, pages 20:1–20:18, 2018.
Ambrus Kaposi, Andra´s Kova´cs, and Thorsten Altenkirch. Constructing Quotient Inductive-Inductive Types. PACMPL, 3(POPL):2:1–2:24, 2019.
Chris Kapulkin and Peter LeFanu Lumsdaine. The Simplicial Model of Univalent Foundations (after Voevodsky), 2012.
Nicolai Kraus. Constructions with Non-Recursive Higher Inductive Types. In Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’16, New York, NY, USA, July 5-8, 2016, pages 595–604, 2016.
Nicolai Kraus and Jakob von Raumer. Path Spaces of Higher Inductive Types in Homotopy Type Theory. CoRR, abs/1901.06022, 2019.
Daniel R. Licata and Eric Finster. Eilenberg-MacLane Spaces in Homotopy Type Theory. In Joint Meeting of the Twenty-Third EACSL Annual Conference on Computer Science Logic (CSL) and the Twenty-Ninth Annual ACM/IEEE Symposium on Logic in Computer Science (LICS), CSL-LICS ’14, Vienna, Austria, July 14 - 18, 2014, pages 66:1–66:9, 2014.
Daniel R. Licata and Michael Shulman. Calculating the Fundamental Group of the Circle in Homotopy Type Theory. In 28th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2013, New Orleans, LA, USA, June 25-28, 2013, pages 223–232, 2013.
Peter LeFanu Lumsdaine. Weak ω-categories from Intensional Type Theory. In International Conference on Typed Lambda Calculi and Applications, pages 172–187. Springer, 2009.
Peter LeFanu Lumsdaine and Mike Shulman. Semantics of Higher Inductive Types. arXiv preprint arXiv:1705.07088, 2017.
Saunders Mac Lane. Categories for the Working Mathematician, volume 5. Springer Science & Business Media, 2013.
Hugo Moeneclaey. A Schema for Higher Inductive Types of Level One and Its Interpretation. Internship report, supervised by Peter Dybjer, ENS Paris-Saclay, 2016.
Egbert Rijke. The Join Construction. arXiv preprint arXiv:1701.07538, 2017.
Egbert Rijke and Bas Spitters. Sets in Homotopy Type Theory. Mathematical Structures in Computer Science, 25(5):1172–1202, 2015.
Kristina Sojakova. Higher Inductive Types as Homotopy-Initial Algebras. In Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015, pages 31–42, 2015.
Ross Street. The Formal Theory of Monads. Journal of Pure and Applied Algebra, 2(2):149–168, 1972.
The Univalent Foundations Program. Homotopy Type Theory: Univalent Foundations of Mathematics.
https://homotopytypetheory.org/book, Institute for Advanced Study, 2013.
Benno Van Den Berg and Richard Garner. Types are Weak ω-Groupoids. Proceedings of the London Mathematical Society, 102(2):370–394, 2011.
Floris van Doorn. Constructing the Propositional Truncation using Non-Recursive HITs. In Proceedings of the 5th ACM SIGPLAN Conference on Certified Programs and Proofs, Saint Petersburg, FL, USA, January 20-22, 2016, pages 122–129, 2016.
Vladimir Voevodsky, Benedikt Ahrens, Daniel Grayson, et al. UniMath — a computer-checked library of univalent mathematics. available at https://github.com/UniMath/UniMath.
