Electronic Notes in Theoretical Computer Science 46 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume46.html 16 pages


A Three-Dimensional Uniquely Parsable Array Grammar that Generates and Parses Cubes

Katsunobu Imai a,1, Yukio Matsuda b, Chuzo Iwamoto a,2, and Kenichi Morita a,3
a Faculty of Engineering Hiroshima University Higashi-Hiroshima, Japan b Sharp Corporation Osaka, Japan


Abstract
A uniquely parsable array grammar (UPAG) introduced by Yamamoto and Morita is a subclass of isometric array grammar (IAG) in which parsing can be performed without backtracking. Hence, we can use a UPAG as an efficient two-dimensional pattern recognition mechanism, if the pattern set is properly described by a UPAG. Furthermore, since a UPAG admits parallel parsing, it can also be used as a formal framework for parallel pattern recognition. In this paper, we show UPAG is also useful to generate and recognize three-dimensional patterns. We construct a UPAG that generate any size of cubes. This UPAG can recognize cubes in linear time of the length of its side by maximum parallel reduction. To construct the grammar, we have made a tool for designing three-dimensional IAG.


Introduction
An isometric array grammar (IAG) introduced by Rosenfeld [3] is a formal modelof two-dimensionalpattern generation. Untilnow, severalsubclasses of IAGs have been proposed and investigated. For example, there are a context- sensitive array grammar (CSAG), a context-free array grammar (CFAG), and a regular array grammar (RAG) that form a Chomsky-like hierarchy in IAGs. Although many research has been done in two-dimensional array grammar [6], it is in general very hard to parse two-dimensional languages based on these IAG frameworks. It has been shown that even for RAGs, the lowest subclass

1 Email: imai@iec.hiroshima-u.ac.jp
2 Email: iwamoto@iec.hiroshima-u.ac.jp
3 Email: morita@iec.hiroshima-u.ac.jp
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


of the Chomsky-like hierarchy, the membership (i.e., recognition) problem is NP-complete [1].
A uniquely parsable array grammar (UPAG) is another subclass of IAGs proposed by Yamamoto and Morita [5]. It is a grammar that satisfies the fol- lowing condition: for any superposition of right-hand sides of any two rewrit- ing rules, the overlapping portions do not match except “context portions”. Because of this condition, parsing can be done without backtracking. UP- AGs also admit parallel parsing. That is, we can make any number of reverse applications of rewriting rules simultaneously, and it is assured that such par- allel reduction leads exactly the same final result as a sequential reduction [5]. Thus, it can be used as a kind of formal framework for parallel pattern recog- nition.
On three-dimensional array grammar, Wang [7] introduced a universal 3- d array grammar (UAG) and he showed that some kind of patterns can be generated and parsed effectively by UAGs. But UAG uses a special type of parsing algorithm and it can’t be regarded as a standard IAG. So we explore the straightforward extension of normal IAG, i.e., we allow that each rule has three-dimensionalshapes. UAG uses rewriting rules of two-dimensionalshapes and it is fairly easy to grasp there derivation processes, but if rewriting rules contain ‘true’ three-dimensional shapes, it becomes quite difficult to design rules and to illustrate there derivation processes.
So we have made a simple tool for designing IAGs. To show the tool is useful, we first design a context-free IAG that generates rectangular paral- lelepipeds. Next, to show UPAG is also useful to generate and parse three- dimensional patterns, we constructed a UPAG that generates cubes. In par- ticular, it can be possible to recognize any size of cubes in linear time of the length of the side by the grammar.
Definition
Let Σ be a nonempty finite set of symbols and d(= 2 or 3) be the dimension of an array. A d-dimensional word over Σ is a d-dimensional finite connected array of symbols in Σ. The set of all words over Σ is denoted by Σd+ (the empty word is not contained in Σd+).
Definition 2.1 An isometric array grammar (IAG) is a system defined by
G = (N, T, P, S, #),
where N is a finite nonempty set of nonterminalsymbols, T is a finite nonempty set of terminalsymbols (N ∩T = ∅), S (∈ N ) is a start symbol, #(/∈ N ∪T ) is a special blank symbol, P is a finite set of rewriting rules of the form α → β, where α and β are words over N∪T ∪{#}, and satisfy the following conditions:
The shapes of α and β are geometrically identical.
α contains at least one nonterminal symbol.
Terminalsymbols in α are not rewritten by the rule α → β.

The application of the rule α → β preserves the connectivity of the host array.
If P also satisfies the following conditions, G is said to be context-free.
The left-hand side of each rule in P only contains a nonterminal symbol and several# symbols.
The right-hand side of each rule in P contains no #.
A #-embedded array of a word ξ ∈ (N ∪ T )d+ is an infinite array over N ∪ T ∪ {#} obtained by embedding ξ in a d-dimensional infinite array of #s, and is denoted by ξ#.  (Formally, a #-embedded array is a mapping Zd → (N ∪ T ∪ {#}), where Z is the set of all integers.) We say that a word η is directly derived from a word ξ in G if η# can be obtained by replacing one of the occurrences of α in ξ# with β for some rewriting rule α → β in G. This is denoted by ξ ⇒ η. The reflexive and transitive closure of the relation ⇒ is
G	G
denoted by ⇒∗ . We say that a word η is derived from a word ξ in G if ξ ⇒∗ η.

G
We write ξ ⇒n
G
η (n = 0, 1, 2, ·· ·) if there is a sequence of words ζ ,ζ ,...,ζ 

G
∈ (N ∪ T )d+ that satisfy

ξ = ζ0 ⇒
G


ζ1 ⇒
G


··· ⇒
G


ζn = η.
0	1	n

The array language generated by G (denoted by L(G) ) is defined by

L(G) = { w | S ⇒∗
w, and w ∈ Td+ }.

A rewriting rule α → β is said to be applicable to ξ at u ∈ Zd, iff α occurs in ξ# at the position u, where the position of an occurrence means the x–y coordinates of the leftmost symbol of its uppermost row of α (d = 2) or x– y–z coordinates of the leftmost symbol of uppermost row of its bottommost pattern of α (d = 3). If η# is obtained by applying α → β at u, we say η is directly derived from ξ by the rewriting with the label L = [α → β, u]. This

is denoted by ξ ⇒L
η. The label L itself is also said to be applicable to ξ.

Similarly, a rewriting rule α → β is said to be reversely applicable to η at
u, iff β occurs in η# at the position u.
Let α → β be a rule. The subarray of α whose symbols are not changed (i.e., rewritten to the same symbols) by the application of α → β is called the context portion of α. The subarray of α all of whose symbols are rewritten to different symbols is called the rewritten portion of α. The context portion and the rewritten portion of β are also defined similarly.
Definition 2.2 Let G = (N, T, P, S, #) be an IAG. If P satisfies the follow- ing condition, G is called a uniquely parsable array grammar (UPAG).
The UPAG Condition:
The right-hand side of each rule in P contains a symbol other than # and S.

Let r1 = α1 → β1 and r2 = α2 → β2 be any two rules in P (may be r1 = r2). Superpose β1 and β2 at all the possible positions variously translating them. For any superposition of β1 and β2, if all the symbols in overlapping portions of them match, then
these overlapping portions are contained in the context portions of
β1 and β2, or
the whole β1 and β2 are overlapping, and r1 = r2.
Example 2.3 The pair of rewriting rules
aB → ab,	Ca → ca
satisfies the UPAG Condition, while the following does not.
#B → ab,	Ca → ca
In [5] the following Lemmas have been shown.
Lemma 2.4 [Unique Parsability] [5] Let G = (N, T, P, S, #) be a UPAG. Let α → β be any rewriting rule in P which is reversely applicable to η ∈ (N∪T )d+ at u. If
η ⇐n	S,
then the following relation holds for some ζ:
η ⇐L	ζ  n⇐−1 S.
Lemma 2.5 [Parallel Parsability] [5] Let G = (N, T, P, S, #) be a UPAG. Let L1, ··· , Lm be different labels which are reversely applicable to η ∈ (N ∪T )d+. If
η ⇐n	S,


then the following relation holds for some ζ:
{L1,···,Lm}
η	⇐=	ζ


n⇐−m  S.

From the Lemma 2.5, the next corollary on maximum parallel reduction can be obtained.
Corollary 2.6 [Maximum Parallel Parsability] Let G = (N, T, P, S, #) be a UPAG. If
η ⇐n	S,
then the following relation holds for some ζ:
η ⇐− ζ  n⇐−m  S,
where m is the total number of labels reversely applicable to η.
All above conditions are agree with three-dimensional cases and each rewrit- ing rule has a pair of three-dimensional figures.


(a)	(b)





Fig. 1. Examples of three-dimensional IAG rules.
Example 2.7 Examples of rewriting rules of three-dimensional IAG are shown in fig. 1.
Rules (a) and (b) in fig. 1 are denoted as follows respectively.
(a)	#	#
SAa → Sa a
#	#
(b)		A	A		A	A AB		→ BB
# ,	# ,
The rule (a) is the same as the two-dimensional case, while (b) is “true” three-dimensionalone. Patterns stacked along z-axis is delimited by commas and ‘ ’ denotes that the position is not used as the context of the rule.

A tool for designing three-dimensional isometric ar- ray grammars
On designing three-dimensional array grammars, each rewriting rule has a complex structure and it is quite difficult to cope with such rules, in particular, checking the UPAG condition. Furthermore, simulating derivation processes and application of each rules are very difficult to perform without any software tools.
So we made a simple tool for designing IAG. Our tool is made with Mac- intosh Common Lisp and a three-dimensionalgraphic library. It has windows for manipulated patterns (fig. 2) and for rewriting rules (fig. 3), which make it easy to edit and apply rules interactively.
It also has a tool which checks whether a grammar is UPAG or not. So it is capable of designing three-dimensional IAGs with ease.

A context-free isometric array grammar that gener- ates rectangular parallelepipeds
In this section, as an example of three-dimensional IAG, we show a context- free IAG that generates rectangular parallelepipeds.
Yamamto and Morita [4] designed a context-free IAG GR that generates rectangles. We extend it and construct a three dimensional context-free IAG



Fig. 2. A pattern window

Fig. 3. A rule window
GRP that generates rectangular parallelepipeds of symbol ‘a’s.
GRP = (VRP , TRP , PRP , S, #)
VRP = {S, U, R, L, I, J1, J2, J3, J4, J5, J6, J7, J8, J9} TRP = {a}
PRP , i.e., rewriting rules of GRP are listed in Appendix A.
Fig. 4 shows the outline of a derivation process of GR. In the process, the rule of fig. 5(1) is used to advance the length of rectangle and the rule of fig. 5(2) is used to terminate the generation.
GRP uses the same approach to generating rectangular parallelepipeds. Fig. 6 shows the outline of a derivation process. First, a rectangle is generated by the same way as GR. But this time, nine non-terminals J1, ··· , J9 are embedded. These symbols denote the shape of each block and referring these symbols, it is possible to stack blocks of the same shape on the rectangle. After repeating this process of stacking blocks, it is interrupted by the same approach as GR and the height is fixed.
GRP generates any rectangular parallelepipeds of depth 3k+6, width 2l+3, and height 2m + 1(k, l, m = 0, 1, 2 .. .). Fig. 7 shows a derivation example of


 			


Fig. 4. A derivation example of GR

I	a	I	a
# # 	a a	# #		a a
# #	a I	# #	a a

(1)	(2)
Fig. 5. The ‘advancing’ rule and the ‘terminating’ rule in GR.

(3) The process of stacking blocks is interrupted by this block and the height is fixed.



(2) The same type of blocks are placed on the rectangle.





(1) A rectangle is two-dimensionally generated.


Fig. 6. The outline of derivation of a rectangular parallelepiped by GRP

GRP . To add appropriate non-terminal symbols, GRP can be extended to generate any size of rectangular parallelepipeds.

A uniquely parsable array grammar that generates any size of cubes

In previous section, we show context-free IAG GRP that generates rectangular parallelepipeds. But it is impossible to use GRP to recognize that a pattern is a rectangular parallelepiped or not. So in this section, we show an example of three-dimensionalUPAG.
By using the simulating tool described above, we constructed a UPAG
Gcube that generates any cubes of symbol‘a’s.
Gcube = (Ncube, Tcube, Pcube, S, #),
Ncube = {S, X, Y, Z, F, A, D, G, E},
Tcube = {a},
Pcube, i.e., rewriting rules of Gcube are listed in Appendix B.
Gcube generates and recognizes any cubes of the size l(≥ 4). It is easy to extend Gcube to generates any size of cubes, i.e., including l(< 4), by adding severalrewriting rules.
Gcube generates a cube by the following method.
generates an l × l square which consists of non-terminal symbol ‘F ’ in
x–z plane (fig. 8(1)).
generates rectangles of the size l × (l − 1) l times (fig. 8(2,3,4)). The outline of a generating process of Gcube is as follows.
Rewriting rules from (31) to (39) in Appendix B. are used to generate an
‘F ’-filled square and the other rules are used to generate l × (l − 1) rectangles on x–y plane.
Generating an ‘F ’-filled square:
The rule (32) is applied to advance the side of an ‘F ’-filled square in −x direction. (31) is used to terminate its growth and to generate a symbol ‘Z’. (33) is used to advance the side of the square in −z direction (34) is used to place ‘F ’ in −x direction and each row is completed by (36). ‘Z’ is sent along the diagonal direction of the square by (35), and if ‘Z’ reaches to the other side, (37) is used to fix the height of the square and generate ‘Y ’ at the bottom side of the square. (38) sends ‘Y ’ along the bottomside in −x direction and (39) completes the square.
Generating l × (l − 1) rectangles:
Rules (11)–(20) and (21)–(30) are used for generating top and bottom rectangles respectively and (1)–(10) are used for generating the other rectangles.
(1+ 10k) (k = 0, 1, 2) advances the side of rectangles in +z direction. This rule invokes each derivation processes of rectangles. (2 + 10k),(4 + 10k),(5 + 10k) are used to advance rectangles in −y and +x direction and (3 + 10k) terminates the growth in +x direction.

(6 + 10k) and (7 + 10k) are used to ‘count’ the length of the side of each rectangle and the symbol ‘G’ is used as a marker and play almost the same roll as ‘Z’ in generating a ‘F ’-filled square. To keep the size of each rectangle should be l × (l − 1), (8 + 10k) is used to terminate the growth in −y direction and the symbol ‘E’ denotes that the growth is finished.
(10+ 10k) sends ‘E’ in +x direction and the generation process is completed by (9 + 10k).
Wang [7] also show a UAG that generates and parses cubes. Although his grammar uses a special type of parsing algorithm, Gcube uses completely the same framework as two-dimensionalIAG. Furthermore, it satisfies the UPAG condition and parallel parsing can be performed without backtracking.
By maximum parallel reduction, parsing l rectangles takes 7(l − 4) + 20 steps and parsing an ‘F’-square takes 3(l−4)+10 steps. Thus the totalparsing steps of a cube of the size l is 10(l − 4) + 30 and linear to l. Fig. 9 shows a maximum parallel reduction example of Gcube.

Conclusion
In this paper, we apply IAG to three-dimensional pattern generations and recognitions. We constructed a context-free IAG GRP that generates rectan- gular parallelepipeds and a UPAG Gcube that generates cubes. In particular, it is possible to recognize cubes in linear time of the length of their side by Gcube.
In the two-dimensionalcase, there are UPAGs that generate and recognize connected patterns [2]. Although such topological properties in the three- dimensional case are very difficult to describe with three-dimensional IAGs and UPAGs, they are interesting problems.
The derivation and parsing processes are hard to show on a paper. These examples can be seen as image files and QuickTime movies at the following addresses via WWW:

http://www.iec.hiroshima-u.ac.jp/projects/ag/3d/.

Acknowledgements: The authors thank Hiroyuki Aga (SONY Co.) for his comments. All software for simulations are made with Macintosh Common Lisp and its graphic libraries. These systems are maintained by engineers of Digitool, Inc. and John Wiseman (Neodesic, Inc.).
This work was supported in part by Grant-in-Aid for Scientific Research
(C) No. 12680353 from JSPS, and by Electric Technology Research Foundation of Chugoku.

References
Morita, K., Y. Yamamoto, and K. Sugata, “The complexity of some decision problems about two-dimensional array grammars,” Information Sciences, 30 (1983), 241–262.
Morita, K., K. Imai, Uniquely parasable array grammars for generating and parsing connected patterns, Pattern Recognition Journal 32 (1999), 269–276.
Rosenfeld, A., Picture Languages, Academic Press, New York (1979).
Yamamoto, Y., K. Morita, and K. Sugata,: An Isometric Context-Free Array Grammar That Generates Rectangles, Trans. IECE of Japan, E 65, No.12 (1982), 754–755.
Yamamoto, Y., and K. Morita, Two-dimensional uniquely parsable isometric array grammars, Int. J. Pattern Recognition and Artificial Intelligence, 6 (1992), 301–313.
Wang, P.S.P., Array grammars, patterns and recognizers, Parallel Image Analysis and Processing, P.S.P Wang (Ed.), Series in Computer Science 18, World Scientific (1989).
Wang, P.S.P., Three-dimensional sequential/parallel universal array grammars for polyhedral object pattern analysis, Parallel Image Analysis and Processing, K.Inoue et. al. (Ed.), Series in Machine Perception Artificial Intelligence 15, World Scientific (1994), 563–576.


 

Fig. 7. A derivation example of GRP




















(1)









(2)	(4)






Fig. 8. The outline of derivation of a cube by Gcube


 

Fig. 9. A maximum parallel reduction example of Gcube

Rewriting rules of GRP
#  , ## , S # → L  , a a ,J1 U
# #  ,  ## , U ## → a I  ,  a a , a J2 U
# # ,  # , U # → a R ,  a , a J3
#  , ## , ## , L  → L  , a a ,J4 a , a 
# #  ,  ## ,  ## ,  I  → a I  ,  a a ,  J5 a ,  a 
# # ,  # ,  # ,  R → a R ,  a ,  J6 ,  a
# # , ## , #  , L  → a a , a a ,J7  , a 
 ## ,  ## , ##  ,  I  →  a a ,  a a ,J8 a  ,  a 
 # ,  # , ## ,  R →  a ,  a ,J9 a ,  a

       J2 	         a 
##    ##  ## → a a    a a   a a 
##  ,  ## ,  ##	a a  ,  a a ,  J2 a
     J3	       a
##  #  # → a a   a   a
## ,  # ,  #	a a ,  a ,  J3

       J5 	         a 
##    ##  ## → a a    a a   a a 
##  ,  ## ,  ##	a a  ,  a a ,  J5 a
     J6	       a
##  #  # → a a   a   a
## ,  # ,  #	a a ,  a ,  J6
    J7 	     a 
## ## #  → a a  a a  a 
## , ## , # 	a a , a a ,J7 
        




    J9 	     a 
 #  # # # →  a   a  a a
 # ,  # , ##	 a ,  a ,J9 a
         J1  	            a  
       ##  #   →         a a   a  
#   , #   , ##  , ###	a   , a   , a a  , a a a 
            
        	 	          
    #   
 #   , ##    
       J3	          a
  #    # # # →    a    a  a a
 # , ## ,  # ,  	 a , a a ,  a ,  
         J4     	            a 






  a    a a  
 ,   a a 



       #   ##  #   →         a    a a   a  
#   , #   , ### ,  #  ,   	a   , a   , a a a ,  a  ,   
             J5      	                a    
  
    #     ##     ##    #   →      a     a a     a a    a  
 #   , ##   ,   ## ,   #  ,    	 a   , a a   ,   a a ,   a  ,   
         J6  	             a   
     #  ##  #  # →       a   a a   a   a   ,  # , ## ,   ,   ,  	  ,  a , a a ,   ,   ,  
      a    
 a   a   a  
 , a a a ,    ,   
        J8        	          a   
   
 ##  ##   ##     #   →  a a   a a    a a     a  
 ##  ,   ## , #    ,    	 a a  ,   a a , a    ,   
           



Rewriting rules of Gcube

##  ##  ##   ##  ##  ## # a F # F F # F F	# a F # a F # F F # A # ### ### → # A # # A # # # #
#  ,  #  ,  #	#  ,  #  ,  #
#	#	#	#	#	#
a a F a F F a F F		 a a F a a F a F F a A		A #		A #	→ a A		a A		A # A	, #	, #		A	, A	, #
#	#	#	#	#	#
 	  	  		 	  	  	
a a #	a F #	a F #	a a #	a a #	a F # a a a # a A ## a A ## → a a a # a a a # a A ## 
A G  ,  ##  ,  ##	A G  ,  A G  ,  ## 
# a a D # A A A # A A A		# a a D # a a D # A A A A A , ## , ##	→		A A  ,  A A  ,  ## 
a a a D a a D A a a D A		a a a D a a a D a a D A A ,	# ,	#	→		A ,	A ,	#
	a D D G D G		a D a D D G G , # , #	→ G , G , #
#	#	#	#	#	#
					
a # D # D # → a # a # D # A , # , #	A , A , #
# a a E , # A A G , # A A G → # a a E , # a a E , # A A G
a a a E , a a E A , a a E A → a a a E , a a a E , a a E A
#	#	#	#	#	#
					
a # E # E # → a # a # E # # , # , #	# , # , #
##  ##  ##   ##  ##  ## # a F # F F ###  # a F # a F ### # A # ### ### → # A # # A # # # #
#  ,  #  ,  #	#  ,  #  ,  #
#	#	#	#	#	#
	 	 			 	 	
a a F a F F ###		 a a F a a F ### a A		A #		##	→ a A		a A		## A	, #	, #		A	, A	, #
#	#	#	#	#	#
 	  	  		 	  	  	
a a #	a F #	###	a a #	a a #	### 
a a a # a A ## #### → a a a # a a a # #### 
A G  ,  ##  ,  ##	A G  ,  A G  ,  ## 
#	#
        	 	        	 
# a a D # A A A #### → # a a D # a a D #### 
A A  ,  ##  ,  ##	A A  ,  A A  ,  ## 
#	#
         		         	
a a a D  a a D A #### → a a a D  a a a D #### 
A  ,	# ,	#	A  ,	A  ,	#
#	#
   		   	
a D D G ## → a D  a D ## 
G  , #  , #	G  , G  , #
#	# # #	#	# # #
			
a # D # # # → a # a # # #
A  , #  , #	A  , A  , #
#	#
# a a E , # A A G , #### → # a a E , # a a E , #### 
#	#
        	 	        	 
a a a E , a a E A , #### → a a a E , a a a E , #### 
#	# # #	#	# # #
			
a # E # # # → a # a # # # # , # , #	# , # , #
##  ##  ##   ##  ##  ## ### # F F # F F	### # a F # F F ### ### ### → ### # A # # # #
#  ,  #  ,  #	#  ,  #  ,  #
#			#			#			#			#			# ### a F F a F F		### a a F a F F ##		A #		A #	→ ##		a A		A # #		, #		, #			#		, A		, #
	#		#		#		#		#		# ###	a F #	a F #	###	a a #	a F #
#### a A ## a A ## → #### a a a # a A ## ## , ## , ##	## , A G , ## 
#### # A A A # A A A	#### # a a D # A A A 
##  ,  ##  ,  ##  →  ##  ,  A A  ,  ## 
#### a a D A a a D A	#### a a a D a a D A
# ,	# ,	#	→	# ,	A  ,	#
## D G D G	## a D D G
# , #  , #	→ #  , G  , #
	#  #  #   #  #  # ## D # D # → ## a # D # # , # , #   # , A  , #
#### , # A A G , # A A G → #### , # a a E , # A A G
#### , a a E A , a a E A → #### , a a a E , a a E A



	#  #  #   #  #  # ## E # E # → ## a # E # # , # , #   # , # , #
#	#
			
Z S # → Y F # #	#
#	#
S Y F → Y F F
#	#
#	#
  	 	  	 
# # Y #	→	# # F #
,  # ,	,  # ,
