Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 332 (2017) 3–20
www.elsevier.com/locate/entcs
Controlling File Access with Types
Rakan Alsowail and Ian Mackie
Department of Informatics University of Sussex Falmer, UK

Abstract
Accidental misuse of shared files by authorised users is a predominant problem. This paper proposes a well-known static analysis approach, namely a type system, to prevent such accidental misuse. We develop a type system that intercepts commands issued by users in a file system and enforces policies on each file. Commands issued by users to manipulate files will be subject to type checking by the type system. Type- checked commands are then guaranteed to not violate policies of the files. The focus of this paper is on a particular policy that allows owners of files (users who created files) to specify the number of times a file can be read by limiting the number of times a file can be copied. Therefore, a file can be read as much as it can be copied. If the file cannot be copied, then it can be read only once. This approach can be extended to other properties.
Keywords: File sharing, security types, type checking

Introduction
File sharing has become an indispensable part of our daily lives. The shared files might be sensitive, thus, their confidentially, integrity and availability should be protected. Such protection might be against external threats that are initiated by unauthorised users or insider threats that are initiated by authorised users. Our main interest is with insider threats, in particular trusted authorised users who might accidentally violate files policies. The most widely used technique to protect shared files is access control such as Discretionary Access Control (DAC) [9,7] and Role-based Access Control (RBAC) [14]. Although access control is useful to specify who can access which information, it cannot protect sensitive information against legitimate users. Access control is concerned with the release of information but not its propagation. It provides a guarantee that information is released only to authorised users. However, once information is released to authorised users, it might be leaked maliciously or accidentally to unauthorised users without any further control. Information flow control is a complementary approach to access control to prevent information leakage. It tracks how information propagates through a program during execution to ensure the program does not leak sensitive information.
http://dx.doi.org/10.1016/j.entcs.2017.04.002
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Information flow control can be enforced statically [4,5,15,16] or dynamically [13,2]. The former analyses information flow within a program prior to executing, while the latter analyses information during the execution. The dominant approach for enforcing secure information flow statically is the use of type systems.
This paper presents a novel approach of using a type system to solve the prob- lem of accidental misuse of shared files by trusted authorised users. Such misuse occurs, for example, when a trusted authorised user accidentally disseminate a file to unauthorised users, write to a file that is meant be read only, or copy a file that is meant to be read once, after which the file should be erased. Hence, misuse is action that violates files policies. We design a language of commands to manipu- late files and specify their policies in a Unix-like file system, and a type system to enforce these policies. In this setting, files are associated with security types that represent security policies, and programs are sets of commands to be issued on files such as read, copy, move, etc. The type system plays the role of a reference monitor that intercepts and statically analyses each command to be issued on a file and determines whether or not the command is safe to be executed. Safe commands are those which do not cause errors during execution. Such errors might be caused by commands that violate the security policies associated with the files or violate its own requirements (e.g., a file must exist to be removed). Therefore, if commands are type-checked, then files and commands policies are not violated and can be executed safely. In this paper, we focus on enforcing a particular policy, namely, limiting the number of times a file can be read. However, the same basic ideas can be extended to enforce other policies as pointed out in Section 6.
The rest of this paper is organised as follows. Section 2 presents the security types and policies of files. Section 3 describes the language syntax and semantics for manipulating files, defines security errors and an algorithm for checking syntactical errors. Section 4 describes the type system, and includes properties. Section 5 introduces a type checking algorithm and proves its soundness and completeness. In Section 6 we give a brief review of related work, and finally we conclude the paper in Section 7.

Security Types and Policies
Our approach to limiting the number of times a file can be read is by limiting the number of copies the file can produce. Therefore, a file can be read as much as it can be copied. If a file cannot be copied, then it can be read once. To enforce this policy, we need to restrict the access to copy operations and restrict the information flow caused by all operations such that restrictions of files over copy operations are not violated. To control the access to copy operations on files we define three security types which are UC, LCn, and NC each of which specifies a distinct policy of how copy operations can be performed on them. UC stands for Unrestricted Copy, which means that a file associated with this type can be copied without restriction. The copied version of a file of type UC should be allowed to be copied in the same way, so should also be of type UC. LCn stands for Linear Copy, which means that a

file associated with this type can be copied n number of times, after which the file cannot be copied anymore. However, unlike UC, the copied version of a file of type LCn should not be copied anymore. NC stands for No Copy, which means that a file associated with this type cannot be copied at all. Hence, the copied version of a file of type LCn should be of type NC.
NC




LCn




UC
Fig. 1. Security types

To control the information flow among files, our security copy types form a lattice (τ, ±), where τ = {NC, LCn, UC}, are partially ordered by ± (see Figure 1). NC and UC are the upper bound and the lower bound of the set τ , respectively. The least restrictive type is UC, while the most restrictive type is NC. Therefore, information is allowed only to flow upwards in the lattice, which means from the less restrictive type to the more restrictive. It should be noted that LCn ± LCn′ if and only if n ≥ nj. To formally state the policies we need to enforce, we define the following functions and notations. The function dst stands for destination, for a given type of a file, the function dst finds the appropriate type for the copied version of that file. That is, dst(UC) = UC and dst(LCn) = NC ⇐⇒ n > 0. The function red stands for reduction, for a given type of a file, the function red reduces that type if needed when it is copied. It is mainly useful for the type LCn to limit the number of times the type can be copied. That is, red(UC) = UC and red(LCn) = LCn—1 ⇐⇒ n > 0. Note that we do not define dst(LCn≤0) nor dst(NC) or red(LCn≤0) and red(NC), because files of these types are not allowed to be copied, and hence, applying the functions on them should result in an error. Let T (f ) denotes the type associated with the file f , and T (f1) HT (f2) denotes the least upper bound of the types of f1 and f2. That is, if T (f1) = NC and T (f2) = UC, then T (f1) H T (f2)= NC. Let f1 →copy f2 denotes a flow of information from f1 to f2 caused by copy operation, f1 →o f2 denotes a flow of information caused by other operations than copy, such as mv, cat, etc., and f1 ∈ types denotes f1 is associated with a security type. Below we give the definitions of the policies to be enforced by our type system.
Definition 2.1 6f1, f2 ∈ types. f1 →o f2 is always allowed, provided that f2 must change its type to T (f1) H T (f2) and f1 must be consumed after performing the operation.
Definition 2.2 6f1, f2, f3 ∈ types. f1, f2 →o f3 is always allowed, provided that f3 must change its type to T (f1) H T (f2) H T (f3) and f1 and f2 must be consumed after performing the operation.

Definition 2.3 6f1, f2 ∈ types. f1 →copy f2 is allowed if and only if T (f1) ∈
{UC, LCn>0}, and f2 must change its type to dst(T (f1)) HT (f2) and f1 must change its type to red(T (f1)) after performing the operation.
It should be noted that when a file is consumed, the file must not be available for any subsequent operations (i.e.the file must be erased). Next we present our language syntax and semantics, define the notion of security errors, and an algorithm for checking syntactical errors.
Language Syntax and Semantics.
Let ⟨f⟩ be a set of valid files names for a given file system. The syntax of the language is given by the following grammar:
⟨p⟩ ::= ⟨cs⟩| ⟨f⟩
⟨cs⟩ ::= ⟨c⟩| ⟨c⟩; ⟨cs⟩
⟨c⟩  ::= cp ⟨f⟩ ⟨f⟩| rm ⟨f⟩| mkf ⟨f⟩ ⟨t⟩| rd ⟨f⟩| cat ⟨f⟩ ⟨f⟩ ⟨f⟩| mv ⟨f⟩ ⟨f⟩
⟨t⟩  ::= NC | LCn | UC
The language above consists of phrases. A phrase is either a list of commands (cs) or a file name (f ). Commands can be either a single command (c) or a se- quence of commands (c ; cs). We include commands to copy, remove, make, read, concatenate and move files. These commands operate on a file system δ that we represent as a set of files. A file has a name, content and a type, and we write f (c) : τ for a file with name f , content c and type τ . For example, δ = {f1(c1) : τ1, f2(c2) : τ2,..., fn(cn) : τn}. In later sections we might refer to δ as the set of file names only (e.g., δ = {f1, f2,..., fn}) or the set of file names with types only (e.g., δ = {f1 : τ1, f2 : τ2,..., fn : τn}). It should be apparent from the context which δ we mean. We use the following notations: C(f ) and T (f ) denote the content of file f and the type of file f , respectively. C(f1)+ C(f2) and T (f1) H T (f2) denote concatenating the content of f1 and f2, and the join of the types of f1 and f2, respectively. We write δ[f2 → C(f1)] for updating f2 with the content of f1 in the file system δ, and δ[f2 → T (f1)] for updating f2 with the type of f1 in δ. Both operations require that f1 and f2 must exist in δ. We write δ[−f ] to remove f from δ if f exists in δ, and δ[+f ] to add f to δ if f does not already exist in δ. We write δ[f3 → C(f1)+ C(f2)] for updating f3 with the concatenated content of f1 and f2, and δ[f3 → T (f1) H T (f2)] for updating f3 with the join of the types of f1 and f2. Both operations require that f1, f2 and f3 must exist in δ. Finally, we write ⟨c, δ⟩ → δj for evaluating the command c in δ that yields a new file system δj. For example, if δ = {f1(c1) : τ1, f2(c2) : τ2}, then ⟨rm f1, δ⟩ → {f2(c2) : τ2}, ⟨mv f1 f2, δ⟩ → {f2(c1) : T (f1) H T (f2)}, and
⟨append f1 f2 f3, δ⟩→ {f3(C(f1)+ C(f2)) : T (f1) HT (f2)}. If any of the constraints
of the operations applied to δ are not satisfied, then evaluating the configuration
⟨c, δ⟩ should lead to an error, written as ⟨c, δ⟩ → Err. Note that a sequence of operations can be applied to δ in order from left to right. For example, the notation

δ[+f, −f ] denotes adding file f first and then removing the file f from δ. We can now put all these ideas together to give the semantics of commands in terms of evaluation rules. These are given below.
⟨cp f1 f2 ,δ ⟩→ δ[f2 → C(f1)][f2 → T (f2) H dst(T (f1))][f1 → red(T (f1))]
⟨rm f, δ⟩→ δ[−f ]
⟨mkf f t, δ⟩→ δ[+f ][f → t]
⟨rd f, δ⟩→ δ[−f ]
⟨cat f1 f2 f3, δ⟩→ 
δ[f3 → C(f1)+ C(f2)][f3 → T (f1) H T (f2) H T (f3)][−f1, −f2]
⟨mv f1 f2 ,δ ⟩→ δ[f2 → C(f1)][f2 → T (f1) H T (f2)][−f1]
From the single-step transitions, we can define the semantics of sequences of commands as the (small-step) operational semantics as shown below:

⟨c, δ ⟩⇒ δj
⟨c; cs, δ⟩⇒ ⟨cs, δj⟩ (ecs)
⟨c, δ ⟩→ δj


⟨c, δ⟩⇒ δj
(ec)

We write ⇒∗ as usual for the reflexive and transitive closure of ⇒. Therefore, a sequence of commands can be computed by: ⟨c, δ⟩ ⇒∗ δj.
Security Errors
Security errors can be divided into syntactical errors and type errors. Syntactical errors occur when the constraints of an operation applied to δ are not satisfied. For example, if δ = {f1(c1): τ1, f2(c2): τ2}, then evaluating the configuration ⟨rm f4, δ⟩ should lead to an error, that is ⟨rm f4, δ⟩ → Err, because the operation δ[−f4] requires f4 to exist in δ. On the other hand, type errors occur when the constraints a function applied to a type of a file are not satisfied. For example, if T (f1) = NC, then
⟨cp f1 f2, δ⟩ → Err, because the function dst(NC) results in an error. Syntactical and type constraints are shown in Table 1 and 2. It can be seen that content update operations in Table 1 (i.e. δ[f2 → C(f1)] and δ[f3 → C(f1)+ C(f2)]) require files names to be distinct. Such constraint is very important to rule out errors that result from evaluating configurations such as ⟨cat f1 f1 f3, δ⟩, which erases f1 twice, and to rule out accidental erasure of files that result from evaluating configurations such as ⟨cat f1 f2 f1, δ⟩ and ⟨mv f1 f1, δ⟩, which have the same effect as evaluating the configuration ⟨rm f1, δ⟩. Next we present our algorithm for checking syntactical errors.
Syntactical checking for correctness
An occurrence of a file name in a command determines whether or not the command can be successfully evaluated in a particular file system δ. Some commands, such as (rm f ), require the file name to exist in δ, while others, such as (mkf f t), require them to not exist. Checking commands individually with respect to a particular


Table 2
Constraints of operations applied to types
Table 1
Constraints of operations applied to δ
file system does not work however. For example, consider the file system δ =
{f1(c1): τ1, f2(c2): τ2}, then the configuration ⟨rm f1; rm f1, δ⟩ will fail to evaluate because the first command will remove f1 from δ so that the second will generate an error. A similar situation arises with the configuration ⟨mkf f3 t; mkf f3 t, δ⟩. In this case, the first command will succeed, but the second will fail because the file f3 is already there. Therefore, since command evaluation changes δ, such changes must be considered by subsequent commands when checking occurrences of file names. We define an algorithm to check consistency of commands in the following way. For a given command cs, we compute a 4-tuple (H, N, C, E) that gives the constraints on a starting file system δ so that it can execute without errors. H denotes the set of file names that must exist in δ, N denotes the set of file names that must not exist in δ. C denotes the set of file names that are created by the sequence of commands, such file names do not necessarily have to be in δ initially. E denotes the set of file names that are erased by the sequence of commands, so such files do not necessarily have to be free in δ initially. Table 3 gives the heart of the algorithm. We write c(H, N, C, E)= (Hj,Nj, Cj, Ej) if an atomic command c satisfies the conditions in the table, where (Hj,Nj, Cj, Ej) are the sets updated by the command c. Sequences of commands are then computed by composition: c; cs(H, N, C, E)= cs(c(H, N, C, E)). The algorithm starts with (∅, ∅, ∅, ∅).
Table 3
Algorithm for syntactically checking commands

An example of using the algorithm is the command cp f1 f2:
cp f1f2 (∅, ∅, ∅, ∅)= ({f1, f2}, ∅, ∅, ∅).
This means that the files {f1, f2} must be part of the file system when this

command is executed. A second example is a sequence of commands mkf f1 t; rm f1:
mkf f1 t; rm f1(∅, ∅, ∅, ∅) = rm f1(mkf f1 t(∅, ∅, ∅, ∅)) Since f1 ∈/ C, then
= rm f1(∅, {f1}, {f1}, ∅) and since f1 ∈/ E, then
= (∅, {f1}, ∅, {f1})
This means that there are no files needed in δ to execute these commands success- fully, and if there are any files, then the file name f1 cannot be used. When a command does not satisfy the conditions in the table, the algorithm fails. Consider a sequence of commands mkf f1 t; mkf f1 t:
mkf f1 t; mkf f1 t(∅, ∅, ∅, ∅) = mkf f1 t(mkf f1 t(∅, ∅, ∅, ∅)) Since f1 ∈/ C
= mkf f1 t(∅, {f1}, {f1}, ∅)
however, since the condition f1 ∈/ C is not satisfied, then mkf f1 t(∅, {f1}, {f1}, ∅) fails. Similarly, a sequence of commands such as rm f1; rm f1:
rm f1; rm f1(∅, ∅, ∅, ∅)) = rm f1(rm f1(∅, ∅, ∅, ∅)). Since f1 /∈ E, then
= rm f1({f1}, ∅, ∅, {f1})
however, since the condition f1 /∈ E is not satisfied, then, rm f1({f1}, ∅, ∅, {f1}) should fail. Table 3 captures the idea that any file name of a command that needs to be in δ must not have been removed by previous commands and any file name of a command that needs not to be in δ must not have been created by previous commands. Furthermore, file names of a command must be distinct. We can relate these syntactical constraints with the operational semantics through the following result which states that if the file system satisfies the constraints needed for a command as set out above, then it will execute successfully (i.e., without error). Essentially, this key result gives the constraints on the file system: which files must be present, and which files must not be present.
Theorem 3.1 For any command sequence cs, if cs(∅, ∅, ∅, ∅) = (H, N, C, E), then for any ﬁle system δ, if H ⊆ δ and N ∩ δ = ∅, then there exists a ﬁle system δj such that ⟨cs, δ⟩ ⇒∗ δj.
Type System
Now we present the type system that will check commands to ensure they are free of syntactical and type errors before execution. Typing judgements have the form Γ | Γj ▶ p : τ where Γ is a list of files with types of the form f : τ . We write ∅ for the empty list. For example, Γ = f1 : τ1, f2 : τ2, f3 : τ3,..., fn : τn. It should be noted that files in the context Γ are unique and the symbol “,” is the disjoint union operation, so that the list of files in Γ does not contain repetitions. The judgement Γ | Γj ▶ p : τ means that typing the phrase p of type τ in the context Γ, will change the context to Γj. In other words, the contexts Γ and Γj represent the set of files before and after typing the phrase p. Note that a phrase p could be a command or

a file name. The typing rules are shown in Figure 2. Rule (f ) says that typinga file from the context Γ consumes the file from the context. Rule (cs) says that if typing the command c of type void changes the context Γ to Γj and typing the command cs of type void changes the context Γj to Γjj, then typing these commands in sequence changes the context Γ to Γjj. Rule (cp) says that if we can type f1 and f2 from the context Γ and f1 is of type UC or LCn>0, then we can type the command cp f1 f2 of type void and the type of f2 is changed to be the least upper bound of its type and the type of dst(f2) and the type of f1 is changed to be the type of red(f1). Rules (rm) and (rd) say that if we can type f from the context Γ, then we can type the command rm f of type void and the command rd f of type void, respectively. Rule (mkf) says that typing the command mkf f t of type void will add f of type t to the context Γ. Rule (cat) says that if we can type f1, f2 and f3 from the context Γ, then we can type the command cat f1 f2 f3 of type void and f1 and f2 will be consumed from the context Γ while the type of f3 is changed to be the least upper bound of its type, the type of f1 and the type of f2. Rule (mv) says that if we can type f1 and f2 from the context Γ, then we can type the command mv f1 f2 of type void and f1 and will be consumed from the context Γ while the type of f2 is changed to be the least upper bound of its type and the type of f1. Examples of commands derivations are given in Appendix A.



Γ,f : τ | Γ ▶ f : τ
(f )
Γ | Γj ▶ c : void	Γj | Γjj ▶ cs : void Γ | Γjj ▶ c; cs : void

(cs)

Γ | Γj ▶ f1 : τ	τ ± LCn>0	Γj | Γjj ▶ f2 : τ j	Γ | Γj ▶ f : τ
(cp)	(rm)
Γ | Γjj, f1 : red(τ ), f2 : τ j H dst(τ ) ▶ cp f1 f : void	Γ | Γj ▶ rm f : void



Γ | Γ,f : t ▶ mkf f t : void
(mkf)
Γ | Γj ▶ f : τ
Γ | Γj ▶ rd f : void (rd)

Γ | Γj ▶ f1 : τ	Γj | Γjj ▶ f2 : τ j	Γjj | Γjjj ▶ f3 : τ jj

Γ | Γjjj, f3 : τ H τ j H τ jj ▶ cat f1 f2 f3 : void
(cat)

Γ | Γj ▶ f1 : τ	Γj | Γjj ▶ f2 : τ j

Γ | Γjj, f2
: τ H τ j ▶ mv f1
(mv)
f2 : void

Fig. 2. Typing rules


Properties of Type System
We prove the soundness and completeness of our type system with respect to the operational semantics. The soundness property is proved by showing two properties which are preservation and progress. Traditionally, the progress theorem states that a program is either a value or can take a step of evaluation. However, in our case, programs are commands that operate on files in a file system, and should always take a step of evaluation. Therefore, if a command c is typable in a particular file system δ, then the command c must take a step of evaluation.

Theorem 4.1 (Progress) If Γ= δ and Γ | Γj ▶ c : τ, then ⟨c, δ⟩ /→ Err.
Proof. We proceed by cases on typing derivation of c. There are 6 cases, we show only two.
c = cp f1 f2
We know there is a typing derivation for c by using rule (cp) with conclusion: Γ | Γjj, f1 : red(τ ), f2 : τ j H dst(τ ) ▶ cp f1 f2 : void. We must also have subderivations with conclusions: Γ | Γj ▶ f1 : τ , τ ± LCn>0 and Γj | Γjj ▶ f2 : τ j. Now we can use rule (1) to obtain ⟨cp f1 f2 , δ⟩ → δ[f2 → C(f1)][f2 → T (f2) H dst(T (f1))][f1 → red(T (f1))]. Since the configuration ⟨cp f1 f2 , δ⟩ require f1 ∈ δ and f2 ∈ δ and f1 /= f2 to be evaluated without syntactical error, and we have f1 ∈ Γ and f2 ∈ Γ and f1 /= f2 in Γ, because Γ does not allow repetition of file names, and Γ = δ. Then, ⟨cp f1 f2 ,δ ⟩ /→s Err. Also, since the operations dst(T (f1)) and red(T (f1)) requires (T (f1)) ± LCn>0 in δ and we have T (f1) ± LCn>0 in Γ and Γ = δ. Then, ⟨cp f1 f2 ,δ ⟩ /→ Err as required.
c = rd f
We know there is a typing derivation for c by using rule (rd) with conclusion: Γ | Γj ▶ rd f : void. We must also have a sub-derivation with conclusion: Γ | Γj ▶ f : τ . Now we can use rule (4) to obtain ⟨rd f, δ⟩ → δ[−f ]. Since the configuration ⟨rd f, δ⟩ requires f ∈ δ to be evaluated without syntactical error, and we have f ∈ Γ and Γ = δ. Then ⟨rd f, δ⟩ /→ Err.
2

Traditionally, the preservation theorem states that as we evaluated a program, its type is preserved at each evaluation step. However, programs manipulate files and their types, and we need to ensure that types of files are preserved during evaluation. Therefore, if a command is typable in a particular file system δ, then types of files we obtain by typing the command must be preserved in the file system we obtain by evaluating the command. This property shows the consistency of the type system with the operational semantics, that is not only typed commands evaluate without errors, but also the types of files in the file system after evaluating the command correspond to the types of files resulted from typing the commands.
Theorem 4.2 (Preservation) If Γ= δ and Γ | Γj ▶ c : τ, and ⟨c, δ⟩ → δj, then
Γj = δj.
Proof. We proceed by cases on ⟨c, δ⟩→ δj. There are 6 cases, we only show two.
c = ⟨cp f1 f2 ,δ ⟩→ δ[f2 → C(f1)][f2 → T (f2) H dst(T (f1))][f1 → red(T (f1))] We know there is a typing derivation for c by using rule (cp) with conclusion:
Γ | Γjj, f1 : red(τ ), f2 : τ j H dst(τ ) ▶ cp f1 f2 : void. We must also have subderivations with conclusions: Γ | Γj ▶ f1 : τ , τ ± LCn>0 and Γj | Γjj ▶ f2 : τ j. To compress the proof let δj = δ[f2 → C(f1)][f2 → T (f2) Hdst(T (f1))][f1 → red(T (f1))]. Now we have 6 cases based on typing f1 and f2, we show two of

them.
: Γ | Γj ▶ f1 : LCn>0, Γj | Γjj ▶ f2 : UC
In this case, the typing derivation of c must have the form Γ | Γjj, f1 : LCn—1, f2 : NC ▶ cp f1 f2 : void. Let Γj = Γjj, f1 : LCn—1, f2 : NC. Now we know that Γ /= Γj because Γ(f1) /= Γj(f1) and Γ(f2) /= Γj(f2), that is LCn>0 /= LCn—1 and UC /= NC, respectively. We also know that δ /= δj because δ(f1) /= δj(f1) and δ(f2) /= δj(f2), that is LCn>0 /= LCn—1 and UC /= NC, respectively. Since Γ /= Γj because Γ(f1) /= Γj(f1) and Γ(f2) /= Γj(f2), and δ /= δj because δ(f1) /= δj(f1) and δ(f2) /= δj(f2), and Γj(f1) = δj(f1) that is LCn—1 = LCn—1 and Γj(f2) = δj(f2) that is NC = NC, and Γ = δ. Then, Γj = δj as required.
: Γ | Γj ▶ f1 : LCn>0, Γj | Γjj ▶ f2 : NC
In this case, the typing derivation of c must have the form Γ | Γjj, f1 : LCn—1, f2 : NC ▶ cp f1 f2 : void. Let Γj = Γjj, f1 : LCn—1, f2 : NC. Now we know that Γ /= Γj because Γ(f1) /= Γj(f1), that is LCn>0 /= LCn—1. We also know that δ /= δj because δ(f1) /= δj(f1), that is LCn>0 /= LCn—1. Since Γ /= Γj because Γ(f1) /= Γj(f1), and δ /= δj because δ(f1) /= δj(f1), and Γj(f1)= δj(f1), that is LCn—1 = LCn—1 and Γ = δ. Then, Γj = δj as required.
c = ⟨rm f, δ⟩→ δ[—f ]
We know there is a typing derivation for c by using rule (rm) with conclusion: Γ | Γj ▶ rm f : void. We must also have sub-derivation with conclusion: Γ | Γj ▶ f : τ . We know that Γ /= Γj because f /∈ Γj. We also know that δ /= δ[—f ] because f /∈ δ[—f ]. Since Γ /= Γj because f /∈ Γj and δ /= δ[—f ] because f /∈ δ[—f ], and Γ = δ. Then, Γj = δ[—f ] as required.
2
Now we show the completeness property of the type system with respect to the operations semantics. The completeness property is useful since it shows that the operational semantics are not unnecessarily restricted by the type system. That is the type system does not provide false negative results. The completeness theorem states that if a command c can be evaluated in a particular file system δ without an error, then the command c must be typable.
Theorem 4.3 (Completeness) If ⟨c, δ⟩ /→ Err and Γ = δ, then Γ | Γj ▶ c : τ
for some Γj.
Proof. We proceed by cases on commands c. There are 6 cases, we show only two.
c = cp f1 f2
If ⟨cp f1 f2, δ⟩ /→ Err, then it must be the case that f1 /= f2, f1 Λ f2 ∈ δ and δ(f1) ∈ {UC, LCn>0}. Therefore, since Γ = δ, we know there is a typing derivation for f1 and f2, and Γ(f1) ∈ {UC, LCn>0}:

(f )
Γ | Γ — {f1}▶ f1 : τ
Γ | Γ — {f }▶ f : τ j (f )

Now by the (cp) rule, there is also a derivation:
Γ | Γ — {f1}▶ f1 : τ	τ ± LCn>0	Γ — {f1}| Γ — {f1, f2}▶ f2 : τ j

Γ | Γ — {f ,f } + {f : red(τ ),f : τ j H dst(τ )}▶ cp f f : void
(cp)

c = rd f
1	2	1	2	1  2

If ⟨rd f, δ⟩ /→ Err, then it must be the case that f ∈ δ. Therefore, since Γ= δ, we know there is a typing derivation for f :
(f )

Γ | Γ — {f}▶ f : τ
Now by the (rd) rule, there is also a derivation:
Γ | Γ — {f}▶ f : τ


Γ | Γ — {f}▶ rd f : void


(rd)
2

It is useful to show that commands in our language are monotonically increasing, in the sense that types of files never decrease during commands evaluation. This is a straightforward property since we only allow commands to change a type of a file to be the least upper bound of its type and the source type. Since the least upper bound of any two types will be at least as restrictive as both of them, types of files will never decrease.
Theorem 4.4 (Monotonicity of files types) If Γ | Γj ▶ c : τ, then 6f, fj ∈
Γ Λ Γj, if Γ(f ) ± Γ(fj), then Γj(f ) ± Γj(fj)
Typing Algorithm
Here we give an algorithm f for typing commands. We define a number of helper functions: check(α, β) returns true if the types are compatible. Note that any two different base types are not compatible, e.g., check(LCn, void) will fail. less(τ, τ j) returns true if τ ± τ j. lub(τ, ..., τn) returns the least upper bound of all its param- eters i.e., τ H ... H τn. Using these functions, we can now define the type checking algorithm f :


where:
f (A, e)= (τ, Aj)

If e is the filename f , and f : α ∈ A then τ = α, Aj = A z {f : α}.
If e is a sequence of commands, c; cs let
(β, A1)	= f (A, c)
check(β, void)
(α, A2)	= f (A1, cs)
check(α, void)
then τ = void, Aj = A2.

If e is the command cp f1 f2 let
(β, A1)	= f (A, f1)
less(β, LCn>0)
(α, A2)	= f (A1, f2)
then if f1, f2 /∈ A2, then τ = void, Aj = A2 ∪ {f1 : red(β), f2 : lub(α, dst(β))}.
If e is the command rm f let (α, A1)= f (A, f ), then τ = void, Aj = A1.
If e is the command mkf f t, then if f /∈ A, then τ = void, Aj = A ∪ {f : t}.
If e is the command rd f let (α, A1)= f (A, f ), then τ = void, Aj = A1.
If e is the command cat f1 f2 f3 let
(β, A1) = f (A, f1)
(α, A2) = f (A1, f2)
(δ, A3) = f (A2, f3)
then if f3 /∈ A3, then τ = void, Aj = A3 ∪ {f3 : lub(β, α, δ)}.
If e is the command mv f1 f2 let
(β, A1) = f (A, f1)
(α, A2) = f (A1, f2)
then if f2 /∈ A2, then τ = void, Aj = A2 ∪ {f2 : lub(β, α)}.

Properties of Algorithm f
If f finds a type for a command, then there is a derivation for that command. This property is called soundness, and means that the algorithm will not give wrong an- swers. We first prove soundness, then show that the algorithm can find all deriva- tions, a property called completeness.
Theorem 5.1 (Soundness of f ) If f (A, e) succeeds with (τ, Aj), then there is a derivation ending in A | Aj ▶ e : τ.
Proof. We proceed by induction on the structure of the command e. There are 8 cases, here we show a selection of them.
If e is the filename f and f : τ ∈ A ∪ {f : τ}, then f (A ∪ {f : τ},f ) succeeds immediately with (τ, A). Using the (f ) rule, there is a derivation ending in A, f : τ | A ▶ f : τ as required.
If e is the sequence of commands c; cs, then f (A, c) succeeds with (β, A1), check(β, void) succeeds, f (A1, cs) succeeds with (α, A2), and check(α, void) also succeeds. Now, by the inductive hypothesis twice, there are derivations A | A1 ▶ c : void and A1 | A2 ▶ cs : void. Using the (cs) rule, there is a derivation A | A2 ▶ c; cs : void as required.

If e is the command cp f1 f2, then f (A, f1) succeeds with (β, A1) and f (A1, f2) succeeds with (α, A2). By the inductive hypothesis twice, there are derivations ending in A | A1 ▶ f1 : β and A1 | A2 ▶ f2 : α. Since less(β, LC), we have β ± LC and now we can use the (cp) rule to give a derivation of A | A2, f1 : β, f2 : α H dst(β) ▶ cp f1 f2 : void as required.
If e is the command rm f , then f (A, f ) succeeds with (α, A1). By the inductive hypothesis, there is a derivation of A | A1 ▶ f : α. Now we can use the (rm) rule to give a derivation of A | A1 ▶ rm f : void as required.
If e is the command mkf f t and f /∈ A, then f (A, (mkf f t)) succeeds im- mediately with (void,A ∪ {f : τ}). Using the (mkf) rule, there is a derivation A | A, f : t ▶ mkf f t : void as required.
2


Theorem 5.2 (Completeness of f ) If there is a derivation ending in A | Aj ▶
e : τ, then f (A, e) succeeds with (τ, Aj).


Proof. We proceed by induction on the structure of the command e. There are 8 cases, here we show a selection of them.
If e is the file name f and f : τ ∈ A ∪ {f : τ}, then by (f ) rule, there is a derivation ending in A, f : τ | A ▶ f : τ . Now, f (A ∪ {f : τ},f ) succeeds with (τ, A) as required.
If e is the sequence of commands c; cs, then by (cs) rule there is a derivation ending in A | A2 ▶ c; cs : void which consists of two derivations: A | A1 ▶ c : void and A1 | A2 ▶ cs : void. By the induction hypothesis twice, f (A, c) succeeds with (void, A1) for the first derivation and f (A1, cs) succeeds with (void, A2) for the second derivation. Now f (A, (c, cs)) succeeds with (void, A2).
If e is the command cp f1 f2, then by (cp) rule, there is a derivation ending in
A | A2, f1 : β, f2 : α H dst(β) ▶ cp f1 f2 : void which consists of two derivations:
A | Aj ▶ f1 : β and A | A2 ▶ f2 : α. By the induction hypothesis twice and
since β ± LC we have less(β, LC), f (A, f1) succeeds with (β, A1) for the first derivation, and f (A1, f2) succeeds with (α, A2) for the second derivation. Now f (A, (cp f1 f2)) succeeds with (void, A2 ∪ {f1 : β, f2 : lub(α, dst(β))}).
If e is the command rm f , then by (rm) rule there is a derivation ending in A | A1 ▶ rm f : void which consists of one derivation: A | A1 ▶ f : β. by the induction hypothesis, f (A, f ) succeeds with (β, A1). Now f (A, (rm f )) succeeds with (void, A1).
If e is the command mkf f t and f /∈ A, then by (mkf) rule, there is a derivation ending in A | A, f : τ ▶ mkf f t : void. Now, f (A, (mkf f t)) succeeds with (void,A ∪ {f : τ}) as required.
2

Related Work and Discussion

Denning [5] pioneered the use of static analysis to identify if the information flow of a program satisfies an application-specific confidentiality policy. Following their work, many security type systems have been developed [1,8,17] beginning with Volpano et al. [15] and Volpano and Smith [16] who were the first to formulate Denning’s secure information flow analysis [4,5] as a type system and prove its soundness. The intuition is that secure information flow is guaranteed for a program if the program is type-checked correctly. A comprehensive survey of the large body of work on this aspect, can be found in [12].
The majority of security type systems focus on enforcing a property known as non-interference [6,15,12,11]. Non-interference for confidentiality requires that pub- lic output is independent from secret input, and for integrity requires that trusted output is independent from untrusted input. However, non-interference is a very re- strictive property since it does not allow downgrading of security levels from high to low which in practice is needed in many applications. We take a different approach to non-interference, and define our security property as the absence of run-time er- rors which are raised by commands that violate files policies. In this way we could easily augment our language with commands that declassify the security levels of information and allow owners of files to execute such commands. Hence, executing such commands by a user who is not an owner should lead to an error.
Furthermore, enforcing non-interference can only control how information flows from one security level to another; but cannot control how information at a par- ticular security level is manipulated [10,3]. For example, regardless of the security level assigned to a variable, the variable can be read, concatenated with itself and saved back as long as these operations only manipulate the variable at the same security level assigned to it. This is because conventional security levels represent only information flow policies which restrict the information flow but not the op- erations which cause such flow. Our security types, however, represent both access control and information flow policies which restrict the operations to be performed on types and the information flow caused by performing the operations.
Broadly, two kinds of information flow policies can be enforced, based on whether the type system is flow-insensitive or flow-sensitive. In flow-insensitive type systems, such as in [15], variables are assigned fixed security levels. Information can flow from variable y to variable x if and only if ly ± lx, that is the security level of x is at least as restrictive as the security level of y. On the other hand, in flow-sensitive type systems [8], information can flow from variable y to variable x without the restriction ly ± lx. However, the security level of x must be changed to be the same as the security level of y after the flow of information.
The information flow policy enforced by our type system is somewhere in between the flow policies enforced by flow-insensitive and flow-sensitive type systems. We follow the idea of flow-insensitive type system in that flow of information must only result in more restrictive type of information while we follow the idea of flow- sensitive type system in that information can flow any where and the security types

can be changed during computation. This can be achieved by allowing information to flow from a security τ1 to any security type τ2, provided that the security type τ2 is changed to the least upper bound of τ1 and τ2 (i.e., τ1 H τ2), after the flow of information. Since 6τ, τ j ∈ f , τ ± τ H τ j, where f is lattice of security types, any information flow is considered a restriction as long as the destination changes its type to the least upper bound of its type and the source type. This is because the least upper bound of two types is always more restrictive than each of them separately. In this way we benefit from the flexibility flow-sensitive type systems of and the restrictiveness of flow-insensitive type systems.
Types of files are not necessarily stored with file names and contents in the file system δ. They can be separated from δ and stored in a different location (e.g., Δ) and fetched upon request by the type system. For example, δ will be the set of file names with contents (e.g., {f1(c1),..., fn(cn)}) and Δ will be the set of file names with types (e.g., {f1 : τ1,..., fn : τn}). For checking commands that need to be executed, the type system makes Δ to be the typing context to begin with. Once all the commands are type-checked correctly, the resulting typing context after the checking (e.g., Γj) should replace the types of files stored in Δ. In this way, we could have an untyped operational semantics that relies solely on the safety guarantee given by the type system. In fact, the reason for having typed operational semantics is just to simplify the soundness proof of the type system—once we have established this result, we can optimise these out.
The type system developed in this paper is only concerned with copy operations. This is because it enforces the number of times a file can be read by limiting the number of copies a file can produce. Therefore, the defined security types in this paper specify policies that restrict the access to copy operations (access control policy), and restrict the information flow caused by all operations including copy, such that copy policies of files are not violated (information flow policy). Other policies can be enforced similarly by defining new security types that restrict the access to the relevant operations and the flow caused by them. For example, to specify policies that restrict the access to read and write operations which are caused by rd, cat, cp and mv operations, we can define the following security types NRW, RO, WO—, WO+, RW—, RW+. NRW stands for NoReadOrwrite, RO stands for ReadOnly, WO stands for WriteOnly, and RW stands for ReadWrite. The symbol (+) means a file of this type cannot be overwritten while the symbol (—) means a file of this type can be overwritten. Since we can only write to a file of type RW or WO, these symbols are associated only with them. Hence the typing rule should restrict rd operation to be performed on a file of type ± RO, cat operation to be performed on source files of type ± WO+ and a destination file of type ± WO—, cp operation to be performed on destination file of type ± WO—, and mv operation to be performed on destination file of type ± WO—. To restrict the flow of information caused by these operations such that policies for read and write operations are not violated, we let these types form a lattice of security types (τ, ±) where τ = {NRW, RO, WO—, WO+, RW—, RW+}, are partially ordered by ± (see Figure 3). Hence, information can only flow from less restrictive types to more

restrictive types.
NRW
RO	WO+
		
RW +	WO−
	
RW −
Fig. 3. Security access types

Conclusion
In this paper we have presented our approach to prevent accidental misuse of the shared files. The focus was on enforcing a particular policy, namely limiting the number of times a file can be read. This is achieved by developing a type system that controls the access to copy operations and the flow caused by all operations including copy, such that the policies for copying files are not violated. The type system plays the role of a reference monitor that intercepts each command and checks whether or not the command will cause run-time errors. Run-time errors are caused by executing commands that violate files policies. Therefore, type-checked commands are safe to be executed since they do not cause any policy violation. We have proven the soundness and completeness of the type system with respect to the operations semantics and define a type checking algorithm that is shown to be sound and complete.
The language and the type system presented in this paper is kept to a minimum to avoid complexity in presenting our approach. Various extensions useful in prac- tice including conditionals, loops, recursion, and variables are left for future work. We aimed to start this line of research with a very simple language with the desired properties and then extending it while ensuring these properties are still preserved. In future work we aim to extend the language with various features and the type system to enforce different kinds of policies useful in practice.
So far we have taken a significant step towards realising these features. In particular, we extended the type system to enforce additional policies to control read and write operations. By defining a new set of security types to control read and write operations, we found that the same typing rules presented in this paper with a few additional constraints can be used to enforce the new policies. Therefore, we have added these additional constraints to the current type system and defined security types of files as pairs that consist of a security copy type and a security access type. The former type represents a policy to control the access and flow of copy operations; and the latter type represents a policy to control the access and flow of read and write operations. The resulting type system controls the access to copy, read and write operations and the flow caused by all operations.

We have also extended the policies of files to specify which operations can be performed on which types of files and by whom. We have done this by defining security types of files as labels that not only consist of a security copy type and a security access type, but also of ownership and authorisation information. The ownership and authorisation information in a label indicates the owners and the authorised users of a file associated with the label. Based on the definition of labels, we extended the type system to not only control the access and flow of operations but also control which user can perform these operations. Furthermore, we have also looked at possible extensions to allow owners to manipulate their files policies. Thus, we extended the commands in our language to include commands that manipulate file policies. Accordingly, we extended the type system with typing rules for these commands along with a typing algorithm for typing phrases.
While the extensions described above have been added to our current work, they are still missing an important aspect. Further investigation and formal proofs their properties are required. We are currently developing various proofs of the extended system to ensure the desired properties of the system are still preserved.

References
M. Abadi. Secrecy by typing in security protocols. J. ACM, 46(5):749–786, Sept. 1999.
T. H. Austin and C. Flanagan. Efficient purely-dynamic information flow analysis. SIGPLAN Not., 44(8):20–31, Dec. 2009.
A. Birgisson, A. Russo, and A. Sabelfeld. Unifying facets of information integrity. In S. Jha and
A. Mathuria, editors, ICISS, volume 6503 of Lecture Notes in Computer Science, pages 48–65. Springer, 2010.
D. E. Denning. A lattice model of secure information flow. Commun. ACM, 19(5):236–243, May 1976.
D. E. Denning and P. J. Denning. Certification of programs for secure information flow. Commun. ACM, 20(7):504–513, July 1977.
J. A. Goguen and J. Meseguer. Security policies and security models. In IEEE Symposium on Security and Privacy, pages 11–20, 1982.
M. A. Harrison, W. L. Ruzzo, and J. D. Ullman. Protection in operating systems. Commun. ACM, 19(8):461–471, Aug. 1976.
S. Hunt and D. Sands. On flow-sensitive security types. SIGPLAN Not., 41(1):79–90, Jan. 2006.
B. W. Lampson. Protection. SIGOPS Oper. Syst. Rev., 8(1):18–24, Jan. 1974.
P. Li, Y. Mao, and S. Zdancewic. Information integrity policies. In Proceedings of The Workshop on Formal Aspects in Security and Trust (FAST), 2003.
J. Mclean. Security models and information flow. In In Proc. IEEE Symposium on Security and Privacy, pages 180–187. IEEE Computer Society Press, 1990.
A. Sabelfeld and A. C. Myers. Language-based information-flow security. IEEE Journal on Selected Areas in Communications, 21(1):5–19, 2003.
A. Sabelfeld and A. Russo. From dynamic to static and back: Riding the roller coaster of information- flow control research. In A. Pnueli, I. Virbitskaite, and A. Voronkov, editors, Ershov Memorial Conference, volume 5947 of Lecture Notes in Computer Science, pages 352–365. Springer, 2009.
R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman. Role-based access control models.
Computer, 29(2):38–47, Feb. 1996.

D. Volpano, C. Irvine, and G. Smith. A sound type system for secure flow analysis. J. Comput. Secur., 4(2-3):167–187, Jan. 1996.
D. M. Volpano and G. Smith. A Type-Based Approach to Program Security. In TAPSOFT, pages 607–621, 1997.
L. Zheng and A. C. Myers. Dynamic security labels and static information flow control. Int. J. Inf. Sec., 6(2-3):67–84, 2007.
