Electronic Notes in Theoretical Computer Science 171 (2007) 37–57	
www.elsevier.com/locate/entcs

Intruder Deduction for the Equational Theory of Exclusive-or with Commutative and Distributive Encryption
Pascal Lafourcade
Information Security ETH Zentrum, IFW C41.2 Haldeneggsteig 4 CH-8092 Zürich Switzerland

Abstract
The first step in the verification of cryptographic protocols is to decide the intruder deduction problem, that is the vulnerability to a so-called passive attacker. We extend the Dolev-Yao model in order to model this problem in presence of the equational theory of a commutative encryption operator which distributes over the exclusive-or operator. The interaction between the commutative distributive law of the encryption and exclusive-or offers more possibilities to decrypt an encrypted message than in the non-commutative case, which imply a more careful analysis of the proof system. We prove decidability of the intruder deduction problem for a commutative encryption which distributes over exclusive-or with a DOUBLE-EXP-TIME procedure. And we obtain that this problem is EXPSPACE-hard in the binary case.
Keywords: Cryptoprotocal verification, Dolev-Yau model, intruder detection problem


Introduction
Today, the number of interactive services proposed on the Internet is exploding. Most of them use cryptographic protocols to guarantee some level of security. They can be seen as relatively simple programs which are executed in an unsecure envi- ronment. There are different approaches for modeling cryptographic protocols and analyzing their security properties. One of them is the approach of Dolev and Yao [12], which models the attacker capabilities by a deduction system. This model is often used to analyze the security of protocols against a passive attacker, i.e an in- truder which obtains information by eavesdropping on the communications between honest participants and deduces some information from these messages. The ques- tion whether a passive attacker gets a certain information from observed messages on the network is called the intruder deduction problem.

1 This work was partially supported by the DGA (Contrat n◦ 06 60 019 00 470 75 01), the research program ACI-SI Rossignol, and the project RNTL PROUVÉ (n◦ 03 V 360).

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.054

Algebraic Properties: Usually the capabilities of the intruder are based on the so-called perfect cryptography assumption, i.e. it is impossible to obtain any information about an encrypted message without knowing the exact key necessary to decrypt this message. Unfortunately, this perfect cryptography assumption is too idealistic: There are protocols which can be proved secure under the perfect cryptography assumption, but which are in reality insecure since an attacker can use properties of the cryptographic primitives in combination with the protocol rules to learn some secret informations (see [2] for a survey). It is necessary to relax this assumption by increasing the deductive power of the intruder. One possibility is to add the capability to take into account some algebraic properties to model an intruder in a more realistic way, which may find new attacks.
Related Work: Solutions to the intruder deduction problem modulo an equa- tional theory are known for the cases of modular exponentiation [4,17], of exclusive- or, of Abelian groups [6,3], of a homomorphism symbol alone [7], and of combinations of homomorphism and one of the operators of exclusive-or or Abelian groups [13,9]. Another result [5] proves that the so-called active intruder with just a commuta- tive encryption and the classical Dolev-Yao model is decidable. We have already studied in [14] the intruder deduction problem for a non-commutative encryption which distributes over the exclusive-or symbol, denoted ⊕. A natural question is to consider now the case of commutative encryption, i.e. {{u}k1}k2 = {{u}k2}k1, for instance the encryption RSA. Notice that in this case the equational theories of the
⊕ operation and of the commutative encryption operation which distributes over the exclusive-or symbol, i.e. {x ⊕ y}k = {x}k ⊕ {y}k, are not disjointed because they share the encryption symbol function, hence the combination algorithm proposed in [8] can not be applied.
Our contribution: We investigate the intruder deduction problem with the equational theory of a commutative encryption, i.e. {{u}k1}k2 = {{u}k2}k1 which distributes over the exclusive-or i.e. {x ⊕ y}k = {x}k ⊕ {y}k, where exclusive-or has the properties of Associativity, Commutativity, Unity and Nilpotency. The interac- tion between the commutative distributive law of the encryption and exclusive-or of- fers more possibilities to decrypt an encrypted message than in the non-commutative case. The commutativity of encryption requires to define new notions and to find new proof transformations, since one encrypted message can be partially decrypted by several different keys. In the non-commutative case for solving this problem it is enough to construct some normalization of proofs where applications of the exclusive-or rules are applied as early as possible. In the case of the commutative encryption, we have to apply as early as possible the decryption and after as early as possible the exclusive-or. This raises some difficulties that we solve by character- izing new proof notions, constructing transformations to pass from one to another, designing a right set of subterms and proving a normalization of proof to get the result. We obtain a decision procedure in DOUBLE-EXP-TIME for the intruder deduction problem with the equational theory of the exclusive-or and commutative distributive encryption over this operator. We prove also in the particular case of the binary proofs that the intruder deduction problem is EXPSPACE-hard for this

equational theory.
Plan: We recall in Section 2 usual notions required in the rest of the paper. In Section 3 we introduce the extended Dolev-Yao model of intruder capacities. In Section 4 we present the generalization of McAllester’s locality algorithm. In the rest we introduce all required notions to show the locality result in Section 9. Finally in Section 10 we present the binary case and conclude in Section 11.

Preliminaries
We refer the reader to [10,1] for an overview of rewriting.
Let Σ be a signature. T (Σ,X) denotes the set of terms over the signature Σ and the set of variables X, that is the smallest set such that: (i) X ⊆ T (Σ,X), (ii) if t1,... , tn ∈ T (Σ,X), and f ∈ Σ has arity n ≥ 0, then f (t1,... , tn) ∈ T (Σ,X). We abbreviate T (Σ, ∅) as T (Σ); elements of T (Σ) are called Σ-ground terms. The set of variables occurring in a term t is denoted by V(t).
The set of occurrences of a term t is defined recursively as O(f (t1,... , tn)) =
{ϵ}∪  i=1...n i · O(ti). For instance, O(f (a, g(b, x))) = {ϵ, 1, 2, 21, 22}. The size |t| of a term t is defined as its number of occurrences, that is |t| = cardinality(O(t)). We extend the notion of size to a set of terms T by |T | = Σt∈T |t|. If o ∈ O(t) then the subterm of t at position o is defined recursively by:
t |є= t
f (t1,... , tn) |j·o= tj |o
A term r is a subterm of a term t if r is a subterm of t at some position of t.
A Σ-equation is a pair (l, r) ∈ T (Σ,X), commonly written as l = r. The relation
=E generated by a set of Σ-equations E is the smallest congruence on T (Σ) that contains all ground instances of all equations in E.
A Σ-rewriting system R is a finite set of so-called rewriting rules l → r where l ∈ T (Σ,X) and r ∈ T (Σ, V(l)). A term t is in normal form if there is no term s with t → s. If t →∗ s and s is a normal form then we say that s is a normal form of t, and write s = t ↓.
Let T be a set of terms, the mapping S : T → T is idempotent if for every
X ⊆ T : S(S(X)) = S(X). The mapping S is monotone if for all X, Y ⊆ T : if X ⊆ Y then S(X) ⊆ S(Y ). S is transitive if for all X, Y, Z ⊆ T , X ⊆ S(Y ) and Y ⊆ S(Z) implies X ⊆ S(Z). The following Proposition is straightforward.
Proposition 2.1 Let S be a mapping from sets of terms to sets of terms. If S is idempotent and monotone then S is transitive.
A Dolev-Yao Model for Rewriting Modulo AC
We consider the classic model of deduction rules introduced by Dolev and Yao [12] in order to model the deductive capabilities of a passive intruder. We present an extension of this model with the equational theory XCDE (eXclusive-or with a Commutative Distributive Encryption over ⊕).

The knowledge of the intruder is represented by terms built over a finite signature Σ = {⟨·, ·⟩, {·}·, ⊕} Σ0, where Σ0 is a set of constant symbols. The term ⟨u, v⟩ represents the pairing of the two terms u and v. The term {u}K represents the encryption of the term u by a finite multiset of keys K and we consider that {u}∅ = u. For the sake of simplicity, we consider symmetric commutative encryption, all results can be extended to the asymmetric case.
The equational theory XCDE is represented by the following convergent rewriting system R: 0 ⊕ x → x; x ⊕ x → 0; {x ⊕ y}z → {x}z ⊕ {y}z;{0}z → 0 (the last rule is required to get the confluence of R). R is terminating and confluent modulo associativity and commutativity of ⊕, and such that for all terms t, s ∈ T (Σ) we have that t =E s if and only if t ↓ =AC s ↓. The deduction system of Figure 1 corresponds to the deductive capabilities of an attacker considering the equational theory XCDE.

u ∈ T
(A)
T ▶ u ↓
T ▶ u	T ▶ v
(P )
T ▶ ⟨u, v⟩↓ 
T ▶ u	T ▶ K
(C)
T ▶ r
(UL)		if ⟨u, v⟩ = r T ▶ u ↓
T ▶ r
(UR)		if ⟨u, v⟩ = r T ▶ v ↓
T ▶ u1	...	T ▶ un



T ▶ {u}K ↓
T ▶ r	T ▶ K
(D)
T ▶ u ↓

if r =E {u}K
(GX)
T ▶ u1
⊕ ... ⊕ un ↓


Fig. 1. A Dolev-Yao proof system working on normal forms by a rewrite system R modulo AC for a com- mutative encryption, where K = {kα1 ,. .., kαn }is a multiset of keys, where αi represents the multiplicity
1	n
of the keys ki in K.
This proof system is composed of the following rules: (A) the intruder may use any term which is in his initial knowledge, (P ) the intruder can build a pair of two messages, (UL),(UR) he can extract each member of a pair, (C) he can encrypt a message u with a multiset K of keys, (D) if he knows a multiset K of keys then
he can decrypt a message encrypted by K. Let K = {kα1 ,... , kαn } be a multiset
1	n
of keys, the sequent T ▶ K is short for: α1 times the sequent T ▶ k1,... , αn
times the sequent T ▶ kn. Sometimes, we shall annotate the rules (C) and (D) by the multiset of keys that they use, yielding rules (CK ) and (DK ). Because of the algebraic properties of the ⊕ operator, we add a family of rules (GX) which allows the intruder to build a new term from an arbitrary number of already known terms by using the ⊕ operator.
Definition 3.1 A proof P of T ▶ w is a finite tree such that:
every leaf of P is labeled by v ∈ T .
every node of P with n children (n ≥ 1) labeled with T ▶ v1,... ,T ▶ vn, is labeled
T ▶ v1 ... T ▶ vn

with T ▶ v such that
T ▶ v
(R) is an instance of the rule of Figure 1.

the root of P is labeled with T ▶ w.

A sub-proof P ' of a proof P is a sub-tree of P . The size of a proof P is the number of nodes in P , denoted by |P |.
In fact, this proof system is equivalent in deductive power to a variant of the system in which terms are not automatically normalized, but in which arbitrary equational proofs are allowed at any moment of the deduction. The equivalence of the two proof systems has been shown in [7] without AC axioms; and in [13] this has been extended to the case of a rewrite system modulo AC. In the following, all terms are normalized and we omit the normalization symbol ↓.

Locality Result and Complexity
Our starting point is the locality technique introduced by McAllester [15]. He con- siders deduction systems which are represented by finite sets of Horn clauses. He shows that there exists a polynomial-time algorithm to decide the deducibility of a term w from a finite set of terms T if the deduction system has the so-called locality property. A deduction system has the locality property if any proof can be trans- formed into a local proof, that is a proof where all nodes are syntactic subterms of T ∪ {w}. The idea of the proof is to check existence of a local proof by a saturation algorithm which computes all syntactic subterms of T ∪ {w} that are deducible from
T. In [14] we generalize McAllester’s approach, here we just recall the definition of a local proof and the locality Theorem. In the rest of the paper we denote T ∪ {w} by T, w.
Definition 4.1 Let S be a function which maps a set of terms to a set of terms. A proof P of T ▶ w is S-local if all nodes are labeled by some T ▶ v with v ∈ S(T, w). A proof system is S-local if whenever there is a proof of T ▶ w then there is also a S-local proof of T ▶ w.
Theorem 4.2 Let S be a function mapping a set of terms to a set of terms, and P
a proof system. Let T be a set of terms, let w be a term and let n be |T, w|. If:
one-step deducibility of S ▶ u in P is decidable in time g(|S, u|) for any term
u and set of terms S,
the set S(T, w) can be constructed in time f (n),
P is S-local,
then provability of T ▶ w in the proof system P is decidable in time f (n)+ f (n) ∗
f (n) ∗ g(f (n)) (non-deterministic if one of (ii), (i) is non-deterministic).
We say that u is one-step deducible from a set of hypotheses H if there exists
T ▶ r1 ... T ▶ rn

an instance
T ▶ r
(R) of some deduction rule such that r = u and

ri ∈ H. The one-step deducibility is decidable in polynomial time for the equational
theory XCDE. Observe first that all rules of deduction of Figure 1 are binary except the rule (GX) (rule (CK) (resp. (DK )) are shorts for finite number of consecutive applications of rule (Cki ) (resp. (Dki )). For all these binary rules proving the

one-step deducibility takes a polynomial time. For the rule (GX) the problem can reduce to solve system of equations in Z/2Z as in [14]. We illustrate the idea of this reduction, with the following example.
Example 4.3 Let T = {a1 ⊕ a2 ⊕ a3, a1 ⊕ a4, a2 ⊕ a4} and w = a1 ⊕ a2, where every ai contains no ⊕. We introduce one numerical variable x0, x1, x2 for each element of T :

For every element of the sum we create an equation, we get the equation system:

a1 : x0 ⊕ x1 =1 a2 : x0 ⊕ x2 =1 a3 : x0 =0 
a4 : x1 ⊕ x2 =0 
The system has a solution over Z/2Z if and only if w is deducible in one-step from
T by (GX). In this example the system has a solution: x0 = 0, x1 = 1, x2 = 1.
In the rest of the paper, to prove the locality of the deduction system, we define a new notion of subterms (Definition 5.7) and some transformations of proof which enable us to prove that any proof can be transformed into a normal proof. Hence we prove that a normal proof is in fact a local proof in Theorem 9.1, yielding the decidability of the intruder deduction problem, using Theorem 4.2.

Terms and Subterms

Definition 5.1 Let u be a term in normal form, u is headed with ⊕ if u is of the form u1 ⊕ ... ⊕ un with n > 1. Otherwise u is not headed with ⊕. A term u in normal form is called headed with {.}K if u is of the form u = {t}K . Otherwise u is not headed with {.}K . We define the function atoms(u):
If u = u1 ⊕ ... ⊕ un, where each of the ui is not headed with ⊕, then atoms(u)= 
{u1,... , un}. The ui’s are called the atoms of u.
If u is not headed with ⊕ then atoms(u)= {u}.
Example 5.2 t1 = u ⊕ ⟨v, w⟩ is headed with ⊕, but t2 = ⟨u, v ⊕ w⟩ is not, hence atoms(t1)= {u, ⟨v, w⟩} and atoms(t2)= {t2}.
The definition of atoms is generalized to sets of terms T in normal form by setting atoms(T ) :=  t∈T atoms(t). According to the definition, the function atoms

is monotone and idempotent. We denote by P[K] the set of all the partitions of the set K.
Definition 5.3 The set of syntactic subterms of a term t is the smallest set S(t)
such that:
t ∈ S(t).
if ⟨u, v⟩ ∈ S(t) then u, v ∈ S(t).

if {u}	∈ S(t) and K = {kα1 ,... , kαp } then u ∈ S(t) and k
∈ S(t) for all i,

K	1	p	i
1 ≤ i ≤ p.
if u = u1 ⊕ ... ⊕ un ∈ S(t) then atoms(u) ⊆ S(t).
Example 5.4 If u = {a}k1 ,k2,k3 i.e. the term a is encrypted by the keys k1, k2 and
k3 then
S(u) = {u, a, k1, k2, k3, {a}k1 , {a}k2 , {a}k3 , {a}k1 ,k2 , {a}k2 ,k3 , {a}k1 ,k3 }, for instance the term {a}k1 comes from the point (iii) of the previous definition with K =
{k2, k3}.
The definition of S is extended to a set T of terms in normal form by setting S(T ) :=  t∈T S(t). Since the encryption is commutative, the number of subterms of S(T ) is exponential in the size of the set of keys of T (consider all the possible combinations of keys for an encrypted term). In the definition of S(t) we do not take care of the distributivity of encryption. Because we work only on normal forms the notion of a syntactic subterm ignores the fact that the term {a}K ⊕ {b}K ⊕ {c}K is equal to {a ⊕ b ⊕ c}K , and that a ⊕ b ⊕ c should be considered to be a subterm of
{a}K ⊕ {b}K ⊕ {c}K and also all sums encrypted with the set P[K].
Definition 5.5 For any term t, ST (t) is the smallest set such that:
S(t) ⊆ ST (t).

If n > 1, K = {kα1 ,... , kαp } and {u }
⊕...⊕{u }
∈ S (t) then u
⊕...⊕u  ∈

ST (t).
1	p	1 K
n K	T	1	n

By definition S(t) ⊆ ST (t). The definition is extended to a set T of terms in normal form by setting ST (T ) := t∈T ST (t). As in Definition 5.3, Definition 5.5 considers also all the possible combinations of keys for an encrypted sum of terms.
Proposition 5.6 For any set of terms M ⊆ TΣ, we have:
atoms(M ) ⊆ S(M ).
atoms(ST (M )) ⊆ ST (M ).
S(S(M )) = S(M ) and ST (ST (M )) = ST (M ).
Proof. Obvious from the definitions of S, atoms and ST .	 
Definition 5.7 Define S⊕ as all combinations of terms of ST (T ) by ⊕:
S⊕(T ) := (   s) ↓| M ⊆ ST (T ),
s∈M

Note that the size of S⊕ is double-exponential in the size of T and ST (T ) ⊆ S⊕(T ): one exponential for the computation of S(T ) ⊆ ST (T ) and the second exponential for all the partial sums.
Proposition 5.8 Let A and B be two sets of terms in normal form, the mappings
S, ST and S⊕ are monotone and have the property:
S(A ∪ B)= S(A) ∪ S(B).
ST (A ∪ B)= ST (A) ∪ ST (B).
S⊕(A) ∪ S⊕(B) ⊆ S⊕(A ∪ B).
Proof. It is an immediate consequence of the definitions of S(T ), ST (T ) and S⊕(T ). 
Remark: Let A = {a} and B = {b}, S⊕(A) = {0, a} and S⊕(B) = {0, b} then
S⊕(A) ∪ S⊕(B) = {0, a, b} ⊆ S⊕(A ∪ B) = {0,a ⊕ b, a, b} but S⊕(A) ∪ S⊕(B) /=
S⊕(A ∪ B).
Lemma 5.9 Let T be a set of terms then ST (S⊕(T )) = S⊕(T ).
Proof. By definition 5.5, S⊕(T ) ⊆ ST (S⊕(T )). We prove the converse inclusion by induction on the number of applications of the rule for ⊕ in the construction of ST (S⊕(T )) (step (ii) in Definition 5.5). Let u ∈ ST (S⊕(T )), and let n be the number of applications of the rule for ⊕. By induction hypothesis, we assume that each term u' ∈ ST (S⊕(T )) obtained with less than n applications of the rule for ⊕ is in S⊕(T ).
Base case n = 0: u ∈ ST (v) for some v ∈ S⊕(T ), where v = v1 ⊕ ... ⊕ vp and all vi ∈ ST (T ). If u = v then u ∈ S⊕(T ). Otherwise u /= v. In this case u ∈ S(vi) ⊆ ST (vi) for some i (since vi ∈ ST (T ) and S(ST (T )) = ST (T )). Since v ∈ S⊕(T ) there exists a ti ∈ T such that vi ∈ ST (ti). Therefore vi ∈ ST (ti) ⊆ ST (T ) with ti ∈ T , hence u ∈ ST (ST (T )) = ST (T ) ⊆ S⊕(T ) by idempotence of ST .
Induction step: let u = u1 ⊕ ... ⊕ un be obtained from {u1}K ⊕ ... ⊕ {un}K ∈ ST (S⊕(T )). By induction hypothesis {u1}K ⊕ ... ⊕ {un}K ∈ S⊕(T ). Hence there exists a partition I1 ∪ ... ∪ Iq = {1,... , n} such that for every j, 1 ≤ j ≤ q, wj = ⊕i∈Ij {ui}K ∈ ST (tj). Hence, ⊕i∈Ij ui ∈ ST (tj) by definition of ST . As a consequence, u ∈ S⊕(T ).	 
Proposition 5.10 Let M be a set of terms then S⊕(S⊕(M )) = S⊕(M ). The map- pings S, ST and S⊕ are transitive.
Proof. The first point is a consequence of Lemma 5.9 and Proposition 5.6. The second is a consequence of the first point and Propositions 2.1, 5.6 and 5.8. 
All these results will be used implicitly in the rest of the paper.
Different Kinds of Proofs
After a description of the different notions of subterms, we now introduce the dif- ferent proof’s characterizations which is a crucial ingredient in the demonstration of the locality result.

Definition 6.1 Let P be a proof of T ▶ w. P is flat if there is no (GX) (respectively
(C) and (D)) rule immediately above another (GX) (respectively (C) and (D)) rule. P is simple if (1) each node T ▶ v occurs at most once on each branch, (2) each node T ▶ v occurs at most once as hypothesis of a rule (GX), (3) there is no consecutive application of (CK ) and (DK' ) (in either order) if K ∩ K' /= ∅.
Any proof can be transformed into a simple proof since we can always cut some branch or piece of branch of the proof. In any proof we can always merge two consecutive applications of a rule (CK ) (respectively (DK ) and (GX)) and get a flat proof. Hence a flat proof can always be transformed into a flat and simple proof.
Proposition 6.2 Let K and K' be two sets of keys such that K ∩ K' = ∅. Applying the rule (DK ) to a term u and then the rule (CK' ) yields the same result as applying the rule (CK' ) to u and then the rule (DK ).
Proof. The fact that K ∩ K' = ∅ is the key of this result.	 
Intuitively, in a D-eager proof the (D) rule is applied as early as possible and in a ⊕-eager proof the (GX) rule is applied as early as possible.
Definition 6.3 Let P be a proof of T ▶ w. P is a D-eager proof if: (1) there is no hypothesis of a rule (GX) which is headed with {.}K and a rule (DK' ) just after a (GX) such that K ∩ K' /= ∅, (2) there is no (C) just above rule (D). P is a ⊕-eager proof if all the rules (CKi ) immediately above a (GX) in P have Ki ∩ Kj = ∅ for all i, j such that i /= j.
We refine the notion of S-local proof by S(T )-local, where T is the set of terms on which S is applied. A normal proof consists of initial subproofs which are S⊕(T )-local, followed by a proof tree consisting of the rules (GX), (C), (P ) only.
Definition 6.4 Let P be a proof of T ▶ u. P is a normal proof if :
either u ∈ S⊕(T ) and P is an S⊕(T )-local proof,
or P = C[P1,... , Pn] where every proof Pi is a normal proof of some T ▶ vi with vi ∈ S⊕(T ) and the context C is built using the inference rules (P ), (C), (GX) only.

Transformations of Proofs
We modify by successive transformations a proof into a simple flat proof, then into a simple flat D-eager proof, next into a simple flat D-eager ⊕-eager proof and finally into a normal proof. With all these transformations we first apply the rule of decryption, then we make the sum with the (GX) rule to simplify or construct terms to get a normal proof.
Lemma 7.1 Let P be a simple and flat proof of T ▶ w. Then there exists a proof
P ' of T ▶ w such that P ' is a simple, flat and D-eager proof.

Proof. Let P be a simple and flat proof of T ▶ w. We transform this proof into a simple, flat and D-eager proof of T ▶ w by induction on the number of nodes of P . We consider the last rule of the proof, if it is:
(A): the result holds.
(GX), (P ), (UR), (UL), (C): we apply the induction hypothesis on all direct sub-proofs.
(DK2 ): we always apply the induction hypothesis on the key part of the rule
(DK2 ), for the encrypted part we consider the rule above (DK2 ) is :
(A), (P ), (UR), (UL) we apply the induction hypothesis on all direct sub-proofs.
(C): we can switch the two rules using Proposition 6.2 and simplicity (to get a
D-eager proof). Hence we apply the induction hypothesis on the sub-proofs.
(GX) if all encrypted hypotheses of the (GX) are encrypted by sets of keys Ki such that Ki ∩K2 = ∅ then we apply the induction hypothesis on the sub-proofs. Otherwise we consider that the hypotheses of the rule (GX) can be split into smaller sums which all give an encrypted term and we apply the transformation described in Figure 2. In certain cases some additional transformations are required to preserve simplicity: we cut the same hypotheses of the rule (GX) or branch of the proof for the new nodes introduced. Moreover if a rule (GX) has just one hypothesis, this rule can be deleted. Since K2 ∩ K1 /= ∅ and
n ≥ 2, the size of the initial proof is Σi=n|πB | + |πK | +2 is greater or equal
i=1	i	2
than Σi=n1 |πB | + |πK ∩K | +2 the size of this sub-proof, hence we apply the
i=1	i	2	1
induction hypothesis on the sub-proof ended by the rule (DK2 ∩K1 ).

Proposition 7.2 The transformations of proofs given in Figures 3 and 4 decrease the number of nodes of the initial proof.
Proof. We denote by πx the subproof of P with root T ▶ x. These transformations transform a proof with some hypotheses and a conclusion into a proof of the same hypotheses and the same conclusion. Figure 3: It is obvious.
Figure 4: The number of nodes of the initial proof is:
αI = Σi=m|πz | + |πx | + |πx | + |πK | + |πK | +3 
i=1	i	1	2	1	2
The number of nodes of the transformed proof is:
αT = Σi=m|πz | + |πx | + |πx | + |πK \K | + |πK \K | + |πK ∩K | +5 

i=1	i	1	2
1	2	2	1	1	2

Observe that |πK1 | = |πK1∩K2 | + |πK1\K2 | and |πK2 | = |πK1∩K2 | + |πK2\K1 |.
αI − αT = |πK1 | + |πK2 |− |πK1\K2 |− |πK2\K1 |− |πK1∩K2 |− 2
= |πK1 ∩K2 | + |πK1\K2 | + |πK2 |− |πK1\K2 |− |πK2\K1 |− |πK1∩K2 |− 2
= |πK1 ∩K2 | + |πK2\K1 |− |πK2\K1 |− 2
= |πK1 ∩K2 |− 2
Since K1 ∩ K2 /= ∅, hence |πK1∩K2 | ≥ 2 and the number of nodes is decreasing. 
Lemma 7.3 If there is a simple, flat and D-eager proof of T ▶ w then there is also a simple, flat, D-eager and ⊕-eager of T ▶ w.






.
(R1 )
.
...	(Rn)



(DK2 )
	T ▶ B1	T ▶ Bn
(GX)	T ▶ {u}	T ▶ K2


T ▶ {u}K1 \K2
⇓



.
(R )
.
.. .	(R  )
.
(Rn	)
.
.. .	(Rn )


(GX)
(GX)
1 T ▶ B

T ▶ {u1}K1
n1
T ▶ Bn1
.. .	(GX)
l−1 +1
l−1 +1
T ▶ {ul}K1


T ▶ Bnl



(D	)
(DK2 ∩K1 )
T ▶ {u1}K1 ⊕ .. . ⊕ {ul}K1 = {u}K1	T ▶ K2 ∩ K1
T ▶ {u}K1 \K2 ∩K1
T ▶ K2 \ K1

K2 \K1
T ▶ {u}(K1 \K2 ∩K1 )\(K2 \K1 )
⇓

.
= {u}K1 \K2


.

(R1)	.. .	(Rn1 )



(DK2 ∩K1 )
	T ▶ B1	T ▶ Bn1 
(GX)	T ▶ {u }	T ▶ K2 ∩ K1
T ▶ {u1 }(K1 \K2 ∩K1 )


(GX)
(Rnl−1 +11)
.

T ▶ Bnl−1 +1
T ▶ {u }

.. .	(Rnl )
.

T ▶ Bnl


T ▶ K2 ∩ K1

...	(DK ∩K )
l K1

2	1
(GX)

T ▶ {u}
T ▶ {u1 }(K1 \K2 ∩K1 )
T ▶ K2 \ K1

(DK2 \K1 )
T ▶ {u}
(K1 \K2 ∩K1 )
= {u}

(K1 \K2 ∩K1 )\(K2 \K1 )	K1 \K2

T ▶ x1	...	T ▶ xn


(GX)
(GX)
T ▶ x1 ⊕ ... ⊕ xn
T ▶ y1	...	T ▶ ym




(GX)
T ▶ x1 ⊕ ... ⊕ xn ⊕ y1 ⊕ ... ⊕ ym
⇓
T ▶ x1	...	T ▶ xn	T ▶ y1	...	T ▶ ym T ▶ x1 ⊕ ... ⊕ xn ⊕ y1 ⊕ ... ⊕ ym
Fig. 3. Transformation of (GX)-(GX) into (GX)

Proof. Let P be a simple, flat and D-eager proof of T ▶ w, we apply many times the proof transformation rules given in Figures 3 and 4. The application of these transformations terminates because Proposition 7.2 shows that they decrease the number of nodes of a proof and the transformation of a proof into a simple and flat proof decreases obviously the number of nodes. Moreover these transformations do not make appear any rule (D) just after a rule (GX) and any rule (D) just after a rule (C), hence the proof is again D-eager .	 

Properties of Proofs
Thanks to previous transformations we consider a simple, flat D-eager ⊕-eager proof P of T ▶ w. Lemma 8.2 shows, using Lemma 8.1, that all nodes stemmed from a rule (UR)(UL) are in S(T ) for simple proof. Lemma 8.3 proves that all nodes stemmed from a rule (D) have the encrypted hypothesis in S⊕(T ) for a simple, flat, D-eager and ⊕-eager proof. In Lemma 8.4 we prove that such a proof can be transformed in a normal proof using Lemma 8.2 and Lemma 8.3.
Lemma 8.1 Let P be a simple proof of the form:

⎧⎪⎪⎨


⎪⎪⎩

P1 ... Pn

T ▶ w


If T ▶ u does not occur in any of P1,... , Pn and ⟨u, v⟩ ∈ S(w) then there is at least one Pi and there exists w' such that ⟨u, v⟩ ∈ S(w') and either the root of Pi is T ▶ w' or w' ∈ T.
Proof. We consider all possible rules for the root of P :
The last rule is (A): obvious since all elements of T are normalized.
The last rule is (UL) or (UR): ⟨u, v⟩ ∈ S(w) by hypothesis, we denote w' =
⟨u1, u2⟩ and by construction w ∈ S(⟨u1, u2⟩). We deduce by transitivity of the subterm relation that ⟨u, v⟩∈ S(w') and conclude with the induction hypothesis.
The last rule is (D): ⟨u, v⟩ ∈ S(w) by hypothesis, we denote w' = {u1}u2 and by construction w ∈ S({u1}u2 ). We deduce by transitivity of the subterm relation












(GX)

(CK1 )
T ▶ x1	T ▶ K1 T ▶ {x1 }K1

(CK2 )
T ▶ x2	T ▶ K2 T ▶ {x2}K2

(R1 )
.

T ▶ z1

.. .(Rm)
.

T ▶ zm

T ▶ {x1 }K1 ⊕ {x2}K2 ⊕ z1 ⊕ .. . ⊕ zm
⇓



(GX)

(CK1 \K2
) T ▶ x1	T ▶ K1 \ K2
T ▶ {x1}K1 \K2

(CK2 \K1
) T ▶ x2	T ▶ K2 \ K1
T ▶ {x2}K2 \K1



(GX)

(CK1 ∩K2 )
T ▶ {x1 }K1 \K2 ⊕ {x2}K2 \K1	T ▶ K1 ∩ K2
T ▶ {x1}K1 ⊕ {x2 }K2	(R1 )
T ▶ {x1 }K1 ⊕ {x2 }K2 ⊕ z1 ⊕ .. . ⊕ zm
.


T ▶ z1

.. .(Rm)
.


T ▶ zm



that ⟨u, v⟩∈ S(w') and conclude with the induction hypothesis.
The last rule is (GX): ⟨u, v⟩ ∈ S(w) by hypothesis and w = (u1 ⊕ ... ⊕ un) ↓. Hence by definition of the subterm relation ⟨u, v⟩ ∈ ∪iS(ui), more precisely there exists i such that ⟨u, v⟩ ∈ S(ui), because ⟨u, v⟩ is not headed with ⊕ and conclude with the induction hypothesis.
The last rule is (P ): since T ▶ u can not occur in P we have that w = ⟨w1, w2⟩ /=
⟨u, v⟩. But ⟨u, v⟩ ∈ S(w) by hypothesis so ⟨u, v⟩∈ S(⟨w1, w2⟩). It is a subterm of
w1 or of w2 and we conclude with the induction hypothesis.
The last rule is (C): We have that w = {w1}w2 /= ⟨u, v⟩. But ⟨u, v⟩ ∈ S(w) by hypothesis so ⟨u, v⟩ ∈ S({w1}w2 ). It is a subterm of w1 or of w2 and we conclude with the induction hypothesis.

Lemma 8.2 Let P be a simple proof of T ▶ u or T ▶ v. If P is one of



(UL)
.


T ▶ ⟨u, v⟩ T ▶ u


(UR)
.


T ▶ ⟨u, v⟩ T ▶ v

then ⟨u, v⟩ ∈ S(T ).
Proof. Let us assume that the last rule is (UL), the case (UR) is similar.
⎧  P1 ... Pn 
P = ⎨ T ▶ ⟨u, v⟩
T ▶ u
⎪⎩

P is simple so T ▶ u does not occur in any of P1,... , Pn. Hence, we can apply
P1 ... Pn

Lemma 8.1 to


T ▶ ⟨u, v⟩
. Either ⟨u, v⟩ ∈ T , or there is some Pi with root T ▶ w

such that ⟨u, v⟩ ∈ S(w) and T ▶ u does not occur in Pi. Lemma 8.1 can be applied again and the iteration of this reasoning finally leads to ⟨u, v⟩∈ T .	 
Lemma 8.3 Let P be a simple, flat, D-eager and ⊕-eager proof of T ▶ u. If P is



(DK )
(R)
.


T ▶ {u}K ↓ = r
T ▶ u
.


T ▶ K ↓

then {u}K ∈ S⊕(T ).
Proof. The proof is by structural induction on P . Base case: obvious.

Induction step: we perform a case analysis on the last rule (R) used in the subproof of P with root {u}v ↓
(R) is (A), (UL), (UR): the result is true by definition (rule (A)) or Lemma 8.2 (rule (UL), (UR)).
(R) is some rule (P ): this cannot happen because {u}K ↓ is not a pair.
(R) is some rule (CK' ): P is D-eager by consequence it is impossible.
(R) is some rule (DK' ) impossible since P is flat.
(R) is (GX). The last deductions in the proof P are described in Figure 5 and we discuss the different cases according to the rules (Ri) and the structure of {u}K ↓.

(R ) T ▶ B1
1 T ▶ B'
... (R ) T ▶ Bn
n T ▶ B'	.


(DK
(GX) 	1	n		
	T ▶ {u}K ↓	T ▶ K ↓
)
T ▶ u ↓



Fig. 5. Illustration of the case (DK ) in Lemma 8.3.
We show that every atom of {u}K ↓ is in fact an element of ST (T ). Let a ∈ atoms({u}K ↓). Note that a is necessarily of the form {a'}K , and that there is an i such that a ∈ atoms(B'). We consider different possible cases for the rule (Ri):
(Ri) is (A), (UL) or (UR). By definition or Lemma 8.2, B' ∈ S⊕(T ).
T ▶ {w1}K' T ▶ K'

(Ri) is (DK' ) s.t. (DK' )
T ▶ w1 = B'
. By induction hypothesis {w1}K' ∈

S⊕(T ), therefore w1 = B' ∈ S⊕(T ).
(Ri) is (P ): B' = ⟨w1, w2⟩, B' cannot occur in {u}K ↓ by consequence B' is
i	i	i
canceled by another hypotheses B' of (GX) such that B' ∈ ST (B' ). B' can not
j	i	j	j
be the result of a rule (P ) by simplicity, neither a rule (C) since it is a pair,
neither (GX) since the proof is flat. In the other cases B' stems from a rule (A), (UL), (UR) or (D) by consequence B' ∈ S⊕(T ). We deduce that B' ∈ S⊕(T ).
j	i
(Ri) is (C), since P is D-eager we get that B' is headed with {.}K' such that
K ∩ K' = ∅. By consequence B' is canceled by another hypotheses B' of (GX)
i	j

such that B' ∈ ST (B'). B'
can not be the result of a rule (P ) since it is an

j	i	j
encrypted term, neither another rule (C) since P is ⊕-eager , neither (GX) since

the proof is flat. In the other cases the copy B'
stems from a rule (A), (UL),

(UR) or (D) by consequence B' ∈ S⊕(T ). We deduce that B' ∈ S⊕(T ).

Therefore in all cases {u}K ↓ = 

i=1,...,n
B' ↓ =  {ti}K where {ti}K ∈ S⊕(T ) ∩

(∪i=1,...,natoms(Bi)) because all atoms of B' are in S⊕(T ) or canceled.

Lemma 8.4 Let P be a flat, simple, ⊕-eager and D-eager proof of T ▶ u. There is a normal proof of T ▶ u.
Proof. Consider first the case where u ∈ S⊕(T ). We proceed by structural induc- tion on the proof P and case distinction of the last rule (R) of P :
(R) is (A): P is obviously a normal proof.

(R) is some rule (UL) or (UR) s.t.
T ▶ ⟨u1, u2⟩ T ▶ u
. The induction hypothesis gives

that there exists a normal proof of ⟨u1, u2⟩. P is simple, we apply Lemma 8.2 and
get ⟨u1, u2⟩ ∈ S(T ) ⊆ S⊕(T ) then the normal proof of ⟨u1, u2⟩ is S⊕(T )-local so
P is normal since u ∈ S⊕(T ).
T ▶ {u}K T ▶ K

(R) is some rule (D) s.t.
T ▶ u
. The induction hypothesis gives that

there exists a normal proof of {u}K . P is flat, simple, D-eager and ⊕-eager with Lemma 8.3 we get {u}K ∈ S(T ) ⊆ S⊕(T ) and then the normal proof of {u}K is S⊕(T )-local so we deduce that P is normal because u ∈ S⊕(T ).
(R) is some rule (P ), (C) are similar. We only give the proof for u = {u1}u2 .
T ▶ u1 T ▶ u2

(R) is some (C) s.t.
T ▶ {u1}u2
Since {u1}u2 = u ∈ S⊕(T ) we deduce that

u1 ∈ S⊕(T ) and u2 ∈ S⊕(T ). Hence applying the induction hypothesis there are
normal proofs of u1 and u2 that are S⊕-local, hence P is normal.

T ▶ B1
(R1) T ▶ B'
T ▶ Bn
...(Rn) T ▶ B'

(R) is some rule (GX) s.t. (GX) 	1	n . We will show
T ▶ u
that for every (Ri) we have that B' ∈ S⊕(T ). We discuss the different cases for
the rules (Ri)’s:
(Ri) is not (GX) because P is flat.
(Ri) is (A), (UL), (UR) or (D) with the definition or Lemma 8.2 or Lemma 8.3 then B' ∈ S⊕(T ). Applying the induction hypothesis there is a normal proof of B' which is S⊕(T )-local.
(Ri) is (P ), there are two possibilities: B' is in ST (u) or not.
B' ∈ ST (u) ⊆ S⊕(T ) we can apply the induction hypothesis and get a normal proof of B' which is S⊕(T )-local.

B' /∈ ST (u) hence B' is canceled by some other elements B' . B'
can not

i	i	j	j
come from a rule (P ) because P is simple, from a rule (C) because a pair is

not headed with {.}.. So B'
come from a rule (A), (UL), (UR) or (D) with

the definition or Lemma 8.2 or Lemma 8.3 then B' ∈ S⊕(T ). More precisely
  B' ∈ S⊕(T ), since B' ∈ S⊕(  B' ), we deduce that B' ∈ S⊕(T ). We apply
the induction hypothesis and get a normal proof of B' which is S⊕(T )-local.
(Ri) is (CK ), this case is similar to the previous case. There are two possibilities:
B' is in ST (u) or not:
' ∈ ST (u) ⊆ S⊕(T ), we apply the induction hypothesis and get a normal
proof of B' which is S⊕(T )-local.
B' /∈ ST (u) hence B' is canceled by some other elements B' . B' can not stem
i	i	j	j
from a rule (P ) since a pair is not headed with {.}., from a rule (CK' ) with
K' /= K since B' not headed with {.}K and not from another rule (CK' ) where

K' ∩ K /= ∅ since P is ⊕-eager . So B'
come from a rule (A), (UL), (UR) or

(D) with the definition or Lemma 8.2 or Lemma 8.3 then B' ∈ S⊕(T ). More

precisely  B' ∈ S⊕(T ), since B' ∈ S⊕(  B' ) we deduce that B' ∈ S⊕(T ).

we can apply the induction hypothesis and get a normal proof of B' which is
S⊕(T )-local.
Since all the subproofs of T ▶ B' are normal we can conclude that P is normal.
In the second case, we assume that u /∈ S⊕(T ) and the proof is of the form C[P1,... , Pn] where P1,... , Pn are maximal S⊕-local subproofs. We prove the result by structural induction on P :
If C is empty, then u ∈ S⊕(T )
If the last rule is (UL), (UR) or (D) we use the definition and Lemma 8.2 and Lemma 8.3 to get u ∈ S⊕(T ).
In the others cases we apply the induction hypothesis.


Our Main Result
In this section, we prove Theorem 9.1 which says that a normal proof is equiv- alent to a S⊕(T, w)-proof. Thanks to Theorem 4.2 we conclude that there is a DOUBLE-EXP-TIME procedure to decide the intruder deduction problem in equa- tional theory XCDE(complexity due to the computation of the set S⊕(T, w)).
Theorem 9.1 Let P be a flat, simple, D-eager and ⊕-eager proof of T ▶ w then
P is normal ⇔ P is S⊕(T, w)-local.
Proof. ⇐ Let us assume that P is S⊕(T, w)-local and prove that P is normal:
If w ∈ S⊕(T ) then P is S⊕(T )-local i.e. P is normal.
If w /∈ S⊕(T ) then we proceed by structural induction on P . The base case (A)
is trivial, consider the last rule:
(UR), (UL), (D) impossible since Lemma 8.2 and Lemma 8.3 show that w ∈
S⊕(T ) which contradicts the hypothesis.
(P ), (C), (GX) by induction hypothesis, the hypotheses wi of the rule stem from normal proofs. Because the last rule is (P ), (C), (GX) then P is normal.
⇒ Let us assume that P is normal and prove that P is S⊕(T, w)-local:
If w ∈ S⊕(T ): P is S⊕(T )-local, hence P is S⊕(T, w)-local.
If w /∈ S⊕(T ) we proceed by structural induction on P . The base case is trivial, consider the last rule:
(UR), (UL), (D): impossible by definition of normal proof.

(P ), (C) are similar, we just give the proof for (C). P is s.t.
T ▶ w1 T ▶ w2
.
T ▶ {w1}w2

By definition for i = 1, 2 wi ∈ S⊕(T, wi), wi ∈ ST ({w1}w2 )= ST (w) ⊆ S⊕(w),
and induction hypothesis which guarantees that all nodes of the sub-proof are in S⊕(T, wi), we conclude that P is S⊕(T, w)-local.

T ▶ B1
(R1 ) T ▶ B'
T ▶ Bn
...	(Rn) T ▶ B'

· (GX) P is s.t. (GX) 	1	n . We will prove that
T ▶ w
all B' are in S⊕(T, w), consider the different cases for the (Ri): (A): by definition B' ∈ S⊕(T ),
(UR), (UL), (D): by Lemma 8.2 and Lemma 8.3 we get B' ∈ S⊕(T ).
(GX): impossible because P is flat.
(P ): if B' ∈ S⊕(T ) the claim holds, otherwise B' /∈ S⊕(T ). Either B' is not
i	i	i
canceled in a sum, then B' ∈ ST (w) ⊆ S⊕(w), or otherwise B' is canceled by
i	i
another element of the sum B' . Since B' is a pair B' can not be deduced from
j	i	j
a rule (C) neither a rule (P ) since P is simple. Hence it stems from one of the
rules (A), (UL), (UR) or (D) and B' ∈ ST (B' ). According to Lemma 8.2 and
i	j
Lemma 8.3 B' ∈ S⊕(T ), hence we get the result by transitivity of S⊕.
(CK): if B' ∈ S⊕(T ) the claim holds, otherwise B' /∈ S⊕(T ). Note that B' can
i	i	i
be partially canceled in a sum. There are two possibilities for the atoms of B':
to be present in w, in which case atoms(B') ∈ atoms(ST (w)) ⊆ atoms(S⊕(w)), or to be canceled by other elements B' of the sum, in which case atoms(B') ∈
j	i
atoms(S⊕(B' )) ⊆ atoms(S⊕(T )). In the latter case, since B' is encrypted by
j	i
the set of keys K, B' can not be the result of a rule (CK' ) with K' /= K, nor the
result of the rule (C' ) with K' ∩ K /= ∅ since P is ⊕-eager , nor (P ), hence it stems from one of the rules (A), (UL), (UR) or (D). Thanks to Lemma 8.2 and Lemma 8.3 B' ∈ S⊕(T ), we conclude with the transitivity of S⊕. In summary,
for all i we get that atoms(B') ∈ atoms(S⊕(T, w)), that is B' ∈ S⊕(T, w)).
i	i
Hence P is S⊕(T, w)-local.

The Binary Case
We call the binary case the situation where the set of assumptions T and the goal u of the proof P of T ▶ u do not contain terms with more than two consecutive applications of the symbol ⊕.
In the case of a commuting encryption operation, we show an EXPSPACE lower bound by reduction of the uniform word problem in commutative semigroups (ab- breviated CSG ) which is EXPSPACE-hard [16]. An instance of CSG is:
α1 = β1,... , αn = βn |= α = β
where α, β, αi and βi are words over some alphabet. It is essential for the complexity of the problem that the alphabet is infinite (of course, any instance C of CSG uses only a finite portion Σ(C ) of that alphabet). Such an instance of CSG has a solution if and only if α = β in every commutative semigroup satisfying the axioms αi = βi. Denoting by x =c y the equality of two words x and y modulo commutativity, this is equivalent to the following assertion:
Either α =c β, or there exists a sequence of pairs (γ1, δ1),... , (γl, δl) such that

each pair (γj, δj) is either some αi = βi or some βi = αi
and a sequence of words c1,... , cl with cj ∈ Σ(C )∗ such that
α =c γ1c1	,	δ1c1 =c γ2c2,... , δl−1cl−1 =c γlcl	,	δlcl =c β
We consider asymmetric encryption to prove the hardness result in the binary case, i.e a term {u}k can be decrypted if and only if we know the inverse of the key k, denoted Inv(k). We just need to add the Inv symbol in the signature and modify the decryption rule:


(DK )
T ▶ {u}K	T ▶ Inv(K) T ▶ u ↓

where K is the non-empty multi-set {kα1 ,... , kαn }, Inv(K) is a notation for the
1	n
multi-set {Inv(k1)α1 ,... ,Inv(kn)αn }, and as previously T ▶ Inv(K) denotes many times the sequent of each inverse keys. Notice if you do not know an inverse of a
key, there is no way to generate it. In this case we have also the locality result.
Theorem 10.1 In case of the equational theory XCDE the binary intruder deduc- tion problem is EXPSPACE-hard.
Proof. We show that this is even true for binary T , u not containing any decryption key as a subterm (i.e. there is no symbol Inv) and any term headed with the pair function.
Given an instance C = (α1 = β1,... , αn = βn |= α = β) of CSG, let
T = {{ *}αi ⊕ { *}βi | 1 ≤ i ≤ n}∪ Σ(C )
u = { *}α ⊕ { *}β
where * is some constant, and all the symbols of Σ(C ) are considered as constants. By locality Theorem 9.1 we know that all nodes of the proofs of T ▶ u are in the set of subterms of T ∪ {u}. Hence these proofs are not using the (D) rule (since no decryption key is a subterm of T or u) and not the rules (UR), (UL) and (P ) because there is no term headed with the pair function in T ∪ {u}. By consequence
theses proofs contains only the rules (A), (C) and (GX).
T ▶ x1	...	T ▶ xn


(CK )
(GX)
T ▶ x1 ⊕ ... ⊕ xn
T ▶ K

T ▶ {x1}K ⊕ ... ⊕ {xn}K
⇓



(GX)
(CK )
T ▶ x1	T ▶ K T ▶ {x1}K
...	(CK )
T ▶ xn	T ▶ K T ▶ {xn}K

T ▶ {x1}K ⊕ ... ⊕ {xn}K
Fig. 6. Permutation of the rules (GX)-(C) into (C)-(GX).
Applying the transformations of the Figure 3 (merge of two (GX) rules) and Figure 6 (switch rules (GX) and (C)), existence of such a proof is equivalent to

existence of a proof of the following form:
{ *}γ1 ⊕ { *}δ1 ∈ T
(A)
T ▶ { *}γ1 ⊕ { *}δ1


(A)

{ *}γl ⊕ { *}δl ∈ T T ▶ { *}γl ⊕ { *}δl

(C)
.
(C)
(C)
.
...	(C)

(GX)

T ▶ { *}γ1 c1 ⊕ { *}δ1 c1

T ▶ { *}α ⊕ { *}β

T ▶ { *}γlcl ⊕ { *}δlcl

where we may assume without loss of generality that no non-empty subset of the premises of the (GX) rule sums up to 0. There exists such a proof if either { *}α =
{ *}β, or if there exists a sequence of terms { *}γ1 ⊕{ *}δ1 ,... , { *}γl ⊕{ *}δl such that each of them is either some { *}αi ⊕ { *}βi or some { *}βi ⊕ { *}αi , and a sequence c1,... , cl such that:
{ *}α = { *}γ1 c1 , { *}δ1 c1 = { *}γ2 c2 ,... , { *}δl−1 cl−1 = { *}γlcl, { *}δlcl = { *}β
in the term algebra, which is equivalent to the existence of a solution to C . The claim follows from the EXPSPACE-hardness of CSG [16].	 

Conclusion
We propose a DOUBLE-EXP-TIME decision procedure for solving the intruder deduction problem in presence of the equational theory XCDE (eXclusive-or with a Commutative and Distributive Encryption). The commutativity of the encryption requires to consider all combinations of keys in the subterms, to be more attentive and to develop a new normalization of proof. We also prove in the binary case that this problem is EXPSPACE-hard. The next stage will be to find the exact complexity of this problem. The intruder deduction problem is the first step in the verification of cryptographic protocols as for instance in [18] without any equational theory, or later in [6,3] to consider the equational theory of exclusive-or. The second step is verifying the case of an active intruder. The active case without equational theory but with a commutative encryption was shown to be decidable by [5]. We prove that the problem is decidable for an active intruder with a homomorphic operation which is not the encryption [11]. In the case of the equational theory of the exclusive-or and non-commutative distributive encryption over this operator, it seems impossible to solve the equations systems in the usual way. But after having studied the first step by demonstrating the intruder deduction problem in the XCDE case, we could apply some mathematical results for solving these equations systems.

References
Franz Baader and Tobias Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.
Véronique Cortier, Stéphanie Delaune, and Pascal Lafourcade. A survey of algebraic properties used in cryptographic protocols. Journal of Computer Security, 14(1):1–43, 2006.

Y. Chevalier, R. Küsters, M. Rusinowitch, and M. Turuani. An NP decision procedure for protocol insecurity with XOR. In Proc. of 18th Annual IEEE Symposium on Logic in Computer Science (LICS’03), pages 261–270, Ottawa (Canada), 2003. IEEE Comp. Soc. Press.
Yannick Chevalier, Ralf Küsters, Michaël Rusinowitch, and Mathieu Turuani. Deciding the security of protocols with Diﬃe-Hellman exponentiation and products in exponents. In Paritosh K. Pandya and Jaikumar Radhakrishnan, editors, FSTTCS, volume 2914 of Lecture Notes in Computer Science, pages 124–135. Springer, 2003.
Y. Chevalier, R. Küsters, M. Rusinowitch, and M. Turuani. Deciding the security of protocols with commuting public key encryption. In Proc. Workshop on Automated Reasoning for Security Protocol Analysis (ARSPA’04), pages 53–63, Cork (Ireland), 2004.
H. Comon-Lundh and V. Shmatikov. Intruder deductions, constraint solving and insecurity decision in presence of exclusive or. In Proc. of 18th Annual IEEE Symposium on Logic in Computer Science (LICS’03), pages 271–280, Ottawa (Canada), 2003. IEEE Comp. Soc. Press.
Hubert Comon-Lundh and Ralf Treinen. Easy intruder deductions. In Nachum Dershowitz, editor, Veriﬁcation: Theory & Practice, Essays Dedicated to Zohar Manna on the Occasion of His 64th Birthday, volume 2772, pages 225–242. Springer-Verlag, 2003.
Yannick Chevalier and Michaël Rusinowitch. Combining intruder theories. In ICALP, pages 639–651, 2005.
Stéphanie Delaune. Easy intruder deduction problems with homomorphisms. Information Processing Letters, 97(6):213–218, March 2006.
Nachum Dershowitz and Jean-Pierre Jouannaud. Rewrite systems. chapter 6, pages 243–320.
Stéphanie Delaune, Pascal Lafourcade, Denis Lugiez, and Ralf Treinen. Symbolic protocol analysis in presence of a homomorphism operator and exclusive or . In Michele Buglesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener, editors, Proceedings of the 33rd International Colloquium on Automata, Languages and Programming (ICALP’06) — Part II, volume 4052 of Lecture Notes in Computer Science, pages 132–141, Venice, Italy, July 2006. Springer.
D. Dolev and A.C. Yao. On the security of public-key protocols. In Transactions on Information Theory, volume 29, pages 198–208. IEEE Computer Society Press, March 1983.
Pascal Lafourcade, Denis Lugiez, and Ralf Treinen. Intruder deduction for AC-like equational theories with homomorphisms. In Jürgen Giesl, editor, Proceedings of the 16th International Conference on Rewriting Techniques and Applications (RTA’05), volume 3467, pages 308–322, Nara, Japan, April 2005. Springer-Verlag.
Pascal Lafourcade, Denis Lugiez, and Ralf Treinen. Intruder deduction for the equational theory of exclusive-or with distributive encryption. Research Report LSV-05-19, Laboratoire Spécification et Vérification, ENS Cachan, France, October 2005. 39 pages.
David A. McAllester. Automatic recognition of tractability in inference relations. Journal of the ACM, 40(2):284–303, April 1993.
Ernst W. Mayr and Albert R. Meyer. The complexity of the word problems for commutative semigroups and polynomial ideals. Advances in Mathematics, 46(3):305–329, 1982.
J. Millen and V. Shmatikov. Symbolic protocol analysis with products and Diﬃe-Hellman exponentiation. In Proc. 16th Computer Security Foundation Workshop (CSFW’03), pages 47–62, Pacific Grove (California, USA), 2003. IEEE Comp. Soc. Press.
M. Rusinowitch and M. Turuani. Protocol insecurity with finite number of sessions is NP-complete. In Proc. 14th Computer Security Foundations Workshop (CSFW’01), pages 174–190, Cape Breton (Canada), 2001. IEEE Comp. Soc. Press.
