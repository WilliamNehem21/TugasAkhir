Electronic Notes in Theoretical Computer Science 58 No. 1 (2001)
URL:  http://www.elsevier.nl/locate/entcs/volume58.html  18 pages
A Representation of F! in LF Carsten Schurmann 1 Dachuan Yu 2;4 Zhaozhong Ni 3

Department of Computer Science Yale University
New Haven USA


Abstract
We study how the type theory F! can be adequately represented in the meta- logical framework Twelf [16]. This development puts special emphasis on the way how terms, types, and kinds are represented in that it uses higher-order abstract syntax to model variable binding and dependent types to model typing constraints. Furthermore our design ensures that only well-typed terms and well-kinded types can be constructed. A possible application of this work lies in the development of safe intermediate languages for compilation.




1	Introduction

Modern compilers employ sophisticated compilation technology to guarantee safety conditions of the generated binary. An important class of safety condi- tions is captured by type systems with which compilers attempt to maintain type information across an entire cascade of intermediate languages through- out a compilation process. The cascade starts with a source language and typically ends in a machine language. A variety of techniques have been pro- posed to express safety conditions, such as PCC [12] and TAL [11].
Intermediate languages are typically designed in such a way that the con- ceptual di erence between the individual languages is small and manageable, the properties of each particular language are provable, and the relationship between di erent intermediate languages is analyzable. In this paper we con- centrate on one particular intermediate language F! and its properties, which forms the basis of FLINT [18] and TILT [8].

1  Email:carsten@cs.yale.edu
2  Email:yu@cs.yale.edu
3  Email:nzz@cs.yale.edu
4 This work was supported in part by NSF Grants CCR-9901011 and CCR-0081590
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

In general, compilation from one language to another is expressed by judg- ments and inference rules. The soundness argument is often left to language designers who typically reason about the language's properties informally, with pencil and paper. Given that the design of those intermediate languages is a challenging engineering task in itself, and that in terms of safety so much de- pends on it, the question of whether the desired properties are really satis ed is of crucial importance. Examples of those properties include the correct- ness of static and dynamic semantics, subject reduction, progress, termination properties, observational equivalence, and soundness and completeness of the compilation.
Informal proofs are often error prone. From an engineering point of view, it is di√Ücult to maintain a valid set of theorems and proofs while a formal development evolves. For this reason we advocate in this paper the use of meta-logical frameworks to specify, implement, and verify designs.
Meta-logical frameworks, such as Coq [4], Nuprl [1], and Isabelle/HOL [13] for example o er elaborate and sophisticated interactive proof search tools. In order to use those tools, one must commit to a particular way of representing the inference systems involved. In particular, representations of typing rela- tions and operational semantics, for example, which have in general extremely elegant and expressive higher-order encodings are not directly supported in Coq, Nuprl, or Isabelle/HOL, because the question what induction princi- ples to use is problematic [3,9]. However, true higher-order encodings of those systems provide enormous advantages in that certain lemmas related to substi- tution and weakening are implicitly supported, and need not be implemented by the language designer. In this paper, we use Twelf [16] as representation language of speci cations, algorithms, and their meta-theory.
From an implementors point of view, each intermediate language and each type system requires a di erent implementation of a type checker. We show in this paper with F! as example, how static typing can become part of the representation. Consequently, the LF type checker can decide if a term is well-typed or not. Ill-typed terms in F! are simply not typable in our repre- sentation. We show an implemented proof of type soundness for this design.
This paper is organized as follows. We discuss Twelf in Section 2, introduce F! in Section 3, discuss issues concerning substitution in Section 4, and give a reduction semantics in Section 5 before we show type soundness in Section 6. An example of how to use our encoding is given in Section 7. Section 8 outlines future work and assesses results.

2	Twelf

The Twelf system [16] is a meta-logical framework and a tool for experi- mentation in the theory of programming languages and logics. It supports a variety of tasks such as the speci cation of object languages and their seman- tics, implementations of algorithms manipulating object-language expressions

and deductions, and formal development of the meta-theory of an object lan- guage. Twelf implements the logical framework LF [7] and it employs the judgments-as-types, and derivations-as-objects methodology for speci cation. Our formulation of LF is standard.


We use a for type constants, c for objects constant, and x for variables. as- signs types to variables. The signature is used below to declare the constants related to our encoding. Following standard practice [14] we assume substi- tutions to be capture avoiding and omit all leading -abstractions pre xes from types.  -convertibility is taken as the underlying notion of de nitional equality [2]. A ! K and A1 ! A2 are used as abbreviations for  x : A: K and  x : A1 : A2 if x does not occur free in K and A2, respectively. Sometimes we write A2   A1 for A1 ! A2.
As typing judgments for LF we write ` M : A if object M has type A in context , and ` M :c A if M is well-typed and in addition a canonical ( - normal, -long) form. The corresponding inference rules can be found in [7].


3	F!

F! is a type theory that has been introduced by Girard in his thesis [5] as a tool to prove properties about higher-order logics. In type-directed compilation, F! 's expressive power has made it an attractive choice for the core of the FLINT system [18] and TILT [8]. It extends the simply-typed -calculus by polymorphism and type constructors.

Kinds  ::= o j  1 )) 2
Types  ::=  j)j 1 2 j   : :  j 8  : : Terms e ::= x j x : : e j e1 e2 j   : : e j e[ ]
There are di erent ways to encode F! in LF. One way, for example, is to represent expressions, types, and kinds as individual syntactic categories, and then to encode the related typing relations explicitly. For the purpose of this work however, we have chosen an \implicit" representation and index types by kinds and terms by types (see below).

kd : type o	: kd
)) : kd ! kd ! kd

We write p q for the (polymorphic) representation function that embeds the syntactic categories of F! into LF.

Theorem 3.1 (Adequacy of encoding: kinds) If   is a kind, then  ` p q :c kd. And conversely, if ` M :c kd for some object K, then, there exists a kind , such that p q = M.

The type system of F! is strongly normalizing, which seems to make LF's simply typed -calculus a good candidate to represent F! 's type level directly. However such an encoding would be unsatisfactory because it is incompatible with polymorphic quanti cation. Therefore we encode F! -types in LF as type family indexed by their respective kinds.


tp : kd ! type
)0 : tp (o )) o )) o)
@0  : tp (K )) K ) ! tp K ! tp K
 ^0  : (tp K ! tp K ) ! tp (K )) K )
80  : (tp K ! tp o) ! tp o

We mark these newly de ned constants with a prime, because we reuse the same names for other inference rules de ning atomic and canonical forms below. This choice makes signatures that encode theorems and proofs more readable.

Theorem 3.2 (Adequacy of encoding: types) If   is a type of kind 

with free type variables 
:  ;::: ; 
:  , then 
: p q;::: ; 
: p  q `

p q : tp p q.  And conversely, if 
: p q;::: ; 
: p 
q ` M : tp p q

then there exists a type  : , s.t. p q = M. p q is compositional in that p[ = ] 0 q = (  : p q: p 0 q) p q.

F! allows -reduction on the type level, which induces an equality relation among well-kinded types denoted by  ` 1  2 : . In order to avoid notational clutter, we suppress context  and kind  and simply write 1   2 for this judgment. However, it is important to note that all of the de ning inference rules rely on the participating types to be well-kinded.

tbeta
(  : :  1 ) 2  [ 2 = ] 1
teta (  not free in  )
     : : 



0
tall
0
tlam

8  : :    8  : :	  : :     : : 

0	0

tarr
 1   1	 2   2


tapp

0	0
) )	 1 2   1 2


tref

 1   2	 2   3


 1   3

ttra

 1   2


 2   1

tsymm


The type level of F! forms a strongly normalizing -calculus [5]. Without further discussion and formalization, we assume this fact as given and leave a formulation of meta-level properties about this congruence relation to future work. F! also satis es several inversion principles, two of which are important for this work.
Lemma 3.3 (Admissible rules of inference)

(i) If ) 
 )  0  0
then 
   0 .

(ii) If 8  : : 
  8  : :  and  0   0 then [ 0 = ]    [ 0 = ]  .

1	2	1	2	1	1	2	2
The congruence relation and the two parts of Lemma 3.3 are expressed in LF by the signature depicted in Figure 1. The encoding of the judgment alone forces the left hand side and right hand side of a congruence to be of the same kind.
Theorem 3.4 (Adequacy of encoding: congruence relation) If R is a derivation of  1   2 with free variables among  1 :  1 ;::: ; n :  n, then

: p q;u  : 
    ;::: ; 
: p 
q;u	: 
` pRq : p q  p q.

And conversely, if 
: p q;u : 
   ;::: ; 
: p 
q;u  : 
` M :

p q  p q then there exists a derivation R of     , s.t. pRq = M.

In addition p q is compositional, but only in as far as derivations of are concerned. This limited property of compositionality alone, however, is insu√Ücient for the general case.	That even derivations of    0 can be substituted for any of the ui's in Theorem 3.4 is the main result of Lemma 4.1. An implementation of this congruence relation is given in [17]. The rule
`tref' from above is also an admissible rule of inference, however we have chosen not to encode it as such, but instead to implement the admissibility proof.
Lemma 3.5 (Identity lemma) For all types  it holds that     .

Its encoding in Twelf as type family with a set of de ning constant decla-

	: tp K ! tp K ! type

tbeta	: (( ^0 ( a : tp K: T a)) @0 T )  T T teta	: T  ^0 ( a : tp K: T @0 a)
tarr	: ) )
ttra	: T1  T2 ! T2  T3 ! T1  T3

tall	: ( a : tp K: a  a ! T1
a  T 0 a) ! 80 T
  80 T 0

tapp	: T
  T 0 ! T
  T 0 ! T
@0 T
  T 0 @0 T 0

tlam	: ( a : tp K: a  a ! T1 tsymm : T1  T2 ! T2  T1
a  T 0 a) ! ^0 T
  ^0 T 0



tinv	: ) @0 T
@0 T ) @0 T 0 @0 T 0 ! T
  T 0

1	2	1
2	2	2

tinvall : 80 T
  80 T 0 ! T   T 0 ! T T   T 0 T 0


Fig. 1. Encoding of  and Lemma 3.3. rations can be found in [17].
id :  T : tp K: T  T ! type

In F! , every equivalence class of types modulo congruence has a unique representative. They are called canonical forms and they are in (tbeta)- normal (teta)-long form [5]. Canonical forms are de ned in terms of two judgments, one for canonical types whose de nition is kind-directed and one for atomic types whose is type-directed. The \j" rule holds only for types of kind o.


 ; #  `  * o
8
  ` 8  : :  * o
 ; #  1 `  *  2
 ^
`   : :  *  1 )) 2
  `  # o
j
  `  * o



  #  2 

  `  # 
)
  `)# o )) o )) o
  ` 1 #  2 )) 1	  ` 2 * 2
@
  ` 1  2 #  1


The representation of atomic and canonical terms in LF is given in Figure 2. The type ascription (T : tp o) in the declaration of j is necessary because Twelf would otherwise infer the more general type `tp K' as argument type.
Theorem 3.6 (Adequacy of encoding:  canonical and atomic forms) If C is a canonical form derivation of type  with free type variables  1 :

can : tp K ! type at	: tp K ! type
8	: ( a : tp K: at a ! can (T a)) ! can (80 T )
 ^	: ( a : tp K: at a ! can (T a)) ! can ( ^0 T )
j	: at (T : tp o) ! can T
) : at )0
@	: at T ! can T ! at (T  @0 T )

Fig. 2. Encoding of canonical and atomic types.





  ;::: ; 
:  , then 
: p q;u 
: at  ;::: ; 
: p 
q;u 
: at 
` pCq :

can p q. And conversely, if 
: p q;u 
: at  ;::: ; 
: p 
q;u 
: at   `

M : can p q then there exists a derivation C that  is canonical, s.t. pCq = M. A symmetric property holds for atomic forms.



Note that in this case p q is compositional, but only in the sense that atomic derivations can be substituted for atomic assumptions. The more general case of substituting canonical derivations for atomic assumptions also holds and is shown in Lemma 4.2. The introduction of canonical and atomic forms brings other bene ts such as additional inversion lemmas (of which we only show one here).


Lemma 3.7 (Inversion) If 8  : :    0 and  ` 0 * o then 0 = 8  : : 00 for some 00 .



What di erentiates Lemma 3.7 from Lemma 3.3 is that  0 and 8  : : 00 are syntactical identical and not only convertible. Consequently this lemma is directly supported by LF and need not to be encoded extra.
Following our original proposal we make the well-typedness condition part of the Twelf encoding and avoid therefore an explicit encoding of the typing relationship. This technique relieves us from having to run a separate type- checking and type-normalization phase once a term has been constructed in LF. The well-typedness condition is built into the representation.

exp : can (T : tp o) ! type

abs : (exp C1 ! exp C2) ! exp (j () @ C1) @ C2) app : exp (j () @ C1 ) @ C2) ! exp C1 ! exp C2
Abs : ( a : tp K:  u : at a: a  a ! exp (C a u)) ! exp (8 C)
App : exp (8(C :  a : tp K: at a ! can (T1 a)))
! T : tp K:  C0 : can T:  R : T T  T :
  C00 : can T : exp C00

Fig. 3. Encoding of terms.



 (x) = 

var
  ` e :	 
0


cong

  ` x : 
 ;x : 1 ` e : 2
abs
  ` x : 1 :e : 1 ! 2
  ` e : 

  ` e1 : 2 ! 1	 ` e2 : 2 app
  ` e1 e2 : 1



 ; :  ` e : 
  `   : : e : 8  : : 

Abs
  ` e : 8  : : 1	  ` 2 : 


  ` e[ 2 ] : [ 2 = ] 1

App


How should terms be represented? The obvious solution to introduce a type family and index it by types is insu√Ücient because typing is not unique. Each term has several types modulo applications of the `cong' rule, and con- sequently none of the desired inversion principles on the type level exist. The alternative and successful solution is to stipulate that all types in the rules must be canonical. This solution amounts to omitting `cong' from the list of rules above, and rewriting the `App' rule in such a way that it satis es this new constraint. [ 2= ] 1 does not necessarily yield a type of canonical form, but it is known be to congruent to one, namely  0 .


  ` e : 8  : : 1	  ` 2 :	[ 2 = ] 1 


  ` e[ 2 ] : 

App

If all types of terms are canonical, the term formation rules are directly representable as type family in LF, indexed by the proof object that certi es the canonicity of its type. The respective constant declarations are given in Figure 3.
We would like to make two comments about this representation. First, the annotation (T : tp o) in the  rst declaration restricts terms to be of

a type of kind o. Second, the formulation of all rules presented so far, but these in particular, take full advantage of Twelf's powerful type reconstruction abilities. (j () @ C1) @ C2), for example, is a proof of `abs E' canonicity. It almost reads as its type. For reasons related to adequacy, Abs's type is parametric in a proof that parameter a is atomic. The additional hypothesis a   a extends the convertibility relation on types by re exivity on parameters.

Theorem 3.8 (Adequacy of encoding: terms) Let e be a term of type
  and C a derivation that   is canonical.	If e contains free type variable
 1 :  1 ;::: m :  m and free term variables x1 : 1 ;::: ; xn : n , (and Ci proofs

of their canonicity) , then 
: tp p q;::: 
: tp p 
q;x 
: exp pC q;::: ;x :

exp pCn q ` peq : exp pCq. And conversely, if  : tp p q;::: m : tp p mq;x :

exp pC q;::: ;x 
: exp pC
q ` M : exp pCq. then there exists a term e : 0 , s.t.

peq = M and    0 .

The bijection between terms and their representation in LF is composi- tional for terms, but not for types. Consequently the concept of substitution on the type level must be considered separately.


4	Substitutions

The particular encoding of F! 's syntactic categories from the previous section brings many advantages, but also some disadvantages. Only well-typed F! terms are representable, however, whenever polymorphic application is used, explicit proofs for the equivalence of types and the corresponding canonical forms must be provided. Consequently, even though we are using higher- order abstract syntax to encode the rule for polymorphic abstraction `Abs', we cannot use LF application to mimic substitution. The representation of terms is not compositional when it comes to instantiating free type variables assumed to be atomic by types that are canonical. Instead we have to in- stantiate all free hypotheses in a hypothetical canonicity proof and convert the result into a canonical form proof by the means of a substitution lemma. In this section, we discuss the appropriate substitution lemmas for the con- gruence relation, canonical forms, and terms. In fact, those lemmas establish generalized compositionality properties for Theorem 3.4, Theorem 3.6, and Theorem 3.8, respectively. For the remainder of this section, recall, that we assume all terms to be well-typed, and all types to be well-kinded.

Lemma 4.1 (Substitution into the congruence relation) Let  3    4 be of kind 0 . If, under the hypothesis that  is a type variable of kind 0 ,
 1   2 is of kind  then [ 3 = ] 1  [ 4 = ] 2.

This proof extends Pfenning's representation of the substitution lemma [15] by polymorphic quanti cation. It is encoded as a type family

thm-sub-c : ( a : tp K0 :a  a ! (T a : tp K)  T a)
! T3  T4
! T1 T3  T2 T4
! type:

and the implementation of the proof is given in [17]. The type annotation (T1 a : tp K) signals Twelf's type reconstruction algorithm that K cannot depend on types. The substitution lemma holds not only for the congruence relation, but also for types.


Lemma 4.2 (Substitution into canonical/atomic forms)
(i) For all proofs that  ; :  `  0 *  and  `  *  there exists a  00 , such that [ = ] 0   00 and a proof of  ` 00 *  .
(ii) For all proofs that  ; :  `  0 #   and  `  *  there exists a  00 , such that [ = ] 0   00 and either a proof that  `  00 *  or  `  00 #  .


And again, this lemma can be formalized in LF by two mutual dependent type families. An encoding of this proof is given in [17]. The main di√Üculty is the disjunction in the second part of the lemma: 00 is either canonical or atomic. Pushing this logical connective into LF suggests an auxiliary inter- mediate type family \can_at".


can_at : tp K ! type:
iscan	: can T ! can_at T:
isat	: at T ! can_at T:

substc : ( a : tp K: at a ! can (T 0 a)) ! can T
! (T 0 T )  T 00 ! can T 00 ! type substa : ( a : tp K: at a ! at (T 0 a)) ! can T
! (T 0 T )  T 00 ! can_at T 00 ! type


Lastly, we de ne substitution application [ ]e on the term level. Substitu- tions are de ned as = 1 = 1;::: ; n= n and all i are in canonical form. As usual, we assume that these substitutions are capture avoiding through tacit

variable renaming.

[ ](x) =  (x)
[ ]( x : : e) = x : 0 : [ ; x=x]e where [ ]( )   0 and  0 canonical [ ](e1 e2 ) = ([ ]e1 ) ([ ]e2)
[ ](  : : e) =   : : [ ;  = ]e
[ ](e[ ]) = ([ ]e)[ 0 ]	where [ ]( )   0 and  0 canonical

[ ]( ) =  ( )
[ ]()) = )
[ ](  ) = 0	where ([ ] ) ([ ] )  0 and 0 canonical
[ ](  : : ) =  : : 0	where [ ; = ]   0 and 0 canonical [ ](8  : : ) = 8  : : 0	where [ ;  = ]    0 and  0 canonical
Unlike applications of term substitutions e=x, which are encoded internally as  -redices, the representation of type substitution application =  is exter- nal. Both, term variables and type variables are represented via higher-order abstract syntax, but  -reduction models substitution only for the former. For the latter we observe that with any instantiation of free type variables the canonicity proofs recorded with \exp" are likely to change. Consequently, this form of substitution application must be de ned externally. Its de nition is quite involved and implements the proof of the following substitution lemma.
Lemma 4.3 (Substitution into terms) For all proofs that  ; : 0 ` e : and  `  0  *  0 there exists a  00 , such that [ 0 = ]    00 and a proof of
  `  00 *   and  ` [ 0 = ]e :  00 .
Proof. By induction on e. We consider only case e = e1[ 1 ]. All other cases are similar.
C0 ::  `  0 *  0	by assumption
D ::  ; :  0 ` e [  ] :	by assumption

E ::  ; :  0 ` e
: 8  :  00 : 
by inversion on D

C ::  ; :  0 `  *  00	by inversion on D
R :: [ 1= ] 2	by inversion on D
R00 :: [ 0 = ](8  :  00 :  )   000	by induction hypothesis on E

2
 000 = 8  :  00 : 0
1
by Lemma 3.7

C000 ::  ` 8  :  00 : 0 * o	by induction hypothesis on E

E 00 ::  ` [ 0 = ]e
: 8  :  00 : 0
by induction hypothesis on E1

0 :: [ 0 = ] 
   0
by Lemma 4.2 on C ; C0

C0 ::  `  0 *  00	by Lemma 4.2 on C ; C0
1	1	1

R00 :: [ 0 = ][  = ] 
  [ 0 = ] 0
by Lemma 3.3 (2) on R00 ; R0

1	2	1	3	1
C00 ::  ; :  00 `  0 * o	by inversion on C000
R0  :: [ 0 = ] 0	by Lemma 4.2 on C00 ; C0
2	1	3	4	1
0 ::  `  * o	by Lemma 4.2 on C00 ; C0
I ::  0   0	by Lemma 3.5 on  0
Q :: [ 0 = ][  = ]   [ 0 = ]	by Lemma 4.1 on R; I
Q :: [ 0 = ]   [ 0 = ][  = ]	by tsymm on Q
Q :: [ 0 = ]   [ 0 = ] 0	by ttra on Q ; R00 ; R0
3	1	3	4	2	2
Q ::  ` ([ 0 = ]e )[ 0 ] :	by App on E 00 ; C0 ; R0
1	1	4	1	2
Q ::  ` [ 0 = ](e [  ]) :	by de nition substitution

2
When substituting a type for a type variable in an expression, it is the proof of Lemma 4.3 that contains an algorithm on how to reestablish the canonicity proofs of the types of the resulting objects. In fact, this algorithm de nes how to apply a substitution and it is formalized in Twelf as follows:

subst :  C : (  a : tp K:  u : at a: can (T a)):
( a : tp K:  u : at a:  e : a  a: exp (C a u))
! can T 0 ! (T T 0 )  T 00
!  C00 : can T 00 : exp C00 ! type

The one discussed case of the proof is depicted in Figure 4. All other cases can be found in [17]. In this representation, substituting types for type variables is more than just an algorithm acting on terms. It simultaneously enforces that all representation invariants are satis ed during execution. With this substitution lemma at hand, it is possible to de ne an operational semantics for F! and prove progress, termination, and eventually type soundness.

5	Reduction Semantics

We have chosen a reduction semantics as operational semantics for F! , which
| by de nition | preserves types. Only well-typed expressions evaluate to expressions of the same type. We write e 7! e0 for the judgment that denotes

that expression e evaluates to e0
 
in one step and e 7! e0
if it does so in arbitrary

but nitely many steps. The left and the right hand sides of the evaluation symbols are always well-typed.


ev beta

( x :  : e)v 7! [v=x]e
0
ev pbeta
(  : : e)[ ] 7! [ = ]e
0

e1 7! e1
0
ev app1
e2 7! e2
ev app2
0
e 7! e
0
ev papp

e1 e2 7! e1 e2
e1 e2 7! e1 e2
e[ ] 7! e [ ]

spapp : subst( a : tp K0 :  u : at a: D a u)
( a : tpK0 :  u : at a: i : a  a:
app(E a u i) (T a) (C a u) (R a i) (D a u)) C0 (ttra (ttra (tsymm Q ) (tinvall R00 R0 )) R0 ) C0

(App E00 T
C0 R0
1
C0 )
1	2	2

6	1	2	2
  subst ( a : tp K0 :  u : at a:
8 ( a1 : tp K:  a2 : at a1 : C2 a u a1 a2))
( a : tp K0 :  u : at a: E  a u) C0 R00 (80 C00 ) E00


   substc C1
C0 R0	0

   substc C00 C0 R0  C0


   id T 0 I
1	2	2

   thm-sub-c ( a : tp K0 :  i : a  a: R a i) I Q

Fig. 4. Representation of Lemma 4.3, case e = e1[ 1].
Without loss of generality, F! 's reduction semantics requires the argument of a -redex to be a value. Only - and -abstractions are considered values. The representation of the rules is given in Figure 5.

6	Type Soundness

By construction, the operational semantics of F! is type preserving. A quick inspection of the evaluation rules reveals that repeated applications of indi- vidual reduction steps must terminate, because the number of -redices in a term (on term and type level) decreases with every individual step.
Theorem 6.1 (Termination) If ` e : , then all sequences of evaluation steps originating from e are nite.
We can assume the context in which e is well-typed to be empty, because the reduction semantics does not evaluate under -binders. Therefore, the question of type soundness reduces to the question of progress that ensures that the evaluation never gets stuck.
Theorem 6.2 (Progress) If  ` e :  then either e is a value or there exists a e0 , s.t. e 7! e0 .
The proof of this theorem is by induction on e. Unfortunately, Twelf's au- tomatic deduction facilities are currently still in preliminary state and cannot be employed to prove the progress theorem automatically. A hand-coded proof

val	: exp C ! type

vallam	: val (abs C) valplam : val (Abs C)
7!	: exp (C : can T ) ! exp (C : can T ) ! type:

ev beta	: (app (abs E) V ) 7! (E V )  val V: ev pbeta : (App (Abs E) T C  R C0 ) 7! E0
  subst C  E C  R0 C0 E0 :
ev app	: app E1 E2 7! app E10 E2   E1 7! E10 :
ev app	: app V E2 7! app V E20   val V   E2 7! E20 :


ev papp : App E A CA
R P 7! App E0 A C 
R P   E 7! E0 :


 
7!	: exp C ! exp C ! type:

ev trans : E2 7! E3 ! E1 7! E2 ! E1 7! E3:
 
ev re	: E 7! E:

Fig. 5. Encoding of the operational semantics.


is feasible and can be found in [17]. The disjunction used in the formulation of Theorem 6.2 is pushed down again to the LF level and called \val_eval".


val_eval : exp C ! type
ve val	: val E ! val_eval E
ve eval	: E 7! E0 ! val_eval E

progress :  E : exp C: val_eval E ! type


The representation of the progress proof in LF is mostly straightforward, however it relies on the property that substitution of types into terms from the previous section is total. Informally true, this property must be formalized explicitly in LF. For a complete development of this (and related) theorems and their proofs consult [17].

bool = 80 ( a : tp o: u : at a: j ) @ (j u) @ (j ) @ (j u) @ (j u))) true : exp bool
=  0 ( a : tp o:  u : at a: i : a  a:
 0 ( t : exp (j u): 0 ( f : exp (j u): t))) false : exp bool
=  0 ( a : tp o:  u : at a: i : a  a:
 0 ( t : exp (j u): 0 ( f : exp (j u): f ))) if	: exp (80 ( a : tp o: u : at a:
j ) @ (j u) @ (j ) @ (j u) @ (j ) @ bool @ (j u)))))
=  0 ( a : tp o: u : at a: i : a  a:
 0 ( x : exp (j u): 0 ( y : exp (j u): 0 ( e : exp bool: (app (app (App e a (j u)
(tapp (tapp tarr i) (tapp (tapp tarr i) i))
(j ) @ (j u) @ (j ) @ (j u) @ (j u)))) x) y)))) Fig. 6. Encoding of Booleans in F! .
7	Example

F! can be used to de ne new types, values, and the corresponding elimina- tion principles for Booleans, natural numbers, pairs, and sum types [6]. By construction all formally encoded objects, types and kinds are well-typed and well-kinded, respectively. We demonstrate how to use our encoding of F! by de ning Booleans values and the corresponding elimination principle as depicted in Figure 6.
Using Twelf, we can experiment easily with this encoding, and verify that the standard properties hold, namely that for any type , and well-typed terms e1 , e2
 
if[ ] e1 e2 true 7! e1
 
if[ ] e1 e2 false 7! e2 :
One disadvantage of our representation is that all terms that make use of the rule of polymorphic application, such as `if[ ]', tend to become very large. This is due to the fact that all assumptions about canonicity and congruence relation are expected to be made explicit. On the other hand these annotations can be automatically generated especially in the setting where we foresee this encoding of F! to be used: as a target language inside the implementation of

a compiler.

8	Conclusion

The main contribution of this paper is an encoding of F! in the meta-logical framework Twelf. It is elegant, precise, and its main bene ts include a formal representation of well-typed terms and a type-preserving operational seman- tics. We have shown in Twelf that F! is type sound. The main bene ts of this encoding is that the LF type checker su√Üces to decide well-typedness. Terms are indexed by proofs that witness the canonicity of its type, which in turn contain all necessary kind information.
We view this paper as a case study on how to use meta-logical frameworks in the design, implementation, and veri cation process of datastructures and algorithms. Speci cally, the main motivation of this work stems from the area of safe intermediate languages. The encoding and the properties of F! are not just of signi cant theoretical interest, but have also many practical applications related to compilers and proof carrying code.
In future work we plan to extend F! to Mini-FLINT [10] by adding other features namely row polymorphism, type tuples, sum types, existentials, xed- point and contextual recursive types. Mini-FLINT can serve as target lan- guage for compiling Featherweight Java [10]. We also plan to develop a com- piler from mini-FLINT to typed assembly language [18] and to develop veri - able safe compilation techniques within the meta-logical framework, possibly all the way down to machine code. Finally, we plan to extend F! to support intensional type analysis in the spirit of [8,19]. Applications of intensional type analysis include tagless garbage collection and polymorphic marshalling.

Acknowledgement

We would like to thank Valery Trifonov and Zhong Shao for many helpful discussions.

References

[1] Robert L. Constable et al. Implementing Mathematics with the Nuprl Proof Development System. Prentice-Hall, Englewood Cli s, New Jersey, 1986.
[2] Thierry Coquand.  An algorithm for testing conversion in type theory.  In G erard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 255{279. Cambridge University Press, 1991.
[3] Joelle Despeyroux, Frank Pfenning, and Carsten Schurmann. Primitive recursion for higher-order abstract syntax. In R. Hindley, editor, Proceedings of the Third International Conference on Typed Lambda Calculus and Applications (TLCA'97), pages 147{163, Nancy, France, April 1997. Springer-Verlag LNCS.

An extended version is available as Technical Report CMU-CS-96-172, Carnegie Mellon University.
[4] Gilles Dowek, Amy Felty, Hugo Herbelin, G erard Huet, Chet Murthy, Catherine Parent, Christine Paulin-Mohring, and Benjamin Werner. The Coq proof assistant user's guide. Rapport Techniques 154, INRIA, Rocquencourt, France, 1993. Version 5.8.
[5] J.-Y. Girard. Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. These D'Etat, Universite Paris VII, 1972.
[6] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types. Cambridge Tracts in Theoretical Computer Science 7. Cambridge University Press, 1988.
[7] Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for de ning logics. Journal of the Association for Computing Machinery, 40(1):143{184, January 1993.
[8] Robert Harper and Greg Morrisett. Compiling polymorphism using intensional type analysis. In Conference Record of POPL '95: 22nd ACM SIGPLAN- SIGACT Symposium on Principles of Programming Languages, pages 130{141, San Francisco, California, 1995.
[9] Martin Hofmann.  Semantical analysis for higher-order abstract syntax.  In
G. Longo, editor, Proceedings of the 14th Annual Symposium on Logic in Computer Science (LICS'99), pages 204{213, Trento, Italy, July 1999. IEEE Computer Society Press.
[10] Christopher League, Valery Trifonov, and Zhong Shao. Type-preserving compilation of featherweight Java. In Foundations of Object-Oriented Languages (FOOL8), London, January 2001.
[11] G. Morrisett, D. Walker, K. Crary, and N. Glew. From system F to typed assembly language. In In 25th ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, pages 85{97, San Diego California, USA, 1998. ACM Press.
[12] George C. Necula. Proof-carrying code. In Neil D. Jones, editor, Conference Record of the 24th Symposium on Principles of Programming Languages (POPL'97), pages 106{119, Paris, France, January 1997. ACM Press.
[13] Lawrence C. Paulson. Isabelle: A Generic Theorem Prover. Springer-Verlag LNCS 828, 1994.
[14] Frank Pfenning.  Logic programming in the LF logical framework. In G erard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 149{181. Cambridge University Press, 1991.
[15] Frank Pfenning. A proof of the Church-Rosser theorem and its representation in a logical framework. Journal of Automated Reasoning, 1993. To appear. A preliminary version is available as Carnegie Mellon Technical Report CMU-CS- 92-186, September 1992.

[16] Frank Pfenning and Carsten Schurmann. System description: Twelf | a meta- logical framework for deductive systems. In H. Ganzinger, editor, Proceedings of the 16th International Conference on Automated Deduction (CADE-16), pages 202{206, Trento, Italy, July 1999. Springer-Verlag LNAI 1632.
[17] Carsten Schurmann, Dachuan Yu, and Zhaozhong Ni. A representation of F! in LF. http://www.cs.yale.edu/  carsten/public/merlin01.elf, 2001.
[18] Zhong Shao. Implementing typed intermediate language. In Proc. 1998 ACM SIGPLAN International Conference on Functional Programming (ICFP'98), pages 313{323, Baltimore, Maryland, September 1998.
[19] Valery Trifonov, Bratin Saha, and Zhong Shao. Fully re exive intensional type analysis. In Proc. 2000 ACM SIGPLAN International Conference on Functional Programming (ICFP'00), pages 82{93. ACM Press, September 2000.
