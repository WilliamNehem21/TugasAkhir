Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 336 (2018) 155–171
www.elsevier.com/locate/entcs

A Categorical Foundation for Structured Reversible Flowchart Languages
Robert Glu¨ck2 Robin Kaarsgaard3
DIKU, Department of Computer Science, University of Copenhagen

Abstract
Structured reversible flowchart languages is a class of imperative reversible programming languages allowing for a simple diagrammatic representation of control flow built from a limited set of control flow structures, as ordinary structured flowcharts allow for conventional languages. This class includes the reversible programming language Janus (without recursion), as well as more recently developed reversible programming languages such as R-CORE and R-WHILE. In the present paper, we develop a categorical foundation for this class of languages based on inverse categories with joins. We generalize the notion of extensivity of restriction categories to one that may be accommodated by inverse categories, and use the resulting decision maps to give a reversible representation of predicates and assertions. This leads to a categorical semantics for structured reversible flowcharts, from which we show that a program inverter can be extracted. Finally, we exemplify our approach by the development of a small structured reversible flowchart language, use our framework to both straightforwardly give it semantics and derive fundamental theorems about it, and discuss further applications of decisions in reversible programming.
Keywords: Reversible computing, flowchart languages, structured programming, denotational semantics, category theory

Introduction
Reversible computing is an emerging paradigm that adopts a physical principle of reality into a computation model without information erasure. Reversible computing extends the standard forward-only mode of computation with the ability to execute in reverse as easily as forward. Reversible computing is a necessity in the context of quantum computing and some bio-inspired computation models. Regardless of the physical motivation, bidirectional determinism is interesting in its own right. The potential benefits include the design of innovative reversible architectures (e.g., [23,22,25]), new programming models and techniques (e.g., [27,11,19]), and the enhancement of software with reversibility (e.g., [5]).

1 The authors acknowledge the support given by COST Action IC1405 Reversible computation: Extending horizons of computing. We also thank the anonymous reviewers for their thoughtful and detailed comments.
2 Email: glueck@acm.org
3 Email: robin@di.ku.dk

https://doi.org/10.1016/j.entcs.2018.03.021
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

The semantics of reversible programming languages are usually formalized using traditional metalanguages such as structural operational semantics or denotational semantics based on complete partial orders. However, these are geared towards the definition of conventional programming languages. The fundamental properties of a reversible language are not naturally captured by these metalanguages and are to be shown individually for each semantic definition, such as the required backward determinism and the invertibility of object language programs.
This paper aims at providing a new categorical foundation specifically for for- malizing reversible programming languages, in particular the semantics of reversible structured flowchart languages [24], which are the reversible counterpart of the structured programming languages used today. This formalization is based on join inverse categories with a developed notion of extensivity for inverse categories, which gives rise to natural representations of predicates and assertions, and consequently to models of reversible structured flowcharts. The goal is to provide a framework for modelling these languages, such that the reversible semantic properties of the object language are naturally ensured by the meta language.
The semantic framework we are going to present in this paper covers the reversible structured languages regardless of their concrete formation, such as atomic operations, elementary predicates, and value domains. Reversible programming languages that are instances of this computation model include the imperative language Janus [27] without recursion, and the while languages R-WHILE and R-CORE with dynamic data structures [12,13]. Further, unstructured reversible flowchart languages, such as reversible assembly languages with jumps [9,2], can be transformed into structured ones thanks to the structured reversible program theorem [24].
Overview: In Section 2, we give an introduction to structured reversible flowchart languages, while Section 3 describes the restriction and inverse category theory used as backdrop in later sections. In Section 4, we warm up by developing a notion of extensivity for inverse categories, based on extensive restriction categories and its associated concept of decisions. Then, in Section 5, we put it all to use by showing how decisions may be used to model predicates and ultimately also reversible flowcharts, and use this to extract a program inverter. In Section 6, we develop a small language to exemplify our framework, and discuss other applications in reversible programming. Section 7 offers some concluding remarks.

Reversible structured flowcharts
Structured reversible flowcharts naturally model the control flow behavior of reversible (imperative) programming languages in a simple diagrammatic representation, as classical flowcharts do for conventional languages. A crucial difference is that atomic steps are limited to partial injective functions and they require an additional assertion, an explicit orthogonalizing condition, at join points in the control flow.
A structured reversible flowchart F is built from four blocks (Fig. 1): An atomic step that performs an elementary operation on a domain X specified by a partial injective function a : X ~ X; a while loop over a block B with entry assertion

) B1
,,	t

,vt ,	 		 	

)
)	)t

p1  )/p2  t)  )/p1 
p2	)

  /	 ˆJ
f	f
B2
(a) Step	(b) While loop	(c) Selection	(d) Sequence Fig. 1. Structured reversible flowcharts.


p1 : X → Bool and exit test p2 : X → Bool ;a selection of block B1 or B2 with entry test p1 : X → Bool and exit assertion p2 : X → Bool ; and a sequence of blocks B1 and B2.
A structured reversible flowchart F consists of one main block. Blocks have unique entry and exit points, and can be nested any number of times to form more complex flowcharts. The interpretation of F consists of a given domain X (typically, a store) and a finite set of partial injective functions a and predicates p : X → Bool . Computation starts at the entry point of F in an initial x0 (the input), proceeds sequentially through the edges of F , and ends at the exit point of F in a final xn (the output), if F is defined on the given input.
The assertion p1 in a reversible while loop (marked by the circle) is a new flowchart operator: the predicate p1 must be true when the control flow reaches the assertion along the t-edge, and false when it reaches the assertion along the f -edge; otherwise, the loop is undefined. The test p2 (marked by a diamond) has the usual semantics. This means that B in a loop is repeated as long as p1 and p2 are false. The selection has an assertion p2, which must be true when the control flow reaches the assertion from B1, and false when the control flow reaches the assertion from B2; otherwise, the selection is undefined. As usual, the test p1 selects B1 or
B2. The assertion makes the selection reversible.
Despite their simplicity, reversible structured flowcharts are reversibly univer- sal [1], which means that they are computationally as powerful as any reversible programming language can be. Given a suitable domain X for finite sets of atomic operations and predicates, there exists, for every injective computable function f : X → Y , a reversible flowchart F that computes f .
Reversible structured flowcharts (Fig. 1) have a straightforward representation as program texts defined by the grammar

B ::= a | from p loop B until p | if p then B else B fi p | B ; B . 

Reversible structured flowcharts defined above corresponds to the reversible language R-WHILE [12], but their value domain, atomic functions and predicates are unspecified. As a minimum, a reversible flowchart needs blocks (a,b,d) because selection (c) can be simulated by combining while loops that conditionally skip the body block or execute it once. R-CORE [13] is an example of such a minimal language.

Restriction and inverse categories
The following section contains the background on restriction and inverse category theory necessary for our later developments. Unless otherwise specified, the defini- tions and results presented in this section can be found in introductory texts on the subject (e.g., [10,14,6,7,8]).
Restriction categories [6,7,8] axiomatize categories of partial maps. This is done by assigning to each morphism f a restriction idempotent f , which we think of as a partial identity defined precisely where f is. Formally, restriction categories are defined as follows.
Definition 3.1 A restriction category is a category C equipped with a combinator
f	f
mapping each morphism A −→ B to a morphism A −→ A satisfying

	

f ◦ f = f ,
g ◦ f = f ◦ g,
f ◦ g = f ◦ g, and
g ◦ f = f ◦ g ◦ f

for all suitable g.
As an example, the category Pfn of sets and partial functions is a restriction category, with f (x)= x if f is defined at x, and undefined otherwise. Note that being a restriction category is a structure, not a property; a category may be a restriction category in several different ways (e.g., assigning f = id for each morphism f gives a trivial restriction structure to any category).
f

In restriction categories, we say that a morphism A −→ B is total if f = idA, and
f†
a partial isomorphism if there exists a (necessarily unique) partial inverse B −→ A

such that f† ◦ f = f and f ◦ f† = f†. Isomorphisms are then simply the total partial isomorphisms with total partial inverses. An inverse category can then be defined as a special kind of restriction category 4 .
Definition 3.2 An inverse category is a restriction category where each morphism is a partial isomorphism.
Every restriction category C gives rise to an inverse category Inv(C ), which has as objects all objects of C , and as morphisms all of the partial isomorphisms of
C . As such, since partial isomorphisms in Pfn are partial injective functions, a canonical example of an inverse category is the category Inv(Pfn) ∼= PInj of sets and partial injective functions.
Since each morphism in an inverse category has a unique partial inverse, as also suggested by our notation this makes inverse categories canonically dagger categories [20], in the sense that they come equipped with a contravariant endofunctor

(−)† satisfying f = f†† and id†
= idA for each morphism f and object A.

Given two restriction categories C and D , the well-behaved functors between them are restriction functors, i.e., functors F satisfying F (f )= F (f ). Analogous to how

4 This is a rather modern definition due to [6]. Originally, inverse categories were defined as the categorical extensions of inverse semigroups; see [18].

regular semigroup homomorphisms preserve partial inverses in inverse semigroups, when C and D are inverse categories, all functors between them are restriction functors; specifically they preserve the canonical dagger, i.e., F (f†)= F (f )†.
Partial order enrichment and joins
A consequence of how restriction (and inverse) categories are defined is that hom sets C (A, B) may be equipped with a partial order given by f ≤ g iff g ◦ f = f (this extends to an enrichment in the category of partial orders and monotone functions). Intuitively, this states that f is below g iff g behaves exactly like f when restricted to the points where f is defined. A sufficient condition for each C (A, B) to have a least element is that C has a restriction zero; a zero object 0 in the usual sense
0A,A	0A,A
which additionally satisfies A −−−→ A = A −−−→ A for each endo-zero map 0A,A.
One may now wonder when C (A, B) has joins as a partial order. Unfortunately, C (A, B) has joins of all morphisms only in very degenerate cases. However, if instead of considering arbitrary joins we consider joins of maps that are somehow compatible, this becomes much more viable.
Definition 3.3 In a restriction category, say that parallel maps f and g are disjoint
iff f ◦ g = 0; and compatible iff f ◦ g = g ◦ f .
It can be shown that disjointness implies compatibility, as disjointness is expect- edly symmetric. Further, we may extend this to say that a set of parallel morphisms is disjoint iff each pair of morphisms is disjoint, and likewise for compatibility. This gives suitable notions of join restriction categories.
Definition 3.4 A restriction category C has compatible (disjoint) joins if it has
a restriction zero, and satisfies that for each compatible (disjoint) subset S of any hom set C (A, B), there exists a morphism Ws∈S s such that
s ≤ Ws∈S s for all s ∈ S, and s ≤ t for all s ∈ S implies Ws∈S s ≤ t;
f ◦ Ws∈S s = Ws∈S (f ◦ s) for all f : B → X; and
Ws∈S s ◦ g = Ws∈S (s ◦ g) for all g : Y → A.
For inverse categories, the situation is a bit more tricky, as the join of two compatible partial isomorphisms may not be a partial isomorphism. To ensure this, we need stronger relations:
Definition 3.5 In an inverse category, say that parallel maps f and g are disjoint

iff f ◦ g = 0 and f† ◦ g† = 0; and compatible iff f ◦ g = g ◦ f and f† ◦ g† = g† ◦ f†.
We may now extend this to notions of disjoint sets and compatible sets of morphisms in inverse categories as before. This finally gives notions of join inverse categories:
Definition 3.6 An inverse category C has compatible (disjoint) joins if it has a restriction zero and satisfies that for all compatible (disjoint) subsets S of all hom

sets C (A, B), there exists a morphism ∨s∈Ss satisfying (i) – (iv) of Definition 3.4.
A functor F between restriction (or inverse) categories with joins is said to be join-preserving when F (Ws∈S s)= Ws∈S F (s).
Restriction coproducts, extensivity, and related concepts
While a restriction category may very well have coproducts, these are ultimately only well-behaved when all coproduct injections are total; if this is the case, we say that the restriction category has restriction coproducts. If a restriction category has all finite restriction coproducts, it also has a restriction zero serving as unit.
In [8], it is shown that the existence of certain maps, called decisions, in a restriction category C with restriction coproducts leads to the subcategory Total(C ) of total maps being extensive (in the sense of, e.g., [4]). This leads to the definition of an extensive restriction category 5 .
Definition 3.7 A restriction category is said to be extensive (as a restriction category) if it has restriction coproducts and a restriction zero, and for each map
f	⟨f⟩
A −→ B + C there is a unique decision A −−→ A + A satisfying

(D.1) ∇◦ ⟨f⟩ = f and	(D.2) (f + f ) ◦ ⟨f⟩ = (κ1 + κ2) ◦ f .
In the above, ∇ denotes the codiagonal [id, id]. A consequence of these axioms is that each decision is a partial isomorphism; one can show that ⟨f⟩ must be
partial inverse to [κ† ◦ f, κ† ◦ f ] (see [8]). Further, when a restriction category with
1	2
restriction coproducts has finite joins, it is also extensive with ⟨f⟩ = κ1 ◦κ† ◦ f ∨κ2 ◦
†	⟨f⟩	f
κ2 ◦ f . As an example, Pfn is extensive with A −−→ A + A for A −→ B + C given by

⟨f⟩(x)= ⎪⎨ κ2(x)	if f (x)= κ2(z) for some z ∈ C .
⎪⎪⎩ undefined if f (x) is undefined
While inverse categories only have coproducts (much less restriction coproducts) in very degenerate cases (see [10]), they may very well be equipped with a more general sum-like symmetric monoidal tensor, a disjointness tensor.
Definition 3.8 A disjointness tensor on a restriction category is a symmetric monoidal restriction functor −⊕− satisfying that its unit is the restriction zero, and that the canonical maps


ρ−1
id⊕0
λ−1
0⊕id

M1 = A −−→ A ⊕ 0 −−−→ A ⊕ B	M2 = B −−→ 0 ⊕ B −−−→ A ⊕ B

5 The name is admittedly mildly confusing, as an extensive restriction category is not extensive in the usual sense. Nevertheless, we stay with the established terminology.

are jointly epic, where ρ respectively λ is the left respectively right unitor of the monoidal functor −⊕ −.
It can be straightforwardly shown that any restriction coproduct gives rise to a disjointness tensor. A useful interaction between compatible joins and a join- preserving disjointness tensor in inverse categories was shown in [3,17], namely that it leads to a †-trace (in the sense of [16,21]):
Proposition 3.9 Let C be an inverse category with (at least countable) compatible joins and a join-preserving disjointness tensor. Then C has a trace operator given by

U A,B
(f ) = f11 ∨  f21 ◦ f22 ◦ f12
n∈ω

satisfying TrU
(f )† = TrU
(f†), where fij = M† ◦ f ◦ Mi.

Extensivity of inverse categories
As discussed earlier, extensivity of restriction categories hinges on the existence of certain partial isomorphisms – decisions – yet their axiomatization relies on the presence of a map that is not a partial isomorphism, the codiagonal.
In this section, we tweak the axiomatization of extensivity of restriction categories to one that is equivalent, but additionally transports more easily to inverse categories. We then give a definition of extensitivity for inverse categories, from which it follows that Inv(C ) is an extensive inverse category when C is an extensive restriction category.
Recall that decisions satisfy the following two axioms:

(D.1) ∇◦ ⟨f⟩ = f and	(D.2) (f + f ) ◦ ⟨f⟩ = (κ1 + κ2) ◦ f
As mentioned previously, an immediate problem with this is the reliance on the codiagonal. However, intuitively, what (D.1) states is simply that the decision ⟨f⟩ cannot do anything besides to tag its inputs appropriately. Using a disjoint join, we reformulate this axiom to the following:
(D’.1) (κ† ◦ ⟨f⟩) ∨ (κ† ◦ ⟨f⟩)= f
1	2
Note that this axiom also subtly states that disjoint joins of the given form always exist. Say that a restriction category is pre-extensive if it has restriction coproducts,
f
a restriction zero, and a combinator mapping each map A −→ B + C to a pre-decision
⟨f⟩
A −−→ A + A (with no additional requirements). We can then show the following:
Theorem 4.1 Let C be a pre-extensive restriction category. The following are equivalent:
C is an extensive restriction category.
Every pre-decision of C satisﬁes (D.1) and (D.2).
Every pre-decision of C satisﬁes (D’.1) and (D.2).

Another subtle consequence of our amended first rule is that κ† ◦ ⟨f⟩ is its own restriction idempotent (and likewise for κ† ) since κ† ◦ ⟨f⟩≤ (κ† ◦ ⟨f⟩) V (κ† ◦ ⟨f⟩)= 
2	1	1	2
f ≤ id, as the maps below identity are precisely the restriction idempotents.
Our next snag in transporting this definition to inverse categories has to do with the restriction coproducts themselves, as it is observed in [10] that any inverse category with restriction coproducts is a preorder. Intuitively, the problem is not that unicity of coproduct maps cannot be guaranteed in non-preorder inverse categories,
[f,g]
but rather that the coproduct map A + B ——→ C in a restriction category is not
guaranteed to be a partial isomorphism when f and g are.
For this reason, we will consider the more general disjointness tensor for sum-like constructions rather than full-on restriction coproducts, as inverse categories may very well have a disjointness tensor without it leading to immediate degeneracy. Notably, PInj has a disjointness tensor, constructed on objects as the disjoint union of sets (precisely as the restriction coproduct in Pfn, but without the requirement of a universal mapping property). This leads us to the following definition:
Definition 4.2 An inverse category with a disjointness tensor is said to be extensive
f	⟨f⟩
when each map A —→ B ⊕ C has a unique decision A ——→ A ⊕ A satisfying
(D’.1) (M† ◦ ⟨f⟩) V (M† ◦ ⟨f⟩)= f
1	2
(D’.2) (f ⊕ f ) ◦ ⟨f⟩ = (M1 ⊕ M2) ◦ f .
As an example, PInj is an extensive inverse category with the unique decision
⟨f⟩	f
A ——→ A ⊕ A for a partial injection A —→ B ⊕ C given by
⎧ M1(x)	if f (x)= M1(y) for some y ∈ B
⟨f⟩(x)=	M2(x)	if f (x)= M2(z) for some z ∈ C	.
⎪⎪⎩ undefined if f (x) is undefined
Aside from a shift from coproduct injections to the quasi-injections of the disjointness tensor, a subtle change here is the notion of join. That is, for restriction categories with disjoint joins, any pair of maps f, g with f ◦ g = 0 has a join – but for inverse categories, we additionally require that their inverses are disjoint as well, i.e., that f† ◦ g† = 0, for the join to exist. In this case, however, there is no difference between the two. As previously discussed, a direct consequence of this axiom is that each M† ◦ ⟨f⟩ must be its own restriction idempotent. Since restriction idempotents are self-adjoint (i.e., satisfy f = f†), they are disjoint iff their inverses are disjoint.
Since restriction coproducts give rise to a disjointness tensor, we may straightfor- wardly show the following theorem.
Theorem 4.3 When C is an extensive restriction category, Inv(C ) is an extensive inverse category.

Further, constructing the decision ⟨f⟩ as (M1 ◦ M† ◦ f ) V (M2 ◦ M† ◦ f ) (i.e.,
1	2
mirroring the construction of decisions in restriction categories with disjoint joins),

we may show the following.
Theorem 4.4 Let C be an inverse category with a disjointness tensor, a restriction zero, and ﬁnite disjoint joins. Then C is extensive as an inverse category.
Modelling structured reversible flowcharts
In the following, let C be an inverse category with (at least countable) compatible joins and a join-preserving disjointness tensor. As disjoint joins are compatible, it follows that C is an extensive inverse category with a (uniform) †-trace operator.
In this section, we will show how this framework can be used model reversible structured flowchart languages. First, we will show how decisions in extensive inverse categories can be used to model predicates, and how this representation extends to give very natural semantics to reversible flowcharts corresponding to conditionals and loops. Then we will use the “internal program inverter” given by the canonical dagger functor on C to extract a program inverter for reversible flowcharts.

Predicates as decisions
In suitably equipped categories, one naturally considers predicates on an object A as given by maps A → 1 + 1. In inverse categories, however, the mere idea of a predicate as a map of the form A → 1 ⊕ 1 is problematic, as only very degenerate maps of this form are partial isomorphisms. In the following, we show how decisions give rise to an unconventional yet ultimately useful representation of predicates. To our knowledge this representation is novel, motivated here by the necessity to model predicates in a reversible fashion, as decisions are always partial isomorphisms.
The simplest useful predicates are the predicates that are always true respectively always false. By convention, we represent these by the left respectively right injection (which are both their own decisions),
Jtrue) = M1
Jfalse) = M2.
Semantically, we may think of decisions as a separation of an object A into witnesses and counterexamples of the predicate it represents. In a certain sense, the axioms of decisions say that there is nothing more to a decision than how it behaves when
postcomposed with M† or M† . As such, given the convention above, we think of
M† ◦⟨p⟩ as the witnesses of the predicate represented by the decision ⟨p⟩, and M† ◦ ⟨p⟩
1	2
as its counterexamples.
With this in mind, we turn to boolean combinators. The negation of a predicate- as-a-decision must simply swap witnesses for counterexamples (and vice versa). In other words, we obtain the negation of a decision by postcomposing with the commutator γ of the disjointness tensor,
Jnot p) = γ ◦ Jp) .

With this, it is straightforward to verify that, e.g., Jnot true) = Jfalse), as
−1	−1
Jnot true) = γ◦M1 = γ◦id⊕0◦ρ	= 0⊕id◦γ◦ρ	= 0⊕id◦λ	= M2 = Jfalse) .

For conjunction, we exploit that our category has (specifically) finite disjoint joins, and define the conjunction of predicates-as-decisions Jp) and Jq) by

†	†	†	†
Jp and q) = (M1 ◦ M1 ◦ Jp) ◦ M1 ◦ Jq)) V (M2 ◦ (M2 ◦ Jp) V M2 ◦ Jq))).
The intuition behind this definition is that the witnesses of a conjunction of predicates is given by the meet of the witnesses of the each predicate, while the counterexamples of a conjunction of predicates is the join of the counterexamples of each predicate. Noting that the meet of two restriction idempotents is given by their composition, this is precisely what this definition states. Similarly we define the disjunction of Jp) and Jq) by

†	†	†	†
Jp or q) = (M1 ◦ (M1 ◦ Jp) V M1 ◦ Jq))) V (M2 ◦ (M2 ◦ Jp) ◦ M2 ◦ Jq))),
as p or q  then has as witnesses the join of the witnesses of p  and q , and as counterexamples the meet of the counterexamples of p and q . With these definitions, it can be shown that, e.g., the De Morgan laws are satisfied.
That all of these are indeed decisions can be shown straightforwardly, as summa- rized in the following closure theorem.
Theorem 5.1 Decisions in C are closed under Boolean negation, conjunction, and disjunction.

Reversible structured flowcharts, categorically
To give a categorical account of structured reversible flowchart languages, we assume the existence of a suitable distinguished object Σ of stores, which we think of as the domain of computation, such that we may give denotations to structured reversible flowcharts as morphisms Σ → Σ.
Since atomic steps (corresponding to elementary operations, e.g., store updates) may vary from language to language, we assume that each such atomic step in our language has a denotation as a morphism Σ → Σ. In the realm of reversible flowcharts, these atomic steps are required to be partial injective functions; here, we abstract this to require that their denotation is a partial isomorphism (though this is a trivial requirement in inverse categories).
Likewise, elementary predicates (e.g., comparison of values in a store) may vary from language to language, so we assume that such elementary predicates have denotations as well as decisions Σ → Σ ⊕ Σ. If necessary (as is the case for Janus [27]), we may then close these elementary predicates under boolean combinations as discussed in the previous section.
To start, we note how sequencing of flowcharts may be modelled trivially by

means of composition, i.e.,


Jc1 ; c2) = Jc2) ◦ Jc1)

or, using the diagrammatic notation of flowcharts and the string diagrams for monoidal categories in the style of [21] (read left-to-right and bottom-to-top),


 )

)

) =	.


To extend this elementary model to one that additionally models reversible condi- tionals, we observe that the partial inverse to a decision is precisely its corresponding assertion. Intuitively, a decision separates an object into witnesses (in the first component) and counterexamples (in the second). As such, the partial inverse to a decision must be defined only on witnesses in the first component, and only on counterexamples in the second.
With this in mind, we achieve a denotation of reversible conditionals as


Jif p then c1 else c2 fi q) = Jq)
or, as diagrams
◦ Jc1) ⊕ Jc2) ◦ Jp)



) c1
t
¨ )/ 
,
,vt ,¨

 	
¨	¨


It is straightforward to see that this has the usual operational behavior of reversible conditionals. For example, when Jp) = Jq) = Jtrue) we get
†
Jif p then c1 else c2 fi q) = Jq) ◦ Jc1) ⊕ Jc2) ◦ Jp)
= Jtrue)† ◦ Jc1) ⊕ Jc2) ◦ Jtrue)
= M† ◦ Jc1) ⊕ Jc2) ◦ M1 = Jc1)
and analogously for the symmetric case.
For reversible loops, we use the †-trace operator to obtain the denotation
Σ	†
Jfrom q loop c until p) = TrΣ,Σ(idΣ ⊕ Jc) ◦ Jp) ◦ Jq) )
or diagrammatically
, )t	q ,)/p  t),
¨˛  J /	¨¸ =	.


That this has the desired operational behavior follows from the fact that the †-trace operator is canonically constructed in join inverse categories as


U X,Y
(f ) = f11 V   f21 ◦ fn ◦ f12 .
n∈ω

Recall that fij = M† ◦ f ◦ Mi. As such, for our loop construct defined above, the f11-cases correpond to cases where a given state bypasses the loop entirely; f21 ◦ f12 (that is, for n = 0) to cases where exactly one iteration is performed by a given state before exiting the loop; f21 ◦ f22 ◦ f12 to cases where two iterations are performed before exiting; and so on. In this way, the given trace semantics contain all successive loop unrollings, as desired.
While it may seem like a small point, the mere existence of a categorical semantics in inverse categories for a reversible programming language has some immediate benefits. In particular, that a programming language is reversible can be rather complicated to show by means of operational semantics (see, e.g., [27, Sec. 2.3]), yet it follows directly in our categorical semantics, as all morphisms in inverse categories have a unique partial inverse. Additionally, reversible loops are significantly easier to work with categorically as †-traces than operationally; the operational semantics of Janus [27, Fig. 4] demonstrate adequately just how difficult it can be to give an operational semantics for reversible loops.
Extracting a program inverter
A desirable syntactic property for reversible programming languages is to be closed under program inversion, in the sense that for each program p, there is another program I[p] such that I[p] = p †. Janus, R-WHILE, and R-CORE [27,12,13] are all examples of reversible programming languages with this property. This is typically witnessed by a program inverter, that is, a procedure mapping the program text of a program to the program text of its inverse program 6 .
Suppose that we are given a language where elementary operations are closed under program inversion (i.e., where each elementary operation b has an inverse I[b] such that I[b] = b †). We can extend this to a program inverter for reversible conditionals and loops as follows, by structural induction with the hypothesis that I[c] = c . Given some conditional statement if p then c1 else c2 fi q, we notice that
Jif p then c1 else c2 fi q) = (Jq) ◦ Jc1) ⊕ Jc2) ◦ Jp))
= Jp)† ◦ Jc1)† ⊕ Jc2)† ◦ Jq)††
= Jp)† ◦ Jc1)† ⊕ Jc2)† ◦ Jq)
= Jp)† ◦ JI[c1]) ⊕ JI[c2]) ◦ Jq)
= Jif q then I[c1] else I[c2] fi p)

6 While semantic inverses are unique, their program texts generally are not. As such, a programming language may have many different sound and complete program inverters, though they will all be equivalent up to program semantics.

which yields the inversion rule
I[if p then c1 else c2 fi q]= if q then I[c1] else I[c2] fi p .

Fortunately, this is precisely the usual inversion rule for reversible conditionals (see,
e.g., [12,13]). For reversible loops, we have

†	Σ	† †
Jfrom q loop c until p) = TrΣ,Σ(idΣ ⊕ Jc) ◦ Jp) ◦ Jq) )

Σ Σ,Σ
Σ Σ,Σ
Σ Σ,Σ
Σ Σ,Σ
((idΣ ⊕ Jc) ◦ Jp) ◦ Jq)†)†) (Jq) ◦ Jp)† ◦ idΣ ⊕ Jc)†) (idΣ ⊕ Jc)† ◦ Jq) ◦ Jp)†) (idΣ ⊕ JI[c]) ◦ Jq) ◦ Jp)†)

= Jfrom p loop I[c] until q)

where the fact that it is a †-trace allows us to move the dagger inside the trace, and dinaturality of the trace in the second component allows us to move idΣ ⊕ c † from the very right to the very left. This gives us the inversion rule
I[from q loop c until p]= from p loop I[c] until q

which matches the usual inversion rule for reversible loops [13]. We summarize this in the following theorem:
Theorem 5.2 If a reversible structured flowchart language is syntactically closed under inversion of elementary operations, it is also closed under inversion of reversible conditionals and loops.

Applications
In this section, we briefly cover some applications of the developed theory: We introduce a small reversible flowchart language and use the results from the previous sections to give it semantics, and discuss how decisions may be used as a programming technique to naturally represent predicates in a reversible functional language.

Example: A reversible flowchart language
Consider the following family of (neither particularly useful nor particularly useless) reversible flowchart languages for reversible computing with integer data, RINTk. RINTk has precisely k variables available for storage, denoted x1 through xk (of which x1 is designated by convention as the input/output variable), and its only atomic operations are addition and subtraction of variables, as well as addition with a constant. Variables are used as elementary predicates, with zero designating truth and non-zero values all designating falsehood. For control structures we have


Σ= Zk
Jxi) (a ,...,a )= , M1(a1,..., ak)	if ai =0 
Jxi += xj) (a1,..., ak)= (a1,..., ai−1, ai + aj ,..., ak)
Jxi += n) (a1,..., ak)= (a1,..., ai−1, ai + n,..., ak)
Jxi —= xj) (a1,..., ak)= (a1,..., ai−1, ai — aj ,..., ak)

Fig. 2. The object of stores and semantics of elementary operations and predicates of RINTk in PInj.
reversible conditionals and loops, and sequencing as usual. This gives the syntax:
p ::= true | false | xi | p and p | not p	(Tests)
c ::= c ; c | xi += xj | xi —= xj | xi += n
| if p then c else c fi p
| from p loop c until p	(Commands)
Here, n is the syntactic representation of an integer n. In the cases for addition and subtraction, we impose the additional syntactic constraints that 1 ≤ i ≤ k, 1 ≤ j ≤ k, and i /= j, the latter to guarantee reversibility. Subtraction by a constant is not included as it may be derived straightforwardly from addition with a constant. A program in RINTk is then simply a command.
We may now give semantics to this language in our framework. For a concrete model, we select the category PInj of sets and partial injections, which is a join inverse category with a join-preserving disjointness tensor (given on objects by the disjoint union of sets), so it is extensive in the sense of Definition 4.2 by Theorem 4.4. By our developments previously in this section, to give a full semantics to RINTk in PInj, it suffices to provide an object (i.e., a set) of stores Σ, denotations of our three classes of elementary operations (addition by a variable, addition by a constant, and subtraction by a variable) as morphisms (i.e., partial injective functions) Σ → Σ, and denotations of our class of elementary predicates (here, testing whether a variable is zero or not) as decisions Σ → Σ ⊕ Σ. These are all shown in Fig. 2. It is uncomplicated to show that all of these are partial injective functions, and that the denotation of each predicate xi is a decision, so that this is, in fact, a model of RINTk in PInj.
We can now reap the benefits in the form of a reversibility theorem for free:
Theorem 6.1 (Reversibility) Every RINTk program p is semantically reversible in the sense that Jp) is a partial isomorphism.
Further, since we can straightforwardly show that xi += xj † = xi —= xj and xi += n † = xi += —n , we can use the technique from Sec. 5.3 to obtain a sound and complete program inverter.
Theorem 6.2 (Program inversion) RINTk has a (sound and complete) program inverter. In particular, for every RINTk program p there exists a program I[p] such that JI[p]) = Jp) .

pnot	:: PBool α ↔ PBool α
pnot (True x ) = False x pnot (False x )= True x
peven	:: Nat ↔ PBool Nat
peven 0	= True 0
peven (n + 1) = fmap (+1) (pnot (peven n))


Fig. 3. The definition of the even-predicate as a decision on natural numbers.
Decisions as a programming technique
Decisions offer a solution to the awkwardness in representing predicates reversibly. On the programming side, the reversible duplication/equality operator [11] (see also [26]) can be seen as a distant ancestor to predicates-as-decisions, in that it provides an ad-hoc solution to the problem of checking whether two values are equal in a reversible manner.
Decisions offer a more systematic approach: They suggest that one ought to define Boolean values in reversible functional programming not in the usual way, but rather by means of the polymorphic datatype
data PBool α = True α | False α

storing not only the result, but also what was tested to begin with. With this definition, negation on these polymorphic Booleans (pnot ) may be defined straight- forwardly as shown in Figure 3. In turn, this allows for more complex predicates to be expressed in a largely familiar way. For example, the decision for testing whether a natural number is even (peven) is also shown in Figure 3, with fmap given in the straightforward way on polymorphic Booleans. For comparison, the corresponding irreversible predicate is typically defined as follows, with not the usual negation of Booleans
even	:: Nat → Bool
even 0	= True
even (n + 1) = not (even n) .

As such, the reversible implementation as a decision is nearly identical, the only difference being the use of fmap in the definition of peven to recover the input value once the branch has been decided.
Concluding remarks
In the present paper, we have built on the work on extensive restriction categories to derive a related concept of extensivity for inverse categories. We have used this concept to give a novel reversible representation of predicates and their corresponding assertions in (specifically extensive) join inverse categories with a disjointness tensor, and in turn used these to model the fundamental control structures of reversible loops and conditionals in structured reversible flowchart languages. This approach allowed us to derive a program inversion theorem for structured reversible flowchart languages, and we illustrated our approach by developing a family of structured

reversible flowchart languages and using our framework to give it denotational semantics, with theorems regarding reversibility and program inversion for free.
The idea to represent predicates by decisions was partially inspired by the instruments associated with predicates in Effectus theory [15]. Given that side effect free instruments ι satisfy a similar rule, ∇◦ ι = id, and that Boolean effecti are extensive, it could be interesting to explore the connections between extensive restriction categories and Boolean effecti, especially as regards their internal logic. Finally, on the programming language side, it could be interesting to further explore how decisions can be used in reversible programming, e.g., to do the heavy lifting involved in pattern matching and branch joining. As our focus has been on the representation of predicates, our approach may be easily adapted to other
reversible flowchart structures, e.g., Janus-style loops [27].

References
	Axelsen, H. B. and R. Glu¨ck, What do reversible programs compute?, in: M. Hofmann, editor, Foundations of Software Science and Computation Structures. Proceedings, Lecture Notes in Computer Science 6604 (2011), pp. 42–56.
	Axelsen, H. B., R. Glu¨ck and T. Yokoyama, Reversible machine code and its abstract processor architecture, in: V. Diekert, M. V. Volkov and A. Voronkov, editors, Computer Science – Theory and Applications. Proceedings, Lecture Notes in Computer Science 4649 (2007), pp. 56–69.
Axelsen, H. B. and R. Kaarsgaard, Join inverse categories as models of reversible recursion, in: B. Jacobs and C. L¨oding, editors, FOSSACS 2016, Proceedings (2016), pp. 73–90.
Carboni, A., S. Lack and R. F. C. Walters, Introduction to extensive and distributive categories, Journal of Pure and Applied Algebra 84 (1993), pp. 145 – 158.
	Carothers, C. D., K. S. Perumalla and R. M. Fujimoto, Efficient optimistic parallel simulations using reverse computation, ACM Trans. Model. Comput. Simul. 9 (1999), pp. 224–253.
Cockett, J. R. B. and S. Lack, Restriction categories I: Categories of partial maps, Theoretical Computer Science 270 (2002), pp. 223–259.
Cockett, J. R. B. and S. Lack, Restriction categories II: Partial map classification, Theoretical Computer Science 294 (2003), pp. 61–102.
Cockett, R. and S. Lack, Restriction categories III: Colimits, partial limits and extensivity, Mathematical Structures in Computer Science 17 (2007), pp. 775–817.
Frank, M. P., “Reversibility for efficient computing,” Ph.D. thesis, EECS Dept., Massachusetts Institute of Technology (1999).
Giles, B. G., “An Investigation of some Theoretical Aspects of Reversible Computing,” Ph.D. thesis, University of Calgary (2014).
Glu¨ck, R. and M. Kawabe, A program inverter for a functional language with equality and constructors, in: A. Ohori, editor, Programming Languages and Systems. Proceedings, Lecture Notes in Computer Science 2895 (2003), pp. 246–264.
Glu¨ck, R. and T. Yokoyama, A linear-time self-interpreter of a reversible imperative language, Computer Software 33 (2016), pp. 108–128.
Glu¨ck, R. and T. Yokoyama, A minimalist’s reversible while language, IEICE Transactions on Information and Systems E100-D (2017), pp. 1026–1034.
Guo, X., “Products, Joins, Meets, and Ranges in Restriction Categories,” Ph.D. thesis, University of Calgary (2012).
Jacobs, B., New directions in categorical logic, for classical, probabilistic and quantum logic, Logical Methods in Computer Science 11 (2015), pp. 1–76.

Joyal, A., R. Street and D. Verity, Traced monoidal categories, Mathematical Proceedings of the Cambridge Philosophical Society 119 (1996), pp. 447–468.
Kaarsgaard, R., H. B. Axelsen and R. Glu¨ck, Join inverse categories and reversible recursion, Journal of Logical and Algebraic Methods in Programming 87 (2017), pp. 33–50.
Kastl, J., Inverse categories, in: H.-J. Hoehnke, editor, Algebraische Modelle, Kategorien und Gruppoide, Studien zur Algebra und ihre Anwendungen 7, Akademie-Verlag, 1979 pp. 51–60.
	Mogensen, T. Æ., Partial evaluation of the reversible language Janus, in: Partial Evaluation and Program Manipulation. Proceedings (2011), pp. 23–32.
	Selinger, P., Dagger compact closed categories and completely positive maps, Electronic Notes in Theoretical Computer Science 170 (2007), pp. 139–163.
	Selinger, P., A survey of graphical languages for monoidal categories, in: B. Coecke, editor, New Structures for Physics (2011), pp. 289–355.
	Thomsen, M. K., H. B. Axelsen and R. Glu¨ck, A reversible processor architecture and its reversible logic design, in: A. De Vos and R. Wille, editors, Reversible Computation. Proceedings, Lecture Notes in Computer Science 7165 (2012), pp. 30–42.
	Thomsen, M. K., R. Glu¨ck and H. B. Axelsen, Reversible arithmetic logic unit for quantum arithmetic, Journal of Physics A: Mathematical and Theoretical 43 (2010), p. 382002.
	Yokoyama, T., H. B. Axelsen and R. Glu¨ck, Reversible flowchart languages and the structured reversible program theorem, in: L. Aceto, I. Damg˚ard, L. A. Goldberg, M. M. Halld´orsson, A. Ing´olfsd´ottir and I. Walukiewicz, editors, International Colloquium on Automata, Languages and Programming. Proceedings, Lecture Notes in Computer Science 5126 (2008), pp. 258–270.
	Yokoyama, T., H. B. Axelsen and R. Glu¨ck, Optimizing clean reversible simulation of injective functions, Journal of Multiple-Valued Logic and Soft Computing 18 (2012), pp. 5–24.
Yokoyama, T., H. B. Axelsen and R. Glu¨ck, Towards a reversible functional language, in: A. De Vos and R. Wille, editors, RC 2011, Lecture Notes in Computer Science 7165 (2012), pp. 14–29.
Yokoyama, T. and R. Glu¨ck, A reversible programming language and its invertible self-interpreter, in:
Partial Evaluation and Semantics-Based Program Manipulation. Proceedings (2007), pp. 144–153.
