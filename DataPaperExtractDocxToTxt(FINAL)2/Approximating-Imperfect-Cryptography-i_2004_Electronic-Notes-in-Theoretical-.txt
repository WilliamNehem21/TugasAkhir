 Electronic Notes in Theoretical Computer Science 99 (2004) 183–203 
www.elsevier.com/locate/entcs




Approximating Imperfect Cryptography in a Formal Model
Angelo Troina1
Dipartimento di Informatica, Universita` di Pisa, Italy
Alessandro Aldini2
Istituto STI, Universit`a Carlo Bo, Urbino, Italy
Roberto Gorrieri3
Dipartimento di Scienze dell’Informazione, Universita` di Bologna, Italy

Abstract
We present a formal view of cryptography that overcomes the usual assumptions of formal mod- els for reasoning about security of computer systems, i.e. perfect cryptography and Dolev-Yao adversary model. In our framework, equivalence among formal cryptographic expressions is pa- rameterized by a computational adversary that may exploit weaknesses of the cryptosystem to cryptanalyze ciphertext with a certain probability of success. To validate our approach, we show that in the restricted setting of ideal cryptosystems, for which the probability of guessing infor- mation that the Dolev-Yao adversary cannot derive is negligible, the computational adversary is limited to the allowed behaviors of the Dolev-Yao adversary.


Introduction
The use of formal methods for modeling and analyzing cryptographic opera- tions is well-established. Since the seminal paper by Dolev and Yao [10] intro- duced a simple and intuitive formalization of cryptographic operations, many

1 Email: troina@di.unipi.it
2 Email: aldini@sti.uniurb.it
3 Email: gorrieri@cs.unibo.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.008

alternative definitions have been proposed on the basis of several approaches, ranging from modal logics to process algebras (see, e.g., [8,17,14,12,19,18,11]). Key to success of such a theory was the very simple idea behind the defini- tion of ciphertext, which is based on the assumption of perfect cryptography. Simply put, a message encrypted with a given key K can be decrypted if and only if K is known, while in each other case such a message is a black box. More formally, {M }K (representing the encryption of M with the key K) and ⊗ (representing an undecryptable ciphertext) are always equivalent if K is not known. On the basis of such an assumption, an adversary can (i) decrypt ciphered information if and only if the needed key is known, (ii) cap- ture plaintext, and (iii) encrypt plaintext with a known key. However, a real computational adversary is an arbitrary algorithm that collects large amount of ciphertext, exploits partial knowledge of information contained in a cipher- text, and performs exhaustive searches in order to crack ciphertext, compute ciphertext from a plaintext without knowing the related key, and guess secret keys. For instance, in [5] it is shown that an improper use of the block cipher Skipjack allows the adversary to perform an attack that is faster than exhaus- tive search, thus increasing the probability of retrieving data ciphered with an unknown key. As another example, the Wired Equivalent Privacy protocol for wireless networks falls short of accomplishing its security goals [6], because of an improper use of the stream cipher RC4. The lesson we learnt is that design of secure protocols is difficult, even if the underlying cryptographic primitives are believed to be secure. These considerations are discordant with the usual assumptions made by formal models, which do not define security in terms of the probability of successful attacks. As a consequence, in practice formal proofs are not enough to guarantee system security or, at least, they need specific assumptions about encryption.
In this paper, we overcome the limitations mentioned above. In partic- ular, we interpret the adversary as a probabilistic polynomial time process that may randomly guess data, perform statistical analysis of exchanged in- formation, exploit keys weakness, use well-known attacks to the used ciphering algorithm, and employ partial information to reduce the range of exhaustive searches. For such a model of adversary the probability of illegally cryptan- alyzing information from a particular ciphertext may be not negligible. In other words, we abandon the perfect cryptography assumption and we take into account encryption schemes that may be violated. To this purpose, we use a probabilistic estimation of the robustness of the cryptosystem to decide the equivalence between formal cryptographic expressions. More formally, we define a function parameterized by the initial knowledge of the adversary, whose outcome is strictly related to the considerations surveyed above. Such

an outcome represents an estimation of the probability of obtaining useful information from a given ciphertext. Consider, for instance, the expressions N = ({M }K, {K}K' ), expressing a pair of ciphertexts, the second one con- taining the key needed to decrypt the first one, and ({M }K, K), expressing a ciphertext and the related key. The two expressions may be equivalent if, e.g., K' is a very short key, the used algorithm is a stream cipher, and in the initial knowledge of the adversary there exists a large amount of data encrypted in the same way by re-using K', so that, in practice, the probability for such an adversary of retrieving M from N in polynomial time can be considered equal to 1. Obviously, when computing the probability of retrieving data, the knowledge of the adversary increases as it succeeds in obtaining new informa- tion. Therefore, the probabilistic estimation of the adversary power always depends on the current knowledge of such an adversary.
The notion of equivalence we adopt takes into consideration the compu- tational power of the adversary in order to establish the indistinguishability among different cryptographic expressions. However, it is possible that the es- timation of the adversary capability of retrieving data is not accurate. More- over, sometimes in practice the adversary cannot distinguish two expressions that, instead, are not equivalent because of negligible differences. In essence, the distinction between sets of cryptographic expressions may be too strong. To this aim, we approximate the closure among cryptographic expressions by introducing an ε-tolerance, which allows those expressions that require al- most the same effort to reveal information to be indistinguishable from the viewpoint of the computational adversary. For instance, expressions {M }K and {rubbish}K are indistinguishable (both represent undecryptable text) if a probabilistic adversary can infer with a negligible probability information about M or rubbish from the ciphertexts encrypted with the unknown key K. That means, by borrowing the same terminology used in [13], the encryption scheme is ideal. Such an example suggests that equivalence in the formal view implies indistinguishability in the computational view if ideal encryption is assumed. In other words, if the probability of retrieving data that the Dolev- Yao adversary cannot obtain is negligible, then the expressive power of the computational adversary is limited to the allowed behaviors of the Dolev-Yao adversary. This is, indeed, the result shown in [1], where the formal view and the computational view of cryptography are related by providing a computa- tional motivation for a formal treatment of encryption. Similarly, as a result of this paper, we show that under the same assumption of ideal encryption, our notion of approximate indistinguishability is implied by a classical notion of equivalence inspired by the formal model of Dolev and Yao.
The rest of the paper is organized as follows. In Sect. 2 we show how we

extended the Dolev-Yao formal model with probabilistic information used to estimate the probability of successful attacks conducted by probabilistic poly- nomial time adversaries. In this framework we introduce a notion of proba- bilistic equivalence among cryptographic expressions. In Sect. 3 we relax such an equivalence through an approximate notion of indistinguishability, which relates expressions that can be considered the same up to small differences. In Sect. 4 we present a soundness result showing that such an approximate relation is implied by the equivalence relation of the Dolev-Yao model in the case ideal encryption is assumed. Some related work and concluding remarks are discussed in Sect. 5 and in Sect. 6, respectively.

Probabilistic Equivalence
The basic elements of our formal model are inspired by the Dolev-Yao encryp- tion setting defined by Abadi and Rogaway [1]. However, in our setting, two cryptographic expressions turn out to be probabilistically equivalent if they yield the same information obtained with the same probability even through cryptanalysis attempts. Therefore, we abandon the usual Dolev-Yao abstrac- tion and we take into consideration cryptanalysis attacks.
Cryptographic Expressions and Probabilistic Adversaries
We start by introducing the formal expressions and the machinery needed to compute an estimation of the adversary capability of retrieving informa- tion from such expressions. We use String to denote a finite set of plain- text messages, i.e. the set of binary strings of a fixed length (ranged over by m, n,.. .), Keys to denote a fixed, nonempty set of key symbols (ranged over by K, K', K'',... and K1, K2, K3,.. .), such that Keys and String are disjoint, and Exp to denote the set of expressions defined by the grammar:

Informally, (M, N ) represents the pairing of M and N , and {M }K represents the encryption of M under K via a symmetric encryption algorithm. Pairing and encryption can be nested, like, e.g., in ({{(m, K)}K1 }K2 , K1).

The entailment relation M '→ N says that N can be derived from M . Formally, such a relation is inductively defined as the least relation satisfying the following properties:

In essence, M '→ N expresses what the adversary obtains from M without any prior knowledge of the keys used in M . For instance, ({{K1}K2 }K3 , K3) '→ K3, and ({{K1}K2 }K3 , K3) '→ {K1}K2 , but ({{K1}K2 }K3 , K3) /'→ K1. We point
out that the entailment relation models the expressive power of the classical
Dolev-Yao adversary and includes all the operations that such an adversary can perform in order to construct ciphertexts or extract plaintexts.
We now extend the model of Dolev and Yao by taking into account the possibility for an adversary of obtaining information from an expression {M }K without knowing the key K. For our purpose, we define the notion of prob- abilistic pattern P.p, which represents an expression P that does not contain undecryptable blocks and is associated with a parameter p ∈]0, 1]. The param- eter p models the probability of getting the plaintext contained in P . Formally, we define the set pPat of probabilistic patterns with the grammar:

A probabilistic pattern associated to a ciphertext is obtained by substituting every ciphered block with the corresponding expression in clear associated with the probability of obtaining information about it. Given any computa- tional adversary A (described by a probabilistic polynomial time algorithm) and the initial knowledge represented by expression G, the probabilistic pat- tern associated with expression {m}K is expressed in terms of the probability of obtaining information about m and is formally defined as m.pdec({m}K, G).

Function pdec({m}K, G) returns the probability of obtaining useful informa- tion from the ciphertext {m}K by employing the initial knowledge G. More formally, a computational adversary A has a probability Pr at most equal to the value expressed by pdec of retrieving m from {m}K by exploiting G:

Note that the outcome of pdec is a value strictly greater than 0, because, even if with small probability, an adversary could always try to randomly guess the key. Besides, the value of pdec depends on the knowledge G exploited to conduct the cryptanalysis attempt.
Intuitively, we could figure out the adversary as an arbitrary algorithm, ex- ecuting in probabilistic polynomial time, that makes computations on ciphered texts in order to get information about the contained plaintext (see, e.g., [13] for a detailed description of adversaries within a computational model). We point out that the classical Dolev-Yao adversary obtains m from {m}K if and only if K can be derived from G. In such a case, if G '→ K, then pdec({m}K, G) = 1. On the other hand, in a classical computational model assuming ideal encryption scheme [13] or type-0 secure encryption scheme [1], pdec is a negligible function, as it turns out that the probability of guessing information that cannot be derived through the classical Dolev-Yao model of cryptography is negligible. In the following we will consider a formal definition of negligible function and we will show that if pdec is negligible, then we ob- tain a soundness result stating that the expressive power of the computational adversary is limited by that of the Dolev-Yao adversary [1,13].
In a more general scenario, in this paper we assume that function pdec provides an outcome that depends on many factors that can violate the ideal encryption scheme assumption, such as the expected robustness of key K, the particular ciphering algorithm, the information collected by A. However, function pdec is not sufficient to define the probability of decrypting a ciphered block. Consider, for example, the expression ({{m}K1 }K2 , {(K1, K2)}K). What is the probability of getting information about m? A simple and immediate answer could be pdec({{m}K1 }K2 ) · pdec({m}K1 ) 4 , that is the probability of sequentially cracking the two keys K2 and K1. However, we observe that if K is a weak key, then information about K1 and K2 can be easily derived from {(K1, K2)}K and, as a consequence, the cryptanalysis of {{m}K1 }K2 may be simplified. Hence, the probability of success may vary according to the strategy the adversary uses when trying to cryptanalyze an expression. Obviously, since we have to assume that the adversary follows the optimal

4 For the sake of simplicity, in every example we omit the knowledge from the parameters of pdec.

attack, we always associate to a ciphered block the maximum probability of getting information about it. As a consequence, we analyze all the possible cryptanalysis paths that the adversary can follow. To this purpose, we em- ploy some auxiliary structures and functions, which we informally introduce as follows.
Given an expression M and initial knowledge G, we denote by pKeysG the set of pairs of the form T.p, where T ⊆ Keys is a set of keys that can be obtained from the expression M , and p ∈]0, 1] is the probability of cracking all the keys contained in T by following a particular strategy. By employing the values contained in the set pKeysG , we get the following information. On the one hand, for each set T of keys that can be obtained from M we compute pGuessG (T ), which is the maximum probability of cracking all keys in T . On the other hand, we compute a parameter pMaxG , associated to the expression M , expressing the maximum probability of getting information about all the plaintext contained in the expression M . Finally, we define function pP G , which employs the results obtained by applying the function pGuessG (T ) in order to turn the expression M into a probabilistic pattern. We formally detail all these structures in the next subsections.
The novel equivalence relation captures when from two messages we can derive the same information and this information is obtained with the same probability in the case the adversary tries to cryptanalyze ciphered pieces of data. Formally, we verify that two expressions M and N are equivalent if they yield the same probabilistic pattern (obtained through the functions pP G and pP G) and if the probabilities of getting information about the overall plaintext
(expressed by the parameters pM axG and pM axG ) are equal. Throughout
the paper we usually assume that set G expressing the initial knowledge of the adversary is empty. When we resort to such an assumption we omit G from the structures. Obviously, it is worth noting that as the adversary gets additional information, the enriched knowledge may be responsible for increasing the estimation given by function pdec.



pKeys

The first step of our procedure that aims at turning an expression M into a probabilistic pattern consists of generating set pKeysG . Such a set contains pairs T.p, where T ⊆ Keys is a set of keys syntactically occurring in M , and p ∈]0, 1] is the probability of retrieving information useful to cryptana-
lyze ciphertexts obtained with the keys contained in T . The set pKeysG is

generated by the following two-step algorithm:
pKeysG = {initKeys((M, G)).1};
addKeys((M, G), 1);
where initKeys : Exp → P(Keys) takes as input an expression L and returns the set of keys recoverable from L through the entailment relation. Formally, we have initKeys(L) = {K ∈ Keys | L '→ K}. Then, addKeys(H, p), with H ∈ Exp and p ∈]0, 1], is the following recursive procedure:
addKeys(H, p) ::=
∀ {N }K : (H '→ {N }K ∧ H /'→ K) do begin
p'	= p · pdec({N }K,H)
L	= (H, K)
T	= {K ∈ Keys | L '→ K}




end
pKeysG
addKeys(L, p')
= pKeysG
∪ {T.p' }


Initially, pKeysG  is set {initKeys((M, G)).1}, where initKeys((M, G)) is
the set of keys that can be derived from M and G with probability 1 (i.e., the
keys an adversary infers from the expression M and from the initial knowledge G without cryptanalysis attempts). In particular, initKeys((M, G)) contains each key K such that (M, G) '→ K.

Then, at each step, we add to pKeysG
sets of keys (obtained from ex-

pression M ) that are somehow cracked. In particular, for each cryptanalysis

strategy that an adversary may follow, pKeysG
contains the set of keys vi-

olated by following that strategy and the probability of cracking such keys.

The procedure addKeys recursively adds to set pKeysG
the results of each

cryptanalysis strategy.
Note that function pdec({N }K,H) (with N ∈ Exp,K ∈ Keys) computes the probability, for an adversary with knowledge H, of obtaining useful infor- mation from N without knowing the key K. In particular, H contains the initial knowledge G of the adversary, and the knowledge obtained by cryptan- alyzing expression M .
Example 2.1 Given M = (({{(m, K)}K1 }K2 , {(K1, K2)}K), K'), pKeysM is

initialized with the keys inferred from (M, G) with probability 1 through the entailment relation. Besides, we assume that the adversary has no initial knowledge, so we just have M '→ K', and we start with pKeysM = {{K'}.1}. Then, the addKeys procedure evaluates all the possible cryptanalysis se- quences an adversary may follow, by adding at each step new elements to set pKeysM (see Fig. 1). We observe that the set of keys {K', K, K1, K2} appears three times in pKeysM (see Fig. 2) with different probabilities. This is due to the alternative strategies the adversary may follow to obtain the plaintext.

   M
break{(K1, K2)}K
  
p' = pdec({(K1, K2)}K)


break{{(m, K)}K1 }K2

L = (M, K)
T = {K', K, K1, K2}
 
p' = pdec({{(m, K)}K1 }K2 )

break{(K1, K2)}K

 
'
  L = (M, K2)
T = {K', K2}
break{(m, K)}

p = pdec({{(m, K)}K1 }K2 ) · pdec({(K1, K2)}K)	K1

L = ((M, K2), K)
T = {K', K2, K, K1}

1
p' = pdec({{(m, K)}K1 }K2 ) · pdec({(m, K)}K1 ) L = ((M, K2), K1)
T = {K', K2, K1, K}

Fig. 1. Computation paths of addKeys(M, 1)


pGuess
Function pGuessG (T ) computes the maximum probability for the adversary of cracking all the keys in T according to the best cryptanalysis strategy that can be followed to attack the expression M . Let allKeys(M ) be the set of
 {K'}.1,	
	'	1	2 pdec({(K1 ,K2)}K )	


pKeysM =
{K , K,K ,K }.	,
 {K', K2}.pdec({{(m,K)}K }K ),	

1	2
	
1	2
	
 {K', K2, K1, K}.pdec({{(m,K)}K }K )·pdec({(m,K)}K )  

Fig. 2. pKeysM



all key symbols that occur in M ; we define DpGuessG
= {T ⊆ Keys | T ⊆

allkeys(M )}.
Then, function pGuessG

: DpGuessG

→ ]0, 1] is formally defined as:



pGuessG (T )= max{p | J.p ∈ pKeysG
∧ T ⊆ J }.

M	M
It is worth noting that pGuessG (∅) = 1. Indeed, ∀M ∈ Exp, we have ∅ ⊆ 
initKeys((M, G)) and initKeys((M, G)).1 ∈ pKeysG .
Example 2.2 Consider again M = (({{(m, K)}K1 }K2 , {(K1, K2)}K), K'). We have that (see set pKeysM in Fig. 2):


pGuessM ({K'})	= 1
 pdec({(K1, K2)}K),	


pGuessM
({K })	= max  pdec({{(m, K)}K1 }K2 ),	

pdec({{(m, K)}K1 }K2 ) · pdec({(K1, K2)}K),
 pdec({{(m, K)}K1 }K2 ) · pdec({(m, K)}K1 ) 
= max  pdec({(K1, K2)}K),	



pGuess
 pdec({{(m, K)}K1 }K2 ) 
({K', K,K ,K }) = max  pdec({(K1, K2)}K ),	

M	1	2



pMax
 pdec({{(m, K)}K1 }K2 · pdec({(m, K)}K1 ) 

Given an expression M , parameter pM axG
expresses the probability of get-

ting the maximum information from M . Therefore, pM axG
represents the

maximum probability of guessing all the keys used in M . Formally, pM axG
is derived in the following way:


pM axG
= max{p | J.p ∈ pKeysG
∧ allKeys(M ) ⊆ J }.



Given that pM axG
represents the probability of guessing all the keys used in

M , and by considering the definitions of pM axG and pGuessG , we observe

that pM axG
can also be defined as:

pM axG = pGuessG (allKeys(M )).

Example 2.3 Consider M = (({{(m, K)}K1 }K2 , {(K1, K2)}K), K'). Since we have allKeys(M ) = {K', K, K1, K2}, it follows that (see the values of pGuessM in Example 2.2):

pM axM = pGuessM ({K', K, K1, K2})
= max  pdec({(K1, K2)}K),	



pP
 pdec({{(m, K)}K1 }K2 ) · pdec({(m, K)}K1 ) 

The family of functions pP turns expressions into probabilistic patterns. In

particular, given an expression N contained in M , pP G
saves in a set T the

set of keys needed to decrypt each ciphered block occurring in N , extracts the information contained in N , and associates to such a plaintext the maximum probability of obtaining it through the best cryptanalysis strategy that can

be applied to M . To this end, we employ function pGuessG
to compute the

probability of cracking the keys needed to decrypt each ciphertext occurring in N . Hence, a probabilistic pattern contains plaintext (which can be inferred with a certain probability) instead of ciphertext.

The function pP G
: Exp × DpGuessG
→  pPat is defined inductively as

follows:
pP G (K, T )	= K.pGuessG (T )	(K ∈ Keys)
M	M
pP G (m, T )	= m.pGuessG (T )	(m ∈ String)
M	M
pP G ((N1, N2),T ) = (pP G (N1,T ), pPG(N2,T )).pGuessG (T )
M	M	M	M
pP G ({N }K,T )	= pP G (N, T ')	(T ' = T ∪ {K})
M	M
The probabilistic pattern that can be obtained from an expression N through the best cryptanalysis strategy applied to M is pP G(N, ∅). In the following, given an expression M , we use the abbreviation pP G (with no arguments) to
stand for pP G (M, ∅).
Example 2.4 Consider again M = (({{(m, K)}K1 }K2 , {(K1, K2)}K), K'). We have that 5 :
pPM = pPM ((({{(m, K)}K1 }K2 , {(K1, K2)}K), K'), ∅)= 
(pPM (({{(m, K)}K1 }K2 , {(K1, K2)}K), ∅), K')
where from

5 When equal to 1, we omit parameter p in every probabilistic pattern P.p.

pPM (({{(m, K)}K1 }K2 , {(K1, K2)}K), ∅)
we get (given p¯ = pGuessM ({K2, K1})) pPM ({{(m, K)}K1 }K2 , ∅)= (m.p¯, K.p¯).p¯
and (given pˆ = pGuessM ({K}))
pPM ({(K1, K2)}K, ∅)= (K1.pˆ, K2.pˆ).pˆ.
Example 2.5 As another example, consider two expressions that yield the same probabilistic patterns and have two different pM ax values:
M = ({m}K, {n}K)	N = ({m}K, {n}K' ),	K /= K'.
We have that:
pPM = (m.pˆ, n.pˆ),
where pˆ = pGuessM ({K}) = max{pdec({m}K), pdec({n}K)}. The intuition is that an adversary can get information contained in M by guessing K, which is used to cipher both blocks. On the other hand, if pGuessM ({K})= pGuessN ({K})= pGuessN ({K'}) we also have that:
pPN = (m.pˆ, n.pˆ)= pPM .
Hence, M and N have the same probabilistic patterns, even if to get in clear the whole expression N an adversary should guess two different keys, namely K and K'. Such a difference is captured by the fact that:
pMaxM = pGuessM ({K})= pˆ /= pˆ2 = pGuessN ({K, K'})= pM axN .
Therefore, pM ax is needed to express the overall probability of getting the entire expression in clear, while the probabilistic pattern is used to associate to each piece of information contained in an expression the probability to get it in clear.

Equivalence
Given the expressions M and N , we say that M and N are probabilistically equivalent (M ≈ N ) if they yield the same probabilistic pattern and if pM axM and pM axN are equal. Formally we have:
M ≈ N	⇔	pPM = pPN ∧ pM axM = pM axN .

Intuitively, two expressions are probabilistically equivalent if one can derive from them the same information and this information is obtained with the same probability in the case it is ciphered with unknown keys.

Example 2.6 Consider M = (({{(m, K)}K1 }K2 , {(K1, K2)}K), K') and N =
(({(m, K)}K1 , {(K1, K2)}K), K'). On the one hand, we have that:
 {K'}.1,	
pKeysN =  {K', K, K1, K2}.pdec({(K1 ,K2)}K ), 
 {K', K1, K, K2}.pdec({(m,K)}K  )  
so if pdec({(m, K)}K1 ) ≤ pdec({(K1, K2)}K) we have that pGuessN ({K1}) = 
pGuessN ({K}) = pdec({(K1, K2)}K) and, given pˆ = pdec({(K1, K2)}K), we
have pPN = (((m.pˆ, K.pˆ).pˆ, (K1.pˆ, K2.pˆ).pˆ), K').
On the other hand, from the previous examples and from the condition pdec({(m, K)}K1 ) ≤ pdec({(K1, K2)}K) we obtain the probabilistic pattern pPM = (((m.pˆ, K.pˆ).pˆ, (K1.pˆ, K2.pˆ).pˆ), K') and, since pM axM = pM axN = pˆ, we also obtain M ≈ N . In conclusion, we observe that ciphering the first block (m, K) of M with both keys K1 and K2 is not meaningful, since M is proba- bilistically equivalent to an expression where this information is ciphered with one of those keys only. In fact, an adversary could gain information about m by cryptanalyzing the second block {(K1, K2)}K.
Example 2.7 Consider an adversary with initial knowledge G = K1 and again the expressions:
M = (({{(m, K)}K1 }K2 , {(K1, K2)}K), K')
N = (({(m, K)}K1 , {(K1, K2)}K), K').
We note that M /≈ N , since the adversary gets in clear the entire expression N with probability 1. In fact, through the key K1 the adversary can get all the other keys by means of the entailment relation. In particular, we have that:
pKeysG = {{K', K1, K, K2}.1}



pKeysG
	'
=  {K',K ,K , K}.


 {K', K1, K, K2}.pdec({(K1 ,K2)}K )	
Example 2.8 Consider expressions M and N of Example 2.5. As we have seen, M and N are not probabilistically equivalent, since they are associ- ated with different pM ax values. Now, let us add to both expressions the ciphertext {o}K' , thus getting the expressions M ' = (({m}K, {n}K), {o}K' )

and N ' = (({m}K, {n}K' ), {o}K' ).	In this case, given pGuessM' ({K}) =
pGuessM' ({K'}) = pGuessN' ({K}) = pGuessN' ({K'}) = pˆ, we obtain that

pPM' = pPN' = ((m.pˆ, n.pˆ).pˆ, o.pˆ) and pM axM' = pM axN' =
M ' ≈ N '.
pˆ2, so that

This example shows that our equivalence relation is not conservative under the kind of operations as above. This is a reasonable consequence of the intuition behind the notion of equivalence among cryptographic expressions. Note that the information carried by expressions M ' and N ' is rather different from that expressed by expressions M and N . In order to get the plaintext from M ' and N ', an attacker has to break two different keys, similarly as seen in the case of expression N . Instead, for expression M it is sufficient to break key K only. Since the knowledge of the adversary changes by adding pieces of information to an expression, the probabilistic equivalence cannot be preserved by constructing (destructing) cryptographic expressions.


Indistinguishability through Probabilistic Similarity

The notion of probabilistic equivalence given above is very restrictive. In practice, it could be very difficult to find blocks that can be decrypted exactly with the same probability. As a consequence, two expressions containing the same information and yielding probabilistic patterns with similar probability (but not exactly the same) would not be probabilistically equivalent. Simi- larly, two different probabilistic patterns that can be deduced with negligible probabilities cannot be probabilistically equivalent.
In this section, we introduce a compatibility relation, called ε−probabilistic similarity (≈ε), which (i) approximates the probabilistic equivalence by intro- ducing a tolerance to small differences of the probabilistic parameters associ- ated to the probabilistic patterns, and (ii) allows for considering indistinguish- able those ciphertexts that can be decrypted with a negligible probability.
We say that expressions M and N are ε−probabilistically similar (M ≈ε N ) if pM axM and pM axN are “almost the same” and if M and N are com- patible, according to the notion of compatibility specified below. Formally, we have:

M ≈ε N	⇔	pPM ∼ε pPN ∧ |pM axM − pM axN | ≤ ε.

The compatibility relation ∼ε for probabilistic patterns expresses when two

probabilistic patterns are indistinguishable. Formally, it is defined as follows:

According to such rules, note that two different pieces of information turn out to be indistinguishable if they are associated with probabilistic parameters that are smaller than the given tolerance ε. This is because the probability of revealing the difference between them is negligible. Informally, we can use this notion in order to consider as undecryptable a ciphertext that can be decrypted with a probability smaller then the fixed threshold. In practice, if the cryptosystem is secure enough (according to the security degree specified by the given tolerance ε), then each ciphertext is really a black box.
Example 3.1 Consider the expressions M = {m}K and N = {n}K' . Given the associated probabilistic patterns pPM = m.p1 and pPN = n.p2 and a fixed threshold ε, we say that M and N are indistinguishable if p1, p2 ≤ ε. In such a case we have that pPM ∼ε pPN and, since pM axM = p1 ≤ ε and pM axN = p2 ≤ ε, we have that |pM axM − pM axN | ≤ ε. Therefore, it follows M ≈ε N .
Example 3.2 Consider M = {m}K and N = {m}K' . If we assume p1 = pdec({m}K) and p2 = pdec({m}K' ), we have that pPM = m.p1 , pPN = m.p2 , pM axM = p1 and pM axN = p2. If p1 and p2 are similar, but not exactly the same, then given a tolerance ε such that |p1 − p2| ≤ ε, we have that M ≈ε N but M /≈ N .
Example 3.3 Consider M = ({m}K, {K}K' ) and N = ({m}K, K). If we consider K' as a weak key, we may have that pdec({m}K) < pdec({K}K' )= p and, therefore, pPM = (m.p, K.p). Moreover, we also have pPN = (m, K). If the probability of violating K' is close to 1, and, in particular, if (1 − p) ≤ ε, we have that M ≈ε N . Intuitively, M is a ciphered variant of N that can be easily cracked.
The following proposition holds.

Proposition 3.4 Given M, N ∈ Exp it holds that:
M ≈ N	⇒	M ≈ε N	∀ε ∈ [0, 1].
Proof. By definition of ∼ε it follows that pPM = pPN ⇒ pPM ∼ε pPN  ∀ε ∈ [0, 1]. Finally, we also have that pM axM = pM axN  ⇒ |pM axM −pM axN | ≤ ε ∀ε ∈ [0, 1].
By the definition of ∼ε the following proposition also holds.
Proposition 3.5 Given M, N ∈ Exp it holds that:
M ≈ N	⇔	M ≈0 N.

Perfect Cryptography vs. Ideal Encryption
In this section we show how our notion of similarity is related to a classical Dolev-Yao equivalence relation defined in an environment where perfect cryp- tography is assumed. In particular, given a notion of ideal encryption, we will show that if two expressions are equivalent within a classical Dolev-Yao model that relies on perfect cryptography, then the two expressions will also be probabilistically similar if we assume ideal encryption.
Equivalence within Perfect Cryptography
In [1], Abadi and Rogaway define an equivalence relation for cryptographic expressions within a formal model where perfect cryptography is assumed. The set Pat of patterns is defined as an extension of the set of expressions that employs the new symbol ⊗ representing a ciphertext that an adversary cannot decrypt.

Intuitively, a pattern is an expression that may contain some parts that an adversary cannot decrypt. They define a function p that, given a set of keys

T and an expression M , computes the pattern that an adversary can obtain from M if the initial knowledge is the set of keys T .





Moreover, they define pat(M ), which expresses the pattern obtained from an expression M without knowing a priori any auxiliary set T of keys. For- mally, pat(M )= p(M, initKeys(M )). For example, pat(({{K1}K2 }K3 , K3)) = ({⊗}K3 , K3).
Finally, by abstracting from the initial knowledge, they say that two ex-
pressions are equivalent if they yield the same pattern:
M =∼ N	⇔	pat(M )= pat(N ).
For example, we have ({{K1}K2 }K3 , K3) ∼= ({{m}K1 }K3 , K3) since both ex- pressions yield the pattern ({⊗}K3 , K3).
In [20] we defined a probabilistic equivalence relation that is conservative with respect to the one introduced by Abadi and Rogaway. In this paper we decided to define a slight variant of that relation, which we consider more intu- itive: two expressions should be equivalent when they yield the same informa- tion, and when such information can be extracted with the same (or similar) probabilities. By taking such a choice we lost the conservativeness with the equivalence of [1]. For example, if we take the two expressions ({m}K, K) and (m, K), it turns out that ({m}K, K) /∼= (m, K), since the two expressions yield different patterns. However, the two expressions contain the same information, which is extractable with the same probability (in this case with probability 1), so we have that ({m}K, K) ≈ (m, K) (note that the probabilistic pattern associated with both expressions is (m.1, K.1)).
Ideal Encryption
The notion of ideal encryption intuitively assumes that it should be hard for the adversary to decrypt a message ciphered with an unknown key. In other words, the probability of breaking an encrypted message that cannot be derived in the classical Dolev-Yao model should be small. We formalize

the concept of small probabilities by introducing the definition of negligible
function (see, e.g., [13]).
Definition 4.1 A function f : N → R is negligible, if for any polynomial q,

∃η0 ∈ N : f (η) ≤  1 
∀η > η0.

Then, the ideal encryption hypothesis assumes that pdec must be a negligible function.
Definition 4.2 An encryption scheme is ideal if and only if
∀A,	∀{N }K ∈ Exp,	∀G ∈ Exp : G /'→ K,	∀ polynomial q
∃η0 ∈ N :

pdec({N }K, G) ≤  1 
∀η > η0.


As a consequence, if the assumption of ideal encryption holds, given {N }K,G ∈
Exp such that G /'→ K, we also have that for all A:


Pr[m ← A({m}K
, G)] ≤	1
q(η)
∀η > η0.

By following an approach also used in [7], we show that a result holding in the perfect cryptography scenario also holds in our model if the ideal encryption assumption is taken.
Theorem 4.3 Given M, N ∈ Exp, if the assumption of ideal encryption holds for a natural η0, taken a polynomial q and a natural parameter η > η0, then:

M =∼ N	⇒	M ≈ε
N	∀ε >	1 .
q(η)

Proof. By the assumption of ideal encryption, either pM axM = pM axN =1 or pM axM , pMaxN ≤  1  < ε. As a consequence, given M ∼= N, in order to prove that M ≈ε N we just need to check that pPM ∼ε pPN . The statement derives by structural induction on the expression M and by observing that, by hypothesis, M ∼= N ⇒ pat(M ) = pat(N ). In the following, we denote by TM the set initKeys(M ) and by TN the set initKeys(N ).
pat(M )= pat(N )= K	K ∈ Keys
⇒
pPM = pPN = K.1 ⇒ pPM ∼ε pPN	∀ε ∈ [0, 1].
pat(M )= pat(N )= m	m ∈ String
⇒
pPM = pPN = m.1 ⇒ pPM ∼ε pPN	∀ε ∈ [0, 1].

pat(M )= pat(N )= ⊗
⇒	by the ideal encryption assumption
pPM = Q.p, pPN = Q'.p' ∧ p, p' ≤ ε ⇒ pPM ∼ε pPN .
pat(M )= {p(L, TM )}K = {p(L', TN )}K = pat(N )
⇒ p(L, TM )= p(L', TN )
⇒	by induction hypothesis
pPM (L, ∅) ∼ε pPN (L', ∅) ⇒ pPM = pPM (L, ∅) ∼ε pPN (L', ∅) = pPN ⇒
pPM ∼ε pPN .
pat(M )= (p(L1, TM ), p(L2, TM )) = (p(L' , TN ), p(L' , TN )) = pat(N ) ⇒
1	2
p(L1, TM )= p(L' , TN ) ∧ p(L2, TM )= p(L' , TN )
1	2
⇒	by induction hypothesis
pPM (L1, ∅) ∼ε pPN (L' , ∅) ∧ pPM (L2, ∅) ∼ε pPN (L' , ∅) ⇒
1	2
pPM = (pPM (L1, ∅), pPM (L2, ∅)).1 ∼ε (pPN (L' , ∅), pPN (L' , ∅)).1 = pPN
1	2
⇒ pPM ∼ε pPN .
In general, the inverse implication of Theorem 4.3 does not hold. Consider for example the expressions M = ({m}K, K) and N = (m, K). As we have seen, the two expressions are probabilistically equivalent, i.e. M ≈ N , and, by Proposition 3.4, also probabilistically similar, i.e. M ≈ε N ∀ε ∈ [0, 1]. However, since the two expressions yield different patterns, they cannot be equivalent according to the Abadi-Rogaway equivalence relation. The result does not change even in the case of ideal encryption, since the probabilistic similarity holds for all ε ∈ [0, 1].

Related Work
The treatment of cryptographic operations within formal models is covered by a quite large body of literature, but most of these efforts do not consider cryptographic operations in an imperfect cryptography scenario.
This work represents a step toward the definition of a formal language with cryptographic primitives and conditional statements for analyzing both unwanted disclosure of data due to the nature of the protocols and information leakage due to the nature of the cryptographic means. In the literature, both probability and computational complexity are studied in formal settings.
Process algebra and computational view of cryptography are combined in [16] where, in the setting of a subset of asynchronous π-calculus, an asymp- totic notion of probabilistic equivalence is defined. The observational equiv- alence defined in terms of such a notion can be related to polynomial time statistical tests, i.e. equivalent processes are indistinguishable from the view- point of polynomial time adversaries. Security is then stated in terms of

indistinguishability between the protocol under analysis and an idealized pro- tocol specification. More recently, a definition of probabilistic noninterference which includes a computational case has been defined in [4] in the setting of asynchronous probabilistic reactive systems. In particular, computational noninterference means that the advantage of the external observer (which in- teracts with the system under analysis) for a correct guess of the interfering adversary behavior is a negligible function. A formal notion of computational indistinguishability is also defined in [15] on the basis of a simple model where public outputs are observed in order to infer the content of secret inputs. Fi- nally, [7] compares the classical Dolev-Yao adversary with an enhanced com- putational adversary which can guess the key for decrypting an intercepted message (albeit only with negligible probability). The two adversaries are shown to be equivalent with respect to a secrecy property.
We also point out that probabilistic notions of security as well as approx- imate security properties can be found in the literature (see, e.g., [12,9,3,2]), but they do not relate probability and cryptographic primitives.

Conclusions
In this paper we put the basis for defining a formal cryptographic language where (i) information leaks due to the weaknesses of the cryptographic prim- itives can be estimated by employing conditional statements and the equiv- alence relation presented in Sect. 2, and (ii) probabilistic covert channels can be revealed by verifying noninterference security properties (as done, e.g., in [9,3]). In particular, the approximate notion of indistinguishability of Sect. 3 can be used (together with an approximate definition of noninterference) to verify whether security properties of cryptographic protocols can be guaran- teed at a reasonable degree.
We did not sift through the details of the estimation of the information leakage which is formally expressed by function pdec. We have partially miti- gated the effect of such an abstraction by relaxing the probabilistic equivalence through an approximate similarity relation, which allows us to relate expres- sions that can be considered equivalent up to a given tolerance ε. Moreover, similarly as the soundness result shown in [1], it turns out that if pdec is a negligible function, i.e. the encryption scheme is ideal, equivalence in a formal setting stating perfect cryptography implies similarity in our framework.

References
M. Abadi, P. Rogaway, “Reconciling Two Views of Cryptography (The Computational Soundness of Formal Encryption)”, in Proc. of 1st IFIP Int. Conf. on Theoretical Computer

Science, Springer LNCS 1872:3-22, 2000.
A. Aldini, M. Bravetti, A. Di Pierro, R. Gorrieri, C. Hankin, H. Wiklicky, “Two Formal Approaches for Approximating Noninterference Properties”, Foundations of Security Analysis and Design II, R. Focardi and R. Gorrieri, eds., Springer LNCS 2946:1-43, 2004.
A. Aldini, M. Bravetti, R. Gorrieri, “A Process-algebraic Approach for the Analysis of Probabilistic Non-interference”, Journal of Computer Security, vol. 12(2), IOS Press, 2004.
M. Backes, B. Pfitzmann, “Computational Probabilistic Non-interference”, in Proc. of 7th European Symposium on Research in Computer Security, Springer LNCS 2502:1-23, 2002.
E. Biham, A. Biryukov, A. Shamir, “Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials”, in Advances in Cryptology, EUROCRYPT’99, Springer LNCS 1592:12-23, 1999.
N. Borisov, I. Goldberg, D. Wagner, “Intercepting Mobile Communications: The Insecurity of 802.11”, in Proc. of 7th Int. Conf. on Mobile Computing and Networking, MOBICOM’01, ACM Press, pp. 180-189, 2001.
P. Degano, R. Zunino, “A Note on the Perfect Encryption Assumption in a Process Calculus”, to appear in Foundations of Software Science and Computation Structures (FOSSACS’04), Springer Verlag, 2004.
R. A. DeMillo, N. A. Lynch, M. Merritt, “Cryptographic Protocols”, in Proc. of the 14th Annual ACM Symposium on Theory of Computing, ACM Press, pp. 383-400, 1982.
A. Di Pierro, C. Hankin, H. Wiklicky, “Approximate Non-Interference”, in Proc. of 15th Computer Security Foundations Workshop, IEEE CS Press, pp. 1-17, 2002.
D. Dolev, A. Yao, “On the Security of Public-key Protocols”, IEEE Transactions on Information Theory 29:198-208, 1983.
A. Durante, R. Focardi, R. Gorrieri, “A Compiler for Analysing Cryptographic Protocols Using Non-Interference”, ACM Transactions on Software Engineering and Methodology (TOSEM), vol. 9(4):489-530, 2000.
J. W. Gray III, “Toward a Mathematical Foundation for Information Flow Security”, Journal of Computer Security 1:255-294, 1992.
J. Herzog, “A Computational Interpretation of Dolev-Yao Adversaries”, in Proc. of 3rd Int. Workshop on Issues in the Theory of Security (WITS’03), 2003.
R. A. Kemmerer, “Analyzing Encryption Protocols using Formal Veriﬁcation Techniques”, IEEE Journal on Selected Areas in Communications, 7(4):448-457, 1989.
P. Laud, “Semantics and Program Analysis of Computationally Secure Information Flow”, in Proc. of 10th European Symposium on Programming (ESOP’01), Springer LNCS 2028:77-91, 2001.
P. Lincoln, J. C. Mitchell, M. Mitchell, A. Scedrov, “A Probabilistic Poly-Time Framework for Protocol Analysis”, in Proc. of 5th ACM Conf. on Computer and Communications Security, ACM Press, pp. 112-121, 1998.
J. K. Millen, S. C. Clark, S. B. Freedman, “The Interrogator: Protocol Security Analysis”, IEEE Transactions on Software Engineering, SE-13(2):274-288, 1987.
L. C. Paulson, “The Inductive Approach to Verifying Cryptographic Protocols”, Journal of Computer Security, 6(1-2):85-128, 1998.
S. Schneider, “Security Properties and CSP”, in IEEE Symposium on Security and Privacy, IEEE CS Press, pp. 174-187, 1996.
A. Troina, A. Aldini, R. Gorrieri, “A Probabilistic Formulation of Imperfect Cryptography”, in Proc. of 1st Int. Workshop on Issues in Security and Petri Nets, WISP’03, 2003.
