 Electronic Notes in Theoretical Computer Science 91 (2004) 195–211 
www.elsevier.com/locate/entcs




The Polymorphic Imperative:
a Generic Approach to In-place Update

C. B. Jay 1	H. Y. Lu 2	Q. T. Nguyen 3
Faculty of Information Technology University of Technology, Sydney Sydney, Australia

Abstract
The constructor calculus supports generic operations defined over arbitrary data types including abstract data types. This paper extends the basic constructor calculus to handle constructed locations. The resulting calculus is able to define a generic assignment operation that performs in-place whenever appropriate and allocates fresh memory otherwise. This approach may eliminate many of the space overheads associated with higher-order polymorphic languages. In combination with existing generic programming techniques it can express some very powerful algorithms such as the visitor pattern.
Keywords: generic functions, constructor calculus, imperative programming, in-place update, location constructors


Introduction
One of the great strengths of functional programming is that it relieves the programmer of the need to manage memory, which helps to make programs shorter and easier to reason about. The price to be paid is that their compilers must take a conservative approach to memory allocation, often allocating new space in the heap and garbage collecting the old when in-place update would have been perfectly safe.

1 Email: cbj@it.uts.edu.au
2 Email: helenlu@it.uts.edu.au
3 Email: qtnguyen@it.uts.edu.au


1571-0661 © 2004 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.013


A significant effort has been made to improve the efficiency of this process. For example, types in compilation [11] uses type information to ensure the safety of some in-place updating. This works well for integers, floats and tuples built of such simple types, but does not handle recursive types like lists where the type does not determine the shape of its values. Monitoring
list lengths etc. may be attempted using sized types [4] or other dependently-
typed systems, e.g. [13] with the aim of extracting compile-time information.
This paper provides an approach to assignment that is able to determine at run-time whether to assign in-place or not using existing techniques from
the constructor calculus [5,6]. This is a variant of the lambda-calculus which supports powerful generic programming [2,7] by means of program extensions
based on pattern-matching over constructors of arbitrary type. It is able to express generic programs for the usual second-order functions, like mapping and folding. It also can easily extend numerical operations, like equality and addition, from primitive datum types (such as the primitive integers or floats) to arbitrary data types.
The same approach is here used to extend primitive operations on locations to generic operations on constructed locations. When generic assignment is defined in this way then in-place update is the norm, based on matching
the structure of the location with that of its new value. We can combine the primitive assignment with the generic to get the best of both worlds, complete safety and in-place update when possible.
Three examples are used to illustrate some of the benefits of this approach. The insertionsort program shows how a space efficient program can be written using higher-order functions and pattern-matching. The program converge shows how to iterate a function while using space efficiently. The visitor pro- gram captures the visitor pattern [3] as a generic function of type

visitor : name(X, Y ) → (loc Y → comm) → loc Z → comm

which operates as follows: visitor n f z traverses the structure of z applying f to any sub-structures named by n. For example, n may characterize employees and f may increment employee salaries inside an organisation.
The structure of the rest of the paper is as follows. Section 2 recalls key aspects of the constructor calculus. Section 3 adds types of locations to the basic calculus with some primitive operations for their creation, reading and writing. Section 4 introduces constructed locations and the corresponding operations. Section 5 provides examples. Section 6 draws conclusions and considers future work.

Review of the constructor calculus
The constructor calculus introduced in [5] was created to support the def- inition of generic functions like mapping and folding in which the types of parameters and return values can be instantiated for a variety of datatypes. The resultant definitions allow these functions to be able to act on a large class of datatypes. The work is further developed in [6] which explains any undefined notation used in this paper. The latter also showed how the key ideas could be demonstrated with respect to the Hindley-Milner type system,
a simple variant of which has types T and terms t given by
T ::= X | D | 1 | T ∗ T | T → T
t ::= x | d | un | pair | t t | λx.t | if t then t else t | let x = t in t | fix.
X is a type variable, D is a type constant, 1 is the unit type, T0 ∗ T1 is the product of T0 and T1 and T0 → T1 is the type of functions from T0 to T1. It would be a trivial matter to add coproduct (or sum) types to the calculus, but we shall see that they can be handled by allowing data type definitions. The
term forms represent, respectively, variables, constants, the unique value of unit type, pairing, application, abstraction, conditional, let-declaration, and fixpoints.
The constructor calculus is created by replacing the conditional with a more powerful branching construct called an extension. Its syntax is
under c apply f else g
where c is a constructor and f and g are terms, called the specialisation and
default function respectively. The rewriting rules for extensions are
(under cn apply f else g) (cn t0 ... tn−1) > f t0 ... tn−1
(under cn apply f else g) t > g t	otherwise
where cn represents a constructor that takes n arguments. From these rules it is clear that f may have a more specialised type than g since it is only required to act on the arguments of the constructor c. This is the key difference from conditionals (or case analyses) where the two branches must have exactly the same type. The type derivation rule for extensions is given by
cn : ∀∆c.T0 → ... → Tn	Γ ▶ g : T → T '
υ = U(Tn,T )	υΓ ▶ f : υ(T0 → ... Tn−1 → T ') Γ ▶ under cn apply f else g : T → T '

where Γ is the term context and U is the most general unifier. It is important for the type safety of specialisation that the type scheme ∀∆c.T0 → ... → Tn for c should be its principal type scheme, i.e. the one it is born with, since the specialisation function must be able to act on the sub-terms of any term constructed by c. That is, specialisation may assume the most general unification of Tn and T but no more.
Because of the constraints above, we limit ourselves to a finite set of con- structor constants. Fundamental examples are un, pair and the polymorphic exception
exn : X → Y
Other examples will be added by datatype declarations.
It is useful to be able to extend numerical functions like addition and equality to arbitrary data types. To do this requires patterns that match with integers and floats. One approach would be to treat integers and floats as values constructed from some type of primitive integers and primitive floats,
e.g. tuples of bits. Since it is unpleasant to expose these in the programming language we shall adopt a different approach, namely to introduce a new term form for each primitive data type, e.g. for the floating point numbers, one can have



with type derivation rule
underfloat apply f else g


Γ ▶ g : T → T '




and evaluation rules
υ = U(float,T )	υΓ ▶ f : float → υT '


Γ ▶ underfloat apply f else g : T → T '

(underfloat apply f else g) n > f n		if n is a floating point number (underfloat apply f else g) t > g t	if t cannot be a floating point number. We may write
under float apply f else g
for underfloat apply f else g. Similar rules and conventions will apply for a type int of integers and other datum types. As syntactic sugar, we may also write
match t1 with t
for t t1 especially when t is given by pattern-matching.


We can use pattern-matching syntax to express extensions, where the pat- tern
| c x0 ... xn−1 → t
represents under c apply λx0,... xn−1.t else    Similarly,
| float x → t
represents underfloat applyλx.t else ... . The ultimate default function in a pattern-match is given by the exception constant exn. For example, here is an equality function that acts on arbitrary tuples of floating point numbers
(tuplefloatequal : X → X → bool) = 
| float x → ( | float y → x = y)
| un → λy.true
| pair x0 x1 → ( | pair y0 y1 → tuplefloatequal x0 y0 && tuplefloatequal x1 y1)
In practice, one wishes to create abstract data types and use their construc- tors, also known as abstractors when defining generic functions. For example,
datatype complex = complex of float and float
introduces complex as a new abstractor which can be used to define new oper- ations. If abstractors are treated as primitives then existing generic functions such as equality must be extended with cases to handle each new abstractor.
Instead, terms built using abstractors are given a concrete representation (re- flecting their deep structure) as a tuple of arguments (built using pair and un). This is then tagged with a name (representing the surface structure). Tagging is handled by the constructor tag of type
tag : ∀X, Y name(X, Y ) → X → Y
where name(X, Y ) is a type of names. For example, complex can be interpreted as
λx, y.tag complex name (pair x y)
where complex name : name(float∗float, complex). Comparison of arbitrary ab- stractors is achieved by pattern-matching against their names. To be precise, this requires an additional type derivation rule, namely
n : name(X, Y )	g : T → T '
υ = U(name(X, Y ),T )	f : υ(T ')
▶ under n apply f else g : T → T '
Type safety is maintained because name constants are required to have con- stant types.


So, a fully generic equality for data types is given by (equal : X → X → bool) = 
| int x → ( | int y → primintequal x y)
| float x → ( | float y → primfloatequal x y)
| un → λy.true
| pair x0 x1 → ( | pair y0 y1 → equal x0 y0 && equal x1 y1)
| tag m x → (
| tag n y → (
match n with
| m → equal x y 
|	→ false))
|	→ λy.false
For example, equal (complex 3.3 4.4) (complex 3.3 5.5) reduces to applying
under complex name apply equal (pair 3.3 4.4) (pair 3.3 5.5) else λy.false
to complex name, which ultimately reduces to false.
The same approach can be used to generalize other numerical operations,
e.g. addition, to arbitrary data structures. These generic operations can then be customized if desired. For example, multiplication of complex numbers can be given its own case.

Locations
This section adds to the constructor calculus some imperative features in a style similar to that of ML [10]. In this setting, the assignment can be treated as an atomic operation, which is simple to describe but extravagant with space.
The type comm of commands is equipped with two constants
skip : comm
seq : comm → X → X.
The command skip has no effect. Evaluation of a term of the form seq t0 t1 executes the command t0 and then evaluates the term t1. We may write x; y for seq x y. While- and for-loops can be defined by fix-point construction, in the usual way.


Now let us consider assignable locations. Each type T has an associated type
loc T
of locations that store values of type T . Locations support three polymorphic constants:
primloc : X → loc X
primval : loc X → X
primassign : loc X → X → comm.
A term of the form primloc t creates a location whose initial value is that of
t. A term of the form primval u represents the value stored at u. A term of the form primassign u t updates the location u with the value of t. Garbage collection is required to recover the redundant locations.
In general, one must restrict the quantification of type variables appearing in location types (see, e.g. [8,12] but this does not limit the polymorphism of the examples in this paper.
The evaluation rules in Figure 1 employ a big-step operational semantics. The values (meta-variable v) are given by the lambda-abstractions, extensions, constructors, constants, and terms of the form d v0 ... vk where d is a con-
structor or constant for which there is no explicit evaluation rule. Such rules are summarised by the rule for evaluating d d0 ... dn−1 in the figure.
A store (meta-variable Σ) is a function from term variables of location
type to values. These term variables must be of location type, and will be represented by the meta-variable u. An evaluation context is a pair (Σ, t) in which all free variables of the term t are in the domain of the store Σ.
Evaluation is expressed using judgements of the form
(Σ, t) ⇒ (Σ', v)
where (Σ, t) is an evaluation context.
Most of the evaluation rules are standard. Note that beta-reduction is eager. For example, (Σ, primassign t0 t1) is evaluated by first evaluating t0. If its value is an identifier u then the value of u is updated in the store to that
of the result of evaluating t1. If, however, t0 has some other value, e.g. an exception, then the result of evaluation is an exception.
Theorem 3.1 For each evaluation context (Σ, t) there is an evaluation rule which can be applied. That is, evaluation is never stuck.
Proof. The proof is by induction on the structure of t. 
The evaluation rules give no indication of how store operations are to be


implemented. One expects that assignment of datum values like integers or floats will be performed in-place and that assignment of functions will be by allocating fresh memory. The delicate case is an assignment of structured data, like a list.
Define list types by
datatype list X = nil | cons of X : list X
and adopt the usual functional syntax for representing them, e.g. [1, 2, 3] rep- resents cons 1 (cons 2 (cons 3 nil)). Now consider the example
let x = primloc [1] in
primassign x [2];	(1)
primassign x [8, 9].
Clearly, the first assignment could be in-place, but any simple implementation of primassign will miss this opportunity since it will not be able to distinguish this case from the second, shape-changing assignment.


Location Constructors
In-place update is possible when the structure of the location is matched by that of its new value. This matching can be checked by comparing constructors if locations are constructed in the same way that their values are. This sec-
tion introduces a new class of constructors, the location constructors. They
can be used to create generic functions for locating, valuing and assigning based on their primitive versions, just as equal is based on datum equality. In this setting, assignment can be treated as a generic operation, which can be performed in-place if possible, and create a new location otherwise
To each constructor c : T0 → ... → Tn associate a location constructor
conloc c of type
conloc c : loc T0 → ... → loc Tn.
The two new evaluation rules associated with location constructors are given in Figure 2. They create identifiers for constructed locations and provide a specialisation rule for extensions that use them (the default rule being un- changed). Note that Theorem 3.1 still applies to this augmented system. Note
too that if c is an abstractor then the techniques used to give c a concrete rep- resentation must be adapted for conloc c.
The generic function loc creates constructed locations for constructed terms and primitive locations otherwise, e.g. for functions, commands and locations






themselves. It is defined by
Fig. 1. Evaluation Rules

(loc : X → loc X) =
| un → conloc un
| pair x0 x1 → conloc pair (loc x0) (loc x1)
| tag m x0 → conloc tag (primloc m) (loc x0)
| x → primloc x










Fig. 2. Evaluating constructed locations

Similarly, the generic valuation function is
(val : loc X → X) =
| conloc un → un
| conloc pair x0 x1 → pair (val x0) (val x1)
| conloc tag m x0 → tag (primval m) (val x0)
| x → primval x
The generic assignment function assign follows the same basic pattern as the others but takes two arguments. The definition of assign can be
(assign : loc X → X → comm) =
| conloc un → ( | un → skip)
| conloc pair x0 x1 → ( | pair y0 y1 → assign x0 y0; assign x1 y1)
| conloc tag m x → (
| tag n y →
match primval m with
| n → assign x y 
|	→ let u = conloc tag m x in primassign u (tag n y))
| x → primassign x
If the location was created by primloc then primassign will be invoked. Oth- erwise, assign will attempt to match the location constructor with that of the
new value. The only case where the matching can fail is when the location and the term are tagged with different names, e.g. the assignment in
let x = loc [1, 3, 5] in
assign x [2, 4, 6];


will succeed in updating the whole structure in-place, but the assignment in
let x = loc [1, 3] in assign x [2, 4, 6];
will first update the locations for the first two list entries to 2 and 4, but then fail to match nil name with cons name.
It is convenient to have some sugar syntax here: let !x denote val x and x := y denote assign x y. Here is our earlier example (1) modified to use constructed locations:
let x = loc [1] in
x := [2];
x := [8, 9].
Now the first assignment is in-place and the second assignment succeeds too.
Thus assignment operation is now a generic function that can perform in-place whenever reasonable and allocate fresh memory otherwise.


Examples
This section uses three examples to illustrate how higher-order functions and pattern-matching can be combined with in-place update, user-control of mem- ory and generic functions to produce short, expressive, efficient programs.

Insertion Sort
Insertion sort works by recursively inserting elements into a sorted list. Here is an implementation as a pair of purely functional programs. The insertion is performed by
(funinsertion : (X → X → bool) → X → list X → list X) g x =
| nil → [x]
| cons h t →
if g x h
then cons h (funinsertion g x t)
else cons x (cons h t)

funinsertion is then used recursively to perform the sort in (funinsertionsort : (X → X → bool) → list X → list X) g =
| nil → nil
| cons h t → funinsertion g h (funinsertionsort g t)

This algorithm uses space proportional to the square of the list length. The following imperative algorithm insertionsort has a similar structure but only uses a constant amount of new memory (when performing swap).

(swap : loc X → loc X → comm) x y =
let t = !x in x :=!y; y := t


(insertion : (X → X → bool) → loc X → loc list X → comm) g x =
| conloc nil → skip
| conloc cons h t →
if g !x !h
then swap x h; insertion g h t
else skip

(insertionsort : (X → X → bool) → loc list X → comm) g =
| conloc nil → skip
| conloc cons h t → insertionsort g t; insertion g h t

The drawback of this program is that the assignments may be expensive to execute when the structures are large. The solution is to instantiate the poly- morphic insertionsort to a type loc Y of locations to get a program of type
(loc Y → loc Y → bool) → loc list loc Y → comm
which can easily be modified to produce a program
insertionsort : (Y → Y → bool) → loc list loc Y → comm
which will use a more efficient swapping.

Converge
The function converge defined below iterates a function f : X → X until the result stabilises, i.e. until some test t : X → X → bool applied to the old and new values becomes true. This captures a common situation when
modelling the evolution of some system to a steady state, e.g. in the Barnes- Hut algorithm [1].
(converge : (X → X) → (X → X → bool) → X → X) f t x =
let y = loc x in
let z = loc (f x) in let b = loc false in while not (t !y !z) do
b := (not !b);
if !b
then y := (f !z)
else z := f !y done;
!y
The use of locations allows the programmer to indicate that exactly two locations of type X are required, rather than an unbounded number. Further, assignment will be done in-place if possible, with fresh memory allocated only when necessary. There are many examples where this will yield significant benefits. For example, it is common to represent complex dynamical systems using structures built of regions whose behaviours are of approximately equal complexity. If a region is quiet then its representation maintains it shape, and in-place update succeeds. Conversely, if a region is eventful then the shape of its representation is likely to change, and require fresh memory.


The Visitor
The visitor pattern [3] describes the process of traversing (and updating) a data structure. This can be done in Java by sub-classing from the Walkabout class [9] which uses reflection to determine the necessary structure. The con-
structor calculus supports a single generic visitor through its powerful pattern- matching approach. As with insertion sort, we will examine both a functional


and imperative version of the algorithm.
(funvisitor : name (X, Y ) → (Y → Y ) → Z → Z) m f =
| pair z0 z1 → pair (funvisitor m f z0) (funvisitor m f z1)
| tag n z0 → (
match n with
| m → f (tag n z0)
|	→ tag n (funvisitor m f z0))
| z → z
funvisitor n f z looks for sub-structures of z named by n and applies f to them. It can be viewed as a form of mapping. As with insertion sort, this algorithm is quadratic in its use of space.
By contrast, the (imperative) visitor only requires constant space.
(visitor : name (X, Y ) → (loc Y → comm) → loc Z → comm) m f z =
match z with
| conloc pair z0 z1 → visitor m f z0; visitor m f z1
| conloc tag n z0 → (
match (primval n) with
| m → f z 
|	→ visitor m f z0)
|	→ skip
Let us consider a particular situation, of updating the salaries of staff in an organisation. Given a type of salaries
datatype salary = salary of float
and a salary update function
(change salary : float → salary → salary) k = | salary y → salary (k ∗ y) we can define
(change salaries : float → Z → Z) k =
funvisitor salary name (change salary k).


For example, if we define a type of universities by
datatype string = string of list char
datatype staff name = staff name of string datatype staff = staff of staff name and salary datatype department = department of list staff datatype university = university of list department

then

let department1 = department [staff (staff name “Barry”) (salary 12.0),
staff (staff name “Helen”) (salary 13.0), staff (staff name “Tony”) (salary 14.0)] in change salaries 2.0 department1

evaluates to

department [staff (staff name “Barry”) (salary 24.0),
staff (staff name “Helen”) (salary 26.0),
staff (staff name “Tony”) (salary 28.0)].

The advantage of this approach is two-fold. First, one does not have to write nested patterns to represent departments, etc. Second, the visitor can be re-used after any change in the university structure, e.g. to create divisions, or on a totally different organisational structure.
Similarly, if we define
(change salary : float → loc salary → comm) k =
| conloc salary y → primassign y (k ∗ (primval y))
then
(update salaries : float → loc Z → comm) k =
visitor salary name (update salary k)
will update salaries in place.

Conclusions
The constructor calculus provides a powerful technique for building generic functions for operations like mapping and addition in terms of some simple


primitives. This paper shows that the same approach can be applied to im- perative operations. That is, primitive operations for creating, reading from and writing to locations can underpin the definition of generic functions for these operations. The most striking advantage of this approach is that the generic assignment operation performs in-place update whenever reasonable, and allocates fresh memory otherwise. To our knowledge, this has not been achieved in other polymorphic languages.
The expressive power of the approach is shown through some representative examples. The insertionsort program shows how the functional programming style, with its pattern-matching and recursion can be used to define efficient imperative code. The converge program nicely illustrates the value of sharing control between the programmer and the system: the programmer specifies
how many data structures are required while the system determines when fresh storage is required. The visitor program shows how the power of generic programming style combines naturally with the imperative features to provide flexible programming on large data structures.
The ideas and examples in this paper show that the constructor calculus is able to combine the functional and imperative programming styles within a single, simple calculus. We are investigating its relevance for other program- ming style such as object-orientation.

References
Barnes, J. E. and P. Hut, A hierarchical O(N log N ) force-calculation algorithm. Nature, 324(6270):446–449, 1986.
Backhouse, R. and T. Sheard, editors, Workshop on Generic Programming: Marstrand, Sweden, 18th June, 1998. Chalmers University of Technology, 1998.
Gamma, E., R. Helm, R. Johnson and J. Vlissides, Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995.
Hughes, R. J. M., L. Pareto and A. Aiken, Proving the correctness of reactive systems using sized types. In Symposium on Principles of Programming Languages. ACM Press, 1996.
Jay, C. B., Distinguishing data structures and functions: the constructor calculus and functorial types. In S. Abramsky, editor, Typed Lambda Calculi and Applications: 5th International Conference TLCA 2001, Krako´w, Poland, May 2001 Proceedings, volume 2044 of Lecture Notes in Computer Science, pages 217–239. Springer, 2001.
Jay, C. B., The constructor calculus.
www-staff.it.uts.edu.au/~cbj/Publications/constructors.ps, 2002.
Jeuring, J. editor, Proceedings: Workshop on Generic Programming (WGP 2000): July 6, 2000, Ponte de Lima, Portugal. Utrecht University, UU-CS-2000-19, 2000.
Paulson, L. C., ML for the Working Programmer. Cambridge University Press, 2nd edition, 1996.
Palsberg, Jens and C. Barry Jay, The essence of the visitor pattern. In Proceedings of COMPSAC’98, 22nd Annual International Computer Software and Applications Conference, pages 9–15, Vienna, Austria, August 1998.


Standard ML of New Jersey, cm.bell-labs.com/cm/cs/what /smlnj/.
The Third ACM SIGPLAN Workshop on Types in Compilation (TIC 2000) Montreal, Canada September 21, 2000, 2000. www.cs.cmu.edu /~crary/tic00/.
Wright, Andrew, Polymorphism for imperative languages without imperative types. Technical Report TR93-200, Rice University, 1993.
Xi, H. and F. Pfenning, Eliminating array bound checking through dependent types. In Proceedings of Programming Language Design and Implementation(PLDI ’98), Montreal, June 1998., pages 214–227, 1998.
