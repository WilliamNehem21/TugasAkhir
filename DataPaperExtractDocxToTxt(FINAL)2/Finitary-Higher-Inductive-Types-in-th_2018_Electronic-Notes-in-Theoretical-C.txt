Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 336 (2018) 119–134
www.elsevier.com/locate/entcs

Finitary Higher Inductive Types in the Groupoid Model
Peter Dybjer1,2
Department of Computer Science and Engineering Chalmers University of Technology
Gothenburg, Sweden
Hugo Moeneclaey3
Ecole normale sup´erieure de Paris-Saclay Paris, France

Abstract
A higher inductive type of level 1 (a 1-hit) has constructors for points and paths only, whereas a higher inductive type of level 2 (a 2-hit) has constructors for surfaces too. We restrict attention to finitary higher inductive types and present general schemata for the types of their point, path, and surface constructors. We also derive the elimination and equality rules from the types of constructors for 1-hits and 2-hits. Moreover,
we construct a groupoid model for dependent type theory with 2-hits and point out that we obtain a setoid model for dependent type theory with 1-hits by truncating the groupoid model.
Keywords: intuitionistic type theory, identity types, homotopy type theory, higher inductive types, setoids, groupoids


Introduction
Martin-L¨of [14] introduced the general identity type former I(A, a, aj), the elements of which are proofs that a and aj are equal elements of A. Since A can be any type, even an identity type, we can iterate this type former and obtain an infinite tower of higher identity types A, I(A, a, aj), I(I(A, a, aj), p, pj), I(I(I(A, a, aj), p, pj), θ, θj), etc. In extensional type theory [15,16] this hierarchy collapses, since it has a rule forcing I(A, a, aj) to have at most one element. However, this is not so in intensional type theory [14,17]. As Hofmann and Streicher [12] showed, it has a model, the

1 The first author was supported in part by the Swedish Research Council (Vetenskapsr˚adet) grant ”Types for Proofs and Programs”.
2 Email: peterd@chalmers.se
3 Email: hmoenecl@ens-paris-saclay.fr

https://doi.org/10.1016/j.entcs.2018.03.019
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

groupoid model, where I(A, a, aj) may have more than one element. In fact, it was later shown that intensional type theory has infinite-dimensional models in Kan simplicial sets [25] and Kan cubical sets [2] which support interesting new axioms such as Voevodsky’s univalence axiom.
A higher inductive type (hit) in the sense of Bauer, Lumsdaine, Schulman, and Warren is a type where all the iterated identity types are inductively generated. Higher inductive types occupy a central role in homotopy type theory [22], where the tower of identity types is given a topological interpretation: a and aj above are points in a space, p and pj are paths from a to aj, θ and θj are homotopies (or surfaces) between p and pj, etc. In this way hits are used as abstract models of certain spaces, such as the interval, the circle, the sphere, the torus, etc.
Although the idea behind higher inductive types is simple, a comprehensive account of their syntax and semantics is still lacking. There is work on their cate- gorical semantics [13,24] and on the semantics of some examples in cubical sets [3]. However, neither of these works answers the question of what a general notion of higher inductive type is. We quote the HoTT book [22, p 179]:
In this book we do not attempt to give a general formulation of what constitutes a ”higher inductive definition” and how to extract the elimination rule from such a definition – indeed, this is a subtle question and the subject of current research. Instead we will rely on some general informal discussion and numerous examples.
So we would like to know what the types of constructors for hits look like in general and what the associated elimination and equality rules are. We would also like to provide a model which shows the consistency of a general theory of higher inductive types. Actually, what is their foundational status and their relation to Martin-L¨of’s meaning explanations [15,16]? Can type theory with higher inductive types be modelled in type theory without higher inductive types, by reducing the meaning of higher inductive types to the standard inductive or inductive-recursive types?
Our goal is thus to formulate a general theory of higher inductive types similar to the theory of inductive families [5,4] and the theory of inductive-recursive definitions [8,9,10]. In this paper we take a step towards this goal by limiting ourselves to the simplest kinds of hits, the 1-hits with only point and path constructors and the 2-hits which may have surface constructors too. Moreover, we limit ourselves to ﬁnitary such constructors in a sense to be made precise below. We propose general schemata for introduction rules, and a method for deriving the elimination and equality rules from the introduction rules. The schema for 1-hits can be interpreted in the setoid model, where types are interpreted as setoids (sets with equivalence relations). Similarly, we interpret our schema for 2-hits in the groupoid model, where types are groupoids (categories where all arrows are isomorphisms).

Plan of the paper
In Section 2 we present an example of a 1-hit where the points are combinatory terms and the paths are proofs that two combinatory terms are convertible. We also sketch the interpretation of this 1-hit as a setoid. The aim here is to highlight

the close connection between 1-hits and equational theories. In Section 3 we first recall the general schema for inductive types and inductively defined binary rela- tions. Although these schemata admit generalized inductive deﬁnitions of infinitely branching trees (such as the elements of W-types) we explain why we here restrict attention to 1-hits given by ﬁnitary inductive deﬁnitions. We propose a schema for the introduction rules for such types and show how to derive their elimination and equality rules. In Section 4 we recall how a 2-hit can represent the torus. In Section 5 we propose an extended schema for 2-hits. We also discuss which of the hits in the HoTT-book are covered by our schema and which are not. In Section 6 we show how to model 2-hits as groupoids. For reasons of space we do not present the setoid model of 1-hits separately. Instead the groupoid model is presented in such a way that the setoid model can be read off as a truncated version of the groupoid model. In Section 7 we mention some related work and suggestions for further research.
Combinatory Logic as a 1-Hit
We start by presenting a small fragment of dependent type theory with dependent functions types written (x : A) → B(x) and non-dependent ones written A → B. Identity types are written a =A aj rather than I(A, a, aj). To this theory we add the rules for the 1-hit CL with its formation rule, introduction rules for points and paths, and elimination and equality rules.
We use “mathematical” notation f (x) for function application, f (x, y) for f (x)(y), etc. Furthermore, x1 : A1,..., xn : An ▶ A means that A is a type in the context x1 : A1,..., xn : An. If x : A ▶ C is a type (or term) depending on a variable x we often (but not always) use the notation C(x) to emphasize this dependence, and also write C(a) for the result of substituting a for x in C.
The introduction rule for identity types is refl : (x : A) → x =A x
for any type A. The elimination rule and equality rule (Paulin [21]) are
JC  : (x : A) → C(x, refl(x)) → (y : A) → (z : x =A y) → C(y, z)
JC(x, d, x, refl(x)) = d
where x : A, y : A, z : x =A y ▶ C(y, z). The usual rules of equality reasoning (transitivity, symmetry, replacement of equals for equals) can be derived from these rules. We shall also derive rules for a heterogeneous identity type a =B aj which lets us compare elements a : B(x) and aj : B(xj) where p : x =A xj, but B(x) and B(xj) are not necessarily deﬁnitionally (judgmentally) equal. Another derivable rule is that a function f : (x : A) → B(x) must preserve identity: apdf : (p : x =A xj) → f (x) =B f (xj).

Rules for combinatory logic as a 1-hit
The formation rule states that CL is a type. The introduction rules are divided into two parts: the types of the point constructors K, S : CL and app : CL → CL → CL and the types of the path constructors (for combinatory conversion)

Kconv : (x, y : CL) → app(app(K, x), y) =CL x
Sconv : (x, y, z : CL) → app(app(app(S, x), y), z) =CL app(app(x, z), app(y, z))
The other rules of combinatory conversion (reflexivity, transitivity, symmetry, ap- plication preserves equality) follow from the fact that =CL is an identity type.
The elimination rule for CL expresses how to define a function f : (x : CL) →
C(x) by structural induction on the point and path constructors (showing that it
preserves identity). This rule has the assumptions K˜ : C(K), S˜ : C(S), ap˜p : (x :
CL) → C(x) → (y : CL) → C(y) → C(app(x, y)), and also
K˜ conv : (x, y : CL) → (x˜ : C(x)) → (y˜ : C(y))
→ ap˜p(app(K, x), ap˜p(K, K˜ , x, x˜), y, y˜) =C	x˜
S˜conv : (x, y, z : CL) → (x˜ : C(x)) → (y˜ : C(y)) → (z˜ : C(z))
→ ap˜p(app(app(S, x), y), ap˜p(app(S, x), ap˜p(S, S˜, x, x˜), y, y˜), z, z˜)

C
Sconv (x,y,z)
The equality rules are
ap˜p(app(x, z), ap˜p(x, x˜, z, z˜), app(y, z), ap˜p(y, y˜, z, z˜)))

f (K) = K˜
f (S) = S˜
f (app(x, y)) = ap˜p(x, f (x), y,f (y))
apdf (Kconv(x, y)) = K˜ conv (x, y, f (x),f (y))
apdf (Sconv(x, y, z)) = S˜conv (x, y, z, f (x),f (y),f (z))

Setoid model
The above theory, dependent type theory with (x : A) → B(x), a =A aj, and CL, has a setoid model [11]. In this model, a type is interpreted as a setoid A consisting of a set A0 together with an equivalence relation R. Here we represent an equivalence
relation as a binary family of sets (A1(x, xj))x,x′∈A  such that A1(x, xj) is inhabited
iff R(x, xj) holds and empty otherwise. Moreover, a setoid map between two setoids
A = (A0, A1) and B = (B0, B1) is a function f0 : A0 → B0 together with a proof that it preserves the equivalence relation: f1 : (A1(x, xj)) → B1(f (x),f (xj)).
There are two reasons for this representation. Although we officially use set theory as the metalanguage for our model constructions, we conjecture that the construction can be carried out in extensional type theory, where an equivalence relation will be implemented by a family of types. (Cf Hofmann and Streicher’s similar claim [12] about their groupoid model.) However, there is another advantage: the setoid model can then be viewed asa truncated version of the groupoid model. The set of objects A0 together with the hom-sets A1(x, xj) of a groupoid form a setoid. In the sequel we will not distinguish between the family A1 and the equivalence relation R which it represents. (We also remark that extensional type theory has a direct interpretation in classical set theory [4], so that type-theoretic notation can be read off as official set theory.)
See Moeneclaey [18] for the details of the construction of a category with families

[6] of setoids and setoid maps which supports dependent function types, intensional identity types, and CL. Suffice it here to say that we interpret the type CL as the setoid (CL0, CL1) where CL0 is an inductive type generated by K, S, and app and CL1 is an inductive family [5,4] generated by Kconv and Sconv and the constructors for transitivity, reflexivity, symmetry, and preservation of equality by app.
A Schema for 1-Hits
We now ask ourselves what introduction rules for points and paths look like in general. We also construct a setoid model for such a general notion of 1-hit. As mentioned above we are looking for a schema for hits in the style of the schema for inductive families [5,4]. The obvious first try is to stay as close as possible to that schema and stipulate that the type of a point constructor for a hit can have the same form as the type of a constructor for an inductive type; and the type of a path constructor for a hit can have the same form as the type of a constructor for a binary inductive family.
The general form of the type of a constructor for an inductive type H is
(x1 : A1) → · · · → (xm : Am(x1,..., xm—1))
→ (B1(x1,..., xm) → H) → · · · → (Bn(x1,..., xm) → H) → H
where A1 is a type, ..., Am(x1,..., xm—1) is a type if (x1 : A1,..., xm—1 :
Am—1(x1,..., xm—2)), and B1(x1,..., xm),..., Bn(x1,..., xm) are types if x1 : A1,..., xm : Am(x1,..., xm—1), and all those judgments are true in the theory without the rules for H. So Ai and Bj do not depend on H.
This general form is obtained by specializing the schema for inductive families [5,4] to the case of inductive types. We remark that Bj can in fact be any sequence of types. We call xi : Ai a non-inductive premise (or side condition) and yj : Bj(x1,..., xn) → H an inductive premise. If Bj is the empty sequence for all j, then we have an ordinary or ﬁnitary inductive definition, otherwise we have a generalized inductive definition.
Note that this is only a mild generalization of the type of the constructor of the W-type [15], which is obtained by setting m = n = 1. In fact, in extensional type theory any inductive type with constructors of the above form is equivalent to a W-type. This is a special case of a more general theorem about the encoding of strictly positive inductive types as W-types [7].
However, a complication arises in the setoid interpretation of generalized induc- tive definitions of a hit H. Assume for example that H has a point constructor c0 : (B → H) → H and that it is interpreted by the set of points H0 and the family of sets of paths H1(x, y) for x, y ∈ H0. Since functions must preserve the equivalence relation, we expect the type of the interpreted constructor for H0 to be
c00 : (f ∈ B0 → H0) → ((x, xj ∈ B0) → B1(x, xj) → H1(f (x),f (xj))) → H0
(Note that this is a typing in the metalanguage and that we use ”∈” rather than ”:” for set/type membership.) Since H1 will be interpreted as an inductive family, we conclude that H0 and H1 are simultaneously defined by an inductive-inductive

definition. However, we prefer not to complicate the metatheory - after all the theory of inductive-inductive definitions is complex [20,19]. For this reason, we choose here to restrict to the simpler case of finitary hits which still cover most hits in the HoTT-book [22], see Section 5.3. As the reader will see, already the theory of finitary 2-hits is quite complex, and we think that it is preferable to leave the additional complexity of generalized inductive definitions to future work.

A schema for point constructors
The general form of a type of a point constructor for a finitary hit is
c0 : (x1 : A1) → · · · → (xm : Am(x1,..., xm—1)) → H → · · · → H → H
where A1 is a type, .. ., and Am(x1,..., xm—1) is a type if x1 : A1,..., xm—1 : Am—1(x1,..., xm—2), all those judgments being true in the theory without the rules for H.

A schema for path constructors
The general form of the type of a path constructor for a finitary hit is: c1 : (x1 : B1) → · · · → (xn : Bn(x1,..., xn))
→ (y1 : H) → · · · → (yn′ : H)
→ p1(x1,..., xn, y1,..., yn′ ) =H q1(x1,..., xn, y1,..., yn′ )
.
→ pn′′ (x1,..., xn, y1,..., yn′ ) =H qn′′ (x1,..., xn, y1,..., yn′ )
→ p (x1,..., xn, y1,..., yn′ ) =H q (x1,..., xn, y1,..., yn′ ) where neither H nor =H may appear in Bi. Moreover, the terms
p1(x1,..., xn, y1,..., yn′ ), q1(x1,..., xn, y1,..., yn′ ),
.,
pn′′ (x1,..., xn, y1,..., yn′ ), qn′′ (x1,..., xn, y1,..., yn′ ),
j	j
p (x1,..., xn, y1,..., yn′ ),q (x1,..., xn, y1,..., yn′ )
are point constructor patterns built up according to the following syntax
p ::= y | c0(a1,..., am, p1,..., pk)
where y : H is a variable among y1,..., yn′ , where pj : H are point constructor patterns, and where x1 : B1,..., xn : Bn(x1,..., xn) ▶ ai : Ai(a1,..., ai—1) are terms built without using any rule for H.
Note that if we delete the second line of the type of the path constructor c1, the schema looks exactly like the schema for constructors for binary finitary inductive families [5] (except that the present schema allows only point constructor patterns and not general terms for the pj). However, we now ask ourselves whether H can appear in a side-condition Bj. Unfortunately, it cannot appear in an arbitrary way,

since a negative occurrence of H could lead to a contradiction. Therefore we simply forbid H to appear in Bj and have a separate list of premises of the form yk : H.

A simpliﬁed form for point and path constructors
In order to simplify the presentation of the elimination and equality rules, we only spell out the special case with one point constructor with m = 1 (one side condition) and one inductive premise
c0 : A → H → H
and one path constructor with n = nj = njj = 1:
c1 : (x : B) → (y : H) → p(x, y) =H q(x, y) → pj(x, y) =H qj(x, y)
We emphasize that this simplification is only a matter of presentation. It is routine but verbose to generalize this simplified form to the general form for constructors for ordinary hits. (The general form is of course necessary to get interesting hits.)

Elimination and equality rules
The elimination rule expresses how to define a function f : (x : H) → C(x) by structural induction on the points and paths (showing that the function preserves identity). More specifically, given
c˜0 : (x : A) → (y : H) → C(y) → C(c0(x, y))
c˜1 : (x : B) → (y : H) → (y˜ : C(y))
→ (z : p =H q) → T0(p) =C T0(q) → T0(pj) =C	T0(qj)
z	c1(x,y,z)
where T0(p): C(p) is the lifting of p : H (to be defined below), we can define f by
f (c0(x, y)) = c˜0(x, y, f (y))
apdf (c1(x, y, z)) = c˜1(x, y, f (y), x, apdf (z))
Note that the second equality is a deﬁnitional equality, rather than only a propo- sitional one, as in the HoTT-book [22]. This definitional equality will be validated by the groupoid model below.

The lifting function
We denote the ”lifting” of a point constructor pattern p :H by T0(p): C(p). The idea is that T0(p) will be equal to f (p), but the latter is not defined yet. For example the liftings of the two point constructor patterns in the equation for K˜ conv are
T0(app(app(K, x), y)) = ap˜p(app(K, x), ap˜p(K, K˜ , x, x˜), y, y˜) T0(x)= x˜
This lifting function for CL is defined by T0(x)= x˜, T0(y)= y˜, T0(K) = K˜ , T0(S) = S˜, and T0(app(t, tj)) = ap˜p(t, T0(t), tj, T0(tj))
In the general (simplified) schema the definition of T0(p(x, y)) : C(p(x, y)) is by induction on the form of the point constructor patterns p(x, y):

T0(y)= y˜
T0(c0(a, p)) = c˜0(a, p, T0(p))
Hence, x : B, y : H, y˜ : C(y) ▶ T0(p(x, y)) : C(p(x, y)) and T0(p)(x, y, f (y)) =
f (p(x, y)). Therefore the equation for apdf (c1(x, y, z)) above is well-typed.
We refer the reader to Moeneclaey [18] for the setoid model of the schema for 1-hits and again point out that it arises by truncating the groupoid model.

The Torus as a 2-Hit
We shall now consider 2-hits with surface constructors in addition to point and path constructors. An example is the following hit which represents the torus T2 as a CW-complex [22]. It has four constructors:
base : T2
path1 : base =T2 base path2 : base =T2 base
surf : path1 ◦ path2 =base=T2 base path2 ◦ path1
In order to state its elimination principle we will make use of a heterogeneous

identity type of level 2. Let a, aj : A, p, pj : a =A aj, θ : p =a=
bj : B(aj), q : b =B bj, qj : b =B bj. We write
q =b=Bb′ qj
a′ pj, b : B(a),

for the heterogeneous identity of the paths q, qj.
We can now prove that functions preserve level 2 identities by identity elimina- tion. If f : (x : A) → C(x) then
2	j	f (x)=C f (x′)	j
apdf : (θ : p =x=Ax′ p ) → apdf (p) =θ	apdf (p )
Now we can formulate the elimination rule for T2. Assume x : T2 ▶ C(x) and

˜b : C(base), p˜1 : ˜b =C
1
˜b, p˜2 : ˜b =C
2
˜b, and also

s˜: p˜1 ◦j
˜b=C˜b
p˜2 =surf
p˜2 ◦j
p˜1

Note the composition ◦j of heterogeneous paths, which can be derived from the J-eliminator. Then there exists a function f : (x : T2) → C(x) such that
f (base) = ˜b apdf (path1)= p˜1 apdf (path2)= p˜2
apd2 (surf) = s˜
The last equation is well typed using the definitional equality apdf (p ◦ q) = apdf (p) ◦j apdf (q) which is true in the groupoid model. These equalities (and similar ones for heterogeneous inverses) are needed for our schema to be well-typed.

A Schema for Finitary 2-Hits
A schema for surface constructors
We shall now present a general schema for 2-hits. The form of point and path constructors are as for 1-hits. The simplified form of a surface constructor is
c2 : (x : D) → (y : H) → (z : p3(x, y) =H q3(x, y))
→ g1(x, y, z) =p4(x,y)=Hq4(x,y) h1(x, y, z)
→ g2(x, y, z) =p5(x,y)=Hq5(x,y) h2(x, y, z)
(In the general form the four premises x : D, y : H,z : p3 =H q3, zj : g1 =p = q h1 become four finite (possibly empty) sequences of premises. Cf the general form of point constructors in 3.1 and path constructors in 3.2.) Here D is a correct type in a theory without the rules for H, so neither H, =H nor = =H  may appear in it. Moreover, in the theory extended with H-formation and H-introduction for the point constructor c0, all of x : D, y :H ▶ p3, q3, p4, q4, p5, q5 : H are point construc- tor patterns (built up from variables by c0) and g1, h1, g2, h2 are path constructor patterns built from the following grammar:
g ::= z | c1(a, p, g) | g ◦ g | id | g—1
where z : p3 =H q3 is a path variable, x : D ▶ a : B is a term built without using rules for H, and p : H is a point constructor pattern under the assumption x : D, y : H.
Each path constructor pattern comes with some definitional equalities which are valid in the groupoid model. It would also be natural to add a fourth ”default constructor” apc0 (corresponding to the arrow part of the point constructor in the model) to the grammar for path constructor patterns. However, checking the interpretation of apc0 in the groupoid model requires lengthy calculations, which we have not yet completed.
Elimination and equality rules
The elimination rule expresses how to define a function f : (x : H) → C(x) by induction with one case for each of the point, path, and surface constructors. To this end we assume we have step functions c˜0 and c˜1 as in the elimination rule for 1-hits and moreover a step function for the surface constructor
c˜2 : (x : D) → (y : H) → (y˜ : C(y)) → (z : p3 =H q3)

→ (z˜ : T0(p3) =C T0(q3)) → (t : g1 =p = q
h1)

→ T (g ) =T0(p4)=HT0(q4) T (h ) → T (g ) =T0(p5)=HT0(q5) T (h )

1  1	t
1	1	1  2
c2(x,y,z,t)	1	2

The lifting T1(g) : T0(p) =C
T0(q) of a path constructor pattern g : p =H q is

defined in an analogous way to the lifting T0(p) of a point constructor pattern:
T1(z)= z˜
T1(c1(x, y, g)) = c˜1(x, y, T0(y), g, T1(g))

T1(g ◦ gj)= T1(g) ◦j T1(gj) T1(id) = id
T (g—1)=T (g)—1′
1	1
where p—1′ denotes the inverse of a path p.
The equality rules for f are:
f (c0(x, y)) = c˜0(x, y, f (y))
apdf (c1(x, y, z)) = c˜1(x, y, f (y), z, apdf (z))
apd2 (c2(x, y, z, t)) = c˜2(x, y, f (y), z, apdf (z), t, apd2 (t))
f	f
Note that all three equality rules are deﬁnitional equalities which are valid in the groupoid model. The last equation type-checks for similar reasons as the second equation (see Section 3.5). We prove by induction on path constructor patterns that T1(g)(x, y, f (y), z, apdf (z)) = apdf (g(x, y, z)).  This proof uses the definitional

equalities apdf
(p ◦ q) = apdf
◦j apdf
and apdf
(p—1) = apdf
(p)—1′ which

are valid in the groupoid model.
Even without these equalities the types of the two sides of the equalities are isomorphic. So it would be possible to add the suitable isomorphisms everywhere, but some coherence problems would arise.
Hits in the HoTT-book
Many of the hits in the HoTT-book are instances of our general syntactic schema. For example the interval, the circle, propositional truncation, the suspension, and the pushout are instances of our schema for 1-hits. The 2-sphere, the torus, the 0-truncation, and the set-quotient are instances of our schema for 2-hits. However, the alternative definition of the torus using hubs and spokes [22, p192] is not an instance of our schema for 1-hits, since it breaks the requirement that only point constructor patterns are allowed in the indices (endpoints) of the types of path constructors. Moreover, the alternative definition of 0-truncation [22, p199] uses generalized induction, and is not covered by our schema either.
Groupoid Model of the Schema for 2-Hits
We build on Hofmann and Streicher’s [12] groupoid model of intensional type theory and have also made use of Ruch’s path model [23]. Just as Hofmann and Streicher we work in set-theoretic meta-language, but conjecture that the model can also be carried out in extensional type theory. In order to suggest why this is the case we will write our definitions in a type-theoretic style, and use the fact that extensional type theory has a set-theoretic model, see e g [4].
A groupoid H (in type-theoretic style, cf the discussion of the representation of setoids) is a tuple (H0, H1, H2, ◦, id, (−)1, tran, refl, sym, w0, w1, α, λ, ρ, ι0, ι1) where
H0 is the set of objects, H1(a, aj)a,a′∈H  is the set of arrows from a to aj and
j	j
H2(f, f )f,f′∈H1(a,a′) is the set of proofs of equality of the arrows f and f . More-
over, ◦, id, (−)1 denote respectively the composition, identity, and inverse opera-

tions. The remaining components witness that equality of arrows is a congruence relation (w0, w1) which satisfies associativity (α), identity (λ, ρ), and inverse laws (ι0, ι1). When refering to a groupoid we typically omit all components except the three first: H = (H0, H1, H2).
The usual set-theoretic notion of groupoid is recovered by defining hom-sets as quotients H1(a, aj)/R(a, aj), where R(a, aj) is the equivalence relation for arrows between a and aj generated by H2. Furthermore, when we use set-theoretic met- alanguage we shall for simplicity identify all proofs of equality of arrows so that θ, θj ∈ H2(f, fj) implies θ = θj. We call this unique element ∗. This representation does not only pave the way for a type-theoretic implementation of the groupoid model, but also for extending our work to the interpretation of 3-hits in a weak 2-groupoid model.
In the groupoid model, a family of types x : A ▶ C(x) is interpreted as a functor from the groupoid A into the category of groupoids. We let C0 denote the object part of that functor, so that C0(x) is a groupoid for x ∈ A0, and C1 denote the arrow part, so that C1(f ) : C0(x) → C0(xj) is a transport functor for f ∈ A1(x, xj). Further- more, we use the notation Cj (x, xj, f, y, yj) for f ∈ A1(x, xj),y ∈ C0(x), yj ∈ C0(xj) for the set of heterogeneous paths between points in different fibres (mediated by the transport). Moreover, we write Cj (f, fj, θ, z, zj, g, gj) where f, fj ∈ A1(x, xj),θ ∈ A2(f, fj),z ∈ C(x), zj ∈ C(xj),g ∈ Cj (z, zj,f ), gj ∈ Cj (z, zj,fj) for the heteroge-
1	1
neous equality (mediated by the transport) of the heterogeneous paths g, gj. A func-
tion f : A → B is interpreted as a functor F between groupoids. It is represented type-theoretically by a triple (F0, F1, F2) representing the object, arrow, and proof of preservation of equality of arrows parts. Similarly, a function x : A ▶ f (x): C(x) is interpreted as a ”dependent functor” between the source groupoid and the fam- ily of fibre groupoids. We refer to Hofmann and Streicher [12] for details of the interpretation.
Note that we justify definitional computation rules also for apf and ap2 , whereas in the HoTT-book there is an informal discussion about models leading to those computation rules being propositional equalities only.
The groupoid model below captures the structure of paths up to homotopy. For example, one can show that in this model the hit T2 is interpreted by its fundamental groupoid Π1(T2) (i.e. isomorphic to Z ⊕ Z). However, the groupoid model does not capture the structure in the higher dimensions. For example, although the 2-sphere is a 2-hit, the groupoid model does not capture its non-trivial structure in dimension
2. Similarly, although we can show that the circle S1 is interpreted by Π1(S1) ∼= Z
in the groupoid model, it is trivial in the setoid model.

Formation rule
Recall the types of the point and path constructors of the schematic 2-hit above: c0 : A → H → H
c1 : (x : B) → (y : H) → p =H q → pj =H qj
c2 : (x : D) → (y : H) → (z : p3 =H q3) → g1 =p4=Hq4 h1 → g2 =p5=Hq5 h2

Let the type A be interpreted by the groupoid (A0, A1, A2), B be interpreted by the groupoid (B0, B1, B2), and D be interpreted by the groupoid (D0, D1, D2). Moreover, p is interpreted as the dependent functor (p0, p1, p2) (cf the groupoid model of terms-in-context, see Hofmann-Streicher or Ruch) consisting of an object, arrow, and preservation of equality part. And similarly for pj, qj, p3, q3, p4, q4, p5, q5. The interpretations of g1, h1, g2, h2 are also dependent functors.
We interpret the schematic hit H as the inductively generated groupoid (H0, H1, H2) the constructors of which will ensure that the types of the point, path and surface constructors in the theory of 2-hits are interpreted as appropriate depen- dent functors between groupoids. The key observation is that all the constructors thus obtained have types which are instances of the general form of a type for a con- structor of a finitary inductive family [5]. Hence we conjecture that the groupoid model of 2-hits can be developed inside a core extensional type theory extended with a schema for these finitary inductive families.
H0 is inductively generated by a constructor for the object part of the point constructor
c00 ∈ A0 → H0 → H0
Using c00, a term p0(x, y) ∈ H0, where x ∈ B0 and y ∈ H0, can be defined by induction on the structure of a point constructor pattern p:
y0(x, y)= y
(c0(s, t))0(x, y)= c00(s0(x), t0(x, y))
where s0 is provided by the hypothesis that s is a term of type A where H does not occur, whereas t0 is provided by the induction hypothesis.
H1 is inductively generated by:
a constructor for the object part of the path constructor
c10 ∈ (x ∈ B0) → (y ∈ H0) → H1(p0(x, y), q0(x, y)) → H1(pj (x, y), qj (x, y))
0	0
a constructor for the arrow part of the point constructor: c01 ∈ (x, xj ∈ A0) → A1(x, xj) → (y, yj ∈ H0)
→ H1(y, yj) → H1(c00(x, y), c00(xj, yj))
constructors for composition, identity, and inverse of paths
◦∈ (x, y, z ∈ H0) → H1(x, y) → H1(y, z) → H1(x, z) id ∈ (x ∈ H0) → H1(x, x)
(−)—1 ∈ (x, y ∈ H0) → H1(x, y) → H1(y, x)
For a point constructor pattern p and x, xj ∈ B0, y, yj ∈ H0, ex ∈ B1(x, xj) and
ey ∈ H1(y, yj) we define p1(ex, ey) ∈ H1(p0(x, y), p0(xj, yj)) by
y1(ex, ey)= ey
(c0(s, t))1(ex, ey)= c01(s0(x), s0(xj), s1(ex), t0(x, y), t0(xj, yj), t1(ex, ey))
where s1 comes from the fact that s is a groupoid map and t1 from the induction hypothesis.

Similarly for g a path constructor pattern from p to q and x ∈ D0,y ∈ H0,z ∈
H1((p3)0(x, y), (q3)0(x, y)), we define g0(x, y, z) ∈ H1(p0(x, y), q0(x, y)) by
z0(x, y, z)= z
c1(s, t, gj)0(x, y, z)= c10(s0(x), t0(x, y), gj (x, y, z))
where s0 comes from the fact that s is a term, t0 because t is a point constructor

pattern and gj
by induction. The equations for identity, composition and inverse

are omitted.
H2 (representing equality of paths) is inductively generated by
the object part of the surface constructor
c20 ∈ (x ∈ D0) → (y ∈ H0) → (z ∈ H1((p3)0, (q3)0))
→ H2((p4)0, (q4)0, (g1)0, (h1)0) → H2((p5)0, (q5)0, (g2)0, (h2)0)
the arrow part of the path constructor:
c11 ∈ (x, xj ∈ B0) → (ex ∈ B1(x, xj)) → (y, yj ∈ H0) → (ey ∈ H1(y, yj))
→ (z ∈ H1(p0(x, y), q0(x, y))) → (zj ∈ H1(p0(xj, yj), q0(xj, yj)))
→ H2(p0(x, y), q0(xj, yj),z ◦ q1(ex, ey), p1(ex, ey) ◦ zj)
→ H2(pj (x, y), qj (xj, yj), c10(x, y, z) ◦ qj (ex, ey), pj (ex, ey) ◦ c10(xj, yj, zj))
0	0	1	1
the surface (preservation of equality of arrows) part of the point constructor: c02 ∈ (x, xj ∈ A0) → (ex, exj ∈ A1(x, xj)) → A2(x, xj, g, gj)
→ (y, yj ∈ H0) → (ey, eyj ∈ H1(y, yj)) → H2(y, yj, ey, eyj)
→ H2(c00(x, y), c00(xj, yj), c01(x, xj, ex, y, yj, ey), c01(x, xj, exj, y, yj, eyj))
the functor laws for the point constructor:

cid ∈ (x ∈ A0) → (y ∈ H0) → H2(c00(x, y), c00(x, y), c01(x, x, idx, y, y, idy), idc c○ ∈ (x, xj, xjj ∈ A0) → (ex ∈ A1(x, xj)) → (exj ∈ A1(xj, xjj))
(x,y))

→ (y, yj, yjj ∈ H0) → (ey ∈ H1(y, yj)) → (eyj ∈ H1(yj, yjj))
→ H2(c00(x, y), c00(xjj, yjj),
c01(x, xj, ex, y, yj, ey) ◦ c01(xj, xjj, exj, yj, yjj, eyj),
c01(x, xjj, ex ◦ exj, y, yjj, ey ◦ eyj))
witnesses that H2 is a family of equivalence relations: tran ∈ (x, y : H0) → (u, v, w : H1(x, y))
→ H2(u, v) → H2(v, w) → H2(u, w)
refl ∈ (x, y ∈ H0) → (u ∈ H1(x, y)) → H2(u, u)
sym ∈ (x, y ∈ H0) → (u, v ∈ H1(x, y)) → H2(u, v) → H2(v, u)
witnesses (whiskerings) that composition preserves equality: w0 ∈ (x, y, z ∈ H0) → (u, v ∈ H1(x, y))
→ (w ∈ H1(y, z)) → H2(u, v) → H2(u ◦ w, v ◦ w)
w1 ∈ (x, y, z ∈ H0) → (u, v ∈ H1(y, z))
→ (w ∈ H1(x, y)) → H2(u, v) → H2(w ◦ u, w ◦ v)
witnesses for the groupoid laws:

A ∈ (x0, x1, x2, x3 ∈ H0) → (u ∈ H1(x0, x1))
→ (v ∈ H1(x1, x2)) → (w ∈ H1(x2, x3))
→ H2((u ◦ v) ◦ w, u ◦ (v ◦ w))
λ ∈ (x, y ∈ H0) → (u ∈ H1(x, y)) → H2(u, idx ◦ u)
ρ ∈ (x, y ∈ H0) → (u ∈ H1(x, y)) → H2(u, u ◦ idy)
ι0 ∈ (x, y ∈ H0) → (u ∈ H1(x, y)) → H2(u ◦ u—1, idx)
ι1 ∈ (x, y ∈ H0) → (u ∈ H1(x, y)) → H2(u—1 ◦ u, idy) It follows immediately that (H0, H1, H2) is a groupoid.
Introduction rules
The point constructor c0 : A → H → H is interpreted by the functor on groupoids with object part c00, arrow part c01 and preservation of equality part c02. The functor laws are witnessed by the constructors cid and c○.
0	0
A groupoid interpreting x =H y is a setoid and hence functors on such groupoids
degenerate to setoid-maps. Hence, the path constructor
c1 : (x : B) → (y : H) → p(x, y) =H q(x, y) → pj(x, y) =H qj(x, y)
is interpreted by the setoid map with underlying function c10 and preservation of equality part c11.
A groupoid interpreting f =x= x′ fj has only one object and one arrow (up to equality). Hence it suffices to state that the constructor for surfaces c2 is interpre- treted by the constructor c20.

Elimination and equality rules
To justify the elimination and equality rules we need to construct a dependent groupoid functor f : (x : H) → C(x) such that
f (c0(x, y)) = c˜0(x, y, f (y))
apdf (c1(x, y, z)) = c˜1(x, y, f (y), z, apdf (z))
apd2 (c2(x, y, z, w)) = c˜2(x, y, f (y), z, apdf (z), w, apd2 (w))
f	f
First we define the object part f0 : (x ∈ H0) → C0(x) by H0-elimination:
f0(c00(x, y)) = (c˜0)0(x, y, f0(y)))
Then we define the arrow part
f1 ∈ (x, xj ∈ H0) → (g ∈ H1(x, xj)) → Cj (g, f0(x), f0(xj))

where Cj
is the heterogeneous equality (between elements of different fibres). This

is done by H1-elimination:
f1(c10(x, y, z)) = (c˜1)0(x, y, f0(y), z, f1(p0(x, y), q0(x, y), z))
f1(c01(x, xj, e, y, yj, d)) = (c˜0)1(x, xj, e, y, yj, d, f0(y), f0(yj), f1(y, yj, d))

where we have omitted the clauses which say that f1 maps an identity on H to an identity, a composition to a composition, and an inverse to an inverse.
Finally, we prove by H2-elimination that f1 preserves equality of arrows:
f2 : (x, xj ∈ H0) → (ex, exj ∈ H1(x, xj))
→ (∗∈ H2(x, xj, ex, exj)) → Cj (∗, f1(x, xj, ex), f1(x, xj, exj))

Here Cj
is a heterogeneous notion of equality between heterogeneous paths. (Note

that there is only one proof of this notion of equality, so all the equations are into a singleton.)
The calculations required for the verification of the elimination and equality rules in the groupoid model are lengthy, but routine, and are left out because of space restrictions. They are included in the full version of the paper which can be found at http://www.cse.chalmers.se/~peterd/papers/hits.html.
Related and further research
Some of the material in this paper (the schema for 1-hits and its setoid model) can be found in the internship report by Moeneclaey [18]. There is also recent work by Basold, Geuvers, and Van der Weide [1]. They formulate a schema for 1-hits and derive elimination rules from the types of the constructors. Their schema is more restricted than ours (for 1-hits) since their path constructors are witnesses of equations, whereas our path constructors can also be witnesses of conditional equations. Moreover, they do not discuss semantics.
The present paper is only a step towards a general theory of hits. There are several possible generalizations, for example, to 3-hits and their interpretation as weak 2-groupoids, to hits with generalized induction, and to hits with a more general class of constructor point and path expressions. In order to get a general theory of hits in cubical type theory [3], a useful step might be to reformulate our theory of 1-hits and 2-hits using degeneracies and restriction maps.

References
Henning Basold, Herman Geuvers, and Niels van der Weide. Higher inductive types in programming.
Journal of Universal Computer Science, 23(1):63–88, 2017.
Marc Bezem, Thierry Coquand, and Simon Huber. A model of type theory in cubical sets. In 19th International Conference on Types for Proofs and Programs, TYPES 2013, April 22-26, 2013, Toulouse, France, pages 107–128, 2013.
Cyril Cohen, Thierry Coquand, Simon Huber, and Anders M¨ortberg. Cubical type theory: a constructive interpretation of the univalence axiom. Submitted for publication, 2015.
Peter Dybjer. Inductive sets and families in Martin-Lo¨f’s type theory and their set-theoretic semantics. In Gerard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 280–306. Cambridge University Press, 1991.
Peter Dybjer. Inductive families. Formal Aspects of Computing, 6:440–465, 1994.
Peter Dybjer. Internal type theory. In Types for Proofs and Programs, International Workshop TYPES’95, Torino, Italy, June 5-8, 1995, Selected Papers, pages 120–134, 1995.
Peter Dybjer. Representing inductively defined sets by wellorderings in Martin-L¨of’s type theory.
Theor. Comput. Sci., 176(1-2):329–335, 1997.

Peter Dybjer. A general formulation of simultaneous inductive-recursive definitions in type theory.
Journal of Symbolic Logic, 65(2), June 2000.
Peter Dybjer and Anton Setzer. A finite axiomatization of inductive-recursive definitions. In Jean-Yves Girard, editor, Typed Lambda Calculi and Applications, volume 1581 of Lecture Notes in Computer Science, pages 129–146. Springer, April 1999.
Peter Dybjer and Anton Setzer. Indexed induction-recursion. J. Log. Algebr. Program., 66(1):1–49, 2006.
Martin Hofmann. Elimination of extensionality in Martin-L¨of type theory. In Types for Proofs and Programs, International Workshop TYPES’93, Nijmegen, The Netherlands, May 24-28, 1993, Selected Papers, pages 166–190, 1993.
Martin Hofmann and Thomas Streicher. The groupoid model refutes uniqueness of identity proofs. In Proceedings of the Ninth Annual Symposium on Logic in Computer Science (LICS ’94), Paris, France, July 4-7, 1994, pages 208–212, 1994.
Peter LeFanu Lumsdaine and Michael Shulman. Semantics of higher inductive types. 2012.
Per Martin-Lof. An intuitionistic theory of types: Predicative part. In H. E. Rose and J. C. Shepherdson, editors, Logic Colloquium ‘73, pages 73–118. North Holland, 1975.
Per Martin-Lof. Constructive mathematics and computer programming. In Logic, Methodology and Philosophy of Science, VI, 1979, pages 153–175. North-Holland, 1982.
Per Martin-Lo¨f. Intuitionistic Type Theory. Bibliopolis, 1984.
Per Martin-Lo¨f. Amendment to intuitionistic type theory. Notes from a lecture given in G¨oteborg, March 1986.
Hugo Moeneclaey. Higher inductive types of level 1. http://www.cse.chalmers.se/~peterd/papers/ moeneclaey.pdf, August 2016. Internship report, ENS Cachan.
Fredrik Nordvall Forsberg. Inductive-inductive definitions. PhD thesis, Swansea University, 2013.
Fredrik Nordvall Forsberg and Anton Setzer. Inductive-inductive definitions. In Computer Science Logic, 24th International Workshop, CSL 2010, 19th Annual Conference of the EACSL, Brno, Czech Republic, August 23-27, 2010. Proceedings, pages 454–468, 2010.
Christine Paulin-Mohring. Inductive definitions in the system Coq - rules and properties. In Proceedings Typed λ-Calculus and Applications, pages 328–345. Springer-Verlag, LNCS, March 1993.
Univalent Foundations Project. Homotopy Type Theory – Univalent Foundations of Mathematics. 2013.
Fabian Ruch. The path model of intensional type theory. Master of Science Thesis in Computer Science, Chalmers University of Technology, 2015.
Kristina Sojakova. Higher inductive types as homotopy-initial algebras. In Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015, pages 31–42, 2015.
Vladimir Voevodsky. The equivalence axiom and univalent models of type theory. arXiv 1402.5556, page 1–11, 2010.
