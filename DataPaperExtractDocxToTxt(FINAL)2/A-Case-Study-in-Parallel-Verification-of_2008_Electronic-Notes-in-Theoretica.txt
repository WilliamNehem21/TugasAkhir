

Electronic Notes in Theoretical Computer Science 220 (2008) 67–83
www.elsevier.com/locate/entcs

A Case Study in Parallel Verification of Component-Based Systems
N. Beneˇs, I. Cˇern´a, J. Sochor, P. Vaˇrekov´a and B. Zimmerova1,2

Faculty of Informatics, Masaryk University Brno, Czech Republic

Abstract
In large component-based systems, the applicability of formal verification techniques to check interaction correctness among components is becoming challenging due to the concurrency of a large number of com- ponents. In our approach, we employ parallel LTL-like model checking to handle the size of the model. We present the results of the actual application of the technique to the verification of a complex model of a real system created within the CoCoME Modelling Contest [18]. In this case study, we check the validity of the model and the correctness of the system via checking various temporal properties. We concentrate on the component-specific properties, like local deadlocks of components, and correctness of given use-case scenarios.
Keywords: Component-based systems, formal verification, parallel model checking.


Introduction
During the last decade, software industry has seriously started to take advantage of component-based software development as an alternative to existing software devel- opment techniques. Component-based development proposes to assemble software systems from reusable components, possibly in a hierarchical manner. This helps to significantly reduce development costs, but brings the issue of correctness of such systems, especially if components are delivered by different vendors.
In this paper, we present a practical application of parallel verification to a large component-based system designed within the CoCoME Modelling Contest [15]. In the contest, a number of teams were asked to create a detailed model of a common
component-based system to make their modelling approaches comparable. While in [18], we present our model of the CoCoME system, this paper complements the

1 Email: {xbenes3,cerna,sochor,xvareko1,zimmerova}@fi.muni.cz
2 The work has been supported by the grants No. 1ET400300504 and No. 1ET408050503.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.014

work by verifying the model. In verification, we concentrate on properties of the final model like correctness of given use-case scenarios, local deadlocks of components, and response properties. Besides these we discuss how the verification helped us to check the validity of the model during modelling.
As a modelling language for component-based systems we use Component- Interaction automata (or CI automata for short) [6,8] which allow very precise and
detailed description of communication among system components. System proper- ties are specified in an extended version of the action-based linear time logic LTL, called CI-LTL. For the verification itself we use the automata-based model check-
ing algorithms implemented in the parallel model checking tool DiVinE [4,10]. We
advocate the choice of a parallel tool by a tremendous size of the model given by concurrency of components in the system.
A short description of the CoCoME Modelling Contest is given in Section 2 followed by an outline of the CI automata modelling language and the CI-LTL logic in Section 3. Section 4 introduces the model we have created within the contest, and Section 5 lists required properties and use-case scenarios including their verification. Finally, Section 6 discusses the results and experience gained during the verification.

CoCoME Modelling Contest
In order to leverage component-based system design to build correct and depend- able component-based systems, researchers have developed various formal and semi- formal component models which concentrate on different yet related aspects of com- ponent modelling [13,7,5,12,2,11]. The main goal of the CoCoME (Common Compo- nent Modelling Example) Modelling Contest [15] was to evaluate and compare the practical application of existing component modelling approaches and techniques on a common modelling example, which was designed to comprise a large number of various aspects and modelling issues that can be identified in different types of component-based systems.
The modelling example, called Trading System, serves to handle sales in a chain of supermarkets. Its functionality includes the interaction with the cashier at the cash desk, like product scanning, price lookup, cash/card payment, and bill printing, as well as accounting the sale at the inventory, or determining whether an express cash desk is needed in the store. Furthermore, the Trading System deals with order- ing goods from wholesalers, and generating various kinds of reports. The system is an open system, designed to interact with external components representing users of the system (cashiers and managers) and a bank application.
The Trading System was implemented as a Java application where components correspond to packages in the source code. The Java source code (125 Java classes in total) served as a detailed specification of the system for the modelling teams to prevent ambiguities in the interpretation of the corresponding high-level speci-
fication. The component structure of the application up to depth four is depicted in Figure 1. The figure includes an id number for each primitive component in the system. If a component is assigned more than one id, it consists of several sub-




Fig. 1. CoCoME Trading System overview
components with these id s. The id s are used as numerical names of the components in automata labels.

Foundations
Modelling language
To model behaviour of component-based systems we use the CI automata lan- guage [6,8]. The language models each component as a labelled transition system with structured labels and a hierarchy of component names. The transition label ar- ticulates which components communicate on an action, and the hierarchy of names represents the architectural structure of the component.
A CI automaton is a 5-tuple C = (Q, Act, δ, I, H) where Q is a finite set of states, Act is a finite set of actions, Σ = ((SH ∪{−})×Act×(SH ∪{−}))\({−}×Act×{−}) is a set of labels, δ ⊆ Q × Σ × Q is a finite set of labelled transitions, I ⊆ Q is a nonempty set of initial states, and H is a structured tuple representing a hierarchy
of component names where the set of component names is denoted SH .
The labels have semantics of input, output, or internal, based on their structure. In the triple, the middle item represents an action name, the first item represents a name of the component that outputs the action, and the third item represents a name of the component that inputs the action. Examples of three CI automata are in Figure 2. Each of them represents a model of behaviour of a basic component. For example, (−, sA, 1) in C1 signifies that the component with numerical name 1 inputs an action sA (a request for a service sA()), and (1, sA', −) in C1 signifies that the component 1 outputs an action sA' (a response for the service sA()).
To compose components into a higher-level component a composition operator is

Hierarchy: (1)	Hierarchy: (2)

J,¸’¸q z,,¸¸¸¸
 (1 ,sB, − )
... J,’¸q ¸z,

( − ,sA, 1) 
   
¸¸¸
(1 ,sC, − ) ¸¸
( −, sB, 2 ) .
....
( 2, int, 2) 

C :		 J,’¸p z, 
zJ,’¸s z,
C   :	 	J,’¸p  z,..	J,’¸r  Jz,   

1	,¸,
2	 ¸, '

,,,,
(1 ,sA', − ) ,,,
( − ,sC', 1.)....
.
. .s	 ( − ,sB', 1) 
( 2, sB , − )
 ( −, sC, 3 )  

r,~¸t~ ,¸c
C3 :		 J,’¸p z,¸,	J,’¸q z,
( 3, sC', − )
Hierarchy: (3)

Fig. 2. Three examples of CI automata
defined. Automata can be composed together using a parametrizable composition operator ⊗F , which composes a given finite set of automata with respect to the set of feasible labels F. Given a set of labels F, the operator composes the set of CI automata into a product automaton allowing only those transitions from the product that have labels from F. In the product, the components cooperate either by interleaving of their original transitions, or by simultaneous execution of two complementary transitions (with labels (n1, a, −), (−, a, n2)) which results into a new internal transition (with label (n1, a, n2)). An example of a composite automaton is in Figure 3. A wider range of composition operators is defined in [6,8].
J,’¸(q,p,p) z,	(1 ,sB, 2 )	J, ’¸(s ,q,p) z,
( − ,sA, 1 )ssss¸, ¸¸¸¸¸¸

ssss
¸¸¸¸¸

ss
C :	 (p,p,p)¸, , ¸
(1 ,sC, 3) 
¸¸z˛
,,J¸’(r,p,q) z,

t, 2) 

¸¸¸¸¸
(3 ,sC',,1,,) ,,,

'	¸¸¸
,,,

(1 ,sA , − )
¸	 ,,,
,¸(t,p,p) z,¸,

(2 ,sB', 1) 
J,’¸(s,r,p) z,



Hierarchy: ((1),(2),(3))

Fig. 3.   A composite CI automaton C = ⊗F {C1, C2, C3} where C1, C2, C3 are in Fig. 2, and
F = {(−, sA, 1), (1, sA', −), (1, sB, 2), (2, sB', 1), (2, int, 2), (1, sC, 3), (3, sC', 1)}


Temporal logic
For property specification, we use a slightly modified version of the linear temporal logic LTL [14] which we refer to as CI-LTL. CI-LTL is designed to express properties about occurring component interaction (i.e. labels in automata), but also about possible component interaction (i.e. label enabledness).
Syntax. For a given set of labels, formulas of CI-LTL are defined as
P(l) and E (l) are formulas, where l is a label.
If Φ and Ψ are formulas, then also Φ ∧ Ψ, ¬ Φ, X Φ and Φ U Ψ are formulas.
Every formula can be obtained by a finite number of applications of steps (1) and (2).

Other operators can be defined as shortcuts:	Φ ∨ Ψ ≡ ¬ (¬ Φ ∧¬ Ψ),	Φ ⇒ Ψ ≡
¬ (Φ ∧¬ Ψ),	F Φ ≡ true U Φ (Future),	G Φ ≡¬ F ¬ Φ (Globally).
Semantics. Let C = (Q, Act, δ, I, H) be a CI automaton. We define a run of C as an infinite sequence σ = q0, l0, q1, l1, q2,.. ., where qi ∈ Q, and ∀i. (qi, li, qi+1) ∈ δ. We further define:
σ(i) = qi (i-th state of σ)
σi = qi, li, qi+1, li+1, qi+2,... (i-th sub-run of σ)
L(σ, i) = li (i-th label of σ)
CI formulas are interpreted over runs and the satisfaction relation |= is defined as

σ |= E (l)	⇐⇒ ∃q. σ(0) −→l  q
σ |= P(l)	⇐⇒ L(σ, 0) = l
σ |= Φ ∧ Ψ	⇐⇒ σ |= Φ and σ |= Ψ 
σ |= ¬ Φ	⇐⇒ σ |= Φ 
σ |= X Φ	⇐⇒ σ1 |= Φ 
σ |= Φ U Ψ	⇐⇒ ∃j ∈ N0 . σj |= Ψ and ∀k ∈ N0,k < j . σk |= Φ 

Informally, formula E (l) is true in all states of the system where the interaction represented by the label l can possibly happen. Formula P(l) is true for a run whenever the interaction represented by the label l is actually happening as the very first transition of the run.


Model checking and veriﬁcation tool
For model checking CI-LTL properties, the automata-based algorithm [17] is slightly modified in the way a formula is translated into a Bu¨chi automaton. Automaton has a special alphabet formed by doubles (set of labels, label). The items correspond to the two operators E (l) and P(l). Apart from that, the model checking algorithm remains the same as in the case of standard LTL (accepting cycle detection) and therefore it has the same complexity.
The tool DiVinE, which we use for the verification, provides several LTL model checking algorithms. In our case study, the algorithm OWCTY is employed. This algorithm always generates the whole reachable state space of the model and its time complexity is higher than that of simple reachability if it is the case that an accepting cycle is found. However, it was chosen because of its efficiency in distributed setting [3].
The verifications presented in this paper have been performed on a cluster of ten
2.60 GHz Intel Pentium 4 Linux workstations with 3800 MB of RAM, interconnected with a 100Mbps Ethernet and using the Message Passing Interface (MPI) library. The chosen number of computers is explained and justified in Section 6.

Model of the Trading System
Within the CoCoME Modelling Contest [15], we have created a detailed model of the Trading System in terms of component interaction using CI automata [18]. The model in a textual notation is available at [16]. The model consists of 140 primitive automata (59 in the CashDeskLine part, and 81 in the Inventory part), composed hierarchically into 34 composite automata up to 6 levels of depth. The Trading System model is complemented by several models of cashiers and managers, who interact with the system, and specify various usage profiles under which properties of the system are checked. 3 Each usage profile/scenario (all provided within the contest) corresponds to a correct behaviour of a user operating the system.
We have experimented with all usage scenarios. However, for the clarity of the presentation, we employ only one usage profile underlying the properties studied in the paper. It is the scenario describing one sale assisted by a cashier. This scenario represents the most complex usage profile described in [15], and it is connected to a large number of component-specific properties that can be checked on the behaviour of the system that is implied by the scenario. In the scenario, the cashier first starts the sale, then scans items (in a loop), finishes the sale and receives the payment. It can select cash or card payment, where the cash payment is followed by entering the received amount and returning change, and the card payment with scanning the card and entering PIN.
Besides the users, the system interacts with a bank application to exchange in- formation during card payments. We suppose that the bank can perform any correct scenario, i.e. it is anytime able to receive requests and for each request it returns a response. We simulate this by leaving the communication with the bank open.
State space of the model. As mentioned above, the Trading System model is composed out of 140 primitive automata hierarchically assembled into 34 composite automata. Even if the size (number of states) of individual primitive automata is moderate, the size of the complete state space is immense due to the concurrency in component behaviour. An attempt to generate the complete state space on a cluster of twenty computers finished unsuccessfully with 322 millions of states demanding for 60 GB of memory in total. The computation took 13 400 seconds. Although this might seem slow, it is not surprising because the state space generation in- volves computation of the successor states. Such computation is a complex task, which needs to take into account the hierarchical composition of components and the feasible labels that can be propagated up in the hierarchy and are part of the composite automata.
Even if the complete model is unfeasibly large, for the verification of the model under the given usage scenario, the model is composed with an automaton repre- senting the user. This restricts possible behaviours and decreases the state space. The size of the model with the cashier mentioned earlier is 749 340 reachable states and 3 181 473 reachable transitions.

3 Only if we know, for instance, that a sale proceeds correctly including the payment, it is meaningful to check that all purchased goods were correctly taken off in the inventory.

Verification of the model
In this section, we discuss some of the properties that were checked on the model, and present verification results. We concentrate on the properties that are specific to component-based systems and emerged from the requirements on the Trading System and discussions with other teams. A part of the contribution of this paper is the identification of such a set of properties defining correctness issues in component- based systems, their formalization in terms of temporal logics, and demonstration of the feasibility and efficiency of their automatic verification in parallel settings.
Moreover, in the CoCoME Modelling Contest, a number of requirements were specified in terms of use-case scenarios. Use-case scenarios define a behaviour of the system in response to a given usage profile. Verification of use-case scenarios is studied after the other properties in this section, and is followed by discussion on the importance of formal verification, to check the validity of the model during the modelling process. The section concludes with experimental results studying the effect of parallelization on the verification.

Basic properties
As the basic properties, we present two properties demonstrating the capability of the CashDeskChannel component in the Trading System to broadcast events to the components that subscribed for them.

Property 1 (Unwanted duplicity). When the CashDeskChannel (200) re- ceives a request to broadcast the SaleSuccessEvent via (100, publishSaleSuccess- Event, 200), the event is going to be delivered to all subscribers (200, onEventSale- Success, X) at most once. In the property, as well as in the following properties, action names are shortened to the sequence of first letters of their sub-words, e.g. publishSaleSuccessEvent becomes pSSE.

G  P(100, pSSE, 200) ⇒¬ [¬ P(100, pSSE, 200) U (P(200, oESS, 142)∧
X [¬ P(100, pSSE, 200) U P(200, oESS, 142)])] 

G  P(100, pSSE, 200) ⇒¬ [¬ P(100, pSSE, 200) U (P(200, oESS, 162)∧
X [¬ P(100, pSSE, 200) U P(200, oESS, 162)])] 


The data in the table refer to the model composed with the appropriate prop- erty automaton. The column memory represents the total memory needed by all workstations in verification of the property. Note that the number of states of the

model composed with the property is, in this case, equal to the number of states of the original model. This interesting fact is explained in Section 6.

Property 2 (Guaranteed delivery). Whenever the CashDeskChannel (200) receives a request to broadcast the SaleSuccessEvent, the event is going to be deliv- ered to all subscribers (200, onEventSaleSuccess, X) at least once, or an exception occurs (200, exceptionPublishSaleSuccessEvent, 100).

G [P(100, pSSE, 200) ⇒ ([BOTH ∧¬ EXC ] ∨ [NONE ∧ EXC ])]
where
BOTH = [¬ P(100, pSSE, 200) U P(200, oESS, 142)] ∧ [¬ P(100, pSSE, 200) U P(200, oESS, 162)]
NONE = (¬ [¬ P(100, pSSE, 200) U P(200, oESS, 142)]) ∧ (¬ [¬ P(100, pSSE, 200) U P(200, oESS, 162)])
EXC = ¬ P(100, pSSE, 200) U (200, ePSSE, 100)


Local deadlocks of components
In component-based systems, many components coexist in parallel. Hence deadlock of some of them cannot be detected as halting of the whole system. We understand a local deadlock of a component as a state from which the component cannot move further. This situation requires the enabledness E operator, otherwise we could only express that it does not move further. The following two properties describe a local deadlock of a component on a particular service call, and the third property specifies a local deadlock with respect to any action.

Property 3 (Local deadlock on one action). It cannot happen that the Store- Application (610) is ready to call getTransactionContext() but never can do so because its counterpart Persistence (511) is never ready to accept the call.

[F P(610, gTC, −)] ∨ G [E (610, gTC, −) ⇒F E (610, gTC, 511)]


This property helped us to evaluate one of our modelling decisions. As the ser- vice getTransactionContext() activates a new instance of the component Trans- actionContextImpl, where only a limited number of instances can be active at any time, this property allows us to check that the bound on the number of instances that are ready to be activated is sufficient.

Note that this property requires the presence of the (610, getTransaction- Context, −) label, which symbolizes an attempt of the component 610 to ask for a new transaction context, in the model. However, this is an output label that, according to the specification, must synchronize with a complementary input la- bel before the model is complete, and be restricted from the model. Therefore, for the purpose of verification of this property, we modify the model in a way that this label is not restricted by the composition. However, to keep the ver- ification faithful, the property is defined in a way that the runs with the label (610, getTransactionContext, −) on them are not traversed during verification (as they have only informative character). Hence the increase in the size of the model (via not omitting the label) influences neither the state-space traversed during ver- ification, nor the fidelity of the model.

Property 4 (Local deadlock on one action).	It cannot happen that the
CashDeskApplication (100) is ready to send a notification to the CashDeskChannel
(200) saying that it received the SaleStartedEvent, but the CashDeskChannel is never ready to accept the notification.


[F P(100, oESS'', −)] ∨ G [E (100, oESS'', −) ⇒F E (100, oESS'', 200)]


The CashDeskChannel (200) in the system is not allowed to accept notifications before it delivers events to all subscribers. If some of the subscribers would be constantly refusing to accept the event, it could block other components that already accepted the event and want to notify the channel. As the property is valid, this cannot happen in the system (on the SaleStartedEvent ).

Property 5 (Local deadlock on any action). It cannot happen that the Per- sistence (511) for StoreApplication becomes deadlocked (cannot make any action).

GF (ENABLED 511)

where ENABLED 511 = E (610, gPC, 511) ∨E (620, gPC, 511) ∨... ∨E (511, eIA, 620),
that is a disjunction of formulas of type E (label) for all labels the Persistence (511)
participates in.


The violation of the property means that the system gets into a state from which the component is no more able to perform any computation. This can happen for three reasons: (1) it gets stuck in its internal computation, (2) the environment refuses to accept its calls, or (3) the environment does not wish the component to compute anything for it any more. After a further analysis of the model we learned that the last case is true because in the usage profile, we suppose that only one sale is accomplished. Hence the system is not supposed to execute forever. This property demonstrates that one needs to be careful when interpreting the result from the local deadlock verification. More, it allows the reader to see the memory and time needed to verify a property that does not hold.

Blocking of components
A stricter version of local deadlocks, which is very interesting in component-based settings, is temporary blocking of a component because of the non-readiness of its counterpart to accept its calls. This property is considered the core issue of correct- ness of component-based systems in several component-based models (SOFA [1], Interface automata [9]).

Property 6. It cannot happen that the StoreApplication (610) wants to begin a transaction (610, beginTransaction, −) calling the TransactionContextImpl (511), which is not right in the current state ready to accept it.

[F P(610, bT, −)] ∨ G ¬ [E (610, bT, −) ∧¬ E (610, bT, 511)]


Note that we require the existence of the (610, beginTransaction, −) label in the model. For the purpose of this verification, we modify the model in a way similar to the case with property 3. Even here, the resulting state space does not change, due to the nature of the property.

Property 7. It cannot happen that the CashDeskApplication (100) is ready to send a notification to the CashDeskChannel (200) saying that it received the SaleStart- edEvent, but the CashDeskChannel is not right in the current state ready to accept the notification.

[F P(100, oESS'', −)] ∨ G ¬ [E (100, oESS'', −) ∧¬ E (100, oESS'', 200)]


The property is a more strict version of the property 4. While the property 4 shows that the CashDeskChannel (200) always sends all copies of the SaleStartedE- vent and gets into the state where it is ready to start accepting notifications, this property shows that it may take a while before the channel gets ready. However, this is not an error in the system. It correctly reflects the nature of the channel.

Loop issues
In our model, many cycles/loops can be found. Each loop can complete a run that enters it but never exits. In software systems, however, most of the loops in models result from for or while cycles that are traversed only finitely many times. The problem is that the number of traversals of the for/while cycles in the system is usually not known in advance—it is computed at run-time. Hence the cycles need to be modelled as loops, which by nature have no bound on the number of traversals. This can cause non-realistic results of properties verification. The properties should be verified only on the runs that follow selected loops only finitely many times.

Property 8. Whenever the ProductDispatcher (630) call queryStoreById() on the Store for ProductDispatcher (523) via (630, queryStoreById, 523), it gets a response (523, queryStoreById', 630) at some point in the future.

G [P(630, qSBI, 523) ⇒F P(523, qSBI', 630)]

In the counterexample, one of the components gets into a loop (representing a for cycle with a finite but unknown number of iterations possible) that it never exits. Hence the counterexample represents a run that is not real in the system. However, as there is no natural way to remove the run from the model for the reasons above, we modify the property in a way that it misses this run, thus forcing verification of the original property only on fair runs.

Property 9. Whenever the ProductDispatcher (630) calls queryStoreById() on the Store (523) for ProductDispatcher, it gets a response at some point in the future, if the progress of the system is forced by transitions of the Store (523), which cannot get into invalid infinite loop.

G [(P(630, qSBI, 523) ∧G F  MOVE 523) ⇒F P(523, qSBI', 630)]
where MOVE 523 = P(610, qLSI, 523) ∨ P(620, qASI, 523) ∨ ... ∨ P(630, qSI, 523),
that is a disjunction of formulas of type P(label) for all labels the Store (523)
participates in.


Note that although the state-space size of the model composed with property 8 is the same as that of property 9, the verification time is larger in the first case. This is due to the nature of the verification algorithm, as mentioned in Section 3.3.


Use-case scenarios
In the verification of use-case scenarios, we are given an assumption on the usage profile of the system, and we want to guarantee that a particular behaviour is present in the response of the system. A use-case scenario is defined as a sequence of interactions (labels). It can be either complete (all labels are listed) or partial (given labels can be interleaved with other labels). In component-based systems, where the searched behaviour can be interleaved by behaviour of independent components in the system, the partial scenarios are of higher interest. This section presents results of verification of the three most complex (partial) scenarios defined in [15]. In contrast to the other verified properties, the use-case scenarios do not state that for all paths, some property holds (as is usual in the LTL model checking), but they state that there is a path, along which some property holds (namely the property representing the sequence of labels). This can be verified with the same methods, just by negating the property. Note that the properties representing the use-case scenarios are so large (their descriptions were over 100 lines long) that we do not give their formal representation here. However, they are a part of the model,
which is available at [16].

UC scenario 1. CashPayment The scenario reflects cooperation of system com- ponents to successfully accomplish purchase of goods finished with cash payment.

UC scenario 2. Unsuccessful CardPayment The scenario describes system reactions to a sale finished with card payment that is refused by the bank.

UC scenario 3. Successful CardPayment The scenario describes component interaction following a successful sale finished with card payment.


Validity of the model
During modelling, we needed to abstract from aspects of the system that could make the size of the model unmanageable, while staying confident about the safety of the abstractions. Two types of abstractions were considered: simplification of the inter- nal behaviour of primitive components, and simplification of the communicational scheme. Regarding the communication among components, we evaluated serializa- tion of selected parallel service calls and changing of some asynchronous calls to synchronous. The serialization was considered both on required (calling services) and provided (serving calls) side. This significantly reduced the state space, while causing no harm when the service calls were independent and their ordering had no effect on further behaviour of the system. Verification helped us to evaluate a number of serialization and synchronisation decisions via checking the validity of the model after the modification.
When checking the validity of the model, we worked with a set of properties based mainly on the use-case scenarios and test cases defined in the CoCoME Mod- elling Contest. We also tested the model for deadlocks, because we experienced that violation of the model validity often results in deadlock situations, either global or local.

Effect of parallelization
This section presents two tables summarizing the time and space consumption of the verification of presented properties, depending on the number of computers used in the computation. This was done in order to analyse the effect of the parallelization of the model checking algorithm and to choose the best number of workstations for detailed experiments. Table 1 shows the total memory used by all workstations, while Table 2 presents the time needed for the verification. A dash “—” indicates that the computation did not finish successfully (ran out of available memory).

Experience and discussion
In this section, we share our modelling and verification experience, discussing some of the results and observations we have achieved.
Characteristics of the model. As the number of components in the Trading Sys- tem is quite large, and our modelling language expresses component concurrency through interleaving, the model suffers from state space explosion. More, the size of the reachable state space does not grow evenly during the hierarchical composition of components, but it changes dramatically. The reason for the irregular changes of the state space is that a composite automaton does not need to be larger than the automata it is composed of. We have observed cases, where the number of reachable states has been dramatically reduced by the composition. This is due to the parametrized operator that can delimit possible behaviour in the composition. This fact can complicate the estimation of the number of states for a given model.


Table 1
Memory consumption depending on number of computers.

But on the other hand, it can be exploited to produce a smaller model out of a large one, as was demonstrated in this case study, where the large Trading System model has been restricted by the usage profile of the cashier.
Deadlocks in the model. After deciding on the model for verification, in the validation phase, we have checked the model for global and local deadlocks. We have learned that the existence of deadlock states often signals a modelling error. A few global deadlocks were found. By careful investigation, we found that these deadlocks correspond to a behaviour reflecting that two components decide to re- ceive messages from one of the event channels in an incorrect order, thus blocking each other. As we were not provided with the specification of the event channels, we can treat this finding in two ways. Either the deadlock reveals an error in the system, or it reflects an unrealistic behaviour, i.e. the system guards that the com- ponents receive messages in the right order. We decided to treat the runs leading to the deadlock states as unrealistic, and ignore them during verification. This is done implicitly in our verification method, because it verifies inﬁnite runs only.
Local deadlocks and component-blocking properties. Interesting observa- tions were made in verifying the local deadlocks and their more strict form, the component-blocking properties. We have verified many pairs of such properties and have found a strong relation between the two kinds. Mostly, it was either the case


Table 2
Time consumption depending on number of computers.

that both properties were satisfied, or none of them was. The reasons are similar to those explained after property 5, that is, the environment does not wish the components to compute anything any more. We have, though, found a few cases, when the local deadlock property holds, but the blocking property does not, and we have presented one of them. Note that both kinds of properties take advantage of the enabledness E operator without which they could not have been formulated.
Size of the model/property composition. As may be noticed in Section 5, in some of the presented cases the state-space size remains (nearly) the same when the model is composed with the property automaton. This interesting fact deserves an explanation. The property automata are generated with the effort to make the resulting composition as small as possible. Then in case of some properties (such as safety and request/response properties), for every state of the model in the com- position, there is a unique state in the property automaton. Hence the composition with the property does not influence the size of the model.
Parallelization. We ran experiments to evaluate the effect of parallelization on the verification of our model, the results of which are shown in Section 5.7. The experiments’ result can serve as a justification for the number of computers used in the main presentation of the verification results, which is ten. It can be seen that although smaller number of workstations would suffice, the verification would

get substantially slower in the case of larger property automata (e.g. the use-case scenarios). One of the use cases could not even be handled with only one worksta- tion. On the other hand, larger number of workstations causes inadequate memory overhead in the case of small property automata, and the time decrease is not as substantial with more than ten workstations. The choice of ten computers seems a reasonable compromise then.


Conclusion and future work
In this paper, we give a practical application of the presented CI-LTL verifica- tion technique to a large component-based system using a parallel model checking tool DiVinE. We briefly introduce our modelling language as well as the temporal logic CI-LTL, a modification of the action based LTL. We have verified a multi- tude of properties of the Trading System. Twelve of them that are of particular interest within the component-oriented software engineering society, are presented here together with the results of the verification and their discussion. The pre- sented properties include two basic properties describing the broadcasting ability of the event-channel components, three properties concerning the possibility of a lo- cal deadlock, two properties addressing the component blocking problem, and two properties dealing with the problems caused by cycles in the model. The last three properties are different from the previous. They are used for checking the correct- ness of the use-case scenarios. Finally, we discuss how the model checking helped us in creation of the model, and we summarize the experience obtained during verifica- tion, including discussion of some of the results, and the effect of the parallelization. The study confirms that the CI automata modelling language suits well both to capture various types of interactions among individual components in component- based systems, and to formally verify interaction properties. This distinguishes our
modelling approach from others presented in the CoCoME Modelling Contest [15]
and brings a new value to the area of component-based software engineering. As the very significant feature of component-based systems is the concurrent behaviour of individual components and consequently the enormous size of the state space, distributed and parallel verification techniques are a need for handling these type of systems in reasonable time. They allowed us to verify very complex properties of the Trading System when restricted to a usage profile. But still, we were not able to verify the Trading System with no usage profile added—this means any usage possible with any number of users—as our hardware capacity did not suffice.
In future, we aim at extending our verification techniques with various reduction methods to allow us to verify even larger systems. Currently, we explore the pos- sibilities of two existing reduction techniques, the partial-order reduction and the symmetry reduction. However, their application in our framework is not straight- forward, due to the nature of the temporal logic we use. We also try to find new reduction methods taking advantage of component-specific characteristics of verified systems.

References
Adamek, J. and F. Plasil, Behavior protocols capturing errors and updates, in: Proceedings of the ETAPS Workshop on Unanticipated Software Evolution (USE’03) (2003), pp. 17–25.
Allen, R. J., “A Formal Approach to Software Architecture,” Ph.D. thesis, Carnegie Mellon University, School of Computer Science, USA (1997).
Barnat, J., L. Brim and I. Cˇern´a, Distributed Analysis of Large Systems, in: Proc. of the 4th International Symposium on Formal Methods for Components and Objects (FMCO’05), LNCS 2006 (2006), pp. 259–279.
Barnat, J., L. Brim, I. Cˇern´a, P. Moravec, P. Roˇckai and P. Sˇimecek, Divine – a tool for distributed verification, in: Proceedings of the Computer Aided Verification conference (CAV’06) (2006), pp. 278– 281.
Becker, S., H. Koziolek and R. Reussner, Modelbased performance prediction with the palladio component model, in: Proceedings of the International Workshop on Software and Performance (WOSP’07) (2007), pp. 54–65.
Brim, L., I. Cˇern´a, P. Vaˇrekova´ and B. Zimmerova, Component-Interaction automata as a verification- oriented component-based system specification, in: Proceedings of the ESEC/FSE Workshop on Specification and Verification of Component-Based Systems (SAVCBS’05) (2005), pp. 31–38, published also in ACM SIGSOFT Software Engineering Notes, Volume 31, Issue 2 (March 2006).
Bruneton, E., T. Coupaye, M. Leclercq, V. Qu´ema and J.-B. Stefani, The fractal component model and its support in java, Software: Practice and Experience 36 (2006), pp. 1257–1284.
Cˇern´a, I., P. Vaˇrekov´a and B. Zimmerova, Component-interaction automata modelling language, Technical Report FIMU-RS-2006-08, Masaryk University, Faculty of Informatics, Brno, Czech Republic (2006).
de Alfaro, L. and T. A. Henzinger, Interface-based design, in: Proceedings of the 2004 Marktoberdorf Summer School (2005), pp. 1 – 25.
DiVinE project web page. URL http://anna.fi.muni.cz/divine/

Garlan, D., R. T. Monroe and D. Wile, “Foundations of Component-Based Systems,” Cambridge University Press, USA, 2000 ISBN 0-521-77164-1.
Magee, J., J. Kramer and D. Giannakopoulou, Behaviour analysis of software architectures, in: Proceedings of the 1st Working IFIP Conference on Software Architecture (WICSA’99) (1999), pp. 35–50.
Plasil, F. and S. Visnovsky, Behavior protocols for software components, IEEE Transactions on Software Engineering 28 (2002), pp. 1056–1076.
Pnueli, A., The temporal logic of programs, in: Proceedings of the 18th IEEE Symposium on the Foundations of Computer Science (1977), pp. 46–57.
Rausch, A., R. Reussner, R. Mirandola and F. Plasil, editors, “The Common Component Modeling Example: Comparing Software Component Models,” To appear in LNCS, 2007.
URL http://www.cocome.org
The CoIn Team, The complete CoIn model of the Trading System (2007).
URL http://anna.fi.muni.cz/coin/cocome/

Vardi, M. Y., An automata-theoretic approach to linear temporal logic, in: Logics for Concurrency: Structure versus Automata, LNCS 1043 (1996), pp. 238 – 266.

Zimmerova, B., P. Vaˇrekov´a, N. Beneˇs, I.
Cˇern´a, L. Brim and J. Sochor, “The Common

Component Modeling Example: Comparing Software Component Models, chapter Component- Interaction Automata Approach (CoIn),” To appear in LNCS, 2007 .
