Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 344 (2019) 3–23
www.elsevier.com/locate/entcs

On Three-Valued Acceptance Conditions of Abstract Dialectical Frameworks
Joao Alcˆantara1
Computer Science Department Universidade Federal do Cear´a Fortaleza, Brazil
Samy S´a2
Computer Science Department Universidade Federal do Cear´a Quixad´a, Brazil

Abstract
Abstract Dialectical Frameworks (adfs) are generalizations of Dung’s abstract argumentation frameworks (afs) where each argument has an associated acceptance condition expressed by a boolean formula. The resulting extension is robust enough not only to model the attack relation original to afs, but also others types of dependencies and interactions between arguments. A recent development in adfs proposed an
alternative formalization involving three-valued acceptance conditions, connecting the original definitions of adfs to the concept of three-valued argument labellings, a core concept in computational argumentation literature. In this paper, we revise some of the main semantics defined under this three-valued approach and prove our definitions hold equivalence to well-known semantics of afs.
Keywords: Abstract Dialectical Frameworks, Argument Labellings, Argumentation, Knowledge Representation, Uncertainty.

Introduction
One of the main concerns in the field of Knowledge Representation and Reasoning is to answer how conclusions can be reached through reasoning. A possible path is to resort to Formal Logic to symbolically represent the knowledge required to solve a problem and ensure that the performed reasoning is sound and complete. An ongoing trend resides in the subfield of Computational Argumentation, where the connections between argumentation and Computer Science are exploited to per- formed both deductive and nonmonotonic or defeasible reasoning [22,23,30,31,25].

1 Email: jnando@lia.ufc.br
2 Email: samy@ufc.br

https://doi.org/10.1016/j.entcs.2019.07.002
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

In this trend, the reasoning process is characterized by constructing and evaluating arguments, which (roughly speaking) can be understood as a sets of reasons for the validity of particular claims.
A core reference in this area, Dung’s Abstract Argumentation frameworks (afs)
[15] models arguments as abstract entities among which an attack relation is de- fined. Dung proposed important concepts widely adopted by the computational argumentation community, such as the concept of argument admissibility. This concept builds on the intuition that to accept a claim c, one needs both to have an argument A supporting c and to justify the rejection of all other arguments that conflict with A. In short, while in Logic the reasoning process is focused on the inference within an argument, in argumentation the reasoning process also involves the interactions between arguments.
A crucial innovation of Dung’s approach is to separate the properties depending exclusively on argument attack from those related to the structure of the argu- ments [28]. Under a mathematical point of view, the thus resulting argumentation framework is a directed graph, the nodes of which are the arguments, and the edges represent the conflicts between the arguments. A semantics for an argumentation framework returns acceptable sets of arguments, the extensions of the framework. It should be clear that different criteria of acceptability will specify different seman- tics, including Dung’s original concepts of complete, stable, preferred and grounded extension-based semantics [15] and semi-stable semantics [29,8].
Dung’s argumentation frameworks achieved remarkable popularity, but they have also been subject to criticism. A contentious issue refers to their alleged limited expressive capabilities of afs, as they lack certain features which are com- mon in almost every form of argumentation to be found in practice [6]. Indeed, in Dung’s argumentation frameworks the only interaction between atomic arguments is given by the attack relation. As overviewed in [5], many proposals extending afs can be found in the literature; it includes among others afs with support relations [12,13,20,21], attacks on attacks [19] and afs with weights [18,16,14].
With such motivation, Brewka and Woltran introduced Abstract Dialectical Frameworks (adfs) in [6,4], a generalization of Dung’s argumentation frameworks that allows arbitrary relationships among arguments to be expressed. Their ap- proach attempts to unify several of those different extensions of afs and to gen- eralize Dung’s afs in a principled, systematic way. In an adf, besides the attack relation, arguments may support each other, or a group of arguments may jointly attack another while each single member of the group is not strong enough to do so [3]. This additional expressiveness is obtained by associating to each node (ar- gument) its two-valued acceptance conditions which can be expressed as arbitrary propositional formulas. The intuition is that an argument is accepted if its as- sociated acceptance condition is accepted. In short, we can characterize adfs as dependency graphs + acceptance conditions.
An alternative formalization for adfs was proposed in [1], where the authors introduced three-valued acceptance conditions for arguments. This move was mo- tivated by the understanding that in an af semantics, a given argument can be

either accepted, rejected or undecided, but the two-valued acceptance conditions of [6,4] do not explicitly evaluate arguments as undecided. Due to this difference, the resulting adfs of [1] yield a relatively simpler formalization which holds the same results of [6], while also capturing the semi-stable semantics of afs [29,8], which was not contemplated in [6]. To illustrate the difference, we provide an example.


Example 1.1 Let A = {a, b, c} be a set of arguments. To depict an adf, we need to specify their acceptance conditions. Consider the two scenarios below where for each argument s ∈ A, its associated acceptance condition is represented as a propositional formula written within square brackets on the right of s:
I:  a  [b V c];  b  [чb];  c[T]
II: a  [(b л чc) V (чb л c) V (b л c)];  b  [чb];  c[T]


From scenario I we can observe a is accepted if b or c is accepted; b is accepted if b is not accepted, and c is always accepted. Assuming a two-valued approach for these acceptance conditions, we conclude scenario II is obviously equivalent to scenario
I. However, as the arguments themselves are evaluated according to three-valued labellings, it is arguable that the acceptance conditions are evaluated according to only two truth values. By posing a three-valued approach, we are basically making a distinction between non acceptance and rejection. In that case, the two scenarios above will not be equivalent: suppose we have c is accepted and b is undefined. In scenario I, we have a will also be accepted; in scenario II only c will be accepted, for a can only be accepted if we accept or explicitly reject b.
In this paper, we take advantage of the formalization of [1] and revise their definition of complete labellings to seek fixpoints of an immediate consequences operator that are minimal concerning a truth ordering that is commonly employed in logic programming theory. As we will show, this difference will guarantee an equivalence result between adf semantics and Dung’s af semantics for every adf whose acceptance conditions model the attack relation of some af. As a consequence of that result, adf semantics will be proven to extend well-known semantics for afs such as complete, stable, preferred and grounded semantics [15] as well as the semi- stable semantics [29,8].
The paper proceeds as follows. Firstly we recall the necessary background on Dung’s abstract argumentation frameworks and present some of the well-known and well-established argumentation semantics in terms of argument labellings. Next we present adfs with three-valued acceptance conditions, accommodating important notions such as that of complete labellings and of an immediate consequences op- erator ΓD. In the subsequent section, we examine the relation between adfs and afs by presenting a subclass of adfs which corresponds to afs. Some of our main results will be introduced at this point. Finally, we round off with a discussion of the obtained results and pointers for future works.

Preliminaries
In this section we overview the main definitions connected with (Abstract) Argu- mentation Frameworks [15]. We are particularly interested in how abstract argu- mentation semantics can be formulated in terms of labellings. In this piece of work, we will restrict ourselves to finite argumentation frameworks.
Definition 2.1 [Argumentation Frameworks][15] An argumentation framework af
is a pair (Ar , att ) where Ar is a ﬁnite set of arguments and att ⊆ Ar × Ar .
Arguments are related to others by the attack relation att : an argument A attacks B iff (A, B) ∈ att . An argumentation framework can be seen as a directed graph where the arguments are nodes and each attack is an arrow.
Given an argumentation framework, we are mainly interested in computing its semantics. The traditional approach of [15] does so by identifying sets of arguments (called extensions) based on the concept of admissibility (see [15]). The approach we will consider in this work is an alternative formalization of abstract argumentation semantics originally introduced in [7] using argument labellings instead of argument extensions:
Definition 2.2 [Argument Labellings][7] Let (Ar , att ) be an af. A labelling is a total function L : Ar : {in, out, undec}.
We write in(L) for {A | L(A)= in}, out(L) for {A | L(A)= out} and undec(L) for {A | L(A)= undec}. Sometimes, we write a labelling L as a triple (Ar 1, Ar 2, Ar 3) where Ar 1 = in(L), Ar 2 = out(L) and Ar 3 = undec(L). The label in is intended to express the argument is explicitly accepted; the label out is intended to express the argument is rejected, and the label undec is intended to express the status of the argument is undecided, i.e., no verdict is achieved about whether the argument should be in or out. We proceed by recalling the definition of admissible labelling:
Definition 2.3 [Admissible Labellings] [2] Let (Ar , att ) be an af.
An in-labelled argument is said to be legally in iff all of its attackers are labelled
out.
An out-labelled argument is said to be legally out iff it has at least one attacker that is labelled in.
A labelling L is admissible if each in-labelled argument is legally in and each
out-labelled argument is legally out.
According to this definition, for any argumentation framework, a labelling where all arguments are undec is admissible. By strengthening the basic requirements employed in the characterization of admissibility, we obtain the concept of complete labelling:
Definition 2.4 [Complete Labellings] [9] Let (Ar , att ) be an af. A labelling L is complete iff for each argument A ∈ Ar it holds that

L(A)= in iff every B ∈ Ar attacking A has L(B)= out.
L(A)= out iff there exists B ∈ Ar attacking A such that L(B)= in.
L(A) = undec iff not every B ∈ Ar attacking A has L(B) = out and no
B ∈ Ar attacking A has L(B)= in.
It is worthwhile noticing that every complete labelling is admissible. The fol- lowing example illustrates both types of argument labellings:
Example 2.5 Consider af = (Ar , att ) depicted below, where Ar = {A1, A2, A3}
and att = {(A1, A2), (A2, A1), (A2, A3)}.

We have
Admissible labellings: ({} , {} , {A, B, C}), ({A} , {B} , {C}), ({A, C} , {B} , {}), ({B} , {A} , {C}), ({B} , {A, C} , {}).
Complete labellings: ({} , {} , {A, B, C}), ({A, C} , {B} , {}), ({B} , {A, C} , {}).
Now we can define the main semantics for afs in terms of labellings:
Definition 2.6 [7,10] Let L be the set of all complete argument labelling of af. Then
L is the grounded argument labelling of af if L ∈ L and ∄Lj ∈ L such that
in(Lj) ⊆ in(L).
L is a preferred argument labelling of af if L∈ L and ∄Lj ∈ L such that in(Lj) ⊇
in(L).
L is a stable argument labelling of af if L∈ L and undec(L)= ∅.
L is a semi-stable argument labelling of af if L ∈ L and ∄Lj ∈ L such that
undec(Lj) ⊆ undec(L).
Note how complete argument labellings constitute the fundamental notion to characterize these semantics:
Example 2.7 Let af = (Ar , att ) be an abstract argumentation framework such that Ar = {A, B, C, D} and att = {(A, A), (B, A), (C, B), (C, D), (D, C)}. We de-
pict af as
Concerning semantics, AF has:
Complete	labellings:	({} , {} , {A, B, C, D}),	({B, D} {A, C} , {})	and ({C}, {B, D} , {A}).
Grounded labelling: ({} , {} , {A, B, C, D}).
Preferred labellings: ({B, D} {A, C} , {}) and ({C}, {B, D} , {A}).
Stable labellings: ({B, D} {A, C} , {}).
Semi-stable labellings: ({B, D} {A, C} , {}).



Fig. 1. An abstract argumentation framework with 6 arguments.
It is clear semi-stable labellings coincide with stable labellings whenever the framework has at least one stable labelling. Another important result showing how argument labellings relate to each other was proved in [7,11]:
Theorem 2.8 [7,11] Let L be a complete argument labelling of an argumentation framework F = (Ar , att ). It holds
in(L) is maximal (w.r.t. set-inclusion) among all complete argument labellings of F iff out(L) is maximal (w.r.t. set-inclusion) among all complete argument labellings of F.
in(L) is minimal (w.r.t. set-inclusion) among all complete argument labellings of af iff out(L) is minimal (w.r.t. set-inclusion) among all complete argument labellings of af.
Hence, concerning complete labellings, we can say that maximizing (resp. min- imizing) the label in is equivalent to maximizing (resp. minimizing) the label out. This result will be employed in Section 4 (Theorem 4.4) to guarantee the semantics we will define for Abstract Dialectical Frameworks (Definition 3.9) are extensions of those in Definition 2.6.
Abstract Dialectical Frameworks
Abstract Dialectical Frameworks were introduced in [6] to treat arguments (called statements there) as abstract and atomic entities. It can be seen as a directed graph whose nodes represent statements which can be accepted or not. In addition, the links between nodes represent dependencies: the status of a node s only depends on the status of its parents (denoted par (s)), that is, the nodes with a direct link to s. In this paper, we will propose a slight change to that approach: instead of resorting to subsets of par (s) to assess the status of s, we will make this dependency
between statements more explicit by resorting to subsets of Lit (s):
Lit (s)= par (s) ∪ чsj | sj ∈ par (s)}
A set M ⊆ Lit (s) is consistent iff there is no statement s ∈ par (s) such that
{s, чs} ⊆ M . We denote by Cs = {M ⊆ Lit (s) | M is consistent} the set of all

consistent subsets of Lit (s). We will refer to a ∈ S as a positive (resp. negative) statement in M if a ∈ M (resp. чa ∈ M ). Now we can accordingly alter the original definition of Abstract Dialectical Frameworks [6] as to obtain the following:
Definition 3.1 [Abstract Dialectical Frameworks] An abstract dialectical frame- work is a tuple D = (S, L, C) where
S is a set of statements (positions, nodes),
L ⊆ S × S is a set of links,
C = {Cs | s ∈ S} is a set of total functions Cs : Cs → {in, out}, one for each statement s, such that for any M ∈ Cs, if Cs(M ) = in, then Cs(Mj) = in for any Mj ⊇ M . Cs is called the acceptance condition of s.
The function Cs for a statement s is intended to determine the acceptance status of s, which as before only depends on the status of its parent nodes par (s). The novelty is that now for each node s ∈ S, its acceptance condition Cs specifies explicitly the exact conditions under which s is accepted, giving room to a (partial) three-valued setting. Intuitively,
s will be accepted if there exists M ⊆ Cs such that Cs(M )= in and every positive statement in M is accepted and every negative statement in M is rejected.
s will be rejected if for every M ⊆ Cs such that Cs(M )= in, there exists either a rejected positive statement in M or an accepted negative statement in M .
s will be undefined otherwise.

Representing Acceptance Conditions
The acceptance conditions in C of an adf(S, L, C) can also be represented in two alternative ways:
Any function Cs ∈ C can be represented by the set of subsets of Cs leading to the acceptance of s, i.e., Cin = {M ∈ Cs | Cs(M ) = in}. We will indicate this
s
in	in	in
Any function Cs ∈ C can also be represented as a propositional formula ϕs over the vocabulary Cs as follows:

ϕs ≡	 
{a1,...,am,чb1,...,чbn}∈Cin

a1 л· · · л am л чb1 л· · · л чbn

If m = n = 0, the corresponding a1 л· · · л am л чb1 л· · · л чbn ≡ T, where T is a constant always evaluated as in. If there is no M ∈ Cs such that Cs(M )= in, then φs ≡ ⊥, where ⊥ is a constant always evaluated as out. We will indicate this alternative by denoting an adf as (S, L, Cϕ), where Cϕ refers to the set
{ϕs | s ∈ S}.
When referring to an adf as (S, L, Cϕ), we will assume the acceptance formulas specify implicitly the parents a node depends on. Then the set L of links between

statements can be ignored, and the adf can be represented as (S, Cϕ), where L is recovered by (a, b) ∈ L iff a appears in φb.
3-Valued Labellings for ADF’s
In order to define different semantics for adfs over statements s, we will resort to the notion of admissible labellings:
Definition 3.2 [Admissible Labellings] Let D = (S, Cϕ) be an adf. A three- valued labelling is a mapping v : S → {in, out, undec} that assigns the values (in), (out), or (undec) to each statement s. Labellings will be extended to assign values to formulas over statements according to Kleene’s strong three-valued logic [17]: negation switches in and out, and leaves undec unchanged; a conjunction is in if both conjuncts are in, it is out if some conjunct is out and it is undec otherwise; disjunction is dual. Sometimes, when convenient, we will refer to a labelling v over S as a set V = {s | s ∈ S and v(s)= in}∪ {чs | s ∈ S and v(s)= out}. Obviously, if neither s ∈ S nor чs ∈ S, then v(s)= undec.
A three-valued labelling v is an admissible labelling of D iff for all s ∈ S, if
v(s) /= undec, then v(s)= v(ϕs).
Admissible labellings can also be characterized as follows:
Proposition 3.3 Let D = (S, L, Cin) be an adf. Given a three-valued labelling v : S → {in, out, undec}, let Mv = {s | v(s)= in}∪ {чs | v(s)= out}. Then v is an admissible labelling of D iff for any s ∈ S
s ∈ Mv iff Mv ∩ Lit (s) ∈ Cin;
чs ∈ Mv iff for all Mj ∈ Cin, we have Mj /⊆ Mv.
The labels in, out and undec are partially ordered under the information or- dering ≤i or under the truth ordering ≤t:
undec ≤i out and undec ≤i in, whereas in and out are incomparable. The intended meaning of ≤i is both in and out are more informative than undec. The pair ({in, out, undec} , ≤i) is a complete meet-semilattice, i.e., every non- empty subset of V = {in, out, undec} has a greatest lower-bound (meet), and every directed subset B ⊆ V (any two elements of B have an upper bound in B), has a least upper bound. This meet, denoted by Hi, is defined as follows: for every x, y ∈ {in, out, undec},
⎧
x Hi y = ⎪⎨ out	if x = y = out
⎪⎪⎩ undec otherwise
out ≤t undec ≤t in. The intended meaning of ≤t is to capture the degree of truthness. The pair ({in, out, undec} , ≤t) is a complete lattice, i.e., every non-empty subset of V = {in, out, undec} has a greatest lower-bound (meet),

denoted by Ht and a least upper-bound (join), denoted by Ht. For every x, y ∈
{in, out, undec}, we define


⎧ in	if x = y = in
x Ht y =	out	if x = out or y = out
⎪⎪⎩ undec otherwise
⎧ in	if x = in or y = in
x Ht y =	out	if x = y = out
⎪⎪⎩ undec otherwise

The information ordering ≤i is extended to labellings v1, v2 over S: v1 ≤i v2 iff
v1(s) ≤i v2(s) for all s ∈ S. Let VS be the set of all three-valued labellings over
S. The pair (Vs, ≤i) is a complete meet-semilattice, where the meet operation Hi of this semilattice is given by v1 Hi v2 = v1(s) Hi v2(s) for all s ∈ S. The valuation v(s)= undec for every s ∈ S is the least element of this semilattice.
Similarly, the truth ordering ≤t is extended to labellings v1, v2 over S: v1 ≤t v2 iff v1(s) ≤t v2(s) for all s ∈ S. Let VS be the set of all three-valued labellings over S. The pair (Vs, ≤t) is a complete lattice, where the meet operation Ht of this lattice is given by v1 Ht v2 = v1(s) Ht v2(s) for all s ∈ S. In addition, the join operation Ht of this lattice is given by v1 Ht v2 = v1(s) Ht v2(s) for all s ∈ S. The valuation v(s)= out for every s ∈ S is the least element of this lattice whereas the valuation v(s)= in for every s ∈ S is its greatest element.
Besides admissible labellings, complete labellings are a crucial notion for the definition adf semantics:
Definition 3.4 [Complete labellings] Let D = (S, L, Cin) be an adf. A three- valued labelling v over S is complete iff v is a ≤t-minimal labelling such that for all s ∈ S, v(s)= v(ϕs).
This means that if v is a complete labelling of an adf D, there is no labelling vj such that vj <t v and for all s ∈ S, vj(s)= vj(ϕs). Such a minimization is a novelty introduced in the present work, and as we will put forward, it will guarantee an equivalence result between adf semantics and abstract argumentation semantics.
Fixed-Point Semantics
We will employ an immediate consequences operator ΓD over three-valued labellings to compute and define the semantics of adfs:
Definition 3.5 [ΓD Operator] Let D = (S, L, Cϕ) be an adf, and v a three-valued labelling over S. We define ΓD(v)= vj, where vj(s)= v(ϕs) for any s ∈ S.
We say v is a fixpoint of ΓD if ΓD(v)= v; it is a pre-fixpoint of ΓD if ΓD(v) ≤i v; it is a post-fixpoint of ΓD if v ≤i ΓD(v). The following result suffices to guarantee each adf has a unique ≤i-least fixpoint/pre-fixpoint:
Its is important to notice that, in general, our version of ΓD will not coincide with the corresponding operator defined in [6,4]. However, if for any acceptance condition formula φ (in disjunctive normal form) in an adf, there is no occurrence

of both a propositional symbol a and its negation чa, the two operators will be equivalent [1].
Proposition 3.6 For any adf D = (S, L, Cϕ), the operator ΓD is ≤i-monotone.
Hence, due to the fundamental result by Tarski and Knaster [27], the ≤i-least pre-fixpoint and also the ≤i-least fixpoint are unique (indeed, they coincide with one another) and guaranteed to exist. Besides, the set of fixpoints of ΓD forms a complete meet-semilattice with respect to ≤i:
Theorem 3.7 Let D be an adf.	The ﬁxpoints of ΓD form a complete meet- semilattice with respect to ≤i.
The next results show how ΓD operator can be employed to characterize admis- sible and also complete labellings:
Proposition 3.8 Let D = (S, L, Cϕ) be an adf. We have
A labelling v over S is an admissible labelling of D iff v ≤i ΓD(v).
A labelling v over S is a complete labelling of D iff v is is a ≤t-minimal labelling such that v = ΓD(v).
In addition, we define that a labelling v over S is a model of D iff ΓD(v) ≤t v. It is worthy noting our definition of model is different from that introduced in [6]. While there models and admissible labellings coincide with each other, in the present work, models in general are not admissible. Indeed, we associate admissible labellings with the post-fixpoints of ΓD operator (with respect to information ordering ≤i), whereas models are associated with the pre-fixpoints of ΓD operator (with respect to truth ordering ≤t). We emphasize anyway our defense of this characterization of models is inspired by how models are usually defined in logic programming (see [24] for more details).
When introducing some semantics for adfs, we will resort to the set of undefined statements of a labelling v over S, denoted by undec(v)= {s ∈ S | v(s)= undec}. We can now define some of the main semantics for an adf as follows:
Definition 3.9 Let D = (S, L, Cϕ) be an adf, and v a labelling over S. We have
v is a grounded model of D iff v is a ≤i-minimal complete labelling of D.
v is a preferred model of D iff v is a ≤i-maximal admissible labelling of D.
v is a stable model of D iff v is a two-valued partial stable model of D.
v is a semi-stable model of D iff v is a complete model of D with minimal (with respect to set inclusion) undec(v).
We proceed by displaying an example to illustrate these semantics:
Example 3.10 Consider the adf D = (S, Cϕ) given by
a[чb]	b[чa]	c[чb л e]	d[чc]	e[чd]

where S = {a, b, c, d, e}, and the acceptance formula of each statement s ∈ S is written in square brackets on the right of s. Concerning the semantics of D, we have:
{a, чb}, {b, d, чa, чc, чe} and ∅ are the complete labellings of D.
∅ is the unique grounded model of D.
{a, чb}, {b, d, чa, чc, чe} are the preferred models of D.
{b, d, чa, чc, чe} is the unique stable model of D
{b, d, чa, чc, чe} is the unique semi-stable model of D.
Notice that unlike complete, grounded, preferred and semi-stable models, the stable models are not defined for all adfs. For instance, in an adf whose unique statement is a[чa], there is no stable model. Furthermore, an adf can have more than one stable model. It is the case of the adf represented by
a[чb]	b[чa]
in which {a, чb} and {b, чa} are the stable models of D.
We also identify the relations below involving the semantics we have defined:
Theorem 3.11 Let D be an adf.
v is a preferred model of D iff v is a ≤i-maximal ﬁxpoint of ΓD.
If D has at least one stable model, then v is a stable model of D iff v is a semi- stable model of D.
If v is a stable model of D, then v is a semi-stable model of D, but not vice versa.
In the next section, we will focus on the semantic relations between adfs and
afs.
From afs to adfs
In this section we will regard a subclass of adfs which corresponds to afs. We will start by showing how to encode a given af into a corresponding adf.
Definition 4.1 [4] Given an af F = (A, R), the adf associated to F is DF = (A, R, Cq) with Cq = {ϕa}a∈A, where
ϕa =		чb
(b,a)∈R
A distinguishing aspect of an adf DF associated to an af when compared with ordinary adfs is that the complete labellings of DF coincide with the fixpoints of ΓDF :
Theorem 4.2 Let F = (A, R) be an af and DF = (A, R, Cq) its associated adf.
j
Given a labelling v over S, if ΓDF (v)= v, then there is no labelling v over S such
that vj <t v and ΓD (vj)= vj.

Corollary 4.3 Let F = (A, R) be an af and DF = (A, R, Cq) its associated adf. For any labelling v over S, v is a complete labelling of DF iff ΓDF (v)= v.
Now we can show a fundamental result of this section: the semantics we have defined for adfs are proper generalizations of the corresponding semantics for afs:
Theorem 4.4 Let F be an af and DF its associated adf. A labelling is admissible, complete, preferred, grounded, stable semi-stable of F iff it is admissible, complete, preferred, grounded, stable, semi-stable of DF .
We thus have generalized the main semantics for afs to adfs by pursuing an approach based on three-valued interpretations.

Conclusions
In this paper, we revisited previous work on Abstract Dialectical Frameworks (adfs) [6,4,1], offering revised definitions (Section 3) and a series of equivalence results between Abstract Argumentation semantics [15,8] and adf semantics under af- induced adfs (Section 4). The main innovations of our work stem from (i) using three-valued acceptance conditions [1] for our adfs instead of the original two- valued approach of [6,4] and (ii) requiring that the complete models of an adf is not only a fixed-point of the consequences operator ΓD, but also that it is ≤i- minimal. Those differences allow us to characterize acceptance conditions that can evaluate arguments as undecided, an assessment that is as much of a standard in computational argumentation as the status of accepted or rejected arguments.
It is important to notice that the immediate consequences operator ΓD used in our calculations is not the same as the one defined in [6,4], mainly because we moved from two-valued labellings of arguments to a three-valued approach. By doing so, an argument whose acceptance condition is a formula like a V чa will be evaluated as undec whenever a is itself undec, while in the original formulation of [6,4], a would be accepted due to its acceptance condition being a tautology. Indeed the two operators will be equivalent if no acceptance condition φ (in disjunctive normal form) refers to both a propositional symbol a and its negation чa [1]. This difference between the operators also contributes to the original results we presented in this work.
As for future work we intend to study the connections amongst adfs semantics and logic programming semantics. In [26] the authors have tried to establish an equivalence relation between both kinds of semantics, but they only succeeded for two-valued semantics. In the same work, they showed two logic programs that are not equivalent according to a three-valued semantics would yield the same frame- work when translated to adfs. Hence, their translation is not faithful with respect to three-valued semantics. We claim one of the culprits for such a negative result is the use of two-valued acceptance conditions. Considering that in [10] a variety of equivalence results between logic programming semantics and (three-valued) af semantics were proved, we conjecture the three-valued setting for the acceptance

conditions is what we need to restore the sought semantic equivalences between
adfs and logic programs.

References
Jo˜ao Alcaˆntara and Samy S´a. Abstract dialectical frameworks with three-valued acceptance conditions. (To appear).
Pietro Baroni, Martin Caminada, and Massimiliano Giacomin. An introduction to argumentation semantics. The Knowledge Engineering Review, 26(4):365–410, 2011.
Gerhard Brewka, Stefan Ellmauthaler, Hannes Strass, Johannes Wallner, and Stefan Woltran. Abstract dialectical frameworks. an overview. IFCoLog Journal of Logics and Their Applications, 4(8):2263– 2317, 2017.
Gerhard Brewka, Stefan Ellmauthaler, Hannes Strass, Johannes Peter Wallner, and Stefan Woltran. Abstract dialectical frameworks revisited. In Proceedings of the Twenty-Third international joint conference on Artificial Intelligence, pages 803–809. AAAI Press, 2013.
Gerhard Brewka, Sylwia Polberg, and Stefan Woltran. Generalizations of dung frameworks and their role in formal argumentation. IEEE Intelligent Systems, 29(1):30–38, 2014.
Gerhard Brewka and Stefan Woltran. Abstract dialectical frameworks. In Twelfth International Conference on the Principles of Knowledge Representation and Reasoning, pages 102–111. AAAI Press, 2010.
Martin Caminada. On the issue of reinstatement in argumentation. Logics in artificial intelligence, pages 111–123, 2006.
Martin Caminada. Semi-stable semantics. 1st International Conference on Computational Models of Argument (COMMA), 144:121–130, 2006.
Martin Caminada and Gabriella Pigozzi.	On judgment aggregation in abstract argumentation.
Autonomous Agents and Multi-Agent Systems, 22(1):64–102, 2011.
Martin Caminada, Samy S´a, Jo˜ao Alcˆantara, and Wolfgang Dvoˇr´ak. On the equivalence between logic programming semantics and argumentation semantics. International Journal of Approximate Reasoning, 58:87–111, 2015.
Martin WA Caminada and Dov M Gabbay. A logical account of formal argumentation. Studia Logica, 93(2-3):109, 2009.
Claudette Cayrol and Marie-Christine Lagasquie-Schiex. On the acceptability of arguments in bipolar argumentation frameworks. In European Conference on Symbolic and Quantitative Approaches to Reasoning and Uncertainty, pages 378–389. Springer, 2005.
Claudette Cayrol and Marie-Christine Lagasquie-Schiex. Bipolarity in argumentation graphs: Towards a better understanding. International Journal of Approximate Reasoning, 54(7):pp–876, 2013.
Sylvie Coste-Marquis, S´ebastien Konieczny, Pierre Marquis, and Mohand Akli Ouali. Weighted attacks in argumentation frameworks. In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR), page 593–597. AAAI Press,, 2012.
P.M. Dung. On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games. Artificial Intelligence, 77:321–357, 1995.
Paul E Dunne, Anthony Hunter, Peter McBurney, Simon Parsons, and Michael Wooldridge. Weighted argument systems: Basic definitions, algorithms, and complexity results. Artificial Intelligence, 175(2):457–486, 2011.
Stephen Cole Kleene, NG de Bruijn, J de Groot, and Adriaan Cornelis Zaanen. Introduction to metamathematics, volume 483. van Nostrand New York, 1952.
Diego C Martınez, Alejandro J Garcıa, and Guillermo R Simari. An abstract argumentation framework with varied-strength attacks. In Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning (KR’08), pages 135–144, 2008.
Sanjay Modgil. Reasoning about preferences in argumentation frameworks. Artificial intelligence, 173(9-10):901–934, 2009.


Nir Oren and Timothy J. Norman. Semantics for evidence-based argumentation. In Philippe Besnard, Sylvie Doutre, and Anthony Hunter, editors, Proceedings of the 2nd International Conference on Computational Models of Argument (COMMA), volume 172, pages 276–284. IOS Press, 2008.
Sylwia Polberg and Nir Oren. Revisiting support in abstract argumentation systems. In COMMA, pages 369–376, 2014.
John L Pollock. How to reason defeasibly. Artificial Intelligence, 57(1):1–42, 1992.
John L Pollock. Cognitive carpentry: A blueprint for how to build a person. Mit Press, 1995.
Teodor C. Przymusinski. The well-founded semantics coincides with the three-valued stable semantics.
Fundamenta Informaticae, 13(4):445–463, 1990.
Guillermo R Simari and Ronald P Loui. A mathematical treatment of defeasible reasoning and its implementation. Artificial intelligence, 53(2-3):125–157, 1992.
Hannes Strass. Approximating operators and semantics for abstract dialectical frameworks. Artificial Intelligence, 205:39–70, 2013.
Alfred Tarski. A lattice-theoretical fixpoint theorem and its applications. Pacific journal of Mathematics, 5(2):285–309, 1955.
Frans H van Eemeren and Bart Verheij. Argumentation theory in formal and computational perspective.
IFColog Journal of Logics and Their Applications, 4(8):2099–2181, 2017.
Bart Verheij. Two approaches to dialectical argumentation: admissible sets and argumentation stages.
Proc. NAIC, 96:357–368, 1996.
Gerard AW Vreeswijk. Studies in defeasible argumentation. PhD thesis, Free University of Amsterdam, 1993.
Gerard AW Vreeswijk. Abstract argumentation systems. Artificial intelligence, 90(1-2):225–279, 1997.

Proofs of Theorems
Theorems and Proofs from Section 3:
Proposition 3.3 Let D = (S, L, Cin) be an adf. Given a three-valued labelling v : S → {in, out, undec}, let Mv = {s | v(s)= in}∪ {чs | v(s)= out}. Then v is an admissible labelling of D iff for any s ∈ S
s ∈ Mv iff Mv ∩ Lit (s) ∈ Cin;
чs ∈ Mv iff for all Mj ∈ Cin, we have Mj /⊆ Mv.
Proof. Let D = (S, L, Ct) be an adf and v be a model of D. Then for any s ∈ S, we have
s ∈ Mv iff v(s) = in iff v(ϕs) = in iff according to the characterization of ϕs, there exists a maximal set Mj ∈ Cin such that v(Mj)= in iff there exists a maximal set Mj ∈ Cin such that Mj ⊆ Mv and Mj ⊆ Lit (s) iff Mv ∩Lit (s) ∈ Cin.
s	s
чs ∈ Mv iff v(s)= out iff v(ϕs)= out iff according to the characterization of ϕs
for all Mj ∈ Cin, we have v(Mj) = out iff for all Mj ∈ Cin, we have Mj /⊆ Mv
s	s
and Mj ⊆ Lit (s) iff Mv ∩ Lit (s) /∈ Cin.
2
Proposition 3.6 For any adf D = (S, L, Cq), the operator ΓD is ≤i-monotone.
Proof. We have to prove that for any interpretations v1 and v2 over S if v1 ≤i v2, then ΓD(v1) ≤i ΓD(v2).

Assume v1 ≤i v2. This means that for each s ∈ S, v(s) ≤i vs(s). We have three possibilities:
ΓD(v1)(s)	=	in.	By definition,  v1(ϕs)	=	in.	Thus,  there exists
{a1,..., am, чb1,..., чbn} ⊆ Lit (s) such that v1(a1) = ··· = v1(am) =
v1(чb1)  =  ···  =  v1(чbn)  =  in.	As v1 ≤i  v2, we have there exists
{a1,..., am, чb1,..., чbn} ⊆ Lit (s) such that v2(a1)= ··· = v2(am)= v2(чb1)= 
··· = v2(чbn)= in. In this case, v2(ϕs)= ΓD(v2)(s)= in.
ΓD(v1)(s)	=	out.	By definition,	v1(ϕs)	=	out.	Thus,	for all
{a1,..., am, чb1,..., чbn} ⊆ Lit (s), there exists 1 ≤ i ≤ m or 1 ≤ j ≤ n
such that v1(ai) = out or v1(чbj) = out.	As v1 ≤i v2, we have for all
{a1,..., am, чb1,..., чbn} ⊆ Lit (s), there exists 1 ≤ i ≤ m or 1 ≤ j ≤ n such that v2(ai)= out or v2(чbj)= out. In this case, v2(ϕs)= ΓD(v2)(s)= out.
ΓD(v1)(s)= undec. Trivially ΓD(v1)(s)= undec ≤i ΓD(v2)(s).
2

Theorem 3.7 Let D be an adf. The fixpoints of ΓD form a complete meet- semilattice with respect to ≤i.
Proof.
Let D = (S, L, Cq) be an adf and F be the set of all fixpoints of ΓD. The set F is non-empty as the ≤i-least fixpoint of ΓD is guaranteed to exist. It is also the least element of F . Let E ⊆ F be finite and non-empty. As the pair (VS, ≤i) is a complete meet-semilattice, E has a greatest lower bound (glb) vE ∈ VS. We have to show that vE ∈ F , i.e., vE is a fixpoint of ΓD.
Notice that the pair (Eˆ, ≤i), where Eˆ = {v ∈ VS | v ≤i vE} is a complete lattice.
Now we will show for every x ∈ Eˆ, ΓD(x) ∈ Eˆ:
Let w be an arbitrary element of E. We have x ≤i vE and vE ≤i w
⇒ {As ΓD is monotonic, ΓD(x) ≤i ΓD(vE) ≤i ΓD(w)} ΓD(x) ≤i ΓD(w)
⇒ {As w is a ﬁxpoint of ΓD} ΓD(x) ≤i w
⇒ {w is an arbitrary element of E}
ΓD(x) is a lower bound of E.
⇒ {vE is the greatest lower bound of E}
ΓD(x) ≤i vE
⇒  Deﬁnition of Eˆ,
ΓD(x) ∈ Eˆ
Thus, ΓD is a mapping over the complete lattice (Eˆ, ≤i). Therefore, it has a ≤i- greatest fixpoint vˆE ∈ Eˆ. Since vE is the greatest element of Eˆ, we have vˆE ≤i vE. Consequently, vˆE is the greatest lower bound of E in F .
2

Proposition 3.8 Let D = (S, L, Cq) be an adf. We have
A labelling v over S is an admissible labelling of D iff v ≤i ΓD(v).
A labelling v over S is a complete labelling of D iff v is is a ≤t-minimal labelling such that v = ΓD(v).
Proof.
Firstly we will prove a valuation v over S is an admissible labelling of D iff
v ≤i ΓD(v):
⇒
Let v be an admissible labelling of D. For any s ∈ S, we have the following possibilities:
v(s) ∈ {in, out}: as v is an admissible labelling of D, by definition, v(s) = 
v(ϕs)= ΓD(v)(s).
v(s)= undec : trivially we obtain v(s) ≤i ΓD(v)(s).
⇐
Suppose v ≤i ΓD(v). This means for every s ∈ S, we have v(s) ≤i ΓD(v)(s). Then, if v(s) /= undec, we know v(s) = ΓD(v)(s) = v(ϕs). In other words, v is an admissible labelling of D.
Now we will prove a valuation v over S is complete iff v is a ≤t-minimal labelling such that v = ΓD(v):
The result is immediate; according to Definitions 3.4 and 3.5, a labelling v over S is complete iff v is a ≤t-minimal labelling such that for all s ∈ S, v(s)= v(ϕs)= ΓD(v)(s), i.e., v = ΓD(v).	2
Theorem 3.11 Let D be an adf.
v is a preferred model of D iff v is a ≤i-maximal fixpoint of ΓD.
If D has at least one stable model, then v is a stable model of D iff v is a semi-stable model of D.
If v is a stable model of D, then v is a semi-stable model of D, but not vice versa.
Proof.
v is a preferred model of D iff v is a ≤i-maximal ﬁxpoint of ΓD.
Let A = {v ∈ Cs | v ≤i ΓD(v)} be the set of all admissible interpretations of D.
⇒ If v1 is a preferred model of D, then v1 is a ≤i-maximal element of A. Further, because v1 ∈ A, v1 ≤i ΓD(v1).
⇒ {As ΓD is ≤i −monotonic,}
ΓD(v1) ≤i ΓD(ΓD(v1))
⇒ {From above, ΓD(v1) ∈ A; and v1 is a ≤i-maximal element of A.} v1 /<i ΓD(v1)
⇒ {v1 is an admissible interpretation of D : v1 ≤i ΓD(v1)}
v1 = ΓD(v1)
⇒ v1 is a ≤i-maximal fixpoint of ΓD, because v1 is a fixpoint of ΓD, and every fixpoint of ΓD is also a pre-fixpoint of ΓD. As v1 is a ≤i-maximal element of

A, it is also a ≤i-maximal fixpoint of ΓD.
⇐
Let v2 be a ≤i-maximal fixpoint of ΓD. Then v2 ∈ A. By absurd, suppose
v1 is a ≤i-maximal element of A and v2 <i v1. From the result above, v1 is a fixpoint of ΓD. It is an absurd as we have assumed v2 is a ≤i-maximal fixpoint of ΓD. Hence, v2 is ≤i-maximal element of A, i.e., v2 is a preferred model of D.
If D has at least one stable model, then v is a stable model of D iff v is a semi- stable model of D.
Let D be an adf with at least one stable model.
⇒
If v is a stable model of D, then v is a complete model of D such that undec(v)= ∅. Thus v is a complete model of D with minimal undec(v), i.e., v is an semi-stable model of D.
⇐
If v is a semi-stable model of D, then v is a complete model of D with minimal undec(v). As D has at least one stable model, there exists a complete model vj of D such that undec(vj)= ∅. This means for any complete model vjj with minimal undec(vjj), we will have undec(vjj) = ∅. Thus, v is a complete model of D such that undec(v)= ∅, i.e., v is a stable model of D.
If v is a stable model of D, then v is a semi-stable model of D, but not vice versa. If v is a stable model of D, then v is a complete model of D such that undec(v)= 
∅. This means for any complete model vj with minimal undec(vj), we will have undec(vj)= ∅. Thus, v is a complete model of D with minimal undec(v), i.e., v is a semi-stable model of D.
As a counterexample in the opposite direction, look on the adf D whose unique statement is a[чa]: we see ∅ is a semi-stable model of D, but it is not a stable model of D.
2

Theorems and Proofs from Section 4:
Theorem 4.2 Let F = (A, R) be an af and DF = (A, R, Cq) its associated adf.
j
Given a labelling v over S, if ΓDF (v)= v, then there is no labelling v over S such
that vj <t v and ΓD (vj)= vj.
Proof. Let F = (A, R) be an af and DF = (A, R, Cq) its associated adf. Consider the labelling v over S and assume ΓDF (v)= v. We will prove there is no labelling
vj over S such that vj <t v and ΓD (vj) = vj. By absurd, suppose there exists a

labelling vj over S such that vj <t v and ΓD following possibilities:
(vj)= vj. For each s ∈ S, we have the

vj(s)= in. As vj <t v, we have v(s)= in.
vj(s) = out. As ΓD (vj) = vj, we know vj(ϕs) = out. This means there exists
(b, s) ∈ R such that vj(b)= in. As vj <t v, we have there exists (b, s) ∈ R such

that v(b)= in. In this case, v(s)= out.
v(s)= in. Then for all (b, s) ∈ R, we have v(b)= out. As vj <t v, we have for all (b, s) ∈ R, vj(b)= out. In this case, vj(s)= in.
v(s)= out. As vj <t v, we have vj(s)= out.
Hence v(s) = in iff vj(s) = in and v(s) = out iff vj(s) = out. This implies v(s) = undec iff vj(s) = undec. But then v = vj. It is an absurd as v <t vj. Consequently, there is no labelling vj over S such that vj <t v and ΓD (vj)= vj. 2
Corollary 4.3 Let F = (A, R) be an af and DF = (A, R, Cq) its associated adf. For any labelling v over S, v is a complete labelling of DF iff ΓDF (v)= v.
Proof.
Let F = (A, R) be an af and DF = (A, R, Cq) its associated adf. Consider the labelling v over S.
⇒
Assume v is a complete labelling of DF . We will prove ΓDF (v)= v:
It is straightforward as any complete labelling of DF is in particular a fixpoint of ΓDF .
⇐
Assume ΓDF (v)= v. We will prove v is a complete labelling of DF :
j
As ΓDF (v) = v, we obtain from Theorem 4.2 there is no labelling v over S
such that vj <t v and ΓD (vj)= vj. This implies v is a ≤t-minimal labelling such
that v = ΓDF (v). From Proposition 3.8 we conclude v is a complete labelling of
DF .
2
Lemma A.1 [7,11] Let L1 and L2 be complete argument labellings of an argumen- tation framework af = (Ar , att ). It holds
in(L1) ⊆ in(L2) iff out(L1) ⊆ out(L2)
in(L1) Ç in(L2) iff out(L1) Ç out(L2)
in(L1)= in(L2) iff out(L1)= out(L2)
Lemma A.2 Let F = (Ar , att ) be an argumentation framework, and v be a com- plete labelling of F. it holds
in(v) is minimal (w.r.t. set-inclusion) iff v is a ≤i-minimal complete labelling of
F.
in(v) is maximal (w.r.t. set-inclusion) iff v is a ≤i-maximal complete labelling of F.
Proof.
in(v) is minimal (w.r.t. set-inclusion) iff v is a ≤i-minimal complete labelling of
F .
⇒ Let us assume in(v) is minimal (w.r.t. set-inclusion) among all complete

labellings of F . From Theorem 2.8, we know out(v) is also minimal (w.r.t. set- inclusion) among all complete labellings of F . We will prove v is a ≤i-minimal complete labelling of F :
By absurd, suppose v is not a ≤i-minimal complete labelling of F . This means there exists a complete labelling vJ of F such that vJ <i v. Thus in(vJ) ⊂ in(v) or out(vJ) ⊂ out(v).
If in(vJ) ⊂ in(v) we have an absurd as we assumed in(v) is minimal; other- wise, if out(vJ) ⊂ out(v) we have also an absurd as out(v) is minimal.
⇐
Let us assume v is a ≤i-minimal complete labelling of F . We will prove in(v) is minimal (w.r.t. set-inclusion) among all complete labelling of F :
By absurd, suppose in(v) is not minimal (w.r.t. set-inclusion) among all complete labellings of F . This means there exists a complete labelling vJ of F such that in(vJ) ⊂ in(v). From Lemma A.1, we also know out(vJ) ⊂ out(v). Thus vJ <i v. It is an absurd as we assumed v is a ≤i-minimal complete labelling of F .
in(v) is maximal (w.r.t. set-inclusion) iff v is a ≤i-maximal complete labelling of
F .
⇒ Let us assume in(v) is maximal (w.r.t. set-inclusion) among all complete labellings of F . From Theorem 2.8, we know out(v) is also maximal (w.r.t. set-inclusion) among all complete labellings of F . We will prove v is a ≤i- maximal complete labelling of F :
By absurd, suppose v is not a ≤i-maximal complete labelling of F . This means there exists a complete labelling vJ of F such that v <i vJ. Thus in(v) ⊂ in(vJ) or out(v) ⊂ out(vJ).
If in(v) ⊂ in(vJ) we have an absurd as we assumed in(v) is maximal; other- wise, if out(v) ⊂ out(vJ) we have also an absurd as out(v) is maximal.
⇐
Let us assume v is a ≤i-maximal complete labelling of F . We will prove
in(v) is maximal (w.r.t. set-inclusion) among all complete labellings of F :
By absurd, suppose in(v) is not maximal (w.r.t. set-inclusion) among all complete labellings of F . This means there exists a complete labelling vJ of F
such that in(v) ⊂ in(vJ). From Lemma A.1, we also know out(v) ⊂ out(vJ). Thus v <i vJ. It is an absurd as we assumed v is a ≤i-maximal complete labelling of F .
2


Theorem 4.4 Let F be an af and DF its associated adf. A labelling is admissible, complete, preferred, grounded, stable semi-stable of F iff it is admissible, complete, preferred, grounded, stable, semi-stable of DF .

Proof.
Let F = (A, R) be an af and DF = (A, R, Cq) be its associated adf, in which

Cq = {ϕa}a∈A and for every a ∈ A,
ϕa =		чb
(b,a)∈R

Let v be a labelling over A. We will prove the following equivalences:
v is an admissible labelling of F iff v is an admissible labelling of DF .
⇒
Let v be an admissible labelling of F . Then for every argument a ∈ A,
If v(a)= in, then for every (b, a) ∈ R, v(b)= out. This means v(ϕa)= in.
If v(a)= out, then there exists (b, a) ∈ R, such that v(b)= in. This means
v(ϕa)= out.
Hence, v(a) ≤i v(ϕa), i.e., v is an admissible labelling of DF (Proposition 3.8).
⇐
Let v be an admissible labelling of DF . Then for every argument a ∈ A,
If v(a)= in, then v(ϕa)= in. This implies for every (b, a) ∈ R, v(b)= out.
If v(a) = out, then v(ϕa) = out. This implies there exists (b, a) ∈ R such that v(b)= in.
Hence, v is an admissible labelling of D.
v is a complete labelling of F iff v is a complete model of DF .
We know v is a complete labelling of F iff for every argument a ∈ A,
v(a)= in iff for every (b, a) ∈ R, v(b)= out iff v(ϕa)= in.
v(a)= out iff there exists (b, a) ∈ R, such that v(b)= in iff v(ϕa)= out.
v(a) = undec iff there exists (b, a) ∈ R such that v(b) /= out and for every (b, a) ∈ R, v(b) /= in iff v(ϕa)= undec
This is equivalent to say v = ΓDF (v). From Corollary 4.3 we obtain v is a complete model of DF .
v is a preferred labelling of F iff v is a preferred model of DF .
v is a preferred labelling of F iff in(v) is maximal (w.r.t. set-inclusion) among all complete labellings of F iff (Lemma A.2) iff v is a ≤i-maximal complete la- belling of F iff v is a ≤i-maximal complete labelling of DF iff v is a ≤i-maximal fixpoint of ΓDF (Corollary 4.3) iff v is a preferred model of DF (Theorem 3.11).
v is a grounded labelling of F iff v is a grounded model of DF .
v is a grounded labelling of F iff in(v) is the least (w.r.t. set-inclusion) among all complete labellings of F iff (Lemma A.2) v is the ≤i-least complete labelling of F iff v is ≤i-least complete labelling of DF iff v is the grounded labelling of DF .
v is a stable labelling of F iff v is a stable model of DF .
v is a stable labelling of F iff v is a complete labelling of F with undec(v)= ∅ iff v is a complete labelling of DF with undec(v) = ∅ iff v is a stable model of DF .
v is a semi-stable labelling of F iff v is a semi-stable model of DF .

v is a semi-stable labelling of F iff v is a complete labelling of F with minimal (w.r.t. set-inclusion) undec(v) iff v is a complete labelling of DF with minimal (w.r.t. set-inclusion) undec(v) iff v is a semi-stable labelling of DF .
2
