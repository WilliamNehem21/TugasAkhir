Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 351 (2020) 167–186
www.elsevier.com/locate/entcs

An Efficient Algorithm for Representing Piecewise Linear Functions into Logic
Sandro Preto1,3 Marcelo Finger1,2,4
Institute of Mathematics and Statistics University of Sa˜o Paulo
S˜ao Paulo, Brazil

Abstract
Rational McNaughton functions may be implicitly represented by logical formulas in L- ukasiewicz Infinitely- valued Logic by constraining the set of valuations to the ones that satisfy some specific formulas. This work investigates this implicit representation called representation modulo satisfiability and describes a polynomial algorithm that builds it — the representative formula and the constraining ones — for a given rational McNaughton function.

Keywords:
Functions.
L- ukasiewicz Infinitely-valued Logic, Rational McNaughton Functions, Piecewise Linear



Introduction
The ability to represent any piecewise linear function with a logical formula allows us to apply automated reasoning techniques to the study of real systems, whose behavior is either modeled or approximated by such a function. However such an ability will only be effective if there are efficient ways to generate a formula in a target logic in which reasoning is not exceedingly complex. Classical logic with its binary semantics, despite of being a natural target for representing Boolean functions, may not be the natural way to represent continuous functions which inevitably would require some encoding of rational or real numbers; so we follow the path of electing some form of many-valued logic, whose semantics range over rational numbers, as a more adequate representation framework. That path has initially been explored by applications in fuzzy control [5].

1 This study was financed in part by the Coordena¸c˜ao de Aperfei¸coamento de Pessoal de N´ıvel Superior - Brasil (CAPES) - Finance Code 001.
2 Partly supported by Fapesp projects 2014/12236-1 and 2019/07665-4 and CNPq grant PQ 303609/2018-4.
3 Email: spreto@ime.usp.br
4 Email: mfinger@ime.usp.br

https://doi.org/10.1016/j.entcs.2020.08.009
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Neural network interpretability is a challenge to the development of artificial intelligence and is also another motivation for the representation of piecewise linear functions, as described by [4]. In fact, a neural network, depending on its class of activation functions, can be seen either as a piecewise linear function or as a continuous function that can be approximated by one [12].
The first candidate to consider as a target logic is L- ukasiewicz Infinitely-valued Logic (L- ∞), arguably one of the best studied many-valued logics [7]; it has sev- eral interesting properties such as continuous truth-functional semantics, classical logic as limit case, and well developed proof-theoretical and algebraic presentations. Its formulas are known to represent exactly the so-called McNaughton functions, consisting of [0, 1]-valued piecewise linear functions with integer coefficients over [0, 1]n [13,15]. This restriction to integer coefficients fails to fulfill, for instance, the hypotheses for the classic Stone-Weierstrass Approximation Theorem [16] and there is no known analogous to Proposition 1.1 below for McNaughton functions.
This issue is circumvented by slightly modifying McNaughton functions to al- low their linear pieces to have rational coefficients — the rational McNaughton functions; such generalization is enough to perform Weierstrass-like approxima- tions [5,2]. Figure 1 shows a continuous function f : [0, 1] → [0, 1] (a) with two possible approximations by rational McNaughton functions: with two (b) and five different linear pieces (c). Note that continuous functions with more general domain and range might be normalized in order to perform such approximations.
Proposition 1.1 (Variation of Weierstrass Approximation Theorem [5])
Let f : [0, 1]n → [0, 1] be a continuous function and ε > 0. Then there is a rational

McNaughton function
x ∈ [0, 1]n.
f˜ : [0, 1]n → [0, 1] such that |f (x) − f˜(x)| < ε, for all

In this context, the target logic must be a system, preferably based on L- ∞, with semantics that comprehends all rational McNaughton functions and, given one such function, be endowed with an efficient algorithm that provides a formula that represents it. Furthermore, we highlight that it would be of little practical use if the reasoning complexity in such system is exceedingly high.
Esteva, Godo & Montagna propose logic L- Π 1 which extends L- ∞ with a product operator, its residuum, and a constant expressing the truth value 1 , not directly expressible in L- ∞ [8]. That logic not only allows for the expressivity of rational McNaughton functions but also expresses piecewise polynomials; as a consequence

satisfiability over L- Π 1
requires finding roots of polynomials of n-degree rendering

its complexity extremely high. Aguzzoli & Mundici propose logic ∃L- which also
expresses rational McNaughton functions and has complexity Σp for the satisfiability
problem [2,3]. Logic ∃L- extends L- ∞ and introduces rational numbers by providing
restricted form of propositional quantification whose semantic counterpart is the maximization of a set of L- ∞-valuations of a formula.

Gerla introduces Rational
L- ukasiewicz Logic by extending
L- ∞ with division

operators δn that induces division by n ∈ N∗ in its semantics [11]; its associated tautology problem is coNP-complete, which is a reasonable complexity for this task.



f (x)
f˜1(x)










x
(a)
x
(b)


f˜2(x)







x
(c)
Fig. 1. Continuous one-variable function approximated by rational McNaughton functions.


This logic expresses all rational McNaughton functions however it was not provided an algorithm to build the representative formulas, and an attempt to derive one from the results in [11] would lead to the problem of representing McNaughton functions in L- ∞; it is known that this task may be done in polynomial time on the coefficients of some specific functions [1], however these methods lead to exponential time complexity if binary representation of the coefficients is used.
Finger & Preto provide a way to implicitly express rational McNaughton func- tions in L- ∞ called representation modulo satisfiability (L- ∞-MODSAT) [10]. For that, in addition to a representative formula, it is introduced a set of formulas that constrains L- ∞-valuations to those that satisfy all formulas in the set; a ra- tional McNaughton function f is then represented by a pair ⟨ϕ, Φ⟩, where ϕ is a formula that semantically acquires values f (x), for x ∈ [0, 1]n, from valuations in
{v(ψ) = 1 | ψ ∈ Φ}, where Φ is a set of formulas. Instead of an extension of the logic, this proposal works in L- ∞ itself, which has computational problems with rea- sonable complexity — e.g., satisfiability over L- ∞ is NP-complete [14]. Also, there

already are available implementations of L- ∞-solvers which are discussed in the liter- ature and for which phase transition phenomenon is identified [6,9]. Unfortunately, an attempt to derive a representation builder algorithm from results in [10] would also lead to an exponential blow up, since the proposed pairs for representing only truncated linear functions are already exponential in the binary representation of their coefficients.
Our goal here is to provide an efficient algorithm that, given a rational Mc- Naughton function, outputs a pair ⟨ϕ, Φ⟩ that represents it in the target system L- ∞-MODSAT. We show that all rational McNaughton functions may be represented modulo satisfiability by a constructive proof from which we derive a polynomial al- gorithm that builds such representation.
This paper is organized as follows: Section 2 introduces all necessary concepts of L- ukasiewicz Infinitely-valued Logic and the definition of rational McNaughton functions; Section 3 has the formalization of the concept of representation modulo satisfiability; Section 4 provides a convention on rational McNaughton functions encoding for computation purposes as well as some results about these functions; Section 5 has a theoretical and algorithmic treatment of a particular case of represen- tation modulo satisfiability of rational McNaughton functions which are truncated linear functions; and Section 6 finally treats, also theoretically and algorithmically, the representation modulo satisfiability of general rational McNaughton functions.


Preliminaries
The basic language L of L- ukasiewicz Infinitely-valued Logic (L- ∞) comprehends the formulas built from a countable set of propositional variables P, and disjunction (⊕) and negation (¬) operators. For the semantics, define a valuation as a function v : L→ [0, 1], such that, for ϕ, ψ ∈ L:

v(ϕ ⊕ ψ)= min(1, v(ϕ)+ v(ψ));	(1)
v(¬ϕ)=1 − v(ϕ).	(2)

One may just give a function vP which maps propositional variables to a value in the interval [0, 1] and extend this function to a valuation by obeying (1) and (2). This extension is uniquely defined by such assignment to the variables in P given by vP.
We denote by Val the set of all valuations; by Var(Φ) the set of all propositional
variables occurring in the formulas ϕ ∈ Φ; and by Xn the set of propositional variables {X1,..., Xn}⊂ P. A formula ϕ is satisﬁable if there exists a v ∈ Val such that v(ϕ) = 1; otherwise it is unsatisﬁable. A set of formulas Φ is satisfiable if there exists a v ∈ Val such that v(ϕ)= 1, for all ϕ ∈ Φ. We denote by ValΦ the set of all valuations v ∈ Val that satisfies a set of formulas Φ.

From disjunction and negation we derive the following operators:
Conjunction: ϕ ⊙ ψ =def ¬(¬ϕ ⊕ ¬ψ)		v(ϕ ⊙ ψ)= max(0, v(ϕ)+ v(ψ) − 1) Implication: ϕ → ψ =def ¬ϕ ⊕ ψ	 v(ϕ → ψ)= min(1, 1 − v(ϕ)+ v(ψ)) Maximum: ϕ ∨ ψ =def ¬(¬ϕ ⊕ ψ) ⊕ ψ	v(ϕ ∨ ψ)= max(v(ϕ), v(ψ))
Minimum: ϕ ∧ ψ =def ¬(¬ϕ ∨ ¬ψ)	v(ϕ ∧ ψ)= min(v(ϕ), v(ψ)) Bi-implication: ϕ ↔ ψ =def (ϕ → ψ) ∧ (ψ → ϕ)  v(ϕ ↔ ψ)=1 − |v(ϕ) − v(ψ)|

Note that v(ϕ → ψ)=1 iff v(ϕ) ≤ v(ψ); similarly, v(ϕ ↔ ψ)=1 iff v(ϕ)= v(ψ). Let X be a propositional variable, then, v(X ⊙¬X)= 0, for any v ∈ Val; we define the constant 0 by X ⊙ ¬X. We also define 0ϕ =def 0 and nϕ =def ϕ ⊕· · ·⊕ ϕ, n times, for n ∈ N∗; and  i∈∅ ϕi =def 0.
Adapting the definition in [7], a rational McNaughton function f : [0, 1]n → [0, 1]
is a function that satisfies the following conditions:
f is continuous with respect to the usual topology of [0, 1] as an interval of the real number line;
There are linear polynomials p1,..., pm over [0, 1]n with rational coefficients such that, for each point x ∈ [0, 1]n, there is an index i ∈ {1,..., m} with f (x)= pi(x). Polynomials p1,..., pm are the linear pieces of f .

Representation Modulo Φ-Satisfiable
A McNaughton function is a rational McNaughton function whose linear pieces have integer coefficients. Let ϕ be a L- ∞-formula with Var(ϕ) ⊂ Xn, we inductively associate to ϕ a function fϕ : [0, 1]n → [0, 1] by:
fXj (x1,..., xn)= xj, for j = 1,..., n;
f¬ϕ(x1,..., xn)=1 − fϕ(x1,..., xn);
fϕ1⊕ϕ2 (x1,..., xn)= min(1, fϕ1 (x1,..., xn)+ fϕ2 (x1,..., xn)).
We have that fϕ is a McNaughton function such that
fϕ(v(X1),..., v(Xn)) = v(ϕ), for v ∈ Val.	(3) Reciprocally, McNaughton’s Theorem [13] states that, for any McNaughton function
f , there is a formula ϕ such that f = fϕ. We say that ϕ represents f .
Although formulas of L- ∞ only represent (integer) McNaughton functions, we take the strategy of restricting the set Val of valuations in order to implicitly represent rational McNaughton functions. For that, we start by noting that value of a formula ϕ according to some valuation v is determined only by the values associated to a finite set of propositional variables X such that Var(ϕ) ⊂ X; this very property is the crux for the possibility that logical formulas represent functions. We next generalize this notion.

Definition 3.1 Let ϕ be a formula and let Φ be a set of formulas. We say that a set of variables Xn determines ϕ modulo Φ-satisﬁable if:
For any ⟨x1,..., xn⟩ ∈ [0, 1]n, there exists at least one valuation v ∈ ValΦ, such that v(Xj)= xj, for j = 1,..., n;
For any valuations v, vj ∈ ValΦ, such that v(Xj) = vj(Xj), for j = 1,..., n, v(ϕ)= vj(ϕ).
For instance, for any formula ϕ such that Var(ϕ) ⊂ Xn, Xn determines ϕ modulo
∅-satisfiable, by truth functionality and the fact that Val∅ = Val.
It is important to note that any set Xn can now represent a rational fraction

1 by determining a propositional variable Z 1
d	d
modulo ϕ 1
d
= Z 1
d
↔ ¬(d − 1)Z 1
d

satisfiable, with d ∈ N∗. In fact, for any valuation v ∈ Val, if v(ϕ 1 ) = 1, then
d
v(Z 1 ) = 1 . We define representation modulo satisfiability in a way that retrieves
d	d
property (3).
Definition 3.2 Let f : [0, 1]n → [0, 1] be a function, and ⟨ϕ, Φ⟩ be a pair where ϕ is a formula and Φ is a set of formulas. We say that ϕ represents f modulo Φ-satisﬁable or that ⟨ϕ, Φ⟩ represents f in the system L- ∞-MODSAT if:
Xn determines ϕ modulo Φ-satisfiable;
f (v(X1),..., v(Xn)) = v(ϕ), for v ∈ ValΦ.
Representation modulo satisfiability presented in [10] has a different approach, which we call function-based and is more restrictive than the one presented here, which we call formula-based. However, the representation methods and algorithms we develop in this work apply to both approaches.
Rational McNaughton Functions
Our algorithm uses a lattice representation of rational McNaughton functions; be- fore that we employ an encoding based in [17,18] as follows. Let Ω○ be the interior of a set Ω ⊂ Rn. A rational McNaughton function f : [0, 1]n → [0, 1] is given by m (not necessarily distinct) linear pieces
pi(x)= γi0 + γi1x1 + ··· + γinxn,	(4) for x = ⟨x1,..., xn⟩ ∈ [0, 1]n, γij ∈ Q and i = 1,..., m, with each linear piece pi
identical to f over a convex set Ωi ⊂ [0, 1]n called region such that:

m
i=1
Ωi = [0, 1]n;

Ω○ ∩ Ω○ = ∅, for ij /= ijj;
i′	i′′
Regions Ωi are given in such a way that there is a polynomial procedure to determine whether or not a linear piece pk is above other linear piece pi over region Ωi, that is whether or not pk(x) ≥ pi(x), for all x ∈ Ωi.
A rational McNaughton function as above is said to be in regional format. Note that






0.6


0.4


x2
Fig. 2. Graph of rational McNaughton function with three linear pieces over [0, 1]2.

(a)	(b)
Fig. 3. Some possible region configurations for function f in Example 4.1.

in this format the number of linear pieces is equal to the number of regions; in this case, the size of a function is the sum of the number of bits necessary to represent its linear pieces coefficients as fractions a plus the space necessary for representing
its regions in some assumed encoding.
Example 4.1 Rational McNaughton function f with graph in Figure 2 may be given by the linear pieces:
p1(x1, x2)= 4 + 2 x2;
9	3
p2(x1, x2)= 5 − 1 x2;
6	2
p3(x1, x2)= 4 − x1.
Regions associated to each linear piece are depicted in Figure 3(a). Determining if some linear piece pk is above other linear piece pi over Ωi is equivalent to determining if the system of corresponding inequalities in Table 1 with added equation pk−pi =0 has no solution and pk(x0) > pi(x0), for some point x0 ∈ Ω○, a tractable process.
Let f : [0, 1]n → [0, 1] be a rational McNaughton function as defined in Section 2,





○
1
8 − 9x1 − 6x2 > 0
1 − x2 > 0
x1 > 0
x2 > 0
○
2
1 − 2x1 + x2 > 0
− 1 + x2 > 0
x1 > 0
1 − x2 > 0
○
3
−8+ 9x1 + 6x2 > 0
−1+ 2x1 − x2 > 0
1 − x1 > 0
x2 > 0



Table 1
Sets Ω◦ for function f in Example 4.1.

with distinct linear pieces p1,..., pm. For each permutation ρ of the set {1,..., m}, we define the polyhedron
Pρ = {x ∈ [0, 1]n | pρ(1)(x) ≥ · · ·≥ pρ(m)(x)}.	(5) Let C be the set of n-dimensional polyhedra Pρ, for some permutation ρ.
Proposition 4.2 The set C has the following properties:
C = [0, 1]n;
For polyhedron P ∈ C and indexes ij, ijj ∈ {1,..., m} with ij /= ijj, pi′ (x) /=
pi′′ (x), for any x ∈ P○;
Pj○ ∩ P jj○ = ∅, for Pj,Pjj ∈C such that Pj /= P jj;
For each polyhedron P ∈ C, there is an index iP ∈ {1,..., m} such that f (x)= 
pi (x), for x ∈ [0, 1]n.
Proof.
For any x ∈ P ∈ C, x ∈ [0, 1]n. On the other hand, for any x ∈ [0, 1]n, there is a permutation ρ for which Pρ is n-dimensional and x ∈ Pρ.
Let x ∈ P○ and let ij, ijj ∈ {1,..., m} be indexes such that ij /= ijj. Since pi′ and pi′′ are linear pieces, if pi′ (x) = pi′′ (x), for some x ∈ P○, there would be points x1, x2 ∈ P○ in a neighborhood of x such that pi′ (x1) < pi′′ (x1) and pi′′ (x2) < pi′ (x2), contrary to the definition of P .
Let x ∈ Pj○∩Pjj○. Then, by definitions of Pj and P jj, there are ij, ijj ∈ {1,..., m}
such that pi′ (x)= pi′′ (x), contrary to item (b).
Let {i1,..., ik} ⊂ {1,..., m} be a non-singleton set of indexes such that, for

any x ∈ P○, there is l ∈ {1,..., k}, such that f (x) = pi (x) and Ui
= {x ∈

P○ | f (x)= pi (x)} /= ∅, for l = 1,..., k. We have that ∪k Ui = P○ and, by
l	l=1	l
item (b), Ui ′ ∩Ui ′′ = ∅, for lj /= ljj. As P○ is a connected set, there are distinct
l	l
ij, ijj ∈ {i1,..., ik} and b ∈ P○ such that b ∈ ∂Ui′ and b ∈ Ui′′ . As pi′ restricted
to Ui′ ∪ {b} is continuous, for any sequence {bn} ⊂ Ui′ such that lim bn = b (which exists since b ∈ ∂Ui′ ), we have that lim f (bn) = lim pi′ (bn) = pi′ (b). However, f (b)= pi′′ (b) /= pi′ (b), by item (b), contrary to the continuity of f .
2

Polyhedra in C may play the role of regions since they are convex sets with the properties above; determining whether a linear piece pk is above other linear piece pi over P ∈ C comes down to comparing their values for some point x ∈ P○. Note that the same linear piece pi may be associated to many distinct polyhedra. Thus, any rational McNaughton function may be encoded in regional format. Figure 3(b) shows the polyhedra-based configuration C for the function in Example 4.1.
The setback with describing a rational McNaughton function using the set C of polyhedra is that in the worst case |C| = m!. However, in general there are smaller sets of regions that comply with representation restrictions above [18].
A Particular Case: Truncated Linear Functions
Let us show the possibility of representing a rational McNaughton function modulo satisfiability and develop a polynomial algorithm for computing such representation in the particular case that function is a truncated linear polynomial with rational coefficients.
Let p : [0, 1]n → R be a nonzero linear polynomial given by

p(x)= a0 + a1 x
b0	b1 1
+ ··· + an x
bn  n
,	(6)

for x = ⟨x1,..., xn⟩ ∈ [0, 1]n, aj ∈ Z, and bj ∈ Z∗ . We want to build a representa- tion for the function p# : [0, 1]n → [0, 1] given by
p#(x)= min 1, max 0, p(x)  .	(7)
We have that p#(x) = 0, if p(x) < 0; p#(x) = 1, if p(x) > 1; and p#(x) = p(x), otherwise.
In order to rewrite expression (6), we define:
αj = aj, for j ∈ P ;
αj = −aj, for j ∈ N ;
βj = β · bj, for j = 0,..., n;
where j ∈ P , if aj > 0, and j ∈ N , if aj < 0, with P ∪ N ⊂ {0,..., n}, and β is the least integer greater than or equal to
max ,⎨Σ aj ,	− Σ aj ,⎬ .
,j∈P bj	j∈N bj ,
We have that αj ∈ Z+ and βj ∈ Z∗ , for j = 0,..., n. Let x0 = 1 and define functions pP : [0, 1]n → R and pN : [0, 1]n → R, for x = ⟨x1,..., xn⟩∈ [0, 1]n, by:
p (x)= Σ αj x ;	p (x)= Σ αj x .	(8)


Lemma 5.1 Functions p, pP , and pN in (6) and (8) have the following properties, for x ∈ [0, 1]n:
p(x)= β · pP (x) − pN (x) ;
0 ≤ pP (x), pN (x) ≤ 1.
Proof. By elementary algebraic manipulation.	2
Lemma above decomposes function p in terms of pP and pN , let us represent
the latter ones. Let Zp,Z  1 ∈ P. For a set of indexes J ∈ {P, N}, define:
j	βj
ϕ˜J =	  αjZp;	Φ˜J =		 ϕ 1 ,  βjZp ↔ Xj,  Zp → Z 1  .

j
j∈J\{0}
βj	j
j∈J\{0}
j	βj

And then, define:

ϕ¯J = ϕ˜J ;
ϕ¯J = α0Z  1
β0


⊕ ϕ˜J ;
Φ¯ J = Φ˜J ,	if 0 ∈/ J; Φ¯ J = Φ˜J ∪ {ϕ  1 },	otherwise.
β0

(9)

Lemma 5.2 Functions pP  and pN in (8) may respectively be represented by
⟨ϕ¯P , Φ¯ P ⟩ and ⟨ϕ¯N , Φ¯ N ⟩ in (9).
Proof. Let J ∈ {P, N}. If J = ∅, then ⟨ϕ¯J , Φ¯ J⟩ = ⟨0, ∅⟩ represents pJ . For
⟨x1,..., xn⟩∈ [0, 1]n, define a valuation v ∈ Val such that v(Xj)= xj and v(Zp)= 
xj , for j ∈ J \ {0}, and v(Z  1 ) =  1 , for j ∈ J. We have that v ∈ Val ¯ .
βj	βj	βj	ΦJ
Now, let v, vj ∈ ValΦ¯	such that v(Xj) = vj(Xj), for j = 1,..., n. By rational

J	j	 1
p	 1

constant representation, v(Z  1 ) = v (Z  1 ) =
βj , for j ∈ J. Thus v(Zj ) ≤ βj

βj	βj
and vj(Zp) ≤  1 , which implies that βj · v(Zp) = v(βjZp) = v(Xj) = vj(Xj) = 
j	βj	j	j
vj(βjZp) = βj · vj(Zp) and, then, v(Zp) = vj(Zp), for j ∈ J \ {0}. Therefore,
j	j	j	j
v(ϕ¯J ) = vj(ϕ¯J ) and Xn determines ϕ¯J modulo Φ¯ J -satisfiable. Finally, suppose
v ∈ ValΦ¯ J . In the case where 0 ∈ J,


pJ (v(X1),..., v(Xn)) = α0 · v(Z  1 )+ 
β0
j∈J\{0}
αj · v(Zp)= v(ϕ¯J ),

by Lemma 5.1 and aforementioned equations v(Z  1 )=  1  and βj · v(Zp)= v(Xj).
β0	β0	j
The case where 0 ∈/ J is similar.	2
For the final step towards a representation for p#, we define:

ϕ¯p = β[¬(ϕ¯P → ϕ¯N )];
Φ¯ p = Φ¯ P ∪ Φ¯ N .	(10)

Theorem 5.3 Function p# in (7) may be represented by ⟨ϕ¯p, Φ¯ p⟩ in (10).
Proof. For ⟨x1,..., xn⟩ ∈ [0, 1]n, there exists v ∈ ValΦ¯  such that v(Xj) = xj as

in the proof of Lemma 5.2 with J = P ∪ N . Now, let v, vj ∈ ValΦ¯
such that

v(Xj)= vj(Xj), for j = 1,..., n. In particular, v, vj ∈ ValΦ¯	and, by Lemma 5.2,
v(ϕ¯J )= vj(ϕ¯J ), for J ∈ {P, N}. Therefore, v(ϕ¯p)= vj(ϕ¯p) and Xn determines ϕ¯p modulo Φ¯ p-satisfiable. Finally, suppose v ∈ ValΦ¯ p . In particular, v ∈ ValΦ¯ P and v ∈ ValΦ¯ N . If p(v(X1),..., v(Xn)) ≤ 0, by Lemma 5.1, pP (v(X1),..., v(Xn)) ≤
pN (v(X1),..., v(Xn)).  Therefore, by Lemma 5.2, v(ϕ¯P ) ≤ v(ϕ¯N ) and, then,
v(ϕ¯p) = 0. On the other hand, if p(v(X1),..., v(Xn)) ≥ 0, by Lemma 5.1, pP (v(X1),..., v(Xn)) ≥ pN (v(X1),..., v(Xn)). Therefore, by Lemma 5.2, v(ϕ¯P ) ≥ v(ϕ¯N ) and, then, v(¬(ϕ¯P → ϕ¯N )) = 1−min(1, 1−v(ϕ¯P )+v(ϕ¯N )) = v(ϕ¯P )−v(ϕ¯N ). Finally, by Lemmas 5.1 and 5.2, p(v(X1),..., v(Xn)) = β · (v(ϕ¯P ) − v(ϕ¯N )), hence p#(v(X1),..., v(Xn)) = v(ϕ¯p) in any case.	2
Table 2 shows how functions in Example 4.1 can be represented as in Theorem 5.3.
In order to set up a polynomial algorithm for computing a representation ⟨ϕp, Φp⟩ for p#, we analyze more closely expressions nψ, which show up in ϕ¯p and in formulas in Φ¯ p. These expressions are exponential in the binary representation of n since it denotes an n-fold repetition of formula ψ. We deviate from this situation by
using [log n♩ + 1 new propositional variables ξ0 , ξ1 ,.  , ξ[log n♩ and replacing every
ψ	ψ	ψ
occurrence of nψ, where n ∈ N \ {0, 1}, with the formula
ξnψ =def	ψ
where nk ∈ {0, 1} comes from the binary representation Σ[log n♩ 2knk of n, and by
adding the following formulas to Φ¯ p:

0 ↔ ψ;
ξk ↔ ξk—1 ⊕ ξk—1, for k = 1,..., [log n♩.
(12)

ψ	ψ	ψ
These formulas define the propositional variables ξk and we call Ξnψ the set that
comprehends them. In this way we avoid exponential blow up as shown in Theorem 5.5.
Lemma 5.4 Let n ∈ N \ {0, 1}, ψ be a formula, and ξnψ and Ξnψ be respectively a formula as in (11) and a set as in (12) built from n and ψ. For any valuation v ∈ ValΞnψ , v(nψ)= v(ξnψ).




¬ Z  1

⊕ Z  1 ⊕ Z  1
⊕ Z  1 ⊕ Zp1 ⊕ Zp1 → 0 

ϕ¯p1 :
⊕¬ Z
	
⊕ Z	⊕ Z
	
⊕ Z	⊕ Zp1 ⊕ Zp1 → 0 





Φ¯ p1 :
Z  1
18
↔ ¬ Z  1 ⊕ Z  1
18	18
⊕ Z  1 ⊕ Z  1
18	18
⊕ Z  1 ⊕ Z  1
18	18
⊕ Z  1 ⊕ Z  1
18	18
⊕ Z  1
 18

⊕ Z 1
18
⊕ Z 1 ⊕ Z 1
18	18
⊕ Z 1 ⊕ Z 1
18	18
⊕ Z 1 ⊕ Z 1
18	18
⊕ Z 1
18

Z 1 ↔ ¬ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 
					
Zp1 ⊕ Zp1 ⊕ Zp1 ⊕ Zp1 ⊕ Zp1 ⊕ Zp1 ↔ X2
2	2	2	2	2	2
Zp1 → Z 1
2	6

ϕ¯p :	¬ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 → Zp2 

Φ¯ p2 :	Z 1 ↔ ¬ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 

Z 1 ↔ ¬Z 1
2	2
Zp2 ⊕ Zp2 ↔ X2
2	2
Zp2 → Z 1
2	2

ϕ¯p :	¬ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 → Zp3  ⊕¬ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 → Zp3 

Φ¯ p3 :	Z 1 ↔ ¬  Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 ⊕ Z 1 

Z 1 ↔ ¬Z 1
2	2
Zp3 ⊕ Zp3 ↔ X1
1	1
Zp3 → Z 1
1	2

Table 2
Representations as in (10) for functions p#, p# and p#, where functions p1, p2 and p3 are from Example
1	2	3
4.1.

k	k
Proof. For v ∈ ValΞnψ and k = 0,..., [log n♩, v(ξ )= min(1, 2 v(ψ)). Then,

v(nψ)= min ,1,
⎝
,
[log n♩ k=0
[log n♩
2knkv(ψ)⎞
⎠
⎞



,	⎞

= min ⎝1,

k=0
k ψ
nk=1
ξk ⎠ = v(ξnψ),

where nk ∈ {0, 1} in the binary representation n = Σ[log n♩ 2knk.	2
Theorem 5.5 Let n ∈ N \ {0, 1}, ψ be a formula, and ⟨ϕp, Φp⟩ be a pair deﬁned from representation ⟨ϕ¯p, Φ¯ p⟩ in (10) by replacing any occurrence of nψ in ϕ¯p and Φ¯ p with ξnψ in (11) and by adding formulas in set Ξnψ in (12) to Φ¯ p. Then, ⟨ϕp, Φp⟩
is also a representation for p# in (7). Furthermore, ⟨ϕp, Φp⟩ is a representation
for p# even if it is deﬁned by multiple suitable replacements of expressions nlψl, for
l = 1,.  , L.
Proof. For ⟨x1,..., xn⟩ ∈ [0, 1]n, define a valuation v such that v(Xj) = xj and
v(Zp) = xj , for j = 1,..., n, v(Z  1 ) =  1 , for j = 0,..., n, v(ξ0 ) = v(ψ), and

j	βj
βj	βj	ψ

v(ξk ) = min(1, v(ξk—1)+ v(ξk—1)), for k = 1,..., [log n♩. Note that v ∈ ValΦ¯
ψ	ψ	ψ	p
and v ∈ ValΞnψ , then, by Lemma 5.4, as Ξnψ ⊂ Φp, we have that v ∈ ValΦp .
Still, for any v ∈ Φp, we have that v ∈ ValΞnψ  and, by Lemma 5.4, v ∈ Φ¯ p.
Therefore, again by Lemma 5.4, for v, vj ∈ Φp such that v(Xj) = vj(Xj), for j =
1,..., n, it follows that v(ϕp) = vj(ϕp), Xn determines ϕp modulo Φp-satisfiable, and p#(v(X1),..., v(Xn)) = v(ϕp). This argument still holds when considering multiple replacements.	2
We set ⟨ϕp, Φp⟩ from ⟨ϕ¯p, Φ¯ p⟩ in (10) by properly replacing all occurrences of
nlψl as stated in the above theorem. By construction, ⟨ϕp, Φp⟩ is given by
ϕp = β[¬(ϕP → ϕN )];	Φp = ΦP ∪ ΦN ;	(13)
where ϕP , ϕN , ΦP , and ΦN are properly defined from their barred correspondents in
(9). Table 3 shows how functions in Example 4.1 can be represented as in Theorem 5.5.
Algorithms 1 and 2 compute the representation modulo satisfiability of nψ. Algorithm 1 returns 0 and ψ in the limit cases n = 0 and n = 1 (lines 1 to 5); when n ∈ N \ {0, 1}, it returns formula ξnψ in (11) by building it in line 6 plus a [log n♩ + 1 iteration loop (lines 7 to 13) where the nk’s in the binary representation of n are calculated by the routine in lines 8 and 9. Algorithm 2 returns ∅ in the limit cases n = 0 and n = 1 (lines 1 to 3); when n ∈ N \ {0, 1}, it returns set Ξnψ that comprehends formulas (12) by building it in line 4 plus a [log n♩ iteration loop (lines 5 to 7). Both algorithms terminate in time O(log n) assuming propositional variables are all represented with a constant size.

ϕp :ξ1 2	1

1  ¬(ξZ  
18
⊕ξ p1 →0)
2

Φp :Z  1
↔¬ ξ4   ⊕ ξ0     ξ0 p
↔ Zp1

1  18
Z 1	Z 1
18	18
Z2 1	2

ξ0	↔ Z  1	ξ1 p1 ↔ ξ0 p1 ⊕ ξ0 p1

Z  1	18
18
Z2	Z2	Z2

ξ1	↔ ξ0
⊕ ξ0
ξ2 p1 ↔ ξ1 p1 ⊕ ξ1 p1

Z  1 18
2
Z  1 18
ξ3
Z  1 18
1
Z  1 18
↔ ξ2
Z  1 18
1
Z  1 18
⊕ ξ2
Z2	Z2
0  ↔ Z 1
1	6
6
ξ1  ↔ ξ0
Z2




⊕ ξ0

Z  1 18
4
Z  1
18
Z  1 18
3
Z  1
18
Z  1 18
3
Z  1
18
Z 1	Z 1
6	6
2  ↔ ξ1
1	1
6	6
Z 1
6
⊕ ξ1
1
6

Z 1 ↔¬ ξ2 ⊕ ξ0
	ξ0 2	1
↔¬ ξ2	⊕ ξ1 p1 → 0 

6	Z 1	Z 1
¬(ξZ  1 ⊕ξ p1 →0)
Z  1	Z2

6	6	18  Z2	18

ξ2 p1 ⊕ ξ1 p1 ↔ X2	ξ1 2	1
↔ ξ0 2	1
⊕ ξ0 2	1

Z2	Z2
¬(ξZ  1 ⊕ξZp1 →0)
¬(ξZ  1 ⊕ξZp1 →0)
¬(ξZ  1 ⊕ξZp1 →0)

Zp1 → Z 1
18	2
18	2
18	2

2
ϕp :¬ ξ2
6
⊕ ξ0
→ Zp2 

2	Z 1	Z 1	2
6	6

Φp :Z 1 ↔¬ ξ2
⊕ ξ0
	ξ1
↔ ξ0
⊕ ξ0

2  6	Z 1	Z 1
6	6

Z 1 ↔ ¬Z 1
Z 1	Z 1
6	6
ξ2  ↔ ξ1
Z 1
6
⊕ ξ1

2	2	Z 1
6
Z 1	Z 1
6	6

ξ1 p2
Z2
↔ X2	ξ0 p2
Z2
↔ Zp2

Zp2 → Z 1
ξ1 p
↔ ξ0 p
⊕ ξ0 p

2	2
0  ↔ Z 1
1	6
6
Z2 2
Z2 2
Z2 2


ϕp :ξ1 2	p3

3  ¬(ξ
1
6
→Z1 )

Φp :Z 1 ↔¬ ξ2
⊕ ξ0
	Zp3 → Z 1

3  6	Z 1	Z 1
6	6
0  ↔ Z 1
1	6
6
1

ξ0 p3
Z1
2

↔ Zp3

ξ1  ↔ ξ0
⊕ ξ0
ξ1 p3 ↔ ξ0 p3 ⊕ ξ0 p3

Z 1	Z 1
6	6
2  ↔ ξ1
1	1
6	6
Z 1
6
⊕ ξ1
1
6
Z1

ξ0 2
¬(ξZ 1
6
Z1

→Zp3 )
Z1
2  → Zp3
6

Z 1 ↔ ¬Z 1
ξ1 2
p3 ↔ ξ0 2
p3 ⊕ ξ0 2	p3

2	2	¬(ξZ 1 →Z1 )
6
¬(ξZ 1 →Z1 )
6
¬(ξZ 1 →Z1 )
6

ξ1 p3 ↔ X1
Z1
Table 3
Representations as in (13) for functions p#, p# and p#, where functions p1, p2 and p3 are from Example
1	2	3
4.1.



Algorithm 1 BINARY-F: computes formula ξnψ in (11) or 0 or ψ
Input: A natural number n and a formula ψ.
Output: Formula ξnψ.
1: if n =0 then
2:	return 0;
3: else if n =1 then
4:	return ψ;
5: end if
6: q := n, nk := 0, ξnψ := 0;
7: for k = 0,..., [log n♩ do
8:	nk := remainder from division of q by 2;
9:	q := quotient from division of q by 2;
10:	if nk =1 then
11:	ξnψ := ξk ⊕ ξnψ;
12:	end if
13: end for
14: return ξnψ;


Algorithm 2 BINARY-S: computes set Ξnψ in (12) or ∅
Input: A natural number n and a formula ψ.
Output: Set Ξnψ.
1: if n =0 or n =1 then
2:	return ∅;
3: end if
4: Ξnψ := {ξ0 ↔ ψ};
5: for k = 1,..., [log n♩ do
6:	Ξnψ := Ξnψ ∪ {ξk ↔ ξk—1 ⊕ ξk—1};
ψ	ψ	ψ
7: end for
8: return Ξnψ;

Algorithm 3 computes a representation modulo satisfiability for p#. It returns
⟨0, ∅⟩ in the limit case a0 = ··· = an = 0 (lines 1 to 3); otherwise it returns representation ⟨ϕp, Φp⟩ given in (13). From line 4 to line 15, the algorithm sets all P , N , αj, βj, and β, for j = 0,..., n, which are used to rewrite function p in terms of pP and pN as in Lemma 5.1. From line 16 to line 26, it writes formulas ϕP and ϕN and adds formulas in ΦP and ΦN to Φp. For J ∈ {P, N}, it works throughout

a |J| iteration loop where each iteration takes a coefficient aj
j
into account, where

it treats a0
0
(lines 18 to 21) separately from the others (lines 22 to 25). In lines 27

and 28 it finally writes formula ϕp and completes set Φp.
Theorem 5.6 Given a rational linear function p by its coefficients, a representation
⟨ϕp, Φp⟩ for p# may be computed in polynomial time by Algorithm 3.
Proof. Algorithm 3 builds representation ⟨ϕp, Φp⟩ in (13). So, its correctness fol- lows from Theorem 5.5. Let [0, 1]n be the domain of p and M the maximum size



Algorithm 3 REPRESENT-TL: computing representations for truncated linear functions	
Input: A linear function p given by its rational coefficients a0 , a1 ,..., an .
b0 b1	bn
Output: A representation ⟨ϕp, Φp⟩ for the truncated function p#.
1: if a1 = ··· = an =0 then
2:	return ⟨0, ∅⟩;
3: end if
4: P := ∅, N := ∅;
5: for j := 0,...,n do
6:	if aj > 0 then
7:	P := P ∪ {j}, αj := aj;
8:	else if aj < 0 then
9:	N := N ∪ {j}, αj := −aj;
10:	end if
11: end for

12: β := least integer greater than or equal to max{
13: for j ∈ P ∪ N do
14:	βj := β · bj;
15: end for
16: ϕP := 0, ϕN := 0, Φp := ∅;
17: for J = P, N do
18:	if 0 ∈ J then
19:	ϕJ := ϕJ ⊕ BINARY-F(α0,Z  1 );
β0
aj
j∈P bj
aj
j∈N bj

20:	Φp := Φp ∪ {Z  1  ↔ ¬BINARY-F(β0 − 1,Z  1 )}∪ BINARY-S(α0,Z  1 ) ∪
β0	β0	β0
BINARY-S(β0 − 1,Z  1 );
β0
21:	end if
22:	for j ∈ J \ {0} do
23:	ϕJ := ϕJ ⊕ BINARY-F(αj, Zp);
p

24:	Φp := Φp ∪ {Z  1
βj
↔ ¬BINARY-F(βj − 1,Z  1 ),	BINARY-F(βj, Zj ) ↔
βj

Xj,	Zp → Z  1 } ∪ BINARY-S(αj, Zp) ∪ BINARY-S(βj − 1,Z  1 ) ∪
j	βj	j	βj
BINARY-S(βj, Zp);
25:	end for
26: end for
27: ϕp := BINARY-F(β, ¬(ϕP → ϕN ));
28: Φp := Φp ∪ BINARY-S(β, ¬(ϕP → ϕN ));
29: return ⟨ϕp, Φp⟩;


of a binary representation for numbers among aj and bj; then the input size of p is at most 2(n + 1)M . The algorithm first calculates in polynomial time all β, αj and βj; let μ be the maximum size of a binary representation for numbers among β, αj and βj. Then, it proceeds to writing the representation which is made up of at
most 3(n + 1) propositional variables of the type Xj, Zp and Z  1 , and 2(n + 1)μ + μ
j	βj

propositional variables of the type ξk , a quantity polynomially proportional to the size of the input. Thus, the size of the representation for each propositional variable may be assumed to be a constant π also polynomially proportional to the size of the input. Next, the algorithm calculates formulas ϕP and ϕN and sets ΦP and ΦN in n + 1 steps; in each one it calculates the part associated to a coefficient αi . For
i
each part, computation takes polynomial time on π and at most three executions
of routines BINARY-F (Algorithm 2) and BINARY-S (Algorithm 1) with argument
⟨ν, P⟩, where ν is αi, βi or βi−1, which are already or may be quickly computed, and P is a propositional variable. In these cases BINARY-F and BINARY-S run in poly- nomial time on μ and π. The algorithm finishes calculating ϕp and Φp by running BINARY-F and BINARY-S with argument ⟨β, ¬(ϕP → ϕN )⟩. Now, BINARY-F runs in polynomial time on μ and π and BINARY-S runs in polynomial time on μ, π and the size of ¬(ϕP → ϕN ). After all, Algorithm 4 terminates in polynomial time.	2
We call REPRESENT-TL-F and REPRESENT-TL-S the routines that sepa- rately compute ϕp and Φp, respectively. Both may be easily derived from routine REPRESENT-TL in Algorithm 3.
The General Case
Given a rational McNaughton function formatted as in Section 4, we now compute a logical representation for it. Let f : [0, 1]n → [0, 1] be a rational McNaughton function in regional format with linear pieces:

p (x)= ai0 + ai1 x
+ ··· + ain x
,	(14)

i	bi0	bi1 1
bin n

for x = ⟨x1,..., xn⟩ ∈ [0, 1]n, aij ∈ Z, bij ∈ Z∗
and i = 1,..., m, with each piece

identical to f in region Ωi, for i = 1,..., m. We call ABOVE(pk,pi) the polynomial
routine that decides if linear piece pk is above a different linear piece pi over Ωi.

Let ⟨ϕp , Φp ⟩ be the representation for p#
given by Theorem 5.5, for i =

i	i	i
1,..., m. We define:
m	m
ϕ =   ϕΩi , with ϕΩi =   ϕpk ;	Φ =  Φpi ;	(15)
where k ∈ K if pk(x) ≥ pi(x), for all x ∈ Ωi. We are able to state the following representation result which is adapted from [17,18].
Lemma 6.1 Let f be a rational McNaughton function in regional format with linear pieces given by (14), and let ϕΩi be a formula and Φ a set as in (15). Then, v(ϕΩi ) ≤ f (v(X1),..., v(Xn)), for v ∈ ValΦ and i = 1,..., m.
Proof. Let v ∈ ValΦ and x0 = ⟨v(X1),..., v(Xn)⟩. In particular, v ∈ ValΦpi , for



ϕ:	(ϕp1 ∧ ϕp2 ∧ ϕp3 ) ∨ (ϕp1 ∧ ϕp2 ∧ ϕp3 ) ∨ (ϕp1 ∧ ϕp2 ∧ ϕp3 )

Φ:	Φp1 ∪ Φp2 ∪ Φp3

Table 4
Representation as in (15) for function f from Example 4.1.


i ∈ K and, by Theorem 5.5,

v(ϕΩ )= min p#(x0).

i	k∈K k
If x0 ∈ Ωi, then v(ϕΩ ) ≤ p#(x0)= pi(x0)= f (x0). On the other hand, if x0 ∈/ Ωi,
i	i
there is some k0 such that x0 ∈ Ωk0 . In the case pk0 (x) ≥ pi(x), for all x ∈ Ωi,
then k0 ∈ K and v(ϕΩ ) ≤ p# (x0)= pk (x0)= f (x0). In the case there is xj ∈ Ωi
i	k0	0
such that pk (xj) < pi(xj), continuity of f yields that there is t ∈ K such that
pt(x) ≥ pi(x), for all x ∈ Ωi and pt(x) ≤ pk0 (x), for all x ∈ Ωk0 . Therefore,
v(ϕΩ ) ≤ p#(x0) ≤ pt(x0) ≤ pk (x0)= p# (x0)= f (x0).	2
i	t	0	k0
Theorem 6.2 Any rational McNaughton function may be represented by ⟨ϕ, Φ⟩
in (15).
Proof. First note that any rational McNaughton function may be put in regional format as showed in Section 4. For ⟨x1,..., xn⟩∈ [0, 1]n, define a valuation v ∈ ValΦ
such that v(Xj)= xj and v(Zpi )=  xj , for i = 1,..., m,j = 1,..., n, v(Z  1  )=  1  ,

j	βij
βij
βij

for i = 1,..., m,j = 0,..., n, v(ξ0 )= v(ψ), and v(ξk )= min(1, v(ξk—1)+ v(ξk—1)),
ψ	ψ	ψ	ψ
for k = 1,..., [log n♩, for any nψ that occurs in ϕ and Φ. Now, let v, vj ∈ ValΦ
such that v(Xj) = vj(Xj), for j = 1,..., n. In particular, v, vj ∈ ValΦ , for
i = 1,..., m, and, by Theorem 5.5, v(ϕp ) = vj(ϕp ), for i = 1,..., m. Therefore,
i	i
v(ϕ)= vj(ϕ) and Xn determines ϕ modulo Φ-satisfiable. Finally, suppose v ∈ ValΦ.
There is some k0 ∈ K such that ⟨v(X1),..., v(Xn)⟩ ∈ Ωk0 . Note that v(ϕΩk ) = 
f (v(X1),..., v(Xn)). Therefore,


f (v(X1),..., v(Xn)) =  max
i=1,...,m
v(ϕΩi )= v(ϕΩk ),

by Lemma 6.1.	2
Table 4 shows how function f in Example 4.1 can be represented as in Theo- rem 6.2.
Algorithm 4 returns representation ⟨ϕ, Φ⟩ for function f with linear pieces given in (14). From line 1 to line 13, the algorithm writes formulas ϕΩi and the set Φ: it first computes formulas ϕpi (lines 2 to 5) by means of routine REPRESENT-TL-F and then it writes ϕΩi (lines 7 to 11) by means of routine ABOVE. It writes set Φ computing each Φpi by means of routine REPRESENT-TL-S (line 12). In line 14 it writes formula ϕ.



Algorithm 4 REPRESENT: computing representations for rational McNaughton functions	 Input: A rational McNaughton function f in regional format given by its linear

pieces coefficients a10 ,..., a1n ,. . . , am0 ,..., amn
and regions Ω1,..., Ωm.

b10
b1n
bm0
bmn

Output: A representation ⟨ϕ, Φ⟩ for the rational McNaughton function f .
1: Φ := ∅;
2: for i = 1,...,m do
3:	ϕp := REPRESENT-TL-F( ai0 ,..., ain );

i
4:	ϕΩi := ϕpi ;
5: end for
6: for i = 1,...,m do
bi0
bin

7:	for k = 1,...,i − 1,i + 1,...,m do 8:		if ABOVE(pk, pi)= true then 9:			ϕΩi = ϕΩi ∧ ϕpk ;
10:	end if
11:	end for
12:	Φ :=Φ ∪ REPRESENT-TL-S( ai0 ,..., ain );

13: end for
14: ϕ := ϕΩ1 ∨· · · ∨ ϕΩm ;
15: return ⟨ϕ, Φ⟩;
bi0
bin



Theorem 6.3 Given a rational McNaughton function f in regional format, a log- ical representation for it may be computed in polynomial time on the size of f by Algorithm 4.
Proof. Algorithm 4 builds representation ⟨ϕ, Φ⟩ in (15). So, the algorithm correct- ness follows from Theorem 6.2. The size of f is the space necessary to storage the coefficients of its m linear pieces p1,..., pm and the regions Ω1,..., Ωm. The algo- rithm first calculates m representative formulas ϕpi by REPRESENT-TL-F, which takes polynomial time on the size of f by Theorem 5.6. Then, it builds formulas ϕΩi from the already built representative formulas in m2 steps; in each of these steps it runs routine ABOVE in assumed polynomial time. Along with the above computa- tion, the algorithm also builds set Φ in m steps; in each one it calculates set Φpi by REPRESENT-TL-S, which takes polynomial time on the size of f by Theorem 5.6. Finally, the algorithm calculates ϕ from formulas ϕΩi already computed. After all, Algorithm 4 terminates in polynomial time.	2
Conclusions
We introduced a way to represent functions by logical formulas in L- ukasiewicz
Infinitely-valued Logic — the representation modulo satisfiability —, and we showed by a constructive proof that all rational McNaughton functions can be represented this way. Moreover, we derive an algorithm that builds such a representation in polynomial time on the size of the function. For the future, we hope to couple this algorithm with algorithms that approximate (normalized) continuous functions by

rational McNaughton functions; also, apply these approximations to the study of real systems such as neural networks through automated reasoning techniques.

References
Aguzzoli, S., The complexity of McNaughton functions of one variable, Advances in Applied Mathematics 21 (1998), pp. 58–77.
Aguzzoli, S. and D. Mundici, Weierstrass approximations by L- ukasiewicz formulas with one quantified variable, in: Proceedings 31st IEEE International Symposium on Multiple-Valued Logic, IEEE, 2001,
pp. 361–366.
Aguzzoli, S. and D. Mundici, “Weierstrass Approximation Theorem and L- ukasiewicz Formulas with one Quantified Variable,” Physica-Verlag HD, Heidelberg, 2003 pp. 315–335.
Amato, P., A. Di Nola and B. Gerla, Neural networks and rational L- ukasiewicz logic, in: 2002 Annual Meeting of the North American Fuzzy Information Processing Society Proceedings. NAFIPS-FLINT 2002 (Cat. No. 02TH8622), IEEE, 2002, pp. 506–510.
Amato, P. and M. Porto, An algorithm for the automatic generation of a logical formula representing a control law, Neural Network World 10 (2000), pp. 777–786.
Bofill, M., F. Manya, A. Vidal and M. Villaret, Finding hard instances of satisfiability in L- ukasiewicz logics, in: Multiple-Valued Logic (ISMVL), 2015 IEEE International Symposium on, IEEE, 2015, pp. 30–35.
Cignoli, R., I. D’Ottaviano and D. Mundici, “Algebraic Foundations of Many-Valued Reasoning,” Trends in Logic, Springer Netherlands, 2000.
Esteva, F., L. Godo and F. Montagna, The L- Π and L- Π 1 logics: two complete fuzzy systems joining L- ukasiewicz and product logics, Archive for Mathematical Logic 40 (2001), pp. 39–67.
Finger, M. and S. Preto, Probably half true: Probabilistic satisfiability over L- ukasiewicz infinitely-valued logic, in: D. Galmiche, S. Schulz and R. Sebastiani, editors, Automated Reasoning (2018), pp. 194–210.
Finger, M. and S. Preto, Probably partially true: Satisfiability for L- ukasiewicz infinitely-valued
probabilistic logic and related topics, Journal of Automated Reasoning (2020).
URL  https://doi.org/10.1007/s10817-020-09558-9

Gerla, B., Rational L- ukasiewicz logic and DMV-algebras, Neural Network World 11 (2001), pp. 579– 594.
Leshno, M., V. Y. Lin, A. Pinkus and S. Schocken, Multilayer feedforward networks with a nonpolynomial activation function can approximate any function, Neural Networks 6 (1993), pp. 861– 867.
URL www.sciencedirect.com/science/article/pii/S0893608005801315
McNaughton, R., A theorem about infinite-valued sentential logic, Journal of Symbolic Logic 16 (1951),
pp. 1–13.
Mundici, D., Satisfiability in many-valued sentential logic is NP-complete, Theoretical Computer Science 52 (1987), pp. 145–153.
Mundici, D., A constructive proof of McNaughton’s theorem in infinite-valued logic, The Journal of Symbolic Logic 59 (1994), pp. 596–602.
Rudin, W., “Principles of Mathematical Analysis,” McGraw-Hill, New York, 1976, 3 edition.
Tarela, J., E. Alonso and M. Mart´ınez, A representation method for PWL functions oriented to parallel processing, Mathematical and Computer Modelling 13 (1990), pp. 75 – 83.
URL www.sciencedirect.com/science/article/pii/089571779090090A

Tarela, J. and M. Mart´ınez, Region configurations for realizability of lattice piecewise-linear models, Mathematical and Computer Modelling 30 (1999), pp. 17–27.
