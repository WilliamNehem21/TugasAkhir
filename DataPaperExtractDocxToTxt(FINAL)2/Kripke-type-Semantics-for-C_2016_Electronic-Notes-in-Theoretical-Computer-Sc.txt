Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 328 (2016) 17–29
www.elsevier.com/locate/entcs
Kripke-type Semantics for CG′
Ver´onica Borja Mac´ıas1 Miguel P´erez-Gaspar2
Facultad de Ciencias F´ısico-Matem´aticas
C.U. Avenida San Claudio y 18 Sur, Colonia San Manuel, Puebla, Pue. 72570 M´exico



Abstract
In [11] Osorio et al. introduced a paraconsistent three-valued logic, the logic CG′

which was named after

the logic G′
due to the close relation between them. Authors defined CG′
via the three-valued matrix

that defines G′
but changing the set of designated truth values. In this article we present a brief study of

the Kripke-type semantics for some logics related with CG′
before constructing a Kripke-type semantics

for it.
Keywords: Many-valued Logics, Paraconsistent Logics, Kripke-Type Semantics


Introduction
Nowadays non-classical logics, particularly intuitionistic logic and paraconsistent logics, have become a fundamental and powerful tool for knowledge representation and human-like reasoning. In general there are a lot of applications of these logics in several topics as we can see in [1,2], then it is important to study this kind of logics to have a better understanding of their behavior and properties.
Regardless of what logical system you want to study, it is possible to take two different approaches: the syntactic one or the semantic one. Both approaches are methods to find out the logical truths as well as the consequence relations of a given logical system. In this article we will proceed in a semantical way, and we will only consider two kinds of semantics: many-valued semantics and Kripke-type semantics.
As B´eziau points out in [3] many-valued semantics and Kripke-type semantics are generalizations of the classical semantics in two different and “opposite” ways.

1 Email: vero0304@gmail.com
2 Email: miguetux@hotmail.com

http://dx.doi.org/10.1016/j.entcs.2016.11.003
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

On the one hand, many-valued semantics try to keep the idea of homomorphisms between the language structure and an algebra of truth functions, and allow more than two values in the algebra domain. On the other one Kripke-type semantics maintain only two truth values, but a relation between valuations is introduced. These semantics could seem philosophically controversial but they are powerful and useful technical tools. In fact they can be used to give a mathematical support to basic philosophical notions.
The existence of one type of semantics for a given logical system does not guar- antee the existence of other types of semantics for it. In fact even if there is certain kind of semantics for a system, very similar systems may not share this property.

Basic Concepts
Let us start by introducing the syntax of the language considered in this article as well as some definitions. We suppose that the reader has some familiarity with basic concepts related to mathematical logic such as those given in the first chapter of [9].

Logical System
We consider a formal language L built from: an enumerable set of atoms (denoted as p, q, r,.. .), the set of atoms is denoted as atom(L) and the set of connectives C = {∧, ∨, →, ¬}. Formulas are constructed as usual and will be denoted as lowercase Greek letters. The set of all formulas of an language L is denoted as Form(L). Theories are sets of formulas and will be denoted as uppercase Greek letters.
A logic is simply a set of formulas that is closed under Modus Ponens (MP) and substitution. The elements of a logic X are called theorems and the notation
▶X ϕ is used to state that the formula ϕ is a theorem of X (i.e. ϕ ∈ X).
We say that a logic X is weaker than or equal to a logic Y if X ⊆ Y . Sometimes we refer to this as Y extends X. Similarly, we say that X is stronger than or equal to Y if Y ⊆ X.
In this article we will work with multiple logical systems so it is appropriate to specify the names we will use for some systems.
Pos is the positive fragment of intuitionistic logic.
Cω is the extension of logic Pos obtained by adding the schemes Cw1 := ϕ∨ ¬ϕ
and Cw2 := ¬¬ϕ → ϕ.
Int is the intuitionistic logic and it is obtained by adding the schemes Int1 := (ϕ → ψ) → ((ϕ → ¬ψ) → ¬ϕ) and Int2 := ¬ϕ → (ϕ → ψ) to the logic Pos.

G3 is the three-valued G¨odel logic and it is obtained by adding the scheme G3 := (¬ψ → ϕ) → (((ϕ → ψ) → ϕ) → ϕ) to the logic Int.

Semantics
There are different ways to define the semantics of a logic, in the case of non-classical logics the range is very wide. As we said, we will focus only on two types multi- valued semantics and Kripke-type semantics. Let us see some general notions about these semantics.

Multi-valued Semantics
The more adequate manner to define the multi-valued semantics of a logic is by using a matrix.
Definition 3.1 Given a logic L in the language L, the matrix of L is a structure
M := ⟨D, D∗,F⟩:
D is a non-empty set of truth values (domain).
D∗ is a subset of D (set of designated values).
F := {fc|c ∈ C} is a set of truth functions, with a function for each logical connective in L.
Definition 3.2 Given a logic L in the language L,a valuation or an interpretation
is a function t : atom(L) → D that maps the atoms to elements in the domain.
An interpretation t can be extended to a one function t : Form(L) → D as usual, i.e. applying recursively the truth functions of logical connectives in F . The interpretations allow us to define the notion of validity in this type of semantics as follows:
Definition 3.3 Given a formula ϕ and an interpretation t in a logic L, we say that the formula ϕ is valid under the interpretation t in the logic L, if t(ϕ) ∈ D∗ and we denote it by t ▶L ϕ.
In this case the validity depends on the interpretation, but if we want to find the “logical truths” of the system then the validity should not depend on the inter- pretation, in other words we have:
Definition 3.4 Given a formula ϕ in the language of a logic L, we say that this is a tautology in L (or simply it is valid) if for every possible interpretation, the formula ϕ is valid and we denote this by ▶L ϕ.
When one defines a logic via a multi-valued semantics it is usual to define the set of theorems of the logic as the set of tautologies that are obtained from the multi-valued semantics, i.e. ϕ ∈ L iff ▶L ϕ.

Kripke-type Semantics
Kripke semantics are also known as relational semantics or frame semantics or pos- sible world semantics. This semantics were developed by Saul Kripke and Andr´e Joyal the late 1950s. Kripke semantics for modal logics was created first and sub- sequently Kripke semantics for intuitionistic logic. Actually, the creation of these semantics was a watershed in the study of the model theory for non-classical logics.
Definition 3.5 A Kripke model for a logic L in the language L is a triple M =
⟨W, R, v⟩ where:
W is a non-empty set (universe).
R is a binary relation on W (accessibility relation).
v is a valuation in M, i.e., is a function v : atom(L) → P(W ).
Once a model is defined it is necessary to establish a relation between the model and the formulas in order to state which formulas are valid in the model and which ones are not.
Definition 3.6 [Modeling relation] Given an atom p in a logic L and a point w in a model M, we say that “p is true in w in M” if w ∈ v(p) and is denoted as:
(M, w) ▶L p
If ϕ ∈ Form(L) the modeling relation is defined recursively depending on the connectives in L and the logic in question.
In general, the notion of modeling is only an intermediate step to define the notion of validity in this type of semantics.
Definition 3.7 A formula ϕ is said to be valid on a model M for logic L, if ϕ is valid in all points x in M and we denote it by M |=L ϕ.
Depending on the logic that we wish to characterize different conditions will be imposed on:
Universe (W ).
Accessibility relation (R).
Valuation (v).
Modeling relation (▶).


Logic G′
In [4] Carnielly and Marcos define Gj


as a paraconsistent logic and use it only as

a tool to prove that (ϕ ∨ (ϕ → ψ)) is not a theorem of Cω (the weakest of the paraconsistent logics defined by da Costa et. al [6]). In [12,11] Osorio et al. define
j by means of its multi-valued semantics. The matrix of Gj logic is given by:
M = ⟨D, D∗,F⟩ where: the domain is D = {0, 1, 2} and the set of designated values




Fig. 1. Kripke model for G3.
is D∗ = {2} and the set F of truth functions for connectives ∧, ∨, → and ¬ consists of the functions shown in Table 1.


Table 1
Truth functions of connectives Λ, V, → and ч in G′ .

As we said, we are interested in the study of certain logical systems related to

CGj , this is the case of Gj . We present here a semantical approach for Gj
but the

3	3	3
reader may be interested in other approaches e.g. Hilbert-type axiomatizations, for
more references see [10].

If we wish to obtain a Kripke-type semantics for CGj
we can begin our labor

by observing Kripke-type semantics for some logical systems closely related to this logic.
Kripke-type semantics for Int
Let us start by defining Kripke models for intuitionistic logic.
Definition 4.1 A Kripke model for Int is a structure ⟨W, R, v⟩, where:
W is a non-empty set of worlds.
R is a relation on the worlds that is reflexive, transitive and anti-symmetric.
v is a valuation function of atom(L) to P(W ). Given a valuation and a point w
in W we define the function vw : atom(L) → {0, 1} as:
v (p)=	1	if w ∈ v(p)
0	otherwise
The valuation must satisfy the following restriction for each atom p: If wRwj and vw(p)=1 then vw′ (p)= 1.

The latter restriction imposed on valuations is called hereditary property (Heredity Constraint or Monotonicity). As we can see in Proposition 2.1 in [5] hereditary property extends to all formulas in Kripke models for Int.
Once the structure of a given Kripke-type model is defined it is necessary to set up the modeling relation.
Definition 4.2 Let M = ⟨W, R, v⟩ be a Kripke model for Int, w ∈ W and ϕ a formula:
If ϕ := p is an atom, from Definition 3.6 we have that:
(M, w) ▶Int p iff w ∈ v(p).
If ϕ is not an atom the modeling relation is defined recursively as: Let γ, ψ be formulas and for all worlds w ∈ W :
(M, w) ▶Int γ ∧ ψ iff (M, w) ▶Int γ and (M, w) ▶Int ψ.
(M, w) ▶Int γ ∨ ψ iff (M, w) ▶Int γ or (M, w) ▶Int ψ.
(M, w) ▶Int γ → ψ iff for all wj such that wRwj, if (M, wj) ▶Int γ then (M, wj) ▶Int ψ.
(M, w) ▶Int ¬γ iff for all wj such that wRwj, (M, wj) /▶Int γ.
Kripke-type semantics for G3
As it is well-known G3 is an extension of Int, and Kripke-type semantics for both systems are related, in fact the Kripke models for G3, is just a subset of the Kripke models for Int.
Definition 4.3 A Kripke model for G3 is a Kripke model for Int, M = ⟨W, R, v⟩, with the followings restrictions:
W is a set of cardinality two.
R is a linear order relation.
Then to depict a Kripke model for G3 is an easy task, it is just a directed graph where worlds in W are the nodes, the relation R corresponds to the graph’s edges, in this case there are two nodes as shown in Figure 1. Nodes in the figure have been labeled as H and T since it is common to refer to these points (worlds) as “Here” and “There”. In fact G3 is also known as HT or Here and There Logic due to the characterization in terms of the Kripke models.
In this case, the modeling relation remains without changes respect to the intu- itionistic case. Usually a subscript G3 is used to identify that the modeling relation is based on a Kripke model for G3, i.e. ▶G3
Kripke-type semantics for daC
In [13] Priest states that one of the motivations of da Costa in order to build the paraconsistent logic Cω was dualize the negation of intuitionistic logic. Intuitionis-

tic logic is a logic that allows for “truth value gaps”; for example, the Law Excluded Middle fails. The logic Cω achieves this but with clear costs; for example substitu- tion of provable equivalents fails. Da Costa proceeded axiomatically, preserving the positive part of intuitionistic logic, and changing the axioms of negation. But the various semantics for intuitionistic logic suggest other ways of pursuit da Costa’s goal. Evidence of this is the paraconsistent logic created by Priest that arises when dualizing the modeling conditions for the negation in Kripke semantics for intu- itionistic logic. This new system is called da Costa logic daC. Let us see the characterization of this logic in terms of Kripke models.
Definition 4.4 A Kripke model for daC is an structure ⟨W, R, v⟩, where:
W is a non-empty set.
R is a relation on the worlds that is reflexive and transitive.
v is a valuation function of atom(L) to P(W ). Given a valuation v and a point
w in W , we define
v (p)=	1	if w ∈ v(p)
0	otherwise
and hereditary property must hold, i.e. for each atom p:
If wRw  and vw(p)=1 then vw′ (p)= 1.
As we can see in [13] the hereditary property extends to all formulas in Kripke models for daC.
The modeling relation for daC is defined in the same way as for intuitionistic logic except for the negation connective as we can see in the following definition.
Definition 4.5 Let M = ⟨W, R, v⟩ be a Kripke model for daC, w ∈ W and ϕ a formula:
If ϕ := p is an atom, from Definition 3.6 we have that:
(M, w) ▶daC p iff w ∈ v(p).
If ϕ is not an atom, the modeling relation is defined recursively as in Definition
4.2 for connectives ∧, ∨, → and the condition 4 for negation is dualized in this case, i.e.
4’. (M, w) ▶daC ¬ϕ iff there exists wj such that wjRw, (M, wj) /▶daC ϕ.
In other words definitions of Kripke model for Int and daC, differ only in the modeling condition for the negation and one is dual of the other.


Kripke-type semantics for Gj
In [8] Osorio et al. demonstrated that the logic Gj

is an extension of the logic daC

so it is natural to consider that Kripke models for Gj
are a sub collection of the

Kripke models for daC. On the other hand as we can see for the case of G3 the Kripke models are Kripke models for intuitionistic but only those whose cardinality is two and the relation is a linear order, a combination of both ideas give us a characterization for Gj .
In fact, we can also find at the end of section 2 of [7] a brief study of extensions of fragments of Heyting-Brouwer Logic. This is the case of the family of logics daCGn, each an extension of daC characterized by a Kripke frame for daC which
is linearly ordered and has n − 1 points. We have that Gj corresponds to daCG3,

and clearly the characterizations agree.
Definition 4.6 A Kripke model for Gj

is a Kripke model for daC, M = ⟨W, R, v⟩,

with the following restrictions:
W is a set of cardinality two.
R is a linear order relation on W .

The modeling relation ▶ ′
3
is demarcated by the Definitions 4.5 and 4.6.

In analogy with the logic G3 we can refer to the worlds in a Kripke model for
j respectively as H (Here) and T (There).
Let us see now that in fact the set of theorems (tautologies) in the multi-valued
logic Gj corresponds to the set of valid formulas in Kripke models for Gj . For this
we need the following definition and proposition. Due to the hereditary property imposed on Kripke models for Gj , the rank of valuation functions do not include

the set {H}, in other words a valuation in a Kripke model for Gj
only assigns ∅,

{T} or {H, T}.
Definition 4.7 Let f : D→ {∅, {T}, {H, T}} be a function defined as follow

The function f of the Definition 4.7 is a bijective function, whereby there exists the inverse function namely f—1.
Proposition 4.8 If there exists an interpretation t such that t(ϕ)= a, then exists a valuation v such that v(ϕ)= f (a). In the same way if there exists a valuation v such that v(ϕ)= b, then there exists an interpretation t such that t(ϕ)= f—1(b).
Proof. See Appendix 7.	2
Theorem 4.9 Let ϕ be a formula in the language of Gj , then:

▶ ′ ϕ iff for any Kripke model M for Gj
3
it holds that M ▶ ′ ϕ.
3

Proof. Both implications by contrapositive. Given a formula ϕ, it is not a tautology in Gj , equivalently there exist an interpretation such that v(ϕ) /= 2, by Proposition
4.8 this condition occurs if and only if there is a model in which the formula is not valid in all worlds.	2

Logic CG′
The logic CGj is a paraconsistent logic that extends Gj . The logical matrix of
CGj is given by D = {0, 1, 2}, D∗ = {1, 2} and the truth functions are those of Gj
that can be found in the Table 1. In other words we obtain the matrix of CGj by
adding 1 as designated value to the matrix of Gj .

Given the narrow relation between Gj
and CGj
is natural to think that, if

there is a Kripke-type semantics for the latter, it must be very similar to the one

of Gj . Actually, we can define the Kripke-type semantics for CGj
in two different

3
ways. The first one based on the semantics of Gj
3
and the second one redefining the

notion of validity as discussed below.


Semantics based on Gj
semantics

Definition 5.1 Let M = ⟨W, R, v⟩ be a Kripke model for Gj , w ∈ W and ϕ a formula. We define the modeling relation (denoted as ▶CG′ ) as follows:


(M, w) ▶CG′
ϕ if and only if there is wRwj
j	′ ϕ.
3

As we can see, the hereditary property also holds for ▶CG′ .
Theorem 5.2 If (M, x) ▶CG′  ϕ and xRy, then (M, y) ▶CG′  ϕ.
Proof. See Appendix 7.	2
The following theorem establishes an equivalence between multi-valued seman- tics and Kripke semantics for CGj .
Proposition 5.3 Let ϕ be a formula on the language of CGj . There exists an interpretation t : L → {0, 1, 2} such that t(ϕ)= 0, if and only if there is a Kripke

model for CGj
whose valuation v is such that v(ϕ)= ∅.

Proof. The proof is by induction on the length of the formula ϕ, it is similar to the Proposition 4.8.	2
Theorem 5.4 Let ϕ be a formula in the language of CGj , then:

▶CG′
ϕ if and only if for any Kripke model M for CGj
it holds that M ▶CG′ ϕ.

Proof. The proof is similar to the proof of Theorem 4.8 in this case using Propo- sition 5.3.	2

Semantics changing the notion of validity
An alternative way of defining the modeling relation for CGj
is to consider that

the kripke models for CGj
are those for Gj
but changing Definition 3.7 by the

following one.

Definition 5.5 A formula ϕ is said to be e-valid 3 on a model M for logic CGj if
exists a point x in M such that (M, x) |= ′ ϕ.
3
It is an easy task to check that this new definition changing the notion of validity agrees with the previous one, as is stated in the following lemma.
Lemma 5.6 Let ϕ be a formula in the language of CGj , then:

▶CG′
ϕ if and only if for any Kripke model M for CGj
it holds that ϕ is e-valid.

Conclusions
We studied some non-classical logics from a semantic point of view. First we did a study of the semantics of some logics such as Int, G3 and daC. After that, we

focused in Gj
and we obtained a characterization of it in terms of Kripke models.

Finally, using this result and making some variations to some of the definitions we

got a characterization of CGj
using Kripke models. Thanks to the Kripke-type

semantics for these logics, we got a new tool that can help us to have a better understanding of these paraconsistent logics. However, there are some important issues related to these systems that need to be studied. For example in the syntacti-

cal approach there is a Hilbert-type characterization for Gj
but an axiomatization

of CGj
is still missing.

Appendix A
Proof. Proposition 4.8
The proof is by induction on the length of the formula ϕ.
If ϕ := p and p is an atom, the result is straightforward from Definition 4.7.
I.H. Suppose that ϕ has length n, then the translation is satisfied. Let ϕ be a formula of length n + 1, then we have the following:
If ϕ := ψ ∨ γ, then
[⇒] t(ϕ) = 0 if and only if t(ψ) = t(γ) = 0, where ψ and γ have length less than or equal n. So, by inductive hypothesis v(ψ) = v(γ) = ∅. Therefore v(ψ ∨ γ)= v(ϕ)= ∅.
[⇐] Suppose that v(ψ ∨ γ) = ∅, then v(ψ) = v(γ) = ∅. So, by inductive hypothesis t(ψ)= t(γ) = 0. Hence t(ψ ∨ γ)= 0.
[⇒] t(ϕ) = 1 if and only if max{t(ψ), t(γ)} = 1. Suppose without loss of generality that t(ψ) = 1. So, by inductive hypothesis v(ψ)= {T}, thus v(ψ ∨ γ)= {T}.

3 The use of the letter e in e-valid is to highlight that the characterization of the validity depends on an existential quantifier and to distinguish from the notion of validity given in Definition 3.7

[⇐] Suppose that v(ψ ∨ γ) = {T}, then v(ψ) = {T} or v(γ) = {T}. So, by inductive hypothesis v(ψ) = {T}, hence v(γ) = {T} or v(γ) = ∅, then by inductive hypothesis t(ψ)=1 and (t(γ)=1 o t(γ) = 0). So t(ψ ∨ γ)= 1.
[⇒] t(ϕ) = 2 if and only if max{t(ψ), t(γ)} = 2. Suppose without loss of generality that t(ψ)= 2, then v(ψ)= {H, T}, so v(ψ ∨ γ)= {H, T}.
[⇐] Suppose that v(ψ ∨ γ) = {H, T}, then T ∈ v(ψ) o T ∈ v(γ). Suppose without loss of generality that T ∈ v(ψ), then v(ψ)= {H, T}. So, by inductive hypothesis t(ψ) = 2. Hence t(ψ ∨ γ)= 2.
If ϕ := ψ ∧ γ the proof is analogous to the disjunction case.
If ϕ := ψ → γ, then
[⇒] t(ϕ) = 0 if and only if t(ψ) ∈ {1, 2} y t(γ)= 0, then
t(ψ)=1 and t(γ)= 0, then v(ψ)= {T} and v(γ)= ∅, therefore vH (ψ → γ)= 0 and vT (ψ → γ)= 0. So v(ψ → γ)= ∅.
t(ψ)=2 and t(γ)= 0, then v(ψ)= {H, T} and v(γ)= ∅, then vH (ψ → γ)=0 and vT (ψ → γ) = 0. Hence v(ψ → γ)= ∅.
[⇐] Suppose that v(ψ → γ) = ∅.  vT (ψ → γ) = 0, then vT (ψ) = 1 and vT (γ) = 0, therefore v(γ)= ∅ and ∅ /= v(ψ) ⊆ {H, T} by inductive hypothesis t(γ)=0 and t(ψ) ∈ {1, 2}, hence t(ψ → γ)= 0.
[⇒] t(ϕ) = 1 if and only if t(ψ) = 2 y t(γ) = 1, then v(ψ) = {H, T} and v(γ)= {T}, therefore vH (ψ → γ)=0 and vT (ψ → γ)= 0. So v(ψ → γ)= ∅. [⇐] Suppose that v(ψ → γ) = {T}, then vH (ψ → γ) = 0 i.e., vH (ψ) = 1 and vH (γ) = 0 and vT (ψ → γ) = 1. Furthermore vH (ψ) = 1, then vT (ψ) = 1 = vT (γ). Then v(ψ)= {H, T}, v(γ)= {T}. So, by inductive hypothesis t(ψ)=2 y t(γ) = 1. Hence t(ψ → γ)= 1.
[⇒] If t(ϕ) = 2 then we have four sub-cases:
If t(ψ) = t(γ) = 0, then v(ψ) = v(γ) = ∅, then vH (ψ → γ) = 1 and vT (ψ →
γ)= 1. So v(ψ → γ)= {H, T}.
If t(ψ)=0 and t(γ)= 1, then v(ψ)= ∅ and v(γ)= {T}, thus vH (ψ → γ)=1 and vT (ψ → γ)= 1. So v(ψ → γ)= {H, T}.
If t(ψ) = 1 and t(γ) = 1, then v(ψ) = {T} y v(γ) = {T}, therefore vH (ψ →
γ)=1 and vT (ψ → γ)= 1. So v(ψ → γ)= {H, T}.
	If t(ψ) ∈ {0, 1, 2} and t(γ)= 2, then v(γ)= {H, T}. So v(ψ → γ)= {H, T}. [⇐] Suppose that v(ψ → γ)= {H, T}, then vH (ψ → γ)=1 and vT (ψ → γ)= 1. Then we have three sub-cases:
If v(ψ) = {H, T}, then v(γ) = {H, T}, therefore t(ψ) = t(γ) = 2. So t(ψ →
γ)= 2.
If v(ψ) = {H}, then ∅ /= v(γ) ⊆ {H, T}. So, by hypothesis t(ψ) = 1 and
t(γ) ∈ {1, 2}. Hence t(ψ → γ)= 2.
If v(ψ)= ∅, then by inductive hypothesis t(ψ)=0 and t(ψ → γ)= 2.
If ϕ := ¬ψ, then
[⇒] If t(ϕ) = 0, then t(ψ) = 2. So, by inductive hypothesis v(ψ) = {H, T}, therefore vH (¬ψ)=0= vT (¬ψ) since there is no evidence below H nor below T that ψ is false.
[⇐] If v(ϕ)= ∅, then vH (¬ψ)= vT (¬ψ)= F . So, there is no evidence in H or

T of ψ is false. Hence vH (ψ)= vT (ψ)= V and v(ψ)= {H, T}. So, by inductive hypothesis t(ψ) = 2 and finally t(¬ψ)= 0.
[⇒] If t(ϕ) = 2, then t(ψ) ∈ {0, 1}. So, by inductive hypothesis v(ψ) = ∅ or v(ψ)= {T}, then vH (ψ)= 0. So vH (¬ψ)= vT (¬ψ)= 1, then v(¬ψ)= {H, T}. [⇐] If v(ϕ) = {H, T}, then there is evidence below H and T that ψ is false, then vH (ψ) = 0, therefore v(ψ)= ∅ and by inductive hypothesis t(ψ)=0 and then we have that t(ϕ)= 2.
It is impossible that v(ϕ)= {T} since v(ϕ)= {T} then vT (¬ψ) = 1, i.e. there is evidence below T of ψ is false, then vH (ψ) = 0. Then vH (¬ψ) = 1. So v(¬ψ)= {H, T}.
2


Proof. Theorem 5.2
Suppose that (M, x) ▶CG′

ϕ and xRy. To proof that (M, y) ▶CG′  ϕ.

The proof is by induction on the length of the formula ϕ.
ϕ := p, where p is an atomic formula, then we have two cases:
If x = w, then we have two sub-cases:

y = w. As (M, x) ▶CG′
p, then there is a wRw∗ such that (M, w∗) ▶ ′ p
3

and as x = w = y, let w∗ = y. Hence (M, y) ▶CG′ p.
j	∗	3	∗

y = w . As (M, x) ▶CG′
p, there is a wRw
such that (M,w ) ▶ ′
3
p, then

we have two cases:
If w∗ = w, then v(p) = {w, wj}. So y = wj ∈ v(p), therefore (M, y) ▶ ′  p.
3
Hence (M, y) ▶CG′  p.
∗	j	3 j
If w = w , then {w }∈ v(p), therefore (M, y) ▶CG′ p.

x = wj we have a case:
y = wj, then (M, wj) ▶ ′
3
3

p. Hence (M, wj) ▶CG′  p.

I.H. suppose that the property holds for formulas less complex than ϕ.
ϕ := ψ1 ∧ ψ2. As (M, x) ▶CG′  ψ1 ∧ ψ2 and xRy, we have two cases:

If x = w, then we have a case:
If y = w, by hypothesis (M, x) ▶CG′
ψ1 ∧ ψ2; i.e., (M, w) ▶CG′
ψ1 ∧ ψ2

equivalently (M, y) ▶CG′  ψ1 ∧ ψ2.
j	3
If x = w , then we have a case:
y = wj this case is analogous to 1.
ϕ := ψ1 ∨ ψ2 this case is similar to the conjunction.
ϕ := ψ1 → ψ2. As (M, x) ▶CG′  ψ1 → ψ2, then there is xRw∗ such that

(M, w∗) ▶G′
3
ψ1 → ψ2, we have two cases:

If w∗
3
= w then (M, w) ▶ ′
3
ψ1 → ψ2 and ▶G′
is monotonic (M, wj) ▶ ′
3
ψ1 →

ψ2. So (M, y) ▶CG′ ψ1 → ψ2.
∗	j	3	j

If w
= w , then (M,w ) ▶ ′
3
ψ1 → ψ2. So (M, y) ▶CG′
ψ1 → ψ2.

ϕ := ¬ψ1. As (M, x) ▶CG′ ¬ψ1 and xRy, we have the following:
j	3	∗	∗

x = w, y = w . As (M, w) ▶CG′
¬ψ1, then there is wRw
such that (M,w ) ▶ ′
3

¬ψ1, then we have two cases:
If w∗ = w, then (M, w∗) $ ′
3
ψ1. Note that w∗Rwj = y, then (M, wj) ▶G′
¬ψ1.

So (M, y) ▶CG′  ¬ψ1.
∗	j	3	j	j	j
If w  = w , then (M,w ) $G′ ψ1, this is, (M,w ) ▶G′ ¬ψ1. Also y = w , then

(M, wj) ▶CG′
3	3
¬ψ1.
2


References
Diderik Batens, Chris Mortensen, Graham Priest, and Jean Paul Van Bendegem. Frontiers of Paraconsistent Logic. Studies in logic and computation. Research Studies Press Limited, 2000.
Jean-Yves B´eziau. The future of paraconsistent logic. Logical Studies, 1999.
Jean-Yves B´eziau. The Age of Alternative Logics: Assessing Philosophy of Logic and Mathematics Today, chapter Many-Valued and Kripke Semantics, pages 89–101. Springer Netherlands, Dordrecht, 2006.
Walter A Carnielli and Joao Marcos. A taxonomy of c-systems. arXiv preprint math/0108036, 2001.
Alexander Chagrov. Modal Logic. Oxford logic guides. Clarendon Press, 1997.
Newton CA Da Costa et al. On the theory of inconsistent formal systems. Notre dame journal of formal logic, 15(4):497–510, 1974.
Thomas Macaulay Ferguson. Lukasiewicz negation and many-valued extensions of constructive logics. In 2014 IEEE 44th International Symposium on Multiple-Valued Logic, pages 121–127. IEEE, 2014.
Mauricio Osorio Galindo, Ver´onica Borja Mac´ıas, and Jos´e Ram´on Enrique Arrazola Ram´ırez. Revisiting da costa logic. Journal of Applied Logic, 16:111 – 127, 2016.
Elliott Mendelson. Introduction to mathematical logic. CRC press, 2009.
Mauricio Osorio, Jos´e R Arrazola, Jos´e L Carballido, and Oscar Estrada. Programas l´ogicos disyuntivos y la demostrabilidad de atomos en Cω. Proceedings of the WS of Logic, Language and Computation, CEUR Vol, 220.
Mauricio Osorio, Jos´e Luis Carballido, Claudia Zepeda, et al. Revisiting Z. Notre Dame Journal of Formal Logic, 55(1):129–155, 2014.
Mauricio Osorio Galindo and Jos´e Luis Carballido Carranza. Brief study of G’3 logic. Journal of Applied Non-Classical Logics, 18(4):475–499, 2008.
Graham Priest. Dualising intuitionictic negation. Principia, 13(2):165, 2009.
