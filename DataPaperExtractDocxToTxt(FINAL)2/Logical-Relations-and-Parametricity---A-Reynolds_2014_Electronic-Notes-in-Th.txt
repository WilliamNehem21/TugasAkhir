Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 303 (2014) 149–180
www.elsevier.com/locate/entcs
Logical Relations and Parametricity -
A Reynolds Programme for Category Theory and Programming Languages
Claudio Hermida1 Uday S. Reddy2
University of Birmingham
Edmund P. Robinson3
Queen Mary, University of London
Dedicated to the memory of John C. Reynolds, 1935-2013

Abstract
In his seminal paper on “Types, Abstraction and Parametric Polymorphism,” John Reynolds called for ho- momorphisms to be generalized from functions to relations. He reasoned that such a generalization would allow type-based “abstraction” (representation independence, information hiding, naturality or parametric- ity) to be captured in a mathematical theory, while accounting for higher-order types. However, after 30 years of research, we do not yet know fully how to do such a generalization. In this article, we explain the
problems in doing so, summarize the work carried out so far, and call for a renewed attempt at addressing the problem.
Keywords: Universal algebra, Category Theory, Homomorphisms, Logical Relations, Natural Transformations, Parametric polymorphism, Relational Parametricity, Data abstraction, Information hiding, Definability, Reflexive Graphs, Fibrations, Relation lifting.

Introduction
Starting with the pioneering work of Emmy Noether, Emil Artin and van der Waer- den in the 1930’s [51], homomorphisms have firmly established themselves as the foundation for modern algebra. In due course, they led to the formulation of cat- egory theory [10], whose central concept is that of “natural transformation,” em- bodying the principle of uniformity with respect to homomorphisms.

1 Email: claudio.hermida@gmail.com
2 Email: u.s.reddy@bham.ac.uk
3 Email: e.p.robinson@qmul.ac.uk

http://dx.doi.org/10.1016/j.entcs.2014.02.008
1571-0661/© 2014 Elsevier B.V. All rights reserved.

John Reynolds’s pioneering work on logical relations and relational parametric- ity [42] (with support from the earlier insights of Christopher Strachey, Dana Scott and Gordon Plotkin) casts doubt on this central place accorded to homomorphisms, and raises new questions. By a “Reynolds programme for category theory and pro- gramming languages,” we mean a programme to answer these questions and to carry out a thorough investigation of the relative place of homomorphisms and logical relations in the broader mathematical thought.
Let us first note the striking similarities in the pre-theoretic intuitions expressed for natural transformations and parametric polymorphism:
This exhibition of the isomorphism L ∼= T (T (L)) is “natural” in that it is given simultaneously for all
finite-dimensional vector spaces L.
Eilenberg and Mac Lane [10, p. 232]
Commutativity conditions like (49) ... play an important role in describing why a morphism ωA, defined for all modules A, is “natural,” that is, independent of artificial choices.
— Mac Lane and Birkhoff [26, p. 192]
In ad hoc polymorphism there is no single systematic way of determining the type of the result from the type of the arguments	Parametric polymorphism is more regular and may be illustrated by an
example. . . . We would like Map to work on all types of list,	so that Map would have to be polymorphic.
Christopher Strachey [49, Sec. 3.6.4]
Intuitively, a parametric polymorphic function is one that behaves the same way for all types, while an
ad hoc polymorphic function may have unrelated meanings for different types.
— John Reynolds [42, Sec. 7] Interpreted in a suitable way, the pre-theoretic intuitions expressed by the pio- neers of category theory and those of programming language theory match up es- sentially word for word: “artiﬁcial choices” corresponds to “ad hoc polymorphism;” “given simultaneously” corresponds “work on all types” and “behave the same way;” and “natural” corresponds to “parametric polymorphism.” So, one might expect to have a single mathematical theory that captures the intuitions expressed in both the contexts. Unfortunately, there is no such a theory, yet. The stumbling block is the choice of the “raw material” used for defining uniformity. In category theory, it
is homomorphisms. In programming language theory, it is logical relations.
In the programming language context, one expects to use a type expression such as [X → X] (or XX ) just like any other. However, such a type expression is not a functor. Given a morphism f : X → Y , there is no canonical way to extend it to a morphism of type [X → X] → [Y → Y ]. Famously, the “→” constructor is contravariant in its first argument and covariant in the second. If the same type variable occurs in both the positions, the resulting type expression fails to be ei- ther covariant or contravariant. The problem was very likely known to Eilenberg and Mac Lane, who carry around both covariant and contravariant type variables separately in their treatment [10]. Later, dinatural transformations (short for “di- agonally natural” transformations) were advanced [25, Sec. IX.4] to address the situation of the same type variable occurring in both positions. However, dinatural transformations do not compose. So, they do not provide a general solution. (See Scott [47] for a review of known results.)
Logical relations arose early in the study of typed lambda calculus (or intuition-

istic proof theory). See Statman [48] and the references cited there. The special case of logical partial equivalence relations appeared even earlier in the work of Turing and Gandy in characterizing “virtual types.” The essential purpose of logi- cal relations in this context is to characterize properties satisfied by lambda terms, or functions computed by lambda terms, so as to be consistent with the implicit operations of the typed lambda calculus. When sufficiently abstracted, the essence of the logical relations proof method can be squeezed out as the idea that the “→” type constructor is a relator. Given relations R ⊆ X × Xj and S ⊆ Y × Y j, there is a corresponding lifting [R → S] ⊆ [X → Y ] × [Xj → Y j] for function types that is consistent with operations of the typed lambda calculus, viz.,
[R → S]= { (f, fj) | ∀x, xj. (x, xj) ∈ R =⇒ (f (x), fj(xj)) ∈ S }
Note that this form of a definition works for relations of any arity, not only binary relations. In his seminal paper on lambda-definability [38], Plotkin demonstrates that all functions definable in typed lambda calculus are invariant under all such “logical” relations, and, moreover, functions invariant under a Kripke variant of logical relations are precisely the lambda-definable ones.
A second, independent discovery of logical relations occurred in automata the- ory [14,15]. We envision automata as having internal sets of states that are hidden from the environment, while the observable behaviour is stated in terms of the inputs and outputs of the automata. It was noticed in this context that homomor- phisms between automata were inadequate to capture the equivalence of behaviour. A form of structure-preserving relations was necessary. Such relations were called “weak homomorphisms,” “covering relations” [9] or “simulation relations” [27]. In due course, they developed into a mathematical theory of “information hiding” or “data abstraction” in computer science, which is the underpinning conceptual framework for the practice of object-oriented programming.
Reynolds integrated these two strands of thought and formulated a general prin- ciple of relational parametricity that is applicable to a wide range of contexts for capturing the notion of “information hiding” or “abstraction.” Unfortunately, we believe that the magnitude of this achievement has not been sufficiently recognized. As Reynolds attempted to give a set-theoretic semantics for impredicative polymor- phic lambda calculus using parametricity, which was found to be impossible upon subsequent investigation [43], the popular image that has developed in subsequent years has tied parametricity to polymorphic lambda calculus. The fact that para- metricity has broad applications throughout mathematics has gone unnoticed. In fact, parametricity counters and challenges the foundations of 20th century math- ematics for its reliance on homomorphisms. (See, for example, Freyd [12].) This challenge has not yet been answered.
In this article, we attempt to re-explain relational parametricity from the first principles, giving an indication of its broad applicability to mathematical concepts. We make no mention of any “calculus” and pay no attention to impredicative type systems. While these applications are interesting and important, they are not the main point of parametricity in our view. Rather, parametricity re-invokes the same

intuitions that led to the notion of natural transformations and the definition of categories in 1940’s and provides a different, novel answer. How to incorporate this answer into the prevailing categorical foundations of mathematics is a question that interests us. Through this exposition, we hope to spur further interest in this question to carry forward Reynolds’s legacy.
Our presentation is targeted at readership from both Mathematics and Com- puter Science. The aim is to explain the issues involved in addressing Reynolds’s challenge, but we do not attempt to survey the entire literature on the sub- ject. Other expository treatments of relational parametricity, by O’Hearn [11] and Scott [47] may be perused for fuller surveys of the literature as well as alternative view points.

Logical Relations
The way out of this impasse is to generalize homomorphisms from functions to relations.	— Reynolds [42, Sec. 1]
A “logical relation” for a particular form of a mathematical structure is a structure-preserving relation just as a “homomorphism” is a structure-preserving function. Such relations are also often called “compatible relations” in algebraic literature because structure-preservation for relations is thought of as “compati- bility” with structure. In this article, we will treat “structure preservation” and “compatibility with structure” interchangeably.
Example 2.1 A group is an algebraic structure involving a set along with a binary associative “multiplication” operation “·”, a unit 1 for multiplication and a multi- plicative inverse x—1 for each element x. We write the underlying set of a group A as |A|. The three operations of groups then have the types · : |A|× |A| → |A|, 1: |A| and ( )—1 : |A|→ |A|.
A (binary) logical relation of groups R : A ↔ Aj between groups 4 A and Aj is a binary relation R ⊆ |A|× |Aj| such that:


x [R] xj ∧ y [R] yj =⇒ xy [R] xjyj
1A [R] 1A′
x [R] xj =⇒ x—1 [R] (xj)—1

(1)

Using the relation operators that are introduced later in this section, these formulas amount to saying the operations of the two groups A and Aj are related as follows:
· [R × R → R] ·, 1A [R] 1A′ and ( )—1 [R → R]( )—1. A logical relation
With this definition, easy calculations give the following examples:
The equality relation IA ⊆ |A|× |A| is a logical relation (the “identity” logical relation IA : A ↔ A).

4 Even though we focus on binary relations for the ease of exposition, all the concepts of logical relations discussed in this paper, except for that of ordered structures, generalize to relations of arbitrary arity. Note that A x A′ and A′ x A are different types of logical relations. There is no implicit symmetry assumed.

An equivalence relation ∼ on |A| is a logical relation of groups if and only if it is a congruence relation of groups.
If h : |A| → |B| is a function between the underlying sets of groups A and B, then the graph of h, denoted ⟨h⟩⊆ |A|× |B|, is a logical relation if and only if h is a group homomorphism.
R ⊆ |A|×|B| is a logical relation if and only if it forms a subgroup of the product group A × B.
A standard early result in group theory is that a function between groups h : A → B is a group homomorphism if and only if it is a monoid homomorphism (preservation of inverses comes for free). This is not the case with logical relations.
This example generalizes to Universal Algebra.
Example 2.2 In classical Universal Algebra, algebras are defined with respect to a signature, which consists of a set of names, each equipped with an arity, n, repre- senting operations. An algebra A is a carrier set |A| equipped with interpretations of the operations. If ω is a member of the signature with arity n, then the interpre- tation of ω is a function fω : |A|n → |A|. A relation R ⊆ |A|×|A| is compatible with operation ω if and only if ∀1 ≤ i ≤ n. ai[R]aj ⇒ fω(a1,... an)[R]fω(aj ,... aj ). The
i	1	n
notion of logical relation is a generalization of this concept for relations between
possibly different algebras. If A and Aj are algebras for Ω then a logical relation
R : A ↔ Aj is a relation R ⊆ |A|× |Aj| that is “compatible” with all the operations
ω in the sense that ∀1 ≤ i ≤ n. ai[R]aj ⇒ fω(a1,... an)[R]fj (aj ,... aj ), where
i	ω	1	n
fω and f ”ω are the interpretations of ω in the algebras A and Aj. The proper-
ties listed of logical relations for groups (identity, congruence, homomorphism and characterization as sub-algebra of the direct product) extend to this setting.
Example 2.3 In that part of Universal Algebra dealing with the lattice of algebraic theories, a key tool is the Galois connection between sets of operations and sets of relations compatible with them, originally developed independently by Geiger
[13] and by Bodnarchuk et al. [4] and subsequently refined and extended by many authors (e.g. P¨oschel [40]), in which the closed sets of operations are precisely the clones. The core notion of compatibility coincides with ours. A relation R ⊆ A × A is compatible with a set of operations (e.g. a clone) if and only if it is compatible with each operation in the set. The standard universal algebraic theory differs from that presented here in considering families of relations in order to establish the Galois connection.
In contrast to the theories above, we are motivated by examples of structures arising as parts of computer programs, as well as in conventional mathematics. In this context operations can take values of arbitrary types in the language as parameters and produce values of arbitrary types as results.
Let now a signature be defined in terms of:
a finite set of “sorts” →a = a1,..., an (replacing the single carrier A), and
a suite of operation symbols Ω = {ωk : Fk(a1,..., an)}k∈I ,

where each Fk is a type expression built from (i) the sorts a1,..., an, (ii) “known types” such as boolean or integer, and (iii) type operators such as ×, + and →. Given a signature ⟨→a, Ω⟩, an algebra A for the signature consists of
an assignment Aa1 ,..., Aan of sets for each sort, and
an assignment Aωk  of elements, for each ωk ∈ Ω, in the corresponding sets
Fk(Aa1 ,..., Aan ).
This kind of algebra can be seen in e.g. [46], except that we allow known types to appear directly in expressions, rather than regarding them as special sorts. We also assume that we have function types, and therefore can equate an operation with the corresponding value of function type. This allows us to deal only with constants (many of which represent functions) and not operations.
From the type-theoretic point of view, the “sorts” are type variables and “known types” are constant types. The entire signature ⟨→a, Ω⟩ is then of a higher-order “sum type”
Σa1,...,an (Πk∈I Fk(a1,..., an))	(2)
where each of the type variables a1,..., an ranges over all sets. For example, the type of groups is Σa [a × a → a] × a × [a → a]. In this type-theoretic point of view, an algebra is just an element of the type (2).
Given two algebras A and Aj for a signature ⟨→a, Ω⟩,a logical relation R : A↔ Aj

is a family of binary relations Ra1
⊆ Aa1
j , . . . , Ra
⊆ Aan
j	such that,

for each operation symbol ωk : Fk(a1,..., an) in Ω, its interpretations Aωk  and
j	are related by Fk(R1,..., Rn). This definition is fashioned after Mitchell’s
treatment of logical relations for applicative structures [28,29], but specialized to the “set-theoretic type frame.”
Basic Type operators
To complete the picture, we must give interpretations of type operators F not only as operations on sets, but also as operations on binary relations between sets. We refer to the latter as the “relation action” of F . For each n-ary type operator F :
F (A1,..., An) must be a set (for given sets A1,. . . ,An), and

if R1 ⊆ A1 × Aj , . . . , Rn ⊆ An × Aj
are binary relations between sets, then

1	n
F (R1,..., Rn) ⊆ F (A1,..., An) × F (Aj ,..., Aj ) must be a binary relation.
1	n
This interpretation is subject to the “identity extension” property:
F (IA1 ,..., IAn )= IF (A1,...,An)	(3)
where IX ⊆ X × X is the identity relation for each set X. This is the part of the theory of functors that deals with identities. By omitting requirements involving composition, Reynolds was able to admit more type operators than categorical functors can accommodate, chief among them the function type constructor →. We will use the framework of reflexive graphs in Secs. 3 and 6 to formalize these intuitions at the level of categories.

We begin with product, sum, function space, powerset and predicate types. In the following, type-forming operations are applied to sequences A, B, C,... and relations are between A and Aj, B and Bj (R ⊆ A × Aj, S ⊆ B × Bj, etc).
Product: as usual, the cartesian product of two sets A and B is the set of ordered pairs. The relation R × S ⊆ (A × B) × (Aj × Bj) is defined by: (a, b)[R × S](aj, bj) ⇐⇒ a[R]aj ∧ b[S]bj.
Sum: we define the sum of two sets as the disjoint union of copies: A + B =
{0}× A + {1}× B. The relation R + S ⊆ (A + B) × (Aj + Bj) is defined by: (i, x)[R + S](j, y) ⇐⇒ (i = j =0 ∧ x[R]y) ∨ (i = j =1 ∧ x[S]y).
Function space: Let [A → B] be the set of (total) functions f : A → B. We define the relation [R → S] ⊆ (A → B) × (Aj → Bj) by f [R → S]fj ⇐⇒
∀a, aj. a[R]aj ⇒ f (a)[S]fj(aj).
Powerset: if PA is the set of all subsets of A, then we define the extension of the powerset operator to relations by u[PR]uj ⇐⇒ (∀a ∈ u. ∃aj ∈ uj. a[R]aj)∧ (∀aj ∈ uj. ∃a ∈ u. a[R]aj). This definition corresponds to the Egli-Milner or- dering for powerdomains [39].
Predicates: The collection of predicates over a set A, which we denote by PA, also has the set of all subsets of A as carrier. However, the relation action is defined by u[PA]uj ⇐⇒ (∀a, aj. a[R]aj ⇒ (a ∈ u ⇐⇒ aj ∈ uj)). Note that the relation action of P^A corresponds to that of [A → 2].


Lemma 2.4 The above deﬁnitions satisfy the identity extension property.
IA × IB = IA×B
IA + IB = IA+B
[IA → IB]= I[A→B]
PIA = IrA
P^IA = Ir^A


The left to right inclusion parts of these equations, e.g., [IA → IB] ⊆ I[A→B], amount to extensionality of higher type values. The right to left inclusions, e.g., I[A→B] ⊆ [IA → IB], say that the relation actions are consistent with the observable information of higher type values.
Nondeterministic functions. Operations in both mathematics and computer science are often partial (not defined for all inputs) and sometimes nondeterministic (different executions may produce different results). We therefore want to handle
f
the type of “nondeterministic functions”. We write x −→ y to mean that y is a
possible result of applying the nondeterministic function f to input x, and the type of nondeterministic functions as A ~ B. It is convenient to reduce [A ~ B] to [A → PB]. The derived relation [R ~ S] is then [R → PS]. Expressed directly in

terms of nondeterministic functions, it says:


f	j	j f′	j	j
j	j f′	j	f	j

Coinductive logical relations defined using this notion of [R ~ S] often go by the name of bisimulation relations. (See Sangiorgi [45] for a historical account.)
Note that this definition is different from the one we would obtain by interpreting
A ~ B as P(A× B).
Partial function space. For sets A and B, their partial function space [A - B] consists of partial functions from A to B. It is convenient to treat partial functions A - B as total functions A → P1B, where P1B is the restriction of PB to subsets of cardinality at most 1. Whenever f : A - B is undefined for an element x ∈ A, its representative fj : A → P1B sends x to ∅. Thus we identify [A - B]= [A → P1B]. Given relations R ⊆ A × Aj and S ⊆ B × Bj, the relation [R - S] is simply [R → P1S]. Spelling out the detail, this means that


f [R - S] fj ⇐⇒
∀x, xj. x [R] xj =⇒

f (x)= ∅∧ fj(xj)= ∅∨ 
f (x) /= ∅∧ fj(xj) /= ∅∧ f (x) [S] fj(xj)

	(5)


Example 2.5 A ﬁeld is a set F equipped with a commutative group structure (+, 0, −) and a partial commutative group structure (·, 1, ( )—1) such that · dis- tributes over +. The multiplicative group structure is “partial” in that the inverse is defined for only non-zero elements: x—1 /= ∅ ⇐⇒ x /= 0. A logical relation of fields R : F ↔ Fj thus requires the two inverse operations to be related by the relation R - R, i.e.,
∀x, xj. x R xj =⇒ (x =0 ∧ xj = 0) ∨ (x /=0 ∧ xj /=0 ∧ x—1 R (xj)—1)
Thus a logical relation of fields can relate 0 to only 0. Since 0 is the unit of the additive group structure, this has the consequence that a logical relation of fields is always a partial bijection. A homomorphism of fields, regarded as a total and single-valued logical relation, is therefore necessarily injective. This is a well-known fact in field theory, but logical relations provide an abstract reason for why it is so. It is also worth noting that Reynolds’s leading example of type abstraction in [42] involves Bessel’s and Decartes’s representations for the field of complex numbers.
The logical relation involved there is indeed a partial bijection.
Further examples
Algebraic structures such as monoids, semigroups, rings, semirings, etc. can be treated in the same way as Examples 2.1 and 2.5. They are one-sorted structures

involving no “known types.” Next we look at actions, which bring out connections with modules and vector spaces on the one hand, and algebraic automata theory on the other. Automata theory happens to be one of the first areas in Computer Science where logical relations were discovered.
A monoid is an algebraic structure M involving a set along with an associative binary operation “·” and its unit 1. A logical relation of monoids R : M ↔ Mj is a relation between the underlying sets such that the two multiplication operations are related by R × R → R and the two units by R.
An action of monoid M on a set X, also called a module for M , is a monoid homomorphism α : M → [X → X], where [X → X] is the collection of endomor- phisms on X viewed as a monoid under composition. It is conventional to write α(m)(x) as m·x, treating it as a form of “scalar multiplication” of type M×X → X. We use the notation M X to talk about the module as a structure. A logical relation of M -actions R : M X ↔ M Xj is a relation R ⊆ X × Xj compatible with scalar multiplication:
x R xj =⇒ m · x R m · xj	(6)
If R = ⟨h⟩ is the graph of a function then h is a homomorphism of M -actions. Note that, with reference to our universal algebraic description, an M -action is a structure involving a “known type” M and a single sort a standing for the underlying set X, i.e., has the type Σa M → [a → a]. This leads to the requirement that the action maps must be related by IM → [R → R] as indicated in (6). Actions of rings or semirings (modules) and those of fields (vector spaces) can be treated in a similar way.
Reflexive graph framework for logical relations
Even before we look at parametricity, it is worth taking an abstract view of the structure underlying logical relations. We need a treatment similar to the definition of categories, retaining identities but dropping composition. The resulting structure is called a reflexive graph [32,35,44], improving on the previous work on scones [31].

Definition 3.1 A reflexive graph G involves a collection Gv of “vertices” and a collection Ge of “edges” or “abstract relations,” along with functions ∂0, ∂1 : Ge → Gv and I : Gv → Ge that satisfy ∂0(I(A)) = ∂1(I(A)) = A. The functions ∂0 and ∂1 pick out the “source” and “target” of abstract relations and I gives a distinguished “identity” relation for each vertex. We write R : A ↔ Aj whenever A and Aj are the source and target of an abstract relation R, and abbreviate I(A) to IA.
A morphism of reflexive graphs F : G → H, which we call a relator, is a pair of functions F = (Fv, Fe) mapping the vertices and edges respectively, preserving all the structure on the nose: ∂i(Fe(R)) = Fv(∂i(R)) and Fe(IA) = IFv (A). We normally drop subscripts of Fv and Fe using the context to disambiguate which is meant.
Fact 3.2 Reflexive graphs and relators form a category RG. It has pointwise prod-

ucts, i.e., (G× H)v = Gv × Hv and (G× H)e = Ge × He.
We borrow the term relator from [1,31]. Note that the property F (IA)= IF (A) of relators is precisely the identity extension property mentioned in (3). It is a fun- damental axiom underlying Reynolds’s theory of logical relations and parametricity. The prototypical example of reflexive graphs is set, which has all sets as its vertices and binary relations R ⊆ A × Aj as edges. The identity edge IA : A ↔ A is the equality relation =A. All the “type operators” mentioned in Sec. 2 are relators:
P, P1, P : set → set
×, +, →, -, ~ : set × set → set
That means that they have an action on sets, such as PA or [A → B], as well as an action on relations, such as PR and [R → S]. The type expressions Fk(→a) in the definition of algebraic structures are built from such relators as well as the constant relators for “known types” ConstK : setn → set given by ConstK(A→) = K and ConstK(R→ )= IK.
Algebras for signatures ⟨→a, Ω⟩, along with their logical relations, give rise to reflexive graphs in turn, denoted alg(→a, Ω).
More generally, for any relator F : G → set, an F -algebra is a pair A = ⟨A, f⟩ of a vertex A of G and an element f ∈ F (A). A logical relation of such algebras R : A ↔ Aj is an abstract relation R in G such that f [F (R)] fj in set. This gives a reflexive graph alg(F ). Note that alg(→a, Ω) is a special case of this where we use G = setn (with →a ranging over its vertices) and Ω is treated as a relator setn → set.
Reflexive graphs from categories
The example of set can be generalized. For any category C with finite products, define rel(C) as the reflexive graph whose vertices are just the objects of C and edges R : A ↔ Aj are subobjects R > A×Aj. 5 The diagonal morphisms δA : A > A×A serve as the identity edges. Note that the reflexive graph set is nothing but rel(Set). An algebraic example is ab = rel(Ab), the reflexive graph of abelian groups. An edge R ⊆ A × Aj is a subgroup of the categorical product (direct sum) A × Aj, the same as the “logical relations of groups” mentioned in Example 2.1. Examples of relators on ab include ⊗, ⊕, → : ab × ab → ab.
Similarly poset = rel(Poset), dcpo = rel(DCPO) and cpo⊥ = rel(CPO⊥) give examples from programming language semantics. In dcpo, the relation edges R ⊆ A× Aj are directed-complete subsets of A× Aj which are also called “directed- complete relations.” In cpo⊥ the relation edges are pointed, directed-complete relations, dubbed “complete relations” by Reynolds. See Pitts [35] for a treatment of these examples.
If C is a concrete category with a generating object c0 and C has finite products, then evidently we can form algebras for signatures ⟨→a, Ω⟩ internal to C. The sorts are interpreted as objects of C and operations ω : F (→a) as “points” Aω : co → F (A→).

5 If a category does not have products, one can use jointly monic spans of C for the same purpose.

Using relations from rel(C), we can define logical relations for such algebras. Thus, we obtain a reflexive graph algC (→a, Ω) of algebras internal to C. Examples of such algebras abound. For example, monoids and monoid actions internal to Ab are well-known as rings and modules. Monoids and monoid actions internal to Poset are called “pomonoids” (short for partially ordered monoids) and “M -posets.”
Reflexive graphs of the form rel(C) and algC (→a, Ω) have additional categorical structure which we discuss in Sec. 6.
Ordered structures
When we deal with ordered structures, we have the option of using the partial order of the structure as the “identity edge” as noted by Reynolds [42, Sec. 5-6]. For example, the reflexive graph poset± is similar to poset except that the identity edge IA : A ↔ A is the partial order ±A. We still have relators such as × and → (product and monotone function space) on poset± because they preserve the new “identity edges”: ±A × ±B = ±A×B and [±A → ±B] = ±[A→B]. We say that a relation R in poset± represents the “graph” of a monotone function f : A → B if x R y  ⇐⇒ f (x) ±B y. We write this relation as ⟨f⟩± rather than ⟨f⟩. For algebras in poset±, homomorphisms derived from logical relations will be “lax homomorphisms.” Dually, those in poset± will be “oplax homomorphisms.”
Reynolds’s concept of the “identity relations” is thus an abstract concept.
Abstract types and Information hiding
One of the first instances of logical relations being formulated in computer science was in automata theory [15]. (See also [9,14].) They were called “weak homo- morphisms” or “covering relations” in this context, and directly inspired the use of logical relations in programming theory (Milner’s simulation relations [27] and Hoare’s representation functions [20]), leading to the notion of “abstract types” ex- tensively developed in succeeding years. (See, for example [5,46] for book length treatments.) Reynolds’s own insights came partly from these developments [41, Chapter 5], allowing him to link logical relations with “abstraction.” We also refer to this idea of “abstraction” as “information hiding,” using a term initiated by Par- nas [34] and used widely in software development, which captures the more general phenomenon at play.
A monoid semiautomaton, also called a deterministic labelled transition system, is the action of a monoid on a set in terms of partial functions, α : M → [X - X]. Note that [X - X], the collection of partial functions from X to itself, forms a monoid under partial function composition and α is a monoid homomorphism. As usual, we use the “scalar multiplication” notation m · x for α(m)(x). The set X is thought of as the set of states for the automaton and the monoid M represents the collection of operations or “inputs.” (An ordinary semiautomaton is obtained by specializing M to the free monoid Σ∗ generated by an alphabet of symbols Σ.)
A monoid automaton is a semiautomaton equipped with a distinguished el- ement called the start state, giving a structure ⟨X, α, x0⟩.  As usual, a logical

relation of automata R : ⟨X, α, x0⟩ ↔ ⟨Xj, αj, xj ⟩ is a relation R ⊆ X × Xj
0
j	j
h : ⟨X, α, x0⟩ → ⟨Y, β, yo⟩ is a function X → Y such that h(m · x)  m · h(x) and h(x0) = y0. (Here, “ ” denotes the so-called “Kleene equality:” either both the sides are undefined or both are defined and equal.) Note that the graph of a homomorphism ⟨h⟩ is a logical relation.
The consideration of automata and semiautomata brought the phenomenon of “information hiding” to the realm of algebra, perhaps for the first time. The in- tuition is that an automaton is a black box with the states forming the internal implementation, hidden to the outside. The externally observable behaviour is whether the automaton converges for particular inputs in M . For an automaton M = ⟨X, α, x0⟩, we can define its external behaviour as
B(M)= { m ∈ M | m · x0 /= ∅} 
Two automata M = ⟨X, α, x0⟩ and Mj = ⟨Xj, α, xj ⟩ are said to be behaviorally equivalent if B(M)= B(Mj). It is possible to show that logical relations represent a complete reasoning principle for behavioral equivalence:
Fact 4.1 Two automata M and Mj are behaviorally equivalent if and only if there exists a logical relation between M and Mj.
(While the existence of isomorphisms or homomorphisms is sufficient to ensure behavioral equivalence, neither of them gives a complete reasoning principle for it.)
To see this fact, let R∞ be the greatest relation R ⊆ X × Xj such that:
x R xj =⇒ ∀m ∈ M. m · x P1R m · xj
(The existence of R∞ can be inferred using the Tarski’s fixed point theorem.) If (x, xj) /∈ R∞, then there must be some m ∈ M such that m · x = ∅ and m · xj /= ∅ or vice versa, i.e., x and xj are not behaviorally equivalent states in their respective machines. So, if M and Mj are behaviorally equivalent then (x0, xj ) ∈ R∞, and
R∞ is the required logical relation.
Similar situation persists with other kinds of abstract machines. A Mealy ma- chine of type M ⇒ O, where M and O are “known” monoids, is a set X equipped with a monoid homomorphism α : M → [X → X × O]. The behaviour of a Mealy machine with an initial state M = (X, α, x0) is defined as the input-output map- ping B(M)= { (m, o) | ∃x. m· x0 = (x, o) }. Once again, homomorphisms represent an incomplete reasoning principle for behavioral equivalence of Mealy machines whereas logical relations represent a complete reasoning principle.
These observations suggest that isomorphisms, homomorphisms and logical re- lations make up a spectrum of correspondences between mathematical structures, with homomorphisms being a “halfway house.” When we deal with information hiding, we face the symmetric concept of behavioral equivalence, which is unlikely to be characterized by the asymmetric concept of homomorphism. Isomorphisms seem appropriate when there is no information hiding involved and logical relations seem appropriate when there is information hiding involved.

We can capture information hiding type-theoretically using existential types pro- posed by Mitchell and Plotkin [30]. A signature ⟨→a, Ω⟩, where all the sorts represent “hidden” types, can be expressed as the higher-order type:

∃a1,...,an (Πk∈IFk(a1,..., an))	(7)

The existential operator “∃,” replacing the sum “Σ” in (2), captures the idea of information hiding. Thus M -automata have the type ∃a ([M → [a - a]] × a) and Mealy machines have the type ∃a ([M → [a → a × O]] × a).
We call the elements of the type (7) abstract algebras. An abstract algebra is an equivalence class of algebras for ⟨→a, Ω⟩ under “behavioral equivalence.” Supported by the evidence from automata theory, we take behavioral equivalence to be the equivalence relation generated by the existence of logical relations. More precisely, we say that
two algebras are similar, A∼ Aj, iff there exists a logical relation R : A↔ Aj, and
two algebras are behaviorally equivalent, A≈ Aj, iff there is sequence of algebras A = A0 ∼ A1 ∼ · · ·∼ An = Aj, where the successive algebras are similar with a logical relation between them.
Note that we do not require the similarity relation to be transitive, i.e., no require- ment for logical relations to compose. Indeed, whenever function types or other mixed variant type operators are involved, logical relations do not compose. We do not see this as a loss. (There have been proposals for composable forms of logical relations [37] but they are not uniformly defined.)
The notion of abstract types in programming languages and specification lan- guages is the same as that of abstract algebras above. As a simple example, con- sider an abstract type intset for finite sets of integers, equipped with the operations e : intset, i : int × intset → intset, and m : int × intset → bool (for the empty set, the insertion of an element into a set, and the membership test in a set). Two simple ways to implement the abstract type are in terms of (unordered) lists (with possible duplicate copies) and ordered lists. (Many other sophisticated implemen- tations such as binary search trees and hash tables etc. can be found in text books on data structures.) The two implementations would be behaviorally equivalent if there is a logical relation between them. The natural candidate for the logical relation is:
L R Lj ⇐⇒ |L| = |Lj|∧ ordered(Lj)
where |L| denotes the set of elements of list L. To show that R is a logical relation, on e must show that the im plementations of the operations are related: e  R  ej,
correctness of a data structure implementation is to prove that it is behaviorally
equivalent to a naive implementation. Examples of such proofs may be found in Reynolds’s Craft of Programming [41, Chapter 5] and de Roever and Englehardt[5].

Relational Parametricity
Parametric transformation is the concept parallel to natural transformation that works with logical relations instead of morphisms. Just as natural transformations are “maps of functors,” parametric transformations are “maps of relators.”
To keep this discussion concrete, we restrict attention to reflexive graphs of the form rel(C) for categories C, with set = rel(Set) being the prototypical example. We will refer to the category C as the “underlying category” of the reflexive graph. A more satisfactory axiomatization of the structure is given in Sec. 6.
Given reflexive graphs G and H and two relators F, G : G → H, a parametric
transformation η : F →○ G is a family of maps ηA : F (A) → G(A), indexed by
vertices A of G, such that, for all edges R : A ↔ Aj in G, we have
ηA F (R) → G(R) ηA′	(8)
Intuitively, η is a “parametrically polymorphic function” that preserves all logical relations between the vertices of G.
Example 5.1 If the multiplication operation of a group is commutative, it is called an abelian group. There is a canonical abelianization of a group G, whose construc- tion illustrates relators and parametric transformations in algebraic settings.
A commutator in a group G is a product of the form aba—1b—1, denoted by the short hand notation [a, b]. The commutator subgroup C(G) of G is the collection of products of the form [a1, b1] ··· [an, bn], for n ≥ 0. Whenever R : G ↔ Gj is a logical relation of groups, there is a corresponding logical relation C(R) : C(G) ↔ C(Gj) given by
C(R)= { ( n	[ai, bi],  n	[aj, bj]) | ∀i = 1, n. ai R aj ∧ bi R bj }
Thus, we havea relator C : grp → grp. (Intuitively, a commutator [a, b] represents the equivalence relation ab ≈ ba and the group C(G) represents the congruence relation generated by all such equivalences.)
The commutator subgroup C(G) is closed under all the automorphisms of G (which are nothing but one-to-one logical relations) and, so, forms a normal sub- group of G. The quotient group A(G)= G/C(G) is called the “abelianization” of
G. Its elements are “cosets” (x)= { cx | c ∈ C(G) } and multiplication is defined by (x)(y)= (xy). A(G) is an abelian group. We can make the A operation on groups into a relator grp → grp by defining A(R) : A(G) ↔ A(Gj) as the relation that relates (x) and (xj) whenever x R xj.
The projection maps νG : x '→ (x) that send elements x ∈ G to cosets form a
parametric transformation ν : Id →○ A : grp → grp. Whenever x R xj, we have
νG(x) A(R) νG′ (xj) directly from the definition of A(R).
Note that the family of projection maps, ν, is a prototypical example of a nat- ural transformation [25]. The example illustrates that the arguments we make for the naturality of such families easily generalize to parametricity. However, para- metricity is a more general concept since it works with the larger class of relators,

which are not required to preserve composition. Hence parametricity applies when naturality fails to apply. The following examples illustrate this fact.
Example 5.2 Consider the composition of functions as a family of maps:
ABC : [B → C] × [A → B] → [A → C]
where the type expressions on both the sides of → are treated as relators set3 → set in the three type variables A, B, C. This is a parametric transformation (but the version defined with maps is not natural in B). Given relations R : A ↔ Aj, S : B ↔ Bj and T : C ↔ Cj, we have:
g S → T gj ∧ f R → S fj =⇒ g ◦ f R → T gj ◦ fj

The “evaluation” map evAB : [A → B]×A → B given by ev(f, x)= f (x) is similarly parametric in both A and B (as opposed to just B).
The reader will be able to construct similar examples for the internal homs in other closed categories.
Example 5.3 The family of iteration maps:
τX : N → [[X → X] → [X → X]]
given by τX (n)(f )= fn is parametric. We have, for all relations R : X ↔ Xj,
τX IN → [[R → R] → [R → R]] τx′
In fact, since the source type N is independent of X, we can regard τ as a function
of type:
τ : N → ∀X [[X → X] → [X → X]]
for a suitable internalization ∀XF (X) → G(X) of parametric transformations. Once we do this, we notice that τ is in fact an isomorphism, i.e., every parametric trans- formation φX : [X → X] → [X → X] is of the form λf. fn, the n’th Church numeral (Consider parametricity with respect to the relation R : N ↔ X given by n R y ⇐⇒ fn(x)= y.)
This result applies to total functions, but not partial or nondeterministic func- tions. For example, the type ∀X [[X - X] → [X - X]] operating on partial functions has the following parametric “snap back” operation:
λf. λx.	∅,	if f (x)= ∅
x,	otherwise
which evaluates f at x but discards the result, returning the original input x. O’Hearn and Tennent [32, Sec. 6] show that this polymorphic type is isomorphic N⊥ × Vnatop.

Arguments of this kind are familiar from the use of the Yoneda lemma for Hom- sets. Relational parametricity allows us to internalize them and reason about inter- nal homs (function spaces) in the same way. The generalization to relations seems essential for dealing with internal homs. For example, note that, even though the relation R : N ↔ X in the above example is the graph of a function, the relation R → R is not the graph of a function.
To make the discussion concrete, we give a definition of ∀XF (X) in algebraic settings, parallel to that of ∃XF (X) in Sec. 2. In doing this, we run into a cardinality issue because the type variable X ranges over large collections such as “all sets,” “all groups” etc. An element of ∀XF (X) is a family ϕ = {ϕX}X indexed by all types of this form and, so, is too large to be a set. Our preferred solution to the problem is to use Grothendieck universes, but we do not wish to belabor this point. We use the notation ϕ ∈ ΠXF (X) to denote that ϕ is such a family.
If F : G → set is a relator then ∀XF (X) is the collection of families φ ∈
ΠX∈Gv F (X) subject to the parametricity requirement :
∀R : X ↔ Xj. ϕX F (R) ϕX′	(9)
In general, we might have type expressions that have other type variables. So, more generally, if F : G× H → set is a relator then ∀XF (X, Y ) isa relator H→ set that sends vertices Y ∈ Hv to sets ∀XF (X, Y ) ⊆ ΠXF (X, Y ) and edges S : Y ↔ Y j to relations ∀XF (X, S): ∀XF (X, Y ) ↔ ∀XF (X, Y j). These are determined by the formulas:
 ϕ ∈ ∀XF (X, Y ) ⇐⇒ ∀R : X ↔ Xj. ϕX F (R, IY ) ϕX′
The generalization of these concepts to reflexive graphs other than set appears in Sec. 6.

Local information hiding
The semantic intuition underlying parametric polymorphism is information hiding, the same phenomenon we have seen with existential types (Sec. 4), but working in a dual fashion. Whereas ∃XF (X) represents the construction of a “black box” that hides the information about the type X to the “outside,” the type ∀XF (X) represents a construction that is generic in X and hence the information about X is hidden from it. We might say that the information hiding involved in ∃X is global whereas that involved in ∀X is local.
Whereas the phenomenon of global information hiding seems rare in mathemat- ics, that of local information hiding is quite common. All the examples mentioned by Eilenberg and Mac Lane [10] for “natural” transformations exhibit this phe- nomenon. This also appears to be the sense in which the term “logical” was used by Plotkin [38] in naming “logical relations.” Since the term-forming operations of the typed lambda calculus are “logical,” they are independent of the specific

type information about the ground types. This led to the thesis that the lambda- definable elements should be invariant under all relations that carry out value sub- stitutions of ground types (“permutations” in a general sense). Plotkin’s results imply that selective information hiding is also captured by logical relations. An element lambda-definable from a set of elements Σ, preserves all relations R that are preserved by the elements of Σ. We see this notion at play, for instance, in Church numerals of type ∀X [X → X] → [X → X]. Given an unknown type X and values f : X → X and z : X, the definable elements of X are exactly those that preserve all relations preserved by f and z. Thus, parametricity gives us an extensional characterization of the intensional aspect of lambda-definability.


Parametric behaviour
The information hiding aspects of automata in Sec. 4 were captured by specifying a particular form of external behavior for an automaton. We can state the behavior as a polymorphic function of type

B : ∀X ([M → [X - X]] × X) → (M → 2)

and note that it is parametric in the state set X. Thus the “global” information hiding for the state sets of automata is reducible to the “local” information hiding of its designated behavior function.
Generalizing this, we can postulate the following equivalence of types:

∃X F (X) ∼= ∀Y (∀X F (X) → Y ) → Y	(10)

The type ∀X F (X) → Y on the right hand side is the type of a possible behaviour function, which should be parametric in X. The type variable Y stands for the type of the observable behaviour, e.g., M → 2 in the case of automata. The universal quantifier ∀Y represents the idea that ∃X F (X) hides its representation type X from all possible observable behaviour functions.
It is possible to prove the equivalence (10) as a theorem from our definitions of
∃X and ∀X quantifiers. However, Reynolds [42] turned the equivalence (10) around and used it as the deﬁnition of ∃X in polymorphic lambda calculus. His calculus only has the ∀X quantifier built-in and ∃X is a derived notion.
In the literature on logical relations [28,29,48], it is common to find a “funda- mental theorem” or “basic lemma” to the effect that all terms of a syntactic calculus preserve the defined logical relations. Reynolds’s insight means that this result can be obtained in a syntax-independent way, by showing that all the primitives and combinators involved in the calculus are parametric. The “fundamental theorem” for logical relations is equivalent to the parametricity of the calculus. It would be worthwhile reexamining the literature on logical relations from this perspective.

Reflexive graph categories
To formalize the notion of parametric transformations and their internalization represented by the ∀X quantifier, we need an explicit notion of morphisms, i.e., a suitable structure of categories.
Since reflexive graphs of Sec. 3 capture logical relations satisfactorily, an appro- priate structure would be to consider categories internal to RG. Such a category would have have a reflexive graph of “objects” and a reflexive graph of “morphisms,” We encourage the reader familiar with internal categories (see, for example, [25, Sec. XII.1]) to follow through this construction.
However, in one of those beautiful symmetries of nature, categories internal to RG turn out to be the same as reflexive graphs internal to Cat. Following O’Hearn and Tennent [32], we follow the latter approach.
Definition 6.1 A reflexive graph category (or a reflexive graph of categories) G
involves a category Gv of “vertices” and a category Ge of “edges” along with functors
∂0, ∂1 : Ge → Gv and I : Gv → Ge that satisfy ∂0(I(A)) = ∂1(I(A)) = A.
A reflexive graph-functor (or relational functor ) F : G → H is a pair of functors F = (Fv : Gv → Hv, Fe : Ge → He) acting on the vertex category and edge category respectively, preserving all the structure on the nose: ∂i(Fe(E)) = Fv(∂i(E)) and Fe(IA) = IFv (A). We normally drop subscripts of Fv and Fe using the context to disambiguate which is meant.
This is a straightforward generalization of Definition 3.1. However, it is im- portant to note that there are four kinds of entities involved in a reflexive graph category: the objects and morphisms of Gv (which we continue to call “objects” and “morphisms”) and the objects and morphisms of Ge (which we call “edges” and “edge morphisms”). If R : A ↔ Aj and S : B ↔ Bj are edges with an edge mor- phism φ : R → S, then the functors ∂0 and ∂1 pick out the morphisms f : A → B and fj : A → Bj that φ “spans,” as in the diagram below
A 	> B 

Λ	Λ
R	φ	S
V	V
(11)

Aj	> Bj
f′
The identity functor I gives an identity edge IA for each object A as well as an identity edge morphism If : IA → IB for each morphism f : A → B. Thus, in a reflexive graph category, we accommodate homomorphisms as well as logical relations side by side with an “equal status.” The reader familiar with double categories [8,23] is invited to view reflexive graph categories as a weakening of the structure of double categories, omitting the notion of composition for vertical morphisms. In analogy with double categories, we also refer to edge morphisms such as φ as “squares.”
Reflexive graph categories can be viewed as adding a category structure to re- flexive graphs of Sec. 3. The underlying reflexive graph of a reflexive graph category

G, obtained by omitting all the morphisms of G, is denoted |G|. We also feel free to treat |G| as a discrete reflexive graph category by implicitly adding identity arrows for all vertices A and edges R. A functor F : |G| → H from a discrete category is referred to as a “nonvariant” relational functor. It is essentially a relator because it ignores all the morphisms of G. If F : |G| → H and F j : |H| → K are nonvariant relational functors, then there is a composite FjF : |G| → K, and there is an “iden- tity” nonvariant functor IdG : |G| → G. Hence, we can use the normal categorical notation for nonvariant functors. If F : G → H is a relational functor, we use the notation |F | : |G| → H to refer to its underlying nonvariant functor.
Reflexive graphs of the form rel(C) give rise to reflexive graph categories Rel(C). The underlying category C of the reflexive graph serves as the vertex category of Rel(C). Edges R : A ↔ Aj are subobjects R > A × Aj and edge morphisms φ : R → S that span f : A → B and fj : Aj → Bj are the unique factors induced by f × fj : A × Aj → B × Bj.


φ
R	> S 
V	V

V	f×f′	V


(12)

A × Aj 	> B × Bj
In this situation, we also say that φ is above the pair of morphisms (f, fj) or that φ is a lifting of the pair (f, fj) to Ge. The identity edge IA : A ↔ A is the diagonal morphism δA : A > A × A and the identity edge morphism If : IA → IB above (f, f ) is nothing but f .
The reader is invited to contemplate the correspondence between the diagrams
(11) and (12), the first representing an abstract higher-dimensional view of relation- preservation and the second representing a normal categorical view.
The definition of Rel(C) allows us to view every category with finite products automatically as a reflexive graph category. From this point on, we change our “call signs,” using names such as Set, Grp, Mod etc. to refer to the reflexive graph categories obtained in this way.
The reflexive graph category Set, for example, has functions f : A → B as its morphisms, binary relations R ⊆ A×Aj as its edges, and relation preservation facts f R → S fj as its edge morphisms. Examples of relational functors include:
P, P1 : Set → Set	×, +: Set × Set → Set
P^ : Setop → Set	→, -, ~ : Setop × Set → Set
Note that, in any reflexive graph category of the form Rel(C), there is at most one edge morphism of type R → S for any given R and S. A reflexive graph category that has this property is said to be relational. Such a category has a hom-functor Hom : Gop ×G → Set, whose vertex part sends pairs of objects (A, B) to the set of morphisms Hom(A, B) and edge part sends pairs of edges (R, S) to relations Hom(R, S) ⊆ Hom(A, B) × Hom(Aj, Bj).

Definition 6.2 Given two relational functors F, G  : G → H, a parametric
natural transformation η : F  →.	G is a pair of natural transformations η =
(ηv : Fv → Gv, ηe : Fe → Ge) preserving the reflexive graph structure: ∂iηe = ηv∂i and Iηv = ηeI. (As usual, we omit the subscripts of ηv and ηe when they can be discerned from the context.) If G is a discrete reflexive graph category, we simply
call η a parametric transformation and write η : F →○ G.
The vertex part ηv is an ordinary natural transformation. The edge part ηe is a family {ηR : F (R) → G(R)}R indexed by edges R : A ↔ Aj in G. The compo- nents ηR are edge morphisms in H that span morphisms ηA : F (A) → G(A) and ηA′ : F (Aj) → G(Aj). Diagrammatically, we can picture this as follows:
A	F (A)	ηA > G(A)

Λ	Λ
R	F (R)	ηR
V	V
Λ
G(R)
V

Aj	F (Aj)
> G(Aj)
ηA′

Remembering that, in a relational reflexive graph category such as Rel(C), there is at most one edge morphism ηR spanning ηA and ηA′ this condition says the same thing as formula (8), viz. parametricity involves the preservation of all logical relations between vertices.
However, note that Definition 6.2 imposes parametricity and naturality as two separate conditions of uniformity. This is redundant for categories like Rel(C). Since their logical relations subsume the morphisms via the graph construction
⟨−⟩, the preservation of logical relations automatically implies the preservation of morphisms as well. Secondly, the use of naturality limits us to functors, which run into variance problems with higher-order types. To get around the second problem, we use the notion of nonvariant functors described earlier in this section.
A parametric natural transformation η : F →.  G between nonvariant functors as
per Definition 6.2 is simply referred to as a parametric transformation because its naturality is trivial.
Fact 6.3 Reflexive graph categories, relational functors and parametric natural transformations form a 2-category RGCat. This 2-category is cartesian closed with products given pointwise and exponentials that have relational functors as objects.
The products are given pointwise: (G×H)v = GV ×Hv and (G×H)e = Ge ×He. This is similar to reflexive graphs in Sec. 3, the difference being that we are now dealing with categories rather than sets.
For exponentials, the category (HG )v has relational functors G → H as objects
and parametric natural transformations η : F →.  G as morphisms. The edge cat-
egory (HG )e has objects representing “higher-order relations” between relational functors.  If F and Fj are relational functors, an edge ρ : F ↔ Fj is a family

{ρR}R∈Ge
of edges ρR : F (A) ↔ Fj(Aj) indexed by edges R : A ↔ Aj of G. An

edge morphism φ : ρ → σ in (HG )e spanning η : F → G and ηj : Fj → Gj is a
family {φR}R of edge morphisms φR : ρR → σR in H. Diagrammatically, an edge

morphism in HG shown on the left is a family of edge morphisms in H shown on the right:

η
F	> G 
F (A)	ηA  > G(A)

Λ	Λ	Λ	Λ
ρ	φ	σ	ρR	φR	σR
V	V	V	V

Fj 	> Gj
η′
Fj(Aj) 	> Gj(Aj)
η′
A

The identity edge IF : F ↔ F for a relational functor F is the family {FR}R and the identity edge morphism Iη : IF → IG for a parametric natural transformation
η : F →.  G is the family {ηR}R. (In other words, the identity edge functor simply
selects the edge parts: IF = Fe and Iη = ηe.)
Since RGCat is a 2-category, we have the notions of adjunctions, monads and comonads available for them. So, we can define the usual adjunctions

Δ E ×	: G× G → G
+ E Δ	: G → G × G
(−× A) E [A → −] : G → G

When we calculate these for particular reflexive graph categories such as Set, we obtain exactly the relation actions described in Sec. 2. A more detailed analysis of such adjunctions in the context of fibrations is given in Sec. 7.
Fact 6.4 There is a “diagonal” relational functor Δ : H → HG that sends the vertices of H to constant relational functors G → H and edges of H to constant higher-order relations between constant functors.
For a vertex K of H, the constant relational functor Δv(K) : G → H sends every vertex of G to K, every morphism to idK, every edge to the identity edge IK and every edge morphism to Iid . For any edge S : K ↔ Kj in H, Δe(S) in (HG )e is the constant family {S}R∈Ge that maps every edge of G to S.
Finally, we define the type quantifiers ∃ and ∀ as the left and right adjoints to the diagonal functor:
∃ E Δ E ∀	:	HG →H 
To explicate the detail, given a relational functor F : G → H, the vertices ∀(F ) and
∃(F ), which are also denoted ∀XF (X) and ∃XF (X), are characterized as follows:
∀XF (X) comes equipped with a parametric natural transformation ν	:
∀XF (X) →.  F that is universal, i.e., any other parametric natural transforma-
tion A →.  F for a vertex A of H uniquely factors through ν. We call this the
parametric limit of F .
∃XF (X) comes equipped with a parametric natural transformation μ	:
F →.  ∃XF (X) that is universal, i.e., any other parametric natural transforma-
tion F →.  A for a vertex A of H uniquely factors through μ. We call this the
parametric colimit of F .

Diagrammatically:

ν	μ
∀(F ) 	> F 	> ∃(F )

.
.
τ
A	> F 
.
.
.
σ	∨.
> A 


Note that these are the expected generalizations of the categorical concepts of “limit” and “colimit” to reflexive graph categories. When we calculate the adjoints for the case H = Set, we obtain the definitions given in Sec. 2 and Sec. 5.
It is also possible to define parametric ends and coends as the internalizations of parametric dinatural transformations in a similar way.


Subsumption
The framework of reflexive graph categories allows us to interpret type expressions in signatures for algebras as well as type expressions in polymorphic programming languages as nonvariant relational functors of the form |G| → H. However, type expressions in which a type variable X occurs only positively, e.g., K → X or (X → K) → K, are expected to be “functorial.” They have an action on morphisms of G. This is facilitated by the fact that the usual examples of reflexive graph categories such as Set or Grp have graph relations ⟨g⟩ for every morphism g, which play the same role as the underlying morphisms. To avoid overuse of the term “graph,” we call ⟨g⟩ the “subsumption” relation of the morphism g. In this section, we give an axiomatic treatment of this property.
Every category C can be treated as a reflexive graph category Arr(C) whose ver- tex category is C and the edge category is the category of arrows of C. In other words, an edge between A and Aj is an arrow g : A → Aj and an edge morphism φ : g → h spanning f : A → B and fj : Aj → Bj is just a commuting square h◦f = fj ◦g. This is a relational reflexive graph category. A reflexive graph-functor between such “ar- row categories” is just an ordinary functor, and a parametric natural transformation between such functors is just a natural transformation.

Definition 6.5 A reflexive graph category G is said to be subsumptive if there is a (chosen) full and faithful functor, the “graph” functor, ⟨−⟩ : Arr(Gv) → G that is identity on the vertex category. A relational functor F : G → H between such categories said to be subsumptive if it commutes with the graph functor: F⟨g⟩ =
⟨Fg⟩ for all morphisms g of Gv.

The definition means that for every arrow g : A → Aj of Gv, there is an edge
⟨g⟩ : A ↔ Aj such that ⟨idA⟩ = IA. Moreover, the full faithfulness requirement means that an edge morphism φ : ⟨g⟩ → ⟨h⟩ between graph relations is the image

of a commutative square:
A 	> B	A 	> B 


g	h	⇐⇒
∨	f′	∨
Λ
⟨g⟩
f′
Λ
⟨h⟩
V
(13)

Aj 	> Bj	Aj 	> Bj
The reflexive graph category G is relational at least between graph relations. So, re- lational squares on the right of the implication are unique when they exist. Further, since IA = ⟨idA⟩, we obtain the identity condition [24]:
(f, fj): IA → IB ⇐⇒ f = fj	(14)
Reflexive graph categories of the form Rel(C) give examples of subsumptive reflexive graph categories with the choice of ⟨g⟩ : A ↔ Aj as the monic ⟨idA, g⟩ : A > A × Aj.
Fact 6.6 If F, G : G → H are subsumptive relational functors then parametric
transformations of type |F | →○ |G| are bijective with parametric natural transforma-
tions of type F →.  G.
In other words, parametricity subsumes naturality.
For dealing with contravariant functors, we need another notion. If G is a re- flexive graph category, then we write Gco for the reflexive graph category that has the same vertex and edge categories as G but the source and target functors ∂0 and ∂1 are exchanged. So, an edge R : A ↔ B in G becomes an edge B ↔ A in Gco. The reflexive graph category Gop, on the other hand, has reversed morphisms f : B → A for every morphism f : A → B of G and reversed squares φ : S → R for every square φ : R → S of G.
Definition 6.7 A reflexive graph category G is said to have converses if there is an isomorphism ( )× : G ∼= Gco that is identity on the vertex category. A relational functor F : G → H preserves converses if F (R×)= F (R)×.
Note that Rel(C) has converses. The converse of m : R > A×B is exchAB ◦m : R > B × A. Every relational functor on Rel(C) preserves converses because it preserves isomorphisms. On the other hand, Arr(C) does not have converses.
Fact 6.8 If a reflexive graph category G is subsumptive and has converses then Gop
is subsumptive, with the graph functor ⟨−⟩ : Arr(Gop) → Gop that sends edges g to
⟨g⟩× and commuting squares (f ,f ): h → g to squares (f ,f ): ⟨h⟩× → ⟨g⟩×.
2	1	2	1
Now, we can deal with contravariant functors in the same way as covariant functors above. If F and G are subsumptive relational functors of type Gop → H 
then parametric transformations of type |F | →○ |G| are one-to-one with parametric
natural transformations of type F →.  G. More interestingly, mixed variant functors
and dinatural transformations can also be treated in the same way.
Fact 6.9 If F, G : Gop ×G → H are subsumptive relational functors, where G and
H are subsumptive reflexive graph categories and G has converses, then parametric

dinatural transformations of type F →..
G are bijective with parametric transforma-

tions of type |F |Δ →○ |G|Δ: |G| → H.
Fibrational framework for logical relations
Reflexive graph categories of the previous sections allow us to overlay a category of edges on top of a category of “types” for modelling the “properties” or “relations” over the types. The uniformity properties of parametrically polymorphic functions are characterized in terms of invariance under all properties and relations. Such properties and relations have a “logical” character, which can be understood using the framework of fibrations. We use fibrations as a framework of categorical logic, representing an alternative view of Lawvere’s hyperdoctrines, as it has a good fit with logical relations and parametricity. See [21,50] for background on fibrations.
A ﬁbration involves two categories E and B and a functor ∂ : E → B, subject to an axiom called “cartesian lifting” stated below. We also say that E is ﬁbred over B. The category B, called the base category, models types. The category E , called the total category, models the “edges,” i.e., abstract properties or relations over types. The functor ∂ designates the underlying types of the properties. If ∂(R)= X, we say that R is “above” X, and understand that R is a property or a relation of X-typed values. If φ : R → S is a morphism such that ∂(φ)= f : X → Y , we say that φ is “above” f , and understand that φ represents an abstract proof witnessing the fact that f maps R-satisfying values of X to S-satisfying values of Y .
For any binary reflexive graph category G, the functor ∂ = ⟨∂0, ∂1⟩ : Ge → Gv ×Gv is a functor of this form. The notation R : A ↔ Aj of the previous sections implies that R is “above” the pair of vertices (A, Aj). If ∂ satisfies the cartesian lifting property, we say that G is a ﬁbred reflexive graph category.
The cartesian lifting property for ∂ is that, for any morphism f : X → Y in B and any edge S above Y , there is a canonical edge f∗S above X along with an edge morphism φ : f∗S → S above f which is universal, i.e., any other edge morphism ψ : P → S above a morphism of the form g; f : X → Y uniquely factors through φ. We can picture this in the following view:
f∗S	φ	> S 
.
.
.
.
.	.	.
X	> Y
f
where the dotted lines represent the idea of being “above” an object or arrow. The edge f∗S is called the reindexing of S along f and the edge morphism φ is called the cartesian lifting of f at S.
Example 7.1 Reflexive graph categories of the form Rel(C) are fibred provided the category C has pullbacks. Given a pair of arrows (f, fj) : (A, Aj) → (B, Bj) and an edge S > B × Bj above (B, Bj), the reindexing (f, fj)∗S is the pullback of f × fj : A × Aj → B × Bj and S > B × Bj. For example, in the reflexive graph

category Set, the reindexing is just the preimage:
(f, fj)∗S = { (x, xj) | (f (x),fj(xj)) ∈ S }
In the Plotkin-Abadi logic for parametricity [36], the reindexed relation (f, fj)∗S
can be expressed as a “definable relation:” (x : A, xj : Aj) f (x) [S] fj(xj).
The inverse image of an object X under ∂ is a subcategory of S called the ﬁbre above X and denoted SX . Its objects are the edges above X and arrows are the edge morphisms above idX . Reindexing along a morphism f : X → Y sends edges S in SY to edges f∗S in SX and, thus, can be regarded as a functor f∗ : SY → SX on the fibres.
The fibre SX represents a logic for the properties of X-typed values. Its products R × S represent conjunctions R Λ S, the exponentials R → S represent implications R ⇒ S etc. The universal and existential quantifiers are obtained as the adjoints to the reindexing functors. If πZX : Z×X → Z is the projection of the first component then, the reindexing functor (πZX )∗ : SZ → SZ×X is thought of as the “weakening” operation which regards a property over Z as a property over Z ×X by ignoring the X component. The existential quantifier  πZX and the universal quantifier  πZX
are the left and right adjoints of this operator:



  πZX
E (πZX )∗ E  π

: SZ×X → SZ


Relation lifting
The formulas given in Sec. 2 and 5 for logical relations corresponding to various type constructors such as product and function space can be generalized to arbitrary fibrations as follows.
Given fibrations ∂ : S → ¥ and ∂j : Sj → ¥j, we talk of “lifting” a functor F : ¥ → ¥j on the base categories to a functor F : S → Sj on the total categories. To say that F is a lifting of F is to say that the pair (F , F ) preserves the fibration functor: ∂j ◦ F = F ◦ ∂. Note that such a lifting need not be unique, and there is no requirement for it to preserve reindexing.
If η, ϵ : F E G : ¥j → ¥ is an adjunction, then a corresponding adjunction η˜, ϵ˜ : F E G : Sj →S is called a lifting of the base adjunction if the functors F and G are liftings of the corresponding base functors F and G and the unit/counit η˜ and ϵ˜ are above η and ϵ. A theory for lifting adjunctions in this way was developed in [16,17]. We illustrate it with examples for products and exponentials in the fibration
∂ : Rel → Set of unary relations (predicates) over the category of sets.
For lifting products, we start with the adjunction Δ E × : Set2 → Set and
proceed as indicated in Fig. 1. The lifting Δ˜ : Rel → Rel2 is the evident functor
R '→ (R, R), φ '→ (φ, φ). It is split into two parts Δ^ and Δ with the motivation of
using the “change of base” lifting represented in the right square [17, Lemma 4.1].
The category RelΔ represents the pullback of ∂2 and Δ in Cat. Its objects are pairs of relations (R, S) above the same set A.



Δ˜











Set ¸,	⊥	 Set2
×


Fig. 1. Lifting of the product adjunction





(π′,A)∗R→ˆ( )
A→( )




∂


vJ˛  s
( )×A	 ¸,7

Set ¸,	⊥	 Set
A→( )

Fig. 2. Lifting of the exponential adjunction

The functor Δ : Rel → RelΔ is the fibre-wise diagonal functor sending R above A to (R, R) above A. Its right adjoint is the fibre-wise product functor ×, repre- senting the conjunction or intersection of relations.
The functor Δ: RelΔ → Rel2 sends (R, S) above A to (R, S) above (A, A). Its right adjoint × is obtained by reindexing along the counit of the base adjunction,
viz., (π, πj). So, R × S = ((πAB)∗R, (πj	)∗S).
The right adjoint to Δ˜ is then the composite of the two right adjoints:

R × S = (πAB) R × (πAB ) S

This gives the formula used in Sec. 2, viz., (R × S)(a, b) ⇔ R(a) Λ S(b).
Lifting the exponential adjunction from Set to Rel is a little more involved as shown in Fig. 2. The middle and right adjunctions in the total category are similar to those for the product adjunction. The left adjunction amounts to requiring the fibration to have right adjoints to reindexing along projections, which is nothing

but universal quantification. On the whole, this gives the formula:


R ˜→ S =  π



A→B,A

j
A→B,A
^→ (ev A,B) S)


Expressed in terms of elements, it means (R ˜→ S)(f ) ⇔ ∀a : A. R(a) ⇒ S(f (a)).


Fibred reflexive graph categories
As noted above, the fibration concept can be combined with that of reflexive graph categories (which we abbreviate to “RG-categories”) by asking for the edges to be fibred over tuples of vertices. More precisely, a fibred RG-category satisfies the condition that the functor ∂ = ⟨∂0, ∂1⟩ : Ge → Gv × Gv is a fibration. Explored in [6,7], this structure allows us to import the “logical character” of fibrations to the setting of RG-categories.
The reindexing operation of ∂ implies that there is a “pre-image” edge (f, fj)∗S
as shown in the square on the right:


(f, fj)∗S	φ	> S 
f
A	> B 

.
.
.	.
.	(f,f′)	.
Λ	Λ
(f,f′)∗S	φ	S
V	V

(A, Aj) 	> (B, Bj)
Aj 	> Bj
f′


From reindexing, we immediately obtain a general formula for the graph of a morphism ⟨f⟩ = (f, idB)∗IB. In Set, this reduces to ⟨f⟩ = { (x, y) | f (x) =B y }. In Poset±, it reduces to the relation { (x, y) | f (x) ±B y }, which we denoted by ⟨f⟩± in Sec. 3.
By requiring the identity condition, f IA → IB fj ⇐⇒ f = fj, we obtain sub- sumptive RG-categories mentioned in Sec. 6.1. By requiring an “ordered” identity condition for locally ordered categories, f IA → IB fj ⇐⇒ f ± fj, we obtain weaker structures that we might call lax-subsumptive RG-categories, which include Poset±. Thus, fibred RG-categories give us a more general framework than simple subsumption.
The natural choice of 1-cells for fibred RG-categories would be that of ﬁbred RG-functors, i.e., RG-functors G → H that send cartesian morphisms in G to cartesian morphisms in H. However, this choices runs into the problem that fibred RG-categories do not have duals. If G is a fibred RG-category, the RG-category Gop obtained by reversing its arrows is not fibred. It is coﬁbred, with universal cocartesian morphisms R → (f, fj)∗R above pairs of arrows (f, fj). Therefore, we cannot treat the function type constructor → : Gop ×G → G as a fibred RG-functor. We would need biﬁbred RG-categories, i.e., those that are both fibred and cofibred, to accommodate the function type constructor.

Structural Induction and coinduction
Programming languages allow recursively defined types, which may be viewed as freely generated algebras. For example, the type of lists over A defined by
List A ∼= 1+ A × List A
represents a freely generated algebra with a single sort X and an operation in : (1 + A × X) → X. The source of the operation is given by an endofunctor TX = 1+A×X and the single operation of the algebra in : TX → X is called its “structure map.” The freely generated algebra, which is the intent of the recursive definition, is the initial object in the category of such algebras. The initial algebra facilitates inductive definition of functions as well as inductive proofs of properties. Relational parametricity plays a key role in interpreting such principles of induction.
Suppose T : G → G is a relational functor. An algebra for T is a pair ⟨X, α⟩ of a “carrier” object X of G and a “structure map” α : TX → X. A logical relation of T -algebras is a pair ⟨R, φ⟩ : ⟨X, α⟩ ↔ ⟨Xj, αj⟩ of an edge R : X ↔ Xj and an edge morphism φ : TR → R above (α, αj). The identity logical relation is I⟨X,α⟩ = ⟨IX, Iα⟩. A morphism of T -algebras f : ⟨X, α⟩ → ⟨Y, β⟩ is a morphism f : X → Y in G such that β ◦ Tf = f ◦ α. With a suitable notion of edge morphisms, we obtain a reflexive graph category Alg(T ) of T -algebras.
The initial object in Alg(T ) is called the initial algebra of T , denoted μ(T ) or μXT (X). Lambek made the important observation that the structure map of the initial algebra α : T (μ(T )) → μ(T ) is an isomorphism. From a computer science point of view, we may also think of μ(T ) as the “least fixed point” of T that is inductively generated.
The type of lists over A is thus the initial algebra μX (1 + A × X) of the end- ofunctor TX = 1 + A × X. Note that the functor has a corresponding relation action TeR = I1 + IA × R. To give an inductive definition of a function on lists, e.g., to determine the length of a list length : List A → Z, it is adequate to give T -algebra structure on Z. The structure map in this case is β : T Z → Z given by β = [λz. 0, λ(a, x). 1+ x]. Since the initial algebra μ(T ) has a unique morphism to any other algebra ⟨Y, β⟩ in Alg(T ), we obtain a map from lists to integers. We denote the unique morphism in question by fold⟨Y,β⟩ : μ(T ) → ⟨Y, β⟩.
To prove a property P of such an inductively defined function for “all lists,” e.g.,
to prove that length(l) is non-negative, the structural induction principle says that it is enough to prove it for the empty list and for a nonempty list (a, lj) assuming it to be true for lj.  The proof amounts to showing that the structure map of
⟨Y, β : TY → Y ⟩ preserves the property P in the sense that, whenever a value z : TY satisfies TeP , β(z): Y satisfies P . In other words, there is an edge morphism ψ : TeP → P above β : TY → Y , which is to say we havea Te-algebra ⟨P, ψ⟩ above
⟨Y, β⟩ in the reflexive graph category Alg(T ).
Structural induction allows us to conclude from this that fold⟨Y,β⟩ : μ(T ) →
⟨Y, β⟩ has an edge morphism above it Iμ(T ) → ⟨P, ψ⟩ in Alg(T ). Postulate this as a unique edge morphism fold⟨P,ψ⟩ : Iμ(T ) → ⟨P, ψ⟩. In other words, we expect

that Iμ(T ) is the initial algebra μ(Te) of the T functor at the level of edges. Recall- ing that IT = Te in the functor category GG (Fact 6.3), our expectation amounts to Iμ(T ) ∼= μ(IT ), which is nothing but the identity extension property for the μ operator.
The idea that structural induction is nothing but the identity extension prop- erty of the μ operator was proposed by Hermida and Jacobs [19] in the setting of fibrations.
Similarly, a coalgebra for a functor T : G → G is a pair ⟨X, α : X → TX⟩. There is a reflexive graph category CoAlg(T ) of such coalgebras. The final object in the category is denoted ν(T ) or νXT (X). Properties of final coalgebras can be proved using a coinduction principle, whose substance is again an identity extension property: Iν(T ) ∼= ν(IT ).
In fact, both initial algebras and final coalgebras can be expressed in terms of parametric limits and colimits using the formulas proposed by Plotkin and Abadi [36]:
μX T (X) = ∀X (T (X) → X) → X
νX T (X) = ∃X (X → T (X)) × X
Here T (X) is a type expression that is functorial. The equations hold in many parametric models of the (impredicative) polymorphic lambda calculus. Birkedal and Mogelberg [3] give a categorical axiomatization of such models. What happens beyond these models is not entirely clear. See Dunphy [6] for some results in this direction. Characterizing the classes of models where these equations hold and where they fail would form important steps in advancing our understanding of parametricity.
Further work
Reynolds’s exhortation to generalize homomorphisms from functions to relations comes to us as a “bolt from the blue.” Its implications will no doubt be far-reaching. In this article, we have attempted to give some idea of how Reynolds’s ideas might apply to mathematical considerations, for universal algebra and category theory. This work is far from complete. We outline some possible directions for future investigation.
Formulating a suitable categorical structure for representing logical relations and relational parametricity tops our list of priorities. In our treatment, we presented two possible approaches: reflexive graph categories, which model the action of type constructors on abstract relations along with the identity extension postulate, and ﬁbrations, which explain in a syntax-independent manner, the origin of logical re- lations formulae needed to obtain the relation actions. It appears to us that the eventual theory of parametricity needs to integrate the two approaches. This might involve understanding and isolating the stumbling blocks for the use of fibred func- tors. As well as the contravariance needed for the function type constructor, see Pitts [35, Sec. 4] for some of the issues in preserving cartesian liftings.
The category theorist would no doubt wonder about the notion of composition

for logical relations. The problem is that, in the first place, the function type con- structor does not preserve the composition of relations, and, secondly, composition brings back the variance issues of functors, which logical relations are meant to avoid. Note that homomorphisms pre- and post-compose with logical relations, although the resulting bimodule structures remains to be explored. It would also be interesting to consider composite logical relations of higher arities [22]. On the other hand, the structure of relations under composition leads to the consideration of bicategories of relations, which might also be appropriate in some contexts. The categorical analysis of relational modalities carried out in [18] considers this direc- tion. The lifting of endofunctors in this context, with applications to coalgebraic bisimulation in the spirit of Sec. 2 is addressed in [2] and the references therein.
Cross connections with other areas that employ relational correspondences need to be made. We have in mind, for instance, the work in universal algebra dealing with Galois connections between theories and relations, as well as the growing body of work in computer science on coalgebraic bisimulations and modalities.
A logic for parametricity has been proposed in [36], where all the previously known consequences of Reynolds’s identity extension postulate have been formally derived. The soundness of such a system is established in [3] using fibrational models. Dunphy [6] proposes a logic called System P for reasoning about fibred reflexive graph categories appropriate for polymorphic lambda calculus. Such logics can be useful for abstracting from some of the sophisticated categorical machinery involved in the models.

References
Abramsky, S. A. and T. P. Jensen, A relational approach to strictness analysis for higher-order polymorphic functions, in: Eighteenth Ann. ACM Symp. on Princ. of Program. Lang., ACM, 1991,
pp. 49–54.
B´ılkova´, M., A. Kurz, D. Petrisan and J. Velebil, Relation lifting, with an application to the many-valued cover modality, Logical Methods in Comp. Sci. 9 (2013), pp. 1–48.
Birkedal, L. and R. E. Møgelberg, Categorical models of Abadi-Plotkin’s logic for parametricity, Math. Struct. Comput. Sci. 15 (2005), pp. 709–772.
Bodnarchuk, V. G., L. A. Kaluzhnin, N. N. Kotov and B. A. Romov, Galois theory for Post algebras, I, Cybernetics 5 (1969), pp. 243–252.
de Roever, W.-P. and K. Engelhardt, “Data Refinement: Model-Oriented Proof Methods and their Comparison,” Cambridge Univ. Press, 1998.
Dunphy, B. P., “Parametricity as a Notion of Uniformity in Reflexive Graphs,” Ph.D. thesis, University of Illinois, Dep. of Mathematics (2002), available electronically from http://www.cs.bham.ac.uk/~udr.
Dunphy, B. P. and U. S. Reddy, Parametric limits, in: Proc. 19th Ann. IEEE Symp. on Logic in Comp. Sci., IEEE, 2004, pp. 242–253.
Ehresmann, C., Cat´egories structur´ees, Ann. Sci. E´cole Norm. Sup. 80 (1963), pp. 349–425.
Eilenberg, S., “Automata, Languages, and Machines; Vol. B,” Academic Press, 1976.
Eilenberg, S. and S. Mac Lane, General theory of natural equivalences, Trans. Amer. Math. Society 58
(1945), pp. 231–294.
Fiore, M. P., A. Jung, E. Moggi, P. W. O’Hearn, J. Riecke, G. Rosolini and I. Stark, Domains and denotational semantics: History, accomplishments and open problems, Bulletin of the European Assoc. for Theoretical Computer Science 59 (1996), pp. 227–256.

Freyd, P., Core algebra revisited, Theoretical Comput. Sci. 375 (2007), pp. 193–200.
Geiger, D., Closed systems of functions and predicates, Pacific J. Math. 27 (1968), pp. 95–100.
Ginzburg, A., “Algebraic Theory of Automata,” Academic Press, New York, 1968.
Ginzburg, A. and M. Yoeli, Products of automata and the problem of covering, Trans. Amer. Math. Soc 116 (1965), pp. 253–266.
Hermida, C., Fibrations, logical predicates and indeterminantes, Ph.D. thesis and Technical Report ECS-LFCS-93-277, University of Edinburgh (1993).
Hermida, C., Some properties of fib as a fibred 2-category, J. Pure and Applied Algebra 134 (1999),
pp. 83–109.
Hermida, C., A categorical outlook on relational modalities and simulations, Inf. Comput. 209 (2011),
pp. 1505–1517.
Hermida, C. and B. Jacobs, Structural induction and coinduction in a fibrational setting, Inf. Comput.
145 (1998), pp. 107–152.
Hoare, C. A. R., Proof of correctness of data representations, Acta Informatica 1 (1972), pp. 271–281.
Jacobs, B., “Categorical Logic and Type Theory,” Studies in Logic and the Foundations of Mathematics
141, Elsevier, 1999.
Jung, A. and J. Tiuryn, A new characterization of lambda definability, 1993 pp. 245–257.
Kelly, G. M. and R. Street, Review of the elements of 2-categories, in: G. M. Kelly, editor, Proc. Sydney Category Seminar, Lect. Notes Math. 420, Springer-Verlag, 1974 pp. 75–103.
Kinoshita, Y., P. W. O’Hearn, A. J. Power, M. Takeyama and R. D. Tennent, An axiomatic approach to binary logical relations with applications to data refinement, in: M. Abadi and T. Ito, editors, Theoret. Aspects of Comp. Softw., LNCS 1281, Springer-Verlag, 1997 pp. 191–212.
Mac Lane, S., “Categories for the Working Mathematician,” Springer-Verlag, 1991, second edition.
Mac Lane, S. and G. Birkhoff, “Algebra,” Chelsea, New York, 1993, third edition.
Milner, R., An algebraic definition of simulation between programs, in: Proc. Second Intern. Joint Conf. on Artificial Intelligence, The British Computer Society, London, 1971, pp. 481–489.
Mitchell, J. C., Type systems for programming languages, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Volume B, North-Holland, Amsterdam, 1990 pp. 365–458.
Mitchell, J. C., “Foundations of Programming Languages,” MIT Press, 1997.
Mitchell, J. C. and G. D. Plotkin, Abstract types have existential types, ACM Trans. Program. Lang. Syst. 10 (1988), pp. 470–502.
Mitchell, J. C. and A. Scedrov, Notes on sconing and relators, in: Computer Science Logic ’92, Selected Papers, LNCS 702, Springer-Verlag, 1993 pp. 352–378.
O’Hearn, P. W. and R. D. Tennent, Parametricity and local variables, J. ACM 42 (1995), pp. 658–709, (Reprinted as Chapter 16 of [33]).
O’Hearn, P. W. and R. D. Tennent, “Algol-like Languages (Two volumes),” Birkha¨user, Boston, 1997.
Parnas, D. L., Information distribution aspects of design methodology, in: IFIP Congress 71, North- Holland, 1971, pp. 339–344.
Pitts, A. M., Relational properties of domains, Inf. Comput. 15 (1996), p. 66.
Plotkin, G. and M. Abadi, A logic for parametric polymorphism, 1993, pp. 361–375.
Plotkin, G., J. Power, D. Sannella and R. Tennent, Lax logical relations, in: Intern. Colloq. Aut., Lang. and Program., Springer-Verlag, 2000 pp. 85–102.
Plotkin, G. D., Lambda definability in the full type hierarchy, in: J. R. Hindley and J. P. Seldin, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, Academic Press, 1980 pp. 363–373.
Plotkin, G. D., Domains (Pisa notes), Electronic manuscript, University of Edinburgh (1983), available from http://homepages.inf.ed.ac.uk/gdp/publications/.


P¨oschel, R., Galois connections for operations and relations, in: K. Denecke, M. Erne and S. L. Wismath, editors, Galois Connections and Applications, Kluwer, 2004 pp. 231–258.
Reynolds, J. C., “The Craft of Programming,” Prentice-Hall International, London, 1981.
Reynolds, J. C., Types, abstraction and parametric polymorphism, in: R. E. A. Mason, editor,
Information Processing ’83, North-Holland, Amsterdam, 1983 pp. 513–523.
Reynolds, J. C., Polymorphism is not set-theoretic, in: G. Kahn, D. B. MacQueen and G. Plotkin, editors, Semantics of Data Types, LNCS 173, Springer-Verlag, 1984 pp. 145–156.
Robinson, E. and G. Rosolini, Reflexive graphs and parametric polymorphism, in: Proc. Ninth Ann. IEEE Symp. on Logic in Comp. Sci., IEEE, 1994, pp. 364–371.
Sangiorgi, D., On the origins of bisimulation and coinduction, ACM Trans. Program. Lang. Syst. 31
(2009), p. 15.
Sannella, D. and A. Tarlecki, “Foundations of Algebraic Specification and Formal Software Development,” Springer-Verlag, 2012.
Scott, P. J., Some aspects of categories in computer science, in: M. Hazewinkel, editor, Handbook of Algebra, Vol. 2, Elsevier, 2000 pp. 3–77.
Statman, R., Logical relations and the typed lambda calculus, Inf. Control 65 (1985), pp. 85–97.
Strachey, C., Fundamental concepts in programming languages, J. Higher-order Symbolic Comput. 13
(2000), pp. 11–49, (original lecture notes, Copenhagen, 1967).
Streicher, T., Fibred categories a` la B´enabou (1999), lecture Notes, available electronically from
http://www.mathematik.tu-darmstadt.de/~streicher/.
van der Waerden, B. L., “Modern Algebra,” Unger, New York, 1949, second edition, (Translated from German by Fred Blum, original version 1930-31).
