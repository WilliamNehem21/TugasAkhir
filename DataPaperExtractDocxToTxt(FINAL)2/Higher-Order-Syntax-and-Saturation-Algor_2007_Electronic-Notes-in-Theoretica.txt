Electronic Notes in Theoretical Computer Science 174 (2007) 15–27	
www.elsevier.com/locate/entcs

Higher-Order Syntax and Saturation Algorithms for Hybrid Logic
Moritz Hardt1	Gert Smolka1
Programming Systems Lab Saarland University Saarbru¨cken, Germany

Abstract
We present modal logic on the basis of the simply typed lambda calculus with a system of equational deduction. Combining first-order quantification and higher-order syntax, we can maintain modal reasoning in terms of classical logic by remarkably simple means. Such an approach has been broadly uninvestigated, even though it has notable advantages, especially in the case of Hybrid Logic.
We develop a tableau-like semi-decision procedure and subsequently a decision procedure for an alternative characterization of HL(@), a well-studied fragment of Hybrid Logic.
With regards to deduction, our calculus simplifies in particular the treatment of identities. Moreover, labeling and access information are both internal and explicit, while in contrast traditional modal tableau calculi either rely on external labeling mechanisms or have to maintain an implicit accessibility relation by equivalent formulas.
With regards to computational complexity, our saturation algorithm is optimal. In particular, this proves the satisfiability problem for HL(@) to be in PSPACE, a result that was previously not achieved by the saturation approach.
Keywords: Hybrid logic, modal logic, lambda calculus, tableau systems, decision procedures


Introduction
When explaining the features of a modal logic, modal logicians stress the point that these languages support an internal view on a relational structure, while on the contrary classical logic employs external mechanisms such as quantification and variable-binding [4]. Consequently, modal logics deserve special-purpose syntax and semantics which capture this essential idea. Surprisingly though, most texts on modal logic introduce “standard translations”, mappings which recursively elimi- nate modal syntax in favor of first-order predicate logic. This exhibits a trade-off. On the one hand, modal reasoning is comfortable in its traditional presentation. On the other hand, the coherence of classical syntax with standard semantics is desirable.

1 {hardt,smolka}@ps.uni-sb.de


1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.023

Taking these points into consideration, we develop a formulation of modal logic based on the simply typed lambda calculus [7] with a system of equational deduc- tion [14]. By combining first-order quantification and higher-order syntax, Kripke semantics is fully internalized in our approach. With a few key definitions, syntax, semantics and deduction is set up for modal logics. While we make a commitment to classical logic, we maintain the “local perspective” of modal logic in our native syntax. Even more so, traditional modal syntax is preserved on a notational level. This way, standard translations are obsolete. Along the line, our approach remedies the problems with β-conversion as they appear in the work of Fitting [11,9] who gives examples of β/η-equal modal terms denoting differently, which is clearly in conflict with the lambda calculus. In order to avoid phenomena like these, we make names for points of evaluation explicit, already in the case of our minimal modal logic MF.
This leads us to the consideration of Hybrid Logic. In a common formulation, often referred to as HL(@, ↓), Hybrid Logic enriches the minimal modal logic K with naming, binding, and referencing constructions, as well as an implicit identity judgement [5,1,4]. We offer an equivalent logic called MFI that extends MF with the identity predicate. Once HL(@) is characterized as the monadic fragment of MFI, we develop a tableau calculus and a tableau-based decision procedure for this logic. The first such algorithm is due to Tzakova [15]. Recently, Bolander and Brau¨ner [6] extended Tzakova’s system by a treatment of the universal modalities and a proof of termination using loop-checking techniques. A semi-decision pro- cedure in form of a tableau calculus is given by Blackburn [3] who discusses the advantages of internalizing labeled deduction in Hybrid Logic. However, none of these results is optimal with respect to computational complexity.



Contributions and Overview
In Section 3, we present syntax, semantics, and deduction for modal logics on the basis of classical logic. Traditional modal syntax is preserved on a notational level, which makes standard translations dispensable. We solve previous problems with β-conversion that are inherent in traditional modal syntax. Proving equivalence, we provide alternative characterizations of HL(@, ↓) and HL(@).
In Section 4, we develop a tableau-based semi-decision procedure for monadic MFI, i.e., HL(@). Careful analysis of the role of the identity predicate in monadic MFI leads to simple saturation rules. Moreover, deduction is fully internal carrying forward [3], but in contrast to [3] we still profit from an explicit access relation at the object level.
In Section 5, we extend our saturation approach to a polynomial space decision procedure for the satisfiability problem of monadic MFI. We are not aware of any previous tableau-based result that matches the PSPACE lower bound for this problem.
Extended discussion of the sections 3 and 4 can be found in [13].

The Logical Base
We consider a simply typed lambda calculus where every term has a unique type. Interpretation for terms and types is provided by standard semantics. In our sys- tem, logical constants are axiomatized by equations and deduction itself is purely equational. For a full discussion of this topic see [14].
Figure 1 specifies a system of first-order predicate logic which includes derived modal operators. The axioms are known to enforce a canonical interpretation of the constants.

Theory	ML
Base Types	B, V
Constants	0: B
→ : B → B → B
∀ : (V → B) → B
=˙ : V → V → B
R : V → V → B
Axioms	0 → x =1 1 → x = x
x ∨ y = y ∨ x	Commutativity
f 0 → f 1 → fx = 1	Boolean Case Analysis
∀(λx.1) = 1
∀f → fx = 1	Instantiation
x=˙ x = 1	Reflexivity
x=˙ y → fx → fy = 1	Replacement
Derived  Constants	1= 0 → 0
¬x = x → 0
x ∨ y = (x → y) → y x ∧ y = ¬(¬x ∨ ¬y)
∃f = ¬(∀(λx.¬(fx)))
□xf = ∀y.Rxy → fy 
  xf = ∃y.Rxy ∧ fy 
Notation	∀x.t = ∀(λx.t)
∃x.t = ∃(λx.t)
Fig. 1. First-order Predicate Logic with Modal Operators

For each type we assume a countably infinite set of variables. For a term t, FV t denotes the set of free variables of type V occurring in t. If FV t = ∅, we say that t is closed. We furthermore assume a countably infinite set Par of constants of type V called parameters. The set of parameters occurring in a term t is denoted by Par t.

Variables of type B and V are written as x, y, while we use a, b for parameters.
The letters u, v may either refer to a variable of type V or a parameter.
We denote by t[u := v] the term obtained from t by replacing all (capture-free) occurrences of u by v. The size of a term t, denoted by |t|, is defined by structural recursion as usual. A formula is a term of type B.



Modal Logic Revisited

Our presentation of modal logic relies on the following key components.
Type constant V
Names u, v : V
Propositional variables f, g : V → B
Relational constant R : V → V → B
Modal operators  , □ : V → (V → B) → B
The type constant V is interpreted by a non-empty set of objects called vertices. Propositional variables denote predicates on vertices. Accordingly, the modal oper- ators enable judgments about a vertex and a property of vertices. It is straightfor- ward to pin down the semantics of the modal operators by means of the two axioms depicted in Figure 1. Arranged in a more suggestive way, these terms enjoy the intuitive reading:
□u(λx.t) “At u, all direct successors x satisfy t.”
 u(λx.t) “At u, some direct successor x satisfies t.”
Surprisingly, a “traditional” modal syntax is still available on a notational level. For this purpose, we reserve a single fixed variable π : V and think of π as the current point of evaluation in our model. This is the standard technique to mimic the external positional argument in Kripke semantics. In a next step, we situate propositional variables as well as the modal operators at π, and hide the free variable by the notation introduced in Figure 2. This allows us to define a traditional minimal modal logic as follows.
Definition 3.1 t ∈ K ::= f˚| ¬t | t ∧ t | □˚t
By dropping the restriction to a single name, we arrive at the first modal fragment
of our choice.
Definition 3.2 t ∈ MF ::= fu | ¬t | t ∧ t | □u(λx.t)
MF subsumes our modal notation. On the other hand, there are certain formulas which lack a single-variable equivalent, e.g., fa ∧ ¬(fb). The point is that MF already is hybrid in that it delivers certain naming and binding capabilities which are absent in K.


Hybrid Logic, Identity and MFI
Hybrid Logic is an extension of K with the advantage that it allows to name and identify vertices. For this purpose, HL introduces three new constructions as de- picted in Figure 2.
Definition 3.3 t ∈ HL ::= f˚| ˚u | ¬t | t ∧ t | □˚t | @u.t |↓ x.t
A formula ˚u is called a nominal, @ the satisfaction-operator, and ↓ the down- operator. HL is often referred to as HL(@, ↓) to distinguish the fragment HL(@) which excludes the down-operator. In this case, u ∈ Par, by convention. Since the remaining free variable π may be replaced by a fresh parameter with the help of the satisfaction-operator, we assume without loss of generality that terms in HL(@) are closed.
Via β-reduction, HL maps into the following extension of MF.
Definition 3.4 t ∈ MFI ::= fu | u=˙ v | ¬t | t ∧ t | □u(λx.t)
Interestingly, this time there exists an inverse mapping. While K and MF do not match up, we find essentially for every term in MFI an equivalent one in modal notation.
Proposition 3.5 Consider the following mapping ϕ ∈ MFI → HL deﬁned by recursion on t ∈ MFI. It holds for all t ∈ MFI with π /∈ FV t that ML ▶ t = ϕt. ϕ(fu) = @u.f˚
ϕ(¬t) = ¬(ϕt)
ϕ(t ∧ t') = (ϕt) ∧ (ϕt')
ϕ(u=˙ v) = @u.˚v ϕ(□u(λx.t)) = @u.□˚(↓ x.ϕt)
As a matter of fact, HL and MFI coincide in a natural way. But, is there a similar result for HL(@)? The operators ↓ and @ are eliminated by β-reduction and therefore indistinguishable in MFI. There is no operator we could simply omit. Instead, we must find a different characterization of HL(@).
Considering nominals ˚a, we find that each identity in HL(@) contains a param- eter. We call this property quasi-monadicity.
Definition 3.6 (Quasi-Monadic Formula) We call a formula t ∈ MFI quasi-

monadic, if every subterm of the form u=˙ v contains a parameter.
Moreover, the scope of the quantifiers is well-nested. That is, every term can be represented with a single bound variable.
Definition 3.7 (Monadic Formula) A formula t ∈ MFI is called monadic, if it is quasi-monadic and every subterm of the form λx.t' is closed.
Definition 3.8 MFI1 = {t ∈ MFI | t monadic and closed}
It is straightforward to prove the analogon of Proposition 3.5, that is, to define a mapping ϕ ∈ MFI1 → HL(@) such that for all t ∈ MFI, it holds ML ▶ t = ϕt. Proof of this fact and the following proposition is found in [13].
Proposition 3.9 For every quasi-monadic formula, we can compute an equivalent monadic formula.
The Case of Modal Base Syntax
Let us evaluate modal notation as a possible base syntax. More precisely, we con- sider □˚ a constant of type B → B, f˚ a constant of type B and so on. Now, with respect to modal semantics, the terms t1 = ˚□f˚ and t2 = (λq.□˚q)f˚ must denote differently, if f˚ is a “non-rigid” constant. For that reason we should be able to distinguish these formulas. However, λq.□˚q η-reduces in one step to □˚, and t2 even β-equals t1. So, with respect to the underlying lambda calculus, there is absolutely no justification to discriminate t1 and t2.
Surprisingly, on a notational level these terms are uncritical. The formula t2 is a short hand for (λq.□π(λπ.q))(fπ). As substitution does not capture, this term β-reduces to □π(λπ'.f π) in contrast to t1 = □π(λπ.f π). In fact, analyzing t2 deductively in ML yields the modal formula with the intended semantics.
t2 = □π(λπ'.f π)= □π(λπ'.0 ∨ fπ)= □π(λπ'.0) ∨ fπ = □˚0 ∨ f˚
The third equation can be derived from well-known quantifier laws. Remarkably, by classical reasoning, we solve a problem related to modal syntax.
A Saturation Procedure for MFI1
In this section, we devise a tableau-like semi-decision procedure for MFI1. In a way that will be suitable for our later analysis, we restate a version of MFI in negation normal form as well as slightly modified syntactic characterizations.
Definition 4.1 MFI is the set of formulas of the following form.
t ::= fu | ¬(fu) | u=˙ v | ¬(u=˙ v) | Ruv | t ∧ t | t ∨ t | □u(λx.t) |  u(λx.t)
Definition 4.2 A formula t ∈ MFI is called
proper, if it does not contain any subterm of the form Ruv.
quasi-monadic, if it is proper and every subterm of the form u=˙ v contains a parameter.

monadic, if it is quasi-monadic, |FV t| ≤ 1 and every subterm of the form λx.t' is closed.
Definition 4.3 MFI1 = {t ∈ MFI | t monadic and closed}
Definition 4.4 (Trivial) A set of formulas C is called trivial if either {t, ¬t} ⊆ C
or ¬(t=˙ t) ∈ C for some term t.
Definition 4.5 (Purely Monadic) A set of formulas C is purely monadic, if C ⊆ MFI1. It is monadic, if all members are either monadic or of the form Ruv.
Definition 4.6 A set of formulas is satisﬁable if and only if there exists an inter- pretation I and an assignment σ such that I |= ML and I,σ |= t = 1 for every t ∈ C
Definition 4.7 (Clause) A clause is a finite set of formulas. The degree of an
def
empty clause is 0, otherwise deg C = maxt∈C |t|.
def
Definition 4.8 We will use the notation (λx.t) ↓ u = t[x := u].

Saturatedness
The design space for our later calculus will be given in this section in terms of saturatedness conditions. The idea is that if a set of formulas respects these closure conditions and we cannot observe an obvious contradiction, then, in fact, this set must be satisfiable. We will formulate this result as a model existence theorem.
Definition 4.9 (Saturatedness) A set of formulas C is saturated, if it satisfies all of the following conditions.
(Sc) C is not trivial
(S∧) If s ∧ t ∈ C, then {s, t} ⊆ C.
(S∨) If s ∨ t ∈ C, then s ∈ C or t ∈ C.
(S ) If  ut ∈ C, then {Rux, t ↓ x} ⊆ C for some x. (S□) If □ut ∈ C and Ruv ∈ C, then t ↓ v ∈ C.
(Ss ) If u=˙ v ∈ C, then v=˙ u ∈ C.
(S=˙ ) If u=˙ a ∈ C and t ∈ C, then t[u := a] ∈ C.
Definition 4.10 For a set of formulas C, we define ∼C to be the least equivalence
def
relation such that u ∼C v whenever u=˙ v ∈ C. We write [u]C = {v | u ∼C v} to
denote the equivalence class of u with respect to ∼C. An equivalence class [u]C is called trivial, if [u]C = {u}.
Proposition 4.11 (Parameter Existence) Let C be a monadic set of formulas. Every nontrivial equivalence class [u]C contains a parameter.
Proposition 4.12 (Agreement) Let C be a saturated monadic set of formulas. Given u /= a, it holds u ∼C a if and only if u=˙ a ∈ C.
A proof of the following result can be found in [13].

Theorem 4.13 (Model Existence) Every (ﬁnite) saturated monadic set of for- mulas is satisﬁable in a (ﬁnite) model.
Proof (Sketch) Given a saturated monadic set of formulas C, our goal is to con- struct a model satisfying C. The interpretation of V will be the set of all equivalence classes of ∼C. To connect this domain of our model with the terms in C, we need representatives. The crucial idea is to choose a parameter as the representative of a nontrivial equivalence class (cf. Parameter Existence). Having done so, we can use Agreement (Proposition 4.12) and (S=˙ ) to argue that this parameter holds a copy of the appropriate terms.	 

Saturation
Previously, we established the notion of a saturated monadic set of formulas and proved that such sets are satisfiable. The computational counterpart is a procedure which performs saturation steps. We approach this goal by defining a binary relation between clauses by means of a few easily computable rules.
Definition 4.14 (Saturation) We let γ be a mapping from clauses to variables of type V such that γC /∈ FV C. The saturation relation → over clauses is defined as follows:
C → D if and only if C ⊂ D and D can be obtained from C by applying one of the following rules.
(C∧) If s ∧ t ∈ C, add s and t.
(C∨) If s ∨ t ∈ C and neither s ∈ C nor t ∈ C, add s or t. (C ) If  ut ∈ C, add Ru(γC) and t ↓(γC).
(C□) If □ut ∈ C and Ruv ∈ C, add t ↓ v. (Cs ) If u=˙ v ∈ C, add v=˙ u.
(C=˙ ) If u=˙ a ∈ C and t ∈ C, add t[u := a].
We say C → D don’t care, if C → D by one of the saturation rules excluding (C∨). We say C → D1, D2 don’t know, if D1 and D2 are the two alternative results of applying (C∨) to some s ∨ t ∈ C.
It is a simple task to show that these rules satisfy the key properties Soundness and Completeness. Soundness ensures that satisfiability propagates back and forth over the application of a saturation rule.
Proposition 4.15 (Soundness) (i) If C → D don’t care, then C is satisﬁable if and only if D is satisﬁable.
(ii) If C → D1, D2 don’t know, then C is satisﬁable if and only if D1 is satisﬁable or D2 is satisﬁable.
To formulate completeness, we will call a purely monadic clause C consistent, if from C we cannot derive a conflict. More precisely, there exists no clause D with C ⊆ D such that D can be obtained from C by applying any finite sequence of saturation steps.

Proposition 4.16 (Completeness) Consistent purely monadic clauses are satis- ﬁable.
Proof. Let C be a consistent purely monadic clause. We can apply the saturation rules in a systematic way in order to obtain a (not necessarily finite) set of formulas D with C ⊆ D such that D cannot be extended by application of a saturation rule. This is a standard technique as described in, for example, [11,3]. Since C is consistent, D is not trivial. Moreover, D is monadic, since monadicity is preserved by saturation [13].
Consequently, C is a saturated monadic set of formulas and thus satisfiable by our previous model existence theorem.	 

Related Tableau Calculi
Tzakova [15] was the first to introduce a tableau-based decision procedure for HL(@). Besides the standard modal and boolean rules, her system comprises four rules concerning @ and nominals (identity). In order to achieve termination, Tza- kova states an involved special-purpose branch extension procedure. Shortly after, Blackburn [3] discusses the advantages of internalizing labeled deduction for Hybrid Logic. He stresses the point that nominals should be considered formulas in order to establish labeling discipline at the object level. To handle identities, Blackburn in- troduces four rules: Reflexivity, Symmetry, Replacement and a rule called “Bridge”. Finally, Bolander and Bra¨uner [6] extend the calculi of Tzakova and Blackburn by a treatment of the universal modalities and give a simplified discussion. In the case of Tzakova’s system, they recognize that two of her rules are subsumed by a strong replacement rule as used by Blackburn. However, such a strong replacement rule immediately requires loop-checking as shown in [13].
Our calculus carries forward the arguments of Blackburn, as state labels are inte- gral parts of formulas. Blackburn avoids the use of meta-level information and thus represents the successor relation Ruv by an equivalent formula like u(λx.x=˙ v) or @u. ˚˚v, respectively. To maintain this representation, he must install the additional rule “Bridge”.
@˚u. ˚˚v	@˚v.˚a
@u. ˚˚a
In our system, the access relation itself is a formula. But then, “Bridge” is just a special case of (C=˙ ): {Ruv, v=˙ a} → {... , Rua}.
In contrast to Blackburn’s system, many modal tableaux as those of Fitting [8,10] and Gabbay [12] maintain external state labels and access information. It turns out that both of these can be naturally represented at the object level.

Saturation in Polynomial Space
In this section we describe a decision procedure for the satisfiability problem of MFI1 based on our saturation rules. A central feature of this algorithm is that it matches the PSPACE lower bound for HL(@) [2].

In the case of MF, that is in the absence of identities, a simple standard tech- nique yields an optimal tableau-based decision procedure. We describe this tech- nique as depth-ﬁrst saturation: When a clause C does not admit any further appli- cation of the saturation rules except for (C ), we pick a diamond ut ∈ C, gather all boxes □ut1,... , □utk and start saturating the clause {t ↓ x, t1 ↓ x,... , tk ↓ x}. If no contradiction occurs, we continue with C\{ ut}.
The intuitive reason why this algorithm uses only polynomial space is that the possibly large set of “edges” Ruv is not stored explicitly. Instead, this graph is traversed “manually” in a depth-first manner. However, in the case of MFI (even MF) this procedure is without modification incomplete. Closed terms might occur which would have been required at an earlier stage of the algorithm in order to reveal a contradiction.
We can anticipate this problem as follows.
On input of a monadic clause, we guess an equivalence relation on its parame- ters. With fixed representatives for the equivalence classes, we “simplify” the clause in accordance with our choice. This will decrease the size of the result- ing clause and it will prevent us from storing terms several times for related parameters.
Additionally, we guess which subterms occurring in this updated clause will (for example by means of (C=˙ )) eventually be added to the parameter component, i.e., the sub-clause consisting of only closed terms.
We perform the standard depth-first saturation with respect to these additional information and verify our choice.
To make these points precise, we introduce the following notation.
Definition 5.1 Let C be a monadic clause.
For each equivalence relation on Par C we consider a fixed system of represen- tatives ρ ∈ Par C → Par C. We write ρt to denote the term obtained from t by replacing each occurring parameter a with its representative ρa.
def
Accordingly, ρC = {ρt | t ∈ C}.
We define Clo C to be the clause containing all subterms of C where the possible free variable has been replaced by a parameter a ∈ Par C.
For  ut ∈ C, we define C ut = {t ↓ x, t1 ↓ x,... , tk ↓ x} where □ut1, ... , □utk are all terms in C of the form □ut'. Furthermore, x is a fresh variable, which we call the characteristic variable of the clause C ut.
Figure 3 introduces our saturation algorithm.
Lemma 5.2 The saturation algorithm terminates on input of a purely monadic clause C and uses polynomial space.
Proof. Let C be a purely monadic clause and let us consider |C|· (deg C) as the input size.
Observe that that each choice of ρ and B in (1) is of polynomial size. In par-



AC =  ρ  B AB(B ∪ ρC)	where B ⊆ Clo(ρC)
ABC = false	if C is trivial or conflicting†
ABC = ABD	if C → D don’t care, excluding (C )
ABC = ABD1  ABD2	if C → D1, D2 don’t know
ABC =   ut∈C ABC  ut	otherwise
†C is conflicting, if a=˙ b ∈ C and a /= b or there is a closed term t ∈ (C\B).

Fig. 3. Saturation Algorithm
ticular, there are finitely many such choices. Moreover, consecutive calls to (3) and
(4) have a polynomial bound as we have ruled out (C ). On the other hand, when- ever we execute (5) on a clause D ⊆ C we know that for every ut ∈ D, we have deg D > deg D ut. Thus, the depth of such recursive calls is bounded in the degree of the input clause C.
If we reuse space in (1), (4), and (5) we achieve an overall space consumption which is bounded by a polynomial in the size of the input.	 
Theorem 5.3 By means of the saturation algorithm we can decide in polynomial space whether or not a purely monadic clause is satisﬁable.
Proof. Let C be a purely monadic clause. After the previous lemma, it remains to prove that C is satisfiable if and only if AC = true.
If C is satisfiable, there exists a clause D which is a saturated extension of
C. From D we obtain appropriate ρ and B for which it is simple to show that
AB(B ∪ ρC)= true. Consequently, AC = true.
Conversely, from the fact that AC = true we construct a saturated extension of
C. That is, if AC = true, then AB(B ∪ ρC)= true for some ρ and B. By traversing the recursion tree for this procedure call, we obtain clauses D1,... , Dm where each

of these clauses Di has the property that ABDi = 
 ut∈D
i ABDi
= true, and

each Di was computed by executing ABDj for some j < i where we let D0 = B∪ρC.
We assume that all characteristic variables are disjoint.
Furthermore, let R be the set of terms Rux whenever x is the the characteristic
variable of a clause Dj that was obtained by executing ABDi	for some  ut ∈ Di
and i < j. We must also add Rua in case x=˙ a ∈ Dj for some parameter a.
Finally, we define D to be the clause obtained from D' =  i Di ∪ R, by adding for each formula t ∈ D' all those copies of t where the parameters a1,... , ak occurring in t have been replaced by arbitrary b1,... , bk with ρbi = ai.
Clearly, C ⊆ D. Moreover, we can prove that D is saturated and thus satisfiable by Model Existence (Theorem 4.13).
(Sc) Arguing by contradiction, assume D is trivial and {t, ¬t} ⊆ D. Then, we have {ρt, ¬(ρt)} ⊆ D' where ρt ∈ Di and ¬(ρt) ∈ Dj for some i, j. If ρt is closed, then {ρt, ¬(ρt)} ⊆ B, since neither Di nor Dj is conflicting. But then, AB(B ∪ ρC)= false. If ρt contains a free variable x, then x is the characteristic

variable of both Di and Dj. Thus, i = j and ABDi = false follows. Either way it is a contradiction. The case of ¬(t=˙ t) ∈ D is clear.
(S∧), (S∨), (Ss ) Straightforward.
(S ) Assume  ut ∈ D, then  (ρu)(ρt) ∈ Di for some i. Then, there is Dj with j > i and a characteristic variable x such that R(ρu)x ∈ R and (ρt) ↓ x ∈ Dj ⊆ D'. Consequently, {Rux, t ↓ x} ⊆ D.
(S□) Suppose {□ut, Ruv} ⊆ D. We demonstrate the case where u is a variable, but v is a parameter. We have □u(ρt) ∈ Di. But, to obtain the edge Ruv ∈ R, there must be a clause Dj with j > i and a characteristic variable y such that t ↓ y ∈ Dj and y=˙ v ∈ Dj. Thus, by application of (C=˙ ), we have (ρt) ↓ v ∈ D' and ρt ∈ D. The case u, v ∈ Par is analogous. The remaining two cases are straightforward.
(Sρ ) Assume {u=˙ a, t} ⊆ D. We have ρu=˙ ρa ∈ D' and ρt ∈ D'. If u is a parameter, then ρu = ρa, since no Di is conflicting. But then, t[u := a] ∈ D follows from the way we constructed D. If u = x and x ∈ FV t, then {x = ρa, ρt} ⊆ Di where x is the characteristic variable of Di. By application of (C=˙ ), (ρt)[x := ρa] ∈ Di ⊆ D' and hence, t[x := a] ∈ D.

Conclusion and Future Work
We presented modal logic on the basis of the simply typed lambda calculus. Our focus was to give modal logic a uniform and natural treatment in terms of classical logic. On the one hand, first-order quantification was strong enough to express the semantics of the modal operators, on the other hand, first-order predicate logic as such was syntactically too weak for our purposes. This is why higher-order syntax came to play such an important role. We employed higher-order variables, derived higher-order constants and finally expressed operators of Hybrid Logic by means of λ-abstraction. We eventually arrived at three different levels of reasoning:
Notational Level On a notational level, we preserved the traditional syntax of modal logics as in K and HL.
Native Modal Syntax It turned out that modal notation was naturally sub- sumed and explained by our native syntax and the fragments MF and MFI which we defined in terms of this syntax. However, in the case of HL we ob- tained a tight equivalence of notation and syntax.
Quantifiers At the bottom, quantifiers were employed to give modal operators their precise meaning. Validities of modal logic could be derived by equational deduction.
From our point of view, traditional studies in correspondence between modal and first-order predicate logic suffered from their syntactical weakness.
When designing the tableau calculus for MFI1, our syntax proved to be the appropriate data structure without the need of modification. Both deductively and later with regards to computational matters, the analysis of our procedure

notably seized upon the rich object-level in our system. Although our tamed rule of replacement gives insight into the limited power of the identity predicate in MFI1, the question remains open whether one can achieve local termination criteria for such a calculus. In the literature, e.g., [6], the argumentation is often that as soon as identities are involved, one faces the same problems as in K over transitive frames where formulas have to be passed along a chain of successors.
With ideas similar to those in [2], the analysis of identities was also crucial to arrive at a space efficient formulation of our algorithm. It was interesting to see that the design space given by the saturation conditions allowed for nontrivial modifications of our saturation procedure.
We are interested in refinements of our saturation algorithm that make it more practical. Techniques, such as “lazy-guessing”, are required to avoid the large com- putational overhead caused by the initial guessing.

Acknowledgments
We thank an anonymous referee for pointing out a flaw in a previous version of the paper. We appreciate the time the editors gave us for reorganizing the results.

References
Areces, C., P. Blackburn and M. Marx, Hybrid logic is the bounded fragment of first order logic, in:
Proceedings of 6th Workshop on Logic, Language, Information and Computation, 1999, pp. 33–50.
Areces, C., P. Blackburn and M. Marx, A road-map on complexity for hybrid logics, in: J. Flum and
M. Rodr´ıguez-Artalejo, editors, Computer Science Logic, number 1683 in LNCS (1999), pp. 307–321.
Blackburn, P., Internalizing labelled deduction, Journal of Logic and Computation 10(1) (2000), pp. 137 – 168.
Blackburn, P., M. de Rijke and Y. Venema, “Modal Logic,” Cambridge Tracks in Theoretical Computer Science, Cambridge University Press, 2001.
Blackburn, P. and J. Seligman, What are hybrid languages?,, 1, CSLI Publications, Stanford University, 1998 pp. 41–62.
Bolander, T. and T. Brau¨ner, “Two Tableau-Based Decision Procedures for Hybrid Logic,” Informatik- Berichte 194, 4th Workshop: Methods for Modalities, Proceedings, 2005, 79-96 pp.
Church, A., A formulation of the simple theory of types, Journal of Symbolic Logic 5 (1940), pp. 56–68.
Fitting, M., “Proof Methods for Modal and Intuitionistic Logics,” D. Reidel Publishing Co., Dordrecht, 1983.
Fitting, M., Higher-order modal logic – a sketch (2001).
Fitting, M., “Types, tableaus, and G¨odel’s god,” Trends in Logic : Studia Logica Library 012, Kluwer Academic Publishers, 2002.
Fitting, M. and R. L. Mendelsohn, “First-Order Modal Logic,” Kluwer Academic Publishers, 1998.
Gabbay, D., “Labelled Deductive Systems,” Oxford University Press, 1996.
Hardt, M., “Bachelor’s Thesis: Hybrid Logic Revisited,” Saarland University, 2006.
URL http://www.ps.uni-sb.de/∼ hardt/hlrev.html
Smolka, G., “Lecture Notes: Introduction to Computational Logic,” Saarland University, 2006.
URL  http://www.ps.uni-sb.de/courses/cl-ss06/script/index.html
Tzakova, M., Tableau calculi for hybrid logics, in: N. V. Murray, editor, Analytic Tableaux and Related Methods, TABLEAUX’99, LNAI 1617 (1999), pp. 278–292.
