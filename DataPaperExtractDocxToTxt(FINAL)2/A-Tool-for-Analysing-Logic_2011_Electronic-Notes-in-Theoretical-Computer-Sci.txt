

Electronic Notes in Theoretical Computer Science 269 (2011) 125–137
www.elsevier.com/locate/entcs
A Tool for Analysing Logics
Sheila R. M. Veloso 2
Systems and Computer Engin. Dept., Fac. of Engineering UERJ: State University of Rio de Janeiro
Rio de Janeiro, RJ, Brazil
Paulo A. S. Veloso
Systems and Computer Engineering Program, COPPE UFRJ: Federal University of Rio de Janeiro
Rio de Janeiro, RJ, Brazil
Paula M. Veloso 3
Mathematics Dept., ICEx
UFMG: Federal University of Minas Gerais Belo Horizonte, MG, Brazil

Abstract
We introduce and examine a tool for analysing logics. This algebraic tool, coming from some ideas introduced by J. Piaget, provides condensed information about a logic (with emphasis on the behavior of a unary symbol), as such, it can be employed for analysing and, to some extent, comparing logics.
Keywords: Logic, interpretation, transformations, groups, monoids, homomorphism.


Introduction
We introduce and examine an algebraic tool for analysing and comparing logics. This tool stems from some ideas introduced by Jean Piaget to analyse the behavior of classical propositional negation [10] [11]. We will extend them to a unary symbol (e. g. negation or a modality).
This algebraic tool provides condensed information about a logic, much as eigen- values (or eigenvectors) give some information about matrices. As such, it can be

1 Partly sponsored by the Brazilian agencies CNPq and FAPERJ.
2 Email: sheila.murgel.bridge@gmail.com
3 Email: pmv@mat.ufmg.br

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.03.010

employed for analysing and, to some extent, comparing logics. Comparing logics is not an easy task; our tool can be used to simplify this task, as we reduce it to comparing algebraic structures.
The structure of this paper is as follows. In Section 2, we revisit Piaget’s analysis and indicate how to extend it to other similar cases. In Section 3, we extend Piaget’s classical analysis to monoids of transformations: we give some examples of transformation monoids, introduce our method for constructing such monoids and give some bounds. In Section 4, we illustrate how our transformation monoids can be used for comparing logics. In Section 5, we extend these ideas to unary symbols other than negation (such as modalities), formulating them in the general context of universal logic and institutions. Finally, Section 6 presents some remarks about our approach and on-going work towards possible extensions.
Reverse Engineering
We will now revisit Piaget’s classical analysis (in 2.1) and introduce some tools for extending it to other similar cases (in 2.2).
Piaget’s analysis
We will now examine Piaget’s analysis of the behavior of classical propositional negation [10] [11].
Piaget’s analysis rests on a simple idea, namely regarding a proposition as a func- tion of its propositional letters. There are three natural ways of applying negation: negate the result, negate the arguments or both. This gives rise to the three Piaget’s transformations: inversion, reciprocal and correlative. For instance, the proposition p ∧ q has inverse ¬(p ∧ q), reciprocal (¬p ∧ ¬q) and correlative ¬(¬p ∧ ¬q).
These three transformations are defined as follows.
(N ) Inversion N : ϕ(p1,..., pn) '→ ¬ ϕ(p1,..., pn)
(R) Reciprocal R : ϕ(p1,..., pn) '→ ϕ(¬ p1,..., ¬ pn)
(C) Correlative C : ϕ(p1,..., pn) '→ ¬ ϕ(¬ p1,..., ¬ pn)
Piaget worked in the context of logical equivalence ≡. For instance, for the proposition p → q, we have N (p → q) := ¬(p → q) ≡ (p ∧ ¬q), R(p → q) := (¬p → ¬q) ≡ (q → p), and C(p → q) := ¬(¬p → ¬q) ≡ (¬p ∧ q) [10] [11]. By examining the effect of repeated applying the three transformations above, Piaget found that they form a 4-element group with the following table [4]:


He also noticed that this group is isomorphic to a familiar and important group: the so called Klein group of symmetries of a plane rectangle [8] [9].
Piaget’s study revisited
Piaget’s analysis and the structure of his group, PC, can be explained by the un- derlying negation graph, as we will now indicate.
We will often use p to abbreviate the n-tuple ⟨p1,..., pn⟩, and, accordingly, ¬ p for the negated n-tuple ⟨¬p1,..., ¬pn⟩.
Remark 2.1 The following diagram commutes
ϕ(p)	N	ϕ(p)
C
R ↓		↓ R

ϕ(¬ p) N
ϕ(¬ p)

Corollary 2.2 The transformations have the following properties.
Inversion and reciprocal commute: N (R(ϕ)) = R(N (ϕ)).
Correlative is derived: C(ϕ) = N (R(ϕ)).
The negation graph describes how negation acts on (the representatives of) the equivalence classes of propositions. In the classical case, we have two such representatives, ϕ and ¬ϕ, and negation flips them around. Thus, the underlying
negation structure NC has 2 elements, ¬0 and ¬1 behaving as ~¬	¬ ¬1. So, NC
is isomorphic to the group of integers modulo 2: ZZ2.
Thus, we have 4 = 22 possible classical transformations: for i, j ∈ {0, 1}, NiRj
: ϕ(p) '→ ¬i ϕ(¬j p). These 4 possible classical transformations form a group TC (isomorphic to the direct product ZZ2 × ZZ2). Its structure is obtained by 2 actions of ZZ2: in the horizontal (N ) and vertical (R) directions:
0	0 N	1	0

~ N R ↔ N R
vertical

R ‡	‡ R	‡

0	1 N	1	1
ZZ2

horizontal ↔ ZZ2
We have 4 possible classical transformations. Are they all really distinct? The answer depends on the available connectives.
If we have only negation, then N and R become the same transformation (N (p) = ¬ p= R(p)). This leads to the collapse PC  NC:
0	0 N	1	0
~ N ◦R  ↔ N ◦R
||	||
N 1◦  1 N	0◦R1
R ↔ N 

We now introduce a tool for the analysis of the other cases. Considering the composite transformation, we note that Ni◦Rj[p] = ¬i ¬j p. The classical weight of a possible transformation is its total number of negations modulo 2, i. e. wC(Ni Rj) := i +2 j. The 4 possible classical transformations have weights as follows: wC(N 0R0)= 0, wC(N 1R0)= 1, wC(N 0R1)=1 and wC(N 1R1)= 0.
We can now see some cases with other connectives besides negation.
If we have the nullary constant ⊥ (R(⊥)= ⊥), then we have no identifications in view of the following situation:

If we have binary connectives ( ∧, ∨, →, ↔), then we have no identifications as the transformations on ϕ := p ∧ q behave as follows:

In both cases, we have no identifications, whence PC  NC × NC  ZZ2 × ZZ2.
We thus have an explanation for Piaget’s analysis: the underlying classical nega- tion structure NC is isomorphic to ZZ2 and we have no identifications.

Direct Engineering
We will now extend Piaget’s classical analysis to monoids of transformations. We will give some examples of logical monoids (in 3.1) and introduce our method for constructing such monoids giving some bounds (in 3.2).
Note that the definitions of the transformations (in 2.1) do not depend on the logic. So, we can examine them in other cases, such as intuitionistic logic.

Examples: intuitionistic negation
We will now consider the case of intuitionistic negation. We will examine the trans- formations much as in 2.2.
With intuitionistic negation, we no longer have the classical equivalence between ϕ and ¬¬ϕ, but we do have the equivalence between ¬ϕ and ¬¬¬ϕ [12]. So, iterated applications of intuitionistic negation lead to an equivalence only after a delay. The underlying intuitionistic negation structure has 3 elements, ¬0, ¬1 and ¬2 behaving
as ~¬	¬ ¬	¬ ¬2. So, NI is isomorphic to the cyclic monoid with transient 1

and period 2: 1C2 [5]. Its table is as follows:
Thus, we now have 9 = 32 possible intuitionistic transformations, namely NiRj : ϕ(p) '→ ¬i ϕ(¬j p), for i, j ∈ {0, 1, 2}. These 9 possible intuitionistic transformations form a monoid TI (isomorphic to the direct product 1C2 × 1C2). Its structure is obtained by 2 actions of 1C2: in the N and R directions.
Now, we have 9 possible intuitionistic transformations. As before, whether they are all really distinct depends on the available connectives. If we have only negation, then N = R, leading to the collapse PI  NI.
We now adapt our tool for the analysis of the other cases: the intuitionistic weight of a possible transformation is its total number of negations counted within 1C2: wI(NiRj) := i ∗ j (where ∗ is the operation of 1C2). The partition of the 9 possible intuitionistic transformations by weights is as follows:
We can now see some cases with other connectives besides negation.
If we only have the constant ⊥, then we have the following situation: Weights	Composite transformations Ni◦Rj(⊥) / Ni◦Rj(¬⊥)






We then have 3 identifications: N 0◦R1 = N 2◦R1, N 1◦R0 = N 1◦R2 and N 2◦R0 = N 2◦R2 = N 0◦R2. So, the transformation monoid P⊥ is a ho- momorphic image of 1C2 × 1C2 with 5 elements.
If we have binary connectives ( ∧, ∨, →, ↔), then we can see that we have exactly 2 identifications: N 1◦R0 = N 1◦R2 and N 2◦R0 = N 2◦R2. 4 Thus,

4 Double negation distributes over binary connectives other than ∨ and we have de Morgan’s law ¬(G∨H) ≡

the transformation monoid PI is a homomorphic image of 1C2 × 1C2 with 7 elements, as follows:
0	0	N	1	0 N	2	0	2	2

~ N ◦R
→	N ◦R
↔ N ◦R
= N ◦R



N ≡ N 1◦R2
R ↓	N 0◦R2	‡ R	‡ R
≡ R (

N 0◦R1
→N	N 1◦R1 ↔N
N 2◦R1


Method: monoid construction
We will now introduce our method for constructing Piaget monoids.
We will examine the general pattern in the negation and Piaget monoids of above logics, which involves equivalence classes of formulas.
(N) Negation gives a transformation on formulas ¬ : ϕ '→ ¬ϕ. Consider this trans- formation up to equivalence and its iterated compositions. This gives a monoid under composition ◦: the underlying negation monoid N. Its elements are of the
form ¬n, for n ∈ IN, with structure ~¬0 →¬ ¬1 →¬ ···. Since monoid N is cyclic, it is either finite or isomorphic to IN [5].
(T) The monoid of possible transformations T consists of the ordered pairs ⟨Ni, Rj⟩. So T is isomorphic to N × N, with the following structure:
0	0 N	1	0 N
~ N R → N R → ···

R ↓	↓ R
N 0 R1 →N N 1 R1 →N

vertical
···	↓
N

R ↓	↓ R
.	.
horizontal → N
(P) The Piaget monoid P consists of the compositions of inversion N , reciprocal R and correlative C. By Corollary 2.2, its elements are the composite trans- formations Ni◦Rj. To determine its structure, we employ weights. The weight of a possible transformation is its total number of negations within underlying negation monoid N: w(NiRj)= k iff ¬i◦¬j = ¬k (in N).
(/=) We first partition by weights (which involves only ¬). If Ni◦Rj = Nk◦Rl, then
¬i¬jp ≡ ¬k¬lp, so ¬i¬jϕ ≡ ¬k¬lϕ, and ¬i◦¬j = ¬k◦¬l.
(=) Next, we identify within weights (examining ¬ and other connectives). If, for every ϕ, ¬i Rj(ϕ) ≡ ¬k Rl(ϕ), then Ni◦Rj = Nk◦Rl (by definition).
This construction provides the Piaget monoid.

(¬G ∧ ¬H) [12]. So, an inductive proof shows that R2[ϕ] ≡ ¬ϕ.

In Section 2, we saw two classical cases (with weights 0, 1) and no identifications: P  N × N (cf. 2.2). We can use our method to construct the Piaget monoid of a logic whose underlying negation monoid is ZZn. In Section 3, we saw two intu- itionistic cases (with weights 0, 1, 2) and some identifications: P is a homomorphic image of N × N (cf. 3.1).
In Section 5, we will show that the Piaget monoid P is a homomorphic image of N × N where the underlying negation monoid N can be embedded (cf. Theorem 5.1 in 5.2). This will provide some bounds on the size of the Piaget monoid: |N| ≤ 
|P|≤ |N|2.
Comparing Logics
We will now illustrate how Piaget monoids can be used for comparing logics. We will examine some simple examples (in 4.1) and some examples involving interpretations (in 4.2).
Simple examples
We now see some simple examples of distinct logics with distinct monoids and with the same monoids. We will consider logics with only ¬ and ⊥. Classical logic has underlying negation monoid NC  ZZ2 and Piaget monoid PC  ZZ2 × ZZ2 (cf. 2.2).
(/=) Distinct logics with distinct monoids. A trivalent logic with underlying negation monoid N3 ZZ3 will have Piaget monoid P3 ZZ3 × ZZ3. So, the distinctions between classical logic and this trivalent logic are reflected in their negation and Piaget monoids.
Also, notice that the only possible homomorphisms between the underlying negation monoids PC and P3 are the trivial ones: erasing negations:
¬1
ч
≡
0 ч	1	0

~ ¬ ↔ ¬ 
~ ¬	↓¬ 
ч
s
¬2

(=) Distinct logics with the same monoids. Consider a L- ukasiewicz logic with 3 values

0 < 1
< 1 so that v(⊥) = 0 and v(¬ ϕ) = 1 − v(ϕ). The value table for this

L- ukasiewicz negation can be visualized as follows:
0
‡	1 Ç

1
We then have ¬¬ ϕ ≡ ϕ. Thus, it has underlying negation monoid NL-

  ZZ2 and

it will have Piaget monoid PL-  ZZ2 × ZZ2. Hence, NL-  NC and PL-
  PC. So,

the distinctions between classical and L- ukasiewicz logics are not reflected in their negation and Piaget monoids.
Negation and Piaget monoids (with sizes) for some logics are as follows:


Examples with interpretations
We will show some examples involving interpretations. We will consider logics with connectives ∧, ∨, →, ↔ and ⊥, besides ¬ and examine their monoids.
Consider classical and intuitionistic logics. It is known that the former C is a non-conservative extension of the latter I and we have a faithful interpretration of the latter I into the former C [6] [12].
(→) First, consider the (non-conservative) extension I ⊆ C.
(N) The assignment ¬I '→ ¬C defines a homomorphism of underlying negation monoids: NI → NC (if ¬iϕ ≡I ¬kϕ, then ¬iϕ ≡C ¬kϕ).
~ ¬I
NI	 
¬I2 ↔ ¬I1
↓	↓	↓	↓
NC	~ ¬C0 ↔ ¬C1
(P) The two assignments NI '→ NC and RI '→ RC define a homomorphism of Piaget monoids: PI → PC. The argument is similar. 5
(→) Next, consider G¨odel’s double-negation translation d : C → I [6] [12].
(N) The assignment ¬I '→ ¬C defines a homomorphism Nd : NI → NC of underlying

5 If Ni◦Yj (ϕ) ≡I Nk◦Yl(ϕ), then Ni◦Yj (ϕ) ≡C Nk◦Yl(ϕ).

negation monoids (if d[¬iϕ] ≡I d[¬kϕ], then ¬iϕ ≡C ¬kϕ).
NC	~ ¬C0 ↔ ¬C1
Nd ↑	↑	↑	↑
~ ¬I
NI	 
¬I2 ↔ ¬I1
(P) The two assignments NI '→ NC and RI '→ RC define a homomorphism Pd :
PI → PC of Piaget monoid. The argument is similar.

General Formulation
We now extend our ideas to a unary symbol, formulating them in the general context of universal logic and institutions.

Context
In the context of universal logic, a logic consists of a set of formulas and a conse- quence relation [2]. We will impose some restrictions on both items.
A general logic G consists of a set FG (of formulas) and a binary (consequence) relation ▶G on FG. An equivalence logic is a general logic E whose binary (con- sequence) relation ▶E is reflexive and transitive. We then define the equivalence relation ≡E on FE by ψ ≡E θ iff ψ ▶E θ and θ ▶E ψ.
Consider given sets P (of propositional letters) and K (of formula-building op- erations) [1]. We call a set free on P under K iff it is freely generated by K on P.
We call an equivalence logic S structural (on P under K) iff
(F) its set FS of formulas is free on P under K;
(≡) its equivalence relation ≡S is a congruence for K that is closed under replace- ment [3] (so that if ϕ ≡S ϕj and θ ≡S θj, then ϕ[p/θ] ≡S ϕj[p/θj]).
We wish to extend our ideas to unary symbols other than negation (such as modalities 2 and 3). Propositional and modal logics usually are structural. Thus, we will consider a fixed unary formula building operation ∂.
By a ∂ logic we mean a structural logic D with ∂ ∈ K. In such a ∂ logic we can reformulate the transformations introduced in 2.1, with ∂ in lieu of ¬, as follows (with p as in 2.2 and ∂ p := ⟨∂ p1,...,∂ pn⟩): N (ϕ(p)) := ∂ ϕ(p), R(ϕ(p)) := ϕ(∂ p) and C(ϕ(p)) := ∂ ϕ(∂ p). Note that R is an endomorphism on FD (e. g. R(ψ • θ)= R(ψ) • R(θ), for a binary •).

Logics and monoids
We now extend our previous ideas to ∂ logics.

Consider a ∂ logic D. We can work with our reformulated transformations up to equivalence. So, using [ϕ]D for equivalence class of formula ϕ ∈ FD, we have well- defined transformations as follows: ND([ϕ]D) := [N (ϕ)]D, RD([ϕ]D) := [R(ϕ)]D and CD([ϕ]D) := [C(ϕ)]D. We can also can transfer Remark 2.1 and Corollary 2.2 (in 2.2). We introduce monoids much as in 3.2.
(N) Unary ∂ gives a transformation on equivalence classes ∂D : [ϕ]D '→ [∂ϕ]D. Con- sidering iterated compositions of this transformation, we have a monoid under composition ◦: the underlying ∂ monoid ND. Its elements are of the form ∂Dn, for n ∈ IN, with structure much as before.
(T) The monoid of possible transformations TD consists of the ordered pairs
⟨NDi, RDj⟩, being isomorphic to the direct product ND × ND.
(P) The Piaget monoid PD consists of the compositions of ND, RD and CD. By Corollary 2.2, its elements are the composite transformations NDi◦RDj.
We then have a method, much as in 3.2, for constructing these 3 monoids. Notice that it is not necessary to obtain the quotient logic: the Lindenbaum-Tarski algebra of formulas (which is often infinite).
We now connect our structures of underlying and Piaget monoids.
Theorem 5.1 Given a ∂ logic D, consider its ∂ and Piaget monoids ND and PD. Then, the Piaget monoid PD is a homomorphic image of ND × ND, where ND can be embedded.
ND ‹→ PD - ND × ND
Proof. First, consider the assignment on the generator ∂D '→ ⟨ND1, RD0⟩. It gives an embedding i : ND ‹→ PD. 6 Next, consider the assignment ⟨NDi, RDj⟩ '→ NDi◦RDj. It gives a surjective homomorphism e : ND × ND ~ PD (by Corollary 2.2 as e(⟨ND1, RD0⟩)= ND and e(⟨ND0, RD1⟩)= RD).	2

Comparison of logics
We now examine translation for comparing logics [7].
Consider logics: source Gs = ⟨Fs, ▶s⟩ and target Gt = ⟨Ft, ▶t⟩. A translation is a function h : Fs → Ft translating formulas: ϕ '→ ϕh. Now, a translation h : Fs → Ft will be said to
(▶) interpret Gs into Gt (h : Gs → Gt) iff ψh ▶t θh whenever ψ ▶s θ;
(~) be eq-surjective (h : Gs ~ Gt) iff h is surjective up to equivalence: for each
θ ∈ Ft, θ ≡t ψh, for some ψ ∈ Fs (e. g. i : I ~ C in 4.2);
(‹→) be eq-injective (h : Gs ‹→ Gt) iff is injective up to equivalences: ψ ≡s θ, whenever ψh ≡t θh (e.g. d : C ‹→ I in 4.2).
Consider ∂ logics on P under K: source Ds and target Dt.  Given naturals
λ, δ ∈ IN, we call a translation h : Fs → Ft a ∂ translation of rank ⟨λ, δ⟩ iff h(p) =

6 Note that ⟨NDi, YD0⟩ = ⟨NDk, YD0⟩ yields ∂Di = ∂Dk.

∂λp, h(∂ϕ) = ∂δh(ϕ) and, for each n-ary formula-building operation k in K other than ∂, there exists a formula Hk(p1,..., pn) ∈ Ft such that h(k(ϕ1,..., ϕn)) = Hk(h(ϕ1),..., h(ϕn)) (e. g. h(p • q) = H•(∂λp, ∂λq)). G¨odel’s double-negation translation is a ¬ translation of rank ⟨2, 1⟩.
Now, call ∂ logics Dj and Djj isomorphic (Dj ∼= Djj) iff there exist ∂ inter- pretations hj : Dj → Djj and hjj : Djj → Dj that are inverses up to equivalences: hjj○hj(ϕj) ≡D′ ϕj and hj○hjj(ϕjj) ≡D′′ ϕjj.
Remark 5.2 For a ∂ translation of rank ⟨λ, δ⟩, h○N = Nδ○h.
Lemma 5.3 For a ∂ translation of rank ⟨λ, δ⟩, h○R = Rδ○h.


Proof. Induction on formulas, as R is an endomorphism. For p ∈ P: h(R(p))
(Y)
=

(h)
h
(h)  δ  λ
λ  δ	(Y)	δ	λ
(h)	δ
(Y)

(∂ p) = ∂
h(p) = ∂ ∂
p= ∂
∂ p = R (∂
p) = R (h(p)) For ∂: h(R(∂ ϕ)) =

h(∂ R
(h)	δ
(IH)	δ	δ
(Y)	δ	δ
(h)	δ

(ϕ)) = ∂ h(R(ϕ))
=	∂ R (h(ϕ)) = R (∂
(Y)	(h)
h(ϕ)) = R (h(∂ ϕ)).  For
(IH)

a binary •:	h(R(ψ • θ))
=	h(R(ψ) • R(θ))
=  H•(h(R(ψ)), h(R(θ))	=

H (Rδ(h(ψ)), Rδ(h	(Y) Rδ(H (h(ψ), h	(h) Rδ(h(ψ • θ)).	2
•	(θ))) =	•	(θ))) =
Theorem 5.4 Consider ∂ logics on P under K: source Ds and target Dt. Each eq-surjective ∂ interpretation h : Ds ~ Dt of rank ⟨λ, δ⟩ induces monoid homomor- phisms Nh : Ns → Nt and Ph : Ps → Pt.
Ds	Ns	Ps
h ] '→ ↓ Nh	↓ Ph
Dt	Nt	Pt
Proof. It suffices to define the monoid homomorphisms on the generators. Set Nh(∂s) := ∂tδ, Ph(Ns) := Ntδ and Ph(Rs) := Rtδ. They are well defined by eq- sujectivity and Lemma 5.3. For each θ ∈ Ft, θ ≡t h(ψ), for some ψ ∈ Fs. Now, if ∂i ψ ≡s ∂k ψ, then h(∂i ψ) ≡t h(∂k ψ), i. e. ∂(δ·i) θ ≡t ∂(δ·k) θ. Hence, ∂si = ∂sk yields ∂t(δ·i) = ∂t(δ·k). Similarly, if Ni○Rj(ψ) ≡s Nk○Rl(ψ), then h(Ni○Rj(ψ)) ≡t h(Nk○Rl(ψ)), i. e. N (δ·i)○R(δ·j)(θ) ≡t N (δ·k)○R(δ·l)(θ). Hence, Nsi○Rsj = Nsk○Rsl yields Nt(δ·i)○Rt(δ·j) = Nt(δ·k)○Rt(δ·l).	2
Proposition 5.5 If ∂ logics Dj and Djj are isomorphic (Dj ∼= Djj), then they have isomorphic monoids Nj  Njj and Pj  Pjj.
Proof. By Theorem 5.4 as eq-surjectivity follows from having inverse up to equiv- alence.	2
Proposition 5.6 Consider ∂ logics on P under K: source Ds and target Dt. Each eq-injective ∂ translation f : Ds ‹→ Dt of rank ⟨λ, 1⟩ induces monoid homomorphisms Nf : Nt → Ns and Pf : Pt → Ps.

Ds	Ns	Ps
f	'→ ↑ Nf	↑ Pf
Dt	Nt	Pt
Proof. It suffices to define the monoid homomorphisms on the generators. Set Nf(∂t) := ∂s, Pf(Nt) := Ns and Pf(Rt) := Rs. They are well defined by eq-injectivity and Lemma 5.3. If ∂ti = ∂tk, then, for every formula ϕ ∈ Fs, f(∂i ϕ)= ∂i f(ϕ) ≡t ∂k f(ϕ)= f(∂k ϕ), so ∂i ϕ ≡s ∂k ϕ, whence ∂si = ∂sk. Similarly, if Nti○Rtj = Ntk○Rtl, then, for every formula ϕ ∈ Fs, we have f(Ni○Rj(ϕ)) = Ni○Rj(f(ϕ)) ≡t Nk○Rl(f(ϕ)) = f(Nk○Rl(ϕ)), thus Ni○Rj(ϕ) ≡s Nk○Rl(ϕ), whence Nsi○Rsj = Nsk○Rsl.	2

Conclusion
We have introduced and examined an algebraic tool for analysing and comparing logics. This tool originates from some ideas introduced by Jean Piaget [10] [11], which we have extended to a unary symbol (e. g. negation or a modality) and formulated in a more general context.
We have provided a method for constructing such algebraic structures (monoids) in 3.2 and 5.2. Our method does not require obtaining the quotient logic: the Lindenbaum-Tarski algebra of formulas is often infinite, whereas our monoids are usually finite.
In this framework, comparing logics can be reduced to the existence of monoid homomorphisms. Such monoids provide condensed information about a logic and there is a wide range of algebraic machinery for checking the existence of monoid homomorphisms.
Piaget monoids are reminiscent of modality diagrams. We intend to extend this approach to such diagrams; this case seems somewhat different, but the ideas presented here provide a first step towards this goal.

References
Barnes, D. W. and J. M. Mack, “An Algebraic Introduction to Mathematical Logic”, Graduate Texts in Mathematics 22, Springer-Verlag, New York, 1975.
B´eziau, Jean-Yves, From consequence operator to universal logic: a survey of general abstract logic, In B´eziau, J.-Y. (ed.) Logica Universalis (2005), 3–17.
Burris, S. and G. Sankappanavar, “A Course in Universal Algebra”, Graduate Texts in Mathematics
78, Springer-Verlag, New York, 1980.
Chavineau, Jean, “La logique moderne” (2e ´edition), PUF, Paris, 1979.
Clifford, A. H. and G. B. Preston, “The Algebraic Theory of Semigroups” (2nd edition), Math. Surveys
7, Amer. Math. Soc., Providence, R.I., 1964.
Feferman, I. et al., “Kurt G¨odel’s Collected Works”, vol. 1, Oxford Univ. Press, Oxford, 1986.
Fiadeiro, J. and A. Sernadas, Structuring theories on consequence, in Sanella, D. e A. Tarlecki, A. (eds.) “5th Workshop on Specification of Abstract Data Types”, 44–72, Springer-Verlag, Berlin, 1988.


Grossman, I. and W. Magnus, “Groups and their Graphs”, New Mathematical Library 14, Random House, New York, 1964.
Paley, H. and P. M. Weichsel, “A First Course in Abstract Algebra”, Holt, Rhinehart & Winston, New York, 1966.
Piaget, Jean (ed.), “Logique et Connaissance Scientifique”, Gallimard, Paris, 1967.
Piaget, Jean, “Structuralism”, Harper & Row, New York, 1971. (Translation of Piaget, Jean, “Le Structuralisme”, PUF, Paris, 1968.)
van Dalen, Dirk, “Logic and Structure” (2nd edn, 3rd pr.), Springer-Verlag, Berlin, 1989.
