	Electronic Notes in Theoretical Computer Science 214 (2008) 309–329	
www.elsevier.com/locate/entcs


General Refinement, Part Two: Flexible Refinement
Steve Reeves1	David Streader2
Department of Computer Science University of Waikato Hamilton, New Zealand

Abstract
In the previous, companion, paper [13] to this paper we introduced our general model of refinement, discussed ideas around determinism and interfaces that the general definition raised, and gave several examples showing how the general definition could be specialised to the sorts of refinement we see in the literature.
In this paper we continue the story and we define vertical refinement on our general model. Ver- tical refinement can be seen as a generalisation of what, in the literature, has been called action refinement or non-atomic refinement. Alternatively, by viewing a special model (from the previous paper) as a logical theory, vertical refinement can be seen as a theory morphism, formalised as a Galois connection.
We give an example of the utility of this definition by constructing a vertical refinement between broadcast processes and interactive branching programs, and we see how interactive branching programs can be implemented on a platform which provides broadcast communication.
We also show how developments that fall outside the usual, special theories of refinement can be brought into the refinement world by giving examples of development which were thought not to be possible using refinement.
Throughout, the central, simple idea of refinement as a development process that moves from abstract to concrete while preserving certain valuable guarantees will guide us.
Keywords: general refinement, Galois connection, vertical refinement


Introduction
In this paper (in Section 3) we introduce a definition of refinement that, amongst other things, permits the refinement of the interpretation of the oper-

1 Email: stever@cs.waikato.ac.nz
2 Email: dstr@cs.waikato.ac.nz



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.014

ational semantics of the entities under consideration. Thus the interpretations that are usually fixed can now be changed during the development of a sys- tem by formal refinement steps. Using a series of examples in Section 4.1, Section 5.1 and Section 5.2 we show our definitions to formalise some quite natural development steps.
Our general theory, in the companion paper [13], centres around a parametrised definition of refinement, which was obtained by reflecting on several particular sorts of refinement, and also on a what seems to be a “natu- ral” notion of refinement, and then abstracting. Various special theories come about by fixing the set of contexts and observations considered. Notable ex- amples of special models we deal with are: abstract data types (ADT); hand- shake processes such as in Communicating Sequential Processes (CSP, [7]) or the Calculus for Communicating Systems (CCS, [9]), or broadcast processes such as in the Calculus of Broadcasting Systems (CBS, [10]); and individual operations.
In our general model we take as primitive the following three components: one, a set of entities, the specifications and implementations we wish to develop by refinement; two, a set of contexts, the environment with which the entities interact; and three, a user who uses an entity ina given context.
Concrete examples include:
an entity as a motor, a context as the car in which the motor runs and the user as the driver of the car
an entity as an abstract data type, a context as the program using the abstract data type and the user a person (or other program) calling the context program.
an entity as a method, a context as the object containing the method and the user a program using the object.
In Section 3 we introduce the second part of our general theory vertical reﬁnement between different special models. Viewing each such model as a layer, the lower, more detailed, layer can be seen as an implementation of the higher, more abstract layer.
As a concrete example of this we implement the IBP layer in the broad- cast layer in Section 5.2. What is particularly interesting about this is that we can find no way to extend this to be able to implement handshake on broad- cast! The problem appears when considering the same processes that cause problems with the definition of determinism.
In Section 5.3 we show the usefulness of our general approach by giving a formal development of a simple, and very natural, system that combines both handshake and broadcast events.

Extension refinement [3] and behavioural sub-typing [5] have been defined so that they make visible (i.e. reverse hiding and restriction of various kinds) in the concrete entity events not visible in the abstract entity. It now turns out that this sort of refinement can be formalised as another special case of theory morphisms.
Finally, we show an example, that can now be treated as refinement, which was originally given as an example of what refinement can not do.
To summarise: existing refinements as given in the literature are, in our terms, special theories (of refinement) which come about by specialising (in- stantiating the parameters to) our general theory of refinement.
Each special theory can be viewed as a layer in a hierarchy of theories, each connected by vertical refinement, formalised as theory morphisms or Galois connections, which are properly seen as refinements since they preserve certain crucial guarantees.
Throughout this work it is the preservation of guarantees as we make development steps that justifies viewing these steps as refinements.

Developing	the	General	Model	of	Refinement— adding layers
We now view the special models (and indeed any other specialisation of the general model) as a layer in the larger scheme of things.
A layer is formalised by a set of entities and a refinement relation. It is important to recall that : one, the entities in a layer can be ADTs, processes of various kinds and even individual operations; and two, different refinement relations can give different meanings to the same operational semantics.
Definition 2.1 A layer L is (EL, ±L) where EL is a set of entities and ±L⊆
EL × EL is a refinement relation.
By considering only layers where the refinement relation is defined as in the companion paper [13], i.e. ±L ±ΞL,OL , our layers can equally well be defined by the triple (EL, ΞL, OL).
For example, a triple consisting of: a set of LTSs representing entities; a set of LTSs representing contexts; and an observation function on LTSs, also defines a layer if we can: one, lift the observation function from LTSs to entities, i.e. if AL =L BL ⇒ O (AL)= O (BL); and two, lift placing in a context from LTS to entities, i.e. AL =L BL ⇒ ∀ x ∈ ΞL.[AL]x =L [BL]x , as is the case for all the models we consider.
We make our general refinement more flexible in Section 3 by giving a general definition of vertical reﬁnement between an abstract and a concrete

layer. Our definition of vertical refinement can be seen as a generalisation of non-atomic refinement [4] or action refinement [14,6] when we consider the LTS used to represent entities. But, when we consider predicates used to define the Ξ × O relations then vertical refinement is a theory morphism similar to those used in UTP [8, Chapter 4] but based on different theories.
Our definition is based on two semantic mappings: )v , that defines how to interpret the high-level abstract entities as low-level concrete entities; and vA, that defines how to interpret the low-level concrete entities as high-level abstract entities. The semantic mappings are vertical refinements if and only if any low-level refinement is interpreted as a high-level refinement and any high-level refinement is interpreted as a low-level refinement. Mathematically our vertical refinement is a Galois connection (or an adjunction) between the layers.
Our definition of vertical refinement is very much more powerful than the, as we shall call them, horizontal refinements within a layer and, as usual, with power comes responsibility. The implementer of a specification may be thought of as free to refine, horizontally, the specification in any way they choose. However, vertical refinement is powerful enough to formalise “design decisions” that are the responsibility of the customer (writer of the specifica- tion).
Fig. 1 shows how our “single layer” general theory generalises further once layers (and vertical refinement) are considered. This diagram is meant to give an idea of the generalisation we are about to make: the diagram is meant to be helpfully suggestive, not definitional, and its various components will be defined shortly. The unbroken line shows the steps of a refinement: one step in the top layer, one step of vertical refinement between layers, and one step in the bottom layer.


General Model of ...
Specific Models in two layers IBP and BC



...Entities and Refinement

(EX, ±X)
IBP
±IBP	±IBP	±IBP
AIBP	BIBP	XIBP	CIBP


...Vertical	±v =
( )v , vA)
Broadcast
±BC	±BC
ABC	BBC	CBC

Refinement
Fig. 1. Big picture

Motivating examples of Reﬁnement
Before we give our abstract definition of vertical refinement we will discuss some special instances from both event-based and state-based theories. These examples are of interest in their own right but are used here to show how a single abstract definition of refinement can be of interest in quite distinct special models.
Our first example is taken from the state-based literature [1] and will be discussed in more detail in Section 4.2. Programmers frequently consider data structures (lists, trees, sets etc.) without fixing the maximum size they can grow to and restricting themselves to considering just the correct behaviour of the system. Nonetheless, at some point in the design, maybe near the end of the process, the maximum size must be fixed (even if only by accepting some system defaults), and error handling has to be tackled. Traditionally the fix- ing of the size would not be considered a formal refinement but some other informal design step. What we do here is relax the formal definition of refine- ment so that this step can be viewed as a formal refinement, with a guaranteed relation between the abstract specification and the implementation. The same goes for error handling.
Our second example, an event-based example, will be discussed in more detail in Section 5. But by way of introduction, note that an early phase in constructing an event-based formal model of any system is that of deciding what constitutes an event. This requires both the set of events, called the alphabet, to be fixed, along with their type of interaction. How the events interact can be modelled by defining the entities EL and their contexts ΞL and the observations we can make OL to define refinement ±ΞL,OL of the entities. Thus at this early step in the development a layer has been fixed and an entity chosen to represent the specification. This specification is then developed using the defined refinement.
Within a layer all entities are built from a common alphabet or set of events. These events are atomic viewed from within the layer, i.e. they have no internal structure. But the vertical refinement may give the high-level events internal structure by relating them to entities on the low-level layer. Such refinements have been extensively studied under the names non-atomic reﬁnement [4] or action reﬁnement [14,6].
There are two well-known issues that are immediately apparent. Firstly, the interleaving assumption must be avoided, and secondly: “The kind of steps one would like to make in top-down design do not always correspond completely to the kind of constructions allowed by action refinement.”[6, sec- tion 7].
It is well-known [6] that interleaving can be avoided. Here we will side-step

the problem by restricting our attention to vertical refinements that relate one sequential entity to another sequential entity. We will focus our attention on the second issue, that of defining vertical refinement so that it is more relaxed than action refinement and reflects some steps that might appear in top-down design.
So, the system may have some features modelled by high-level events in alphabet ActH and others modelled by low-level events in alphabet ActL. We first model the features needing the high-level events, then we vertically refine this to an entity using only low-level events. This step preserves the meaning of the specification while embedding it in a more detailed low-level layer.
Recall our three basic types of interaction: one, method calling of pro- grams; two, handshake synchronisation of process algebra; and three, broad- cast communication. We use vertical refinement to embed one layer in another, thus defining how we might “implement” one style of interaction in another. In Section 5.2 we construct a special(ised) vertical refinement from a spe- cific abstract layer to a specific concrete layer. The events in the concrete layer are broadcast events and the events in the abstract layer are handshake events. But with the semantic mappings we have designed we have a Galois connection only when the handshake events are limited to the IBP entities.
We have found no way build a Galois connection between handshake processes and broadcast processes. Indeed, we conjecture that this cannot be done.

General vertical refinement
We use a semantic mapping )v to embed, or interpret, high-level EH entities as low-level entities EL. To allow for the possibility that not all the low- level entities and contexts are in the range of )v we use a separate semantic mapping vA to embed, or interpret, low-level entities as high-level entities.

PH	±H
QH ±H
vA QH)v 	±H	vA(RL)

±v	±v	vA

 PH)v
± ΞH,OH)v
 QH)v
± ΞH,OH)v	RL

Fig. 2.  Refinement  within and between layers

In top-down development a vertical refinement ±v = ( )v , vA) may be preceded by some high-level refinement steps and may itself precede low-level refinement steps (see Fig. 2, and here, to make the point we abuse notation and use ±v to emphasise the use of the refinement between layers when what actually does the mapping is )v ). The vertical refinement replaces a high- level entity by a low-level entity. But this new low-level entity cannot interact

with the old high-level contexts so the contexts must also be vertically refined. (It will turn out in all our examples here that the observation function always just gives us complete traces, though the range of that function may change— as it does with the operation refinement example in the companion paper
[13]—as we do vertical refinements.) As we will see it is the application of the refinement mappings to the contexts that allows the contexts to be sufficiently different on each layer so that the refinement on each layer assigns a different interpretation of interaction in the different layers.
The “mixing interaction type” situations we have described use low-level entities, contexts and observations in the range of  )v only. Hence ± ΞH,OH)v is an appropriate refinement.
For this example, if we have semantic mappings  )v and vA so that:
low-level refinement can be interpreted as high-level refinement
 PH)v ± ΞH,OH)v RL ⇒ PH ±H vA(RL)
high-level refinement can be interpreted as low-level refinement
 PH)v ± ΞH,OH)v RL ⇐ PH ±H vA(RL).
then we have what we call a vertical refinement.
This is a special case of the following:
Definition 3.1 Semantic mappings  )HL and vAHL define a vertical refine-
ment ±HL between high-level layer (EH, ±H) and low-level layer (EL, ±L) if they are adjoint:
∀ XH ∈ EH, YL ∈ EL. XH)HL ±L YL ⇔ XH ±H vAHL(YL)
We drop the superscripts where possible, using the context to determine H
and L.
The entities in any layer are represented by equivalence sets of operational semantics (e.g. sets of LTS) not just a single operational semantics. When the semantic mappings define a vertical refinement then the equalities =H and =L are congruent w.r.t. the relevant semantic mappings )v and vA 3 . Consequently we are free to define the semantic mappings as mappings be- tween individual operational semantics and then lift them to mapping between entities (equivalence classes of operational semantics e.g. LTS).
So, a vertical reﬁnement ±v = ( )v , vA) defines a guaranteed relation between the more abstract high-level entities and the more concrete low-level entities.

3 Monotonicity with respect to the preorders defining an adjunction is a well-known prop- erty of adjunctions [15, p151].

Thinking of layers as theories means the two functions  )HL and vAHL
define how to interpret one theory in the other, so we have a theory morphism,
and consequently:
H ±HL L guarantees that the high-level vA-interpretation of entity L be- haves like (can be observed to have a subset of the observations of) entity H (e.g. PH in Fig. 2) whenever it is placed in any high-level context ΞH and only the high-level observations OH are made.
In Section 5.2, we define a vertical refinement from an IBP layer to a broad- cast layer. But, we have been unable to extend this vertical refinement to a high-level layer of handshake processes, see Section 5.3, as we can “implement” only the deterministic IBPs.

Subset morphisms
In this section we are interested in the special case of theories A and C where ΞA ⊆ ΞC and OA ⊆ OC.
It is well-known ([15, p155] [8, 4.1]) that subset relations like ΞA × OA ⊆
ΞC × OC form a simple theory morphism which we denote by ±AC , where the
interpretation mappings are:
embedding of the abstract in the more complex concrete, where for any
PA ∈ EA (using the definitions ΞC\A  ΞC\ΞA and OC\A  OC\OA) : 

 PA)AC
   PA)ΞA,OA
∪ {(x , o) | x ∈ ΞC\A ∨ o ∈ OC\A};

projection of the concrete back into the abstract, where for any PC ∈ EC:
subAAC(PC)    PC)Ξ ,O .


We can establish that ±AC
is a theory morphism, i.e. that:

∀ XA ∈ EA, YC ∈ EC. XA)AC ±C YC ⇔ XA ±A subAAC(YC)
by checking that:
∀ XA ∈ EA, YC ∈ EC. XA)ΞA,OA ∪ {(x , o) | x ∈ ΞC\A ∨ o ∈ OC\A} ⊇  YC)ΞC,OC
⇔  XA)ΞA,OA ⊇  YC)ΞA,OA
Intuitively we can think of ΞA × OA as defining a frame and subset mor- phisms as formalising undefined outside frame. That is to say the abstract A is silent outside of its frame.

ΞA	OA	ΞC	OC
e OA  {e, f , g }
f
g ΞA  {a, b, c}



Fig. 3. A ±AC C
Our subset theory morphism formalises the addition of new ob- servations,  the y in Fig. 3.   The intuitive justification for adding
{(a, y ), (b, y ), (c, y ), (x , y )} is that in the abstract specification ΞA × OA the y observation had not been considered (recorded). Although this definition of vertical refinement may seem unusual when considering the entity to be a single operation, it is no more than an application of Galois connections. It is the adding of the new observations that makes our formal model (of both single operations and machines) so flexible. In addition it is the preservation of the guarantee that allows us to view theory morphisms as refinements.
Recall that our theory can be applied both to single operations and to processes or machines. As not all context, observation relations represent

valid processes we have the problem that the embedding  )AC
may return

relations that are not the semantics of any valid processes. We could, like UTP,
define healthiness condition on the relational semantics so that all processes have healthy relational semantics and all healthy relations are the semantics of some processes. But as we are interested primarily in refinement and the guaranteed relation between entities and what they are refined into, we choose to avoid any discussion about healthiness conditions.
The strict embedding projection morphisms satisfy a strict guarantee

AC
sub
 PA)AC
guarantees the high-level vA-interpretation of  PA)AC
be-

haves exactly like entity PA whenever it is placed in any abstract context
ΞA and only the abstract observations OA are made.

But, this is not always very useful in practice as PA)AC
may be unhealthy. So

we take a more pragmatic view and consider PA ±AC
 PA)AC
±C PC. Hence we

can choose some actual process PC whose relational semantics is a subset of the

potentially unhealthy  PA)AC
and we still have a useful refinement guarantee.

Restricting the guarantee for vertical refinement to this special case we get:

AC
sub
 PA)AC
±C PC guarantees the high-level vA-interpretation of any

entity PC behaves like (can be observed to have a subset of the observations
of) entity PA whenever it is placed in any abstract context ΞA and only the

abstract observations OA are made.
Concrete examples of this appear in Section 5.1.
Thinking of Fig. 3 as representing a single operation then we observe that this is not how refinement is normally defined in the literature. In particular note the increase in non-determinism. Similarly if we consider x and y to be
⊥, Fig. 3 is a definition of lifting and totalising the operation but not one that appears in the literature.

Vertical refinement between state-based systems
Operations
The ISO Z semantics is silent about termination and has been formalised in the companion paper [13] by E)(Ξisoz,Oisoz). Other interpretations, such as partially correct or undefined outside of precondition, can easily be formalised by defining appropriate observation functions. For these interpretations the frame (of reference) will be a superset of the ISO Z frame Ξisoz × Oisoz.
By the application of the obvious subset morphism the ISO Z semantics
can be formally refined into other interpretations of behaviour. Thus the choice of how to interpret the ISO Z semantics need not be made as the first step in the development process but can be postponed until the choice, if ever, is needed. Importantly when the design decision is made it can be applied without leaving our formalism and a guarantee can be given as to the relation between the initial ISO Z specification and its new interpretation.
Abstract data types
We take this example, formalised in Z, from [1], but wish to stress our paper is not about Z. Also, the work on approximate refinement [2] provides another means to deal with these sorts of examples.
All the reader needs to know about Z is that state spaces and operations over them are defined by schemas: named boxes with declarations above the dividing line and predicates giving properties below the line. Operations are then to be understood as relations between “before and after” states, or pre- and post-states, using the useful convention that pre-state observation names are unprimed, e.g. s, and post-state observation names are primed, e.g. s'.

This priming convention is also applied to state schemas, so State'
has an

observation named s'. 4

4 Seasoned Z readers will note conventions that we might have followed to make our Z more standard—we have omitted these since, as we said, this paper is not about Z, does not depend on it and no knowledge of Z is needed to read it.

SetC


SetA




















Fig. 4. Infinite SetA and bounded SetC
The abstract definition SetA of a (data structure for a) set containing natural numbers with two operations PutA, to add numbers to the set, and GetA, to remove them, can be found in Fig. 4. 5
The black-box view of the abstract data type SetA is that the state is private or unobservable. Only the public method calls are observable and consequently SetA is interpreted as a specification guaranteeing that an infinite number of PutA operations, each with distinct inputs, can be successfully called. This is plainly not possible to implement. Computers have a finite amount of storage and hence a program that is repeatedly executing PutA will, at some point, simply run out of space. A more concrete, and now implementable, definition, SetC, with the size of the set bounded by three,

5 We note that, in fact, since Z is strongly typed and so ∪ must join two things of the same type, the type PN ∪ {X } in this example as it stands cannot properly be said to be Z. However, with more work, we could make this proper Z, but it would complicate, somewhat, what is written for the type concerned and would therefore distract us from the point of this paper. Finally, we have used exactly the example from [1].

can be found in Fig. 4 too (for the moment ignore mention of the set {X }). If refinement is meant to capture this black-box guarantee then SetC is not a refinement of SetA.
Clearly the example is very small and we could easily throw away SetA and use the concrete specification SetC in the first place. The point we make, though, is that if one were given a large complex specification on which a lot of time has been spent, then one would be reluctant to throw away all this effort and start again.
Nonetheless, if we accept that in some “practical situations” a reasonable person might wish to view SetC as a refinement of SetA then such a person cannot be giving SetA this black-box interpretation.
Here we replace the black-box interpretation with a clear-box interpreta- tion by regarding the state of SetA to also be part of the specification. Thus, via the undefined outside of frame interpretation that subset morphisms allow, we can modify both the state of SetA and the set of operations in SetA.
Given that we would like SetC to be a refinement of SetA we can, informally speaking, ask for a guarantee that SetC behaves just like SetA in contexts satisfying the following assumptions:
the set is not used to store more than three different numbers; and
only the Put and Get operations are called.
This clear-box guarantee is certainly weaker than the (unreasonable be- cause unimplementable) black-box guarantee we started with, but it seems to be the strongest guarantee we can expect, and, crucially, it is useful and, probably, all we were expecting all along (being reasonable people).
We will show how to formally model the development of SetA into SetC via three refinement steps and show that its formal guarantee corresponds to the above informal guarantee.
First we will perform the same subset morphism on both operations in SetA and thus introduce some non-determinism. Secondly we will perform a normal horizontal refinement to remove the non-determinism we just introduced and finally we will perform a subset morphism on the whole data type to introduce a new operation.


PutA
({}, 0){0}
 PutA)T({0}, 0){0}
({0}. , 1){0,. 1}

. 	 .
Fig. 5. PutA and PutA)T⊥	⊥

The only difference between the relational semantics in Fig. 5 and the semantics that appeared in Section 3.1 is that the pre-state of Put is a pair, the first element being State and the second being the input value n

PutX
({}, 0){0}
 PutX)T({0}, 0)	{0}
({0}. , 1)	{0,. 1}
.	.
(X., 0)	X.
. 	 .
⊥	⊥


Fig. 6. PutA ±{X } PutX

That the operation PutA can be refined via a subset morphism into PutX using the results and definitions of Section 3.1 is clear and we leave the details to the interested reader.
We define a state-based refinement of an ADT to be the state-based re- finement of all its operations and hence for example Fig. 7:
SetA ±{X } SetX  PutA ±{X } PutX ∧ GetA ±{X } GetX

sub
sub
sub

Having introduced nondeterminism into the specification we are now free to remove it via horizontal refinement SetX ± SetB. The final refinement is applied to the whole of SetB to introduce the new operation Reset. The contexts ΞB are any trace of the operations in SetB so clearly any trace that includes Reset is not in this set of contexts and hence the behaviour of SetB in this context is not defined. Hence it is easy to establish that there exists a subset morphism and refinement SetB ±{Reset} SetC.
We adopt the clear-box interpretation of the specification SetA hence it
defines only the behaviour of its operations PutA and GetA and it only defines their behaviour when they remain within StateA.
The first refinement SetA ±{X } SetX guarantees that SetX behaves like SetA
when operations PutX and GetX keep out of the error state X .
The second refinement step is a simple reduction of nondeterminism. It is in this step that the developer decides that the set is to have no more than three elements. Hence the guarantee is unchanged when sets never have more than three elements but any operation that attempts to increase the size to greater than three is free to return the new state X .



SetX
SetB
StateB
t : PN ∪ {X }

PutB
StateB, State'
n?: N
(t /= X ∧
#t < 3 ∧ t ' = t ∪ {n?}) ∨
(t /= X ∧
#t =3 ∧ t ' = X )
GetB
StateB, State'
n!: N
t /= X ∧ n! ∈ t t ' = t \{n!}

Fig. 7. SetA ±{X } SetX and SetX ± SetB
The third and final refinement SetB ±{Reset} SetC guarantees that any be- haviour of SetC, when used by programs that call only the “Put” and “Get” operations could also be a behaviour of SetB.
Together these guarantees form exactly the guarantee we wanted, as given in Section 4.2, and they have been captured formally via flexible refinement.

Vertical refinement between event-based LTS
By applying vertical refinement to processes with LTS operational semantics we are able to refine processes based on actions with one style of interac- tion (e.g.handshake) on a layer of process with another style of interaction (e.g.broadcast). Before considering vertical refinement in general we consider the much simpler subset morphisms and show how to use them to model restriction and hiding as found in the process literature CSP/CCS/ACP.
From Restriction and Hiding to subset morphisms
Restriction and Hiding in the process literature refer to functions that remove events from a process and can be viewed as “abstraction” functions. Having

defined the “observational” semantics of processes ACP models Restriction as a function renaming events to δ events, here called δ-abstraction, and Hiding as a function renaming events to τ event, here called τ-abstraction.
The abstraction functions, Restriction and Hiding, can simply be applied to a process to remove events from a concrete process when ever the developer chooses. But here, as in [3,5], we are interested in reversing this process and introducing these events, new to the abstract process, and thus creating the concrete process. Further we are interested in viewing the introduction of these new events as a formal refinement step.
Let the alphabet of an entity A, written α(A), be the set of events that it can engage in. Further let the alphabet of the set of contexts ΞA be the union of the alphabet of the individual contexts α(ΞA)  {α(x) | x ∈ ΞA}.
We reverse the τ-abstraction and δ-abstraction of Definition 6.1 by extend- ing refinement to introduce events in two quite separate ways [11,12].
Firstly if δ–refinement holds, A ±ΞδDel C (as we apply the abstraction functions both to entities and contexts α(ΞA) ∩ Del = ∅), then it introduces events that were previously not observable and always blocked. This would be used, for example, to refine a specification that defined successful behaviour and assumed error events, in set Del , never occurred.
Secondly if τ –refinement holds, A ±ΞτHid C (where α(A) ∩ Hid = ∅), then it introduces events that were previously not observable and never blocked in the more abstract view.
Definition 5.1 δ–refinement and τ–refinement. For LTS A and C :
A ±ΞδDel C  A ±Ξ CδDel
A ±Ξτ Hid C  A ±Ξ CτHid
Clearly the guarantee from the subset refinement applies in both these cases.

(TIBP, ±IBP) ±v (TBC, ±BC)
In this section we will define a particular vertical refinement between high- level IBP entities and low-level broadcast processes, both from the companion paper [13]. We will then show that we have been unable to extend the high- level to all handshake processes. The reason appears to be related to the way handshake processes have abstracted away the cause and response nature of event synchronisation.
We map an active high-level event such as b (see Fig. 8) into three parts. The try event tb! is performed, subsequently either aborting (rb?) if the context cannot interact on b, or succeeding (ab?) if the context can interact on b. The

mapping for the passive event b can be seen in right-hand side of Fig. 8.
x	s	b	e	s	b	e

x	tb?	◦
rb!
s	◦	ab?	 e
s	tb?	 ◦	ab!	 e


Fig. 8. Vertical refinement )B
Our semantic mapping )B from a high-level layer to a low-level layer will not only map events b and b to different processes but also add try-reject loops tb?rb! wherever a passive event b cannot be performed, i.e. when b /∈ π(x), see left-hand side of Fig. 8.
Although we see this as the natural solution, because of the addition of the try-reject loops it is neither an action refinement nor indeed an instance of Vertical Implementation [14].
We need some care in interpreting the events of Fig. 8. In particular both handshake events b and b are able to be blocked but the broadcast events tb!,rb! and ab! are not.
Definition 5.2 Let A be an LTS (NA, sA, TA).
 A)B  MBC (N A)B , sA, T A)B )
a
N A)B  NA ∪ {nt | t ∈ TA}∪ {n(m,a) | m ∈ NA ∧ m−→}

T	tx!
rx?
ax?	x
= n	}∪

 A)B
{s−→z , z −→s, z −→t | s−→t ∧ z


s−→t

tx?	ax!	x
{s−→z , z −→t | s−→t ∧ z = ns−x→t }∪

tx?
rx!	x

{s−→z , z −→s | s−→ ∧ z = n(s,x)}
Not all the processes (N A)B , sA, T A)B ) are valid broadcast processes, i.e. they are not all in TBC . For this reason we have applied MBC . For ease of understanding we have not shown the events added by MBC in Fig. 8.
Next we define abstraction vAB . It should be noted that tx? events are replaced by two τ events, one each way.
Definition 5.3 Let A be an LTS (NA, sA, TA).
vAB (A)  (NA, sA, TvAB (A))


TvAB (A)	{s−→
ax?	x
t | s−→t }∪ {s−→
ax!
t | s−→t }∪

τ	tx!
rx!
rx?	τ
tx?
tx?

{s−→t | s−→t ∨ s−→t ∨ s−→t ∨ s−→t ∨ s−→t ∨ t −→s}

Theorem 1 Semantic mappings vAB and )B deﬁne a vertical reﬁnement from the handshake layer with ±(ΞIBP,Tr c ) to the broadcast layer with ±(ΞBC ,Tr c ).
Vertical reﬁnement failure—and success
We take the special vertical refinement above, defining how to refine IBP into broadcast processes, as being almost inevitably correct. But, we find that we cannot expand IBP to all processes as defined by CSP/CCS etc. as is illustrated by returning to the example from our companion paper ([13], Section 5.4) and reproduced here in Fig. 9. Recall that we described Rob as nondeterministic and here our “implementation” on a broadcast layer, as we show, also requires Rob to be nondeterministic.



s c Rob

◦
 d2
e
 d1
e

Fig. 9. Are VM and Rob deterministic?
The implementation on a broadcast layer is illustrated in Fig. 10 6 .

Rob
d2	e
/±PA	RobotH

s	c	◦
tb1!	◦
b1 ab1?
d1 e	s	c	◦
d1	e
b1	◦
d1	e
d1	e

s	c	◦
rb2?
rb1? tb2!
◦

ab2? ◦
s
d2	e

 Rob)B
±BC
RobotL

Fig. 10. Rob)B ±BC RobotL but Rob /±PA RobotH and MIBP (Rob) ±IBP RobotH
 Rob)B in Fig. 10 is a non-deterministic broadcast process. In particular which button, b1 or b2, it tries to push first is not determined. Hence when offered both buttons by VM its behaviour is non-deterministic. Process RobotL is a refinement of Rob)B that will try button b1 only.
We wish to stepwise refine our model to formalise the design decision that the vending machine only has two cups and that when out of cups it responds to further requests with error events that are broadcast not handshake events.

6 So as to keep the lower level diagrams small we have expanded only the high-level events
b1! and b2!. The expansion of the other events is obvious from Fig. 8.

First the vending machine VM in Fig. 9 is defined with handshake interac- tions. This can be vertically refined into an entity with broadcast interactions, VMv in Fig. 11.

Fig. 11. (Fig. 9) VM ±v VMv

Secondly we add an error event, the “return of the coin”. This event is to occur if a button is pushed but the vending machine has none of the required drink left. But since we do not wish this error event to be blocked by a user (robot), it must be under local control. Thus the return of the coin event is a broadcast event cr!.
This step is formalised by a δ-refinement, as discussed in Section 5.1, to give VMvd in Fig. 11.

Fig. 12. (Fig. 11)VMv ±BCδ{cr} VMvd
A more compact way to view this process is VMb in Fig. 13 where the original handshake events are shown with the newly visible broadcast event cr!. We could formalise this by defining LTS with four types of event but here we simply view VMb as “sugar” for VMvd in Fig. 12 and leave the reader to expand the dashed lines in Fig. 8.


Fig. 13. VM ±BCδ{cr} VMb

Having made visible the return of coin event we now have an entity that is non-deterministic, as you can never tell if the result of pushing a button will be to dispense a drink or return the coin. More technically, the events cr! and td2? both leave the same node.
We can easily refine this specification to model a vending machine which can vend a total of two drinks only, i.e. d1 and then d2 or d2 and then d1, thus giving Fig. 14.



s  c ◦


◦
◦ d1  ◦
◦
◦	◦
◦	◦
◦


Fig. 14. VMvd ±BC VM2

Conclusion
By making use of an explicit representation of the contexts in which entities are placed we have been able to construct a flexible definition of refinement.
What can be observed is also a parameter in our flexible refinement and has been used in the following ways:
Refinement steps that expand the set of considered observations, for his- torical reasons called a subset morphism, have been used for both state- and event-based systems—adding error states and new operations in Sec- tion 4.2 and adding new events in Section 5.1;
Using a function to relate entities with completely distinct sets of events in Section 5.3.
We define a layer as consisting of a set of entities and a refinement relation based on the style of interaction between entities in the layer. Using this we define vertical refinement (Section 3) between different layers where each layer may contain different styles of event-interaction. As an example we define vertical refinement from a “handshake layer” to a “broadcast layer”.
Both for state-based models Section 4.2 and event-based models Section 5.3 we have shown examples of our very “relaxed” definition of refinement allow- ing the formal introduction of error handling. Both examples adopt a very similar methodology. They each come with a formally guaranteed relation be- tween the specification and implementation (more concrete specification). For neither example have we found alternative formal solutions in the literature.

Acknowledgement
We would like to thank the many people who have discussed the ideas pre- sented in this paper over many years—you know who you are! In particular, though, we give thanks to Lindsay Groves, John Derrick, Jim Woodcock, Jim Davies, Eerke Boiten and Mark Utting.

References
Banach, R. and J. Derrick, Filtering retrenchments into reﬁnements, in: Proceedings of SEFM’06 (2006), pp. 60–69.
Boiten, E. and J. Derrick, Formal program development with approximations, in: H. Treharne,
S. King, M. Henson and S. Schneider, editors, ZB 2005: Formal Speciﬁcation and Development in Z and B, Lecture Notes in Computer Science 3455 (2005), pp. 374–392.
Brinksma, E. and G. Scollo, Formal notions of implementation and conformance in LOTOS, Technical Report INF-86-13, Twente University of Technology, Department of Informatics, Enschede, The Netherlands (1986).
Derrick, J. and E. Boiten, Non-atomic reﬁnement in Z, in: J. Wing, J. Woodcock and J. Davies, editors, FM’99 World Congress on Formal Methods in the Development of Computing Systems, Lecture Notes in Computer Science 1708 (1999), pp. 1477–1496.
Fischer, C. and H. Wehrheim, Behavioural subtyping relations for object-oriented formalisms, Lecture Notes in Computer Science 1816 (2000), pp. 469–483.
URL citeseer.nj.nec.com/fischer00behavioural.html
Gorrieri, R. and A. Rensink, Action reﬁnement, in: J. A. Bergstra, A. Ponse and S. A. Smolka, editors, Handbook of Process Algebra, Elsevier, 2001 pp. 1047–1147.
URL citeseer.nj.nec.com/gorrieri00action.html
Hoare, C., “Communicating Sequential Processes,” Prentice Hall International Series in Computer Science, 1985.
Hoare, C. and H. Jifeng, “Unifying Theories of Programming,” Prentice Hall International Series in Computer Science, 1998.
Milner, R., “Communication and Concurrency,” Prentice-Hall International, 1989.
Prasad, K. V. S., A calculus of broadcasting systems, Science of Computer Programing 25
(1995), pp. 285–327.
Reeves, S. and D. Streader, Comparison of data and process reﬁnement, in: J. Woodcock and
J. Dong, editors, Proceedings of ICFEM 2003, number 2885 in Lecture Notes in Computer Science (2003), pp. 266–285.
Reeves, S. and D. Streader, Liberalising Event B without changing it, Technical report, University of Waikato (2006), computer Science Working Paper Series 07/2006, ISSN 1170- 487X.
URL http://researchcommons.waikato.ac.nz/cms papers/14/
Reeves, S. and D. Streader, General reﬁnement, part one: interfaces, determinism and special reﬁnement, Proceedings of Refine 2008, Electronic Notes in Theoretical Computer Science (2008).
Rensink, A. and R. Gorrieri, Vertical implementation, Information and Computation 170 (2001), pp. 95–133, extended version of “Vertical Bisimulation” (TAPSOFT ’97). Full report version: Hildesheimer Informatik-Bericht 9/98, University of Hildesheim.
Taylor, P., “Practical Foundations of Mathematics,” Cambridge University Press, 1999, cambridge studies in advanced mathematics 59.

Appendix
τ –Abstraction and δ–Abstraction
In process algebra, events can be abstracted from a process in two distinct ways. In CCS these ways are restriction and hiding. Here we will use the ACP special events δ and τ to define the two distinct ways δ–abstraction and τ –abstraction to abstract events.
Definition 6.1 δ–abstraction and τ –abstraction. Given LTS A = (NA, sA, TA) and Del ⊆ Names ∪
Names we have:
AδDel  (NA, sA, TAδDel ) where, for all x ∈ Names ∪ Names , TAδDel is defined by:

x
n−→
Al , x /∈ Del
x



Let Hid ⊆ Names ∪ Names and
n−→AδDel l

AτHid   Abs(NA, sA, TAτHid )



where for all x ∈ Names ∪ Names , TAτHid is defined by:
x
n−→

Al , x /∈ Hid
x


x
n−→

Al , x ∈ Hid
τ

n−→AτHid l	n−→AτHid l
