

Electronic Notes in Theoretical Computer Science 240 (2009) 129–148
www.elsevier.com/locate/entcs

Checking Z Data Refinements Using Traces Refinement
Andr´e Didier1 ,2 , Adalberto Farias3 , Alexandre Mota4
Federal University of Pernambuco, Centre of Informatics, P.O.Box 7851, Cidade Universitria – 50732-970 – Recife – PE – Brazil

Abstract
Data refinement is useful in software development because it allows one to build more concrete specifications from abstract ones, as long as there is a mathematical relation between them. It has associated rules (proof obligations) that must be discharged; this is normally performed by interactive theorem proving systems. This work proposes an approach based on refinement checking to automatically check the Z data refinement rules. Our approach captures the relational semantics of these rules by using the functional support of CSPM (the machine-readable version of process algebra CSP) and uses the traceability feature of CSP to
find the rules that cannot be satisfied. Moreover, it is able to automatically calculate the mathematical relation between an abstract and a concrete specification, if one exists. We present our approach using an example.
Keywords: Z,data refinement,model-checking


Introduction
Although tool support for formal methods has significantly increased in the last years, checking data reﬁnements still deserves attention because user intervention is required in many ways. Data refinement techniques aim at making abstract spec- ifications more concrete by changing their data structures. This requires a relation- ship between the specifications so that the concrete system simulates the abstract one, and generates reﬁnement rules (or proof obligations) that must be checked. The user intervention is commonly required to relate the systems and to check such rules. Moreover, depending on the system and on the way the specifications are related, this check becomes tedious or some rule(s) will never be satisfied.

1 We are thankful to CNPq, which supported us with Grant No. 485488/2006-0. We also thank Dr. Juliano Iyoda for suggestions in early drafts of this paper and Professor Jim Woodcock for substantial help on the final version of this paper.
2 alrd@cin.ufpe.br
3 acf@cin.ufpe.br
4 acm@cin.ufpe.br


1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.049

Recently, model checkers and SAT solvers have been employed to check data re- finements [1,12,13]. However, this use still presents some limitations concerned with input/output manipulation, infinite state-spaces handling or with the construction of the mathematical relation between the abstract and the concrete system. In an- other direction, theorem provers handle input/output and infinite state-spaces but requires user intervention, in general [8].
This work proposes a way of automatically checking data refinements for Z [16] (introduced in Section 2) and also of calculating the relation between the analysed specifications (abstract and concrete), as long as it exists. We briefly introduce our target notation CSPM (the machine-readable version of the process algebra CSP [11]) in Section 3 and show how to use its functional support to describe the Z refinement rules. Then, we propose a template process to discharge them; the process performs a specific sequence of events if and only if all rules are satisfied (detailed in Section 4). We analyse this template process using the refinement checker FDR [7]; as this check is automatic, theorem proving is unnecessary.
The translation from Z to CSPM follows the strategy implemented in a support tool [5]. Some adjustments are necessary as we deal with refinement rules instead of the behaviour of Z specifications. Moreover, the translation has limitations because some Z constructs might not have a direct correspondent in CSPM . Nevertheless, all solutions in this direction present similar limitations [2,3,15].
We want to stress that we do not use the equivalence between data refinement and process refinement, as reported in [2]. Instead, we describe the proof obligations according to their relational semantics and check them. If any of them fails, we use the traceability feature provided by CSPM and FDR to find the rules that are not satisfied, in such a way that the proposed refinement (concrete system) can be adjusted. This occurred in our example. Moreover, as we use refinement checking, our strategy gives a result only when both specifications have finite state spaces. The use of compression techniques like data abstraction [9] is a further effort to overcome this, as pointed out as future work in Section 6.
The general contribution of this paper concerns the reduction of user interven- tion when employing data refinement in the development process. Currently, user intervention is necessary only to provide the relation (as a Z schema) between the ab- stract and the concrete specifications, and to translate all schemas into CSPM . Our specific contributions are: (i ) the usage of CSP to capture the relational semantics of the Z data refinement rules; (ii ) the automatic verification of Z data refinements given a retrieve relation, and; (iii ) the automatic calculation of a retrieve relation, if one exists, to justify data refinement.
In Section 5 we discuss related work and in Section 6 we present our conclusions and potential directions for future work.

Overview of Z
The language Z is based on set theory and first-order logic. It provides abstract data types like sets, sequences and bags, and the schema language, which is in-

tended to structure and compose descriptions. A Z schema is useful to describe state, initialisation and operations (viewed as relations), which contain an enabling condition (the precondition) and an associated effect (post-condition).
In the blocking view of Z, preconditions act as guards for operations. Thus, as long as the precondition of an operation holds in the before state, the after state is calculated as described in the post-condition; otherwise, an undefined state is originated. On the other hand, the non-blocking view establishes that, when a precondition holds, its corresponding operation yields an after state according to the post-condition; otherwise, it yields an arbitrary state [16] (anything can happen). In this work we adopt the blocking view and present Z using the vending machine example given in [16] (Fig. 1). We abstract away the payment, and the kind of drink that gets dispensed.

Fig. 1. Abstract specification of a vending machine

The machine uses three types. The free-type Status is used to signal the success (yes) or failure (no) of the current interaction, and to keep track of the progress of a transaction. The type Digit is a number between 0 and 9; and seq3[X ] is a sequence of three elements of type X . The state (StateA) contains two Boolean variables to indicate if the machine is in use (busy ), and if the current transaction is successful
(vend ). The initialisation (InitA) sets both state variables to false (busy' means the next value of busy ).
Users interact with the machine through the operation Choose, which inputs a three-digit sequence (i ?: seq3 Digit ) at once and then dispenses the drink, as long as the numbers were correctly chosen. The operation VendA simply signals whether the transaction is successful or not (through the nondeterministic output o!) and makes the machine available again (busy' = no). Note that, in the operations
Choose and VendA, the variable vend ' is left undetermined because its value is nondeterministically chosen.
In the concrete vending machine proposed by [16], the state (StateC ) contains the amount of digits; that is, StateC =^ [digits : 0..3] (the digits are entered sequentially).

This allows one to relate the two states through a Retrieve relation in such a way that, if the system is not in use, then no digits have been entered.
Retrieve 	





The remaining schemas are illustrated in Fig. 2. The initialisation (InitC ) con- siders that no digit has been entered. Thus, the machine becomes busy after one execution of FirstPunch and in the two following executions of NextPunch. After that, it executes VendC , dispensing the drink and outputting (nondeterministically) its status.














Fig. 2. Concrete specification of the vending machine

According to [16], a concrete operation COp refines an abstract one AOp (AOp ± COp) if and only if COp simulates AOp, in the sense that everything COp does, AOp also does, possibly more nondeterministically. This correspondence requires a relation between the concrete and the abstract states in two possible direc- tions: forward (from abstract to concrete) or backward (from concrete to abstract). The conceptual difference between them concerns the resolution of nondetermin- ism. In this paper we use the latter because the concrete specification postpones the nondeterminism to the end of the execution of VendC and the refinement can- not be proved using forward simulation. Moreover, in most data refinements, each abstract operation has one direct concrete version. Our example is quite different: FirstPunch refines Choose and VendC refines VendA. As NextPunch preserves the abstract state, it refines ΞStateA, (ΞS stands for the preservation of S ) [16].
The proof obligations originated by the data refinement use some operators over sets and relations. Table 1 shows the main operators.
The rules formalising the notion of a backward simulation between Z speci- fications involve initialisation, applicability and correctness of operations (Defini- tion 2.1). We use the relational version of the refinement rules proposed in [14]; they extend those proposed in [16] to also contemplate inputs and outputs. We just

Table 1 Operators

replace the correctness rule with the suitable version for the blocking view, as pre- sented in [1]. Moreover, since our system does not explicitly initialises inputs, and as we assume that all observations of the state come from system’s outputs, we need a
smaller set of rules. We represent a Z specification as a triple (State, Init , {Opi }i∈I ) containing a state schema (State : Exp), an initialisation schema (Init ) and an in- dexed set of operation schemas ({Opi }i∈I ). Each operation is a relation of type State × Statein ↔ State × Stateout , where Statein (Stateout ) represents the inputs (outputs) parameters of the operation. This requires the existence of retrieve rela- tions for the state (R), inputs (Rin ) and outputs (Rout ).
Definition 2.1 Let (CS , CI , {COpi }i∈I ) and (AS , AI , {AOpi }i∈I ) be two Z spec- ifications. (CS , CI , {COpi }i∈I ) is a backward simulation of (AS , AI , {AOpi }i∈I ) with respect to the retrieve relations R, Rin and Rout if and only if:
CI o R ⊆ AI	(b-init)

dom COpi ⊆ dom((R || Rin ) −D (dom AOpi ))	(b-app)
COpi o (R || Rout ) ⊆ (R || Rin ) o AOpi	(b-corr)
Each rule in the above definition has an interpretation in the relational seman- tics. The initialisation (b-init ) must be checked once and establishes that for each concrete initial state there is a corresponding abstract initial state. The applicability (b-app) and the correctness (b-corr ) rules must be checked for all operations. The former says that whenever it is possible to perform the abstract operation AOpi , it must be possible to perform the concrete operation COpi on the corresponding concrete state and concrete input. The latter establishes that whenever it is pos- sible to perform the abstract operation, and the corresponding concrete operation

can result in state C ' and output C!, then it must be possible to find an abstract state A' and output A!, corresponding to that C ' and C!, which is the result of performing the abstract operation.
We point out that the original rules of data refinement consider total relations (operations and retrieves). However, as Z specifications usually present partial operations, the totalisation is achieved by using augmented domains in such a way
that: (i ) the state includes a new bottom element (that is, State⊥ = State ∪ {⊥}, where ⊥/∈ State); (ii ) the operations are totalised to map elements outside its
•
precondition (that is, op = op ∪ {x : State | x /∈ dom Op • (x , ⊥)}); and (iii ) the
◦
retrieve is lifted to also propagate undefinedness (that is, R = R ∪ {(⊥State , ⊥StateA
)}). Fig. 3 illustrates the totalisation of an operation and of a retrieve relation.


State	State	State	State A

Fig. 3. Totalisation of {1 '→ 1, 2 '→ 1} and lifting of {1 '→ a, 2 '→ a, 3 '→ b}


Note that the rules of Definition 2.1 do not involve totalised relations. Actually, the use of domain restriction and subtraction allows one to find equivalent rules for partial relations [16]. Furthermore, the relations Rin and Rout depend on the compared operations. Thus, regarding Choose and FirstPunch, Rout disappears in b-corr (outputs are absent), whereas Rin is given by:







On the other hand, the operations VendA and VendC have the same outputs but no inputs. Hence, Rin disappears in b-app and in b-corr , and Rout = id(Status).
Concerning the operations NextPunch and ΞStateA, we need some adjustments to apply b-app and b-corr . Note that NextPunch has an input d ?: Digit , whereas ΞStateA has not. In order to represent all operations uniformly, we define a new operation XiStateA that is similar to ΞStateA but with an abstract input of type seq3 Digit , which is not manipulated by XiStateA. As NextPunch is intended to read the second and the third digits, we use a new retrieve relation for inputs:







In [16], the refinement of the vending machine used the identity to map existing inputs and outputs parameters. This simplification is possible because the domains are finite. Moreover, no input parameter was inserted into ΞState because the refinement rules were adapted to ignore it. We inserted an input in XiStateA to avoid changes in the refinement rules. In specification meanings, the new input is only used to represent operations uniformly and does not affect the state preservation.

Overview of CSP
The process algebra CSP [11] is suitable for describing the behaviour of systems. It has constructs for modelling successful termination, deadlocks, livelocks and atomic computations (modelled as events). Its machine-readable version CSPM also pro- vides functional features and support for manipulating integers, sequences, sets, booleans and customized types. We concentrate on showing only the elements of CSPM used in this work; a complete description can be found in [7,11]. Further- more, CSPM code is represented using true type fonts.
Processes interact with each other by communicating events through channels (declared with the keyword channel). A channel with a type defines a family of events, whereas a non-typed channel defines only one non-communicating event.
Concerning the Boolean expressions, we use the operators not (negation), and (conjunction) and or (disjunction). We also use sequences, sets and some basic operators: empty(A) tests if the set A is empty, member(e,A) tests if e is an element of A, diff(A,B) gives the set difference between A and B, s1^s2 concatenates the sequence s1 with s2, head(<a>^s) gives the head element a, and tail(<a>^s) returns the tail sequence s.
Sets and sequences over a type T are defined as Set T and Seq T, respectively. Alternatively, sets can be defined using ranges or comprehension. For example,
{1..5} or {x|x <- {1..10}, x <= 5} represent the same set {1,2,3,4,5}. The comma in the predicate part of the comprehension is a shorthand for logical con- junction, and x <- {1..10} means that the value x is taken from the set {1..10}. The conditional construction if b then E1 else E2 is also available in CSPM , where b is a Boolean condition and E1 and E2 are expressions of any (the same) type. The operators == and <= are overloaded and may be used for integers, sequences,
sets and tuples. For sets, the operator <= means inclusion (⊆).
Pattern matching is also supported. For example, the first element of a pair is easily obtained by using the function first. The underscore ‘’ matches any value.
first((x,_)) = x

Custom data types can be defined using the keyword datatype. For example, the type Status can be defined as:
datatype Status = yes | no
The abstract state space (StateA) is determined by the set containing all pairs involving the type Status; that is, {(busy,vend) | busy <- Status, vend <- Status}. This corresponds to the set {(no,no),(no,yes),(yes,no),(yes,yes)}. Another functional feature is local definition (the let ... within construct).
For instance, the function getFirst below returns the first component of an abstract state (represented by a pair).
getFirst(state) = let
(busy,vend) = state within busy

Behaviour in CSPM
In CSPM , processes can be primitive (or basic) or defined using operators. The following grammar defines the subset of CSPM we are interested in.
Event ::= ChanName | ChanName ? Variable | ChanName ! Expression
Process ::= STOP | SKIP	(basic processes)
| Event -> Process	(prefix)
| Process [] Process	(external choice)
| Process ; Process	(sequential composition) An Event can be a channel name (ChanName), an input event (ChanName ?
Variable) or an output event (ChanName ! Expression). Variable is an identifier (a name of a variable).
The process STOP denotes deadlock (abnormal termination) whereas SKIP means successful termination. The process e -> P is ready to engage on the event e; after performing e, it behaves like P. The process P [] Q behaves like P or Q, depending on the other processes (the environment) it interacts with. The process P;Q represents the sequential composition of P and Q; it requires that P terminates successfully.
In this work, we study processes using the semantic model of traces (or T , for short), where a process is represented by the set of all sequences of events (traces) it can perform [11]. For example, the process P = a -> b -> STOP is represented by
{<>,<a>,<a,b>}, where <> means P performed no event yet, <a> means P performed the event a, and <a,b> means P performed a followed by b. The set of all traces of a process P is denoted by T (P ). We have chosen this model because it is sufficient for our purposes. In T , the notion of refinement is given in terms of set inclusion: a process Q refines a process P if and only if the traces of Q are a subset of those of P ; that is, P ±T Q ⇔ T (Q ) ⊆ T (P ). Thus, the process Q = a -> STOP refines
P because {<>,<a>} ⊆ {<>,<a>,<a,b>}. The refinement P ±T Q is put into the
refinement checker FDR by the statement assert P [T= Q.
Besides performing refinement checks, FDR provides traceability when a refine- ment fails (the counterexample). We use this feature to find the rule (and operation) that failed when checking a Z data refinement, as explained in the next section.

Automatic Verification of Z Data Refinement
Our approach to automatically check a Z data refinement is illustrated in Fig. 4. The parameters AZSpec and CZSpec represent the abstract and the concrete speci- fications, respectively. Both of them, conjointly with the retrieve relations R, Rin and Rout are translated into CSPM before performing the check. The proof obli- gations are encoded as functions. Due to the pattern matching feature provided by CSPM , we are also able to automatically compute the retrieve relation to validate a data refinement between two given specifications, as long as it exists.


AZSpec CZSpec R
R_in


boolean

R_out
(AZSpec
CZSpec)


Fig. 4. Overall strategy


Translating Z into CSPM
The state is represented by a tuple; the state space, the initialisation and the op- erations are converted into set comprehensions. Although some operations might not have input/output (as the operations Choose and VendA in Fig. 1), we repre- sent them uniformly in the conventional type State × Statein ↔ State × Stateout . To achieve that, we insert the necessary input/output (of type UNDEFINED) in the schemas (see the sets Choose and VendA in Table 2).
datatype UNDEFINED = {BOTTOM}
Table 2 shows the complete translation of the abstract vending machine. We point out that, CSPM does not provide a direct type corresponding to a sequence of three digits (seq3 Digit ) in Z. Thus, we define the type SeqDigit3 as follows:
SeqDigit_3 = {<x,y,z>|x <- Digit,y <- Digit,z <- Digit}
Table 3 shows the translation of the concrete vending machine. Recall from Section 2 that Retrieve considers only the component busy to relate the states. As CSPM does not have operators for ⇔ and ⇒, we use the equivalences A ⇔ B ≡ A ⇒ B ∧ B ⇒ A and A ⇒ B ≡ ¬ A ∨ B from predicate calculus, and pattern matching to implement them as the functions iff and implies, respectively. Then, we use the function iff to define an implementation for the Retrieve relation.
implies(A,B) = not(A) or B
iff(A,B) = implies(A,B) and implies(B,A)
Retrieve = {((busy,vend),digits) | (busy,vend) <- StateA,
digits <- StateC, iff(busy == no,digits == 0)}
The association of Rin and Rout with each pair of operation is achieved by using the abstract operations as a suffix. Thus, RinChoose and RoutChoose are associated with the pair (Choose, FirstPunch), and so on.

Table 2
Translation of the abstract vending machine

R_in_Choose = {(d,i) | d <- Digit, i <- SeqDigit_3, head(i) == d} R_out_Choose = id(UNDEFINED)
R_in_XiStateA = {(d,i) | d <- Digit, i <- SeqDigit_3,
d = head(tail(i)) or d = head(tail(tail(i)))} R_out_XiStateA = id(Status)
R_in_VendA = id(UNDEFINED) R_out_VendA = id(Status)
The translation of the proof obligations is almost a direct transcription to CSPM according to the prefixed functions of Table 4. The translation of all rules of Defi- nition 2.1 is illustrated in Table 5.

Discharging Proof Obligations Automatically
In CSPM , a specification is represented as a triple (State,Init,Ops), where Ops
is a sequence of operations. Thus, both versions of the vending machine are repre-

Table 3
Translation of the concrete vending machine

sented by:
AZSpec = (StateA,InitA,<Choose,VendA,XiStateA>) CZSpec = (StateC,InitC,<FirstPunch,VendC,NextPunch>)
The pairs of operations to be compared are directly obtained from AZSpec and CZSpec, following the same order they appear in the sequences. Moreover, as we capture invalid rules using traces, we need to define special events.
channel initOk, initNotOk
channel appOk,appNotOk:AOPNAME.COPNAME channel corrOk,corrNotOk:AOPNAME.COPNAME
Channels initOk and initNotOk define non-communicating events that are per- formed when b-init is valid or not, respectively. Channels appOk and appNotOk, and

Table 4
Translation of the main Z operators

Table 5
Translation of the backwards simulation rules

corrOk and corrNotOk have the same purpose for b-app and b-corr , respectively. As these rules are applied to a pair of operations, the corresponding channels accept to communicate the names of the compared operations: abstract and concrete, in this order. Thus, instead of directly communicating the CSPM representation of the operations on channels, we communicate only their names, which are defined in new data types: AOPNAME for abstract operations and COPNAME for concrete ones. The sequences AOpNames and COpNames represent the name of the operations that must be communicated on channels. Note that the names follow the same order the corresponding operations appear in the specifications.
datatype AOPNAME = ChooseOp | XiStateAOp | VendAOp datatype COPNAME = FirstPunchOp | NextPunchOp | VendCOp

AOpNames = <ChooseOp,VendAOp,XiStateAOp> COpNames = <FirstPunchOp,VendCOp,NextPunchOp>
To use the suitable retrieve in a refinement rule, we put them into sequences that follow the same order as the operations.
R_in_Sequence = <R_in_Choose,R_in_VendA,R_in_XiStateA> R_out_Sequence = <R_out_Choose,R_out_VendA,R_out_XiStateA>
In the process representation of a refinement rule, each function of Table 5 is used to enable the associated events. The process initialisation, for example, receives both initialisations as parameters and uses the global Retrieve between them. It performs initOk as long as b-init is valid (b-init i the CSPM representation of b-init); otherwise, it performs initNotOk.
initialisation(Inits) = let (AI,CI) = Inits
R = Retrieve
within if b_init(AI,CI,R) then
initOk -> SKIP
else initNotOk -> STOP
In its base case, the process applicability behaves like SKIP. In the inductive case, it receives the concrete state and five sequences: abstract operations, concrete operations, names of abstract operations, names of concrete operations and retrieves for inputs. Operations and names are taken from their respective sequences (heads) and the global Retrieve is used to to relate the states. The process checks the rule b-app (the CSPM representation of b-app) for the first pair of operations. If b-app returns true, the process communicates the names of the operations on channel appOk and recursively checks the remaining operations; otherwise, the names are communicated on channel appNotOk, ending with a STOP.
applicability(_,<>,_,_,_,_) = SKIP applicability(CS,AOpSeq,COpSeq,AOpSeqName,COpSeqName,R_in_Seq) = let
AOp = head(AOpSeq) COp = head(COpSeq)
AOpName = head(AOpSeqName) COpName = head(COpSeqName) R = Retrieve
R_in = head(R_in_Seq)
within if b_app(CS,AOp,COp,R,R_in) then appOk.AOpName.COpName -> applicability(CS,tail(AOpSeq),tail(COpSeq),
tail(AOpSeqName),tail(COpSeqName),tail(R_in_Seq)) else
appNotOk.AOpName.COpName -> STOP
The process correctness is defined similarly to applicability. The differ- ence is related to some parameters, the use of the function b-corr (the CSPM

representation of b-corr), and the use of channels corrOk and corrNotOk.
correctness(<>,_,_,_,_,_) = SKIP correctness(AOpSeq,COpSeq,AOpSeqName,COpSeqName,R_in_Seq,R_out_Seq)=
let
AOp = head(AOpSeq) COp = head(COpSeq)
AOpName = head(AOpSeqName) COpName = head(COpSeqName) R = Retrieve
R_in = head(R_in_Seq) R_out= head(R_out_Seq)
within if b_corr(AOp,COp,R,R_in,R_out) then corrOk.AOpName.COpName -> correctness(tail(AOpSeq),tail(COpSeq),tail(AOpSeqName),
tail(COpSeqName),tail(R_in_Seq),tail(R_out_Seq)) else
corrNotOk.AOpName.COpName -> STOP
The complete set of backward rules is represented by the process BackwardRules, which is defined as the sequential composition of the previous processes.
BackwardRules(CS,AI,CI,AOpSeq,COpSeq,
AOpSeqName,COpSeqName,R_in_Seq,R_out_Seq) = initialisation(AI,CI); applicability(CS,AOpSeq,COpSeq,AOpSeqName,COpSeqName,R_in_Seq);
correctness(AOpSeq,COpSeq,AOpSeqName,COpSeqName,R_in_Seq,R_out_Seq)
As long as the processes initialisation, applicability and correctness
successfully terminate, BackwardRules performs the sequence
<initOk>^<appOk.AOpNamei.COpNamei>i ^<corrOk.AOpNamei.COpNamei>i where <ch.anamek.cnamek>k means <ch.aname1.cname1,...,ch.anamek.cnamek> and k = #AOpSeq (the sequences of operations have the same size and order). For initialisation purposes, we define the process BACKRULES that extracts the necessary parameters from the global structures and passes them to BackwardRules, as long as the retrieves are total. The totality is checked by testing if the domain of each retrieve relation is equal to the respective concrete domain. If this is invalid for at least one retrieve, the process BACKRULES performs the event partialRetrieve and then deadlocks. Thus, when using some partial retrieve to check a refinement in our approach, FDR produces the trace <partialRetrieve>.
BACK_RULES = let
(_,AI,AOpSeq) = AZSpec (CS,CI,COpSeq) = CZSpec
R_in_Seq = R_in_Sequence R_out_Seq = R_out_Sequence

within if ((StateC != dom(Retrieve)) or (Digit != dom(R_in_Choose)) or (UNDEFINED != dom(R_out_Choose)) or (Digit != dom(R_in_XiStateA)) or (Status != dom(R_out_XiStateA)) or (UNDEFINED != dom(R_in_VendA)) or (Status != dom(R_out_VendA)))
then partialRetrieve -> STOP
else BackwardRules(CS,AI,CI,AOpSeq,COpSeq,AOpNames, COpNames,R_in_Seq,R_out_Seq)
To validate a data refinement using refinement checking we define a process that performs the sequence of events in case of success: RefOk. It uses auxiliary pro- cesses that communicate events denoting success for each rule. RefInitOk performs initOk behaves like SKIP. When the sequence of operations is empty, RefAppOk and RefCorrOk behave like SKIP; otherwise, they communicate the names of the first op- erations (head) on their respective channels and consider the remaining operations (tail).
RefOk = RefInitOk;RefAppOk(AOpNames,COpNames); RefCorrOk(AOpNames,COpNames)
RefInitOk = initOk -> SKIP
RefAppOk(<>,_) = SKIP RefAppOk(AOpSeqName,COpSeqName) =
appOk.head(AOpSeqName).head(COpSeqName) -> RefAppOk(tail(AOpSeqName),tail(COpSeqName))
RefCorrOk(<>,_) = SKIP RefCorrOk(AOpSeqName,COpSeqName) =
corrOk.head(AOpSeqName).head(COpSeqName) -> RefCorrOk(tail(AOpSeqName),tail(COpSeqName))
Finally, the validation is put into FDR by using the refinement assertion:
assert RefOk [T= BACKRULES
If RefOk [T= BACKRULES is valid, then BACKRULES performs the trace repre- senting the success of applying the rules of Definition 2.1.
Note that the traces refinement here does not take into account the existence or inexistence of nondetermism nor undefinedness. They are dealt into the proof obligation rules which were fully translated into CSPM . Then, the BACKRULES process actually simulates the verification of the proof obligation rules. Thus, our approach does not verify a data refinement between Z specifications using their corresponding process representations [1,2,4]. Instead is performs the real validation of Z data refinement into a model checker, like a human being does to discharge the proof obligations.

Trace Inspection in Invalid Reﬁnements
The refinement check assert RefOk [T= BACKRULES is our CSPM encoding of the refinement reported in [16]. We performed it using FDR and surprisingly obtained a false result. Then, we used the sequence of performed events (the counterex- ample) illustrated in Fig. 5.a to see which rule and operation was invalid. The occurrence of appNotOk.XiStateAOp.NextPunchOp reveals that NextPunch is not a valid simulation for XiStateA. Then, we performed a deeper investigation and found a subtlety: NextPunch is not defined when digits = 3. Although this never occurs, the specification must consider such a situation. Then, we adjusted the precondition of NextPunch from digits =0 to digits =0 ∨ digits = 3 and obtained a valid refinement (Fig. 5.b).

(a)	(b)

Fig. 5. Traceability of FDR


Automatic Computation of Retrieves
In the previous section, the functions implementing the proof obligations receive the retrieve relations as parameters. In this section we show how to determine a retrieve automatically, if it exists. We consider only the state but inputs and outputs are dealt with similarly. The existence of such relations means the refinement is valid (Equation 1).
(1)	∃ R ∈ P Rmax ⇒ A ±R C
In the above equation, A and C are the abstract and the concrete specification,
respectively, ±R means ‘refined with respect to R’, and Rmax is the cartesian product between the abstract and the concrete states. The set comprehension RMax below implements the relation Rmax above.
RMax = {(sc,sa) | sc<-StateC, sa <-StateA}
The function validretrieves takes the abstract and the concrete specifications and returns the set of all retrieve relations that satisfy all rules in the conjunction of the application of binit, bappall and bcorrall, where bappall and

bcorrall are new functions that apply bapp and bcorr, respectively, to all operations.
valid_retrieves(ASpec,CSpec) = let (_,AI,AOpSeq) = ASpec (CS,CI,COpSeq) = CSpec
within { R | R <- Set(RMax),b_init(AI,CI,R) and b_app_all(CS,AOpSeq,COpSeq,AOpNames,COpNames,R,R_in_Sequence) and b_corr_all(AOpSeq,COpSeq,AOpSeqName,
COpSeqName,R,R_in_Seq,R_out_Sequence)}
b_app_all(_,<>,_,_,_,_,_) = true b_app_all(CS,AOpSeq,COpSeq,AOpSeqName,COpSeqName,R,R_in_Seq) = let
AOp = head(AOpSeq) COp = head(COpSeq)
AOpName = head(AOpSeqName) COpName = head(COpSeqName) R_in = head(R_in_Seq)
within b_app(CS,AOp,COp,R,R_in) and b_app_all(CS,tail(AOpSeq),tail(COpSeq),tail(AOpSeqName),
tail(COpSeqName),R,tail(R_in_Seq))
b_corr_all(<>,_,_,_,_,_,_) = true b_corr_all(AOpSeq,COpSeq,AOpSeqName,COpSeqName,R,R_in_Seq,R_out_Seq)= let
AOp = head(AOpSeq) COp = head(COpSeq)
AOpName = head(AOpSeqName) COpName = head(COpSeqName) R_in = head(R_in_Seq) R_out= head(R_out_Seq)
within b_corr(AOp,COp,R,R_in,R_out) and b_corr_all(tail(AOpSeq),tail(COpSeq),tail(AOpSeqName),
tail(COpSeqName),R,tail(R_in_Seq),tail(R_out_Seq))

The relation R is calculated by extension, following the principle behind model checking (exhaustive search). Thus, all possible sets of combinations between con- crete and abstract states are covered, without user intervention and with the guar- antee that a retrieve is found as long as there is a refinement. In order to validate the refinement, we only need to check if the set validretrieves(.) is not empty. To do that, we use the process EXISTRETRV and the refinement assertion as follows:
EXIST_RETRV(ASpec,CSpec) =
not empty(valid_retrieves(ASpec,CSpec)) & SKIP assert EXIST_RETRV(AZSpec,CZSpec) [T= SKIP

Theorem 4.1 associates the above check with the existence of a retrieve relation.
Theorem 4.1 Let AZSpec and CZSpec an abstract and a concrete Z speciﬁca- tions, respectively, and let ACSPSpec and CCSPSpec be their CSPM representations. Then, EXISTRETRIEVE(ACSPSpec,CCSPSpec) [T= SKIP if and only if CZSpec re- ﬁnes AZSpec with respect to a retrieve relation R.

Proof

From the CSP theory [11], EXISTRETRV(ACSPSpec,CCSPSpec) [T= SKIP is valid only if validretrieves(ACSPSpec,CCSPSpec) returns a non- empty set.  This happens only if the functions binit, bappall and bcorrall return true.  From this and from Equation 1 we know that there exists a retrieve relation that validates the refine- ment.  Conversely, if the refinement is valid, then there is a re- trieve R that validates binit, bappall and bcorrall. Therefore, validretrieves(ACSPSpec,CCSPSpec) returns a non-empty set and then EXISTRETRV(ACSPSpec,CCSPSpec) [T= SKIP is valid.


The complete CSPM code of our example can be requested via e-mail or down- loaded from http://www.cin.ufpe.br/˜alrd/entcs2008/refinements.csp.

Related Work
The approach presented in [2] shows the correspondence between data and process refinements using the CSP semantics of Z. Thus, a Z data refinement is valid, if and only if, the refinement between the corresponding CSP processes is valid. We see our work as complementary, as we follow the relational semantics of Z data refinements. We use processes only to establish a behaviour for each proof obligation instead of the behaviour of a Z specification. This is more useful to find out, via counterexamples, which rule invalidated a refinement. In principle, both approaches deal with the same class of problems and have the same limitation when domains are infinite.
In [1] the conversion from Z to Alloy enables the use of SAT solvers to verify Z data refinements. Like our approach the user does not need to provide a retrieve relation a priori; it can be computed automatically. As Alloy is very close to Z, the conversion used in [1] is, in principle, simpler than ours. Moreover, the way Alloy deals with finite domains is more efficient than FDR. Nevertheless, Alloy does not provide traceability features to capture rules and operations that invalidated a refinement. A common limitation of both approaches concerns infinite state space systems. The use of data abstraction [6,9] in both approaches would be helpful to limit the scope of data domains.

A similar approach for verifying Z data refinements using model checking is proposed in [4], where Z specifications are translated into equivalent processes so that process refinement corresponds to data refinement. That work is able to handle infinite domains in communications by using special schemas to make them finite. These schemas cannot contain any relation between outputs and state variables. Our approach is free of such a restriction as it allows inputs/outputs refinement through retrieve relations.
As far as we know, the use of process refinement does not provide detailed information about an invalid rule [1,2,4]. Instead, in an invalid refinement, one can observe, for example, a sequence of operations performed only by the concrete system that is not performed by the abstract one. In our approach, invalid refine- ments reveal exactly what rule and operation failed. This allows adjustments in the original models, as usually employed in counterexample-guided approaches.
The technique reported in [12] uses classical model checking (and temporal logic) to verify data refinements based on forward simulations. Another translation strat- egy is proposed to write the transitions and paths as structures that can be analysed by a model checker. The strategy requires that the retrieve relation is given and suggests the embedding of input/output into the state. Our approach covers two situations: when a retrieve relation is given and when it is not. In the first situation, we indicate if the refinement is valid or not. In the second situation we are able to find (if it exists) a retrieve relation to validate a refinement.

Conclusions
Combining data refinement with stepwise development is a powerful alternative to establish correctness between specifications, where transformations are applied to derive more concrete artifacts that are mathematically equivalent to the original ones. Because such a guarantee is usually based on theorem proving, user interven- tion might be required to verify the underlying proof obligations. In this context, the use of techniques and tools to make data refinement as automatic as possible is essential for its practical application.
In this paper we proposed an approach for automatically checking Z data refine- ments. We consider the relational semantics of Z [16] and the functional support of CSPM to write the proof obligations as functions that basically check set inclusions. Then, we provided template processes whose refinement check is valid if and only if the proof obligations are satisfied. Although FDR is not the best tool to check our functions, it provides traceability features that allows one to find invalid rules and discards the use of theorem proving. Three immediate results emerge from this: (i ) automatic verification of a data refinement between two specifications; (ii ) automatic calculation of a retrieve relation that assures a data refinement; and (iii ) the use of counterexamples for adjusting the specification whenever the refinement between them is invalid. We used (iii ) to detect a subtlety in a common example of the literature.
As refinement checking is limited to finite state space systems, our technique

cannot deal with the state space explosion directly. Nevertheless, by integrating our approach with data abstraction [6,9] we can limit the data domains (to finite but sufficient subsets of them) before applying our approach. This is a topic for future work. Furthermore, we performed the translation to CSPM by hand. However, we intend to add this feature in the tool presented in [10]. Currently, the tool is able to translate Z specifications into processes. This new feature will discharge the user of manipulating the CSPM code of the proof obligations.

References
Bolton, C., Using the alloy analyzer to verify data refinement in Z., Electr. Notes Theor. Comput. Sci.
137 (2005), pp. 23–44.
Bolton, C., J. Davies and J. Woodcock, On the refinement and simulation of data types and processes, in: IFM99, 1999, pp. 273–292.
Borba, P. and S. Meira, From VDM specifications to functional prototypes, Journal of Systems and Software 21(3) (1991), pp. 267–278.
Derrick, J. and H. Wehrheim, On Using Data Abstractions for Model Checking Refinements, Acta Informatica 44 (2007), pp. 41–71.
Farias, A., A. Mota and A. Sampaio, From CSPZ to CSPM : A transformational java tool, in: WMF, 2001, pp. 1–10.
Farias, A., A. Mota and A. Sampaio, Efficient CSPZ data abstraction, in: E. B., J. Derrick and G. Smith, editors, Integrated Formal Methods (IFM 2004), Lecture Notes in Computer Science 2999 (2004), pp. 108–127.
Goldsmith, M., “FDR: User Manual and Tutorial, version 2.77,” Formal Systems (Europe) Ltd (2001).
Larrecq, J. and I. Mackie, “Proof Theory and Automated Deduction,” Applied Logic Series 6, Kluwer Academic Publishers, 1997.
Mota, A., P. Borba and A. Sampaio, Mechanical abstraction of CSPZ processes, in: L. Eriksson and
P. Lindsay, editors, Formal Methods Europe (FME’2002), LNCS 2391, 2002, pp. 163–183.
Mota, A. and A. Sampaio, Model checking CSPZ : strategy, tool support and industrial application, Science of Computer Programming 40 (2001), pp. 59–96.
Roscoe, A., “The Theory and Practice of Concurrency,” Prentice Hall, 1998.
Smith, G. and J. Derrick, Verifying data refinements using a model checker, Form. Asp. Comput. 18
(2006), pp. 264–287.
Smith, G. and K. Winter, Proving temporal properties of z specifications using abstraction, in: ZB, 2003, pp. 260–279.
Stepney, S., D. Cooper and J. Woodcock, More powerful z data refinement: Pushing the state of the art in industrial refinement, in: ZUM’98: Proceedings of the 11th International Conference of Z Users on The Z Formal Specification Notation (1998), pp. 284–307.
Wehrheim, H., Data abstraction for CSP-OZ, , 1709, LNCS (1999).
Woodcock, J. and J. Davies, “Using Z: specification, refinement, and proof,” Prentice-Hall, Inc., Upper Saddle River, NJ, USA, 1996.
