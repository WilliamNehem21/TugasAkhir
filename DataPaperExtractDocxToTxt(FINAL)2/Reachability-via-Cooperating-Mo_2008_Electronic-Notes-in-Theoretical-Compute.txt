

Electronic Notes in Theoretical Computer Science 223 (2008) 15–27
www.elsevier.com/locate/entcs

Reachability via Cooperating Morphisms

Juhani Karhumäki1,2
Department of Mathematics University of Turku
Turku, Finland

Abstract
The goal of this presentation is to analyze the equality mechanism of cooperating morphisms of free monoids, and to point out that the reachability questions lead to the undecidability and easy characterizations of recursively enumerable languages. In particular, we aim to show, which subconstructions are needed in such results. Moreover, we recall that in some cases the undecidability of the reachability is achieved although the sets of all reachable objects are simple, or more formally, regular languages.
Keywords: morphisms, equality languages, recursively enumerable languages, reachability problems


Introduction
We consider morphisms of free monoids, that is, mappings h : Σ∗ → Δ∗ satisfying h(uv) = h(u) · h(v), for all u, v ∈ Σ∗. By an equality mechanism of two morphisms h and g we mean a selector or a filter, which takes only those words w, such that h(w) and g(w) are in prefix relation, that is, there exists a word z, such that
h(w)z = g(w) or h(w) = g(w)z.	(1) Such a filter can be viewed as a mapping
Fh,g : Σ∗ → {0, 1},

or as a mapping

FWh,g : Σ∗ → Δ∗,

1 Supported by the Academy of Finland under grant 121419
2 Email: karhumak@utu.fi

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.028

where in the first case Fh,g(w) = 1, if and only if (1) holds true for some z, and
FWh,g(w) = z, if (1) holds true with the value z. There are two obvious observations:
Whenever Fh,g(wa), with a ∈ Σ, assumes value 1, so does Fh,g(w);
Whenever FWh,g(wa), with a ∈ Σ, is defined, so is FWh,g(w). Actually, in the second statement we can even write

FWh,g

or
FWh,g
(wa) ∈  FWh,g



(wa) ∈  FWh,g
(w)g(a) −1h(a), h(a)−1 FW 



(w)h(a) −1g(a), g(a)−1 FW 
(w)g(a) }


(w)h(a) }

depending on whether FWh,g(w) = z satisfies the first or the second condition in (1). Note also that the value of FWh,g(wa) in both of these cases is uniquely determined by relative lengths of h(a) and g(a).
The above mechanism can be viewed as a computation procedure, when starting from a fixed w satisfying “ h(w) and g(w) are in prefix relation”. Of course, such a process can be nondeterministic or deterministic, as well as finite or infinite. Hence, reachability questions come in a natural way into the game. We can ask whether such a computation is finite or reaches a particular situation or configuration. We are going to demonstrate that such definitionally natural and simple looking problems are extremely complicated.
More background material can be found, e.g., in handbook chapters [2] and [8].

Equality sets
The theory of equality languages fits well into the above formalism. The equality set of two morphisms h, g : Σ∗ → Δ∗ is the set
E(h, g) = {w ∈ Σ∗ | h(w) = g(w)}.
That is, E(h, g) is the maximal set of words for which h and g are equal word by word. In terms of our reachability problems it constitutes of exactly those words w for which our filter F Wh,g gives the value ε. Another variant of our reachability problem might ask whether our filter is passed by an infinite word.
Following three examples illustrate the above cases.
Example 2.1 For morphisms


a '→ a
h
b '→ baa
a '→ aab
g
b '→ a

we have E(h, g) = (aabb)∗. Now, the above as a computation process is illustrated by the following figure




Example 2.2 If in the above example g(b) is replaced by g(b) = aa, then no
element of E(h, g) (except ε) can be found, but the infinite word  ∞ a2i b2i goes
through the filter as follows:

a a b a a b a a a a a a b a a b a a b a a b a a a a a a a a . . .



Example 2.3 This example shows more clearly how the above mechanism can be viewed to compute something. Consider the morphisms:


1 '→ i
'→ ab
'→  s : 4 '→ a
'→ baba
'→ baf
'→ iab 
'→ abab
'→ 
p : 4 '→ a	.
'→ ba
'→ f


Now, comparable images of letters are 1, 2, 3 and 5. Since s(3) =  = p(3), the word 3 is in E(s, p), and nothing interesting comes out here. Neither give the initial values 2 or 4 anything interesting: they define the prefixes of 2ω (and 4ω) as filtered words. The fourth possibility, that is the letter 1, is more interesting. Indeed, for example,
v3 = 123223222245555355356
is in E(s, p), since the word
w3 = iab (ab)2 (ab)4 (ab)8a (ba)4 (ba)2 baf
can be parsed with the equality mechanism, by s and p; that is,
s(v3) = w3 = p(v3).

It is not difficult from above to conclude the general formula for the set of all minimal elements in E(s, p), where minimal refers to the fact that no word is a prefix of another in the set. In particular, E(s, p) is not a regular language, while s is a suffix set and p is a prefix set. Note also, that in the above construction the middle marker 4 is used to change the period ab to that of ba — and hence the counting becomes possible.

The equality sets determine exactly all solutions of instances of Post Correspon- dence Problem, which is probably the best known representative of combinatorial undecidable problems, cf. [10] and [8]. Hence, our point is not to emphasize the undecidability of our reachability problems as such, but rather to try to find basic and clear constructions needed in such proofs.

Basic reachability problem
We define an individual reachability problem for triples (α, h, g), where h, g : Σ∗ → Δ∗ are morphisms and α ∈ Σ+, as the decision question, whether there exists a word w, such that
FWh,g(αw) ∈ Δ∗§Δ∗,
where § is a special symbol in Δ. Our first result is
Theorem 3.1 Individual reachability problem is undecidable.
Proof. Our proof constitutes of straightforward simulation of the Halting Problem for Turing machines. We try to be selfcontained but brief in our presentation.
Assume that M is a Turing machine, with Q as the set of states and Γ as the total set of tape symbols. The transitions of the machine are of the form
(p, a) → (q, b, L/R).	(2)
We assume that the machine is deterministic, 1-way and complete (meaning that there exists always the next move except when p above is the halting state qh). As usual, configurations of M are words of the form
αpβ	with α ∈ Γ∗,β ∈ Γ+ and p ∈ Q.

Each rule (2) changesa factor cpa in a configuration to the factor qcb or cbq depend- ing on whether the third component in the right is L or R, respectively. In addition, the machine has a designated initial state q0.
Now, the fundamental Halting Problem for Turing machines (of above restricted type) asks whether a given Turing machine M halts on a given input w. That is, whether the sequence of configurations
q0w = w0, w1, w2,...,	(3)
where wi+1 is obtained from wi under the above rewriting determined by transitions of M, is finite or infinite. In other words, whether M ever enters to the state qh. This is typically the first example of undecidable problems.
Now, we conclude how our theorem follows from this. We have to define an instance (α, h, g), with α ∈ Σ+, h, g : Σ∗ → Δ∗, such that there exists a word w such that



FWh,g(αw) ∈ Δ∗§Δ∗
if and only if
M halts on input w.
⎫⎪⎪⎬
⎪⎪⎭


(4)

In order to construct h and g we encode the computation into the form
Iw0 w1 w2	,

where I is so called initial marker and  is a separator. We choose α = i ∈ Σ,
§ = qh ∈ Δ and set h(i) = Iq0w and g(i) = I, illustrated as
h(i)
I q0 w g(i)

We assume that configurations αpβ are actually of the form αpβ¯, where β¯ is a barred copy of β, or in fact in the spirit of Example 2.3, letters in α are written in the form
∗a = a and in β¯ in the form b∗ = ¯b. Now, we define
h(ix) = x = g(ix)	for x = , ∗a or b∗,

and further

g(it) = ∗cpa∗	and	h(it) = new t,

if t is the transition

(p, a) → (q, b, L)	(resp. (q, b, R))

and

new t = qc∗b∗	(resp. ∗c∗bq).

It follows that assuming inductively that
h(iw)

I		. . .	 e1 ... en cp a¯ d¯1 ... d¯m g(iw)

the only way to parse g(iw)−1h(iw), by images of g, is as illustrated below:

I	. . .	 e1 ... en cp a¯ d¯1 ... d¯m e1 ... en new t d¯1 ... d¯m 


↓
new t

: qc¯¯b or
cbq


Consequently, the restrictions on M immediately imply the equivalence (4), and hence also the proof of the theorem.	 

PCP as a reachability problem
In the previous section we showed how computations of a Turing machine on a given input can be simulated by a pair of cooperating morphisms, and thus the individual reachability problem for morphisms is undecidable. Our construction is quite general and easily allows many variants of “reachability”: We required that the reached configuration contains a special symbol. Equally we could require that “reachability” means that an infinite word passes our filter or that at the end the morphisms are not only in the prefix relation, but actually match to each other. The second variant corresponds to the famous Post Correspondence Problem, while the former to that for infinite words — or to be precise, to the modified versions, where first symbols in solutions are fixed.
Both of these, and many other situations, are easily shown undecidable, since the corresponding problems for Turing machines are so, and our approach allows simulations similar to those explained in the previous section. We prove here the case of the Modified Post Correspondence Problem asking to decide whether for two morphisms h, g : Σ∗ → Δ∗ and a letter i ∈ Σ, the set
Ei(h, g) = {w ∈ iΣ∗ | h(w) = g(w)}
is nonempty, cf. [8].
Theorem 4.1 Modified Post Correspondence Problem is undecidable
Proof. We use the notation of the proof of Theorem 3.1. The crucial idea is as follows: We extend a halting computation of a Turing machine M on w to the following generalized computation
Iw0 w1 ... αaqh¯bβ¯ αaqhβ¯ ... αaqh αaq¯h αq¯h	 q¯hT.
Of course, this is not a computation of M, but is described, as a computation, where, in addition, there are rewriting rules like
qh¯b → qh,	qh  → q¯h	and	aq¯h → q¯h.

As we showed in the proof of Theorem 3.1 we can find morphisms h, g : Σ∗ → Δ∗, such that
h(iwn )
I w0	. . .	 αa qh ¯b β¯ g(iwn )
Now, since qh has not appeared earlier, we can easily extend the domains of h and
g, such that for some iwn+1 we have
h(iwn+1 )
I w0	. . .	 αa qh ¯b β¯ α a qh β¯ 

g(iwn+1 )
Repeating the process and changing qh to q¯h (when we start to erase immediately before the state qh) we finally succeed to extend h and g, such that for some word iwm we have the matching h(iwm ) = g(iwm ), proving the theorem.	 
The above shows, we believe, that the Modified Post Correspondence Problem and it’s undecidability is a very natural and clear example of reachability problems in our terminology.
To go from the Modified PCP to the ordinary PCP is not difficult, as is well known, see e.g. [8]. This is essentially done by the argument of shifting periods shown already in Example 2.3.

Reachability and language generation
In our formulation of reachability problems so far the initial word was part of the input as it is in the Halting Problem for Turing machines. On the other hand, Turing machines can be used as language generators by selecting those inputs, which allow a halting computation. The very same holds in our formulation of reachability problems for morphisms, and moreover, the power of the equality mechanism of two morphisms makes this extension quite straightforward.
This is the goal of this section. More concretely, we shall show how recursively enumerable languages can be obtained from equality languages, that is, via our reachability approach, by using in addition only simple language operations.
The contents of the next important result were proved simultaneously in slightly different forms in three different papers [4], [5] and [12].
Theorem 5.1 For each recursively enumerable language L, there exist a regular language R and morphisms h, g and π, such that
L = π R ∩ E(h, g) .

Proof. Let L be accepted by a Turing machine, say M, of the type described in Section 3. We associate to each accepted word w = a1 ··· an of M a generalized computation of M of the form:
Iq qa' ... qw' q0w¯ w1 ... αqhβ¯ ... q¯hT	(5)
`w˛¸0x
constituting of three parts: the prefix up to q0, the factor from q0 to the first occurrence αqhβ¯ and the suffix from there on.
The first part corresponds the generation of an input, the second part (accepting) computation of M on w, and the last one the erasing of the tape (and hence matching the cooperating morphisms). We shall show that the above words can be filtered by equality mechanism of two morphisms. Actually, by what we have already seen, it is enough to show that part one can be defined by our method, that is, that we can construct morphisms h and g for which the following holds for some word iw
h(iw)


I q q a'	. . .	 q a' ... a'
 q0 a¯1 ... a¯n 

n	1	n

g(iw)

Moreover, the morphisms h and g have to be defined such, that they do uniformly this for all input words w, that is, that they can generate all potential input words. Hence, the process is inherently nondeterministic. This, however, is no problem, since the morphisms are allowed to be noninjective.
The above is realized as depicted below (where instead of primed letters a' we use factors ∗a; cf. the period shifting of Example 2.3):


h :	i
ian
iq ia1∗
ian∗

I
g :
q ∗ q∗an ∗ q∗an−1 ∗an ∗	...	∗ q∗a1 ∗...an ∗ q0


ian∗

a¯1 ... a¯n 


What happens here is as follows. We start from a new state q. When g (which is behind) decodes q, it generates randomly an input letter a in the shifted form ∗a. These input letters are preserved under parsing by g. A crucial thing here is that in any point g is decoding q it can, besides above, decide that the whole input is already created and accordingly transform the q to the initial state q0 of M, and simultaneously change the shifted input ∗a1 ··· ∗an to the actual input w¯ = a¯1 ··· a¯n. This together with our earlier constructions guarantees that we can select by the equality mechanism exactly the encodings (5). But from this we can easily extract the input w = a1 ··· an. We only have to use different indices, namely ia∗ (not used anywhere else), when decoding the occurrences of w just before q0 by g, and specify

the index (say t) encoding the final marker T . Then π can be defined such, that it erases everything else, but transforms the indices of the above word w to the actual letters of this word. To conclude, we set R = (dom(h) \ {t})∗t.	 
The following remark follows directly from the above proof. Obviously, any equality set is a submonoid of a free monoid. Hence, it possesses the unique minimal generating set; let us refer to such a set as minimal equality set. Then, if equality sets are replaced by minimal equality sets, we can get rid of the intersection with a regular set. This indeed was the result of [4].
Theorem 5.2 Each recursively enumerable set can be expressed as a morphic image of a minimal equality set.
The above theorem is a splendid example of the power of morphisms of free monoids, by giving a purely morphic characterization of computability.

Complete twin shuﬄe languages as generators
In the previous section we showed that all recursively enumerable languages are gen- erated by equality languages of morphisms of free monoids under a simple language- theoretic operations, namely closure under intersection with regular sets and morphic images. In this section we go a step further: We show that for this generation only very special equality sets are needed. This marvelous result was proved in [7].
We recall that the shufle of two words u and v is the set of all words of the form u1v1u2 ··· un−1vn−1un, with u = u1 ··· un and v = v1 ··· vn−1. Let Σn be an n-letter alphabet and Σ¯ n its barred copy. We define, for n ≥ 1, the complete twin shufle TSn over Σn as the language

TSn = {w ∈ (Σn ∪ Σ¯ n)∗ | πΣ
(w) = πΣ¯ n
(w)},

where πΣn and πΣ¯ n are projections of (Σn ∪ Σ¯ n)  into Σ  and Σ¯ , respectively. It
∗	∗	∗
follows immediately that TSn is an example of an equality language.
Now, the result of [7] can be stated as
Theorem 6.1 For each recursively enumerable language L there exist an n,a mor- phism π and a regular language R, such that
L = π(R ∩ T Sn).
Proof. Again we rely on our earlier constructions. According to that, we can asso- ciate to each accepted input w of M the computation as shown in (5):
I q w1 w2 ... wn−1 qh T,	(6)

w0	wn
where each wi is a (generalized) configuration of M, and, for all i ≥ 0, wi−1 derives
wi in one step computation, that is, wi = Next(wi−1). Recall that these generalized

configurations are words of the form uqv, where u and v are words over the alphabet of M and q is a state. Consequently, the set of all potential configurations, say Conf(M), is a regular language. This holds also under the assumptions used in our earlier constructions, where in some places we used copies of letters. Further the words of the form (6) are also from a regular language. We denote this set by R'.
Now, we introduce crucial steps of our construction. For each wi ∈ Conf(M), we define the indices
dg(wi) = g−1(wi) = a1 ··· an	(7)
and
dh(wi) = h−1(wi) = b1 ··· bn	(8)


and the combined index


d(wi) = a1¯b1 ··· an¯bn.	(9)

Consequently, dg computes the index of wi, with respect to g. Interestingly, this is unique, as our construction shows. Similarly, dh computes the index of wi under h, and this need not be unique, since the previous configuration in the computation of M need not be so.
Actually, two small clarifications of the above definitions are needed (and left to the reader): Namely the configurations wi−1 and wi need not be exactly of the same length, and hence the indices in (7) and (8) might be of slightly different lengths. Another small thing is that the computations of the indices in (7) and (8) are in some cases dependent not only on wi but also the surrounding markers.
Now, we are ready to conclude our proof. We associate to the word (6) the word


I¯Idg(q) d(w1) ¯ d(w2) ... d(wn) ¯ dh(qh)¯ T T¯
(10)

We choose R to be the set of words of the form (10) obtained from the words R' defined earlier. Clearly, R is regular, since we use in (9) only balanced shuﬄing. Implicitly the above fixes the size of Σ, that is n, needed here. It follows from above that


if and only if and
w ∈ R ∩ TSn

dg(wi−1) = dh(wi)

dg(wi+1) = dg Next(wi) .

To summarize, R is used to consider sequences of correct configurations, and the complete twin shuﬄe to guarantee that the sequence of configurations is actually a computation of M. Therefore, the result follows, if we choose π to pick up from
(10) the input w.	 

Our final step in sharpening the representation result of recursively enumerable languages is to eliminate the parameter n in Theorem 6.1. This requires the use of another operation, namely that of inverse morphic image. Indeed, let Σn =
{a1,..., an} and define c : (Σn ∪ Σ¯ n)∗ → (Σ2 ∪ Σ¯ 2)∗, with Σ2 = {a, b}, by
ai '→ aib

c :
a¯i
'→ a¯i¯b	.

Then, obviously TSn = c−1(TS2), and we can formulate
Theorem 6.2 For each recursively enumerable language L there exists a regular language R and morphisms π and c, such that
L = π R ∩ c−1(TS2) .

We emphasize that all the operations used in the above theorem are rational, see [1]. Hence, there is a single, and at least definitionally simple, generator for the family of recursively enumerable languages under rational operations.

Regularity and undecidability
We conclude by pointing out one amazing result on equality languages originally proved in [11].
As we saw all recursively enumerable languages can be obtained from a fixed language, namely complete twin shuﬄe TS2 over Σ2, via rational operations. This means that TS2 can be neither regular nor context-free. On the other hand, it is clearly recursive, or even context sensitive (since it is accepted by a deterministic Turing machine in linear space).
A question arises: Does there exists a class of morphisms for which the equality language would be regular? And if “yes”, a further question would be the decidability of PCP for such a class of morphisms.
The first question was first answered affirmative in [5], where it was shown as a tool to resolve the famous D0L sequence equivalence problem, that the class of so-called elementary morphisms is such a class. Later it was noticed that it was not the elementariness, but so-called bounded delay property, which makes the equality sets regular, cf. [3]. We shall explain this in the moment.
After having this the second question became more concrete: Is the PCP for bounded delay morphisms decidable? The surprising negative answer to this was proved in [11], even in the case of prefix (or biprefix) morphisms.
To be more precise we recall that morphism h : Σ∗ → Δ∗ possesses a bounded delay p, if the following holds:
h(au) < h(bv)	&	|u|≥ p	=⇒	a = b.
Here the sign < is used for the prefix relation. It follows that p = 0 corresponds to

the fact that h is a prefix morphism, and, for any p ≥ 0, bounded delay p implies that h is injective.
It is worth noting that (at least) morphism g in our earlier considerations does not have bounded delay for any p. And our results here shows that this is unavoidable.
A fundamental property of bounded delay morphisms related to the equality sets is as follows:
Lemma 7.1 Let h and g have a bounded delay p. Then for any u ∈ Pref (E(h, g))
satisfying
h(u) = g(u)z	with |z|≥ max{|h(a)|· p}
a∈Σ
there exists the unique letter b, such that ub ∈ Pref (E(h, g)).
From this lemma it is straightforward to conclude
Theorem 7.2 For any pair of bounded delay morphisms their equality language is regular.
The above theorem motivates to study PCP for bounded delay morphisms. A striking answer was discovered:
Theorem 7.3 The PCP for bounded delay morphisms is undecidable.	Conse- quently, the regularity in Theorem 7.2 is nonconstructive.
Above results deserve a few comments. First of all, Theorem 7.3 (even in the case of biprefix morphisms) was first proved in [11]. A simpler, more like a textbook type proof, was recently given in [9]. In the latter case p can be shown to be 2.
The proofs are based on the use of so-called reversible Turing machines and of two properties of those. Such machines are “globally injective” in the sense that for any configuration of the computation the previous one is uniquely defined. The two properties needed in the proof are that the halting problem for reversible Turing machines is undecidable, and that the computations of reversible Turing machine can be simulated, in the spirit of Section 3, by bounded delay morphisms
The result of this section clearly demonstrates, we believe, the power of the equality mechanism of two morphisms: The undecidability of PCP is not due to the fact that the set of all solutions is complicated.

Acknowledgement
The author is grateful to Markku Laine for helping in the preparations of this paper.

References
Berstel, J., Transductions and Context-Free Languages, Teubner (1979).
Choffrut, C., and J. Karhumäki, Combinatorics of Words, in G. Rozenberg and A. Salomaa (eds), Handbook of Formal Languages, Springer (1997).
Choffrut, C., and J. Karhumäki, Test sets for morphisms with bounded delay, Discrete Appl. Math. 12
(1985) 93–101.


Culik II, K., A purely homomorphic characterization of recursively enumerable sets, J. ACM 26 (1979), 345–350.
Ehrenfeucht, A., and R. Rozenberg, Elementary homomorphisms and a solution of the D0L sequence equivalence problem, Theoret. Comput. Sci. 7 (1978), 169–183.
Engelfriet, J., and G. Rozenberg, Equality languages and ﬁxed point languages, Inform. Control 43
(1979), 20–49.
Engelfriet, J., and G. Rozenberg, Fixed Point Languages, Equality Languages, and Representation of Recursively Enumerable Languages J. ACM 27 (1980), 499–518.
Harju, T., and J. Karhumäki, Morphisms, in G. Rozenberg and A. Salomaa (eds), Handbook of Formal Languages, Springer (1997).
Karhumäki, J., Saarela, A., Noneflective regularity of equality languages and bounded delay morphisms, manuscript, 12pp.
Post, E., A variant of a recursively unsolvable problem, Bull. Amer. Math. Soc. 52 (1946), 264–268.
Ruohonen, K., Reversible machines and Post’s correspondence problem for bipreﬁx morphisms, J. Inform. Process. Cybernet. (EIK) 21 (1985), 579–595.
Salomaa, A., Equality sets for homomorphisms of free monoids, Acta Cybernetica 4 (1978), 127–139.
