

Electronic Notes in Theoretical Computer Science 192 (2008) 71–83
www.elsevier.com/locate/entcs
A Hierarchy of Quantum Semantics
Simon Perdrix1
Oxford University Computing Laboratory

Abstract
Several domains [1,4,12,16] can be used to define the semantics of quantum programs. Among them Abram- sky [1] has introduced a semantics based on probabilistic power domains, whereas the one by Selinger [16] associates with every program a completely positive map. In this paper, we mainly introduce a semantical domain based on admissible transformations, i.e. multisets of linear operators. In order to establish a com-
parison with existing domains, we introduce a simple quantum imperative language (QIL), equipped with three different denotational semantics, called pure, observable, and admissible respectively. The pure se- mantics is a natural extension of probabilistic (classical) semantics and is similar to the semantics proposed by Abramsky [1]. The observable semantics, `a la Selinger [16], associates with any program a superoperator over density matrices. Finally, we introduce an admissible semantics which associates with any program an
admissible transformation. These semantics are not equivalent, but exact abstraction [7] or interpretation relations are established between them, leading to a hierarchy of quantum semantics.
Keywords: Quantum programming semantics, admissable transformation, QIL


Introduction
Which formalism is adapted to the representation of quantum states and quantum evolutions ? It turns out that at least two formalisms can be used for representing quantum states: pure states (i.e vectors in a Hilbert space) and mixed states (i.e. density matrices). For the representation of quantum evolutions, at least three can- didates exist: superoperators 2 acting on density matrices, probabilistic functions acting on pure states, and admissible transformations 3 .
In the context of quantum programming, several semantic domains based on the above formalisms have been designed: the domain of superoperators [16], the domain of probabilistic functions acting on pure states [1], and a new quantum semantic domain based on admissible transformations, which is introduced in this paper.

1 Email: simon.perdrix@comlab.ox.ac.uk
2 Trace decreasing, completely positive maps.
3 Multisets of linear operators satisfying a completeness condition, see section 2.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.028

In order to compare these three domains, a simple quantum programming lan- guage QIL is introduced, together with three denotational semantics. These three semantics are not equivalent, however exact abstraction or interpretation relations are established between them, leading to a hierarchy of quantum semantics.
The domain of admissible transformations is the most concrete domains, and the domain of superoperators is the most abstract. Notice that an even more abstract domain have been introduced in [14] in order to realise an analysis of entanglement evolution based on abstract interpretation. Finally, the main differences and specific properties of these three non equivalent domains are discussed.
This work is related to several works consisting in establishing hierarchies of ’classical’ semantics, for instance [8]. In the case of quantum semantics, a con- nection between the domain of pure states and the one of density matrices have been established by Selinger in a categorical framework [17], by means of a CPM- construction.
Quantum Computing Basics
The basic carrier of information in quantum computing is a 2-level quantum system (qubit ), or more generally a register of n qubits. The state of a n-qubit register is a normalized vector of a Hilbert space C2n . So, for a given basis A, a general state
|ϕ⟩∈ C|A| can be written as:	Σ

with x A αx 2 = 1. Vectors, inner and outer products are expressed in the notation introduced by Dirac. Vectors are denoted ϕ ; the inner product of two vectors |ϕ⟩, |ψ⟩ is denoted by ⟨ϕ|ψ⟩. If |ϕ⟩ =  x∈A αx|x⟩ and |ψ⟩ =  x∈A βx|x⟩,
hand side ϕ of the inner product is a bra-vector, and the right hand side ψ  is a
ket-vector. A bra-vector is defined as the adjoint of the corresponding ket-vector: if
|ϕ⟩ =	x A αx|x⟩, then ⟨ϕ| = |ϕ⟩† =	x A αx∗ ⟨x|. The bra-ket notation can also be used to describe outer products: |ϕ⟩⟨ψ| is a linear operator such that (|ϕ⟩⟨ψ|)|ϵ⟩ =
⟨ψ|ϵ⟩ |ϕ⟩. The state of a register composed of 2 sub-systems in state |ϕ⟩∈ C|A| and
|ψ⟩∈ C|B| respectively, is the normalized vector |ϕ⟩⊗ |ψ⟩∈ C|A| ⊗ C|B| ∼= C|A|×|B|,
where ⊗ is the tensor product. For any x ∈ A, y ∈ B, |x, y⟩ denotes |x⟩⊗ |y⟩.
An isolated system evolves according to a unitary transformation 4 U ∈ L(C|A|), transforming a state |ϕ⟩ ∈ C|A| into U|ϕ⟩. A projective measurement is a proba- bilistic evolution described by a set Pi i∈B of orthogonal projectors 5 which is complete 6 . A measurement produces a classical outcome i B and transforms the state ϕ  C|A| into   Pi|ϕ⟩  with probability ϕ Pi ϕ .
⟨ϕ|Pi|ϕ⟩
The composition of two projective measurements is not necessary a projective measurement. However, any quantum evolution, can be described in a more general

4 U is unitary if and only if U†U = I.
5 ∀i, j ∈ B, PiPj = δi,j Pi where δ is the Kronecker delta.

6
i∈B
Pi = I

framework the admissible transformations, which is closed under composition. An admissible transformation is a countable multiset M  of linear operators which satisfy the completeness condition i A Mi†Mi = I. An admissible transformation composed of a unique operator U is an isometry since U†U = I, moreover if UU† = I then U is a unitary transformation. An admissible transformation composed of only projectors is a projective measurement.
A probability distribution of quantum states of C|A| can be represented by a density matrix ρ D(C|A|) L(C|A|), i.e. a self adjoint 7 positive-semidefinite 8 complex matrix of trace 9 less than one. A unitary transformation U transforms ρ into UρU† and a projective measurement Pi i∈B transforms ρ into  i B PiρPi. Such a projective measurement produces the classical outcome i B with proba- bility Tr(PiρPi) = Tr(Piρ).
Any n-qubit unitary transformation U can be approximated within an arbitrary accuracy 10 by composing unitary transformations from the universal set of unitary transformations H, T, CNot , composed of two 1-qubit and one 2-qubit unitary transformations. Notice that there exist several universal families of unitary trans- formations in the literature [13].



1 ⎛ 1 1 ⎞



⎛ 1	0	⎞
⎛ 1 0 0 0 ⎞
⎜	⎟

⎝ 0 0 1 0 ⎠



A Quantum Programming Language
Several quantum programming languages have been introduced recently, for a com- plete overview see [9] and [15]. In this paper, we introduce a Quantum Imperative Language (QIL), the syntax is similar to the one of the language introduced by Abramsky [1], except for quantum measurements which are treated implicitly in QIL, like in QML [2].
A QIL program is a pair (Q, C), where Q = {q0,..., qn} is a finite set of symbols





7 M is self adjoint (or Hermitian) if and only if M† = M
8 M is positive-semidefinite if all the eignenvalues of M are non-negative.
9 The trace of M (tr(M )) is the sum of the diagonal elements of M
10 U is approximated by V within є > 0 if ||U − V || < є 

representing a finite memory of qubits, and C is a command defined as follows:

C ::=	skip
| C1; C2
| if q then C1 else C2
| while q do C
| H(q)
| T(q)
| CNot(q, q)

Notice that QIL is not limited to a unitary fragment, since according to the se- mantics of the language, quantum measurements are encoded into the conditional structures of the language: when a qubit q is used as a condition, q is first mea- sured, then the classical outcome of the measurement plays the role of the boolean evaluation of the condition.
Example 3.1


ex1 : while q do H(q)
ex2 : while q do H(q) ; 
H(q) ; 
if q then skip
else
skip
ex3 : while q do H(q) ; 
H(q) ; 
if q then
H(q)
else
H(q)


A Probabilistic Semantics
According to the postulates of quantum mechanics, the state of a quantum system is a normalised vector in a Hilbert space, and its evolution is probabilistic. Thus, a natural way to define a quantum semantics consists in a quantum version of a classical probabilistic semantics, based for instance on probabilistic power domains [10].
For a given qubit q, let |ttq⟩ (true) and |ffq⟩ (false) be the two basis states of
q. The state of q is then a normalised vector of the Hilbert space Hq = {α|ttq⟩ +
β|ffq⟩ | α, β ∈ C} ∼= C2.  For a given finite set Q of qubits, the state of Q is a

normalised vector of HQ
=  q∈Q Hq
∼= C2|Q| , i.e. an element of the unit sphere

1 = {|ϕ⟩∈ HQ | |||ϕ⟩|| = 1} of HQ.
Since the evolution of a quantum system is probabilistic, the state of mem-
ory is not, in general, a pure state but a probabilistic distribution of pure

states. Such a probabilistic distribution is represented by a valuation ν : H1 →
R+ which associates with every pure state its probability.	Let VQ = {ν ∈

1
Q
uations.
|ϕ⟩∈supp(ν)
ν(|ϕ⟩) ≤ 1} be the set of discrete val-

Theorem 3.2 ([10]) (VQ, ±) is a complete partial order with 0 (i.e.	the val- uation with an empty support) as least element, where ν ± μ if and only if
∀|ϕ⟩∈ supp(ν), ν(|ϕ⟩) ≤ μ(|ϕ⟩).
Since any unitary transformation U is reversible, with U−1 = U†, the probability that a quantum system is in state |ϕ⟩ after the application of U is equal to the probability that the system was in state U†|ϕ⟩ before the application of U . Thus, U transforms a discrete valuation ν into λ|ϕ⟩.ν(U†|ϕ⟩) 11 .
A projective measurement {Pi}i∈B, which is not reversible, produces the classical outcome i ∈ B and transforms a state |ϕ⟩ into √ Pi|ϕ⟩  with probability ⟨ϕ|Pi|ϕ⟩.

Thus,
⟨ϕ|Pi|ϕ⟩
{Pi}i∈B produces the classical outcome i ∈ B, and transforms a discrete val-

uation ν into Σ

|ϕ⟩∈supp(ν)
ν(|ϕ⟩)⟨ϕ|Pi|ϕ⟩δ


 Pi|ϕ⟩  (ϕ|Pi|ϕ⟩
, where δx
(y) =	1	if x = y
0	otherwise

Definition 3.3 (Pure semantics) For any finite set Q, for any command C, let [[C]]p : VQ → VQ be defined as follows:
[[skip]]p = I
[[C1; C2]]p = [[C2]]p ◦ [[C1]]p
[[T(q)]]p = λν.λ|ϕ⟩.ν(Tq†|ϕ⟩)
[[H(q)]]p = λν.λ|ϕ⟩.ν(Hq†|ϕ⟩) [[CNot(q1, q2)]]p = λν.λ|ϕ⟩.ν(CNot†q1,q2 |ϕ⟩)
[[if q then C1 else C2 ]]p = λν.[[C1]]p,⎝ Σ |⟨ϕ|ttq⟩|2ν(|ϕ⟩)δ (|ttq⟩(ttq|)|ϕ⟩ ⎞⎠
|ϕ⟩∈supp(ν)

+ [[C2]]p	ϕ ffq  2ν( ϕ )δ (|ffq⟩(ffq|)|ϕ⟩
|(ϕ|ffq⟩|
|ϕ⟩∈supp(ν)

[[while q do C ]]p = lfp λf.λν.f	[[C]]p	ϕ ttq 2ν( ϕ )δ (|ttq⟩(ttq|)|ϕ⟩
|(ϕ|ttq⟩|
|ϕ⟩∈supp(ν)
+	ϕ ffq  2ν( ϕ )δ (|ffq⟩(ffq|)|ϕ⟩
|(ϕ|ffq⟩|
|ϕ⟩∈supp(ν)

where Mq means that M is applied on qubit q.
One can prove by induction on the command C that [C]]p : VQ → VQ is conti-

11 In this paper, functions are represented using λ-notation: λx.y is a function which associates y with x,
i.e. the function x '→ y.

nuous 12 and that the least fixed point used for defining the semantics of the while
command exists, thanks to the fixed point theorem 13 .
Example 3.4 [[ex1]]p = λν.δ|ff⟩, [ex2]]p = λν.( 1 δ|tt⟩ + 1 δ|ff⟩), and [ex3]]p =
2	2
λν.( 1 δ(|tt⟩+|ff⟩)/2 + 1 δ(|tt⟩−|ff⟩)/2))

Observable Semantics
The pure semantics introduced in the previous section does not take into account quantum properties like indistinguishability. For instance, according to the pos- tulates of quantum mechanics, a qubit in state |tt⟩ or |ff⟩ with equal probability cannot be distinguished from a qubit in state √1 (|tt⟩ + |ff⟩) or √1 (|tt⟩− |ff⟩) with
equal probability. In order to take into account this phenomenon, one can use the formalism of density matrices (see section 2) for representing quantum states.
For a finite set of variables Q =  q0,..., qn , let	Q = D(  Q) be the set of
density matrices on Q.
Theorem 3.5 ([16]) The poset (DQ, ±) is a complete partial order with 0 as least element, where M ± N if N − M is positive (L¨owner partial order).
Definition 3.6 (Observable semantics) For any finite set Q, for any command
C, let [C]]o : DQ → DQ be defined as follows:
[[skip]]o = I
[[C1; C2]]o = [[C2]]o ◦ [[C1]]o
[[H(q)]]o = λρ.HqρHq†
[[T(q)]]o = λρ.TqρTq†
[[CNot(q1, q2)]]o = λρ.CNotq1,q2 ρCNot†q1,q2
[[if q then C1 else C2 ]]o = λρ. [[C1]]o(P ttρP tt)+ [[C2]]o(P ff ρP ff) 
[[while q do C ]]o = lfp  λf.λρ. f ◦ [[C]]o(P ttρP tt)+ P ff ρP ff 
= λρ.	(FP ff ◦ ([[C]]o ◦ FP tt )n(ρ))
n∈N
where P tt = , 1 0 ⎞ and P ff = , 0 0 ⎞, F	= λρ.MρM†.

⎝ 0 0 ⎠
⎝ 0 1 ⎠
M

, 1 0 ⎞


, 1 0 ⎞

Example 3.7
ex1 o
o	⎝ 0 1 ⎠
o	⎝ 0 1 ⎠



12 A continuous function is monotonic and preserves least upper bounds.
13 The fixed point theorem states that for a given complete partial order (D, ≤) and a continuous function f : D → D, f has a least fixed point lfp(f ). Notice that here, the fixed point theorem is applied with the complete partial order ([VQ → VQ], ±) of continuous functions where ± is defined pointwise.

The observable semantics associates with any command C a map [C]]o that is a superoperator 14 , thus for any ρ ∈ ÐQ, [[C]]o(ρ) ∈ ÐQ.
Observable and probabilistic semantics of QIL are not equivalent, as it is illus- trated in example 3.4 and 3.7: [ex2]]o = [[ex3]]o whereas [ex2]]p = [[ex3]]p. However, observable semantics is an exact abstraction [7] of the probabilistic semantics. Any probability distribution over quantum states ν can be abstracted into a density ma- trix ρ = α(ν), where α : VQ → ÐQ is defined as α = λν.  |ϕ⟩∈supp(ν) ν(|ϕ⟩) |ϕ⟩⟨ϕ|.
Lemma 3.8 [[.]]o is an α-abstraction of [[.]]p, i.e. for any command C,
[[C]]o ◦ α = α ◦ [[C]]p


Ð	[[.]]o ) Ð
ˆ	ˆ
α	α
[[.]]p )
VQ	Q


Proof. (sketch) The proof is by induction on the command C. The proof is immediate for the commands skip, the composition and the unitary transformations H, T, and CNot. For the if case, the main two ingredients of the proof are:
– for any ν ∈ VQ,
α ,⎝ Σ |⟨ϕ|ttq⟩|2ν(|ϕ⟩)δ (|ttq⟩(ttq|)|ϕ⟩ ⎞⎠ = P ttα(ν)P tt

|ϕ⟩∈supp(ν)
– α is linear: for any ν1, ν2, α(ν1 + ν2) = α(ν1)+ α(ν2)
For the while case, in order to preserve the least fixed point, the continuity of α is used.	HH
Lemma 3.8 establishes a connection between two domains used in quantum com- putation. Observable and pure semantics are not equivalent, however the observable semantics is an abstraction of the pure one. This abstraction carries the indistin- guishability to the pure semantics: let C1 and C2 be two commands such that [[C1]]p = [[C2]]p and [C1]]o = [[C2]]o, then for any ν  Q, [[C1]]p(ν) and [C1]]p(ν) are indistinguishable. However, even if observable and pure semantics are not equiva- lent, none of them violate the postulates of quantum mechanics. Notice that the author have established a similar exact abstract connection for the semantics of the quantum calculus [11].

14 F is a superoperator if Tr(F (ρ)) ≤ Tr(ρ), and (Ik ⊗F )(ρ') is positive for any k ≥ 0 and any ρ, ρ' positive, where Ik : Ck → Ck is the identity map.

Additionally to the abstraction function α : Q  Q, a concretisation function γ : Q  Q can be defined. The concretisation function is based on spectral de- composition of density matrices. For any ρ	, since ρ is self-adjoint, there exist an orthonormal basis {|ϕi⟩}i=0...2|Q| 1 and λis such that ρ = i=0...2|Q| 1 λi|ϕi⟩⟨ϕi|. Moreover, since ρ is positive, λi ≥ 0 for any i.  The function γ is such that
supp(γ(ρ)) = ϕi i 0...2|Q| 1, and for any i, γ(ρ)( ϕi ) = λi. Notice that the orthonormal basis of eigenvectors is not unique, as a consequence, for any ρ, the support of γ(ρ) is one among all the possible orthonormal basis of eigenvectors of
ρ. Since α ◦ γ = I, a corollary of lemma 3.8 is that for any command,

[[C]]o = α ◦ [[C]]p ◦ γ


Ð	[[.]]o ) Ð
ˆ
γ	α
v	[[.]]p )
VQ	VQ



Admissible semantics
According to the postulates of quantum mechanics, any quantum evolution can be described by an admissible transformation, i.e. a countable multiset of linear operators (see section 2). In this section, we introduce a denotational semantics associating with every program an admissible transformation.
Let MQ be the set of all countable multisets {Mi}i∈A such that ∀i ∈ A, Mi ∈
L(HQ) and	i A Mi†Mi ± I. Let mK(x) be the multiplicity of x in the multiset K,
i.e. the number of occurrences of x in K. For any two multisets K and L, K ⊆ L if for any x, mK(x) ≤ mL(x). The join K  L is such that for any x, mK L(x) = mK(x)+mL(x). Moreover, composition • of admissible transformations is defined as follows: for any {Mi}i∈A, {Mj' }j∈B ∈ MQ, {Mi}i∈A • {Mj' }j∈B = {MiMj' }(i,j)∈A×B.
Theorem 3.9 (MQ, ⊆) is a complete partial order with {0} as least element.
Proof. Let F0 ⊆ F1 ... be an increasing sequence.  Assume w.l.o.g that Fi =
{Mj}j∈Ii where Ii is an interval of N such that 0 ∈ Ii and Ii ⊆ Ii+1. The increasing sequence I0 ⊆ I1 ⊆ ... has a limit J ⊆ N, thus the least upper bound of F0 ⊆ F1 ... F	{Mi}i∈J	i∈j Mi Mi	limn→∞	i∈In Mi Mi ± I	F  ∈  MQ
HH
Definition 3.10 (Admissible semantics) For any finite set Q, for any command
C, let [C]]p : MQ → MQ be defined as follows:

[[skip]]a = {I}
[[C1; C2]]a = [[C2]]a • [[C1]]a
[[H(q)]]a = {Hq}
[[T(q)]]a = {Tq}
[[CNot(q1, q2)]]a = {CNotq1,q2 }




[[while q do C ]]a

∞
=
k=0
q

 {P ff }• ([[C]]a
q

{P tt})n 

Example 3.11 Since for any n > 1, (HP tt)n =  1  , 1 0 ⎞,



[[ex1]]
= {, 0 0 ⎞} {,
0	0 ⎞}

a	⎝ 0 1 ⎠

 1  2n/2
n>0


[[	]]
= {  1  , 0 1 ⎞
 1  , 0 0 ⎞

	1	
2(n+1)/2
0	0 ⎞

ex2 a
√2 ⎝ 0 0 ⎠ , √2 ⎝ 0
−1 ⎠} {⎝
,	  1	 2(n+1)/2
0 ⎠}n>0

1 , 0 1 ⎞
1 , 0 −1 ⎞
, 	1	 0 ⎞
1 ,   −1	 0 ⎞

[[ex3]] = {	,
} { 
2(n+2)/2
,	2(n+2)/2	}

a	2 ⎝ 0 1 ⎠
2 ⎝ 0 1 ⎠
	1	 2(n+2)/2
2		1	
2(n+2)/2
n>0

Admissible transformations and superoperators are related by the Krauss rep- resentation theorem [3]: for any superoperator F , there exists a set of linear op- erators Mi i∈A such that F = λρ. i A MiρMi†. Notice that this set of linear operators is not unique. Any admissible transformation can be seen as the repre- sentation of a superoperator. χo :  Q  ( Q   Q) is an interpretation func- tion which associates with any admissible transformation M  a superoperator χo( Mi i∈A) = λρ.  i A MiρMi†. The observable semantics is an interpretation of the admissible semantics:
Lemma 3.12 For any command C, [[C]]o = χo([[C]]a).
Proof. (sketch) The proof is by induction on the command C. The proof is immediate for the commands skip and the unitary transformations H, T, CNot. The composition is treated as follows, for any command C1 and C2, let [C1]]a = {Mi}i∈A and [C2]]a = {Nj}j∈B. χo([[C1; C2]]a) = χo([[C2]]a•[[C1]]a) = χo({NjMi}(i,j)∈A×B) = λρ.NjMiρMi†Nj† = [[C1; C2]]o. The if and while cases are based on the linearity of
χo : χo(K  L) = χo(K)+ χo(L).	HH
Moreover, admissible transformations can also be interpreted in terms of prob- abilistic evolutions via the function χp : MQ → (VQ → VQ) which associates with

any admissible transformation {Mi}i∈A a probabilistic evolution χp({Mi}i∈A) =

λν.	i∈A,|ϕ⟩∈supp(ν) ν(|ϕ⟩)⟨ϕ|Mi†Mi|ϕ⟩δ r

pretation of the admissible semantics:

Mi|ϕ⟩
†
(ϕ|M M |ϕ⟩
i
. The pure semantics is an inter-

Lemma 3.13 For any command C, [[C]]p = χp([[C]]a).
Proof. The proof, by induction on the command C, is based on the linearity of χp (χp(K L) = χp(K) + χp(L)), and its continuity which preserves least fixed points.	HH
Notice that lemma 3.12 can be seen as a consequence of lemmas 3.8 and 3.13: for any command C, [[C]]o = α◦[[C]]p◦γ and [C]]p = χp([[C]]a), so [C]]o = α◦χp([[C]]a)◦γ.
The admissible semantics associates with any program an admissible transfor- mation. Since an admissible transformation is not a function but a multiset of linear operators, no connection based on abstraction function can be realised with the pure and observable semantics introduced in previous sections. However, inter- pretation functions, χp and χo transform the admissible semantics into the pure and the observable semantics, showing that the admissible semantics is a more concrete semantics. As admissible semantics is more concrete than pure semantics, the indis- tinguishability phenomenon is not taken into account as it is illustrated in example
3.11 since [ex2]]a = [[ex3]]a. In order to illustrate the concreteness of the admissible semantics, one can notice in the definition of the semantics that the existence of while loop in a command C implies that the admissible semantics of C is an in- finite multiset: each linear operator of the admissible transformation represents a computational path.
Exact abstraction and interpretations between the semantics established in lem- mas 3.8, 3.12, and 3.13 lead to a semantical hierarchy:
Theorem 3.14 (Hierarchy of quantum semantics) For  any  commands
C1, C2,
[[C1]]a = [[C2]]a =⇒ [[C1]]p = [[C2]]p	and	[[C1]]p = [[C2]]p =⇒ [[C1]]o = [[C2]]o

Discussion and Perspectives
Three non equivalent semantics can be used for defining the semantics of a quantum program. One can wonder which one has to be used in which context. This question is discussed in this section. First, a natural extension of the language is considered: the parallel composition of programs.

Parallel composition
For given programs (Q1, C1) and (Q2, C2), such that Q1 Q2 =  , a natural extension of the language consists in allowing the parallel composition of these two programs, leading to a program (Q1 ∪ Q2, C1 | C2).

Observable and admissible semantics can be extended as follows: [C1 | C2]]o = [[C1]]o ⊗ [[C2]]o and [C1 | C2]]a = [[C1]]a ⊗ [[C2]]a, where the tensor product on multisets is defined as {Mi}i∈A ⊗ {Nj}j∈B = {Mi ⊗ Nj}(i,j)∈A×B.
The pure semantics cannot be easily extended to the parallel composition. One way to explain this difference between observable, admissible and pure semantics is that the Hilbert space structure is not explicitly represented in the pure semantics, avoiding a natural representation of the tensor product.

Indistinguishability of quantum evolutions
The introduction of density matrices is mainly motivated by the indistinguishability of some probability distributions over pure states (see section 3.2.) In order to decide which domain among the superoperators, the probabilistic functions and the admissible transformations is the most suitable for the representation of quantum evolution, the indistinguishability of quantum evolutions is a relevant question to address.
Indistinguishability of quantum evolutions can be derived from indistinguishabil- ity of quantum states. Since the indistinguishability of quantum states is captured by density matrices, indistinguishability of two evolutions f and g can be stated as
ρ, f (ρ) = g(ρ) (i.e. f = g) if f and g are superoperators, or as χo(f ) = χo(g) if
f and g are admissible transformations, or finally as α  f  γ = α  g  γ if f and
g are probabilistic functions. As a consequence, it turns out that the observable semantics is the best candidate to take into account such an indistinguishability of quantum evolutions.
However, additionally to the indistinguishability of the quantum states pro- duced by quantum evolutions, one can also take into account the classical out- comes produced during the computation in order to distinguish two evolutions.
For instance, consider the following two admissible transformations: A1 = {M0}

and A2 = {N0, N1}, where M0 = I and N0 = N1 =
1 I. One can prove that
2

χp( 1) = χp( 2) and χo( 1) = χo( 2). However, for any input state, 1 produces always the same classical outcome 0, whereas  2 produces 0 with probability 1/2
and 1 with probability 1/2, making these two evolutions easily distinguishable.
As a consequence, the question of indistinguishability of quantum evolutions might be stated within a framework allowing hybrid memories, i.e. memories com- posed of a classical part and a quantum part such that the classical outcomes pro- duced during the computation can be taken into account for distinguishing quantum evolutions.

Hybrid computation
In this paper, a purely quantum programming language has been introduced in the sense that the memory is entirely quantum. However, hybrid computation, where the memory is composed of a quantum part and a classical part, is a natural architecture to consider for a quantum computer. As a consequence, the ability to represent classical variables and classical evolutions is a relevant parameter for

comparing pure, observable and admissible semantics.
In the case of the pure semantics, the use of valuations makes the representa- tion of classical data an easy task, since this formalism is largely used for classical probabilistic computations. Instead of valuations over 7Q, one can use valuations over E × 7Q where E is the state space of the classical variables.
One way to represent classical variables in the formalism of density matrices is to encode classical data as quantum basis states. The hybrid domain is then E×Q. This solution is used in [16], however such an encoding does not point out
the proper properties of classical data like the ability of copying data [5,6].
The probabilistic interpretation of an admissible transformation Mi i∈A is such that A represents the possible classical outcomes, and if the outcome i A occurs, then the quantum system evolves according to Mi. Thus, an admissible transforma- tion is already a natural representation of the classical-quantum interactions. Hence, the extension of the admissible transformation formalism to classical-quantum evo- lutions is a promising perspective.

Lattices
Finally, the choice of the semantics can be based on some specific properties of the domain, for instance whether the domain is a lattice or not. For any finite set Q, (VQ, ±, H, 0) is a lower semilattice, with ν1Hν2 = λ|ϕ⟩.min(ν1(|ϕ⟩), ν2(|ϕ⟩)). (łQ, ⊆
,  , 0) is a lower semilattice as well, with mK∩L = λx.min(mK(x), mL(x)). Notice
that the previous domains can be turned into lattices by relaxing the condition
|ϕ⟩∈supp(ν) ν(|ϕ⟩) ≤ 1 in the definition of VQ (see in section 2.1) and the condition
i A Mi†Mi ± I in the definition of łQ (see section 2.3).
The domain of density matrices is neither an upper nor a lower semilattice. It is proved in [16], that ( Q,  ) is not an upper semilattice. Moreover, ( Q,  ) is not a lower semilattice, since

, 0.3	0 ⎞
and , 0	0 ⎞

⎝ 0	0 ⎠
⎝ 0	0.3 ⎠


are two different maximal lower bounds of


0.3	0
0	0.3
and	0.4	0.2
0.2	0.4

Conclusion
We have mainly proved that the semantics of a quantum program can be based on admissible transformations, i.e. multisets of linear operators. We have introduced a complete partial order over admissible transformations and defined an admissible semantics, based on admissible transformations, of a simple quantum imperative

language (QIL). In order to compare this new semantic domain with existing ones, two additional semantics based on probability distributions over pure states (pure semantics) and on density matrices (observable semantics) are defined. These three semantics are not equivalent and lead to a hierarchy where the admissible semantics is the most concrete one. The pure semantics, based on probabilistic power domain is more abstract, whereas the most abstract semantics is the one based on density matrices.

References
S. Abramsky. A Cook’s tour of a simple quantum programming language. 3rd International Symposium on Domain Theory, Xi’an, China, May 2004.
T. Altenkirch and J. Grattage. QML: Quantum data and control. Manuscript, 2005.
M.-D. Choi. Completely positive linear maps on complex matrices. Linear Algebra Appl., 10:285, 1975.
B. Coecke and K. Martin. A partial order on classical and quantum states. Technical report, PRG- RR-02-07, 2002.
B. Coecke, D. Pavlovic. Quantum measurements without sums In Mathematics of Quantum Computing and Technology, 2007.
B. Coecke, E. O. Paquette, and S. Perdrix. Bases in diagramatic quantum protocols In the proceedings of the 24th conference on the Mathematical Foundations of Programming Semantics (MFPS), 2008.
P. Cousot. Types as abstract interpretations. In POPL, pages 316–331, 1997.
P. Cousot. Constructive Design of a Hierarchy of Semantics of a Transition System by Abstract Interpretation. Theoretical Computer Science, vol 277, 2002.
S. J. Gay. Quantum programming languages: Survey and bibliography. Mathematical Structures in Computer Science, 16(4), 2006.
C. Jones and G. D. Plotkin. A probabilistic powerdomain of evaluations. In LICS, pages 186–195, 1989.
Ph. Jorrand and S. Perdrix. Towards a quantum calculus. In To appear in Proceedings of the 4th International Workshop on Quantum Programming Languages, ENTCS, 2006.
E. Kashefi. Quantum domain theory — definitions and applications. In Proceedings of the International Conference on Computability and Compexity in Analysis, number 302 – 8/2003 in Fernuniversit¨at Hagen Informatik Berichte, 2003.
M. A. Nielsen and I. L. Chuang. Quantum computation and quantum information. Cambridge University Press, New York, NY, USA, 2000.
S. Perdrix. Quantum entanglement analysis based on abstract interpretation. In Proceedings of the 15th International Static Analysis Symposium (SAS’08), LNCS 5079, (preprint arXiv:0801.4230), 2008.
P. Selinger. A brief survey of quantum programming languages. In Proceedings of the 7th International Symposium on Functional and Logic Programming, volume 2998 of Lecture Notes in Computer Science, pages 1–6. Springer, 2004.
P. Selinger. Towards a quantum programming language. Mathematical Structures in Computer Science, 14(4):527–586, 2004.
P. Selinger. Dagger compact closed categories and completely positive maps In Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005), Chicago. ENTCS 170:139- 163, 2007.
