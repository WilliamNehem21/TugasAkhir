Electronic Notes in Theoretical Computer Science 213 (2008) 23–38	
www.elsevier.com/locate/entcs


Towards a Systematic Method for Proving Termination of
Graph Transformation Systems
H. J. Sander Bruggink1 ,2
Institut fu¨r Informatik und Interaktive Systeme, Universit¨at Duisburg–Essen Duisburg, Germany

Abstract
We describe a method for proving the termination of graph transformation systems. The method is based on the fact that infinite reductions must include infinite ‘creation chains’, that is chains of edges in different graphs of the reduction sequence, such that each edge is involved in creating the next edge. In our approach, the length of such creation chains is recorded by associating with each edge label a creation depth, which denotes the minimal length of a creation chain from an edge in the initial graph to that edge. We develop an algorithm which can prove the absence of such infinite chains (and therefore termination), analyse problems of the approach and propose possible solutions.
Keywords: termination, graph transformation


Introduction
Proving termination of graph transformation systems (gtss) has applications in model transformation, program analysis and modelling dynamic systems. This has brought about emerging interest in finding termination techniques for gtss [4,3,6,16,10].
In term and string rewriting, proving termination has historically attracted much more attention. Many general techniques for proving termination have

1 Partially supported by dfg project sands.
2 E-mail: sander.bruggink@uni-due.de



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.072

been devised, even to the point that many of them can be used to automati- cally obtain termination proofs of specific rewrite systems. The most succesful of these techniques make use of the fact that infinite reduction sequences must have infinite ‘creation chains’, that is infinite chains of symbols f1, f2, f3,... in different terms of the reduction sequence, such that each symbol of the sequence is involved in creating the next symbol [12,1,8,5]. Proving that such chains do not exist is often easier than proving termination of a rewrite system directly.
Although termination techniques for term rewriting have been transferred to the area of term graph rewriting (see e.g. [13] for an overview), transferring proof techniques to the general form of graph rewriting is often not directly possible, because they make use of the inherent hierarchical nature of terms and strings. Still, we think it is a worthwile area of research to see how much of the theory can be ported to a graph rewriting setting.
In this paper we describe ongoing research to develop a method for prov- ing the termination of gtss based on the “absence of infinite creation chains” approach. We do not focus on proving non-existence of infinite reduction se- quences starting from one particular source graph, such as most other termina- tion results for gtss, but instead on proving non-existence of infinite reduction sequences starting from arbitrary members of inﬁnite classes of graphs, which we will call regular graph languages. Additionally, we describe an algorithm which can find termination proofs for some graph transformation systems au- tomatically. Finally, we analyse problems of the approach and propose possible solutions.

Preliminaries
We work with edge-labelled directed graphs and employ the double pushout (dpo) approach to graph transformation. We refer to the standard literature for definitions and discussion, e.g. [7,15]. Here, we just recapitulate the most important concepts that are needed in some more detail later.
Given a set Σ of labels, a Σ-graph is given by G = ⟨VG, EG, srcG, tgtG, labG⟩, where: VG is the set of nodes, EG is the set of edges, src, tgt : EG → VG are resp. the source and target function, and labG : EG → Σ is the labelling func- tion. We restrict our attention to ﬁnite graphs, i.e. we assume that VG and EG are finite sets.
Let a graph morphism be defined as usual. A Σ-production is then a pair of injective graph morphisms L ← K → R, where L is called the left-hand side, R the right-hand side and K the interface of the production. Throughout the paper we assume that each production is discrete (i.e. K contains only nodes)

and edge-consuming (i.e. L contains at least one edge). Graph productions are represented graphically by drawing the left-hand side and the right-hand side in which some nodes are named. The interface can be reconstructed by taking only the named nodes, and the morphisms will be just the identities.
We define a gts to be a set of graph productions, i.e. we do not fix a start graph as usual. Instead, we define termination relative to a set of possible start graphs:
R is terminating on a Σ-graph G, if no infinite reduction sequence from G
exists. In this case, we also say that G is R-terminating.
R is terminating on a set of Σ-graphs L, if it is terminating on each G ∈ L. In this case, we also say that L is R-terminating.
R is terminating, if it is terminating on the set of all Σ-graphs.

Finite graph automata
Regular graph languages
The following notion of a finite graph automaton is a generalization of the notion of finite (string) automaton. If a string is encoded as a graph in the usual way, that is, as a linear graph with the string’s symbols as edge labels, a finite automaton accepts the string if and only if a graph morphism exists from the string into the automaton (taking care that the first symbol of the string is mapped to an edge leaving a start state, and the last symbol to an edge entering an accepting state). This definition can be straightforwardly generalized to graphs in the following way:
Definition 3.1 A finite graph automaton (fga) A is a finite graph. A graph G is accepted by a finite graph automaton A if there exists a morphism f : G → A. The language accepted by a fga A is defined as:
L(A) := {G | ∃f : G → A}
fgas A and B are equivalent if L(A)= L(B).
A set of graphs L is a regular graph language if L = L(A) for some fga A.
We will use fraktur uppercase letters for fgas, while we use ‘normal’ uppercase letters for other graphs.
The class of regular graph languages as defined here is incomparable to the class of graph languages which can be recognized by context free (edge replacement) graph grammars [9]. On the one hand, the language of all graphs over a certain label set is regular because it is accepted by the final graph over

that label set; it is however not context free (cf. Theorems IV.3.3, IV.3.4 and IV.3.6 of [9]). On the other hand, the language of all finite trees is context free but not regular.
The definition of finite graph automaton is similar to the definition of a type graph: a regular graph language is the set of graphs of a specific type. However, where a type graph is usually meant to be a static structure which is set up in advance, our aim is the other way around: given an untyped graph transformation system, we want to generate an automaton which ac- cepts all the reachable graphs. For this reason, we prefer to maintain different terminology.

Minimization of ﬁnite graph automata
Having defined our notion of regular graph language, we investigate minimiza- tion of fgas.
Lemma 3.2 Let two fgas A and B be given. A and B are equivalent if and only if there exists a morphism A → B and a morhpism B → A.
Proof. Directly from the definitions and the fact that the composition of two morphisms is a morphism again.	 
Example 3.3 Consider the following fgas:



A:	•

A
A
B:	•	•
A


In many notions of equivalence of graphs the (nodes of the) above two fgas are considered equivalent because they represent the same (regular) tree; see
e.g. [11]. However, here they are not equivalent because they do not accept the same regular graph language: the A-loop is accepted by A but not by B.
Example 3.4 Consider the following fgas:


1
A: •
A	A	2
	 •
B: •	A	•


A and B are equivalent (accept the same graph language) because there exists a morphism from A to B (so every graph in L(A) is also in L(B)) and also a morphism from B to A (so every graph in L(B) is also in L(A)).

In Example 3.4, the left automaton is clearly more “complex” than the right one: either the left-most or the right-most node of the left graph (marked 1 and 2 in the figure, respectively) is superfluous: for every morphism which maps a node to node 1, there is an alternative morphism which maps the same node to 2. So, node 1 and the edge leading to it could be removed without affecting the accepted graph language. This observation gives rise to the question of whether or not we can find a minimal fga among an equivalence class of fgas. We define a minimal fga to be an fga which does not contain redundancy in the way illustrated above.
Definition 3.5 A fga A is minimal if every morphism f : A → A is an isomorphism, i.e. A has no non-trivial automorphisms.
Definition 3.6 Let a fga over the signature Σ, A = ⟨V, E, src, tgt, lab⟩, and an automorphism f : A → A be given. The lessening of A over f is defined as follows:
lessf (A)= ⟨V ', E', src', tgt', lab'⟩
where:
V ' = V T Rng(f )
E' = E T Rng(f )
src' = src T (V ' × E')
tgt' = tgt T (V ' × E')
lab' = lab T (E' × Σ)
Lemma 3.7 Let A be an fga.
There exists a morphism from A to lessf (A).
There exists a morphism from lessf (A) to A.
L(A)= L(lessf (A)).
A = lessf (A) if and only f is an isomorphism.
Proof. (i) Because the nodes and edges of lessf (A) are exactly the ones which are in the domain of f , f itself functions as a morphism from A to lessf (A).
By construction, lessf (A) is a subgraph of A, and therefore the identity functions as a morphism from lessf (A) to A.
Suppose g : G → A. Then by (i), (g ; f ) : G → lessf (A). Inversely, suppose g : G → lessf (A). Then by (ii), (g ; id): G → A.
Because the domain and range of automorphisms are the same (and finite), surjectiveness coincides with injectiveness and thus with being an iso- morphism. By construction, f is surjective if and only if A = lessf (A). 

In view of the above Lemma, it is easy to construct an equivalent minimal fga from a given one. We now show that every equivalence class of fgas has a unique (up to isomorphism) minimal element:
Lemma 3.8 If M and N are minimal fgas such that L(M) = L(N), then
M and N are isomorphic.
Proof. Since M and N accept the same language, there must be morphisms f : M → N and g : N → M. By definition of minimality, (f ; g) and (g ; f ) are isomorphisms. From this it follows that f and g are isomorphisms as well.	 

Annotating GTSs with creation heights
Our termination method depends on recording creation heights of edges by an- notating the edges of a graph with a natural number representing the creation height. The creation heights of the edges in the source graph of a reduction sequence are initialized to 0, and in each step the creation height of edges in the target of the step is equal to the least creation height of the edges involved in creating it plus one. Thus, the creation height of an edge represents the minimal length of the ‘creation chains’ to that edge. The absence of infinite creation chains is now equivalent to the creation heights in a reduction being bounded by some natural number.
First we define functions which translate annotated and non-annotated graph into each other: liftn(G) annotates each edge of G with the creation height n, while proj(G) removes all annotations from the annotated graph G.
Definition 4.1 Let Σ be a set of labels. We define the maps proj(·) and liftn(·) between Σ-graphs and (Σ × N)-graphs as follows:
Let G be a Σ-graph. We define: liftn(G) := ⟨VG, EG, srcG, tgtG, lab'⟩ where lab'(x) := ⟨lab(x), n⟩.
Let G be a (Σ × N)-graph. We define: proj(G) := ⟨VG, EG, srcG, tgtG, labG ;
π1⟩
where π1 is the projection function: π1(⟨x, y⟩) := x.
Definition 4.2 The set of heights of a (Σ × N)-graph G is defined as:
hts(G) := {n | ⟨l, n⟩ ∈ Rng (labG)}
where for a function f we define Rng (f ) to be the range of f , i.e.: Rng (f ) :=
{b ∈ B | f (a)= b for some a ∈ A}. The set of heights of a reduction sequence of (Σ × N)-graphs ρ = G0 ⇒ G1 ⇒ G2 ⇒ ··· is defined as: hts(ρ) :=
≤i≤|ρ| hts(Gi).

In the following, the set Σ of labels will be fixed. (Σ×N)-graphs will be called annotated graphs. A label ⟨l, n⟩ of an annotated graph will be denoted by ln. The same convention is used for productions, steps, reductions, etc.
Definition 4.3
An annotated graph G٨ is called an annotation of a graph G, if proj(G٨)= 
G. The set of annotations of a graph G is denoted by Ann(G).

An annotated graph production p٨ : L٨ ←l
K٨ →r
R٨ is an annotation of a

production p : L ←l
proj(L٨)= L
K →r
R if

R٨ = liftc(R), where c = min(hts(L∗)) + 1 3 , and
K٨ = K.
(Note that the assumption that all productions are discrete assures that l
and r are morphisms from K٨ to L٨ and from K٨ to R٨, resp.)
The set of annotations of a graph production p is denoted by Ann(p).
If R is a gts, then its annotation RN is defined as: RN =	Ann(p).
Example 4.4 The annotation of the gts It on the left, consists of all rules of the form on the right, where e = min{c, d} + 1.


1
It : •
	A
B
2	1	2
⇒ •	•
A	
B
1
It N: •
Ac

Bd
2	1	2
⇒ •	•
Ae

Be


The creation heights of the right-hand side are all strictly larger than the lowest creation height of the left-hand side.
Note that the annotation RN of a gts R contains infinitely many rules. This is no problem in either theory or practice. Given an annotated graph G٨ and a morphism m from the left-hand side of a (non-annotated) production p : L ← K → R into proj(G٨), we can construct the unique annotated production p٨ : L٨ ← K٨ → R٨ such that m is a morphism of L٨ into G٨. In other words, the technique of this paper can be implemented by creating the needed annotated rules on the fly.
The following proposition follows from the fact that, for each L∗, there is a unique R∗ such that L∗ ← K∗ → R∗ is an annotation.
Proposition 4.5 Let R be a gts and RN its annotation.

3 Alternatively, we could define c = max(hts(L∗)) + 1. In this case, all the results of Sect. 4 would still hold. However, with min we obtain a stronger termination criterion in Sect. 5.

For each R-step G ⇒p,m H and annotated graph G٨ ∈ Ann(G), there exists a unique RN-step G٨ ⇒ps,m H٨ such that p٨ ∈ Ann(p). Moreover, it holds that H٨ ∈ Ann(H).
It follows from Prop. 4.5 that for each reduction sequence ρ = G0 ⇒ G1 ⇒ ··· 

there exists a unique annotated reduction sequence ρ٨ = G٨
⇒ G٨
⇒ ··· 

such that G٨ = lift0(G0) and proj(G٨) = Gi for each Gi in the reduction
sequence. In the following, this reduction sequence will be called the canonical annotation of ρ, and denoted by ρN. In the following, we will use hts(ρ) as a synonym for hts(ρN).
We can now show that a reduction sequence is infinite if and only if there is no bound on its creation heights. The property depends on the assumption that at least one annotation (in particular the minimal one) is replaced by an (arbitrary amount of) strictly bigger annotations, which is assured by the assumptions that interfaces are discrete and each left-hand side contains at least one label.
Theorem 4.6 A reduction sequence ρ is ﬁnite if and only if there is a b ∈ N
such that for every c ∈ hts(ρ) it holds that c < b.
Proof. (⇒) Trivial.
(⇐) Assume that b is the bound on the creation heights of ρ. We associate with each graph in the reduction sequence an array x0,... , xb of natural num- bers, where xc denotes the number of edges in the graph that have annotation
c. These sequences can be ordered lexicographically, yielding a well-founded ordering on such arrays. According to this ordering the graphs strictly de- crease in every step of the sequence, therefore the sequence is finite. 

Proving termination
In this section we describe a method to prove termination of graph rewriting. In particular, we are interested in the question of whether or not a gts is terminating on a regular graph language. However, for ease of presentation, we first consider the weaker question of whether or not an infinite reduction sequence exists from a single graph. It will turn out that the technique devel- oped for graphs is easily extended to regular graph languages.
Termination on a single graph
In order to find out whether or not there is a bound on the creation heights of the graphs reachable from a specific graph, we use the notion of unwinding, which is essentially a simpler form of unfolding [2]: it encodes in an econom-

ical way the graphs which are reachable from a specific graph, so that some properties of the gts (combined with the start graph) can be read from it.
Definition 5.1 Let R be a gts. A graph U is a R-unwinding of a graph G, if there is a morphism h : G → U , and for each production L ← K → R and morphism f : L → U , there exists a morphism g : R → U such that the following diagram commutes:
L  K  R
	
U
Lemma 5.2 Let a gts R and a graph G be given, and let U be a R-unwinding of G. For each graph H such that G ⇒∗ H there exists a morphism eH : H → U.
Proof. By induction on the length of the reduction sequence G ⇒∗ H. If the length of the reduction is 0, then the lemma follows immediately. Otherwise, G ⇒∗ H' ⇒ H, where a production p : L ← K → R is responsible for the last step. By definition of unwinding, there exists a morphism g : R → U , and by the induction hypothesis, there exists a morphism eH' : H' → U , so we have the following situation:
l	r
L  K  R
m	d	(1)	m'
g
H'  D  H
l'	r'
H
eH'	U

The existence of the dashed morphism eH follows from the morphisms (l' ; eH' ) and g, and the fact that the right square (marked (1) above) is a pushout by definition.	 
Corollary 5.3 Let a gts R and a graph G be given. Furthermore, let U ٨ be a RN-unwinding of lift0(G). G is R-terminating if and only if there is a bound on the creation heights of U ٨.
Proof. Suppose there exists an infinite R-reduction sequence from G. Then there exists an infinite RN-reduction sequence from lift0(G) by Prop. 4.5. By

Theorem 4.6, the creation heights in this reduction sequence are unbounded, and therefore by Lemma 5.2 the creation heights of U ٨ are unbounded. 
This provides us with the following systematic method for proving that, given a gts R, no infinite R-reduction sequence exists from a given graph G:
“Construct” the annotation RN of R.
Construct a RN-unwinding U of lift0(G). Constructing an unwinding will be the topic of Sect. 6.
G is R-terminating if and only if there is a bound on the creation heights of U . In practice, we will use the fact that a ﬁnite unwinding always has a bound on the creation heights.
Note that the method is not total (it can’t be, because termination of gtss is non-decidable in general [14]), in particular the second step will loop forever if the gts does not terminate. However, by aborting the algorithm after a predefined number of steps, we do have a correct algorithm for proving termination.
Example 5.4 Consider the one-production gts It from Ex. 4.4 and the fol- lowing graph G:
G:	•  •  •  •
	A	A	A
B
An unwinding of lift0(G) is the following annotated graph:

A2
A1
 •  •	B3



The It -unwinding is finite, and thus the creation heights are bounded, so we conclude that no infinite It -reduction exists from G.
Termination on a regular graph language
Because of the way we have set things up, the results of the previous section are easily generalized from proving termination of a single graph to proving termination of a regular graph language. The following auxiliary result, which follows from the fact that the composition of two morphisms is a morphism again, is responsible for this.

Lemma 5.5 Let R be a gts, A a fga and G ∈ L(A) a graph. Every R- unwinding of A is an R-unwinding of G.
From this lemma and the results of the previous section, the following result can be easily proved:
Lemma 5.6 Let R be a gts, A be a fga and U be a R-unwinding of A. For each G ∈ L(A) and H such that G ⇒∗ H, it holds that there is a morphism f : H → U.
It is easy to see that, for an fga A, we have L(lift0(A)) = {lift0(G) | G ∈
L(A)}, and thus we have the following corollary:
Corollary 5.7 Let a gts R and a fga A be given. Furthermore, let U٨ be a RN-unwinding of lift0(A). L(A) is R-terminating if and only if there is a bound on the creation heights of U٨.
This provides us with the following systematic method for proving that, given a gts R and a fga A, no infinite reduction sequence exists from any member of L(A):
Construct the annotation RN of R.
Construct an RN-unwinding U٨ of lift0(A).
L(A) is R-terminating if and only if there is a bound on the creation heights of U٨.
In the next section we will discuss an algorithm to construct an unwinding of a graph or fga.
Example 5.8 Consider the fga G := G, where G is the graph from Ex. 5.4, and let the gts It from the same example be given. The language L(G) consists of all acyclic graphs with maximal path length 3, and because there is a bound on the creation heights in an unwinding of lift0(G), we conclude that L(G) is It -terminating.
Example 5.9 Let the following gts T r and fga A be given:


 C
T r : 1 •
 B

C
A	•	⇒ 1 •	A	•
2	2
A

A:	•
B	C


Note that L(A) contains all graphs over the signature A, B, C. An unwinding

of lift0(A) is the following:

B0	A
C0	1



Since the creation heights in the unwinding are bounded (because it is finite) we conclude that T r is terminating on the class of all {A, B, C}-graphs.
Note that in Ex. 5.8 and Ex. 5.9, we show termination of an inﬁnite class of graphs, in the second case even of the class of all graphs (over the signature). Many other termination techniques for gtss, on the other hand, focus on proving termination of a single source graph.


Constructing unwindings of graphs
The method described above depends on constructing an unwinding of the initial annotation of a graph. Since this unwinding is necessarily infinite if there is no bound on the creation heights, we cannot hope to find an algorithm which always terminates. However, usually the goal is to prove termination rather than non-termination, and thus a semi-decision procedure is already useful. We analyse the following algorithm:
Algorithm 1
given: a tuple ⟨R, G⟩, where R is a gts and G a graph;
U := G;
do
S := {(L ← K → R) ∈ R | 
there exists a morphism f : L → U,
but there is no morphism R → U such that the following diagram commutes:

l
L
r
K	R
U	};

if S =/
∅ then

(L ← K → R) := an arbitrary element of S ;
Construct the following pushout:

r
K  R
l 
L
f 
U  U '
U := U ';
endif; until S = ∅; output: U;
It is easy to show that if Algorithm 1 terminates on input ⟨R, G⟩, then its output is an R-unwinding of G. For example, the unwindings of Ex. 5.4 and Ex. 5.9 can be found by running the algorithm. However, the algorithm does not always terminate, not even in some cases in which a finite unwinding exists. Consider as a counter-example the following one-production gts Bad and graph G:


1
Bad :	•
	A
B
•
2	1	2
• ⇒ •	•
A	
B

G:	•	A	•

B



The gts Bad is obviously terminating on finite graphs without A-cycles, or even more generally, on graphs without infinite A-paths. However, the fol- lowing is now a run of the algorithm (starting from the initial annotation lift0(G)), which increases the number of A1-edges in every step:





A	•

B0
⇒	•	•
⇒
⇒ ··· 


Note that the bound on the creation heights in graphs of the sequence (except the first) is 2. In the example above, the solution is to include a minimization step in the while-loop. In this case the second graph in the above sequence

would be minimized to:


A1
 •
A0
B0	B1

which is a finite unwinding of the initial annotation of G. However, minimiza- tion will not work in general. Consider the following gts:
2 B 3	2	3 B
 •	•	•  •
A	⇒
• 1	• 1

C0

The following is (the beginning of) an infinite run of the algorithm with min- imization:


B0	B0	B1
•	•	•  •  •
B0	B1	B1
 •  •  •

A0 	⇒ A0	A1
•	•
	
C0	C0
⇒ A0	A1
A

C0


Note that all graphs of the sequence are minimal, but that the highest creation height obtained is 1.

Related Work
As mentioned in the introduction, there exist several other termination results in the area of gtss. Many of the results, however, focus on proving termination from a single source graph, whereas our method proves termination from an infinite class of source graphs.
The most related termination technique is the approximation-based ap- proach by Varro´ et al. [16], in which gtss are approximated by Petri-nets, such that termination of the approximation implies termination of the gts. Both results offer sound, but not complete, termination proving techniques, and both techniques work for proving termination of single source graphs

as well as of infinite sets of source graphs. The approximations technique, however, ignores the structure of the graph, and focusses on the number of occurrences of elements of a certain type. In contrast, our approach can take the structure of the source graph(s) into account.
A more direct comparison of the two methods, for example with case stud- ies, would be interesting, but is outside the scope of this paper.



Conclusion and future work

We describe a method to prove termination of gts. The method works by showing that a reduction does not contain infinite creation chains, or equiv- alently, that the creation heights in a reduction are bounded by a natural number. This is done by encoding the graphs which are reachable from a given regular graph language in a so-called unwinding.
As it stands, the algorithm which constructs the unwinding does not always terminate, not even in the case of some reasobly simple terminating gtss. However, restricting the algorithm to a certain number of steps, does yield an algorithm which either proves termination, or results in an “unkown” answer. Such an algorithm can be useful in praxis.
Also, the method shows termination of inﬁnite classes of graphs. Most other termination results for gtss focus on a single source graph.
For the above reasons, we feel the method is promising to investigate fur- ther. Possible improvements and ideas for further research include:
Obtaining similar results for more expressive classes of graph languages. Regular graph languages are not expressive enough to recognize the class of acyclic finite graphs or even the class of finite trees, while non-cyclicity is can be an important property for proving termination. Combining cre- ation heights with more expressive classes of graph languages may provide stronger results.
Extending the method to gtss with negative application conditions. This is a non-trivial extension because, where the creation heights of edges depend on other edges which are present, negative application conditions typically allow certain transformation steps only in the case that something is not present.
Extending the method also to non-termination proving. It is also inter- esting to see whether conditions can be found on the basis of which non- termination can be concluded.

References
Thomas Arts and Ju¨rgen Giesl.  Termination of term rewriting using dependency pairs.
Theoretical Computer Science, 236(1–2):133–178, 2000.
Paolo Baldan. Modelling Concurrent Computations: From Contextual Petri Nets to Graph Grammars. PhD thesis, Dipartimento di Informatica, Universit`a di Pisa, 2000.
Paolo Bottoni, Kathrin Hoffman, Francesco Parisi Presicce, and Gabriele Taentzer. High- level replacement units and their termination properties. Journal of Visual Languages and Computing, 2005.
Paolo Bottoni, Manuel Koch, Francesco Parisi-Presicce, and Gabriele Taentzer. Termination of high-level replacement units with application to model transformation. ENTCS, 127, 2005.
H. J. Sander Bruggink. A proof of finite family developments for higher-order rewriting using a prefix property. In Proceedings of RTA ’06. Springer, 2006.
Hartmut Ehrig, Karsten Ehrig, Juan de Lara, Gabriele Taentzer, D´aniel Varro´, and Szilvia Varro´-Gyapay. Termination criteria for model transformation. In Proceedings of FASE ’05. Springer, 2005.
Hartmut Ehrig, Michael Pfender, and Hans Ju¨rgen Schneider. Graph-grammars: An algebraic approach. In FOCS, 1973.
Alfons Geser, Dieter Hofbauer, and Johannes Waldmann. Match-bounded string rewriting.
Applicable Algebra in Engineering, Communication and Computing, 15(3–4):149–171, 2004.
Annegret Habel. Hyperedge Replacement: Grammars and Languages. Springer, 1992.
Tiham´er Levendovszky, Ulrike Prange, and Hartmut Ehrig. Termination criteria for DPO transformations with injective matches. In Proceedings of the GT-VC workshop at CONCUR ’06. Elsevier, 2007. To appear.
Laurent Mauborgne. An incremental unique representation for regular tree. Nordic Journal of Computing, 7(4):290–311, 2000.
Vincent van Oostrom. Finite family developments. In Proceedings of RTA ’97. Springer, 1997.
Detlef Plump.	Term graph rewriting.	In H. Ehrig, G. Engels, H.-J. Kreowski, and
G. Rozenberg, editors, Handbook of Graph Grammars II. World Scientific, 1997.
Detlef Plump. Termination of graph rewriting is undecidable. Fundementa Informaticae, 33(2):201–209, 1998.
Grzegorz Rozenberg, editor. Handbook of Graph Grammars. World Scientific, 1997.
D´aniel Varro´, Szilvia Varr´o-Gyapay, Hartmut Ehrig, Ulrike Prange, and Gabriele Taentzer. Termination analysis of model transformations by Petri Nets. In Proceedings of ICGT ’06. Springer, 2006.
