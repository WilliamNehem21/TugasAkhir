

Electronic Notes in Theoretical Computer Science 246 (2009) 199–214
www.elsevier.com/locate/entcs

Transforming SAT into Termination of Rewriting 1
Harald Zankl2 Christian Sternagel3 Aart Middeldorp4
Institute of Computer Science University of Innsbruck Innsbruck, Austria

Abstract
In this paper we propose different translations from SAT to termination of term rewriting, i.e., we translate a propositional formula ϕ into a generic rewrite system Rϕ with the property that ϕ is satisfiable if and only if Rϕ is (non)terminating. Our experiments reveal that the generated rewrite systems are challenging for automated termination provers. Furthermore, a large class of them seems to be just unprovable by current methods implemented in termination analyzers.
Keywords: term rewriting, termination, semantic labeling, SAT solving


Introduction
Termination of term rewrite systems (TRSs) is an undecidable property [12]. Never- theless, nowadays powerful (incomplete) algorithms exist that can prove termination of many rewrite systems as can be witnessed by the international termination com- petition. 5 In 2004 Kurihara and Kondo were the first who encoded a termination method in propositional logic [19] and in 2006 the first tools (Jambox 6 and Match- box [21]) employed SAT-solving techniques in the competition. They surprised the community by the gains in power and speed. Their success was mainly due to the so-called matrix-method [8] which can effectively be implemented using SAT- solvers. But even for very simple and ancient methods like the lexicographic path order [13,6] (LPO) the recent development in the SAT community allows way faster

1 This research is supported by FWF (Austrian Science Fund) project P18763.
2 Email: harald.zankl@uibk.ac.at
3 Email: christian.sternagel@uibk.ac.at
4 Email: aart.middeldorp@uibk.ac.at
5 http://www.lri.fr/~marche/termination-competition/
6 Available from http://joerg.endrullis.de.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.023

implementations [4] than some years ago. A similar speedup [22] is achieved for the Knuth-Bendix order (KBO) [14]. This is remarkable because KBO orientability is known to be decidable in polynomial time [18] whereas SAT is NP-complete [5]. In other words, the sophisticated algorithms for solving the computationally harder (unless P = NP) problem SAT outperform the dedicated methods for KBO [7,18]. In this paper we address the question whether a similar result also holds when translating the NP-complete SAT problem into the undecidable termination prop- erty of TRSs. However, the experiments reveal that at least for our translations the results are as expected. Concerning the transformation from SAT to termina- tion, the dedicated SAT approaches perform much better. Even further, only the most simple propositional formulas produce TRSs which can be shown terminating by state-of-the-art termination provers. Therefore the translations can be used to generate a large set of difficult termination problems automatically.
The rest of the paper is organized as follows: In Section 2 propositional formulas are introduced and many-sorted rewriting is defined. In Section 3 we define TRSs U ϕ that are terminating if and only if the propositional formula ϕ is unsatisfiable. In Section 4 the dual problem is considered for many-sorted TRSs Sϕ and T ϕ that are terminating if and only if ϕ is satisfiable. That even simple propositional formulas produce TRSs where termination analysis is challenging is demonstrated in Section 5 where it also becomes apparent that narrowing [10] is one method which can handle small instances. We conclude in Section 6.


Preliminaries
In this section we fix basic notation concerning propositional logic, introduce many- sorted TRSs and define the model variant of semantic labeling [24] in a many-sorted setting. Aoto and Yamada [1] already generalized semantic labeling to many-sorted rewriting but just for the quasi-model case.


Propositional Logic
Let A be a set of propositional variables (atoms). Sometimes we find it convenient to abbreviate the set of atoms p1,..., pn by An. The set of propositional formulas P(A) is inductively defined by the following BNF

ϕ ::= p ∈A| (ϕ ∧ ϕ) | (¬ϕ)

Note that we do not allow disjunction (which does not pose a restriction but al- lows to keep the presentation concise). The following convention is used to reduce the number of parentheses: (i) Outermost parenthesis are omitted, (ii) ‘∧’ is left- associative, and (iii) ‘¬’ binds stronger than ‘∧’.
Let B := {0, 1}.  An assignment is a mapping α : A → B.  It is lifted to an

interpretation of formulas: [α]: P(A) → B with
⎧⎪⎨α(p)	if ϕ = p for some p ∈A 
⎪[α](ψ)	if ϕ = ¬ψ

Here (·): B×B → B is defined as x · y = 1 if and only if x = y = 1 and for (∗): B → B we have x = 1 if and only if x = 0. A formula ϕ is satisﬁable (unsatisﬁable) if an (no) assignment α exists such that [α](ϕ) = 1. This problem is known as the satisfiability problem (SAT). For a propositional formula ϕ its depth is defined as follows: depth(p) = 0 for p ∈ A, depth(ϕ ∧ ψ) = 1 + max(depth(ϕ), depth(ψ)), and depth(¬ϕ) = 1+depth(ϕ). Similarly the set of variables Var(ϕ) is defined recursively by: Var(p) = {p} for p ∈ A, Var(ϕ ∧ ψ) = Var(ϕ) ∪ Var(ψ), and Var(¬ϕ) = Var(ϕ). The well-known coincidence lemma states that when testing ϕ for satisfiability only the (finitely many) variables that actually occur in ϕ have to be considered which makes SAT decidable because the search space becomes finite. Furthermore, this allows us to relate assignments to substitutions (whose domain must be finite by definition) in the next section. Despite the fact that the search space for a satisfying assignment is finite, deciding SAT is difficult, more precisely, SAT is an NP-complete problem [5].

Many-Sorted Semantic Labeling
We assume basic familiarity with term rewriting [3]. Let S be a non-empty set of sorts. An S-sorted signature is a set of function symbols F, where each f ∈ F of arity n is associated with the function signature sig : F → Sn+1. Here the first n components of sig(f ) give the sort (type) of each argument and the last gives the sort of the function’s result. In the following, we write f : s1 ×· · · × sn → sn+1, to express that f has (function) signature (s1,..., sn+1).
An S-sorted set A is a family of sets {As}s∈S . For an S-sorted set V of variables (where Vs ∩ Vt = ∅ for s /= t), let T (F, V)s denote the set of terms with sort s over F and V, which is defined inductively by the rules

x ∈ Vs
x
f ∈F	f : s1 ×· · · × sn → s	ti ∈T (F, V)si

f (t1,..., tn)

This yields the S-sorted set T (F, V) = {T (F, V)s}s∈S .  Associated with every term t ∈ T (F, V) is its sort, i.e., if t ∈ T (F, V)s then sort(t) = s. An S-sorted TRS R is an S-sorted set of pairs (l, r) ∈ Rs—the so called rewrite rules—written as l → r, such that there exists an s ∈ S with l, r ∈ T (F, V)s and the usual restrictions that l is not a variable and all variables in r also occur in l are satisfied. In the sequel we identify one-sorted TRSs with unsorted ones and feel free to omit sort information where it is not essential.
Let F be an S-sorted signature. An S-sorted F-algebra A consists of an S-sorted
carrier A (where each As ∈ A is non-empty) and a set of interpretations {fA}f∈F ,

such that for each function symbol f : s1 ×··· ×sn → sn+1 there is an interpretation fA : As1 ×· · · × Asn → Asn+1 . An S-sorted substitution σ : V → T (F, V) is a set of mappings σs : Vs → T (F, V)s for every s ∈ S such that σ(x) /= x only for finitely many x ∈ V. An S-sorted assignment α : V → A is a set of mappings αs : Vs → As for every s ∈ S. For every S-sorted term t and assignment α : V → A, a mapping [α]A : T (F, V) → A is defined inductively



[α]A
(t) =	αs(x)	if t = x and sort(t) = s fA([α]A(t1),..., [α]A(tn))	if t = f (t1,..., tn)

An S-sorted F-algebra is a model of an S-sorted TRS, if for all S-sorted assign- ments α and rewrite rules l → r ∈R it holds that [α]A(l) = [α]A(r). A labeling L chooses for every f ∈F a set of labels Lf . The labeled signature is defined by
Flab = {f | f ∈ F, Lf = ∅}∪ {fa | f ∈ F,a ∈ Lf }
where the arity and function signature of fa and f coincide. A labeling l for an S- sorted algebra A consists of a labeling L together with a labeling function lf : As1 ×
··· × Asn → Lf for every f ∈ F with Lf /= ∅ and sig(f ) = s1 ×· · ·× sn → sn+1.
Let AV denote the set of all S-sorted assignments from V to A. Let l be a labeling for A.  For every assignment α ∈ AV a mapping labα : T (F, V) → T (Flab, V) is defined inductively as follows
⎧⎪⎨x	if t = x
 
fa(labα(t1),..., labα(tn))	if t = f (t1,..., tn) and Lf /= ∅
with a = lf ([α]A(t1),..., [α]A(tn)). For any S-sorted TRS R over F, together with an F-algebra A and a labeling l, the S-sorted TRS Rlab over Flab is given by
Rlab = {labα(l) → labα(r) | l → r ∈ R,α ∈ AV }
An S-sorted TRS R is terminating if it does not admit an infinite rewrite se- quence t1 →R t2 →R ... starting at some t1 ∈T (F, V)s for some s ∈ S.
Theorem 2.1 Let R be an S-sorted TRS. Let the algebra A be a model of R and let l be a labeling for A. Then R is terminating if and only if Rlab is terminating.
For the TRSs we are dealing with in the subsequent sections, many-sorted termi- nation is equivalent to the one-sorted case [23] since the systems are non-collapsing. A TRS is collapsing if it contains a rule l → x for some variable x. Restricting to many-sortedness simplifies the proofs of Theorems 4.2 and 4.6 considerably.
Transforming Unsatisfiability to Termination
In the following we want to express SAT as a termination problem in rewriting, i.e., given a formula ϕ, we construct a TRS Rϕ that is terminating if and only if ϕ is

satisfiable. This transformation is addressed in the next section. First we focus on the simpler dual problem, namely the construction of a TRS Yϕ that is terminating if and only if ϕ is unsatisfiable.
For this purpose we consider a {bool}-sorted signature J = { ,—} containing a binary function symbol ( ) : bool × bool → bool and a unary function symbol
— : bool → bool. Furthermore we assume that the propositional atoms in A are contained in the set of term variables Vbool.  Although ‘ ’ will represent (on the
term level) the same as ‘Λ’ does on formulas, we use different function symbols because we want to clearly separate between the two different concepts. The same holds for the symbols ‘—’ and ‘ч’. The obvious encoding ∗’ : У(A) →7 ({ ,—}, V) transforms formulas into terms as follows: p’ = p for p ∈ A, ϕ Λ ψ’ = ϕ’  ψ’, and чϕ’ = — ϕ’. Now every well-formed formula in У(A) has a corresponding term representation in 7 (J, V).
The next goal is to mimic the task of assignments for formulas on the term level. Thus the signature J is extended by two constant symbols of sort bool, namely ‘⊥’ and ‘T’. We say that an assignment α : An → B and a substitution σ : Vn → {⊥, T} are corresponding if α(pi) = 0 if and only if σ(pi) = ⊥ for all 1 ≤ i ≤ n (here Vn = An).
In order to perform the work [α] does on formulas the six rewrite rules

⊥  ⊥→⊥  ⊥  T→⊥  T  ⊥→⊥  T  T→T  — ⊥→T  — T →⊥ 
referred to as the TRS £imp are employed. The next lemma formalizes the interplay of assignments and substitutions.
Lemma 3.1 Let ϕ ∈ У(An) and t ∈7 (J, V) such that ϕ’ = t. If the assignment
α and the substitution σ are corresponding, then

[α](ϕ) = 0 implies tσ →∗
[α](ϕ) = 1 implies tσ →∗
⊥ and dually
T

Proof By induction on the structure of ϕ.	 
The following example already contains the main idea for constructing nonter- minating sequences.
Example 3.2 Consider the formula ϕ = p1 Λ чp2 with the corresponding term
t = ϕ’ = p1  (— p2). Then the TRS £imp together with the rewriting rule
unsat(p1, p2, T) → unsat(p1, p2, p1  (— p2)) admits the cyclic reduction
unsat(T, ⊥, T) → unsat(T, ⊥, T  (— ⊥)) → unsat(T, ⊥, T  T) → unsat(T, ⊥, T)

which proves nontermination of this TRS. The reason for nontermination is that for a satisfying assignment α (in this case α(p1) = 1 and α(p2) = 0) there is


⊥B = 0	TB = 1 
 B(x, y) = x · y	—B(x) = x
unsatB(p1,..., pn, y) = 0 

Table 1
A model for the TRS Uϕ.
a corresponding substitution σ such that the term ϕ’σ = tσ rewrites to T by Lemma 3.1.
The next theorem formally establishes the relation between satisfiable formulas and nontermination of corresponding TRSs.
Theorem 3.3 Let ϕ ∈ У(An). The parametrized TRS C ϕ that consists of all rules in £imp and
unsat(p1,..., pn, T) → unsat(p1,..., pn, ϕ’)	(1)
is terminating if and only if ϕ is unsatisﬁable.
Proof For the direction from left to right assume C ϕ to be terminating and ϕ to be satisfiable to arrive at a contradiction. Since ϕ is satisfiable there must be a satisfying assignment α and a corresponding substitution σ. But then there is the cyclic reduction
t = unsat(σ(p1),..., σ(pn), T) → unsat(σ(p1),..., σ(pn), ϕ’σ) →∗ t

where the first rewrite step is an application of rule (1) and the rest of the sequence
holds by Lemma 3.1 since ϕ’σ →∗	T. Contradiction.
For the direction from right to left we assume unsatisfiability of ϕ and show termination of C ϕ. For this purpose we apply semantic labeling. Note that we consider C ϕ as one-sorted. The idea is to label the symbol unsat by the value which ϕ evaluates to—under all possible assignments. To obtain a model, the function symbols are interpreted in the Boolean algebra. The interpretation У over the carrier B depicted in Table 1 is a model for C ϕ. Next the labeling for C ϕ is defined. For this purpose only the function symbol unsat gets labeled, i.e., L٨ = L− = ∅ 7 and Lunsat = B. The labeling function lunsat : Bn+1 → B is defined as: lunsat(p1,..., pn, y) = y. By assumption the formula ϕ evaluates to 0 under all assignments. Hence the labeled variant of rule (1) looks like
unsat1(p1,..., pn, T) → unsat0(p1,..., pn, ϕ’)	(2)

Termination of the labeled system can then easily be shown by some basic method, e.g., LPO; choosing the precedence unsat1 > unsat0, , — allows to orient rule (2)
from left to right and — > ⊥, T handles the rules in £imp. So C ϕ is terminating.
Theorem 2.1 yields the termination of C ϕ.	 

7 Labeling constants is superfluous and hence we implicitly set L⊥ = LT = ∅.

Transforming Satisfiability to Termination
In the previous section the task was somehow simpler since there it sufficed to construct a nonterminating sequence if there exists a satisfying assignment. Hence by guessing a satisfying assignment for ϕ one could construct an infinite sequence in the TRS C ϕ. In this section the endeavor is more challenging, because one has to guarantee that one cycles if no satisfying assignment exists. Hence, the parametrized TRS will have to test all assignments before entering a loop if none of them satisfied the formula ϕ. Thus we have to provide the possibility to generate all assignments successively. The following three rules, referred to as Uext do this job by representing assignments as bitlists (consequently the signature J is extended by the binary function symbol (::) : bool × list → list, the constant nil : list, and the unary function symbol next : list → list):

next(nil) → nil next(⊥ :: xs) →T :: xs
next(T :: xs) →⊥ :: next(xs)

To ease notation we will encode lists over ⊥ and T as natural numbers. There- fore, lists are interpreted as little endian representation of binary numbers where
⊥ corresponds to 0 and T to 1. Let G be the signature {⊥, T, ::, nil}. The map-
ping enc: 7 (G) → N × N, enc(nil) = (0, 0) and enc(x :: xs) = (x + 2i, l + 1) where enc(xs) = (i, l), uniquely associates lists with entries ⊥ or T to pairs. The first component of the pair is the little endian representation of the bitlist whereas the second component is the length of the list. For convenience we denote (i, l) by il.
Furthermore if l is irrelevant or fixed we feel free to omit it. Taking the above conventions into account the bitlist [T; ⊥; T; T] 8 can be written as 134 or more sloppily as 13. But we do not only identify these bitlists with natural numbers, they also encode substitutions. Hence, a bitlist [t1; ... ; tn] gives rise to a substitu- tion σ with σ(pi) = ti for 1 ≤ i ≤ n. Using this convention a term t indexed with a bold face integer denotes the result of applying the substitution to the term, i.e., (p1 ((— p2) p3))13 denotes T ((— ⊥) T).
Lemma 4.1 For a bitlist t, next(t) rewrites to the successor of t:
If enc(t) = il then next(t) →∗	t' with enc(t') = (i + 1 mod 2l)l.
Proof By induction on the structure of t and unfolding the definition of il.	 
To proceed we explicitly state the function signature sig, i.e., the sort for each function symbol, in the left column of Table 2. In the theorem below the variables p1,..., pn are of sort bool and xs is of sort list.


8 To ease readability, lists x :: (y :: (z :: nil)) are abbreviated by [x; y; z].


⊥ : bool	⊥A = 0 
T : bool	TA = 1 
  : bool × bool → bool	 A(x, y) = x · y
— : bool → bool	—A(x) = x
nil : list	nilA = (0, 0)
:: : bool × list → list	::A(x, (i, l)) = (x + 2i, l + 1)
next : list → list	nextA((i, l)) = (i +1 mod 2l, l)
sat : list × bool → bool	satA((i, l), b) = 0 

Table 2
A model for the {bool, list}-sorted TRS Sϕ.

Theorem 4.2 Let ϕ ∈ У(An). Then the parametrized {bool, list}-sorted TRS £ϕ
that contains all rules of £imp, Uext, and additionally
sat([p1; ... ; pn], ⊥) → sat(next([p1; ... ; pn]), ϕ’)	(3)
is terminating if and only if the formula ϕ is satisﬁable.
Proof For the direction from left to right assume for the sake of a contradiction unsatisfiability of ϕ. The cyclic reduction
sat(0, ⊥) →
sat(next(0), ϕ’0) →∗ sat(1, ϕ’0) →∗ sat(1, ⊥) →∗ ··· →∗
sat(next(2n — 1), ϕ’2n−1) →∗ sat(0, ϕ’2n−1) →∗ sat(0, ⊥)
proves nontermination of £ϕ where next(in) →∗	(i + 1 mod 2n)n follows from

Lemma 4.1 and since we assumed that ϕ is unsatisfiable ϕ’in
Lemma 3.1, for all 0 ≤ i < 2n.
∗
Simp
⊥ by

For the direction from right to left we will again give a proof using semantic labeling. The difference this time is that we exploit the many-sorted version of semantic labeling. Now for every sort s ∈ {bool, list} we have to specify a carrier. The choices are Abool = B and Alist = P := {(i, l) ∈ N × N | i < 2l}. Then the interpretation in the right column of Table 2 is a model for £ϕ. We show this for the Uext-rules. Let us fix an arbitrary value (i, l) ∈ P for xs. The three Uext-rules generate the three equalities
(0+1 mod 20, 0) = (0, 0)	(4)
((0+ 2i)+1 mod 2l+1,l + 1) = (1+ 2i, l + 1)	(5) ((1+ 2i)+1 mod 2l+1,l + 1) = (0+ 2(i +1 mod 2l),l + 1)	 (6)
Equation (4) is trivially valid. Since i < 2l by definition of P equation (5) holds since the modulo operation can be omitted.  Validity of equation (6) is shown

by case distinction. For i = 2l — 1 it simplifies to 1 + 2(2l — 1) + 1 mod 2l+1 = 0 + 2(2l — 1+1 mod 2l) where both sides equal 0. For the other case we know that i < 2l — 1 and consequently 2i + 2 < 2l+1. Hence, the modulo operation does no harm and both sides evaluate to the same value.
The following sets of labels are employed: L٨ = L− = L:: = Lnext = ∅ and Lsat = N × B. Then, the labeling function lsat : P × N → N × B with lsat((i, l), b) = (i, b) is used which produces the following labeled variants of rule (3)
sati,0([p1; ... ; pn], ⊥) → sat(i+1 mod 2n),ϕi (next([p1; ... ; pn]), ϕ’)	(7) where 0 ≤ i < 2n. In the right-hand side of the generic rule (7) the expression ϕi
n
means that ϕ is evaluated by the assignment corresponding to the bitlist in.
If for at least one assignment ϕ evaluates to 1 then the system can be proved terminating. Assume that the j-th assignment satisfies ϕ. Then the precedence
sat(j+1),0 > sat(j+2),0 > ··· > sat(2n−1),0 > sat0,0 > sat1,0 > ··· > satj,0 sati,0 > sat(i+1 mod 2n),1	(0 ≤ i < 2n)
satj,0 > next, , — > ⊥, T

is well-founded and allows LPO to orient all rules of the labeled TRS £ϕ  from left
to right. Termination of £ϕ follows from Theorem 2.1.	 
As an example consider the transformation of the formula p1 Λ чp2 below.
Example 4.3 The system £p1∧¬p2 gives rise to the labeled rules
sat0,0([p1; p2], ⊥) → sat1,0(next([p1; p2]), p1  (— p2))
sat1,0([p1; p2], ⊥) → sat2,1(next([p1; p2]), p1  (— p2))
sat2,0([p1; p2], ⊥) → sat3,0(next([p1; p2]), p1  (— p2))
sat3,0([p1; p2], ⊥) → sat0,0(next([p1; p2]), p1  (— p2))
Note that because in the second line the term (p1 (— p2))1 is interpreted as 1 and hence the system can easily be proved terminating by LPO with the precedence
sat2,0 > sat3,0 > sat0,0 > sat1,0 > sat2,1, next, , —	— > ⊥, T
In this translation the TRS Sϕ gets exponentially larger (in the number of variables
in ϕ) than the original unlabeled system. More precisely, rule (3) gives rise to 2n different labeled variants due to the n Boolean variables in the list [p1; ... ; pn]. But the resulting TRS is still finite, in contrast to the one from the next subsection.

An Alternative Transformation
In the transformation £ϕ the formula ϕ gets assigned the values implicitly by pattern matching because the same variables p1,..., pn are used in the formula and in the assignment.  One not so nice side-effect is that in rule (3) the list of variables

occurring in ϕ must be specified as the first argument to sat. Here we present a different translation where the variables p1,..., pn are considered as constants v1,..., vn in the signature J. For terms that represent formulas on the syntactic level, the sort formula is used, i.e., vi : formula for 1 ≤ i ≤ n. Furthermore a close inspection of the systems C ϕ and £ϕ reveals that there is no clear separation between syntax and semantics when formulas are represented as terms. To differentiate these two concepts we employ different function symbols for the two layers. Once more the signature J is augmented by a binary function symbol and : formula×formula → formula and a unary function symbol not : formula → formula. Consequently also the encoding ∗’ must now map formulas to their syntactic representation on the term level. Hence the function ∗’ is redefined accordingly, i.e., ∗’ : У(An) → 7 ({v1,..., vn, and, not}) with pi’ = vi for 1 ≤ i ≤ n, ϕ Λ ψ’ = and( ϕ’, ψ’), and
 чϕ’ = not( ϕ’). Thus, for the formula p1 Λ чp2 the (syntactic) term representation
 ϕ’ is and(v1, not(v2)).
In the TRS £ϕ the assignment was applied automatically by pattern matching of the variables. Now we employ separate rewrite rules that perform that step. Note that these rules at the same time execute the transformation from the syntactic to the semantic level. The TRS Assign
assign(xs, and(x, y)) → assign(xs, x)  assign(xs, y)
assign(xs, not(x)) → — assign(xs, x)
assign(xs, vi) → nth(xs, si(0))	1 ≤ i ≤ n
nth(⊥ :: xs, 0) →⊥ 
nth(T :: xs, 0) →T 
nth(b :: xs, s(j)) → nth(xs, j)
performs the task of [α] on the term representation of propositional formulas. The way how assignments were generated in the previous subsection is no longer suitable. There all variables occurring in ϕ had to be specified in sat’s first argument. Since we want to get rid of that requirement the idea is to start with an empty assignment (empty list) and increase its length repeatedly. Hence in this section the assignments are no longer computed modulo some length but the overflow is simply taken into account by increasing the length of the list. The three rules below are referred to as the TRS Uext2:
next(nil) →T :: nil next(⊥ :: xs) →T :: xs
next(T :: xs) →⊥ :: next(xs)
Similar to before a more readable notation for bitlists is employed, i.e., they are identified with natural numbers as follows: enc: 7 (G) → N with enc(nil) = enc(⊥) = 0, enc(T) = 1, and enc(x :: xs) = enc(x)+2 enc(xs). This encoding is not injective because the lists [T; ⊥; ⊥] and [T] are both denoted by 1. In our setting these (more or less) leading zeros do not pose a problem.


⊥ : bool	TA = 1 
T : bool	⊥A = 0 
  : bool × bool → bool	 A(x, y) = x · y
— : bool → bool	—A(x) = x
nil : list	nilA = 0 
:: : bool × list → list	::A(x, i)) = x + 2i
next : list → list	nextA(i) = i +1 
vi : formula	1 ≤ i ≤ n			viA = pi and : formula × formula → formula	andA(x, y) = x Λ y not : formula → formula		notA(x) = чx
0 : nat	0A = 0 
s : nat → nat	sA(x) = x +1 
assign : list × formula → bool	assignA(i, ϕ) = [αi](ϕ)
nth : list × nat → bool	nthA(i, j) = αi(pj)
sat : list × bool → bool	satA(i, b) = 0 

Table 3
A model for the {bool, formula, list, nat}-sorted TRS T ϕ.

Lemma 4.4 For a bitlist t, next(t) rewrites to the successor of t:
If enc(t) = i then next(t) →∗	t' with enc(t') = i + 1.
Proof By induction on the structure of t and unfolding the definition of i.	 
The desired property that the rules in Assign evaluate the term representation
 ϕ’ for a given bitlist i is formalized in the lemma below.
Lemma 4.5 Let ϕ ∈ У(An) and let i be the encoding of an assignment α with
[α](ϕ) = 0. Then assign(i, ϕ’) →∗	⊥.
Proof By induction on the structure of ϕ’ and unfolding the definition of i.	 
Now, we will establish a theorem similar to Theorem 4.2. Again, we prove the theorem in a many-sorted setting. The full information is depicted in Table 3. The variables in the TRS are associated to sorts as follows: b ∈ Vbool, xs ∈ Vlist, j ∈ Vnat, and x, y ∈ Vformula.
Theorem 4.6 Let ϕ ∈ У(An). Then the parametrized {bool, formula, list, nat}- sorted TRS 7 ϕ consisting of the £imp-, Uext2-, and Assign-rules plus additionally
sat(xs, ⊥) → sat(next(xs), assign(xs, ϕ’))	(8)
is terminating if and only if ϕ is satisﬁable.

Proof Concerning the direction from left to right one can again construct a non- terminating reduction for any unsatisfiable formula ϕ. In order not to get stuck while evaluating assign(i, ϕ’) a sufficiently large i is taken (e.g., i = 2n+1). Then there is the infinite sequence
sat(i, ⊥) → sat(next(i), assign(i, ϕ’)) →∗
sat(i + 1, ⊥) → sat(next(i + 1), assign(i + 1, ϕ’)) →∗
sat(i + 2, ⊥) → sat(next(i + 2), assign(i + 2, ϕ’)) →∗ ··· 
where the →-steps are applications of rule 8 and the →∗-steps can be performed because of Lemmata 4.4 and 4.5.
For the direction from right to left once more a semantic labeling approach is followed. The interpretation given in Table 3 models the {bool, formula, list, nat}- sorted TRS 7 ϕ. What remains to be defined is an enumeration αi of assignments as follows: αi(pj) = f j(i) mod 2 with f 0(i) = i and f j+1(i) = f j([i÷ 2|). Checking that A models 7 ϕ is straightforward.
Again, only the function symbol sat is labeled. Note that the labeled TRS T ϕ is infinite since all possible instances of bitlists are considered (compared to finitely many bitlists of a specified length in the previous subsection). The labeling function lsat(i, b) = (i, b) gives rise to infinitely many rules of the following shape
sati,0(xs, ⊥) → sat(i+1),[αi](ϕ)(next(xs), assign(xs,  ϕ’))
Similar to before a precedence of the shape sati,0 > sat(i+1),0 if [αi](ϕ) = 0 and sati,0 > sat(i+1),1 if [αi](ϕ) = 1 for all i ≥ 0 is needed which in general might not be well-founded since it can contain the infinite sequence
sat0,0 > sat1,0 > sat2,0 > . . .
but due to the assumption that ϕ is satisfiable, not all of these precedence com- parisons are necessary. If [αj](ϕ) = 1 then there is no labeled rule which demands satj,0 > sat(j+1),0. Without loss of generality we can assume 0 ≤ j < 2n. Due to
the construction of αj also αj+2n , αj+2n+1 , ... satisfy ϕ and hence removing all superfluous comparisons sat(j+2n+m),0 > sat(j+2n+m+1),0 for all m ∈ N produces a
well-founded precedence (because for any i ∈ N one can find a k ∈ N such that
i ≤ j + 2n+k). It follows that 7 ϕ is terminating. The termination of 7 ϕ follows
from Theorem 2.1.	 
Although the transformations £ϕ and 7 ϕ look very similar at first, they are quite different. Concerning the number of rewrite rules, £ϕ does not depend on ϕ whereas 7 ϕ depends linearly on the number of variables in ϕ. On the other hand, the list of variables p1,..., pn must be given as an argument to sat in £ϕ. In Section 5 it becomes apparent that proving (non)termination automatically is much more challenging for 7 ϕ than for £ϕ. The main reason is that by separating syntax from semantics, there is less structure that can be exploited by termination tools. The nontermination proofs become more challenging because for £ϕ an infinite rewrite


2 variables, depth 3	3 variables, depth 4	4 variables, depth 5


Table 4 Experimental Results.

sequence can be captured by considering cyclic reductions of ground terms, i.e., t →+ t for a ground term t (cf. the proof of Theorem 4.2). In contrast 7 ϕ really demands looping reductions, i.e., t →+ C[tσ] where the context C is empty but t may no longer be ground since the lengths of the bitlists are increased.

Evaluation
For experimental results 9 we considered all automated (non)termination analyzers that participated in the 2007 edition of the international termination competition for term rewrite systems augmented with TPA [15], a tool with strong support for termination proofs via semantic labeling. To our knowledge none of these tools supports analysis of sorted TRSs. Consequently we provide our examples unsorted. As already stated in the beginning, dropping sorts does not affect termination of the TRSs we propose. Furthermore we stress that the proofs of Theorems 4.2 and 4.6 can be modified to work on unsorted TRSs. For the TRS £ϕ this means that the interpretations range over the set of pairs P whereas the proof of Theorem 4.6 can be generalized to one sort by using the natural numbers as a carrier and representing formulas via a Go¨del encoding [11].
It turned out that even for rather small formulas (some of) our transformations produce rewrite systems whose termination analysis is challenging. We considered 100 randomly generated formulas of different shapes. Table 4 summarizes the re- sults, e.g., formulas of depth three using two different propositional variables are considered in the leftmost block, etc. Every tool was run on all TRSs resulting from transforming the formula ϕ to £ϕ, 7 ϕ, and C ϕ for at most 60 seconds to analyze termination (T) or nontermination (N) of each system. Globally speaking, for TRSs originating from very small formulas AProVE [9] performs best. This is due to its support for narrowing which allows to exploit the structure of £ϕ and C ϕ. Jambox solves some instances by semantic labeling over Boolean models (which is very close to the way how we proved termination) and by the matrix method.  The latter

9 Further details to be found at http://colo6-c703.uibk.ac.at/ttt2/hz/sat2trs/.

systems could also be handled by TTT2. 10 NTI [20] supports only nontermination analysis, using an unfolding operator. Semantic labeling based on Boolean models and (quasi-)models over the naturals is implemented in TPA [17,16] which usually
performs very well on standard examples. The experiments reveal that the latter is not powerful for the systems obtained from the transformations proposed in this paper.
But narrowing is expensive which can be seen by comparing the different blocks of Table 4. AProVE can handle all TRSs resulting from the £ϕ translation if formulas
are of depth three but for depth four (five) the performance decreases to 34% (14%). For the other translations the effect is not so tremendous, well, for 7 ϕ the surprising outcome is that no tool could handle any system at all and the systems in C ϕ are generally a bit easier since they do not iterate over the assignments. Needless to say, the formulas ϕ which are considered for our experiments are a very trivial task for any SAT-solver.
We conclude this section by a sketch of how AProVE solves many instances by considering the TRS Sϕ for ϕ = p1 Λ p2. After some preliminary analysis based on dependency pairs [2], AProVE concludes that any infinite sequence applies the rule
sat([p1; p2], ⊥) → sat(next([p1; p2]), p1  p2)

indefinitely. Narrowing the above rule at position 1 allows to replace it by the two rules
sat([⊥; p2], ⊥) → sat(next([⊥; p2]), ⊥  p2)
sat([T; p2], ⊥) → sat(next([T; p2]), T p2) and narrowing these rules at position 1 gives
sat([⊥; ⊥], ⊥) → sat(next([⊥; ⊥]), ⊥  ⊥)
sat([⊥; T], ⊥) → sat(next([⊥; T]), ⊥  T)
sat([T; ⊥], ⊥) → sat(next([T; ⊥]), T  ⊥)
sat([T; T], ⊥) → sat(next([T; T]), T T)

After this state is reached the right-hand sides can be rewritten [10] using the
£imp and Uext rules which allows the dependency graph processor [2] to conclude termination.

Conclusion
In this paper we proposed three different transformations from propositional for- mulas ϕ to confluent—since orthogonal—term rewrite systems £ϕ, 7 ϕ, and C ϕ such that ϕ is satisfiable (unsatisfiable) if and only if £ϕ, 7 ϕ (C ϕ) is terminating. Although the systems can be proved (non)terminating by semantic labeling using

10 http://colo6-c703.uibk.ac.at/ttt2/

intuitive models, state-of-the-art termination tools fail even on very small and sim- ple TRSs. Especially the transformation 7 ϕ produces unsolvable rewrite systems which might be due to the fact that it preserves much less structure than £ϕ does. If tool authors investigate the reasons why the generated problems are that hard, new termination techniques could emerge.

References
Aoto, T. and T. Yamada, Termination of simply typed term rewriting by translation and labelling, in: Proc. 14th International Conference on Rewriting Techniques and Applications, LNCS 2706, 2003, pp. 380–394.
Arts, T. and J. Giesl, Termination of term rewriting using dependency pairs, Theoretical Computer Science 236 (2000), pp. 133–178.
Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, 1998.
Codish, M., V. Lagoon and P. Stuckey, Solving partial order constraints for LPO termination, in: Proc. 17th International Conference on Rewriting Techniques and Applications, LNCS 4098, 2006, pp. 4–18.
Cook, S., The complexity of theorem-proving procedures, in: Proc. 3rd annual ACM symposium on theory of computing (1971), pp. 151–158.
Dershowitz, N., Orderings for term-rewriting systems, Theoretical Computer Science 17 (1982),
pp. 279–301.
Dick, J., J. Kalmus and U. Martin, Automating the Knuth-Bendix ordering, Acta Informatica 28 (1990),
pp. 95–119.
Endrullis, J., J. Waldmann and H. Zantema, Matrix interpretations for proving termination of term rewriting, Journal of Automated Reasoning 40 (2008), pp. 195–220.
Giesl, J., P. Schneider-Kamp and R. Thiemann, AProVE 1.2: Automatic termination proofs in the dependency pair framework, in: Proc. 3rd International Joint Conference on Automated Reasoning, LNAI 4130, 2006, pp. 281–286.
Giesl, J., R. Thiemann and P. Schneider-Kamp, The dependency pair framework: Combining techniques for automated termination proofs, in: Proc. 11th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning, LNAI 3452, 2005, pp. 301–331.
G¨odel, K., U¨ber formal unentscheidbare sa¨tze der principia mathematica und verwandter systeme, Monatshefte fu¨r Mathematik und Physik 38 (1931), pp. 173–198.
Huet, G. and D. Lankford, On the uniform halting problem for term rewriting systems, Technical Report 282, INRIA, Le Chesnay, France (1978).
Kamin, S. and J. L´evy, Two generalizations of the recursive path ordering, Unpublished manuscript, University of Illinois (1980).
Knuth, D. and P. Bendix, Simple word problems in universal algebras, in: J. Leech, editor,
Computational Problems in Abstract Algebra, Pergamon Press, 1970 pp. 263–297.
Koprowski, A., TPA: Termination proved automatically., in: Proc. 17th International Conference on Rewriting Techniques and Applications, LNCS 4098, 2006, pp. 257–266.
Koprowski, A. and A. Middeldorp, Predictive labeling with dependency pairs using SAT, in: Proc. 21st International Conference on Automated Deduction, LNAI 4603, 2007, pp. 410–425.
Koprowski, A. and H. Zantema, Automation of recursive path ordering for infinite labelled rewrite systems, in: Proc. 3rd International Joint Conference on Automated Reasoning, LNAI 4130, 2006, pp. 332–346.
Korovin, K. and A. Voronkov., Orienting rewrite rules with the Knuth-Bendix order, Information and Computation 183 (2003), pp. 165–186.
Kurihara, M. and H. Kondo, Efficient BDD encodings for partial order constraints with application to expert systems in software verification, in: Proc. 17th International Conference on Industrial and Engineering Applications of Artificial Intelligence and Expert Systems, LNAI 3029, 2004, pp. 827–837.

Payet, E´., Detecting non-termination of term rewriting systems using an unfolding operator, in: Proc. 11th International Symposium on Logic-Based Program Synthesis and Transformation, LNCS 4407, 2007, pp. 194–209.
Waldmann, J., Matchbox: A tool for match-bounded string rewriting, in: Proc. 15th International Conference on Rewriting Techniques and Applications, LNCS 3091, 2004, pp. 85–94.
Zankl, H. and A. Middeldorp, Satisfying KBO constraints, in: Proc. 18th International Conference on Rewriting Techniques and Applications, LNCS 4533, 2007, pp. 389–403.
Zantema, H., Termination of term rewriting: Interpretation and type elimination, Journal of Symbolic Computation 17 (1994), pp. 23–50.
Zantema, H., Termination of term rewriting by semantic labelling, Fundamenta Informaticae 24 (1995),
pp. 89–105.
