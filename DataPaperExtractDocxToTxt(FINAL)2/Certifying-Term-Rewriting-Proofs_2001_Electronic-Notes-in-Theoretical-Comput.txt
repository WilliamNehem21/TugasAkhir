Electronic Notes in Theoretical Computer Science 59 No. 4 (2001)
URL:  http://www.elsevier.nl/locate/entcs/volume59.html  21 pages
Certifying Term Rewriting Proofs in ELAN Quang-Huy Nguyen 1

LORIA & INRIA
BP 101, 54602 Villers-l es-Nancy Cedex, France



Abstract
Term rewriting has been shown to be a good environment for both programming and proving. For analysing and debugging rule-based programs, we propose in this work a formalism based on the rewriting calculus with explicit substitutions (  -calculus). This formalism also allows us to build the proof terms of rewrit- ing derivations. Therefore, term rewriting proofs can be exported to other sys- tems by translating them into the corresponding syntaxes. That is, using a proof checker, one can certify these proofs and vice versa, this method allows us to get term rewriting in proof assistants using an external system. Our method not only works with syntactic rewriting but also with rewriting modulo a set of axioms (e.g. associativity-commutativity).




1	Introduction

In a proof assistant, formal proofs are composed of deduction steps performed by the user with the possible help of tactics. These steps should be memo- rised if one wants to check the proofs and to communicate them with other systems [24,14]. In some proof assistants (e.g. ALF, Coq, LEGO), the proof terms of all deduction steps are explicitly stored. In other systems, proof term memorising was not given the rst priority but some attempts have been done to get this feature, for example, in Isabelle [6] or in HOL [35].
Term rewriting has been shown to be fundamental for both programming and proving. In proof assistants, term rewriting is very useful since it eases equational reasoning and considerably simplify proofs by abstracting the com- putational arguments [16]. However, in a system like Coq [20], term rewriting is painful due to the size of its proof term. In order to justify a rewrite step, the context and the used substitution need to be kept in the proof term. This fact poses a serious space problem for Coq kernel in proof checking. Besides,

1 Email: Quang-Huy.Nguyen@loria.fr
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


term rewriting in Coq still requires user interactions and its eÆciency is also limited since Coq works in interpreted mode.
At this stage, one might exploit the performance of the rule-based program- ming environments to help proof assistants in dealing with term rewriting. However, most of these environments consider term rewriting as computation but not as deduction. That is, no proof term is generated during the execu- tion of a ruled-based program. In fact, some systems have considered tabling rewriting but only for improving eÆciency or termination behaviour [33] [23], and the stored information cannot be seen as proof terms of their computa- tions.
Hence, proof assistants must, in this situation, trust programming en- vironments and consider the computations they perform as axioms in their proofs. This approach is not completely reliable since these computations are not checked. In other words, when correctness is crucial, rule-based programs should return the proof terms of their computations.
A rule-based program takes a term as its input and returns zero, one, or several terms as its output. When considering equational interpretation, the input and the output are equal in the context of the considered program. The derivation between them can be seen as a proof of this equality. On the other hand, it is well-known that using a relevant strategy, eÆciency and some behaviors (e.g. termination) of rule-based programs can be signi cantly improved. Recently, some systems (e.g. ELAN [28], STRATEGO [25]) allow the user to guide the applications of rewrite rules instead of using a strategy by default like leftmost-innermost. This new feature gives rise to a demand to memorise user-guided computations, for example by tracing them. From a logical point of view, when rewriting is equationally interpreted, this trace can be seen as a proof of equality between the input and the output. From the programming aspect, the trace is very helpful in analysing and in debugging programs. And last but not least, this trace gives a means to export the computations (or proofs) to other systems.
The information kept in the trace depend on how this trace is used later. For example, in order to replay a derivation in syntactic rewriting, the trace of a rewrite step may simply contain the position of redex and the applied rule as it is used in [2] since pattern matching is deterministic and not costly. But when considering rewriting modulo a set of axioms like associativity and commutativity (AC rewriting), pattern matching becomes much more diÆcult (non-deterministic and NP-complete [5]) and hence, the trace of a rewrite step should contain more information such as the used substitution. Moreover, to improve the eÆciency of pattern matching modulo AC, most of systems (e.g. ELAN, MAUDE) put a term in its AC canonical form before reducing it. The canonical form is built based on a total ordering on ground terms. In other words, the position of a redex depends on this ordering and rewriting context might be a better choice for memorising this redex. At this stage, a uni ed representation of trace (or proof term for term rewriting) is desirable


since this allows to analyse the program execution and facilitates the syntactic manipulations (e.g. compacting or translating) on this trace.
The rewriting calculus [10,9] or Cal is a simple calculus whose rst class objects are the di erent ingredients of term rewriting i.e. terms, rules, rule applications, strategies and sets of results. Therefore, Cal can capture both non-determinism where rewriting returns a set of results and failure where this set is empty. In Cal, the arrow rewrite symbol (!) is considered as the abstractor, while the left hand sides are seen as binding patterns. This generalises the abstraction mechanism of -calculus where the binding pattern is simply a variable and only trivial pattern matching is required. In other words, Cal integrates term rewriting and -calculus in a uni ed framework where both of them can be naturally expressed. As a further step, Cal with explicit substitutions ( -calculus) was designed [9] in order to make the substitution process explicit in the calculus.
One of the main motivations of this work is to communicate the proof term of rewriting derivation that is in rst order syntax with proof assistants that are mostly based on higher order logic. Therefore,  Cal and eventually
  -calculus, since we need to explicitly manipulate substitutions, is a relevant
framework to represent proof terms.
In this paper we present a representation of the proof term of rewriting derivation based on  -calculus. We have generated the proof term of syntactic rewriting and AC rewriting in ELAN. The translation of this proof term into Coq-syntax is described and is proved sound. This translation has also been implemented in ELAN. As a result, we get the corresponding proof term for Coq proof assistant. This proof term is then formally checked by Coq to ensure correctness. This work allows one to certify term rewriting proofs in ELAN and hence, to get term rewriting in Coq using ELAN.
The notations used in this paper are described in section 2.  Section	3
reviews the syntax and the operational semantics of  -calculus. In section 4, we describe the proof term for term rewriting in this syntax. The proof term syntax of equality in Coq is presented in section 5. Section 6 describes the translation between the two above syntaxes. We describe and discuss our current implementation in section 7 before giving the conclusion.

2  Preliminaries

We mostly use the notations introduced in [15] and [19].
A rewrite rule is written l ! r where l is not a variable and Var(r) 
Var(l). We call l and r respectively the left hand side (LHS) and the right hand side (RHS) of rule. A set of rewrite rules R is called a term rewriting system (TRS). Let R be a TRS. The term t rewrites to the term s in one rewrite step if there exist some rule l ! r in R, position p in t and substitution such that: tjp = l and s = t[r ]p. If p is not empty, then this step is called non-root. We denote a rewrite step in R by t !R s and the re exive-transitive


closure of the binary relation !R by ! . This relation is also called syntactic rewriting. The subterm tjp = l is called a redex in t since it is an instance of a LHS of R. If we replace this redex by a \hole", then we get the rewriting context of the rewrite step at position p. A term is said to be in normal form (NF) w.r.t. R if it contains no redex. A (rewriting) derivation in R is any ( nite or in nite) sequence of rewrite steps.
Let l1 ! r1 and l2 ! r2 be two rewrite rules with distinct variables. If p is the position of a non-variable subterm of l2,  is a most general uni er of l1 and l2jp, then the equation r2 = l2 [r1 ]p is a critical pair formed from those rules.
A conditional rewrite rule is written l ! r if c where c is called the condi- tion. There are several methods to de ne semantics of conditional rewriting. In this work, a (conditional) rewrite step is performed if and only if c ( is the used substitution) can be evaluated to T rue by the same rewrite system and by the re exivity of equality.
We denote the equality modulo an equational theory T by =T : t =T s if and only if T j= t = s. Associativity and commutativity (AC) is one of the most useful equational theories. By replacing syntactic equality by equality modulo AC in the de nition of rewrite steps we get AC rewriting relation.
By l  ? t we denote the matching problem between term t and pattern l in
equational theory T . A solution of this problem is the substitution  such

that l =T t. The set of such solutions is written Sol(l  ?
t).

When working with Coq-syntax, the bold Sans serif font (e.g. Lemma) is used for Coq keywords, while the bold font (e.g. A) is used for Coq identi ers. The notation t : A means that the type of t is A. The arrow symbol (!) in a type expression denotes a functional type and is right associative. The application of term f on term t is denoted by (f t). Term abstractor ( ) is written [], e.g. [x; y : A; z : B]x denotes xy : A z : B:x. Type abstractor ( ) is written (), e.g. (x; y : A; z : B)x denotes  xy : A z : B:x.

3	  -calculus

We only introduce here the notions and notations which are useful in this work. For a general presentation of explicit substitution calculi, the reader is referred for example, to [1,13].
Syntax For all x 2 V and f 2 F:

terms t ::= x j f (t; :::; t) j ft; :::; tg j [t](t) j t ! t j thsi substitutions s  ::=  ID j " j * j t:s j s Æ s
In the term syntax, t ! u denotes a rewrite rule (a.k.a. -abstraction), [t](u) represents the application of t on u, the application of substitution s on t is denoted by binary operator thsi. The substitution syntax is composed of the


identity substitution (ID ), the shift ("), the composition operator (s Æ v), the substitution concatenator (s:v) and the lift (* (s)).
Operational semantics Figure 1 describes the evaluation rules of the - calculus. The rule Fire describes the application of a rewrite rule l ! r at root position of term t. This rewrite step replaces t by a set of instantiated RHSs frh ig where is a solution of the pattern matching problem between t and l. The rule Congruence allows one to apply a rule on a non-root position. The
 ve rules Distrib, Batch, Switch, OpOnSet and Flat are added to manipulate
the sets of results.


Since the substitution process is explicit in this calculus, a set of evaluation rules for thsi is also presented in [9]. We do not describe these rules here due to space reason but using them, one can reduce th i to t for any rst order term t and substitution , as in other explicit substitution calculi. In the sequel, !7! denotes the reduction relation by these rules while !7! stands for the reduction relation by the rules in gure 1. The combination of these two relations is written !7!  .

4	Proof Term for Term Rewriting in   -syntax

De nition 4.1 (Proof term) Let R be a TRS and t, s be two terms. The

  -term  is called a proof term of the derivation t ! 
s if [ ](t) !7! 
fsg.

The proof term of the identity derivation t ! t is given by the  -term id  [x ! x] since [id](t)  [x ! x](t) !7!Fftg for every term t.


Lemma 4.2 (Rewrite step at root position) If l ! r is the applied rule and is the used substitution, then lh i ! rh i is a proof term of the one-step derivation l ! r .

Proof. By the following derivation:


[lh i ! rh i](l ) !7!F frh ihID ig !7!I frh ig !7!  fr g


2

Lemma 4.3 (Conditional rewrite step at root position) Let l ! r if c be the applied rule and  be the used substitution. If c is a proof term of
the derivation c !  T rue, then lh i ! [T rue ! rh i]([  ](ch i)) is a proof
c
term of the one-conditional-step derivation l ! r .

Proof. By the following derivation:


[lh i ! [T rue ! rh i]([ c](ch i))](l ) !7!F  [T rue ! rh i]([ c](ch i))

!7! 
[T rue ! rh i]([ c](c ))	!7! 
[T rue ! rh i](fT rueg)

!7!B f[T rue ! rh i](T rue)g	!7!F  ffrh igg
!7!Fl frh ig	!7!   fr g

2

Lemma 4.4 (Non-root rewrite step) If i is a proof term of the rewrite step ti ! si, then f (id; :::; i; :::; id) is a proof term of the one-step derivation f (t1; :::; ti; :::; tn) ! f (t1; :::; si; :::; tn)

Proof. By the following derivation:


[f (id; :::;  i; :::; id)](f (t1; :::; ti; :::; tn))
!7!C ff ([id](t1); :::; [ i](ti); :::; [id](tn)g	!7! 


ff (t1; :::; fsig; :::; tn)g

!7!O fff (t1; :::; si; :::; tn)gg	!7!Fl ff (t1; :::; si; :::; tn)g

2

Lemma 4.5 (Rewriting derivation) If 1; :::; n are respectively a proof term of the derivations t1 ! t2,...,tn ! tn+1, then x ! [ n](::: [ 1](x) :: :) is a proof term of the n-steps derivation t1 ! ::: ! tn+1


Proof. By the following derivation:

[x ! [ n](::: [ 1](x) :: :)](t1) !7!F f[ n](::: [ 1](t1) :: :)g

!7! 
f[ 
](::: [  ](ft g) :: :)g	!7!	f[  ](::: f[  ](t )g :: :)g

n	2	2	B	n	2	2
!7!  :::	!7!  f[ n](tn)g
!7!   fftn+1gg	!7!Fl ftn+1g

2
For short, in the sequel, we denote x ! [ n](::: [ 1](x) :: :) by  1; ::: ;  n.
Example 4.6 Consider the TRS
R = nf (x) ! x


The derivation g(f (a);f (b)) ! 
g(a; b) has a proof term given by the   term:

  = g(f (x)hx 7! ai ! xhx 7! ai; id); g(id;f (x)hx 7! bi ! xhx 7! bi)

Proof term compacting Proof terms need to be as concise as possible so that they can eÆciently be stored, communicated and checked by proof assis- tants. The rules in gure 2 allow to reduce the size of proof terms by combining proof terms in di erent branches of a function symbol and by eliminating the proof term of identity. This rewrite system is terminating since the size of a proof term strictly decreases after the application of each rule on it, and con-
 uent since the only critical pair formed by Id elim l and Id elim r is trivial.














Example 4.7 The proof term   in example 4.6 can be reduced as follows:

  = g(f (x)hx 7! ai ! xhx 7! ai; id); g(id;f (x)hx 7! bi ! xhx 7! bi)
!7!Disjoint g(f (x)hx 7! ai ! xhx 7! ai; id ; id; f (x)hx 7! bi ! xhx 7! bi)
!7!Id elim r g(f (x)hx 7! ai ! xhx 7! ai ; id; f (x)hx 7! bi ! xhx 7! bi)
!7!Id elim l g(f (x)hx 7! ai ! xhx 7! ai ; f (x)hx 7! bi ! xhx 7! bi) = 


Related work There are several works in the literature on representing proofs in rewriting logic. First of them was Meseguer's work on modelling concurrency by (conditional) rewriting logic [22] (see also [18]). Our formal- ism is more related to the representation proposed in Gadducci's work on at rewriting logic [17] since we orient towards an implementation in sequential machines and hence, do not allow concurrent rewrite steps.  Our choice of
  -calculus is motivated by the need of a readable syntax and of a strong
relationship with type theory [11]. Besides, conditional rewriting is smoothly incorporated in our formalism thanks to the evaluation mechanism of  - calculus.



5	Proof Term of Equality in Coq

Coq is a proof assistant based on the Calculus of Inductive Constructions (the Calculus of Constructions [12] with inductive data types [27]). Proofs in Coq are constructive and hence, assuming excluded middle is up to the user. By Curry-Howard isomorphism, logical propositions are interpreted as types. A proposition is provable if and only if it is inhabited by some terms built using Coq pre-de ned constants. These terms are the proof terms of that proposi- tion. Coq proof mode is interactive: the user builds proofs in a backward style using Coq tactics. At each step, the applied tactic generates a list of subgoals needed to be proved in order to conclude the current goal. The proof terms generated in deduction steps are stored and certi ed (i.e. type checked) by Coq kernel. This approach has some advantages: correctness is ensured by the reliability of a tiny kernel which has formally been proved in [3], a certi ed (functional) program can be extracted from the proof of its speci cation [26], etc. However, this mechanism requires to keep all informations concerning each deduction step in the proof term and sometimes, poses a serious problem of space.



5.1	Equality in Coq

Coq uses Leibniz equality. Let A be the carrier type and Prop be the type which represents logical propositions in Coq. Leibniz equality is an equivalence relation =A on A such that:

8x; y : A:x =A y , 8 : A ! Prop:( x) ! ( y)

Leibniz equality enjoys standard properties such as re exivity, transitivity and substitutivity. For equality proofs using these properties, Coq provides


corresponding constants allowing to build proof terms.


x : A


(re  equal A x) : x =A x
Re exivity

x; y; z : A	 1 : x =A y	 2 : y =A z


(trans equal A x y z  1  2) : x =A z
Transitivity

 : A ! Prop	x; y : A	 1 : x =A y	 2 : ( x) (eq ind A x   2 y  1) : (  y)
Substitutivity

Re exivity: If t is a term of type A, then (re equal A t) is a proof of t =A t.
Transitivity: Let t; s and v be three terms of type A. If 1 and 2 are respectively a proof of t =A s and s =A v, then (trans equal A t s v  1  2) is a proof of t =A v.
Substitutivity: Let t; s be two terms of type A and  : A ! Prop be a predicate. If 1 and 2 are respectively a proof of t =A s and ( t), then (eq ind A t   2 s  1) is a proof of ( s).
This rule actually allows us to simplify a goal by term rewriting inside a context ( ). The proof term of the rewrite step ( t) ! ( s) contains rewriting context , instantiated LHS t, instantiated RHS s and a proof of t =A s.
Notice that these constants correspond to the case where the type of A is Set. The other case (A : Prop) requires two other constants but their usage is similar. In the sequel, for short, if A is involved in the context, then we use
= to denote Leibniz equality on A instead of =A.

5.2	Rewrite rule
The equational axiom l = r is speci ed in Coq by the following axiom:

` : (x1; :::; xn : A) l = r

where ` is the label of this axiom and x1; :::; xn are the variables of l and r (fx1; :::; xng  Var(l) [ Var(r)). If t1; :::; tn are n terms of type A, then (` t1 ::: tn) is of type (or a proof) of lfx1 7! t1g ::: fxn 7! tng = rfx1 7! t1g ::: fxn 7! tng.

5.3	Proof term factorisation
The contexts stored in the proof term of a rewriting derivation are usually redundant. Redundancy appear in particular when some rewrite steps are performed at the same non-root position or when some rewrite steps are per- formed at disjoint branches of a function symbol.
Non-root rewrite steps The context needs to be separated from the proof term of a rewrite step in order to avoid repeating identical context when


performing several rewrite steps at the same position. To this end, for each rewrite step (or derivation) at position p of term t, the following lemma is added and proved:

Lemma ctx t : (x; y : A) x = y ! t[x]p = t[y]p

The proof of this lemma consists simply in applying the tactic Rewrite x = y on t. After being proved, this lemma can be used as a new constant for building Coq proof terms. Let s and v be two terms of type A. If  is a proof of s = v, then (ctx t s v ) is a proof of t[s]p = t[v]p.
Rewrite steps at disjoint branches The root function symbol is the com- mon part of the contexts and needs to be factorised. To this end, for each arity value n, the following lemma is added and proved:
n times
Lemma eq concat n : (x1; :::; xn : A; : (Az ! :}:|: ! A{ ! Prop))
(  x1 ::: xn) ! (y1 : A)x1 = y1 ! ::: ! (yn : A)xn = yn
! (  y1 ::: yn)

This lemma also avoids copying all other branches in the context of each rewrite step performed in a branch. The proof of this lemma consists of n applications of the Rewrite tactic:  Rewrite x1 = y1 ::: Rewrite xn = yn.
This lemma provides a new constant for building Coq proof terms.  Let
n times
t1; :::; tn; s1; :::; sn be 2n terms of type A and  : Az ! :}:|: ! A{ ! Prop be
a predicate. If  1; :::; n are respectively a proof of t1 = s1; :::; tn = sn and 
is a proof of (  t1 ::: tn), then (eq concat n t1 ::: tn   s1  1 ::: sn  n) is a proof of ( s1 ::: sn).

6	Proof Term Translation

For building proof terms in Coq-syntax, the proof term of identity (id) in
  -syntax is replaced by the terms on which it applies.
An auxiliary syntax ( -syntax) is rst introduced as a bridge between  - syntax and Coq-syntax. -syntax makes the translation more open in the sense that one can parameterise it by proof term syntaxes of proof checkers. Two operators   2 and 2Coq which respectively translate proof terms from
  -syntax to -syntax and from -syntax to Coq-syntax are then presented.
Finally, a soundness proof of the whole translation process is described.

6.1	 -syntax
We de ne -syntax as a simple syntax which represents proof terms in a compact format and which is straightforward to be translated into the syntaxes


of proof checkers. In order to stay independent of proof checkers, we only use in  syntax the basic properties of equality, namely re exivity, transitivity and substitutivity.

terms t ::= s CT X concat f (t; :::; t) trans(t; t) ref l(t) ctx(t; t)

where s is any  -term which represents the proof term of a rewrite step (see section 4); CT X is a fresh constant representing the hole in a context; concat f inherits the arity from f 2 F and combines the proof terms at disjoint branches of f ; trans concatenates the proof terms of two consecutive derivations; ref l represents a proof by re exivity; ctx represents the proof term of a non-root rewrite step. The introduction of ctx aims to separate the context from the proof term of a rewrite step and hence, to reduce the size of proof terms in Coq-syntax as described in section 5.3.
Example 6.1 Consider the proof term   in example 4.7. Its counterpart in  syntax is

  = concat g(f (x)hx 7! ai ! xhx 7! ai ; f (x)hx 7! bi ! xhx 7! bi)

But when considering the derivation g(f (a); b) !R g(a; b) we have the fol- lowing proof term in -syntax: g(f (x)hx 7! ai ! xhx 7! ai ; b) and its counterpart in -syntax:

ctx(g(CT X; b) ; f (x)hx 7! ai ! xhx 7! ai)

6.2	  2 
Figure 3 describes the evaluation rules for  2 . The rule Step states that the proof term of a rewrite step at root position is not changed by 2 . The rule Concat concatenates the proof terms of n consecutive derivations. The rule Ref l treats the case where no rewrite step is performed. This case corresponds to a proof by re exivity. The rule Disj1 separates the context from the proof term of a derivation performed in one branch of a function symbol. The rule Disj2 deals with the case where rewrite steps are performed at disjoint branches of a function symbol.
Example 6.2 The translation of   into   by  2 is described as follows:

  2 (g(f (x)hx 7! ai ! xhx 7! ai ; f (x)hx 7! bi ! xhx 7! bi))
!7!Disj2 concat g(  2 (f (x)hx 7! ai ! xhx 7! ai) ;
  2 (f (x)hx 7! bi ! xhx 7! bi))
!7!Step concat g(f (x)hx 7! ai ! xhx 7! ai ;  2 (f (x)hx 7! bi ! xhx 7! bi))
!7!Step concat g(f (x)hx 7! ai ! xhx 7! ai ; f (x)hx 7! bi ! xhx 7! bi) = 



6.3	 2Coq
Two operators In and Out which return the input (the term to be reduced) and the output (the result) of a rewriting derivation are rst described by the rules in gure 4.

The evaluation rules for 2Coq are then presented for all possible output of  2 (see gure 3).
rewrite steps at root position The proof term in Coq-syntax is given by instantiating the corresponding axiom with the used substitution:

 2Coq(lh i ! rh i) !7! (`  x1  :::  xn )

where fx1; :::; xng  Var(l) [ Var(r) and ` is the label of the axiom l = r in


Coq.
trans The proof term in Coq-syntax is built by concatenating proof terms of two consecutive derivations using trans equal:

 2Coq(trans( 1; 2)) !7! (trans equal A In( 1) Out( 1) Out( 2) 2Coq( 1) (trans equal A Out( 1) In( 2) Out( 2) lm eq  2Coq( 2)))
where lm eq is the following lemma: Lemma lm eq : Out( 1) = In( 2): This lemma states that the output of the rst derivation is equal to the input of the second derivation modulo the working equational theory T . This statement is obvious in case of syntactic rewriting (T ;) where no lemma is generated. However, in case of rewriting modulo a set of axioms, it is less obvious since the output of the rst derivation can be syntactically transformed before being reduced in the second derivation. For instance, in AC rewriting, a term is usually put in AC-canonical form before any further reduction is applied on it. In this case, lm eq needs to be added and proved since Coq has not reasoning modulo AC in its kernel.
re The proof term in Coq-syntax is built using re equal where A is the carrier type:
 2Coq(ref l(t)) !7! (re  equal A t)
ctx The proof term in Coq-syntax is built using lemma ctx t:

 2Coq(ctx(t[CT X]p;  )) !7! (ctx t In( ) Out( )  2Coq( ))

concat f This case corresponds to the derivations in di erent branches of function symbol f whose arity is n. The proof term in Coq-syntax is built using lemma eq concat n where A is the carrier type:

 2Coq(concat f ( 1; :::; n)) !7! (eq concat n In( 1) :::  In( n)
[x1; :::; xn : A]f (In( 1); :::; In( n)) = f (x1; :::; xn)
(re  equal A f (In( 1); :::; In( n)))
Out( 1)  2Coq( 1)  :::  Out( n)  2Coq( n))
Example 6.3 Continue with our example. We translate  into its counter- part in Coq-syntax as follows:

 2Coq(concat g(f (x)hx 7! ai ! xhx 7! ai ; f (x)hx 7! bi ! xhx 7! bi))
!7! (eq concat 2 f (a) f (b) [x1; x2 : A]g(f (a);f (b)) = g(x1; x2) (re equal A g(f (a);f (b))) a (` a) b (` b))


where ` is the label of the following Coq axiom:

(x : A) f(x) = x:

6.4	Soundness
Lemma 6.4 If  is a proof term in -syntax, then 2Coq( ) is a proof of equality In( ) = Out( ) in Coq.
Proof. By induction on the length of the derivation  represents. Consider di erent cases of 2Coq:
rewrite step at root position This is the basic case.
 2Coq( ) = (`  x1  :::  xn ) is a proof of lh i = rh i   In( ) = Out( ).
trans Lemma lm eq is a proof of Out( 1) = In( 2). By induction hypoth- esis, 2Coq( 2) is a proof of In( 2) = Out( 2). Hence, by the de nition of trans equal, (trans equal A Out( 1) In( 2) Out( 2) lm eq  2Coq( 2)) is a proof of Out( 1) = Out( 2).
Furthermore, by induction hypothesis, 2Coq( 1) is a proof of In( 1) = Out( 1) and so,  2Coq(trans( 1; 2)) is a proof of In( 1) = Out( 2) In(trans( 1;  2)) = Out(trans( 1;  2)).
re  2Coq(ref l(t)) is a proof of t = t  In(ref l(t)) = Out(ref l(t)) by the de nition of re equal.
ctx By induction hypothesis, 2Coq( ) is a proof In( ) = Out( ). By the de nition of ctx t,  2Coq(ctx(t[CT X]p;  )) is a proof of t[In( )]p = t[Out( )]
   In(ctx(t[CT X]p;  )) = Out(ctx(t[CT X]p;  )).
concat f Consider the predicate     x1 ::: xn : A:f (In( 1); :::; In( n)) = f (x1; :::; xn), we have: (re equal A f (In( 1);::: ; In( n))) is a proof of
f (In( 1); :::; In( n)) = f (In( 1); :::; In( n))   ( In( 1) ::: In( n)) and by induction hypothesis, 2Coq( 1); :::; 2Coq( n) are respectively a proof of In( 1) = Out( 1);::: ; In( n) = Out( n).  By the de nition of eq concat n,
 2Coq(concat f ( 1; :::;  n)) is a proof of (  Out( 1) ::: Out( n))
 f (In( 1); :::; In( n)) = f (Out( 1); :::; Out( n))  In(concat f ( 1; :::; n)) = Out(concat f ( 1; :::; n)).
2
Lemma 6.5 If  is a proof term in  -syntax of derivation t ! s, then In(  2 ( )) = t and Out(  2 ( )) = s.
Proof. By induction on the length of the derivation  represents. Consider di erent cases of  2 (see gure 3):
Step This is the basic case: In(  2 (t ! s)) = In(t ! s) = t while Out(  2 (t ! s)) = Out(t ! s) = s.


Concat In(  2 (t1; ::: ; tn)) = In(trans(  2 (t1); trans(t2; ::: ; tn)))
= In(  2 (t1)) = t due to induction hypothesis. Similarly, Out(  2 (t1; ::: ; tn))
= Out(trans(  2 (t1); trans(t2; ::: ; tn))) = Out(trans(t2; ::: ; tn)) = ::: = Out(  2 (tn)) = s due to induction hypothesis.
Re  In this case, no rewrite step has been performed in  and t = s.
Therefore, In(  2 (ref l(f (t1; :::; tn)))) = f (t1; :::; tn) = t while
Out(  2 (ref l(f (t1; :::; tn)))) = f (t1; :::; tn) = s.
Disj1 By induction hypothesis, In(ctx(f (t1; :::; ti[CT X]p; :::; tn);  2 (tijp)))
= f (t1; :::; ti[In(tijp)]; :::; tn) = t.
Similarly, Out(ctx(f (t1; :::; ti[CT X]p; :::; tn);  2 (tijp)))
= f (t1; :::; ti[Out(tijp)]; :::; tn) = s.
Disj2 By induction hypothesis, In(concat f (  2 (t1); :::;  2 (tn)))
= f (In(  2 (t1)); :::; In(  2 (tn))) = t
Similarly, Out(concat f (  2 (t1); :::;  2 (tn)))
= f (Out(  2 (t1)); :::; Out(  2 (tn))) = s
2
Theorem 6.6 (Soundness) If  is a proof term in  -syntax of derivation t ! s, then 2Coq(  2 ( )) is a proof of equality t = s in Coq.
Proof. By lemma 6.4, 2Coq(  2 ( )) is a proof of In(  2 ( )) = Out(  2 ( )) which is equivalent to t = s due to lemma 6.5.	2
7	Implementation
In our implementation, ELAN and Coq work on the same TRS R. On one hand, the rules in R are speci ed as axioms in Coq: the AC function symbols require adding associative and commutative axioms. On the other hand, R is also speci ed as an ELAN speci cation. Generality is ensured since our implementation is completely independent of R.
The aim of this implementation is to generate from each derivation t !  s
in ELAN a proof term of proposition t = s in Coq. We rst implement a tracing mechanism for syntactic rewriting and AC rewriting in ELAN. The generated trace includes the rewriting context, the used substitution and the applied rule in each rewrite step. We next transform the trace into a proof term in
  -syntax by a module written itself in ELAN. This module also normalises
this proof term in order to reduce its size by the rules in gure 2. A set of lemmas and their proofs in Coq is then generated from this normalised proof term via the translation described in section 6. These lemmas include the main claim which states that t = s. Finally, all generated lemmas are automatically checked in Coq.
Equality modulo AC When working with AC rewriting, a decision proce-


dure for equality modulo AC is needed in Coq since ELAN works on terms in canonical form. An approach to implement this decision procedure is given by ordered rewriting proposed in [21]. Equality modulo AC between two ground terms can be decided by a TRS which includes three following syntactic (con- ditional) rewrite rules for each AC function symbol fAC in the signature:

fAC(x; fAC(y; z)) ! fAC(y; fAC(x; z)) if (x  lpo y) fAC(x; y)	! fAC(y; x)	if (x lpo y) fAC(fAC(x; y); z) ! fAC(x; fAC(y; z))
where lpo denotes the lexicographic path ordering. Intuitively, these rules implement a sorting algorithm (bubble sort) on the subterms of a ground term. Two ground terms are equal modulo AC if and only if their sorted forms are syntactically equal. The search for a derivation from a term to its sorted form is done in ELAN. Coq replays this derivation later by checking its proof term as described in this paper or by using the Coq/ELAN interface for syntactic rewriting described in [2].
Benchmarking We give here some performance data yielded by testing our implementation on the TRS given by completing an Abelian group and that is composed of the following rewrite rules (+ being a AC function symbol):

x +0 ! x	 0 ! 0   (x + y) ! ( x)+ ( y) x + ( x) ! 0   ( x) ! x
This TRS is expressed in a natural way by the ELAN speci cation in g- ure 5. Syntactic function symbols and their arity are described in section Ops. Section ACOps contains the AC function symbols (with arity 2). In section Type, we need to precise the carrier type used in Coq since this type is re- quired in building Coq proof terms. Section Vars declares the variables used in de ning rewrite rules. These rules are given in section Rules with their label in the following syntax: [label] LHS ! RHS.
The experiment consists in normalising randomly generated terms using the leftmost-innermost strategy of ELAN and checking the corresponding proof term in Coq to prove that every term is equal to its normal form.
We used a PC Pentium III 860 Mhz running Linux for these tests. Time is measured in second. Table 1 shows that the number of generated lemmas and the proof term size of the main theorem is linear in the number of rewrite steps. It is not easy to estimate the proof term size since the e ectiveness of the optimisations in size reducing depends on the positions of contracted redexes. These optimisations generate some auxiliary lemmas (see section 5.3). The proofs of these lemmas in Coq are not expensive. On the contrary, the lem- mas for equality modulo AC are costly since we presently use the Coq/ELAN


specification abelian_group Ops


ACOps Type Vars Rules
Opp:1 Zero:0 Plus
A

X_1 X_2

[neutral] (Plus X_1 Zero) -> X_1 [Opp_Null] (Opp Zero) -> Zero [Opp_Opp] (Opp (Opp X_1)) -> X_1 [Opp_Plus] (Opp (Plus X_1 X_2)) ->
(A_Plus (Opp X_1) (Opp X_2)) [invert] (Plus X_1 (Opp X_1)) -> Zero

end of specification

Fig. 5. ELAN speci cation for Abelian groups

Table 1
Benchmark on Abelian groups

interface [2] to prove them and the replaying process in Coq is quite time con- suming. In other words, term rewriting proofs in ELAN are not only checked but partially replayed in Coq.

8	Conclusions

We have described a representation of the proof term for term rewriting in
 -calculus. This representation allows to communicate term rewriting proofs with other systems by translating proof terms into their syntaxes. One of these translations (from   -syntax into Coq-syntax) has been described and


implemented. As a result, term rewriting proofs in ELAN can be checked in Coq. In this translation we only need two Coq constants which provide equality proofs by re exivity (re  equal) and transitivity (trans equal). Most of proof checkers (e.g. ALF, LEGO) also o er these constants and hence, the translations into their proof term syntaxes can be given by adapting 2Coq. Translating logical proofs between theorem provers has been studied by several researchers [24,32]. This is not always a simple task since they need to bridge the gap between di erent logical foundations on which these systems are based. Our work is more restrictive since we only consider equational proofs. Therefore, we can avoid the semantics issues and concentrate on the syntax of proof terms. In [35], Wong traces HOL proofs in order to check them by an independent proof checker which has been developed itself by the author. On the contrary, as what is done in [7], we use Coq kernel as proof checker.	This fact requires us to respect Coq-syntax when building proof terms. However, we think that Coq kernel is more reliable since its logical foundation has been well-studied.	Moreover the kernel has formally been proved consistent itself [3]. In [31], Twelf [29] has been chosen for checking proofs. The authors have de ned their own equality relation and its properties in this framework. We think that it is not diÆcult to adapt our translation process, namely the procedure 2Coq, to generate proof terms for checking in Twelf. Moreover, since proof terms in -syntax are already compacted, the generated proof terms in Twelf-syntax will be more concise than in the format
used in [31].
Some attempts [8,2] have been done in order to get eÆcient term rewrit- ing in Coq using re ection method. This approach is adequate for syntactic rewriting but when considering AC rewriting it becomes less obvious since pattern matching modulo AC is not simple enough to be eÆciently performed in Coq.
The next step of this work is to implement an interface in Coq which allows the user to send the equalities they want to prove to ELAN. This latter per- forms these proofs and sends back the corresponding proof terms for checking in Coq.
One main advantage of ELAN is its set of strategies which allows the user to control rewriting and hence, to implement sophisticated proof search pro- cedures [30,4]. Generating proof terms of these strategies helps to check a proof done by ELAN and to export it to other systems. Presently, only proof terms of the normalisation strategies in ELAN are generated but it seems not diÆcult to extend the formalism (and the implementation) to the complete set of ELAN strategies.
Another use of proof terms is to analyse and to debug ELAN programs. To this end, not only the proof terms of successful rewrite steps but also that of failure should be stored in order to understand why a rule or a strategy failed to apply on some term. At this stage, we need to deal with the space problem due to the size of proof terms. Sharing gives a means to overcome


this problem. Some public libraries like ATerm [34] o er a term representation with maximal sharing. Integrating ATerm in ELAN is being investigated.
Acknowledgements I am indebted to Claude Kirchner for numerous dis- cussions and to some anonymous referees for their helpful remarks.


References

[1] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L evy. Explicit substitutions. In ACM, editor, Conf. Rec. 17th Symp. POPL, pages 31{46, 1990.
[2] C. Alvarado and Q-H. Nguyen.  ELAN for equational reasoning in Coq. In J. Despeyroux, editor, Proc. of 2nd Workshop on Logical Frameworks and Metalanguages. Institut National de Recherche en Informatique et en Automatique, ISBN 2-7261-1166-1, June 2000.
[3] B. Barras. Auto-validation d'un syst eme de preuves avec familles inductives. PhD thesis, Universit e Paris VII, November 1999.
[4] E. Be ara, O. Bournez, H. Kacem, and C. Kirchner. Veri cation of timed automata using rewrite rules and strategies. In N. Dershowitz and A. Frank, editors, Proc. BISFAI 2001, June 2001.
[5] D. Benanav, D. Kapur, and P. Narendran. Complexity of matching problems. Journal of Symbolic Computation, 3(1{2):203{216,	1987.
[6] S. Berghofer and T. Nipkow. Proof terms for simply typed higher order logic. In J. Harrison and M. Aagaard, editors, Proc. 13th Int. Conf. TPHOL, volume 1869 of Lecture Notes in Computer Science, pages 38{52. Springer-Verlag, 2000.
[7] M. Bezem, D. Hendriks, and H. de Nivelle. Automated proof construction in type theory using resolution. In D. McAllester, editor, Proc. 17th Int. Conf. CADE, volume 1831 of Lecture Notes in Arti cial Intelligence, pages 148{163. Springer-Verlag, 2000.
[8] S. Boutin. Using re ection to build eÆcient and certi ed decision procedures. In M. Abadi and T. Ito, editors, Proc. of the 3rd Int. Symp. TACS, number 1281 in Lecture Notes in Computer Science, pages 515{529. Springer-Verlag, 1997.
[9] H. Cirstea. Calcul de r e ecriture : fondements et applications. PhD thesis, Universit e Henri Poincar e - Nancy I, October 2000.
[10] H. Cirstea and C. Kirchner. The rewriting calculus | Part I and II. Journal of the Interest Group in Pure and Applied Logics, 9(3):427{498, May 2001.
[11] H. Cirstea, C. Kirchner, and L. Liquori. The Rho Cube. In F. Honsell, editor, Proc. of FOSSACS, volume 2030 of Lecture Notes in Computer Science, pages 166{180, April 2001.


[12] T. Coquand and G. Huet. The Calculus of Constructions. Information and Computation, 76, 1988.
[13] P-L Curien, T Hardin, and J-J L evy. Con uence properties of weak and strong calculi of explicit substitutions. Journal of the ACM, 43(2):362{397, March 1996.
[14] E. Denney. A prototype proof translator from HOL to Coq. In M. Aagaard and J. Harrison, editors, Proc. 13th Int. Conf. TPHOL, volume 1869 of Lecture Notes in Computer Science, pages 108{125. Springer-Verlag, 2000.
[15] N. Dershowitz and J-P. Jouannaud. Handbook of Theoretical Computer Science, volume B, chapter 6: Rewrite Systems, pages 244{320. Elsevier Science Publishers B. V. (North-Holland), 1990.
[16] G. Dowek, T. Hardin, and C. Kirchner. Theorem proving modulo. Rapport de	Recherche	3400, Institut National de Recherche en Informatique et en Automatique, April 1998. ftp://ftp.inria.fr/INRIA/publication/RR/RR-3400.ps.gz.
[17] F. Gadducci. On the Algebraic Approach to Concurrent Term Rewriting. PhD
thesis, Universita di Pisa, January 1996.
[18] Claude Kirchner, H el ene Kirchner, and M. Vittek. Designing CLP using Computational Systems. In P. Van Hentenryck and S. Saraswat, editors, Principles and Practice of Constraint Programming. The MIT press, 1995.
[19] J.W. Klop.  Term rewriting systems.  In S. Abramsky, D. M. Gabbay, and
T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 2, chapter 1, pages 1{117. Oxford University Press, Oxford, 1992.
[20]  LogiCal/INRIA.  The  Coq  homepage.  http://coq.inria.fr.
[21] U. Martin and T. Nipkow. Ordered rewriting and con uence. In M.E. Stickel, editor, Proc. 10th Int. Conf. Automated Deduction, volume 449 of Lecture Notes in Computer Science, pages 366{380. Springer-Verlag, 1990.
[22] J. Meseguer. Conditional rewriting logic as a uni ed model of concurrency. Theoretical Computer Science, 96(1):73{155,	1992.
[23] J-Y. Moyen. System presentation: an analyser of rewriting systems complexity. In Mark van den Brand and Rakesh Verma, editors, Prceedings of the second RULE workshop, volume 59. Elsevier Science Publishers B. V. (North-Holland), 2001. In this volume.
[24] P. Naumov, M-O. Stehr, and J. Meseguer. The HOL/NuPRL proof translator: A practical approach to formal interoperability. In R.J. Boulton and P.B. Jackson, editors, Proc. 14th Int. Conf. TPHOL, volume 2152 of Lecture Notes in Computer Science, pages 329{345. Springer-Verlag, 2001.
[25] University  of  Utrecht.	The STRATEGO homepage. http://www.stratego-language.org.


[26] C. Paulin-Mohring. Extracting !'s programs from proofs in the calculus of constructions. In ACM, editor, Proc. 16th Symp. POPL, January 11{13, 1989, Austin, TX, pages 89{104. ACM Press, 1989.
[27] C. Paulin-Mohring. Inductive de nitions in the system Coq: Rules and properties. In M. Bezem and J. F. Groote, editors, Proc. of the 1st Int. Conf. TLCA, volume 664 of Lecture Notes in Computer Science, pages 328{ 345, Berlin, 1993. Springer-Verlag.
[28] PROTHEO/LORIA.  The ELAN  homepage.  http://elan.loria.fr.
[29] Carnegie Mellon School of Computer Science. The twelf project. http://www-2.cs.cmu.edu/~twelf/.
[30] J. Stuber. Experiments with an implementation of Extended Narrowing And Resolution in the rewriting language ELAN (system description). Available at http://www.loria.fr/~stuber/software,  December  2000.
[31] A. Stump and D. L. Dill. Generating proofs from a decision procedure. In Proc. of Workshop on Run-Time Result Veri cation, July 1999. Available at http://sprout.Stanford.EDU/~stump.
[32] T. Tammet and J.M. Smith. Optimized encodings of fragments of type theory in rst-order logic. JLC: Journal of Logic and Computation, 8, 1998.
[33] R. Verma and S. Senanayake. LR2: A laboratory for rapid term graph rewriting. In P. Narendran and M. Rusinowitch, editors, Proc. 10th Int. Conf. RTA, volume 1631 of Lecture Notes in Computer Science, pages 252{255. Springer- Verlag, 1999.
[34] Centrum voor Wiskunde en Informatica (CWI). The ATerm homepage. http://www.cwi.nl/projects/MetaEnv/aterm/.
[35] W. Wong. Validation of HOL proofs by proof checking. Formal Methods in System Design: An International Journal, 14(2):193{212,	1999.
