Electronic Notes in Theoretical Computer Science 188 (2007) 21–35	
www.elsevier.com/locate/entcs

Formal Properties of Needed Narrowing with Similarity Relations1
Gin´es Moreno and Vicente Pascual2
Dep. of Computing Systems, U. of Castilla–La Mancha, 02071 Albacete, Spain

Abstract
The integration of declarative paradigms such as functional-logic and fuzzy-logic programming seems to be an interesting challenge in the design of highly expressive declarative languages where mathematical functions cohabit with fuzzy logic features. Starting with two representative languages from both settings, namely Curry and Likelog, we have recently proposed an hybrid dialect where a set of (Curry) rewrite rules together with a set of (Likelog) similarity equations can be safely executed by means of a fuzzy variant of
needed narrowing. This paper is devoted to show some important properties enjoyed by the new narrowing strategy. Firstly, we prove the termination of the process which determines the set of tuples that enable new narrowing steps for a given term. Termination in the fuzzy context is not trivial since, apart that it is required to compute the transitive closure of the initial set of similarity equations, it is also mandatory to ensure the finiteness of the set of recursive calls performed by the narrowing strategy, as well as that each call never falls into an infinite loop. From here, we prove two important (somehow complementary) properties, that we call crispness and fuzziness, respectively. The first one implies that the new strategy is (at least) conservative with respect to the original one of needed narrowing, in the sense that each tuple
obtained in the crisp case, is also replicated (with the maximum truth degree) in the fuzzy case. On the other hand, fuzziness means the maximality of the new strategy when exploiting (as much as possible) the similarity relations collected in a given program.
Keywords: Functional Logic Prog. Needed Narrowing, Similarity

Introduction
Fuzzy Logic Programming amalgamates fuzzy logic [8] and pure logic programming [6], in order to provide these pure logic languages with techniques or constructs to deal with uncertainty and approximated reasoning. Although there is no common method for introducing fuzzy concepts into logic programming, in this paper we are specially interested in the promising approach presented in [3,9], which basically consists in combining similarity relations with classical Horn clauses. Similarity relation is a mathematical notion strictly related with equivalence relations and closure operators, that provides a way to manage alternative instances of an entity

1 This work has been partially supported by the EU, under FEDER, and the Spanish Science and Education Ministry (MEC) under grant TIN 2004-07943-C04-03.
2 Emails:	{gmoreno,vpascual}@dsi.uclm.es

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.036

that can be considered ”equal” with a given degree [10]. A very simple, but effective way to introduce similarity relations into pure logic programming, generating one of the most promising ways for the integrated paradigm of fuzzy logic programming, consists in modeling them by a set of the so-called similarity equations of the form eq(s1, s2) = α, whith the intended meaning that s1 and s2 are predicate/function symbols of the same arity with a similarity degree α. This approach is followed, for instance, in the fuzzy logic language Likelog [3], where a set of usual Prolog clauses are accompanied by a set of similarity equations which play an important role at (fuzzy) unification time. Of course, the set of similarity equations is as- sumed to be safe in the sense that each equation connects two symbols of the same arity and nature (both predicates or both functions) and the properties required for similarity relations are not violated, as occurs, for instance, with the wrong set
{eq(a, b) = 0.5, eq(b, a) = 0.9} which, apart for introducing risks of infinite loops
when treated computationally, in particular,does not verify the symmetric prop- erty. It is important to note, that since Likelog is oriented to manipulate inductive databases, where no function symbols of arity greater than 0 are allowed, then, sim- ilarity equations only consider similarities between two predicates or two constants of the same arity. In this paper, we drop out this last limitation by also allowing similarity equations between any pair of (both defined or both constructor) function symbols with the same arity, which do not necessarily be constants. Moreover, we wish to remark again that, similarly to Likelog, no similarity equations are allowed between two symbols with different arity and/or nature (i.e, a constructor with a defined function symbol and viceversa).
Let us recall that a T-norm ∧ in [0, 1] is a binary operation ∧ : [0, 1] × [0, 1] → [0, 1] associative, commutative, non-decreasing in both arguments, and with the identity symbol 1. In order to simplify our developments, and similarly to other approaches in fuzzy logic programming [9], in the sequel, we assume that x ∧ y is equivalent to min(x, y), that is, the minimum between two elements x, y ∈ [0, 1], whereas x ∨ y and max(x, y) refers to the maximun operator. Both notations have a long presence in the specialized literature and help us to clarify expressions in recursive calculations. A similarity relation ঩ on a domain U is a fuzzy subset
঩ : U × U → [0, 1] of U × U such that, ∀x, y, z ∈ U, the following properties hold: reflexivity ঩(x, x) = 1, symmetry ঩(x, y)= ঩(y, x) and transitivity ঩(x, z) ≥
঩(x, y) ∧ ঩(y, z). In the following, we assume that the intended similarity relation
঩ associated to a given program R, is induced from the (safe) set of similarity equations of R, verifying that the similarity degree of two symbols s1 and s2 is
1 if s1 ≡ s2 or, otherwise, it is recSursively defined as the transitive closure of
the equational set defined as: T t(R)	Rf where Rf+1 = Rf ◦t R, for a given
r	f =1...∞
T-norm t. Moreover, it can be demonstrated that, if the domain is a finite set
with n elements, then only n-1 powers must be calculated [4]. Finally, by simply assuming that the set of similarity equations in R is trivially extended by reflexivity, then ঩ = Tr(R)= R(n−1) [4]. For instance, in the following pair of matrix, we are considering similarities between four arbitrary constant symbols. The second matrix

has been obtained from the first one after applying the algorithm described in [4].

⎛ 1 .7 .6 .4⎞
⎜.7 1 .8 .9⎟	R
⎛ 1 .7 .7 .7⎞
⎜.7 1 .8 .9⎟

−−−−−−→
⎜	⎟	⎜	⎟

.6 .8 1 .7
⎝.4 .9 .7 1 ⎠
Similarity
.7 .8 1 .8
⎝.7 .9 .8 1 ⎠

In what follows, we propose the combined use of similarity equations together with rewrite rules (instead of Horn clauses) typically used in languages (with a functional taste) such as Haskell or Curry. In this sense, it is important to note that, although there exists some precedents for introducing fuzzy logic into logic programming, to the best of our knowledge, our approach represents the first attempt for fuzzifying (integrated) functional-logic languages. We consider a signature Σ partitioned into a set C of constructors and a set F of deﬁned functions (also called operations). The set of constructor terms (with variables) is obtained by using symbols from C (and a set of variables X ). The set of variables occurring in a term t is denoted by Var(t). We write on for the list of objects o1,... , on. A pattern is a term of the form f (dn) where f /n ∈F and d1,... , dn are constructor terms (with variables). A term is linear if it does not contain multiple occurrences of one variable. A position p in a term t is represented by a sequence of natural numbers (Λ denotes the empty sequence, i.e., the root position). The set of positions of a term t is denoted by Pos(t). Positions are ordered by the preﬁx ordering: p ≤ q, if ∃w such that p.w = q. t|p and t↑p denote the subterm of t at a given position p, and the symbol rooting such subterm, respectively. t[s]p represents the result of replacing the subterm t|p by the term s. We denote by {x1 '→ t1,... , xn '→ tn} the substitution σ whose application to a term t is denoted by σ(t). A set of rewrite rules l → r such that l /∈ X , and Var(r) ⊆ Var(l) is called a term rewriting system (TRS). The terms l and r are called the left-hand side (lhs) and the right-hand side (rhs) of the rule, respectively. A TRS R is left-linear if l is linear for all l → r ∈ R. A TRS is constructor–based (CB) if each left-hand side is a pattern. In the remainder of this paper, a functional logic program is a left-linear CB-TRS without overlapping rules (i.e. the lhs’s of two different program rules do not unify). A rewrite step is an application of a rewrite rule to a term, i.e., t →p,R s if there exists a position p in t, a rewrite rule R = (l → r) and a substitution σ with t|p = σ(l) and s = t[σ(r)]p. Narrowing is a combination of variable instantiation and reduction. Formally, t ~p,R s is a
narrowing step if p is a non-variable position in t and σ(t) →p,R s.

The Original Needed Narrowing Strategy
Functional logic programming languages combine the operational principles of the most important declarative programming paradigms, namely functional and logic programming. The operational semantics of such languages is usually based on narrowing, where efficient demand-driven functional computations are amalgamated

with the flexible use of logical variables providing for function inversion and search for solutions. A challenge in the design of functional logic languages is the definition of a “good” narrowing strategy, i.e., a restriction on the narrowing steps issuing from a term without losing completeness.
Needed narrowing [2] is currently one of the best known narrowing strategies due to its optimality properties w.r.t. the length of the derivations and the number of computed solutions. It extends Huet and L´evy’s notion of a needed reduction [5]. The definition of needed narrowing uses the notion of a deﬁnitional tree [1], which refines the standard matching trees of functional programming. However, differ- ently from left-to-right matching trees used in either Hope, Miranda, or Haskell, definitional trees deal with dependencies between arguments of functional patterns. Roughly speaking, a definitional tree for a function symbol f is a tree whose leaves contain all (and only) the rules used to define f and whose inner nodes con- tain information to guide the (optimal) pattern matching during the evaluation of expressions. Each inner node contains a pattern and a variable position in this pattern (the inductive position) which is further refined in the patterns of its imme- diate children by using different constructor symbols. The pattern of the root node
is simply f (xn), where xn are different variables.
Example 2.1 It is often convenient and simplifies the understanding to provide a graphic representation of definitional trees, where each node is marked with a pattern, the inductive position in branches is surrounded by a box, and the leaves contain the corresponding rules. For instance, given the following program (right column) defining functions “f” and “g”, the definitional tree for f is:

f(
, Y)
/ 

R1 : f(a, N) → a

/
/ /	R2 : f(s(M), a) → b

f(a, Y) ≡ [R1]	f(s(X'),	)
// 
/
R3 : f(s(M), s(N)) → f(M, N)
R4 : g(a, N) → N

//	R5
: g(s(M), N) → s(g(M, N))

f(s(X'), a) ≡ [R2]	f(s(X'), s(Y')) ≡ [R3]
For the definition of needed narrowing, we assume that t ≡ f (sn) is an operation- rooted term and Pf is a definitional tree for f with root π such that π ≤ t. Hence, when π is a leaf, i.e., Pf = {π}, we have that R : π → r is a variant of a rewrite rule. On the other hand, if π is a branch, we consider the inductive position o of π and we say that the pattern πi ≡ π[ci(xn)]o ∈ Pf , is a child of π in Pf . Moreover, the definitional (sub-)tree of Pf rooted with πi, (i.e., where all patterns are instances
of πi) is denoted by Pπi = {π' ∈ Pf | πi ≤ π'}. We define now a function λcrisp
from terms to sets of tuples (position, rule, substitution) which uses an auxiliary function λc for explicitly referring to the appropriate definitional tree in each case. Then, λcrisp(t)= λc(t, Pf ) returns the least set satisfying:
LR (LEAF-RULE) CASE: λc(t, Pf )= {(Λ, R, id)}

BV (BRANCH-VAR) CASE: If t|o = x ∈ X , then λc(t, Pf )= {(p, R, σ ◦ τ ) |
πi ≡ π[ci(xn)]o ∈ Pf and τ = {x '→ ci(xn)} and (p, R, σ) ∈ λc(τ (t), Pπi )}
BC (BRANCH-CONS) CASE: If t|o = ci(tn), where ci ∈ C, then λc(t, Pf )= 
{(p, R, σ ◦ id) | πi ≡ π[ci(xn)]o ∈ Pf and (p, R, σ) ∈ λc(t, Pπi )}
BF (BRANCH-FUNC) CASE: If t|o = g(tn), where g ∈ F, then λc(t, Pf )= 
{(o.p, R, σ ◦ id) | (p, R, σ) ∈ λc(t|o, Pg)}
When none of the previous cases is satisfied, we assume that function λc returns
∅. Informally speaking, needed narrowing directly applies a rule if the term is an instance of some left-hand side (LR case), or checks the subterm corresponding to the inductive position of the branch: if it is a variable (BV case), it is instantiated to the constructor of each one of the children; if it is already a constructor (BC case), we proceed with the corresponding child; if it is a function (BF case), we evaluate it by recursively applying needed narrowing. Thus, the strategy differs from lazy functional languages only in the instantiation of free variables. In contrast to more traditional narrowing strategies, needed narrowing does not compute most general unifiers. In each recursive step during the computation of λc, we compose the current substitution with the local substitution of this step (which can be the identity id). As in proof procedures for logic programming, we assume that definitional trees always contain new variables if they are used in a narrowing step. Moreover, as introduced in Section 1, it is important to remember that, if σ is a substitution appearing in a tuple (p, R, σ) ∈ λcrisp(t), then σ only contains bindings for variables of t. So, the application of σ to t, enables the subsequent rewriting step at position p with rule R, that is, σ(t) →p,R s, which completes the corresponding needed

narrowing step. Then, t ~p,R
s is a needed narrowing step for all (p, R, σ) ∈

λcrisp(t).
Example 2.2 For instance, if we consider again the rules for f and g in Example 2.1 then we have λcrisp(f(X, g(X, X)))  =	{(Λ, R1, {X '→ a}),  (2, R5,
{X '→ s(X')})} which enables the following pair of needed narrowing steps:

f(X, g(X, X)) ~Λ,R1	a, and f(X, g(X, X)) ~2,R5
'	f(s(X'), s(g(X', s(X')))).

		{X'→a}		
{X'→s(X )}

Needed Narrowing with Similarity Relations
This section recalls from [7] the basis of our attempt for fuzzifying the needed narrowing strategy. For the definition of needed narrowing with similarity rela- tions, we extend the notion of computed answer for also reporting now (apart for the classical components of substitution and value), a real number in the interval [0, 1] indicating the similarity degree computed along the corresponding derivation. Hence, we define function λfuzzy from terms and definitional trees to sets of tu- ples (position, rule, substitution, similarity degree). If t ≡ f (sn) is the operation- rooted term we consider in the initial call to λfuzzy, we must guarantee that any term (including t itself), rooted with a symbol similar to f be will be treated. So, λfuzzy(t){(p, R, σ, min(α, β)) | ঩(f, g) = α and (p, R, σ, β) ∈ λf (g(sn), Pg}, where function λf is defined as follows:

LR (LEAF-RULE) CASE: λf (t, Pf )= {(Λ,π → r, id, 1)}
BV (BRANCH-VAR) CASE: if t|o = x ∈ X , then λf (t, Pf )= {(p, R, σ ◦ τ, α) |
πi ≡ π[ci(xn)]o ∈ Pf ,	τ = {x '→ ci(xn)} and (p, R, σ, α) ∈ λf (τ (t), Pπi )}
BC (BRANCH-CONS) CASE: if t|o = d(tn), where d ∈ C, then λf (t, Pf )= 
{(p, R, σ, min(α, β)) | ঩(d/n, ci/n)= α > 0 and πi ≡ π[ci(xn)]o ∈ Pf and (p, R, σ, β) ∈ λf (t[ci(tn)]o, Pπi )}

BF (BRANCH-FUNC) CASE: if t|o = g(tn), where g ∈ F, then λ(t, Pf )= {(o.p, R, σ, min(α, β))| ঩(g/n, h/n)= α > 0 and (p, R, σ, β) ∈ λ(h(tn), Ph)}
As we can see, LR and BV cases are very close to the corresponding ones analyzed in Section 2, but propagating now the corresponding similarity degrees. Moreover, closely related to the initial call to λfuzzy seen before, the last case (BF) performs recursive calls to λf for evaluating the operation–rooted subterm at the considered inductive position, as well as each other (almost identical) subterms rooted with defined function symbols similars to g. Something almost identical occurs with the BC case, but the intention now is to treat all subterms with constructor symbols similars to d at the inductive position.
Example 3.1 Consider again the same program of Example 2.1 augmented with the new rule R6 : h(r(X), Y) → r(Y) together with the similarity equations S1 : eq(g, h) = 0.7 and S2 : eq(s, r) = 0.5.  Then, λfuzzy(f(X, g(X, X))) = λf (f(X, g(X, X)), Pf)   =   {(Λ, R1, {X '→ a}, 1), (2, R5, {X '→ s(X')}, 1), (2, R6,
{X '→ s(X')}, min(0.7, 0.5))} = [see BV1] ∪ [see BV2].
BV1.  The first alternative in this BV case, consists in generating the bind- ing τ1 = {X '→ a} and then computing λf(τ1(f(X, g(X, X))), Pf(a,Y)) = λf(f(a, g(a, a)), Pf(a,Y)).  Since this last call represents a LR case, it returns
{(Λ, R1, id, 1)}. Then, after applying the binding τ1 to the third element of this last tuple, the returned set for this case is {(Λ, R1, {X '→ a}, 1)}.
BV2.  After generating the second binding τ2 = {X '→ s(X')}, we must com-

f(s(X'),Y)
'	'	'
f(s(X'),Y)

pute λf(τ2(f(X, g(X, X))), Pf	) = λf(f(s(X ), g(s(X ), s(X ))), Pf	) = 
{(2, R5, id, 1), (2, R6, id, min(0.7, 0.5))}= [see BF1 below]. Now, we simply need to apply τ2 to the last component of the tuples obtained in BF1, hence returning
{(2, R5, {X '→ s(X')}, 1), (2, R6, {X '→ s(X')}, min(0.7, 0.5))}.
BF1. In this BF case, where the considered inductive position is 2, we per- form the following two recursive calls (observe that the second one exploits the similarity equation S1 and it would not be performed in the crisp case): λf (g(s(X'), s(X')),  Pg) ∪ λf (h(s(X'), s(X')),  Ph) = [see BC1]  ∪  [see BC2]
{(Λ, R5, id, 1), (Λ, R6, id, 0.5)}. And then, since obviously position Λ.2 coincides directly with position 2, and the similarity between g and h is 0.7, the set of tuples returned in this case is {(2, R5, id, 1), (2, R6, id, min(0.7, 0.5))}.
BC1.    This  BC  case,  immediately  evolves  to  the  following  LR  case:
λ (g(s(X'), s(X')),  Pg(s(M),N)) = {(Λ,R , id, 1)}.	Now, since ঩(s, s) = 1, and
f	g	5
min(1, 1) = 1, the returned tuple in this case is (Λ, R5, id, 1) itself.

BC2. By exploiting the similarity equation S2 : eq(s, r) = 0.5, this BC case also computes the LR case λf (h(r(X'), s(X')), Ph(r(X),Y)) = {(Λ, R6, id, 1)} and since
min(0.5, 1) = 0.5, then λf (h(s(X'), s(X')), Ph)= {(Λ, R6, id, 0.5)}.
Inspired by the schema used in [2], the following diagram reproduces the previous explanation in a concise, but precise manner:


λ	(f(X, g(X, X))) = ··· 
⎛	⟨Λ, R1, {X '→ a}, min(1, 1)⟩	⎞⎟

fuzzy
⟨2, R5, {X '→ s(X )}, min(1, 1)⟩
⟨2, R6, {X '→ s(X')}, min(1, 0.5)⟩






[BV]	λ (f(X, g(X, X)), P )= ··· 
⟨Λ, R1, {X '→ a}, 1)⟩
'

f	f	⟨2, R , {X '→ s(X )}, 1)⟩
 ⟨2, R6, {X '→ s(X')}, 0.5)⟩ 

f
'

[BF]	λ (f(s(X'), g(s(X'), s(X'))), Pf(s(X ),Y))= ··· 
⟨2, R5, id, min(1, 1)⟩

⟨2, R6, id, min(0.7, 0.5)⟩
[BC]	λf(g(s(X'), s(X')),  Pg)= ···	⟨Λ, R5, id, min(1, 1)⟩

[LR]	λ (g(s(X'), s(X')), Pg(s(M),N))=	⟨Λ, R
, id, 1⟩

f	g	5
[BC]	λf(h(s(X'), s(X')),  Ph)= ···	⟨Λ, R6, id, min(0.5, 1⟩
[LR]	λf(h(r(X'), s(X')), Ph(r(X),Y))=	⟨Λ, R6, id, 1⟩

As our example reveals, there are three important properties enjoyed by our ex- tended definition of needed narrowing: 1) the set of recursive calls performed during the computation of λfuzzy is finite and terminating, 2) λfuzzy is conservative w.r.t. λcrisp since, the first two tuples computed before are the same to those ones obtained in the crisp case (see example 2.2), but accompanied now with the maximum truth degree 1, and 3) similarity equations between defined/constructor function symbols are exploited as much as possible (in the initial call and BF/BC cases), which is the key point to obtain the third tuple in our example. In the following, we formally prove all these properties.

Termination
We start this section by introducing some auxiliary concepts which will be very help- ful when formulating/proving our main results. Intuitively, we say that two terms t and t' which contain exactly the same set of positions, that is, Pos(t)= Pos(t'), are similar if each pair of symbols rooting two (non-variable) subterms at the same posi- tion in both terms are similars w.r.t. ঩. In symbols, ∀p ∈ Pos(t), ঩(t↑p , t'↑p) > 0. An special case appears when comparing two variable subterms, where we require that both subterms be exactly the same variable. This implies the need for ap- plying and appropriate variable renaming on both terms before comparing them. For instance, terms f (X, X) and g(D, D), after being renamed become f (A, A) and g(A, A), respectively, and then they can be considered similar if ঩(f, g) > 0. On

the other hand, f (X, X) and f (Z, Y ), become after renaming f (A, A) and f (A, B), and they can never be considered similar terms. Moreover, the similarity degree α of two similar terms is defined as the minimum one among all the similarities exploited in the calculus, that is α = minp∈Pos(t) ঩(t↑p , t'↑p). We formalize this notion by means of the following recursive definition:
Definition 4.1 [Similar Terms] Two terms t and t' (whose variables have been appropriately renamed) are similar with similar degree α if Sim(t, t') = α > 0, where function Sim is recursively defined as:



Sim(t, t') = ⎪⎪⎨
⎪⎪⎪⎩
.., Sim(un, vn))	f, g ∈ (C ∪ F) and ঩(f, g)= β > 0
1	if t and t' are the same variable
0	otherwise


The previous definition extends the similarity relation ঩ between symbols, to simi- larity between terms, and it represents a nice measure that can be calculated at a purely syntactic level (before performing any kind of evaluation process based on rewriting/narrowing). Moreover, it enjoys the following property.
Lemma 4.2 Function Sim represents a well deﬁned similarity relation between terms, verifying the properties of reflexivity, symmetry and transitivity.
Proof.
Reflexivity: Sim(t, t)= 1. Obvious by Definition 4.1 of Sim.
Symmetry: Sim(t, s)= Sim(s, t). This result is again trivially derived from the Symmetry of ঩ and Definition 4.1.
min-Transitivity: Sim(t, s) ≥ (Sim(t, t') ∧ Sim(t', s)). From definition 4.1 we have that:
Sim(t, s)= mini(঩(t↑i, s↑i)) = mini{M axj[঩(t↑i, t'↑j ) ∧ ঩(t'↑j, s↑i)]}≥ 
mini(঩(t↑i, t'↑i) ∧ ঩(t'↑i, s↑i)) = mini(঩(t↑i, t'↑i)) ∧ mini(঩(t'↑i, s↑i)) =
Sim(t, t') ∧ Sim(t', s).

The following definition will largely help us to prove by induction all the properties of our fuzzified version of needed narrowing. Inspired by [2], we extend their notion of Noetherian ordering ≺ between tuples of terms and definitional (sub-)trees 3 by taken also into account the presence of similarities among terms in the new fuzzy setting.

3 This ordering is very useful in induction-based proofs for λc(t, P) and λf (t, P), since both strategies compute tuples throughout an interleaved descent down both t and P.

Definition 4.3 We define the Noetherian ordering ≺ over the cartesian product of
T erms × (sub−)Trees as follows:


(t, P) ≺ (t', P') ⇔
b) There exists a (possibly empty) substitution σ, such
⎪⎩that Sim(t, σ(t')) > 0 and P is a proper sub-tree of P'

The first case of our definition corresponds exactly with the homologous one pre- sented in [2], and it is very useful in our proofs when dealing with BF. Moreover, the second case generalizes the associated one in the same paper, but taking now into account the specificities introduced in the new fuzzy setting by similar terms. This last case will be applied when analyzing BV and BC cases, as we are going to see in the following proof of our first theorem.
Theorem 4.4 (Termination) Given an operation-rooted term t, the evaluation of λfuzzy(t) terminates in a ﬁnite time.

Proof. As defined in Section 3, the initial call to λfuzzy(f (tn)) generates a set of calls of the form λf (gi(tn), Pgi ) where each gi is a symbol verifying ঩(gi,f ) > 0. This set of calls is finite due to the proper finiteness of ঩. So, our goal simply consists in proving that each call to λf eventually terminates. The proof is made by induction on the ordering introduced in Definition 4.3.
Base Case. This case, which corresponds to the so called LR case of the definition of λf shown in Section 3, is trivial since no recursive calls are performed.
Induction step. Now, we consider the three subcases of the definition of λf for branch nodes:
BV case. In order to evaluate λf (t, P) in a BV case, a set of n calls of the form λf (τ (t), Pπi ) are performed, being n the number of children of the root of P. Since condition b in Definition 4.3 implies that (τ (t), Pπi ) ≺ (t, P), then the claim follows by the inductive hypothesis.
BC case. This case is very close to the previous one, but now only a few (not all) children of the root of P are exploited. More exactly, λf (t, P) performs a finite set of calls of the form λf (ti, Pπi ) such that t and ti are exactly the same terms except for the constructor symbols rooting subterms at the inductive position o in both terms. Moreover, ঩(t↑o, ti↑o)= α > 0, and then Sim(t, ti)= α > 0. So, by the second condition in Definition 4.3 we have that (ti, Pπi ) ≺ (t, P), which let us to confirm our claim by the inductive hypothesis.
BF case. The evaluation of λf (t, P) in a BF case, generates a finite set of recursive calls in a similar way to the initial call to λfuzzy, but the main difference now is that each new call uses as first parameter a proper subterm of t. Since t is an operation rooted term, obviously t|o has less defined operation symbols than t (at least the first occurrence of the operation symbol rooting t has been removed in t|o). This satisfies the first condition of the ≺ ordering, and concludes our proof by the inductive hypothesis.
 

To finish this section, it is important to remember the following remark we in- troduced in the preliminaries section. In order to avoid the risk of infinite loops associated to the intrinsic (reflexive, symmetric and transitive) properties of simi- larity relations, we avoid the direct use of similarity equations in our definition of λfuzzy. Instead of this, we prefer to compute the transitive closure of such set of similarity equations, thus obtaining the finite similarity relation ঩ which can be safely accessed from λfuzzy without harming the termination property we have just proved.

Crispness
This section is devoted to prove a kind of correctness result (both soundness and completeness) enjoyed by λfuzzy when compared with λcrisp. The idea is to show that our fuzzy strategy is conservative w.r.t. the crisp case. In this sense, observe in Example 3.1 that tuples ⟨Λ, R1, {X '→ a}⟩ and ⟨2, R5, {X '→ s(X')}⟩, obtained by λcrisp, are also replicated by λfuzzy with the maximum truth degree 1, which implies a sort of crisp-completeness. On the other hand, whereas λfuzzy produces three tuples, only two of them (except ⟨2, R6, {X '→ s(X')}, 0.5⟩) have the maximum truth degree 1, but these tuples are also generated in the crisp case, which represents a kind of crisp-soundness related to tuples with maximum truth degree. The following theorem formalizes this property.
Theorem 5.1 (Crispness) For any operation-rooted term t, we have that: Crisp-Completeness. If ⟨p, R, σ⟩∈ λcrisp(t) then ⟨p, R, σ, 1⟩ ∈ λfuzzy(t).
Crisp-Soundness. If ⟨p, R, σ, 1⟩ ∈ λfuzzy(t) and there is no similarity relations with truth degree 1 apart from the reflexive one, then ⟨p, R, σ⟩∈ λcrisp(t).
Proof. We consider each claim separately, assuming that t = f (tn):
Crisp − Completeness. Our goal is to show how tuple ⟨p, R, σ⟩ ∈ λcrisp(t) can be also obtained in the fuzzy case by applying λfuzzy(t). We know that by the definition of λcrisp shown in Section 2, λcrisp(t)= λc(t, Pf ) and also by the definition of λfuzzy shown in Section 3, λfuzzy(t) makes at least the call λf (t, Pf ) since ঩(f, f ) = 1 (being f the defined function symbol rooting term t). So, we must prove that if
⟨p, R, σ⟩ ∈ λc(t, Pf ) then ⟨p, R, σ, 1⟩ ∈ λf (t, Pf ). The proof is made by induction on the Noetherian ordering ≺ while considering the different cases of the definition of λc.
Base Case. This case corresponds to the so called LR case of the definition of λc shown in Section 2, where the associated definitional tree Pf = {π} only contains a pattern (leaf-rule node) and no recursive calls are performed. Then λc(t, Pf )= {⟨p, R, σ⟩} and by the definition of λf shown in Section 3, we directly conclude with λf (t, Pf )= {⟨p, R, σ, 1⟩}, as we wanted to prove.
Induction step. We consider now the three subcases of the definition of λc shown in Section 2, for branch nodes:
BV case. Here t|o = x ∈ X , and there exists a pattern πi ≡ π[ci(xn)]o ∈ Pf

and a substitution τ = {x '→ ci(xn)}, such that, after performing the recursive call λc(τ (t), Pπi ), we obtain (p, R, θ) and hence, λc(t, Pf ) returns the intended tuple (p, R, σ) where σ = θ ◦ τ . By the inductive hypothesis (condition b in Definition 4.3 is fulfilled since the recursive call is done with an instance of t, and a proper sub-tree of Pf ) λf (τ (t), Pπi ) also generates tuple (p, R, θ, 1), and finally, by the definition of λf shown in Section 3, λf (t, Pf ) returns the intended tuple (p, R, σ, 1), as we wanted to prove.
BC case. This case is very similar to the previous one. Now, we have that t|o = ci(tn), where ci ∈ C, and there exists a pattern πi ≡ π[ci(xn)]o ∈ Pf such that, after performing the recursive call λc(t, Pπi ), we obtain (p, R, σ) and hence, λc(t, Pf ) returns the intended tuple (p, R, σ) (since σ = σ ◦ id). The inductive hypothesis is now applicable in the same way than the previous case (observe that the recursive call is done with the same term, which always can be considered an instance of itself, and an smaller sub-tree) so λf (t, Pπi ) also generates the tuple (p, R, σ, 1). This implies that by the definition of λf shown in Section 3, λf (t, Pf ) returns the tuple (p, R, σ, min(α, 1)), and since α = ঩(ci, ci) = 1, the resulting tuple (p, R, σ, 1) belongs to λf (t, Pf ).
BF case. Now, t|o = g(sm), where g ∈ F, and there exists a definitional tree
Pg for g such that, after performing the recursive call λc(t|o, Pg), we obtain (q, R, σ) and hence, λc(t, Pf ) returns the intended tuple (p, R, σ), where p = o.q and σ = σ ◦ id. The inductive hypothesis is applicable here since the recursive call is made with the proper subterm of t, t|o (which obviously contains less defined functions symbols than t and hence satisfies condition a of Definition 4.3). So, λf (t|o, Pg) also generates the tuple (q, R, σ, 1). By the definition of λf shown in Section 3, λf (t, Pf ) makes at least a recursive call to λf (t|o, Pg), due to the fact that ঩(g, g) = 1, and hence, it returns the tuple (p, R, σ, min(1, 1)), which obviously is (p, R, σ, 1), as wanted.

Crisp − Soundness. This proof is very similar to the previous one, by sim- ply reverting the reasoning in each case and assuming that the unique similar- ity relations exploited by λfuzzy are the reflexive ones, that is, those of the form
঩(f, f )= 1, ∀f ∈ (C∪ F).	 

As a final remark, we illustrate by a simple example the need for requiring that no similarity equations of the form eq(f, g) = 1 belongs to a given program, if we really want to preserve the crisp-soundness of λfuzzy. Given a program composed by the single rewrite rule R : f(a) → a and the single similarity equation E : eq(f, g)= 1, then λfuzzy(g(a)) = {⟨Λ, R1, id, 1⟩} whereas λcrips(g(a)) = ∅. Fortunately, these cases are not usual in practice, and moreover, in the worst case, the original program often admits a transformation process (we are nowadays working in its automation) that removes those risky similarity equations and replaces them by a set of rewrite rules without altering the program meaning (for instance, in the previous case it suffices by replacing equation E by rule R : g(a) → a to recover the previously lost crisp-soundness).

Fuzziness
In this section we prove our last property related to λfuzzy, which is conceived as a complementary result of the previous property. In fact, the fuzzy strategy not only is conservative w.r.t. the crisp one, but also it is able to exploit the similarity relation ঩ as much as possible when evaluating λfuzzy. In doing this, we need the following instrumental result showing that, when we consider two identical terms with the exception that they have two different, but similar, symbols at a given position p, they produce the same set of tuples (except for their truth degrees) when being evaluated with λfuzzy.
Lemma 6.1 (Similar Symbols Replacement) Let t and t' be two opera- tion rooted terms with Pos(t) = Pos(t') such that, for a given position p ∈ Pos(t), we have: t|p = s(o), t'|p = s'(o), t' = t[s'(o)]p, and ঩(s, s') > 0. Then, ⟨p, R, σ, α⟩ ∈ λfuzzy(t) if and only if ⟨p, R, σ, α'⟩∈ λfuzzy(t').
Proof. Due to the reflexivity, symmetry and transitivity of the similarity relation
঩, we have that, if ঩(s, s') > 0, then for any other symbol s'', it is verified that
঩(s, s'') = β > 0 if and only if ঩(s', s'') = β' > 0. In other words, if we denote by S(s) the set of symbols {si ∈ (C ∪ F) | ঩(s, si) > 0}, then S(s) = S(s'). On the other hand, if t and t' are the same terms with the exception that they have different, but similar symbols (say s and s'), at a given position p, we have that the sets of tuples returned by λfuzzy(t) and λfuzzy(t') do coincide in the case that position p is never considered as an inductive position in any recursive call to λf . Otherwise, we have the following cases:
The intended position p is the top position Λ. Then, By the definition of λfuzzy
shown in Section 3, λfuzzy(s(o)) performs exactly the same set of calls to λf than
λfuzzy(s'(o)), say λf (si(o), Ps ), for all si ∈ S(s). Now, if ⟨q, R, σ, γ⟩ ∈ λf (si(o)),
then ⟨q, R, σ, min(঩(s, si), γ)⟩ ∈ λfuzzy(s(o)) and ⟨q, R, σ, min(঩(s', si), γ)⟩ ∈
λfuzzy(s'(o)), which confirms our claim in this case.
The intended position p is eventually considered as an inductive position in a BC case. Then, by the definition of λf shown in Section 3, λf (t[s(o)]p, P) per- forms exactly the same set of recursive calls than λf (t[s'(o)]p, P), by using as first arguments terms of the form t[si(o)]p, for all si ∈ S(s). So, similarly to the previous case, if ⟨q, R, σ, γ⟩ ∈ λf (t[si(o)]p, Pπi ), then ⟨q, R, σ, min(঩(s, si), γ)⟩ ∈ λf (t[s(o)]p, P) and ⟨q, R, σ, min(঩(s', si), γ)⟩ ∈ λf (t[s'(o)]p, P) too, which con- firms our claim once again.
The intended position p is eventually considered as an inductive position in a BF case.  Our last case has many similarities with the two previ- ous ones. Now, by the definition of λf shown in Section 3, λf (t[s(o)]p, Ps) performs exactly the same set of recursive calls than λf (t[s'(o)]p, Ps' ), that is λf (si(o), Psi ), for all si ∈ S(s).  So, if ⟨q, R, σ, γ⟩ ∈ λf (si(o), Psi ), then ⟨p.q, R, σ, min(঩(s, si), γ)⟩ ∈ λf (t[s(o)]p, Ps) and it is also verified that
⟨p.q, R, σ, min(঩(s', si), γ)⟩ ∈ λf (t[s'(o)]p, Ps' ), which finishes our proof.
 

Next lemma extends the previous one by considering multiple similar symbols re- placements (instead of a single symbol) when comparing the evaluation of λfuzzy with two similar terms.
Lemma 6.2 (Similar Subterms Replacement) Let t and t' be two operation rooted terms with Pos(t) = Pos(t') such that, for a given position p ∈ Pos(t), we have: t|p = s, t'|p = s', t' = t[s']p, and Sim(s, s') > 0. Then, ⟨p, R, σ, α⟩ ∈ λfuzzy(t) if and only if ⟨p, R, σ, α'⟩∈ λfuzzy(t').
Proof. The result is easily obtained by repeatedly applying Lemma 6.1.	 
Finally, we are now ready to prove our main result in this section.
Theorem 6.3 (Fuzziness) Let t and t' be two operation rooted terms, such that
Sim(t, t') > 0. Then, ⟨p, R, σ, α⟩ ∈ λfuzzy(t)  iff  ⟨p, R, σ, α'⟩∈ λfuzzy(t').
Proof. This theorem directly follows from the previous result, by simply consider- ing that the intended position p used in the formulation of Lemma 6.2, is the top position Λ.	 
Example 6.4 Going back again to Example 3.1 and denoting now with αrs and αh,g to ঩(r, s) and ঩(h, g), respectively, it is easy to see that any pair of terms t and t' chosen among g(s(X), X), g(r(X), X), h(r(x), x) and h(s(x), x) verify Sim(t, t') > 0. The following diagrams reproduce the evaluation of λfuzzy for each one of the previous terms for illustrating our fuzziness result:
λ   (g(s(X), X)) = ···	⟨1, R5, id, 1⟩
⟨1, R6, id, αhg⟩

[BC]	λ (g(s(X), X), Pg(s))= ···	⟨1, R , id, 1⟩
f	g	5
g(s(X' ),Y)
[LR]	λf(g(s(X), X), Pg	)=	⟨1, R5, id, 1⟩
[BC]	λf(h(s(X), X), Ph)= ···	⟨1, R6, id, αhg⟩
h(s(X' ),Y)
[LR]	λf(h(s(X), X), Ph	)=	⟨1, R6, id, 1⟩
λ	(g(r(X), X)) = ···	⟨1, R5, id, αrs⟩
⟨1, R6, id, αhg⟩

[BC]	λf(g(r(X), X), Pg)= ···	⟨1, R5, id, αrs⟩
g(s(X' ),Y)
[LR]	λf(g(s(X), X), Pg	)=	⟨1, R5, id, 1⟩
[BC]	λ(h(r(X), X), Ph)= ···	⟨1, R6, id, αhg⟩
h(r(X' ),Y)
[LR]	λf(h(r(X), X), Ph	)=	⟨1, R6, id, 1⟩
λ	(h(r(X)), X)) = ···	⟨1, R6, id, 1⟩
⟨1, R5, id, αhg ∧ αrs⟩

[BC]	λf(h(r(X)), X), Ph)= ···	⟨1, R6, id, 1⟩
h(r(X' ),Y)
[LR]	λf(h(r(X), X), Ph	)=	⟨1, R6, id, 1⟩
[BC]	λf(g(r(X)), X), Pg)=	⟨1, R5, id, αrs⟩
g(s(X' ),Y)
[LR]	λf(g(s(X), X), Pg	)=	⟨1, R5, id, 1⟩

λ	(h(s(X), X)) = ···	⟨1, R6, id, αrs⟩
⟨1, R5, id, 1⟩
[BC]	λf(h(s(X), X), Ph)= ···	⟨1, R6, id, αrs⟩
h	'
[LR]	λf(h(r(X), X), Ph(r(X ),Y))=	⟨1, R6, id, 1⟩
g	h
[BC]	λf(g(s(X), X), Pg )= ···	⟨1, R5, id, 1⟩
[LR]	λ (g(s(X), X), Pg(s(X' ),Y))=	⟨1, R , id, 1⟩
f	5

Conclusions and Future Work
In this paper we have been concerned with the first attempt for introducing fuzzi- ness into functional-logic programming that we proposed in [7], where we provided (both the syntax and the operational semantics of) an hybrid functional-fuzzy-logic language combining the functional-logic properties of Curry with the fuzzy-logic fea- tures of Likelog. From here, we have reinforced the original idea that a set of rewrite rules together with a set of similarity equations can be successfully processed by using an extended version of needed narrowing which has the extra ability of dealing with similarity relations. Focusing on the new fuzzy narrowing strategy represented by function λfuzzy, we have demonstrated its capability not only for simulating the crisp version described by λcrisp, but also for capturing the similarities collected in a given program as much as possible without harming its termination properties. We think that the set of results we have just formalized and proved in this paper are not only relevant by themselves, but also, and what is better, they seem to be crucial for proving new soundness/completeness results of the fuzzified version of needed narrowing with respect to a new declarative semantics in which we are work- ing nowadays. In this sense, it must be clear that the denotation we are looking for, is not an application from (ground) expressions to data terms. Rather than this, in the fuzzy setting, we think that it seems more natural to associate fuzzy sets (modeled as pairs composed by a data term together with its corresponding truth degree) to a given initial (ground) term, which, among other things, implies a sub- sequent re-formulation of the notion of confluence typically used in pure functional and functional-logic programming.

References
S. Antoy. Definitional trees. In Proc. of the 3rd Int’l Conference on Algebraic and Logic Programming, ALP’92, pages 143–157. Springer LNCS 632, 1992.
S. Antoy, R. Echahed, and M. Hanus. A needed narrowing strategy. In Journal of the ACM, volume 47(4), pages 776–822, 2000.
F. Arcelli and F. Formato. Likelog: A logic programming language for flexible data retrieval. In Proc. of the ACM Symp. on Applied Computing (SAC’99), pages 260–267. ACM, Artificial Intelligence and Computational Logic, 1999.
L. Garmendia and A. Salvador. Comparing transitive closure with other new T-transitivization methods. In Proc. Modeling Decisions for Artificial Intelligence, pages 306–315. Springer LNAI 3131, 2004.

G. Huet and J.J. L´evy. Computations in orthogonal rewriting systems, Part I + II. In J.L. Lassez and
G.D. Plotkin, ed., Computational Logic. Essays in Honor of Alan Robinson, pages 395–443. The MIT Press, Cambridge, MA, 1992.
J.W. Lloyd. Foundations of Logic Programming. Springer-Verlag, Berlin, 1987.
G. Moreno and V. Pascual. Programming with Fuzzy–logic and Mathematical Functions. In I. Bloch,
A. Petrosino, and A. Tettamanzi, editors, Proc. of the 6th. International Whorshop on Fuzzy Logic and Applications, WILF’05, University of Milan, Crema (Italy), pages 89–98. Springer LNCS 3849, 2006.
H.T. Nguyen and E.A. Walker. A First Course in Fuzzy Logic. Chapman & Hall/CRC, Boca Rat´on, Florida, 2000.
M.I. Sessa. Approximate reasoning by similarity-based SLD resolution. Fuzzy Sets and Systems, 275:389–426, 2002.
L. A. Zadeh. Similarity relations and fuzzy orderings. Inf. Sci., 3:177-200, 1971.
