	Electronic Notes in Theoretical Computer Science 190 (2007) 95–110	
www.elsevier.com/locate/entcs

Exogenous Probabilistic Computation Tree Logic
Pedro Baltazar1 ,6	Paulo Mateus2 ,6
Security and Quantum Information Group, Institute for Telecommunications and Instituto Superior T´ecnico, Universidade T´ecnica de Lisboa, Lisbon, Portugal
Rajagopal Nagarajan3 ,5	Nikolaos Papanikolaou4 ,5
Department of Computer Science, University of Warwick, Coventry, England

Abstract
We define a logic EpCTL for reasoning about the evolution of probabilistic systems. System states corre- spond to probability distributions over classical states and the system evolution is modelled by probabilistic Kripke structures that capture both stochastic and non–deterministic transitions. The proposed logic is a temporal enrichment of Exogenous Probabilistic Propositional Logic (EPPL). The model-checking prob- lem for EpCTL is analysed and the logic is compared with PCTL; the semantics of the former is defined in terms of probability distributions over sets of propositional symbols, whereas the latter is designed for reasoning about distributions over paths of possible behaviour. The intended application of the logic is as a specification formalism for properties of communication protocols, and security protocols in particular; to demonstrate this, we specify relevant security properties for a classical contract signing protocol and for the so–called quantum one–time pad.
Keywords: stochastic process, Kripke structure,CTL, PCTL, EPPL


Introduction
There are numerous applications in science where reasoning about probabilistic be- haviour is necessary. In computing, applications include probabilistic algorithms,

1 Email: pbtz@math.ist.utl.pt
2 Email: pmat@math.ist.utl.pt
3 Email: biju@dcs.warwick.ac.uk
4 Email: nikos@dcs.warwick.ac.uk
5 Partially supported by the EU Sixth Framework Programme (Project SecoQC: Development of a Global Network for Secure Communication based on Quantum Cryptography ).
6 Partially supported by FCT and EU FEDER, namely via CLC POCTI (Research Unit 1-601), QuantLog project POCI/MAT/55796/2004 and the recent QSec initiative of SQIG-IT. Pedro Baltazar also supported by FCT and EU FEDER PhD fellowship SFRH/BD/22698/2005.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.07.007

computer modelling and verification of probabilistic systems, including communica- tion protocols with and without security guarantees. The properties of probabilistic programs in particular have been studied before using many different approaches, and it is widely accepted that the development of formal logics for reasoning about such programs is highly beneficial, allowing designers and users of systems to for- mulate properties which the programs may or may not satisfy.
In this paper we describe a temporal probabilistic logic, EpCTL. Our approach is characterised by the use of an exogenous semantics, such that the models of state formulas are essentially probability distributions of models of a propositional logic. We build atop earlier work on the probabilistic state logic EPPL [24] by introducing a temporal extension; the result is a branching time logic for reasoning about probabilistic programs. Our intention is to provide a powerful framework for specifying properties of communication protocols, especially security protocols. The proposed logic has enough expressive power to allow specification of relevant security properties, and enables high–level reasoning due to the use of an exogenous semantics.
The exogenous semantics approach [25] involves taking the semantic structures of a base logic (e.g. propositional logic) and combining them together, possibly adding new structure, to provide the semantics for a higher-level logic. This approach has been used to build the probabilistic state logic EPPL and also a logic EQPL for reasoning about states of quantum information systems. The exogenous semantics approach can be considered a variant of the possible-worlds approach of Kripke for modal logic [18], and it is related to the society semantics introduced in [8] for many-valued logic and to the possible translations semantics proposed in [7] for paraconsistent logic.
This paper is structured as follows. First we examine the syntax, semantics, model–checking problem and axiomatisation of the state logic EPPL. We then de- scribe each of these aspects in turn for the temporal extension, namely the new logic EpCTL, and provide intuition for the various constructs. Proofs of theorems have been relegated to the Appendix.
Logic of Probabilistic States - EPPL
The state logic of temporal logics like CTL [13], LTL [29] and CTL* [11] is clas- sical propositional logic. Probabilistic temporal extensions, like PCTL [16], also use classical propositional logic for state logic. Here we consider quite a different state logic, exogenous probabilistic propositional logic (EPPL) [23,25,9,24], which was highly inspired by the works of Halpern et al. [15]. Given the envisaged appli- cation to model–checking, we consider only models over a finite set of propositional symbols Φ, which can be understood as Boolean registers (bits) that constitute the internal state of a protocol or an algorithm. In this setting an EPPL model, that
henceforth we will call a probabilistic structure, is a pair (V, μ) where V is a set of classical valuations 7 over Φ and μ is a map μ : V → [0, 1] where Σv∈V μ(v) = 1.

7 Recall that a classical valuation over Φ is a map v :Φ → {0, 1}.

For a model (V, μ) we call V the set of possible valuations, and μ the probability measure. Observe that μ can be extended to all valuations by assuming that impos- sible valuations are improbable, i.e, μ(v) = 0 for any v ∈V \ V where V is the set of
all valuations over Φ. Finally, it will be useful to consider the probability measure , where μ is defined over sets of valuations, (V, 2V , μ) and μ(U )= Σv∈U μ(v) for any U ⊆ V.
Example 2.1 Consider a variant of the Russian roulette game, where the gambler tosses a coin and if the outcome is heads, the gun is fired. Assume also that the gambler has 1/6 probability of shooting a bullet. We describe the system with three propositional symbols h (heads), b (bullet was shot), d (gambler is dead). The pos- sible valuations described as sets of propositional symbols are: ∅ (all propositional symbols are false, the outcome of the coin was not heads); {h} (the outcome of the coin was heads but no bullet was shot); and {h, b, d} (the outcome of the coin was heads, a bullet was shot and the gambler is dead). The probability measure is μ(∅)= 1/2, μ({h})= 5/12 and μ({h, b, d})= 1/12.
We continue by describing the syntax of the logic.
Language
The language consists of formulas at two levels. The formulas at the first level, classical formulas, enable reasoning about propositional symbols. The formulas at the second level, probabilistic state formulas, enable reasoning about probabilistic structures. There are also probability terms used in probabilistic state formulas to denote real numbers. The syntax of the language, expressed using BNF notation, is as follows.
Classical formulas
γ := Φ ▢ ⊥ ▢ (γ ⇒ γ)
Probability terms
p := 0 ▢ 1 ▢ y ▢ ( γ) ▢ (p + p) ▢ (p p)
Probabilistic state formulas
ξ := ( γ) ▢ (p ≤ p) ▢ ⊥⊥ ▢ (ξ ⊃ ξ)
The classical state formulas, ranged over by γ, γ1,.. ., are built from the propo- sitional symbols Φ and the classical disjunctive connectives ⊥ (falsum) and ⇒ (im- plication). As usual, other classical connectives (¬, ∨, ∧, ⇔) are introduced as ab- breviations. For instance, (¬ γ) stands for (γ ⇒ ⊥).
The probability terms, ranged over by p, p1,.. ., denote elements of the reals. We also assume a set of variables, Y = {yk : k ∈ N}, ranging over the reals. The
The probabilistic state formulas, ranged over by ξ, ξ1,.. ., are built from the
necessity formulas ( γ), the comparison formulas (p1 ≤ p2) and the connectives ⊥⊥

8 Recall that a probability measure is a triple (Ω, F , μ) where F is a σ-algebra over Ω and μ is a measure where μ(Ω) = 1. Given the finitary assumption over Φ, in this paper we will always have Ω to be V and F to be the powerset of V.

and ⊃. The formula ( γ) is true when γ is true of every possible valuation in the semantic structure. Other probabilistic connectives (g, ∪, ∩, ≈) are introduced as abbreviations. For instance, (g ξ) stands for (ξ ⊃ ⊥⊥). We shall also use ( γ) as an abbreviation for (g( (¬ γ))). Please note that the and are not modalities 9 . We also use any algebraic real number as a constant since the langu√age of EPPL
has enough expressiveness to specify these constants. For instance,	2 ≤ y1 can
be written as (y2y2 = (1 + 1) ∩ y2 ≥ 0) ⊃ y2 ≤ y1. We will use subtraction and division freely since they can also be expressed in EPPL, for instance x/y = −2 can be written as ((z +∫ (1+ 1) = 0) ∩ (g(y = 0))) ⊃ ∫x = y · z. Fin∫ally, the conditional
probability term ( γ1|γ2) is an abbreviation of ( (γ1 ∧ γ2))/( γ2).
The notion of occurrence of a term p and a probabilistic state formula ξ1 in the probabilistic state formula ξ can be easily defined. The notion of replacing zero or more occurrences of probability terms and probabilistic formulas can be similarly defined. For the sake of clarity, we shall often drop parentheses in formulas and terms if it does not lead to ambiguity.
Example 2.2 Consider again the variant of the Russian roulette described in Ex- ample 2.1. Stating that the coin is fair can be expressed by ( h = 1/2). We can also say the bullet is shot only if the outcome of the coin is heads by (b ⇒ h). Similarly, the gambler is dead only if the outcome of the coin toss is heads and the bullet is shot, which can be expressed by  (d ⇒ b ∧ h). Finall∫y, the fact that the
probability of the bullet being shot is 1/6 can be captured by ( b|h)= 1/6.
Semantics
Given V ⊆ V, the extent of a classical formula γ in V is defined as |γ|V = {v ∈ V : v Hc γ}, where Hc is the satisfaction relation for classical propositional logic. For interpreting the probabilistic variables, we need the concept of an assignment. An assignment ρ is a map such that ρ(y) ∈ R for each y ∈ Y.
Given a probabilistic structure (V, μ) and an assignment ρ, the denotation of probabilistic terms and satisfaction of probabilistic state formulas are defined in- ductively as follows.
Denotation of probability terms
· [[0]](V,μ) =0 
· [[1]](V,μ) =1 
· [[y]](V,μ) = ρ(y)

ρ
(V,μ)
ρ
= μ(|γ|V )

· [[p1 + p2]](V,μ) = [[p1]](V,μ) + [[p2]](V,μ)
ρ	ρ	ρ
· [[p1p2]](V,μ) = [[p1]](V,μ) × [[p2]](V,μ)
Satisfaction of probabilistic formulas
(V, μ)ρ H ( γ) iff v Hc γ for every v ∈ V
(V, μ)ρ H (p1 ≤ p2) iff V /= ∅ implies ( [p1]](V,μ) ≤ [[p2]](V,μ))

9 We do not have formulas such as  ( γ).

· (V, μ)ρ /H ⊥⊥
(V, μ)ρ H (ξ1 ⊃ ξ2) iff (V, μ)ρ H ξ2 or (V, μ)ρ /H ξ1
The formula ( γ) is satisfied only if all v ∈ V satisfy γ. The formula (p1 ≤ p2) is satisfied if the term denoted by p1 is less than p2. The formula (ξ1 ⊃ ξ2) is satisfied by a semantic model if either ξ1 is not satisfied by the model or ξ2 is satisfied by the model. Entailment is defined as usual: Ξ entails ξ (written Ξ ▶ ξ) if (V, μ)ρ H ξ whenever (V, μ)ρ H ξ0 for each ξ0 ∈ Ξ.
Please note that an assignment ρ is sufficient to interpret a useful sub-language of probabilistic state formulas:

κ := (a ≤ a) ▢ ⊥⊥ ▢ (κ ⊃ κ)
a := 0 ▢ 1 ▢ x ▢ (a + a) ▢ (aa).

Henceforth, the terms of this sub-language will be called analytical terms and the formulas will be called analytical formulas.

Model–checking EPPL
For the model–checking procedure we assume that the probabilistic structure and assignment are represented using a floating point data structure. We assume that a probabilistic structure (V, μ) for Φ propositional symbols is modelled by a V -array of real numbers; the size of V is at most 2n with n = |Φ|. We also assume that the basic arithmetical operations take O(1) time. Moreover, we assume that we use only a finite number of variables Y and that assignment is a vector of real number of size |Y|.
We also assume the definition of the length of a classical formula γ or a prob- abilistic formula ξ as the number of symbols required to write the formula. The length of a formula ξ (classical or probabilistic) is given by |ξ|.
Given a probabilistic structure (V, μ), assignment ρ and a probabilistic formula ξ, the first step is to evaluate all the terms occurring in ξ. For the probability terms γ, the evaluation takes |V |· |γ| steps as we check the set of valuations that satisfy γ. Once the terms are evaluated, the model–checking algorithm is straightforward.

Theorem 2.3 Assuming that all basic arithmetical operations take unit time, there is an algorithm O(|ξ| · |V |) to decide if a probabilistic structure over Φ and an assignment ρ satisfy ξ.
Proof. First notice that the terms that take longer to evaluate are those of the type ( γ) and ( γ). The number of terms of type ( γ) is bounded by |ξ|. To evaluate one of these terms we require O(|V |) time corresponding to traveling throughout all the valuations satisfying γ and summing all the associated probabilities. So, com- puting all ( γ) terms takes O( ξ . V ) time. The same expression will be obtained to check the satisfaction of ( γ).

After these values are obtained, the remaining computation (comparing terms, negating a boolean value, and making implications between boolean values) takes at most O(|ξ|) time. Hence, the total time to decide if a if a probabilistic structure over Φ and an assignment ρ satisfy ξ is O(|ξ|.|V | + |ξ|)= O(|ξ|.|V |).	 
Clearly, since in the worst case the probability distribution will span all possible valuations, we have |V | = 2n where n = |Φ|. Observe that in many cases the set of possible valuations is small and it is possible to describe this set in a compact manner, as well as the probabilities associated, we will return to this discussion when we discuss the model–checking procedure of the temporal extension of the logic.
Axiomatisation of EPPL
The axiomatisation of the EPPL logic presented here relies entirely on that in [9] and will be presented in a summarised way. We need two new concepts for the axiomatisation, namely the notions of probabilistic tautology and of valid analytical formulas.
Consider propositional formulas built from a countable set of propositional sym- bols Q using the classical connectives ⊥ and →. A probabilistic formula ξ is said to be a probabilistic tautology if there exists a propositional tautology β over Q, and a map σ from Q to the set of probabilistic state formulas, such that ξ coincides with βpσ (where βpσ is the probabilistic formula obtained from β by replacing all occurrences of ⊥ by ⊥⊥, → by ⊃ and q ∈ Q by σ(q)). For instance, the probabilistic formula ((y1 ≤ y2) ⊃ (y1 ≤ y2)) is tautological (obtained, for example, from the propositional tautology q → q).
As noted in Section 2.2 an assignment is enough to interpret all analytical for- mulas. We say that κ is a valid analytical formula if for any real closed field K and assignment ρ, κ is true for ρ. Clearly, a valid analytical formula holds for all semantic structures of EPPL. It is a well-known fact from the theory of quantifier elimination [17,3] that the set of valid analytical formulas so defined is decidable over algebraic ordered fields. Moreover, since the real numbers consitute a repre- sentative model of algebraic ordered fields (that is, if there exists a solution for a systems of inequations written with the terms of EPPL in an algebraic order field, there is also a solution for the real numbers), the decidability result extends over the real numbers. We shall not go into details of this result as we want to focus exclusively on reasoning about probabilistic aspects.
The axioms and inference rules of EPPL are listed below.
Axioms
[CTaut] ▶ ( γ) for each valid formula γ;
[PTaut] ▶ ξ for each probabilistic tautology ξ
[Lift⇒] ▶ ((  (γ1 ⇒ γ2)) ⊃ (  γ1 ⊃  γ2))
[Eqv⊥] ▶ ((  ⊥) ≈ ⊥⊥)
[Ref∧] ▶ ((( γ1) ∩ ( γ2)) ⊃ ( (γ1 ∧ γ2)))


[RCF] ▶ κ{|→y/p→|} where κ is a valid analytical formula, →y and →p are sequences of probability variables and probability terms respectively
[Meas∅] ▶ ((∫ ⊥)= 0)
[FAdd] ▶ ((∫(∫(γ1 ∧ γ2)) = 0) ⊃ ((∫(γ1 ∨ γ2)) = (∫ γ1)+ (∫ γ2)))
[Prob] ▶ (( T)= 1)	∫	∫

[Mon] ▶ ((  (γ1 ⇒ γ2)) ⊃ ((
Inference rules
γ1) ≤ (
γ2)))

· [CMP] (  γ1), (  (γ1 ⇒ γ2)) ▶ (  γ2)
· [PMP] ξ1, (ξ1 ⊃ ξ2) ▶ ξ2
The axiom CTaut says that if γ is a valid classical formula then ( γ) is an axiom. The axiom PTaut says that a probabilistic tautology is an axiom. Since the set of valid classical formulas and the set of probabilistic tautologies are both recursive, there is no need to spell out the details of tautological reasoning.
The axioms Lift⇒, Eqv⊥ and Ref∧ are sufficient to relate (local) classical state reasoning and (global) probabilistic tautological reasoning.
The term κ{|→y/p→|} in the axiom RCF is the term obtained by substituting all occurrences of yi in κ by pi. The axiom RCF says that if κ is a valid analytical formula, then any formula obtained by replacing variables with probability terms is a tautology. We refrain from spelling out the details as the set of valid analytical formulas is recursive.
The axiom Meas∅ says that the measure of empty set is 0. The axiom FAdd is the finite additivity of the measures. The axiom Mon relates the classical connec- tives with probability measures and is a consequence of monotonicity of measures. The axiom Prob says that the measure is a probability measure.
The inference rules CMP and PMP are the modus ponens for classical and probabilistic implication respectively.
As usual we say that a set of formulas Γ derives ξ, written Γ ▶ ξ, if we can build a derivation of ξ from axioms and the inference rules using formulas in Γ as hypothesis.
Theorem 2.4 EPPL is sound and weakly complete. Moreover, the set of theorems is recursive.
Proof. The result follows from the fact that EPPL logic present here is a sublan- guage of that presented in [9], for which the corresponding axiomatisation is proved to be sound and weakly complete. Hence, for further details look at [9].	 

The Computation Tree Extension - EpCTL
In this section we define the computation tree extension to EPPL, which we call exogenous probabilistic computation tree logic (EpCTL). The idea is to consider several probabilistic structures together with a transition relation between them, in other words, a Kripke structure whose nodes are probability structures. This

structure is particularly interesting for two reasons. Firstly, it captures the idea, which arises in the study of probabilistic transition systems, that the state space should be described as a distribution of classical states [30,14,9]. Secondly, it is a step towards reasoning about quantum systems, since in such systems a state is described as a probabilistic ensemble of pure quantum states (cf. mixed states, density operators). We will explore both aspects in Section 4 by presenting two detailed examples.
We proceed to present the syntax of EpCTL.
Syntax
The syntax of EpCTL can be easily obtained from the syntax of EPPL. The idea is that at the level of probabilistic state formulas, we also introduce the usual CTL modalities. For the sake of clarity, we recall the definition of classical formulas and probability terms.
Classical formulas
γ := Φ ▢ ⊥ ▢ (γ ⇒ γ)
Probability terms
p := 0 ▢ 1 ▢ y ▢ ( γ) ▢ (p + p) ▢ (p p)
Exogenous probabilistic computation tree logic formulas
· δ := ( γ) ▢ (p ≤ p) ▢ ⊥⊥ ▢ (δ э δ) ▢ (EXδ) ▢ (AFδ) ▢ (E[δUδ])
The intuitive semantics of the temporal modalities is similar to that in classical CTL. The modalities are composed by two symbols, where the first one is chosen among E or A, and the second one among X, F, G and the bi-modality U. The second symbol is used for temporal reasoning: X stands for next; F for sometime in the future; G for always in the future; and U for until. The first symbol quantifies over all computation paths: an existential (E - for there exists) path or a universal (A - for all) paths. The combination of the two symbols can be easily understood. For example, the formula EXδ holds in a probability structure (V, p) if there exists a next structure of (V, p) (that is, a structure reachable from (V, p) with a single transition) that satisfies δ. As usual, all CTL modalities are obtained as abbreviations from EX, AF and EU.
(AX δ) for g EX(g δ);
(EF δ) for g(E[(g ⊥⊥)Uδ]);
(AG δ) for g(EF(g δ));
(EG δ) for g(AF(g δ));
A[δ1Uδ2] for g(E[(g δ2)U(g δ1 ∩  δ2)]) ∩ (g(EG(g δ2))).
Example 3.1 Consider again the Russian roulette variant from Example 2.1 to- gether with some temporal primitives. First, we will like to state that the bullet can not be shot before the outcome of the coin is heads, which can be expressed as A[(( b)= 0)U(( h) > 0)]. Suppose that the gambler is always playing this game alone, clearly the probability of killing himself tends asymptotically to 1, we can

capture this statement with ((x < 1) э AF((∫ d) > x)).
Semantics
A probabilistic Kripke structure is a pair (P, R) where P is a set of probabilistic structures and R ⊆ P × P is a total transition relation, that is, for any (V, μ) ∈ P there exists (V , μ ) such that (V, μ) R (V , μ ). The notion of probabilistic Kripke structure is very general, and, as we shall see, it is capable of capturing Markov tran- sitions (and more) as well as systems with both non–deterministic and probabilistic transitions.
Example 3.2 Consider the Russian roulette from Example 2.1, and consider that the gambler plays the game twice and then, if alive, halts. The probabilistic Kripke structure is such that all probability structures involved have the set of admissible valuations V = {∅, {h}, {h, b, d}}. Assume that the initial distribution μ0 is μ(∅)= 
1. The probability distribution over V evolves accordingly to the following stochastic matrix
1  5   1
2 12 12
M =	1  5   1
2 12 12
⎣ 0 0 1 ⎦
so, assuming that the gambler’s only choice is to play twice and then halt if alive, we have that μ0 R μ1 and μ1(∅) = 1/2, μ1({h}) = 5/12 and μ1({h, b, d}) = 1/12; moreover, μ1 R μ2, with μ2(∅) = 11/24, μ2({h}) = 55/144 and μ2({h, b, d}) = 23/144; and finally μ2 R μ2.
The interpretation of probabilistic terms is defined as before. The satisfaction of a temporal formula is defined over a probabilistic Kripke structure (P, R), a probabilistic structure (V, μ) ∈P and an assignment ρ.
(P, R), (V, μ),ρ H (  γ) iff (V, μ),ρ H (  γ);
(P, R), (V, μ),ρ H (p1 ≤ p2) iff (V, μ),ρ H (p1 ≤ p2);
(P, R), (V, μ),ρ /H ⊥⊥;
(P, R), (V, μ),ρ H (δ1 э δ2) iff (P, R), (V, μ),ρ /H δ1 or (P, R), (V, μ),ρ H δ2;
(P, R), (V, μ),ρ H (EXδ) iff (P, R), (V ', μ'),ρ H δ with (V, μ) R (V, μ);
(P, R), (V, μ),ρ H (AFδ) iff for all path π over R starting in (V, μ) there exist
k ∈ N such that (P, R), πk,ρ H δ;
(P, R), (V, μ),ρ H (E[δ1Uδ2]) iff there exist path π over R starting in (V, μ) and
k ∈ N such that (P, R), πk,ρ H δ2 and (P, R), πi,ρ H δ1 for every i ≤ k;
where πi denotes the i-element of the path π.
We say that (P, R) H δ iff (P, R), (V, μ),ρ H δ for all (V, μ) ∈P and assignment
ρ.
Example 3.3 Consider the probabilistic Kripke structure (P, R) of Example 3.2. The structure satisfies the property that the probability of dying is non decreasing,

that is, (P, R) H (((∫ d)= x) э (AG((∫ d) ≥ x))).

The relation of EpCTL to PCTL
EpCTLis related to the logic PCTL proposed by Hansson and Jonsson [16]. The PRISM tool [19,20] is a symbolic model-checker for PCTL. There is a fundamental difference between the semantics of EpCTL and PCTL; whereas PCTL enables rea- soning about distributions over paths in a probabilistic transition system, EpCTL is designed for reasoning about how a probability distribution over a finite set of propositional symbols changes over time. The latter approach is particularly advan- tageous for reasoning about certain types of systems, such as distributed randomised algorithms. Depending on the application, it can be better or worse to model a given property using distributions over paths or over the propositional symbols, since both approaches are valid, but quite different. Hence, the PCTL formula AG>qϕ states that, for any choice of the scheduler, the measure of paths satisfying Gϕ is greater than q. On the other hand the EpCTL formula AG( ϕ > q) means that for any choice of the scheduler, all the state distributions reached are such that the prob- ability of ϕ holding is greater than q. Given that in PCTL the probabilities are endogenous in the modalities, it does not seem to be possible to express some more sophisticated types of property, such as: AG(( ϕ1 · ϕ2) > q). It is possible to devise a mapping from probabilistic transition systems to probabilistic Kripke struc- tures using a construction that involves blind schedulers, but we will not elaborate on this here. Investigating the connections between the semantics of EpCTL and of other logics is certainly a direction for future work.

Model–checking EpCTL
We now address the problem of model–checking a temporal formula. Following the usual model–checking technique for CTL, the goal is to compute the set
Sat(P,R),ρ(δ) := {(V, μ) ∈P : (P, R), (V, μ),ρ H δ}

for a probabilistic Kripke structure (P, R), assignment ρ and formula δ. This is called the global model–checking problem. Before presenting the model–checking al- gorithm, it is useful to introduce some notation for relations, namely in the context of a probabilistic Kripke structure ( , R). We denote by R−1 the inverse relation of R, that is, (V, μ)R−1(V ', μ') iff (V ', μ')R(V, μ). Given a set of probabilistic stru- cutures X ⊆ P, we denote by RX the set {(V, μ) ∈ P : there exists (V ', μ') ∈ X such that (V ', μ')R(V, μ)}. We are now able to present a model–checking algorithm, adapted from the usual algorithm for CTL:
Sat(P,R),ρ( γ)= {(V, μ) ∈P : (V, μ),ρ H ( γ)};
Sat(P,R),ρ(p1 ≤ p2)= {(V, μ) ∈P : (V, μ),ρ H (p1 ≤ p2)};
Sat(P,R),ρ(δ1 э δ2)= (P \ Sat(P,R),ρ(δ1) ∪ Sat(P,R),ρ(δ2);
Sat(P,R),ρ(EXδ)= R−1Sat(P,R),ρ(δ);

Sat(P,R),ρ(AFδ)= FixedPoint[λX.F(AFδ)(X), Sat(P,R),ρ (δ)] with
F(AFδ)(X)= X ∪ {(V, μ) ∈P : R{(V, μ)} ⊆ X};
Sat(P,R),ρ(E[δ1Uδ2]) = FixedPoint[λX.FE[δ1 Uδ2 ](X), Sat(P,R),ρ(δ2)] with
FE[δ Uδ ](X)= X ∪ (Sat(P,R),ρ(δ1) ∩ R−1X).
In general, a probabilistic Kripke structure requires exponential space (over the number of propositional symbols) due to the exponential spanning of probabilities on the distribution over the valuations. For this reason, the model–checking algorithm takes exponential time on the number of propositional symbols, but it is polynomial on the size of the probabilistic Kripke structure and the complexity of the formula.
Theorem 3.4 Assuming that all basic arithmetical operations take unit time, the model–checking algorithm for EpCTL takes O(|δ|2 ·|P|2 · 2n) time for inputs (P, R),ρ and δ, where δ is written with n propositional symbols.
Proof. The propositional CTL model–checking algorithm takes O(|δ| · |P|2) (see [10] for a detailed analysis). So, if we consider each ( γ) and p1 ≤ p2 to be a propositional symbol, the time complexity of the algorithm would be O(|δ|· |P|2). Finally, since checking if these formulas are satisfied by a (P, μ) and ρ takes O(|δ|·2n) (c.f. Theorem 2.3) we derive the desired upper bound. Recall that we consider all arithmetic computations to be O(1) by using floating point representation for the real numbers.	 
It is well known that a slightly better algorithm can be obtained if EG is taken as a basic modality instead of AF, but we refrain from doing so here. Although the algorithm is exponential in the worst case, it assumes that a probability distribution over valuations is encoded as a vector of probabilities. Clearly, for particular rele- vant cases, there are much more efficient and compact encodings; we are currently investigating which probability distributions can be encoded efficiently.

Illustrative Examples
In order to demonstrate the expressiveness of EpCTL, we consider a couple of exam- ples from the literature, starting with a model of the contract-signing protocol due to Ben-Or et al. [6]. We then consider a simple example of a protocol from the area of quantum cryptography, the quantum one–time pad [1], noting that this particular protocol may be modelled entirely in a probabilistic setting, and its properties for- malised in a classical probabilistic (as opposed to specifically quantum) formalism.
A Contract Signing Protocol
The problem of contract signing is to find a way of getting two users, A and B, to commit to a contract C in such a way that neither party may falsely convince the other that the former has signed. In other words, A and B must sign the

contract together, without one party gaining any advantage over the other. The traditional solution to the problem is for A and B to sign C simultaneously, but this is only possible if A and B are in physical proximity. Assuming that A and B are spatially separated, the only way for contract signing to be achieved is through a communication protocol, although it is likely that, at different stages of such a protocol, one party will have a relative advantage over the other. The objective of a “fair” contract signing protocol, such as the one proposed by Ben-Or et al. [6] (henceforth referred to simply as the BGMR protocol) is to constrain this relative advantage so that it remains within specific bounds tolerated and agreed upon by both users.
The BGMR protocol assumes the setting of a network of users (we focus only on the two user case) with a signature scheme in operation. Only user U is assumed capable of producing U’s signature on message m (unforgeability) and any other user is assumed capable of verifying the validity of U’s signature on m (universal veriﬁability). The protocol assumes that neither user A nor user B wants to be committed to contract C unless the other user is, and makes it possible for A and B to sign C by exchanging commitments. The notion of fairness for the protocol is defined as the property that, the conditional probability with which “B is not privileged” given that “A is privileged” is always small. Formally, the BGMR protocol is said to be (v, ϵ)–fair, this being defined as follows.
Definition 4.1 A contract signing protocol is (v, ϵ)–fair for A if the following holds, for any contract C, when A follows the protocol properly: At any step of the protocol in which the probability that “B is privileged” is greater than v, the conditional probability that “A is not privileged” given that “B is privileged” is at most ϵ.
If A and B are assumed to be dishonest, then a third party – a judge – must be invoked during the protocol in order to provide an independent judgement as to whether the contract is to be considered binding for both users. During the protocol, A and B exchange signed messages of the following form:
m = (C, p, U ) = “With probability p, the contract C shall be valid.
Signed, User U . ” 
When message m is received, the recipient is said to be privileged with probability p, meaning that invocation of the judge will result in him ruling that contract C is binding to A and B with probability p. If the protocol does not terminate successfully by a pre–agreed date D, one of the two users invokes an early stopping procedure.
We are now ready to state the BGMR protocol in detail. Steps 1–5 are for initialization of protocol parameters.
Parties A and B agree who goes first and set a termination date D. We assume that A is to go first.
Party A chooses the conditional probability v that “B is privileged” while “A is not privileged.”
Party A chooses the parameter α > 1 such that, the conditional probability

that “A is privileged” given that “B is privileged” is at least  1 .
Party B chooses β > 1 such that, the conditional probability that “B is privi- leged” given that “A is privileged” is at least 1 .
The protocol is initialised with λA = λB = 0. The symbol λA stores the probability mentioned in the message last sent from A, and similarly λB stores the probability mentioned in the message last transmitted from B.
A and B perform the following procedures alternately:
A-step. User A denotes the probability mentioned in the last message re- ceived by p. A then checks whether p ≥ λA. If so, then A sets λA := max(v, min(1,p · α)). Otherwise, A assumes the protocol has been termi- nated. A then transmits message (C, λA, A) to B.
B-step. User B denotes the probability mentioned in the last message received by p. B then checks whether p ≥ λB. If so, then B sets λB := min(1,p · β). Otherwise, B assumes the protocol has been terminated. B then transmits message (C, λB, B) to B.
The details of the judge’s procedure, and of the early stopping procedure, are to be found in [6]. An analysis of the protocol has been performed using the PRISM model-checker by Norman and Shmatikov [27].
The essential point about the BGMR protocol is that it ensures a specified degree of fairness, characterised by the constants v and ϵ. At the end of the protocol, both parties need to be privileged. We formalise the notion of (v, ϵ)–fairness using EpCTL in what follows.
We establish the set Φ = {ϕA, ϕB} of propositional constants, where ϕA corre- sponds to the truth of the event “A is privileged,” and similarly ϕB is true if “B is privileged.” To express the fairness property, we regard the protocol parameter ϵ as a real variable, namely a member of the set Y defined in Section 2. The probability v which party A fixes in step (ii) above may be expressed as the following term in EpCTL :
v = ∫ ϕB|(¬ϕA) 
In steps (iii) and (iv) of the protocol, parties A and B fix the parameters α and
β respectively such that the following EpCTL properties are true:

(1)
(2)
 ∫ ϕA
 ∫ ϕB
1
|ϕB  ≥ α
1
|ϕA  ≥ β

The property of (v, ϵ)–fairness may be expressed thus:
AG  ∫ ϕB > v э  ∫ (¬ϕA)|ϕB ≤ ϵ 
that is to say, in all paths of the protocol, the probability that “A is not privileged” given that B is, assuming that the probability of “B being privileged” is greater than v, remains less than ϵ. Note that we are using the comparators >, ≥ freely; these may be expressed in terms of the ≤ operator in the formal syntax of EpCTL.

Quantum One Time Pad
A qubit is the basic memory unit in quantum computation (just as a bit is the basic memory unit in classical computation). The state of a qubit is a pair (α, β) of complex numbers such that |α|2 + |β|2 = 1. A quantum one time pad [1] encrypts a qubit using two key (classical) bits in a secure way: observing the encrypted qubit yields two results, both with equal probability. In the special case that α and β are real numbers one bit key ϕK suffices. If ϕK = 1 then the qubit is encrypted as the pair (β, −α), otherwise it remains the same. We consider that a real number α is encoded using floating point representation, namely a vector of propositional
symbols ϕα ... ϕα which we denote just by ϕα. We will abbreviate by α = β the
1	n
classical formula (ϕα ⇔ ϕβ) ∧ ... ∧ (ϕα ⇔ ϕβ).
The following program simulates this process by first generating a random key and then encrypting the qubit (α, β):
Let ϕK := outcome of a fair Bernoulli trial;
If (ϕK = 1) then
γ := α
α := β
β := −γ
Assume that the initial values of α and β are c and d respectively (with c /= d). It follows from quantum information theory that in order to prove the security of the quantum one-time pad, it suffices to show that the probability after the
encryption of α being c is 1 (and hence of α being d is also 1 ). We can use our logic
2	2
and model checking procedure to show the above by considering the probabilistic
Kripke structure induced by the encryption program. Assume that the program induces a single transition in the Kripke structure, and from that point on the probability distribution over the states remains the same. Therefore, the security of the quantum one-time pad is equivalent to checking that all initial states fulfill
( (α = c ∧ β = d ∧ (¬(c = d)))) э AX((∫(α = c)) = 1 ).

Summary and Conclusion
In this paper we have introduced a probabilistic branching-time logic, EpCTL, which may be regarded as a temporal extension of the exogenous probabilistic state logic EPPL. We have stated the syntax and semantics of EPPL, considered the model– checking problem for formulas in this state logic, and presented an axiomatisation for it. We described the EpCTL extension, stating syntax, semantics, and model– checking issues in an analogous way to EPPL. The expressiveness of EpCTL was discussed, and an axiomatisation was given. We demonstrated the use of EpCTL as a means of expressing properties of two security protocols: a classical probabilistic contract signing protocol, and the quantum one–time pad.
Our approach has been inspired by earlier work by Halpern, and we expect the probabilistic temporal logic EpCTL to serve as a useful alternative to related

classical logics such as PCTL. Future work will include refining the axiomatisation of EpCTL, considering possible improvements to the model–checking algorithm, and implementing the algorithm. Further work on case studies is necessary, especially with a view to classifying and verifying the types of properties which typically arise in security.
We hope this work will serve as a basis for ongoing work in developing an exoge- nous, temporal quantum logic for model–checking general quantum protocols. A quantum state logic, exogenous quantum propositional logic (EQPL) was proposed in [23]; we intend to provide a temporal extension of that logic, extending the tech- niques described in the present paper. Thus we have the necessary ingredients for building a dedicated model–checking tool for the analysis of quantum cryptographic and communication systems, which is one of our long-term goals.

References
Ambainis, A., M. Mosca, A. Tapp and R. de Wolf, Private quantum channels, in: FOCS ’00: Proceedings of the 41st Annual Symposium on Foundations of Computer Science (2000), p. 547.
Baier, C. and M. Z. Kwiatkowska, Model checking for a probabilistic branching time logic with fairness, Distributed Computing 11 (1998), pp. 125–155.
URL citeseer.ist.psu.edu/article/kwiatkowska96model.html
Basu, S., R. Pollack and R. M.-F. coise, “Algorithms in Real Algebraic Geometry,” Springer, 2003.
Beauquier, D., A. M. Rabinovich and A. Slissenko, A logic of probability with decidable model-checking, in: CSL ’02: Proceedings of the 16th International Workshop and 11th Annual Conference of the EACSL on Computer Science Logic (2002), pp. 306–321.
Ben-Ari, M., Z. Manna and A. Pnueli, The temporal logic of branching time, in: POPL ’81: Proceedings of the 8th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (1981), pp. 164–176.
Ben-Or, M., O. Goldreich, S. Micali and R. L. Rivest, A fair protocol for signing contracts, IEEE Transactions on Information Theory 36 (1990), pp. 40–46.
Carnielli, W. A., Possible-translations semantics for paraconsistent logics, in: Frontiers of Paraconsistent Logic (Ghent, 1997), Studies in Logic and Computation 8 (2000), p. 149163.
Carnielli, W. A. and M. Lima-Marques, Society semantics and multiple–valued logics, in: Advances in Contemporary Logic and Computer Science (Salvador, 1996), Contemporary Mathematics 235 (1999),
pp. 33–52.
Chadha, R., P. Mateus and A. Sernadas, Reasoning about states of probabilistic sequential programs, in: Z. E´sik, editor, Computer Science Logic 2006 (CSL06), Lecture Notes in Computer Science 4207, Springer-Verlag, 2006 pp. 240–255.
Clarke, E. M. and E. A. Emerson, Design and synthesis of synchronization skeletons using branching time temporal logics, in: Proceeding of the Workshop on Logics of Programs, LNCS 131, Springer- Verlag, 1981 .
Clarke, E. M. and E. A. Emerson, Design and synthesis of synchronization skeletons using branching- time temporal logic, in: Logic of Programs, Workshop (1982), pp. 52–71.
Clarke, E. M., E. A. Emerson and A. P. Sistla, Automatic verification of finite-state concurrent systems using temporal logic specifications, ACM Trans. Program. Lang. Syst. 8 (1986), pp. 244–263.
Clarke, E. M. and J. M. Wing, Formal methods: state of the art and future directions, ACM Comput. Surv. 28 (1996), pp. 626–643.
den Hartog, J. and E. de Vink, Verifying probabilistic programs using a hoare like logic, International Journal of Foundations of Computer Science 13 (2002), pp. 315–340.

Fagin, R., J. Y. Halpern and N. Megiddo, A logic for reasoning about probabilities, Information and Computation 87 (1990), pp. 78–128.
URL citeseer.ist.psu.edu/fagin90logic.html

Hansson, H. and B. Jonsson, A logic for reasoning about time and reliability, Formal Aspects of Computing 6 (1994), pp. 512–535.
URL citeseer.ist.psu.edu/hansson94logic.html
Hodges, W., “Model Theory,” Cambridge University Press, 1993.
Kripke, S., Semantical analysis of modal logic I. Normal modal propositional calculi, Zeitschrift fu¨r Mathematische Logik und Grundlagen der Mathematik 9 (1963), pp. 67–96.
Kwiatkowska, M., G. Norman and D. Parker, Prism: Probabilistic symbolic model checker, in: TOOLS ’02: Proceedings of the 12th International Conference on Computer Performance Evaluation, Modelling Techniques and Tools (2002), pp. 200–204.
Kwiatkowska, M., G. Norman and D. Parker, Probabilistic model checking in practice: case studies with prism, SIGMETRICS Perform. Eval. Rev. 32 (2005), pp. 16–21.
Kwon, Y. and G. Agha, Linear inequality LTL (iLTL): A model checker for discrete time Markov chains, in: J. Davies, W. Schulte and M. Barnett, editors, Proceedings of 6th International Conference on Formal Engineering Methods (ICFEM 2004), Lecture Notes in Computer Science 3308 (2004).
Mateus, P. and A. Sernadas, Exogenous quantum logic, in: W. Carnielli, F. Dion´ısio and P. Mateus, editors, Proceedings of CombLog’04, Workshop on Combination of Logics: Theory and Applications (2004), pp. 141–149.
Mateus, P. and A. Sernadas, Reasoning about quantum systems, in: J. Alferes and J. Leite, editors, Logics in Artificial Intelligence, Ninth European Conference, JELIA’04, Lecture Notes in Artificial Intelligence 3229 (2004), pp. 239–251.
Mateus, P. and A. Sernadas, Weakly complete axiomatization of exogenous quantum propositional logic, Information and Computation 204 (2006), pp. 771–794, arXiv math.LO/0503453.
URL
http://www.elsevier.com/wps/find/journaldescription.cws_home/622844/description#description
Mateus, P., A. Sernadas and C. Sernadas, Exogenous semantics approach to enriching logics., in:
G. Sica, editor, Essays on the Foundations of Mathematics and Logic (2005), pp. 165–194.
Nilsson, N. J., Probabilistic logic, Artificial Intelligence 28 (1986), pp. 71–87.
Norman, G. and V. Shmatikov, Analysis of probabilistic contract signing, Journal of Computer Security (2006), to appear.
Papanikolaou, N., “Techniques for Design and Validation of Quantum Protocols,” Master’s thesis, Department of Computer Science, University of Warwick (2005), also available as Research Report CS-RT-413.
Pnueli, A., The temporal logic of programs, in: Proceedings of the 18th IEEE Symposium on Foundations of Computer Science (FOCS 1977), 1977, p. 4657.
Ramshaw, L. H., “Formalizing the analysis of algorithms.” Ph.D. thesis, Stanford University (1979).
