Electronic Notes in Theoretical Computer Science 174 (2007) 55–70	
www.elsevier.com/locate/entcs

Rewrite-Based Satisfiability Procedures for Recursive Data Structures
Maria Paola Bonacina1	Mnacho Echenim2
Dipartimento di Informatica, Università degli Studi di Verona, Italy

Abstract
If a rewrite-based inference system is guaranteed to terminate on the axioms of a theory T and any set of ground literals, then any theorem-proving strategy based on that inference system is a rewrite-based decision procedure for T -satisfiability. In this paper, we consider the class of theories defining recursive data structures, that might appear out of reach for this approach, because they are defined by an infinite set of axioms. We overcome this obstacle by designing a problem reduction that allows us to prove a general termination result for all these theories. We also show that the theorem-proving strategy decides satisfiability problems in any combination of these theories with other theories decided by the rewrite-based approach.
Keywords: Rewrite-based inference systems, recursive data structures


Introduction
Most state-of-the-art verification tools rely on built-in satisfiability procedures for specific theories. These satisfiability procedures can be quite complicated to design and combine, and significant effort is devoted to proving them correct and complete, and implementing them. A new approach to defining satisfiability procedures was introduced in [3], where the authors showed that a sound and complete first-order theorem-proving strategy can be used to solve satisfiability problems for several theories of data structures. The idea behind this approach is that since such a strategy is a semi-decision procedure for first-order validity, if one proves that it terminates on a presentation of the theory of interest T and any set of ground literals, then it is a decision procedure for T -satisfiability. In [3], this idea was applied to a standard inference system, the superposition calculus SP, and several theories, including those of arrays and possibly cyclic non-empty lists.

1 Email: mariapaola.bonacina@univr.it
2 Email: echenim@sci.univr.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.039

Since most verification problems involve more than one theory, a significant ad- vantage of an approach based on generic reasoning is that it makes it conceptually simple to combine theories, by considering the union of their presentations. The notion of variable-inactive theories appeard in [1], along with several experimental results that showed the practicality of the rewrite-based approach. This variable- inactivity condition guarantees that SP terminates on a combination of theories, provided it terminates on each individual theory. Thus, it was shown in [1] that an SP-based strategy is a satisfiability procedure for any combination of the theories considered in [3] and [1].
Several of the theories for which SP has been shown to yield satisfiability pro- cedures involve lists. The superposition calculus yields satisfiability procedures for the theories of lists à la Shostak and à la Nelson and Oppen (see [3]), and for the theory of lists with nil (see [2]). A theory of lists that was not yet examined is that of acyclic lists, where formulae such as car(x)  x are unsatisfiable. This theory, along with that of integer oﬀsets studied in [8,1], belongs to the general class of theories of recursive data structures, that we denote RDS. Each member of this class is denoted RDSk, where k represents the number of selectors in the theory. We shall see that the theory of integer offsets is RDS1 and the theory of acyclic lists is RDS2. In this paper, we investigate how a rewrite-based inference system can be used to solve any RDSk-satisfiability problem, for any k. The contributions of the paper are the following:
Every theory in the class RDS is presented by an infinite set of axioms, which cannot be given as an input to a theorem prover. Here, we present a reduction that conquers this infinite presentation problem.
We prove that for any fair search plan, the inference system terminates on any reduced RDSk-satisfiability problem.
We show that for every k, the theory RDSk can be combined with all the theories considered in [3,1,2], namely those of lists à la Shostak and à la Nelson and Oppen, arrays and records with or without extensionality, sets with extensionality, possibly empty lists and integer offsets modulo.

Related work.
Theories of recursive data structures were studied by Oppen in [10], where he described a linear satisfiability procedure for the case where uninterpreted function symbols are excluded. The authors of [11] investigated quantifier-elimination prob- lems for an extension of the theory considered by Oppen: their setting includes atoms (constants) and several different constructors. However, their setting also ex- cludes uninterpreted function symbols. They provided a satisfiability procedure for this theory that “guesses” a so-called type completion, to determine which construc- tor was used on each term, or whether the term is an atom, and then calls Oppen’s algorithm. However, this type completion can be expensive in practice as the num- ber of guesses explodes with the number of constructors. More recently, the authors of [6] devised an algorithm for a more general class of recursive data structures: the

algorithm is based on a multi-sorted logical framework and solves 7 -decision prob- lems for several recursive data structures that may be mutually recursive, each of which may include several constructors. This algorithm uses a combination of the techniques of [10,11]: as in [10], it performs congruence and unification closure, and it handles multiple constructors with a type completion as in [11]. The algorithm is presented as an elegant combination of standard inference rules for congruence closure (see, e.g., [5]) and unification closure (see, e.g, [7]), with more specialized inference rules for type completion or the detection of cycles. In particular, the infer- ence rules for type completion make this procedure more flexible and less expensive than that of [11].
In this paper, we consider the recursive data structures as defined in [10], since our aim is to investigate how to apply the rewrite-based methodology to theories defined by infinite sets of axioms. Similar to any other theory for which the super- position calculus can be used as a satisfiability procedure, all these theories can be combined with the theory of equality with uninterpreted functions. For instance, it can be used to prove the YÐ£k-unsatisfiability of a set such as
S = {cons(c1,... , ck)  c, cons(c1,... , ck)  c', f (c) / f (c')},
where f is an uninterpreted function symbol.

Preliminaries
In the following, given a signature Σ, we consider the standard definitions of Σ- terms, Σ-literals and Σ-theories. The symbol denotes unordered equality and da is either  or / . Unless stated otherwise, the letters x and y will denote variables, d and e elements of an interpretation domain, and all other lower-case letters will be constants or function symbols in Σ. Given a term t, Var(t) denotes the set of variables appearing in t. If t is a constant or a variable, then the depth of t is depth(t)= 0, and otherwise, depth(f (t1,... , tn)) = 1+max{depth(ti) |i = 1,... , n}. The depth of a literal is defined by depth(l da r) = depth(l) + depth(r). A positive literal is flat if its depth is 0 or 1, and a negative literal is flat if its depth is 0. We will make use of the following standard result: given a signature Σ and a Σ-theory 7 , let S be a finite set of Σ-literals. Then there exists a signature Σ' obtained from Σ by adding a finite number of constants, and a finite set S' of flat Σ'-literals such that S' is 7 -satisfiable if and only if S is.
A simplification ordering > is an ordering that is stable, monotonic and contains the subterm ordering : if s > t, then c[s]σ > c[t]σ for any context c and substitution σ, and if t is a subterm of s then s > t. A complete simplification ordering, or CSO, is a simplification ordering that is total on ground terms. We write t < s if and only if s > t. More details on orderings can be found, e.g., in [4]. A CSO is extended to literals and clauses by multiset extension as usual, and when no confusion is possible we will mention maximal literals without any reference to >.
The superposition calculus, or £У, is a rewrite-based inference system which is refutationally complete for first-order logic with equality (see, e.g., [9]). It consists



Fig. 1. Expansion inference rules of £P: in expansion rules, what is below the inference line is added to the clause set that contains what is above the inference line.
of expansion rules (see Figure 1) and contraction rules (see Figure 2), and is based on a CSO on terms which is extended to literals and clauses in a standard way. Given a CSO >, we write £У> for £У with >. An £У>-derivation is a sequence
S0 ▶£P> S1 ▶£P> ... Si ▶£P> ... ,
each Si being a set of clauses obtained by applying an expansion or a contraction rule to clauses in Si—1. Such a derivation yields a set of persistent clauses:
S∞ =	Si,
j≥0 i≥j
which can of course be infinite. Given a finite set of ground literals S, in order to prove that the set of persistent clauses obtained by a fair £У>-derivation from 7 ∪ S is finite, we may impose additional restrictions on the CSO >. Any CSO verifying these restrictions will be termed as 7 -good. We also say that an £У>-strategy is 7 -good if the CSO > is 7 -good.
A clause C is variable-inactive for > if no maximal literal in C is an equation
t  x, where x ∈/ Var(t). A set of clauses is variable-inactive for > if all its clauses



Fig. 2. Contraction inference rules of £P: in contraction rules, what is above the double inference line is removed from the clause set and what is below the double inference line is added to the clause set.
are variable-inactive for >. A theory presentation 7 is variable-inactive for > if the limit S∞ of any fair £У>-derivation from S0 = 7 ∪ S is variable-inactive. When no confusion is possible, we will say that a clause (resp. a set of clauses or a theory presentation) is variable-inactive, without any mention of >.

The theory of recursive data structures
The theory YÐ£k of recursive data structures is based on the following signature:
ΣYÐ£k = {cons}∪ Σsel ,
Σsel = {sel1,... , selk},
where cons has arity k, and the seli’s all have arity 1. The function symbols sel1,... , selk stand for the selectors, and cons stands for the constructor. This theory is axiomatized by the following (infinite) set of axioms, denoted Ax(YÐ£k):
seli(cons(x1,... , xi,... , xk))  xi	for i = 1,... ,k 
cons(sel1(x),... , selk(x))  x,
t[x] / x,
where x and the xi’s are (implicitly) universally quantified variables and t[x] is any compound Σsel -term where the variable x occurs. The axioms t[x] / x are acyclicity axioms that prevent the theory from entailing equations such as sel1(sel2(sel3(x))) x.
For the sake of clarity, we also define
Ac = {t[x] / x | t[x] is a Σsel -term},
Ac[n]= {t[x] / x | t[x] is a Σsel -term and depth(t[x]) ≤ n}.
Example 2.1 Consider the case where k = 2. If we write car(x) instead of sel1(x)
and cdr(x) instead of sel2(x), then our axioms become:

car(cons(x, y))  x,
cdr(cons(x, y))  y,
cons(car(x), cdr(x))  x,
t[x] / x,
and for example, we have:
Ac[2] = {car(car(x)) / x, cdr(cdr(x)) / x, car(cdr(x)) / x, cdr(car(x)) / x}.
We consider the problem of checking the YÐ£k-satisfiability of a set S of ground (equational) literals built out of the symbols in ΣYÐ£k and a set of finitely many constant symbols. This is done by checking the satisfiability of the following set of clauses:
Ax(YÐ£k) ∪ S.
According to the methodology of [3,1,2], this problem is solved in three phases:
Flattening: flatten all ground literals in the original problem, thus obtaining an equisatisfiable set of flat literals,
YÐ£k-reduction: transform the flattened problem into an equisatisfiable YÐ£k- reduced problem consisting of a finite set of clauses,
Termination: prove that any fair £У>-strategy terminates on the YÐ£k-reduced problems.
The flattening step is straightforward and we now focus on the YÐ£k-reduction step.

YÐ£k-reduction
The aim of a reduction is to transform a formula into another one which is equisatis- fiable and easier to work on. Here, given a formula S, we want to transform it into a formula which is equisatisfiable in a theory that does not axiomatize the relationship between the constructor and the selectors. We begin by observing that S can be transformed by suppressing either every occurrence of cons, or every occurrence of the seli’s.
Example 3.1 Consider the case where k = 2, and let
S = {cons(c1, c2)  c, sel1(c)  c' }.
If we remove the occurrence of cons, S would become
S1 = {sel1(c)  c1, sel2(c)  c2, sel1(c)  c' }.
If we remove the occurrence of sel1, S would become
S2 = {cons(c1, c2)  c, c1  c' }.
We choose to remove every occurrence of cons because it is easier to work with function symbols of arity 1:

Definition 3.2 A set of ground flat literals is YÐ£k-reduced if it contains no oc- currence of cons.
Given a set S of ground flat literals, the symbol cons may appear only in literals of the form cons(c1,... , ck)  c for constants c, c1,... , ck. Negative ground flat literals are of the form c / c' and therefore do not contain any occurrence of cons. The YÐ£k-reduction of S is obtained by replacing every literal cons(c1,... , ck)  c appearing in S by the literals sel1(c)  c1,... , selk(c)  ck. The resulting YÐ£k-

reduced form S' of S is denoted Red YÐ£
(S) and it is obviously unique.

It is not intuitive in which theory the YÐ£k-reduced form of S is equisatisfiable to S, and we need the following definition:
Definition 3.3 Let (ext) denote the following “extensionality lemma”:
k
(selk(x)  selk(y)) ⇒ x  y.
i=1
Proposition 3.4 The extensionality lemma is logically entailed by the axiom
cons(sel1(x),... , selk(x))   x.
Proof. We show that the set
{cons(sel1(x),... , selk(x))  x}∪ {seli(a)  seli(b) | i = 1,... , k}∪ {a / b}
is YÐ£k-unsatisfiable. The superposition of literal sel1(a) sel1(b) into cons(sel1(x),... , selk(x))  x yields cons(sel1(b), sel2(a),... , selk(a))  a. Then, the respective superpositions of sel2(a)   sel2(b), sel3(a)   sel3(b), etc, yield cons(sel1(b),... , selk(b)) a. Finally, a superposition of the latter into cons(sel1(x),... , selk(x))  x produces the literal a  b, which contradicts a / b. 
We can then show that YÐ£k-reduction reduces satisfiability w.r.t. Ax(YÐ£k)
to satisfiability w.r.t. Ac ∪ {(ext)}.
Lemma 3.5 Let S be a set of ground flat literals, then Ax(YÐ£k) ∪ S is satisfiable if and only if Ac ∪ {(ext)}∪ Red YÐ£k (S) is.
Proof. (⇒) For i = 1,... , k, literal seli(c)  ci is a logical consequence of Ax(YÐ£k) and cons(c1,... , ck)  c. Indeed, it can be generated by a superpo- sition of the latter into the axiom seli(cons(x1,... , xi,... , xk))  xi. So we have that Ax(YÐ£k) ∪ S |= Ac ∪ Red YÐ£k (S). By Proposition 3.4, it is also the case that Ax(YÐ£k) ∪ S |= {(ext)}, hence the result.
(⇐) Let M = (D, I) be a model for Ac ∪ {(ext)}∪ Red YÐ£k (S). We will build a model M ' = (D',I') for Ax(YÐ£k) ∪ S starting from M . In particular, I' must interpret the function symbol cons in such a way that any sequence d1,... , dk of elements of D' has an image by consI' . We inductively build a model M ' = (D',I') for Ax(YÐ£k)∪S as follows: first, I' and I both interpret the constants appearing in
S the same way; second, for every d ∈ D, we let selI' (d)= selI (d) for all i = 1,... , k.
i	i
Let D0 = D, and consider the k-fold Cartesian product Dk = D0 × ... × D0.

We start by separating the elements in Dk
that can be represented as a tuple

⟨selI' (d),... , selI' (d)⟩ with d ∈ D , from those that cannot. Formally, we define
1	k	0
the following partition of Dk:
E = {⟨selI' (d),... , selI' (d)⟩| d ∈ D },
0	1	k	0
F0 = Dk \ E0.
Note that by construction, for every ⟨d1,... , dk⟩ ∈ E0, there exists a d ∈ D0 such
that selI' (d) = d for all i = 1,... , k. Furthermore, since M satisfies axiom (ext),
i	i
d is unique. Hence, we can safely define consI' (d ,... ,d )= d. Therefore, for every
1	k
tuple ⟨d ,... ,d ⟩ in E , if d = consI' (d ,... ,d ), then we have
1	k	0	1	k
selI' (d)= d , and consI' (selI' (d),... , selI' (d)) = d.
i	i	1	k

We now extend the function consI' to the elements in F . We let D'
be a set

0	0
disjoint from F0 ∪D0, such that there exists a bijection η0 from F0 to D' . Intuitively,
0
'	I'
D0 will provide the images cons (d1,... , dk) of all the tuples ⟨d1,... , dk⟩ in F0,
and each tuple is associated to its image by η0. Formally, for every element t =
⟨d ,... ,d ⟩ in F , we define selI' (η (t)) = d for i = 1,... , k, and consI (d ,... ,d )= 

1	k	0
i	0	i	1	k

η0(t). Let D1 = D0  D' : obviously D0 ⊆ D1, and for every ⟨d1,... , dk⟩ ∈ Dk, the

element d = consI'
0	0
(d1,... , dk) is well-defined and verifies

∀i = 1,... , k, selI' (d)= d , and consI' (selI' (d),... , selI' (d)) = d.
i	i	1	k
At this point, since I and I' interpret the constant symbols from S and the selector functions on D0 the same way, it is clear that I' satisfies Ac ∪ S, as well as the other axioms of Ax(YÐ£k) on D0. However, I' may still not be an interpretation, since the function consI' is not defined on the Cartesian product Dk. This is why
we perform the following induction step.
Suppose that for p ≥ 1, we have constructed a set Dp such that Dp—1 ⊆ Dp, on which we have defined the selI' ’s and consI' in such a way that for every ⟨d ,... ,d ⟩∈ 
i	1	k
k	I'
Dp—1, there exists a d ∈ Dp such that for all i = 1,... , k, seli (d) = di, and
consI' (selI' (d),... , selI' (d)) = d. Then as previously, we define the sets E  and F
1	k	p	p
by:
E = {⟨selI' (d),... , selI' (d)⟩| d ∈ D },
p	1	k	p
Fp = Dk \ Ep.
Let D' be a set disjoint from Fp ∪ Dp, such that there exists a bijection ηp from

F  to D' . For every element t = ⟨d ,... ,d ⟩ in F , we define selI' (η (t)) = d
for

p	p	1	k	p	i	p	i
i = 1,... , k, and consI' (d ,... ,d )= η (t). Finally, we let D	= D   D' , and it

1	k	p
p+1	p	p

is clear that Dp+1 satisfies the required property.
Let D' =	i≥0 Di, then I' is an interpretation on D'. By construction, for
every ⟨d ,... ,d ⟩ ∈ D'k, the image consI' (d ,... ,d ) is well-defined.	Also by
1	k	1	k

construction, we have that selI' (consI' (d ,... ,d )) = d
and for every d ∈ D',

'	I'
i	1	k	i
I'

consI (sel1 (d),... , selk (d)) = d. Thus, M ' is a model for Ax(YÐ£k). Further- more, since I and I' both interpret constants the same way and f I and f I' are identical on D for every f ∈ Σsel , M ' is also a model for S.	 

Example 3.6 Consider the case where k = 1, and let S = {cons(c')  c}. The YÐ£1-reduced form of S is therefore S' = {sel1(c)  c'}. We consider the model M = (N,I) of Ac ∪ {(ext)}∪ S', where I interprets c as 0, c' as 1, and sel1 as the successor function on natural numbers. Then we have
D0 = N, E0 = N \ {0}, and F0 = {0},
and for every d ∈ E , consI' (d) is the d' such that selI' (d') = d, hence consI' (d) is

0
the predecessor of d.
We now select a set D'
1

disjoint from F0 ∪ D0 such that there exists a bijection

'	0	'	I'
from F0 to D0. We can for example choose D0 = {−1}, then define sel1 (−1) = 0,
consI' (0) = −1, and let D = N ∪ {−1}. Then F = {−1} and we can choose D' =
1
{−2}, etc. At the end, we obtain M ' = (D',I'), where D' = Z, I' interprets sel1 as the standard successor function on integers, and cons as the standard predecessor function on integers. It is clear that M ' is a model of Ax(YÐ£k) ∪ S.
It is also possible to define a notion of YÐ£k-reduction where every occurrence of the seli’s is removed. However, no additional property is gained by using this other alternative, and the corresponding reduction is less intuitive.

From Ac to Ac[n]
The set Ac being infinite, £У cannot be used as a satisfiability procedure on any set of the form Ac ∪ {(ext)}∪ S, where S is an YÐ£k-reduced set of literals. Thus, the next move is to bound the number of axioms in Ac needed to solve the satisfiability problem, and try to consider an Ac[n] instead of Ac. It is clear that for any n and any set S, a model of Ac ∪ {(ext)} ∪ S is also a model of Ac[n] ∪ {(ext)} ∪ S, the difficulty is therefore to determine an n for which a model of Ac ∪ {(ext)}∪ S is guaranteed to exist, provided Ac[n] ∪ {(ext)} ∪ S is satisfiable. The following example provides the intuition that this bound depends on the number of selectors in S.
Example 4.1 Let S = {sel1(c1)  c2, sel2(c2)  c3, sel3(c3)  c4, c1  c4}. Then:
Ac[1] ∪ {(ext)}∪ S and Ac[2] ∪ {(ext)}∪ S are satisfiable,
Ac[3] ∪ {(ext)}∪ S and  Ac ∪ {(ext)}∪ S	are unsatisfiable.
We will prove that having n occurrences of selectors implies that it is indeed sufficient to consider Ac[n] instead of Ac. We start by introducing the notion of an M -path.
Definition 4.2 Let M = (D, I) be a model for an YÐ£k-reduced set of literals S. For every m ≥ 2, a tuple p = ⟨d1, f1, d2, f2,... , dm, fm⟩ is called an M -path if for i = 1,... , m,
fi ∈ Σsel ,

for all j ∈ {i + 1,... , m}, dj /= di,
if i ≤ m − 1, then di+1 = f I(di).
The length of p is m, we say that p is cyclic if f I (dm)= d1, and acyclic otherwise.
Intuitively, there is an M -path of length m from d to d' if and only if we have
f I (f I	(... (f I(d)) .. .)) = d'. Thus, if d = d', then I violates one of the axioms
m  m—1	1
t[x] / x, where t is of depth m.
Example 4.3 Consider the case where k = 2, let S = {sel1(c)  c1, sel2(c)  c2}, D = {1, 2, 3}, and define:

I(c)  = 1,	I(c1) = 2,	I(c2) = 3,
selI (1) = 2,	selI (2) = 3,	selI (3) = 1,
1	1	1
selI (1) = 3,	selI (2) = 3,	selI (3) = 2.
2	2	2
Then M = (D, I) is a model for S, ⟨1, sel1, 2, sel1⟩ is an acyclic M -path of length 2, and ⟨1, sel1, 2, sel2, 3, sel1⟩ is a cyclic M -path of length 3.
We have the following obvious property:
Proposition 4.4 Let M be a model for a set of literals and l ∈ N, then M |= Ac[l]
if and only if the length of every cyclic M -path is strictly greater than l.
In Lemma 4.8, we will show how to construct a model M ' for Ac[n + 1]∪{(ext)}∪ S, given a model M for Ac[n]∪{(ext)}∪S. The construction involves breaking cyclic M -paths while preserving satisfiability, and this preservation will be guaranteed for M -paths containing selector-free elements.
Definition 4.5 Given a set S of YÐ£k-reduced literals and M = (D, I) a model for S, we say that an element d ∈ D is selector-free in S if and only if for no f (c)  c' ∈ S (where f ∈ Σsel ), is c interpreted as d.
Example 4.6 In Example 4.3, element 1 is not selector-free in S, since sel1(c) 
c1 ∈ S and I(c)= 1. However, elements 2 and 3 both are.
Intuitively, an element is selector-free if its images by the selI ’s are not con- strained to be the images of constants in S. This will allow us in Lemma 4.8 to define an interpretation I' that does not interpret the seli’s as I does, but still satisfies S.
Proposition 4.7 Let M = (D, I) be a model for a set S containing l occurrences of selectors, and let p be an M -path of length at least l + 1. Then at least one of the elements appearing in p is selector-free in S.
Proof. Let m = l + k, where k ≥ 1, p = ⟨d1, f1,... , dm, fm⟩, and suppose that no element appearing in p is selector-free in S. Then by definition, for every j = 1,... , m, there must be a literal fj(cj)  c' appearing in S, such that I(cj )= dj. By

d4	d4
d3	d5	d3

d2	d1	d2	d1
Fig. 3. Breaking cyclic M -paths: d5 is selector-free
hypothesis, since p is an M -path, the dj’s are all distinct, so there must be at least
m distinct literals in S. This is impossible, since S contains l < m such literals. 
We now state the lemma relating the number of selectors in S and the sets Ac[n]
that can safely replace Ac.
Lemma 4.8 Let S be an YÐ£k-reduced set of ground flat literals and let l be the number of occurrences of selectors in S. For n ≥ l, suppose that Ac[n] ∪ {(ext)}∪ S is satisfiable. Then Ac[n + 1] ∪ {(ext)}∪ S is also satisfiable.
Proof. Let M = (D, I) be a model of Ac[n] ∪ {(ext)}∪ S. We are going to build a model M ' of {(ext)}∪ S, starting from M , such that there are no cyclic M '-paths of length smaller or equal to n + 1. Thus, M ' will also be a model of Ac[n + 1].
Let P = {p | p is a cyclic M -path of length n + 1}. If P is empty, then there are no cyclic M -paths of length n + 1, so that M |= Ac[n + 1] ∪ {(ext)}∪ S by Proposition 4.4. Otherwise let p ∈ P , since there are l occurrences of selectors in S, by Proposition 4.7 we must have p = ⟨... , d, f,.. .⟩, where d is selector-free in S, and f ∈ Σsel . Consider a set Ep = {ej | j ≥ 0} disjoint from D, and let Ip be the interpretation on D ∪ Ep which is identical to I, except that f Ip (d) = e0, and for j ≥ 0 and i = 1,... , k, selIp (ei) = ei+1 (see Figure 3). By repeating this transformation on every M -path in P , we obtain a new model M ' = (D',J), and of course, D ⊆ D'.
We now show that M ' |= Ac[n + 1] ∪ {(ext)}∪ S.
M ' |= Ac[n + 1]: By construction, there is no cyclic M '-path of length smaller or equal to n + 1, hence M ' |= Ac[n + 1] by Proposition 4.4.
M ' |= {(ext)}: Consider two elements d, d' such that f J (d)= f J (d') for all f ∈ Σsel . Note that if f J (d) ∈ D, then f J (d)= f I(d) by construction of J . Hence, if for all f ∈ Σsel , f J (d) ∈ D, then since M |= {(ext)}, we have d = d'. Otherwise, there exists a selector f such that e = f J (d) ∈/ D, and by construction, d is the unique element that is mapped to e by f J , so that it must be d = d'.
M ' |= S: Suppose that f (c)  c' ∈ S, since both I and J interpret constants the same way, we have I(c) = J (c), I(c') = J (c'), and f I(I(c)) = I(c'). Since I(c) is not selector-free in S, necessarily f I (I(c)) = f J (I(c)). We deduce that f J (J (c)) = f J (I(c)) = f I (I(c)) = I(c')= J (c'), and that M ' |= S.

A simple induction using Lemma 4.8 shows that if S is an YÐ£k-reduced set containing n selectors and Ac[n] ∪ S is satisfiable, then for every k ≥ 0, Ac[n + k] ∪ S

is also satisfiable. We therefore deduce:
Corollary 4.9 Let S be an YÐ£k-reduced set of ground flat literals and let n be the number of occurrences of selectors in S. Then, Ac ∪ {(ext)}∪ S is satisfiable if and only if Ac[n] ∪ {(ext)}∪ S is.

£У> as a satisfiability procedure
We now show that only a finite number of clauses are generated by the superposition calculus on any set Ac[n] ∪ {(ext)}∪ S, where S is YÐ£k-reduced. This will be the case provided we use an YÐ£k-good CSO:
Definition 5.1 A CSO > is YÐ£k-good if t > c for every ground compound term
t and every constant c.
Lemma 5.2 Let S0 = Ac[n] ∪ {(ext)}∪ S, where S is a finite YÐ£k-reduced set of ground flat literals. Consider the limit S∞ of the derivation S0 ▶£P> S1 ▶£P> ... generated by a fair YÐ£k-good £У>-strategy; every clause in S∞ belongs to one of the categories enumerated below:
the empty clause;
the clauses in Ac[n] ∪ {(ext)}, i.e.
t[x] / x, where t is a Σsel -term of depth at most n,
x  y V   k  (seli(x) / seli(y)) ;
ground clauses of the form
c  c' V ( m  dj / d' ) where m ≥ 0,
f (c)  c' V ( m  dj / d' ) where m ≥ 0,
t[c] / c' V( m  dj / d' ), where t is a compound Σsel -term of depth at most
n — 1 and m ≥ 0,

m j=1
dj / d' , where m ≥ 1;

clauses of the form

c  x V   j


seli (c) / seli (x)  V   k


ci / seli (x)  V


m j=1
dj / d' 


where i1,... , ik is a permutation of 1,... , k, 0 ≤ j ≤ k and m ≥ 0;
clauses of the form


c  c' V   j1

(seli (c) / seli (c'))  V  j2

(seli (c) / c'

)  V

  j3
(ci
/ seli (c'))  V   k
(ci
/ c' )  V


m j=1
dj / d' 

where i1,... , ik is a permutation of 1,... , k, 0 ≤ j1 ≤ j2 ≤ j3 ≤ k, j3 > 0 and
m ≥ 0.
Proof. We prove the result by induction on the length l of the derivations. For l = 0, the result is trivial: the clauses in S0 are in (ii) or (iii) with m = 0. Now assume the result is true for l — 1, where l ≥ 1, and that a new inference step is carried out. The result is obvious if the inference performed is a subsumption or a deletion, now suppose that the inference is a reflection. This reflection inference can occur on a clause in (ii.b), in which case a clause containing x  x is generated, hence deleted, or in category (iii), in which case the clause generated belongs to the same category or is the empty clause. We now suppose that the inference is either a simplification, a superposition or a paramodulation. For the sake of conciseness, we write “paramodulation” in all cases.
Paramodulation from (iii): any paramodulation from a clause in (iii) generates a clause in categories (iii), (iv) or (v).
Paramodulation from (ii), (iv) or (v): none applies. For clauses in category (iv), this is due to the fact that the considered clause contains either a literal selip (c) / selip (x) or cip / selip (x), both of which are greater than c  x. For clauses in category (v), this is due to the fact that for the considered clause we have j3 > 0, hence it necessarily contains a function symbol f ∈ Σsel , and the literal c  c' cannot be maximal.

Example 5.3 Consider the case where k = 3, and suppose we want to test the unsatisfiability of the following set:
S = { sel1(c)  d1, sel2(c')  d' , sel2(c)  d2,
sel1(c')  d' , sel3(c)  d3, sel3(c')  d' ,
1	3
d1  d' ,	d2  d' ,	d3  d' ,
1	2	3
c / c'	}.
A superposition of sel1(c)  d1 into {(ext)} yields a clause in (iv) (with m = 0):
c  x V sel2(c) / sel2(x) V sel3(c) / sel3(x) V d1 / sel1(x) ,


A superposition of sel2(c')  d'
into the underlined literal of this clause yields a

clause in (v):
c  c' V sel3(c) / sel3(c') V sel2(c) / d'  V d1 / sel1(c') ,
A simplification of this clause by sel2(c)  d2 yields a clause in (v):
c  c' V sel3(c) / sel3(c') V d1 / sel1(c') V d2 / d' ,

Further simplifications by sel1(c')  d' , sel3(c)  d3 and sel3(c')  d'
yield the

clause

c  c' V
1
  3

i=1
3

di / d' .

The simplifications by di   d' for i = 1,... , 3 yield the clause c   c', which
together with c / c' produces the empty clause.
Since the signature is finite, there are finitely many clauses such as those enu- merated in Lemma 5.2. We therefore deduce:
Corollary 5.4 Any fair YÐ£k-good £У>-strategy terminates when applied to
Ac[n] ∪ {(ext)}∪ S, where S is a finite YÐ£k-reduced set of ground flat literals.
We can also evaluate the complexity of this procedure by determining the number of clauses in each of the categories defined in Lemma 5.2.
Theorem 5.5 Any fair YÐ£k-good £У>-strategy is an exponential satisfiability procedure for YÐ£k.
Proof. Let n be the number of literals in S, both the number of constants and the number of selectors appearing in S are therefore in O(n). We examine the cardinalities of each of the categories defined in Lemma 5.2.
Category (ii) contains O(n) clauses if k =1 and O(kn) clauses if k ≥ 2.
Clauses in categories (iii), (iv) or (v) can contain any literal of the form d / d'
2
where d and d' are constants, thus, these categories all contain O(2n ) clauses.
2
Hence, the total number of clauses generated is bound by a constant which is O(2n ),

2
and since each inference step is polynomial, the overall procedure is in O(2n
).	 

Although this complexity bound is exponential, it measures the size of the sat- urated set. Since a theorem prover seeks to generate a proof, as opposed to a saturated set, the relevance of this result with respect to predicting the performance of a theorem prover can be quite limited.
One could actually have expected this procedure to be exponential for k ≥ 2, since in that case Ac[n] contains an exponential number of axioms. However the procedure is also exponential when k = 1, and a more careful analysis shows that this complexity is a consequence of the presence of (ext). In fact, it is shown in [2] that any fair £У>-strategy is a polynomial satisfiability procedure for the theory presented by the set of acyclicity axioms Ac when k = 1.
We finally address combination by proving that YÐ£k is variable-inactive for
£У>.
Theorem 5.6 Let S0 = Ac[n] ∪ S ∪ {(ext)}, where S is an YÐ£k-reduced set of ground flat literals, and n is the number of occurrences of selectors in S. Then S∞ is variable-inactive.
Proof. The clauses in S∞ belong to one of the classes enumerated in Lemma 5.2.
Thus, the only clauses of S∞ that may contain a literal t   x where x ∈/ Var(t)

are in class (iv). Since > is a CSO, the literals t  x cannot be maximal in those clauses.	 
This shows that the rewrite-based approach to satisfiability procedures can be applied to the combination of YÐ£k with any number of the theories considered in [3,1], including those of arrays and records with or without extensionality.

Conclusion
In this paper, we considered a class of theories representing recursive data struc- tures, each of which is defined by an infinite set of axioms. We showed that the superposition calculus can be used as the basis of a satisfiability procedure for any theory in this class, and this result was obtained by defining a reduction that permits to restrict the number of acyclicity axioms to be taken into account.
A main issue we plan to investigate is complexity, since the basic procedure is exponential. A linear algorithm for such structures was obtained in [10], but it excludes uninterpreted function symbols. The setting of [8] includes uninterpreted function symbols, but the authors gave a polynomial algorithm only for the case where k = 1 (the theory of integer offsets). We intend to investigate making the complexity of the rewrite-based procedure dependent on k, and improving the bound for k = 1.
From the point of view of practical efficiency, we plan to test the performance of a state-of-the-art theorem prover on problems featuring this theory, possibly combined with those of [3,1], and compare it with systems implementing decision procedures from other approaches. In this context, we may work on designing specialized search plans for satisfiability problems.
The work of [6] bears some similarity to ours since it is also based on a set of inference rules, and basic equational reasoning (i.e., congruence closure) is done by rewriting, as in £У. It would hence be interesting to investigate how their techniques can be applied to our framework, and in particular whether £У can be enriched with specialized inference rules to handle acyclicity instead of including the acyclicity axioms in the satisfiability problems. Another direction for future work is to examine how the rewrite-based approach applies to recursive data structures with multiple constructors.

Acknowledgement
The authors wish to thank Silvio Ranise for bringing this class of theories to their attention.

References
Alessandro Armando, Maria Paola Bonacina, Silvio Ranise, and Stephan Schulz. On a rewriting approach to satisfiability procedures: Extension, combination of theories and an experimental appraisal. In Bernhard Gramlich, editor, Proc. 5th FroCoS, volume 3717 of LNAI, pages 65–80. Springer, 2005. Full version available as [2].


Alessandro Armando, Maria Paola Bonacina, Silvio Ranise, and Stephan Schulz. On a rewriting approach to satisfiability procedures: Theories of data structures, modularity and experimental appraisal. Technical Report RR 36/2005, Dipartimento di Informatica, Università degli Studi di Verona, 2006.
Alessandro Armando, Silvio Ranise, and Michaël Rusinowitch. A rewriting approach to satisfiability procedures. Inf. Comput., 183(2):140–164, 2003.
Franz Baader and Tobias Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.
Leo Bachmair, Ashish Tiwari, and Laurent Vigneron. Abstract congruence closure. J. Autom. Reasoning, 31(2):129–168, 2003.
C. Barrett, I. Shikanian, and C. Tinelli. An abstract decision procedure for satisfiability in the theory of recursive data types. In Proceedings of PDPAR’06, 2006. Full version available at http://www.cs.nyu.edu/~barrett/pub.html#tech .
Jean-Pierre Jouannaud and Claude Kirchner. Solving equations in abstract algebras: A rule-based survey of unification. In Computational Logic - Essays in Honor of Alan Robinson, pages 257–321, 1991.
Robert Nieuwenhuis and Albert Oliveras. Congruence closure with integer offsets. In Moshe Y. Vardi and Andrei Voronkov, editors, Logic for Programming, Artiﬁcial Intelligence, and Reasoning, 10th International Conference, LPAR 2003, Almaty, Kazakhstan, September 22-26, 2003, Proceedings, volume 2850 of Lecture Notes in Computer Science, pages 78–90. Springer, 2003.
Robert Nieuwenhuis and Albert Rubio. Paramodulation-based theorem proving. In John Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Reasoning, pages 371–443. Elsevier and MIT Press, 2001.
Derek C. Oppen. Reasoning about recursively defined data structures. J. ACM, 27(3):403–411, 1980.
Ting Zhang, Henny B. Sipma, and Zohar Manna. Decision procedures for recursive data structures with integer constraints. In David A. Basin and Michaël Rusinowitch, editors, Automated Reasoning
- Second International Joint Conference, IJCAR 2004, Cork, Ireland, July 4-8, 2004, Proceedings, volume 3097 of Lecture Notes in Computer Science, pages 152–167. Springer, 2004.
