Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 309 (2014) 95–107
www.elsevier.com/locate/entcs

An Algebraic Approach to Population-Based Evolutionary Algorithm Generation
Yu-Jun Zheng1,2, Bei Zhang, Min-Xia Zhang
College of Computer Science & Technology Zhejiang University of Technology Hangzhou, China

Abstract
Evolutionary algorithms (EAs) are popular in solving a diversity of problems, but current algorithm design approaches typically require formulating an algorithmic structure for each individual problem. The pa- per presents an algebraic framework for high-level specification of general-purpose metaheuristic methods, which cover a wide range of population-based EAs. Based on specification composition and refinement, the framework support mechanical program generation for concrete problem solving. We illustrate the applica- tions of the framework in two typical optimization problems, which show that the proposed approach can achieve a high level of abstraction and mechanization without losing performance.
Keywords: Algebraic specifications, evolutionary algorithms (EAs), code generation, generic types.

Introduction
In the areas of science and engineering, a very wide class of problems are found to be computationally intractable by traditional deterministic algorithmic methods. In recent two decades, evolutionary algorithms (EAs), including genetic algorithm (GA) [5], evolutionary strategy (ES) [1], evolutionary programming (EP) [4], swarm intelligence methods [2], etc., have received great interest and achieved great success in solving such problems. In general, EAs are stochastic search methods that are mainly inspired by biological evolution and that support a parallel trial and error of a population of different solutions. They do not guarantee finding the exact optimal solution in a single simulation run, but in most cases they are capable of finding acceptable solutions in a reasonable computational time.
Rigorously speaking, EAs are not real “algorithms”; Instead they are “meta- heuristics” which are high-level strategies for designing heuristics procedures for

1 This work was supported by National Natural Science Foundation of China under Grant No. 61020106009, 61105073 and 61272075.
2 Email:zhengyujun@acm.org

http://dx.doi.org/10.1016/j.entcs.2014.12.008
1571-0661/© 2014 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/3.0/).

solving different problems, e.g., the knapsack problem, the traveling salesman prob- lem (TSP), the vehicle routing problem (VRP), etc. Nevertheless, due to the in- herent complexity and diversity of the problems, the application of an EA typically requires formulating different algorithmic structures for different problems, which leads to poor reusability, maintainability, and extensibility.
The community has advocated the use of algebraic specification and program transformation technologies to improve software productivity and quality for many years [7], and a number of development tools and environments have been proposed for this purpose [3]. However, most of those methods and tools are used only in limited areas such as real-time and embedded systems. Moreover, few works have been done on the implementation of general-purpose EAs for a wide range of problems which are often encountered in a variety of real-world applications.
In order to minimize the user efforts and ensure product quality in algorith- mic program development, we have studied the algebraic approach to transform abstract specifications to concrete programs based on data type refinement and functional refinement [10,11,15], which have been successfully applied to a set of classical algorithm design methods including dynamic programming, greedy, and branch-and-bound [13,17,18], and some heuristic methods such as tabu search [14]. The approach has been used in a number of industrial software projects and has demonstrated its advantage in software quality and productivity.
In this paper, we present a high-level but practical framework for mechanical im- plementation of population-based EAs for complex problem solving. The framework supports algebraic specification of metaheuristic methods and optimization prob- lems, and mechanical generation of algorithmic programs for concrete problems. Using algebraic specification composition and refinement techniques, our approach achieves a high level of abstraction and mechanization without losing performance in detailed implementation.
The remainder of the paper is structured as follows: Section 2 introduces the preliminaries of algebraic data types and specifications, Section 3 presents our alge- braic framework of metaheuristic EAs, including specifications of typical EAs such as GA, PSO, and biogeography-based optimization (BBO) [9]; Section 4 presents our algebraic approach to concrete program generation, and finally Section 5 con- cludes with discussion.

Preliminaries of Basic Concepts
The basic concepts and constructions used in our approach are based on algebraic data types and specifications [8]. Formally, a specification is the finite presentation of a theory with the signature describing objects, operations, and properties:
A signature Σ = ⟨S, Ω⟩ consists of a set S of sorts and operations Ω over S;
A specification SP = ⟨S, Ω, A⟩ consists of a signature Σ = ⟨S, Ω⟩ and a set of Σ-sentences A called axioms;
A specification morphism F : ⟨S1, Ω1, A1⟩ → ⟨S2, Ω2, A2⟩ maps S1 to S2 and Ω1

to Ω2 such that for each a ∈ A1 we have F (a) ∈ A2.
The following presents the algebraic specifications of basic data types Boolean
and Real respectively.


type	Boolean (abbr. B) constants true, false :→ Boolean operations ¬ : Boolean → Boolean
∧, ∨ : Boolean × Boolean → Boolean
axioms	¬true = false; ¬false = true
(b, b1, b2 : Boolean) b1 ∧ b2 = b2 ∧ b1; b1 ∨ b2 = b2 ∨ b1
false ∧ b = false; true ∨ b = true; true ∧ b = b; false ∨ b = b b ∧ (b1 ∧ b2)= (b ∧ b1) ∧ b2; b ∨ (b1 ∨ b2)= (b ∨ b1) ∨ b2
b ∧ (b1 ∨ b2)= (b ∧ b1) ∨ (b ∧ b2); b ∨ (b1 ∧ b2)= (b ∧ b1) ∨ (b ∧ b2)


type	Real (abbr. R) imports	Boolean constants 0, 1, ∞ :→ Real
operations +, −, ×,/ : Real × Real → Real
axioms	(a, a1, a2 : Real) a1 + a2 = a2 + a1; a1 × a2 = a2 × a1
0+ a = a;1 × a = a;0 × a = 0;
a /= ∞⇒ a/∞ = 0; a /=0 ⇒ a ×∞ = ∞
a + (a1 + a2)= (a + a1)+ a2; a × (a1 × a2)= (a × a1) × a2 a × (a1 + a2)= (a × a1)+ (a × a2); a1 × (a/a1)= a
...



A parameterized specification has formal parameters that are themselves spec- ifications, the binding of actual values to which is accomplished by specification morphisms. The incremental development of specifications involves developing sim- ple specifications and then importing them into more complex ones. For example, the following gives the algebraic specification of data structure Set, in which type

parameter T denotes the abstract type of set elements.


type	Set⟨T⟩ imports	Boolean, Nat sorts	T
constants ∅ :→ Set⟨T⟩
operations {} : T → Set⟨T⟩; || : Set⟨T⟩→ Nat
∈: T × Set⟨T⟩→ Boolean
⊂, ⊆: Set⟨T⟩× Set⟨T⟩→ Boolean
∪, ∩, \ : Set⟨T⟩× Set⟨T⟩→ Set⟨T⟩
axioms	(u, v : T ; U, V : Set⟨T⟩) |∅| = 0; |{u}| =1 
u ∈∅ = false; u ∈ {u} = true; u ∈ U ∪ {u} = true
∅⊂ U = true; u ∈ U ∧ U ⊆ V = u ∈ V
U ∪ V = V ∪ U ; U ∩ V = V ∩ U ; ∅∪ U = U ; ∅∩ U = ∅
¬(u ∈ U ) ⇒ U\{u} = U
...



According to the theory of algebraic data types, a specification defines a problem by specifying a domain of problem inputs and the notion of what constitutes a solution to a given input [6].


type	Problem⟨D, Z⟩
imports	B
sorts	D, Z
operations I : D → B; O : D × Z → B


where the input condition I(x) constrains the input domain D and the output condition O(x, z) describes the condition under which the output domain value z ∈ Z is feasible solution with respect to an input x ∈ D.

In particular, an optimization problem, which is typically defined on a partial ordered set (Poset), can be treated as an extension of problem as follows:
type	OptProblem⟨D, Z⟩ refines	Problem⟨D, Z⟩ imports	B, R, Set
sorts	D, Z
operations ξ : D → Set⟨Z⟩;	c : D × Z → B;	f : Z → R
axioms	(d1, d2 : D)	d1 ≤D d2 ⇒ ξ(d1) ⊆ ξ(d2)
where ξ is the generative function for generating the solution space, c is the con- straint function defining the feasibility, f is the objective function for evaluating the optimality, and ≤D is the ordering relation on D.
Algorithm Framework
A General Framework for Population-Based EAs
In its search procedure, an EA typically evolves a population of candidate solutions to a given problem, using operators inspired by natural or biological evolution. We define a very high-level specification of a population-Based EA as follows, which consists of the signatures of a problem of OptProblem⟨D, Z⟩ and a set of abstract functions:
type	Alg⟨D, Z⟩
imports	B, R, Set, List, OptProblem
sorts	D, Z;
P : OptProblem⟨D, Z⟩;	POP : Set⟨Z⟩;
OP : List⟨Z × Z → Z⟩
operations init : D × N → Set⟨Z⟩;	evol :→ Set⟨Z⟩; solve : D × N → Z;	best :→ Z;	tune :→
axioms	(z : Z)	z ∈ POP ⇒ P.f (best()) ≤ P.f (z)
In the above specification, init is used for initializing a set of solutions for a given problem input d, evol performs an iteration of evolution of the algorithm, solve runs a given number of iterations to produce a result solution, best returns the optimal solution found so far, and tune adjusts related control parameters after each iteration; POP maintains a population of solutions, and OP is a set of evolutionary operators of the algorithm.
Among the abstract functions, the default implementation of evol applies each evolutionary operator to the solutions in POP one by one:

def fun evol() : Set⟨Z⟩
begin
let POP 1= new Set⟨Z⟩();
for each z ∈ POP do
POP 1 → POP 1 ∪ {z};
for each o ∈ OP do
for each z ∈ POP 1 do
z → o(z);
best();
tune();
return POP1;
end
And the default implementation of solve evolves the population for a given number of generations:
def fun solve(d : D; size, iters : N): Z
begin
POP → init(d, size);
for k =1 to iters do
POP → evol();
return best();
end

Speciﬁcations of Typical EAs
By specifying different evolutionary operators and their application procedures, the top-level specification Alg can be refined to different EA specifications. GA is such a typical EA that uses two well-known evolutionary operators: crossover and mutation, and the specification of GA can be easily defined based on Alg:
type	GA⟨D, Z⟩
refines	Alg
imports	B, R, Set, List, OptProblem
operations mutate : Z → Z;	crossover : Z × Z → Z × Z; select : Set⟨Z⟩→ Z
Note that the crossover operator of GA takes two parent solutions and produces two child solutions, and its signature does not meet that defined in specification Alg. Thereby, we redefine its evol operator by overriding the default implementation in Alg:
Beside overriding a default implementation, another common way to tackle with variation of operation signatures is wrapping. For example, the BBO algorithm uses a migration operator that migrate features from a probably high quality solution to a low quality one. The following specification defines a selMigrate to perform

override fun evol() : Set⟨Z⟩
begin
let POP 1= new Set⟨Z⟩();
while |POP 1| < |POP| do
let z1 = select(POP ), z2 = select(POP ); POP 1 → POP 1 ∪ {corssover(z1, z2)}; for each z ∈ POP 1 do
z → mutate(z); best();
return POP1;
end


such an operation, and lets OP contains the other three functions that satisfy the signatures defined in Alg:
type	BBO⟨D, Z⟩
refines	Alg
imports	B, R, Set, List, OptProblem
sorts	OP = {migrate, mutate}
operations migrate : Z → Z;	mutate : Z → Z; selMigrate : Z × Z → Z;	select : Set⟨Z⟩→ Z;
And the migrate function encapsulates selMigrate in its default implementation as follows:


def fun migrate(z : Z): Z
begin
let z1 = select(POP );
return selMigrate(z, z1);
end


The following presents the algebraic specification of the PSO algorithm and its standard implementations of main operations, where Particle is a data type extends the basic definition of problem solution.
type Particle⟨Z⟩
sorts z : Z;	pb : Z;	v : V ector

type	PSO⟨D, Z⟩
refines	Alg
imports	B, R, Set, List, OptProblem
sorts	POP = List⟨Particle⟨Z⟩⟩;	PB : List⟨Z⟩; gb : Z;	w, c1, c2 : R;
OP = {learn, move}
operations learn : Z → Z;	move : Z × V ector → Z;

def fun learn(z : Z): Z
begin
z.V → w ∗ (z.V + rand() ∗ c1 ∗ (z.pb − z.z)+ rand() ∗ c2 ∗ (gb − z.z));
z.z → move(z.z, z.V );
return z;
end


Program Generation for Concrete Problem Solving
Given a concrete problem specification of OptProblem⟨D, Z⟩, the process for gener- ating algorithmic program from the algebraic specification can be divided into the following steps:
Construct the refinement morphisms from type parameters in the algebraic specification to their concrete types;
For each abstract function in the specification, if no user-defined implementa- tion is provided, then use its default implementation in the framework;
Construct the refinement morphisms from abstract functions to their imple- mentations;
Generate the concrete algorithmic program by colimit computation on generic specification and its refinements [16];
Transform the abstract algorithmic program to one or more executable pro- grams [12].
Next we illustrate the process using two different problems.

Algorithms for Integer Programming
Integer programming problem is a class of mathematical optimization problems where the decision variables are restricted to integer values. Based on our algebraic

framework, an integer programming problem can be specified as:
type	IPProblem
refines	OptProblem⟨V ector⟨Z⟩→ R,V ector⟨Z⟩⟩
imports	B, Z, R,V ector, Set
sorts	obj : V ector⟨Z⟩→ R
V L, VU : V ector⟨Z⟩
refinement with c d z = ∀i : (0 ≤ i < |d|): V L[i] ≤ d[i] ≤ V U [i]; f = obj
To apply the GA specification to the problem, we respectively construct the morphisms from the crossover and mutate operations to the following two imple- mentations:


fun crossover(z1, z2 : Z): Z × Z
begin
let p = rand(1, |z|− 1);
let zj = z1[0..p]#z2[p + 1..];
let zj = z2[0..p]#z1[p + 1..];
return (zj , zj );
1	2
end





fun mutate(z : Z): Z
begin
if rand() < mr //mutation rate
let p = rand(0, |z|);
z[p] → round(V L[p]+ rand() ∗ V U [p]);
return z;
end


Based on categorical computation, we directly work out the following GA pro- gram for solving an integer programming problem:

Algorithm 1 GA
POP : Set⟨V ector⟨Z⟩⟩; mr : R
fun main(d : IPProblem; size, iters : N)
begin
POP → init(d, size);
for k =1 to iters do
POP → evol();
return best();
end
fun init(d : IPProblem; size : N): Set⟨V ector⟨Z⟩⟩
begin
POP → newSet⟨V ector⟨Z⟩⟩();
for k =1 to size do
POP → POP ∪ {rand(V L, V U )};
return POP;
end
fun evol() : Set⟨V ector⟨Z⟩⟩
begin
let POP 1= new Set⟨V ector⟨Z⟩⟩();
while |POP 1| < |POP| do
let z1 = select(POP ), z2 = select(POP );
let p = rand(1, |z|− 1);
let zj = z1[0..p]#z2[p + 1..];
let zj = z2[0..p]#z1[p + 1..];
POP 1 → POP 1 ∪ {zj , zj )};
1	2
for each z ∈ POP 1 do if rand() < mr
p → rand(0, |z|);
z[p] → V L[p]+ rand() ∗ V U [p];
best();
tune();
return POP1;
end
If we use PSO to solve the integer programming problem, we can keep the default implementation of learn and simply construct the morphisms from move to the following implementation, and thereby obtain a PSO program for integer programming (the detailed code is omitted here).
fun move(z : V ector⟨Z⟩,v : V ector): V ector⟨Z⟩
begin
for k =0 to |z|− 1 do
z[k] → round(z[k]+ v[k]);
return z;
end

Algorithms for the Traveling Salesman Problem
The traveling salesman problem (TSP) is a well-known combinatorial optimization problem, which takes a weighted graph as the input and a Hamiltonian cycle of the graph with minimum weight as a solution. A weighted graph can be represented by a matrix of real numbers and a Hamiltonian cycle can be represented by a permutation of nodes, and thus the TSP can be specified as:
type	TSP
refines	OptProblem⟨Matrix, Perm⟩
imports	B, Z, R, Matrix, Set, Perm
refinement with ξ d = allperms(|a|);
c d z = (|z| = |m|);
fz = Σ|z|−2 m[i, i + 1]+ m[|z|− 1, 0]
If we use BBO to solve the TSP, the migration operation can be used for migrat- ing a subsequence of the emigrating solution to the current one, meanwhile keeping the solution a permutation. Thus the target implementation can be respectively defined as:

fun selMigrate(z, z1 : Perm): Perm
begin
let p1 = rand(0, |z|− 2); p2 = rand(p1, |z|− 1);
for k = p1 to p2 do
let p = indexof (z1[k], z); (z[k], z[p]) → (z[p], z[k]);
return z;
end

And the mutate operation can be simply defined as swapping two randomly chosen nodes in the permutation:

fun mutate(z : Perm): Perm
begin
let p1 = rand(0, |z|− 2); p2 = rand(p1, |z|− 1); (z[p1], z[p2]) → (z[p2], z[p1]);
return z;
end

The result BBO program for solving the TSP is as follows:

Algorithm 2 BBO
POP : Set⟨Perm⟩; ems, ims, ms : List⟨R⟩;//emigration, immigration, and mutation rates
fun main(d : TSP ; size, iters : N)
begin
POP → init(d, size);
for k =1 to iters do
POP → evol();
return best();
end
fun init(d : TSP ; size : N): Set⟨Perm⟩
begin
POP → newSet⟨Perm⟩();
for k =1 to size do
POP → POP ∪ {randperm(|d|)};
return POP;
end
fun evol() : Set⟨Perm⟩
begin
let POP 1= new Set⟨Perm⟩();
for each z ∈ POP do if rand ≤ ims(z)
let z1 = select(POP );
let p1 = rand(0, |z|− 2); p2 = rand(p1, |z|− 1);
for k = p1 to p2 do
let p = indexof (z1[k], z);
(z[k], z[p]) → (z[p], z[k]); POP 1 → POP 1 ∪ {z)};
for each z ∈ POP 1 do if rand() < ms(z)
p1 → rand(0, |z|− 2); p2 → rand(p1, |z|− 1);
(z[p1], z[p2]) → (z[p2], z[p1]); best();
tune();
return POP1;
end

Conclusion
The paper presents an algebraic framework for high-level specification of general- purpose metaheuristic methods and mechanical generation of algorithmic programs for concrete problem solving. Our algebraic approach is mathematically abstract and computationally efficient. Currently we are extending the approach to support

algorithms for multiobjective optimization problems.

References
Beyer, H.-G. and H.-P. Schwefel, Evolution strategies -- a comprehensive introduction, Natural Comput.
1 (2002), pp. 3–52.
Bonabeau, E., M. Dorigo and G. Theraulaz, 4, Oxford University Press, New York, 1999.
Claszen, I., H. Ehrig and D. Wolz, “Algebraic specification techniques and tools for software development: the ACT approach,” World Scientific, 1993.
Fogel, L. J., A. J. Owens and M. J. Walsh, “Artificial intelligence through simulated evolution,” John Wiley & Sons Chichester, 1967.
Holland, J. H., “Adaptation in Natural and Artificial Systems: An Introductory Analysis with Applications to Biology, Control and Artificial Intelligence,” MIT Press, Cambridge, MA, USA, 1992.
Lowry, M., “Algorithm synthesis through problem reformulation,” Ph.D. thesis, Stanford University (1989).
Partsch, H., “Specification and transformation of programs: a formal approach to software development,” Springer, 1990.
Sannella, D. and A. Tarlecki, Essential concepts of algebraic specification and program development, Formal Aspects of Computing 9 (1997), pp. 229–269.
Simon, D., Biogeography-based optimization, IEEE Trans. Evol. Comput. 12 (2008), pp. 702–713.
Xue, J., A unified approach for developing efficient algorithmic programs, Journal of Computer Science and Technology 12 (1997), pp. 314–329.
Xue, J., Formal derivation of graph algorithmic programs using partition-and-recur, Journal of Computer Science and Technology 13 (1998), pp. 553–561.
Xue, J., Par method and its supporting platform, in: Proc. 1st Intl Workshop of Asian Working Conf. Verified Software, Macao, China, 2006, pp. 11–20.
Zheng, Y., H. Shi and J. Xue, Toward a unified implementation for dynamic programming, High Technology Letters 12 (2006), pp. 31–34.
Zheng, Y., H. Shi and J. Xue, An algebraic approach to mechanical tabu search algorithm generation, in: IEEE International Conference on Progress in Informatics and Computing, 2010, pp. 988–992.
Zheng, Y. and J. Xue, A problem reduction based approach to discrete optimization algorithm design, Computing 88 (2010), pp. 31–54.
Zheng, Y., J. Xue and W. Liu, Object-oriented specification composition and refinement via category theoretic computations, in: J.-Y. Cai, S. Cooper and A. Li, editors, Theory and Applications of Models of Computation, Lecture Notes in Computer Science 3959, Springer Berlin Heidelberg, 2006 pp. 601–610.
Zheng, Y., J. Xue and H. Shi, A category theoretic approach to search algorithms: Towards a unified implementation for branch-and-bound and backtracking, in: 4th International Conference on Computer Science Education, 2009, pp. 845–850.
Zheng, Y., J. Xue and Z. Zuo, Toward an automatic approach to greedy algorithms, in: X. Deng,
J. Hopcroft and J. Xue, editors, Frontiers in Algorithmics, Lecture Notes in Computer Science 5598, Springer Berlin Heidelberg, 2009 pp. 302–313.
