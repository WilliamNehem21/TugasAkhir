Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 352 (2020) 191–209
www.elsevier.com/locate/entcs

A Pebbling Comonad for Finite Rank and Variable Logic, and an Application to the Equirank-variable Homomorphism Preservation Theorem
Thomas Paine1
Computer Science Department, University of Oxford

Abstract
In this paper we recast the proof of Rossman’s equirank homomorphism preservation theorem using comonadic formulations of bounded quantifier rank and variable count (and dually tree width and tree- depth), and work towards generalisation of it that simultaneously preserves quantifier rank and variable count. Along the way, we give an exposition of the required comonads, showing how their properties arise.
Keywords: Pebble Games, Pebbling Comonad, Finite Rank logic, Finite Variable logic, Tree-depth, Tree-width


Introduction
First-order sentences can be graded by quantifierrank (nesting depth of quanti- fiers) and variablecount (number of variables used in a formula). These play an important role in model Finite Model Theory and Descriptive Complexity (see [3] and [7]), representing an idea of bounding resources during computation. The cor- responding notions to these on the side of first-order structures are the parameters known respectively as tree-depth and tree-width, which have been extensively stud- ied, primarily as graph parameters, though they can also be applied to first-order structures. The latter is particularly well known as many difficult to solve problems become tractable on classes of bounded tree-width (the most notable result perhaps is Courcelle’s theorem in [4], which says that that every graph property definable in the monadic second-order logic of graphs can be decided in linear time on graphs of bounded tree-width). The introduction of the pebbling comonad in [1] gives a

1 Email: thomas.paine@cs.ox.ac.uk

https://doi.org/10.1016/j.entcs.2020.09.010
1571-0661/Crown Copyright © 2020 Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

semantic account of the interaction between first-order structures and formulas of bounded variable count. In addition, the parameter of tree-width is given a semantic description via looking at coalgebras of the pebbling comonad. In the first section we give a brief overview of brief overview of the quantifier rank and variable count, and their relationship to tree-width and tree-depth. In the second, we synthesise the pebbling comonad, and the Ehrenfeucht-Fraisse comonad from [2] (which is an analogue of the pebbling comonad but for quantifier rank) into one which simulta- neously captures quantifier rank and variable count, and whose coalgebras can be used to capture both tree-depth and tree-width. This is a minor modification of the comonads found in [1] and [2], in order to move on to the material in the third section, though also novel to this paper is how to generalise the comonads to deal with constants in the signature, and free variables.
A preservation theorem in model theory is a equivalance between a semantic property and a syntactic restriction of a first order sentence, however the content is almost always in finding a syntactic restriction given a semantic. For example, the classic homomorphism preservation theorem of model theory is as follows:
Theorem 1.1 A ﬁrst-order sentence is preserved under homomorphisms between structures, if and only if there exists a semantically equivalent positive existential ﬁrst order sentence.
This was improved by Rossman in [8], who showed that one can preserve the quantifier rank of the formula:
Theorem 1.2 (Rossman’s Equirank Homomorphism Preservation Theorem) Let φ be a formula of quantiﬁer rank n. Then it is preserved under homomorphisms between ﬁrst-order structures, if and only if there exists a semantically equivalent positive existential formula of quantiﬁer rank at most n.
In the third section of this paper we follow Abramsky’s idea of using the comon- ads to give a proof of the Equirank HPT in a more categorical style. Further, the apparent uniformity of the comonads used to characterise formulas of bounded quantifier rank and those used to characterise formulas of bounded quantifier rank and variable count serves as good motivation for Abramsky’s conjectured generali- sation, which we will refer to as the (n, k)-preservation conjecture:
Conjecture 1.3 (Abramsky’s Equirank-Variable Preservation Conjecture) Let φ be a formula of quantiﬁer rank n, using at most k variables. Then it is preserved under homomorphism if and only if there exists a semantically equivalent positive existential formula of quantiﬁer rank at most n, that uses at most k variables.
The reverse implication is clear straightforward so the implication is what discuss in the third section. We attempt a naive translation of the proof of the Equirank HPT by replacing the use the comonads used to characterise formulas of bounded quantifier rank and those used to characterise formulas of bounded quantifier rank and variable count. This fails for arbitrary quantifier rank n and variable count k, though works in the case when k ≥ n − 2. We include a discussion of where the proof fails to translate and indicate a number of results that would imply the

general case.



Model Theoretic Background
This is intended as background material so discussed briefly, with sketched proofs. See [5] for more details.
Let σ be a finite, purely relational signature. We let L(l) denote first-order formulas over σ with free variables occurring in x1, ..., xl (and write L := L(0), ie sentences over σ). We are interested in various fragments of L(l), as mentioned in the introduction. Let Ln,k(l) be the fragment of L(l) of quantifier rank at most n, and with at most l variables. Note that the free variables do come out of the total number of allowed variables, and that rebinding variables with different quantifiers is necessary for full expressivity when limiting the variable count (for instance, the existence of a walk of length n in in a directed graph can be expressed by a sentence in Ln,2)). We define Ln(l) := Ln,n(l). It can be easily checked that a formula of quantifier rank n can fruitfully use at most n variables, so this semantically captures captures all formulas of quantifier rank n (with any number of variables), and we need never consider the case k > n.
We are also interested existential positive formulas, due to their close ties with homomorphisms, which are those constructed using {∃, ∧, ∨} as their only connectives. We decorate a fragment with a superscript + to denote the subset of that fragment consisting only of existential positive formulas. We use similarly use a superscript ’prim’ for primitive positive formulas, constructed using only {∃, ∧}. It should be noted that for each of the above fragments, all of its existential positive formulas can be expressed as disjunctions of primitive positive formulas from it.
We immediately here point out the very important fact:
Lemma 1.4 Ln,k(l) is ﬁnite (up to equivalence of formulas).
This is proved by induction on the quantifier rank. It depends very much on the

assumption that σ is finite and relational. As a rather obvious consequence, L+
(l),

and Ln,kprim(l) are also finite.
We associate to σ also a category Rσ whose objects first-order structures, that is to say sets (called the universe of the structure) equipped with interpretations of each R ∈ σ. We commit the abuse of notation to by using the same symbol for the universe and the structure. Morphisms between these structures are the usual set maps between their universes that preserve the interpretation of the relations. Structures interpret sentences in the usual way. We also define a category Rσ(l) whose objects are of form (A, a¯) where A ∈ Rσ, a¯ ∈ Al, and whose morphisms are morphims f : A → B ∈ Rσ such that f (ai)= bi for i = 1,, l. Structures from Rσ(l) can be used to interpret formulas from L(l) by using the tuple a¯ to interpret the

free variables.
For (A, a¯), (B, ¯b) ∈ Rσ(l) we use (A, a¯) → (B, ¯b) to denote the existence of a morphism f : (A, a¯) → (B, ¯b). If A and B are finite, this is equivalent to saying that for every φ ∈ L+(l), (A, a¯) |= φ =⇒ (B, ¯b) |= φ. This prompts the following definition which may be thought of approximating the existence of a homomorphism:

Definition 1.5 We write (A, a¯) →n,k (B, ¯b) for every ψ ∈ L+
(l), (A, a¯) |= ψ =⇒

(B, ¯b) |= ψ.
We write (A, a¯)  n,k (B, ¯b) for (A, a¯) →n,k (B, ¯b) and (B, ¯b) →n,k (A, a¯).
We use →n in place of →n,n.

Notice that since every φ ∈ L+
(l) can be written as a disjunction of formulas

from Ln,kprim(l) we could instead just quantify formulas over Ln,kprim(l) in the above definition if we preferred. We can grade elementary equivalence in a similar way:
Definition 1.6 We write (A, a¯) ≡n,k (B, ¯b) for every ψ ∈ Ln,k(l), (A, a¯) |= ψ =⇒ (B, ¯b) |= ψ.
We use ≡n in place of ≡n,n.
We now define tree depth and tree width via forest covers and k-labellable forest covers. Bounding respectively tree depth and tree width can be thought of as the analogue of bounding quantifier rank and variable count, which we will see shortly.
We will say for a rooted forest (F, r¯) (where F is the vertex set and r is a the set of roots) a branch is the unique path from a vertex to its root and the depth of the forest will be the maximum number of vertices occurring in a single branch.
Definition 1.7 • The Gaifman graph of A ∈ Rσ, G(A), is an undirected simple graph with vertex set A, and an edge between a1, a2 if they occur together in some guarded tuple of A (that is to say, there is a relation R ∈ σ and tuple a¯ ∈ RA containing a1, a2).
A forest cover of a graph G is a rooted forest (F, r¯) on the same vertex set, such that whenever there is an edge a1, a2 in G, they occur together in some branch of F .
A k − labelled forest cover of a graph G is a forest cover (F, r¯) along with a labelling of the vertices c : F → {1, ..., k} such that whenever there is an edge a1, a2 in G, and a1 is an ancestor of a2 (that is to say, a1 lies on the unique path from a2 to its root), then for any a3 on the unique path from a1 to a2, we have c(a3)= c(a1) =⇒ a3 = a1 (or in other words, the label of a1 is not used again on the path to a2, including at a2, whenever there is an edge a1, a2 in G).
Definition 1.8 • An (n, k) − cover of (A, a¯) is k-labelled rooted forest cover of
G(A) of depth at most n
An (n, k) − cover of A is k-labelled rooted forest cover of G(A) of depth at most n + l with unique root a1, and such that the unique child of ai is ai+1 for

i = 1, ..., l − 1 (one may think of this as takinga forest cover of G(A) −{a1, ..., al} and then adding the remaining elements in a path at the top). For convenience, we will also insist a1, .., al all have different labels in an (n, k)-cover.
The tree depth of (A, a¯) is the least n such that there exists an (n, k)-cover of (A, a¯) for some k (if one exists); or, equivalently, that there exists an (n, n)-cover (since one only needs at most n-labels label a forest of height n).
The tree width of (A, a¯) is the minimal k such that there exists a k-labelled forest cover minus one (subtracting one is a convention so that a tree always has tree width 1)
We will largely focus on structures with (n, k)-covers, which one might think of as simultaneous depth-width decompositions of structures. There is an explicit link between (n, k)-covers, and quantifier rank and number of variables using canonical queries.
Definition 1.9 For a finite structure (A, a¯), and some preferred ordering of its universe a1, ..., al, .., am (where a¯ = (a1, ..., al)), we define its canonical query, φ(A,a¯), to be:
φ(A,a¯)(x¯) := ∃xl+1, ..., ∃xm ^{R(x1, ..., xj): R ∈ σ, (a1, ..., aj) ∈ RA}
The canonical query is semantically characterised by the following property:
Lemma 1.10 For (A, a¯), (B, ¯b) in Rσ(l), (where (A, a¯) is ﬁnite), B |= φ(A,a¯) ⇐⇒
(A, a¯) → (B, ¯b)
Proof. This is proved by noting the the (slightly sharper) correspondence between witnesses for φ(A,a¯) in (B, ¯b) and maps f : (A, a¯) → (B, ¯b).	2
Lemma 1.11 If (A, a¯) has an (n, k)-cover, then φ(A,a¯) is equivalent to a formula
φ ∈ Ln,kprim(l).
Proof. The intuition for this is to write a sentence on the forest cover of the struc- ture, with each vertex corresponding to a quantifier (or free variable, in the case of a1, ..., al). At a vertex a, we quantify with variable xc(a) (recall c(a) is the label of a), and list all atomic propositions true of a and its ancestors whose label has not been reused. The structure of an (n, k)-cover ensures we do not miss any atomic propositions.	2
We can also associate a structure to a given primitive positive sentence, called the term model:
Definition 1.12 Let φ ∈ Ln,kprim(l). For notational convenience, rewrite φ using variables xj where the variables x1,	, xk are used in φ, and the superscript j denotes
number of times xi has been quantified over so far (use j =0 when xi occurs free).
Define Cφ to be the structure with universe {cj : xj occurs in ψ}∪ {c0,	, c0} (to
i	i	1	l
ensure we have a witness for each of the free variables, even if they satisfy no rela-

tions) distinguished elements (c0, ..., c0), and satisfy atomic relations R(cj1 , ..., cjm )
1	l	i1	im
if and only if R(xj1 , ..., xjm ) occurs in φ.
i1	im
Lemma 1.13 For φ ∈ Ln,kprim(l), (B, ¯b) ∈ Rσ(l), Cφ → (B, ¯b) ⇐⇒ (B, ¯b) |= φ.
Proof. Indeed, there is a sharper correspondence: {tuples witnessing φ in (B, ¯b)}↔ 
{maps f : Cφ → (B, ¯b)}.	2
Lemma 1.14 If φ ∈ Ln,kprim(l), then Cφ has an (n, k)-cover.
Proof. Use the direct scope relation between quantifiers as the parent relation in the forest cover, and the labelling of the variables in φ for the labelling of the forest cover.	2
Lemma 1.15 For each n, k, l there exists a ﬁnite set of ﬁnite structures Fn,k,l ⊂ Rσ(l), each with an (n, k)-cover, with the property that for every (A, a¯) ∈ Rσ(l) there exists (C, c¯) ∈ Fn,k,l such that (A, a¯)  n,k (C, c¯).
Proof. To get such a set, choose finitely many formulas φ ∈ Ln,kprim(l) to cover Ln,kprim(l), up to equivalence of formulas, and take Fn,k,l to be the set of term models for these formulas. Now, if (A, a¯) ∈ Rσ(l), we can find φ ∈ Ln,kprim(l) such that φ :=  {φ ∈ Ln,kprim(l): (A, a¯) |= φ}. We will have that Cφ  n,k (A, a¯).   2
We note that the above lemma relies on finiteness of the signature σ, and is simply the analog of choosing representatives for the finite up to equivalence set Ln,kprim(l). We fix an arbitrary choice of sets for each n, k, l, with the above prop- erty, throughout the rest of the paper.
We can in fact rephrase the →n,k relation from the perspective of structures:
Lemma 1.16 For (A, a¯), (B, ¯b) ∈ Rσ(l) (A, a¯) →n,k (B, ¯b) if and only if for every
(C, c¯) ∈ Rσ(l) with an (n, k)-cover, (C, c¯) → (A, a¯) =⇒ (C, c¯) → (B, ¯b).
Proof. We make use of the canonical queries in one direction and the structures
Cφ in the other.	2
And further we can rewrite the (n, k)-preservation conjecture, via the following lemma:
Lemma 1.17 A class M of structures is preserved under →n,k (that is to say: if
(A, a¯) ∈ M and (A, a¯) →n,k (B, ¯b) then (B, ¯b) ∈ M) if and only if there is some

+
n,k
(l) such that Mod(φ)= M.

Proof. The reverse direction is clear. For the forwards direction, the key is to define Fj := {(C, c¯) ∈ Fn,k,l : (C, c¯) ∈ M}, and set
φ =  {φ(C,c¯) : (C, c¯) ∈ Fj}
. It can be easily verified that φ satisfies the required properties.	2
Corollary 1.18 A formula ψ ∈ L is preserved under →n,k if and only if there is

some φ ∈ L+
(l) semantically equivalent to it.

Via the above lemma, we can now state the structural version of the (n, k)- preservation conjecture:
Conjecture 1.19 Any class M of structures preserved under ≡n,k and → is pre- served under →n,k.
This version is akin to what is proved in [8], and what we will focus on. The (n, k)-preservation conjecture would follow from this setting M = Mod(ψ) for a given ψ preserved under →. Setting n equal to the quantifier rank of ψ and k equal to the number of variables in the conjecture above, followed by applying the lemma, gives the required result.
Game Comonads
Here we cover the Game Comonads needed for later, which we will motivate by us- ing the recursive characterisation of →n,k. These will simultaneously capture →n,k and (n, k)-covers as features of the comonad. Comonads of this type were first in- troduced in [1], and further explored in [2].
We present the recursive definition of →n,k (recursing on n, for fixed k). We say a partial morphism from A to B is a partial map from A → B that is a morphism on the substructure of A induced by the domain of the partial map, and use a¯[α/ai] to denote the tuple a¯ where the ith entry has been swapped with α
Definition 2.1 • (A, a¯) →0,k (B, ¯b): The assignment ai '→ bi defines a partial morphism from A to B.
If n > 0,l < k, then (A, a¯) →n,k (B, ¯b): The assignment ai '→ bi defines a partial morphism from A to B, and for every α ∈ A, there exists β ∈ B such that (A, a¯, α) →n−1,k (B, ¯b, β).
If n > 0,l = k, then (A, a¯) →n,k (B, ¯b): The assignment ai '→ bi defines a partial morphism from A to B, and for every α ∈ A i ∈ {1, ..., l}, there exists β ∈ B such that (A, a¯[α/ai]) →n−1,k (B, ¯b[β/bi]).
We abuse notation here slightly, by using the same symbol →n,k. It can be proved by induction that the above characterisation of of →n,k agrees with the others already shown. We also have a recursive characterisation of ≡n,k:
Definition 2.2 • (A, a¯) ≡0,k (B, ¯b): The assignment ai '→ bi defines a partial isomorphism from A to B.
If n > 0,l < k, then (A, a¯) ≡n,k (B, ¯b): The assignment ai '→ bi defines a partial isomorphism from A to B, and for every α ∈ A, there exists β ∈ B such that (A, a¯, α) ≡n−1,k (B, ¯b, β), and for every β ∈ B, there exists α ∈ A such that (A, a¯, α) ≡n−1,k (B, ¯b, β).
If n > 0,l = k, then (A, a¯) ≡n,k (B, ¯b): The assignment ai '→ bi defines a partial isomorphism from A to B, and for every α ∈ A, there exists β ∈ B such that

(A, a¯[α/ai]) ≡n−1,k (B, ¯b[β/bi]), and for every β ∈ B, there exists α ∈ A such that (A, a¯[α/ai]) ≡n−1,k (B, ¯b[β/bi]).
The above can also be phrased as two player games between players Spoiler and Duplicator, commonly referred to as Ehrenfeucht-Fraisse games ([6]). In the game to describe →n,k between structures A and B , the (n, k)-pebble game Spoiler has k pebbles, and on each of the n rounds he places a pebble on an element of A (the l < k case), or moves an existing pebble from an element of A to another (the l = k case). During each round, Duplicator responds likewise in B, and his aim is to ensure the partial map generated by looking at the pebbles is a partial morphism. It is a theorem that Duplicator can win the (n, k)-pebble game, no matter how
Spoiler plays if and only if A →n,k B. The (n, k)-pebble game between structures (A, a¯) and (B, ¯b) is effectively the (n + l, k) pebble game between A and B, in which the first l moves have been fixed (Spoiler plays a1, .., al, and Duplicator responds
b1, ..., bl.) There is a similar game and theorem for the ≡n,k relation.
We have insisted in both games that Spoiler must place all k pebbles before he begins moving them. It is an equivalent game (in the sense that Duplicator can always win one if and only if he can always win the other) if we allow Spoiler to begin moving pebbles before he has placed all of them. The (n, n)-game (which has no movement of pebbles) is commonly known as the n-round Ehrenfeucht-Fraisse game. This game consists only of Spoiler placing pebbles on a structure A and Duplicator responding with elements from a structure B (for the time being, we will focus only the category Rσ). Duplicator can only win this game if A →n B. We will consider first the case l = 0 for simplicity.
Definition 2.3 For a structure A, let EnA be the set of (non-empty) sequences of elements of A length at most n, and let ϵA : EnA → A be the function that gives the last element of a sequence.
A (deterministic) strategy for Duplicator in the n-round Ehrenfeucht-Fraisse game is precisely a function f : EnA → B. If Spoiler plays a1, a2, ..an, Duplicator simply plays f ([a1]),f ([a1, a2]), ..., f ([a1, ..., an]). This gives exact correspondence between maps f : EnA → B and strategies for Duplicator. We will endow EnA with a relational structure, such that the map f is a winning strategy precisely if it is a morphism, but first we will consider strategies for the general (n, k)-pebble game.
Definition 2.4 For a structure A, let Pn,kA be the set of (non-empty) sequences of elements of A × {1, ..., k}, of length at most n, such that the second co-ordinate is not repeated within the first k entries of the sequence (ie if s ∈ Pn,kA, and i ∈ {1, ..., k}, then i occurs at most once as the second co-ordinate in the first k entries of s). Once again (in a slight abuse of notation), let ϵA : Pn,kA → A denote the first co-ordinate (ie the entry from A) of the last element of a sequence.
Analogously to above, a strategy for Duplicator in the (n, k)-pebble game is precisely a function f : Pn,kA → B. This case is made slightly more compli- cated by having to keep track of the fact the pebbles can move. In this case, f ([(a1, i1), ..., (aj, ij)]) represents what Duplicator will play in the jth round of a 

game in which, in the mth round, Spoiler placed (or moved) pebble im onto am.
We now endow our sets with relational structures, and give some intuition as to why we have done so. We will let, for s1, s2 sequences, s1 и s2 denote that s1 is a prefix of s2, and s1 ∼ s2 denote s1 и s2 ∨ s2 и s1. For s ∈ Pn,kA, we will refer to the second-coordinate of its last entry as its pebble index.
Definition 2.5 For A ∈ Rσ, R ∈ σ:
For EnA: (s1, ..., sj) ∈ REnA if and only if:
(ϵA(s1), ..., ϵA(sj)) ∈ RA.
For each i1, i2 ∈ {1, ..., j}, we have si1 ∼ si2 .
For Pn,kA: (s1, ..., sj) ∈ RPn,k A if and only if:
(ϵA(s1), ..., ϵA(sj)) ∈ RA.
For each i1, i2 ∈ {1, ..., j}, we have si1 ∼ si2 .
For each i1, i2 ∈ {1, ..., j}, if si1 и si2 , then then pebble index of si1 does not
occur as a second coordinate in sj, where si = si sj.
One can understand these definitions of the relations on EnA (or Pn,kA), simply as a way of imposing conditions on morphisms f : EnA → B. The first condi- tion helps us to ensure that a morphism f : EnA → B entails partial morphisms from {a1, ..., aj} to {f ([a1]), ..., f ([a1, ..., aj])}, as would be required in the n-round Ehrenfeucht-Fraisse game. The second condition ensures we are not asking too much of a morphism f : EnA → B; if s1  s2, then they cannot represent situations that occur in same game, thus there should be no relations between them. For Pn,kA recall that for a sequence s1, f (s1) tells us how Duplicator should respond when Spoiler has just moved the pebble index of s1, pebble i say, to ϵ(s1). If s1 и s2, and the pebble index of s1 occurs again in s2 (after s1), that is telling us pebble i has moved, thus there need be no relation between f ([s1]) and f ([s2]). This isa sketch proof of the following theorem:
Theorem 2.6 For A, B ∈ Rσ, there is a bijection between:
Winning strategies for Spoiler in the n-round Ehrenfeucht-Fraisse game from A
to B.
Morphisms f : EnA → B.
Or in the more general case, there is a bijection between:
Winning strategies for Spoiler in the (n, k)-pebble game from A to B.
Morphisms f : Pn,kA → B.
Rather than give a detailed proof, we will instead later prove the following, slightly weaker result (as it all we will use), after a discussion of how (n, k)-covers relate to Pn,kA.
Theorem 2.7 For A, B in Rσ:
A →n B if and only if EnA → B.

A →n,k B if and only if Pn,kA → B
We now display the categorical properties of the assignment A '→ Pn,kA. Note that En is similar in shape to the (non-empty) list comonad on the category of sets, prompting us to make the following definition:
Definition 2.8 We turn En into a functor, by pointwise application of functions. In other words for A, B ∈ Rσ and f : A → B, Enf ([a1, ..., aj]) := [f (a1), ..., f (aj)]]. We similarly turn Pn,k into a functor, by pointwise applications and not touching the pebble indices, so f ([(a1, i1), ..., (aj, ij)]) := [(f (a1), i1), ..., (f (aj), ij)].
As before, we abuse notation by using the same δ for the functors En and Pn,k.
Definition 2.9 For A ∈ Rσ, define δ : EnA → EnEnA recursively (on the length of a sequence) by:
δA([a]) := [[a]]
δA(s[a]) := δ(s)[s[a]]
In other words, δA([a1, ..., aj]) = [[a1], [a1, a2], ..., [a1, ..., aj]], the sequence of prefixes of [a1, ..., aj]. Similar to before, we give an analogous definition for Pn,k keeping the pebble indices fixed.
δA([(a, i)] := [([(a, i)], i)]
δA(s[(a, i)] := δ(s)A[(s[(a, i)], i)]
The above definition is made with the following theorem in mind:
Theorem 2.10 (En, ϵ, δ) and (Pn,k, ϵ, δ) are comonads.
By comparison to the standard list comonad on the category of sets, we will have that all necessary diagrams commute. The only thing needed to verify is that everything we have defined is indeed a morphism in Rσ, which follows easily from our definitions.
We now generalise this to the categories Rσ(l). As commented above, the (n, k)- game between structures (A, a¯) and (B, ¯b) is just the (n, k + l) game where we have fixed Spoiler’s and Duplicator’s first l moves. Thus we make the following definition:
Definition 2.11 For (A, a¯) ∈ Rσ(l):
En(A, a¯) is the induced substructure of En+lA, on the subset {s ∈ En+lA : s ∼ [a1, ..., al]}. We consider it a structure in Rσ(l) by distinguishing the tu- ple ([a1], [a1, a2], ..., [a1, ..., al]).
Pn,k is the induced substructure of Pn+l,kA on the subset {s ∈ Pn+l,kA : s ∼ [(a1, 1), ..., (al, l)]}. We consider it a structure in Rσ(l) by distinguishing the tuple ([(a1, 1)], [(a1, 1), (a2, 2)], ..., [(a1, 1), ..., (al, l)]).
We (lazily) re-use ϵ and δ to denote the obvious natural transformation given by restriction of our previous ϵ and δ maps, and similarly define the action of En and Pn,k on maps by restriction (indeed, we are even reusing En and Pn,k in a different context; hopefully no confusion should occur here).

This definition works as one would hope:
Lemma 2.12 (En, ϵ, δ) and (Pn,k, ϵ, δ) are comonads on Rσ(l) Similarly to above, we will also see:
Lemma 2.13 For (A, a¯), (B, ¯b) in Rσ(l):
En(A, a¯) → (B, ¯b if and only if (A, a¯) →n (B, ¯b).
Pn,k(A, a¯) →n,k (B, ¯b) if and only if (A, a¯) →n,k (B, ¯b).
We can now see how these comonads give us new characterisations of tree depth and tree-width (via (n, k)-covers), as proved in [1] and [2].
Theorem 2.14 There is a one to one correspondence between:
Coalgebras for a structure (A, a¯) for the comonad En.
Forest covers of depth at most n of (A, a¯). There is a one to one correspondence between:
Coalgebras for a structure (A, a¯) for the comonad Pn,k.
(n, k)-covers of (A, a¯).
Proof. Once one carefully unpicks the definitions of an (n, k)-cover we will see the following correspondences:
Forests on vertex set A with that begin with the path a1, ..., al of depth at most n + l ↔ Set maps (A, a¯) → En(A, a¯) (respecting the distinguished elements) that make the coalgebra diagrams commute.
Forest covers of (A, a¯) of depth at most n ↔ coalgebras (A, a¯) → En(A, a¯)
(n, k)-covers of (A, a¯) ↔ coalgebras (A, a¯) → Pn,kA
Now for the details:
Note that the data of a tree can be given by specifying, for each vertex, the unique path to its root. This data can of course be expressed as a function F : A → En+lA. Certainly not all functions of this type describe forests beginning with the path a1, .., al. The conditions required for the function to be a forest beginning with the path a1, ..., al are precisely that, F restricts to a function (A, a¯) → En(A, a¯) (the forest begins with the path a1, ..., al), ϵ(F (a)) = a for each a ∈ A (ie the unique path to a ends with a), and δ(F (a)) = F (F (a)) for each a ∈ A (if some b lies on the path on the unique path a, then F (b) is the unique prefix of F (a) ending in b). We have just written inline the commutative diagrams defining a coalgebra, thus we have correspondence (i).
Now suppose F satisfies the properties in (i). F is a morphism if and only if, for every tuple b1, ..., bj of A, and R ∈ σ,
(b1, ..., bj) ∈ R(A,a¯) =⇒ (F (b1), ..., F (bj)) ∈ REn(A,a¯).
Now the consequent is true precisely when (ϵ(F (b1)), ..., ϵ(F (bj))) ∈ R(A,a¯) and,

for each pair b, bj among b1, ..., bj, F (b) ∼ F (bj). Now the first condition is met by assumptions on F in (i), so we need only check the second condition. We restate it as the following: whenever there is an edge b, bj in G(A) (recall G(A) is the Gaifman graph of A and there is an edge between two vertices if and only there is some tuple (b1, ..., bj) containing b, bj and relation R ∈ σ such that (b1, ..., bj) ∈ RA) we have F (b) ∼ F (bj). Since F (b) describes the unique path from b to its root, we have that F (b) ∼ F (bj), if and only if b and bj lie on the same branch. Summing up, we have that F is a morphism if and only if whenever there is an edge b, bj in G(A), then b and bj lie on the same branch as the forest described by F , ie if and only if F describes a forest cover of (A, a¯). This completes correspondence (ii).
Given a coalgebra F for (A, a¯) over the comonad En, it is straightfoward to see the correspondence between the data required to turn F intoa map to Pn,kA, and k-labelling functions of the forest cover described by F . It is a simple check that we will get a morphism if and only if the labelling turns the forest cover described by F into an (n, k)-cover.
2
We state the following immediate corollary to above:
Corollary 2.15 Any structure of form Pn,k(A, a¯) (for some (A, a¯) ∈ Rσ(l)) always has a colagebra provided by δA, thus always has an (n, k)-cover.
This theorem tells us the category of (n, k)-covers is precisely the Eilenberg- Moore category of the comonad Pn,k. It also provides the proof of 2.7 :
Theorem 2.16 (restatement of 2.7) For (A, a¯), (B, ¯b) in Rσ(l):
(A, a¯) →n (B, ¯b) if and only if En(A, a¯) → (B, ¯b).
(A, a¯) →n,k (B, ¯b) if and only if Pn,k(A, a¯) → (B, ¯b).
Proof. We just prove the second statement, using the combinatorial characterisa- tion of →n,k.
Suppose (A, a¯) →n,k (B, ¯b). Since Pn,k(A, a¯) has an (n, k)-cover, and Pn,k(A, a¯) →
A, we then have Pn,k(A, a¯) → (B, ¯b).
Now suppose Pn,k(A, a¯) → (B, ¯b). Let C have an (n, k)-cover, and (C, c¯) → (A, a¯).
Since (C, c¯) has an (n, k)-cover, it has a coalgebra, and thus (C, c¯) → Pn,k(C, c¯). By functoriality, Pn,k(C, c¯) → Pn,k(A, a¯) and putting both of these together with the assumption, we get (C, c¯) → (B, ¯b).	2
3	Preservation Theorems
We now seek to move toward a proof of what is conjectured at the end of the first section (that a class M closed under → and ≡n,k is closed under →n,k). Our proof will essentially expose Rossman’s ideas, tweaked for our case. The proof idea is the
well-known method of companion structures. Namely, given A in Rσ, we wish to find A˜, Pn˜,kA such that:

(i) A → A˜

(ii)
(iii)
A˜ ≡n,k Pn˜,kA Pn˜,kA → Pn,kA

The proof would then follow by, given A ∈ M and B ∈ Rσ such that A →n,k B, chasing the following diagram (using the closure properties of M we could then obtain B ∈ M ):
A˜	≡n,k	Pn˜,kA
	
A	Pn,kA  B
We will in fact find structures with more properties than this, but we present this as the strategy to clarify the argument. Our aim will be to build the ≡n,k relation along the n,k relation, directly generalising what is called n-extendability in [8]. Consider a pair A  n,k B. By the recursive definition of →n,k for any b ∈ B there is some a ∈ A such that (B, b) →n−1,k (A, a). If we aim to keep build isomorphism, we might hope to find a ∈ A with the property that (A, a)  n−1,k (B, b) also, since this will ensure a partial isomorphism between {a} and {b}. If we could do this for
any b ∈ B (and of course relative to some tuple ¯b of B), and vice versa, then we
would have that A ≡n,k B. We state this more formally below:
Definition 3.1 A ∈ Rσ is (n, k)-extendable if for every:
0 < nj ≤ n
Tuple a¯ of length l ≤ k
Structure (B, ¯b) such that (A, a¯)  (n′,k) (B, ¯b)
β ∈ B
When l < k there exists α ∈ A such that
(A, a¯, α)  (n′−1,k) (B, ¯b, β)
When l = k, for each i ∈ {1, ..., l} there exists α ∈ A such that
(A, a¯[α/ai])  (n′−1,k) (B, ¯b[β/bi])



This property of A is telling us we can extend partial isomorphisms between A and any structure B by choosing any element in B (subject to the presence of, and whilst maintaining a  n,k relation). It follows that:
Lemma 3.2 If A, B ∈ Rσ are (n, k)-extendable, and A  n,k B, then A ≡n,k B.
With this definition, we have that if we can construct, for any given A, and

(n, k)-extendable A˜ such that A˜  A, then we can use the above lemma (since A n,k Pn,kA, so A˜ n,k Pn˜,kA), and we would have the required result. This is of course stronger than strictly necessary, though achievable in some cases.
We will build the structure A˜ with extensive use of coproducts, so first we need
to investigate how the coproduct interacts with →n,k. We will sometimes appeal to the intuitive characterisation of →n,k to avoid tedious book-keeping of indices. We use ⊕ to denote the coproduct of two structures in their respective category. We state without proof the following intuitive characterisation in the most common cases:
Lemma 3.3 For structures A, B ∈ Rσ A⊕B has universe AHB (the disjoint union of their universes), and relations, for R ∈ σ, RA⊕B := RA ∪ RB. For structures (A, a¯), (B, ¯b) ∈ Rσ(l), when the case that the tuples a¯ and ¯b have repeated elements in the same places, we can directly construct (A, a¯) ⊕ (B, ¯b), by taking the quotient of A ⊕ B under the relation ai ∼ bi for i = 1, ..., l.
Lemma 3.4 For A, B, C ∈ Rσ, if A →n,k C and B →n,k C then A ⊕ B →n,k C.
Proof. Intuitively, in the (n, k)-game, Duplicator can just play both strategies for A →n,k C and B →n,k C simultaneously. If Spoiler plays in A, Duplicator follows the strategy for A →n,k C, and similarly for B. This corresponds to a map Pn,k(A ⊕ B) → Pn,kA ⊕ Pn,kB . For some s ∈ Pn,k(A ⊕ B), if ϵA⊕B(s) ∈ B, we delete all entries of elements of A in the sequence, and if ϵA⊕B(s) ∈ A we delete all entries of elements of B.	2
It is, unfortunately, not the same story in Rσ(l). We provide a counterexample:
Example 3.5 Let σ consist of a single binary relation R, and a unary relation U . Let A be the three cycle on elements {a1, a2, a3}, pictured below:
a1
a2	a3
Let B be the path on {b1,  , b7} with a single unary relation on b4.

b1	R	b2
R	b3
R	b4
R	b5
R	b6
R	b7

We see from a simple check that (A, a1) →3,2 (B, b4) (and of course (B, b4) →3,2 (B, b4)), but it is not the case that (A, a1) ⊕ (B, b4) →3,2 (B, b4). In the previous case where we worked in Rσ, there was no interaction between A and B, and thus Duplicator could run the two strategies simultaneously and independently. However, now we have identified a1 and b4 this no longer works.
In the example above we see that if we have at least two more moves than pebbles left to place, then passing →n,k through a ⊕ fails. The example above was

the worst possible in this sense.
Lemma 3.6 Suppose (A, a¯), (B, ¯b), (C, c¯) ∈ Rσ(l), (A, a¯) →n,k (C, c¯), (B, ¯b) →n,k
(C, c¯), and n ≤ k − l + 1, then (A, a¯) ⊕ (B, ¯b) →n,k (C, c¯).
Proof. First we consider the case n = k − l, so we are in fact playing the n- round Ehrenfeucht-Fraisse game, and can make use of the simpler comonad En. In terms of strategies, Duplicator can once again run the strategies for (A, a¯) and (B, ¯b) independently. Playing optimally, there is no point Spoiler replacing a pebble
where one is already placed, Spoiler will never place one on the identified elements ai(= bi), thus Duplicator never has to deal with any conflict between his strategies. Formally, we describe a map En((A, a¯) ⊕ (B, ¯b)) → (En(A, a¯) ⊕ En(B, ¯b)) by, for
s ∈ En((A, a¯) ⊕ (B, ¯b)), deleting all entries not in A (respectively B) occurring in s
if ϵ((A,a¯)⊕(B,¯b))(s) ∈ A− {a1, .., al} (respectively B−{b1, ..bl}), and if ϵ((A,a¯)⊕(B,¯b))(s) occurs among the tuple a¯(= ¯b), so ϵ(s)= ai for some i, then send s to [a1, ..., ai].
The case n = k − l + 1 is similar to above. There is only one pebble move after all the pebbles have been placed, so Duplicator can run the strategies for A and B independently (there are not enough moves for Spoiler to move off and on the shared elements of A and B to cause discrepancy between the respective strategies).  2
If (A, a¯), (B, ¯b) ∈ Rσ(l) and b ∈ B, we let ((A, a¯) ⊕ (B, ¯b), b) denote the structure obtained by taking the coproduct (A, a¯) ⊕ (B, ¯b) in Rσ(l), and then distinguishing an extra element of B to view it as an object of Rσ(l + 1). An important point for later will be when we can conclude ((A, a¯) ⊕ (B, ¯b), b) →n,k (B, ¯b, b).
Lemma 3.7 If n ≤ k − l + 2, and (A, a¯) →n,k (B, ¯b), then ((A, a¯) ⊕ (B, ¯b), b) →n,k
(B, ¯b, b).
Proof. We essentially follow the proof of the above lemma, (noting that of course (B, ¯b) →n,k (B, ¯b)), following strategies for A and B independently. The extra distinguished element b in each structure is clearly respected if we use the identity map to witness (B, ¯b) →n,k (B, ¯b). We follow the same strategy as above whilst placing pebbles, and describe how we can deal with up the two pebble moves at the end. There are many cases to check, so we consider the only sequence of moves that
may cause difficulty for Duplicator as demonstrated in the example above: if Spoiler
moves a pebble of some ai occurring in the tuple a¯ to some aj ∈ A and then some pebble from some ajj ∈ A onto ai (since this is the only way Spoiler might be able to make Duplicator’s parallel strategies for A and B conflict in only two moves). We note that because at least one pebble is placed on B − {a1, ..., al} (on b), Duplicator essentially has a pebble spare in following his strategy for A, and can treat the movement of the pebble ai → aj as if Spoiler had placed a new pebble there, thus maintaining a partial morphism between ai, aj, and ajj. Therefore the following pebble movement ajj → ai can be responded to by moving the corresponding pebble onto bi(= ai) on B, which does not conflict with the strategy identity strategy being used on B.	2
In fact, what is needed in the general case is the following (recall that Fn,k,l is

a set of representatives for equivalences classes of  n,k each finite and having an (n, k)-cover):
Conjecture 3.8 There exists a choice of the of the sets Fn,k,l for every n, k, l such that for each (A, a¯) ∈ Rσ(l), and each (C, c¯, c) ∈ Fn,k,l such that (A, a¯) →n,k (C, c¯),and (C, c¯) → (A, a¯), we have ((A, a¯) ⊕ (C, c¯), c)) →n,k (C, c¯, c).
We have this in the case of n ≤ k − l + 2 (indeed, it follows immediately from the more general lemma above that any choice will do), but have been unable to prove it for the general case. We shall see how this would imply the (n, k)- preservation theorem, and thus give a proof of the (n, k)-preservation theorem in the case n ≤ k − l + 2. We emphasise that the following rely on this conjecture and are thus yet unproven except in this case.
In order to build (n, k)-extendable structures, it is convenient to test (n, k)- extendability on representative structures from Fn,k,l. Further, as we wish to find structures which are, in a sense, extensions of given structures, we find a test for (n, k)-extendability on structures of form ((A, a¯) ⊕ (C, c¯), c), where A is fixed and (C, c¯) ∈ Fn,k,l as we will see below:
Lemma 3.9 Assuming 3.8, a structure A is (n, k)-extendable if for every:
l < k,
0 < nj ≤ n − l,
l-tuple a¯ of A,
(C, c¯, c) ∈ Fn′,k,l+1 such that (C, c¯) → (A, a¯) →n′−1,k (C, c¯), there exists α ∈ A such that
(A, a¯, α)  n′−1,k ((A, a¯) ⊕ (C, c¯), c)
Proof. Let a¯, nj, and l be as above, and let (B, ¯b) ∈ Rσ(l) be such that (A, a¯) n,k (B, ¯b). As in the definition of (n, k)-extendability, we break into cases l = k and l < k.
First let l < k and take some β ∈ B. Take (C, c¯, c) ∈ Fn′−1,k,l+1 such that (B, ¯b, β) n′−1,k (C, c¯, c). By the recursive characterisation of →n′,k, we note that there is a ∈ A such that (B, ¯b, β) →n′−1,k (A, a¯, a). Hence, by transitiv- ity of →n′−1,k, we have (C, c¯, c) →n′−1,k (A, a¯, a). Since (C, c¯, c) ∈ Fn′−1,k,l it has an (nj − 1, k)-cover, so we get a morphism (C, c¯) → (A, a¯). We also have (A, a¯)n′−1,k(B, ¯b) → (C, c¯) (the first arrow from the fact (A, a¯) →n′,k (B, ¯b) and the second from (B, ¯b, β) →n′−1,k (C, c¯, c)) and can apply the hypothesis of the lemma. So let α ∈ A be such that (A, a¯, α)  n′−1,k ((A, a¯) ⊕ (C, c¯), c). It is immediate that (B, ¯b, β) →n′−1,k ((A, a¯) ⊕ (C, c¯), c) since ((A, a¯) ⊕ (C, c¯), c) is a superstructure of (C, c¯, c). By the 3.8 we have ((A, a¯) ⊕ (C, c¯), c) →n′−1,k (C, c¯, c) →n′−1,k (B, ¯b, b). Combining these we get (A, a¯, α)  n′−1,k (B, ¯b, β) as required.
The structure of the second case is very similar. Suppose l = k and let β ∈ B,

i ∈ {1, ..., l}. Without loss of generality we may reorder the tuples a¯, ¯b so that i = l(= k). Again let (C, c¯) ∈ Fn′,k,l be such that (B, ¯b[β/bi]) n′—1,k (C, c¯, c). By identical reasoning to the previous case, we see that (C, c¯) → (A, a¯ − al) (where a¯ − al denotes the tuple a¯ with the lth entry deleted). The argument now
proceeds exactly as in the previous case.
2
We now have the means to build up (n, k)-extendable structures.
Definition 3.10 For A ∈ Rσ, and a fixed choice of (n, k), let Σ(A) be the colimit over all the canonical inclusion maps of form:
A → ((A, a¯) ⊕ (C, c¯))
for (C, c¯, c) ∈ Fn′,k,l such that (C, c¯) → (A, a¯), where 0 < nj ≤ k − l, and where we view ((A, a¯) ⊕ (C, c¯), c) as an object of Rσ in a slight abuse of notation. In other words, we have glued each of these structures along A, or one could think of starting with a single copy of A and gluing the structures (C, c¯) to it along appropriate tuples.
Lemma 3.11 For A ∈ Rσ, 0 < nj ≤ k − l, (C, c¯, c) ∈ Fn′—1,k,l such that (C, c¯) →
(A, a¯), we have
(Σ(A), a¯, c)  ((A, a¯) ⊕ (C, c¯), c)
Proof. ((A, a¯)⊕(C, c¯), c) → (Σ(A), a¯, c) is just an inclusion map. For the other way around, we note that Σ(A) is a colimit so it suffices to give a (coherent) set of maps out of the objects (A, a¯j) ⊕ (Cj, c¯j) for appropriate (Cj, c¯j). If (Cj, c¯j) = (C, c¯) and
a¯j = a¯ we just take the identity map on ((A, a¯) ⊕ (C, c¯), otherwise; take the identity on A along with any map (C, c¯j) → (A, a¯j). It is straightforward to see that such maps all commute where necessary and respect the required distinguished elements of Σ(A).	2
We also have the following:
Lemma 3.12 Σ(A) is a co-retract of A (meaning there are maps A  Σ(A) that

compose to give the identity on A). In particular, if a¯ (A, a¯)  (Σ(A), a¯).
is any tuple of A, then

Proof. For the map A → Σ(A), just take the inclusion map. The other way around, for each (A, a¯) ⊕ (C, c¯), use the map given by the identity on A and any choice of map (C, c¯) → (A, a¯).	2
We have, in a sense, that Σ(A) satisfies the (n, k)-extendability criteria, but for A rather than for itself. Thus we take the colimit, or countable union, of the structures Σi(A) (for i ∈ N) to obtain something akin to a fixed point of Σ, which will be (n, k)-extendable.
Definition 3.13 Let Σω(A) be the colimit over all inclusion maps of form:
Σi(A) → Σi+1(A)

for i ∈ N. Or, more constructively, Σω(A)is the union  i∈N Σi(A).
Σω(A) enjoys similar properties to Σ(A).
Lemma 3.14 Σω(A) is a co-retract of Σi(A) for any i ∈ N. In particular, if a¯ is any tuple of Σi(A), then (Σi(A), a¯)  (Σω(A), a¯).
Proof. For Σi(A) → Σω(A) we take the inclusion map. For the other way around, we need to specify coherent maps Σj(A) → Σi(A) for each j ∈ N. If i ≤ j then just take the inclusion map. If j > i then take compositions of the maps Σj(A) → Σj—1(A) as described in the lemma above. It is straightforward to see that these maps all commute with the inclusion maps (thus giving us a map out of the colimit), and that the composition of these maps give the identity on Σi(A).	2
We can now show Σω(A) is (n, k)-extendable (modulo 3.8):
Theorem 3.15 Assuming 3.8, for any A ∈ Rσ, Σω(A) is (n, k)-extendable,
Proof. We use 3.9 which gives us the simplest test for (n, k)-extendability. Suppose 0 < nj < k − l, l < k, a¯ is an l-tuple of Σω(A), and (C, c¯, c) ∈ Fn′—1,k,l+1 is such that (C, c¯) → (Σω(A), a¯). Recall that all structures in Fn′—1,k,l+1 are finite, so the map (C, c¯) → (Σω(A), a¯) is in facta map (C, c¯) → (Σi(A), a¯) for some i ∈ N. Thus, we have a map (Σi+1(A), a¯, c) (((Σi(A), a¯) ⊕ (C, c¯)), c). Combining this with the retraction maps from Σω(A), we get
(Σω(A), a¯, c)  (Σi+1(A), a¯, c)  (((Σi(A), a¯)⊕(C, c¯)), c)  (((Σω(A), a¯)⊕(C, c¯)), c)
(where the last  is the retraction maps Σi(A)  Σω(A) paired with identity map on C) as required by the conditions of the lemma.	2
Thus we may take Σω(A) as A˜ and Σω(Pn,kA) as Pn˜,kA in the argument pre- sented at the beginning of the section to obtain a proof of the (n, k)-preservation theorem (again, we emphasise this is only in the cases where conjecture 3.8 holds).

Comments and Further Questions
Possible Solutions
We have proved so far that the (n, k)-preservation theorem for the case n ≤ k +2 holds (and it is also trivially true in the case k = 1 for abitrary n). We also claim it is very easy to extend the work above to formulas with constants. The problem remains open for the general pair. We outline some possible lines to solve the general case:
Prove conjecture 3.8 for arbitrary (n, k). For the cases n ≤ k − l + 2 we actually have a much stronger result which implies it, which is not true for arbitrary (n, k). There is some freedom in the choices of sets Fn,k,l and it may be that choosing them to have structures of a certain property helps.

A proof of 3.8 would in fact give us, for any (n, k), a way of producing an (n, k)- extendable co-retract of any given structure A. As commented at the beginning of the section, this is much stronger than necessary, we only need some pair

of co-retracts A˜, Pn˜,kA (of A, Pn,kA respectively) such that A˜
≡n,k
Pn˜,kA. It

might be possible to tweak the construction shown above to this end. For in-
stance, one can define a structure A to be (n, k)-homomorphically extendable, by replacing (A, a¯) →n′,k (B, ¯b) with (A, a¯) → (B, ¯b, b) →n′,k (A, a¯) everywhere in the hypotheses and conclusion of (n, k)-extendability. One can define (n, k)-
cohomomorphically analagously. It will then be the case that if A → B →n,k A, A is (n, k)-homomorphically extendable and B is (n, k)-cohomomorphically ex- tendable, then A ≡n,k B. We can see in our picture above that Σω(Pn,kA) → Σω(A) →n,k Σω(Pn,kA), and the above material shows Σω(Pn,kA) is (n, k)-homo- morphically extendable (we avoid the problem of 3.8, we work with proper mor- phisms rather than →n,k). This gives a slightly different challenge of trying to find an (n, k)-cohomomorphically extendable co-retract of A instead.
Further Work
This paper is part of a larger project following the work of [1] and [2] aiming to use semantic techniques such as these to understand different fragments of logic. In this paper we have applied our understanding of the bounded quantifier rank and variable fragments in order to better understand the proof of the Rossman’s equirank homomorphism theorem, and move towards a proof of (n, k)-preservation conjecture. Future work in this project will aim to include work on Modal and Guarded Fragments, fragments of second order logic, in order to better understand those areas from a more semantic perspective.

References
Samson Abramsky, Anuj Dawar, and Pengming Wang. The pebbling comonad in finite model theory. In Logic in Computer Science (LICS), 2017 32nd Annual ACM/IEEE Symposium on, pages 1–12. IEEE, 2017.
Samson Abramsky and Nihil Shah. Relating structure and power: Comonadic semantics for computational resources. In 27th EACSL Annual Conference on Computer Science Logic, CSL 2018, September 4-7, 2018, Birmingham, UK, pages 2:1–2:17, 2018.
John Baldwin. Finite and infinite model theory-a historical perspective. Logic Journal of the IGPL, 8(5), 2000.
Bruno Courcelle. The monadic second-order logic of graphs. i. recognizable sets of finite graphs.
Information and computation, 85(1):12–75, 1990.
Heinz-Dieter Ebbinghaus and Jo¨rg Flum. Finite model theory. Springer Science & Business Media, 2005.
Andrzej Ehrenfeucht. An application of games to the completeness problem for formalized theories.
Fund. Math, 49(129-141):13, 1961.
Eric Rosen. Some aspects of model theory and finite structures. Bulletin of Symbolic Logic, 8(3):380–403, 2002.
Benjamin Rossman. Homomorphism preservation theorems. Journal of the ACM (JACM), 55(3):15, 2008.
