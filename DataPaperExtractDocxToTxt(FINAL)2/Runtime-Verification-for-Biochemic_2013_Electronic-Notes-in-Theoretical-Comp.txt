Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 297 (2013) 27–46
www.elsevier.com/locate/entcs

Runtime Verification for Biochemical Programs
Oana Andrei1
School of Computing Science, University of Glasgow, Glasgow, UK
H´el`ene Kirchner2
INRIA, France

Abstract
The biochemical paradigm is well-suited for modelling autonomous systems and new programming languages are emerging from this approach. However, in order to validate such programs, we need to define precisely their semantics and to provide verification techniques. In this paper, we consider a higher-order biochemical calculus that models the structure of system states and its dynamics thanks to rewriting abstractions, namely rules and strategies. We extend this calculus with a runtime verification technique in order to perform automatic discovery of property satisfaction failure. The property specification language is a subclass of LTL safety and liveness properties.
Keywords: Biochemical calculus, Rewriting strategies, Autonomous systems, Runtime verification.


Introduction
More and more complex distributed computing systems are employed in large com- puter networks where direct human intervention would become easily overwhelmed. Then self-managing properties for such systems became highly desirable and the autonomic computing framework [14] was designed for this purpose. Autonomous systems are initially provided with some high-level instructions from administrators and should require minimal human intervention during their functioning if none. There is crucial need for theories and formal frameworks to model computation, to define unconventional languages for programming and to establish foundations for verifying properties of these systems, for instance security-related properties.

1 Email: Oana.Andrei@glasgow.ac.uk
2 Email: Helene.Kirchner@inria.fr

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.12.003

Our work fits into the unconventional programming languages approach such as the chemical paradigm [11,13,7]. The chemical paradigm captures the intuition of a collection of freely interacting atomic values where interactions are modelled by rules and has been applied to modelling self-managing systems [7], computer networks, grid infrastructures [8], web services [16]. We extended this paradigm with structured objects instead of atomic values and defined a higher-order formalism, the Abstract Biochemical Calculus [5]. An autonomous system is modelled as a biochemical program with the structural part described by a collection of objects and behavioural part as a collection of transformations (rewrite rules) over collections of objects, both at the same level. Objects and rewrite rules are generically called molecules and collections of molecules are also molecules. Higher-order rewrite rules over molecules introduce new rewrite rules in the behaviour of the system. More expressive power is gained in modelling a system’s evolution via strategies which control the application order of a set of rewrite rules.
In [3] we proposed the visual structure of port graph, as well as port graph rewrite rules and a rewriting relation on port graphs for modelling complex systems with dynamical topology, whose components interact in a concurrent and distributed manner. Nodes with ports represent components (or objects), while edges corre- spond to interactions (or communications). Then port graph rewrite rules are used for modelling the system evolution by creating new nodes and connections among them at specific points (ports), breaking connections, merging, splitting, or delet- ing nodes, or performing any combination of these operations. By instantiating the structure of the objects in the Abstract Biochemical Calculus with port graphs, we obtained the Port Graph Calculus and we showed its capabilities of modelling autonomous systems and biochemical networks in [1,4]. An implementation of the port graph calculus is provided by the PORGY environment [2].
At this stage, our aim is to improve the confidence in biochemical models of autonomous systems by ensuring that the current execution is consistent with the expected properties of the system and by detecting violations of safety properties in order to recover from problematic situations. Runtime verification fits well in this context as a verification technique that increases confidence in the correctness of the system behaviour with respect to its formal specification. We have already proposed a method for verifying invariant properties of biochemical program [5]. An invariant property is encoded as a special rule in the biochemical program modelling the system and such rule is dynamically checked at each execution step. We obtained a kind of runtime verification technique which allows the running program to detect its own structural failures.
In this paper, we enrich the abstract biochemical calculus with a verification technique where properties are expressed in linear temporal logic (LTL) [17]. We concentrate here on safety properties (“Something bad never happens”) that include invariant properties as subclass, and liveness properties (“Something good will hap- pen eventually”). We consider a set of LTL formulae built using one temporal modal operator, which is enough to express a fair amount of properties, and we use a three-valued semantics for the LTL formulae [10]. In order to illustrate our

approach and the proposed concepts, in this paper we develop a simple example of service orchestration based on library loaning services.
The paper is organised as follows. In the next section, we give an overview of the abstract biochemical calculus, syntax and semantics. Section 3 discusses the Kripke structure associated to a biochemical program and the set of temporal formulae we consider. In Section 4, we formalise runtime verification in this context and extend the calculus to perform simultaneously computation and verification steps. Further perspectives are drawn in Section 5.
The Abstract Biochemical Calculus
The Abstract Biochemical Calculus [5] is based on two main formalisms: the ρ-calculus (also called the rewriting calculus) [12] and the γ-calculus [6]. It extends the chemical model of the γ-calculus by embedding higher-order capabilities of the rewriting calculus and by considering an abstract structure OBJ for the basic chem- ical objects of the γ-calculus. The structure OBJ is required to allow modelling connections between objects as well as creating and removing such connections. The result is an abstract biochemical calculus based on rewriting structured molecules, called the ρ⟨OBJ ⟩-calculus and presented in the rest of this section.
Syntax
The syntax of the Abstract Biochemical Calculus is given in Fig. 1. In the following we detail each class of entities.
The structure of objects OBJ is an abstract one; for instance objects may be terms, records, graphs, etc. We only require that for any object O ∈ OBJ , we can retrieve the set of its variables denoted by Var(O), we can select a sub- object, and that there always exists a procedure for matching objects w.r.t. a given congruence. We assume that a matching algorithm Sol for OBJ as well as a structural congruence relation ≡ on objects are given as parameters of the calculus. Following the intuition of chemical solutions, collections of objects are built using an associative and commutative juxtaposition operator •. We also define an object stk to be used later as failure object.
The collection of objects can be transformed using rules of the form L ⇒ R where L and R are objects such that Var(R) ⊆ Var(L). Objects and rules are grouped together in molecules which are bags built using the same associative-commutative

Fig. 1. The syntax of the Abstract Biochemical Calculus

(AC) juxtaposition operator • as for objects. The structural congruence relation on molecules is defined as the union of structural congruence relation on OBJ and the AC properties of the juxtaposition operator on objects and molecules.
Transformations of molecules are defined as higher-order abstractions M $ K. A rule is a first-order abstraction that abstracts only on (collections of) objects while the general higher-order abstractions act on objects as well as on rules. Hereafter, we use the symbol $⇒ to denote either ⇒ or $. The application operator @ takes an abstraction and a molecule to build a reactive molecule. Higher-order abstractions, also called strategies, may contain in their right-hand side reactive molecules.
Collections of molecules and abstractions are called conﬁgurations. Then all molecules and abstractions describing the structure and behaviour of the system to be modelled are put in a configuration to obtain a biochemical program, which we also refer to as (system) state. We introduce the program entity in order to distinguish between global and local configurations by making explicit the square brackets for the former ones. This distinction is needed in the formalisation of the calculus.

Example 2.1 We illustrate the calculus with a toy example of a loaning service model provided by a university library for students in the Departments of Math- ematics and Computer Science. The entities of this model are students as users, libraries as service providers, textbooks as resources (or services), and a global clock:
student S (id, dpt, state), where id is a unique student identity, dpt takes a value of M or CS, and state takes a value of 1 for requesting, 2 for pending, 3 for reading;
library L(dpt, SID, BID ), where SID and BID are sets of student and book identities respectively;
book B (b, sid, tick ), where b is the book identity, and sid takes the value of the identifier of the student who borrowed it at non-nullary time stamp tick , otherwise nil if tick is 0.
We model each entity as a node with ports in a port graph [4], where some ports have states or maximum arity greater than one. A library node has the port SID where several students from the same department may connect and the port BID where all book nodes from the same department are connected, a student node can be connected with a book node, and the two libraries are connected. Let ≡ denote the isomorphism relation on port graphs. The juxtaposition operator • is not represented for port graph objects.
The library service example has three basic actions illustrated as port graph rewrite rules in Fig. 2:
BReq: a student requests a book at the departmental library within one time unit;
BBrw: a student borrows an available book from the library within one time unit;
BRet: a student returns a book instantaneously to the departmental library after holding it for at most 5 time units;



Fig. 2. Rewrite rules describing the actions in the library loaning service
DBRet: a student returns a book instantaneously to the library of another depart- ment after holding it for at most 3 time units.

Semantics of Biochemical Programs
The evaluation mechanism of the calculus relies on solving the fundamental problem of matching a pattern to a molecule, i.e., finding an injective morphism between the pattern and the molecule. Let Sol be a function that returns the set of substitutions σ solutions of a given matching problem between two molecules M and Mj, denoted M  Mj. A submatching problem M ≺≺ Mj is a matching problem from M to a sub-molecule Mjj of Mj.
Definition 2.2 The structural congruence on conﬁgurations is the least equivalence relation on configurations such that it includes the structural congruence relation on molecules and the following equations:
(Application) (M $⇒ K)@Mj ≡ ς(K) if ς ∈ Sol(M ≺≺ Mj)
(Application Fail) (M ⇒$ K)@Mj ≡ stk if Sol(M ≺≺ Mj)= ∅
(Stuck) stk •K ≡ K
If the matching problem between the left-hand side of the abstraction M $⇒ K and the molecule Mj has solutions, the equation (Application) is used and one substitution is chosen from the solution set and applied on the right-hand side of M ⇒$ K; otherwise, if the matching problem has no solution, the application fails and it is reduced to the failure object stk according to equation (Application Fail). A stk object is deleted from a juxtaposition of configurations according to (Stuck).

Definition 2.3 A configuration is in normal form if it is irreducible with respect to the equations (Application), (Application Fail) and (Stuck) ordered from left to right. A program [K] is in normal form if configuration K is in normal form.
The following evaluation rule defines the operational semantics of biochemical programs, more specifically, the interaction between abstractions and molecules:
(Interaction) [Kj•(M ⇒$ K)•Mj] −→ [Kj•ς(K)]
if ς ∈ Sol(M ≺≺ Mj) and [Kj•(M $⇒ K)•Mj] is in normal form
The interaction evaluation rule chooses an abstraction M $⇒ K, a molecule Mj in the current program and a substitution ς solution of the matching problem M ≺≺ Mj, and then replaces M ⇒$ K and Mj with the configuration obtained from applying the substitution ς to K. The variable Kj captures the context in which the rule M $⇒ K and the molecule Mj interact, thanks to the AC properties of •.
We define a new evaluation rule on biochemical programs [K] −→≡ [Kj] as syntactic sugar for [K] −→ [Kjj] and [Kjj] ≡ [Kj] with [Kj] in normal form.
Strategies
It is important to emphasise that we can model a non-deterministic (and possibly non-terminating) behaviour for the application of abstractions in a biochemical program, or introduce some control to compose or to choose the rules to apply. For this purpose we introduce strategies in the calculus by expressing them as higher- order abstractions. Strategies may be used in various ways: to sequentialise or order the application of several abstractions, to exploit failure information, to define persistent rules that are not consumed when applied, to implement case analysis and iteration. More details can be found for instance in [1,5].
Most strategies are encoded as abstractions of the form Y $ K, where Y is a molecule variable and it corresponds to a higher-order function, i.e. to a lambda expression λY.K. When Y $ K is applied to a molecule M , we obtain a reactive molecule (Y $ K)@M which is structurally congruent to K where each occurrence of Y has been replaced by M .
In Fig. 3 we recall the encoding of some strategies as higher-order abstractions in the ρ⟨&5J ⟩-calculus, where T, T1, T2, T3 range over abstractions. The strategies id and fail represent the identity and failure strategies. The seq(T1, T2) strategy applies sequentially the two abstractions T1 and T2, while first(T1, T2) tries first to apply T1 and in case of application failure it applies the second abstraction T2. The application of not(T ) fails if the application of T1 does not fail, otherwise it does nothing. The strategy ifThenElse(T1, T2, T3) applies the first strategy: if it does not fail, it applies the second strategy, else it applies the third strategy; it fails if both applications of T2 and T3 fail.
A strategy T can be applied as long as it is does not fail using the recursive strategy: repeat(T ) μX.first(seq(T, X), id). The recursion operator μ is en- coded using the fixed-point combinator of the λ-calculus following the procedure

id  Y $ T	fail  Y $ stk	seq(T1, T2)  Y $ T2@(T1@Y )
first(T1, T2)  Y $ (T1@Y )•(stk $ (T2@Y ))@(T1@Y )
not(T )  Y $ first(stk $ Y, Y j $ stk)@(T @Y )
ifThenElse(T1, T2, T3)  Y $ first(stk $ T3@Y, Y j $ T2@Y )@(T1@Y )
Fig. 3. Strategy operators encoded as higher-order abstractions

done for encoding iterators in the ρ-calculus [12].
In the (Interaction) evaluation rule, a strategy (or a rule) M ⇒$ K is consumed by a non-failing interaction with a molecule Mj. The persistent strategy combina- tor defined by T ! μX.seq(T, first(stk ⇒ stk,Y $ Y •X)), when applied to a molecule, applies T to the molecule and T ! is replicated; if the application of T fails, then the failure stk is returned.
Example 2.4 We extend the library service model with an action DBReq de- picted in Fig. 2 which allows a library to dispatch a book request to the other library if the latter has available books resulting in a student borrowing a book from the other department’s library. A library can dispatch a request only when it has no book available by considering a strategy which gives a higher priority to BBrw than DBReq; therefore we replace the rules BBrw and DBReq by seq(BBrw, DBReq).
The initial state of the biochemical program modelling the library service is a juxtaposition of student nodes in requesting state, two connected library nodes – one for each department, book nodes available for each library, and the persistent strategies BReq!, seq(BBrw, DBReq)!, BRet1! and BRet2!.
Rewrite rules and strategies used in biochemical programs are indeed essential concepts to express evolution of autonomous systems. The same concepts can be reused for developing verification techniques for autonomous systems.
A first approach for embedding verification in models of autonomous systems, described in [5], consists in expressing an invariant property of the system as an abstraction with identical sides, M ⇒$ M , and relying on the matching process for testing the presence of a molecule M . The failure of the invariant is handled by a failure port graph Error that does not allow the execution to continue. The strategy verifying such an invariant is first(M ⇒$ M, X ⇒ Error)!. We can also express the unwanted occurrence of a molecule M using the strategy (M ⇒ Error)!. In both cases above, instead of yielding the failure Error signalling that a property of the system is not satisfied, the problem can be “repaired” by associating to each prop- erty the necessary rules or strategies to be inserted in the system in case of failure. Such ideas open a wide field of possibilities for combining runtime verification and self-healing capabilities and we explore them further in Sect. 4.
Building up on this simple idea, our goal is to generalise invariant verification towards the proof of safety and liveness properties. This is natural since the eval- uation rule of biochemical programs can be seen as a reduction relation in a state

transition system – more specifically an Abstract Reduction System (ARS). For verification, we consider properties expressed as formulae in a three-valued linear temporal logic and interpreted over traces in the ARS associated to the program. First we show how to encode the properties into adequate rewrite strategies, which allows us to embed them in each state of an extended ARS. For that purpose, the structure of programs is enriched by guards and another reduction relation is de- fined on guarded programs. Then property satisfaction is checked on each transition state via the evaluation mechanism of the rewrite strategies.
Linear Temporal Logic for Biochemical Reductions
In this section, we first review the basic concepts underlying an Abstract Reduc- tion System. Then we define a set of structural formulae for reasoning about the molecular structures in configurations. Finally, we review the set of LTL formu- lae [17] defined over the Abstract Reduction System whose states are biochemical programs and whose transitions are determined by the interaction evaluation rule in the ρ⟨&5J ⟩-calculus.
Abstract Reduction Systems
An Abstract Reduction System (ARS) [15] is a labelled oriented graph (S, s0, R) with S a finite set of nodes called states, s0 ∈ S the initial state, and R a binary relation over S × S called transition relation. Let A be the ARS built over biochemical programs using the interaction evaluation relation. Then (s, sj) ∈ R if s −→≡ sj in the ρ⟨&5J ⟩-calculus. We call s −→≡ sj a reduction steps or transition. If we consider a function labelling states with atomic propositions, we obtain the definition of a Kripke structure.
A computation path or trace in the ARS A is a path in the graph starting from the initial state s0, i.e., an infinite non-empty sequence s0s1s2 ... of states in S where si −→≡ si+1 for all i ≥ 0. Let Path(A) denote the set of paths of A. A finite trace is a non-empty sequence s0s1 ... sn with n ≥ 0. A finite trace u = s0s1 ... sn can be

concatenated with an infinite sequence of states w = sj sj ... with sj −→≡ sj
, for

0 1	j	j+1
all j ≥ 0, to obtain a new infinite trace if and only if sn −→≡ sj and we say that
w is a continuation of u. For a path w = s0s1s2 .. ., we denote by w[i] the ith state of the path, namely si—1, and by wi the suffix of the path w starting at state w[i], i.e., wi = si—1si	We say that a state s in the ARS A is ﬁnal (or irreducible) if
there is no state sj such that s −→≡ sj. We denote a final state s by s↓.
Structural Formulae and Structural Satisfaction
Based on molecule definition and Boolean connectors, in the following we define the formulae characterising the molecular structure of states in A.
Definition 3.1 The set of structural formulae F(M) is constructed inductively as follows:
ϕ ::= true | false | ¬ϕ | ϕ ∧ ϕ | ϕ ∨ ϕ | ϕ → ϕ |	ϕ

with true, false, ¬, ∧, ∨ and → the usual boolean connectors, and “somewhere” ϕ.
ϕ read as

Definition 3.2 The semantics of a structural formula ϕ ∈ F(M) with respect to a molecule M , denoted by M |= ϕ, is defined inductively as follows:
M |= true	M |= ϕ1 ∧ ϕ2 ⇔ M |= ϕ1 and M |= ϕ2
M |= false	M |= ϕ1 ∨ ϕ2 ⇔ M |= ϕ1 or M |= ϕ2 M |= Mj ⇔ Mj  M		M |= ϕ1 → ϕ2 ⇔ M |= ϕ1 or M |= ϕ2

M |= ¬ϕ ⇔ M |= ϕ	M |=
ϕ ⇔ ∃M j ≺≺ M. Mj |= ϕ

We say that a state s of the ARS A satisﬁes a structural formula ϕ and write s |= ϕ
if s ≡ [M•Kj] and M |= ϕ.
The structural satisfaction problem between a molecule M and a formula Mj
reduces to successfully solving the matching problem Mj  M . A molecule M

structurally satisfies a formula
ϕ if M has a submolecule Mj satisfying ϕ.

The following proposition states that the structural satisfaction is up to the structural congruence relation on states. The proof is immediate using induction over the structure of ϕ.
Proposition 3.3 If s |= ϕ and s ≡ sj then sj |= ϕ.
Temporal Formulae
In order to express safety or liveness properties, we need a temporal logic. The set of LTL formulae over F(M) is inductively defined by:
φ ::= true | false | ϕ | ¬φ | φ ∧ φ | φ ∨ φ | φ → φ | X φ | φ U φ
where ϕ ranges over the set of structural formulae F(M). Three more path op- erators are available as syntactic sugar: the eventually operator F (future) with Fφ ≡ true U φ, the always operator G (globally) with Gφ ≡ ¬(F¬φ), and the release operator R with φ1Rφ2 = ¬(¬φ1U¬φ2).
The LTL formulae are interpreted over traces in the ARS A and their semantics is defined inductively as follows:


w |= true  w |= false w |= ϕ  iff w[0] |= ϕ w |= ¬φ iff w |= φ
w |= Xφ  iff w1 |= φ
w |= φ1 ∨ φ2 iff w |= φ1 or w |= φ2 w |= φ1 ∧ φ2 iff w |= φ1 and w |= φ2 w |= φ1 → φ2 iff w |= φ1 or w |= φ2

w |= Fφ	iff ∃i ≥ 0 . wi |= φ	w |= Gφ iff ∀i ≥ 0 . wi |= φ w |= φ1Uφ2 iff ∃k ≥ i s.t. wk |= φ2 and ∀i ≤ l < k . wl |= φ1
w |= φ1Rφ2 iff ∀k ≥ 0 either wk |= φ2 or ∃j ≥ 0 s.t. wi |= φ1 and ∀j ≤ i. wj |= φ2

An LTL formula φ holds in a state s of A, ⟨A, s⟩ |= φ, if and only if for every infinite trace w with w[0] = s in A we have w |= φ. The LTL model checking problem A |= φ checks if ⟨A, s0⟩ |= φ where s0 is the initial state of A.
We consider only LTL formulae in positive normal form, i.e. negations only occur in front of structural formulae. This is possible since every operator in the LTL syntax presented above has a dual. In particular we have the following equivalences:
¬(Xφ)= X(¬φ), ¬(Fφ)= G(¬φ), ¬(Gφ)= F(¬φ), ¬(φ1 U φ2)= ¬φ1 R¬φ2.
Embedding Runtime Verification in the Abstract Biochemical Calculus
In this section we extend the reduction relation defined for the biochemical calculus with LTL formulae as guards of the computation. The aim is to check at runtime that, after each interaction step induced by the interaction evaluation rule, a set of properties expressed as simple LTL formulae is satisfied.
In runtime verification a trace is also called run and a finite trace an execution. Monitoring a property at runtime can only be formally defined over finite traces. The LTL3 [9], a variant of LTL with a three-valued semantics, was designed to overcome this gap between monitoring finite and infinite traces. In an automaton approach, a finite trace is a good preﬁx if any infinite continuation of the trace will always be accepted, a bad preﬁx if there is no continuation of the trace to build an accepting trace, and an ugly preﬁx otherwise. A good, bad or ugly prefix of an LTL formula is evaluated to true, false or inconclusive (denoted by ?) respectively. The semantics of a LTL3 formula φ with respect to a finite trace u in an abstract reduction system A is defined as follows:
⎧⎪⎨true	if ∀ w continuation for u, uw |= φ
⎪?	otherwise
We adopt the following approach. We start with an inconclusive guard and we check that a property φ is satisfied by the current execution by applying a strategy encoding the formula. If no decision can be made, either to state that the property is satisfied or not, we pass on the inconclusive guard meaning that all along the current execution there is no state that makes the property not satisfied.
Syntax
We consider the following set of LTL formulae defined over the set of structural formulae F(M):
φ ::= true | false | ϕ | ¬φ | φ ∧ φ | φ ∨ φ | φ → φ | F ϕ | G ϕ | ϕ U ϕ | ϕ R ϕ
We define guarded biochemical programs with the guard being an LTL formula
φ over molecules, prefixed by a satisfaction operator (either |=, |= or |=?), or a

conjunction of such formulae:

The atomic guard |= φ (|= φ) states that the formula φ is satisfied (not satisfied respectively) by the current execution, whereas |=? φ corresponds to a consistent inconclusive satisfaction answer all along the current execution. We consider guards α φ with φ in positive conjunctive normal form and we decompose guards such that the LTL formula φ is not a conjunction. The structural congruence relation on atomic guards, denoted also ≡, is defined inductively as follows:
α φ1 ≡ α φ2 if φ1 and φ2 are syntactically equivalent
α (φ1 ∧ ... ∧ φn) ≡ (α φ1) ∧ ... ∧ (α φn)
(|= φ) ∧ (α φ1) ∧ ... ∧ (α φn) ≡ |= (φ ∧ φ1 ∧ ... ∧ φn)
We introduce an intermediate form of guarded programs, (M $ K)@[K]H, con- sisting of the application of an abstraction on a guarded program of the form [K]H . We need it to define the new extended reduction relation for guarded program.
Let Z and W denote respectively sets of variables for configurations and for guarded programs. We define new abstractions over guarded programs of the form W $⇒ GS and [Z]H ⇒$ GS where W ∈ W, Z ∈Z and GS a guarded program.
Definition 4.1 The structural congruence relation on guarded biochemical pro- grams is the least equivalence relation on guarded biochemical programs generated by the equation:
[K]H ≡ [Kj]H′ if and only if K ≡ Kj and H ≡ Hj
and by the following equations oriented from left to right:
(M ⇒$ K)@[Kj]H ≡ [(M ⇒$ K)@Kj]H
(W ⇒$ [K]H )@[Kj]H′ ≡ [K]H
([Z]H $⇒ [K]H )@[Kj]H ≡ [{Z '→ Kj}K]H
where {Z '→ Kj}K denotes the replacement of all occurrences of the variable Z in
K by Kj.
In the following we explain each of the three application reductions included in the definition of the structural congruence relation above. First, the application of an abstraction M $⇒ K on a guarded program [Kj]H is equivalent to the application of the abstraction to the top-level configuration of the guarded program since the

abstraction M
⇒$ K as no effect on the guard H. Second, the application of an

abstraction with a guarded program variable as left-hand side on any guarded pro- gram returns its right-hand side: the matching substitution associates W to [Kj]H′ and the application result is the right-hand side [K]H (the matching substitution

does not modify it). Third, the application of an abstraction [Z]H $⇒ [K]H on a guarded program [Kj]H′ produces a matching substitution associating variable Z to Kj and returns the right-hand side [K]H of the abstraction where every occurrence of the variable Z is replaced by K.
Definition 4.2 A guarded biochemical program is in normal form if it has the form [K]H where K is in normal form and H is a conjunction of atomic guards whose underlying LTL formulae are in positive conjunctive normal form.
Example 4.3 An example of safety formula in the library service model is the property that a student should always be able to borrow a book from any de-

partmental library G(
S (id, dpt, 2 ) ∧
B (b, nil, 0 ))) with formula S (id, dpt, 2 )

standing for a student connected to a library in requesting mode and formula
B (b, nil, 0 ) standing for an available book. We can formulate other formulae such

as: ¬G(
B (b, SID, i ) ∧
B (b, SID, j )) stating that a book cannot be simultane-

ously borrowed by two students or the liveness property F( to be available at some point.
B (id, nil, 0 ) for a book

Semantics of Guarded Biochemical Programs
A structural formula ϕ in F(M) is mapped to a strategy τ (ϕ) and it is interpreted over a molecule M from a program configuration as the result of the strategy ap- plication τ (ϕ)@M . We define the mapping τ from structural formulae to strategies inductively as follows:
τ (true)  id	τ (false)  fail
τ (  M )  M ⇒ M	τ (¬ϕ)  not(τ (ϕ))
τ (ϕ1 ∧ ϕ2)  seq(τ (ϕ1),τ (ϕ2))	τ (ϕ1 ∨ ϕ2)  first(τ (ϕ1),τ (ϕ2)) τ (ϕ1 → ϕ2)  Y $⇒ seq(τ (ϕ1), first(stk $⇒ Y, τ (ϕ2)))@Y
Lemma 4.4 Let ϕ be a structural formula in F(M) and M a molecule. Then the normal form of τ (ϕ)@M is either M or stk.
Proposition 4.5 If M is a molecule and ϕ a structural formula in the calculus, then (i) M |= ϕ if and only if τ (ϕ)@M ≡ M, and (ii) M |= ϕ if and only if τ (ϕ)@M ≡ stk.
Intuitively, if the application of the strategy encoding ϕ on a molecule M fails, then the formula is not satisfied by M . The above proposition shows the soundness and completeness of encoding the semantics of structural formulae via the evaluation mechanism of strategies. The proofs of these last two results can be found in [1].
For s0 the initial state of the ARS A and φ a temporal property that we want to verify along the execution of the system, we start with the initial guarded bio- chemical program s0|=?φ. In the following we define a new reduction relation on guarded programs denoted e⇒= which encompasses the reduction relation −→≡ on biochemical programs and verifies at each step the satisfaction of the guard.

The process of verifying the satisfaction of a guard along an execution trace consumes it: an LTL formula and a state s generate another LTL formula. To define the consumption of an LTL formula φ by the reduction relation in the calculus, we use derivatives [18] for LTL. The evaluation of derivations provide a way of determining if a prefix is good or bad for a formula. For s a state and φ an LTL formula, the derivative of φ in state s, denoted by φ{s}, has the property that for any finite trace u, su |= φ iff u |= φ{s} and su |= φ iff u |= φ{s}.
Theorem 4.6 (Derivative [18]) For any LTL formula φ and for any ﬁnite trace u = s0s1 ... sn, u is a good (bad) preﬁx for φ if and only if φ{s0}{s1} ... {sn} evaluates to true (false).
The recursive definition of the operator { } is:
false{s} = false	true{s} = true
(¬φ){s} = ¬(φ{s})	(φ1 ∨ φ2){s} = φ1{s}∨ φ2{s}
(φ1 ∧ φ2){s} = φ1{s}∧ φ2{s}	(φ1 → φ2){s} = φ1{s}→ φ2{s}
The definition of derivatives for the rest of temporal formulae is given together with the definition of the reduction relation e⇒= on guarded biochemical programs. The latter is defined by structural induction on the LTL formulae by associating a strategy Θ(φ) to each formula φ.
Definition 4.7 The reduction relation on guarded biochemical programs extends the interaction relation on biochemical programs with an evaluation of all atomic guards:

[K]α φ Λ...Λα φ
e⇒= [Kj]α′ φ Λ...Λα′ φ
if [K]α φ
e⇒= [Kj]α′ φ
for all i

1 1	n n
1 1	n n	i i	i i

[K]|=?φ e⇒= (Θ(φ)@[Kj]|=?φ)@[K]|=?φ if [K] −→≡ [Kj] [K]|=φ e⇒= [Kj]|=φ if [K] −→≡ [Kj]
[K]/|=φ e⇒= [Kj]/|=φ if [K] −→≡ [Kj]
where Θ(φ) is the strategy associated to the formula φ.

In order to address the case where the current execution reaches an irreducible program with an inconclusive guard, we need to extend the congruence relation on guarded biochemical programs as follows:

[K]|=?φ ≡ Θ↓(φ)@[K]|=?φ if [K] is irreducible

To achieve the complete definition of the reduction relation on guarded biochem- ical programs, we have to define strategy mappings Θ and Θ↓ for each type of LTL formulae φ used as a guard, relying in the intuition provided by derivatives. This is the purpose of the following five subsections.

Strategy encoding for structural formulae
The derivative of a structural formula ϕ in a state s is true if s |= ϕ and false otherwise. The strategy encoding the temporal formula ϕ evaluates the application of the strategy τ (ϕ) on the current state s and returns the guard |= ϕ if s |= ϕ, otherwise the guard |= ϕ.
Θ(ϕ)   [Z]|=?ϕ $⇒ ifThenElse(τ (ϕ), W1 ⇒$ [Z]|=ϕ, W2 $⇒ [Z]/|=ϕ) Θ↓(ϕ)  ifThenElse(τ (ϕ), [Z]|=?ϕ ⇒$ [Z]|=ϕ, [Z]|=?ϕ ⇒$ [Z]/|=ϕ)
Strategy encoding for Gϕ formulae
The derivative of the globally operator for a non-final state s and a final state s↓ is defined as follows:


(Gϕ){s} =	false	if ¬ϕ{s}
Gϕ	otherwise
false	if ¬ϕ{s↓}
↓
true	otherwise

The strategy encoding Gϕ tests the satisfaction of ϕ in the current state: if the answer is positive then the guard is inconclusive for the current execution and the verification continues with the same guard, otherwise the guard is negative meaning that the temporal formula Gϕ is not satisfied by the current execution. If the current state is final, then the inconclusive guard turns into a positive one if this state satisfies ϕ as well, since the formula ϕ is satisfied in every state of the execution. The strategies Θ and Θ↓ encoding Gϕ for non-final and final states are:
Θ(Gϕ)  [Z]|=?Gϕ ⇒$ ifThenElse(τ (ϕ), W1 $⇒ [Z]|=?Gϕ, W2 $⇒ [Z]/|=Gϕ) Θ↓(Gϕ)  ifThenElse(τ (ϕ), [Z]|=?Gϕ $⇒ [Z]|=Gϕ, [Z]|=?Gϕ $⇒ [Z]/|=Gϕ)
Strategy encoding for Fϕ formulae
The derivative of the eventually operator for a non-final state s and a final state s↓
is defined as follows:

(Fϕ){s} =  true	if ϕ{s}
(Fϕ){s } = ϕ{s } =  true	if ϕ{s↓}


The strategy encoding Fϕ tests if the current state satisfies ϕ. If it does, then one state satisfying ϕ in the current execution has been found, hence the inconclusive guard is turned to a positive one. Otherwise, the guard is passed to the next state as inconclusive. If the current state is final and it satisfies ϕ, then the execution satisfies the temporal formula Fϕ; otherwise, the execution does not satisfy Fϕ. The strategiesΘ and Θ↓ encoding Fϕ for non-final and final states are the following respectively:
Θ(Fϕ)  [Z]|=?Fϕ ⇒$ ifThenElse(τ (ϕ), W1 $⇒ [Z]|=Fϕ, W2 ⇒$ [Z]|=?Fϕ) Θ↓(Fϕ)  ifThenElse(τ (ϕ), [Z]|=?Fϕ $⇒ [Z]|=Fϕ, [Z]|=?Fϕ $⇒ [Z]/|=Fϕ)

Strategy encoding for ϕ1Uϕ2 formulae
The derivatives of ϕ1Uϕ2 for non-final and final states respectively are defined as follows:



(ϕ1Uϕ2){s}  =
true	if ϕ2{s}
(ϕ1Uϕ2)	if ¬(ϕ2{s}) and ϕ1{s}
⎪⎩false	if ¬(ϕ2{s}) and ¬(ϕ1{s})

(ϕ Uϕ ){s } =  true	if φ2{s↓} or (¬(ϕ2{s↓}) and ϕ1{s↓})


The strategy encoding the temporal formula ϕ1Uϕ2 tests first if the current state satisfies ϕ2: if it does, then the inconclusive guard is transformed into a positive guard; otherwise, it tests if the current state satisfies ϕ1: if it does, then we continue with an inconclusive guard (hence all previous and current states in the execution satisfy ϕ1), else we found a state where neither ϕ1 or ϕ2 are satisfied, hence the formula ϕ1Uϕ2 is not satisfied by the execution. The strategies Θ and Θ↓ encoding ϕ1Uϕ2 for non-final and final states are the following respectively:
Θ(ϕ1Uϕ2)  [Z]|=?ϕ1Uϕ2 $⇒ ifThenElse(τ (ϕ2), W1 $⇒ [Z]|=ϕ1Uϕ2 ,
W2 $⇒ ifThenElse(τ (ϕ1), W3 $⇒ [Z]|=?ϕ1Uϕ2 , W4 $⇒ [Z]/|=ϕ1Uϕ2 )) Θ↓(ϕ1Uϕ2)  ifThenElse(τ (ϕ2), [Z]|=?ϕ1Uϕ2 $⇒ [Z]|=ϕ1Uϕ2 ,
[Z]|=?ϕ1Uϕ2 $⇒ ifThenElse(τ (ϕ1), W3 ⇒$ [Z]|=ϕ1Uϕ2 , W4 $⇒ [Z]/|=ϕ1Uϕ2 ))

Strategy encoding for ϕ1Rϕ2 formulae
The derivatives of ϕ1Rϕ2 for non-final and final states respectively are defined as follows:



(ϕ1Rϕ2){s}  =
true	if ϕ2{s} and ϕ1{s}
(ϕ1Rϕ2)	if ϕ2{s} and ¬(ϕ1{s})
⎪⎩false	if ¬(ϕ2{s})

(ϕ Rϕ ){s } =  true	if φ2{s↓}

The strategy encoding the temporal formula ϕ1Rϕ2 tests first if the current state satisfies ϕ2: if it does, then the inconclusive guard is transformed into a positive guard; otherwise, it tests if the current state satisfies ϕ1: if it does, then we continue with an inconclusive guard (hence all previous and current states in the execution satisfy ϕ1), else we found a state where neither ϕ1 or ϕ2 are satisfied, hence the formula ϕ1Rϕ2 is not satisfied by the execution. The strategies Θ and Θ↓ encoding









Fig. 4. Normal forms of (Θ(φ)@s′
|= φ
)@s|=? φ and (Θ↓(φ)@s|=? φ) for s|=? φ the current guarded biochemical

program and s′ the next unguarded biochemical program
ϕ1Rϕ2 for non-final and final states are the following respectively:
Θ(ϕ1Rϕ2)  [Z]|=?q1Rq2 $⇒ ifThenElse(τ (ϕ2),
W1 ⇒$ ifThenElse(τ (ϕ1), W2 $⇒ [Z]|=q1Rq2 , W3 ⇒$ [Z]|=?q1Rq2 ), W4 $⇒ [Z]/|=q1Rq2 ) Θ↓(ϕ1Rϕ2) ifThenElse(τ (ϕ2), [Z]|=?q1Rq2 ⇒$ [Z]|=q1Rq2 , [Z]|=?q1Rq2 ⇒$ [Z]/|=q1Rq2 )
The properties of the strategy definitions above are summarised by the next proposition:
Proposition 4.8 Let s|=?q be the current guarded biochemical program. If the next biochemical program computed by the evaluation rule (Interaction) is sj, then its guard is computed, according to Def. 4.7, as the normal of the application
(Θ(φ)@sj ? )@s|=?φ. Otherwise, if the biochemical program s is irreducible, then
|= φ
its guard is computed by reducing to normal form the application (Θ↓(φ)@s|=?φ). Figure 4 lists these computations when the current guard φ ranges over ϕ, Gϕ, Fϕ, ϕ1Uϕ2 and ϕ1Rϕ2.
We are now ready to prove the correctness of our encoding of the runtime ver-



Fig. 5. Rewrite rules describing a student returning a book to the library of another department and of the same department

ification of LTL formulae in the calculus using strategies, based on the result of Theorem 4.6.
Theorem 4.9 (Correctness) For any LTL formula φ guarding a biochemical pro- gram s0 and for any ﬁnite trace u = s0s1 ... sn, u is a good preﬁx for φ if and only if either:

∃i, 0 ≤ i ≤ n, such that for all j < i, sj—1
j
|=?φ
i—1
|=?φ
e⇒= si
, or

0
|= φ
e⇒= s1 ?
e⇒= ... e⇒= sn ?
and sn ?
|=φ.

We obtain a similar result for a bad preﬁx if we replace the guard |= φ by |= φ.

Example: Repairing a property of the loaning service speciﬁcation
Consider a biochemical program P describing the library loaning service from Ex- amples 2.1 consisting of: the library of the Maths department with 6 Statistics textbooks and 6 Maths students, the library of the CS department with 3 Statistics textbooks and 6 CS students, and the strategies given in Example 2.4. We guard

the program P with the safety formula φ = G(
S (id, dpt, 2 )л
B (b, nil, 0 ))) which

requires that a student should always be able to borrow a book from any depart- mental library. However, this guard may become false if P evolves to a state where both libraries lent all their textbooks and a Maths (resp. CS) student demands a book. In order to solve this problem and offer the students an equal chance to study, exceptionally a CS (resp. Maths) student is forced to return a book if borrowed from the other department, otherwise a student from the same department. Such behaviour is modelled by the strategy R = try(FRet1, FRet2) with FRet1 and FRet2 depicted in Fig. 5. Therefore we provide the guard φ with the repairing strategy above and have in the calculus:
s/|=φ(R) ≡ (R@s)|=?φ(R)
such that, every time the guard φ is not satisfied, the guard is transformed into an inconclusive guard and the repairing rule is injected into the program.

On LTL Formulae Guards with Two Modal Operators
We have seen by now how to encode the LTL formulae built with at most one path operator using strategies such that their verification during the program execution amounts to strategy evaluation. However there are plenty of interesting LTL for-

mulae with two modal operators. For instance, in the library example the formula
G(  S (id, dpt, 2 ) → F(  S (id, dpt, 3 ))) says that always a student request of a book
is eventually fulfilled.
In the following we sketch a methodology of encoding guards consisting of LTL formulae built using at most two modal operators such as G(ϕ1 → Xϕ2), G(ϕ1лXϕ2), G(ϕ1 V Xϕ2), F(ϕ1 → Xϕ2), F(ϕ1 л Xϕ2), F(ϕ1 V Xϕ2), G(ϕ1 → Fϕ2), G(ϕ1Uϕ2), or
F(ϕ1Rϕ2). The keys of this encoding are the use of derivatives and LTL formulae consumption [18].
During the execution of a guarded program s|=?φ, the guard φ is consumed or reduced to a residual LTL formula φj, in order to reduce the satisfaction problem of an LTL formula with two modal operators or with the next operator X to the satisfaction problem of a simpler LTL formula. Here we want to reduce to a formula with at most one modal operator and without the next operator, whose satisfaction problem has been handled in Sect. 4.2. However, by consuming the guard φ, the information about the initial temporal formula to be tested may be lost. We avoid this by annotating the guards along the program execution with the initial guard: for φj the residual guard and φ the initial guard, we denote by φj/φ the annotated guard.
In the following we define the execution of Xϕ-guarded programs. The deriva- tives of Xϕ in a non-final state s and in a final state s↓ respectively are defined as follows:
(Xϕ){s} = ϕ/Xϕ	(ϕ/Xϕ){s} =	true	if ϕ{s}
false	otherwise
(Xϕ){s } = false	(ϕ/Xϕ){s } =  true	if ϕ{s↓}
It is worth noticing that the derivative of Xϕ reduces to the residual formula ϕ while carrying along its original formula Xϕ. Then the strategies encoding the next operator are:
Θ(Xϕ)  [Z]|=?Xq ⇒$ (W ⇒$ [Z]|=?q/Xq)
Θ(ϕ/Xϕ)  [Z]|=?q/Xq $⇒ ifThenElse(τ (ϕ), W1 $⇒ [Z]|=q/Xq, W2 ⇒$ [Z]/|=q/Xq) Θ↓(Xϕ)  [Z]|=?Xq $⇒ [Z]/|=Xq
Θ↓(ϕ/Xϕ)  ifThenElse(τ (ϕ), [Z]|=?q/Xq ⇒$ [Z]|=q/Xq, [Z]|=?q/Xq ⇒$ [Z]/|=q/Xq) with |= (ϕ/φ) ≡ |= φ and |= (ϕ/φ) ≡ |= φ.
Theorem 4.10 For any LTL formula Xϕ guarding a biochemical program s0 and
for any ﬁnite trace u = s0s1 ... sn, u is a good preﬁx for Xϕ if and only if n ≥ 1

and s0 ?
1
|= q/Xq
2
|=Xq
. The ﬁnite trace u is a bad preﬁx for Xϕ if and

only if n =0 or n ≥ 1 and s0 ?
1
|= q/Xq
2
|=Xq

Having illustrated the consumption of guards on encoding the formula Xϕ, we define in the following the strategy encoding a two-temporal modal operator LTL

formula F(ϕ1 л Xϕ2) for a non final-state s. Its derivative is defined as:


F(ϕ1
л Xϕ ){s} =  ϕ2/F(ϕ1 л Xϕ2)	if ϕ1{s}

F(ϕ1 л Xϕ2)	otherwise
Then the encoding strategies of F(ϕ1 л Xϕ2) are the following: Θ(F(ϕ1 л Xϕ2))  [Z]|=?F(q1ΛXq2) $⇒ ifThenElse(τ (ϕ1),
W1 $⇒ [Z](|=?q2/F(q1ΛXq2)) Λ (|=?F(q1ΛXq2)), W2 ⇒$ [Z]|=?F(q1ΛXq2))
Θ(ϕ2/F(ϕ1 л Xϕ2))  [Z]|=?q2/F(q1ΛXq2) $⇒ ifThenElse(τ (ϕ2),
W1 $⇒ [Z]|=q2/F(q1ΛXq2), W2 $⇒ [Z]/|=q2/F(q1ΛXq2))
The other LTL formulae mentioned at the beginning of section can be care- fully encoded using strategies, by following the top-down decomposition approach, according to the temporal operator on top, until reaching a residual LTL formula consisting of a structural formula, and by keeping track of the decomposition history.
Conclusions and Future Work
The main contributions of this paper are an abstract biochemical calculus to model autonomous systems with runtime verification capabilities for critical properties and a self-repairing method for the calculus when critical properties are violated.
In Sect. 4.4 we only gave a glimpse of how to define strategies encoding LTL formulae built using two temporal operators. Based on these ideas, we can synthe- sise a methodology or, even better, an automatic procedure which takes as input an LTL formula built using at most two temporal operators and produce the encoding strategy. A challenge will be then to encode even more complex LTL formulae.
For future work we plan to implement the runtime verification technique de- scribed in this paper in the PORGY system [2], an environment for visual mod- elling of complex systems through graphs and graph rewriting rules. PORGY is still under development but already provides tools to visualise traces of rewriting, and a strategy language has been designed in particular to guide the construction of the derivation tree. We envisage applications to wireless sensor networks and biochemical signalling pathways to accompany their formal model development by analysing random executions and critical properties.

References
Andrei, O., “A Rewriting Calculus for Graphs: Applications to Biology and Autonomous Systems,” Ph.D. thesis, Institut National Polytechnique de Lorraine, http://tel.archives-ouvertes.fr/docs/ 00/35/00/13/PDF/thesis-OanaAndrei.pdf (2008).
Andrei, O., M. Fern´andez, H. Kirchner, G. Melan¸con, O. Namet and B. Pinaud, PORGY: Strategy Driven Interactive Transformation of Graphs, in: R. Echahed, editor, TERMGRAPH, EPTCS 48, 2011, pp. 54–68.
Andrei, O. and H. Kirchner, A Rewriting Calculus for Multigraphs with Ports., in: Proceedings of RULE’07, Electronic Notes in Theoretical Computer Science 219, 2008, pp. 67–82.


Andrei, O. and H. Kirchner, A Higher-Order Graph Calculus for Autonomic Computing, in: M. a. Lipshteyn, editor, Graph Theory, Computational Intelligence and Thought. Golumbic Festschrift, Lecture Notes in Computer Science 5420 (2009), pp. 15–26.
Andrei, O. and H. Kirchner, A Port Graph Calculus for Autonomic Computing and Invariant Verification, Electronic Notes in Theoretical Computer Science 253 (2009), pp. 17–38.
Banˆatre, J.-P., P. Fradet and Y. Radenac, Higher-Order Chemical Programming Style, in: J.-P. Banˆatre,
P. Fradet, J.-L. Giavitto and O. Michel, editors, UPP, Lecture Notes in Computer Science 3566 (2004),
pp. 84–95.
Banˆatre, J.-P., P. Fradet and Y. Radenac, Programming Self-Organizing Systems with the Higher-Order Chemical Language, International Journal of Unconventional Computing 3 (2007), pp. 161–177.
Banˆatre, J.-P., N. L. Scouarnec, T. Priol and Y. Radenac, Towards ”Chemical” Desktop Grids, in:
eScience (2007), pp. 135–142.
Bauer, A., M. Leucker and C. Schallhart, Monitoring of Real-Time Properties, in: S. Arun-Kumar and
N. Garg, editors, FSTTCS, Lecture Notes in Computer Science 4337 (2006), pp. 260–272.
Bauer, A., M. Leucker and C. Schallhart, Runtime Verification for LTL and TLTL, Technical Report TUM-I0724, Technische Universit¨at Mu¨nchen (2007).
Berry, G. and G. Boudol, The Chemical Abstract Machine., Theoretical Computer Science 96 (1992),
pp. 217–248.
Cirstea, H. and C. Kirchner, The Rewriting Calculus - Part I and II, Logic Journal of the IGPL 9
(2001), pp. 427—498.
Giavitto, J.-L. and O. Michel, MGS: a Rule-Based Programming Language for Complex Objects and Collections., Electronic Notes in Theoretical Computer Science 59 (2001), pp. 286–304.
Kephart, J. O. and D. M. Chess, The Vision of Autonomic Computing, IEEE Computer 36 (2003),
pp. 41–50.
Kirchner, C., F. Kirchner and H. Kirchner, Strategic computations and deductions, in: C. Benzmueller,
C. E. Brown, J. Siekmann and R. Statman, editors, Reasoning in Simple Type Theory: Festschrift in Honor of Peter B. Andrews on His 70th Birthday (Paperback), Studies in Logic, Mathematical Logic and Foundations 17 (2008), pp. 339–364.
Pazat, J.-L., T. Priol and C. Tedeschi, Towards a Chemistry-Inspired Middleware to Program the Internet of Services, ERCIM News 2011 (2011), p. 34.
Pnueli, A., The Temporal Logic of Programs,, in: FOCS (1977), pp. 46–57.
Sen, K., G. Rosu and G. Agha, Generating Optimal Linear Temporal Logic Monitors by Coinduction, in: V. A. Saraswat, editor, ASIAN, Lecture Notes in Computer Science 2896 (2003), pp. 260–275.
