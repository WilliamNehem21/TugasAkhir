	Electronic Notes in Theoretical Computer Science 169 (2007) 133–146	
www.elsevier.com/locate/entcs

Multi Labelled Transition Systems: A Semantic Framework for Nominal Calculi
Rocco De Nicola and Michele Loreti
Dipartimento di Sistemi e Informatica, Università di Firenze.
{denicola,loreti}@dsi.unifi.it

Abstract
Action Labelled transition systems (LTS) have proved to be a fundamental model for describing and proving properties of concurrent systems. In this paper,Multiple Labelled Transition Systems (MLTS) are introduced as generalizations of LTS that permit dealing also with systems features that are becoming more and more important when considering languages and models for network aware programming. MLTS permit describing not only the actions systems can perform but also system’s resources usage and their handling (creation, revelation . . . ) of names. To show adeguacy of our proposal we show how MLTS can be used to describe the operational semantics of one of the most studied calculus for mobility: the asynchronous
π-calculus.
Keywords: Mobile Code Languages, Temporal Logics of Programs, Coordination Models, Proof Systems


Introduction
A successful approach to the description of the behaviour of concurrent processes is the one based on Labelled Transition Systems (LTS). An LTS consists of a set of state S, a set of transition labels L and a transition relation →⊆ S × L × S. States correspond to the possible configurations a system can reach. Labels describe the actions a system can perform to interact with the environment. Transition relations model how a system, in a given configuration, evolves after the execution of an action.
For the concrete case of a, by now, classical process description language like CCS [13], we have that S is the set of CCS terms (or agent expressions); L consists of the input/output actions over channels that CCS processes can perform plus the distinct action τ ; → describes the systems evolutions as determined by the execution of specific actions.

٨ The work presented in this paper has been partially supported by EU Project Software Engineering for Service-Oriented Overlay Computers (SENSORIA, contract IST-3-016004-IP-09).

1571-0661 © 2007 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.019

The simplicity and versatility of Labelled Transition Systems has greatly con- tributed to the development and exploitation of different process description lan- guages. Indeed, LTS have been the common semantic framework that has been the basis for defining common formal tools, like temporal logics and behavioural equivalences useful for reasoning and establishing properties of concurrent systems. In the last decade, stimulated by new applications of network aware program- ming, several new formalisms based on process descripting languages but with new constructs for modelling network topology, name passing, resources usage and mobil- ity have been proposed. Here, we just want to mention the Distributed Join-calculus [10], the Distributed π-calculus [11], the Ambient calculus [5], the Seal calculus [6],
Nomadic Pict [16] and Klaim [8].
The new primitives of these distributed nominal calculi, are such that not only actions, but also names and resources play a central role when modelling systems behaviour. This fact renders it more difficult to use classical LTS as semantic models. To capture some of the distinguishing features of the new calculi, such as name scoping or process and data distribution, transition labels have to be enriched to carry information not only about the performed actions but also about the state of the system. This interplay has rendered more difficult the development of a general approach to distributed nominal calculi and we have witnessed to the development of a number of theories tailored on specific calculi that cannot be easily generalised. Indeed, each calculus requires its own set of transition labels that depends on its specific aspect. The drawback of having a variety of transition labels limits the possibility of using the operational semantics as the basis for defining common formal tools, like logics and equivalences.
We feel that it would be important to come up with a general operational model that, for distributed nominal calculi, can play the same role LTS have played for process description languages. Such operational model should permit naturally cap- turing all main aspects of the new class of systems and should represent the natural basis for interpreting temporal logics for describing systems properties.
As a candidate general operational model, we propose Multiple Labelled Tran- sition Systems (MLTS). Our starting point is the consideration that a central role in the new set of mobile calculi is played by names and resources. Names can be public, i.e. known by the environment where the system is executing, or private; and systems, during execution, can discover some of the private names. Resources, instead, can be used, consumed, and created. Thus, the description of the behaviour of terms of mobile calculi has to take into account both names and resources. We have that states of MLTS describe systems configurations while their naming struc- tures permit associating public (known by the environment) names to each state. Resources model data (e.g. the values exchanged over a channel), computational en- vironments (e.g. the locations where processes can be executed) and network links (that can be used for interaction). Moreover, MLTS are equipped with different transition relations that capture the different aspects of systems behaviour namely actions execution, resources creation and consumption and name revelation.
Indeed, an MLTS consists of a set of states, a set of resources, a set of transi-

tion labels, a naming structure and three transition relations. The three transition relations describe systems interactions with the environment:
the computation relation describes the interaction with the environment;
the resource relation describes resource usage;
the revelation relation describes the names revealed to the environment.
In the rest of the paper we shall first present our new model, then we will show usefulness of our proposal by using it to describe the operational semantics of a well known formalism generally recognized as a minimal common denominator of calculi for mobility: the asynchronous π-calculus (Aπ) [3,12]. Finally, we shall touch the issue of behavioural equivalence for MLTS and will propose an equivalence that induces the same identification of those induced by asynchronous bisimulation for Aπ.
Multi Labelled Transition Systems
In this section we introduce our variant of LTS that will be used as a general frame- work for describing the semantics of mobile calculi. As mentioned in the introduction a key role will be played by names that can be used to refer to channels (as in the case of π-calculus [15]) or to localities (as in the case of locality-based calculi like Klaim). These names can be public, i.e. known by the environment where the sys- tem is running, or private. The system, during its computation, can discover some private names.
First of all, we introduce a few basic definitions that permit dealing with struc- tured sets of names.
Definition 2.1 Let N be a set of names and X ⊆ N , a name substitution is a function σ : N → N , where:
{y1/x1,... , yn/xn} denotes the substitution that maps xi into yi and that is the identity on the other names;
σ1 · σ2 is the composition of σ1 and σ2;
σ1\X is the substitution σ2 such that:
n	if n	X
σ (n)= 


∅ denotes the identity substitution;
⎩ σ1(n) otherwise

Σ denotes the set of functions (substitutions) N → N .
Definition 2.2 Let X ⊆N and σ ∈ Σ, σ(X) is the image of X with respect to σ, namely:
σ(X)= x'|∃x ∈ X : σ(x)= x'}
Definition 2.3 Let S be a set, a naming structure for S is a triple N = ⟨N , η, ◦⟩
such that:

N is a countable set of names;
η : S → 2N , is the naming function;
◦ : S × Σ → S, is the renaming function.
where, if we use s ◦ σ for ◦(s, σ), we have that for each s ∈ S and σ ∈ Σ:
η(s) is ﬁnite;
s ◦∅ = s;
η(s ◦ σ)= σ(η(s)).
Intuitively, a naming structure for S permits considering the elements of S as containers of names. For each element s in S, η(s) gives the set of names that appear in s while the application of an element s to a substitution σ (s ◦ σ) yields the element of S obtained by renaming each name in s according to σ.
A Multi Labelled Transition System, MLTS for short, consists of a set of states S,a set of resources R,a set of transition labels L and a naming structure ⟨N, η, σ⟩ for each of S, R and L.
States describe the configurations a system can reach. The naming structure labels each state by a set of names. These are the names that are public (known by the environment) when the system is in a that state. Resources are the necessary prerequisites for system evolutions.
Transition labels typically identify the actions a system can perform to interact with the environment. We also assume that L contains a special distinct transition label τ denoting internal/silent evolution of a system.
The transition relations provide information about the actions systems can per- form to interact with the environment; about the reaction of systems to creation or deletion of new resources and about the handling by systems of private and public names.
MLTS have three different transition relations:
the computation relation, −→ S ×L× S;
the resource relation,	).. ⊆S × ({⊕, g} × R) × S;
the revelation relation, ‹→⊆ S × N × S.
The computation relation plays the same role as the transition relation in an LTS; it describes the actions a system can perform to interact with the environment.
The resource relation describes how a system evolves when resources are created
gr
or consumed. If r is a resource, we have that s1	).. s2 is possible if r is available
⊕r
at state s1; after r is consumed state s2 is reached. Similarly, we have s1	).. s2
if the environment can add resource r to s1 leading the system to s2.
The revelation relation describes the capability of a system to reveal a private name to the environment.
To guarantee the correct management of names, we need to require some specific properties for the three transition relations, namely that they be preserved by name

permutations.
Definition 2.4 A substitution σ is a name permutation if it is bijective.
Definition 2.5 Let N = ⟨N , η, ◦⟩ be a naming structure for A1,... , An, we say that a relation R ⊆ A1 × ... × An is preserved by name permutations if and only if for each name permutation σ:
(a1,... , an) ∈ R ⇔ (a1 ◦ σ,... , an ◦ σ) ∈ R
Definition 2.6 A Multi Labelled Transition System is a 7-uple



where:
M = ⟨S, R, L, N, −→,	)..
, ‹→⟩

S, R and L are countable sets of states, resources and transition labels;
N = ⟨N , η, ◦⟩ is a naming structure for S, R, L and N ; and
the three relations
·
· −→ ⊆ S ×L× S;

·	)..
⊆ S × ({⊕, g} × R) × S;

· ‹→ ⊆ S × N × S;
are preserved by name permutations.
In the rest of the paper we will use MS , MR, ML and MN to denote, re- spectively, the set of state, the set of resources, the set of transition labels and the naming structure of MLTS M.
Asynchronous π-Calculus
In this section we consider the asynchronous π-calculus (Aπ) [3,12], a subset of the
π-calculus with no output prefixing and provide an MLTS for it.
First we define the syntax of Aπ. If Ch is a countable set of channels (whose elements are ranged over by a, b, ... ), we let ProcAπ be the set of Aπ processes (P , Q,...) defined by the following syntax:
P, Q ::= ab G P |Q νa.P  !G G ::=	a(b).P	τ.P	G + G
where G denotes guarded processes.
In Aπ processes interact by exchanging messages over channels.
The term ab is used to indicate the availability of message b over channel a; it models non-blocking outputs. Instead, the term a(b).P , indicates the process that retrieves a value over then channel a and then behaves like process P where the name b is bound to the retrieved value;
The term 0 denotes the deadlocked process and τ.P denotes the process that performs an internal action and then behaves like P ; finally G1 + G2 indicates the

P |0 ≡ P	P |Q ≡ Q|P	(P |Q)|R ≡ P |(Q|R)
	a /∈ f n(Q)	

!P ≡ P |!P
ν a.(P |Q) ≡ (ν a.P )|Q
Table 1
ProcAπ Structural Equivalence

process that can nondeterministically behave like G1 or like G2.
Processes are composed via parallel composition, P |Q describe a system com- posed by two components (specified respectively by P and Q) that can proceed independently and that can interact via shared channels.
Private names are defined using restriction : νa.P denotes that a is a private name in P .
Infinite behaviours are modelled via process replication (!G). This can be thought of as an infinite composition of P (P |P | .. .).
Please notice that both input prefixing b(a).P and name restriction νa.P act as binders for name a within P . In the rest of the paper we shall use f n(P ) to denote the set of names free in P . We will also write P =α Q to denote that P and Q are equals up-to renaming of bound names. For instance, a(x).b(x) =α a(y).b(y) and ν a.ba =α ν c.bc. Let P be a process and σ a name substitution, we let P ◦ σ be the process obtained from P by replacing every free name a with σ(a).
Terms that intuitively represent the same process are identified by means of standard structural congruence ≡. This relation is defined as the smallest congruence relation over Aπ processes induced by the laws in Table 1. The structural laws express that | is commutative and associative and that the empty process can always be safely removed/added in a parallel composition. Structural equivalence states also that !P is equivalent to !P |P and that, if a does not occur in Q, ν a.(P |Q) is equivalent to ν a.P |Q. In the sequel, elements in ProcAπ will be considered equals up to structural equivalence.
Let us now consider a simple Aπ specification for a simple system that we will use as a running example in the sequel.
Example 3.1 A proxy is a system such that, given two channels a and b, if appro- priate, emits the values read from channel a on channel b.
A possible Aπ specifications for this system is:

Proxy1 =!a(x).τ.bx
where process Proxy1 models the system as the infinite replication of a process that first reads a value x from channel a, then performs some internal actions and finally emits x on channel b.
In [1] the operational semantics of Aπ processes is described by means of the LTS relation ('−→) defined in Table 2 where it is assumed that '−→ is closed with respect to the structural congruence relation ≡; this means that:




ab '−a→b 0	τ.P '−τ→ P
P '−a→b  P '	a /= b



a(b).P ac
P [c/b]
ν b.P a(b)	'


P	λ	'	λ

  '−→ P	a /∈ n(λ)
  G '−→ P	

ν a.P	λ  ν a.P '
G + G'  λ  P



ab	'

ab	'
a(b)
P
ab	'

P '−→ P	Q '−→ Q	  '−→ P	Q '−→ Q	b /∈ f n(Q)

τ
'−→
P	λ	'
P '|Q'
τ
'−→
ν b.P '|Q'

λ

  '−→ P	f n(Q) ∩ bn(α)= ∅
  G '−→ P	

λ
'−→
P '|Q'



Table 2
λ
'−→
P |!G

Labelled transition system for Aπ



P ≡ Q	Q '−λ→ Q'	Q' ≡ P '
P '−→ P '
As usual, bound and free names are considered and we have n(λ)= f n(λ)∪bn(λ)
where:
f n(τ )= ∅ f n(a(b)) = {a} f n(ab)= f n(a(b)) = {a, b}
bn(τ )= ∅ bn(a(b)) = {b}	bn(ab)= bn(a(b)) = ∅
The transition relation '−→ of [1] makes uses of labels of the form:

λ ::= τ  ab  a(b)  a(b)
and describes behaviours by considering different aspects at once. Labels τ and
a(b) are used to describe computations of a process: P	τ	P ' if P can perform an
internal synchronisation and then behaves like P ', while P a(b) P ' if P behaves like
'−→
P after value b is retrieved from channel a. The same relation is used to describe
state/spatial configuration of a process: P '−→ P ' if P ≡ P '|ab. Moreover, if the

value b is private in P (P ≡ ν b.P '|ab), P evolves to P ' with a label a(b) denoting that b is bound in P and that b is somehow communicated to the environment: b is no more private in P '.
We shall now see how MLTSs can be used to describe behaviour of Aπ processes when computations, spatial configurations and name revelations are modelled sepa- rately. We shall first define an MLTS (named MAπ) that can be used as a semantic model for Aπ processes. The set of states in MAπ will be the set of all Aπ pro- cesses. Our resources will be the set of terms denoting the availability of messages over channels; indeed π-processes during their computations consume and produce

values over channels.
The computation relation will consider only internal actions and synchronization.
For this reason, the set of transition labels in MAπ will contain only τ labels.
We let MAπ be the MLTS defined as follow:



where:
⟨ProcAπ, ResAπ, LabAπ, NAπ, −→,	)..
, ‹→⟩

ResAπ = {ab|a, b ∈ Ch};
LabAπ = {τ };
NAπ = ⟨Ch,fn, ◦⟩;

−→,	)..
and ‹→ are the transition relations induced by the rules of Table 3,

plus those induced by the closure of the relations under ≡ as defined in Table 1.
Transition relation describes internal computation of a system caused by internal moves (τ.P ) or by process synchronisation. Starting from a process P a resource ab can be created leading to process P |ab. Conversely, a resource ab can be consumed in P ≡ Q|ab obtaining Q. Finally, a process P reveals a name a, if name a is available over a public channel b. Intuitively, this means that the environment can be able to know the private name.
To show that the above is a MLTS, we need to prove that NAπ is a named struc- tures for states, resources and transition labels, and that all considered transition relations are preserved by name permutation.
Lemma 3.2 NAπ is a naming structure for ProcAπ, ResAπ, LabAπ and Ch.
Proof. The thesis follows easily by noting that:
for each process P and substitution σ f n(P ) is finite, P ◦∅ = P and f n(P ◦ σ)= 
σ(f n(P ));
for each a ∈ Ch, f n(a)= {a} and a ◦ σ = σ(a);
f n(τ )= ∅ and τ ◦ σ = τ .
□
Lemma 3.3 −→, ......)..	and ‹→ are preserved by name permutation.
Proof. We prove the lemma for −→. Proofs for	)..	and ‹→ are similar.

Let σ be a permutation, we have to prove that for each P and Q, if P
−−→ Q

then P ◦ σ	τ	Q ◦ σ.
τ
We proceed by induction on the derivation for P −−→ Q.
Base of Induction: We can distinguish two cases:
P = τ.Q and
P = a(b).R|ac with Q = R[c/b].
In both the cases, for each permutation σ, P ◦ σ	τ	Q ◦ σ.

τ.P −−τ→ P	a(b).P |ac −−τ→ P [c/b]

τ
−−τ→ P
τ
−−τ→ P

P |Q −−→ P '|Q
ν a.P	ν a.P '
gab

P	)..
P |ab	P |ab	).. P
		a /= b	 ν a.(P |ba) ‹→a P |ba
Table 3
MAπ: Transition Relations






gbv



τ
⊕av



τ






Fig. 1. A portion of the MLTS for Proxy1 of Example 3.1
Induction Hypothesis: For each P and Q, if P −−τ→ Q is derivable in i steps then
for each permutation σ, P ◦ σ	τ	Q ◦ σ.
Inductive Step:  Let P	τ	Q be derivable in i +1 steps. We can distinguish three

cases:
P = P '|R, P '	τ
Q' and Q = Q'|R;

P ≡ P ', P
'	τ−−→'
−−→ Q
and Q'
≡ Q.

P = ν a.P ' (σ(a)= a), P ' −−τ→ Q' and Q = ν a.Q';
In these cases cases, by using induction hypothesis, for each permutation σ, P ' ◦
σ	τ	'
−−→ Q ◦ σ. Thus the thesis follows easily by considering that for each R and S:
(S|R) ◦ σ = (S ◦ σ)|(R ◦ σ);
ν a.S ◦ σ = ν a.S ◦ σ (σ(a)= a); and
if R ≡ S then for each σ, R ◦ σ ≡ S ◦ σ.
□
In Figure 1 you can find a portion of the MLTS describing the behaviour of Proxy1 (see Example 3.1), where dashed arrows denotes resource transitions. Please notice only a subset of all the possible transitions are reported in the figure. Indeed, v could be any of the admissible values moreover resources can be added at any state.
Let us now consider the following lemma that permits establishing a correspon- dence between LTS semantics of [1] and the MLTS semantics presented in this paper.

Lemma 3.4 The following assertion holds:

P	τ	P ' ⇔ P	τ
P ';

P  ab  P '
a(b)	'
gab
⇔ P	)..
''
P ';
b


gab
''	'

P '−→ P
Proof.
⇔ ∃P
‹→ P
......).. P ;

P '−τ→ P ' if and only if:
either P ≡ ν a.(τ.Q1|Q2) and P ' = ν a.Q1|Q2;
or P ≡ ν ˜a.(ab|a(c).Q1|Q2) and P ' ≡ ν ˜a.(Q1[c/b]|Q2).
But the above holds if and only if P	τ	P '.

P '−a→b P '
if and only if P ≡ ab|P '. Moreover P ≡ abP '
gab
if and only if P	)..
P '.

P a(b) P ' if and only if P ≡ ν b.(ab|P ') and b /= a. However, this holds if and

'−→


gab

only if P ‹→b ab|P ' and ab|P '	)..
P '.
□


MLTS Bisimulation and Aπ
A methodology for proving properties of process calculi is the one based on be- havioural equivalences that requires providing a concrete and an abstract specifica- tion of the behaviour of a given system and then establishing that they are "indistin- guishable" under appropriate assumptions. Equivalences turn out to be important also because they would permit determining when parts of a system can be replaced without changing the behaviour of the whole specification. If we consider the proxy specified in Example 3.1, we could imagine that the τ action, which is performed after a message is retrieved over channel a, models an internal behaviour and the system could be refined with an alternative implementation:

Proxy3 =!ν c.a(x).cx|c(y).by
Bisimulation has been one of the most successful techniques to establish identifi- cations like the above. We shall now introduce a behavioural equivalence for MLTS that generalizes the bisimulation requirement to the three transition relations of the model. We shall then prove that the induced equivalence coincides with the classical one determined by relation proposed in [1]. The proposed behavioural equivalence is defined over the states of a MLTS. We first define three relations that characterise the bisimulations over the three relations associated to each MLTSs.
Definition 4.1 Let M be a MLTS.
A relation R ⊆ M£ × M£ is a resource preserving bisimulation if and only if
R is symmetric and for each (s1, s2) ∈ R and r ∈ MY:

⊕r
s1	)..
s' then there exists s'
⊕r
such that s2	)..
s' and (s' , s' ) ∈ R;

gr
s1	)..
s' then there exists s'
gr
such that s2	)..
s' and (s' , s' ) ∈ R;

We let ∼Y denoting the largest resource preserving bisimulation.
A relation R ⊆ M£ × M£ is a revelation bisimulation if and only if R is symmetric and for each (s1, s2) ∈ R and n ∈ MN :
s1 ‹→n s' then there exists s' such that s2 ‹→n s' and (s' , s' ) ∈ R;
We let ∼N denoting the largest revelation bisimulation.
A relation R ⊆ M£ × M£ is a A −parameterised bisimulation whenever A ⊆ ML × ML, if and only if R is symmetric and for each (s1, s2) ∈ R and λ1 ∈ ML:

s	λ1	'
'	λ2	'

1 −−−→ s1 then there exist λ2 and s2 such that s2 −−−→ s2, (λ1, λ2) ∈ A and
(s' , s' ) ∈ R;
We let ∼L denoting the largest A −parameterised bisimulation.
Building on the relations above, we can define the wanted bisimulation for MLTS.
Definition 4.2 Let M be a MLTS, A ⊆ ML × ML, we let ∼A =∼Y ∩ ∼N ∩ ∼A
We are now ready to study the relationships between the behavioural equivalence between Aπ processes of [1] and our MLTS equivalence. First of all we have to notice that:
Lemma 4.3
MAπ is image-finite with respect to AAπ and AAπ;
AAπ = {(τ, τ )} and AAπ are transition respectful in MAπ.
Proof. Image-finiteness of MAπ with respect to AAπ and AAπ follows easily from the following:

⊕ab

for each P and ab, {P '|P	)..
gab

for each P and ab, {P '|P ......).. set;
P '} = {P |ab};
P '} is {Q} if P ≡ Q  ab otherwise is the empty

for each P and a, {P '|P ‹→a P '} = {P '|∃P ''.P ≡ ν a.P ' and P ' ≡ P ''|ab} which is finite since in P only a finite number of bound names can occur;
λ	τ
for each P and α, {P '|∃λ.λ ∈ A[[α]] and P −−→ P '} is equal to {P '|P −−→ P '}
which is finite because in P only a finite number of synchronisations can occur.
Moreover, AAπ = {(τ, τ )} . Hence, for each P and λ1, λ1 ∈ AAπ[[√]] while for each λ2 ∈ LabAπ, (λ1, λ2) ∈ AAπ. Hence, AAπ and AAπ are transition respectful in MAπ.	□
Moreover, we will show that the equivalence ∼{(τ,τ)} defined over Aπ processes coincides with the asynchronous bisimulation (∼a) defined in [1].
Definition 4.4 A symmetric relation R on Aπ terms isa strong oτ −bisimulation if
P RQ, P	α P ', α is not an input action, and bn(α) ∩ f n(Q)= ∅ implies Q α  Q'
'	'−'→	'−→
and P RQ . Let ∼oτ be the largest oτ −bisimulation.

Definition 4.5 A relation R is an asynchronous bisimulation if it is an oτ −bisimulation
and whenever P RQ and P  ab  P ' the following holds:

either Q ab
Q' and P 'RQ'

or Q  τ
Q' and P 'R(Q'|ab).

Definition 4.6 ∼a is the largest asynchronous bisimulation.
Definition 4.7 Let ∼ 1 be the largest relation R such that R is an oτ −bisimulation and P RQ implies (P |ab)R(Q|ab), for all ab.
Theorem 4.8 ∼a=∼1
Proof. See [1].	□

Let P =!τ.0 and Q =!τ.0|a(b).ab, we have that P ∼a Q. Please notice that these processes can be distinguished by using the modal logics defined in [14], [7] and [4].
Theorem 4.9 ∼{(τ,τ)}⊆∼a
Proof. We first prove that ∼{(τ,τ)} is an oτ −bisimulation. We have to show that if
P RQ, P	α P ', α is not an input action, and bn(α) ∩ f n(Q)= ∅ implies Q α  Q'
'	'−'→	'−→
and P RQ .
Thanks to Lemma 3.4, it easy to prove that if P ∼{(τ,τ)} Q then:

P	τ	'
'	τ	'
'	{(τ,τ)}	'

−−→ P
gab
⇒ ∃Q .Q −−→ Q
gab
and P ∼	Q ;

P	)..
P ' ⇒ ∃Q'.Q	)..
gab
Q' and P ' ∼{(τ,τ)} Q';;
gab

P ‹  b P ''	)..
Q'.
P ' ⇒ ∃Q', Q''.Q ‹→b Q''	)..
Q' and P '' ∼{(τ,τ)} Q'', P ' ∼{(τ,τ)}

We have now to prove that for each ab if P ∼{(τ,τ)} Q then P |ab ∼{(τ,τ)} Q|ab.

⊕ab
For each ab, P	)..
⊕ab
P |ab and Q	)..
Q|ab. Since P ∼{(τ,τ)} Q, it follows that

P |ab ∼{(τ,τ)} Q|ab and that ∼{(τ,τ)} is an asynchronous bisimulation.
Since ∼a is the largest asynchronous bisimulation, it implies that ∼{(τ,τ)}⊆∼a.□
Theorem 4.10 ∼a⊆∼{(τ,τ)}
Proof. We prove that ∼a is a resource preserving bisimulation, a revelation bisimu- lation and a {(τ, τ )}−parameterised bisimulation. We have to show that if P ∼a Q then:


⊕ab
P	)..

gab
P ......)..


⊕ab
P ' then there exists Q' such that Q	)..

gab
P ' then there exists Q' such that Q ......)..
Q' and P ' ∼a Q'.
Q' and P ' ∼a Q';

P ‹→a P ' then there exists Q' such that Q ‹→a Q' and P ' ∼a Q';
P −−τ→ P ' then there exists Q' such that Q −−τ→ Q' and P ' ∼a Q'. The above easily follow directly from definition of ∼a by noting that:
⊕ab

if P	)..
P ' then P ' ≡ P |ab;

gab
'

ab	'


if P	).. P
then P '−→ P ;

if P ‹→b P ' then P ' = ab|P '' (a /= b) and P a(b) P '';
if P −−τ→ P ' then P '−τ→ P '.
Conclusions and future work
In this paper we have proposed a variant of LTS that we called Multiple Labelled Transition Systems (MLTS) as a candidate general operational model for distributed calculi with names and mobility. To show usefulness of our proposal we used MLTS to describe the operational semantics of a well known formalism that is the gen- erally recognized as a minimal common denominator of calculi for mobility: the asynchronous π-calculus (Aπ) [3,12].
We have also defined a behavioural equivalence between MLTS and proved that, in the case of Aπ, this coincides with the asynchronous bisimulation defined in [1]. In a companion paper [9], that can be considered the extended version of the current one, we show versatility of MLTS by using them also for modelling the operational semantics of μKlaima calculus for mobile distributed agents with ex- plicit localities [2]. There we also introduce, MoMo, a logic inspired by Hennessy- Milner Logic that consists of a small set of operators to be used to describe proper- ties/behaviours of mobile and distributed systems. Together with the usual logical connectives and the operators for minimal and maximal fixed points, the logics is equipped with operators for describing dynamic behaviours (temporal proper- ties), for modelling resource management (state properties), for keeping into account names handling (nominal properties), and for controlling mobile processes (mobility properties). Temporal formulae, that are interpreted by considering the computation relation describe the actions a system can perform to interact with the environment. These are parameterized with respect to a set A of label predicates. Properties of names, like freshness or revelation, are specified using nominal formulae, whose
semantic is given by using relation the revelation and the resource relations.
Our final target is a general framework based on MLTS and MoMo that will sufficient to provide semantics to (and to reason on the behaviour) to terms of process calculi for network aware programming.
Acknowledgement
We would like to thank Diego Latella and Mieke Massink for helpful suggestions and other members of the SENSORIA projects for interesting discussions.

References
Amadio, R. M., I. Castellani and D. Sangiorgi, On bisimulations for the asynchronous π-calculus, Theoretical Computer Science 195 (1998), pp. 291–324, an extended abstract appeared in Proceedings

of CONCUR ’96, LNCS 1119: 147–162.
URL http://www.inria.fr/RRRT/RR-2913.html
Bettini, L., V. Bono, , R. De Nicola, G. Ferrari, D. Gorla, M. Loreti, E. Moggi, R. Pugliese, E. Tuosto and
B. Venneri, The klaim project: Theory and practice, in: Global Computing, Lecture Notes in Computer Science 2874 (2003), pp. 88–150.
Boudol, G., Asynchrony and the π-calculus (note), Rapport de Recherche 1702, INRIA Sophia-Antipolis (1992).
URL http://www.inria.fr/RRRT/RR-1702.html
Caires, L., Behavioral and spatial observations in a logic for the pi-calculus., in: I. Walukiewicz, editor,
FoSSaCS, Lecture Notes in Computer Science 2987 (2004), pp. 72–89.
Cardelli, L. and A. D. Gordon, Mobile ambients., Theor. Comput. Sci. 240 (2000), pp. 177–213.
Castagna, G. and J. Vitek, Seal: A framework for secure mobile computations, in: H. Bal, B. Belkhouche and L. Cardelli, editors, Internet Programming Languages, number 1686 in Lecture Notes in Computer Science, Springer, 1999 pp. 47–77.
Dam, M., Model checking mobile processes, Journal of Information and Computation 129 (1996),
pp. 35–51.
De Nicola, R., G. Ferrari and R. Pugliese, Klaim: a Kernel Language for Agents Interaction and Mobility, IEEE Transactions on Software Engineering 24 (1998), pp. 315–330.
De Nicola, R. and M. Loreti, Multi labelled transition systems for nominal calculi and their logics, Matematical Structure in Computer Science (2007), to appear.
Fournet, C., G. Gonthier, J. J. Levy, L. Maranget and D. Remy, A Calculus of Mobile Agents, in:
U. Montanari and V. Sassone, editors, Proc. of 7th Int. Conf. on Concurrency Theory (CONCUR’96), Lecture Notes in Computer Science 1119 (1996), pp. 406–421.
Hennessy, M. and J. Riely, Resource access control in systems of mobile agents, Information and Computation 173 (2002), pp. 82–120.
Honda, K. and M. Tokoro, An object calculus for asynchronous communication, in: P. America, editor,
European Conference on Object-Oriented Programming (ECOOP’91), LNCS 512 (1991), pp. 133–147.
Milner, R., “Communication and Concurrency,” International Series in Computer Science, Prentice Hall, 1989, sU Fisher Research 511/24.
Milner, R., J. Parrow and D. Walker, Modal logics for mobile processes, Theoretical Computer Science
114 (1993), pp. 149–171.
Milner, R., J. Parrow and J. Walker, A Calculus of Mobile Processes, I and II, Information and Computation 100 (1992), pp. 1–40, 41–77.
Wojciechowski, P. T. and P. Sewell, Nomadic pict: Language and infrastructure design for mobile agents., in: ASA/MA (1999), pp. 2–12.
