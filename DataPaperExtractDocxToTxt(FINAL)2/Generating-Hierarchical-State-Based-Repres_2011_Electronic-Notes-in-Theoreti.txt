Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 280 (2011) 35â€“46
www.elsevier.com/locate/entcs


Generating Hierarchical State Based Representation From Event-B Models
Dipak L. Chaudhari1,2 Om P. Damani3
Department of Computer Science and Engineering, Indian Institute of Technology, Bombay,
Mumbai, India

Abstract
Many properties of a system may not be obvious just by a quick inspection of the corresponding Event- B model. Users typically rely on animation, scenario analysis, and inspection of state transition graphs for discovering certain behavior of the system. We propose a methodology for generating a hierarchical representation of the system for visualising Event-B models. Our representation is succinct and it provides multiple views to aid in better comprehension of the Event-B models.
Keywords: Event-B, Model visualization, Hierarchical state based representation


Introduction
In Event-B, desired global properties of the system are specified in the form of invariants and the invariant preservation proofs ensure that these properties are maintained by the system after execution of any enabled event[1]. However, after execution of an enabled event, it is not obvious which events will be enabled or disabled next. Users typically rely on animation, scenario analysis, and inspection of state transition graphs to grasp the behavioral aspects of the system. The ProB animator[9], with the aid of a model checker, can generate graphical visualization of the state space of a B machine. However, because of the flat (non-hierarchical) nature of the ProB state space representation, it becomes difficult to reduce the complexity of the state space graphs even after employing the state space reduction techniques[10]. In general, hierarchical state transition diagrams are found to be useful in reducing the complexity of the state transition diagrams [6].

1 This work was supported in part by the Ministry of Human Resources Development, Government of India and by the Tata Research Development and Design Center (TRDDC).
2 Email: dipakc@cse.iitb.ac.in
3 Email: damani@cse.iitb.ac.in

1571-0661 Â© 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.11.016

We propose a hierarchical representation, similar to the statechart diagrams, for visualising Event-B models. We present a top-down methodology for constructing an abstract representation of desired granularity directly from the given Event-B model.

Hierarchical Abstract State Transition Machine
To represent a discrete event system, we use a Hierarchical Abstract State Tran- sition Machine (HASTM) representation which uses the concepts of hierarchical states and guarded transitions similar to those in statechart diagrams [6]. In HASTM, state-space is arranged in the form of a tree (which we call a state- space partition tree) and the root node of the tree represents all the valid states of the system, i.e., the states defined by the conjunction of all the invariants.
The root node is partitioned into substates based on some predicate. The substates are in turn partitioned further using appropriate predicates. Figure 1 shows the state-space par- tition tree generated by our method (Algorithm 1) for the Lift Event-B model 4 shown in Figure 2, given the predicates (cf = topFloor), (cf = botF loor), (doorOpen = T ),

and (dirUp = T ).	The algorithm starts constructing the tree from the
Fig. 1: State-space partition tree for the Lift exam- ple. The hierarchy relation is shown by dotted arrow.

root node and at each node selects a partitioning predicate that minimizes the number of transitions in the generated HASTM. This reduces the complexity of the generated HASTM. While partitioning the tree, the algorithm also computes the pre-states, transition guards, and the post states (defined in Section 2.1 ) for the transitions. The final HASTM for the Lift model is shown in Figure 4.

Structure and Semantics of HASTM
If v denotes the variables of a system then the set Î¦ = {v|True} is the entire state space of the system. We use the term abstract state to represent any subset of Î¦ and the term concrete state or just state to represent a particular element of Î¦. 5
Abstract states are usually specified using predicates. If Q(v) is a predicate with free variables in v then we represent by Q the set of all concrete states satisfying Q(v), i.e., Q = {v|Q(v)}. If a system is in a concrete state q, and q âˆˆ Q where Q is an abstract state then the system is said to be in the abstract state Q.
HASTM is a tuple H = âŸ¨v, S, >, Î£,T, t0âŸ© , where

4 The Lift Event-B model is adapted from the B model that comes with the ProB tool [9].
5 The terms abstract state and concrete state should not be confused with the terms abstract model and
concrete model which are used in context of refinements.



Fig. 2. Event-B Model for the Lift Controller. upRequested stands for ğ–¤c.(c âˆˆ Z âˆ§ c > cf âˆ§ c âˆˆ callbtns), downRequested stands for ğ–¤c.(c âˆˆ Z âˆ§ c < cf âˆ§ c âˆˆ callbtns),T stands for True, and F stands for False.

v denotes the variables of the system.
S is a finite set of abstract states. S âŠ† P(Î¦) where Î¦ is the set of all the states of the system.
> is a hierarchy relation on S that satisfies the following conditions
For any two abstract states X and Y in S, X > Y â‡’ X âŠ‡ Y .
There exists a unique abstract state r âˆˆ S , called the root state of H and denoted as root(H), such that r âˆˆ/ ran(>), where ran(>) is the range of the relation >.
For every X âˆˆ S \ {root(H)}, there exists a unique abstract state Y âˆˆ S such that Y > X. Y is called the immediate superstate of X, whereas X is called an immediate substate of Y . An abstract state without any immediate substate is called a basic abstract state.
If X is a non-basic abstract state in S and W is a set of all immediate substates of X then W partitions the set X. i.e., all the immediate substates of X are collectively exhaustive ( (W)= X ) and any two distinct immediate substates of X are mutually exclusive. (âˆ€Aâˆ€B).A âˆˆW âˆ§ B âˆˆW â‡’ A = B ğ–µ A âˆ© B = âˆ…)
Î£ denotes set of event signatures. An event signature consists of an event name and event parameters.
T is a 5-ary transition relation. Each element of t of T represents a transition in H. We refer the elements of 5-tuple t as t.Evt, t.Pre, t.K, t.Act and t.Post, where
t.Evt âˆˆ Î£ is an event signature, t.Pre âˆˆS is the pre-state (originating abstract state) of the transition, t.K(v, u) is a transition guard predicate (where u are the event parameters of t.Evt), t.Post âˆˆ S is the post-state (target abstract

state) of the transition, and t.Act is the transition action for the event t.Evt. Transition action is a simultaneous assignment to the variables of the system.
Â· For any two transitions t1 and t2, if t1.Evt = t2.Evt then
t1.Pre(v) âˆ§ t1.K(v, u) â‡’ Â¬ (t2.Pre(v) âˆ§ t2.K(v, u))	(1)
where u are the parameters of event t1.Evt ( and t2.Evt). Motivation for this condition is given at the end of this subsection.
t0 is a 5-tuple âŸ¨t0.Evt, t0.Pre, t0.K, t0.Act, t0.PostâŸ© representing the init transi- tion, where t0.Evt is the init event, t0.Pre is a pseudo-state that represents the pre-state of t0, the transition guard t0.K is True, Act0 is the initialization action, and S0 âˆˆS is the initial abstract state.

Transition t is represented as {t.Pre
t.Evt(u)[t.K(v,u)]/t.Act
t.Post} where u are the

} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’{ 
parameters of Evt. If the system is in the abstract state t.Pre and also satisfies the transition guard tÂ·K(v, u), then the transition t is said to be enabled. A transition can take place only when it is enabled. If the transition t is enabled and it occurs then after the execution of t.Act , the system moves to the abstract state t.Post. This behavioral semantics of a transition in HASTM is captured in the following proof obligation.
t.Pre(v) âˆ§ t.K(v, u) âˆ§ BA(v, u, v') â–¶ t.Post(v')
where BA(v, u, v') is the before-after predicate of the action t.Act. The init tran- sition initializes the system to the initial abstract state S0 and is represented as
init[True]/Act0	'	'
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {S0}. Proof obligation for the init transition is A(v ) â–¶ S0(v ) where
A is the after predicate of the action Act0.
Condition in Equation 1 in the HASTM definition ensures that two transitions corresponding to same event are not enabled for a given state and event parameters.

Representing Event-B Machine as a HASTM
Let M be an Event-B machine, v be its variables, and I(v) be the invariants. Let Em be the event denoted by â€œany u where Gm(v, u) then v : | BAm(v, u, v') endâ€ where Gm(v, u) is the guard and BAm(v, u, v') is the before-after predicate corresponding to the action Actm of event Em. Let A(v') be the after predicate for the init event.(We adapt the notation from [1])
HASTM H : âŸ¨v, S, >, Î£,T, t0âŸ© is a representation of the Event-B machine M if
variables v and event signatures Î£ in H are the same as the variables and event signatures in M .
root(H)â‡” I(v).
For any transition t in H, the action t.Act is the same as the action of event t.Evt in M . The action of the init transition in H is the same as the action of the init event in M .
Let t1, t2, .. ., tk be the transitions in H corresponding to an event Em in M

(i.e. ti.Evt = Em for i âˆˆ 1..k) then
I(v) âˆ§ Gm(v, u) â‡”
iâˆˆ1..k


(ti.Pre(v) âˆ§ ti.K(v, u))	(2)

Condition in Equation 2 along with the condition in Equation 1 imply that event Gm is enabled in M if and only if there is a single enabled transition t in H with t.Evt = Gm.
The HASTM representation is for a specific Event-B model in the Event-B refinement chain. Each Event-B model in the refinement chain will have a separate HASTM representation. In this work, we do not establish a link be- tween HASTM representations corresponding to abstract and concrete Event-B models.

Generating HASTM from Event-B Machine
We first explain the process for generating a HASTM interactively and then present an algorithm for automatically generating a HASTM from a given Event-B ma- chine.
Let t be a transition in H and X be a substate of t.Pre. Transition t is said to be exclusively enabled in X if t.Pre(v) âˆ§ t.K(v, u) â‡’ X(v) where u are the parameters of t.Evt.

Consider a transition t : {t.Pre
t.Evt(u)[t.K(v,u)]/t.Act
t.Post} in H.  Parti-

tioning t.Pre with predicate p(v) generates two immediate substates of t.Pre viz. X1 : t.Pre(v) âˆ§ p(v) and X2 : t.Pre(v) âˆ§ Â¬p(v). If t is exclusively enabled in either X1 or X2 then t is said to be amenable to partitioning of t.Pre with respect to p(v).

Interactive Generation of HASTM
We first define a Primitive HASTM representation of an Event-B machine which is a very simple HASTM with a single abstract state I. Consider the Event-B machine M described in Section 2.2. Let r be the number of events in M .
Primitive HASTM of M is a HASTM with the same variables and event signatures as those of M , a single abstract state I, and the following transitions.
init[True]/Act0	Ei[Gi]/Acti
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I} and {I} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I} for i from 1 to r.
The proof obligations for all the transitions in the primitive HASTM are the same as those of M . It is easy to verify that Primitive HASTM of M satisfies the conditions mentioned in section 2.2, and hence represents M .
To generate a HASTM of desired granularity, we start with a primitive HASTM of the given Event-B machine and then successively partition the basic abstract states and modify the transitions according to the following procedure.
Process for partitioning a basic abstract state X.
Partitioning: Select a partitioning predicate p(v) and partition the abstract state X into two substates X1 : X(v) âˆ§ p(v) and X2 : X(v) âˆ§ Â¬p(v).

Modify the pre-state: For any transition t:{X


E(u)[K(v,u)]/Act

.} originating from X, there are two

possibilities.
} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’{ 

t is exclusively enabled in X1: In this case, we strengthen the pre-state of t to X1. If the transition guard K(v, u) has p(v) as a conjunct, remove it from K(v, u) since it is redundant now as X1 already has the conjunct.

The transition now becomes :
E(u)[K'(v,u)]/Act
where	'(
) is

t {X1} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {.}
K  v, u

the predicate obtained after removing the conjunct p(v) from K(v, u).
t is exclusively enabled in X2: This case is symmetric to case a.
t is exclusively enabled in neither X1 nor in X2: We have two choices in this case.
In place of the transition {X} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {.}, create two new transi-

tions : {X1
E(u)[K(v,u)]/Act
.} and {X2
E(u)[K(v,u)]/Act
.}

} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’{	} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’{ 
E(u)[K(v,u)]/Act
Keep the transition as it is {X} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {.}. This is the default option in the automatic HASTM generation algorithm (to be discussed in Section 3.2). We choose this option in Algorithm 1 to prevent the number of transitions from increasing.
Strengthen the post-state: Strengthen the post-state of all the affected transitions (transitions whose pre-state has changed in step c and the transi- tions whose post-state has been partitioned in step i).

Consider transition t : {.
E(u)[K(v,u)]/Act
Y } whose post-state is Y . Let Y '

} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ { 
be the immediate substate of Y that already exists in the state-space partition

tree. If the proof obligation for {.
E(u)[K(v,u)]/Act
Y '} is discharged then

} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ { 
strengthen the post-state of the transition to Y '. Now with Y ' as the new post state, we repeat the above step till we fail to discharge the proof obli- gation or we reach a basic abstract state. The algorithm is given in function strengthenPostState in Algorithm 1.
Example:
Consider the Lift Event-B model given in Figure 2.	We start with a primitive

HASTM which has a single abstract state I , transitions: {I
Ei[Gi]/Acti
I} for i


from 1 to 7, and an init transition init[True]/Act0
} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ { 
I}. Invariants I and the events

are as shown in Figure 2.
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {

We now show how the transitions corresponding to events MoveUp and
CloseDoor are modified after the partitioning of the root abstract state I.
We use the predicate p=(dirU p = T ) for partitioning the abstract state I into two immediate substates (I âˆ§ p) and (I âˆ§ Â¬p)
Consider the transition in primitive HASTM corresponding to the event MoveU p.
(dirUp = T ) âˆ§ (cf âˆˆ/ callbtn) âˆ§ upRequestedâˆ§	:= +1 (cf < topF loor) âˆ§ (doorOpen = F )
{I} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I}
Since the primitive HASTM has a single abstract state I, pre-state as well as

post-state of the transition is I. Pre-state I and the transition guard imply (dirUp = T ) and hence I âˆ§ (dirUp = T ). This transition is exclusively enabled in I âˆ§ (dirUp = T ) and hence amenable to partitioning of the abstract state I with predicate (dirUp = T ). As per step a, we strengthen the pre-state of the transition to I âˆ§ (dirUp = T ) and weaken the transition guard by removing the conjunct (dirUp = T ). The modified transition is

(cf âˆˆ/ callbtn) âˆ§ upRequestedâˆ§
(cf < topF loor) âˆ§ (doorOpen = F )
 /cf :=cf +1

{I âˆ§ (dirUp = T )} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I}
Now we try to strengthen the post-state of the transition to one of the sub-states of the current post-state I. The proposed transition is

(cf âˆˆ/ callbtn) âˆ§ upRequestedâˆ§
(cf < topF loor) âˆ§ (doorOpen = F )

 /cf :=cf +1

{I âˆ§ (dirUp = T )} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I âˆ§ (dirUp = T )}
Proof obligation for this transition is discharged successfully.	Hence, we strengthen the post-state of the transition to I âˆ§ (dirUp = T ).
We now consider the transition in primitive HASTM corresponding to the Close- Door event.
CloseDoor [doorOpen = T ] /doorOpen := F ; callbtns := callbtns\{cf }
{I} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I}
For this transition, pre-state I along with the transition guard (doorOpen = T ) neither imply (dirUp = T ) nor imply (dirUp = F ). Hence this transition is not amenable to partitioning of I with predicate (doorOpen = T ). According to step c, we now have two choices: i) Do not modify the transition ii) Split the transition into two new transitions. Here we opt for the later choice and create two new transitions as follows.

CloseDoor [doorOpen = T ] /
doorOpen := F ;
callbtns := callbtns\{cf }

{I âˆ§ dirUp = T } âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I}
doorOpen := F ;

CloseDoor [doorOpen = T ] /
callbtns := callbtns\{cf }

{I âˆ§ dirUp = F } âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I}
The post-states of both these transitions can be strengthened as follows after verifying the corresponding proof obligations.
doorOpen := F ;

CloseDoor [doorOpen = T ] /
callbtns := callbtns\{cf }

{I âˆ§ dirUp = T } âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I âˆ§ dirUp = T }
doorOpen := F ;

CloseDoor [doorOpen = T ] /
callbtns := callbtns\{cf }

{I âˆ§ dirUp = F } âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {I âˆ§ dirUp = F }
Following the above procedure for all the transitions, we get a HASTM as shown in Figure 3. We can further partition a basic abstract state with another predicate and continue the process.

Automatic Generation of HASTM
Algorithm 1 automatically generates a HASTM from a given Event-B machine and a set of partitioning predicates. Algorithm 1 is similar to the interactive generation algorithm, except that basic abstract states are recursively partitioned and the



Fig. 3. HASTM representation of the Lift Event-B machine generated interactively by using partitioning predicate (dirUp = T ).



Global Variables:
Input Variables:
M : Event-B machine with r events
Output: HASTM H = âŸ¨v, S, >, Î£,T, t0âŸ©

 P : set of partitioning predicates	


function Main() BuildPrimitiveHASTM() PartitionAbstractState(I) for transition t in T
StrengthenPostState(t)
StrengthenPostState(t0)
function BuildPrimitiveHASTM()
v := variables of M

function SelectPredicate(X: abstract state)
score := ğœ™ //score âˆˆ P â†’ N
for p in P
if X(v) already has conjuct p(v) or Â¬p(v) continue
:=	t.Pre = X and t is amenable to partitioning of X with p

Î£ := Event signatures of M
I := Conjunction of invariants of M
S := {I}
score(p) := |eT |
if score = ğœ™
return Null

>: = ğœ™
T := {âŸ¨Evt : Em,Pre : I, K : Gm,
Act : Actm, Post : IâŸ©|m âˆˆ 1..r}
t0 := âŸ¨Evt : init, Pre : Null,
bestP red :âˆˆ arg maxp score(p) if score(bestP red)=0 
bestP red := Null
return bestP red
function StrengthenPostState(t: transition)

function
K : T rue, Act : Act0, Post : IâŸ©
PartitionAbstractState(X:
Y = {Y âˆˆ S|t.Post > Y }
if Y = ğœ™  //t.Post is a basic abstract state

abstract state)
p : =SelectPredicate(X) if p = Null
return
return
Y in Y
proof obligation for
t.Evt[t.K]/t.Act

X1:= AddSubState(X, p) X2:= AddSubState(X, Â¬p) PartitionAbstractState(X1) PartitionAbstractState(X2)
function AddSubState(X: abstract state,
q: predicate)
X'(v) := X(v) âˆ§ q(v) S := S âˆª {X'}
>:=> âˆª{X 'â†’ X'}
for t in T such that t.Pre = X
if (X(v) âˆ§ t.K(v, u) â‡’ q(v))
t.Pre := X'
t.K = K' where K' is the predicate obtained after removing conjuct q(v) from t.K if it exists.
if	{t.Pre} âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ {Y }
is discharged
t.Post := Y strengthenPostState(t) break
return

return X'

Algorithm 1. Algorithm for generating HASTM representation from an Event-B machine given a set of partitioning predicates.

partitioning predicate is automatically selected from the given set of predicates.
We start with a primitive HASTM of M and then recursively partition the abstract state I. At each basic abstract state in the state-space partition tree, further partitioning predicate is selected to maximize the number of events amenable to partitioning with the selected predicate. This allows us the strengthen pre-state of these events without any increase in the number of transitions in the generated HASTM.
We define a score function that assigns each partitioning predicate p with the number of transitions that are amenable to partitioning X with p (Refer function SelectPredicate from Algorithm 1). Figure 4 shows a HASTM representation of the Lift Event-B machine generated by Algorithm 1 given the partitioning predicates (cf = topFloor), (cf = botF loor), (doorOpen = T ), and (dirUp = T ). The score function for the abstract state I is score = {(doorOpen = T ) 'â†’ 6, (dirUp = T ) 'â†’ 4, (cf = topFloor) 'â†’ 2, (cf = botF loor) 'â†’ 2}. We select the predicate (doorOpen = T ) that has maximum score for partitioning the abstract state I. We repeat this process for the sub-states till all the predicates are utilized while creating that abstract state or score of all the given predicates is zero.
For the selected partitioning predicate if there are events not amenable to parti- tioning then we decide not to strengthen the pre-state. This choice is not required as per the definition of HASTM. However, we choose this option in the automatic generation algorithm to prevent the number of transitions from increasing. The procedure for partitioning and pre-state strengthening is implemented in functions PartitionAbstractState and AddSubState in Algorithm 1. The number of transitions in the HASTM generated by Algorithm 1 always equals the number of events in the Event-B model.
After the complete state-partition tree is ready and pre-state of all the transitions is strengthened to appropriate abstract states, we strengthen the post-states of all the transitions. Refer function StrengthenPostState in Algorithm 1 for details.
After the automatic generation of a HASTM, user can further modify the rep- resentation by employing the interactive algorithm and partition the basic states with different predicates.
Multiple Views
In the HASTM shown in Figure 4, the automatic HASTM generation algorithm has not partitioned the node (doorOpen = T ) since score of all the predicates is zero. Partitioning with any of the given predicates would not have allowed us to strengthen the pre-state of the CloseDoor transition without splitting it.
Although the automatic generation algorithm avoids generating multiple transi- tions for a single event, user can force selection of different predicate resulting in a different state-space partition tree. For example, at node (dirUp = T ) in Figure 4, if we choose the predicate (cf = botF loor) instead of (cf = topFloor), we get a different representation as shown in Figure 5. This partitioning has increased the complexity of the HASTM representation since two transitions are generated for the MoveUp event. However, this is sometimes desirable since multiple HASTM



Fig. 4. HASTM representation of the Lift Event-B machine generated by Algorithm 1 given the partitioning predicates (cf = topF loor), (cf = botF loor), (doorOpen = T ), and (dirUp = T ).















Fig. 5. An alternate HASTM representation of the Lift Event-B machine. At node (dirUp = T ), we interactively choose the partitioning predicate (cf = botF loor). Transition guards and actions are not shown in the figure and are the same as in Figure 4 for all the events.
representations highlight different aspects of the system.
Note from Figure 4 that after execution of OpenDoor event, all other events except CloseDoor and PushCallBtn are disabled. This property might not be clear from the Event-B machine. Another property that ReverseUp event is disabled when (cf = topFloor) is not clear from the Event-B model. Guard of the ReverseUp event together with the invariants imply (cf < topFloor). This fact is not clear even in the HASTM in Figure 4 since the abstract state (dirUp = F ) is not partitioned with the predicate (cf = topFloor). However, if we partition the state-space differently as in the HASTM shown in Figure 5, it becomes clear that ReverseUp is only enabled in abstract states with (cf < topFloor).
Related and Future Work
A lot of work has been done [8,11,12,13] on deriving formal B models from the speci- fications in visual representations(mostly UML). Our approach is the reverse of this. We start from an existing Event-B model and build multiple visual representations that focus on different behavioral aspects of the system.
In [5], a method for specifying structured models is presented and its use for sequential program development is demonstrated. This approach is especially useful

for modeling of problems that require sequential ordering of events. The algorithm presented in this work can be used to extract structure out of the Event-B models in which abstract program counters are used to achieve ordering of events. For such models, predicates involving the program counters are the natural choices for the partitioning predicates. Although, in this paper, we only consider binary partitioning of the state-space, the approach can easily be extended to multi-ary partitioning.
In [7], three techniques based on animation and proof are presented for con- structing state transition diagrams. The work proposes to associate the states of the diagram with abstract invariants in order to reduce the number of states to a finite one. The ProB tool [9] can generate state-space graph of a B machine by traversing the state-space of the machine. However, for most models, complete state-space is not explored. Also, for larger state-spaces these graphs become very complex. In [10], two algorithms for reducing the complexity of the state-space graphs are presented making it possible to visualise larger state spaces. However, the transitions in the state-space graphs are not labeled with predicates. In [2], flow graph is derived from an Event-B model which is very useful for uncovering implicit algorithmic structures. Flow graph does not employ hierarchical states and can get very complex as the number of events in the model increase. In HASTM, complexity of the representation can be maintained to a comprehensible level by se- lective partitioning of hierarchical abstract states. However, sometimes getting the right perspective might need human intervention in selecting the right partitioning predicates.
The work in [3,4] presents a method and a tool (GeneSyst) to build symbolic labeled transition systems from Event-B specifications. GeneSyst system requires the invariants associated with the states in the transition system to be specified by the user. GeneSyst system supports refinements of the models. HASTM has hierarchical states but more work is needed to establish a link between HASTM corresponding to the abstract and concrete Event-B models in the refinement chain. In this work, we partition the global state-space of the Event-B machine. We would like to explore the partitioning of the local state-space defined by the event parameters. Having developed the basic concept of a HASTM and an algorithm for automatic generation of a HASTM from an Event-B model, we now plan to implement this algorithm and try out this visualisation technique on various Event-
B models.

Conclusions
In this work, we present a methodology for visualising Event-B models by using Hierarchical State Transition Machines (HASTM). We specify the conditions that a HASTM should satify in order to represent an Event-B machine. We then present an algorithm for automatic generation of a HASTM representation from a given Event-B model and a set of partitioning predicates. With the help of examples, we demonstrate that multiple HASTM representations aid in grasping certain behav-

ioral aspects of the systems.

References
Jean-Raymond Abrial. Modeling in Event-B : system and software engineering. Cambridge University Press, Cambridge, New York, 2010.
Jens Bendisposto and Michael Leuschel. Automatic flow analysis for Event-B. In Dimitra Giannakopoulou and Fernando Orejas, editors, Fundamental Approaches to Software Engineering, volume 6603 of Lecture Notes in Computer Science, pages 50â€“64. Springer Berlin / Heidelberg, 2011. 10.1007/978-3-642-19811-3_5.
Didier Bert and Francis Cave. Construction of finite labelled transistion systems from B abstract systems. In Proceedings of the Second International Conference on Integrated Formal Methods, IFM â€™00, pages 235â€“254, London, UK, 2000. Springer-Verlag.
Didier Bert, Marie-Laure Potet, and Nicolas Stouls. GeneSyst: a tool to reason about behavioral aspects of B event specifications. application to security properties. CoRR, abs/1004.1472, 2010.
Stefan Hallerstede. Structured Event-B models and proofs. In Marc Frappier, Uwe GlÃ¤sser, Sarfraz Khurshid, RÃ©gine Laleau, and Steve Reeves, editors, Abstract State Machines, Alloy, B and Z, volume 5977 of Lecture Notes in Computer Science, pages 273â€“286. Springer Berlin / Heidelberg, 2010. 10.1007/978-3-642-11811-1_21.
David Harel. Statecharts: a visual formalism for complex systems. Science of Computer Programming, 8(3):231â€“274, 1987.
A. Idani and Y. Ledru. Dynamic graphical UML views from formal B specifications. Information and Software Technology, 48(3):154â€“169, 2006.
Hung Ledang and Jeanine SouquiÃ¨res. Contributions for modelling UML State-Charts in B. In Proceedings of the Third International Conference on Integrated Formal Methods, IFM â€™02, pages 109â€“127, London, UK, UK, 2002. Springer-Verlag.
Michael Leuschel and Michael Butler. ProB: a model checker for B. In FME 2003: FORMAL METHODS, LNCS 2805, pages 855â€“874. Springer-Verlag, 2003.
Michael Leuschel and Edd Turner. Visualising larger state spaces in pro B. In ZB 2005: Formal Specification and Development in Z and B, volume 3455 of Lecture Notes in Computer Science, pages 6â€“23. Springer Berlin / Heidelberg, 2005.
Emil Sekerinski and Rafik Zurob. Translating statecharts to B. In Proc. of the 3rd International Conference on Integrated Formal Methods (IFMâ€™02), volume 2335 of LNCS, pages 128â€“144. Springer- Verlag, 2002.
Colin Snook and Michael Butler. UML-B: formal modeling and design aided by UML. ACM Transactions on Software Engineering and Methodology, 15(1):92â€“122, 2006.
Colin Snook and Michael Butler. UML-B and Event-B: an integration of languages and tools. In Proceedings of the IASTED International Conference on Software Engineering, SE â€™08, pages 336â€“341, Anaheim, CA, USA, 2008. ACTA Press.
