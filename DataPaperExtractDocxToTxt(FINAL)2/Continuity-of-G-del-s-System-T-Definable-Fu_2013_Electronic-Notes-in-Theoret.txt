Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 119–141
www.elsevier.com/locate/entcs

Continuity of Gödel’s System T Definable Functionals via Effectful Forcing
Martín Escardó1
School of Computer Science University of Birmingham Birmingham, England

Abstract
It is well-known that the Gödel’s system T definable functions (N → N) → N are continuous, and that their restrictions from the Baire type (N → N) to the Cantor type (N → 2) are uniformly continuous. We offer a new, relatively short and self-contained proof. The main technical idea is a concrete notion of generic element that doesn’t rely on forcing, Kripke semantics or sheaves, which seems to be related to generic
effects in programming. The proof uses standard techniques from programming language semantics, such as dialogues, monads, and logical relations. We write this proof in intensional Martin-Löf type theory (MLTT) from scratch, in Agda notation. Because MLTT has a computational interpretation and Agda can be seen as a programming language, we can run our proof to compute moduli of (uniform) continuity of T-definable functions.
Keywords: Gödel’s system T, continuity, uniform continuity, Baire space, Cantor space, intensional Martin-Löf theory, Agda, dialogue, semantics, logical relation.


Introduction
This is a relatively short, and self-contained, proof of the well-known fact that any function f : (N → N) → N that is definable in Gödel’s system T is continuous, and that its restriction from the Baire type (N → N) to the Cantor type (N → 2) is uniformly continuous [15,2]. We believe the proof is new, although it is related to previous work discussed below. The main technical idea is a concrete notion of generic element that doesn’t rely on forcing, Kripke semantics or sheaves, which seems to be related to generic effects in programming [13]. Several well-known ideas from logic, computation, constructive mathematics and programming-language semantics naturally appear here, in a relatively simple, self-contained, and hopefully appealing, development.

1 Email: m.escardo@cs.bham.ac.uk

1571-0661 © 2013 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.010

The idea is to represent a function f : (N → N) → N by a well-founded dialogue tree, and extract continuity information about f from this tree. To calculate such a tree from a system T term t: (Ì ⇒ Ì) ⇒ Ì denoting f , we work with an auxiliary
interpretation of system T, which gives a function f˜ : (N˜ → N˜) → N˜, where N˜ is the
set of dialogue trees. Applying f˜ to a certain generic sequence N˜ → N˜, the desired
dialogue tree is obtained. We now explain this idea in more detail.
In the set-theoretical model of system T, the ground type Ì is interpreted as the set N of natural numbers, and if the types σ and τ are interpreted as sets X and Y , then the type σ ⇒ τ is interpreted as the set of all functions X → Y .
We consider an auxiliary model that replaces the interpretation of the ground type by the set N˜, but keeps the interpretation of ⇒ as the formation of the set of all functions. In this model, the zero constant is interpreted by a suitable element ˜0 of N˜, the successor constant is interpreted by a function N˜ → N˜, and each iteration combinator is interpreted by a function (X → X) → X → N˜ → X. An element of the set N˜ is a well-founded dialogue tree that describes the computation of a natural number relative to an unspecified oracle α : N → N. An internal node is labeled by a natural number representing a query to the oracle, and has countably many branches corresponding to the possible answers. Each leaf is labeled by a natural number and represents a possible outcome of the computation. These dialogues represent computations in the sense of Kleene [10].
If a particular oracle α : N → N is given, we get a natural number from any
d ∈ N˜ via a decodification function
decode : (N → N) → N˜ → N.
It turns out that there is a function generic : N˜ → N˜
that can be regarded as a generic sequence in the sense that, for any particular sequence α : N → N,

N˜	generic ) N˜


decode α
v
N
decode α
v
) N.
α


That is, the generic sequence codes any concrete sequence α, provided the sequence α itself is used as the concrete oracle for decodification. The idea is that the application of the function generic to a dialogue tree adds a new layer of choices at its leaves.
Next we show that for any given term t : (Ì ⇒ Ì) ⇒ Ì denoting a function f : (N → N) → N in the standard interpretation and f˜ : (N˜ → N˜) → N˜ in the dia- logue interpretation, we have that
f α = decode α (f˜ generic).
This is proved by establishing a logical relation between the set-theoretic and di- alogue models. Thus we can compute a dialogue tree of f by applying f˜ to the

generic sequence.
The set N˜ is constructed as B N for a suitable dialogue monad B. Then the
interpretation of the constant zero is η 0 where η is the unit of the monad, the interpretation of the successor constant is given by functoriality as B succ, and the interpretation of the primitive recursion constant is given by the Kleisli extension of its standard interpretation. The object part B X of the monad is inductively defined by the constructors
η : X → B X,
B : (N → B X) → N → B X,
where η constructs leaves and B constructs a tree B F n given countably many trees F and a label n. With X = N, we have B η : N → B N, and the generic sequence is the Kleisli extension of B η. Thus, the generic sequence seems to be a sort of generic eﬀect in the sense of [13]. Notice that our interpretation is a call-by-name version of Moggi’s semantics.
Using this, it follows that if a function f : (N → N) → N is the set-theoretical interpretation of some system T term t : (Ì ⇒ Ì) ⇒ Ì, then it is continuous and its restriction to N → 2 is uniformly continuous, where 2 is the set with elements 0 and
1. The reason is that a dialogue produces an answer after finitely many queries, because it is well-founded, and that a dialogue tree for a function (N → 2) → N is finite, because it is finitely branching. Recall that continuity means that, for any sequence of integers α : N → N, there is m : N, called a modulus of continuity of f at the point α, such that any sequence αj that agrees with α at the first m positions gives the same result, that is, f α = f αj. Uniform continuity means that there is m : N, called a modulus of uniform continuity of f on N → 2, such that any two binary sequences α and αj that agree at the first m positions give the same result. Our arguments are constructive, and we write the full proof from scratch in intensional Martin-Löf type theory (MLTT), in Agda notation [4], without the use of libraries. We don’t assume previous familiarity with Agda, but we do require rudimentary knowledge of MLTT. The Agda source file for this program/proof [7] is
written in Knuth’s literate style, which automatically generates the LATEX file that produces this article. Agda both checks proofs and can run them. Notice that MLTT or Agda cannot prove or disprove that all functions (N → N) → N are continuous, as
they are compatible with both classical and constructive mathematics, like Bishop mathematics [3]. The theorem here is that certain functions (N → N) → N are continuous: those that can be defined in system T.
Related work. The idea of computing continuity information by applying a func- tion to effectful arguments goes back to Longley [11], who passes exceptions to the function. A similar approach is described in an example given by Bauer and Pret- nar [1].
The idea of working with computation trees is of course very old, going back to Brouwer [2] in intuitionistic mathematics, and to Kleene [10] in computability theory in the form of dialogues, where the input is referred to as an oracle. Howard [9] derives computation trees for system T, by operational methods, by successively

reducing a term so that each time an oracle given by a free variable of type Ì ⇒ Ì is queried, countably many branches of the computation are created, corresponding to the possible answers given by the oracle. Hancock and Setzer use variations of dialogue trees to describe interactive computation in type theory [12] (see also [8]). Our work is directly inspired by Coquand and Jaber’s work on forcing in type theory [5,6]. Like Howard, they derive computation trees by operational methods. They extend dependent type theory with a constant for a generic element, and then decorate judgements with subscripts that keep track of approximation information about the generic element as the computations proceed (similarly to [15]). In this way they extract continuity information. They prove the termination and sound- ness of this modification of type theory using Tait’s computability method, which here is manifested as a logical relation between our two models. They also pro- vide a Haskell implementation for the system T case as an appendix, which uses a monad that is the composition of the list monad (for nondeterminism) and of the state monad. Their Haskell program implements a normalization procedure with bookkeeping information, tracked by the monad, that produces computation trees. Because they only account for uniform continuity in their Haskell implementation, such trees are finite. They describe their work as a computational interpretation of forcing and continuity as presented in Beeson [2]. The difference is that their approach is syntactical whereas ours is semantical, and the reader may sense an analogy with normalization by evaluation. Notice that these arguments only show that the definable functions are continuous. To get a constructive model in which all functions are continuous, they work with iterated forcing, which is related to our
recent work [16], but this is another story.
Organization. (2) Formal proof in Agda. (3) Informal, rigorous proof.

Proof in Martin-Löf type theory in Agda notation
Agda preliminaries
The purpose of this subsection is two-fold: (1) To develop a tiny Agda library for use in the following sections, and (2) to briefly explain Agda notation [4] for MLTT. We assume rudimentary knowledge of (intensional) Martin-Löf type theory and the BHK interpretation of the quantifiers as products Π and sums Σ. We don’t use any feature of Agda that goes beyond standard MLTT. If we were trying to be purist, we would use W-types rather than some of our inductive definitions using the Agda keyword data. Notice that the coloured text in the electronic version of this paper is the Agda code.
The universe of all types is denoted by Set, and types are called sets (this is a universe à la Russell). Products Π are denoted by ∀ in Agda. Consider the definition of the (interpretation of) the standard combinators:
K¸ : ∀{XY : Set} → X → Y → X
K¸ xy = x
Ş : ∀{XYZ : Set} → (X → Y → Z) → (X → Y) → X → Z
Ş fgx = fx (g x)

The curly braces around the set variables indicate that these are implicit parameters, to be inferred by Agda whenever K¸ and Ş are used. If Agda fails to uniquely infer the missing arguments, one has to write e.g. K¸ {X} {Y } x y rather than the abbreviated form K¸ x y. The following should be self-explanatory:
_◦_ : ∀{XYZ : Set} → (Y → Z) → (X → Y) → (X → Z) g ◦ f = ń x → g(f x)
data N : Set where zero : N
succ : N → N
rec : ∀{X : Set} → (X → X) → X → N → X
rec fx	zero	= x
rec fx (succ n) = f(rec fx n)
Agda has a termination checker that verifies that recursions are well-founded, and hence all functions are total. We also need types of binary digits, finite lists, and finite binary trees:
data N2 : Set where
0 1 : N2
data List (X : Set) : Set where []	: List X
_::_ : X → List X → List X
data Tree (X : Set) : Set where empty : Tree X
branch : X → (N2 → Tree X) → Tree X
Sums are not built-in and hence need to be defined:
data Σ {X : Set} (Y : X → Set) : Set where
_,_ : ∀(x : X)(y : Y x) → Σ {X} Y
The definition says that an element of Σ {X} Y is a pair (x,y) with x : X and y : Y x. Notice that comma is not a reserved symbol: we define it as a binary operator to construct dependent pairs. Because Y = ń(x : X) → Y x if one assumes the η-law, and because the first argument is implicit, we can write Σ {X} Y as Σ Y or Σ \(x : X) → Y x, where backslash is the same thing as lambda. We will use backslash exclusively for sums.
π0 : ∀{X : Set} {Y : X → Set} → (Σ \(x : X) → Y x) → X
π0(x , y) = x
π1 : ∀{X : Set} {Y : X → Set} → ∀(t : Σ \(x : X) → Y x) → Y(π0 t)
π1(x , y) = y
The identity type Id X x y is written x ≡ y with X implicit, and is inductively defined as “the least reflexive relation”:
data _≡_ {X : Set} : X → X → Set where refl : ∀{x : X} → x ≡ x
sym : ∀{X : Set} → ∀{xy : X} → x ≡ y → y ≡ x
sym refl = refl
trans : ∀{X : Set} → ∀{xyz : X} → x ≡ y → y ≡ z → x ≡ z
trans refl refl = refl
cong : ∀{XY : Set} → ∀(f : X → Y) → ∀{x0 x1 : X} → x0 ≡ x1 → f x0 ≡ f x1
cong f refl = refl
cong2 : ∀{XYZ : Set} → ∀(f : X → Y → Z)

→ 6{x0 x1 : X}{y0 y1 : Y} → x0 ≡ x1 → y0 ≡ y1 → f x0 y0 ≡ f x1 y1
cong2 f refl refl = refl



Dialogues and continuity
We consider the computation of functionals (X → Y ) → Z with dialogue trees. We work with the following inductively defined type of (well founded) dialogue trees indexed by three types X, Y and Z. These are Y -branching trees with X-labeled internal nodes and Z-labeled leaves:
data D (XYZ : Set) : Set where
η : Z → D XYZ 
B : (Y → D XY Z) → X → D XYZ 
A leaf is written η z, and it gives the final answer z (η will be the unit of a monad). A forest is a Y -indexed family F of trees. Given such a forest F and x : X, we can build a new tree B F x whose root is labeled by x, which has a subtree F y for each y : Y . We can imagine x : X as query, for which an oracle α gives some intermediate answer y = α x : Y. After this answer y, we move to the subtree F y, and the dialogue proceeds in this way, until a leaf with the final answer is reached:
dialogue : 6{XYZ : Set} → D XYZ → (X → Y) → Z
dialogue (η z)	α = z
dialogue (B F x) α = dialogue (F(α x)) α
We say that a function (X → Y ) → Z is eloquent if it is computed by some dialogue:
eloquent : 6{XYZ : Set} → ((X → Y) → Z) → Set eloquent f = Σ \d → 6 α → dialogue d α ≡ f α

Here we are interested in the case X=Y =Z=N. Think of functions α : N → N as sequences of natural numbers. The set of such sequences is called the Baire space:
Baire : Set Baire = N → N
Functions Baire → N are coded by a particular kind of dialogue trees, namely B N
where B is defined as follows:
B : Set → Set B = D N N 

We work with a refined version of continuity, which gives more information than the traditional notion introduced in Section 1, where the modulus of continuity is a finite list of indices rather than an upper bound for the indices. The agreement relation determined by a list of indices is inductively defined as follows, where α ≡[ s ] αj says that the sequences α and αj agree at the indices collected in the list s:
α ≡[ [] ] αj,
α i ≡ αj i → α ≡[ s ] αj → α ≡[ i :: s ] αj.
We write this inductive definition as follows in Agda, where we give the name [] to the proof of the first clause and the name :: to the proof of the second clause, that

is, using the same constructor names as for the inductively defined type of lists:
data _≡[_]_ {X : Set} : (N → X) → List N → (N → X) → Set where []	: 6{α α’ : N → X} → α ≡[ [] ] α’
_::_ : 6{α α’ : N → X}{i : N}{s : List N} → α i ≡ α’i → α ≡[ s ] α’ → α ≡[ i :: s ] α’
continuous : (Baire → N) → Set
continuous f = 6(α : Baire) → Σ \(s : List N) → 6(α’ : Baire) → α ≡[ s ] α’ → f α ≡ f α’
It is an easy exercise, left to the reader, to produce an Agda proof that this refined notion of continuity implies the traditional notion of continuity, by taking the max- imum value of the list s. Functions defined by dialogues are continuous, because a dialogue produces an answer after finitely many queries:
dialogue-continuity : 6(d : B N) → continuous(dialogue d)
dialogue-continuity (η n) α = ([] , lemma) where
lemma : 6 α’ → α ≡[ [] ] α’ → n ≡ n
lemma α’r = refl
dialogue-continuity (B F i) α = ((i :: s) , lemma) where
IH : 6(i : N) → continuous(dialogue(F(α i)))
IH i = dialogue-continuity (F(α i))
s : List N
s = π0(IH i α)
claim0 : 6(α’ : Baire) → α ≡[ s ] α’ → dialogue(F(α i)) α ≡ dialogue(F(α i)) α’
claim0 = π1(IH i α)
claim1 : 6(α’ : Baire) → α i ≡ α’i → dialogue (F (α i)) α’ ≡ dialogue (F (α’ i)) α’
claim1 α’r = cong (ń n → dialogue (F n) α’) r
lemma : 6(α’ : Baire) → α ≡[ i :: s ] α’	→ dialogue (F(α i)) α ≡ dialogue(F (α’ i)) α’
lemma α’ (r :: rs) = trans (claim0 α’ rs) (claim1 α’ r)
This formal proof is informally explained as follows. We show that
∀(d : B N) → continuous(dialogue d)
by induction on d. Expanding the definition, this amounts to, using Agda notation,
∀ d → ∀ α → Σ \s → ∀ αj → α ≡[ s ] αj → dialogue d α ≡ dialogue d αj.
For the base case d = η n, the definition of the function dialogue gives dialogue d α = n, and so we must show that, for any α,
Σ \s → ∀ αj → α ≡[ s ] αj → n ≡ n.
We can take s = [] and then we are done, because n ≡ n by reflexivity. This is what the first equation of the formal proof says. Thus notice that Agda, in accordance with MLTT, silently expands definitions by reduction to normal form. For the induction step d = B F i, expanding the definition of the dialogue function, what we need to prove is that, for an arbitrary α,
Σ \sj → ∀ αj → α ≡[ sj ] αj → dialogue (F(α i)) α ≡ dialogue (F αj i) αj.
The induction hypothesis is ∀(i : N) → continuous(dialogue(F(α i))), which gives, for any i and our arbitrary α,
Σ \s → ∀ αj → α ≡[ s ] αj → dialogue(F(α i)) α = dialogue(F(α i)) αj.
Using the two projections π0 and π1 we get s and a proof that

∀ αj → α ≡[ s ] αj → dialogue(F(α i)) α = dialogue(F(α i)) αj.
Hence we can take sj = i :: s, and the desired conclusion holds substituting equals for equals (with cong) using transitivity and the definition α i ≡ αj i → α ≡[ s ] αj
→ α ≡[ i :: s ] αj. This amounts to the second equation of the proof, where in the pattern of the proof of the lemma we have r : α i ≡ αj i and rs : α ≡[ s ] αj.

We need the following technical lemma because it is not provable in intensional MLTT that any two functions are equal if they are pointwise equal. The proof is admitedly written in a rather laconic form. The point is that the notion of continuity depends only on the values of the function, and the hypothesis says that the two functions have the same values. Notice that the axiom of function extensionality (any two pointwise equal functions are equal) is not false but rather not provable or disprovable, and is consistent [14].
continuity-extensional : 6(fg : Baire → N) → (6 α → f α ≡ g α) → continuous f → continuous g continuity-extensional fgtc α = (π0(c α) , (ń α’r → trans (sym (t α)) (trans (π1(c α) α’ r) (t α’)))) eloquent-is-continuous : 6(f : Baire → N) → eloquent f → continuous f
eloquent-is-continuous f (d , e) = continuity-extensional (dialogue d) fe (dialogue-continuity d)
The development for uniform continuity is similar to the above, with the crucial difference that a dialogue tree in C N is finite:
Cantor : Set Cantor = N → N2 C : Set → Set
C = D N N2
We work with a refined version of uniform continuity (cf. Section 1), where the modulus is a finite binary tree s of indices rather than an upper bound of the indices. We could have worked with a list of indices, but the proofs are shorter and more direct using trees. The agreement relation defined by a tree of indices is inductively defined as follows, where α ≡[[ s ]] αj says that α and αj agree at the positions collected in the tree s:
data _≡[[_]]_ {X : Set} : (N → X) → Tree N → (N → X) → Set where empty : 6{α α’ : N → X} → α ≡[[ empty ]] α’
branch :
6{α α’ : N → X}{i : N}{s : N2 → Tree N}
→ α i ≡ α’i → (6(j : N2) → α ≡[[ sj ]] α’) → α ≡[[ branch is ]] α’
Again we are using the same constructor names as for the type of trees.
uniformly-continuous : (Cantor → N) → Set
uniformly-continuous f = Σ \(s : Tree N) → 6(α α’ : Cantor) → α ≡[[ s ]] α’ → f α ≡ f α’
dialogue-UC : 6(d : C N) → uniformly-continuous(dialogue d)
dialogue-UC (η n) = (empty , ń α α’n → refl) dialogue-UC (B F i) = (branch i s , lemma)
where
IH : 6(j : N2) → uniformly-continuous(dialogue(F j))
IH j = dialogue-UC (F j)
s : N2 → Tree N
s j = π0(IH j)
claim : 6 j α α’ → α ≡[[ s j ]] α’ → dialogue (F j) α ≡ dialogue (F j) α’
claim j = π1(IH j)
lemma : 6 α α’ → α ≡[[ branch i s ]] α’ → dialogue (F (α i)) α ≡ dialogue (F (α’ i)) α’

lemma α α’ (branch r l) = trans fact0 fact1 where
fact0 : dialogue (F (α i)) α ≡ dialogue (F (α’ i)) α
fact0 = cong (ń j → dialogue(F j) α) r
fact1 : dialogue (F (α’ i)) α ≡ dialogue (F (α’ i)) α’
fact1 = claim (α’ i) α α’ (l(α’ i))
UC-extensional : 6(fg : Cantor → N) → (6(α : Cantor) → f α ≡ g α)
→ uniformly-continuous f → uniformly-continuous g
UC-extensional fgt (u , c) = (u , (ń α α’r → trans (sym (t α)) (trans (c α α’ r) (t α’))))
eloquent-is-UC : 6(f : Cantor → N) → eloquent f → uniformly-continuous f
eloquent-is-UC f (d , e) = UC-extensional (dialogue d) fe (dialogue-UC d)
We finish this section by showing that the restriction of an eloquent function f : Baire → N to the Cantor type is also eloquent. We first define a pruning function from B N to C N that implements restriction:
embed-N2-N : N2 → N embed-N2-N 0 = zero embed-N2-N 1 = succ zero
embed-C-B : Cantor → Baire embed-C-B α = embed-N2-N ◦ α
C-restriction : (Baire → N) → (Cantor → N)
C-restriction f = f ◦ embed-C-B
prune : B N → C N
prune (η n) = η n
prune (B F i) = B (ń j → prune(F(embed-N2-N j))) i
prune-behaviour : 6(d : B N)(α : Cantor) → dialogue (prune d) α ≡ C-restriction(dialogue d) α
prune-behaviour (η n)	α = refl
prune-behaviour (B F n) α = prune-behaviour (F(embed-N2-N(α n))) α
eloquent-restriction : 6(f : Baire → N) → eloquent f → eloquent(C-restriction f)
eloquent-restriction f (d , c) = (prune d , ń α → trans (prune-behaviour d α) (c (embed-C-B α)))


Gödel’s system T extended with an oracle
For simplicity, we work with system T in its original combinatory form. This is no loss of generality, because both the combinatory and the lambda-calculus forms define the same elements of the set-theoretical model, and here we are interested in the continuity of the definable functionals. The system T type expressions and terms are inductively defined as follows:
data type : Set where
Ì	: type
_⇒_ : type → type → type
data T : (σ : type) → Set where Zero	: T Ì
Succ	: T(Ì ⇒ Ì)
Rec	: 6{σ : type}	→ T((σ ⇒ σ) ⇒ σ ⇒ Ì ⇒ σ)
K	: 6{σ τ : type}	→ T(σ ⇒ τ ⇒ σ)
S	: 6{ρ σ τ : type} → T((ρ ⇒ σ ⇒ τ ) ⇒ (ρ ⇒ σ) ⇒ ρ ⇒ τ )
_·_	: 6{σ τ : type}	→ T(σ ⇒ τ ) → T σ → T τ
infixr 1 _⇒_
infixl 1 _·_

Notice that there are five constants (or combinators) and one binary constructor (ap- plication). Notice also that one can build only well-typed terms. The set-theoretical interpretation of type expressions and terms is given by
SetJ_) : type → Set SetJ Ì ) = N
SetJ σ ⇒ τ ) = SetJ σ ) → SetJ τ )


J_) : 6{σ : type} → T σ → SetJ σ ) J Zero )	= zero
J Succ )	= succ
J Rec )	= rec
J K )	= K¸
J S )	= Ş
J t · u )	= J t ) J u )

An element of the set-theoretical model is called T-definable if there is a T-term denoting it:
T-definable : 6{σ : type} → SetJ σ ) → Set T-definable x = Σ \t → J t ) ≡ x
As discussed above, the main theorem, proved in the last subsection, is that every T- definable function Baire → N is continuous. The system T type of such functionals is (Ì ⇒ Ì) ⇒ Ì.
We also consider system T extended with a formal oracle Ω : Ì ⇒ Ì:
data TΩ : (σ : type) → Set where
Ω	: TΩ(Ì ⇒ Ì)
Zero	: TΩ Ì
Succ	: TΩ(Ì ⇒ Ì)
Rec	: 6{σ : type}	→ TΩ((σ ⇒ σ) ⇒ σ ⇒ Ì ⇒ σ)
K	: 6{σ τ : type}	→ TΩ(σ ⇒ τ ⇒ σ)
S	: 6{ρ σ τ : type} → TΩ((ρ ⇒ σ ⇒ τ ) ⇒ (ρ ⇒ σ) ⇒ ρ ⇒ τ )
_·_	: 6{σ τ : type}	→ TΩ(σ ⇒ τ ) → TΩ σ → TΩ τ

In the standard set-theoretical interpretation, the oracle can be thought of as a free variable ranging over elements of the interpretation Baire of the type expression Ì ⇒ Ì:
J_)’ : 6{σ : type} → TΩ σ → Baire → SetJ σ ) J Ω )’   α = α
J Zero )’  α = zero J Succ )’ α = succ J Rec )’  α = rec
J K )’	α = K¸
J S )’	α = Ş
J t · u )’  α = J t )’ α (J u )’ α)
To regard TΩ as an extension of T we need to work with an embedding:
embed : 6{σ : type} → T σ → TΩ σ
embed Zero = Zero embed Succ = Succ embed Rec = Rec embed K = K embed S = S
embed (t · u) = (embed t) · (embed u)

The dialogue interpretation of system T
We now consider an auxiliary interpretation of system T extended with an oracle in order to show that the original T-definable functions Baire → N are continuous. In the alternative semantics, types are interpreted as the underlying objects of certain algebras of the dialogue monad. The ground type is interpreted as the free algebra of the standard interpretation, and function types as function sets. For the sake of brevity, we will include only the parts of the definition of the monad that we actually need for our purposes.
kleisli-extension : 6{XY : Set} → (X → B Y) → B X → B Y
kleisli-extension f (η x)	= fx 
kleisli-extension f (B F i) = B (ń j → kleisli-extension f (F j)) i
B-functor : 6{XY : Set} → (X → Y) → B X → B Y
B-functor f = kleisli-extension(η ◦ f)
The following two lemmas are crucial. We first swap the two arguments of the dialogue function to have the view that from an element of the Baire type we get a B-algebra B X → X for any X:
decode : 6{X : Set} → Baire → B X → X
decode α d = dialogue d α
The decodification map is natural for any oracle α : Baire:
B X	B g ) B Y


decode α
v
decode α
) v

X	Y.
g


decode-α-is-natural : 6{XY : Set}(g : X → Y)(d : B X)(α : Baire) → g(decode α d) ≡ decode α (B-functor g d)
decode-α-is-natural g (η x)	α = refl
decode-α-is-natural g (B F i) α = decode-α-is-natural g (F(α i)) α
The following diagram commutes for any f : X → B Y :
B X	kleisli-extension f	) B Y


decode α
v


)		)
decode α
v

X	B Y
f
decode α	Y.



decode-kleisli-extension : 6{XY : Set}(f : X → B Y)(d : B X)(α : Baire)
→ decode α (f(decode α d)) ≡ decode α (kleisli-extension f d)
decode-kleisli-extension f (η x)	α = refl
decode-kleisli-extension f (B F i) α = decode-kleisli-extension f (F(α i)) α

System TΩ type expressions are interpreted as the underlying sets of certain algebras of the dialogue monad. The base type is interpreted as the underlying set of the free algebra of the standard interpretation, and function types are interpreted as

sets of functions, exploiting the fact that algebras are exponential ideals (if Y is the underlying object of an algebra, then so is the set of all functions X → Y for any X, with the pointwise structure).
B-SetJ_) : type → Set B-SetJ Ì ) = B(SetJ Ì ))
B-SetJ σ ⇒ τ ) = B-SetJ σ ) → B-SetJ τ )

According to the official definition of an algebra of a monad, to show that a set X is the underlying object of an algebra one must provide a structure map B X → X. Alternatively, which is more convenient for us, one can provide a generalized Kleisli extension operator, defined as follows, where the base case is just Kleisli extension, and the induction step is pointwise extension:
Kleisli-extension : 6{X : Set} {σ : type} → (X → B-SetJ σ )) → B X → B-SetJ σ )
Kleisli-extension {X} {Ì} = kleisli-extension
Kleisli-extension {X} {σ ⇒ τ } = ń gds → Kleisli-extension {X} {τ } (ń x → gx s) d
With this we can now define the dialogue interpretation of system TΩ. The generic element of the Baire type under this interpretation will interpret the Baire oracle Ω:
generic : B N → B N
generic = kleisli-extension(B η)
As discussed in Section 1, the crucial property of the generic element is this:

B N	generic ) B N


decode α
v
N
decode α
v
) N.
α



generic-diagram : 6(α : Baire)(d : B N) → α(decode α d) ≡ decode α (generic d)
generic-diagram α (η n) = refl
generic-diagram α (B F n) = generic-diagram α (F(α n))
The alternative interpretations of zero and successor are obvious:
zero’ : B N
zero’ = η zero succ’ : B N → B N
succ’ = B-functor succ

And the interpretation of the primitive recursion combinator again uses Kleisli ex- tension in an obvious way:
rec’ : 6{σ : type} → (B-SetJ σ ) → B-SetJ σ )) → B-SetJ σ ) → B N → B-SetJ σ )
rec’ fx = Kleisli-extension(rec f x)
This gives the dialogue interpretation. Notice that the interpretations of K, S and application are standard. This is because we interpret function types as sets of functions:
BJ_) : 6{σ : type} → TΩ σ → B-SetJ σ )
BJ Ω )	= generic


BJ Zero ) = zero’ BJ Succ ) = succ’ BJ Rec )  = rec’
BJ K )	= K¸
BJ S )	= Ş
BJ t · u )	= BJ t ) (BJ u ))
This semantics gives the desired dialogue trees:
dialogue-tree : T((Ì ⇒ Ì) ⇒ Ì) → B N
dialogue-tree t = BJ (embed t) · Ω )

The remainder of the development is the formulation and proof of the correctness of the dialogue-tree function. We conclude this section with the trivial proof that the embedding of T into TΩ preserves the standard interpretation and furthermore is independent of oracles:
preservation : 6{σ : type} → 6(t : T σ) → 6(α : Baire) → J t ) ≡ J embed t )’ α
preservation Zero α = refl preservation Succ α = refl preservation Rec α = refl preservation K α = refl preservation S α = refl
preservation (t · u) α = cong2 (ń fx → f x) (preservation t α) (preservation u α)

Relating the two models
The main lemma is that for any term t : TΩ Ì,
J t )j α ≡ decode α (BJ t )).
We use the following logical relation to prove this:
R : 6{σ : type} → (Baire → SetJ σ )) → B-SetJ σ ) → Set R {Ì} n n’ =
6(α : Baire) → n α ≡ decode α n’
R {σ ⇒ τ } f f’ =
6(x : Baire → SetJ σ ))(x’ : B-SetJ σ )) → R {σ} x x’ → R {τ } (ń α → f α (x α)) (f’ x’)
We need a (fairly general) technical lemma, which is used for constants with an interpretation using the Kleisli-extension operator. In our case, this is just the re- cursion combinator. The proof is by induction on type expressions, crucially relying on the lemma decode-kleisli-extension, but is routine otherwise:
R-kleisli-lemma : 6(σ : type)(g : N → Baire → SetJ σ ))(g’ : N → B-SetJ σ ))
→ (6(k : N) → R (g k) (g’ k))
→ 6(n : Baire → N)(n’ : B N) → R n n’ → R (ń α → g (n α) α) (Kleisli-extension g’ n’)
R-kleisli-lemma Ì g g’ rgn n’ rn = ń α → trans (fact3 α) (fact0 α)
where
fact0 : 6 α → decode α (g’ (decode α n’)) ≡ decode α (kleisli-extension g’ n’)
fact0 = decode-kleisli-extension g’ n’
fact1 : 6 α → g (n α) α ≡ decode α (g’(n α))
fact1 α = rg (n α) α
fact2 : 6 α → decode α (g’ (n α)) ≡ decode α (g’ (decode α n’))
fact2 α = cong (ń k → decode α (g’ k)) (rn α)
fact3 : 6 α → g (n α) α ≡ decode α (g’ (decode α n’))
fact3 α = trans (fact1 α) (fact2 α)

R-kleisli-lemma (σ ⇒ τ ) g g’ rgn n’ rn
= ń y y’ ry → R-kleisli-lemma τ (ń k α → gk α (y α)) (ń k → g’k y’) (ń k → rg k y y’ ry) n n’ rn
The proof of the main lemma is by induction on terms, crucially relying on the lemmas generic-diagram (for the term Ω), decode-is-natural (for the term Succ) and R-kleisli-lemma (for the term Rec). The terms K and S are routine (but laborious and difficult to get right in an informal calculation), and so is the induction step for application:
main-lemma : 6{σ : type}(t : TΩ σ) → R J t )’ (BJ t ))
main-lemma Ω = lemma where
claim : 6 α n n’ → n α ≡ dialogue n’ α → α(n α) ≡ α(decode α n’)
claim α n n’s = cong α s
lemma : 6(n : Baire → N)(n’ : B N) → (6 α → n α ≡ decode α n’)
→ 6 α → α(n α) ≡ decode α (generic n’)
lemma n n’ rn α = trans (claim α n n’ (rn α)) (generic-diagram α n’)
main-lemma Zero = ń α → refl main-lemma Succ = lemma
where
claim : 6 α n n’ → n α ≡ dialogue n’ α → succ(n α) ≡ succ(decode α n’)
claim α n n’s = cong succ s
lemma : 6(n : Baire → N)(n’ : B N) → (6 α → n α ≡ decode α n’)
→ 6 α → succ (n α) ≡ decode α (B-functor succ n’)
lemma n n’ rn α = trans (claim α n n’ (rn α)) (decode-α-is-natural succ n’ α)

main-lemma {(σ ⇒ .σ) ⇒ .σ ⇒ Ì ⇒ .σ} Rec = lemma where
lemma : 6(f : Baire → SetJ σ ) → SetJ σ ))(f’ : B-SetJ σ ) → B-SetJ σ )) → R {σ ⇒ σ} f f’
→ 6(x : Baire → SetJ σ ))(x’ : B-SetJ σ ))
→ R {σ} x x’ → 6(n : Baire → N)(n’ : B N) → R {Ì} n n’
→ R {σ} (ń α → rec (f α) (x α) (n α)) (Kleisli-extension(rec f’ x’) n’)
lemma f f ’ rf x x’ rx = R-kleisli-lemma σ g g’ rg where
g : N → Baire → SetJ σ ) g k α = rec (f α) (x α) k g’ : N → B-SetJ σ )
g’ k = rec f ’ x’ k
rg : 6(k : N) → R (g k) (g’ k)
rg zero = rx
rg (succ k) = rf (g k) (g’ k) (rg k)
main-lemma K = ń x x’ rxy y’ ry → rx
main-lemma S = ń f f’ rfg g’ rgx x’ rx → rfx x’ rx (ń α → g α (x α)) (g’ x’) (rgx x’ rx)
main-lemma (t · u) = main-lemma t J u )’ BJ u ) (main-lemma u)
This gives the correctness of the dialogue-tree function defined above: the standard interpretation of a term is computed by its dialogue tree.
dialogue-tree-correct : 6(t : T((Ì ⇒ Ì) ⇒ Ì))(α : Baire) → J t ) α ≡ decode α (dialogue-tree t)
dialogue-tree-correct t α = trans claim0 claim1 where
claim0 : J t ) α ≡ J (embed t) · Ω )’ α
claim0 = cong (ń g → g α) (preservation t α)
claim1 : J (embed t) · Ω )’ α ≡ decode α (dialogue-tree t)
claim1 = main-lemma ((embed t) · Ω) α
The desired result follows directly from this:


eloquence-theorem : 6(f : Baire → N) → T-definable f → eloquent f
eloquence-theorem f (t , r) = (dialogue-tree t , ń α → trans(sym(dialogue-tree-correct t α))(cong(ń g → g α) r))
corollary0 : 6(f : Baire → N) → T-definable f → continuous f
corollary0 fd = eloquent-is-continuous f (eloquence-theorem f d)
corollary1 : 6(f : Baire → N) → T-definable f → uniformly-continuous(C-restriction f)
corollary1 fd = eloquent-is-UC (C-restriction f) (eloquent-restriction f (eloquence-theorem f d))
This concludes the full, self-contained, MLTT proof in Agda notation, given from scratch. Because MLTT proofs are programs, we can run the two corollaries to compute moduli of (uniform) continuity of T-definable functions. Because MLTT itself has an interpretation in ZF(C), in which types are sets in the sense of classical mathematics, the results of this paper hold in classical mathematics too. Because
the LATEX source for this article [7] is simultaneously an Agda file that type-checks, the readers don’t need to check the routine details of the proofs themselves, provided they trust the minimal core of Agda used here, and can instead concentrate on the interesting details of the constructions and proofs. One can envisage a future in
which it will be easier to write (constructive and non-constructive) formal proofs than informal, rigorous proofs, letting our minds concentrate on the insights. This is certainly a provocative statement. But, in fact, the proof presented here was directly written in its formal form, without an informal draft other than a mental picture starting from the idea of generic sequence as described in the introduction, with some rudimentary help by Agda to perform the routine steps. Tactic-based systems such as e.g. Coq provide much more help, which in some instances can be considered as non-routine even if ultimately they are based on algorithms. But our principal motivation for writing this formal proof in an MLTT or realizability based computer system such as NuPrl, Coq, Lego, Agda, Minlog etc. is that mentioned above, that the proof is literally a program too, and hence can be used to compute moduli of (uniform) continuity, without the need to write a separate algorithm based on an informal, rigorous proof, as it is usually currently done, including by ourselves in previous work.
Having said that, it is useful to have a self-contained informal rigorous proof, which we include in the next section. Before that, we conclude this section by running our formal constructive proof for the purposes of illustration.
Experiments
To illustrate the concrete sense in which the above formal proof is constructive, we develop some experiments. These experiments are not meant to indicate the usefulness of the theorem proved above. They merely make clear that the theorems do have a concrete computational content.
First of all, given a term t : (Ì ⇒ Ì) ⇒ Ì, we can compute its modulus of (uni- form) continuity.
mod-cont : T((Ì ⇒ Ì) ⇒ Ì) → Baire → List N
mod-cont t α = π0(corollary0 J t ) (t , refl) α)
mod-cont-obs : 6(t : T((Ì ⇒ Ì) ⇒ Ì))(α : Baire) → mod-cont t α ≡ π0(dialogue-continuity (dialogue-tree t) α)
mod-cont-obs t α = refl



infixl 0 _::_
infixl 1 _++_
_++_ : {X : Set} → List X → List X → List X
[] ++ u = u
(x :: t) ++ u = x :: t ++ u
flatten : {X : Set} → Tree X → List X
flatten empty = []
flatten (branch x t) = x :: flatten(t 0) ++ flatten(t 1)
mod-unif : T((Ì ⇒ Ì) ⇒ Ì) → List N
mod-unif t = flatten(π0 (corollary1 J t ) (t , refl)))
The following Agda declaration allows us to write e.g. 3 rather than succ(succ(succ zero)):
{-# BUILTIN NATURAL N #-}
{-# BUILTIN ZERO zero #-}
{-# BUILTIN SUC succ #-}
A difficulty we face is that it is not easy to write system T programs in the combi- natory version of system T. Hence we start by developing some machinery.
I : 6{σ : type} → T(σ ⇒ σ)
I {σ} = S · K · (K {σ} {σ})
I-behaviour : 6{σ : type}{x : SetJ σ )} → J I ) x ≡ x
I-behaviour = refl
number : N → T Ì
number zero = Zero
number (succ n) = Succ · (number n)
Here is our first example:
t0 : T((Ì ⇒ Ì) ⇒ Ì)
t0 = K · (number 17)
t0-interpretation : J t0 ) ≡ ń α → 17
t0-interpretation = refl example0 example0’ : List N
example0 = mod-cont t0 (ń i → i)
example0’ = mod-unif t0
These examples both evaluate to []. To provide more sophisticated examples, we work with an impoverished context G that allows us to consider just one free variable v, which is represented by the I combinator:
v : 6{G : type} → T(G ⇒ G)
v = I
Application for such a context amounts to the S combinator:
infixl 1 _•_
_•_ : 6{G σ τ : type} → T(G ⇒ σ ⇒ τ ) → T(G ⇒ σ) → T(G ⇒ τ )
f • x = S · f · x
Number : 6{G} → N → T(G ⇒ Ì)
Number n = K · (number n)
Here is an example:
t1 : T((Ì ⇒ Ì) ⇒ Ì)
t1 = v • (Number 17)
t1-interpretation : J t1 ) ≡ ń α → α 17


t1-interpretation = refl example1 : List N example1 = mod-unif t1
This evaluates to 17 :: [].
t2 : T((Ì ⇒ Ì) ⇒ Ì)
t2 = Rec • t1 • t1
t2-interpretation : J t2 ) ≡ ń α → rec α (α 17) (α 17)
t2-interpretation = refl example2 example2’ : List N example2 = mod-unif t2
example2’ = mod-cont t2 (ń i → i)
These examples evaluate to 17 :: 17 :: 17 :: 0 :: 1 :: [] and to a list whose members are all 17.
Add : T(Ì ⇒ Ì ⇒ Ì) Add = Rec · Succ infixl 0 _+_
_+_ : 6{G} → T(G ⇒ Ì) → T(G ⇒ Ì) → T(G ⇒ Ì)
x + y = K · Add • x • y
t3 : T((Ì ⇒ Ì) ⇒ Ì)
t3 = Rec • (v • Number 1) • (v • Number 2 + v • Number 3)
t3-interpretation : J t3 ) ≡ ń α → rec α (α 1) (rec succ (α 2) (α 3))
t3-interpretation = refl example3 example3’ : List N example3 = mod-cont t3 succ example3’ = mod-unif t3
These examples evaluate to 3 :: 2 :: 1 :: 2 :: 3 :: 4 :: 5 :: 6 :: 7 :: 8 :: [] and 3 :: 2 ::
1 :: 1 :: 0 :: 1 :: 2 :: 1 :: 0 :: 1 :: 1 :: 0 :: 0 :: 1 :: 1 :: 0 :: 1 :: [].
length : {X : Set} → List X → N
length [] = 0
length (x :: s) = succ(length s)
max : N → N → N
max 0 x = x
max x 0 = x
max (succ x) (succ y) = succ(max x y)
Max : List N → N
Max [] = 0
Max (x :: s) = max x (Max s)
t4 : T((Ì ⇒ Ì) ⇒ Ì)
t4 = Rec • ((v • (v • Number 2)) + (v • Number 3)) • t3
t4-interpretation : J t4 ) ≡ ń α → rec α (rec succ (α (α 2)) (α 3)) (rec α (α 1) (rec succ (α 2) (α 3)))
t4-interpretation = refl example4 example4’ : N example4 = length(mod-unif t4) example4’ = Max(mod-unif t4)
These examples evaluate to 215 and 3.
t5 : T((Ì ⇒ Ì) ⇒ Ì)
t5 = Rec • (v • (v • t2 + t4)) • (v • Number 2)
t5-explicitly : t5 ≡ (S · (S · Rec · (S · I · (S · (S · (K · (Rec · Succ)) · (S · I · (S · (S · Rec ·
(S · I · (K · (number 17))))· (S · I · (K · (number 17)))))) · (S · (S · Rec ·
(S · (S · (K · (Rec · Succ)) · (S · I · (S · I · (K · (number 2))))) · (S · I ·
(K · (number 3))))) · (S · (S · Rec · (S · I · (K · (number 1)))) · (S · (S ·
(K · (Rec · Succ)) · (S · I · (K · (number 2)))) · (S · I · (K · (number 3))))))))) ·
(S · I · (K · (number 2))))
t5-explicitly = refl
t5-interpretation : J t5 ) ≡ ń α → rec α (α(rec succ (α(rec α (α 17) (α 17))) (rec α (rec succ (α (α 2)) (α 3))




t5-interpretation = refl
example5 example5’ example5” : N example5 = length(mod-unif t5) example5’ = Max(mod-unif t5) example5” = Max(mod-cont t5 succ)
(rec α (α 1) (rec succ (α 2) (α 3)))))) (α 2)

These examples evaluate to 15551, 17 and 57. All evaluations reported above are instantaneous, except this last set, which takes about a minute in a low-end netbook. The use of Church encoding of dialogue trees produces a dramatic performance improvement [7], with an instantaneous answer in these examples, because Klesli extension and the functor don’t need to walk through trees to be performed.

Informal, rigorous proof
We now provide a self-contained, informal, rigorous version of the formal proof given above, in a foundationally neutral exposition.
We work with the combinatory version of (the term language of) Gödel’s sys- tem T. We have a ground type ι and a right-associative type formation operation
−⇒ −. Every term as a unique type. We have the constants
Zero: ι.
Succ: ι ⇒ ι.
Recσ : (σ ⇒ σ) ⇒ σ ⇒ ι ⇒ σ.
Kσ,τ : σ ⇒ τ ⇒ σ.
Sρ,σ,τ : (ρ ⇒ σ ⇒ τ ) ⇒ (ρ ⇒ σ) ⇒ ρ ⇒ τ .
We omit the subscripts when they can be uniquely inferred from the context. If t : σ ⇒ τ and u : τ are terms, then so is tu : τ , with the convention that this appli- cation operation is left associative. Write Tσ for the set of terms of type σ.
In the standard interpretation, we map a type expression σ to a set Jσ) and a term t : σ to an element Jt) ∈ Jσ). These interpretations are defined by induction as follows:
Jι) = N,	Jσ ⇒ τ ) = Jτ )Jσ) = (Jσ) → Jτ )) (set of all functions Jσ) → Jτ )), JZero) = 0,		JSucc)n = n + 1,	JRec)fxn = fn(x),
JK)xy = x,	JS)fgx = fx(gx),	Jtu) = Jt)(Ju)).
For any given three sets X, Y, Z, the set D XY Z of dialogue trees is inductively defined as follows:
A leaf labeled by an element z ∈ Z is a dialogue tree, written ηz.
If φ : Y → D XY Z is a Y -indexed family of dialogue trees and x ∈ X, then the tree with root labeled by x and with one branch leading to the subtree φy for each y ∈ Y is also a dialogue tree, written βφx.
Such trees are well founded, meaning that every path from the root to a leaf is finite.

The above notation gives functions
η : Z → D XY Z,
β : (Y → D XY Z) → X → D XY Z.
Dialogue trees describe “computations” of functions f : Y X → Z. Leaves give an- swers, and labels of internal nodes are queries to an “oracle” α ∈ Y X , the argument of the function f . For any dialogue tree d ∈ D XY Z, we inductively define a function fd : Y X → Z by
fηz(α)= z,	fβφx(α)= fφ(αx)(α).
The functions Y X → Z that arise in this way are called eloquent. Notice that the oracle α is queried finitely many times in this computation, because a dialogue tree is well founded. Hence the function f = fd : Y X → Z satisfies
∀α ∈ Y X	∃finite S ⊆ X	∀αj ∈ Y X,α =S αj =⇒ fα = fαj,

where α =S αj is a shorthand for ∀x ∈ S, αx = αjx. When X = Y = Z = N, this amounts to continuity in the product topology of NN with N discrete, which gives the Baire space.
For Y finite and X, Z arbitrary, the dialogue tree is finitely branching and hence finite by well-foundedness (or directly by induction), and so the set of potential queries to the oracle is finite, so that, for any f = fd : Y X → Z with Y finite,
∃finite S ⊆ X ∀α, αj ∈ Y X,	α =S αj =⇒ fα = fαj.

When Y =2= {0, 1} and X = Z = N, this amounts to (uniform) continuity in the product topology of 2N with 2 discrete, which gives the Cantor space.
Clearly, any N-branching tree d ∈ D NNN can be pruned to a 2-branching tree dj ∈ D N2N so that fd′ : 2N → N is the restriction of fd : NN → N from sequences to binary sequences. Hence if we show that every T-definable function NN → N is eloquent, we conclude that every T-definable function NN → N is continuous and its restriction to 2N is uniformly continuous. For this purpose, we consider an auxiliary model of system T.
Define B X = D NNX. We remark that although B is the object part of a monad, as discussed in the introduction, it is not necessary to know this for the purposes of this proof. The data given below do obey the required laws to get a monad, but the details are left to the interested reader.
For any function f : X → B Y , inductively define f : B X → B Y by
f (ηx)= fx,
f (βφi)= β(λj.f (φj))i.
This says that the tree f (d) is d with each leaf labeled by x replaced by the subtree fx, with no changes to the internal nodes. Given f : X → Y , we define f : B X → B Y by
B f = (η ◦ f ) .

Hence B f (d) replaces each label x of a leaf of d by the label f (x), and we have the naturality condition
B X B)f B Y
ˆ	ˆ
η	η
X	) Y.
f
For each α ∈ NN and any set X, define a map decodeα : B X → X by
decodeα(d)= fd(α).
Then, by definition, decodeα(ηx) = x, and hence the naturality of η gives that of
decodeα:
B X	B f ) B Y

decodeα
v
decodeα
v
(1)

X 	) Y.
f
It is also easy to see, by induction on dialogue trees, that
f 
B X	B Y

decodeα
v
decodeα
v
(2)


Now define
generic : B N → B N generic = (βη) .
X 	) B Y
f
	) Y.
decodeα

Because β : (N → B N) → N → B N and η : N → B N, the function generic is well defined. Its crucial property is that
B N	generic ) B N

decodeα
v
decodeα
v
(3)


The proof that
N 	) N.
α

decodeα(generic d)= α(decodeα d)

is straightforward by induction on d.
Now define the B-interpretation of types as follows:
BJι) = B(Jι))= B N,	BJσ ⇒ τ ) = BJτ )BJσ).

For any type σ and f : X → BJσ), define f : B X → BJσ) by induction on σ, where the base case σ = ι is given by the above definition, and the induction step σ = (ρ ⇒ τ ) is given pointwise as
f dy = (λx.fxy) d.
Notice that f : X → BJρ) → BJτ ) and f : B X → BJρ) → BJτ ).
Next extend system T with a new constant Ω: ι ⇒ ι, a formal oracle, and define the B-interpretation of terms as follows:
BJΩ) = generic,  BJZero) = η0,	BJSucc) = B(λn.n + 1),	BJRec)fx = (λn.fn(x))  ,
BJK)xy = x,	BJS)fgx = fx(gx),	BJtu) = BJt)(BJu)).
We also need to consider the standard interpretation of system T extended with the oracle Ω. We treat the oracle as a free variable, as hence the value of this free variable has to be provided to define the interpretation:
JΩ)α = α,	JZero)α = 0,	JSucc)αn = n + 1,	JRec)αfxn = fn(x),
JK)αxy = x,	JS)αfgx = fx(gx),	Jtu)α = Jt)α(Ju)α).
We claim that for any term t : ι,
Jt)α = decodeα(BJt)).
To prove this, we work with a logical relation Rσ between functions NN → Jσ) and elements of BJσ) by induction on σ. For any n : NN → N and nj ∈ B N, we define
Rιnnj ⇐⇒ ∀α, nα = decodeα nj,
and, for any f : NN → Jσ) → Jτ ) and fj : BJσ) → BJτ ), we define
Rσ→τ ffj ⇐⇒ ∀x : NN → Jσ), ∀xj : BJσ), Rσxxj → Rτ (λα, fα(xα))(fjxj).
We need a technical lemma for dealing with the dialogue interpretation of Rec:
Claim 3.1 For all g : N → NN → BJσ) and gj : N → BJσ), if
∀k ∈ N, Rσ(gk)(gjk),
then ∀n : NN → N, ∀nj ∈ B N, Rιnnj → Rσ(λα → g(nα)α)(gjnj) . The proof is straightforward by induction on types, using diagram 2. Claim 3.2 Rσ Jt) (BJt)) for every term t : σ.
The proof is by induction on terms, using diagram 3 for the term Ω, diagram 1 for the term Succ, and Claim 3.1 for the term Rec. The terms K and S are immediate but perhaps laborious, and the induction step, namely term application, is easy. This gives, in particular:

Claim 3.3 For every term t : (ι ⇒ ι) ⇒ ι, we have Jt)α = decodeα(BJtΩ)).
It follows that every T-definable function f : NN → N is eloquent, with dialogue tree given by BJtΩ), where t : (ι ⇒ ι) ⇒ ι is any term denoting f , and hence continuous, with uniformly continuous restriction to 2N.

Discussion, questions and conjectures
It may not be apparent from the informal proof of Section 3 that the argument is constructive, but Section 2 provides a constructive rendering in Martin-Löf type theory. We emphasize that our proof doesn’t invoke the Fan Theorem [15,2] or any constructively contentious axiom.
We have deliberately chosen system T in its combinatory form as the simplest and most memorable non-trivial higher-type language to illustrate the essence of the technique proposed here. It is clearly routine (as well as interesting and useful) to apply the technique to a number of well-known extensions of the simply-typed lambda-calculus. But, for instance, at the time of writing, dependent types seem to require further thought, particularly in the presence of universes. Can one, e.g. (generalize and) apply the technique developed here to show that all MLTT defin- able functions (N → N) → N are continuous, and that their restrictions to (N → 2) are uniformly continuous, in the main versions of (intensional) MLTT? More ambi- tiously, does the technique apply to Homotopy Type Theory [14]?
As pointed out by one of the anonymous referees, the syntactical techniques of [15] give more information: for any term t of type (ι ⇒ ι) ⇒ ι one can construct a term m : (ι ⇒ ι) ⇒ ι such that m internalizes the modulus of continuity of t. We adapted our technique to achieve this, as reported in [7], by working with Church encodings of dialogue trees defined within system T, and turning our semantical interpretation into a compositional translation of system T into itself. A corollary is that the dialogue trees of T-definable functions (N → N) → N, being themselves T-definable, have height smaller than ϵ0.

Acknowledgement
I benefitted from remarks on a previous version of this paper by Thierry Coquand, Dan Ghica, Achim Jung, Chuangjie Xu, and the anonymous referees.

References
A. Bauer and M. Pretnar. Programming with algebraic effects and handlers. Submitted for publication, 2012.
M.J. Beeson. Foundations of Constructive Mathematics. Springer, 1985.
E. Bishop. Foundations of constructive analysis. McGraw-Hill Book Co., New York, 1967.

A. Bove and P. Dybjer. Dependent types at work. Proceedings of Language Engineering and Rigorous Software Development, LNCS, 5520:57–99, 2009.


T. Coquand and G. Jaber. A note on forcing and type theory. Fundam. Inf., 100(1-4):43–52, January 2010.
T. Coquand and G. Jaber. A computational interpretation of forcing in type theory. In Epistemology versus Ontology, pages 203–213. Springer, 2012.
M.H. Escardó. Continuity of Gödel’s system T definable functionals via effectful forcing. Agda proof at http://www.cs.bham.ac.uk/~mhe/dialogue/, July 2012.
P. Hancock, D. Pattinson, and N. Ghani. Representations of stream processors using nested fixed points. In Logical Methods in Computer Science, page 2009.
W. A. Howard. Ordinal analysis of terms of finite type. The Journal of Symbolic Logic, 45:493–504, 1980.
S.C. Kleene. Recursive functionals and quantifiers of finite types I. Trans. Amer. Math. Soc, 91, 1959.
J. Longley. When is a functional program not a functional program? In Proceedings of Fourth ACM SIGPLAN International Conference on Functional Programming, pages 1–7. ACM Press, 1999.
P.Hancock and A. Setzer. Interactive programs in dependent type theory. In CSL, pages 317–331, 2000.
G. Plotkin and J. Power. Algebraic operations and generic effects. Applied Categorical Structures, 11, 2003.
The Univalent Foundations Program. Homotopy type theory: Univalent foundations of mathematics. Technical report, Institute for Advanced Study, 2013.
A. S. Troelstra, editor. Metamathematical investigation of intuitionistic arithmetic and analysis. Lecture Notes in Mathematics, Vol. 344. Springer-Verlag, Berlin, 1973.
C. Xu and M.H. Escardó. A constructive model of uniform continuity. To appear in TLCA, 2013.
