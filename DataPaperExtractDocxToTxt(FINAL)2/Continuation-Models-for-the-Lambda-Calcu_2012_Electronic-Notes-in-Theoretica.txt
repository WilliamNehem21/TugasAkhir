Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 337–350
www.elsevier.com/locate/entcs

Continuation Models for the Lambda Calculus With Constructors
Barbara Petit1
Focus - INRIA University of Bologna (Italy)

Abstract
The lambda calculus with constructors decomposes the pattern matching `a la ML into some atomic rules. Some of them do not match with the usual computational intuitions (in particular with typing intuitions). However it is possible to define an abstract notion of model for the untyped calculus, that has a trivial syntactic instance.
Nevertheless, the question of devising a non-syntactic model for this calculus was still unresolved. In this paper we answer this question in the untyped setting, by going back to the first motivation of the lambda- calculus with constructors: the simulation of an abstract machine with two independent stacks. This provides immediately a CPS translation into the usual lambda calculus. At the semantic level, it appears that this translation transforms any continuation model of the untyped lambda calculus into a model of the lambda calculus with constructors. In particular, any Scott domain can be turned into such a model.
Keywords: Lambda calculus, Pattern matching, Continuation Passing Style transformation, Categorical semantics, Continuation model.

Introduction
Pattern matching is a key feature in modern functional programming languages (Haskell, Ocaml) and proof assistants (Agda, Coq, Twelf). Since the late 90’s, many formalisms have been proposed to integrate it with lambda calculus [3,9,1,2]. The syntactic properties of these calculi have been thoroughly studied, in both typed and untyped settings, and this led Jay to implement a programming language centred on pattern matching [8].
A more abstract approach to these formalisms could allow a deeper understand- ing of them, and possibly a comparison between them. As far as we know, no (non syntactical) denotational model has been defined for any of these calculi.
Owing to its simple syntax, the lambda calculus with constructors (or λC - calculus) may be the best one to start with. Indeed, whereas most calculi with

1  Email:barbara.petit@ens-lyon.org

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.10.001

pattern matching require the definition of a powerful operation of pattern substi- tution, the operational semantics of the λC -calculus is composed of atomic rules: the pattern matching `a la ML is decomposed into a simple analysis on constants (like the case instruction of Pascal), and a commutation rule between the case con- struction and the application (Sec. 1.2). Although this last rule is rather counter intuitive at first sight (it was presented as “ill-typed” in the introducing paper), the calculus is confluent and enjoys the separation property (in the spirit of B¨ohm’s theorem), and a type system has also been defined for it [13].
A naive definition of a model can be given in category theory for the untyped lambda calculus with constructors [12]. However it seems difficult to build non syntactic instantiations of this definition. This sends us back to one of the main challenges of theoretical computer science in the late 60’s: to build a denotational model for the pure lambda calculus (i.e. a mathematical structure with a reflexive object D ∼= DD). This problem was solved by Scott [16] in 1970, with the con- struction of a so-called D∞ domain. It appeared later that such domains are in fact continuation models (characterised by two objects R and C such that C ∼= RC × C) of the pure lambda calculus [15].
The idea underlying these continuation models is to use a cps translation of the pure lambda calculus into the simply typed lambda calculus with only two basic types (one for the continuations, and one for the responses), and then to use the standard interpretation of the simply typed lambda calculus in a Cartesian closed category. We use the same method in this paper: we define a cps transformation of the lambda calculus with constructors into the lambda calculus, and then interpret the translated terms in a ccc (with some required isomorphisms). The main difficulty is to interpret the pattern analysers (called case bindings). Indeed, to keep the definition of the models conceptually simpler, we use an operation of composition of case bindings, that has a non trivial trans- lation in the cps. However, the translation is correct, and provides as expected a sound definition of continuation models for the lambda calculus with constructors.
Outline: In the first section, we give an intuitive presentation of the lambda cal- culus with constructors, by defining an abstract machine for it. A cps translation naturally results from this machine; we formalise it in Sec. 2. In the last section, we give the categorical definition of models (Sec. 3.1), and of continuation models (Sec. 3.2) for the lambda calculus with constructors, and we show that the second ones form a subclass of the first ones (Sec. 3.3). Finally we show that good candid- ates for continuation models of the λC -calculus already exist (like Scott’s domains for instance).
Lambda calculus with constructors
First approach: a two stack abstract machine
We extend the syntax of the lambda calculus with a finite set C of constructors (c,
d etc.) and a case construct {|θ|} · t, where t is a term and θ a case binding, i.e. a

partial function from constructors to terms:
θ := {c1 '→ t1; ··· ; ck '→ tk}
The domain {c1; ··· ; ck} of this case binding is denoted by dom(θ), and θci repres- ents the term ti. Pattern matching occurs when such a case binding is associated to a constructor of its domain, just like a case analysis on constants:
{|θ|} · c → t	if	c '→ t ∈ θ
The conditional branching, testing a Boolean and returning t or u if it is true or
false respectively (where true and false are constructors), is then written
ift,u = λx.{|true '→ t; false '→ u|} · x.
In this language, there are now two different kinds of values: the functions (the usual λ-abstractions) and the constructors 2 . Each of them can be evaluated by the corresponding construction in a context: the argument of an application and the case binding of a case construct respectively. Also we can extend the Krivine abstract machine [5] to this syntax, by replacing the stack of arguments originally composing the evaluation context by two stacks: one (say the “right stack”) for the arguments, and the other one (the “left stack”) for the case bindings. When a term is evaluated in this machine, it then interacts with the left stack if it is a case construct or a case binding, and with the right stack if it is an application or a λ-abstraction. This machine is formally defined in Fig. 1. Evaluating the term (ift,u false) in this machine (starting with two empty stacks) will indeed lead to
the configuration ⬦  u  ⬦ . But this machine can also simulate the pattern matching on compound data structures.

Processes:	s  :=	τ	  t   π
Execution rules:


Figure 1. A two stacks abstract machine.


2 This second kind of values will be elaborated in Sec. 1.2.

with θ ◦ {c1'→t1;...; cn'→tn} = {c1'→{|θ|}·t1;...;cn'→{|θ|}·tn}

Figure 2. The λ-calculus with constructors.
ML-style pattern matching
Notice that constructors, just as any terms, can be applied to any number of argu- ments (they are variadic). We call a data structure a constructor possibly applied to some arguments. For instance, one can represent the natural numbers by data structures, using two constructors S and 0 and the unary encoding of natural num- bers. The predecessor function is then written pred := λx.{|0 '→ 0; S '→ λz.z|}·x. Its application to a number Sn is actually evaluated to n (we skip the first β-reduction
steps):

(where θ = {0 '→ 0; S '→ λz.z}). More generally, any pattern matching with a branch “ C(x1,...,xk) -> t ” in a ML-like program behaves like a term with a branch c '→ λx1 ... xk.t evaluated in our machine. In this sense, the machine presented above is able to simulate pattern matching on elaborated data structures with a simple rule of constant analysis. The same idea is underlying the lambda calculus with constructors (or λC -calculus).
Operational semantics of the λC -calculus
The ML-style pattern matching is achieved in the double stack abstract machine by giving a double status to the constructors: they can be applied to some arguments to form a compound data structure (in this case they interact with the application stack), but they can also be seen as a constant to analyse by the case bindings (and then interact with the case stack). In the semantics setting, this context switch- ing corresponds to the following commutation rule between case and application constructs:
{|θ|} · (tu)		({|θ|} · t) u . 
This is a crucial rule of the lambda calculus with constructors (Fig. 2), called CaseApp (or ca for short). In addition to this rule, the calculus supports the usual β and η-reductions (resp. al and la), and the rule of constant analysis that we

have seen earlier (co). There are also a commutation rule between case construct and λ-abstractions (cl), and a composition rule for case bindings (cc) so that the λC -calculus enjoys confluence and separation properties [1]. Writing →∗ the transitive closure of the reduction relation →, one can check that pred (Sn) →∗ n, using rules al, ca and co.
Whereas the rule CaseApp does not match with the usual typing intuitions (the same subterm can be applied like a function, or pattern matched like a data structure), the case composition corresponds to a commutative conversion in logic [6, Sec. 10.4]:
{|θ|} · {|c1 '→ u1; ...; cn '→ un|} · t → {|c1 '→ {|θ|} · u1; ...; cn '→ {|θ|} · un|} · t

Concerning evaluation contexts, this rule amounts to merging all case bindings of a case stack ⬦ · θ1 ··· θk in only one (optional) case binding θ1 ◦ · · · ◦ θk (with left associativity of ◦). Also we consider the following alternative abstract machine for the λC -calculus, that we call the KAMλC :
Definition 1.1 (The KAMλC ). A process is a triple ⟨θ⟩    t    π, where ⟨θ⟩ is an optional case binding (⬦ or θ), t is a term and π a stack of terms. The four execution rules are
⟨θ⟩	λx.t	  u · π	►	⟨θ⟩	  t[x := u]	π
⟨θ⟩		tu		π	►	⟨θ⟩			t	  u · π θ			c		π	►		⬦		θc		π
⟨θ⟩   {|φ|} · t	π	►	⟨θ⟩◦ φ	t		π
where ⟨θ⟩◦ φ is φ if ⟨θ⟩ = ⬦, and θ ◦ φ if ⟨θ⟩ = θ.
Actually the rule CaseCase is not absolutely necessary from the computational point of view (it is only necessary for the separation property). Hence we could also consider the λC -calculus without cc (the λ−-calculus), and the first version of abstract machine we have presented. This would also lead to a slightly different notion of models (see the footnotes 3 and 5).
In the next section, we will use this machine to translate the lambda calculus with constructors into the pure lambda calculus.

CPS translation
Plotkin [14] used stack abstract machines to define continuation passing style (cps) translations between the call-by-name and call-by-value λ-calculi. Indeed, the stack of the the machine can be encoded with pairs in the λ-calculus. In the same way, we will define a cps translation of the λC -calculus into the lambda calculus with pairs (or λp-calculus) based on the KAMλC . A λC -term t will be translated by a λp-term t∗ that takes an evaluation context k (the continuation) in argument, and that returns the result of the evaluation of t with context k in the machine.


|Mθ  x  Mπ| = x ⟨|Mθ, Mπ|⟩
|Mθ  tu  Mπ| = |Mθ  t  ⟨|u∗, Mπ|⟩|
|Mθ  λx.t  Mπ| = let ⟨|x, xπ′ |⟩ = Mπ in |Mθ  t  xπ′ |	(if x∈/fv(Mθ,Mπ))
|Mθ  ci  Mπ| = let ⟨|x1; ... ; xn|⟩n = Mθ in |∗   xi  Mπ|
|Mθ  {|φ|} · t  Mπ| = |⟨|N1; ··· ; Nn|⟩n  t  Mπ|
where Ni = λk′.let ⟨|zθ,zπ|⟩=k′ in |Mθ ٨ ui ٨ zπ|	if ci'→ui ∈ φ Ni = ∗	if ci ∈/ dom(φ)
Figure 3. Translation of λC -calculus into λp-calculus
Target calculus
A continuation is a pair ⟨|Mθ, Mπ|⟩ where Mθ and Mπ are two λp-terms representing respectively the case binding and the application stack of the evaluation context. From now on, we write {c1, ··· , cn} the set C of constructors, and a case binding θ of the λC -calculus will be translated by a the n-tuple ⟨|M1, ··· , Mn|⟩n where Mi is t∗ if (ci '→ ti) ∈ θ, or a special constant ∗ (meaning here match failure) if ci ∈/ dom(θ).
Terms of the λp-calculus are given by the following grammar and rules:
M, N, P :=	x | λx.M | MN |  ∗  | ⟨|M, N |⟩ | πi(M )	(i∈{1,2})
(λx.M ) N →p M [x := M ]	;	λx.(Mx) →p M	(x∈/fv(M ))
πi(⟨|M1, M2|⟩) →p Mi	;	⟨|π1(M ), π2(M )|⟩ →p M
We use the same names for variables than in the λC -calculus, although we may also write k for some λp-variables (representing a continuation). We use the notations ⟨|M1,..., Ml|⟩l and πl(M ) for the usual encoding of tuples and gen- eralised projections with pairs.  We also write let ⟨|x1,..., xl|⟩l = P in M for
the term (λx1,..., xl.M )πl(P ) ... πl(P ) (when l is not specified it is 2), so that
1	l
let ⟨|x1,..., xl|⟩l = ⟨|N1,..., Nl|⟩n in M →∗ M [x1 := N1] ... [xl := Nl].
The CPS translation
The translation of a λC -term t in the λp-calculus is then given by
t∗ :=	λk.let ⟨|xθ, xπ|⟩ = k in |xθ  t  xπ|
where the result of t in context ⟨|Mθ, Mπ|⟩ (where Mθ an d Mπ are two λp-terms), denoted by |Mθ t Mπ|, is defined by induction in Fig. 3. The translations of a variable, a λ-abstraction and an application exactly correspond (after forgiving the “case” part of the continuation) to the translation c.b.v.-c.b.n. of Plotkin [14]. The translation of a constructor ci consists in giving the application context to the ith component of the case context (xi). Remark that no case context is given (we use the term ∗), since xi comes with its own case context (Ex. 2.1). The translation of

a case construct amounts to composing the (translated) case binding with the case context.
Example 2.1 Let ψ = {ci '→ ui/i ∈ E ⊆ [1..n]} and φ = {ci '→ si/i ∈ E′ ⊆ [1..n]}. Then the result of the term u = {|φ|} · {|ψ|} · (cj t) (with j ∈ dom(ψ)) is:
|Mθ  u  Mπ| = |⟨|N1,..., Nn|⟩n  {|ψ|} · (cj t)  Mπ|
(with Ni=λk.let ⟨|zθ,zπ|⟩=k in |Mθ ٨ si ٨ zπ| if i∈dom(φ))
|Mθ  u  Mπ| = |⟨|P1,..., Pn|⟩n  cj t  Mπ|
(with Pi=λk′.let ⟨|z′ ,z′ |⟩=k′ in |⟨|N1,...,Nn|⟩n ٨ ui ٨ z′ | if i∈dom(φ))
θ  π	π
|Mθ  u Mπ| = |⟨|P1,..., Pn|⟩n  cj  ⟨|t∗, Mπ|⟩|
= let ⟨|x1; ... ; xn|⟩n = ⟨|P1,..., Pn|⟩n in |∗   xj  ⟨|t∗, Mπ|⟩|
= let ⟨|x1; ... ; xn|⟩n = ⟨|P1,..., Pn|⟩n in xj ⟨|∗, ⟨|t∗, Mπ|⟩|⟩
→∗ Pj ⟨|∗, ⟨|t∗, Mπ|⟩|⟩
→p let ⟨|zj , zj |⟩ = ⟨|∗, ⟨|t∗, Mπ|⟩|⟩ in |⟨|N1,..., Nn|⟩n  uj  zj |
θ	π	π
→∗ |⟨|N1,..., Nn|⟩n  uj  ⟨|t∗, Mπ|⟩|
This translation enables the simulation of the lambda calculus with constructors in the lambda calculus with pairs (Theo. 2.4). This result derives from the following lemmas (proved by a trivial induction on t):
Lemma 2.2 Let t, tj,u be three λC -terms, and x a variable not free in tj. Then for any λp-terms N, Mθ, Mπ,
|Mθ  tj  Mπ| [x := N ]	=	| Mθ[x := N ]  tj  Mπ[x := N ] |
|Mθ  t  Mπ| [x := u∗]	→∗	| Mθ[x := u∗]  t[x := u]  Mπ[x := u∗] |

Mθ →p Mj
=⇒ |Mθ  t  Mπ| →p |Mj
  t  Mπ|

Mπ →p Mj	=⇒ |Mθ  t  Mπ| →∗ |Mθ  t  Mj |
π	p	π
Lemma 2.3 For any λC -terms t, u, any case-bindings φ, ψ, and any λp- terms Mθ, Mπ,

|Mθ  (λx.t)u  Mπ|	→+
|Mθ  λx.tx  Mπ|	→+
|Mθ  {|φ|} · c  Mπ|	→+
|Mθ  t[x := u]  Mπ|
|Mθ  t  Mπ|	if x ∈/ fv(t)
|Mθ  u  Mπ|	if c '→ u ∈ φ

|Mθ  {|φ|} · tu  Mπ|	= |Mθ  ({|φ|} · t)u Mπ|
|Mθ  {|φ|} · λx.t  Mπ|	= |Mθ  λx.{|φ|} · t  Mπ|  if x ∈/ fv(φ)
|Mθ  {|φ|} · {|ψ|} · t Mπ| = |Mθ  {|φ ◦ ψ|} · t Mπ|
Notice that the only λC -rules that are actually simulated by some reduction steps in the λp-calculus are the β and η-reductions, and the constant analysis. The other rules correspond to the management of the stacks by the machine, and are simulated during the cps translation.
Theorem 2.4 (Correct simulation) For any λC -terms t, tj,

t → tj	implies	t∗ →∗ tj∗ .

Consequences for denotational models
The simulation theorem provides a sound interpretation of the λC -calculus in any model of the λp-calculus. Indeed, if [·] is an interpretation of the λp-terms that
j	∗	j∗
equalises the equivalent ones, then t  λC t implies t  λ t	(by Theo. 2.4 and
the Church-R¨osser property) and thus [t∗]= [tj∗] in the model (for each calculus L presented in this paper, we write  L the reflexive symmetric and transitive closure of its reduction rules).
In the next section, we give a categorical definition of models for the λC -calculus, and we show how to transform a model of the lambda calculus with pairs into a λC - model. This transformation of models will directly come from the cps translation we have just presented.

Classical models for the λC -calculus
In this section we briefly present what is a categorical model for the λC -calculus (more details and proofs can be found in [12]), and we show that the continuation models of the pure lambda calculus have the good structure to be seen as λC -models. Notations: In a Cartesian closed category (ccc), we write IdA the identity morph- ism on A, and f ; g the composition of f and then g. We denote by A × B the product of two objects A and B, and by BA their exponent, and by 1 the terminal

object. The ith projection morphisms over k is written πk
(or πi
if k = 2), the

pairing of f and g is ⟨f, g⟩, ev is the evaluation morphisms and Λ(f ) the curried
form of f .

Categorical models of the λC -calculus
In category theory, a model for the pure lambda calculus is a ccc with a reflexive object D ∼= DD. Indeed, λ-terms are interpreted in D, and points of DD are functions from terms to terms (i.e. open terms, abstracted over a free variable). Then a morphism lam : DD → D enables to construct the denotation of λx.t, from the representation of the function mapping x to t. In the same way, a morphism app : D → DD allows to interpret the application of any term to an other one. Also the equality app ◦ lam = Id ensures that the interpretation respects β-equivalence.
To interpret the λC -calculus in such a category, some extra morphisms are ne-
cessary (for the interpretation of the constructors and the case construct), as well as some equalities between them to validate the Case rules. A case binding θ will be interpreted in Dn: the ith component corresponds to θc if it is defined, and is a special point (meaning match failure) of D otherwise. Then a morphism case : (Dn × D) → D is required to interpret the case construct {|θ|} · t, given the denotation of θ in Dn and the one of t in D. We also needa point c∗ of D for every
constructor ci ∈ C .

Definition 3.1 (λC -model) A categorical model for the untyped λC -calculus isa 

structure (C ,D , app , lam , (c∗)n
,  , case) where

i i=1
C is a Cartesian closed category, and D is one of its object.
app : D → DD and lam : DD → D form an isomorphism: D ∼= DD .
All the c∗’s and  are points of D, and case is a morphism of Dn × D → D,
The four diagrams of Fig.4 commute ((D1) commutes for every i ∈ 1..n)).

Figure 4. Commuting diagrams in a λC -model
The equalities of morphisms described in Fig. 4 ensure that the interpretation we have informally presented respects λC -equivalence. It is pretty clear how the commutation of diagrams (D4) and (D2) entail the validity of rules CaseCons and CaseApp respectively. The validity of the rule CaseCase is expressed through a morphism • : Dn × Dn → Dn (D4), that represents the case binding composition in the categorical framework (Lem. 3.3). It is defined as the pairing of the morphisms (IdDn × πn); case, for 1 ≤ i ≤ n.
The diagram (D3) is the only one that does not directly translate a reduction
rule of the λC -calculus. It expresses the equivalence between a match failure and the matching of a match failure 3 , and is necessary for the soundness w.r.t. the rule CaseCase.

3  If we enrich the λC -calculus with explicit match failure (that is, a special constant  and the rule
{|θ|} · c → if c ∈/ dom(θ)), then we need an extra rule {|θ|} ·  →  for confluence (to close the critical pair

Notice that there is no diagram corresponding to the rule
CaseLam
in the

definition of a λC -model. In the same way that the rule cl closes a critical pair between ca and al, the commutation of the diagram corresponding to it (D2j) is induced by the commutation of (D2) and the reflexivity of D, as expressed by Lem. 3.2. This diagram uses a morphism case○ : Dn×DD → DD, that abstracts the case construct over a variable: it turns a case binding θ and a function mapping x to t into the function mapping x to {|θ|} · t, and it is formally defined as the curried form of

(Dn
× DD
) × D
~= Dn
× (DD
IdDn ×ev
× D)  Dn
case
× D  D .

Lemma 3.2 (Diagram (D2j)) If (app, lam) form an isomorphism between D and DD, then the commutation of (D2) is equivalent to the commutation of the following diagram:

Dn × DD
Id×lam

Dn × D
case◦





case

DD

lam

D


(D2j)

This enables to define a sound interpretation of λC -terms in any λC -model: if t has its free variables included in Γ = (x1,..., xk), then its interpretation [t]Γ is defined by induction in Fig. 5.

[xi]Γ	= πk : Dk → D

[tu]Γ
=	Dk
⟨[t]Γ,[u]Γ⟩
D × D
app×IdD
DD × D
ev	D

[λx
k+1
.t]Γ
=	Dk
Λ(ft)
 DD
lam	D

where ft =
∼=
D × D  D
k+1 [t]Γ,xk+1

[c]Γ
=	Dk
!Dk	c∗
1  D

[{|θ|} · t]Γ =	Dk
⟨[θ]Γ,[t]Γ⟩
Dn × D	case	D
⎨

Γ	1	n


⎩ !Dk ;  if ci ∈/ dom(θ)



Figure 5. Interpretation of λC -terms in a categorical model


Lemma 3.3 (Categorical case composition) If θ and φ are two case bindings whose free variables are all in Γ, then their interpretation in any λC -model satisﬁes

[θ ◦ φ] =	Dk ⟨[θ]Γ,[φ]Γ⟩ Dn × Dn
Dn  .



with cc). The model we present here would still be sound for the extended calculus, and the diagram (D3) corresponds to this last rule. Alternatively, if we remove the rule CaseCase form the calculus, then the commutation of (D1) and (D2) is sufficient.

Proposition 3.4 (Soundness) If  (C ,D , app , lam , (c∗)n  ,  , case)  is  a  λC -
i i=1
model, then Fig. 5 interprets each closed λC -term t by a point [t] of D such that
t  λ	tj	=⇒	[t]= [tj] .
In fact λC -models are even complete for the sub calculus with no match fail- ure [12].
Continuation models
A Cartesian closed category is a model of the pure λ-calculus if it has an object D equivalent to its function space, in which we can interpret the λ-terms. Among them are the continuation models 4 (see the excellent introduction of [15]): ccc with two objects C and R satisfying the equation C ∼= C × RC. Indeed, taking D = RC
fulfils the condition D ∼= DD, and leads to interpret the λ-terms by points of RC,
i.e. informally by functions taking a continuation argument in C, and returning a response in R. A functional term (i.e. a point of DD) is interpreted in (RC)RC ∼= RC×RC , also the continuation argument of a function is a point of C × RC. It represents a pair composed of later continuation (in C) anda term (in RC) that is the argument of the function. That is why we can see the continuations as stacks of arguments, and the term interpretations in a continuation model as processes in a stack abstract machine.
As we have seen earlier (Sec. 2.1), a continuation for the λC -calculus should not be only a stack of arguments, but a pair composed of a case binding (i.e. a point of Dn) and a stack (i.e. a point of some object S satisfying the stack equation). This gives rise to the following definition.
Definition 3.5 (Continuation λC -model) A ccc is a continuation λC -model (or classical λC -model) if it has four objects R, C, S 5 and D satisfying the following equations:
D ∼= RC	;	C ∼= Dn × S	;	S ∼= D × S
In the next section, we show that every continuation λC -model is actually a λC -model in the sense of Def. 3.1. It might be a bit tedious to describe the morph- isms app, lam, c∗ and  in a continuation model (and still more to prove the diagrams commutation) with compositions and curried forms; and so we use the λ-calculus with pairs (as an internal language for cccs) to define those morphisms. Given a Cartesian closed category C, we call its internal language the λC-calculus, and we write  C the equivalence of terms in this language.
From continuation λC -models to λC -models
Let C be a continuation λC -model (Def. 3.5). We write ↑s, ↓s, ↑c and ↓c the terms (resp. of type S → D ×S, D ×S → S, C → Dn ×S and Dn ×S → C) corresponding

4 Also called classical models, as their underlying logic is the classical logic [10].
5 Without the case composition, the case context would be not only a case binding (in Dn), but a stack of case bindings. Hence we would need a fourth object S′ satisfying the equation S′ ~= Dn × S′, and the interpretation of terms in such a model would be more complex.

to the morphisms that guarantee S ∼= D × S and C ∼= Dn × S. We show that C can be provided with the structure of a λC -model (Def. 3.1). To do so, we refer to the λC-terms defined in Fig. 6. The terms Mlam, Mapp and Mcase have a free

Mlam = λk.let ⟨|xθ, xπ|⟩ =↑c k in let ⟨|x, xj |⟩ =↑s xπ in z x  ↓c ⟨|xθ, xj |⟩ 
π	π
Mapp = λx.λk.let ⟨|xθ, xπ|⟩ =↑c k in z  ↓c ⟨|xθ, ↓s ⟨|x, xπ|⟩|⟩ 
Mci = λk.let ⟨|xθ, xπ|⟩ =↑c k in let ⟨|x1; ... ; xn|⟩n = xθ in xi k Mcase = λk.let ⟨|xθ, xπ|⟩ =↑c k in
let ⟨|yφ, y|⟩ = z in y  ↓c ⟨|⟨|M1,..., Mn|⟩n, xπ|⟩ ,
where Mi = λkj. let ⟨|zθ, zπ|⟩ =↑c kj in
let ⟨|x1; ... ; xn|⟩n = yφ in xi  ↓c ⟨|xθ, zπ|⟩ 
M = λk.let ⟨|xθ, xπ|⟩ =↑c k in let ⟨|x, xj |⟩ =↑s xπ in x  ↓c ⟨|⟨|x,..., x|⟩n, xπ|⟩ 
Figure 6. Terms for the morphisms of a continuation λC -model
variable z, that will correspond (through the mapping from the λC-calculus to C) to the arguments of lam. app and case respectively. Remark that there is a direct connection between the terms defined in Fig. 6 and the cps translation of Sec. 2 (Fig. 3), given that |Mθ  t  Mπ|  λ  t∗⟨|Mθ, Mπ|⟩.
Definition 3.6 The morphisms defining a λC -model are given by the following derivable judgements:	  = ▶ M : D
lam
c∗
Theorem 3.7 (C is a λC -model) In a Cartesian closed category C that is a con- tinuation λC -model, the morphisms deﬁned in Def. 3.6 satisfy the diagrams in Fig. 4, and the morphisms lam and app form an isomorphism between D and DD. Also
(C ,D , app , lam , (c∗)n  ,  , case) is a λC -model.
i i=1
Proof (sketch). All the equalities on morphisms can be proved using the internal language: two morphisms are equal if their corresponding terms are convertible. For instance, the equality lam; app = IdDD follows from the λC-convertibility of lam; app (i.e. λz.Mapp[z := Mlam]) and λz.z, and inverse equation comes from λz.Mapp[z := Mlam] C λz.z. In the same way, the commutation of the diagrams come from the following equivalences:
λz.Mcase[z := ⟨|π1(z), Mc |⟩]  Cλz.πn((π2(z)))	(D1)
i	i
λy.(Mapp[z := Mcase[z := π1(y)]])π2(y)  C
λy.Mcase[z := ⟨|π11(y), (Mapp[z := π21(y)]|⟩)π2(y)] (D2)
λy.Mcase[z := ⟨|M• π1(y), π2(y)|⟩]  C
λy.Mcase[z := ⟨|π11(y), Mcase[z := ⟨|π21(y), π2(y)|⟩]|⟩] (D4)
λy.M   Cλy.Mcase[z := ⟨|π1(z), M |⟩] (D3)

In the commutation of (D4), the term M• corresponds to •, the pairing of the morphisms (IdDn × πn); case:
M• = λz.⟨|Mcase[z := ⟨|π (z), πn(z)|⟩]; ... ; Mcase[z := ⟨|π (z), πn(z)|⟩]|⟩n	2
1	1	1	n
Non syntactical λC -model
Although it is a priori not easy to construct a λC -model 6 (using Def. 3.1), some well- known categories are in fact continuation λC -models. Indeed, every continuation model (i.e. every ccc with two objects R and C such that C ∼= RC × C) happens to be a continuation λC -model if we take (by definition) S = C and D = RC: we immediately have S ∼= D × S, and
C ∼= RC × C ∼= RC × (RC × C) ∼= ... ∼= (RC)n × C = Dn × S.
Corollary 3.8 There is a sound interpretation of the λC -calculus in any ccc with two objects R and C such that	C ∼= RC × C.
This is good news, since we know how to construct such mathematical structures. In particular, any Scott’s D∞ domain is suitable [15, Theo. 3.1].
Notice that conversely, every continuation λC -model is a continuation model:
C ∼= Dn × S ∼= Dn × (D × S) ∼= (Dn × S) × D ∼= C × RC.
By plugging this decomposition of isomorphism into the usual interpretation of the pure lambda calculus in continuation models, one actually obtains the morph- isms lam and app as defined in Def. 3.1. Hence, using this isomorphism to trans- form a continuation λC -model into a continuation model, and then interpreting pure λ-terms in it, amounts to the same as interpreting directly the λ-terms (seen as λC -terms) in the continuation λC -model.
Conclusion and further work
We have shown how to construct an interpretation of the λC -calculus in any continu- ation model (for instance in Scott’s domain): first use the isomorphism C ∼= RC × C to define the isomorphism C ∼= Dn × S (with S = C and D = RC), and then use the isomorphims in Def. 3.6 to define the morphisms lam, app, c∗, case and . Finally interpret the λC -terms as in Fig. 5.
This work raises several questions. The first one concerns the interaction of the λC -calculus with the λμ-calculus of Parigot [11], as a calculus corresponding to classical models. Is there a well-behaved calculus including both of them? Such a calculus would be of particular interest, since the λμ-calculus corresponds to classical logic, whereas pattern matching on data structures is usually associated to constructive proofs [4].
The second one is about the completeness of categorical models for the lambda calculus with constructors. Indeed, the λC -models are complete for the λC -calculus with no match failure (or with identification of all of them, as explained in the footnote p. 9). It is then natural to ask whether the continuation λC -models are

6 Except the syntactical model in the category of Partial Equivalence Relations [12].

complete for the calculus; in other words, whether every λC -model (in particular, the syntactic model of pers) is equivalent to continuation λC -model. If they are not, what would be an internal language for these categories? Maybe a kind of “λμC -calculus”, since continuation categories are complete for the λμ-calculus [7]. Last, the question of a denotational model for the typed λC -calculus is still pending. The syntax of this calculus is quite simple but the type system proposed for it [13] is not. To give a categorical definition of the data types seems especially not easy (the only denotational model for the typed calculus so far is the syntactic
model of reducibilty candidates).

Acknowledgement
To Alexandre Miquel, for giving the idea of a double stack abstract machine for the
λC -calculus, and for all the fruitful discussions we had on this work.

References
Ariel Arbiser, Alexandre Miquel, and Alejandro R´ıos. The lambda-calculus with constructors: Syntax, confluence and separation. Journal of Functional Programming, 19(5):581–631, 2009.
Horatiu Cirstea and Germain Faure. Confluence of pattern-based lambda-calculi. In Franz Baader, editor, RTA, volume 4533 of Lecture Notes in Computer Science, pages 78–92, Paris, France, June 2007. Springer.
Horatiu Cirstea and Claude Kirchner. The rewriting calculus as a semantics of elan. In ASIAN, pages 84–85, 1998.
Thierry Coquand. Pattern matching with dependant types. Proceedings of the Workshop on Types for Proofs and Programs, June 1992.
Pierre Cr´egut. An abstract machine for lambda-terms normalization. In Proceedings of the 1990 ACM conference on LISP and functional programming, LFP ’90, pages 333–340, 1990.
Jean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and Types. Cambridge University Press, 1989.
Martin Hofmann and Thomas Streicher. Continuation models are universal for lambda-mu-calculus. In LICS, pages 387–395, 1997.
Barry Jay. Pattern Calculus: Computing with Functions and Structures. Springer, 2009.
C. Barry Jay and Delia Kesner. Pure pattern calculus. In ESOP, pages 100–114, 2006.
Yves Lafont, Bernhard Reus, and Thomas Streicher. Continuation semantics or expressing implication by negation. Technical report, University of Munich, 1993.
Michel Parigot. Lambda-my-calculus: An algorithmic interpretation of classical natural deduction. In
LPAR, pages 190–201, 1992.
Barbara Petit. Categorical model for the lambda calculus with constructors. http://arxiv.org/abs/ 1202.4678, 2011.
Barbara Petit. Semantics of typed lambda-calculus with constructors. Logical Methods in Computer Science, 7(1:2), 2011.
Gordon D. Plotkin. Call-by-name, call-by-value and the lambda-calculus. Theoretical Computer Science, 1(2):125–159, 1975.
Bernhard Reus and Thomas Streicher. Classical logic, continuation semantics and abstract machines.
Journal of Functional Programming, 8(6):543–572, 1998.
Dana Scott. Outline of a mathematical theory of computation. Technical report, Princeton University, 1970.
