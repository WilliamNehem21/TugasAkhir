Cyber Security and Applications 2 (2024) 100030

		




Colour image encryption algorithm using Rubik’s cube scrambling with bitmap shuﬄing and frame rotation
Aditi Nair a, Diti Dalal a, Ramchandra Mangrulkar b,∗
a Department of Computer Engineering, D J Sanghvi College of Engineering, Mumbai, India
b Department of Information Technology, D J Sanghvi College of Engineering, Mumbai, India


a r t i c l e	i n f o	a b s t r a c t

	

Keywords:
Rubik’S cube scrambling Bitplane decomposition Frame rotation
Image encryption Symmetric-key encryption Cryptography
The 21st century has seen a significant increase in the usage of multimedia to transfer information. Algorithms used for the encryption of plain text are not suitable for multimedia encryption. This paper proposes a new and unique algorithm - Rubik’s cube scrambling with Bitplane shuﬄing and Frame rotation (RBF) for the encryption of coloured images. RBF is a symmetric key algorithm that takes two 128-bit key inputs from the user. The algorithm uses Rubik’s cube moves for generating scrambling sequences, followed by the shuﬄing of the bitplanes to generate the encrypted image. A distinctive frame rotation technique is applied to each of the bitplanes in the encryption process. The RBF algorithm is simple and straightforward to implement but produces satisfactory results. The algorithm is evaluated using a range of multimedia data. The paper also describes the various analysis tests and results of the algorithm in detail. Overall, the algorithm demonstrates its value for encrypting many types of multimedia data with practical applications.





Introduction

Every day, information is exchanged through multimedia in numer- ous areas around the world. Internet protocols transmit private data in packets along the same channels as public data, but sadly, hackers have developed methods for spying on the data being sent across the network. Security for web services becomes quite important, especially when it pertains to distributed system environments [1]. As a result, there is a continuing requirement for secure data transfer. There are several algo- rithms for this purpose, but with attackers attempting to intercept data, new methods that improve security are constantly encouraged. This is where encryption comes into play. The primary objective of an encryp- tion algorithm should be to make encryption and decryption operations very fast while also withstanding any attempts to break them[2]. En- cryption has proven useful in a variety of industries. Based on their industry, size, and budget, businesses invest a lot in data security be- cause they need to safeguard their trade secrets, intellectual property, etc [3]. When the data is encrypted, the original data is scrambled to obscure the text’s meaning while still leaving room for the data to be de- crypted using a secret key. It is important to use encryption to make sure data is protected from tampering (data integrity), to ensure that people communicate with the people they think are communicating with (au- thentication), and to ensure that messages have been sent and received (non-repudiation) [4]. Stream cyphers and block cyphers are the two basic classifications of cryptographic algorithms that are used for en-

∗ Corresponding author.
E-mail address: ramchandra.mangrulkar@djsce.ac.in (R. Mangrulkar).
cryption. Block cyphers work with groups of fixed-length bits known as blocks, whereas stream cyphers are designed to encrypt one bit at a time [5]. Besides that, cryptography can be categorized into two categories: symmetric encryption and asymmetric encryption.
In this paper, RBFRubik’s cube scrambling with Bitplane shuﬄing and Frame rotation, a novel symmetric key algorithm for secure data transfer through multimedia data, which includes a three-stage encryp- tion is introduced. The encryption and decryption processes in symmet- ric key cryptography employ the same key for both the sender and the receiver [6]. Due to its single key sharing scheme, symmetric key cryp- tosystems are substantially faster than asymmetric key cryptosystems [7]. Additionally, symmetric key encryption offers better security than asymmetric key encryption [8]. AES [9], DES [10], Blowfish, and RC5
[11] are some examples of symmetric cryptography algorithms. It is also important to know the algorithm’s weaknesses and strengths along with its performance to appropriately use the algorithm for certain appli- cations [12]. Thus various analyses of the algorithm related to perfor- mance are included in the paper.
The three stages of the proposed encryption method that will be dis- cussed in this paper are Rubik’s cube scrambling, frame rotation of bit- planes, and bitplane shuﬄing. The remainder of the article’s structure is as follows. Existing work in the field of Rubik’s cube encryption and bitplane decomposition is summarised in Section 2 of this paper. The proposed methodology is described in Section 3. A detailed explanation of the encryption and decryption methods is provided in Sections 4 and


https://doi.org/10.1016/j.csa.2023.100030
Received 3 May 2023; Received in revised form 15 July 2023; Accepted 9 August 2023
Available online 18 August 2023
2772-9184/© 2023 The Authors. Publishing Services by Elsevier B.V. on behalf of KeAi Communications Co., Ltd. This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/)



5, respectively. The complete algorithm is presented in Section 6. The execution of RBF on various multimedia data, as well as the implemen- tation and results of various analytical tests, are covered in Section 7. In Section 8, the study is concluded.

Related work

Rubik’S cube

This section provides an overview of a few studies in the field of cryptography that make use of the Rubik’s cube principle. Here, the basic Rubik’s cube notations are also explained. Oﬃcial cubing compe- titions use computer-generated permutations to correctly scramble all of the puzzles and ensure that speedcubers have an equal opportunity [13]. Basic Notation is used to express each scrambled sequence. R sig- nifies ”turn the right face of the cube clockwise” in the Basic Notation system, and R2 stands for ”flip the cube’s right face 180 degrees.” [14]. F stands for front, B for back, L for left, R for right, U for up, and D for down [14]. A letter by itself means a clockwise rotation of a face, while the letter followed by an apostrophe (’) means a counterclockwise turn [13]. Fig. 1 Renusree Varma Mudduluri et al. developed a unique image encryption algorithm based on Rubik’s cube principle. In their paper, using two randomly generated vectors, the pixels of the image are ran- domly shuﬄed in a manner similar to that of a Rubik’s cube [15]. Li
field of image cryptography involving bitplane decomposition is stated further.
An image is made up of pixels of various values and is denoted in a matrix format. These values range from 0 to 255 for each colour of each pixel. Thus 1 byte i.e. 8 bits can be used to denote a pixel(in the case of grayscale images). There are various methods that can be used to generate the bitplanes, viz. Binary Bitplane Decomposition (BBD), Grey Code Bitplane Decomposition (GCBD), and Fibonacci p-code Bitplane Decomposition (FBD).

BBD
The Binary Bitplane Decomposition is the most conventional form of Bitplane Decomposition where a non-negative number N(1 byte) is decomposed into 8 bitplanes corresponding to its binary sequence.
7
𝑁 =  𝑏𝑖 2𝑖 = 𝑏020 + 𝑏121 + …+ 𝑏727
𝑖=0
GCBD
In Grey Code Bitplane Decomposition, the grey code is considered for bitplane decomposition that differs by 1 bit. This method also generates 8 bitplanes.
𝑔 = {𝑏𝑖	if 𝑖 = 7

Rubik’s Cube. Their algorithm divides an original image into a number of blocks and rotates these cubes in a manner resembling a Rubik’s cube employing techniques produced by the logistic system. In the end, a new scrambled image is created using those cubes [16]. Xiao Feng et al. pub- lished a paper on how to optimize an image-scrambling method based on logistic sequence and Rubik’s cube rotation. The improved algorithm resizes the original image, divides the resized image into six blocks, and then rotates the cubes in 25 steps applying 30 different rotating tech- niques that are managed by a chaotic system [17].
Adrian-Viorel Diaconu et al. suggested a newly proposed digital im- age cryptosystem that combines a digital chaotic cipher and the Rubik’s cube approach. The original image is first scrambled using the Rubik’s
𝑖	𝑖
where 𝑔 is the grey code of the corresponding binary of the 𝑖𝑡ℎ bit.

FBD
In Fibonacci p-code Bitplane Decomposition makes use of the p- Fibonacci Series. A natural number can be represented using p-code Fibonacci Series as follows:
7
𝑁 =	𝑓0 𝐹𝑝 (0) + 𝑓1 𝐹𝑝 (1) + …+ 𝑓7 𝐹𝑝 (7)
𝑖=0
where 𝑓𝑖 is a weight associated with 𝐹𝑝 (𝑖) for uniqueness and
0	if 𝑖 < 0

cube principle (rows and columns are alternatively shuﬄed and each row and column’s circular-shifting direction and number of steps are de-
rived from their intrinsic properties using different modulo operators),
𝐹𝑝 (𝑖) =
⎧⎨⎪
1	if 𝑖 = 1
𝐹 (𝑖 − 1) + 𝑓 (𝑖 − 1 − 𝑝)  if 𝑖 > 1

and then the XOR operator is applied to the rows and columns of the scrambled image using a chaos-based cipher (due to its proven diffu- sion properties) [18]. Khaled Loukhaoukha et al. suggested an effective image cryptosystem based on diffusion and permutation operations to strengthen the security of iris-based systems against replay threats. They first divide the original image into blocks, which are then permuted us- ing a permutation key, and the Rubik’s cube principle is then applied to each block to obtain a scrambled image [19].

BITPlane decomposition

The concept of bitplanes, as well as the various types of bitplanes, are described in this section. A summary of some of the work done in the


Fig. 1. Rubik’s Cube Notation [13].
𝑝	𝑝
Various values can be used for p. For example, when p = 1 the following
Fibonacci series is obtained: 1,1,2,3,5,8,13,21...
The number of bitplanes generated is based on the value of p. For 𝑝 = 1, 12 bitplanes can be generated, for 𝑝 = 2, 14 bitplanes can be generated
and so on.
Francesc Aul’-Llin’as et al. use bitplanes to create an image cod- ing scheme as they use less computing power [20]. Few works have been done that use bitplanes for encryption, each employing a differ- ent approach. For example, Zhou et al. use bitplanes as security keys followed by bit-level scrambling for encryption of the image [21]. Simi- larly, Madhu and Kumari present a method for selecting a bitplane of the source image as a key for encrypting partial and all bitplanes of the orig- inal image [22]. Houas et al. decompose the bitplanes and encrypt and decrypt using a key-image obtained from the representation of the 8 bit- planes through a unique method [23]. Sun et al. propose an encryption technique that uses a random sequence to scramble the bitplane order [24]. Podesser et al. propose to only selectively encrypt certain bitplanes for data in mobile devices [25]. Liu et al. propose a novel technique for image sharing that includes compressing the bitplanes [26]. Some of the existing Encryption algorithms combine Bitplane decomposition and other techniques. The encryption method presented by Mozaffari, for example, combines bitplane decomposition with genetic algorithm that is used for permutations while Naveen and Satpute use the A5/1 Cipher with the bitplanes in their proposed image encryption algorithm [27,28]. Chen and Cheng propose a technique of reversible data hid-




Fig. 2. Bitplanes of the Lena Image.


ing in encrypted images that preserves the correlation in the high-order bitplanes while compressing [29]. Song et al. propose an encryption al- gorithm that scrambles the bitplanes using chaotic logistic maps [30]. All of them employ the BBD (Binary Bitplane Decomposition) approach, while the suggested algorithms in [31,32], and [33] apply the Gray Code and Fibonacci p-code Bitplane Decomposition techniques[30].
In this paper, Binary Bitplane Decomposition is used in the encryp- tion algorithm. Bitplane is the plane (2D matrix) generated by consider- ing a bit’s value of each pixel for an image. Thus using BBD, a grayscale image forms 8 bitplanes where bitplane 0 takes the least significant bit and bitplane 7 takes the most significant bit.
Considering the value of a pixel of a grayscaled image to be 200. Its binary representation will be 11001000. As it is observed, the value of the 3rd, 6th, and 7th bits are 1 while the value of the 0th,1st, 2nd, 4th, and 5th bits are 0. 8 bitplanes can be formed using these bit values, each replacing its pixel value for the corresponding bitplane. 0th bitplane will take the value of bit0, 1st of bit1, 2nd of bit2, and so on. Fig. 2 depicts the various 8-bitplanes that can be formed using the BBD (Binary Bitplane Decomposition) method for the grayscale Lena image.
As seen from Fig. 2, higher bitplanes that are formed using the MSB contain more information about the image than the other bitplanes.



Fig. 3. Encryption-Decryption Flow.



About 94% percent of the image data is present in the first four bit- planes [31].
A coloured image consists of 3 values for every pixel, each for blue, green, and red colours, and each of these values ranges from 0 to 255.
Thus a coloured image can be denoted in a 3D matrix, i.e. 3∗2D matrices
for every r,g, and b colour. The values of the pixel determine the colour
decomposed into 8∗3 bitplanes i.e. 8 planes for each r,g, and b colour. and intensity of the image collectively. Hence a coloured image can be


Fig. 4. Encryption Matrix.


Fig. 5. Initial Matrix.
Proposed methodology

A novel and innovative technique for multimedia cryptography - RBF, is described in this section. This method takes two 128-bit unique keys and a coloured image as input to generate its corresponding en- crypted image output. The encryption and decryption algorithms have 3 main stages as shown in Fig. 3.
The first step i.e. Rubik’s Cube Scrambling uses the two keys to gen- erate a scrambling sequence based on the techniques used in solving a Rubik’s cube as mentioned in Section 4.1. In the second step, the image is decomposed into 24 bitplanes as described in Section 4.2, and frame rotation is applied for each of the bitplanes using the input keys. The third step involves scrambling the bitplanes in a specific sequence and integrating them to form the encrypted image. During the decryption procedure, the receiver uses the same two 128-bit keys to decrypt the received encrypted image.

Encryption

Rubik’S cube scrambling

This section provides a detailed explanation of the algorithm’s first stage, i.e. the Rubik’s cube scrambling. The fundamental idea behind this approach is to resemble the image as a Rubik’s cube’s face and then apply the scrambling operations generally used to scramble the cube. Here, however, just one face is taken into account rather than the com- plete cube. An image in the digital format is represented by a matrix. Therefore, when dealing with images for encryption, one would actually be dealing with a matrix of pixel values.
In this step, the image matrix is divided into n x n sized blocks. Each block represents the face of a n x n Rubik’s cube. The scrambling op- erations will then be applied to these blocks based on the scrambling sequence generated. L, R, U, D, F, L’, R’, U’, D’, F’, L2, R2, U2, D2, F2 are the basic operations that the encryption scrambling sequence is


Fig. 6.


Fig. 7. Key Update Logic.



composed of. A number attached with these operations will indicate the column or row number of the block that the operation is to be performed on (This number renders meaningless when the operation is F, F’, or F2). Then, in the direction indicated by the letter in the scrambling sequence, the corresponding row or column is circularly shifted. A 2D matrix was formulated containing all the operations and there is a different matrix for encryption and decryption. Fig. 4.
The keys K1 and K2 are used to generate the scrambling sequence for each block-row of the image. The two keys are divided into sub- sequences of four digits. Each 4-digit sub-sequence from K1 gives the number indicating the row/column index. The corresponding 4-bit sub- sequence from K2 represents the index of the 2D operation matrix, re- sulting in the operation to be performed.
For example, when
𝐾1 = 01010100001000111 ……… .00110011
𝐾2 = 11010100011110100 ……… .10111100
First 4 bits of K1 = 0101
= 5(𝑑𝑒𝑐𝑖𝑚𝑎𝑙)
First 4 bits of K2 = 1101
= (𝑟𝑜𝑤)11 and (𝑐𝑜𝑙)01
Therefore, the first operation =  5𝐷2
Thus a sequence of 32 operations is obtained from the 2 keys. This se- quence is used for scrambling all the blocks in a row. Next, the Key




Fig. 8. Rubik’s cube scrambling (a) Original Image (b) Resultant Image.




Fig. 8. Continued


Fig. 9. Frame Rotation.



Fig. 10. Reduction Logic.

Update Logic is applied. The two updated keys of a row are similarly used to generate sequences for the next row.

Implementation of the Rubik’s cube encryption sequence on a 10x10
Let the encryption sequence be EncSeq = [4R’, 7D, 2L, 9F, 3D2, 1L’,
7U, 5L2, 8R, 3F2, 2U’, 6D’, 1R2, 8F’, 5U2]
Fig. 11. Sequence Generation.

The 10x10 block is displayed in Fig. 5 EncSeq[0] = 4R’, so the fourth column from the right is located and rotated downwards by one cell. The resultant matrix can be seen in Fig. 6 a
EncSeq[1] = 7D, the seventh row from the bottom is located and
right-shifted by one as shown in Fig. 6 b




Fig. 12. (a) Resultant image after Rubik’s cube scrambling (b) Final Encrypted Image.


Fig. 13. Decryption Matrix.
EncSeq[2] = 2L, the second column from the left is rotated down- wards by one cell. The resultant matrix is shown in Fig. 6 c
EncSeq[3] = 9F, when the operation is F, the integer renders mean-
ingless. The matrix simply gets rotated clockwise as displayed in Fig. 6 d.
EncSeq[4] = 3D2, the third row from the bottom is right-shifted by
two cells. The resultant matrix is displayed in Fig. 6 e
EncSeq[5] = 1L’, the first column from the left is rotated upwards by
one and the result is shown in Fig. 6 f
EncSeq[6] = 7U, the seventh row from the top will be left shifted by
one. The resultant matrix is displayed in Fig. 6 g
EncSeq[7] = 5L2, the fifth column from the left will be rotated down-
wards by two cells as displayed in Fig. 6 h
EncSeq[8] = 8R, the eighth column from the right is rotated upwards
by one. The resultant matrix is shown in Fig. 6 i
EncSeq[9] = 3F2, the integer before the operation F’ renders mean-
ingless. The matrix is simply rotated twice in clockwise direction and
displayed in Fig. 6 j
EncSeq[10] = 2U’, the second row from the top gets right-shifted by
one as displayed in Fig. 6 k
EncSeq[11] = 6D’, the sixth row from the bottom gets left-shifted by
one and the resultant matrix is shown in Fig. 6 l
EncSeq[12] = 1R2, the first column from the right gets rotated up-
wards by two cells. The result is displayed in Fig. 6 m
EncSeq[13] = 8F’, the integer in this case renders meaningless. The
EncSeq[14] = 5U2, the fifth row from the top will be left-shifted by matrix is simply rotated counterclockwise as displayed in Fig. 6 n
two cells. The resultant matrix is shown in Fig. 6 o
Thus, the final resultant matrix is obtained after undergoing a set of
operations from the EncSeq.	Fig. 14. Diagrammatic representation of the encryption algorithm.



Key updation
This section explains the key updating procedure, which helps gen- erate new set of keys for each row. For the following row, the keys are left shifted by 1 bit and xored with the other original key (updated K1 is xored with K2 and vice versa). Then the bit at the location of the
key number, i.e. the 𝑖𝑡ℎ bit is flipped. This operation ensures that no se-
quence is repeated. The logical flow is shown in Fig. 7. The remaining
block at the end of the row or column having a rectangular size also goes through all the operations except for the F (face rotation) operation. To increase the complexity, the entire process is applied to the image thrice
i.e. for three rounds. The block size in the first round is 16, 32 for the next round, and 64 for the last round. Fig. 8 a shows the original source image and Fig. 8 b shows the image after it has been scrambled using a Rubik’s cube.

Bitplane shuffiing and frame rotation

This section discusses the second and last stage of the RBF algorithm, which involves first separating the scrambled image into its bitplanes. Frame rotation is performed on these bitplanes, followed by bitplane shuﬄing.

Generating bitplanes
An image is represented as a matrix and is made up of pixels with different values. For each pixel of each colour, these values fall between 0 and 255. The planes (2D matrix) created by taking into account the bit value of each pixel in a picture are known as ”bitplanes.” As mentioned in section 2.2.1, bitplanes are generated using the BBD (Binary Bitplane
Decomposition). Thus in this step, 24 (8∗3) bitplanes are generated for
coloured images. (0–7 for blue, 8–15 for green and 16–23 for red) for
blue:
𝑖𝑚𝑔[𝑖, 𝑗, 0] = 27 ∗ 𝑏0[𝑖, 𝑗] + 26 ∗ 𝑏1[𝑖, 𝑗] + 25 ∗ 𝑏2[𝑖, 𝑗] + 24 ∗ 𝑏3[𝑖, 𝑗]
+ 23 ∗ 𝑏4[𝑖, 𝑗] + 22 ∗ 𝑏5[𝑖, 𝑗] + 21 ∗ 𝑏6[𝑖, 𝑗] + 20 ∗ 𝑏7[𝑖, 𝑗]
Similarly, the bitplanes are generated for green and red components. The sequence of colour components may change based on the storing technique such as JPEG, PNG, etc.

Bitplane frame rotation
This stage proves to be quite helpful in order to boost the unpre- dictability and complexity of the encryption process. Using the original keys frame rotation is applied on each bit plane separately. A frame is considered as the outline 1-pixel border square/rectangle of a plane at a particular distance from the edge. The frames in each bitplane are then rotated by a certain count in a circular manner in the clockwise direction.
Two methods are applied to an image in this step - frame rotation
a few units. For 𝑖𝑡ℎ frame i.e. outline box of pixels at a distance of i from and a certain shift. First, the rotation is applied followed by an offset of
image and its 0𝑡ℎ frame are considered. The rotation of 1 followed by the end, the two steps are successively applied. As shown in Fig. 9 a 5x5
an offset of 2 units is applied in clockwise direction. The two 128-bit keys K1 and K2 are used to determine the count with which the frames in each bitplane need to be rotated. First, a reduction logic is applied to both keys, reducing them to 96 bits each. Then random sequences are generated using the reduced keys for each frame of a bitplane. This is followed by updating the reduced keys to generate new random se- quences.

Reduction logic
From the 128-bit key, every 4th bit is discarded to produce a 96-bit key. That is bit positions 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120,
124, 128 are discarded as shown in Fig. 10.



Fig. 15. Results of encryption and decryption of various images using the RBF algorithm.


Fig. 16. Total time vs Image size.



















































Random sequence generation
The two 96-bit keys are used to generate 24 8-bit sequences corre- sponding to the 24-bitplanes for each frame. To create an 8-bit sequence, 4 bits from each of the keys are considered. For the first bitplane, the first 4 bits of K1 and K2 are considered, for the second bitplane, bits 4–8 of K1 and K2 are considered, and so on. The sequence is generated by appending the 4 bits of K2 after the 4 bits of K1. The first and last bits of this sequence is used to determine the number of rotations to
be performed. And the 6 middle bits give the offset value as shown in Fig. 11.
The keys are updated using the same logic as mentioned in Sec- tion 4.1.2.

Bitplane shuffiing
The frame rotation step is applied to all the 24 bitplanes. The order of the bitplanes is changed to generate a better-encrypted image when



integrated. The bitplanes for each colour are shuﬄed as follows: blue:	initial order : 0,1,2,3,4,5,6,7
shuﬄed order: 7,6,5,4,3,2,1,0 green:	initial order : 8,9,10,11,12,13,14,15
shuﬄed order: 15,14,13,12,11,10,9,8 red:	initial order : 16,17,18,19,20,21,22,23
shuﬄed order: 23,22,21,20,19,18,17,16

Generating the encrypted image
The bitplanes after being shuﬄed in the order mentioned before are integrated into an image. The bitplanes are integrated into an image by reversing a similar decomposition procedure for each colour component. for blue:
𝑒𝑛𝑐[𝑖, 𝑗, 0] = 27 ∗ 𝑏7[𝑖, 𝑗] + 26 ∗ 𝑏6[𝑖, 𝑗] + 25 ∗ 𝑏5[𝑖, 𝑗] + 24 ∗ 𝑏4[𝑖, 𝑗]
+ 23 ∗ 𝑏3[𝑖, 𝑗] + 22 ∗ 𝑏2[𝑖, 𝑗] + 21 ∗ 𝑏1[𝑖, 𝑗] + 20 ∗ 𝑏0[𝑖, 𝑗]
Similarly values for red and green components are calculated. These aggregated 2D matrices for each colour components are then stacked over each other to form a 3D matrix i.e. the Encrypted Image.
Fig. 12 a depicts the image formed after stage 1(Rubik’s cube scram- bling) and Fig. 12 b shows the final encrypted image after stage 2(Frame Rotation and Bitplane shuﬄing).
Decryption

The process of reconstructing the original image from the encrypted image using the same two 128-bit keys is briefly described in this sec- tion.
Reverse bitplane shuffiing and frame rotation

Generating bitplanes
Same as Section 4.2.1

Bitplane reverse shuffiing
The shuﬄed bitplanes are reshuﬄed to the original order. This step is similar to the step mentioned in Section 4.2.5. The bitplanes for each colour are reverse shuﬄed as follows:
blue:	shuﬄed order : 0,1,2,3,4,5,6,7 final order : 7,6,5,4,3,2,1,0
green:	shuﬄed order : 8,9,10,11,12,13,14,15 final order: 15,14,13,12,11,10,9,8
red:	shuﬄed order : 16,17,18,19,20,21,22,23 final order: 23,22,21,20,19,18,17,16


Fig. 17. Key Sensitivity Test (a) Original Image (b) Encrypted Image (with k1 and k2) (c) Encrypted Image (with k3 and k4) (d) Difference between Figs. 17 b and 17 c.



Fig. 18. Histogram Analysis (a) Original Image (b) Encrypted Image (c) His- togram of the source image (d) Histogram of the encrypted image.



Reverse frame rotation
For each bitplane, 8-bit sequences are generated, similar to encryp- tion using the two 128-bit key inputs and the same logic for reduction and updating the keys. Here, first the frames are shifted in a circular manner by the offset in anti-clockwise direction and then perform the derived number of rotations, also in anti-clockwise direction.
The bitplanes are then integrated and sent to the next step.

Rubik’S cube unscrambling

The image received after the above processing is again divided into n x n sized blocks. The two 128-bit keys K1 and K2 are used to get started with the first block-row. They generate a sequence of 32 operations with the help of the 2D operations matrix for decryption. The same logic is applied for updating the keys Fig. 13.
This entire process is applied for three rounds. In the first round, the block size is 64x64, the block size in the next image is 32x32 and for the last round, the image is divided into 16x16 sized blocks. At the end of this step, the original image i.e. the decrypted image is retrieved.

Algorithms

For this version of the algorithm, perform the Rubik’s cube encryp- tion for 3 rounds with 3 different values of n:
1st round: n = 16
2nd round: n = 32 3rd round: n = 64
The diagrammatic representation of the encryption process can be seen in Fig. 14.

Results and discussion

In order to test the algorithm’s performance on images from various categories, it is applied to a range of images. The RBF algorithm was implemented on pictures of monuments, portraits, animals, and even x-rays. This section discusses the results of these implementations. This section also includes demonstrations of several analysis tests. The results demonstrate how the proposed encryption technique is applicable across a wide range of domains. The source image, the resultant encrypted image and the final decrypted picture of various different images are displayed in Fig. 15.
It can be seen that the encrypted image successfully converts the original source image into a random assortment of pixels, rendering it


	

Algorithm 1: Rubik’s Encryption.


Data: img, encMatrix, n, k1, k2 k1Reverse = reverse(k1) K2Reverse = reverse(k2)
sequence = sequenceGeneration(encMatrix, k1, k2) sequence1 = sequenceGeneration(encMatrix, k1Reverse, k2Reverse)
foreach nxn sized block row do foreach nxn sized block do
blockMatrix = values of the nxn sized block
sequenceCalculation(sequence, blockMatrix) sequenceCalculation(seq1, blockMatrix)Update the corresponding block in the img with the values of the modified blockMatrix
end
newK1 = keyUpdation(k1) newK2 = keyUpdation(k2) newK1Reverse = reverse(newK1)
newK2Reverse = reverse(newK2)newSequence = sequenceGeneration(encMatrix, newK1, newK2) newSequence1 = sequenceGeneration(encMatrix, newK1Reverse, newK2Reverse)
end
return img



Algorithm 2: sequenceGeneration.


Data: s, k1, k2
⊳ s - list of possible operations
sequence = []
for i from 0 to 128 step 4 do
num = substring of k1 from i to i + 3
num = int(num) + 1operationIndex = substring of k2 from i to i + 3
operationIndex = int(operationIndex)
operation = s[operationIndex]append (str(num) + operationIndex) to sequence
end
return sequence



Algorithm 3: sequenceCalculation.


Data: sequence, blockMatrix
foreach term in sequence do
row/column index = integer part of termoperation = remaining part of termapply the operation on the row/column of the block_matrix
end
return blockMatrix



impossible to identify the original image in any way while maintain- ing the image’s integrity. To accurately evaluate the algorithm’s per- formance, a number of additional analyses are carried out. Time com- plexity, key sensitivity analysis, histogram analysis, and recoverability analysis are all used to evaluate the algorithm.


Time complexity

The time complexity of an algorithm is primarily the total time re- quired for the encryption algorithm to encrypt an image. The total time increases as the size of the image gets larger. Thus the time complexity is a function of the size of the image. The following results display the time recorded for the encryption process for various images.
Algorithm 4: Bitplane Shuﬄing.


Data: image, k1, k2
bp = generate bitplanes from image reducedK1, reducedK2 = keyReduction(k1, k2)
newBp = frameRotation(bp, reducedK1, reducedK2)
//for each color in (R,G,B)
for i in [1,2,3] do
bp[0*i] = new_bp[7*i] bp[1*i] = new_bp[6*i] bp[2*i] = new_bp[5*i] bp[3*i] = new_bp[4*i] bp[4*i] = new_bp[3*i] bp[5*i] = new_bp[2*i] bp[6*i] = new_bp[1*i] bp[7*i] = new_bp[0*i]
end
image = generate image from bitplanes bp return image



Algorithm 5: frameRotation.


Data: bp, k1, k2
newK1, newK2 = k1, k2
foreach frame in image do
i = frame number
newK1, newK2 = keyUpdation(k1, k2, newK1, newK2, i)
foreach bitplane in bp do
j = bitplane number //0–24
noOfRotations, offset = frameRotationSeqGeneration(k1, k2)x = noOfRotations * imgDimensions + offset newBp[j] = shift the contents of ith frame of bp[j] by x places
end end
return newBp




Algorithm 6: frameRotationSeqGeneration.


Data: k1, k2
newK1, newK2 = k1, k2
for i from 0 to len(k1) in steps of 4 do
noOfRotations = int(k1[i] + k2[i+3])
offset = int((substring of k1 from i+1 to i+3)+(substring of k2 from i to i+2))
end
return noOfRotations, offset




Algorithm 7: keyUpdation.


Data: k1Original, k2Original, k1, k2, i left shift k1 by 1
left shift k2 by 1k1 = k1 exor k2Original
k2 = k2 exor k1Originalflip digit at ith position in k1 and k2return k1, k2



Algorithm 8: keyReduction.


Data: k1, k2
foreach char in k1 and k2 do
if the position of char is multiple of 4 then
discard the char
else
append the char to newK1 and newK2
end end
return newK1, newK2







Fig. 19. Histogram Analysis (a) Original Image (b) Encrypted Image (c) Histogram of the source image
(d) Histogram of the encrypted image.





Fig. 20. Recoverability (a) Original Image (b) Decrypted Image (c) Difference between 20 a and 20 b.



The graphical representation of the total time vs the size of the image is shown in Fig. 16.

Key sensitivity analysis

In this section, the aforementioned algorithm’s sensitivity to changes in the user’s initial two 128-bit keys is put to the test. The source image is encrypted with two different key combinations to get the resultant encrypted images. Then to test the sensitivity, the difference between those two encrypted images is taken.
keys k1 and k2, taken for the first case are: k1=“01010100011010000 Fig. 17 a shows the source image selected for encryption. The
11000010111010001110011001000000110110101111001001000000
k2=“1110001000110010111111001111000110010001000100101001 1001011011101010110111001100111001000000100011001110101”
00011000100010110001010110011110010011100110110101100111
10011010001010010011”
Fig. 17 b shows the resultant encrypted image using k1 and k2. The keys taken for the second case for this analysis are:
k3=“1011010001101011011000010111010001110011001001100110
11010111100100100001001010110111010101101110011001110010
00000100011001110101” k4=“111000100011001011111100111100
01100100010010101010010001100010001011000101011001101001
001110011011010110011110011010001010010011”
The resultant encrypted image using the above keys k3 and k4 is shown in Fig. 17 c.
To show that the encrypted image differs greatly based on the keys used for the encryption process, the difference between the images is taken as shown in Fig. 17 b and 17 c. Hence, from Fig. 17 d, it can be concluded that change in the keys affects the results of the designed en- cryption process. Thus it can be said that the algorithm is key sensitive.

Histogram analysis

The distribution of intensity levels for each pixel value in an image is depicted by the histogram for that image. The intensity distribution differs from image to image when the histogram for them is plotted. The encrypted images’ histograms are plotted in order to assess the intensity distribution of the images.
The source image is considered to be a portrait image as shown in Fig. 18 a. The original source image is then encrypted using the algo- rithm and the encrypted image can be seen in Fig. 18 b. Figs. 18 c and 18 d show the resulting histograms for both the images, which display the intensity distribution. Similarly, an x-ray image is analysed as shown in Fig. 19 a. The corresponding encrypted image can be seen in Fig. 19 b. The histograms depicting the intensity distribution for both the images are generated as shown in Figs. 19 c and 19 d. It is observed that af- ter encryption, a similar but not same, bell shaped distribution for the images is obtained. Additionally, it is observed that the intensity distri- bution of the encrypted images is considerably more uniform than that of the original image.

Recoverability test

For any encryption algorithm, it is necessary that the algorithm is capable of effectively recovering the original source image after decryp- tion. Thus, for the described encryption algorithm, it is to be proven that the original image is generated after decryption, using the same keys as






Fig. 21. Recoverability (a) Original Image (b) Decrypted Image (c) Difference between 21 a and 21 b.

in encryption. An approach to show 100% recoverability is to subtract the pixel values of the decrypted image from the corresponding pixel values of the original image.
Fig. 20 a shows the original image and its decrypted image can be seen in Fig. 20 b. The difference between the two images is displayed in Fig. 20 c. It is a completely black image that indicates complete and loss- less recoverability of the source image. Fig. 21 shows the same results with another image.
Conclusion

This paper presents a novel approach to image encryption for se- cure image transfer. The RBF algorithm consists mainly of three steps
- ‘Rubik’s Cube Scrambling ’, ‘Bitplane Frame Rotation ’, and ‘Bitplane Scrambling ’. The Rubik’s cube scrambling principle is successfully in- corporated into the proposed encryption algorithm, thus introducing a higher degree of randomness. As a future scope, the Rubik’s cube scram- bling can be done on nxn sized blocks with n as 32, 64 and 128 rather than 16, 32 and 64. This will help induce a greater degree of randomness in large images. The length of the scrambling sequence and hence, the size of the keys can also be changed accordingly. The complexity in the first stage is increased by applying the scrambling for three rounds on different-sized blocks. In the second stage, the bit planes of the image are separated and frame rotation is applied to the individual bitplanes. The encryption process is completed by the last stage where the bitplanes are combined according to a definite sequence. The entire process is reversed for the decryption of the image. Two 128-bit keys are taken as input from the user to uniquely encrypt and decrypt the image. This paper also describes a new technique that is employed for updating the keys between steps to increase the randomness.
The combination of these methods helps the algorithm sustain vari- ous attacks. The RBF algorithm is completely lossless as the information in the image can entirely be recovered after decryption. The proposed technique is flexible in nature as it can work on images of any size. The described algorithm is robust in nature and can be used in day-to-day life for a variety of images. The evaluation and analysis of the RBF al- gorithm are explained in depth throughout the paper.
Declaration of Competing Interest

The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
References

G. Kołaczek, J. Mizera-Pietraszko, Security framework for dynamic service-oriented it systems, J. Inform. Telecommun. 2 (4) (2018) 428–448, doi:10.1080/24751839.
2018.1479926.
K. Deshpande, J. Girkar, R. Mangrulkar, Security enhancement and analysis of im- ages using a novel sudoku-based encryption algorithm, J. Inf. Telecommun. 0 (0) (2023) 1–34, doi:10.1080/24751839.2023.2183802.



P. Vörös, D. Csubák, P. Hudoba, A. Kiss, Securing personal data in public cloud, J. Inform. Telecommun. 4 (1) (2020) 51–66, doi:10.1080/24751839.2019.1686684.
Internet Society what is encryption, (https://www.internetsociety.org/issues/ encryption/what-is/).
D. Lambić, S-Box design method based on improved one-dimensional discrete chaotic map, J. Inform. Telecommun. 2 (2) (2018) 181–191, doi:10.1080/
24751839.2018.1434723.
H. Delfs, H. Knebl, Symmetric-Key Cryptography, 2015, pp. 11–48.
M. Blaze, W. Diﬃe, R.L. Rivest, B. Schneier, T. Shimomura, Minimal key lengths for symmetric ciphers to provide adequate commercial security. A report by an ad hoc group of cryptographers and computer scientists, 1996.
M. Agrawal, P. Mishra, A comparative survey on symmetric key encryption tech- niques, Int. J. Comput. Sci. Eng. 4 (2012).
A. Abdullah, Advanced encryption standard (aes) algorithm to encrypt and decrypt data (2017).
N. Kaur, S. Sodhi, Article: data encryption standard algorithm (des) for secure data transmission, IJCA Proc. Int. Conf. Adv. Emerg. Technol. ICAET 2016 (2) (2016) 31–37. Full text available
R.L. Rivest, The rc5 encryption algorithm, in: B. Preneel (Ed.), Fast Software Encryp- tion, Springer Berlin Heidelberg, Berlin, Heidelberg, 1995, pp. 86–96.
B. Rahul, K. Kuppusamy, Eﬃciency analysis of cryptographic algorithms for image data security at cloud environment, IETE J. Res. 0 (0) (2021) 1–12, doi:10.1080/
03772063.2021.1990141.
Twisty puzzle scramble generators, (https://ruwix.com/puzzle-scramble- generators/).
M. Deutsch, How to fairly scramble a rubik’s cube, 2017, (https://medium. com/@maxdeutsch/m2m- day- 88-how-to- fairly- scramble- a- rubiks- cube- 8c715f3
8475a#:∼:text=Each%20scramble%20is%20expressed%20using,of%20the%
20cube%20180%20degrees%E2%80%9D).
R.V. Mudduluri, A. Golla, S. Raghava, T.J. Sai, Advanced image encryption & de- cryption using Rubik’s cube technology, Int. J. Eng. Adv. Technol. (IJEAT) 11 (3) (2022) 24–27, doi:10.35940/ijeat.C3331.0211322.
l. Zhang, X. Tian, S. Xia, A scrambling algorithm of image encryption based on rubik’s cube rotation and logistic sequence, volume 1, 2011, pp. 312–315, doi:10.1109/ CMSP.2011.69.
X. Feng, X. Tian, S. Xia, An improved image scrambling algorithm based on magic cube rotation and chaotic sequences (2011). doi:10.1109/CISP.2011.6100274.
A.-V. Diaconu, K. Loukhaoukha, An improved secure image encryption algorithm based on rubik’s cube principle and digital chaotic cipher, Math. Probl. Eng. 2013 (2013) 1–10, doi:10.1155/2013/848392.
K. Loukhaoukha, N. Makram, K. Zebbiche, An eﬃcient image encryption algorithm based on blocks permutation and rubik’s cube principle for iris images, 2013, doi:10. 1109/WoSSPA.2013.6602374.
S. Mozaffari, Parallel image encryption with bitplane decomposition and genetic algorithm, Multimed. Tools Appl. 77 (19) (2018) 25799–25819.
Y. Zhou, W. Cao, C. Chen, Image encryption using binary bitplane, Signal Process. 100 (2014) 197–207, doi:10.1016/j.sigpro.2014.01.020.
S. Madhu, N. Kumari, Novel approaches for selection of bitplanes in image encryp- tion, 2019.
A. Houas, B. Rezki, Z. Mokhtari, An encryption algorithm for grey-scale image based on bit-plane decomposition and diffuse representation, J. Discr. Math. Sci. Cryptogr. 24 (1) (2021) 35–47, doi:10.1080/09720529.2019.1664382.
Q. Sun, W. Yan, J. Huang, W. Ma, Image encryption based on bit-plane decom- position and random scrambling, in: 2012 2nd International Conference on Con- sumer Electronics, Communications and Networks (CECNet), 2012, pp. 2630–2633, doi:10.1109/CECNet.2012.6201673.
M. Podesser, H.-P. Schmidt, A. Uhl, Selective bitplane encryption for secure trans- mission of image data in mobile environments, Fifth IEEE Nordic Signal Process. Sympos. (2002).
Y. Liu, Q. Zhong, J. Shen, C.-C. Chang, A novel image protection scheme using bit- plane compression and secret sharing, J. Chinese Inst. Eng. 40 (2) (2017) 161–169, doi:10.1080/02533839.2017.1294994.
S. Mozaffari, Parallel image encryption with bitplane decomposition and ge- netic algorithm, Multimed. Tools Appl. 77 (2018), doi:10.1007/s11042-018-
5817-8.
C. Naveen, V.R. Satpute, Image encryption technique using improved a5/1 cipher on image bitplanes for wireless data security, in: 2016 International Conference on Microelectronics, Computing and Communications (MicroCom), 2016, pp. 1–5, doi:10.1109/MicroCom.2016.7522451.
K.-M. Chen, C.-C. Chang, High-capacity separable reversible data-hiding method in encrypted images based on block-level encryption and huffman compres- sion coding, Conn. Sci. 33 (4) (2021) 975–994, doi:10.1080/09540091.2021.
1926930.
W. Song, C. Fu, Y. Zheng, M. Tie, J. Liu, J. Chen, A parallel image encryption al- gorithm using intra bitplane scrambling, Math. Comput. Simul. 204 (2023) 71–88, doi:10.1016/j.matcom.2022.07.029.
Y. Zhou, K. Panetta, C. Chen, Image encryption using p-fibonacci transform and decomposition, Opt. Commun. 285 (2012) 594–608, doi:10.1016/j.optcom.2011.
11.044.
A. Kumar, P. Singh, Aggrandize bit plane coding using gray code method, Int. J. Comput. Appl. 20 (2011) 44–49, doi:10.5120/2434-3273.
Y. Zhou, K. Panetta, S. Agaian, Image encryption algorithms based on generalized p-gray code bit plane decomposition, in: 2009 Conference Record of the Forty-Third Asilomar Conference on Signals, Systems and Computers, 2009, pp. 400–404, doi:10. 1109/ACSSC.2009.5469840.
