

Electronic Notes in Theoretical Computer Science 265 (2010) 403–421
www.elsevier.com/locate/entcs
A Nominal Relational Model for Local Store
Rasmus Ejlers Møgelberg 1
IT University of Copenhagen Denmark

Abstract
The theory of nominal sets is a theory for names, freshness and binders. It has recently been suggested as a framework for modelling local store because it allows for a more elementary development than the traditional presheaf models. However, when modelling the important principle of relational reasoning for local store all these models use families of relations indexed by relations on store, and thus essentially return to presheaf models on the relational level. In this paper we show how relational reasoning can also be modelled using nominal sets. Building on a model suggested by Pitts and Shinwell we construct a relational model for local store in nominal sets in which types are interpreted as relations. These relational interpretations of types capture, in a single relation for each type, the relational reasoning principle for local store which in previous models was captured using a family of relations for each type. The relational model also demonstrates how the relations constitute a model in their own right, which hopefully means that they can be used to construct better models. Using the relational model we construct a relational parametricity principle for the operation allocating local store, and we show how this implies the relational reasoning principle.
Keywords: local store, denotational semantics, parametric polymorphism, nominal sets


Introduction
Most programming languages contain a construction for declaring local store, i.e., store cells that can only be accessed by a specified piece of the program. This restriction of access provides an important information hiding principle: changes to an implementations internal use of local store should not affect the observable behaviour of the program. When constructing tools for reasoning about local store a challenging issue is to express the information hiding principle. One idea that has proved useful is relational reasoning: if two programs are implemented using local store, and we can show that there exists a relation between the local stores preserved by the programs, then the programs should be contextually equivalent. This method of proof goes back at least to [12]. Relational reasoning can be proved sound using either syntactic or denotational methods.

1 This work was supported by the Danish Agency for Science, Technology and Innovation

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.024

Traditionally, denotational models of local store have used presheaf categories [11,16,6,14] interpreting types as families of sets indexed over store shapes, i.e., finite sets of cell names. Recently an alternative approach using a continuation monad on the category of nominal sets [5] has been suggested [17,1]. The advantage of this new approach is that the technical development is simpler, mainly because the exponentials in the category of nominal sets have a simpler description than the Kripke style exponents of presheaves. The two approaches are related, because the category of nominal sets is equivalent to a full subcategory of a presheaf topos [5]. In the nominal sets models of local store [1,2] soundness of the relational rea- soning principle is proved by constructing, for each type, a family of relations on the denotations of the type, indexed by relations on store, and verifying that the relations corresponding to identity relations on store are contained in contextual equivalence. The construction uses Kripke semantics as one has to take into ac- count that any program can be called at a later time where the store contains more cells. This technique has been successful in creating a useful tool for showing contex- tual equivalence, but at the moment these relations seem like a trick for obtaining
better equational theories on a given model, and their semantic status is unclear.
This paper shows how relational reasoning can be build into nominal sets, and settle the semantic status of the relations by showing that they form a model in their own right. We start by considering a variant of the model of local store used in [1] and then show how a model of relations capturing relational reasoning for local store can be constructed in a very similar way. The key observation for our construction is that the category of nominal sets used in the first model is equivalent to a category of sets indexed over store shapes. Using sorted nominal sets we construct a category of nominal sets equivalent to a category of sets indexed by relations on store, and use this as basis for the relational model. The resulting model can be seen as a nominal representation of the relational presheaf models of [10,9,3].
We treat ground store only. Other authors (e.g. [1,2]) have considered relational reasoning for more advanced notions of store, but we leave it to future work to extend the techniques here to those cases.
Parametricity for store access operations
Earlier work in the context of presheaf models [10,9,3] has show a connection be- tween local variables and relational parametricity: a procedure can be called in any extension of the store that it is defined in, and it is relationally parametric in this store extension. In this paper we approach the connection between parametricity and local variables from another angle, by showing that the relational reasoning principle for local store follows from a principle of relational parametricity for the operation allocating store cells.
The allocation operation is an algebraic operation [14], and we briefly recall what this means. If T is a (strong) monad, following [8], we think of T (X) as the collection of computations returning values in X. Effectful computations can then arise from algebraic operations or equivalently generic effects [15]. The former are functions that take computations as input and produce computations, e.g. in the

case of store effects we consider operations
updateb,X : T (X) → ref b → b → T (X)	(1)
lookupb,X : (b → T (X)) → ref b → T (X)	(2)
Intuitively, update takes a computation, a reference to a storage cell of type b, a value of type b, and returns the computation that first updates the storage cell with the given value and then continues the original computation. The lookup operation takes a family of computations indexed by values of type b and a reference to a storage cell, and returns the computation that looks up the value in the storage cell and continues with the corresponding computation.
The algebraic operation corresponding to allocation has type
newX,b : [Ab]T (X) → b → T (X)	(3)
For the moment the type [Ab]T (X) should the thought of as a type of computations in T (X) with a bound name of a reference cell of type b. In Section 3 we shall model this type using atom abstraction in nominal sets. The intuition for newX,b is that it returns the computation that allocates a fresh cell of type b, initializes it to the given value of type b and continues with the given computation with the abstracted name bound to the allocated cell.
The relational model constructed here validates a principle of relational para- metricity for newX,b in the type of the allocated cell. The crucial ingredient in formulating this principle is a relational interpretation of atom abstraction: for any relation r : Rel(b, bj) we construct a relation from [Ab]T (X) to [Ab′ ]T (X), which intuitively relates two computations with bound cell names if they preserve the re- lation r (this is to be understood in the sense of the relational reasoning principle for local store). The relational reasoning principle for local store can be seen as a consequence of this parametricity principle.
Section 2 fixes a language with local store, and Section 3 describes a model in nominal sets. Section 4 construct a relational model and shows how this can be used to reason about contextual equivalence. Section 5 describes connections to relational parametricity, and Section 6 gives two examples of using the relational model to show contextual equivalence of programs. Finally Section 7 sketches how a variant of the relational model construction can allow for reasoning using more advanced relations on store.
A call-by-value language with local store
We start by fixing a language in which we can write sample programs to illustrate the semantic developments. For this we could have chosen some advanced type theory for effects such as call-by-push-value [6] or the enriched effect calculus [4] and in fact the semantic construction of this paper can be used to construct models of these, but here we choose a simple call-by-value language because it suffices for our purposes.


	
Θ | Γ,x : σ, Γj ▶v x : σ	Θ,a : b, Θj | Γ ▶v a : ref b

Θ | Γ ▶v V : σ


Θ | Γ ▶c return V : σ
Θ | Γ ▶c M : σ	Θ | Γ,x : σ ▶c N : τ

Θ | Γ ▶c M to x. N : τ

Θ | Γ ▶v V : σ ~ τ	Θ | Γ ▶v W : σ


Θ | Γ ▶c V W : τ
Θ | Γ,x : σ ▶c N : τ

Θ | Γ ▶v λx : σ. N : σ ~ τ

Θ | Γ ▶c N : τ	Θ | Γ ▶v V : b	Θ | Γ ▶v W : ref b

Θ | Γ ▶c W := V ; N : τ
Θ | Γ,x : b ▶c N : τ	Θ | Γ ▶v W : ref b

Θ | Γ ▶c readW as x. N : τ

Θ,a : b | Γ ▶c N : τ	Θ | Γ ▶v V : b Θ | Γ ▶c let a : b = new (V ) in N : τ

Fig. 1. Typing rules for the Fine-Grained-CBV calculus with local store
The language we consider here is a variant of Fine-Grained CBV [7] (Fine- Grained call-by-value) to which we have added local store. We assume given a set Σ of base types and we use b to range over elements of Σ. The types are given by
σ, τ ::= b | ref b | σ ~ τ
The type ref b is a type of references to cells of type b. In this paper we only consider references to base types. The type σ ~ τ is a call-by-value function space; elements take values as input and produce computations.
Rather than giving an operational semantics we give an equality theory on terms to be considered as an approximation of contextual equality in the spirit of [13]. Because of the presence of effects it is important to specify evaluation order in the language, and for this the language distinguishes between (pure) values terms and computations terms, each of which has its own typing judgement written as
Θ | Γ ▶v V : σ	Θ | Γ ▶c M : σ
respectively. Only computations are allowed to access store.
Typing rules can be found in Figure 1. Open terms have two contexts. The first is a context of variables x : A in the usual sense for which we use Γ as a metavariable. Variables in this context should be thought of as place holders for values. The second context is one of names a : b for which we use Θ as a metavariable. This should be thought of as a list of references to previously allocated distinct cells in the store.
Figure 2 presents an equality theory on terms of Fine-Grained-CBV with local


return V to x. N = N [V/x]
M to x. return x = M
(M to x. N ) to y. P = M to x. (N to y. P )
λx : σ. M (V ) = M [V/x]
λx : σ. (V x) = V
(readW as z. M ) to x. N = readW as z. (M to x. N ) (W := V ; M ) to x. N = W := V ; (M to x. N )
(let a : b = new (V ) in M ) to x. N = let a : b = new (V ) in (M to x. N ) readW as x. (W := x; M ) = M
readW as x. readW as y. M = readW as x. M [x/y] W := V ; W := V j; M = W := V j; M
W := V ; readW as x. M = W := V ; M [V/x]
reada as x. reada′ as y. M = reada′ as y. reada as x. M a := V ; aj := V j; M = aj := V j; a := V ; M
a := V ; reada′ as x. M = reada′ as x. a := V ; M
let a : b = new (V ) in (a := V j; M ) = let a : b = new (V j) in M
let a : b = new (V ) in (reada as x. M ) = let a : b = new (V ) in M [V/x]
let a = new (V ) in (let aj = new (V j) in M ) = let aj = new (V j) in (let a = new (V ) in M ) let a : b = new (V ) in (W := V j; M ) = W := V j; let a : b = new (V ) in M
let a : b = new (V ) in (readW as x. M ) = readW as x. let a : b = new (V ) in M
let a : b = new (V ) in M = M ,	a ∈/ FV(M )

Fig. 2. The Fine-Grained-CBV calculus. The equality rules are subject to the usual conventions on free variables. Moreover, all rules assume a and a′ distinct and the last rule requires a not free in M .

store. The equality theory consist of three different elements: the first five rules are equality rules of Fine-Grained-CBV [7], the next three are algebraicity axioms [15], and the final 13 axiom schemes are the Plotkin-Power axioms for local store [14].
The axioms of Figure 2 provide basic axioms for local store, but do not capture the information hiding principle sketched in the introduction. To illustrate what is needed we give an example of two programs that should be contextually equivalent, but cannot be proved so using the axioms. In Section 6 we show how to prove this using the relational reasoning tools developed in this paper. We stress, however, that this is a standard example of programs that have been proved contextually equivalent, e.g. in [1], but the example is included here for illustration.
Consider the two counters defined as
let a : Int = new (0) in return (λx : Int. reada as z. a := z + x; return (z + x)) let a : Int = new (0) in return (λx : Int. reada as z. a := z − x; return (x − z))
Both of these are computations of type Int ~ Int which compute functions, that

given an integer x return the sum of the integers by which they have been called previously. They also both accomplish this task by allocating a local store cell, but where the first counter keeps the sum of the previous x’s in that local cell, the second counter keeps the negative of this number.
To prove these programs contextually equivalent one usually uses relational rea- soning: consider the relation on stores relating s to sj if s(a)= −sj(a). If we imagine the two counters being run on parallel machines with stores in this relation, then each pair of calls to the counters with equal inputs not only gives equal outputs, but also leaves the stores related. Using the techniques of [12,1] this suffices for showing the programs equivalent.

A model in nominal sets
We construct an interpretation of the Fine-Grained CBV calculus with local store using nominal sets [5]. The interpretation is a variant of the one used in [17,1]. We assume that we are given for each b ∈ Σ an interpretation of b as a set [b]]. Moreover we assume that we are given a sorted collection of atoms by which we mean a map of sets A → Σ, such that for each sort b there are infinitely many atoms mapping to b by the sorting function. We shall think of a sorted collection of atoms as a signature for a typed store. The set A is the set of cells and the sorting maps a cell to the type of the content stored in that cell. The set of atoms with sort b is denoted Ab, and we often write ab to indicate that a is an atom of sort b. Given a sorted collection of atoms A → Σ we can form the category of nominal sets, which we denote Nom or sometimes Nom[A→Σ] when the atom sorting is not clear from context, as usual. First we consider the group Perm(A → Σ) of finite permutations (i.e. permutations fixing all but a finite number of elements) of A respecting sortings. The category Nom has as objects sets with a left Perm(A → Σ)-action, ie., a map · : Perm(A → Σ) × X → X such that (π ◦ πj) · x = π · (πj · x) and id · x = x such that each x in X has a finite support, i.e. a finite set A of atoms such that if π fixes all elements of A then π · x = x. It is well known that Nom is a cartesian closed category with exponent given by the set of finitely supported functions with respect to the action defined by (π · f )(x)= π · (f (π—1 · x)), see [5]. We write A × B and A →fs B or BA for the cartesian closed structure on the category of nominal sets and reserve A → B for the set of functions with empty support between a pair of nominal sets. We write x ∈ X for X a nominal set if x
is an element in the underlying set of X.
As in [17,1] we use a cps style semantics, because it greatly simplifies the inter- pretation of allocation. So we assume given a nominal set R of results, which has trivial permutation action. The set A is a nominal set with the obvious action and recalling that each sort b has an interpretation as a set, we can consider each of these a nominal set with trivial permutation action.
We define the nominal set of stores as
S = Qb∈Σ Ab →fs [[b]].


[[readW as x. N ]]ρ(k)(s) = [N ]]ρ[x'→s([[W ]]ρ)](k)(s)
[[W := V ; N ]]ρ(k)(s) = [N ]]ρ(k)(s[[[W ]]ρ '→ [[V ]]ρ])
[[let a : b = new (V ) in N ]]ρ(k)(s) = fresh ab. [[N ]]ρ[a'→ab](k)(s[ab '→ [[V ]]ρ])

Fig. 3. Interpretation of store access operations.

Note that by this product we mean the product in Nom, i.e., we only consider elements f with a finite set of atoms which supports all of the fb : Ab →fs [[b]]. We usually assume that all the sets [b] are non-empty as otherwise S becomes empty. A continuation is a map that takes a store and produces a result in R, however,
by our definition of S, stores are infinite and intuitively, computable continuations can only look at finite subsets of the store. The restriction to finitely supported functions is not sufficient to ensure this restriction, as, e.g., maps counting the number of cells holding a specific value are finitely supported (in fact equivariant). Instead we define our collection of continuations to be the nominal set
K = {k : RS | ∃A ⊆fin A. ∀s, sj ∈ S. (∀a ∈ A. s(a)= sj(a)) =⇒ k(s)= k(sj)} .  (4)
This restriction has important consequences for the model and is also crucial for the construction of the relational model.
Lemma 3.1 If k ∈ K and s, sj ∈ S agree on the support of k, then k(s)= k(sj).
We interpret Fine-Grained CBV using the monad T = KK(−) on Nom. The type ref b is interpreted as Ab and σ ~ τ is interpreted as [σ]] → T ([[τ ]]). Value terms Θ | Γ ▶v V : σ are interpreted as equivariant maps [[Θ]]× [Γ]] → [[σ ] and computation terms Θ | Γ ▶c V : σ are interpreted as equivariant maps [[Θ]] × [Γ]] → T ([[σ]]). The context Γ is interpreted as usual using products, but following the intuition given in Section 2, a name context Θ = a1 : b1,..., an : bn is interpreted as the set ⊗bi∈bAbi of tuples (a1,..., an) of distinct elements with ai ∈ Ab . This is a special case of
the tensor product on Nom:
A ⊗ B = {(x, y) | x y}	(5)
where x y means that x, y have disjoint support.
We omit the details of the standard monadic interpretation and focus on the interpretation of the operations on store. The interpretations are given in Figure 3. In the figure we use environments ρ which are maps specifying elements in [[Θ]] × [Γ]] in the hopefully obvious way. Also the notation s[ab '→ n] is used for updating s at
location ab, where s ∈ S, i.e., s[ab '→ n](aj ) is n if aj = ab and s(aj ) otherwise.
b	b	b
We have used similar notation for updating the environment ρ.
In the interpretation of cell allocation we have used the notation fresh ab. This means: pick some ab not in the support of k, s, ρ and compute the element to the right of the fresh statement. Of course, for this to be well defined, one must show

that the element on the right is independent of the particular choice of ab, which can be done using standard techniques from nominal set theory.
Proposition 3.2 The model validates the axioms of Figure 2.
The last axiom of Figure 2 (garbage collection) does not hold in the model of [1], but can only be verified up to relational reasoning. The reason it holds in this model is the restriction to continuations in K.
Proof. We verify the garbage collection axiom. The condition of a not free in M means that Θ | Γ ▶c M : σ is well typed. A simple induction shows that [[Θ | Γ ▶c M : σ]]ρ = [[Θ,a : b | Γ ▶c M : σ]]ρ[a'→a ]. In particular this means that if ab is fresh for ρ and k then it is also fresh for [[Θ,a : b | Γ ▶c M : σ]]ρ[a'→a ](k) which
is an element in K. We compute
[[let a : b = new (V ) in M ]]ρ(k)(s)
= fresh ab. [[Θ,a : b | Γ ▶c M : σ]]ρ[a'→a ](k)(s[ab '→ [[V ]]ρ])
= fresh ab. [[Θ,a : b | Γ ▶c M : σ]]ρ[a'→a ](k)(s)
= [[Θ | Γ ▶c M : σ]]ρ(k)(s) .
The equality between line 2 and 3 is a consequence of Lemma 3.1.	2

Algebraic operations for local store
The interpretation of local store in Figure 3 can be read as defining algebraic oper- ations for local store for the monad T in the sense of Plotkin and Power [14]. The types of these were suggested in the introduction (1, 2, 3), but in fact, we can give these more general types, defining e.g.,
updateb,X : KX → Ab →fs [[b]] →fs KX
lookupb,X : ( [b]] →fs KX ) → Ab →fs KX
for all nominal sets X. The operations are defined as
updateb,X (f )(ab)(v)= λx : X. λs : S. f (x)(s[ab '→ v])
lookupb,X (f )(ab)= λx : X. λs : S. f (s(ab))(x)(s)
As mentioned in the introduction, the algebraic operation for cell allocation takes a computation with a bound cell name as input. Since the result of applying the operation should not depend on the name of the abstracted cell, the appropriate input type is given by atom abstraction [5]. Recall that the atom abstraction [Ab]X is defined as the quotient Ab × X/ ∼ where (a, x) ∼ (aj, xj) if (a ajj) x = (aj ajj) xj for some (indeed any) fresh ajj. Recall also that there is a concretion map (−)@ (=): [Ab]X ⊗ Ab → X defined as [(a, x)]@ aj = (a aj) x. Note that this is only well defined for aj fresh for [(a, x)], i.e., for aj ∈/ supp(x) \ {a}.

Now, the algebraic operation for allocating a fresh storage cell has type
newX,b : [Ab]KX → [[b]] →fs KX
and is defined as newX,b(f )(v)= λx : X. λs : S. fresh ab. (f @ ab)(x)(s[ab '→ v]) .
Algebraic operations correspond to generic effects [15]. The update and lookup correspond to maps Ab × [[b]] → T (1) and Ab → T ([[b]]) respectively. Following Staton [18], one can describe allocation using a family of generic effects of type
allocb,⊗iAb : ⊗i Abi × [[b]] → T ((⊗iAbi ) ⊗ Ab) .	(6) These can be thought of as maps computing an extended context from a given one.
A relational model construction
In this section we construct a relational model of Fine-Grained CBV with local store. The construction is similar to that of Section 3 except that we pass from sets to relations. We do this first for the base types. Suppose that we are given a set of base types Σ and an interpretation of each base type as a set, as in Section 3. Consider the set of relations
ΣRel = {(b, bj, R) | b, bj ∈ Σ,R : Rel( [b]], [[bj]]), R non-empty} .

The restriction to non-empty relations is necessary to get an interesting model (if we omit it, the KRel defined below becomes the total relation, relating all pairs of continuations) and is similar to the restriction that [b] is non-empty. We use r as a metavariable to range over ΣRel and also use r for the relation part of the triple. We assume that we are given a sorted collection of atoms p : ARel → ΣRel (we call the sorting p because the main example is the projection ΣRel × N → ΣRel). To give some intuition for why Nom[ARel→ΣRel] is an interesting category to consider, we recall the relationship between nominal sets and presheaf categories [5]. Suppose we are given a sorted collection of atoms A → Σ as in Section 3, following the intuition that this is a signature for typed store, we define a store shape to be a finite subset of A. An object in Nom[A→Σ] defines a family of sets indexed by store shapes,
namely the family {x ∈ X | supp(x) ⊆ A}A⊆fin A.
Similarly, we may consider finite subsets of ARel to be simple finite relations on stores, namely A describes the relation relating s to sj if r(s(ar), sj(ar)) holds for all ar ∈ A. This way, an object of Nom[ARel→ΣRel] can be considered as a family of sets indexed by relations on stores. For relational reasoning for local store we need families of relations indexed over finite relations on stores, and in this paper we shall consider relations in Nom[ARel→ΣRel]. The relations on local store described above are extremely simple, but we have chosen this simplicity for presentation purposes. In Section 5 we sketch how to extend this idea to more advanced relations on store.
Following the intuition above it is tempting to define a relation on store objects

as follows: writing Sdom and Scod for Q

r∈Σ
Rel ARel → dom(r) and Q

r∈Σ
Rel ARel →

cod(r) respectively define SRel : Rel(Sdom, Scod) by
SRel(s, sj) ⇐⇒ ∀ar ∈ ARel. r(s(ar), sj(ar))
Unfortunately the SRel so defined is empty. However, we can define a relation on con- tinuations as follows. Consider first the continuation objects Kdom ⊆ RSdom , Kcod ⊆ RScod defined as in Section 3 and define
KRel = {(kd, kc) ∈Kdom × Kcod | ∃A ⊆fin ARel. ∀sd, sc.
(∀ar ∈ A. r(sd(ar), sc(ar))) =⇒ kd(sd)= kc(sc)}
The relation KRel satisfies an equivariance property: if π is a finite permutation re- specting the atom sorting ARel → ΣRel then KRel(kd, kc) holds iff KRel(π · kd,π · kc).
Note the similarity of the definition of KRel to (4).
Lemma 4.1 Let kd ∈ Kdom, kc ∈ Kcod be given. Then (kd, kc) ∈ KRel iff
(∀ar ∈ supp(kd) ∪ supp(kc). r(sd(ar), sc(ar))) =⇒ kd(sd)= kc(sc)
for all sd ∈ Sdom and sc ∈ Scod.
At the moment we have several atom sortings in play. Apart from the given one p : ARel → ΣRel there are the two compositions of p with the domain and codomain map dom ◦ p, cod ◦ p : ARel → Σ. There is a pair of functors
Nom[dom ○ p]  ) Nom[ARel→ΣRel] (  Nom[cod ○ p] ,
given simply by restriction of permutation action.
We now define the category Rel which will be the base for the relational model of local store. Following the intuition given in the beginning of this section, Rel can be thought of as a category of relations indexed by relations on stores.
Definition 4.2 The category Rel has
Objects: Triples (X, Y, Q) where X, Y are objects of Nom[dom ○ p] and Nom[cod ○ p] respectively and Q is an equivariant (in the sense of Nom[ARel→ΣRel]) subset of X × Y .
Morphisms: A morphism from (X, Y, Q) to (Xj,Y j, Qj) is a pair of maps f : X → Xj and g : Y → Y j in Nom[dom ○ p] and Nom[cod ○ p] respectively, such that (f, g) map pairs related in Q to pairs related in Qj.
The triple (Kdom, Kcod, KRel) defines an object of Rel by the equivariance prin- ciple noticed above. Any element of ΣRel defines an object of Rel in the obvious way. For any r we can define a relational interpretation of atoms. Define first (with a slight misuse of notation)


Rel dom(r)
Rel cod(r)
= {a | dom(p(a)) = dom(r)}	(7)
= {a | cod(p(a)) = cod(r)}	(8)

with permutation actions given by application. The relation is given (as a span) by the inclusion of ARel = {a | p(a)= r} into both these sets. This defines an object of Rel for which we shall often simply write ARel. In general, we shall usually simply denote objects of Rel simply by their third component.
Proposition 4.3 The category Rel is cartesian closed and the domain and codomain functors

Nom[dom ○ p] (	 Rel 	) Nom[cod ○ p]	(9)

preserve the cartesian closed structure.
Proof. The products of two relations relate pairs whose components are related. The exponent: (X, Y, Q) → (Xj,Y j, Qj) is the triple (X →fs Xj,Y →fs Y j, QjQ) where the first two components are constructed using exponents in Nom[dom ○ p] and Nom[cod ○ p] respectively, and QjQ(f, g) holds if Q(x, y) implies Qj(f (x), g(y)).  2
The tensor products on Nom[dom ○ p] and Nom[cod ○ p] (5) extend to a tensor product on Rel: the tensor of two relations relates pairs whose components are related.
We now describe how Fine-Grained-CBV can be interpreted in Rel. Each base type b is interpreted as the identity relation eq[[b]] on the set [b]] and ref b is

interpreted as ARel
[[b]]
.  The rest of the types are interpreted using the cartesian

closed structure on Rel and the monad T
Rel
K(−)
= K Rel . Since the projections (9)

preserve all this structure, the interpretation of a type σ in the relational model is a
relation [σ]]Rel : Rel( [σ]]dom, [[σ]]cod) where [σ]]dom and [σ]]cod are the interpretations of σ as defined in Section 3 using the atom sortings dom and cod respectively.
Variable contexts Γ can be interpreted using the products in Rel. Name contexts Θ= a1 : b1,..., an : bn are interpreted as ⊗iAeq . The following “logical relations
i
lemma” gives the interpretation of terms in the relational model.
Proposition 4.4 If Θ | Γ ▶v V : σ and Θ | Γ ▶c M : σ then
([[V ]]dom, [[V ]]cod) : [[Θ]]Rel × [Γ]]Rel → [[σ]]Rel
([[M ]]dom, [[M ]]cod) : [[Θ]]Rel × [Γ]]Rel → T Rel([[σ]]Rel)
where [[−]]dom, [[−]]cod denote the interpretations of terms in the model of Section 3 using the atom sortings dom and cod respectively.
Proposition 4.4 is proved by induction over the typing rules, but we omit the details. Most cases follow from the fact that the interpretation of Fine-Grained- CBV is given by the cartesian closed structure and the monad, and both projections of (9) preserve this structure. This leaves the operations for local store, and these cases follow from Theorem 5.1 below.

Approximating contextual equivalence
The semantic relations constructed above define an equality relation on computation terms: if Θ | Γ ▶c M, N : σ, we write M ∼σ N if
([[M ]]dom, [[N ]]cod) : [[Θ]]Rel × [Γ]]Rel → T Rel([[σ]]Rel)
In the following we shall show that this defines an equivalence relation on terms and that it is contained in contextual equivalence.
Is the semantic relation [σ]]Rel an equivalence relation? At the moment it is not even an endorelation. Under reasonable assumptions however, we can make [σ]]Rel an endorelation. Consider the map (−)op : ΣRel → ΣRel which maps a relation to its opposite. For the rest of the paper we shall assume that there is a lift of this map to atoms, i.e., a map making the diagram commute


Rel  (−)op
Rel


p	p
v  (−)op	v
ΣRel 	) ΣRel

such that ((a )op)op = a , and aop = a
. This can be defined for example if

r	r	eqb	eqb
ARel = ΣRel × N with sorting map the first projection. Such a lift induces an isomorphism of atom sortings between dom ◦ p : ARel → Σ and cod ◦ p : ARel → Σ, which induces an isomorphism of categories Nom[dom ○ p] ∼= Nom[cod ○ p] by the following general proposition.
Proposition 4.5 Suppose α : A → Aj is an isomorphism commuting with the atom storting A → Σ and Aj → Σ. Then Nom[A→Σ] and Nom[A′→Σ] are isomorphic. The isomorphism maps a nominal set X to X with action deﬁned by π·x = (α—1◦π◦α)·x.
Up to this isomorphism [σ]]dom ∼= [[σ]]cod, and we can consider [σ]]Rel an endore- lation on [σ]]dom, and we shall often simply write [σ]] for [[σ]]dom.
Theorem 4.6 sums up the main properties of the relations defined above.
Theorem 4.6	(i) Each relation [[σ]]Rel is symmetric and zigzag-closed, i.e.,
[[σ]]Rel(x, y) ∧ [[σ]]Rel(z, y) ∧ [[σ]]Rel(z, w) =⇒ [[σ]]Rel(x, w)
The induced relations on computation terms ∼σ is an equivalence relation.
The union of all the ∼σ relations is a congruence relation on terms.
Proof. The proof of (i) is by induction on the structure of σ, and we refer to Appendix A for further details. By (i), ∼σ is symmetric and zigzag-closed, and by Proposition 4.4 it is reflexive. These properties imply transitivity, and so we conclude that it is an equivalence relation. Item (iii) is a consequence of composi- tionality of the interpretation.	2

The relation [σ]]Rel does not seem to be transitive, and this seems to be a general fact for relations constructed using relational reasoning for local store.
We end this section by showing that ∼σ is an approximation of contextual equiv- alence. To do this we first need to define contextual equivalence. A (Θ, Γ, σ) − b context is a term C[−] with a hole such that whenever Θ | Γ ▶c M : σ then − |
— ▶c C[M ]: b is well typed. Two open terms in the same context are contextually equivalent, written Θ | Γ ▶c M ≡ N : σ if [C[M ]]] = [[C[N ]]] for all (Θ, Γ, σ) − b contexts C[−].
Lemma 4.7 Suppose T Rel(eqX )(f, g) for some set X and suppose f, g both have empty support. Then f = g.
See Appendix B for a proof of Lemma 4.7.
Theorem 4.8 If Θ | Γ ▶c M, N : σ and M ∼σ N then Θ | Γ ▶c M ≡ N : σ.
Proof. Suppose C[−] is a (Θ, Γ, σ) − b context.  By item (iii) of Theorem 4.6
C[M ] ∼b C[N ], which by Lemma 4.7 implies [C[M ]]]= [[C[N ]]].	2
Algebraic operations in the relational model
We now show how the algebraic operations of Section 3.1 preserve relations on store by using the relational model. At the moment, we are missing one ingredient for this: a relational interpretation of the atom abstraction [A(—)]X from nominal

sets. To this end define [ARel](X, Y, Q) to be the relation on ([ARel
]X, [ARel
]Y )

r
relating (x, y) if Q(x@ ar, y@ ar) for all fresh ar.
dom(r)
cod(r)

Theorem 5.1 Let (X, Y, Q) be an object in Rel and r = (b, bj, R) be an element in ΣRel. Let lookup, update, new be as deﬁned in Section 3.1. Then
(updateX,b, updateY,b′ ): KQ  → ARel →fs r →fs KQ

Rel	r
Rel

(lookupX,b, lookupY,b′ ): (r →fs KQ ) → ARel →fs KQ

Rel
Rel
Q
r	Rel
Q

(newX,b, newY,b′ ): [Ar  ]KRel → r →fs KRel
Proof. We just show the case of new.  Suppose ([ARel]KQ
)(f, g), r(v, vj) and

r	Rel
Q(x, y). Write A for the union of the supports of f, g, x, y. We must show that if
s, sj are stores satisfying r(s(ar), sj(ar)) for all ar ∈ A, then
fresh a. (f @ a)(x)(s[a '→ v]) = fresh aj. (g@ aj)(y)(sj[aj '→ vj]) .	(10) The requirements on a, aj in the equation above is that they are fresh (i.e., not in
A) elements of ARel mapped by the sorting ARel → ΣRel to relations whose domain
and codomain are respectively b and bj. As long as these requirements are satisfied, the elements on both sides of (10) are independent of the concrete choice of atoms. This means that we are allowed to choose some fresh ar and use that for both
atoms above. Since ([ARel]KQ  )(f, g) and Q(x, y) also KRel((f @ ar)(x), (g@ ar)(y)).
r	Rel

Moreover, the support of both (f @ ar)(x) and (g@ ar)(y) is contained in A ∪ {ar}, and
rj(s[ar '→ v](aj ′ ), sj[ar '→ vj](aj ′ ))
r	r
for all aj ′ ∈ A ∪ {ar}. So (f @ ar)(x)(s[ar '→ v]) = (g@ ar)(y)(sj[ar '→ vj]) which proves (10).	2
If we instantiate the case for new with Q = KeqX we get the parametricity prin- ciple advertised in the introduction. One way to read the relation [ARel](T Rel[[σ]]Rel) is that it relates two computations with bound cell names, if the computations pre- serve the relation r between the contents of the abstracted cells. The statement for new in Theorem 5.1 is then the relational reasoning principle for local store. To see this, suppose that a : b | − ▶c M : σ and a : bj | − ▶c N : σ are such that [ARel](T Rel([[σ]]Rel))((a. [[M ]](a'→a)), (a. [[N ]](a'→a))), and r([[V ]], [[V j]]). Then also
T	([[σ]]	)(newb,[[σ]]((a. [[M ]](a'→a)))([[V ]]), newb′,[[σ]]((a. [[N ]](a'→a))([[V ]])))

i.e.,
let a : b = new (V ) in M ∼ let a : bj = new (V j) in N , 

which by Theorem 4.8 implies contextual equivalence.
Another consequence of Theorem 5.1 is that we can use the relational model to interpret not only the Fine-Grained CBV calculus with base types in Σ as we saw in Section 4, but also the larger Fine-Grained CBV with base types in ΣRel. Each base type in ΣRel is interpreted as itself, and the store access operations are interpreted using the algebraic operations
update(X,Y,Q),r = (updateX,b, updateY,b′ ) lookup(X,Y,Q),r = (lookupX,b, lookupY,b′ )
new(X,Y,Q),r = (newX,b, newY,b′ ) .

Rather than considering algebraic operations, we could also consider generic effects, which also preserve relations. For example, the generic effect corresponding to new
(6) satisfies


(allocb,⊗iAb , allocb′,⊗iAb′ ): ⊗i Ari × [[r]] → T
i
Rel
((⊗iAri ) ⊗ Ar) .

Examples
To illustrate how the relational model captures relational reasoning for local store we show how to prove contextual equivalence of the counters defined in Section 2. In the example of the counters, the signature Σ consists of the single type Int interpreted as the set Z of integers. We write counterup and counterdown for the two counters. Consider the relation R : Rel(Z, Z) relating x, z iff x = −z, and consider
the four functions fd, fc, gd, gc : Z × Z → Z defined as follows
fd(x, z)= z + x	fc(x, z)= z − x	gd(x, z)= z + x	gc(x, z)= x − z. 

The pair f = (fd, fc) defines a morphism eqZ × R → R and the pair g = (gd, gc) defines a morphism eqZ × R → eqZ in Rel.
Consider a third counter counterrel defined in Fine-Grained-CBV over ΣRel as
let a : R = new ((0, 0)) in return (λx : eqInt. reada as z. a := f (x, z); return (g(x, z)))
Interpreting counterrel in the relational model gives ([[counterup]], [[counterdown]]) and so by well definedness of the interpretation in the relational model counterup ∼ counterdown. By Theorem 4.8 we conclude that counterup and counterdown are contextually equivalent.
For a very different kind of example, consider the two computation terms
p1 = let a : Int = new (0) in return λx : ref Int. (x == a) p2 = return λx : ref Int. return (false) .

Both these have type ref Int → Bool. This example not only requires Int, Bool to be base types, but also requires a comparison operator on reference. The latter, however, can be defined using equality on integers as
λx : ref Int. return (λy : ref Int. readx as z. y := z + 1; readx as w. return ¬(w == z))
The computations p1, p2 should intuitively be equivalent because the first can never leak the locally created variable a, and so a can never occur as input to the function. We can give a formal argument for contextual equivalence using the relational model as follows.
Since p2 equals let a : Int = new (0) in return (λx : ref Int. return (false)) by the garbage collection axiom, it suffices to show that
([[a : Int | x : Int ▶c x == a : Bool ], [[a : Int | x : Int ▶c return (false): Bool]]) define a map of type ARel × ARel → T Rel(eq[[Bool]]) in Rel for some relation r on
r	eqZ
integers containing (0, 0). Recall that ARel(a, aj) holds iff a = aj is some atom of sort r, so verifying this boils down to showing that we can choose r in such a way

that [x == a]](a'→a ,x'→a′
) is η(false) ∈ T ([[Bool]]), for all ar, aj
where η is the

r	eqZ
eqZ

unit of T . But in fact, if we choose r different from the identity relation, then this
will always hold, because ar, aj	will range over the disjoint sets ARel, ARel.
eqZ	r	eqZ
Towards more advanced relations on store
Up to now, the relations on store that we have considered have been the simplest possible: relating two stores if the contents of their cells are related pointwise. An obvious next step is to consider relations relating contents of several cells, such as
{(s, sj) | s(a)+ s(aj)= sj(a)}

In this section we sketch how one can construct a relational model for reasoning with these kinds of relations on store using slightly more advanced atom sortings. The first step is to change the sorts in the relational model to relations on vectors of base types

ΣRel = {(b, bj, R) | b, bj ∈ Σ∗,R : Rel( [b]], [[bj]]), R non-empty} .
where [b] is defined to be the product Q [[bi]]. Now consider the sets of atoms defined as

Adom =	′


A	ARel = ΣRel × A

(b,b ,R)∈ΣRel	0≤i≤|b|
Acod =	′	′ A
	
(b,b ,R)∈ΣRel	0≤i≤|b |
The projection defines a sorting ARel → ΣRel, and there are also sortings dom: Adom → Σ and cod: Acod → Σ defined as dom((b, bj, R), i, a)) = bi and cod((b, bj, R), i, a)) = bj. There is a pair of homomorphisms
Perm(Adom → Σ) (  Perm(ARel → Σ)  ) Perm(Acod → Σ)
e.g.,   the  homorphism  on  the  left  maps  the  transposition (((b, bj, R), a) ((b, bj, R), aj)) to the permutation

(((b, bj, R), 1, a) ((b, bj, R), 1, aj)) ◦ ... ◦ (((b, bj, R), n, a) ((b, bj, R), n, aj)) where n is the length of b. This pair of homorphisms induces a pair of functors
Nom[dom: Adom→Σ]  ) Nom[ARel→ΣRel] (  Nom[cod: Acod→Σ] ,
and with these in hand one can construct the category Rel exactly as before.
As we saw in Section 5, the key ingredient needed for expressing the parametric- ity principle for allocation was the atom abstraction in Rel. The definition can be generalised to the setting of the current section as follows. Given r = (b, bj, R) in ΣRel and (X, Y, Q) in Rel, we can defined the relation
[ARel]Q ⊆ [Adom]X × [Acod]Y


where
r	b	b′

[Adom]X = [Adom] ... [Adom]X
b	b1	bn
[Acod]Y  = [Acod] ... [Acod]Y
′	′	′
1	m
by relating (x, y) iff for all fresh (r, a),
Q(x@ (r, 1, a) ... @ (r, n, a), y@ (r, 1, a) ... @ (r, m, a)) .
The relation [ARel](T Rel[[σ]]Rel) relates two computations with bound sequences of cell names, if the computations preserve the relation r between the contents of

the abstracted cells. Using an appropriate generalisation of Theorem 5.1 involving vectors of update, lookup and new operations on each side, one can use this to prove soundness of relational reasoning using relations between vectors of cells. We leave further details to future publications.
Acknowledgement
I thank Nick Benton, Lars Birkedal, Andy Pitts, Alex Simpson, Ian Stark and Sam Staton for helpful discussions.

References
N. Benton and B. Leperchey. Relational reasoning in a nominal semantics for storage. In TLCA, volume 3461 of LNCS, pages 86–101. Springer, 2005.
N. Bohr and L. Birkedal. Relational reasoning for recursive types and references. In Naoki Kobayashi, editor, APLAS, volume 4279 of Lecture Notes in Computer Science, pages 79–96. Springer, 2006.
Brian Dunphy and Uday S. Reddy. Parametric limits. In LICS, pages 242–251. IEEE Computer Society, 2004.
J. Egger, R. E. Møgelberg, and A. Simpson. Enriching an effect calculus with linear types. In CSL, volume 5771 of LNCS, pages 240–254. Springer, 2009.
M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, 13:341–363, 2001.
Paul Blain Levy. Call By Push Value, a Functional/ Imperative Synthesis. Kluwer, December 2003.
P.B. Levy, J. Power, and H. Thielecke. Modelling environments in call-by-value programming languages.
Information and Computation, 185, 2003.
E. Moggi. Notions of computation and monads. Information and Computation, 93:55–92, 1991.
P. W. O’Hearn and J. C. Reynolds. From algol to polymorphic linear lambda-calculus. Jrnl. A.C.M., 47(1):167–223, January 2000.

P. W. O’Hearn and R. D. Tennent. Parametricity and local variables. Jrnl. A.C.M., 42(3):658–709, 1995.
F. J Oles. A category-theoretic approach to the semantics of programming languages. PhD thesis, Syracuse University, Syracuse, N.Y, 1982.
A. M. Pitts and I. D. B. Stark. Operational reasoning for functions with local state. In Higher Order Operational Techniques in Semantics, pages 227–273. Cambridge University Press, 1998.
G. Plotkin. Call-by-name, call-by-value, and the λ-calculus. Theoret. Comp. Sci., 1:125–159, 1975.
G. Plotkin and J. Power. Notions of computation determine monads. In FOSSACS, volume 2620 of
LNCS, pages 342–356, 2002.
G. D. Plotkin and J. Power. Algebraic operations and generic effects. Appl. Categ. Structures, 11(1):69– 94, 2003.
John C. Reynolds. The essence of Algol. In Proceedings of the 1981 International Symposium on Algorithmic Languages, pages 345–372. North-Holland, 1981.
M. R. Shinwell and A. M. Pitts. On a monadic semantics for freshness. Theor. Comput. Sci, 342(1):28– 55, 2005.
S. Staton. Completeness for algebraic theories of local state. In FOSSACS, volume 6014 of LNCS, pages 48–63. Springer, 2010.

Proof of Theorem 4.6
We first give the definition of the isomorphisms [σ]]dom ∼= [[σ]]cod. Abusing notation, we shall simply write (−)op for both directions of this isomorphism.
The needed isomorphism
[[ref b]]dom = ARel	→ [[ref b]]cod = ARel
(notation as in (7, 8)) is simply a restriction of the (−)op assumed to exist. For the case of base types b, we can take the needed isomorphism to be simply the identity.
For the rest of the cases we need an isomorphism
Kdom ∼= Kcod
This is defined to map k to kop where kop(s) = k(s ◦ (−)op). It is convenient to write sop for s ◦ (−)op. The rest of the cases of [σ]]dom ∼= [[σ]]cod are simply defined by lifting the isomorphism to function spaces in the usual way by defining f op(x)= (f (xop))op.
We must show that (−)op ◦ [[σ]]Rel is a symmetric and zigzag-closed relation on [[σ]]dom. This is done by induction on σ. The case of base types is trivial. In the case

of references the relation (−)op ◦ [[ref b]]Rel is the relation {(aeq
ARel}, which is clearly symmetric and zigzag-closed.
, (aeqb
)op) | aeq ∈

We show that (−)op ◦ KRel is a symmetric relation on Kdom. For this it suffices
to show that (k ,k ) ∈ K	implies (kop, kop) ∈ K	for any k ∈ K	,k ∈ K	.

d	c	Rel
d	Rel
dom	c
cod

So, assume that there exists some A ⊆fin ARel such that for all
∀sd, sc. (∀ar ∈ A. r(sd(ar), sc(ar))) =⇒ kd(sd)= kc(sc)	(A.1) we will show that for all sd, sc
∀sd, sc. (∀ar ∈ Aop. r(sd(ar), sc(ar))) =⇒ kop(sd)= kop(sc)	(A.2)
c	d
where Aop = {a | aop ∈ A}. Note first that (A.2) can be reformulated as
∀sd, sc. (∀ar ∈ A. rop(sd(aop), sc(aop))) =⇒ kop(sd)= kop(sc)	(A.3)
r	r	d	c
If (s ,s ) satisfy the hypothesis of (A.3) then (sop, sop) satisfy the hypothesis of
d	c	c	d
(A.1), from which we conclude k (sop) = k (sop).  Since k (sop) = kop(s ) and
d  c	c  d	d  c	d	c
k (sop)= kop(s ), we conclude the proof of (−)op ◦ K	being symmetric.

c  d	c	d
Rel

To show that (−)op ◦ KRel is zigzag-closed it suffices to show that KRel is. If A
witnesses KRel(kd, kc), Aj witnesses KRel(kj , kc) and Ajj witnesses KRel(kj , kj ) then
d	d	c
A ∪ Aj ∪ Ajj witnesses KRel(kd, kj ).
The rest of the proof follows from the following easy lemma.
Lemma A.1 Suppose R ⊆ X × Y and S ⊆ W × Z are relations on sets. Consider the relation R → S ⊆ (X → W ) × (Y → Z) relating f, g if S(f (x), g(y)) for all x, y such that R(x, y). Then

If R and S are symmetric so is R → S.
If S is zigzag-closed, so is R → S.
Proof of Lemma 4.7
For the proof we need the following definition and lemma. We say that an element x has support on the diagonal, if all a in the support of x are mapped by p to an identity relation.
Lemma B.1 Suppose kd, kc ∈ Kdom both have support on the diagonal.  Then
(k , kop) ∈ K	iff k = k .
d	c	Rel	d	c
Proof. Suppose first (k , kop) ∈ K	and s ∈ S	. We must show that k (s) = 
d	c	Rel	dom	d
kc(s).  Note first that since kc has support on the diagonal, so has kop.  Since

op
eqb
= aeqb
, also s(a
eqb
)= sop(aeq
) for any aeqb
, so the requirement of support on

the diagonal implies the condition
∀ar ∈ supp(kd) ∪ supp(kop). r(s(ar), sop(ar))
to be satsified. Now, by Lemma 4.1 we conclude k (s)= kop(sop). Since by defini-

tion kop(sop)= k (s) we conclude k
d	c
= k .

c	c	d	c
On the other hand, suppose we are given k with support on the diagonal and
sd, sc such that
∀ar ∈ supp(k) ∪ supp(kop). r(sd(ar), sc(ar)) .
We must show that k(sd) = kop(sc). Since k has support on the diagonal, the condition says that sd and sc agree on the support of k, so k(sd) = k(sc), by Lemma 3.1. Since any store s agrees with sop on the support of k, Lemma 3.1 also implies that k = kop, and so we conclude k(sd)= kop(sc).	2
Suppose T Rel(eqX )(f, g) for some set X and suppose f, g both have empty
KX

support.	Precisely, f, g are both elements of K
dom
dom
and the assumption of

T Rel(eqX )(f, g) should be read up to the isomorphism constructed in Section A. We will show that f (k)= g(k) for all k.
The continuation k may not have support on the diagonal, but there is a per- mutation π such that π · k does. Since f, g both have empty support it suffices to show that f (π · k)= g(π · k).
The assumption says exactly that (f, gop): (eqX → KRel) → KRel. Note that for any x, (π · k)(x) has support on the diagonal, and so by Lemma B.1
(eqX → KRel)(π · k, (π · k)op) .
So (f (π · k), gop(π · k)op) ∈ KRel. Since both these elements have support on the diagonal,
f (π · k)= (gop(π · k)op)op .
Finally, since (gop(π · k)op)op = g(π · k) we conclude f = g.
