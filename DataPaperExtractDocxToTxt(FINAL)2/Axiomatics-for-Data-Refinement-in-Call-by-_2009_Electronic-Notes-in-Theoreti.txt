

Electronic Notes in Theoretical Computer Science 225 (2009) 281–302
www.elsevier.com/locate/entcs

Axiomatics for Data Refinement in Call by Value Programming Languages
John Power1,2
Department of Computer Science University of Bath
Claverton Down, Bath BA2 7AY, UK
Miki Tanaka3
National Institute of Information and Communications Technology 4-2-1 Nukui-Kitamachi, Koganei, Tokyo 184-8795, Japan

Abstract
We give a systematic category theoretic axiomatics for modelling data refinement in call by value pro- gramming languages. Our leading examples of call by value languages are extensions of the computational λ-calculus, such as FPC and languages for modelling nondeterminism, and extensions of the first order fragment of the computational λ-calculus, such as a CPS language. We give a category theoretic account of the basic setting, then show how to model contexts, then arbitrary type and term constructors, then signatures, and finally data refinement. This extends and clarifies Kinoshita and Power’s work on lax logical relations for call by value languages.
Keywords: computational lambda calculus, premonoidal category, data refinement, lax logical relation.


Introduction
There have been two main category theoretic approaches to modelling data re- finement. One arose from Tony Hoare’s 1972 paper on data representation [5]. Hoare [6], then Hoare and He Jifeng [7] (see [16] for an account in standard cat- egory theoretic terms and see [17] for application of these ideas in practice), took as fundamental the idea that data refinements compose, i.e., if M refines N , and N refines P , then M refines P . However, that approach does not generalise easily to higher order types as for instance in the λ-calculus, as explained in [31] (but

1 This author has been supported by EPSRC grants GR/M56333: The structure of programming languages
: syntax and semantics and GR/586372/01:A Theory of Effects for Programming Languages.
2 Email: ajp@inf.ed.ac.uk
3 Email: miki.tanaka@nict.go.jp

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.081

see [23] for a solution using predicate transformers). The other approach, which has many sources but which has been advocated strongly by Tennent [31], has been to use binary logical relations [21,19,4] to model data refinement. Binary logical relations model data abstraction and are well suited to higher order types, but they do not compose. So one seeks a common generalisation that both accounts easily for higher order types and is closed under composition. That has led to the notion of lax logical relation [24,15] and variants [14]. Here, we explain and develop the notion of lax logical relation in the setting of call by value languages, based on but clarifying and extending the work of [15].
For the simply typed λ-calculus generated by a signature Σ, Hermida [4] showed that to give a logical relation is equivalent to giving a strict cartesian closed functor from the cartesian closed category L determined by the term model for Σ, to Rel2, the cartesian closed category for which an object is a pair of sets X and Y together with a binary relation R from X to Y . A lax logical relation is exactly the same except that the functor from L to Rel2, although still required to preserve finite products strictly, equivalently, to respect contexts, need not preserve exponentials. There is a syntactic counterpart to this [24], but the above is the most compact definition.
For call by value languages, the situation is more complex. One must distinguish between values and arbitrary expressions. So rather than considering a single cate- gory L, one considers a pair of categories Lv and Le, the former for modelling values in context and the latter for modelling arbitrary expressions in context, together with an identity on objects functor L : Lv −→ Le that allows one to see the values as possible expressions. The notion of cartesian closedness must be generalised cor- respondingly, yielding the notion of closed Freyd-category [30], and the notion of lax logical relation can and must also be generalised accordingly [15].
A leading example of a call by value language is Moggi’s computational λ- calculus, or λc-calculus [22], for which data refinement was studied in [15]. But there are many other call by value languages, for instance FPC [3], some CPS lan- guages [32], and languages with nondeterminism [1]. So we should like a systematic account of data refinement for call by value languages that includes a wide range of such languages, and that is the topic of this paper. So this paper clarifies and extends the work of [15], where attention was restricted to the λc-calculus.
We first describe models of call by value languages. This requires care. In Sec- tion 2, we recall the computational λ-calculus and show how its central feature, the distinction between values and arbitrary expressions, can be modelled in cat- egory theoretic terms, specifically in terms of categories enriched in the cartesian
closed category [→, Set], the functor category of functors from the arrow category to Set. An [→, Set]-category consists exactly of a pair of categories A0 and A1 and an identity on objects functor A : A0 −→ A1.
As outlined above, the notion of context is fundamental to data refinement, so we devote Section 3 to the category theoretic modelling of contexts in simply typed call by value languages. We recall the notion of Freyd-category, explain why it is of interest to us, and show how it is to be used here.

Next comes the central generalisation from the modelling of the computational λ-calculus in [15]: we must show how to model arbitrary type and term constructors, not just those of the λc-calculus. That requires a notion of algebraic structure, equiv- alently finitary monad, on the category [→, Set]-Cat of small [→, Set]-categories. Once one understands algebraic structure for ordinary categories, as used to de- scribe Hoare’s approach to data refinement in [16], it is not difficult but requires a little care to generalise to [→, Set]-categories with algebraic structure: we give that generalisation in Section 4.
We begged one question above in speaking of languages generated by a signature, and that was how to give a category theoretic formulation of the notion of signature. That is provided by the notion of a T -sketch for a finitary monad T . Again, once one understands that for categories, the extension to [→, Set]-categories is not difficult but requires a little care. In doing so in Section 5, we also give a slightly better focused definition of the notion of T -sketch than that in the literature.
Finally, we reach the modelling of data refinement. With the above extensions or improvements of previous work, we routinely generalise the notion of lax logical relation in [15]. In doing so, we give a version of the Basic Lemma that is a much more direct generalisation of its usual formulation than appears in [15]. We also give a condition, satisfied by all our leading examples, under which lax logical relations compose; one can see immediately that lax logical relations account for higher order structure too.
We do not address representation independence, the topic of [14], in this paper, but the techniques of [14], based on the T -sketches in [18], extend to the setting of this paper. We plan to make that extension, but it is not entirely clear how to do so yet. We also do not make explicit a relationship with logic. In the case of the simply typed λ-calculus and similar languages, that can be done using fibrations with structure [4]; but it is not yet clear how to do that here, as not only do we generalise from logical to lax logical relations, but also we generalise to call by value languages, and an appropriate notion of fibration has not been developed in that setting yet: it may well be straightforward, but it remains to be investigated.

Modelling Call by Value Languages
Our goal in this paper is to model data refinement for call by value programming languages. So for concreteness, we shall present a leading example of a call by value language and outline the key features of its models.
We consider a version of the computational λ-calculus, or λc-calculus [22]. There are several equivalent formulations of the λc-calculus. The original formulation included a type constructor TX and associated term constructors [e] and μ(e). But they are redundant, so we omit them.
The λc-calculus has type constructors given by

​
where B is a base type.
X ::= B | X1 × X2 | 1 | X ⇒ Y

The terms of the λc-calculus are given by
e ::= x | b | e'e | λx.e |∗| (e, e') | πi(e)
where x is a variable, b is a base term of arbitrary type, ∗ is of type 1, with πi
existing for i = 1 or 2, all subject to the evident typing.
It is common to see a let constructor in descriptions of the λc-calculus, with let x = e in e' being syntactic sugar for (λx.e')e. It only plays a substantial role when one wants to consider a first-order fragment of the calculus [27], so, for simplicity, we omit it here.
The λc-calculus has two predicates: existence, denoted by ↓, and equivalence, denoted by ≡. The ↓ rules may be expressed as saying ∗ ↓, x ↓, λx.e ↓ for all e, if e ↓ then πi(e) ↓, and similarly for (e, e'). A value is a term e such that e ↓. The rules for ≡ say ≡ is a congruence, with variables allowed to range over values; there are also rules for the basic constructions and for unit, product and functional types. It follows from the rules that types together with equivalence classes of terms in context form a category, with a subcategory determined by values.
It is straightforward, using the original formulation of the λc-calculus in [22], to spell out the inference rules required to make this formulation agree with the original one: one just bears in mind that the models are the same, and we use syntactic sugar as detailed above. We do not clutter our presentation by repeating the rules of [22].
The λc-calculus represents a fragment of a call by value programming language. In particular, it was designed to model fragments of M L, but is also a fragment of other languages such as FPC [3] or a nondeterministic call by value language [1]. The first-order fragment is part of the CPS calculus of [32], which in turn is a typed version of Appel’s calculus for compiling M L, as explained in [32]. For category theoretic models, the key feature is that there are two entities, expressions and values, so the most direct way to model the language as we have formulated it is in terms of a pair of categories Lv and Le, together with an identity on objects inclusion functor L : Lv −→ Le. This is subject to some generalisation of the notion of finite product in order to model contexts and product types, further subject to a closedness condition to model X ⇒ Y , as we shall explain in later sections.
The key point for us is that the basic information, i.e., categories Lv and Le and an identity on objects functor (its faithfulness is a distraction) L : Lv −→ Le, amounts exactly to the data and axioms for an enriched category: let [→, Set] denote the functor category of functors from the arrow category to Set, and con- sider its cartesian closed structure. It is immediate from the definition of enriched category [11] that one has
Proposition 2.1 An [→, Set]-category consists of categories A0 and A1 and an identity on objects functor A : A0 −→ A1. An [→, Set]-functor from A : A0 −→ A1

to A' : A'
−→ A'
consists of a pair of functors F0 : A0 −→ A'
and F1 : A1 −→ A'

making the square of functors commute. An [→, Set]-natural transformation from (F0, F1) to (G0, G1) consists of a natural transformation α : F0 ⇒ G0 with naturality extending to A1.

By systematic use of this observation and the theory of enriched categories [11], we can model call by value languages such as the computational λ-calculus [22], extensions [3,1], and extensions of its first order fragment such as used to model continuations in [32,30]. We shall proceed systematically to show how one can model such languages, then finally show how to extend that analysis to model data refinement.
Modelling Contexts
Central to our modelling of both call by value languages and data refinement is the modelling of contexts. In giving an axiomatic account of data refinement, we shall want contexts to be respected by data refinements, while not asking for any of the other structure to be respected. So we need to pay special attention to modelling contexts. That is delicate for call by value languages, requiring the notion of Freyd- category [30]. So in this section, we develop the machinery for Freyd-categories.
We must first recall the definitions of premonoidal category and strict pre- monoidal functor, and symmetries for them, as introduced in [28] and further stud- ied in [1,26,32,30]. A premonoidal category is a generalisation of the concept of monoidal category: it is essentially a monoidal category except that the tensor need only be a functor of two variables and not necessarily be bifunctorial, i.e., given maps f : X −→ X' and g : Y −→ Y ', the evident two maps from X ⊗ Y to X' ⊗ Y ' may differ.
Given a symmetric monoidal category C such as Set, and an object S of C, one might consider the category D with the same objects as C and with D(X, X') = C(S ⊗X, S ⊗X'), with composition induced by that of C. Such a construction may be used to model a functional language with side-effects [22]. The category D does not have finite products or monoidal structure, as would usually be used to model contexts, the problem being that, although one has evident functors X ⊗ − and
−⊗ Y for arbitrary objects X and Y , they do not yield a bifunctor. So we need a precise way to enunciate what structure D does have, allowing one to account for contexts in it.
Definition 3.1 A binoidal category is a category K together with, for each object X of K, functors hX : K −→ K and kX : K −→ K such that for each pair (X, Y ) of objects of K, hXY = kY X. The joint value is denoted X ⊗ Y .
Definition 3.2 An arrow f : X −→ X' in a binoidal category K is central if for every arrow g : Y −→ Y ', the following diagrams commute


X ⊗ Y  X ⊗ )g
X ⊗ Y '
Y ⊗ X g ⊗ X) Y ' ⊗ X



f ⊗ Y
v
f ⊗ Y '
v
Y ⊗ f
v
Y ' ⊗ f
v

X' ⊗ Y
	) X' ⊗ Y '
X' ⊗ g
Y ⊗ X' 	) Y ' ⊗ X'
g ⊗ X'

A natural transformation α : G =⇒ H : C −→ K is called central if every component of α is central.
Definition 3.3 A premonoidal category is a binoidal category K together with an object I of K, and central natural isomorphisms a with components (X⊗Y )⊗Z −→ X ⊗ (Y ⊗Z), l with components X −→ X ⊗I, and r with components X −→ I ⊗X, subject to two equations: the pentagon expressing coherence of a, and the triangle expressing coherence of l and r with respect to a (see [11] for an explicit depiction of the diagrams).
Proposition 3.4 Given a strong monad T on a symmetric monoidal category C, the Kleisli category Kl(T ) for T is a premonoidal category, with the functor J : C −→ Kl(T ) preserving premonoidal structure strictly: a monoidal category such as C is trivially a premonoidal category.
Moggi’s work on monads as notions of computation [22] provides a leading source of examples of premonoidal categories. Moggi showed that Kleisli categories for strong monads on cartesian closed categories provide a sound and complete class of models for the λc-calculus [22]. More specifically, one can take C = Set or the category of ω-cpo’s, both of which are cartesian closed; and one can take a strong monad on them, such as a lifting monad or ones for modelling side-effects, exceptions, continuations, etcetera. More specifically again, the paper [27] shows how every countable Lawvere theory gives rise to a canonical premonoidal category, including all the examples just cited.
More generally, Kleisli categories for premonoidal dyads [29] also provide a good class of examples of premonoidal categories, including a more natural class of models for side-effects.
Having defined the notion of premonoidal category, we need a subsidiary defi- nition, that of the centre of a premonoidal category K, which is defined to be the subcategory of K consisting of all the objects of K and the central morphisms. This
notion was fundamental to Thielecke’s account of values for continuations in [32] but is of somewhat less importance here.
Given a strong monad on a symmetric monoidal category, the base category C need not be the centre of Kl(T ). But, modulo the condition that J : C −→ Kl(T ) be faithful, or equivalently, the mono requirement [22,28], i.e., the condition that the unit of the adjunction be pointwise monomorphic, it must be a subcategory of the centre.
The functors hX and kX preserve central maps. So we have
Proposition 3.5 The centre of a premonoidal category is a monoidal category.
Thus we can deduce the coherence theorem for premonoidal categories.
Theorem 3.6 Every diagram built from the structural natural transformations in the deﬁnition of a premonoidal category commutes.
Proof. Since the centre of a premonoidal category is a monoidal category and all the structural maps are central, the result follows immediately from coherence for

a monoidal category as in Kelly’s refinement [10] of Mac Lane’s proof.	 
All of the premonoidal categories of primary interest to us are symmetric in some reasonable sense, and we require that symmetry for a soundness proof for models of the λc-calculus, so we make precise the notion of a symmetry for a premonoidal category.
Definition 3.7 A symmetry for a premonoidal category is a central natural isomor- phism with components c : X ⊗ Y −→ Y ⊗ X, satisfying the two conditions c2 = 1 and equality of the evident two maps from (X⊗Y )⊗Z to Z⊗(X⊗Y ). A symmetric premonoidal category is a premonoidal category together with a symmetry.
Finally, we need another supplementary definition. The key notion for us here is that of Freyd-category, but we need both the notions of premonoidal category and strict symmmetric premonoidal functor in order to define it.
Definition 3.8 A strict premonoidal functor is a functor that preserves all the structure and sends central maps to central maps.
One may similarly generalise the definition of strict symmetric monoidal functor to strict symmetric premonoidal functor.
We are finally in a position to define the notion of Freyd-category, which is the central definition of this section.
Definition 3.9 A Freyd-category consists of a category A0 with finite products, a symmetric premonoidal category A1, and an identity on objects strict symmetric premonoidal functor A : A0 −→ A1. A strict Freyd-functor consists of a pair of functors that preserve all the Freyd-structure strictly.
Given a category C with finite products and a strong monad T on it, Kl(T ) is a Freyd-category. A functor strictly preserving the strong monad and the finite products yields a strict Freyd-functor, but the converse is not true.
It is immediate from the definition that a Freyd-category is a [→, Set]-category with extra structure. In the next section, we shall make precise the notion of [→, Set]-category with algebraic structure and shall see that a Fryed-category can be seen as such. But first we develop the notion of Freyd-category a little more in its own terms.

Note that a strict Freyd-functor from A : A0 −→ A1 to A' : A'
−→ A'
need

not send every central map of A1 to a central map of A' : centrality is a property of
a map in a premonoidal category, not a piece of structure; so we have not explicitly asked it to be preserved. The key reason for defining Freyd-categories as they have been defined was precisely to avoid preservation of arbitrary central maps by
Freyd-functors. Maps in A0, which are necessarily central in A1, are sent to maps
in A' , therefore to central maps in A' , but we specifically do not require that an
0	1
arbitrary central map be sent to a central map.
Definition 3.10 A Freyd-category A : A0 −→ A1 is closed if for every object X, the functor A(X⊗−) : A0 −→ A1 has a right adjoint. A strict closed Freyd-functor is a Freyd-functor that preserves all the closed structure strictly.

Observe that if A is closed, then by taking X to be the unit I, it follows that the functor A : A0 −→ A1 has a right adjoint, and so A1 is the Kleisli category for a monad on A0. We sometimes write A1 for the Freyd-category as the rest of the structure may be implicit: often, it is given by the centre of A1 and the inclusion.
Given a category C with finite products and a strong monad T on C, one says Kleisli exponentials exist if, for each object X of C, the functor J (X × −) : C −→ Kl(T ) has a right adjoint. A variant of one of the main theorems of [26] is
Theorem 3.11 To give a closed Freyd-category is to give a category C with ﬁnite products together with a strong monad T on C together with assigned Kleisli ex- ponentials. To give a strict closed Freyd-functor is to give a strict map of strong monads that strictly preserves Kleisli exponentials.
It follows from Moggi’s result, but may also be proved directly, that closed Freyd-categories provide a sound and complete class of models for the λc-calculus. It is routine to define the notion of a model of the λc-calculus in a closed Freyd- category: types are modelled by objects of A0, equivalently A1; product and expo- nential types are modelled by the premonoidal and closed structures respectively; for pairing, one makes a systematic choice in modelling (e, e'), whether one operates from left to right or conversely. Left to right seems generally favoured [22,30,32].

Modelling Type and Term Constructors
In a call by value programming language, one has contexts as we have studied in the previous section, but one also has an arbitrary collection of type and term con- structors, and these are subject to equations. For instance, both the λc-calculus and FPC have exponential types, FPC has coproduct types, and a language for nondeterminism has a term constructor ∨ to model a nondeterministic operator [1]. So we seek a general category theoretic account of modelling type and term con- structors. The notion of algebraic structure, or equivalently finitary monad, on the category [→, Set]-Cat provides such a unified structure for us.
Algebraic structure for [→, Set]-categories generalises universal algebra, i.e., the study of sets with algebraic structure [13,2]. It has long been known that every category of algebras for a one-sorted signature, subject to equations, is equivalent to the category of algebras for a finitary monad on the category of sets [20]; the term “finitary” is a size condition: a definition is not essential to this paper, so we shall not define it. So our definition of algebraic structure for [→, Set]-categories is characterised by extending that theorem from sets to [→, Set]-categories. An article explaining that result in far greater generality is [13], and a version for categories with structure appears in [25]; but for work exactly at this level of generality, see [26]. In ordinary universal algebra, an algebra is a set X together with a family of basic operations σ : Xn → X, subject to equations between derived operations. In order to define algebraic structure on [→, Set]-categories, one must of course replace the set X by a [→, Set]-category A. One also replaces the finite number n
by a finitely presentable [→, Set]-category c.

The definition of finitely presentable [→, Set]-category provides the definitive generalisation of the notion of finite set for the standard category theoretic treat- ment of universal algebra in this setting [13]. But the definition is complex, all finite [→, Set]-categories are finitely presentable, and finite [→, Set]-categories are the only finitely presentable [→, Set]-categories we need. So we omit the definition here, referring the interested reader to [12].
One must also generalise functions from [→, Set]-Cat(c, A) into the set of objects of A to allow functions from [→, Set]-Cat(c, A) into the sets of arrows of A0 and A1. These are subject to equations between derived operations. It follows that the models of all of the languages we have mentioned, i.e., extensions of the λc-calculus or its first-order fragment by various type and term constructors, the category of small such [→, Set]-categories with structure and functors that strictly preserve the structure is equivalent to the category of algebras, T–Alg, for a finitary monad T on [→, Set]-Cat.
In order to include all of our examples, specifically those involving higher order structure either explicitly as in the λc-calculus or implicitly as in the CPS-calculus, one needs an unenriched version of algebraic structure on the category [→, Set]-Cat: so at the base level, we need to consider categories enriched in [→, Set], but at what one might call the meta-level, we then need to consider unenriched structure on [→, Set]-Cat.
In calculating the details, it is easier to study the basic examples such as Freyd- categories using 2-categories. Any Cat-enriched algebraic structure on [→, Set]- Cat qua 2-category trivially yields unenriched algebraic structure on [→, Set]-Cat qua ordinary category. So, perhaps counter-intuitively, there are more ordinary algebraic structures on [→, Set]-Cat than there are 2-categorical algebraic structures on [→, Set]-Cat. As the basic examples are 2-categorical and are expressible more simply in those terms, we shall give the details of this section in 2-categorical terms, with the remark that all the following extends without fuss to unenriched algebraic structure.
Let C denote the 2-category [→, Set]-Cat, let Cf be the full sub-2-category of finitely presentable [→, Set]-categories (we need only note that these include the finite such), and let ob Cf denote the set of objects of that category, i.e., the set of finitely presentable [→, Set]-categories. The following is a completely routine variant of the work of [25], which in turn is a special case of [13] (see also [26]).

Definition 4.1 A signature on C is a 2-functor S: ob Cf −→ C, regarding ob Cf as a discrete 2-category.

For each c ∈ ob Cf , S(c) is called the [→, Set]-category of basic operations of arity
c. Using S, we construct Sω : Cf −→ C as follows: set
S0 = J,	the inclusion of Cf in C
Sn+1 = J + Σ C(d, Sn(−)) × S(d),
d∈ob Cf

and define
σ0 : S0 −→ S1	to be	inj : J −→ J + Σd∈ob Cf C(d, S0(−)) × S(d) σn = J + Σd∈ob Cf C(d, σn−1(−)) × S(d) : Sn −→ Sn+1
Sω = colimn<ωSn.
The colimit exists because C is cocomplete, and it is a colimit in a functor category with base C. In many cases of interest, each σn is a monomorphism, so Sω is the union of { Sn }n<ω. For each c, we call Sω(c) the [→, Set]-category of derived c-ary operations.
A signature is typically accompanied by equations between derived operations.
So we say
Definition 4.2 The equations of an algebraic theory with signature S are given by a 2-functor E : ob Cf −→ C together with 2-natural transformations τ1, τ2 : E −→ Sω(K(−)), where K : ob Cf −→ Cf is the inclusion.
Definition 4.3 Algebraic structure on C consists of a signature S, together with equations (E, τ1, τ2). We generally denote algebraic structure by (S, E), suppressing τ1 and τ2.
We now define the algebras for a given algebraic structure.
Definition 4.4 Given a signature S, an S-algebra consists of a small [→, Set]- category A together with a [→, Set]- functor νc : C(c, A) −→ C(S(c), A) for each c.
So, an S-algebra consists of a carrier A and an interpretation of the basic operations of the signature. This interpretation extends canonically to the derived operations, giving an Sω(K(−))-algebra, as follows:
ν0 : C(c, A) −→ C(S0(c), A)  is the identity;
to give νn+1 : C(c, A) −→ C(Sn+1(c), A), using the fact that C(−, A) sends colimits to limits, is to give a [→, Set]-functor C(c, A) −→ C(c, A), which we will make the identity, and for each d in ob Cf , a [→, Set]-functor
C(c, A) −→ C(C(d, Sn(c)), C(S(d), A)),
or equivalently, C(c, A) × C(d, Sn(c)) −→ C(S(d), A), which is given inductively by


C(c, A) × C(d, S (c)) νn ×)id C(S (c), A) × C(d, S (c)) com)p C(d, A) )ν
C(S(d), A)



Definition 4.5 Given algebraic structure (S, E), an (S, E)-algebra is an S-algebra that satisfies the equations, i.e., an S-algebra (A, ν) such that both legs of



agree.

C(c, A)
ν)ω
C(τ1c, A))

C(Sω(Kc), A) 	) C(E(c), A)
C(τ2c, A)

Given (S, E)-algebras (A, ν) and (B, δ), we define the homcategory (S, E)–Alg((A, ν), (B, δ)) to be the equaliser in of
C(A, B)	{ C(c, −) }c∈ obCf ) Y C(C(c, A),C(c, B))
c

(3)
{ C(S(c), −) }c∈ obCf
Qc C(C(c, A), δc )

v
Y C(C(S(c), A),C(S(c),B))
c
c C(νc,C(S(c), B))) Y
c
v
C(C(c, A),C(S(c),B)).

This agrees with our usual universal algebraic understanding of the notion of ho- momorphism of algebras, internalising it to C.  (S, E)–Alg can then be made into a category in which composition is induced by that in C.  An arrow in (S, E)–Alg is a [→, Set]-functor F : A −→ B such that for all finitely presentable c, F νc(−) = δc(F−) : C(c, A) −→ C(S(c), B), i.e., a [→, Set]-functor that commutes with all basic c-ary operations for all c.
A special case of the main result of [13] says
Theorem 4.6 An [→, Set]-category is equivalent to (S, E)–Alg for algebraic struc- ture (S, E) on [→, Set]-Cat if and only if there is a ﬁnitary 2-monad T on [→, Set]- Cat such that the 2-category is equivalent to T –Alg.
Example 4.7 Let 2 denote the discrete [→, Set]-category on two objects; let →0 denote the [→, Set]-category for which both A0 and A1 are given by the arrow category and A is the identity functor; let Cone denote the [→, Set]-category for which both A0 and A1 are given by two objects together with a cone over them, with A being the identity functor; and let Comp denote the [→, Set]-category with A0 and A1 both given by a pair of objects, a pair of cones over them, and an intermediary map from one vertex to the other, commuting with the projections, again with A being the identity functor. Define S : ob Cf −→ C by S(2) = Cone, S(Cone) = Comp, and for all other c, S(c) is the empty [→, Set]-category.
An S-algebra is a small [→, Set]-category A together with a functor φ : C(2, A) −→ C(Cone, A) and a functor ψ : C(Cone, A) −→ C(Comp, A). The functor φ is to take a pair of objects to its limiting cone, and the functor ψ is to take a cone to itself, the limiting cone, and the unique comparison map. So we add equations as follows: we may add equations factoring through S1(2) and S1(Cone) respectively so that φ(x) : Cone −→ A restricts along the inclusion 2 −→ Cone to x, and so that ψ sends a cone σ : Y −→ x to a commutative diagram of the form

Y	σ	) x




X	.
Finally, we add an equation factoring through S2(2) so that, for each x : 2 −→ A, we have γφ(x) = idX .

Putting this together, let E(2) be the [→, Set]-category for which both A0 and A1 are given by Cone+ →0 with A being the identity, let E(Cone) have both A0 and A1 be given by Cone + Cone with A being the identity, and let E(c) be the empty [→, Set]-category for all other c, and define τ1 and τ2 to force the equations as described above: on most components, the τ ’s factor through S1(c), but for one of them, we need to factor through S2(c).
It then follows that for any x : 2 −→ A, φ(x) is a limiting cone: given any cone σ : Y −→ x, the diagram ψ(σ) provides a comparison map; and given any comparison map f : Y −→ X, functoriality of ψ applied to the arrow

Y	σ	) x

f	idx
v	) v
X	x
φ(x)

in C(Cone, A) shows that

Y	γσ	) X

f	idX
v	v
X 	) X
γφ(x) = idX

commutes, so f = γσ.
An (S, E)-algebra is precisely a small category A0 with assigned binary products, together with an identity on objects functor A : A0 −→ A1. An (S, E)-algebra map is a [→, Set]-functor that sends assigned binary products to assigned binary products.
Observe in the above that all of the finitely presentable [→, Set]-categories we considered have A0 = A1 with A being the identity functor. That is no coincidence. In fact, one can use the above observation to prove
Theorem 4.8 Let T be any ﬁnitary monad on Cat. Then there exists a ﬁnitary monad T ' on [→, Set]-Cat for which a T '-algebra consists of a T -algebra (A0, a) together with an identity on objects functor A : A0 −→ A1.
This result allows us to extend known examples of categories with algebraic structure to give [→, Set]-categories with algebraic structure, providing our only concern is with structure on A0.

Some examples of categories with algebraic structure that routinely extend the above example are small categories with finite products, small categories with finite coproducts, small monoidal categories and small symmetric monoidal categories. As mentioned above, we can account for exponentials if we drop the enrichment in Cat. Another example of algebraic structure (S, E) is that for which an (S, E)-algebra is a small category together with a monad on it. The construction is not difficult. For instance, for an endofunctor, one puts S(c) = 1 if c = 1 and makes it empty otherwise, with no equations.
This gives us part of the structure of a Freyd-category and extensions, such as finite coproducts as in the models of FPC. However, all the structure exemplified so far has been structure on A0, so we need to consider non-trivial structure on A1.
Theorem 4.9 There is algebraic structure on [→, Set]-Cat for which an algebra is a small premonoidal category A1 together with a monoidal A0 and an identity on objects strict premonoidal functor A : A0 −→ A1.
Proof. Extending the notation of Example 4.7, let → denote the [→, Set]-category with two objects, with one arrow from the first to the second in A1, and with A0 discrete. Recall that we let →0 denote the [→, Set]-category with two objects and an arrow from one to the other in both A0 and A1. Let 1 denote the discrete [→, Set]-category with one object.
Let A : A0 −→ A1 be an arbitrary small [→, Set]-category. Then the cat- egory [→, Set]-Cat(1, A) is isomorphic to A0.  Also, an object of the category [→, Set]-Cat(→, A) is an arrow of A1, and an arrow is a pair of arrows in A0 that together with the domain and codomain, form a commutative square in A1. The category [→, Set]-Cat(→0, A) maps faithfully into [→, Set]-Cat(→, A) and is given by the arrows of A0.
So if we put
S(1+ →) =→,
S(→ +1) =→, and
S(c) = 0 for all other c,
then an S-algebra would consist of a [→, Set]-category A : A0 −→ A1, together with the data for functors hX : A1 −→ A1 and kX : A1 −→ A1 for each object X, with corresponding data for each map in A0, subject to naturality conditions that will force each map in A0 to be central. One can extend S by operations and equations to force the above data to give A1 the structure of a binoidal category: one needs to ensure that the object functions of the two functors are well defined and agree as required by the binoidal definition, and that composition and identities are preserved. So, for instance one puts E(2) = 1 and defines τ1 and τ2 to force hX (Y ) = kY (X); similarly for composition and identities for hX and kX ; one must extend the signature S and add further equations to give the structural isomorphisms of a premonoidal category, but these are given along the lines of Example 4.7, extending the algebraic structure for monoidal categories. In doing so, the image of A0 is forced to lie in the centre of A1. Then one can routinely add operations and equations to

give the coherent structural isomorphisms a, l, and r, making A1 premonoidal. 
Combining the constructions of Example 4.7 and Theorem 4.9, we have
Corollary 4.10 There is algebraic structure on [→, Set]-Cat for which an algebra is a small Freyd-category.
We have expressed the technical details of this section almost entirely in terms of 2-categories and algebraic structure with respect to 2-categories. Closed Freyd- categories are not included in that, just as cartesian closed categories are not given by algebraic structure on Cat seen as a 2-category [13]: the reason is that closed structure is contravariant, whereas Cat-enrichment requires covariance, as in all the above examples. But, just as cartesian closed categories are given by algebraic structure on Cat as an ordinary category [13,25], closed Freyd-categories are given by algebraic structure on [→, Set]-Cat seen as an ordinary category, cf [26], a proof given by a routine, albeit careful extension of the proof for closedness of a cartesian category. Summarising, we have
Corollary 4.11 There is algebraic structure on [→, Set]-Cat, seen as an ordinary category, for which an algebra is a small closed Freyd-category.
These results suggest one consider [→, Set]-categories with algebraic structure as a way to provide semantics of call by value languages. One may use the results of enriched category theory to do so. For instance, [→, Set] is a [→, Set]-category, and plays a similar role to that of Set in ordinary category theory, so one can speak of presheaves, free cocompletions, etcetera. Moreover, [→, Set]-Cat is a locally finitely presentable 2-category, so one has access to the theory of 2-monads, in particular to the treatment of functors that preserve structure only up to coherent isomorphism. In particular, for the purposes of this paper, for any monad T on [→, Set]-Cat and for any [→, Set]-category A, one has a free T -algebra on A. As the models of our various languages are to be taken in T -algebras, this fact allows us to give a category theoretic account of the language generated by a signature. We develop that in the next section.
Modelling Signatures
There are two different notions of signature in this paper. We introduced one such notion, consistently with the relevant literature, in Section 4. The other, consistent with a different body of literature, is given by basic types and expressions for a call by value programming language in the spirit of Section 2. In this section, we characterise the notions of signature in the latter sense, language generated by a signature, and model, in category theoretic terms. The key notions for this are those of T -sketch S, the theory Th(S) of a sketch, and a model of a T -sketch, for a given finitary monad T on [→, Set]-Cat.
A programming language may be freely generated by a signature, i.e., basic data types and basic expressions. For a recent account and use of the idea, see [14]. For a category theoretic formulation of the notion of signature, we give, for any finitary

monad T on [→, Set]-Cat, a notion of a T -sketch S, which we identify with the notion of signature Σ. We then prove that each T -sketch S generates a free model ι : S −→ Th(S). The free model Th(S) represents the programming language generated by the signature Σ.
We first need a supplementary definition. Although it is the first definition in this section, it is not to be taken as being of central importance, just as the notion of binoidal category is supplementary to the notion of premonoidal category.
Just as in the previous section, the leading examples are more easily seen in terms of 2-monads rather than ordinary monads: recall that 2-monads on [→, Set]- Cat have underlying ordinary monads, so enrichment amounts to a restriction, but one that includes our leading examples. So, for convenience, we express ourselves in terms of 2-monads: the description of the examples in terms of ordinary monads is routine but tedious.
Definition 5.1 Given a finitary 2-monad T on [→, Set]-Cat, a family D of diagram types is a small family of 4-tuples (ci, di, ji : ci → di, ki : di → T ci), where ci and di are finitely presentable [→, Set]-categories, and ji and ki are both [→, Set]-functors, subject to the condition that the following diagram commutes:
d	ki	) Tc 






ci

We generally suppress ji and ki, leaving them implicit in ci and di, just as one often refers to a category in terms of its set of the objects, with the rest of the data implicit. So we speak of (ci, di).
Example 5.2 Let T be the 2-monad for small [→, Set]-categories A : A0 −→ A1 for which A0 has finite products. With the notation of Ex. 4.7, let D consist of one pair (2, Cone), with j the (ordered) inclusion of 2 into the base of the cone, and k the inclusion of Cone into T (2) yielding that part of T (2) that gives the product cone over the two base objects. That it satisfies the condition on a family of diagram types amounts to the assertion that k sends Cone to the product cone of the two objects given by 2.
If one began directly with algebraic structure (S, E) rather than a finitary 2- monad T , it would be natural to give a mildly stronger definition of family of diagram types: one would demand that the [→, Set]-functors k : di −→ T ci have codomain Sωci, then rewrite the condition so that the top [→, Set]-functor is re- placed by the composite of ki : di −→ Sωci with the universal map t : Sω −→ T(S,E) evaluated at ci. Thus a family of diagram types for algebraic structure would im- mediately give rise to a family of diagram types for the induced 2-monad, but they would not a priori be equivalent. We only need the latter concept here, so shall

not formalise the former. However, all constructions we make here are immediately expressible directly in terms of algebraic structure (S, E).
Now assume we are given a finitary 2-monad T .
Definition 5.3 A T -sketch S consists of a small [→, Set]-category X, a family of diagram types D, and a D-indexed family of [→, Set]-functors φi : di −→ X. A model of (X, φi) in a T -algebra (A, a) is a [→, Set]-functor f : X −→ A such that the following diagrams commute:
d	ki	) Tc 

φi	a · T (f φiji)
v	v
X 	) A
f

If one began with algebraic structure (S, E), then this definition of model would be expressible directly in terms of (S, E): the algebra (A, a) would be replaced by (A, ν), and in the condition, the expression a · T (fφj) would be replaced by ν(fφj), with the codomain of k replaced by Sωc as above.
Definition 5.4 Given a T -sketch S, the category Mod(S, (A, a)) is defined to be the limit in Cat of the diagram with vertex [→, Set]-Cat(X, A) and for each φi, two maps from [→, Set]-Cat(X, A) to [→, Set]-Cat(di, A), the first given by composition with φi, the second given by first precomposing with φiji, then applying a · T ( ), then precomposing with ki : di −→ T ci.
The main result of [18] yields
Theorem 5.5 Let T be a ﬁnitary 2-monad on [→, Set]-Cat. Then for any T -sketch S, there is a model ι : S −→ T h(S) of S such that composition with ι induces an isomorphism of categories from T–Alg(Th(S), (A, a)) to Mod(S, (A, a)).
We have expressed this result in terms of [→, Set]-functors that strictly preserve structure, but it is fairly routine, by mild adaptation of the results of [2], to extend it to [→, Set]-functors preserving structure in the usual sense, i.e., to T–Algp.
Example 5.6 Consider Example 5.2. In it, T is the 2-monad for small [→, Set]- categories A for which A0 has finite products, and D has one element, giving one cone. Let S be an arbitrary T -sketch with family of diagram types given by the singleton D, i.e., a small [→, Set]-category X together with a pair of objects of
X. By Theorem 5.5, S freely generates a [→, Set]-category A for which A0 has
finite products, in particular having a product of the specified pair of objects of X. Theorem 5.5 tells us that there an isomorphism of categories between the category of models of S in any T -algebra (B, b) and the category of [→, Set]-functors from
A to B that strictly preserve the finite products of A0.

If we extend to arbitrary monads rather than 2-monads, the notion of T -sketch allows one to speak of the free closed Freyd-category generated by a signature as in Corollary 4.11 and the discussion preceding it. So, for instance, if one starts with the λc-calculus and some basic types and terms such as those for the natural numbers, we would let T be the monad on [→, Set]-Cat for small closed Freyd- categories, and let S be the sketch determined by the given basic types and terms. Then T h(S) would be the free closed Freyd-category determined by the base types and terms, hence the free model for the λc-calculus with those types and terms. See [14] for examples of sketches for monads on Cat and their use for modelling signatures in call by name programming languages, and see [18] for more detail of this idea.

Modelling Data Refinement
In this section, we finally model data refinement, extending the analysis of [15]. We assume we have a call by value language with models given by algebraic struc- ture, equivalently a finitary monad T , on [→, Set]-Cat, and that T extends Freyd- structure, which is used to model contexts. Examples are given by extensions of the λc-calculus such as FPC [3] and call by value languages with nondetermin- ism [1], and extensions of the first order fragment of the λc-calculus such as CPS- languages [32].
For concreteness, we shall consider Set-based models: our results here do not strictly require that, as all our results generalise by use of sconing [4,19,24]. As outlined in Section 3, a good source of examples of semantic models for call by value languages is given by taking a monad M on Set and considering the Kleisli category of the monad. Every monad on Set has a unique strength, and Kleisli exponentials always exist. So if we denote the Kleisli category by SetM , then SetM is a Freyd- category (leaving Set and the canonical functor J : Set −→ SetM implicit by the convention we mentioned in Section 3); in fact, it is a closed Freyd-category. We assume that SetM has T -structure. That is true for example for FPC as Set has finite coproducts, and it is true for languages with nondeterminism [1] by choice of M as given by a powerdomain.
We further assume we are given a signature (= T -sketch) Σ for a call by value language. Extending our convention for the λc-calculus [15], and following Hoare’s convention in his modelling of data refinement [6,16], we identify the language gen- erated by Σ with T h(Σ), so for the purposes of this section, we denote T h(Σ) by L : Lv −→ Le, the idea being that Lv denotes our category of values, and Le denotes the category of arbitrary expressions.
Definition 6.1 A model N of L in SetM is a map of T -algebras from L to SetM . We need to model relations between two models N and P of L. So, in principle,
we need to send a type σ, i.e., an object of L, to a relation Rσ from Nσ to Pσ.
We then need to add conditions to the effect that the structure of both Lv and Le
is respected. To put this in category theoretic terms, we first denote by Rel2 the

category for which an object consists of a triple (X, R, Y ) where X and Y are sets and R is a binary relation from X to Y , and where a map (f, g) : (X, R, Y ) −→ (X', R',Y ') consists of functions f : X −→ X' and g : Y −→ Y ' that respect the relations. The category Rel2 has finite products, and that they are preserved by the two projections to Set.
Proposition 6.2 Given a monad M on Set, the following data forms a Freyd- category Rel2M together with a pair of strict Freyd-functors from Rel2M to SetM :
the category Rel2
the category Rel2M with the same objects as Rel2 but with an arrow from (X, R, Y ) to (X', R',Y ') given by maps f : X −→ MX' and g : Y −→ MY ' such that there exists a map h : R −→ MR' commuting with the projections, with the evident composition
the canonical functor J : Rel2 −→ Rel2M taking an object of Rel2 to itself and taking an arrow (f, g) to its composite with the X'- and Y '-components of the unit of M.
the projections δ0, δ1 : Rel2M −→ SetM .
The functor J : Rel2 −→ Rel2M has a right adjoint and so Rel2M is the Kleisli category for a monad on Rel2, but we do not use that fact. Observe that we make no mention of T -structure beyond that for Freyd-structure for modelling contexts.
We do not assume that M preserves jointly monic pairs as it does not hold for our nondeterminism example: a powerdomain is a construct for modelling nondeter- minism, a slightly simplified version of one being the endofunctor on Set that sends a set X to its set of finite subsets, Pf (X), with the operation of the endofunctor on maps given by taking the image of each finite subset. A jointly monic pair in Set amounts to a pair of sets (X, Y ) together with a subset R of X ×Y . Our point here is that the set of finite subsets Pf (R) of R need not be exhibited by the functor Pf as a subset of Pf (X) × Pf (Y ), as for instance can be seen by taking X and Y both to be two element sets with R their product. For notational simplicity, we abbreviate Rel2M by RelM where the context is clear.
One could define a logical relation for L as a functor from L to RelM that strictly preserves all the T -structure and commutes with the projections, providing RelM has and the projections preserve T -structure. But that is not our immediate concern here as logical relations need not compose, and we want composition in order to model data refinement. So we now define lax logical relations. The central idea is preservation of that structure required to model contexts, i.e., Freyd-structure.
Definition 6.3 A binary lax logical relation from N to P is a strict Freyd-functor R : L −→ RelM such that (δ0, δ1)R = (N, P ).
Our definition restricts to the notion of lax logical relation, or equivalently pre- logical relation, in [15], [24], and [8] if M is the identity.
It is not automatically the case that a pointwise composite of binary lax logical relations is again a binary lax logical relation. That requires an extra condition

on the monad M on Set. The central point is that we must consider when the composite of two binary relations extends from Rel2 to Rel2M ; the condition we need is that M weakly preserves pullbacks, i.e., that if
W	h	) X

k	k'
v	v



is a pullback, then the diagram
Y 	) Z
h'

MW	M h) MX 

Mk	Mk'
v	v
MY 	) MZ 
Mh'
satisfies the existence part of the definition of pullback. This condition is the central condition used to analyse functional bisimulation in [9] with several of the same examples. Examples of such monads are powerdomains, S ⇒ (S × −) for a set S, as used for modelling side-effects, and similarly for monads used for modelling partiality, or exceptions, or combinations of the above. It does not seem to hold of the monad (− ⇒ R) ⇒ R as has been used to model continuations; but that does not concern us greatly, as data refinement for continuations seems likely to follow a different paradigm to that adopted here anyway.
Theorem 6.4 Let M be a monad on Set that weakly preserves pullbacks. Then for any lax logical relations R : L −→ RelM and S : L −→ RelM such that δ1R = δ0S, the pointwise composite of relations yields a lax logical relation R ◦ S.
The proof of Theorem 6.4 is given by routine checking that the pointwise com- posite satisfies the conditions required to be a lax logical relation. At one critical point in the proof, one uses the fact that strong epimorphisms in Set are retracts. Unfortunately, the fact that a strong epimorphism is a retract seems unavoidable, contrary to a remark in [15]. moreover, we cannot see any alternative that does not require the condition but retains the same spirit as we have here. So this result ap- pears not to extend to arbitrary toposes for example. But there seems no difficulty in routinely extending the result to categories given by sconing [4,19,24]. There would be more difficulty if we demanded that a lax logical relation preserve not merely Freyd-structure but also the monad, as one would need a condition such as M preserving strong epimorphisms, contradicting examples such as M = S ⇒ (S ×−).
We now give a generalised Basic Lemma for lax logical relations.

Theorem 6.5 (The Basic Lemma) To give a lax logical relation from N to P is to give for each type σ of L, a relation

(4)
such that
Rσ ⊆ Nσ × Pσ

for every expression in context, Γ ▶ e : σ, if x RΓ y, then N (Γ ▶ e : σ)x is related to P (Γ ▶ e : σ)y by the relation generated by MRσ, and
if the expression e is a value, then if x RΓ y, one has the stronger result that
N (Γ ▶ e : σ)x Rσ P (Γ ▶ e : σ)y
where x RΓ y is an abbreviation for xi Rσi yi for all i when σ1, ··· , σn is the sequence of types given by Γ.
Proof. For the forward direction, suppose Γ has sequence of types σ1, ··· , σn. Since R preserves Freyd-structure, x RΓ y implies x Rσ1×···×σn y. The expression Γ ▶ e : σ is a map in L from σ1, ··· , σn to σ, so R sends it to the unique map from Rσ1×···×σn to Rσ that lifts (N (Γ ▶ e : σ),P (Γ ▶ e : σ)). The first part of the result is now
immediate as N and P strictly preserve Freyd-structure. The second part is similar. For the converse, first taking Γ to be a singleton, the two conditions say that the family Rσ extends, necessarily uniquely, to give graph morphisms from Le
to RelM and from Lv to Rel2.	the former restricting to the latter, such that
(δ0, δ1)R = (N, P ). Such a pair of graph morphisms trivially forms a [→, Set]- functor as compositions and identities are preserved trivially. Taking Γ ▶ e : σ to be ∅ ▶ ∗ : 1, where ∗ is the unique element of type 1, the second condition yields ∗ R1 ∗, so R preserves the unit of the Freyd-structure. Taking Γ ▶ e : σ to be a : σ0,b : σ1 ▶ (a, b) : σ0 × σ1 yields that if x0 Rσ0 y0 and x1 Rσ1 y1, then
(x0, x1) R(σ0×σ1) (y0, y1). And taking Γ ▶ e : σ to be a : σ0 ×σ1 ▶ πia : σi for i = 0, 1
gives the converse. So R strictly preserves Freyd-structure.	 
Finally, we shall consider an example to see how this all works in practice.
Example 6.6 Consider the computational λ-calculus LStack generated by the data for a stack. We have base types Stack and Nat, and we have base terms including pop and push. The intended semantics of the unCurrying of pop is a partial function from N (Stack) to N (Stack), with N (Stack) being the usual set of stacks. The partiality of the intended semantics for pop is the reason we use the λc-calculus here rather than the ordinary λ-calculus. Let N be the intended semantics for stacks in Set⊥, where ⊥ is the usual lifting monad on Set. The functor ⊥ preserves pullbacks, so our composability result holds. Let P be a model of LStack in Set⊥ generated by modelling stacks in terms of trees, so P (Stack) is the set of non-empty finite trees. Define a logical relation from N to P by defining it on base types as the identity on Nat and on Stack, by the usual relationship between stacks and trees. This respects base terms, so it automatically lifts to higher types. We might further define a model Q of LStack in Set⊥ by modelling stacks by lists of natural numbers. We then have a logical relation S from P to Q generated by the identity on Nat and on Stack, by relating finite trees with lists. Now taking the pointwise composite

R ◦ S, we have a lax logical relation from N to Q.

References
Anderson, S. O., and A. J. Power, A representable approach to finite nondeterminism, Theoretical Computer Science 177 (1997), 3–25.
Blackwell, R., G. M. Kelly, and A. J. Power, Two-dimensional monad theory, J. Pure Appl. Algebra
59 (1989), 1–41.
Fiore, M., and G. D. Plotkin, An axiomatisation of computationally adequate domain-theoretic models of FPC, “Proc LICS 1994,” IEEE Press, 1994, 92–102.
Hermida, C. A., “Fibrations, Logical Predicates and Indeterminates,” Ph.D. thesis, The University of Edinburgh, 1993, available as CST–103–93, also as ECS–LFCS–93–277.
Hoare, C. A. R., Proof of correctness of data representations, Acta Informatica 1 (1972) 271–281.
Hoare, C. A. R., “Data refinement in a categorical setting,” unpublished manuscript, 1987.
Hoare, C. A. R., and H. Jifeng, “Data refinement in a categorical setting,” Oxford University Technical Mongraph PRG-90,1990.
Honsell, F., and D. T. Sannella, Pre-logical relations, “Computer Science Logic 1999,” Lecture Notes in Computer Science 1683 (1999), 546–561.
Johnstone, P. T., A. J. Power, T. Tsujishita, H. Watanabe, and J. Worrell, An Axiomatics for Categories of Transition Systems as Coalgebras, “ Proc LICS 1998,” IEEE Press, 1998, 207–213.
Kelly, G. M., On Mac Lane’s conditions for coherence of natural associativities, commutativities, etc.,
J. Algebra 1 (1964), 397–402.
Kelly, G. M., “Basic concepts of enriched category theory,” Cambridge University Press, 1982.
Kelly, G. M., Structures defined by finite limits in the enriched context I, Cahiers de Topologie and Geometrie Differentielle 23 (1982), 3–41.
Kelly, G. M., and A. J. Power, Adjunctions whose counits are coequalizers, and presentations of finitary enriched monads, J. Pure Appl. Algebra 89 (1993), 163–179.
Kinoshita, Y., P. O’Hearn, A. J. Power, M. Takeyama, and R. D. Tennent, An Axiomatic Approach to Binary Logical Relations with Applications to Data Refinement, “Proc TACS 1997,” Lecture Notes in Computer Science 1281 (1997), 191–212.
Kinoshita, Y., and A. J. Power, Data refinement for Call-by-value programming languages, “Computer Science Logic 1999,” Lecture Notes in Computer Science 1683 (1999), 562–576.
Kinoshita, Y., and A. J. Power, Data refinement and algebraic structure, Acta Informatica 36 (2000), 693–719.
Kinoshita, Y., and A. J. Power, A general completeness result in refinement, “Recent Trends in Algebraic Development Techniques,” Lecture Notes in Computer Science 1827 (2000), 201–218.
Kinoshita, Y., A. J. Power, and M. Takeyama, Sketches, J. Pure Appl. Algebra 143 (1999), 275–291.
Ma, Q., and J. C. Reynolds, Types, abstraction and parametric polymorphism 2, “Mathematical Foundations of Computer Science 1991,” Lecture Notes in Computer Science 598 (1991), 1–40.
Mac Lane, S., “Categories for the working mathematician,” Graduate Texts in Mathematics 5, Springer, 1971.
Mitchell, J., “Foundations for programming languages,” Foundations of Computing Series, MIT Press, 1996.
Moggi, E., Computational Lambda-calculus and Monads, “Proc LICS 1989,” IEEE Press (1989), 14–23.
Naumann, D. A., Data refinement, call by value, and higher order programs, Formal Aspects of Computing 7 (1995), 752–762.

Plotkin, G. D., A. J. Power, D. T. Sannella, and R. D. Tennent, Lax logical relations, “Proc ICALP 2000,” Lecture Notes in Computer Science 1853 (2000), 85–102.
Power, A. J., Categories with algebraic structure, “Computer Science Logic 1997,” Lecture Notes in Computer Science 1414 (1998), 389–405.
Power, A. J., Premonoidal categories as categories with algebraic structure, Theoretical Computer Science 278 (2002), 303–321.
Power, A. J., Generic models for computational effects, Theoretical Computer Science 364 (2006) 254–269.
Power, A. J., and E. P. Robinson, Premonoidal categories and notions of computation, Math. Structures in Computer Science 7 (1997), 453–468.
Power, A. J., and E. P. Robinson, Modularity and Dyads, Electronic Notes in Theoretical Computer Science 20 (1999) 1–14.
Power, A. J., and H. Thielecke, Environments, Continuation Semantics and Indexed Categories, “Proc TACS 1997,” Lecture Notes in Computer Science 1281 (1997), 391–414
Tennent, R.D., Correctness of data representations in ALGOL-like languages, “A Classical Mind, Essays in Honour of C.A.R. Hoare,” Prentice-Hall, 1994, 405–417.
Thielecke, H., Continuations semantics and self-adjointness, Electronic Notes in Theoretical Computer Science 6 (1997).
