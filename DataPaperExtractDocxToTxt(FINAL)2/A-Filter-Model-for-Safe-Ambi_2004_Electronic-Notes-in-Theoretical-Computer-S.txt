Electronic Notes in Theoretical Computer Science 104 (2004) 217–234 
www.elsevier.com/locate/entcs


A Filter Model for Safe Ambients
Ines Margaria 1 ,2
Dipartimento di Informatica Universit`a di Torino Torino, Italy
Maddalena Zacchi3
Dipartimento di Informatica Universit`a di Torino Torino, Italy

Abstract
The definition of filter model is extended to a variant of Ambient Calculus: the Safe Ambient Calculus. The types are constructed by means of elementary and higher-order actions, that define the moves processes can do. Entailment rules for types allow to translate the parallel composition of moves into a non-deterministic choice of sequences of interleaved actions, providing a normal form for types assigned to processes. In the filter model obtained via the introduced type system, any process is interpreted as the set of all its types. The type assignment system results to be sound and complete with respect to the given semantics. Moreover the partial order relation induced by the filter model is compared with observational equivalence: the model is proved adequate, but it fails to be fully abstract.
Keywords: Ambient Calculus, Safe Ambient Calculus, Types, Filter Models


Introduction
One of the fundamental aspects of Wide Area Networks is that of barriers: the notions of locality, communication, mobility and security assume partic-

1 Partially supported by IST-2001-33477 Project, Cofin ’01 CoMeta Project, Cofin ’01 Napoli Project and IST-2001-33477 DART Project. The funding bodies are not responsible for any use that might be made of the results presented here.
2 Email: ines@di.unito.it
3 Email: zacchi@di.unito.it


1571-0661 © 2004 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.027


ular importance due to the necessity of crossing barriers. The calculus of Mobile Ambients (MA) [5] is a process calculus for describing mobile compu- tations, that is computations that cross barriers. Unit of the movement is the ambient n[P ] that represents a bounded space named n enclosing a multi- threaded process P . Ambients can be nested and can run concurrently. Inside ambients, processes can make computations and interact with other parallel processes of the same ambient, but not with processes running inside other ambients. To interact with processes of different ambients, a process can ex- ercise the movement capabilities: in m, out m and open m to enter or exit other named ambients or dissolve ambient boundaries. The ambient object of the movement undergoes the action, because it has no means to control if and when the movement occurs. To provide processes with tools to protect themselves from unwanted movements, a variant of MA: the calculus of Safe Ambients (SA) [12] has been proposed. SA is obtained from MA by adding to the three mobility actions three corresponding coactions: in m, out m and open m. In SA to cross a barrier is always the result of a handshaking between two ambients. So ambient behaviors result from a subjective control exerted by the migrating ambient and an agreement given by the ambient where the coaction is consumed. The introduction of coactions is explicitly motivated by the aim of studying a dangerous form of interferences, situations where ”the activity of a process is damaged or corrupted because of the activities of the other processes” [12]. An interesting topics in Ambient Calculi is the study of an appropriate notion of semantics equivalence and of the methods for establishing such equivalences [6], [14]; the principal equivalence relation proposed for the Ambient Calculi is a contextual equivalence based on the observability of ambients [5]. In [9] the equivalence between processes of a variant of MA is studied by means of a filter model, that results to be fully abstract with respect to the contextual equivalence ∼=obs. The model is de- signed via a type system, where types represent properties of processes. This paper is devoted to Safe Ambients and provides processes with types having a normal form, an intersection of ”sequential” types. In this way a process is described as the set of all possible traces of its behaviours. Moreover the type system, inspired by the labelled transition system of [13], is used to define a filter model in which the SA processes are interpreted, as usual, as the set of their types. The inclusion relation between set of types induces an ordering
⊆F on processes. Soundness and completeness of the type assignment system
with respect to the given semantics is proved; moreover the model is proved to be adequate in the sense that : P ⊆F Q implies P ⊆obs Q.



Names: n ∈ N;
Capabilities: c ∈ C
c ::= in m | out m | open m | in m | out m | open m;
Processes: P ∈ P 
P ::= 0 | c.P | P1 | P2 | n[P] | (νn)P | !P.

Fig. 1. Process syntax

The Calculus
The syntax of the calculus is given in Fig. 1. For simplicity in this paper, we omit communication. N denotes the set of ambient names, ranged over by n, m, ...; C the set of capabilities, ranged over by c, d, ... and P the set of processes, ranged over by P , Q.. .. The operator of restriction (νn) is a binder for ambient names and leads to the usual notions of free occurrences of names for a process P (fn(P )) and of α-conversion. In the sequel the prefixing operator . takes precedence over the parallel composition |; hence c.P | Q is read as (c.P ) | Q. The nil process 0 is often omitted, so c can be a shorthand for c.0.
Structural congruence and reduction rules defined in Fig. 2, give the op- erational semantics of the calculus. For the out-reduction rule we follow the variant proposed in [13], requiring that the co-capability out m for the emigra- tion outside of the ambient m is exercised by the target computation rather then by the ambient m. This choice is due to the aim of giving to the receiving ambient the control of the movement.
In process calculus, a standard way to define behavior equivalence for pro- cesses is the may-testing equivalence: two processes are contextually equiva- lent if they satisfy the same observation predicates, when they are placed in the same contexts. For MA the observation predicate proposed [5] is the oc- currence, at top level of a process, of an ambient whose name is not restricted. Actually the presence of an ambient n at top level of a process, represents the possibility for P of interacting with the environment via n. In [12], for SA, where to cross a boundary requires an authorization, the ”exhibition of an am- bient” requires that the ambient brought at top level can exercise the in or the open capability. We use in that follows a simplification of the definition in [12], as introduced in [13], requiring only the presence of the co-capability open.



≡ is the least equivalence relation that:
includes α-conversion
is preserved by all operators
satisfies the following rules:

→ is the least preorder relation that:
is preserved by all operators, except prefixing
satisfies the rules below:
m[in n.P | Q] | n[in n.R | S]	→ n[m[P | Q] | R | S]	(Red-In)
m[n[out m.P | Q] | R] | out m.S → n[P | Q] | m[R] | S	(Red-Out)
open n.P  | n[open n.Q | R]	→ P | Q | R	(Red-Open)
P  ≡ Q, Q → R, R ≡ S	⇒	P → S	(Red-Struct)
Fig. 2. Structural Congruence and Reduction Relation

Definition 2.1  (i) A process P exhibits an ambient n: P ⇓ n if P →∗
→∗ (ν→−m)(n[open n.Q | R] | S) for some processes Q, R, S (n ∈/ {→−m}).
P ⊆obs Q if for all context C[] and ambients n: C[P ] ⇓ n ⇒ C[Q] ⇓ n.
P ∼=obs Q if P ⊆obs Q and Q ⊆obs P .
Remark 2.2 Note that P →∗ Q implies Q ⊆obs P , but in general it does not imply that P ∼= Q ; for example, let P = open n.0 | n[open n.0 | m[0]] and Q = m[0], P →∗ Q, but for the context [-], P ⇓ n whereas Q does not converge to any ambient n.

Types

Type systems have been proposed for Mobile Calculi essentially with the goal to provide a tool of control: to control the mobility of ambients [4], the values exchanged [7], the absence of grave interferences [12]. Different is the aim of the type system proposed in [9] for MA: to characterize the process behavior in order to provide a tool for giving its semantics. This is also our goal for SA; the process semantics we look for, is a kind of trace semantics, in which a process is characterized by means of all sequences of actions it may exercise. Therefore in the definition of types we want to capture the idea of action.
In [13] the labels of the transition system are actions, defined as an exten- sion of the original definition of capability. As a matter of fact each capability gives rise to an action, but, when inserted in ambients, it can induce further higher order actions. In fact, as the process in n.P , when inserted in an ap- propriate ambient, can exercise the action in n and then its behavior is that one of the process P , in the same way the process m[in n.P ], placed in a suitable ambient, has the capability to move the ambient m into the ambient n, and then it continues with some behavior. To describe this continuation Merro and Hennessy use the concretion (ν→−m)(< P >n Q) (see also [6], [12]); a concretion (ν→−m)(< P >n Q) models the behavior of a process that, after exercising an action, leaves inside the ambient n the process P , and outside the ambient n the process Q; →−m  represents the set of private names shared by P and Q.
We follow this suggestion, so our set of types T contains besides the six actions induced by the capabilities and co-capabilities (elementary actions), five higher order actions, precisely the action enter mn induced by m[in n], the action exit mn induced by the m[out n], the action enter n induced by n[in n], the action popmn induced by n[m[out n]] and the action free n induced by n[open n].

The pairs (enter mn, enter n), (popmn, out n), (free n, open n) are said matching pairs. Notice that the definition of out semantics here considered allows to have the actions of the matching pair (popmn, out n) at the same level of ambient nesting.
The formal definition of the set of types T is given in Fig. 3. Preﬁxes1 define the actions requiring as continuation a standard type, whereas Preﬁxes2 define the actions that must be followed by a concretion (ν→−m)(< σ >n τ ), where σ is the type of the process that is into the ambient n, τ is the type of the process that is outside n and →−m  are the private names shared by σ and τ . In the sequel (ν→−m)(< σ >n τ ) T Q indicates the concretion (ν→−m)(< σ >n (τ | Q)), whereas (ν→−m)(< σ >n τ ) ² Q indicates the concretion (ν→−m)(< (σ |




Preﬁxes1: µ ::= in n|out n|open n|in n|out n|open n|popmn|free n;
Preﬁxes2: α ::= enter mn|exit mn|enter n;
Actions: γ ::= µ|α;
Types: σ ::= ω | µ.σ | α.(ν→−m)(< σ1 >n σ2) | n[σ] | (νn)σ |
| σ1 | σ2 | σ1 ∧ σ2
Fig. 3. Type Definition


Q) >n τ ). Besides actions, as type constructors we consider the ambient, the restriction, the parallel composition, and the intersection ∧. Type ω represents a property true for all processes, whereas the intersection ∧ models ”may” nondeterminism: a process having type σ ∧ τ can possibly exhibit, in different reduction paths, both property σ and τ .
An action γ is said compatible with the ambient n if γ ∈ {in m, out m, in n, open n,	exit mn}, not compatible otherwise. If γ is not compatible with n, the type n[γ.σ] is said deadlocked.
The notion of free name of a type is usual; remember that the occurrence of a subscript name of a prefix must not be considered a free occurrence.
On the set of types T is defined a partial order relation ≤; σ ≤ τ means that the property σ entails property τ ; σ τ iff σ ≤ τ and τ ≤ σ. Type Entailment Rules are shown in Fig. 4 and Fig. 5. The Action rules define the higher order actions, whereas Reduction rules formalize the fact that the execution of an action corresponds to a loss of capabilities. As usual, the right hand side of a reduction rule is called the contractum. Of particular relevance for our goal are the Sequentialization rules, that can be interpreted as a first step toward the translation of parallel composition of actions into nondeterministic choice between sequences of interleaved actions. The first four sequentialization rules say that the type γ.(σ | τ ) has fewer capabilities than the type γ.σ | τ because it can offer to its environment, as first move, only the action γ, whereas γ.σ | τ besides the action γ, can possibly offer other moves risen by the type τ . The last two rules say that the parallel com- position of two prefix types γ1.σ | γ2.τ is equivalent to the nondeterministic choice between different paths; if the actions γ1 and γ2 do not match the paths are two: one starting with the move γ1, the other one starting with the move γ2. If the two actions γ1 and γ2 match, there is a third choice: to execute the reduction. To sake of simplicity in Fig. 5 the notation of a prefix type has been stretched so that γ.σ denotes both Preﬁxes1 types (hence σ represents a type) and Preﬁxes2 types (hence σ represents a concretion). So in the expressions


of the shape γ1.(σ | γ2.τ ), (σ | γ2.τ ) indicates the usual parallel composition between types if γ1 is a elementary action, it denotes (σ ² (γ2.τ )) if γ1 is the action enter n, (σ T (γ2.τ )) otherwise. Types are considered modulo  . is preserved by both intersection and parallel composition with ω. Parallel
composition of types is considered modulo permutations, and intersection of

types is considered modulo permutations and repetitions. 
 

i∈[1···n]
σi denotes

the intersection σ1 ∧ σ2 ∧ σn;. τ ∝
i∈[1···n] σi denotes that τ ≡ σi for some σi.

A crucial notion is that of sequential type. A sequential type models the behavior of a process performing a sequence of actions.
Definition 3.1	(i) The set S ⊂ T of sequential types is defined inductively in the following way: ϕ ::= ω | µ.ϕ | α.(ν→−m)(< ϕ1 >n ϕ2)
(ii) The weight of a sequential type is defined as follows:

To prove that every type can be expressed by a nondeterministic choice of sequential types, we use the functions res, unfold and ser. Their formal definition is rather complex and can be found in Appendix. Here we give only an informal description.
The function res, defined by structural induction on sequential type definition, takes as arguments a sequence of names →−n and a sequential type ξ and returns a sequential type such that:
res (→−n, ξ)		(ν→−n )ξ.
The functions ser and unfold are defined by simultaneous induction on the weight. ser takes as arguments two sequential types ξ, χ and returns a set of sequential types such that :

ζ∈ ser(ξ,χ)
ζ	  ξ | χ

The function unfold takes as arguments a name n and a sequential type ξ, and returns a set of sequential types such that :

ζ∈ unfold(n,ξ)
ζ		n[ξ]

We can now prove that every type has a unique normal form modulo permutations and parallel composition with ω.






Axioms for ω

σ ≤ ω	− σ  σ | ω
(νn)ω  ω	− n[ω]  ω

Commutativity and Associativity of parallel composition |
— σ | τ  τ | σ	− (σ | τ ) | Q  σ | (τ | Q)
Intersection ∧
σ ∧ τ ≤ σ	σ ∧ τ ≤ τ	− σ ≤ σ ∧ σ
σ ≤ σ' and τ ≤ τ ' ⇒ σ ∧ τ ≤ σ' ∧ τ '	− ρ | (σ ∧ τ )   (ρ | σ) ∧ (ρ | τ )
n[σ ∧ τ ]   n[σ] ∧ n[τ ]	− µ.(σ ∧ τ )   µ.σ ∧ µ.τ
— α.(ν→−m)(< σ ∧ τ >n ρ)  α.(ν→−m)(< σ >n ρ) ∧ α.(ν→−m)(< τ >n ρ)
— α.(ν→−m)(< σ >n ρ ∧ τ )  α.(ν→−m)(< σ >n ρ) ∧ α.(ν→−m)(< σ >n τ )
Action









Reduction
m[in n.σ]  enter mn.(< m[σ] >n ω)
m[out n.σ]  exit mn.(< ω >n m[σ])
n[in n.σ]  enter n.(< σ >n ω)
n[open n.σ]   free n.σ
n[exit mn.(< σ >n τ )   popmn.(n[σ] | τ )
n[γ.σ]   ω	if γ not compatible with n

— enter mn.(ν→−p )(< σ1 >n σ2) | enter n.(ν→−q )(< τ1 >n τ2) ≤
≤ (ν→−p )(ν→−q )(n[σ1 | τ1] | σ2 | τ2)
popmn.σ | out n.τ ≤ σ | τ
open n.σ | free n.τ ≤ σ | τ
Fig. 4. Type Entailment Rules (part I)






Restriction

(νm)n[σ]   n[(νm)σ]	m /= n
(νn)(νm)σ   (νm)(νn)σ
(νm)(σ | τ )   σ | (νm)τ	m ∈/ f n(σ)
(νm)(σ ∧ τ )   (νm)σ ∧ (νm)τ
(νm)γ.σ   ω	if m ∈ f n(γ)
(νm)γ.σ   γ.(νm)σ	if m ∈/ f n(γ)

Sequentialization
— µ.σ | τ	≤	µ.(σ | τ )

enter
mn.(
→−
ν h )(< σ >n
τ ) | ρ	≤	enter
mn.(
→−
ν h )(< σ >n
(τ | ρ))∗

exit
n.(ν→− )(< σ > τ ) | ρ	≤	exit n.(ν→− )(< σ | ρ > 
τ )∗

enter n.(
→−
ν h )(< σ >n
τ ) | ρ	≤	enter n.(
→−
ν h )(< σ >n
(τ | ρ))∗

γ1.σ | γ2.τ   γ1.(σ | γ2.τ ) ∧ γ2.(γ1.σ | τ ) if γ1 and γ2 do not match
	Q ∧ γ1.(σ | γ2.τ ) ∧ γ2.(γ1.σ | τ )
if γ1 and γ2 match and ρ is the contractum
Congruence

Transitivity
— σ ≤ τ  & τ ≤ ρ ⇒ σ ≤ ρ


(٨) If fn(ρ)
∩{ h } = Φ


Fig. 5. Type Entailment Rules (part II)




Lemma 3.2 For all σ ∈  T there is a unique type 
 

i∈[1···n]
ξi, where ξi are

sequential types, such that σ 
denoted by nf (σ).
i∈[1···n] ξi . We call it the normal form of σ,

Proof. The proof is by structural induction on types, using the functions res, ser and unfold.



nf (ω)= ω.
nf (µ.σ)= 



ζ∝nf(σ)

µ.ζ .

nf (α.(< σ >n τ )) = 
nf (n[σ]) = 

ζ∝nf(σ), χ∝nf(τ)
ζ.
(α.(< ζ >n χ)).

ζ∈unfold(n,ξ), ξ∝nf(σ)
ζ∈ser(χ,ξ),χ∝nf(σ), ξ∝nf(τ) ζ.
nf (σ ∧ τ )= nf (σ) ∧ nf (τ )

nf ((ν→−n )σ) = 
ζ=res(→−n ,ξ), ξ∝nf(σ) ζ.


Example 3.3	σ ≡ m[out n.in m.ω | open m.ω]
nf (σ)= exit mn. (< ω >n (enter m.(< open m.ω >m ω))) ∧
∧ exit mn. (< ω >n (free m.in m.ω)) ∧ free m.out n.in m.ω

nf (n[σ]) = popmn.(enter m.(< open m.ω >m ω)) ∧ popmn.free m.in m.ω

The following Lemma, proved by induction on the definition of ≤ relates entailment relations between types and normal forms.
Lemma 3.4	(i)	ξi ≤	χj implies that for every j ∈ J there is a
i ∈ I such that ξi ≤ χj.
(ii) Let σ ≤ τ. Then for every χ ∝ nf (τ ), there is a ξ ∝ nf (σ) such that
ξ ≤ χ.

Type Inference
Types are associated with processes by means of a type assignment system ▶, defined by the rules of Fig. 6.
We can prove by simple induction on deduction the following Lemma:
Lemma 4.1 (Generation Lemma)	(i) ▶ 0 : σ iff σ  ω;
▶ c.P : σ iff	▶ P : τ and c.τ ≤ σ  for some τ;
▶ n[P ]: σ  iff	▶ P : τ and n[τ ] ≤ σ  for some τ;
▶ (νn)P : σ iff	▶ P : τ and (νn)τ ≤ σ for some τ;
▶ P | Q : σ  iff	▶ P : τ, ▶ Q : ρ and τ | ρ ≤ σ  for some τ, ρ;
▶ !P : σ iff	▶ P : τi(1 ≤ i ≤ n) and τ1 | ... | τn ≤ σ
for some τi(1 ≤ i ≤ n).





(ω)	▶ P : ω	(pref ix)

▶ P : σ n ∈ N
▶ P : σ c ∈ C

▶ c.P : c.σ
▶ P1 : σ	▶ P2 : τ

(amb)

(res)


▶ n[P ]: n[σ]
▶ P : σ

▶ (νn)P : (νn)σ
(|)

(!)


▶ P1 | P2 : σ | τ
▶ P : σ	▶ !P : τ

▶ !P : σ | τ



(∧)
▶ P : σ	▶ P : τ

▶ P : σ ∧ τ
(≤)
▶ P : σ	σ ≤ τ

▶ P : τ

Fig. 6. Type Inference Rules

Lemma 4.1 with the definitions of ≡ and of → allows us to state Subject Congruence Property (congruent processes have the same types) and Sub- ject Expansion Property (types are preserved under subject expansion). The proofs are by induction on deduction.
Lemma 4.2 (Subject Congruence) ▶ P : σ  and P ≡ Q	⇒	▶ Q : σ.
Lemma 4.3 (Subject Expansion) ▶ Q : σ  and P →∗ Q	⇒	▶ P : σ.

The Filter Model
The construction of the filter model via type system is an approach widely used for λ-calculus and its extensions [1], [2], [3]. A filter model has been also used for higher order concurrent processes [10], [11], and in [9] for Mobile Ambients. Let us recall the filter definition. Let < D, ≤> be a preorder. A non-empty subset L of D is a ﬁlter if it is an upper set, i.e. d ∈ L and d ≤ d' imply d' ∈ L, and every finite subset of L has a greatest lower bound in L. Domain of our model is < F (T ), ⊆> where F (T ) is the set of filters over < T, ≤> and ⊆ is the set inclusion relation. Note that the intersection operator plays an important role on < T, ≤>, because the greatest lower bound of a finite set of types is the intersection of the types in the set. It is standard to prove that < F (T ), ⊆> is a complete algebraic lattice, so every continuous function f has the least fixed point f ix(f ).
Lemma 5.1 < F (T ), ⊆> is a complete algebraic lattice.
If A ⊆ T then ↑ A denotes the filter generated by A, obtained by closing

A under finite intersection and by (upper closing A under) ≤.
Let par: F (T ) × F (T ) → F (T ) be the function defined by
par(F, G) =↑ {σ | τ | σ ∈ F and τ ∈ G}.
It is standard to prove that the function par is continuous.
The interpretation of a type in the model is done by means of the function
 − , defined by structural induction on types.
Definition 5.2 The function  − : P → F (T ) is defined as follows:
 0 	= ↑ {ω}
 c.P 	= ↑ {c.σ | σ ∈ P }
 n[P ] 	= ↑ {n[σ] | σ ∈ P }
 P | Q 	= par(  P ,  Q  )
 (νn)P 	=  ↑ {(νn)σ | σ ∈ P }
 !P 	= f ix(λX ∈ F (T ). par(  P ,X))
By Lemma 4.2 we can prove that the interpretation of a process is the filter of all types that can be derived for it.
Theorem 5.3  P 	= {σ |	▶ P : σ}
The inclusion on filters gives rise to an order relation ⊆F on processes, in the sense that P ⊆F Q if and only if  P  ⊆  Q  . Obviously, by Theorem 5.3, follows that P ⊆F Q if and only if  ▶ P : σ implies ▶ Q : σ , for all σ.
A crucial question is the relationship between the order relation ⊆F and the observational relation ⊆obs. We prove that P ⊆F Q implies P ⊆obs Q , whereas a counter-example shows that the converse is not true; so the model is adequate, but it fails to be fully abstract.
The proof of adequacy is done via a type interpretation, defined in a quite standard way. This interpretation allows to prove easily that the type assign- ment system is sound and complete with respect to the obtained semantics.
We associate with every type a set of filters of F (T ) (type interpretation) and we show that the interpretation of a process P belongs to the interpreta- tion of a type σ if and only if σ can be derived for P . For the definition of type interpretation, we need a stronger notion of reduction over processes ~, that does not modify the notion of ambient convergency.
Definition 5.4 The reduction relation ~ over P is defined by adding to the reduction rules of Fig. 2 the following rule:
c.P | Q ~ c.(P | Q)    (Red-Seq)
Lemma 5.5  (i) P ~٨ Q and  ▶ Q : σ  ⇒  ▶ P : σ


(ii) P ⇓ n iff P ~٨ (ν→−m)(n[open n.Q | R] | S)	(n ∈/ {→−m})
for some processes Q, R, S.

The interpretation of the types is done in two steps: first we define the interpretation of sequential types, then we use the definition of normal form to construct the interpretation of generic types.
Definition 5.6 The interpretation of sequential types is defined by structural induction as follows:
 ω 	= P
 c.ξ 	= {P | P ~٨ c.Q and Q ∈ ξ  }
 free n.ξ 	= {P | P ~٨ n[open n.Q | R] and Q | R ∈ ξ  }
 popmn.ξ 	= {P | P ~٨ n[m[out n.Q]] | R and m[Q] | R ∈ ξ  }
 enter n.( →− )(< ξ >  ξ )	= {P | P ~٨ ( →− )(m[in n.Q] | R) and

m	ν h
1	n  2	ν h

and m[Q] ∈ ξ1 	and R ∈ ξ2 }

 exit n.( →− )(< ξ >
ξ ) 	= {P |P ~٨ ( →− )(m[out n.Q]|R) and

m	ν h
1	n  2	ν h

and m[Q] ∈ ξ2 	and R ∈ ξ1 }
 enter n.( →− )(< ξ >  ξ ) 	= {P | P ~٨ ( →− )(n[in n.Q] | R) and
ν h	1	n  2	ν h
and Q ∈ ξ1 	and R ∈ ξ2 }
Definition 5.7 The interpretation of generic types is defined by:
 σ 	=   ξ∝nf(σ)  ξ 
In order to prove the soundness of type assignment we need some lem- mas, in particular we must prove that the type interpretation agrees with the entailment relation.
Lemma 5.8  (i) P ∈ ξ  implies (νn)P ∈ ζ  for all ζ ∝ nf ((νn)ξ).
Let ξ and χ be two sequential types. Then P ∈ ξ  and Q ∈ χ  imply P | Q ∈ ζ  for all ζ ∝ nf (ξ | χ) and m[P ] ∈ ϑ   for all ϑ ∝ nf (m[ξ]).
σ ≤ τ  implies   σ   ⊆   τ 
Proof.
By structural induction on sequential types.
By simultaneous induction on the weight.
σ ≤ τ  ⇒ nf (σ) ≤ nf (τ )
⇒ for every χ ∝ nf (τ ) there is a ξ ∝ nf (σ) such that ξ ≤ χ
⇒ P ∈ σ  implies P ∈ τ  .


 
Theorem 5.9 (Soundness and completeness of ▶) ▶ P : σ iff P ∈ σ  .
Proof. Soundness is proved by induction on deduction using Lemma 5.8(iv) for rule (≤). As for completeness, it is sufficient to prove for sequential types: ξ P ∈ ξ  ⇒ ▶ P : ξ. This can be proved by induction on weight, using Definition 5.7, Lemma 5.5 and Lemma 4.1.	 
We can now prove that there is a type characterizing the convergency to an ambient.
Lemma 5.10 ▶ P : free n.ω iff P ⇓ n
Proof.
(=⇒)	▶ P : free n.ω ⇒ P ∈ free n.ω 
⇒ P ~٨ (n[open n.Q] | R) and Q | R ∈ ω 
by Definition 5.6
⇒ P ⇓ n by Lemma 5.5(ii)
(⇐=) P ⇓ n	⇒ P ~٨ (ν→−m)(n[open n.Q | R] | S) by Lemma 5.5(ii)
⇒ ▶ P : n[open n.ω] | ω	by subject expansion
⇒ ▶ P : free n.ω by (≤) rule.

Theorem 5.11 (Adequacy) If P ⊆F Q then P ⊆obs Q.
Proof.

To show that the model is not fully abstract, let consider the processes P
and Q:
P = n[in n.0]
Q = n[m[out n.open m.0 | n[in n.0]]] | open m.out n.0

They are not comparable in the order relation ⊆F because for P is deriv- able the type enter n.(< ω >n ω), whereas the same type is not derivable for Q and vice versa the type open m.out n.(< ω >n ω) is derivable for Q,


but not for P . In the order relation ⊆obs however P ⊆obs Q, in fact for a non-trivial context C[−], if C[P ] ⇓ h for some ambient h, C[−] must allow the emigration from n by exhibiting the co-capability out n, hence it must have the form C[− | out n], but C[Q | out n] →٨ C[P | out n] and so there is no way to find a distinguishing context between P and Q. This fact is not sur- prising: Merro and Hennessy [13] already noticed the difficulties in conceiving a distinguishing context for action enter n.

Conclusion
We have constructed a filter model via a type system for Safe Ambients, fol- lowing the line of the filter model defined in [9] for Mobile Ambients. Basic elements of our types are the actions that can be considered as the atomic moves of an ambient. We proved that every type has a normal form that is an intersection of sequential types; this fact allows to express a parallel compo- sition of actions as a nondeterministic choice of the sequences of interleaved actions.
The model turns out to be adequate, but not fully abstract. In [9] it is a new capability, the self-open n, that makes the filter model fully abstract. We conjecture that also in SA the addition of the self-open n capability should permit to obtain a fully abstract filter model, but it should distort the spirit of the calculus. On the other hand the self-open n with its corresponding co-action in the ambient outside does not modify the calculus. In the future we wish to study a way to obtain a fully abstract model or by means of a stronger notion of type inclusion or by adding new features to capabilities (cfr. the password in [13]). Other interesting arguments of study are the application of this type system to the problem of graves interferences [12] and the connections between this system and the logics for ambient calculi, [8], [14].

References
S. Abramsky and C. H. L. Ong. Full abstraction in the lazy lambda calculus. Information and Computation, 105(2):159–267, 1993.
H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini.  A filter lambda model and the completeness of type assignment. The Journal of Symbolic Logic, 48(4):931–940, 1983.
G. Boudol. Lambda-calculi for (strict) parallel functions. Information and Computation, 108(1):51–127, 1994.
L. Cardelli, G. Ghelli, and A. D. Gordon. Mobility types for mobile ambients. In J. Wiederman,
P. van Emde Boas, and M.Nielsen, editors, ICALP’99, volume 1644 of LNCS, pages 230–239, Berlin, 1999. Springer-Verlag.


L. Cardelli and A. D. Gordon. Mobile ambients. In FoSSaCS’98, volume 1378 of LNCS, pages 140–155, Berlin, 1998. Springer-Verlag.
L. Cardelli and A. D. Gordon. Equational properties of mobile ambients. In FoSSaCS’98, volume 1578 of LNCS, pages 212–226, Berlin, 1999. Springer-Verlag.
L. Cardelli and A. D. Gordon. Types for mobile ambients. In POPL’99, pages 79–92, New York, 1999. ACM Press.
L. Cardelli and A. D. Gordon. Anytime, anywhere. modal logics for mobile ambients. In
POPL’00, pages 365–377. ACM Press, 2000.
M. Coppo and M. Dezani-Ciancaglini. A fully abstract model for higher-order mobile ambients. In VMCAI’02, volume 2294 of LNCS, pages 255–271, Berlin, 2002. Springer-Verlag.
C. Hartonas and M. Hennessy. Full abstractness for a functional/concurrent language with higher-order value-passing. Information and Computation, 145(1):64–106, 1998.
M. Hennessy. A fully abstract denotational model for higher-order processes. Information and Computation, 112(1):55–95, 1994.
F. Levi and D. Sangiorgi. Controlling interferences in ambients. In POPL’00, pages 352–364, New York, 2000. ACM Press.
M. Merro and M. Hennessy. Bisimulation congruences in safe ambients. In SIGPLAN Notices, 31(1)’02, pages 71–80, New York, 2002. ACM Press.
D. Sangiorgi. Extensionality and intensionality of the ambient logics. In POPL’01, pages 4–13, New York, 2001. ACM Press.

Appendix

Definition 7.1	(i) The function res: (N ٨ × S) → S is defined by structural induction on sequential types definition, as follows:

res (→−
res (→−
)= ω
→−	→−

→−
h, µ.ψ
)= ω	otherwise

res (→−	(ν→−m)(< ϕ >
ϕ )) =

h, α.
1	n	2

= α.(ν→−m)(
→− )(< ϕ > ϕ )	if f n(α)
→−	= Φ

ν h	1	n	2
∩{ h }

— res (→−	(ν→−m)(< ϕ >
ϕ )) = ω	otherwise

h, α.
1	n	2

The functions ser : (S × S) → 2S and unfold : (N × S) → 2S are defined by simultaneous induction on the weight.
For |ϕ| + |ψ| = w, we define ser (φ, ψ) in such a way that for every
ζ ∈ ser (φ, ψ): |ζ|≤ w;
For |φ| = w, we define unfold (n, φ) in such a way that for every
ζ ∈ unfold (n, φ): |ζ|≤ 1+ w.

Base step:
ser (ω, ω)= ω
unfold (n, ω)= ω
Inductive step:
We distinguish the following cases:

— ϕ = µ.φ1,ψ = ω :	ser (ϕ, ψ)= {ϕ}
ϕ = µ.φ1,ψ = ν.ψ1,  µ, ν not matching:
ser(ϕ, ψ)= {µ.ζ | ζ ∈ ser (ϕ1, ν.ψ1)}∪ {ν.ξ | ξ ∈ ser (µ.φ1, ψ1)}
ϕ = µ.φ1,ψ = ν.ψ1,  µ, ν matching :
ser(ϕ, ψ)= {χ | χ ∈ ser (ϕ1, ψ1)}∪ {µ.ζ | ζ ∈ ser (φ1, ν.ψ1)} ∪ 
∪ {ν.ξ | ξ ∈ ser (µ.φ1, ψ1)}
ϕ = µ.φ1,ψ = α.(ν→−m)(< ψ1 >n ψ2): 
ser(ϕ, ψ)= {µ.ζ | ζ ∈ ser (ϕ1, ψ)} ∪ 
∪ {α.(ν→−m)(< ψ1 >n χ) | χ ∈ ser (µ.φ1, ψ2)}
ϕ = α.(ν→−m)(< ϕ1 >n ϕ2),ψ = β.(ν→−q )(< ψ1 >m ψ2),
α, β not matching:
ser(ϕ, ψ)= {α.(ν→−m)(< ϕ1 >n ξ) | ξ ∈ ser (ϕ2, ψ)}∪
∪ {β.(ν→−q )(< χ1 >m χ) | χ ∈ ser (ϕ2, ψ2)}
ϕ = enter pn.(ν→−m)(< ϕ1 >n ϕ2) and
ψ = enter n.(ν→−q )(< ψ1 >m ψ2): 
ser(ϕ, ψ)= {enter pn.(ν→−m)(< ϕ1 >n ψ) | ξ ∈ ser (φ2, ψ)}∪
∪ {enter n.(ν→−q )(< ψ1 >n χ) | χ ∈ ser (φ, ψ2)}∪
∪ {ζ | ζ = res(→−m →−q , ζ'),ζ' ∈ ser(ζ1, ζ2) |
| ζ1 ∈ unfold (n, χ),χ ∈ ser (φ1, ψ1) and ζ2 ∈ ser (φ2, ψ2)}


We distinguish the following cases:
ϕ = µ.ψ :
unfold(n, ϕ) = {ω}	if µ is not compatible with n
= {enter nm.(< ζ >m ω) | ζ ∈ unfold(n, ψ)} if µ = in n
= {exit nm.(< ω >m ζ) | ζ ∈ unfold(n, ψ)}	if µ = out m
= {enter n.(< ζ >n ω) | ζ ∈ unfold(n, ψ)}	if µ = in n
= {free n.ψ}	if µ = open n
ϕ = α.(< ϕ1 >n ϕ2): 
unfold(n, ϕ) = {ω}	if α is not compatible with n
= {popmn.ζ | ζ ∈ ser(χ, ϕ2) with χ ∈ unfold (n, ϕ1)}
if α = exit mn
Lemma 7.2	(i) If ξ is a sequential type, (ν→−m)ξ  res (→−m, ξ)
If ξ is a sequential type, n[ξ]	ζ
If ξ and χ are sequential types, ξ | χ	ζ
ζ∈ser(ξ,χ)
Proof. Obvious by definitions of  , res, ser, and unfold.	 
