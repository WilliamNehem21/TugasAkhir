Electronic Notes in Theoretical Computer Science 40 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume40.html 19 pages


A Superposition Operator for the Reﬁnement of Algebraic Models

Claus Pahl 1
School of Computer Applications Dublin City University
Dublin, Ireland


Abstract
The development of computer languages or software artefacts from basic concepts to the final product is usually a process starting with an abstract model of a key concept and extending this by adding more detailed functionality for extended structural definitions. We will present a refinement approach for the stepwise development of algebraic models. In each step we either add new elements to a model or refine the properties of existing ones. The process of refining elements such that properties of the original element are preserved is called superposition. We will present a categorical framework for refining algebraic structures. Algebras can be used to model a variety of concepts and objects. Language semantics and formal methods are two application areas which use models represented in terms of algebras.


Introduction
The development of computer languages or software artefacts from basic con- cepts to the final product is usually a process of starting with an abstract model of a key concept and extending this by adding more detailed func- tionality for extended structural definitions. We propose a layered, stepwise development method for algebraic models. Each new layer either adds new elements to a model or refines the properties of existing ones. Since addition of new elements is a straightforward operation, we address the refinement or redefinition of elements here. The process of redefining elements such that properties for the original element are preserved, shall be called superposition. We present a categorical framework for refining algebraic structures. Alge- bras are used to model a variety of concepts and objects. Language semantics [11,12] and formal methods [10] are two application areas which use mod- els represented in terms of algebras. Our approach generalises other extension

1 Email:cpahl@compapp.dcu.ie
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


and refinement techniques such as the VDM refinement notion, see [5,6]. Soft- ware component technology in another possible application area, where our framework can be used as an adaptation technique in order to re-use a library component in a slightly different context. Our main objective is to obtain a framework for superposition which can be used in the definition of development methodologies for language design or software development. Our framework supports the idea of modularity in design by introducing concepts for a step- wise development in layers. Applying the superposition operator discharges automatically all proof obligations concering property preservation. We will present a framework which allows a language or software designer to create a library of superposition operators for various applications.
An incremental strategy starts with a core model. Elements in a new layer are defined in terms of the layer below. Definitions of elements in the new layer shall superimpose definitions of the respective original elements. A particular problem of this superposition is the preservation of properties of the original elements. We identify two kinds of elements in models: types and functions. We define both and explain notions of property preservation for superposi- tions of these kinds of elements (Section 2 and 3). A set of constructs for refining these elements is introduced. We argue that the standard notion for structure preservation, the homomorphism, is too restrictive. A more flexible notion is sought. More abstract, observationally oriented notions of property- preservation based on quotients, subobjects and characteristic functions are developed. We investigate how the two forms of property-preserving super- positions interfere. We are going to present an algebraic framework which provides concepts for lifting types and functions such that superposition of original elements by lifted elements with preservation of properties is possi- ble. Elements (types and functions) are transformed to adapt to new struc- tures. Essentially, we define our abstract superposition framework in Section
4. Functions and types and their refinements are formalised as subcategories
with corresponding functors. A superposition operator formalising property- preserving refinements of algebras is introduced. The compositionality of su- perposition is studied.

Function Preservation
A function f : A → B is a map from one domain to another. Functions are characterised by some observable behaviour, which allows them to be distin- guished from other functions with the same domain and codomain. The idea of observable behaviour is essential in our approach. In general, we distinguish two ways in which functions are given: extensionally and intensionally. Ex- tensionally means that functions are given in terms of their input/output be- haviour. We follow the intensional view here, distinguishing functions based on some notion of behaviour observation. Our framework centres on the preser- vation of properties in extensions of algebraic structures. These properties are

characterised in terms of observations on function behaviour.
The function f : A → B – called the base function – where A, B are types shall be lifted to T f : T A →T B – called the lifted function – where T maps types (objects) and functions (maps) such that
properties of A, B are preserved, called type preservation – type proper- ties are specified by a type predicate,
properties of f are preserved, called function behaviour preservation – function behaviour is to be preserved by T f : T A →T B.
The lifting T f superimposes the definition of f . The mapping T on maps is constrained: if f : A → B is a map, then T f : T A → T B is a map. This shall be illustrated by a small example.
Example 2.1 Let sqr denote the usual squaring function n '→ n2. Let A = B = Z. Define TZ = Q. Then, T sqr is the lifted squaring function. If we define equivalence classes on Q - classes of rational values that are mapped to the same integer value - then we expect T sqr on these classes and sqr to show the same behaviour. The equivalence is the observation criterion here.
By introducing two objects A and B we would distinguish two types of domains. However, we shall postpone the introduction of types for domains for some time and work with an untyped universe for the time being. Functions shall be maps on a domain D, e.g. f : D → D.
The category of sets shall be the underlying default category. Whenever the term ’domain’ is used, the reader can think of sets unless stated otherwise.

A Notion of Function Preservation
Let us assume an object lifting (a type operator) T : D '→ T D and a domain mapping φ : D →T D. A straightforward way to define function preservation of f : D → D by a lifted function T f : T D → T D would be based on the commutativity of the following diagram:
T D	T f ✲ T D
✻	✻
φ	φ
D	f	✲ D
(i.e. T f ◦ φ = φ ◦ f ). Whenever f maps d to d', we expect T f to map φ ◦ d to φ ◦ d'. The map φ preserves a property, here structural information. It preserves the structure f in T f . We could represent this in a category of endomaps for a given base category C. Objects are domains D with endomaps f , maps are C-maps φ such that φ ◦ f = T f ◦ φ. The objects are structured,

the structure is imposed by maps f or T f . The map φ is equivariant; it
preserves structure if the equation is satisfied.
An example shall show that this definition is too restrictive for our frame- work and that a more relaxed notion of observational preservation is needed.

Example 2.2 Consider ( ×D): D → D×D as the definition for T . Assume that φ maps d to ⟨d, d1⟩ and d' to ⟨d', d2⟩. T f shall be defined as f × 1D. In this case, the diagram does not commute since ⟨d', d1⟩ is not equal to ⟨d', d2⟩ if f maps d to d', but T f preserves the behaviour of f in its first component.
Thus, we consider the above definition of function preservation as too restrictive. The given observability criterion for the example – consider the first component only – is sufficient for function preservation. A weaker notion of function preservation shall be introduced. For the given example, points of the product D × D can be considered as representing the same original element with respect to the lifting ( × D), if they correspond in their first component. Let us make precise what a point is. In the category of sets, a point x of a set X is a unique map x : 1 → X where 1 is the terminal object, see [7] p.19. Functions are expected to preserve the first component for the given example. In a new layer, we expect additional constructs resulting in additional elements. Several of the extended elements might represent the same base element, i.e. are mapped back to the same base element.

Definition 2.3 An equivalence relation ∼ on T D shall be called a represen- tation relation of D in T D if there is one equivalence class in T D/∼ for each point of D. The representation shall be called faithful, if the representation mapping φ∼ : D → T D/∼ is monic; it shall be called full, if the mapping is epic.
Normally, we expect representations to be faithful, i.e. elements distin- guishable in the basic layer should be distinguishable in the extension.
Definition 2.4 Let T be a lifting on domains and functions, and φ : D →T D a domain mapping. The lifting T f preserves the function f with respect to the representation ∼, if T f ◦ φ ◦ d ∼ φ ◦ f ◦ d for any point d and T f preserves the representation of D, i.e. if x1 ∼ x2 ⇒T f ◦ x1 ∼T f ◦ x2 for x1 = φ ◦ d1 and x2 = φ ◦ d2 and d1, d2 : 1 → D.
The second condition states that ∼ is a congruence on the D-relevant part of T D. The represention relation can be seen as an observability criterion. Extended elements are observably equal, if they are equivalent, i.e. represent the same basic element in the extension.

Determine a Representation
Instead of determining the domain mapping φ first, we start with the rep- resentation relation on domains. The representation is made explicit in our approach, since it will be used as the main element in constructing all ingredi- ents necessary to define an extended layer. This makes our approach different from those where an equivalence is implicitly defined via a retrieve operator [5,6]. Let x1, x2 : X → T D be two maps (e.g. points of T D) with codomain T D where X is the terminal 1. We can refine a relation ∼R on T D ×T D by pairs (x1, x2) with x1, x2 : X →T D that are mapped to equivalent values. The relation ∼R can be expanded to ∼, the transitive closure of ∼R which is the least equivalence relation containing ∼R. Based on the equivalence ∼, we define a quotient for each domain:
T D/∼	= {S ⊆T D | y1 ∼ y2 for all y1, y2 in S}
T D is partitioned into equivalence classes, which together form the quotient.
Example 2.5 Let us look at products again. Two elements x1, x2 of T D = D × D for T =( × D) can be considered equivalent, if their first components are equal: x1 ∼ x2 if p1 ◦ x1 = p1 ◦ x2 for x1 = ⟨p1 ◦ x1, p2 ◦ x1⟩ and x2 =
⟨p1 ◦ x2, p2 ◦ x2⟩ where p1 and p2 are projections onto the first and second element, respectively. Then, x1 and x2 represent the same element of D, namely p1 ◦ x1 (or p2 ◦ x2).
We can relate T D and its quotient T D/∼ by an injection ι : T D ‹→T D/∼.

Proposition 2.6 An injection ι : T D ‹→T D/∼ from any object into its quo- tient always exists
Proof. See [2,3].	✷
There is another property of quotients and their inclusion. A map h : B → C is a coequaliser of f, g : A → B, if h ◦ f = h ◦ g and for any map k : B → D for which k ◦ f = k ◦ g, there is is a unique map l : C → D such that l ◦ h = k (see [1] p.239). Coequalisers generalise equivalence relations.
Proposition 2.7 An injection ι : T D ‹→T D/∼, which assigns an equivalence class for each point of T D, is a coequaliser of points x1, x2 : 1 →T D.
Proof. Follows directly from Proposition 8.4.2 in [1].	✷
Having the existence of the inclusion ι guaranteed, we might want to con- sider the inverse of ι. The resulting map is a choice operator, called δ, which assigns representatives for each equivalence class:


T D ✛
ι ✲
T D/∼
δ



Proposition 2.8 Assume an injection ι : T D ‹→ T D/ ∼.	Then, a map
δ : T D/∼→ T D exists such that ι is a retraction of δ, i.e. ι ◦ δ = 1T D/∼.
Proof. See [7] p.72/73.	✷
Based on a given equivalence on T D – which can be derived from a relation specification – the existence of maps ι and δ between the lifted domain T D and its quotient T D/ ∼ is guaranteed. These results will be useful in the construction of a function preserving extension, including the construction of the domain mapping φ : D →T D.
Example 2.9 For products, we can define the choice operator δ : T D/ ∼
→ T D by δ : [(d, d0)]∼ '→ (d, d0) and the injection ι : T D ‹→ T D/ ∼ by
ι : (d, d') '→ [(d, d0)]∼ for all d' : D, where d0 is any fixed element of D.
Constructing a Representation Mapping
The quotient captures what has to be preserved in a function lifting. We are going to construct a representation mapping φ∼ : D → T D/∼ for a domain mapping φ : D →T D. Based on ∼, the map φ∼ shall associate an equivalence class to each point of D.
Definition 2.10 A representation mapping φ∼ : D →T D/∼ is called
faithful, if it is monic (i.e. d1 /= d2 ⇒ φ∼ ◦ d1 /= φ∼ ◦ d2 for any d1, d2 : D),
full, if it is epic (i.e. t1 ◦ φ∼ = t2 ◦ φ∼ ⇒ t1 = t2 for t1, t2 : T D/∼→ X).
Normally, we expect φ∼ to be faithful, since it guarantees that distinguish- able points of the base domain are distinguishable when mapped into the lifted domain. In general, the map φ∼ will not be full, but if that is the case we get isomorphsm between the basic domain and the quotient of the extension.
With the results obtained so far, such as existence of inclusion and choice, we can now define the domain mapping φ.
Definition 2.11 The domain mapping φ shall be defined by φ := δ ◦ φ∼.
The user specifies the representation relation ∼ and the representation map φ∼ based on the lifting T . The rest can be derived. The elements T , ∼ and φ∼ are the basic ingredients of a function preserving extension.
Definition 2.12 The lifting triple ⟨T , ∼, φ∼⟩ consists of a lifting operator
T , a representation relation ∼ and a representation mapping φ∼.
It should be noted here that T is not generally a functor. The lifting triple can not expected to be a monad - a confusion might occur since some authors use the name triple for monads. Triples are different from monads here.

Example 2.13 For products, we define φ∼ : d '→ [(d, d0)]∼ for any d0 : D and derive φ : d '→ (d, d0). For products, we have a full and faithful presentation.

Construct a Function Lifting
Given an object lifting T on domains, a representation ∼ and a representa- tion mapping φ∼, we have constructed the domain mapping φ. The remaining construct to be defined is the function lifting. Lifting T f preserves the func- tion f , if [T f ] ◦ φ∼ = φ∼ ◦ f , where [T f ] is defined by [T f ] ◦ [x]∼ = [x']∼ if T f ◦ x = x' for points x and x' of T D. Given a representation relation
∼, a lifting T f : T D → T D has also to satisfy the substitution property of congruences x1 ∼ x2 ⇒ T f ◦ x1 ∼ T f ◦ x2 for x1, x2 : T D with x1 = φ ◦ d1 and x2 = φ ◦ d2 and d1, d2 : D.
Definition 2.14 Let x be a point of T D. A lifted function T f for function
f which preserves the behaviour of f is defined as follows:
T f ◦ x =  φ ◦ f ◦ d if x ∼ φ ◦ d for some point d of D
 y	otherwise, where y is any point of T D

This defines T f based on f for all points of T D. If φ∼ is full, we can simplify the definition, i.e. T f◦x = φ◦f◦d for x ∼ φ◦d for some point d of D.

Proposition 2.15 The lifting T f based on f as deﬁned in Def. 2.14 is func- tion preserving.
Proof. Let f ◦ d = d' for any d : D. Then T f ◦ x = φ ◦ f ◦ d = φ ◦ d' for arguments x which are equivalent to φ◦d. Thus, we have T f ◦φ = φ◦f . This is even equality instead of equivalence. This is obviously a congruence on the D-relevant part, i.e. satisfies the substitution property x1 ∼ x2 ⇒ T f ◦ x1 ∼ T f ◦ x2 for any x1, x2 : T D with x1 = φ ◦ d1 and x2 = φ ◦ d2 and d1, d2 : D. ✷
Example 2.16 For products, we have the case that φ∼ is full, thus we define
T f ◦ (p1 ◦ x, p2 ◦ x)= φ ◦ f ◦ a for x ∼ φ ◦ p1 ◦ x for some point p1 ◦ x of D.

Type Preservation
A domain can be constrained by a type predicate. We consider types as explicit objects, we also consider the predicate as a truth-valued map which includes or excludes elements from the domain. Our approach to representing types will use slice categories, see [1] p.35. However, we also look at monoid actions and types in Section 3.2 in order to introduce an alternative.

Parts and Characteristic Function
There is a duality between parts (or subobjects) of an object, related by an inclusion ι : S ‹→ D where S is a part of D (denoted S ⊆ D) and a characteristic function χS : D → Ω. The characteristic function determines whether an element of X is a part (or a subobject) or not. Ω is a truth-value object – a standard way of defining Ω is 2 = {true, false} for the Boolean topos Set. The truth-value object is unique to its own topos [7] p.348. In more structured categories Ω might have more structure for the truth value. Let Γ be a set of types. In the category of sets we can state: for any x : Γ → X, x is included in the part (S, ι) of X iff χS(x) = trueΓ for χS : X → 2 and trueΓ : Γ → 1 → 2. We can combine the two constructs:

S ⊂	✲ D	✲ Ω
In general, Ω is a truth object if for any object X; maps χS : X → Ω are natural bijections of ι : S ‹→ X, i.e. for each subobject S ⊆ X there is exactly one χS : X → Ω (see [7]).
All types we are going to introduce are subobjects of the domain D. Due to the strict typing approach of category theory, an element of a subobject cannot be an element of another object at the same time.
Definition 3.1 The category of subobjects (or types) of D, abbreviated
C/D, in a category C can be defined as follows:
inclusion maps α : A ‹→ D, β : B ‹→ D, ... are objects
a map from α : A ‹→ D to β : B ‹→ D is a C-map f : A → B such that
β ◦ f = α.
It follows that C/D is indeed a category, see [7]. If f exists, it is unique. This means that there is at most one map between two objects. In that case, we indicate A ⊆D B (A is included in B over D). Due to the uniqueness of f , C/D is a preordered set (poset). If additionally a map g : B → A exists such that α ◦ g = β, then α : A → D and β : B → D are isomorphic objects, denoted A ∼= B. If α : A → D, x : Γ → D, and x ∈ A and A ⊆D B, then x ∈ B.
The need to relate or combine different predicates might arise in our super- position approach. Suppose χT A, the characteristic function for an extended type, is constructed from χA, the characteristic function for a basic type. It might be necessary to introduce another predicate on T A resulting in a com- bination, weakening or strengthening of χT A. The category of parts is the framework to explore relations between characteristic functions.

Actions and Types
Before continuing with type extensions, we shall be look at an alternative way of dealing with types. We follow [1] p.64ff here closely. Consider the monoid (F, ◦, 1) where F is the set of functions and ◦ is the composition. Define a mapping α : F × D → D by α(f, d)= f ◦ d for f : F and d : D. We shall write f (d) for f ◦ d in the remainder of this section. domains.
Proposition 3.2 The map α is a monoid action.
Proof. α(1,s)= s and α(f ◦ g, s)= α(f, α(g, s)) = α(f, g(d)) = f (g(s)).  ✷
Types are introduced for domains through a type function type : D → Γ. Let Γ be a set of types. Each t ∈ Γ is defined by {d ∈ D | type(d)= t}. Domain and codomain of functions are specified by input : F → Γ and output : F → Γ. We expect input(f2) = output(f1) for a composite f2 ◦ f1 to be well-defined. We assume 1t ∈ F for each t with input(1t)= output(1t) as the identity. We can define a typed universe, represented by a category CΓ where elements of Γ are the objects and elements f of F with input(f ) and output(f ) as domain and codomain, respectively, are the maps. The category CΓ is well-defined. We write as an abbreviation f : A → B for f : D → D, input(f ) = A and output(f )= B. We consider elements of the type set Γ as objects. Soon, we will see that these type objects are subobjects of the domain D.
Extending a Type
We define type preservation first, and then consider how to construct type preserving extensions. A lifting triple ⟨T , ∼, φ∼⟩ shall be assumed for this discussion.
Definition 3.3 If a domain D is lifted to a domain T D, then the type A
constraining D is preserved, if the following diagram commutes:
T A ⊂	✲ T D
✻	✻
φA	φ
A ⊂	ιA	✲ D
The mappings ιA, ιT A are inclusions, φ maps from D to T D, φA maps from type A to T A.
A type is characterised by a subobject, e.g. T A, and its inclusion, e.g. ιT A. The diagram in the previous definition formalises type preservation: (T A, ιT A) preserves (A, ιA). Due to the duality of concepts, types can also be represented by characteristic functions. We can construct a subobject based on a given characteristic function, and vice versa. Here is the alternative definition.

Definition 3.4 The characteristic function χT A preserves the type χA, if
χT A ◦ φ = φΩ ◦ χA.
The following diagram is an elaboration of the above one with other con- structs discussed.
ιT A	χT A
T A ⊂	) T D 	) T Ω

ˆ
ψA	φA

a	v	ιA
ˆ	ˆ
φ	φΩ
χA

1 	) A ⊂	) D 	) Ω
It should be remembered here that there is a unique truth value object 2 that we have introduced earlier on.
Constructing a Type Preserving Lifting
After defining type preserving extensions, we now look at how to construct such an extension. We look at characteristic functions here – keeping in mind that we can construct the corresponding subobject inclusions at any time. Let us assume a characteristic function χA : D → Ω, as well as maps φA : A →T A, φΩ : Ω →T Ω and a retraction ψA : T A → A such that ψA ◦ φA = 1A.
Definition 3.5 Define the lifted characteristic function χT A : T D →T Ω by:



χT A


ιT A
x =  φΩ ◦ χA ◦ ιA ◦ ψ ◦ x	for all x = φA ◦ a for some point a : A
 false	otherwise

We will soon investigate in more detail what ψ is and when it exists.
Proposition 3.6 The mapping χT A is a well-deﬁned type preserving exten- sion of χA.
Proof. A diagram for Def. 3.4 commutes for the given definition.	✷
Type preservation can be looked at what is called a determination problem, see [7]. The truth-value object is unique for a category, i.e. T Ω = Ω. We have now the following determination problem:
Ω
/’	`❅

χA /
❅ χT A

/	❅
/	❅
/	❅
D (	) T D
ψ


where the lifted characteristic function χT A for χA is sought.
Proposition 3.7 If the map φ has a retraction ψ – i.e. if ψ ◦ φ = 1A – then the above diagram commutes, i.e. χT A = χA ◦ ψ.
Proof. [7] p.72f.	✷
The retraction can be used to construct a solution for the determination problem. We would like to know when such a retraction exists.
Proposition 3.8 A retraction ψ for φ exists, if φ is monic, i.e. φ ◦ d1 =
φ ◦ d2 ⇒ d1 = d2 for any two points d1, d2 of D.
Proof. We can define ψ : T D → D by ψ ◦ x = d1 for φ ◦ d1 = x (injectivity).
ψ is a retraction if ψ ◦ φ ◦ d1 = d1. This is true due to the definition of ψ. ✷
The two propositions guarantee that our standard type preserving lifting according to Definition 3.5 for characteristic functions always works.
Type and Function Preservation
The combination of both forms of preservation, type and function preservation, shall result in a function lifting which respects types. The main problem is that the representation is introduced on the original domain, not on its constrained forms, the types. We carry out two investigations. Firstly, we consider the integration of the representation into the characteristic function definition. Secondly, we integrate types into function preservation.

We extend the definition of χT A to an extended form χ∼
which also

respects the representation ∼.
Definition 3.9 The extended lifting χ∼

for characteristic function lifting

χT A is defined by:



~
T A	T A
x =  χT A ◦ ιT A ◦ x	if x ∼ φ ◦ a for some point a : A
 false	otherwise



The map χ∼
yields the same result for all points x : T A which are equiva-

lent to some φ◦a. The extended form χ∼
subsumes the standard construction

χT A.
Let us now consider so-called type-compliant functions for a domain D.
Definition 3.10 A function f : A → B is called type-compliant with the characteristic functions χA : D → Ω and χB : D → Ω, if whenever χA ◦ιA ◦a = true for some point a of A, then χB ◦ ιB ◦ f ◦ a = true.
The lifted function T f should preserve the function f , but T f should also respect the type constraints, i.e. should be type-compliant, if f is so.

Proposition 3.11 Assume the maps φA : A → T A, φB : B → T B, f : A →
B, T f : T A → T B and corresponding characteristic functions χA : D → Ω,

χB : D → Ω, χ∼
: T D → T Ω and χ∼
: T D → T Ω for a given domain D.

If
T f preserves function f,

(a) χ∼
preserves type χA and (b) χ∼
preserves type χB,

f is compliant with χA and χB,
then, T f is compliant with χ∼	and χ∼ .


Proof. We assume χA ◦ ιA ◦ a ⇒ χ∼
ιT A ◦ φA ◦ a (2a) and χB ◦ ιB ◦ f ◦ a ⇒

~ ◦ ιT B ◦ φB ◦ f ◦ a (2b). We have to show: if χA ◦ ιA ◦ a ⇒ χB ◦ ιB ◦ f ◦ a
(3), then χ∼ ◦ ιT A ◦ φA ◦ a ⇒ χ∼	◦ ιT B ◦T f ◦ φA ◦ a. From χA ◦ ιA ◦ a we
get χ∼ ◦ ιT A ◦ φA ◦ a via (2a) and χB ◦ ιB ◦ f ◦ a via (3), from the latter also
~ ◦ ιT B ◦φB ◦f ◦a via (2b). We know that T f ◦ ιT A ◦φA ◦a ∼ χB ◦ ιB ◦f ◦a
since T f preserves the function f via (1). χ∼	works as an equalizer on the

equivalent values: χ∼
◦T f ◦ ιT A ◦ φA ◦ a = χ∼
χB ◦ ιT B ◦ f ◦ a.	✷

Since there is only one truth-value object Ω = T Ω, we have χT A = χA ◦ ψ where ψ is a retraction of φ. If φ∼ is a full representation mapping, we can define χT A = χA ◦ ψ∼ ◦ ι where ψ∼ is a retraction of φ∼. The map ψ is not needed in this construction, we can construct via the quotient.

Superposition
We shall now attempt to summarise the previous results and define a com- prehensive superposition operator which shall guarantee type and function preservation for lifted types and functions.

Basic Categories and Functors for Type and Function Lifting
Let T be a lifting – technically an endomap on a given category, i.e. it maps certain objects (domains and types) to the corresponding lifted objects. It respects the function typing, i.e. f : A → B is mapped to T f : T A → T B. However, T might not be a functor. All elements participating in property- preserving liftings (based on the lifting triple and derived constructs) shall be collected in a construct called the superposition category.
Definition 4.1 A superposition category E for lifting triple ⟨T , ∼, φ∼⟩
and a given base category C shall contain the following elements:
Objects (all objects are C-objects):
domain D, types A, B, ... , a truth-value object Ω,
extensions T1X, T2X, ... where X is type, domain or truth-value object or extension, and T1, T2,... are mappings on objects,

quotients T X/∼1, T X/∼2,... for extensions T X of domains and types with respect to representations ∼1, ∼2,... .
Maps (all maps are C-maps):
identities 1X : X → X on all objects X,
functions on domains, types, and quotients f : X → X where X is domain, type or quotient,
characteristic functions χX : D → Ω from domains or types to truth-value objects,
maps between a domain and quotient, between type and domain, between domain and extended domain, between domain and quotient of extension, between types.
We assume a single domain D of values, similar to a universe domain in some type systems.
Proposition 4.2 The superposition category E is well-deﬁned.
Proof. Identity and composition are those defined for C. The category E is a subcategory of the base category C.	✷
Based on the category E, which comprises all elements needed in our approach, we define two major subcategories of E which will capture function preservation, viz. Ef , and type preservation, viz. Et, in isolation. Additionally, two functors expressing the extensions will be defined on these subcategories.
Functions
We are going to define a subcategory of the superposition category which captures the concepts of function preservation in a categorical setting.
Definition 4.3 The category of functions Ef for the superposition cate- gory E shall contain the following (all elements are taken from category E):
Objects: domain D, types A, B, ... , extensions T A, T B, ... and quotients
T A/∼, T B/∼,... for any T and ∼.
Maps: functions on domains, types, quotients and identities on each object.
Proposition 4.4 Category Ef is well-deﬁned and forms a full subcategory of extension category E.
Proof. Since composition and identity are elements of E, Ef is well-defined. The set of objects is a subset of objects of E. Maps of Ef also form a subset of maps of E. Thus, Ef is a subcategory of E. For each typed set of functions (hom-set) of E, the whole set forms the corresponding hom-set in Ef . Thus, we have a full subcategory.	✷
We can construct an inclusion functor Υf : Ef ‹→ E mapping elements of Ef into E. The functor Υf is a monomorphism. The category Ef is the

structural framework on which a functor T f describes function preserving liftings.
Definition 4.5 The endofunctor T f on Ef , called the function preserva- tion functor, shall be defined as follows:
T f maps the domain D to the quotient of the lifted object T D/∼.
T f maps a function f : D → D to [T f ]: T D/∼→ T D/∼ such that function behaviour is preserved.
Proposition 4.6 The functor T f is well-deﬁned.
Proof. Identity and composition have to be considered. T f (1D)= 1T D/∼ due to function preservation φ∼ ◦ [1D]= [1T D] ◦φ∼ and T f (g ◦f )= T f (g) ◦T f (f ) due to composability of functions in Ef .	✷
A functor is faithful, if the induced mapping on each hom-set is injective.
T f satisfies this property.
Proposition 4.7 The functor T f is faithful, if the underlying representation mapping φ∼ is faithful.
Proof. Injectivity is the key requirement in the definition of a faithful repre- sentation mapping φ∼ on which T f is based for each f : A → B. Suppose f maps a to b1 and g maps a to b2 for g : A → B. f and g are distinguishable. If b1 and b2 are distinguishable, so will be φ∼ ◦ b2 and φ∼ ◦ b2. Thus, [T f ] and [T g] are distinguishable.	✷
However, T f is not necessarily a full functor. It is normally also not unique – this is only the case if the representation mapping is full. In that case T f is an isomorphism.
Types
Analogously to functions, we are going to define a category Et and a functor T t based on the superposition category E and a lifting triple ⟨T , ∼, φ∼⟩ to capture type preservation. Category Et satisfies properties similar to those of Ef .
Definition 4.8 The category of types Et for the superposition category E
shall contain the following elements:
objects: domain D, types A, B, ... , extensions T A, T B, ... and the truth- value objects.
maps: characteristic functions and identities on each object.
Proposition 4.9 Category Et is well-deﬁned and forms a full subcategory of the superposition category E.

Proof. Analogously to Proposition 4.4.	✷

Analogously, we can construct an inclusion functor Υt : Et ‹→ E, where Υt is a monomorphism. Let us now define the endofunctor T t on Et.

Definition 4.10 The endofunctor T t on Et, called the type preservation functor, shall be defined as follows:
T t maps the domain D to T D and the truth-value object Ω to T Ω.

T t maps a characteristic function χA : D → Ω to χ∼
: T D → T Ω such

that types are preserved. In particular, T t maps identities 1X to 1T X for domains.
The truth-value object is unique to the category, i.e. Ω = T Ω. Remember,

that applying Definition 3.9 to define χ∼
guarantees type preserving function

liftings. We do not have to look at this issue explicitly.

Proposition 4.11 The functor T t is well-deﬁned.
Proof. Identity and associativity of composition have to be considered. It

holds T
t(1D) = 1T tD by definition and T
t(g ◦ f ) = T
t(g) ◦T t(f ), since at

least one of f, g has to be the identity (the characteristic map can only be
composed with identities in this category).	✷

Proposition 4.12 Functor T t is faithful, if the underlying mapping φ is monic.
Proof. Analogously to T f .	✷

The functor T t is not necessarily a full functor. It is normally also not unique. This is only the case if it full (and faithful), and thus, an isomorphism.

Natural Transformations
Now, we are going to reformulate the mappings φ∼ and φ on a higher level of abstraction as natural transformations between functors on the function category and the type category, respectively. We look at functions first. A natural transformation in the context of function preservation is a function φ that assigns a map φA : 1(A) → T (A) for each object A. We define for the remainder φf : = φ∼ and φt : = φ in order to achieve a consistent style of naming when all constructs will finally be assembled.

Proposition 4.13 Let T f be an endofunctor and 1f the identity functor on

Ef . Then, φf is a natural transformation from 1f to T f :


T f A
[T f f)]
T f B

ˆ
f A

1f A
ˆ
f B
1f f
1 B

Proof. The diagram commutes since T f is an endofunctor on Ef , see Prop.
4.6. Commutativity is guaranteed due to function preservation.	✷
Proposition 4.14 Let T t be an endofunctor on Et and 1t the identity functor on Et. Then, φt is a natural transformation from 1t to T t:


T tD
T tχT A)
T tΩ

ˆ
t D

1tD
ˆ
t
Ω
1tχA)	t

Proof. The diagram commutes since T t is an endofunctor on Et, see Prop.
4.11. Commutativity is guaranteed due to the type preservation require- ment.	✷
The Superposition Operator
Finally, all constructs will be assembled together in order to form a type and function preserving superposition operator which, for a given model (a set of objects and maps) and a lifting triple, constructs a lifted model (another set of objects and maps) which superimposes the definition of the base one.
Definition 4.15 Let E be a superposition category for a lifting triple ⟨T , ∼
, φ∼⟩ with full subcategories Et (the type category) and Ef (the function category). The quintuple
⟨ T : E → E, T t : Et → Et, φt : 1t →T t, T f : Ef → Ef , φf : 1f →T f ⟩
or ⟨T , T t, φt, T f , φf ⟩ is a superposition, if the following is satisfied:
T is an endomap on E,
T t is an endofunctor on Et,
φt is a natural transformation from 1t to T t on Et,
T f is an endofunctor on Ef ,
φf is a natural transformation from 1f to T f on Ef .

The operator is well-defined, i.e. it guarantees type and behaviour preser- vation of functions f : A → B in liftings T f : T A → T B. Remember that type compliancy of the extension (which is caused by interaction between type and function properties) is guaranteed, if the basic function is type-compliant.
Theorem 4.16 [Superposition Theorem] Every type and function prop- erty of the underlying model is a property of the transformed model if the superposition operator is applied.
Proof. Both transformations, represented by (T t, φt) for type liftings and (T f , φf ) for function liftings preserve the respective properties, see Proposi- tions 4.6, 4.11, 4.13 and 4.14.	✷
Laws of Superposition
After defining our main extension operator, the superposition, we are going to investigate some properties connected to this operator. One of the important questions addresses the compositionality of the operator. Let us summarise the context briefly. The underlying mappings T1, T2,... are in general not functors; associativity of composition is consequently not guaranteed. Com-

position of functors T f
and T f
on quotients and analogously for the type

functor involving truth-value objects is not relevant. These constructs only constrain one particular step. Quotients, for instance, are a means to capture which behaviour has to be preserved for a single step; it is not relevant for a second lifting. Subject to composition are only mappings on types, e.g. from A to T1A and from T1A to T2T1A, and on functions, e.g. f to T1f and T1f to T2T1f . A result about the compositionality of extensions shall be formulated.

Definition 4.17 We construct a category E→ based on the superposition category E. Maps T1,... , Tn shall be endomaps on E:
Objects are functions, including basic ones f : A → B or g : B → C, ... , and extended ones T1f : T1A → T1B or T2g : T2B → T2C, ... 
Maps on objects are triples of maps (φA, φB, TF ) which map the object f : A → B to T f : T A → T B with domain mappings φA : A → T A, φB : B → T B, and a function lifting TF : F → T F (F is the set of basic functions, T F the set of extended functions, etc.) such that T A preserves type A, T B preserves type B and T f preserves function f ,
The identity is (1A, 1B, 1F ),
The composite of two maps (φT A, φT B, φT F )◦(φA, φB, φF ) is defined element- wise by (φT A ◦ φA, φT B ◦ φB, φT F ◦ φF ).
Maps in the category E→ are property-preserving liftings of functions. The definition states that the composition of property-preserving lifting of functions is associative.

Proposition 4.18 The category E→ is well-deﬁned.
Proof. Identity and associativity of composition have to be shown.
Identity: (1A, 1B, 1F ): (f : A → B) '→ (f' : A → B) is the identity since we have function preservation 1B ◦ f = f' ◦ 1A of f in f'.
Associativity: The maps φA, φB are E-maps. Their composition is as- sociative. F is the set of functions in E. Composition for maps in F is associative. Thus, the composition of function liftings T1,... , Tn is also associative.
✷

Discussion
Applying our superposition operator results in a model presented in layers, each superimposing the layer below. The layers are specified using superpo- sition and (possibly) augmentation. Redefinition with property preservation is captured by superposition. In order to provide a useful tool kit, so-called superposition schemes need to be introduced - essentially a library of common superpositions which have been obtained by applying our concepts to language semantics. Details about this in an earlier work can be found in [12].
Our approach compares to the application of monads in language seman- tics in that modular extensions of existing semantic models by new features are sought. Unlike Moggi’s work [8] for modular language semantics, we do not assume a particular form of semantics (programs having computations as their semantics), thus we can provide a more general framework. Another framework, which is similar to ours, is Hoare and Jifeng’s approach to linking theories in their unified theory of programming [4]. Our framework attempts to provide a similar tool kit for relating algebras. Refinement calculi for soft- ware development are well established [9]. We have presented a refinement approach for the stepwise development of algebraic models.
In the future, we plan to apply this framework. A promising application area is component technology. Component technology aims at reusing software through component libraries. Often, matching of requirements with services provided by a library component does not succeed. Support for automatic and semi-automatic adaptation can solve this problem. Adapting functionality of a library component to extended structural requirements can be facilitated using the techniques presented here.

Acknowledgements
We are grateful to the anonymous reviewers who have helped to improve the paper considerably.

References
M. Barr and C. Wells. Category Theory for Computing Science. Prentice Hall, 1995. (second edition).
P.M. Cohn. Universal Algebra. Harper and Row Publishers, 1965.
G. Gra¨tzer. Universal Algebra. D. van Nostrand Company, 1968.
C.A.R. Hoare and H. Jifeng. Uniﬁed Theories of Programming. Prentice Hall, 1998.
C.B. Jones. Data Reification. In J.A. McDermid, editor, The Theory and Practice of Reﬁnement. Butterworths, 1989.
C.B. Jones. Systematic Software Development with VDM. Prentice Hall, 1990.
F.W. Lawvere and S. Schanuel. Conceptual Mathematics. Cambridge University Press, 1998.
E. Moggi. Notions of Computation and Monads. Information and Computation, 93:55–92, 1991.
C. Morgan. Programming from Speciﬁcations 2e. Addison-Wesley, 1994.
C. Pahl. A Modular Development of the Denotational RSLConcurrency Model. Technical Report IT-TR:1997-016, Department of Information Technology, Technical University of Denmark, 1997.
C. Pahl. Modular, Behaviour Preserving Extensions of the Unix C-shell Interpreter Language. Technical Report IT-TR:1997-014, Department of Information Technology, Technical University of Denmark, 1997.
C. Pahl. Modular Composition of Language Features through Language Extensions. In A. Butterfield and S. Flynn, editors, Proc. 3rd Irish Workshop on Formal Methods, July 1999, Galway, Ireland, Electronic Workshops in Computing. Springer-Verlag, 1999.
