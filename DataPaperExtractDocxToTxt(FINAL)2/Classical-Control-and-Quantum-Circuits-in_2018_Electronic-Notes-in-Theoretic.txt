Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 336 (2018) 257–279
www.elsevier.com/locate/entcs

Classical Control and Quantum Circuits in Enriched Category Theory
Mathys Rennela
Institute for Computing and Information Sciences Radboud University
Nijmegen, The Netherlands

Sam Staton
Department of Computer Science Oxford University
Oxford, United Kingdom


Abstract
We describe categorical models of a circuit-based (quantum) functional programming language. We show that enriched categories play a crucial role. Following earlier work on QWire by Paykin et al., we consider both a simple first-order linear language for circuits, and a more powerful host language, such that the circuit language is embedded inside the host language. Our categorical semantics for the host language is standard, and involves cartesian closed categories and monads. We interpret the circuit language not in an ordinary category, but in a category that is enriched in the host category. As an extended example, we recall an earlier result that the category of W*-algebras is dcpo-enriched, and we use this model to extend the circuit language with some recursive types.
Keywords: Enriched categories, categorical semantics, linear type theory, quantum circuits, relative monad, quantum domain theory

Introduction


One of the subtle points about quantum computation is the interaction between classical control flow and quantum operations. One can measure a qubit, de- stroying the qubit but producing a classical bit; this classical bit can then be used to decide whether to apply quantum rotations to other qubits. This kind
control

Classical	Quantum
measurements

of classical control can be neatly described in quantum circuits, for example when one uses the measurement outcome of a qubit a to conditionally perform a gate X

https://doi.org/10.1016/j.entcs.2018.03.027
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

on a qubit b:

b a

(1)

This can be understood semantically in terms of mixed states, density matrices,
and completely positive maps. However, high level languages have more elaborate data structures than bits: they have higher order functions and mixed variance recursive types, and associated with these are elaborate control structures such as higher order recursive functions. These are important, paradigmatic ways of structuring programs.
How should these high level features be integrated with quantum computation? One option is to build a semantic domain that accommodates both quantum com- putation and higher order features. This is an aim of some categorical semantics of the quantum lambda calculus [21,17] and of prior work of the authors [24,26]. This is a fascinating direction, and sheds light, for example, on the structure of the quantum teleportation algorithm (e.g. [21, Ex. 6]). However, the general connection between physics and higher-order quantum functions is yet unclear. Although some recent progress has been made [14], it is still unclear whether higher-order quantum functions of this kind are useful for quantum algorithms.
Another approach is to understand a high level quantum programming language as an ordinary higher-order functional language with extra features for building and running quantum circuits. In this setting, quantum circuits form a first-order embedded domain specific language within a conventional higher order language. This fits the current state-of-the-art in interfaces to quantum hardware, and is the basis of the languages Quipper [10] and LiQUi|⟩ [31]. This is the approach that we study in this paper.

Embedded languages and enriched categories
Our work revolves around a new calculus that we call ‘EWire’ (§2). It is a minor generalization of the QWire language [22]. QWire idealizes some aspects of the architecture of Quipper and LiQUi|⟩. The idea is that we deal with a host language separated from an embedded circuit language.
The circuit language is a first order typed language. The types, called ‘wire types’, include a type for qubits. The wire type system is linear to accommodate the fact that qubits cannot be duplicated.
The host language is a higher order language. The types of the host language do not include the wire types, there is not a type of qubits, and it is not a linear type system. However, there is a special host type Circ(W1, W2) associated to any pair of wire types W1 and W2, whose inhabitants are the circuits with inputs of type W1 and outputs of type W2.
Let us describe the circuit language in a nutshell: the very simple circuit (1) cor- responds to the instruction below (2) in the circuit language. Given two qubits a and b, it measures the qubit a, stores the result in a bit x which is later used in the

application of the classical-controlled-X gate and discards the bit x, then outputs the resulting qubit y.


−; a, b : qubit ▶ C	d=ef
x → gate meas a; (x, y) → gate (bit-control X) (x, b); () → gate discard x; output y	: qubit	(2)

The interface between the host language and the circuit language is set up in terms of boxing and unboxing. For example, the instruction


t  d=ef
box (a, b) ⇒ C(a, b)	(where C is as in (2))	(3)

creates a closed term of type Circ(qubit⊗qubit,qubit) in the host language. We recover the instruction C in the circuit language (2) from the boxed expression t in the host language (3) by using the instruction unbox tw for some fresh wire w of type qubit.
Also, it is possible to write a program that composes two circuits C1 and C2
with the right input/output types, for example:

This is a program

comp d=ef
λ(C1, C2). box w1 ⇒  w2 → unbox C1w1; w3 → unbox C2w2; output w3 

in the host language, associated with the type
comp : Circ(W1, W2) × Circ(W2, W3) → Circ(W1, W3)	(4) where Wi is the type of the wire wi for i ∈ {1, 2, 3}.
Now, recall the idea of an enriched category, which is informally a category such that the morphisms from A to B form an object of another category. In Section 3, once we conceptualize types as objects and terms as morphisms, we show that the embedding of the circuit language in the host language is an instance of enriched category theory : the circuits (morphisms) between wire types (objects) form a type (object) of the host language. The host composition term in (4) is precisely composition in the sense of enriched categories. (See §3 for details.)
For a simple version of the model, wire types are understood as finite-dimensional C*-algebras, and circuits are completely positive unital maps – the accepted model of quantum computation. Host types are interpreted as sets, and the type of all circuits is interpreted simply as the set of all circuits. The category of sets supports higher order functions, which shows that it is consistent for the host language to have higher order functions.
As with any higher order language, the set-theoretic model is not sufficient to fully understand the nature of higher order functions. We envisage that other semantic models (e.g. based on game semantics or realizability) will also fit the

same framework of enriched categories, so that our categorical framework provides a sound description of the basic program equivalences that should hold in all models. These equivalences play the same role that the β and η equivalences play in the pure lambda calculus. In other words, we are developing a basic type theory for quantum computation.
Recursive types and recursive terms
Within this semantic model, based on enriched categories, we can freely accom- modate various additional features in the host language, while keeping the circuit language the same. For example, we could add recursion to the host language, to model the idea of repeatedly trying quantum experiments, or recursive types, to model arbitrary data types. This can be shown to be consistent by modifying the simple model so that host types are interpreted as directed complete partial orders (dcpo’s).
Many quantum algorithms are

actually parameterized in the num- ber of qubits that they operate on. For example, the Quantum Fourier Transform (QFT) has a uniform def- inition for any number of qubits,
|x1⟩ 	•	 ··· 	•	•	
|x2⟩
|x3⟩
.
.
|xn⟩
|yn⟩
|yn−1⟩
|yn−2⟩
.
.
|y1⟩

where H
is the Hadamard gate	x

1	1 1
2  1 −1

and Rn is the Z rotation
 



We formalize this by extending the circuit language with a wire type QList of qubit-lists for which the following equivalence of types holds:
QList ∼= (qubit ⊗ QList) ⊕ 1 so that we can define a function
fourier : Circ(QList, QList)
In Section 4, we part away from the canonical intuition of circuits by considering them as first-order and linear (in the linear logic sense of the term) instructions. In practice, it will be useful for a circuit layout engine to know the number of qubits in the lists, suggesting a dependent type such as
fourier : (n : Nat) → Circ(QList(n), QList(n))
but we leave these kinds of elaboration of the type system to future work.
The categorical essence of recursive data types is algebraic compactness. In short, one says that a category C is algebraically compact (for a specific class of endofunctors) when every endofunctor F : C → C has a canonical fixpoint, which is the initial F-algebra [3]. In earlier work [24], the first author has shown that the

category of W*-algebras is algebraically compact and enriched in dcpo’s, and so this is a natural candidate for a semantics of the language. In brief: circuit types are interpreted as W*-algebras, and circuits are interpreted as completely positive sub-unital maps; host types are interpreted as dcpo’s; in particular the collection of circuits Circ(W, Wj) is interpreted as the dcpo of completely positive sub-unital maps, with the L¨owner order. In this way, we providea basic model fora quantum type theory with recursive types. We conclude the present work with what is, to our knowledge, the first categorical semantics of a language that can accommodate QFT in this parameterized way.

Functional programming and quantum circuits
We introduce a new calculus called EWire as a basis for analysing the basic ideas of embedding a circuit language inside a host functional programming language. EWire (for ‘embedded wire language’) is based on QWire [22] (‘quantum wire lan- guage’), and we make the connection precise in Section 2.2. One may add other features, for instance as discussed in Section 4.1.
We assume two classes of basic wire types.
Classical wire types, ranged over by a, b,... . The wire types exist in both the circuit language and the host language. For example, the type of classical bits, or Booleans.
Circuit-only wire types, ranged over by α, β,	These wire types only exist in
the circuit language. For example, the type of qubits.
From these basic types we build all wire types:
W, Wj ::= I | W ⊗ Wj | a | b | α | β ... 

We isolate the classical wire types, which are the types not using any circuit-only basic types:
V, V j ::= I | V ⊗ V j | a | b ... 
We also assume a collection G of basic gates, each assigned an input and an output wire type. We write G(Win, Wout) for the collection of gates of input type Win and output type Wout.
In addition to the embedded circuit language, we consider a host language. This is like Moggi’s monadic metalanguage [20] but with special types for the classical wire types a, b and a type Circ(W, Wj) of circuits for any wire types W and Wj. So the host types are
A, B ::= A × B | 1 | A → B | T (A) | Circ(W, W j) | a | b
The monad T is primarily to allow probabilistic computations, although one might also add other side effects to the host language. Notice that every classical wire type V can be understood as a first order host type |V |, according to the simple

translation, called lifting :
 V ⊗ V j d=ef |V |× V j	|I| d=ef 1	|a| d=ef a
Circuit typing and host typing
A well-formed circuit judgement Γ; Ω ▶ C : W describes a circuit with input context Ω= (w1 : W1 ··· wn : Wn) (for n ∈ N) and output wire type W under the context of host language variables Γ = (x1 : A1 ··· xm : Am) (for m ∈ N). Wires are organised in patterns given by the grammar p ::= w | () | (p, p) associated to the following set of rules:

—

· =⇒ () : 1
—
w : W =⇒ w : W
Ω1 =⇒ p1 : W1	Ω2 =⇒ p2 : W2

Ω1, Ω2 =⇒ (p1, p2): W1 ⊗ W2

Linear type theory for circuits
The first five term formation rules are fairly standard for a linear type theory. These are the constructions for sequencing circuits, one after another, and ending by outputting the wires, and for splitting a tensor-product type into its constituents. The fifth rule includes the basic gates in the circuit language.


Γ; Ω1 ▶ C1 : W1	Ω =⇒ p : W1	Γ; Ω, Ω2 ▶ C2 : W2

Γ; Ω1, Ω2 ▶ p → C1; C2 : W2
Ω =⇒ p : W

Γ; Ω ▶ output p : W

Ω =⇒ p : 1	Γ; Ωj ▶ C : W

Γ; Ω, Ωj ▶ () → p; C : W
Ω =⇒ p : W1 ⊗ W2	Γ; w1 : W1, w2 : W2, Ωj ▶ C : W

Γ; Ω, Ωj ▶ (w1, w2) → p; C : W

Ω1 =⇒ p1 : W1	Ω2 =⇒ p2 : W2	Γ; Ω2, Ω ▶ C : W
Γ; Ω1, Ω ▶ p2 → gate g p1; C : W
For example, coin flipping is given by the following circuit:
g ∈ G(W1, W2)

flip d=ef a → gate init0 (); aj → gate H a; b → gate meas aj; output b

Interaction between the circuits and the host
A well-formed host judgement Γ ▶ t : A describes a host-language program of type A in the context of host language variables Γ. The next set of typing rules describe the interaction between the host language and the circuit language. The host can run a circuit and get the result. Since this may have side effects, for example probabilistic behaviour, it returns a monadic type.
Γ; ·▶ C : W



Γ ▶ run C : T (|W|)
W classical

The next two rules concern boxing a circuit as data in the host language, and then unboxing the data to form a circuit fragment in the circuit language. Notice that unboxing requires a pure program of type Circ(W1, W2), rather than effectful

program of type T (Circ(W1, W2)). For example, you cannot unbox a probabilistic combination of circuits. The monadic notation clarifies this point.


Ω =⇒ p : W1	Γ; Ω ▶ C : W2

Γ ▶ box (p : W1) ⇒ C : Circ(W1, W2)
Γ ▶ t : Circ(W1, W2)	Ω =⇒ p : W1

Γ; Ω ▶ unbox tp : W2

Finally we consider dynamic lifting, which, informally, allows us to send classical data to and from the host program while the quantum circuit is running.


Γ ▶ t : |W|
Γ; −▶ init t : W

W classical
Ω =⇒ p : |W|	Γ,x : W ; Ωj ▶ C : Wj


Γ; Ω, Ωj ▶ x ⇐ lift p; C : Wj

W classical

These rules are in addition to the standard typing rules for the host language, following Moggi [20] (see Appendix A).
In Appendix B we recall a reduction relation on circuits, based on [22], which reduces a circuit with no free host variables to an expression in the following gram- mar
N ::= output p | w → gate g p; N | x ⇐ lift p; N | () → w; N | (w1, w2) → w; N
The reduction works by rearranging patterns and resolving unboxed boxes.
QWire
The language QWire of Paykin, Rand and Zdancewic [22] is an instance of EWire where:
there is one classical wire type, bit, and one circuit-only wire type, qubit.
there are basic gates meas ∈ G(qubit, bit) and new ∈ G(bit, qubit).
A subtle difference between EWire and QWire is that in QWire one can directly run a circuit of type qubit, and it will produce a bit, automatically measuring the qubit that results from the circuit. To run a circuit of type qubit in EWire, one must append an explicit measurement at the end of the circuit. These explicit measurements can be appended automatically, to give a translation from QWire proper to this instantiation of EWire. We now summarize how this is done. We first define a translation (−) from all wire types to classical wire types:
W ⊗ Wj d=ef W ⊗ Wj	I d=ef I	bit d=ef bit	qubit d=ef bit Then, from an arbitrary wire type W , we can extract a host type W .
From the basic gates meas and new we can define circuits measW : Circ(W, W ) and newW : Circ(W, W ) for all wires W . These are defined by induction on W . For example,
measI d=ef id	measbit d=ef id
measqubit d=ef box p ⇒ pj → gate meas p; output pj

meas

W ⊗W
′ d=ef box (w, wj) ⇒ x → unbox measW w; xj → unbox meas
output (x, xj)
′ wj;

and newW is defined using new G(bit, qubit) similarly. Then we define the following derived syntax, so that run and lift can be used at all wire types, not just the classical ones:

qwire-run(C) d=ef
run(x → C; unbox meas x)

(x ⇐ qwire-lift p ; C) d=ef
y ⇐ lift p ; x → unbox new y ; C

Categorical models of EWire
Let us define a sufficient set of properties which ensure that a pair of categories corresponds to a categorical model in which one can interpret EWire, in order to reason about circuits and identify their denotational meaning. We assume that the circuit language is parametrized by a fixed collection of gates, noted G.
Enriched categories. Our development is based on the theory of enriched cat- egories, which are increasingly widely used in programming language theory. We recall some basics. If H is a category with finite products ×, then a category C enriched in H is given by a collection of objects together with
for each pair of objects A and B in C, an object C(A, B) of H;
for each object A of C, a morphism 1 → C(A, A) in H;
for objects A, B, C of C, a morphism C(A, B) × C(B, C) → C(A, C) in H
such that composition satisfies the identity and unit laws. If C and D are enriched in H, an enriched functor F is a mapping from the collection of objects of C to the collection of objects of D together with, for objects A and B of C, a morphism C(A, B) → D(F (A),F (B)), respecting composition and identities in a suitable way.
For a first example, a locally small category is a category for which the collection of morphisms C(A, B) is a set; this is a category enriched in the category Set of sets and functions.
As a first illustration of the importance of enriched categories in computer science, recall that a model of the typed lambda calculus is a cartesian closed category, which is a category H with finite products that is enriched in itself.
Symmetric monoidal enriched categories. Recall that a symmetric monoidal category is a category C together with a distinguished object I and a functor
⊗ : C × C → C together with coherent associativity, identity and symmetry natural isomorphisms. Any category with products is an example of this, but more generally symmetric monoidal categories model linear type theories where weakening and contraction might not hold. An H-enriched symmetric monoidal category is defined in a similar way except that the functor must be an enriched functor and the isomorphisms must also be enriched natural transformations.

(Recall that for H-enriched functors F, G : C → D between H-enriched categories
C and D, an enriched natural transformation η : F ⇒ G is a family of morphisms
{ηc : 1 → D(Fc, Gc)}c∈Obj(C) in the category H which satisfy a straightforward naturality condition. See [13] for more details.)
Computational effects. Embedding the circuit language requires the use of some computational effects in the host language. When the circuit language involves quantum measurement, then the closed host term ▶ run flip : T (bit) is a coin toss, and so the semantics of the host language must accommodate probabilistic features.
Following Moggi, we model this by considering a cartesian closed category H with an enriched monad on it. Recall that an enriched monad is given by an endofunctor T on H together with a unit morphism η : X → T (X) for each X in H, and a bind morphism H(X, T (Y )) → H(T (X),T (Y )) for objects X and Y , subject to the monad laws [20].
The idea is that deterministic, pure programs in the host language are inter- preted as morphisms in H. Probabilistic, effectful programs in the host language are interpreted as Kleisli morphisms, i.e. morphisms X → T (Y ).
Relative monads. The monads of Moggi are a slightly higher order notion. In a truly first order language, this type arguably should not exist. In particular, there is no wire type T (A) of all quantum computations. To resolve this mismatch, authors have proposed alternatives such as relative monads [1] and monads with arities [4]. A relative adjunction is given by three functors J : B → D, L : B → C and
R : C → D such that there is a natural isomorphism C(L(b), c) ∼= D(J (b), R(c)). We write L J E R and call relative monad the functor RL : B → D.
Enriched relative adjunctions and enriched relative monads are defined in the obvious way, by requiring J , L and R to be enriched functors and the adjunction to be an enriched adjunction. In an enriched relative monad T = RL, the bind operation is a morphism of type D(J (X),T (Y )) → D(T (X),T (Y )).
Copowers. A copower is a generalization of an n-fold coproduct. Let n be a natural number, and let A be an object of a category C with sums, the copower n ⊙ A is the n fold coproduct A + ··· + A. This has the universal property that to give a morphism n ⊙ A → B is to give a family of n morphisms A → B. In general, if C is a category enriched in a category H, and A is an object of C and h an object of H, then the copower is an object h ⊙ A together with a family of isomorphisms C(h ⊙ A, B) ∼= H(h, C(A, B)), natural in B.
The relevance of Set-enriched copowers to quantum algorithms has previously been suggested by Jacobs [11]. On the other hand, copowers and enrichment play a key role in the non-quantum enriched effect calculus [7,19] and other ar- eas [16,18,23,29]. Nonetheless, our connection with the EWire syntax appears to be novel.

Definition 3.1 A categorical model of EWire (H, H0, C,T ) is given by the follow- ing data:
A cartesian closed category H with a strong monad T on H. This is needed to interpret the host language.
A small full subcategory j : H0 ⊆ H. The idea is that the objects of H0 interpret the first order host types, equivalently, the classical wire types: the types that exist in both the host language and the circuit language.
An H-enriched symmetric monoidal category (C, ⊗,I). This allows us to in- terpret the circuit language, and the H-enrichment allows us to understand the host types Circ(W, Wj).
The category C has copowers by the objects of H0. The copower induces a functor J : H0 → C defined by J (h) = h ⊙ I. Then, we have a natural isomorphism
C(J (h), C)= C(h ⊙ I, C) ∼= H(j(h), C(I, C))
and therefore a j-relative adjunction J jE C(I, −) between circuits and (host) terms. This functor J : H0 → C interprets the translation between first order host types and classical wire types.
For each object A of C, the functor A ⊗− : C → C preserves copowers. This makes the functor J symmetric monoidal, and makes the relative adjunction an enriched relative adjunction.
There is an enriched relative monad morphism
runh : C(I, J (h)) → T (j(h))
where the enriched relative monad C(I, J (−)) : H0 → H is induced by the enriched j-relative adjunction J jE C(I, −). This is the interpretation of running a quantum circuit, producing some classical probabilistic outcome.
If the category C has a given object [α ] for each basic quantum wire type α, and H0 has a given object [a] for each basic classical wire type a, then we can interpret all wire types W as objects of C:
[1]] d=ef I	[[a]] d=ef J ([[a]])	[W ⊗ Wj]] d=ef [[W ]] ⊗ [[W j]].
If the category C also has a given morphism [g]] : [[W1]] → [[W2 ] for every gate
g ∈ G(W1, W2), then we can interpret the circuit langauge inside C.
In light of those axioms, and to every categorical model of EWire, we associate the following denotational semantics. First, we define as promised the denotation of the host type Circ(W, Wj) by [[Circ(W, Wj)]] d=ef C(W, Wj), an object of the category
H. The semantics of the other host types is given as follows:
[1]] d=ef 1 [A × Aj]] d=ef [[A]] × [[Aj]] [[A → Aj]] d=ef ( [A]] → [[Aj]]) [T (A)]] d=ef T ([[A]]).

Ordered context of wires Ω have the following semantics:
[[•·⟩]] = I	[[w : W ]]= [[W ]]	[[Ω, Ωj]]= [[Ω ] ⊗ [[Ωj]]
A circuit judgement Γ; Ω ▶ t : W is denoted by
[Γ; Ω ▶ t : W ]] ∈ H([[Γ]], C([[Ω]], [[W ]]))
relying on the assumption that the category H is a model of the host language. A host type Circ(W, Wj) is interpreted as the hom-object C([[W ]], [[W j]]), in the category H. In this setting, denotations of boxing and unboxing instructions are trivial. Indeed, notice that whenever Ω =⇒ p : W1 holds, we have [[Ω]] ∼= [[W1]], and we put
[[Γ ▶ box (p : W1) ⇒ C : Circ(W1, W2)]]= [[Γ; Ω ▶ C : W2]]
[Γ; Ω ▶ unbox tp : W2]]= [[Γ ▶ t : Circ(W1, W2)]]
The denotation of output p : W is the identity when the type of the pattern p is not a sum type, and is the i-th projection when p is of the form ini pj. Moreover, instructions Γ; Ω, Ωj ▶ () → p; C : W and Γ; Ωj ▶ C : W (resp. Γ; Ω, Ωj ▶ (w1, w2) → p; C : W and Γ; w1 : W1, w2 : W2, Ωj ▶ C : W ) have isomorphic denotations whenever Ω =⇒ p : 1 holds (resp. Ω =⇒ p : W1 ⊗ W2 holds).
The lift construction is interpreted by the copower. In detail, for every object h
of H, and every object hj of H0, we consider the isomorphism
lifth : H(h × hj, C(X, Y )) ∼= H(h, H(hj, C(X, Y ))) ∼= H(h, C(hj ⊙ X, Y ))
Since we’re enforcing explicit measurement here, the denotation of the operation
run for a circuit C whose output wire type is the type W is given by Def. 3.1(vi).
The denotations of the remaining instructions are given as follows.
[Γ; Ω1, Ω ▶ p2 → gate g p1; C : W ]]= [[Γ; Ω2, Ω ▶ C : W ]] ◦ ([[g]] ⊗ id)
[Γ; Ω1, Ω2 ▶ p → C; Cj : Wj]]= [[Γ; Ω, Ω2 ▶ Cj : Wj]] ◦ ([[Ω1 ▶ C : W ]] ⊗ id)
Consider the operational semantics given in Appendix B. Assuming that H is a sound categorical model of the host language, one obtains the following theorem by straightforward induction on typing judgements. (This is similar to the proof in [22, App. B].)
Theorem 3.2 (Soundness) For every denotational semantics induced by a cate- gorical model of EWire, if the circuit judgement ·;Ω ▶ C : W holds and the circuit C reduces to a circuit Cj, then [[·;Ω ▶ C : W ]]= [[·;Ω ▶ Cj : W ]].
It is now time to elaborate an example. Our view on the semantics of quantum computing relies on the theory of C*-algebras. The positive elements of C*-algebras correspond to observables in quantum theory, and we understand quantum compu- tations as linear maps that preserve positive elements, in other words, ‘observable

transformers’. Circuits (·; (x : W ) ▶ C : Wj) will be interpreted as completely posi- tive unital maps [Wj]] → [[W ]. The reverse direction is in common with predicate transformer semantics for conventional programming.
In short, a (unital) C*-algebra (e.g. [27]) is a vector space over the field of complex numbers that also has multiplication, a unit and an involution, satisfying associativity and unit laws for multiplication, involution laws (e.g. x∗∗ = x, (xy)∗ = y∗x∗, (αx)∗ = α¯(x∗)) and such that the spectral radius provides a norm making it a Banach space.
There are two crucial constructions of C*-algebras: matrix algebras and direct sums. Matrix algebras provide a crucial example of C*-algebras. For example, the algebra M2 of 2 × 2 complex matrices represents the type of qubits. The direct sum of two C*-algebras, A⊕B, is the set of pairs with componentwise algebra structure. For instance, C ⊕ C represents the type of classical bits. Every finite-dimensional C*-algebra is a direct sum of matrix algebras.
The tensor product ⊗ of finite dimensional C*-algebras is uniquely determined by two properties: (i) that Mk ⊗ Ml ∼= Mk×l, and (ii) that A ⊗ (−) and (−) ⊗ B preserve direct sums. In particular Mk ⊗ A is isomorphic to the algebra of (k × k)- matrices valued in A.
We do not focus here on linear maps that preserve all of the C*-algebra structure, but rather on completely positive maps. An element x ∈ A is positive if it can be written in the form x = y∗y for y ∈ A. These elements correspond to quantum observables. A map f : A → B, linear between the underlying vector spaces, is positive if it preserves positive elements. A linear map is unital if it preserves the multiplicative unit. A linear map f is completely positive if the map (Mk ⊗ f ) : Mk ⊗A → Mk ⊗B is positive for every k. This enables us to define a functor C⊗(−) for every finite dimensional C*-algebra C. Thus finite dimensional C*-algebras and completely positive unital linear maps form a symmetric monoidal category. There are completely positive unital maps corresponding to initializing quantum data, performing unitary rotations, and measurement, and in fact all completely positive unital maps arise in this way (e.g. [28,30]).

Proposition 3.3 The triplet (FdC∗-Algop
, Set, D) is a model of EWire, formed

by the category FdC∗-AlgCPU of ﬁnite-dimensional C*-algebras and completely pos- itive unital maps, the cartesian closed category Set of sets and functions, and the probability distribution monad D over Set. In fact it is a model of QWire, with

[[qubit]]
def
= M2 and [[bit]]
def
= C ⊕ C.

Proof. See Appendix C.	2

Steps towards subsets and variations on quantum computation
Completely positive maps between C*-algebras allow for all quantum opera- tions, but sometimes one would focus on a variation of quantum computation, or a restricted set of gates, such as the stabiliser gates.
Definition 3.4 A category of quantum computation is a subcategory Q of the cate-

gory C∗-AlgCPU of C*-algebras together with completely positive unital maps. For the sake of coherence, we also require:
Initiality: the C*-algebra C of complex numbers is in Q.
Closure under matrix algebras: if A is in Q then so is Mn ⊗ A (n ∈ N).
Closure under matrices of morphisms: for every pair (A, B) of C*-algebras in
Q, if the map f in Q(A, B) then the map (Mn ⊗ f ) in Q(Mn ⊗ A, Mn ⊗ B).
Different choices for the category Q give different classes of states and unitaries for our language, making Q the ‘categorical signature’ of the subset of quantum mechanics associated with the collection G of gates which parametrize QWire.
For example, we define a category of quantum computation which only contains matrix algebras and the completely positive unital maps generated by the stabilizer states of the Clifford group [26, Sec. 1.3]. We call this category Clifford; it corre- sponds to stabilizer quantum mechanics [2], which can be efficiently simulated by classical computers.
Then, considering that the single-qubit Clifford group together with the gate

T =	iπ
0 e 4
can approximate any single-qubit unitary up to an arbitrary accuracy

[5], adding the completely positive unital map T∗ − T generated by the gate T to
the maps of the category Clifford forms a category CliffordT that is arguably the smallest category which corresponds to a reasonably complete subset of quantum theory.

A step towards quantum domain theory
A W*-algebra is an unital C*-algebra A whose unit interval is a dcpo, with suffi- ciently many normal states, i.e. normal completely positive unital maps A → C. We write W∗-AlgCPSU for the category of W*-algebras and completely positive subunital maps, which is known for being Dcpo⊥-enriched (see e.g. [24]), where Dcpo⊥ is the category of pointed dcpos and Scott-continuous maps.
In fact, its opposite category is part of a categorical model of QWire (as shown in Appendix C), when one considers the restricted version of the monad of sub- valuations V = dcGEMod([0, 1](−), [0, 1]) on Dcpo⊥ (see e.g. [12, Section 5.6]), where the category dcGEMod is the category of directed-complete generalized ef- fect modules and Scott-continuous effect module homomorphisms, also introduced as a category of quantum predicates in [25,26].


Proposition 4.1 (W∗-Algop
, Dcpo⊥,V ) is a categorical model of QWire.

The remaining part of this section is devoted to an investigation of the extra

syntax supported by the category W∗-Algop
. We argue that the present work

constitutes a milestone for the development of quantum domain theory. The inter- ested reader will find the proofs in Appendix C.

Extensions of EWire
Let us part away from the traditional notion of circuits in order to be able to deal with inputs and outputs of sum types and recursive types: in what follows, circuits are first-order linear instructions. Therefore, the structures that our circuit language manipulate are not per se circuits but generalised circuits.

Conditional branching
To extend EWire with conditional branching, one needs to introduce sum types (that is, W ::= ··· | W ⊕Wj and A ::= ··· | A+Aj), and gates in1 ∈ G(W1, W1 ⊕W2) and in2 ∈ G(W2, W1 ⊕ W2) for every pair of types W1 and W2. Additionally, we introduce case expressions
case p of (in1 w1 → C1 | in2 w2 → C2): W

(where p : W1 ⊕ W2, C1 : Circ(W1,W ) and C2 : Circ(W2,W )) and extend the grammar of patterns:
p ::= ··· | in1 p | in2 p
Then, bit is 1 ⊕ 1. A wire type W ⊕ Wj is classical if W and Wj are classical, and then |W ⊕ Wj| d=ef |W| + |Wj|.

Patterns of sums are eliminated using
Ω =⇒ p : Wi


Ω =⇒ ini p : W1 ⊕ W2
i ∈ {1, 2} and the

typing rule for branching is the following:
Ω =⇒ p : W1 ⊕ W2	Γ; w1 : W1, Ωj ▶ C1 : W	Γ; w2 : W2, Ωj ▶ C2 : W

Γ; Ω, Ωj ▶ case p of (in1 w1 → C1 | in2 w2 → C2): W

Recursive types
Let us complete the grammars of wire types and host types:
W ::= ··· | X | μX.W	A ::= ··· | X | μX.A
A wire type μX.W is classical if W is, and |μX.W| d=ef μX. |W|.
We assume that G contains gates
foldμX.W ∈ G(W [X '→ μX.W ], μX.W )	unfoldμX.W ∈ G(μX.W, W [X '→ μX.W ])
which corresponds to the folding/unfolding of a recursive type μX.W . For example, for the type QList of quantum lists defined by QList = μX.qubit ⊗ X ⊕ 1, we have fold ∈ G(qubit ⊗ QList ⊕ 1, QList) and unfold ∈ G(QList, qubit ⊗ QList ⊕ 1). As another example, QNat d=ef μX.X ⊕ 1 is a wire type of natural numbers and Nat = μX.X + 1 is the host type of natural numbers. The type QNat is classical and |QNat| d=ef Nat.

In line with [8], we introduce the recursive typing rules as type judgements Θ ▶ τ , which entail that the type τ is well-formed with respect to the context of distinct type variables Θ. We introduce the following set of rules for typing judgements:
Θ ▶ W1	Θ ▶ W2	Θ,X ▶ W




Θ ▶ 1	Θ, X, Θj ▶ X
Θ ▶ W1
② W2
② ∈ {⊗, ⊕}


Θ ▶ μX.W

The typing judgement Θ ▶ Γ holds whenever Γ is a context of language variables such that Θ ▶ τ holds for every variable (x : τ ) ∈ Γ.
At this point, one might question the interest for recursive types in a circuit- based language. In the traditional conceptualization of circuits, lists and other infinite data types must be instantiated at a specific length to be used as the input type of a circuit and therefore (iso)recursive types cannot appear in the wire types of a circuit.
Let us illustrate our interest for patterns of recursive types by focusing on the pattern p : QList. We want to implement the Quantum Fourier Transform. Tak- ing inspiration from [22, Sec. 6.2] and [10], we assume a host language constant CR : Nat → Circ(qubit ⊗ qubit, qubit ⊗ qubit), so that (CR n) corresponds to the

controlled rotation by  2π
around the z-axis. Then the program rotations performs

the rotations of a QFT circuit and the instruction (fourier) corresponds to the QFT, as illustrated in the circuit in the introduction.
rotations :

length :
Circ ( QList , QNat QList ) =
box qs => 
case qs of [] => output (0 ,[])
| ( q: qs ’) =>
( n,qs ’) <- unbox length qs ’; output ( S n , q: qs ’) 
Nat -> Circ ( qubit QList , qubit QList ) =
lambda m. box ( c , qs ) =>
case qs of [] => output ( c ,[])
| ( q: qs ’) =>
( n,qs ’) <- unbox length qs ’ ; n <= lift n ;
( c,qs ’) <- unbox ( rotations m) ( c , qs ’) ;
( c ,q) <- unbox ( CR (1+m -n)) ( c ,q) ; output (c ,( q: qs ’))


fourier : Circ ( QList , QList ) =
box qs => 
case qs of [] => []
| ( q: qs ’) =>
qs ’ <- unbox fourier qs ’ ; ( n,qs ’) <- unbox length qs ’ ; n <= lift n ;
( q,qs ’) <- unbox ( rotations n) ( q , qs ’) 
q <- gate H q ; output (q , qs ’)
Here we are using some standard syntactic sugar for recursive types and lists. For example, length is more verbosely written
Y (lambda l. box qs => qs <- unfold qs ; case qs of 
in2 () => qs <- gate in1 () ; qs <- gate fold qs ; z <- gate in1 () ; z <- gate fold z ; output ( z , qs )
| in1 ( q , qs ) =>
( n , qs ) <- unbox l qs ;
qqs <- gate in1 ( q , qs ) ; qqs <- gate fold qqs ; n ’ <- gate in2 n ; n ’ <- gate fold n ;
output ( n ’, qqs ) )

where Y is a fixed point combinator, defined using recursive types. (This stan- dard QFT algorithm leaves the list in reverse order, and so for many purposes this program must be composed with a standard list reversal program, omitted here.)
Here, we consider recursive types because they are a quick way of introducing operations over lists, and these quickly fit into our categorical formalism. The drawback is that in quantum programming, it is useful to make the lengths of lists more explicit. For example, the type system does not tell us that (unbox fourier qs) has the same length as qs. This is a familiar problem in a functional language such as Haskell, but it is particularly inconvenient for a quantum circuit layout engine. A good way to deal with it would be through some kind of dependent types [22, 6.2], for instance allowing a type QArray(n) of arrays of qubits of size n and fourier : (n : Nat) → Circ(QArray(n), QArray(n)). However, what follows discusses categorical models of QWire in which one can denote recursive types, exploiting a presheaf-theoretic semantics which we intend to use as a foundation for a theory of quantum domains. Therefore, integrating dependent types to EWire/QWire and associating such types to an appropriate categorical semantics is left for future work.

Towards quantum domains
The notion of algebraic compactness provides a way to interpret recursive types. A Dcpo⊥!-enriched category C is algebraically compact [3] for locally continuous endofunctors if every locally continuous endofunctor F on C (i.e. F is such that all FX,Y : C(X, Y ) → C(FX, FY ) are Scott-continuous) has a canonical fixpoint written μF , which is the initial F -algebra (where Dcpo⊥! is the category of pointed dcpos and strict Scott-continuous maps).
Every algebraically compact category C, as part of a categorical model (C, H,T ), is a domain-theoretic model of FPC [8, Def. 6.7] and as such provides a computationally adequate model for the language FPC, a functional programming language with recursive types [8, Th. 7.14].
Consider that every type judgement Θ ▶ W is denoted by a locally continuous functor Cn → C, defined by inductions as follows:
[[Θ ▶ W ]](χ)= [[W ]] when W ∈ {1, bit, qubit}	[[Θ ▶ X]]= Id
[[Θ ▶ W1  W2]](χ)= [[Θ ▶ W1]](χ)  [[Θ ▶ W2]](χ) with  ∈ {⊗, ⊕}
[[Θ ▶ μX.W ]] = μ[[Θ,X ▶ W ]]
The algebraic compactness of the category of W*-algebras together with (completely) positive sub-unital maps has already been established [24]. This result establishes W*-algebras and completely positive unital maps as a categorical model of higher-order quantum computing. For example, the type QList is denoted by the fixpoint ⊕k≥0M2k of the endofunctor F : X '→ X ⊗ M2 ⊕ 1.
Ultimately, we are interested in quantum domains, that is in finding models and convenient programming languages that mix quantum features and classical

features more generally. Enriched category theory offers a compelling way to elevate ourselves from the theory of W*-algebras.
Indeed, whenever a category C is enriched over a category H, one can form a category of H-enriched presheaves [Cop, H], which inherits some of the structure of H and C. In particular, when a category C is enriched over a category Dcpo, order- enriched presheaves Cop → Dcpo are the objects of the free colimit completion of the category C as a Dcpo-enriched category. We recall that Malherbe et al. [17] also used presheaves in their steps towards a model of a higher-order quantum programming language.

Definition 4.2 Consider a categorical model of QWire (C, Dcpo,T ). A quantum predomain is an order-enriched contravariant presheaf F : Cop → Dcpo. A quan- tum domain is a quantum predomain whose root F (1) is a pointed dcpo, i.e. a dcpo which has a least element.

The literature is rich of examples of dcpo structures over quantum systems, upon which quantum (pre)domains can be built. Normal states NS(A) and predicates [0, 1]A of a C*-algebra A form dcpos whenever A is a W*-algebra. Projections Proj(A) on a finite-dimensional C*-algebra A, which are elements p of A which are self-adjoint (i.e., p = p∗) and idempotent (i.e., p = p2), are continuous lattices, used in von Neumann’s quantum logic. Furthermore, one can consider the dcpo C(A) of commutative C*-subalgebras of a C*-algebra A (seen as classical views of a quantum system) ordered by inclusion.
The following proposition will not come as a surprise to the reader familiar with enriched categories: mostly, it follows from the fact that the Yoneda embedding is full and faithful.

Proposition 4.3 Consider a categorical model of QWire (C, Dcpo,T ) where C is a small category of quantum computation. Then, the triplet ([Cop, Dcpo], Dcpo,T ) is a categorical model of QWire, where [Cop, Dcpo] is algebraically compact for locally continuous endofunctors.


Consequently, the triplet ([FdC∗-Algop
, Dcpo], Dcpo,V ) is a categorical

model of QWire, which will be investigated in future work.
Summary. We have introduced a new calculus, EWire (Sec. 2), for embedded circuits within an expressive host language. The language includes QWire as an instance (Sec. 2.2). We have proposed a notion of categorical model for EWire (Sec. 3) in which the relationship between the circuit and host language is explained in terms of enriched categories. Our first example of a model is based on the Set- enrichment of C*-algebras. Finally by considering a model of QWire based on W*- algebras and dcpos, we have introduced some recursive types to give a denotational semantics to the Quantum Fourier Transform.

Acknowledgement
The authors would like to thank Bart Jacobs, Michele Pagani and Shane Mansfield for helpful discussions, but also Bert Lindenhovius, Michael Mislove and Vladimir Zamdzhiev for hosting the first author at Tulane University during the elaboration of this work, and Jennifer Paykin for introducing us to the subtle aspects of QWire. The research leading to these results has received funding from the ERC grant agreement n. 320571, a Royal Society fellowship, and EPSRC grant EP/N007387/1.

References
Thorsten Altenkirch, James Chapman, and Tarmo Uustalu. Monads need not be endofunctors. In
Proc. FOSSACS’10, pages 297–311. Springer, 2010.
Miriam Backens. The zx-calculus is complete for stabilizer quantum mechanics. New Journal of Physics, 16(9):093021, 2014.
Michael Barr. Algebraically compact functors. Journal of Pure and Applied Algebra, 82(3):211–231, 1992.
Clemens Berger, Paul-Andr´e Melli`es, and Mark Weber. Monads with arities and their associated theories. J. Pure Appl. Algebra, 216(8-9):2029–2048, 2012.
P. O. Boykin, T. Mor, M. Pulver, V. Roychowdhury, and F. Vatan. On universal and fault-tolerant quantum computing: a novel basis and a new constructive proof of universality for shor’s basis. In Foundations of Computer Science, 1999. 40th Annual Symposium on, pages 486–494, 1999.
Brian Day. On closed categories of functors. In Reports of the Midwest Category Seminar IV, pages 1–38. Springer, 1970.
Jeff Egger, Rasmus Ejlers Møgelberg, and Alex Simpson. The enriched effect calculus: syntax and semantics. Journal of Logic and Computation, 2012.
Marcelo P Fiore and Gordon D Plotkin. An axiomatisation of computationally adequate domain theoretic models of FPC. In Proc. LICS’94, 1994.
Robert Furber and Bart Jacobs. From Kleisli categories to commutative C*-algebras: probabilistic Gelfand duality. In Proc. CALCO’13, pages 141–157. Springer, 2013.
Alexander S Green, Peter LeFanu Lumsdaine, Neil J Ross, Peter Selinger, and Benoˆıt Valiron. Quipper: a scalable quantum programming language. In Proc. PLDI’13, pages 333–342. ACM, 2013.
Bart Jacobs. On block structures in quantum computation. In Proc. MFPS’13, volume 298 of Electron. Notes Theor. Comput. Sci., pages 233–255. Elsevier, 2013.
Bart Jacobs. A recipe for state-and-effect triangles. In Proc. CALCO’15, volume 35, 2015.
Max Kelly. Basic concepts of enriched category theory, volume 64. CUP Archive, 1982.
Aleks Kissinger and Sander Uijlen. A categorical semantics for causal structure. In Proc. LICS’17, 2017.
Andre Kornell. Quantum collections. arXiv preprint arXiv:1202.2994, 2012.
Paul Blain Levy. Call-by-push-value: A functional/imperative Synthesis, volume 2. Springer Science & Business Media, 2012.
Octavio Malherbe, Philip Scott, and Peter Selinger. Presheaf models of quantum computation: an outline. In Computation, Logic, Games, and Quantum Foundations. The Many Facets of Samson Abramsky, pages 178–194. Springer, 2013.
Paul-Andr´e Melli`es. Parametric monads and enriched adjunctions. Available from the author’s webpage, 2012.
R. E. Møgelberg and Sam Staton. Linear usage of state. Logical Methods in Computer Science, 10(1), 2014.
Eugenio Moggi. Computational lambda-calculus and monads. In Proc. LICS’89, 1989.


Michele Pagani, Peter Selinger, and Benoˆıt Valiron. Applying quantitative semantics to higher-order quantum computing. In Proc. POPL’14, pages 647–658. ACM, 2014.
Jennifer Paykin, Robert Rand, and Steve Zdancewic. QWIRE: a core language for quantum circuits. In Proc. POPL’17, pages 846–858. ACM, 2017.
A J Power. Enriched Lawvere theories. Theory Appl. Categories, 6(7):83–93, 1999.
Mathys Rennela. Towards a quantum domain theory: order-enrichment and fixpoints in W*-algebras. In Proc. MFPS XXX, volume 308, pages 289–307. Electron. Notes Theoret. Comput. Sci., 2014.
Mathys Rennela. Operator algebras in quantum computation. arXiv preprint arXiv:1510.06649, 2015.
Mathys Rennela and Sam Staton. Complete positivity and natural representation of quantum computations. In Proc. MFPS XXXI, volume 319, pages 369–385. Electron. Notes Theoret. Comput. Sci., 2015.
Shˆoichirˆo Sakai. C*-algebras and W*-algebras. Springer Science & Business Media, 2012.
Peter Selinger. Towards a quantum programming language. Math. Struct. Comput. Sci., 14(04):527– 586, 2004.
Sam Staton. Freyd categories are enriched Lawvere theories. In Proc. WACT, Electron. Notes Theor. Comput. Sci., pages 197–206, 2013.
Sam Staton. Algebraic effects, linearity, and quantum programming languages. In Proc. POPL’15, pages 395–406. ACM, 2015.
Dave Wecker and Krysta M Svore. LIQUi >: A software design architecture and domain-specific language for quantum computing. arXiv preprint arXiv:1402.4467, 2014.

Additional typing rules for the host language
Recall that the types of the host language are
A, B ::= A × B | 1 | A → B | T (A) | Circ(W, W j) | a | b
The standard typing rules of the monadic metalanguage are the rules of the simply- typed λ-calculus


(x : A) ∈ Γ

Γ ▶ x : A
Γ,x : A ▶ t : B


Γ ▶ (λxA.t): A → B
Γ ▶ t : A → B	Γ ▶ u : A

Γ ▶ t(u): B

Terms of product types are formed following four typing rules


—

Γ ▶ unit : 1
Γ ▶ t : A	Γ ▶ u : B


Γ ▶ (t, u): A × B
Γ ▶ t : A × B


Γ ▶ π1(t): A
Γ ▶ t : A × B

Γ ▶ π2(t): B

to which we need to add the typing rules for the monad [20], associated respectively to the unit and the strong Kleisli composition:


Γ ▶ t : B

Γ ▶ return(t): T (B)
Γ ▶ t : T (B)	Γ,x : B ▶ u : T (C)

Γ ▶ let x = t in u : T (C)

This is in addition to the typing rules for the interaction between the host language and the circuit language given in Section 2.

Operational semantics of EWire
Let us start with the (partial) destruction of patterns.

p → output pj; C =⇒ C[p '→ pj]	unbox (box w ⇒ C) p =⇒ C[w '→ p]

() → (); C =⇒ C	(w ,w ) → (p ,p ); C =⇒ C[ w1 ''→p1 ]
The reduction system → on terms is defined in two parts: the reduction →H is the operational semantics of the host language, while the reduction →b is the operational semantics of boxed circuits (we refer to [22, Sec. 4] for its description), in such a way that →=→H ∪ →b. This allows us to define the following reduction rules for boxing and unboxing instructions.


C =⇒ Cj


box (w : W ) ⇒ C →b box (w : W ) ⇒ Cj

Then, we add the structural reduction rule
t → tj

unbox tp ⇒ unbox tj p
C =⇒ Cj
with

E[C] =⇒ E[Cj]
E ::= w →  ; C | w → gate gp in  | () → p;  | (w1, w2) → p; 
Therefore, normal circuits are given by the following grammar:
N ::= output p | w → gate g p; N | x ⇐ lift p; N | () → w; N | (w1, w2) → w; N

Finally, commuting conversion rules allows to reduce even more instructions to normal forms, ensuring preservation, progress and normalization.

w → (p2 → gate g p1; N ); C =⇒ p2 → gate g p1; w → N ; C

w → (x ⇐ lift p; Cj); C =⇒ x ⇐ lift p; w → Cj; C

w → (() → wj; N ); C =⇒ () → wj; w → N ; C

w → ((w1, w2) → wj; N ); C  =⇒ (w1, w2) → wj; w → N ; C
The following propositions are proven by straightforward induction. In partic- ular, assuming that the reduction →H satisfies preservation, progress and strong normalization one can deduce that the reduction → does too. The interested reader will find the proofs of the following propositions in [22, App. A].
Proposition B.1 (Preservation) If the judgement Γ; Ω ▶ C : W holds and the circuit C reduces to the circuit Cj, then the judgement Γ; Ω ▶ Cj : W holds.

Proposition B.2 (Progress) If the judgement Γ; Ω ▶ C : W holds, then either the circuit C is normal or there is a circuit Cj such that C reduces to Cj, i.e. the relation C =⇒ Cj holds.
Proposition B.3 (Normalization) If the judgement Γ; Ω ▶ C : W holds, then there exists a normal circuit N such that the circuit C reduces to N in a ﬁnite number of steps.
Omitted proofs
Proof of Proposition 3.3
The category Set of sets and functions is the canonical example of cartesian closed category, and the distribution monad D : Set → Set is a strong monad.

The category FdC∗-Algop
of the opposite category of finite-dimensional C*-

algebras and completely positive unital maps has a monoidal structure given by the tensor product of C*-algebras, finite sums given by direct sums and the C*-algebra C of complex numbers is the unit I.
In this setting, H0 is the category N, skeleton of the category of finite sets and functions which considers natural numbers as its objects. The copower n ⊙ A of a natural number n ∈ N and a C*-algebra A is the C*-algebra n⊙A, defined as the n- fold direct sum A⊕··· ⊕A like in [11]. We observe that the copower distributes over the coproduct (n⊙ (A⊕B)= n⊙A⊕n⊙B) and that composition is multiplication (n ⊙ (m ⊙ A)= nm ⊙ B).
The copower n⊙C is the C*-algebra Cn. Copowers are preserved by endofunctors
A ⊗ −.
A ⊗ (n ⊙ B)= A ⊗ B ⊕· · · ⊕ A ⊗ B = n ⊙ (A ⊗ B)
We still need to verify that we have a relative adjunction. Observing that
FdC∗-AlgCPU(A, Cn) ∼= FdC∗-AlgCPU(A, C) ×· · · × FdC∗-AlgCPU(A, C) one deduces that
FdC∗-AlgCPU(A, Cn) ∼= Set(n, FdC∗-AlgCPU(A, C))


and therefore

FdC∗-Algop

(Cn, A) ∼= Set(n, FdC∗-Algop

(C, A))

Then, the symmetric monoidal functor J : N → FdC∗-Algop
associates every

natural number n ∈ N to the C*-algebra Cn. The morphisms runn are given by the isomorphism

FdC∗-Algop
(C, Cn) := FdC∗-AlgCPU(Cn, C) ∼= D(n)

between states on Cn and the n-simplex D(n) := {x ∈ [0, 1]n |	i xi = 1} [9, Lemma 4.1].

The semantics of types and gates is rather standard. Probabilities are complex numbers C and a (classical) bit is therefore an element of the C*-algebra C ⊕ C. Moreover, n-qubit systems are modelled in the C*-algebra M2n . In other words,
1 = C	bit = C ⊕ C	qubit = M2	u = u† − u (for every unitary u ∈ U ) meas : C ⊕ C → M2 : (a, b) '→  a 0		new : M2 → C ⊕ C :  a b  '→ (a, b)
0 b	c d 
and so on.


Proof of Proposition 4.1
First, it has been established that the category W∗-Algop

is symmetric monoidal

when equipped with the spatial tensor product [15] and it is a well-known fact that the category Dcpo⊥ of pointed dcpos and strict Scott-continuous maps is cartesian closed.
Much like in [12, Section 5.6], we introduce the restricted version of the monad of subvaluations V = dcGEMod([0, 1](−), [0, 1]) on Dcpo⊥, where the category dcGEMod is the category of directed-complete generalized effect modules and Scott-continuous effect module homomorphisms, also introduced as a category of quantum predicates in [25,26].
Recall that a strong monad over a monoidal closed category K is the same thing as a K-enriched monad. The monad V is enriched over Dcpo⊥ and therefore a strong monad since the category Dcpo⊥ is (cartesian) closed.
Since there is a full and faithful functor which takes every W*-algebra A to its directed-complete generalized effect module [0, 1]A of predicates [26], there is an equivalence
V (n)= dcGEMod([0, 1]n, [0, 1]) ∼= W∗-AlgCPSU(Cn, C) for every n ∈ N


and therefore an equivalence V (n) ∼= W∗-Algop
(C, Cn) for every n ∈ N.

Building up on the constructions of Prop 3.3,  we deduce that (W∗-AlgCPSU, Dcpo⊥,V ) is a categorical model of QWire.
Proof of Proposition 4.3
Variations of most of the categorical constructions required have been discussed in [26]. The coproduct of quantum predomains F, G : Cop → Dcpo is defined pointwise on the disjoint sum of dcpos, and so does the terminal object (resp. zero object) of the category of quantum (pre)domains and Scott-continuous maps (resp. strict Scott-continuous maps).
Since C is a small category, the Day convolution provides us with a symmetric monoidal closed category of quantum predomains [6] and algebraic compactness for locally continuous endofunctors is given by [8, Example 6.9].
The copower takes inspiration from the fact that the equivalence Mn(A) ∼= Mn ⊗ A holds for every C*-algebra A and every natural number n ∈ N. In short: for every

n ∈ N, n ⊙ F is the quantum predomain defined as the mapping A '→ F (Mn(A)) on objects and f '→ F (Mn(f )) on maps.
Finally, exploiting the fact that the enriched Yoneda embedding y : C → [Cop, Dcpo] is full and faithful, we observe that there is a one-to-one correspondance between completely positive unital maps I → J (n) and Scott-continuous natural transformations C(−,I) ⇒ C(−,J (n)), which leads us to the following equivalence
T (n) ∼= C(I, J (n)) ∼= [Cop, Dcpo](I, J (n)) for every n ∈ N
