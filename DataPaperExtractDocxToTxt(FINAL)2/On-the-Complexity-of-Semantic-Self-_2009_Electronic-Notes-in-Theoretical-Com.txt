

Electronic Notes in Theoretical Computer Science 250 (2009) 3–19
www.elsevier.com/locate/entcs

On the Complexity of Semantic Self-minimization
Adam Antonik1,2
Laboratoire Sp´ecification et V´erification LSV, CNRS & ENS de Cachan Cachan Cedex, France
and Michael Huth1,3
Department of Computing Imperial College London London, United Kingdom

Abstract
Partial Kripke structures model only parts of a state space and so enable aggressive abstraction of systems prior to verifying them with respect to a formula of temporal logic. This partiality of models means that verifications may reply with true (all refinements satisfy the formula under check), false (no refinement satisfies the formula under check) or don’t know. Generalized model checking is the most precise verification for such models (all don’t know answers imply that some refinements satisfy the formula, some don’t), but computationally expensive. A compositional model-checking algorithm for partial Kripke structures is efficient, sound (all answers true and false are truthful), but may lose precision by answering don’t know instead of a factual true or false. Recent work has shown that such a loss of precision does not occur for this compositional algorithm for most practically relevant patterns of temporal logic formulas. Formulas
that never lose precision in this manner are called semantically self-minimizing. In this paper we provide a systematic study of the complexity of deciding whether a formula of propositional logic, propositional modal logic or the propositional modal mu-calculus is semantically self-minimizing.
Keywords: 3-valued model checking, partial state spaces, computational complexity, supervaluations.

Introduction
Partial state spaces abstract an actual state space so that the resulting smaller state space allows for a feasible verification of such partial models. Such a check

1 This research was, in part, sponsored by the UK EPSRC grants EP/D50595X/1 Efficient Specification Pattern Library for Model Validation and EP/E028985/1 Complete and Efficient Checks for Branching- Time Abstractions
2 Email: antonik@lsv.ens-cachan.fr
3 Email: M.Huth@doc.imperial.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.002

then has to be conservative: if the partial model satisfies the property under check, then all concrete systems consistent with that partial model should satisfy that property. This is required since we otherwise cannot be certain whether the actual state space satisfies this property, unless we check it on that actual system – the task we intend to avoid by using this abstraction technique in the first place – or have some other means of connecting properties of that abstraction to properties of the actual system.
If φ is the property we want to check, and φM a property that characterizes all concrete systems that are consistent with the partial model M , we therefore want to check whether the property φM → φ, a logical implication, holds in all concrete systems. Identifying the set of concrete systems with some class of models, and assuming that φM and φ belong to some logic that is interpretable over that class of models, we recognize this problem as a validity check of some logic. Since the size of φM may be exponential in the size of M , this conceptually useful insight is perhaps less useful as the basis for efficient algorithms. Indeed, for the proposi- tional modal mu-calculus [15] this would render a method for property verification in 2EXPTIME whereas the most precise conservative check of partial models is EXPTIME-complete [8].
A less precise compositional – but much cheaper and still conservative – algo-
rithm [7] (a 3-valued generalization of the familiar labelling algorithm) is available as an alternative that often can verify that all concrete models consistent with a partial one satisfy the property in question. Given that alternative, it is tempting to ask whether a property φ is such that the cheaper algorithm always produces a correct result, regardless of the choice of partial model. In fact, it turns out [5] that this is the case for most practically relevant patterns of temporal logic specifications, as documented in [11] and at patterns.projects.cis.ksu.edu.
We can express this desirable feature of a property φ – written in the propo- sitional modal mu-calculus – via a computation of some normal form, followed by a “quantified” model check. For such a φ, one can compute a formula φp in the propositional modal mu-calculus such that running the cheap model-checking al-
gorithm on φp gives us the same result as running the expensive but most precise algorithm on φ, for all partial models. We will refer to φp as a pessimistic semantic minimization of φ. Unfortunately, φp may be exponentially larger than φ.
This blow-up in the size of the formula suggests that one cannot decide effi- ciently whether properties have an efficient, compositional, and precise verification of partial models. The results in this paper corroborate this suspicion since we secure hardness results matching those for the validity problem of the respective logics. Alas, our hardness results only come with an upper bound of an exponential gap. To add to this frustration, we cannot show any hardness results for deciding whether a formula and its negation do not lose precision in the sense discussed above.
From a practitioner’s point of view, the results of this paper may not matter much. For one, and as already mentioned, popular specification patterns were shown to either not lose precision or to have minor syntactic variants that don’t

lose precision [5]. For another, temporal logic formulas used in practice tend to be rather short, and so an exponential or double exponential worst-case inflation in their size may sometimes be feasible. But we still think that the results reported here are of interest. They pose the question of the exact computational complexity of the decision problems associated with semantic minimizations. And they also suggest connections with recent work on the complexity of decision problems for modal and mixed specifications [3,2,4]. Such specifications are related to the partial models we study in this paper.

Outline of paper.
In Section 2 we provide background on the verification of partial systems and on the concepts presented informally in the introduction. Our technical results, upper and lower bounds on the computational complexity of decision problems for semantic minimizations in temporal logics, are featured in Section 3. Related work is discussed in Section 4, and we conclude the paper in Section 5.

Background
In this paper we work with a countable set of atomic propositions, AP. Atomic propositions are the observations one can make at states of partial models.
We now define our models of partial state spaces. Since all temporal logics we study enjoy a finite-model property (and since we wish to verify abstractions that have finite state space), we will – without loss of generality – work with finite-state models throughout this paper.
Definition 2.1 A partial Kripke structure [7] M is a tuple (S, R, L) where S is a finite set of states, R ⊆ S × S is a state transition relation, and L: S × AP →
{0, 1/2, 1} a total (labeling) function such that L(s, q) specifies the truth value of
atomic proposition q at state s.
We identify 0 with false, 1 with true, and 1/2 with don’t know and make
{0, 1/2, 1} into a poset with respect to the information ordering ≤i [14,7] speci- fied as partial order by 1/2 ≤i 0 and 1/2 ≤i 1 as the only non-reflexive instances of
≤i. Figure 1 shows two partial Kripke structures. We note that Kripke structures M = (S, R, L) are those partial Kripke structures that don’t have 1/2 in the image of L. The meaning of a partial Kripke structure is that it describes a set of Kripke structures, those refinements that resolve all partiality of the state space. Such res- olution means that labels L(s, q) have no longer value 1/2 but that the state space may well be larger or smaller. Refinement is defined as in [7].
Definition 2.2 Let M = (SM , RM , LM ) and N = (SN , RN , LN ) be two partial Kripke structures.
A binary relation ≤ ⊆ SM × SN is a refinement iff s ≤ t implies
L(s, q) ≤i L(t, q) for all q ∈ AP,
for all (s, s') ∈ RM there is (t, t') ∈ RN with s' ≤ t', and


s2

Fig. 1. Two partial Kripke structures M and N such that (N, t1) refines (M, s1) and N is a Kripke structure.
for all (t, t') ∈ RN there is (s, s') ∈ RM with s' ≤ t'.
Given s ∈ SM we call (M, s) a pointed model, which represents the partial Kripke structure M with initial state s.
We say that (M, s) has (N, t) as refinement whenever there is a refinement ≤
as above such that s ≤ t.
Example 2.3 Two partial Kripke structures are depicted in Figure 1. The one on the right is a pointed Kripke structure (N, t1) and refines the pointed model (M, s1) on the left where ≤ = {(s1, t1), (s2, t2), (s3, t3), (s4, t3)}.
We assume the usual satisfaction semantics between pointed Kripke structures and formulas of the propositional modal mu-calculus (MC), both of which we define below. Refinement and this standard satisfaction notion let us define two judgments, one for generalized model checking [8] (SAT, called GMC in loc. cit.), and one for its logical dual (VAL).
Definition 2.4 Let (M, s) be a pointed model and φ a sentence of the propositional modal mu-calculus. Then SAT(M, s, φ) holds iff there is a pointed Kripke structure that refines (M, s) and satisfies φ. Dually, VAL(M, s, φ) holds iff all pointed Kripke structures that refine (M, s) satisfy φ.
Whenever convenient, as in the next example, we make liberal use of CTL* connectives as syntactic sugar expressible in MC.
Example 2.5 For the partial Kripke structure M in Figure 1, the judgments VAL(M, s1, AF (q ∧ ¬r)) and VAL(M, s1, AF EG ¬r) hold. But we don’t have VAL(M, s1, AF AG ¬r), where the pointed Kripke structure (N, t1) serves as a coun- terexample.
We hasten to point out that every partial Kripke structure has some pointed Kripke structure as refinement, so there are no vacuities [16] – here at the level of models – introduced into these two judgments SAT(M, s, φ) and VAL(M, s, φ). When φ ranges over the propositional modal mu-calculus, both judgments are EXPTIME-complete in the size of φ and quadratic in the size of M [8].
The compositional semantics of [7] trades off the precision of these judgments with their computational complexity, and gives rise to the aforementioned cheap and

sound, compositional algorithm. We present this compositional semantics through two judgments, a “pessimistic” one (M, s) |=p φ, and an “optimistic” one (M, s) |=o φ between pointed models and formulas of the propositional modal mu-calculus.
The syntax of this propositional modal mu-calculus MC is given by
φ ::= q | Z | φ ∧ φ | ¬φ | EX φ | μZ.φ
where q ranges over a set of propositional atoms, Z ranges over a set of recursion variables, μZ.φ binds occurrences of Z in its body φ, and all free occurrences of Z in that body are under an even scope of negations. We use φ ∨ ψ as syntactic sugar for ¬(¬φ ∧ ¬ψ), and use → and ↔ as abbreviations with their usual encodings in terms of ¬ and ∨. A formula φ is a sentence if it has no free variables.
We let PML, (basic) propositional modal logic, be those formulas of MC that contain neither recursion variables Z nor fixed-point operators μZ. Propositional logic is the set PL of those formulas of PML that don’t contain any EX operator.
For each partial Kripke structure M = (S, R, L) and each formula φ ∈ MC we define in Figure 2 a set [| φ |]m (for m ∈ {o, p}) of those states in S that satisfy φ, where ρ maps each recursion variable Z to a set of states, ρ(Z) ⊆ S.
We explain the salient features of this semantics:
For atomic propositions, the “optimistic” semantics [| q |]o interprets the labels 1 and 1/2 for q at states as denoting truth of q at those states. The “pessimistic” semantics [| q |]p, in contrast, interprets only the label 1 for q at states as denoting truth of q at those states.
The meaning of conjunction is compositional, interpreted as intersection as usual in Kripke structures.
The meaning of negation is that is swaps the evaluation mode of the semantics: to evaluate ¬φ in the pessimistic mode, say, we evaluate φ in the optimistic mode and then form the set complement of the resulting set of states. This reflects the duality between satisfiability and validity checking inherent in this reasoning about sets of refinements of models.
For a sentence φ ∈ MC we define

​
(M, s) |=m φ	d=ef
s ∈ [| φ |]m for some ρ

This is well defined as [| φ |]m is independent of the choice of ρ for sentence φ. The
cost of computing [| φ |]m is, up to a constant, essentially that of computing the
standard satisfaction relation on Kripke structures [8]. So the judgments in (2) can be computed as efficiently as satisfaction for Kripke structures. We note that both (K, t) |=o φ and (K, t) |=p φ render the standard satisfaction relation [15] on pointed Kripke structures (K, t).
The results and proofs in this paper will only apply to sentences. We therefore abuse notation by referring to MC, PML, and PL also as the subsets of sentences of these respective logics. Context will always determine the proper interpretation of these symbols.
The next theorem, whose result is implicit in [7,8], connects the compositional semantics with that of generalized model checking.

[| q |]o = {s | L(s, q) /= 0}	[| q |]p = {s | L(s, q) = 1}
ρ	ρ
[| Z |]o = ρ(Z)	[| Z |]p = ρ(Z)

ρ
[| φ ∧ ψ |]o = [| φ |]o ∩ [| ψ |]o
ρ
[| φ ∧ ψ |]p = [| φ |]p ∩ [| ψ |]p

ρ	ρ	ρ
ρ	ρ	ρ

[| ¬φ |]o = S \ [| φ |]p	[| ¬φ |]p = S \ [| φ |]o
ρ	ρ	ρ	ρ
[| EX φ |]o = pre([| φ |]o )	[| EX φ |]p = pre([| φ |]p)

ρ	ρ
[| μZ.φ |]o = lfp Fo
ρ	ρ
[| μZ.φ |]p = lfp Fp

ρ	φ,ρ
ρ	φ,ρ


Fig. 2. Compositional semantics of propositional modal mu-calculus formulas φ over a partial Kripke struc- ture M = (S, R, L) for environment ρ mapping recursion variables to subsets of S, where pre: P(S) → P(S)

is pre(X) = {s ∈ S | ∃(s, s') ∈ R: s' ∈ X}, Fm : (P(S), ⊆) → (P(S), ⊆) is Fm (X) = [| φ |]m
for

φ,ρ
φ,ρ
ρ[Z'→X]

m ∈ {o, p}, and lfp F is the least fixed point of a monotone function F on the complete lattice (P(S), ⊆).
Theorem 2.6 Let (M, s) be a pointed model and φ ∈ MC a sentence. Then:
(M, s) |=p φ implies VAL(M, s, φ) and
SAT(M, s, φ) implies (M, s) |=o φ.
Item (i) states that the compositional semantics is sound. We can verify the ex- pensive VAL(M, s, φ) by trying to establish the much cheaper (M, s) |=p φ. Item (ii) in that theorem may not be of direct interest in verification but is useful for the proof of the first implication.
Showing VAL(M, s, φ) through the cheaper judgment (M, s) |=p φ won’t always succeed.
Example 2.7 [12] Consider the formula φ = EX q ∧ (EX r ∨ EX ¬r) and any model M = ({s}, {(s, s)}, L) with L(s, q) = 1 and L(s, r) = 1/2. Then (M, s) |=p φ since (M, s) |=p EX r ∨ EX ¬r. But all pointed Kripke structures that refine (M, s) satisfy φ, i.e. VAL(M, s, φ) holds.
This example illustrates the necessary trade-off between the precision of VAL(M, s, φ) and the lower computational cost of (M, s) |=p φ. In this paper we are interested in those φ ∈ MC for which the implications in Theorem 2.6 are reversible for all pointed models. This leads to the concept of semantic minimization [6,21,20,12].
Definition 2.8 [12] A sentence φ ∈ MC is
pessimistically self-minimizing iff for all pointed models (M, s) we have (M, s) |=p φ ⇔ VAL(M, s, φ),
optimistically self-minimizing iff for all pointed models (M, s) we have (M, s) |=o φ ⇔ SAT(M, s, φ), and
semantically self-minimizing iff it is optimistically and pessimistically self- minimizing.
Given these three concepts, we write PSM, OSM, and PSM ∩ OSM for the sets of sentences of MC that satisfy the respective concept in items (i), (ii), and (iii).

Example 2.9 • The formula q ∨ ¬q is optimistically self-minimizing but not pes- simistically so – consider the case when L(s, q) = 1/2.
The pattern “Precedence Chain: 2 stimuli, 1 response; Globally q and s precede
r” [11], as documented at patterns.projects.cis.ksu.edu, written in MC as
¬E[¬qU r] ∧ E[¬rU (q ∧ ¬r ∧ EX (E[¬sU (r ∧ ¬s)]))] is pessimistically self-minimizing [5].
The pattern “Absence of q, Before r”, written in MC as
φ = A[¬q ∨ AG(¬r)W r] is not pessimistically self-minimizing but
φp = A[¬q ∨ AX (AG(¬r)W r]
is, and is logically equivalent to φ over Kripke structures [5].
Decision Problems
We write VAL for the valid sentences of MC and, dually, UNSAT for the un- satisfiable sentences of MC. The set MC is partitioned into VAL, UNSAT, and MC \ (VAL ∪ UNSAT). If we refine this partition with the sets PSM and OSM under union, intersection, and complement we arrive at six equivalence classes. Throughout, it will be clear from the context whether these sets are meant to be subsets of MC, PML or PL.
The proposition stated next would not hold, as stated, in the presence of con- stants for true and false in MC. But their absence from MC merely simplifies the presentation of our results.
Proposition 3.1	(i) VAL is contained in OSM and disjoint from PSM. Dually,
UNSAT is contained in PSM and disjoint from OSM.
For each L ∈ {MC, PML, PL}, set L is partitioned into the six sets
VAL
UNSAT
OSM \ (VAL ∪ PSM)
PSM \ (UNSAT ∪ OSM)
L\ (PSM ∪ OSM)
PSM ∩ OSM
as illustrated in Figure 3.
Proof (Sketch)
Consider the partial Kripke structure M⊥ = ({s⊥}, {(s⊥, s⊥)}, L⊥) where L⊥(s⊥, q) = 1/2 for all q ∈ AP. Then every pointed Kripke structure (over AP) is a refinement of (M⊥, s⊥). One shows that for all sentences φ ∈ MC we have
(M⊥, s⊥) |=o φ	and	(M⊥, s⊥) |=p φ
The first statement in (3) is used to prove that UNSAT and OSM are disjoint. The second statement in (3) implies that VAL is disjoint from PSM.





Fig. 3. A partition of MC, PML, and PL into six equivalence classes, generated by Boolean combinations of VAL and PSM.

To see that VAL ⊆ OSM, let φ be valid and (M, s) a pointed model. We have that SAT(M, s, φ) holds since there are refining pointed Kripke structures of (M, s) and φ is valid. But then (M, s) |=o φ holds by Theorem 2.6. Since (M, s) was arbitrary, φ ∈ OSM follows.
The dual statement, that UNSAT is contained in PSM, is proved in the dual fashion.
From the first item it follows that VAL, PSM, and OSM alone generate only the six sets I - VI by repeated applications of union, intersection, and complement; and that these six sets are mutually disjoint. We list sentences that show all six sets are inhabited: q∨¬q ∈ VAL, q∧¬q ∈ UNSAT, (q∨¬q)∧r ∈ OSM\(VAL∪ PSM), (q ∧ ¬q) ∨ r ∈ PSM \ (UNSAT ∪ OSM), [q ∧ (r ∨ ¬r)] ∨ [¬q ∧ (r ∧ ¬r)] ∈ MC \ (PSM ∪ OSM), and q ∈ PSM ∩ OSM. Since these sentences are in PL, we thus have a partition for all three cases of L ∈ {MC, PML, PL}.
 

For each of these six sets we now study the complexity of deciding membership of that set. We first observe how negation acts on these sets.
Lemma 3.2 Negation φ '→ ¬φ maps the following pairs of sets into each other:
OSM and PSM, I and II, III and IV, V and itself, and VI and itself.
Proof (Sketch) A sentence is in VAL iff its negation is in UNSAT, and it is in OSM iff its negation is in PSM. Therefore a sentence is in set I iff its negation is in set II, and it is in OSM \ (VAL ∪ PSM) iff its negation is in PSM \ (UNSAT ∪ OSM). This shows the claim for I and II, and for III and IV. Sets V and VI are closed under negation, since φ '→ ¬φ maps set OSM into PSM, and vice versa.	 

Sets I and II.
Deciding membership of sets I (VAL) and II (UNSAT) has, of course, the same complexity as that of the validity of the underlying logic – EXPTIME-complete for MC, PSPACE-complete for PML, and coNP-complete for PL.

Set OSM.
By Lemma 3.2 we have φ ∈ OSM ⇔ ¬φ ∈ PSM. Thus the complexity of deciding OSM is the same as that of deciding PSM. But deciding OSM is at least as hard as deciding validity of the underlying logic. This can be seen by considering the function
E(φ) = φ ∨ (x ∧ ¬x)
where x is a propositional atom not in φ, and so not contained in φ. If φ is valid, then so is E(φ), and this implies that E(φ) is in OSM. If φ is not valid, then there is a pointed Kripke structure (K, t) in which φ is false. We extend the labeling function L of K so that L(s, x) = 1/2 for all states s of K – making K into a partial Kripke structure. Then (K, t) |=o E(φ) follows for this extended K but there is no refinement of (K, t) that satisfies E(φ) as this formula is semantically equivalent to φ over Kripke structures. Thus, φ is valid iff E(φ) is in OSM and so we can reduce validity checks to checks of membership of OSM.
To summarize, deciding OSM is EXPTIME-hard, PSPACE-hard, and coNP- hard for MC, PML, and PL respectively.


MC.
We can decide in 2EXPTIME whether a sentence φ ∈ MC is in OSM. This is implicit in [12], where from φ two alternating tree automata are being constructed – with exponential blowup in the worst case – and membership of φ in OSM is then being reduced to a language inclusion check for these automata, again, in EXPTIME but now in the size of these automata.


PML.
Consider a sentence φ ∈ PML. As just said for MC, in [12], two tree au-
tomata A3 and A3 o  were constructed such that φ is optimistically self-minimizing
φ	|= φ
iff L(A3 o ) ⊆ L(A3 ), i.e. the language accepted by A3 o is contained in the lan-
|=	φ	|=
guage accepted by A3 . Since PML ⊆ MC, such a language inclusion check is in
EXPTIME in the size of these automata. However, since both automata cannot distinguish trees at depths greater than the size of φ, reflecting the shallow model property of PML, such a language inclusion check can be performed already in PSPACE. Since the underlying automata has size at most exponential in the size of φ we conclude that the language inclusion check can be done in EXPSPACE in the size of φ.

boolean NotInOSM(phi) {
**choose** model M such that M(x) = 1/2 for some x in AP(phi); if (M |=^o phi) {
for (all x in AP(phi) with M(x) = 1/2) {
if (!(M[x --> 0] |=^o phi) && !(M[x --> 1] |=^o phi)) { ACCEPT;
}
}
REJECT;
}
}

Fig. 4. NP algorithm that decides membership of PL\ OSM. If at least one choice of model leads to ACCEPT, the algorithm returns true; otherwise it returns false.

PL.
We now show that, for PL, deciding membership of OSM is in coNP, and so the above hardness result is indeed exact. Let AP(φ) be the set of atomic propositions that occur in φ. The evaluation of (M, s) |=o φ for φ ∈ PL depends only on the values {LM (s, q) | AP(φ)}. Therefore, we can think of the pointed model (M, s) as a function from atomic propositions to values in {0, 1/2, 1} and so we will write M (q) etc. below with that interpretation in mind. We write M [q '→ v] for the model that is as M , except that it maps q to value v ∈ {0, 1}. We will also use that M |=o φ will only depend on the behavior of M on set AP(φ).
If there are k > 0 atomic propositions in φ ∈ PL, we have just seen that we can decide semantic self-minimization of φ by inspecting, for 3k models, whether the compositional model-checking algorithm loses any precision. This observation leads to a non-deterministic algorithm, depicted in Figure 4, for showing that PL \ OSM is in NP, and so OSM is in coNP.
The idea behind the algorithm is the following: suppose we have that M |=o φ but neither M [q '→ 0] |=o φ nor M [q '→ 1] |=o φ hold. Then φ cannot be in OSM: otherwise, there is some function K from atomic propositions to {0, 1} that refines M and satisfies φ. But any refinement of M has to be either a refinement of M [q '→ 0] or M [q '→ 1]. So at least one M [q '→ 0] |=o φ and M [q '→ 1] |=o φ would have to hold by Theorem 2.6, a contradiction. Thus this is a sound test for membership in OSM. But if we apply this method to all partial models M , it becomes complete as such a membership test.
Proposition 3.3 The NP algorithm in Figure 4 correctly decides membership of
PL \ OSM.
Proof (Sketch)
Let φ ∈ PL be such that the algorithm accepts it. Then there is some model M
and some x ∈ AP(φ) such that
· M (x) = 1/2,
M |=o φ, and
M [x '→ v] |=o φ for all v ∈ {0, 1}.
The last item and Theorem 2.6 imply that SAT(M [x '→ v], ·, φ) is false for both v = 0, 1. Then it must also be that SAT(M, ·, φ) is false. But then the second item implies that φ is not in OSM.

Conversely, let φ /∈ OSM. Then, by Theorem 2.6, there is a model M such that
M |=o φ holds and SAT(M, ·, φ) does not hold
This can only be if there is some x ∈ AP(φ) with M (x) = 1/2. Let M be a model satisfying (5) but where the set
{x ∈ AP(φ) | M (x) = 1/2}
is minimal amongst all models satisfying (5). Since there is some x with M (x) = 1/2, the algorithm will encounter the first if-statement and its guard will be true. Therefore, its for-statement will be executed and, for the first (indeed all) x it executes we can now reason that the algorithm will accept.
Since SAT(M, ·, φ) is false, we know that SAT(M [x '→ v], ·, φ) is false for all
v ∈ {0, 1}. By the minimality of model M with respect to (5), we infer that M [x '→ v] |=o φ has to be false for v = 0 and for v = 1. Thus the algorithm reaches ACCEPT.


Set III.
Deciding set III is at least as hard as deciding OSM, and therefore at least as hard as deciding validity of the underlying logic. To see this, consider the function
F (φ) = (φ ∨ x) ∧ (y ∧ (z ∨ ¬z))
where x, y, and z are propositional atoms not contained in φ. The reduction is shown through the composition F ◦ E if

​
holds. We show (7):
F (φ) ∈ III	⇔	φ ∈ OSM

For no φ is F (φ) in PSM: consider a pointed model (M, s) with L(s, x) = L(s, y) = 1 and L(s, z) = 1/2. Then (M, s) |=p F (φ) holds but all pointed Kripke structures that refine (M, s) satisfy φ.
For no φ is F (φ) in VAL since there are, e.g., pointed models (M, s) for which
L(s, y) = 0.
So F (φ) is in set III iff F (φ) is in OSM \ VAL iff F (φ) is in OSM. Thus it suffices to show F (φ) ∈ OSM ⇔ φ ∈ OSM. In doing so, we appeal to the fact that φ, ψ ∈ OSM imply that φ ∧ ψ ∈ OSM whenever φ and ψ share no atomic propositions, and that OSM is closed under disjunctions [12].
Let φ ∈ OSM. Since y and z ∨ ¬z ∈ OSM we get y ∧ (z ∨ ¬z) ∈ OSM as both conjuncts share no atomic propositions. Since φ, x ∈ OSM, their disjunction φ∨x is in OSM as well. Since φ ∧ x and y ∧ (z ∨ ¬z) share no atomic proposition and both are in OSM, we get F (φ) ∈ OSM.
Let φ /∈ OSM. Then there is a pointed model (M, s) such that (M, s) |=o φ and SAT(M, s, φ) is false. Extend the labeling function LM of (M, s) such that LM (s, y) = LM (s, z) = 1 and LM (s, x) = 0. Then (M, s) |=o F (φ) holds for this extension but SAT(M, s, F (φ)) is false, since SAT(M, s, φ) is false and all pointed

Kripke structures (K, t) that refine the extended (M, s) must satisfy LK(t, x) = 0 and LK(t, y) = 1. So F (φ) /∈ OSM.
Combining (7) with the reduction of OSM to validity checks, we infer that deciding set III is EXPTIME-hard, PSPACE-hard, and coNP-hard for łC, УłL and УL (respectively).

łC.
We can decide PSM and OSM in 2EXPTIME, and decide VAL in EXPTIME. So we can decide set III in 2EXPTIME.

УłL.
We already have seen that OSM can be decided in EXPSPACE, so this applies to PSM as well. Since VAL can be decided in PSPACE we can decide set III also in EXPSPACE.

УL.
We have shown that OSM is in coNP. By Lemma 3.2 this implies that PSM is in coNP as well. Since VAL is in coNP, the language УL \ (VAL ∪ PSM) is in NP. Set III equals OSM ∩ (УL\ (VAL ∪ PSM)) and so is in DP [18,19] as the intersection of a language in coNP with one in NP. We are presently unable to show DP-hardness of set III, despite having made a considerable effort to that end.

Set V.
Sentences in set V lose precision in the pessimistic and in the optimistic compo- sitional semantics. Since unsatisfiable sentences are in PSM, sentences in set V must be satisfiable. Deciding membership of set V is also at least as hard as the satisfiability check of the relevant logic. To see this, consider
G(φ) = (φ л (x V чx) л y) V (z л чz)
where x, y, and z are in AP and again not appearing in φ.
For no φ is G(φ) in OSM, and so G(φ) is in set V iff G(φ) is not in PSM: consider a pointed model (M, s) with LM (s, z) = 1/2 and LM (s, y) = 0. Then (M, s) |=o G(φ) holds but no pointed Kripke structure that refines (M, s) satisfies φ.
Now if φ is unsatisfiable, then G(φ) is also unsatisfiable, so G(φ) will be in PSM. Conversely, if φ is satisfiable (on some pointed Kripke structure (K, t)) we claim that G(φ) is not in PSM. To see this we make K into a partial Kripke structure by extending its labeling function L with L(t, x) = L(t, y) = 1 and L(t, z) = 1/2. Then all pointed Kripke structures that refine this expanded (K, t) satisfy φ, yet (K, t) |=p G(φ).
The combination of these two items shows
φ satisfiable	e	G(φ) ∈ V

To summarize, deciding set V is EXPTIME-hard, PSPACE-hard, and NP-hard for łC, УłL, and УL (respectively).

łC.
It is easily seen that deciding set V is in 2EXPTIME as that complexity class is closed under finite unions and complements.

УłL.
We can decide membership of set V by two checks, one for OSM and one for PSM – both were shown to be in EXPSPACE. We therefore conclude that set V can be decided in EXPSPACE as well.

УL.
Since OSM and PSM are in coNP so is their union. But then set V is in NP as the complement of a language in coNP. Since we already showed that set V is NP-hard, we get that set V is NP-complete.

Set VI.
Sentences in VI are well behaved in that they lose precision neither for the pes- simistic nor for the optimistic compositional semantics. So satisfiability and validity checks for all partial state spaces are reducible to a single, simple verification for such sentences. The exact complexity of deciding this set remains to be frustrat- ingly unknown. Of course, deciding set VI is no harder than deciding two instances of OSM:
(φ ∈ PSM ∩ OSM) e (φ ∈ OSM & чφ ∈ OSM)
So deciding set VI is no harder than deciding validity of the respective logic. Alas, we are unable to produce any hardness results for this class for any of the logics considered.

łC.
Since OSM and PSM are in 2EXPTIME and the latter is closed under finite intersections, set VI is in 2EXPTIME.

УłL.
We argue as for set V to see that deciding set VI is in EXPSPACE.

УL.
Since OSM and PSM are in coNP and coNP is closed under finite intersections, set VI is in coNP.

Experimental data
With the decision problems at hand, experimental data are probably not obtainable with ease. Still, we wanted to get a feel for how many formulas of a given size are in OSM and in the sets V and VI. We used Perl scripts to randomly generate “all” formulas of УL in sizes ranging from 1 to 5 where “size” refers to the number of occurrences of logical connectives in the formula. These scripts then performed a brute-force check for membership of sets of interest. This showed that about 75% of those formulas are in OSM and about the same percentage are in PSM, whereas about 50% of formulas were in PSM ∩ OSM. Of the formulas generated, only about 2.45% were in the NP-complete set УL \ (PSM ∪ OSM). Our results indicate that less formulas are in the latter set as the number of occurrences of logical operators in these formulas increases.

Summary of results
The complexity results shown in this paper are summarized in Figure 5. These results illustrate that we cannot issue any exact complexity results, apart from those for propositional logic for sets PSM and OSM (coNP-complete) and set УL \ (PSM ∪ OSM) (NP-complete). Our hardness results either exhibit an exponential gap for upper bounds (for łC and УłL) or a believed gap in the Boolean hierarchy over NP (for УL). One can also see that semantic self-minimization, the question of whether a formula and its negation are in PSM, lacks any hardness results at present.

Related work
The partial models, their refinement notion, and the compositional semantics for partial models presented in this paper were introduced (for CTL, a fragment of łC) in [7]. Generalized model checking, its complexity analysis, and a model-checking algorithm for it were then presented in [8] for linear-time and branching-time tem- poral logics. Partial models, their refinement, and temporal logic semantics were already developed for labelled transition systems in [17] and for Kripke structures in [9,10]. Partial versions of models that have labels on transitions as well as on states were discussed in [13]. The notion of semantic minimization, as presented in this paper, was proposed and shown to exist for propositional logic, propositional modal logic, and the propositional modal mu-calculus in [12]. The demonstration that practically relevant temporal logic specifications are by and large pessimistically self-minimizing was given in [5].
Blamey [6] studied partial-valued logics and their applications to linguistics and model theory and proved the existence of semantic minimizations (in our terminol- ogy) for propositional logic. The notion of supervaluational meaning was defined and studied by van Fraassen [21]; it is the definitional template for the generalized model checking judgements for temporal logics in this paper. Reps et al. [20] use BDD-based prime-implicant algorithms for a more efficient implementation of the

Results for łC:

Results for УłL:

Results for УL:


Fig. 5. Complexity results for PSM, OSM, and for the partition induced by VAL and PSM; the three tables present these results for MC, PML, and PL (respectively).

computation of semantic minimizations in propositional logic.
In [3,2,4], modal and mixed transition systems serve as partial models and the following decision problems are studied:
(Common implementation) Do finitely many models have a common transition system as refinement? This is EXPTIME-complete for both mixed and modal transition systems [4].
(Consistency) Does a model have a transition system as a refinement? This is trivial for modal transition systems, and EXPTIME-complete for mixed transition systems [4].
(Thorough refinement) Are all transition systems that refine one model also re- finements of another model? This is EXPTIME-complete for mixed transition systems [4], and only known to be PSPACE-hard for modal transition systems [2,3] at the time of writing.

Conclusions
We presented two notions of satisfaction for partial state spaces – a precise but expensive one, and a cheap but imprecise one. We then asked how complex it is to decide whether a given property yields the same satisfaction result, for all par- tial state spaces, in both notions. We showed that this problem is connected to the validity problem of the respective temporal logic but that the actual picture is

more complex. For the propositional modal mu-calculus and propositional modal logic we showed that deciding optimistic and pessimistic self-minimization is at least as hard as the respective validity problems, but that we can show membership of this decision problem only for a complexity class exponentially higher than that. For semantic self-minimization, we could not show a hardness result for any logic considered. For propositional logic we could show that optimistic and pessimistic self-minimization both match the complexity of validity and that the set of formu- las that are neither optimistically nor pessimistically self-minimizing matches the complexity of satisfiability. We also discovered that two sets, for which we had ex- ponential gaps for the propositional modal mu-calculus and for propositional modal logic, are coNP-hard sets in DP in the case of propositional logic.
Acknowledgments
We expressly thank the anonymous referees for their thoughtful comments, which helped to improve the presentation and clarity of this paper. A preliminary version of this paper, with all results reported in this final version, appeared in the workshop proceedings of the Seventh International Workshop on Automated Verification of Critical Systems, held in Oxford, England, from 10-12 September 2007. The work reported here is already published as Chapter 4 of the first author’s PhD thesis [1].

References
A. Antonik. Decision problems for partial specifications: empirical and worst-case complexity. PhD thesis, Imperial College London, Department of Computing, London, United Kingdom, October 2008.
A. Antonik, M. Huth, K. G. Larsen, U. Nyman, and A. Wasowski. 20 Years of Mixed and Modal Specifications. Bulletin of the European Association for Theoretical Computer Science 95:94–129, July 2008.
A. Antonik, M. Huth, K. G. Larsen, U. Nyman, and A. Wasowski. Complexity of decision problems for mixed and modal specifications. In Proc. of the 11th International Conference on Foundations of Software Science and Computation Structures, volume 4962 of Lecture Notes in Computer Science pages 112-126. Springer Verlag, March 2008.
A. Antonik, M. Huth, K. G. Larsen, U. Nyman, and A. Wasowski. EXPTIME-complete Decision Problems for Mixed and Modal Specifications. In Proc. of the 15th International Workshop On Expressiveness in Concurrency (2008), to appear in ENTCS.
A. Antonik and M. Huth. Efficient Patterns for Model Checking Partial State Spaces in CTL & LTL.
ENTCS 158:41–57, Elsevier and Science Direct, 2006.
S. Blamey. Partial-Valued Logic. PhD thesis, University of Oxford, Oxford, England, 1980.
G. Bruns and P. Godefroid. Model Checking Partial State Spaces with 3-Valued Temporal Logics. In Proc. of the 11th Conference on Computer Aided Verification, volume 1633 of Lecture Notes in Computer Science, pages 274–287. Springer Verlag, July 1999.
G. Bruns and P. Godefroid. Generalized Model Checking: Reasoning about Partial State Spaces. In Proc. of the 11th International Conference on Concurrency Theory, volume 1877 of Lecture Notes in Computer Science, pages 168–182. Springer Verlag, August 2000.
D. Dams. Abstract interpretation and partition refinement for model checking. PhD thesis, Technische Universiteit Eindhoven, The Netherlands, 1996.
D. Dams, R. Gerth, and O. Grumberg. Abstract interpretation of reactive systems. ACM TOPLAS, 19:253–291, 1997.
M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns in Property Specifications for Finite-state Verification. In Proc. of the 1999 International Conference on Software Engineering, pages 411-420, IEEE Computer Society Press, May 1999.


P. Godefroid and M. Huth. Model Checking Vs. Generalized Model Checking: Semantic Minimizations for Temporal Logics. In Proc. of LICS’05, pages 158–167, Chicago, Illinois, 26-29 June 2005. IEEE Computer Society Press.
M. Huth, R. Jagadeesan, and D. A. Schmidt. Modal transition systems: a foundation for three-valued program analysis. In D. Sands, editor, Proc. of the 10th European Symposium on Programming, pages 155–169. Springer Verlag, April 2001.
S. C. Kleene. Introduction to Metamathematics. Van Nostrand, 1952.
D. Kozen. Results on the propositional mu-calculus. Theoretical Computer Science, 27:333–354, 1983.
O. Kupferman and M. Y. Vardi. Vacuity Detection in Temporal Model Checking. In Proc. of the 10th IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification, volume 1703 of Lecture Notes in Computer Science, pages 82–96, Springer Verlag, 1999.
K. G. Larsen and B. Thomsen. A modal process logic. In Proc. of the 13th Annual Symposium on Logic in Computer Science, pages 203–210, IEEE Computer Society Press, 1989.
C. H. Papadimitriou and M. Yannakakis. The complexity of facets (and some facets of complexity). In Proc. of the fourteenth annual ACM symposium on Theory of Computing, pages 255–260, San Fransisco, California, ACM Press, 1982.
C. H. Papadimitriou and D. Wolfe. The Complexity of Facets Resolved. Journal of Computer and System Sciences 37:2–13 (1998).
T. Reps, A. Loginov, and M. Sagiv. Semantic Minimization of 3-Valued Propositional Formulae. In Proc. of the 17th Annual IEEE Symposium on Logic in Computer Science, pages 40–51, Copenhagen, Denmark, 22-25 July 2002. IEEE Computer Society Press.
B. van Fraassen. Singular terms, truth-value gaps, and free logic. J. Phil., 63(17):481–495, September 1966.
