Computers & Graphics: X 2 (2019) 100007

		


Technical Section
Clipping simple polygons with degenerate intersections6
Erich L Foster a, Kai Hormannb,∗, Romeo Traian Popa c
a Carnegie Robotics, LLC, 4501 Hatfield Street, Pittsburgh, PA 15201, USA
b Faculty of Informatics, Università della Svizzera italiana, Via Giuseppe Buffi 13, Lugano 6904, Switzerland
c Faculty of Mechanical Engineering and Mechatronics, Politehnica University of Bucharest, Splaiul Independen¸tei 313, Bucures¸ ti 060042, Romania


a r t i c l e	i n f o	a b s t r a c t

	

Article history:
Received 10 April 2019
Revised 29 May 2019
Accepted 3 June 2019
Available online 12 June 2019

MSC:
68U05

Keywords:
Polygon clipping Degenerate intersections
Polygon clipping is a frequent operation in many fields, including computer graphics, CAD, and GIS. Thus, eﬃcient and general polygon clipping algorithms are of great importance. Greiner and Hormann (1998) propose a simple and time-eﬃcient algorithm that can clip arbitrary polygons, including concave and self-intersecting polygons with holes. However, the Greiner–Hormann algorithm does not properly han- dle degenerate intersection cases, without the undesirable need for perturbing vertices. We present an extension of the Greiner–Hormann polygon clipping algorithm that properly deals with such degenerate cases.
© 2019 The Author(s). Published by Elsevier Ltd. This is an open access article under the CC BY-NC-ND license. (http://creativecommons.org/licenses/by-nc-nd/4.0/)





Introduction

Polygon clipping is an indispensable tool in computer graph- ics [2], computer aided design (CAD) [3], geographic information systems (GIS) [4], and computational sciences [5]. Applications such as VLSI circuit design [6] as well as numerical simulations typically require polygon clipping to be done thousands of times, and in GIS the polygons that are to be clipped are generally non- convex, possibly with holes and may have several thousands of vertices [7]. Therefore, eﬃcient and general algorithms for polygon clipping are very important.
Weiler and Atherton [8] were the first to present a clipping al- gorithm for convex and concave polygons with holes. Their idea was developed further by Greiner and Hormann [1], who pro- pose a simple and eﬃcient algorithm that can also deal with self- intersecting polygons, just like Vatti’s algorithm [9], which was the first to handle this most general setting.
The main advantage of the Greiner–Hormann algorithm, as compared to Vatti’s algorithm, lies in its simplicity [10], but there is one serious limitation: degenerate intersections. If a vertex of one polygon lies on an edge or coincides with a vertex of the other polygon, then the algorithm fails. Greiner and Hormann suggest perturbing polygon vertices to deal with degenerate cases, which is suﬃcient in computer graphics, since the result remains visually

6 This article was recommended for publication by L. Barthe.
∗ Corresponding author.
E-mail address: kai.hormann@usi.ch (K. Hormann).
correct as long as the perturbations are smaller than the size of the screen pixels. However, in most other applications the inaccuracy caused by the perturbation is undesirable.
Kim and Kim [3] present an extension of the Greiner–Hormann algorithm that deals with these degenerate cases without the need for perturbing polygon vertices. However, the method requires cal- culating the inside/outside status of the midpoints of all edges ad- jacent to an intersection, inducing a considerable additional com- putational cost. In the sections that follow we present an alter- native approach for dealing with degeneracies that avoids these costly computations. Another, albeit less eﬃcient method that can handle these cases is the flooding-based clipping algorithm by Wang and Manocha [11].
We start by briefly summarizing the problem (Section 2) and the original Greiner–Hormann algorithm, including its failure cases (Section 3), before presenting the proposed extensions (Section 4). In particular, the detection and classification of all possible degen- erate intersections (Section 4.1) and the labelling of intersections (Section 4.2) are discussed in detail. After presenting a number of examples (Section 5), we conclude the paper with a discussion of our algorithm’s advantages and limitations (Section 6).
Polygon clipping

Let  us  begin  by  formally  defining  the  clipping  problem. A planar polygon P = [P1, P2, . . . , Pn] with n ≥ 3 vertices Pi ∈ R2 is defined as the piecewise linear, closed path that is formed by joining the edges [P1, P2], [P2, P3], . . . , [Pn−1, Pn], [Pn, P1] that consecutively connect the vertices Pi  in the given order


https://doi.org/10.1016/j.cagx.2019.100007
2590-1486/© 2019 The Author(s). Published by Elsevier Ltd. This is an open access article under the CC BY-NC-ND license. (http://creativecommons.org/licenses/by-nc-nd/4.0/)


			
a	b	c	d
Fig. 1. Examples of a single simple polygon (a), a simple complex polygon with three components and one hole (b), a single self-intersecting polygon (c), and a complex self-intersecting polygon with three components (d), with their interiors shaded.










a	b	c
Fig. 2. Example of polygon clipping: the intersection of a simple polygon P with three components and one hole (a) and a self-intersecting polygon Q with one component
(b) gives a result polygon R with two components, one of them simple, the other self-intersecting (c).

a	b	c
Fig. 3. For two given polygons P and Q (a), the Greiner–Hormann algorithm first computes all intersection points (), then marks them as entry () or exit () points for both polygons (b), and finally generates the result polygon R (c).


(see Fig. 1a,c). A complex polygon P = {P1 , P2 , . . . , Pm} is a set of m ≥ 1 polygons Pj , called the components of P (see Fig. 1b,d). We follow the convention that the interior of P is determined by the even-odd rule [2] and consists of all points p ∈ R2 which do not lie on any of the edges of P and for which a ray drawn from p to infinity in any direction crosses P an odd number of times. Be- cause of this definition, components that are inside other compo- nents are commonly referred to as holes (see Fig. 1b). For the sake of brevity, we consider single polygons as complex polygons with one component and refer to complex polygons simply as polygons. A polygon is called simple if it does not cross itself, that is, its edges intersect only at common endpoints, which in turn is equivalent to the property that its half-open edges do not intersect at all. Each component of a simple polygon is thus topologically equivalent to a circle (see Fig. 1a,b).
Polygon clipping usually refers to computing the intersection P ∩ Q of the interiors of two polygons P and Q, often called the clip and the subject polygon, which is itself a region bounded by a polygon R (see Fig. 2). Most clipping algorithms can be modified to also compute other polygon set operations, like the union P ∪ Q
and the differences P \ Q and Q \ P. Especially in computer graph-
ics, polygon clipping may also refer more specifically to the process of fragmenting the subject polygon into those parts that lie inside the clip polygon and those that lie outside the clip polygon [12]. However, we follow the more common convention that clipping P
and Q yields P ∩ Q and note that the result is symmetric with re- spect to P and Q.

Greiner–Hormann algorithm

The Greiner–Hormann polygon clipping algorithm [1] consists of three phases. The intersection phase computes all intersections points between P and Q and inserts them as new vertices into both polygons. In Fig. 3, there are eight such intersection points I1 , ... , I8 , and the algorithm adds, for example, I1 as a new vertex of P between P1 and P2 and I1 , I6 , I8 , and I3 in this order as new vertices of Q between Q3 and Q4. Greiner and Hormann propose to represent all polygon components with circular doubly-linked lists to facilitate the vertex insertion operation and to link corre- sponding pairs of intersection vertices using additional neighbour pointers that are needed in the third phase (see Fig. 4).
The labelling phase marks each intersection vertex I of P as en- try or exit point, depending on whether someone travelling along P in the given order enters or leaves the interior of Q at I, and similarly for the intersection vertices of Q. To this end, the algo- rithm starts for each component P of P at the first vertex P of P, determines whether P lies inside or outside Q [13], and then tra- verses all vertices of P in the given order, labelling the intersection vertices alternately as entry or exit. For the example in Fig. 3, the first vertex P1 of the first component of P is identified as lying




Fig. 4. The Greiner–Hormann algorithm uses doubly-linked lists to represent polygon components. After inserting and labelling the intersection vertices (cf. Fig. 3b), each component R of R is traced out by starting at an intersection vertex on P (shaded), moving along P in the correct order, switching over to Q at the next intersection vertex, and repeating this process until R is closed. The switching step requires linking corresponding intersection vertices of P and Q with neighbour pointers (dashed).

a	b	c
Fig. 5. The Greiner–Hormann algorithm cannot deal with degenerate intersections like the one at P3 (a), and while perturbing the vertex helps to overcome this limitation, different perturbation directions may lead to geometrically and topologically different results (b, c).


inside Q, so that the next intersection vertex along this compo- nent, I1, is marked as exit, the second next, I2, as entry, and so on. For the second component of P, its first vertex P6 is found to lie outside Q, hence I5 gets an entry and I6 an exit label, etc. For Q, the algorithm determines that Q1 lies outside P and then marks I2, this time as a vertex of Q, as entry, then I7 as exit, and so forth.
The tracing phase finally generates all components of the re- sult polygon R. Starting at an intersection vertex I of P, the al- gorithm moves along the corresponding component of P either in the forward or backward direction, depending on whether the la- bel of I is entry or exit, respectively, until the next intersection vertex is encountered. Using the neighbour pointer, the algorithm then switches to the corresponding intersection vertex of Q and repeats this process until it returns to I. All vertices visited this way and in this order constitute one component of R, and the algorithm continues generating components until all intersection vertices have been visited. For the example in Fig. 3, the tracing of the first component starts at I1. Since I1 is marked as an exit point, we traverse P backward, encountering first P1 and then I4, where we switch over to Q. As a vertex of Q, the label of I4 is exit, hence we proceed backwards to I5 and switch back to P. Observing that I5 on P is an entry point, we advance forward to I6, and after switching, moving along Q to I1, and switching back, we arrive at the initial vertex I1 on P. This completes the tracing of the first component R1 of R with vertices R1 = I1 , R2 = P1 , R3 = I4 , R4 = I5 , R5 = I6 (see Figs. 3c and 4). After generating the second component R2 = [R6 , R7 , R8 , R9 ] = [I2 , I3 , I8 , I7 ] in the same way with I2 on P as the initial vertex, all intersection vertices have been visited and the algorithm terminates.

Degeneracies

Despite its favourable simplicity, a serious limitation of the Greiner–Hormann algorithm is that it cannot deal with degenerate intersections, that is, if a vertex of P lies on an edge or coincides with a vertex of Q or vice versa. For example, if P3 in Fig. 5a is detected as an intersection and hence inserted as an intersection vertex into both P and Q, then the result will be incorrect, be- cause the strategy of labelling intersection vertices alternately as entry and exit gives wrong labels in this case. While the problem may be fixed by slightly perturbing any such degenerate intersec-
tion vertices, the method of perturbation can result in different so- lutions depending upon the perturbation direction. In the previous example, moving P3 slightly towards the interior of Q gives a result polygon with five vertices (see Fig. 5b), and any perturbation in the opposite direction produces an intersection polygon with two triangular components (see Fig. 5c). This renders the perturbation method indeterminate and not appropriate for various applications, such as numerical simulation [5].
Extension of the Greiner–Hormann algorithm

Inspired by the work of Kim and Kim [3], we figured out that the aforementioned limitation of the Greiner–Hormann algorithm can be overcome with rather small changes that do not affect the simplicity of the algorithm. In fact, our extension mainly requires a more refined analysis of the intersection vertices in the labelling phase of the algorithm, provided that degenerate intersections are detected and handled correctly in the intersection phase. Our re- vised labelling strategy uses local orientation tests to identify and mark a subset of all intersection vertices as crossing intersections. These are then labelled alternately as entry and exit points exactly as in the original Greiner–Hormann algorithm, and also the tracing phase of the algorithm remains basically the same.
Intersection phase

The first phase of our algorithm is essentially the same as in the Greiner–Hormann algorithm as it finds all intersection points of P and Q, but we must deal with degenerate intersections ap- propriately. To this end, we test the half-open edges of P against the half-open edges of Q for potential intersections, so as to avoid detecting a possible intersection at a vertex twice. Without loss of generalization, let us consider the half-open edges [P1 , P2 ) and [Q1 , Q2) and distinguish two cases.
If both edges are not parallel, then there exists a unique inter- section point of the two lines defined by both edges,
I = (1 − α)P1 + αP2 = (1 − β)Q1 + βQ2,  α, β ∈ R,
and the edges themselves intersect at I, if and only if 0 ≤ α, β < 1. The parameters α and β describe the relative position of I between P1 and P2 and between Q1 and Q2 , respectively. They can be deter- mined as


			
a	b	c	d
Fig. 6. Possible intersection types for two non-parallel edges [P1 , P2 ) and [Q1 , Q2 ): X-intersection (a), T-intersection (b, c), and V-intersection (d). Note that P2 and Q2 are depicted by empty circles to emphasize that we are considering half-open edges.





a	b	c
Fig. 7. Possible overlap types for two collinear edges [P1 , P2 ) and [Q1 , Q2 ): X-overlap (a), T-overlap (b, c), and V-overlap (d).


α = 	 A(P1, Q1, Q2 )	 ,
A(P1, Q1, Q2 ) − A(P2, Q1, Q2 )
β = 	 A(Q1, P1, P2 )	 ,	(1)
A(Q , P , P ) − A(Q , P , P )
T-overlap: if α < 0 or α ≥ 1, and 0 < β < 1, then we add a copy of P1 to Q, linked with P1 . Likewise, a copy of Q1 , linked with Q1, is added to P, if β < 0 or β ≥ 1, and 0 < α < 1.
V-overlap: if α = β = 0, then P1 = Q1 , and we link P1 with Q1 .

where
1  1  2
2  1  2
Again, we do not consider overlap cases involving P2 or Q2, for

A(P, Q, R) = (Qx − Px )(Ry − Py ) − (Qy − Py )(Rx − Px ),
is the function that computes twice the signed area of the triangle [P, Q, R]. Note that the denominators in (1) do not vanish as long as [P1 , P2 ) and [Q1 , Q2 ) are not parallel. We classify the possible intersection types as shown in Fig. 6:
X-intersection: this non-degenerate intersection occurs if and only if 0 < α, β < 1. In this case, we add I to P and Q and link the two copies with the neighbour pointer as described in [1].
T-intersection: if α = 0 and 0 < β < 1, then P1 lies on the edge [Q1 , Q2 ], but does not coincide with Q1 or Q2 . In this case, we add a copy of P1 to Q and link it with P1. Likewise, a copy of Q1 is added to P and linked with Q1, if β = 0 and 0 < α < 1.
V-intersection: if α = β = 0, then both edges intersect at P1 =
Q1 , and we link P1 with Q1 .
We do not consider degenerate intersection cases involving P2, because they will be detected as soon as we move on to the next edge [P2, P3) of P, and the same holds for degenerate cases involv- ing Q2 .
If both edges are parallel, then they can intersect or rather over-
lap only if they are collinear, that is, if
A(P1, Q1, Q2 ) = A(P2, Q1, Q2 ) = A(Q1, P1, P2 ) = A(Q2, P1, P2 ) = 0.
Under this assumption, we can express Q1 relative to [P1 , P2 ) and
P1 relative to [Q1 , Q2 ) as
Q1 = (1 − α)P1 + αP2,   P1 = (1 − β)Q1 + βQ2,
and the parameters α and β can be determined as
the same reasons as above.
After executing the first phase of our algorithm, it is guaranteed that all intersections of P and Q occur at common intersection ver- tices, which are linked by neighbour pointers, or along common segments, which are now represented as common edges in both P and Q with common intersection vertices as endpoints. Fig. 8 shows an example.

Labelling phase

As in the Greiner–Hormann algorithm, the goal of the second phase is to mark the previously found intersection vertices as en- try or exit points. If all intersections of P and Q are assumed to be non-degenerate X-intersections, then marking these vertices is sim- ple, because an entry intersection vertex is always followed by an exit intersection vertex and vice versa (see Section 3). Degenerate intersections, however, require a more careful investigation of the local situation around each intersection vertex.
To this end, let us first recall that a point Q lies to the left of the edge [P1 , P2 ] if A(Q, P1 , P2 ) > 0 and to the right if A(Q, P1 , P2 ) < 0. If we now consider two adjacent edges [P1 , P2 ] and [P2 , P3 ], then we can determine whether Q lies to the left or to the right of the polygonal chain (P1 , P2 , P3 ) by computing
s1 = A(Q, P1, P2 ), s2 = A(Q, P2, P3 ),  s3 = A(P1, P2, P3 )
and distinguishing three cases as shown in Fig. 9:
Left turn: if s3 > 0, then the chain takes a left turn at P2 and

(Q − P , P − P ⟩
(P − Q , Q
— Q ⟩
Q lies to the left of (P1 , P2 , P3 ) if s1 > 0 and s2 > 0, and to the

α =	1
1  2	1
,	β =	1
1	2	1  ,
right if s1 < 0 or s2 < 0.

(P2 − P1, P2 − P1⟩
(Q2 − Q1, Q2 − Q1⟩
Straight: if s3 = 0, then sign(s1 ) =sign(s2 ) and Q lies to the left

where ( · , · ⟩ denotes the standard dot product in R2. We clas- sify the possible overlap types in analogy to the intersection types above and as shown in Fig. 7:
X-overlap: this type of overlap occurs if and only if 0 < α, β < 1. In this case, we add a copy of P1 to Q, linked with P1, and a copy of Q1 to P, linked with Q1 .
of (P1 , P2 , P3 ) if s1 > 0 and to the right if s1 < 0.
Right turn: if s3 < 0, then the chain takes a right turn at P2 and Q lies to the left of (P1 , P2 , P3 ) if s1 > 0 or s2 > 0, and to the right if s1 < 0 and s2 < 0.
Clearly, the case of a straight polygonal chain can be included in either of the other two cases, for the sake of simplifying the code.


	
a	b
Fig. 8. Example of two polygons before (a) and after (b) executing the intersection phase. Note that we renumber the vertices of both polygons in (b) to simplify the notation. The algorithm detects nine common intersection vertices () and the two common segments of P and Q are now represented as edges [P2 , P3 ] = [Q5 , Q6 ] and [P8 , P9 ] = [Q12 , Q13 ].

a	b	c
Fig. 9. Regions to the left (light grey) and to the right (dark grey) of the polygonal chain (P1 , P2 , P3 ) for the three possible cases: left turn (a), straight (b), and right turn (c).

a	b	c
Fig. 10. Possible local configurations without overlaps around an intersection vertex I after the first phase: crossing (a) and bouncing (b, c).


Now let I be an intersection vertex of P, preceded by P− and succeeded by P+. As a consequence of the first phase, I is also a vertex of Q with neighbours Q− and Q+. We then distinguish two possible cases.
If the four edges adjacent to I do not overlap, then the local behaviour of P with respect to Q at I can be classified as shown in Fig. 10:
Crossing: if Q− and Q+ lie on different sides of (P−, I, P+ ), then
P crosses Q at I, and we mark I as crossing.
Bouncing: if Q− and Q+ lie on the same side of (P−, I, P+ ), then
P does not cross Q at I, and we mark I as bouncing.

For the example in Fig. 8b, this classification scheme marks P7, P13 , P14 as crossing and P5 , P11 as bouncing (see Fig. 12a).
The situation is slightly more complicated, if I is the endpoint of
a common segment. If the edge [I, P+] of P overlaps with Q, then it is either equal to [Q−, I] or [I, Q+], because all common segments are represented as common edges after phase one. Therefore, this situation can be detected by checking if P+ is itself an intersection vertex and linked to either Q− or Q+, and a similar test reveals if the edge [P−, I] of P overlaps with Q. With these considerations in mind, we can distinguish the five cases shown in Fig. 11 for de- scribing the local position of P around I relative to Q:

Left/On: if P+ is linked to Q+ (or Q−) and Q− (or Q+) lies to the right of (P−, I, P+ ), then P changes from being left of Q to being on Q at I.
Right/On: if P+ is linked to Q+ (or Q−) and Q− (or Q+) lies to the left of (P−, I, P+ ), then P changes from being right of Q to being on Q at I.
On/On: if P+ is linked to Q+ (or Q−) and P− is linked to Q− (or
Q+), then P is on Q to both sides of I.
On/Left: if P− is linked to Q− (or Q+) and Q+ (or Q−) lies to the right of (P−, I, P+ ), then P changes from being on Q to being left of Q at I.
On/Right: if P− is linked to Q− (or Q+) and Q+ (or Q−) lies to the left of (P−, I, P+ ), then P changes from being on Q to being right of Q at I.
After this analysis, all intersection vertices of P with adja- cent overlapping edges form polygonal intersection chains I = (I1 , I2 , . . . , Ik ) with k > 1, where I1 is marked as x/on, I2 , . . . , Ik−1 are marked as on/on, and Ik is marked as on/y with x, y ∈ {left, right}. Each polygonal intersection chain I can then be classified as fol- lows:
Delayed crossing: if x /= y, then P crosses Q at I. In this case, we mark the intersection vertices I1 , . . . , Ik−1 as bouncing and Ik as crossing.
Delayed bouncing: if x = y, then P does not cross Q at I, and
we mark all intersection vertices I1, . . . , Ik as bouncing.
Note that in the case of a delayed crossing we could actually mark any intersection vertex in I as crossing, as long as all other vertices in I are marked as bouncing. For the example in Fig. 8, the strategy above identifies a delayed crossing at (P8, P9) and a de-


    
a	b	c	d	e
Fig. 11. Possible local configurations with overlaps around an intersection vertex I of P with respect to Q after phase one: left/on (a) right/on (b), on/on (c), on/left (d), on/right
(e).

a	b
Fig. 12. Example from Fig. 8 after the second phase (a). The algorithm marks the intersection vertices as crossing () or bouncing () and labels the crossing vertices as
entry () and exit () points for both polygons. The third phase of the algorithm finally creates the intersection polygon (b).

a	b	c	d
Fig. 13. Examples of some special cases. If a polygon component consists of intersection vertices only after phase one (a), then we add the midpoint of the first non- overlapping edge to the polygon, because the entry/exit-classification in phase two requires an initial non-intersection vertex. For the two polygons in (a), the result has one non-simple component R = [R1 , ... , R9 ] (b). If some polygon component does not contain any crossing vertices after the labelling phase, then it either does not intersect the other polygon (c), or it contains or is contained in a component of the other polygon (d), and then the interior component is added to R.


layed bouncing at (P2 , P3 ), and consequently marks P9 as crossing
and P2 , P3 , P8 as bouncing (see Fig. 12a).
Once the intersection vertices of P have been marked as cross- ing or bouncing, we can simply copy these labels to the intersec- tion vertices of Q, because Q crosses P at an intersection vertex I if and only if P crosses Q at I.
The labelling of crossing vertices is finally done as described in Section 3 by tracing all components of both polygons P and Q once and marking entry and exit points with respect to the other polygon’s interior. For the example in Fig. 8, this algorithms marks the vertices P7 , P13 , Q2 , Q9 as entry points and the vertices P9 , P14 ,
Q7 , Q12 as exit points (see Fig. 12a).
Note that the final labelling stage requires at least one vertex of each polygon component to be non-intersecting, so that the in- side/outside test can be executed unambiguously, which may not be the case in some special situations like the one in Fig. 13a. To explain how to overcome this problem, let us assume that some component P of P consists entirely of intersection vertices after executing the first phase of our algorithm and distinguish two cases. If all edges of P represent common segments, then P and some component Q of Q enclose the same region and we can sim- ply add P = Q as a component of the intersection polygon R, if and only if either both components are holes or if both are not holes. Otherwise, at least one of the intersection vertices of P is not an on/on vertex and thus adjacent to an edge, say [Pi, Pi+1 ],
that does not overlap with Q. Hence, we can add the midpoint
P = (Pi + Pi+1 )/2 as temporary vertex to P and use it as the initial non-intersection vertex for the entry/exit-classification.

Tracing phase

The third phase of the algorithm for creating the intersection polygon R remains largely unchanged from the original Greiner– Hormann algorithm and is described in Section 3. The only dif- ference is that the generation of each result component starts at a crossing intersection vertex I of P and that we traverse P as usual, forward if I is an entry point and backward otherwise, but this time until we reach a vertex of P with opposite entry/exit flag, and likewise after switching over to Q. In the absence of degener- ate intersections, this is equivalent to proceeding to the next inter- section vertex, but in general we may pass one or more bouncing intersection vertices before switching polygons. For the example in Fig. 12b, we thus start at P7, traverse P forward until we get to P9 = Q12 , then backward along Q up to Q9 = P13 , and so on.
If some component P of P does not contain any crossing inter- section vertex, then we have encountered one of the special cases shown in Fig. 13c and 13d, which can be dealt with as follows. Let P be a non-intersection vertex of P or the midpoint of an edge that does not overlap with Q. If and only if P lies inside Q, then so does the entire component P and we add it as a component of R in this case. The same strategy is applied to all components of Q that do not contain any crossing intersection vertex, and by ex-


			
a	b	c	d
Fig. 14. Example of two polygons (a), for which the algorithm without vertex splitting generates a degenerate result with one component R1 = [R1 , . . . , R7 ] that contains a duplicate vertex R2 = R6 (b). After splitting the vertex pair (P, Q) = (P3 , Q2 ), setting the entry/exit flags, and linking the new vertices Pr and Qr (c), the third phase of the algorithm generates the correct result with two simple components R1 = [R1 , R2 , R3 ] and R2 = [R4 , R5 , R6 , R7 ] (d).


amining all possible cases, it is clear that this procedure gives the correct result, even in the case of nested holes.

Improvements and generalizations

In contrast to the Greiner–Hormann algorithm and as a conse- quence of the way we handle degenerate intersections, the result generated by the algorithm above may contain three kinds of de- generacies, which are not incorrect per se, but should be resolved in order to make the result as simple as possible.
First, there can be chains of three or more successive, collinear vertices, and all but the first and last vertices of such a chain can be omitted without modifying the correctness of the result. An ex- ample is the intersection polygon in Fig. 12b, where the vertices
R3 , R9 , and R11 should be removed. In general, the vertex R should be removed, if and only if A(R—, R, R+ ) = 0, and this can be done
in a post-processing step that visits each vertex of the result once. Second, it may happen that a vertex appears twice in the result polygon, as shown in Fig. 14b. The polygon should then be split into two parts at such vertex, so as to make all components of R simple. Notice that this situation can only occur at a bouncing in- tersection vertex for which the adjacent edges of P lie inside Q and vice versa. In order to detect these cases, we extend the final labelling stage of the second phase to mark all bouncing vertices that lie between an entry and an exit point as split candidates. For the example in Fig. 14a, the split candidates are the bounc- ing vertices P3 , P4 , Q2 , and Q3 , but not P6 , P9 , Q5 , and Q8 . After the labelling, we loop through the split candidates of P and if we encounter a candidate P, whose neighbour Q has been marked as a split candidate for Q, we prepare the split of this vertex pair (P, Q). To this end, we insert a copy Pr of P after P into P and likewise for Q, as shown in Fig. 14c. We then label P and Q as exit and Pr and Qr as entry points and mark all four vertices as crossing, so that they can serve as initial vertices for generating the intersec- tion polygons in the third phase. Finally, we need to link them in the correct way. If the local orientation of P at P and Q at Q is
different, that is,
sign(A(P—, P, P+ )) /= sign(A(Q—, Q, Q+ )),
as in the example in Fig. 14c, then we keep the link between P and Q and link Pr with Qr. Otherwise, we link P with Qr and Q with Pr. Third, the result may contain “glued” edges, like [R3, R4] and [R8 , R9 ] in Fig. 13b or [R1 , R2 ] and [R6 , R1 ] in Fig. 16b, which bound an area with no interior and should therefore be removed. While this can also be done in a post-processing step, it is prefer- able to avoid them upfront. Indeed, we achieve this by two mi-
nor modifications of the labelling strategy in the second phase of our algorithm, which are inspired and adapted from the obser- vations in [14]. On the one hand, when classifying the intersec- tion chain I = (I1 , I2 , . . . , Ik ), we mark I1 and Ik as endpoints of a delayed crossing or delayed bouncing and the intersection vertices I2 , . . . , Ik—1 as bouncing. On the other hand, when tracing P and Q for setting the entry/exit flags, we mark the endpoints of a de- layed bouncing in the same way as regular crossing intersection vertices, while the endpoints of a delayed crossing are marked ei- ther both as entry or both as exit points. In addition, we mark the first vertex of an exiting delayed crossing and the last vertex of an entering delayed crossing as crossing. In case of a delayed bounc- ing, we mark both endpoints as crossing, if and only if the adja- cent edges of P lie inside Q and vice versa. Similar to the vertex splitting above, this requires identifying crossing candidates during the traversal and marking matching candidates afterwards. Since the traversal starts at a non-intersection vertex and thus never at an interior vertex of an intersection chain, the two endpoints of an intersection chain are always visited in pairs and it is easy to distinguish the first endpoint from the last.
As the examples in Figs. 15 and 16c show, this improved la- belling strategy is able to remove glued edges effectively, and an exhaustive examination of all possible combinations of clockwise- or counterclockwise oriented components of P and Q, of enter- ing or exiting delayed crossings, as well as interior or exterior de- layed bouncings, reveals that this strategy handles all cases cor- rectly; see [14] for details.
We finally note that, just like the original Greiner–Hormann al- gorithm [1], our extended version can also compute the union of P and Q after some minor modifications. The key change is to re- verse the traversal directions during the tracing phase and to travel forward from exit to entry points along the polygons and back- ward from entry to exit points. Moreover, entire components must be added to R if they lie outside instead of inside the other poly- gon, and the rules for splitting vertices and the labelling of end- points of delayed crossing and delayed bouncings must be reversed.
Similar changes can be made for determining the differences P \ Q
and Q \ P.


Examples

We implemented the algorithm in C++ and tested it exten- sively for various input polygons. The code and all examples are
available on the second author’s webpage at https://www.inf.usi. ch/hormann/polyclip/.


		
a	b	c
Fig. 15. For the example from Fig. 13a, the improved labelling strategy sets the entry/exit flags not only for crossing vertices, but for all endpoints of intersection chains, both for P (a) and for Q (b), so that the third phase of the algorithm generates a result polygon with two components R1 = [R1 , R2 , R3 ] and R2 = [R4 , R5 , R6 ] (c).

a	b	c
Fig. 16. Example of two polygons (a), for which the algorithm generates a degenerate result with glued edges [R1 , R2 ] and [R6 , R1 ] (b). Both get removed with the improved labelling strategy (c).

a	b	c
Fig. 17. The intersection of a closed fifth-order Hilbert curve (a) with a rotated copy of itself (b), aligned at the top right, gives 116 simple polygons (c).















a	b	c
Fig. 18. The algorithm also handles complex input polygons with multiple and nested components (a,b) and computes the intersection correctly (c).


The first example in Fig. 17 is a real stress test for degenerate intersections, as both input polygons, with 820 vertices each, in- terpolate all nodes of a regular 32 × 32 grid. The first phase of the algorithm finds 14 non-degenerate and 1010 degenerate intersec- tions (176 T- and 432 V-intersections, as well as 208 T- and 194 V-overlaps) and adds 206 vertices to both polygons. The second phase detects 42 bouncing intersection vertices and 396 delayed crossings, and splits 21 bouncing vertex pairs. The third phase cre- ates 116 simple polygons with 804 vertices, and 164 of these are removed by the post-processing step that eliminates collinear ver- tices.
The second example in Fig. 18 illustrates that the algorithm also handles complex input polygons with multiple and nested compo- nents, with the interior defined by the even-odd rule [2]. There are 46 non-degenerate and 21 degenerate intersections in this exam-
ple, with the latter corresponding to 4 bouncing intersection ver- tices, 2 delayed crossings, and 5 delayed bounces. No bouncing ver- tex pairs need to be split, and after removing 3 collinear vertices, the result consists of 14 simple polygons with 64 vertices.
The last two examples testify to the need of being able to han- dle degenerate cases in real-world applications. In Fig. 19 we show the polygons representing the boundaries of a canton (5 compo- nents, 1322 vertices) and a nature park (1 component, 2602 ver- tices) in Switzerland. The close-ups zoom to the crossing and the delayed crossing (right) found by the algorithm. Comparing the area of the intersection result (1240 vertices) with the area of the nature park reveals that 46.6% of the park belong to this canton.
In the final example in Fig. 20, we consider polygons represent- ing US school districts in the Albuquerque region, ranked by school rating. We first compute the union of the polygons for the 5 best-


		

Fig. 19. Intersection (shaded) of the boundary of the Regional Nature Park Gruyère Pays-d’Enhaut (dashed lines and dotted vertices) with the boundary of the Canton of Fribourg (solid lines and circled vertices), with close-ups to the regions where both boundaries intersect. (Data used in this example is from www.openstreetmap.org, made available under the Open Database License (ODbL).)

a	b	c	d
Fig. 20. To find the common region of five elementary school districts (a), three middle school districts (b), and two high-school districts (c), we first compute their respective unions and finally their intersection (d).


ranked elementary schools (which requires to run the algorithm four times, adding one polygon at each run) and likewise for the 3 best-ranked middle schools and the 2 best-ranked high schools, resulting in the polygons E, M, and H. We then compute the in- tersection of E with M and further intersect the result with H. This finally gives the shaded polygon in Fig. 20d, which represents the neighbourhood with access to top schools on all three levels of schooling.

Discussion and conclusions

Clipping planar polygons is central to several fields, and the need for a general algorithm capable of clipping convex and con- cave polygons with multiple components and holes was pointed out by Weiler and Atherton [8]. Their algorithm was the first to have this feature, and is akin to our work in that it consists of an intersection and a tracing phase that are basically the same as ours. The Weiler–Atherton algorithm gets by without a labelling phase, since it assumes the vertices of all polygon components to be ordered consistently, namely clockwise for exterior boundaries and counter-clockwise for holes. By adding the labelling phase,
Greiner and Hormann [1] manage to avoid this restriction on the vertex order and to generalize the Weiler–Atherton algorithm so that it also handles self-intersecting polygons correctly. However, both algorithms cannot deal with degenerate intersection cases, which is a severe limitation in many applications.
Weiler’s polygon comparison algorithm [12] overcomes this drawback, albeit at the expense of using a more complicated graph data structure. Instead, we show that degenerate intersection cases can also be dealt with effectively by carefully refining the labelling phase of the Greiner–Hormann algorithm. Our new labelling phase (Sections 4.2 and 4.4) is eﬃcient, since it relies on strictly local operations and on detecting and distinguishing a small number of cases. In fact, the running time of this phase is O(k), where k is the number of intersections between P and Q, and according to our experience it takes only about twice as long as the orig- inal labelling phase of the Greiner–Hormann algorithm. The only global information needed for labelling all entry/exit flags cor- rectly at the end of this phase is the inside/outside test that is applied to one non-intersection vertex for each polygon compo- nent and typically requires O(n) operations, where n is the number of vertices of the other polygon. Note that the algorithm of Kim


			
a	b	c	d
Fig. 21. Our algorithms handles self-intersecting polygons correctly, as long as the self-intersection does not lie on the other polygon (a), but may fail otherwise (b, c, d).


and Kim [3], which also extends the Greiner–Hormann algorithm to handle degenerate intersections, requires carrying out two in- side/outside tests for each intersection vertex or intersection chain, resulting in an inferior O(kn) time complexity.
Overall, our algorithm is only marginally slower than the origi- nal Greiner–Hormann algorithm, because the running time is dom- inated by the intersection phase, which usually takes more than 80% of the time, so that the small overhead induced by the new labelling phase is negligible. As proposed by Greiner and Hor- mann [1], we adopt the brute force approach for the intersection phase and find the k intersections of P and Q by simply testing all n edges of P against all m edges of Q, which obviously requires O(nm) operations, and is the best one can do in the worst case, when k ∈ O(nm). However, if the number of intersections is small, then it is more eﬃcient to compute them with a plane sweep ap-
proach in O((n + m + k) log(n + m)) time [15]. The latter is done
by Vatti’s algorithm [9], the algorithm of Martínez et al. [16], and its successor [17], which are also able to deal with degenerate in- tersections and are reportedly faster than the Greiner–Hormann al- gorithm if k ∈ O(n + m) [16,17].
Our experiments confirmed these timings, and also those in [1], which show that both the Greiner–Hormann and our algorithm outperform the plane-sweep-based approaches for completely ran- dom polygons with many self-intersections, simply because the latter do not have to be computed. Moreover, our algorithm is the fastest in case of moderately sized polygons (mn ≤ 1 000 000, k ≤ 10 000), most probably because of the extremely eﬃcient la- belling and tracing phases, which both take less than 1 ms in this case. It is very likely that the algorithm can further be sped up by employing the plane sweep approach in the intersection phase, but it remains future work to verify this conjecture. Further improve- ment, also in terms of memory eﬃciency, is probably possible by adapting the idea of Liu et al. [4], who suggest to maintain a single doubly-linked list of intersections, instead of inserting them into P and Q.
The only limitation of our algorithm are degenerate intersec- tions involving self-intersection points. In fact, if a self-intersection of one polygon lies on an edge or coincides with a vertex of the other polygon, then the algorithm may fail (see Fig. 21). However, this problem can be avoided by resolving self-intersections in a preprocessing step, for example by splitting P in Fig. 21 into two triangles.
It remains future work to find a more elegant solution to the aforementioned limitation and to extend the ideas presented in this paper to the 3D setting, so that they can be used for Boolean
operations in solid modeling, model repair, and other geometry processing applications [11].

Declaration of competing interest

The authors declare that they have no known competing finan- cial interests or personal relationships that could have appeared to influence the work reported in this paper.

Supplementary material

Supplementary material associated with this article can be found, in the online version, at doi:10.1016/j.cagx.2019.100007
References

Greiner G, Hormann K. Eﬃcient clipping of arbitrary polygons. ACM Trans Graph 1998;17(2):71–83.
Foley JD, van Dam A, Feiner SK, Hughes JF. Computer Graphics: Principles and Practice. Addison-Wesley Systems Programming Series. 2nd. Reading: Addis- on-Wesley; 1990.
Kim DH, Kim M-J. An extension of polygon clipping to resolve degenerate cases. Comput-Aided Des Appl 2006;3(1–4):447–56.
Liu YK, Wang XQ, Bao SZ, Gomboši M, Žalik B. An algorithm for polygon clip- ping, and for determining polygon intersections and unions. Comput Geosci 2007;33(5):589–98.
Farrell PE, Piggott MD, Pain CC, Gorman GJ, Wilson CR. Conservative interpola- tion between unstructured meshes via supermesh construction. Comput Meth Appl Mech Eng 2009;198(33–36):2632–42.
Simonson LJ. Industrial strength polygon clipping: a novel algorithm with ap- plications in VLSI CAD. Comput-Aided Des 2010;42(12):1189–96.
Schettino A. Polygon intersections in spherical topology: Applications to plate tectonics. Comput Geosci 1999;25(1):61–9.
Weiler K, Atherton P. Hidden surface removal using polygon area sorting. SIG- GRAPH Comput Graph 1977;11(2):214–22.
Vatti BR. A generic solution to polygon clipping. Commun ACM 1992;35(7):56–63.
Agoston MK. Clipping. In: Computer graphics and geometric modeling: imple- mentation and algorithms. London: Springer; 2005. p. 69–110. 3
Wang CCL, Manocha D. Eﬃcient boundary extraction of BSP solids based on clipping operations. IEEE Trans Vis Comput Graph 2013;19(1):16–29.
Weiler K. Polygon comparison using a graph representation. SIGGRAPH Comput Graph 1980;14(3):10–18.
Hormann K, Agathos A. The point in polygon problem for arbitrary polygons. Comput Geom 2001;20(3):131–44.
Popa RT, Mladin E-C, Petrescu E, Prisecaru T. A simple en,ex marking rule for degenerate intersection points in 2D polygon clipping; 2017. arXiv:1709.00184.
de Berg M, Cheong O, van Kreveld M, Overmars M. Computational geometry: algorithms and applications. 3rd. Berlin: Springer; 2008. p. 19–43. 2
Martínez F, Rueda AJ, Feito FR. A new algorithm for computing Boolean oper- ations on polygons. Comput Geosci 2009;35(6):1177–85.
Martínez F, Ogayar C, Jiménez JR, Rueda AJ. A simple algorithm for Boolean operations on polygons. Adv Eng Softw 2013;64:11–19.
